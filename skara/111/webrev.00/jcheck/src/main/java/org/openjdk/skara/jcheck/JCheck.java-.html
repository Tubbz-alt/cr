<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.jcheck;
 24 
 25 import org.openjdk.skara.census.Census;
 26 import org.openjdk.skara.jcheck.iterators.*;
 27 import org.openjdk.skara.vcs.*;
 28 import org.openjdk.skara.vcs.openjdk.CommitMessageParser;
 29 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
 46     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 47 
 48     private JCheckConfiguration cachedConfiguration = null;
 49 
 50     JCheck(ReadOnlyRepository repository,
 51            Census census,
 52            CommitMessageParser parser,
 53            String revisionRange,
 54            Pattern allowedBranches,
 55            Pattern allowedTags,
 56            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
 57            Set&lt;Hash&gt; blacklist) throws IOException {
 58         this.repository = repository;
 59         this.census = census;
 60         this.parser = parser;
 61         this.revisionRange = revisionRange;
 62         this.whitelist = whitelist;
 63 
 64         var utils = new Utilities();
 65         commitChecks = List.of(
 66             new AuthorCheck(),
 67             new CommitterCheck(census),
 68             new WhitespaceCheck(),
 69             new MergeMessageCheck(),
 70             new HgTagCommitCheck(utils),
 71             new DuplicateIssuesCheck(repository),
 72             new ReviewersCheck(census, utils),
 73             new MessageCheck(utils),
 74             new IssuesCheck(utils),
 75             new ExecutableCheck(),
 76             new BlacklistCheck(blacklist)
 77         );
 78         repositoryChecks = List.of(
 79             new BranchesCheck(allowedBranches),
 80             new TagsCheck(allowedTags)
 81         );
 82     }
 83 
 84     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h) {
 85         try {
 86             var content = r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList());
 87             if (content.size() == 0) {
 88                 return Optional.empty();
 89             }
 90             return Optional.of(JCheckConfiguration.parse(content));
 91         } catch (IOException e) {
 92             throw new UncheckedIOException(e);
 93         }
 94     }
 95 
 96     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
 97         var confPath = Paths.get(&quot;.jcheck/conf&quot;);
 98         var changesConfiguration = c.parentDiffs()
 99                                     .stream()
100                                     .map(Diff::patches)
101                                     .flatMap(List::stream)
102                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||
103                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));
104 
105 
106         if (changesConfiguration || cachedConfiguration == null) {
107             var confAtCommit = parseConfiguration(repository, c.hash());
108             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);
109             return confAtCommit;
110         } else {
111             return Optional.of(cachedConfiguration);
112         }
113     }
114 
115     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
116         log.fine(&quot;Checking: &quot; + commit.hash().hex());
117         var configuration = getConfigurationFor(commit);
118         if (!configuration.isPresent()) {
119             log.finer(&quot;No .jcheck/conf present for &quot; + commit.hash().hex());
120             return Collections.emptyIterator();
121         }
122 
123         var conf = configuration.get();
124         var message = parser.parse(commit);
125         var enabled = conf.checks().enabled(commitChecks);
126         var iterator = new MapIterator&lt;CommitCheck, Iterator&lt;Issue&gt;&gt;(enabled.iterator(), c -&gt; {
127             var skip = whitelist.get(c.name());
128             if (skip != null &amp;&amp; skip.contains(commit.hash())) {
129                 log.finer(&quot;Commit check &#39;&quot; + c.name() + &quot;&#39; is whitelisted for &quot; + commit.hash().hex());
130                 return Collections.emptyIterator();
131             }
132             log.finer(&quot;Running commit check &#39;&quot; + c.name() + &quot;&#39; for &quot; + commit.hash().hex());
133             return c.check(commit, message, conf);
134         });
135         return new FlatMapIterator&lt;Issue&gt;(iterator);
136     }
137 
138     private Set&lt;CommitCheck&gt; checksForCommit(Commit c) {
139         var configuration = getConfigurationFor(c);
140         if (!configuration.isPresent()) {
141             return new HashSet&lt;&gt;();
142         }
143 
144         var conf = configuration.get();
145         return new HashSet&lt;&gt;(conf.checks().enabled(commitChecks));
146     }
147 
148     private Set&lt;Check&gt; checksForCommits() throws IOException {
149         var commits = repository.commits(revisionRange);
150         return commits.stream()
151                 .flatMap(commit -&gt; checksForCommit(commit).stream())
152                 .collect(Collectors.toSet());
153     }
154 
155     public static class Issues implements Iterable&lt;Issue&gt;, AutoCloseable {
156         private final Iterator&lt;Issue&gt; iterator;
157         private final Closeable resource;
158 
159         public Issues(Iterator&lt;Issue&gt; iterator,
160                       Closeable resource) {
161             this.iterator = iterator;
162             this.resource = resource;
163         }
164 
165         @Override
166         public Iterator&lt;Issue&gt; iterator() {
167             return iterator;
168         }
169 
170         public List&lt;Issue&gt; asList() {
171             var res = new ArrayList&lt;Issue&gt;();
172             for (var err : this) {
173                 res.add(err);
174             }
175             return res;
176         }
177 
178         public Stream&lt;Issue&gt; stream() {
179             return StreamSupport.stream(spliterator(), false);
180         }
181 
182         @Override
183         public void close() throws Exception {
184             if (resource != null) {
185                 resource.close();
186             }
187         }
188     }
189 
190     private Iterator&lt;Issue&gt; commitIssues(Commits commits) {
191         return new FlatMapIterator&lt;Issue&gt;(
192                 new MapIterator&lt;Commit, Iterator&lt;Issue&gt;&gt;(commits.iterator(), this::checkCommit));
193     }
194 
195     private Iterator&lt;Issue&gt; repositoryIssues() {
196         var iterator = new MapIterator&lt;RepositoryCheck, Iterator&lt;Issue&gt;&gt;(repositoryChecks.iterator(), c -&gt; {
197             log.finer(&quot;Running repository check &#39;&quot; + c.name() + &quot;&#39;&quot;);
198             return c.check(repository);
199         });
200         return new FlatMapIterator&lt;Issue&gt;(iterator);
201     }
202 
203     private Issues issues() throws IOException {
204         var commits = repository.commits(revisionRange);
205 
206         var repositoryIssues = repositoryIssues();
207         var commitIssues = commitIssues(commits);
208 
209         var errors = new ConcatIterator&lt;Issue&gt;(repositoryIssues, commitIssues);
210         return new Issues(errors, commits);
211     }
212 
213     private static Issues check(ReadOnlyRepository repository,
214                                 Census census,
215                                 CommitMessageParser parser,
216                                 String branchRegex,
217                                 String tagRegex,
218                                 String revisionRange,
219                                 Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
220                                 Set&lt;Hash&gt; blacklist) throws IOException {
221 
222         var defaultBranchRegex = &quot;|&quot; + repository.defaultBranch().name();
223         var allowedBranches = Pattern.compile(&quot;^(?:&quot; + branchRegex + defaultBranchRegex + &quot;)$&quot;);
224 
225         var defaultTag = repository.defaultTag();
226         var defaultTagRegex = defaultTag.isPresent() ? &quot;|&quot; + defaultTag.get().name() : &quot;&quot;;
227         var allowedTags = Pattern.compile(&quot;^(?:&quot; + tagRegex + defaultTagRegex + &quot;)$&quot;);
228 
229         var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist);
230         return jcheck.issues();
231     }
232 
233     public static Issues check(ReadOnlyRepository repository,
234                                Census census,
235                                CommitMessageParser parser,
236                                String revisionRange,
237                                Hash configuration,
238                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
239                                Set&lt;Hash&gt; blacklist) throws IOException {
240         if (repository.isEmpty()) {
241             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);
242         }
243 
244         var conf = parseConfiguration(repository, configuration);
245 
246         var branchRegex = conf.isPresent() ?  conf.get().repository().branches() : &quot;.*&quot;;
247         var tagRegex =  conf.isPresent() ?  conf.get().repository().tags() : &quot;.*&quot;;
248 
249         return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist);
250     }
251 
252     public static Issues check(ReadOnlyRepository repository,
253                                Census census,
254                                CommitMessageParser parser,
255                                String revisionRange) throws IOException {
256         var master = repository.resolve(repository.defaultBranch().name())
257                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
258         var whitelist = new HashMap&lt;String, Set&lt;Hash&gt;&gt;();
259         var blacklist = new HashSet&lt;Hash&gt;();
260         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
261     }
262 
263     public static Issues check(ReadOnlyRepository repository,
264                                Census census,
265                                CommitMessageParser parser,
266                                String revisionRange,
267                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
268                                Set&lt;Hash&gt; blacklist) throws IOException {
269         var master = repository.resolve(repository.defaultBranch().name())
270                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
271         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
272     }
273 
274     public static Set&lt;Check&gt; checks(ReadOnlyRepository repository, Census census, Hash hash) throws IOException {
275         var jcheck = new JCheck(repository,
276                                 census,
277                                 CommitMessageParsers.v1,
278                                 hash.hex() + &quot;^..&quot; + hash.hex(),
279                                 Pattern.compile(&quot;.*&quot;),
280                                 Pattern.compile(&quot;.*&quot;),
281                                 new HashMap&lt;String, Set&lt;Hash&gt;&gt;(),
282                                 new HashSet&lt;Hash&gt;());
283         return jcheck.checksForCommits();
284     }
285 }
    </pre>
  </body>
</html>