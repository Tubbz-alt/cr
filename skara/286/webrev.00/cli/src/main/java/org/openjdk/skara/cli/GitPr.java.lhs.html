<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.proxy.HttpProxy;
 29 import org.openjdk.skara.vcs.*;
 30 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 31 
 32 import java.io.IOException;
 33 import java.net.URI;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.*;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.function.Supplier;
 39 import java.util.logging.Level;
 40 import java.util.stream.Collectors;
 41 
 42 public class GitPr {
 43     private static void exit(String fmt, Object...args) {
 44         System.err.println(String.format(fmt, args));
 45         System.exit(1);
 46     }
 47 
 48     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 49         return () -&gt; {
 50             exit(fmt, args);
 51             return null;
 52         };
 53     }
 54 
 55     private static void await(Process p) throws IOException {
 56         try {
 57             var res = p.waitFor();
 58             if (res != 0) {
 59                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 60             }
 61         } catch (InterruptedException e) {
 62             throw new IOException(e);
 63         }
 64     }
 65 
 66     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 67         String editor = null;
 68         var lines = repo.config(&quot;core.editor&quot;);
 69         if (lines.size() == 1) {
 70             editor = lines.get(0);
 71         }
 72         if (editor == null) {
 73             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 74         }
 75         if (editor == null) {
 76             editor = System.getenv(&quot;EDITOR&quot;);
 77         }
 78         if (editor == null) {
 79             editor = System.getenv(&quot;VISUAL&quot;);
 80         }
 81         if (editor == null) {
 82             editor = &quot;vi&quot;;
 83         }
 84 
 85         var pb = new ProcessBuilder(editor, file.toString());
 86         pb.inheritIO();
 87         var p = pb.start();
 88         try {
 89             return p.waitFor() == 0;
 90         } catch (InterruptedException e) {
 91             throw new IOException(e);
 92         }
 93     }
 94 
 95     private static String projectName(URI uri) {
 96         var name = uri.getPath().toString().substring(1);
 97         if (name.endsWith(&quot;.git&quot;)) {
 98             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 99         }
100         return name;
101     }
102 
103     private static HostedRepository getHostedRepositoryFor(URI uri, Forge host) throws IOException {
104         var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
105                 new IOException(&quot;Could not find repository at: &quot; + uri.toString())
106         );
107         var parentRepo = remoteRepo.parent();
108         var targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
109         return targetRepo;
110     }
111 
112     private static PullRequest getPullRequest(URI uri, Forge host, Argument prId) throws IOException {
113         if (!prId.isPresent()) {
114             exit(&quot;error: missing pull request identifier&quot;);
115         }
116 
117         var pr = getHostedRepositoryFor(uri, host).pullRequest(prId.asString());
118         if (pr == null) {
119             exit(&quot;error: could not fetch PR information&quot;);
120         }
121 
122         return pr;
123     }
124 
125     private static void show(String ref, Hash hash) throws IOException {
126         show(ref, hash, null);
127     }
128     private static void show(String ref, Hash hash, Path dir) throws IOException {
129         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
130                                                    &quot;--patch&quot;,
131                                                    &quot;--find-renames=50%&quot;,
132                                                    &quot;--find-copies=50%&quot;,
133                                                    &quot;--find-copies-harder&quot;,
134                                                    &quot;--abbrev&quot;,
135                                                    ref + &quot;...&quot; + hash.hex());
136         if (dir != null) {
137             pb.directory(dir.toFile());
138         }
139         pb.inheritIO();
140         await(pb.start());
141     }
142 
143     private static void gimport() throws IOException {
144         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
145         pb.inheritIO();
146         await(pb.start());
147     }
148 
149     private static void hgImport(Path patch) throws IOException {
150         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
151         pb.inheritIO();
152         await(pb.start());
153     }
154 
155     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
156         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
157         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
158         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
159         var p = pb.start();
160         var bytes = p.getInputStream().readAllBytes();
161         var exited = p.waitFor(1, TimeUnit.MINUTES);
162         var exitValue = p.exitValue();
163         if (!exited || exitValue != 0) {
164             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
165         }
166 
167         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
168     }
169 
170     private static String hgResolve(String ref) throws IOException, InterruptedException {
171         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
172         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
173         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
174         var p = pb.start();
175         var bytes = p.getInputStream().readAllBytes();
176         var exited = p.waitFor(1, TimeUnit.MINUTES);
177         var exitValue = p.exitValue();
178         if (!exited || exitValue != 0) {
179             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
180         }
181 
182         return new String(bytes, StandardCharsets.UTF_8);
183     }
184 
185     private static Path diff(String ref, Hash hash) throws IOException {
186         return diff(ref, hash, null);
187     }
188 
189     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
190         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
191         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
192                                                    &quot;--patch&quot;,
193                                                    &quot;--find-renames=50%&quot;,
194                                                    &quot;--find-copies=50%&quot;,
195                                                    &quot;--find-copies-harder&quot;,
196                                                    &quot;--abbrev&quot;,
197                                                    ref + &quot;...&quot; + hash.hex());
198         if (dir != null) {
199             pb.directory(dir.toFile());
200         }
201         pb.redirectOutput(patch.toFile());
202         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
203         await(pb.start());
204         return patch;
205     }
206 
207     private static void apply(Path patch) throws IOException {
208         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
209         pb.inheritIO();
210         await(pb.start());
211     }
212 
213     private static int longest(List&lt;String&gt; strings) {
214         return strings.stream().mapToInt(String::length).max().orElse(0);
215     }
216 
217     public static void main(String[] args) throws IOException, InterruptedException {
218         var flags = List.of(
219             Option.shortcut(&quot;u&quot;)
220                   .fullname(&quot;username&quot;)
221                   .describe(&quot;NAME&quot;)
222                   .helptext(&quot;Username on host&quot;)
223                   .optional(),
224             Option.shortcut(&quot;r&quot;)
225                   .fullname(&quot;remote&quot;)
226                   .describe(&quot;NAME&quot;)
227                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
228                   .optional(),
229             Option.shortcut(&quot;b&quot;)
230                   .fullname(&quot;branch&quot;)
231                   .describe(&quot;NAME&quot;)
232                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
233                   .optional(),
234             Option.shortcut(&quot;&quot;)
235                   .fullname(&quot;authors&quot;)
236                   .describe(&quot;LIST&quot;)
237                   .helptext(&quot;Comma separated list of authors&quot;)
238                   .optional(),
239             Option.shortcut(&quot;&quot;)
240                   .fullname(&quot;assignees&quot;)
241                   .describe(&quot;LIST&quot;)
242                   .helptext(&quot;Comma separated list of assignees&quot;)
243                   .optional(),
244             Option.shortcut(&quot;&quot;)
245                   .fullname(&quot;labels&quot;)
246                   .describe(&quot;LIST&quot;)
247                   .helptext(&quot;Comma separated list of labels&quot;)
248                   .optional(),
249             Option.shortcut(&quot;&quot;)
250                   .fullname(&quot;columns&quot;)
251                   .describe(&quot;id,title,author,assignees,labels&quot;)
252                   .helptext(&quot;Comma separated list of columns to show&quot;)
253                   .optional(),
254             Switch.shortcut(&quot;&quot;)
255                   .fullname(&quot;no-decoration&quot;)
256                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
257                   .optional(),
258             Switch.shortcut(&quot;&quot;)
259                   .fullname(&quot;no-token&quot;)
260                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
261                   .optional(),
262             Switch.shortcut(&quot;&quot;)
263                   .fullname(&quot;mercurial&quot;)
264                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
265                   .optional(),
266             Switch.shortcut(&quot;&quot;)
267                   .fullname(&quot;verbose&quot;)
268                   .helptext(&quot;Turn on verbose output&quot;)
269                   .optional(),
270             Switch.shortcut(&quot;&quot;)
271                   .fullname(&quot;debug&quot;)
272                   .helptext(&quot;Turn on debugging output&quot;)
273                   .optional(),
274             Switch.shortcut(&quot;&quot;)
275                   .fullname(&quot;version&quot;)
276                   .helptext(&quot;Print the version of this tool&quot;)
277                   .optional());
278 
279         var inputs = List.of(
280             Input.position(0)
281                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
282                  .singular()
283                  .required(),
284             Input.position(1)
285                  .describe(&quot;ID&quot;)
286                  .singular()
287                  .optional()
288         );
289 
290         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
291         var arguments = parser.parse(args);
292 
293         if (arguments.contains(&quot;version&quot;)) {
294             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
295             System.exit(0);
296         }
297 
298         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
299             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
300             Logging.setup(level);
301         }
302 
303         HttpProxy.setup();
304 
305         var isMercurial = arguments.contains(&quot;mercurial&quot;);
306         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
307         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
308         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
309         var remotePullPath = repo.pullPath(remote);
310         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
311         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
312         var uri = Remote.toWebURI(remotePullPath);
313         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
314         var credentials = !shouldUseToken ?
315             null :
316             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
317         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
318         var forge = credentials == null ?
319             Forge.from(forgeURI) :
320             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
321         if (forge.isEmpty() || !forge.get().isValid()) {
322             if (!shouldUseToken) {
323                 if (arguments.contains(&quot;verbose&quot;)) {
324                     System.err.println(&quot;&quot;);
325                 }
326                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
327                 if (!arguments.contains(&quot;verbose&quot;)) {
328                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
329                     System.err.println(&quot;&quot;);
330                 }
331             }
332             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
333         }
334         var host = forge.get();
335 
336         var action = arguments.at(0).asString();
337         if (!shouldUseToken &amp;&amp;
338             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
339             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
340             System.exit(1);
341         }
342 
343         if (action.equals(&quot;create&quot;)) {
344             if (isMercurial) {
345                 var currentBookmark = repo.currentBookmark();
346                 if (!currentBookmark.isPresent()) {
347                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
348                     System.err.println(&quot;&quot;);
349                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
350                     System.err.println(&quot;&quot;);
351                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
352                     System.err.println(&quot;&quot;);
353                     System.exit(1);
354                 }
355 
356                 var bookmark = currentBookmark.get();
357                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
358                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
359                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
360                     System.err.println(&quot;&quot;);
361                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
362                     System.err.println(&quot;&quot;);
363                     System.exit(1);
364                 }
365 
366                 var tags = hgTags();
367                 var upstreams = tags.stream()
368                                     .filter(t -&gt; t.endsWith(bookmark.name()))
369                                     .collect(Collectors.toList());
370                 if (upstreams.isEmpty()) {
371                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
372                     System.err.println(&quot;&quot;);
373                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
374                     System.err.println(&quot;&quot;);
375                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
376                     System.err.println(&quot;&quot;);
377                     System.exit(1);
378                 }
379 
380                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
381                 for (var tag : tags) {
382                     tagsAndHashes.put(tag, hgResolve(tag));
383                 }
384                 var bookmarkHash = hgResolve(bookmark.name());
385                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
386                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
387                     System.err.println(&quot;&quot;);
388 
389                     if (upstreams.size() == 1) {
390                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
391                         System.err.println(&quot;&quot;);
392                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
393                         System.err.println(&quot;&quot;);
394                     } else {
395                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
396                         System.err.println(&quot;&quot;);
397                         for (var upstream : upstreams) {
398                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
399                         }
400                         System.err.println(&quot;&quot;);
401                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
402                         System.err.println(&quot;&quot;);
403                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
404                         System.err.println(&quot;&quot;);
405                     }
406                     System.exit(1);
407                 }
408 
409                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
410                 var targetHash = hgResolve(targetBranch);
411                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
412                 if (commits.isEmpty()) {
413                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
414                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
415                     System.exit(1);
416                 }
417 
418                 var diff = repo.diff(repo.head());
419                 if (!diff.patches().isEmpty()) {
420                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
421                     System.err.println(&quot;&quot;);
422                     for (var patch : diff.patches()) {
423                         var path = patch.target().path().isPresent() ?
424                             patch.target().path().get() : patch.source().path().get();
425                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
426                     }
427                     System.err.println(&quot;&quot;);
428                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
429                     System.err.println(&quot;&quot;);
430                     System.err.println(&quot;    hg commit --amend&quot;);
431                     System.err.println(&quot;    hg git-cleanup&quot;);
432                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
433                     System.err.println(&quot;    hg gimport&quot;);
434                     System.err.println(&quot;&quot;);
435                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
436                     System.err.println(&quot;&quot;);
437                     System.err.println(&quot;    hg shelve&quot;);
438                     System.err.println(&quot;&quot;);
439                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
440                     System.exit(1);
441                 }
442 
443                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
444                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
445                 );
446                 if (token == null) {
447                     GitCredentials.approve(credentials);
448                 }
449                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
450                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
451 
452                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
453                 if (commits.size() == 1) {
454                     var commit = commits.get(0);
455                     var message = CommitMessageParsers.v1.parse(commit.message());
456                     Files.writeString(file, message.title() + &quot;\n&quot;);
457                     if (!message.summaries().isEmpty()) {
458                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
459                     }
460                     if (!message.additional().isEmpty()) {
461                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
462                     }
463                 } else {
464                     Files.write(file, List.of(&quot;&quot;));
465                 }
466                 Files.write(file, List.of(
467                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
468                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
469                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
470                     &quot;# the subject from the body.&quot;,
471                     &quot;#&quot;,
472                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
473                     ),
474                     StandardOpenOption.APPEND
475                 );
476                 for (var commit : commits) {
477                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
478                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
479                 }
480                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
481                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
482                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
483                 var success = spawnEditor(repo, file);
484                 if (!success) {
485                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
486                     System.exit(1);
487                 }
488                 var lines = Files.readAllLines(file)
489                                  .stream()
490                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
491                                  .collect(Collectors.toList());
492                 var isEmpty = lines.stream().allMatch(String::isEmpty);
493                 if (isEmpty) {
494                     System.err.println(&quot;error: no message present, aborting&quot;);
495                     System.exit(1);
496                 }
497 
498                 var title = lines.get(0);
499                 List&lt;String&gt; body = null;
500                 if (lines.size() &gt; 1) {
501                     body = lines.subList(1, lines.size())
502                                 .stream()
503                                 .dropWhile(String::isEmpty)
504                                 .collect(Collectors.toList());
505                 } else {
506                     body = Collections.emptyList();
507                 }
508 
509                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
510                 if (arguments.contains(&quot;assignees&quot;)) {
511                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
512                     var assignees = usernames.stream()
513                                              .map(u -&gt; host.user(u))
514                                              .collect(Collectors.toList());
515                     pr.setAssignees(assignees);
516                 }
517                 System.out.println(pr.webUrl().toString());
518                 Files.deleteIfExists(file);
519 
520                 System.exit(0);
521             }
522             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
523                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
524                     System.exit(1);
525                     return null;
526             });
527             if (currentBranch.equals(repo.defaultBranch())) {
528                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
529                 System.err.println(&quot;&quot;);
530                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
531                 System.err.println(&quot;&quot;);
532                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
533                 System.err.println(&quot;    git branch --force master origin/master&quot;);
534                 System.err.println(&quot;&quot;);
535                 System.exit(1);
536             }
537 
538             var upstream = repo.upstreamFor(currentBranch);
539             if (upstream.isEmpty()) {
540                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
541                 System.err.println(&quot;&quot;);
542                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
543                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
544                 System.err.println(&quot;&quot;);
<a name="1" id="anc1"></a><span class="line-modified">545                 System.err.println(&quot;    git push --set-upstream &quot; + remote + &quot; &quot; + currentBranch.name());</span>
546                 System.err.println(&quot;&quot;);
547                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
548                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
549                 System.err.println(&quot;&quot;);
550                 System.err.println(&quot;    git fetch &quot; + remote);
551                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
552                 System.err.println(&quot;&quot;);
553                 System.exit(1);
554             }
555 
556             var upstreamRefName = upstream.get().substring(remote.length() + 1);
557             repo.fetch(uri, upstreamRefName);
558             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
559             if (!branchCommits.isEmpty()) {
560                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
561                 System.err.println(&quot;&quot;);
562                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
563                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
564                 System.err.println(&quot;&quot;);
565                 for (var commit : branchCommits) {
566                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
567                 }
568                 System.err.println(&quot;&quot;);
569                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
570                 System.err.println(&quot;&quot;);
571                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
572                 System.err.println(&quot;&quot;);
573                 System.exit(1);
574             }
575 
576             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
577             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
578             if (commits.isEmpty()) {
579                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
580                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
581                 System.exit(1);
582             }
583 
584             var diff = repo.diff(repo.head());
585             if (!diff.patches().isEmpty()) {
586                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
587                 System.err.println(&quot;&quot;);
588                 for (var patch : diff.patches()) {
589                     var path = patch.target().path().isPresent() ?
590                         patch.target().path().get() : patch.source().path().get();
591                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
592                 }
593                 System.err.println(&quot;&quot;);
594                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
595                 System.err.println(&quot;&quot;);
596                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
597                 System.err.println(&quot;&quot;);
598                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
599                 System.err.println(&quot;&quot;);
600                 System.err.println(&quot;    git stash&quot;);
601                 System.err.println(&quot;&quot;);
602                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
603                 System.exit(1);
604             }
605 
606             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
607                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
608             );
609             if (token == null) {
610                 GitCredentials.approve(credentials);
611             }
612             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
613                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
614 
615             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
616             if (commits.size() == 1) {
617                 var commit = commits.get(0);
618                 var message = CommitMessageParsers.v1.parse(commit.message());
619                 Files.writeString(file, message.title() + &quot;\n&quot;);
620                 if (!message.summaries().isEmpty()) {
621                     Files.write(file, message.summaries(), StandardOpenOption.APPEND);
622                 }
623                 if (!message.additional().isEmpty()) {
624                     Files.write(file, message.additional(), StandardOpenOption.APPEND);
625                 }
626             } else {
627                 Files.write(file, List.of(&quot;&quot;));
628             }
629             Files.write(file, List.of(
630                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
631                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
632                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
633                 &quot;# the subject from the body.&quot;,
634                 &quot;#&quot;,
635                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
636                 ),
637                 StandardOpenOption.APPEND
638             );
639             for (var commit : commits) {
640                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
641                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
642             }
643             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
644             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
645             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
646             var success = spawnEditor(repo, file);
647             if (!success) {
648                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
649                 System.exit(1);
650             }
651             var lines = Files.readAllLines(file)
652                              .stream()
653                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
654                              .collect(Collectors.toList());
655             var isEmpty = lines.stream().allMatch(String::isEmpty);
656             if (isEmpty) {
657                 System.err.println(&quot;error: no message present, aborting&quot;);
658                 System.exit(1);
659             }
660 
661             var title = lines.get(0);
662             List&lt;String&gt; body = null;
663             if (lines.size() &gt; 1) {
664                 body = lines.subList(1, lines.size())
665                             .stream()
666                             .dropWhile(String::isEmpty)
667                             .collect(Collectors.toList());
668             } else {
669                 body = Collections.emptyList();
670             }
671 
672             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
673             if (arguments.contains(&quot;assignees&quot;)) {
674                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
675                 var assignees = usernames.stream()
676                                          .map(u -&gt; host.user(u))
677                                          .collect(Collectors.toList());
678                 pr.setAssignees(assignees);
679             }
680             System.out.println(pr.webUrl().toString());
681             Files.deleteIfExists(file);
682         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
683             var pr = getPullRequest(uri, host, arguments.at(1));
684 
685             if (action.equals(&quot;integrate&quot;)) {
686                 pr.addComment(&quot;/integrate&quot;);
687             } else if (action.equals(&quot;test&quot;)) {
688                 pr.addComment(&quot;/test&quot;);
689             } else if (action.equals(&quot;approve&quot;)) {
690                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
691             } else {
692                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
693             }
694         } else if (action.equals(&quot;list&quot;)) {
695             var remoteRepo = getHostedRepositoryFor(uri, host);
696             var prs = remoteRepo.pullRequests();
697 
698             var ids = new ArrayList&lt;String&gt;();
699             var titles = new ArrayList&lt;String&gt;();
700             var authors = new ArrayList&lt;String&gt;();
701             var assignees = new ArrayList&lt;String&gt;();
702             var labels = new ArrayList&lt;String&gt;();
703 
704             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
705                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
706                 Set.of();
707             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
708                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
709                 Set.of();
710             var filterLabels = arguments.contains(&quot;labels&quot;) ?
711                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
712                 Set.of();
713 
714             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
715             var columnValues = Map.of(defaultColumns.get(0), ids,
716                                       defaultColumns.get(1), titles,
717                                       defaultColumns.get(2), authors,
718                                       defaultColumns.get(3), assignees,
719                                       defaultColumns.get(4), labels);
720             var columns = arguments.contains(&quot;columns&quot;) ?
721                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
722                 defaultColumns;
723             if (columns != defaultColumns) {
724                 for (var column : columns) {
725                     if (!defaultColumns.contains(column)) {
726                         System.err.println(&quot;error: unknown column: &quot; + column);
727                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
728                         System.exit(1);
729                     }
730                 }
731             }
732 
733             for (var pr : remoteRepo.pullRequests()) {
734                 var prAuthor = pr.author().userName();
735                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
736                     continue;
737                 }
738 
739                 var prAssignees = pr.assignees().stream()
740                                     .map(HostUser::userName)
741                                     .collect(Collectors.toSet());
742                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
743                     continue;
744                 }
745 
746                 var prLabels = new HashSet&lt;&gt;(pr.labels());
747                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
748                     continue;
749                 }
750 
751                 ids.add(pr.id());
752                 titles.add(pr.title());
753                 authors.add(prAuthor);
754                 assignees.add(String.join(&quot;,&quot;, prAssignees));
755                 labels.add(String.join(&quot;,&quot;, prLabels));
756             }
757 
758 
759             String fmt = &quot;&quot;;
760             for (var column : columns.subList(0, columns.size() - 1)) {
761                 var values = columnValues.get(column);
762                 var n = Math.max(column.length(), longest(values));
763                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
764             }
765             fmt += &quot;%s\n&quot;;
766 
767             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
768                 var upperCase = columns.stream()
769                                        .map(String::toUpperCase)
770                                        .collect(Collectors.toList());
771                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
772             }
773             for (var i = 0; i &lt; ids.size(); i++) {
774                 final int n = i;
775                 var row = columns.stream()
776                                  .map(columnValues::get)
777                                  .map(values -&gt; values.get(n))
778                                  .collect(Collectors.toList());
779                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
780             }
781         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
782             var prId = arguments.at(1);
783             if (!prId.isPresent()) {
784                 exit(&quot;error: missing pull request identifier&quot;);
785             }
786 
787             var remoteRepo = getHostedRepositoryFor(uri, host);
788             var pr = remoteRepo.pullRequest(prId.asString());
789             var repoUrl = remoteRepo.webUrl();
790             var prHeadRef = pr.sourceRef();
791             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
792             if (isHgGit) {
793                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
794                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
795 
796                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
797                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
798                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
799 
800                     if (action.equals(&quot;show&quot;)) {
801                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
802                     } else {
803                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
804                         hgImport(patch);
805                         Files.delete(patch);
806                     }
807                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
808                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
809                     var hgGitBranches = hgGitRepo.branches();
810                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
811                         hgGitRepo.delete(new Branch(hgGitRef));
812                     }
813                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
814                     gimport();
815                     var hgFetchHead = repo.resolve(hgGitRef).get();
816 
817                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
818                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
819                     } else if (action.equals(&quot;checkout&quot;)) {
820                         repo.checkout(hgFetchHead);
821                         if (arguments.contains(&quot;branch&quot;)) {
822                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
823                         }
824                     }
825                 } else {
826                     exit(&quot;Unexpected action: &quot; + action);
827                 }
828 
829                 return;
830             }
831 
832             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
833             if (action.equals(&quot;fetch&quot;)) {
834                 if (arguments.contains(&quot;branch&quot;)) {
835                     var branchName = arguments.get(&quot;branch&quot;).asString();
836                     repo.branch(fetchHead, branchName);
837                 } else {
838                     System.out.println(fetchHead.hex());
839                 }
840             } else if (action.equals(&quot;checkout&quot;)) {
841                 if (arguments.contains(&quot;branch&quot;)) {
842                     var branchName = arguments.get(&quot;branch&quot;).asString();
843                     var branch = repo.branch(fetchHead, branchName);
844                     repo.checkout(branch, false);
845                 } else {
846                     repo.checkout(fetchHead, false);
847                 }
848             } else if (action.equals(&quot;show&quot;)) {
849                 show(pr.targetRef(), fetchHead);
850             } else if (action.equals(&quot;apply&quot;)) {
851                 var patch = diff(pr.targetRef(), fetchHead);
852                 apply(patch);
853                 Files.deleteIfExists(patch);
854             }
855         } else if (action.equals(&quot;close&quot;)) {
856             var prId = arguments.at(1);
857             if (!prId.isPresent()) {
858                 exit(&quot;error: missing pull request identifier&quot;);
859             }
860 
861             var remoteRepo = getHostedRepositoryFor(uri, host);
862             var pr = remoteRepo.pullRequest(prId.asString());
863             pr.setState(PullRequest.State.CLOSED);
864         } else if (action.equals(&quot;update&quot;)) {
865             var prId = arguments.at(1);
866             if (!prId.isPresent()) {
867                 exit(&quot;error: missing pull request identifier&quot;);
868             }
869 
870             var remoteRepo = getHostedRepositoryFor(uri, host);
871             var pr = remoteRepo.pullRequest(prId.asString());
872             if (arguments.contains(&quot;assignees&quot;)) {
873                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
874                 var assignees = usernames.stream()
875                     .map(u -&gt; host.user(u))
876                     .collect(Collectors.toList());
877                 pr.setAssignees(assignees);
878             }
879         } else {
880             exit(&quot;error: unexpected action: &quot; + action);
881         }
882     }
883 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>