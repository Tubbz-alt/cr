diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
@@ -0,0 +1,188 @@
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.host.HostUser;
+import org.openjdk.skara.issuetracker.Comment;
+import org.openjdk.skara.vcs.*;
+
+import java.net.URI;
+import java.time.ZonedDateTime;
+import java.util.*;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+class ArchiveItem {
+    private final String id;
+    private final ZonedDateTime created;
+    private final HostUser author;
+    private final Map<String, String> extraHeaders;
+    private final ArchiveItem parent;
+    private final Supplier<String> subject;
+    private final Supplier<String> header;
+    private final Supplier<String> body;
+    private final Supplier<String> footer;
+
+    private ArchiveItem(ArchiveItem parent, String id, ZonedDateTime created, HostUser author, Map<String, String> extraHeaders, Supplier<String> subject, Supplier<String> header, Supplier<String> body, Supplier<String> footer) {
+        this.id = id;
+        this.created = created;
+        this.author = author;
+        this.extraHeaders = extraHeaders;
+        this.parent = parent;
+        this.subject = subject;
+        this.header = header;
+        this.body = body;
+        this.footer = footer;
+    }
+
+    static ArchiveItem from(PullRequest pr, Repository localRepo, URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, Hash base, Hash head) {
+        return new ArchiveItem(null, "fc", pr.createdAt(), pr.author(), Map.of("PR-Head-Hash", head.hex(), "PR-Base-Hash", base.hex()),
+                               () -> "RFR: " + pr.title(),
+                               () -> "",
+                               () -> ArchiveMessages.composeConversation(pr, base, head),
+                               () -> {
+                                    var fullWebrev = webrevGenerator.generate(base, head, "00");
+                                    webrevNotification.notify(fullWebrev, 0, true);
+                                    return ArchiveMessages.composeConversationFooter(pr, issueTracker, issuePrefix, localRepo, fullWebrev, base, head);
+                               });
+    }
+
+    static ArchiveItem from(PullRequest pr, Repository localRepo, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, Hash lastBase, Hash lastHead, Hash base, Hash head, int index, ArchiveItem parent) {
+        return new ArchiveItem(parent,"ha" + head.hex(), ZonedDateTime.now(), pr.author(), Map.of("PR-Head-Hash", head.hex(), "PR-Base-Hash", base.hex()),
+                               () -> String.format("Re: [Rev %02d] RFR: %s", index, pr.title()),
+                               () -> "",
+                               () -> ArchiveMessages.composeRevision(pr, localRepo, base, head, lastBase, lastHead),
+                               () -> {
+                                    var fullWebrev = webrevGenerator.generate(base, head, String.format("%02d", index));
+                                    webrevNotification.notify(fullWebrev, index, true);
+                                    if (lastBase.equals(base)) {
+                                        var incrementalWebrev = webrevGenerator.generate(lastHead, head, String.format("%02d-%02d", index - 1, index));
+                                        webrevNotification.notify(incrementalWebrev, index, false);
+                                        return ArchiveMessages.composeIncrementalFooter(pr, localRepo, fullWebrev, incrementalWebrev, head, lastHead);
+                                    } else {
+                                        return ArchiveMessages.composeRebaseFooter(pr, localRepo, fullWebrev, base, head);
+                                    }
+                               });
+    }
+
+    static ArchiveItem from(PullRequest pr, Comment comment, HostUserToEmailAuthor hostUserToEmailAuthor, ArchiveItem parent) {
+        return new ArchiveItem(parent, "pc" + comment.id(), comment.createdAt(), comment.author(), Map.of(),
+                               () -> ArchiveMessages.composeReplySubject(parent.subject()),
+                               () -> ArchiveMessages.composeReplyHeader(parent.createdAt(), hostUserToEmailAuthor.author(parent.author)),
+                               () -> ArchiveMessages.composeComment(comment),
+                               () -> ArchiveMessages.composeReplyFooter(pr));
+    }
+
+    static ArchiveItem from(PullRequest pr, Review review, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, ArchiveItem parent) {
+        return new ArchiveItem(parent, "rv" + review.id(), review.createdAt(), review.reviewer(), Map.of(),
+                               () -> ArchiveMessages.composeReplySubject(parent.subject()),
+                               () -> ArchiveMessages.composeReplyHeader(parent.createdAt(), hostUserToEmailAuthor.author(parent.author())),
+                               () -> ArchiveMessages.composeReview(pr, review, hostUserToUserName, hostUserToRole),
+                               () -> ArchiveMessages.composeReplyFooter(pr));
+    }
+
+    static ArchiveItem from(PullRequest pr, ReviewComment reviewComment, HostUserToEmailAuthor hostUserToEmailAuthor, ArchiveItem parent) {
+        return new ArchiveItem(parent, "rc" + reviewComment.id(), reviewComment.createdAt(), reviewComment.author(), Map.of(),
+                               () -> ArchiveMessages.composeReplySubject(parent.subject()),
+                               () -> ArchiveMessages.composeReplyHeader(parent.createdAt(), hostUserToEmailAuthor.author(parent.author())),
+                               () -> ArchiveMessages.composeReviewComment(pr, reviewComment) ,
+                               () -> ArchiveMessages.composeReplyFooter(pr));
+    }
+
+    static ArchiveItem findParent(List<ArchiveItem> generated, Comment comment) {
+        ArchiveItem lastCommentOrReview = generated.get(0);
+        for (var item : generated) {
+            if (item.id().startsWith("pc") || item.id().startsWith("rv")) {
+                if (item.createdAt().isBefore(comment.createdAt()) && item.createdAt().isAfter(lastCommentOrReview.createdAt())) {
+                    lastCommentOrReview = item;
+                }
+            }
+        }
+
+        return lastCommentOrReview;
+    }
+
+    static ArchiveItem findRevisionItem(List<ArchiveItem> generated, Hash hash) {
+        // Parent is revision update mail with the hash
+        ArchiveItem lastRevisionItem = generated.get(0);
+        for (var item : generated) {
+            if (item.id().startsWith("ha")) {
+                lastRevisionItem = item;
+            }
+            if (item.id().equals("ha" + hash.hex())) {
+                return item;
+            }
+        }
+        return lastRevisionItem;
+    }
+
+    static ArchiveItem findReviewCommentItem(List<ArchiveItem> generated, ReviewComment reviewComment) {
+        for (var item : generated) {
+            if (item.id().equals("rc" + reviewComment.id())) {
+                return item;
+            }
+        }
+        throw new RuntimeException("Failed to find review comment");
+    }
+
+    static ArchiveItem findParent(List<ArchiveItem> generated, Review review) {
+        return findRevisionItem(generated, review.hash());
+    }
+
+    static ArchiveItem findParent(List<ArchiveItem> generated, List<ReviewComment> reviewComments, ReviewComment reviewComment) {
+        // Parent is previous in thread or the revision update mail with the hash
+
+        var threadId = reviewComment.threadId();
+        var reviewThread = reviewComments.stream()
+                                         .filter(comment -> comment.threadId().equals(threadId))
+                                         .collect(Collectors.toList());
+        ReviewComment previousComment = null;
+        for (var threadComment : reviewThread) {
+            if (threadComment.equals(reviewComment)) {
+                break;
+            }
+            previousComment = threadComment;
+        }
+
+        if (previousComment == null) {
+            return findRevisionItem(generated, reviewComment.hash());
+        } else {
+            return findReviewCommentItem(generated, previousComment);
+        }
+    }
+
+    String id() {
+        return id;
+    }
+
+    ZonedDateTime createdAt() {
+        return created;
+    }
+
+    HostUser author() {
+        return author;
+    }
+
+    Map<String, String> extraHeaders() {
+        return extraHeaders;
+    }
+
+    Optional<ArchiveItem> parent() {
+        return Optional.ofNullable(parent);
+    }
+
+    String subject() {
+        return subject.get();
+    }
+
+    String header() {
+        return header.get();
+    }
+
+    String body() {
+        return body.get();
+    }
+
+    String footer() {
+        return footer.get();
+    }
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -1,14 +1,19 @@
 package org.openjdk.skara.bots.mlbridge;
 
-import org.openjdk.skara.email.Email;
-import org.openjdk.skara.forge.Review;
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.issuetracker.Comment;
+import org.openjdk.skara.network.URIBuilder;
 import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.Issue;
 
+import java.io.*;
 import java.net.URI;
+import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
-import java.util.Arrays;
+import java.util.Optional;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 class ArchiveMessages {
     private static String formatCommit(Commit commit) {
@@ -40,126 +45,187 @@
 
         body = MarkdownToText.removeFormatting(body);
         return body.strip();
     }
 
-    private static String quoteBody(String body) {
-        return Arrays.stream(body.strip().split("\\R"))
-                     .map(line -> line.length() > 0 ? line.charAt(0) == '>' ? ">" + line : "> " + line : "> ")
-                     .collect(Collectors.joining("\n"));
+    @FunctionalInterface
+    interface CommitFormatter {
+        String format(Commit commit);
     }
 
-    private static String replyFooter(PullRequestInstance prInstance) {
-        return "PR: " + prInstance.pr().webUrl();
+    private static String formatCommitMessages(Repository localRepo, Hash first, Hash last, CommitFormatter formatter) {
+        try (var commits = localRepo.commits(first.hex() + ".." + last.hex())) {
+            return commits.stream()
+                          .map(formatter::format)
+                          .collect(Collectors.joining("\n"));
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
     }
 
-    // When changing this, ensure that the PR pattern in the notifier still matches
-    static String composeConversation(PullRequestInstance prInstance, URI webrev) {
-        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), ArchiveMessages::formatCommit);
-        var filteredBody = filterComments(prInstance.pr().body());
+    private static Optional<String> issueUrl(PullRequest pr, URI issueTracker, String projectPrefix) {
+        var issue = Issue.fromString(pr.title());
+        return issue.map(value -> URIBuilder.base(issueTracker).appendPath(projectPrefix + "-" + value.id()).build().toString());
+    }
+
+    private static String stats(Repository localRepo, Hash base, Hash head) {
+        try {
+            var diff = localRepo.diff(base, head);
+            var inserted = diff.added();
+            var deleted = diff.removed();
+            var modified = diff.modified();
+            var linesChanged = inserted + deleted + modified;
+            var filesChanged = diff.patches().size();
+            return String.format("%d line%s in %d file%s changed: %d ins; %d del; %d mod",
+                                 linesChanged,
+                                 linesChanged == 1 ? "" : "s",
+                                 filesChanged,
+                                 filesChanged == 1 ? "" : "s",
+                                 inserted,
+                                 deleted,
+                                 modified);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    private static String diffUrl(PullRequest pr) {
+        return pr.webUrl() + ".diff";
+    }
+
+    private static String fetchCommand(PullRequest pr) {
+        var repoUrl = pr.repository().webUrl();
+        return "git fetch " + repoUrl + " " + pr.sourceRef() + ":pull/" + pr.id();
+    }
+
+    static String composeConversation(PullRequest pr, Hash base, Hash head) {
+        var filteredBody = filterComments(pr.body());
         if (filteredBody.isEmpty()) {
-            filteredBody = prInstance.pr().title().strip();
+            filteredBody = pr.title().strip();
         }
-        var issueString = prInstance.issueUrl().map(url -> "  Issue: " + url + "\n").orElse("");
-        return filteredBody + "\n\n" +
-                infoSeparator + "\n\n" +
-                "Commits:\n" +
+        return filteredBody;
+    }
+
+    static String composeRevision(PullRequest pr, Repository localRepository, Hash base, Hash head, Hash lastBase, Hash lastHead) {
+        try {
+            if (base.equals(lastBase)) {
+                if (localRepository.isAncestor(lastHead, head)) {
+                    var updateCount = localRepository.commits(lastHead.hex() + ".." + head.hex()).stream().count();
+                    return "The pull request has been updated with " + updateCount + " additional commit" + (updateCount != 1 ? "s" : "") + ".";
+                } else {
+                    return "Previous commits in this pull request have been removed, probably due to a force push. " +
+                            "The incremental views will show differences compared to the previous content of the PR.";
+                }
+            } else {
+                return "The pull request has been updated with a new target base due to a merge or a rebase.";
+            }
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    static String composeReplySubject(String parentSubject) {
+        if (parentSubject.startsWith("Re: ")) {
+            return parentSubject;
+        } else {
+            return "Re: " + parentSubject;
+        }
+    }
+
+    static String composeReplyFooter(PullRequest pr) {
+        return "PR: " + pr.webUrl();
+    }
+
+    // When changing this, ensure that the PR pattern in the notifier still matches
+    static String composeConversationFooter(PullRequest pr, URI issueProject, String projectPrefix, Repository localRepo, URI webrev, Hash base, Hash head) {
+        var commitMessages = formatCommitMessages(localRepo, base, head, ArchiveMessages::formatCommit);
+        var issueString = issueUrl(pr, issueProject, projectPrefix).map(url -> "  Issue: " + url + "\n").orElse("");
+        return "Commits:\n" +
                 commitMessages + "\n\n" +
-                "Changes: " + prInstance.pr().changeUrl() + "\n" +
-                " Webrev: " + webrev.toString() + "\n" +
+                "Changes: " + pr.changeUrl() + "\n" +
+                " Webrev: " + webrev + "\n" +
                 issueString +
-                "  Stats: " + prInstance.stats(prInstance.baseHash(), prInstance.headHash()) + "\n" +
-                "  Patch: " + prInstance.diffUrl() + "\n" +
-                "  Fetch: " + prInstance.fetchCommand() + "\n\n" +
-                replyFooter(prInstance);
-    }
-
-    static String composeRebaseComment(PullRequestInstance prInstance, URI fullWebrev) {
-        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), ArchiveMessages::formatCommit);
-        var issueString = prInstance.issueUrl().map(url -> "  Issue: " + url + "\n").orElse("");
-        return "The pull request has been updated with a complete new set of changes (possibly due to a rebase).\n\n" +
-                infoSeparator + "\n\n" +
-                "Commits:\n" +
+                "  Stats: " + stats(localRepo, base, head) + "\n" +
+                "  Patch: " + diffUrl(pr) + "\n" +
+                "  Fetch: " + fetchCommand(pr) + "\n\n" +
+                composeReplyFooter(pr);
+    }
+
+    static String composeRebaseFooter(PullRequest pr, Repository localRepo, URI fullWebrev, Hash base, Hash head) {
+        var commitMessages = formatCommitMessages(localRepo, base, head, ArchiveMessages::formatCommit);
+        return "Commits:\n" +
                 commitMessages + "\n\n" +
-                "Changes: " + prInstance.pr().changeUrl() + "\n" +
+                "Changes: " + pr.changeUrl() + "\n" +
                 " Webrev: " + fullWebrev.toString() + "\n" +
-                issueString +
-                "  Stats: " + prInstance.stats(prInstance.baseHash(), prInstance.headHash()) + "\n" +
-                "  Patch: " + prInstance.diffUrl() + "\n" +
-                "  Fetch: " + prInstance.fetchCommand() + "\n\n" +
-                replyFooter(prInstance);    }
-
-    static String composeIncrementalComment(Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
-        var newCommitMessages = prInstance.formatCommitMessages(lastHead, prInstance.headHash(), ArchiveMessages::formatCommit);
-        var issueString = prInstance.issueUrl().map(url -> "  Issue: " + url + "\n").orElse("");
-        return "The pull request has been updated with additional changes.\n\n" +
-                infoSeparator + "\n\n" +
-                "Added commits:\n" +
+                "  Stats: " + stats(localRepo, base, head) + "\n" +
+                "  Patch: " + diffUrl(pr) + "\n" +
+                "  Fetch: " + fetchCommand(pr) + "\n\n" +
+                composeReplyFooter(pr);
+    }
+
+    static String composeIncrementalFooter(PullRequest pr, Repository localRepo, URI fullWebrev, URI incrementalWebrev, Hash head, Hash lastHead) {
+        var newCommitMessages = formatCommitMessages(localRepo, lastHead, head, ArchiveMessages::formatCommit);
+        return "Added commits:\n" +
                 newCommitMessages + "\n\n" +
                 "Changes:\n" +
-                "  - all: " + prInstance.pr().changeUrl() + "\n" +
-                "  - new: " + prInstance.pr().changeUrl(lastHead) + "\n\n" +
+                "  - all: " + pr.changeUrl() + "\n" +
+                "  - new: " + pr.changeUrl(lastHead) + "\n\n" +
                 "Webrevs:\n" +
                 " - full: " + fullWebrev.toString() + "\n" +
                 " - incr: " + incrementalWebrev.toString() + "\n\n" +
-                issueString +
-                "  Stats: " + prInstance.stats(lastHead, prInstance.headHash()) + "\n" +
-                "  Patch: " + prInstance.diffUrl() + "\n" +
-                "  Fetch: " + prInstance.fetchCommand() + "\n\n" +
-                replyFooter(prInstance);
+                "  Stats: " + stats(localRepo, lastHead, head) + "\n" +
+                "  Patch: " + diffUrl(pr) + "\n" +
+                "  Fetch: " + fetchCommand(pr) + "\n\n" +
+                composeReplyFooter(pr);
     }
 
-    private static String filterParentBody(Email parent, PullRequestInstance prInstance) {
-        var parentFooter = ArchiveMessages.replyFooter(prInstance);
-        var filteredParentBody = parent.body().strip();
-        if (filteredParentBody.endsWith(parentFooter)) {
-            return filteredParentBody.substring(0, filteredParentBody.length() - parentFooter.length()).strip();
-        } else {
-            return filteredParentBody;
-        }
-    }
-
-    static String composeReply(Email parent, String body, PullRequestInstance prInstance) {
-        return "On " + parent.date().format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + parent.author().toString() + " wrote:\n" +
-                "\n" +
-                quoteBody(filterParentBody(parent, prInstance)) +
-                "\n\n" +
-                filterComments(body) +
-                "\n\n" +
-                replyFooter(prInstance);
-    }
-
-    static String composeCombinedReply(Email parent, String body, PullRequestInstance prInstance) {
-        return filterParentBody(parent, prInstance) +
-                "\n\n" +
-                filterComments(body) +
-                "\n\n" +
-                replyFooter(prInstance);
+    static String composeComment(Comment comment) {
+        return filterComments(comment.body());
     }
 
-    static String reviewCommentBody(String body) {
-        return filterComments(body);
+    static String composeReviewComment(PullRequest pr, ReviewComment reviewComment) {
+        var body = new StringBuilder();
+
+        // Add some context to the first post
+        if (reviewComment.parent().isEmpty()) {
+            body.append(reviewComment.path()).append(" line ").append(reviewComment.line()).append(":\n\n");
+            try {
+                var contents = pr.repository().fileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());
+                for (int i = Math.max(0, reviewComment.line() - 2); i < Math.min(contents.size(), reviewComment.line() + 1); ++i) {
+                    body.append("> ").append(i + 1).append(": ").append(contents.get(i)).append("\n");
+                }
+                body.append("\n");
+            } catch (RuntimeException e) {
+                body.append("> (failed to retrieve contents of file, check the PR for context)\n");
+            }
+        }
+        body.append(filterComments(reviewComment.body()));
+        return body.toString();
     }
 
-    static String reviewVerdictBody(String body, Review.Verdict verdict, String user, String role) {
-        var filteredBody = filterComments(body);
+    static String composeReview(PullRequest pr, Review review, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole) {
         var result = new StringBuilder();
-        if (verdict != Review.Verdict.NONE) {
-            if (filteredBody.length() > 0) {
+        review.body().ifPresent(body -> result.append(filterComments(body)));
+        if (review.verdict() != Review.Verdict.NONE) {
+            if (result.length() > 0) {
                 result.append("\n\n");
                 result.append(infoSeparator);
                 result.append("\n\n");
             }
-            if (verdict == Review.Verdict.APPROVED) {
+            if (review.verdict() == Review.Verdict.APPROVED) {
                 result.append("Approved");
             } else {
                 result.append("Changes requested");
             }
             result.append(" by ");
-            result.append(user);
+            result.append(hostUserToUserName.userName(review.reviewer()));
             result.append(" (");
-            result.append(role);
+            result.append(hostUserToRole.role(review.reviewer()));
             result.append(").");
         }
         return result.toString();
     }
+
+    static String composeReplyHeader(ZonedDateTime parentDate, EmailAddress parentAuthor) {
+        return "On " + parentDate.format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + parentAuthor.toString() + " wrote:";
+    }
 }
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -23,11 +23,11 @@
 package org.openjdk.skara.bots.mlbridge;
 
 import org.openjdk.skara.bot.WorkItem;
 import org.openjdk.skara.email.*;
 import org.openjdk.skara.forge.PullRequest;
-import org.openjdk.skara.host.*;
+import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
 import org.openjdk.skara.mailinglist.*;
 import org.openjdk.skara.vcs.Repository;
 
 import java.io.*;
@@ -185,10 +185,46 @@
         } else {
             throw new RuntimeException("Something is wrong with the mbox");
         }
     }
 
+    private EmailAddress getAuthorAddress(CensusInstance censusInstance, HostUser originalAuthor) {
+        var contributor = censusInstance.namespace().get(originalAuthor.id());
+        if (contributor == null) {
+            return EmailAddress.from(originalAuthor.fullName(),
+                                     censusInstance.namespace().name() + "+" +
+                                             originalAuthor.id() + "+" + originalAuthor.userName() + "@" +
+                                             censusInstance.configuration().census().domain());
+        } else {
+            return EmailAddress.from(contributor.fullName().orElse(originalAuthor.fullName()),
+                                     contributor.username() + "@" + censusInstance.configuration().census().domain());
+        }
+    }
+
+    private String getAuthorUserName(CensusInstance censusInstance, HostUser originalAuthor) {
+        var contributor = censusInstance.namespace().get(originalAuthor.id());
+        var userName = contributor != null ? contributor.username() : originalAuthor.userName() + "@" + censusInstance.namespace().name();
+        return userName;
+    }
+
+    private String getAuthorRole(CensusInstance censusInstance, HostUser originalAuthor) {
+        var version = censusInstance.configuration().census().version();
+        var contributor = censusInstance.namespace().get(originalAuthor.id());
+        if (contributor == null) {
+            return "no OpenJDK username";
+        } else if (censusInstance.project().isLead(contributor.username(), version)) {
+            return "Lead";
+        } else if (censusInstance.project().isReviewer(contributor.username(), version)) {
+            return "Reviewer";
+        } else if (censusInstance.project().isCommitter(contributor.username(), version)) {
+            return "Committer";
+        } else if (censusInstance.project().isAuthor(contributor.username(), version)) {
+            return "Author";
+        }
+        return "no project role";
+    }
+
     @Override
     public void run(Path scratchPath) {
         var path = scratchPath.resolve("mlbridge");
         var archiveRepo = materializeArchive(path);
         var mboxBasePath = path.resolve(bot.codeRepo().name());
@@ -232,104 +268,79 @@
         var census = CensusInstance.create(bot.censusRepo(), bot.censusRef(), scratchPath.resolve("census"), pr);
         var jbs = census.configuration().general().jbs();
         if (jbs == null) {
             jbs = census.configuration().general().project();
         }
-        var prInstance = new PullRequestInstance(scratchPath.resolve("mlbridge-mergebase"), pr, bot.issueTracker(),
-                                                 jbs.toUpperCase());
-        var reviewArchive = new ReviewArchive(bot.emailAddress(), prInstance, census, sentMails);
-        var webrevPath = scratchPath.resolve("mlbridge-webrevs");
-        var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer(), bot.sendInterval());
-        var list = listServer.getList(bot.listAddress().address());
-
-        // First post
-        if (sentMails.isEmpty()) {
-            log.fine("Creating new PR review archive");
-            var webrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
-                                                              prInstance.headHash(), "00");
-            reviewArchive.create(webrev);
-            updateWebrevComment(comments, 0, webrev, null);
-        } else {
-            var latestHead = reviewArchive.latestHead();
-
-            // Check if the head has changed
-            if (!pr.headHash().equals(latestHead)) {
-                log.fine("Head hash change detected: current: " + pr.headHash() + " - last: " + latestHead);
-
-                var latestBase = reviewArchive.latestBase();
-                if (!prInstance.baseHash().equals(latestBase)) {
-                    // FIXME: Could try harder to make an incremental
-                    var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
-                                                                          prInstance.headHash(), String.format("%02d", reviewArchive.revisionCount()));
-                    reviewArchive.addFull(fullWebrev);
-                    updateWebrevComment(comments, reviewArchive.revisionCount(), fullWebrev, null);
-                } else {
-                    var index = reviewArchive.revisionCount();
-                    var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
-                                                                          prInstance.headHash(), String.format("%02d", index));
-                    var incrementalWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, latestHead,
-                                                                                 prInstance.headHash(), String.format("%02d-%02d", index - 1, index));
-                    reviewArchive.addIncremental(fullWebrev, incrementalWebrev);
-                    updateWebrevComment(comments, index, fullWebrev, incrementalWebrev);
+
+        // Materialize the PR's target ref
+        try {
+            var repository = pr.repository();
+            var localRepo = Repository.materialize(scratchPath.resolve("mlbridge-mergebase"), repository.url(), pr.targetRef());
+            var targetHash = localRepo.fetch(repository.url(), pr.targetRef());
+            var headHash = localRepo.fetch(repository.url(), pr.headHash().hex());
+            var baseHash = localRepo.mergeBase(targetHash, headHash);
+
+            var webrevPath = scratchPath.resolve("mlbridge-webrevs");
+            var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer(), bot.sendInterval());
+            var list = listServer.getList(bot.listAddress().address());
+
+            var archiver = new ReviewArchive(pr, bot.emailAddress(), baseHash, headHash);
+
+            // Regular comments
+            for (var comment : comments) {
+                if (ignoreComment(comment.author(), comment.body())) {
+                    continue;
                 }
+                archiver.addComment(comment);
             }
-        }
 
-        // Regular comments
-        for (var comment : comments) {
-            if (ignoreComment(comment.author(), comment.body())) {
-                continue;
+            // Review comments
+            var reviews = pr.reviews();
+            for (var review : reviews) {
+                if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
+                    continue;
+                }
+                archiver.addReview(review);
             }
-            reviewArchive.addComment(comment);
-        }
 
-        // Review comments
-        var reviews = pr.reviews();
-        for (var review : reviews) {
-            if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
-                continue;
+            // File specific comments
+            var reviewComments = pr.reviewComments();
+            for (var reviewComment : reviewComments) {
+                if (ignoreComment(reviewComment.author(), reviewComment.body())) {
+                    continue;
+                }
+                archiver.addReviewComment(reviewComment);
             }
-            reviewArchive.addReview(review);
-        }
 
-        // File specific comments
-        var reviewComments = pr.reviewComments();
-        for (var reviewComment : reviewComments) {
-            if (ignoreComment(reviewComment.author(), reviewComment.body())) {
-                continue;
+            var webrevGenerator = bot.webrevStorage().generator(pr, localRepo, webrevPath);
+            var newMails = archiver.generateNewEmails(sentMails, localRepo, bot.issueTracker(), jbs.toUpperCase(), webrevGenerator,
+                                                      (uri, index, isFull) -> updateWebrevComment(comments, index, uri, null),
+                                                      user -> getAuthorAddress(census, user),
+                                                      user -> getAuthorUserName(census, user),
+                                                      user -> getAuthorRole(census, user));
+            if (newMails.isEmpty()) {
+                return;
             }
-            reviewArchive.addReviewComment(reviewComment);
-        }
 
-        // Review verdict comments
-        for (var review : reviews) {
-            if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
-                continue;
+            // Push all new mails to the archive repository
+            newMails.forEach(reviewArchiveList::post);
+            pushMbox(archiveRepo, "Adding comments for PR " + bot.codeRepo().name() + "/" + pr.id());
+
+            // Finally post all new mails to the actual list
+            for (var newMail : newMails) {
+                var filteredHeaders = newMail.headers().stream()
+                                             .filter(header -> !header.startsWith("PR-"))
+                                             .collect(Collectors.toMap(Function.identity(),
+                                                                       newMail::headerValue));
+                var filteredEmail = Email.from(newMail)
+                                         .replaceHeaders(filteredHeaders)
+                                         .headers(bot.headers())
+                                         .build();
+                list.post(filteredEmail);
             }
-            reviewArchive.addReviewVerdict(review);
-        }
-
-        var newMails = reviewArchive.generatedEmails();
-        if (newMails.isEmpty()) {
-            return;
-        }
-
-        // Push all new mails to the archive repository
-        newMails.forEach(reviewArchiveList::post);
-        pushMbox(archiveRepo, "Adding comments for PR " + bot.codeRepo().name() + "/" + pr.id());
-
-        // Finally post all new mails to the actual list
-        for (var newMail : newMails) {
-            var filteredHeaders = newMail.headers().stream()
-                                         .filter(header -> !header.startsWith("PR-"))
-                                         .collect(Collectors.toMap(Function.identity(),
-                                                                   newMail::headerValue));
-            var filteredEmail = Email.from(newMail)
-                                     .replaceHeaders(filteredHeaders)
-                                     .headers(bot.headers())
-                                     .build();
-            list.post(filteredEmail);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
         }
     }
 
     @Override
     public void handleRuntimeException(RuntimeException e) {
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToEmailAuthor.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToEmailAuthor.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToEmailAuthor.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.host.HostUser;
+
+@FunctionalInterface
+interface HostUserToEmailAuthor {
+    EmailAddress author(HostUser user);
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToRole.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToRole.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToRole.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.host.HostUser;
+
+@FunctionalInterface
+interface HostUserToRole {
+    String role(HostUser user);
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToUserName.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToUserName.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/HostUserToUserName.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.host.HostUser;
+
+@FunctionalInterface
+interface HostUserToUserName {
+    String userName(HostUser user);
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.mlbridge;
-
-import org.openjdk.skara.forge.PullRequest;
-import org.openjdk.skara.network.URIBuilder;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.Issue;
-
-import java.io.*;
-import java.net.URI;
-import java.nio.file.Path;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-class PullRequestInstance {
-    private final PullRequest pr;
-    private final Repository localRepo;
-    private final Hash targetHash;
-    private final Hash headHash;
-    private final Hash baseHash;
-    private final URI issueTracker;
-    private final String projectPrefix;
-
-    PullRequestInstance(Path localRepoPath, PullRequest pr, URI issueTracker, String projectPrefix) {
-        this.pr = pr;
-        this.issueTracker = issueTracker;
-        this.projectPrefix = projectPrefix;
-
-        // Materialize the PR's target ref
-        try {
-            var repository = pr.repository();
-            localRepo = Repository.materialize(localRepoPath, repository.url(),
-                                               "+" + pr.targetRef() + ":mlbridge_prinstance_" + repository.name());
-            targetHash = localRepo.fetch(repository.url(), pr.targetRef());
-            headHash = localRepo.fetch(repository.url(), pr.headHash().hex());
-            baseHash = localRepo.mergeBase(targetHash, headHash);
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
-    Repository localRepo() {
-        return this.localRepo;
-    }
-
-    Hash baseHash() {
-        return this.baseHash;
-    }
-
-    Hash headHash() {
-        return this.headHash;
-    }
-
-    String diffUrl() {
-        return pr.webUrl() + ".diff";
-    }
-
-    String fetchCommand() {
-        var repoUrl = pr.repository().webUrl();
-        return "git fetch " + repoUrl + " " + pr.sourceRef() + ":pull/" + pr.id();
-    }
-
-    String stats(Hash base, Hash head) {
-        try {
-            var diff = localRepo.diff(base, head);
-            var inserted = diff.added();
-            var deleted = diff.removed();
-            var modified = diff.modified();
-            var linesChanged = inserted + deleted + modified;
-            var filesChanged = diff.patches().size();
-            return String.format("%d line%s in %d file%s changed: %d ins; %d del; %d mod",
-                                 linesChanged,
-                                 linesChanged == 1 ? "" : "s",
-                                 filesChanged,
-                                 filesChanged == 1 ? "" : "s",
-                                 inserted,
-                                 deleted,
-                                 modified);
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
-    Optional<String> issueUrl() {
-        var issue = Issue.fromString(pr.title());
-        return issue.map(value -> URIBuilder.base(issueTracker).appendPath(projectPrefix + "-" + value.id()).build().toString());
-    }
-
-    @FunctionalInterface
-    interface CommitFormatter {
-        String format(Commit commit);
-    }
-
-    String formatCommitMessages(Hash first, Hash last, CommitFormatter formatter) {
-        try (var commits = localRepo().commits(first.hex() + ".." + last.hex())) {
-            return commits.stream()
-                          .map(formatter::format)
-                          .collect(Collectors.joining("\n"));
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
-    String id() {
-        return pr.id();
-    }
-
-    PullRequest pr() {
-        return pr;
-    }
-}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -1,409 +1,244 @@
 package org.openjdk.skara.bots.mlbridge;
 
-import org.openjdk.skara.census.Contributor;
 import org.openjdk.skara.email.*;
 import org.openjdk.skara.forge.*;
-import org.openjdk.skara.host.*;
+import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
-import org.openjdk.skara.vcs.Hash;
+import org.openjdk.skara.vcs.*;
 
 import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.security.*;
 import java.util.*;
+import java.util.regex.Pattern;
 import java.util.stream.*;
 
 class ReviewArchive {
-    private final PullRequestInstance prInstance;
-    private final CensusInstance censusInstance;
+    private final PullRequest pr;
     private final EmailAddress sender;
-    private final List<Email> existing;
-    private final Map<String, Email> existingIds = new HashMap<>();
-    private final List<Email> generated = new ArrayList<>();
-    private final Map<String, Email> generatedIds = new HashMap<>();
-    private final Set<EmailAddress> approvalIds = new HashSet<>();
-    private final List<Hash> reportedHeads;
-    private final List<Hash> reportedBases;
-
-    private EmailAddress getAuthorAddress(HostUser originalAuthor) {
-        var contributor = censusInstance.namespace().get(originalAuthor.id());
-        if (contributor == null) {
-            return EmailAddress.from(originalAuthor.fullName(),
-                                     censusInstance.namespace().name() + "+" +
-                                             originalAuthor.id() + "+" + originalAuthor.userName() + "@" +
-                                             censusInstance.configuration().census().domain());
-        } else {
-            return EmailAddress.from(contributor.fullName().orElse(originalAuthor.fullName()),
-                                     contributor.username() + "@" + censusInstance.configuration().census().domain());
-        }
-    }
-
-    private EmailAddress getUniqueMessageId(String identifier) {
-        try {
-            var prSpecific = prInstance.pr().repository().name().replace("/", ".") + "." + prInstance.id();
-            var digest = MessageDigest.getInstance("SHA-256");
-            digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
-            digest.update(identifier.getBytes(StandardCharsets.UTF_8));
-            var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
-
-            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + prInstance.pr().repository().url().getHost());
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException("Cannot find SHA-256");
-        }
-    }
-
-    private EmailAddress getMessageId() {
-        return getUniqueMessageId("fc");
-    }
-
-    private EmailAddress getMessageId(Comment comment) {
-        return getUniqueMessageId("pc" + comment.id());
-    }
+    private final Hash base;
+    private final Hash head;
 
-    private EmailAddress getMessageId(ReviewComment comment) {
-        return getUniqueMessageId("rc" + comment.id());
-    }
+    private final List<Comment> comments = new ArrayList<>();
+    private final List<Review> reviews = new ArrayList<>();
+    private final List<ReviewComment> reviewComments = new ArrayList<>();
 
-    private EmailAddress getMessageId(Hash hash) {
-        return getUniqueMessageId("ha" + hash.hex());
+    ReviewArchive(PullRequest pr, EmailAddress sender, Hash base, Hash head) {
+        this.pr = pr;
+        this.sender = sender;
+        this.base = base;
+        this.head = head;
     }
 
-    private EmailAddress getMessageId(Review review) {
-        return getUniqueMessageId("rv" + review.id());
+    void addComment(Comment comment) {
+        comments.add(comment);
     }
 
-    private String getStableMessageId(EmailAddress uniqueMessageId) {
-        return uniqueMessageId.localPart().split("\\.")[0];
+    void addReview(Review review) {
+        reviews.add(review);
     }
 
-    private Set<String> getStableMessageIds(Email email) {
-        var ret = new HashSet<String>();
-        ret.add(getStableMessageId(email.id()));
-        if (email.hasHeader("PR-Collapsed-IDs")) {
-            var additional = email.headerValue("PR-Collapsed-IDs").split(" ");
-            ret.addAll(Arrays.asList(additional));
-        }
-        return ret;
-    }
+    void addReviewComment(ReviewComment reviewComment) {
+        reviewComments.add(reviewComment);
+    }
+
+    // Searches for a previous reply to a certain parent by a specific author
+    private Optional<ArchiveItem> findPreviousReplyBy(List<ArchiveItem> generated, HostUser author, ArchiveItem parent) {
+        return generated.stream()
+                        .filter(item -> item.author().equals(author))
+                        .filter(item -> item.parent().isPresent())
+                        .filter(item -> item.parent().get().equals(parent))
+                        .findAny();
+    }
+
+    private List<ArchiveItem> generateArchiveItems(List<Email> sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification) {
+        var generated = new ArrayList<ArchiveItem>();
+        Hash lastBase = null;
+        Hash lastHead = null;
+        int revisionIndex = 0;
+
+        // Check existing generated mails to find which hashes have been previously reported
+        for (var email : sentEmails) {
+            if (email.hasHeader("PR-Base-Hash")) {
+                var curBase = new Hash(email.headerValue("PR-Base-Hash"));
+                var curHead = new Hash(email.headerValue("PR-Head-Hash"));
+
+                if (generated.isEmpty()) {
+                    var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, curBase, curHead);
+                    generated.add(first);
+                } else {
+                    var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0));
+                    generated.add(revision);
+                }
 
-    private Email topEmail() {
-        if (!existing.isEmpty()) {
-            return existing.get(0);
+                lastBase = curBase;
+                lastHead = curHead;
+            }
         }
-        return generated.get(0);
-    }
-
-    // Returns a suitable parent to use for a general comment
-    private Email latestGeneralComment() {
-        return Stream.concat(existing.stream(), generated.stream())
-                     .filter(email -> !email.hasHeader("PR-Head-Hash"))
-                     .filter(email -> email.subject().startsWith("Re: RFR"))
-                     .max(Comparator.comparingInt(email -> Integer.parseInt(email.headerValue("PR-Sequence"))))
-                     .orElse(topEmail());
-    }
 
-    // Returns the top-level comment for a certain head hash
-    private Email topCommentForHash(Hash hash) {
-        return Stream.concat(existing.stream(), generated.stream())
-                     .filter(email -> email.hasHeader("PR-Head-Hash"))
-                     .filter(email -> email.headerValue("PR-Head-Hash").equals(hash.hex()))
-                     .findFirst()
-                     .orElse(topEmail());
-    }
-
-    private Email parentForReviewComment(ReviewComment reviewComment) {
-        var parent = topCommentForHash(reviewComment.hash());
-        if (reviewComment.parent().isPresent()) {
-            var parentId = getStableMessageId(getMessageId(reviewComment.parent().get()));
-            var last = Stream.concat(existing.stream(), generated.stream())
-                             .filter(email -> (email.hasHeader("References") && email.headerValue("References").contains(parentId)) ||
-                                     (getStableMessageId(email.id()).equals(parentId)) ||
-                                     (email.hasHeader("PR-Collapsed-IDs") && email.headerValue("PR-Collapsed-IDs").contains(parentId)))
-                             .max(Comparator.comparingInt(email -> Integer.parseInt(email.headerValue("PR-Sequence"))));
-
-            if (last.isEmpty()) {
-                throw new RuntimeException("Failed to find parent");
+        // Check if we're at a revision not previously reported
+        if (!base.equals(lastBase) || !head.equals(lastHead)) {
+            if (generated.isEmpty()) {
+                var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, base, head);
+                generated.add(first);
             } else {
-                return last.get();
+                var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, lastBase, lastHead, base, head, ++revisionIndex, generated.get(0));
+                generated.add(revision);
             }
         }
-        return parent;
-    }
 
-    ReviewArchive(EmailAddress sender, PullRequestInstance prInstance, CensusInstance censusInstance, List<Email> sentMails) {
-        this.sender = sender;
-        this.prInstance = prInstance;
-        this.censusInstance = censusInstance;
-
-        existing = sentMails;
-        for (var email : existing) {
-            var stableIds = getStableMessageIds(email);
-            for (var stableId : stableIds) {
-                existingIds.put(stableId, email);
-            }
+        // A review always have a revision mail as parent, so start with these
+        for (var review : reviews) {
+            var parent = ArchiveItem.findParent(generated, review);
+            var reply = ArchiveItem.from(pr, review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);
+            generated.add(reply);
         }
-
-        // Determine the latest hashes reported
-        reportedHeads = existing.stream()
-                                .filter(email -> email.hasHeader("PR-Head-Hash"))
-                                .map(email -> email.headerValue("PR-Head-Hash"))
-                                .map(Hash::new)
-                                .collect(Collectors.toList());
-        reportedBases = existing.stream()
-                                .filter(email -> email.hasHeader("PR-Base-Hash"))
-                                .map(email -> email.headerValue("PR-Base-Hash"))
-                                .map(Hash::new)
-                                .collect(Collectors.toList());
-    }
-
-    Hash latestHead() {
-        if (reportedHeads.isEmpty()) {
-            throw new IllegalArgumentException("No head reported yet");
+        // Comments have either a comment or a review as parent, the eligible ones have been generated at this point
+        for (var comment : comments) {
+            var parent = ArchiveItem.findParent(generated, comment);
+            var reply = ArchiveItem.from(pr, comment, hostUserToEmailAuthor, parent);
+            generated.add(reply);
         }
-        return reportedHeads.get(reportedHeads.size() - 1);
-    }
-
-    Hash latestBase() {
-        if (reportedBases.isEmpty()) {
-            throw new IllegalArgumentException("No base reported yet");
+        // Finally, file specific comments should be seen after general review comments
+        for (var reviewComment : reviewComments) {
+            var parent = ArchiveItem.findParent(generated, reviewComments, reviewComment);
+            var reply = ArchiveItem.from(pr, reviewComment, hostUserToEmailAuthor, parent);
+            generated.add(reply);
         }
-        return reportedBases.get(reportedBases.size() - 1);
-    }
-
-    int revisionCount() {
-        return reportedHeads.size();
-    }
-
-    void create(URI webrev) {
-        var body = ArchiveMessages.composeConversation(prInstance, webrev);
-        var id = getMessageId();
-        var email = Email.create("RFR: " + prInstance.pr().title(), body)
-                         .sender(sender)
-                         .author(getAuthorAddress(prInstance.pr().author()))
-                         .id(id)
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .build();
-        generated.add(email);
-        generatedIds.put(getStableMessageId(id), email);
-    }
 
-    private String latestHeadPrefix() {
-        return String.format("[Rev %02d]", revisionCount());
+        return generated;
     }
 
-    void addFull(URI webrev) {
-        var body = ArchiveMessages.composeRebaseComment(prInstance, webrev);
-        var id = getMessageId(prInstance.headHash());
-        var parent = topEmail();
-        var email = Email.reply(parent, "Re: " + latestHeadPrefix() + " RFR: " + prInstance.pr().title(), body)
-                         .sender(sender)
-                         .author(getAuthorAddress(prInstance.pr().author()))
-                         .recipient(parent.author())
-                         .id(id)
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
-                         .build();
-        generated.add(email);
-        generatedIds.put(getStableMessageId(id), email);
+    private Set<String> sentItemIds(List<Email> sentEmails) {
+        var primary = sentEmails.stream()
+                                .map(email -> getStableMessageId(email.id()));
+        var collapsed = sentEmails.stream()
+                                  .filter(email -> email.hasHeader("PR-Collapsed-IDs"))
+                                  .flatMap(email -> Stream.of(email.headerValue("PR-Collapsed-IDs").split(" ")));
+        return Stream.concat(primary, collapsed)
+                     .collect(Collectors.toSet());
     }
 
-    void addIncremental(URI fullWebrev, URI incrementalWebrev) {
-        var body = ArchiveMessages.composeIncrementalComment(latestHead(), prInstance, fullWebrev, incrementalWebrev);
-        var id = getMessageId(prInstance.headHash());
-        var parent = topEmail();
-        var email = Email.reply(parent, "Re: " + latestHeadPrefix() + " RFR: " + prInstance.pr().title(), body)
-                         .sender(sender)
-                         .author(getAuthorAddress(prInstance.pr().author()))
-                         .recipient(parent.author())
-                         .id(id)
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
-                         .build();
-        generated.add(email);
-        generatedIds.put(getStableMessageId(id), email);
+    // Group items that has the same author and the same parent
+    private List<List<ArchiveItem>> collapsableItems(List<ArchiveItem> items) {
+        var grouped = items.stream()
+                           .collect(Collectors.groupingBy(item -> item.author().id() + "." + (item.parent().isPresent() ? item.parent().get() : "xxx"),
+                                                          LinkedHashMap::new, Collectors.toList()));
+        return new ArrayList<>(grouped.values());
     }
 
-    private Optional<Email> findCollapsable(Email parent, HostUser author, String subject) {
-        var parentId = getStableMessageId(parent.id());
-
-        // Is it a self-reply?
-        if (parent.author().equals(getAuthorAddress(author)) && generatedIds.containsKey(parentId)) {
-            // But avoid extending top-level parents
-            if (!parent.hasHeader("PR-Head-Hash")) {
-                // And only collapse identical subjects
-                if (parent.subject().equals(subject)) {
-                    return Optional.of(parent);
-                }
-            }
-        }
-
-        // Have we already replied to the same parent?
-        for (var candidate : generated) {
-            if (!candidate.hasHeader("In-Reply-To")) {
-                continue;
-            }
-            var inReplyTo = EmailAddress.parse(candidate.headerValue("In-Reply-To"));
-            var candidateParentId = getStableMessageId(inReplyTo);
-            if (candidateParentId.equals(parentId) && candidate.author().equals(getAuthorAddress(author))) {
-                // Only collapse identical subjects
-                if (candidate.subject().equals(subject)) {
-                    return Optional.of(candidate);
-                }
-            }
+    private static final Pattern commentPattern = Pattern.compile("<!--.*?-->",
+                                                                  Pattern.DOTALL | Pattern.MULTILINE);
+    private static final Pattern cutoffPattern = Pattern.compile("(.*?)<!-- Anything below this marker will be .*? -->",
+                                                                 Pattern.DOTALL | Pattern.MULTILINE);
+    private static String filterComments(String body) {
+        var cutoffMatcher = cutoffPattern.matcher(body);
+        if (cutoffMatcher.find()) {
+            body = cutoffMatcher.group(1);
         }
 
-        return Optional.empty();
-    }
-
-    private void addReplyCommon(Email parent, HostUser author, String subject, String body, EmailAddress id) {
-        if (!subject.startsWith("Re: ")) {
-            subject = "Re: " + subject;
-        }
+        var commentMatcher = commentPattern.matcher(body);
+        body = commentMatcher.replaceAll("");
 
-        // Collapse self-replies and replies-to-same that have been created in this run
-        var collapsable = findCollapsable(parent, author, subject);
-        if (collapsable.isPresent()) {
-            // Drop the parent
-            var parentEmail = collapsable.get();
-            generated.remove(parentEmail);
-            generatedIds.remove(getStableMessageId(parentEmail.id()));
-
-            var collapsed = parentEmail.hasHeader("PR-Collapsed-IDs") ? parentEmail.headerValue("PR-Collapsed-IDs") + " " : "";
-            collapsed += getStableMessageId(parentEmail.id());
-
-            var reply = ArchiveMessages.composeCombinedReply(parentEmail, body, prInstance);
-            var email = Email.from(parentEmail)
-                             .body(reply)
-                             .subject(subject)
-                             .id(id)
-                             .header("PR-Collapsed-IDs", collapsed)
-                             .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
-                             .build();
-            generated.add(email);
-            generatedIds.put(getStableMessageId(id), email);
-        } else {
-            var reply = ArchiveMessages.composeReply(parent, body, prInstance);
-            var email = Email.reply(parent, subject, reply)
-                             .sender(sender)
-                             .author(getAuthorAddress(author))
-                             .recipient(parent.author())
-                             .id(id)
-                             .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
-                             .build();
-            generated.add(email);
-            generatedIds.put(getStableMessageId(id), email);
-        }
+        body = MarkdownToText.removeFormatting(body);
+        return body.strip();
     }
 
-    void addComment(Comment comment) {
-        var id = getMessageId(comment);
-        if (existingIds.containsKey(getStableMessageId(id))) {
-            return;
-        }
-
-        var parent = latestGeneralComment();
-        addReplyCommon(parent, comment.author(), "Re: RFR: " + prInstance.pr().title(), comment.body(), id);
+    private String quoteBody(String body) {
+        return Arrays.stream(body.strip().split("\\R"))
+                     .map(line -> line.length() > 0 ? line.charAt(0) == '>' ? ">" + line : "> " + line : "> ")
+                     .collect(Collectors.joining("\n"));
     }
 
-    private String projectRole(Contributor contributor) {
-        var version = censusInstance.configuration().census().version();
-        if (censusInstance.project().isLead(contributor.username(), version)) {
-            return "Lead";
-        } else if (censusInstance.project().isReviewer(contributor.username(), version)) {
-            return "Reviewer";
-        } else if (censusInstance.project().isCommitter(contributor.username(), version)) {
-            return "Committer";
-        } else if (censusInstance.project().isAuthor(contributor.username(), version)) {
-            return "Author";
+    private String quotedParent(ArchiveItem item, int quoteLevel) {
+        if (item.parent().isPresent() && quoteLevel > 0) {
+            var quotedParentBody = quotedParent(item.parent().get(), quoteLevel - 1);
+            if (!quotedParentBody.isBlank()) {
+                return quoteBody(quotedParentBody) + "\n> \n" + quoteBody(item.parent().get().body());
+            } else {
+                return quoteBody(item.parent().get().body());
+            }
         }
-        return "no project role";
+        return "";
     }
 
-    void addReview(Review review) {
-        var id = getMessageId(review);
-        if (existingIds.containsKey(getStableMessageId(id))) {
-            return;
-        }
-
-        // Default parent and subject
-        var parent = topCommentForHash(review.hash());
-        var subject = parent.subject();
-
-        var replyBody = ArchiveMessages.reviewCommentBody(review.body().orElse(""));
-
-        addReplyCommon(parent, review.reviewer(), subject, replyBody, id);
+    private Email findArchiveItemEmail(ArchiveItem item, List<Email> sentEmails, List<Email> newEmails) {
+        var uniqueItemId = getUniqueMessageId(item.id());
+        var stableItemId = getStableMessageId(uniqueItemId);
+        return Stream.concat(sentEmails.stream(), newEmails.stream())
+                     .filter(email -> getStableMessageId(email.id()).equals(stableItemId) ||
+                             (email.hasHeader("PR-Collapsed-IDs") && email.headerValue("PR-Collapsed-IDs").contains(stableItemId)))
+                     .findAny()
+                     .orElseThrow();
     }
 
-    void addReviewVerdict(Review review) {
-        var id = getMessageId(review);
-        if (existingIds.containsKey(getStableMessageId(id))) {
-            return;
-        }
-
-        var contributor = censusInstance.namespace().get(review.reviewer().id());
-        var isReviewer = contributor != null && censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
-
-        // Default parent and subject
-        var parent = topCommentForHash(review.hash());
-        var subject = parent.subject();
+    private EmailAddress getUniqueMessageId(String identifier) {
+        try {
+            var prSpecific = pr.repository().name().replace("/", ".") + "." + pr.id();
+            var digest = MessageDigest.getInstance("SHA-256");
+            digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
+            digest.update(identifier.getBytes(StandardCharsets.UTF_8));
+            var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
 
-        // Approvals by Reviewers get special treatment - post these as top-level comments
-        if (review.verdict() == Review.Verdict.APPROVED && isReviewer) {
-            approvalIds.add(id);
+            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + pr.repository().url().getHost());
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Cannot find SHA-256");
         }
-
-        var userName = contributor != null ? contributor.username() : review.reviewer().userName() + "@" + censusInstance.namespace().name();
-        var userRole = contributor != null ? projectRole(contributor) : "no OpenJDK username";
-        var replyBody = ArchiveMessages.reviewVerdictBody(review.body().orElse(""), review.verdict(), userName, userRole);
-
-        addReplyCommon(parent, review.reviewer(), subject, replyBody, id);
     }
 
-    void addReviewComment(ReviewComment reviewComment) {
-        var id = getMessageId(reviewComment);
-        if (existingIds.containsKey(getStableMessageId(id))) {
-            return;
-        }
-
-        var parent = parentForReviewComment(reviewComment);
-        var body = new StringBuilder();
+    private String getStableMessageId(EmailAddress uniqueMessageId) {
+        return uniqueMessageId.localPart().split("\\.")[0];
+    }
 
-        // Add some context to the first post
-        if (reviewComment.parent().isEmpty()) {
-            body.append(reviewComment.path()).append(" line ").append(reviewComment.line()).append(":\n\n");
-            try {
-                var contents = prInstance.pr().repository().fileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());
-                for (int i = Math.max(0, reviewComment.line() - 2); i < Math.min(contents.size(), reviewComment.line() + 1); ++i) {
-                    body.append("> ").append(i + 1).append(": ").append(contents.get(i)).append("\n");
+    List<Email> generateNewEmails(List<Email> sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole) {
+        var allItems = generateArchiveItems(sentEmails, localRepo, issueTracker, issuePrefix, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, webrevGenerator, webrevNotification);
+        var sentItemIds = sentItemIds(sentEmails);
+        var unsentItems = allItems.stream()
+                                  .filter(item -> !sentItemIds.contains(getStableMessageId(getUniqueMessageId(item.id()))))
+                                  .collect(Collectors.toList());
+
+        var combinedItems = collapsableItems(unsentItems);
+        var ret = new ArrayList<Email>();
+        for (var itemList : combinedItems) {
+            var body = new StringBuilder();
+            for (var item : itemList) {
+                if (body.length() > 0) {
+                    body.append("\n\n");
                 }
-                body.append("\n");
-            } catch (RuntimeException e) {
-                body.append("> (failed to retrieve contents of file, check the PR for context)\n");
+                body.append(item.body());
             }
-        }
-        body.append(reviewComment.body());
 
-        addReplyCommon(parent, reviewComment.author(), parent.subject(), body.toString(), id);
-    }
+            // All items have the same parent and author after collapsing -> should have the same header and footer
+            var firstItem = itemList.get(0);
+            var header = firstItem.header();
+            var quote = quotedParent(firstItem, 2);
+            if (!quote.isBlank()) {
+                quote = quote + "\n\n";
+            }
+            var footer = firstItem.footer();
 
-    List<Email> generatedEmails() {
-        var finalEmails = new ArrayList<Email>();
-        for (var email : generated) {
-            for (var approvalId : approvalIds) {
-                var collapsed = email.hasHeader("PR-Collapsed-IDs") ? email.headerValue("PR-Collapsed-IDs") + " " : "";
-                if (email.id().equals(approvalId) || collapsed.contains(getStableMessageId(approvalId))) {
-                    email = Email.reparent(topEmail(), email)
-                                 .subject("Re: [Approved] " + "RFR: " + prInstance.pr().title())
-                                 .build();
-                    break;
-                }
+            var combined = (header.isBlank() ? "" : header +  "\n\n") + quote + body.toString() + (footer.isBlank() ? "" : "\n\n-------------\n\n" + footer);
+
+            var emailBuilder = Email.create(firstItem.subject(), combined);
+            if (firstItem.parent().isPresent()) {
+                emailBuilder.reply(findArchiveItemEmail(firstItem.parent().get(), sentEmails, ret));
+            }
+            emailBuilder.sender(sender);
+            emailBuilder.author(hostUserToEmailAuthor.author(firstItem.author()));
+            emailBuilder.id(getUniqueMessageId(firstItem.id()));
+
+            var collapsedItems = itemList.stream()
+                                         .skip(1)
+                                         .map(item -> getStableMessageId(getUniqueMessageId(item.id())))
+                                         .collect(Collectors.toSet());
+            if (collapsedItems.size() > 0) {
+                emailBuilder.header("PR-Collapsed-IDs", String.join(" ", collapsedItems));
             }
-            finalEmails.add(email);
+            emailBuilder.headers(firstItem.extraHeaders());
+            var email = emailBuilder.build();
+            ret.add(email);
         }
 
-        return finalEmails;
+        return ret;
     }
 }
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevNotification.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevNotification.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevNotification.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.mlbridge;
+
+import java.net.URI;
+
+@FunctionalInterface
+interface WebrevNotification {
+    void notify(URI uri, int index, boolean isFull);
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevStorage.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevStorage.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevStorage.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/WebrevStorage.java
@@ -21,11 +21,11 @@
  * questions.
  */
 package org.openjdk.skara.bots.mlbridge;
 
 import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.forge.*;
 import org.openjdk.skara.network.URIBuilder;
 import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.webrev.Webrev;
 
 import java.io.*;
@@ -48,13 +48,13 @@
         this.storage = storage;
         storageRef = ref;
         this.author = author;
     }
 
-    private void generate(PullRequestInstance prInstance, Path folder, Hash base, Hash head) throws IOException {
+    private void generate(PullRequest pr, Repository localRepository, Path folder, Hash base, Hash head) throws IOException {
         Files.createDirectories(folder);
-        Webrev.repository(prInstance.localRepo()).output(folder)
+        Webrev.repository(localRepository).output(folder)
               .generate(base, head);
     }
 
     private void push(Repository localStorage, Path webrevFolder, String identifier) throws IOException {
         var batchIndex = new AtomicInteger();
@@ -103,25 +103,34 @@
         } catch (IOException io) {
             throw new RuntimeException(io);
         }
     }
 
-    URI createAndArchive(PullRequestInstance prInstance, Path scratchPath, Hash base, Hash head, String identifier) {
+    private URI createAndArchive(PullRequest pr, Repository localRepository, Path scratchPath, Hash base, Hash head, String identifier) {
         try {
             var localStorage = Repository.materialize(scratchPath, storage.url(),
                                                       "+" + storageRef + ":mlbridge_webrevs");
-            var relativeFolder = baseFolder.resolve(String.format("%s/webrev.%s", prInstance.id(), identifier));
+            var relativeFolder = baseFolder.resolve(String.format("%s/webrev.%s", pr.id(), identifier));
             var outputFolder = scratchPath.resolve(relativeFolder);
             // If a previous operation was interrupted there may be content here already - overwrite if so
             if (Files.exists(outputFolder)) {
                 clearDirectory(outputFolder);
             }
-            generate(prInstance, outputFolder, base, head);
+            generate(pr, localRepository, outputFolder, base, head);
             if (!localStorage.isClean()) {
-                push(localStorage, outputFolder, baseFolder.resolve(prInstance.id()).toString());
+                push(localStorage, outputFolder, baseFolder.resolve(pr.id()).toString());
             }
             return URIBuilder.base(baseUri).appendPath(relativeFolder.toString().replace('\\', '/')).build();
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
+
+    @FunctionalInterface
+    interface WebrevGenerator {
+        URI generate(Hash base, Hash head, String identifier);
+    }
+
+    WebrevGenerator generator(PullRequest pr, Repository localRepository, Path scratchPath) {
+        return (base, head, identifier) -> createAndArchive(pr, localRepository, scratchPath, base, head, identifier);
+    }
 }
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -549,17 +549,74 @@
 
             var replies = conversations.get(0).replies(mail);
             var thread3 = replies.get(2);
             assertEquals("Re: RFR: This is a pull request", thread3.subject());
             var thread4 = replies.get(3);
-            assertEquals("Re: [Approved] RFR: This is a pull request", thread4.subject());
+            assertEquals("Re: RFR: This is a pull request", thread4.subject());
             assertTrue(thread4.body().contains("Looks fine"));
             assertTrue(thread4.body().contains("The final review comment"));
             assertTrue(thread4.body().contains("Approved by integrationreviewer1 (Reviewer)"));
         }
     }
 
+    @Test
+    void commentThreadingSeparated(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var archiveFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var author = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+            var archive = credentials.getHostedRepository();
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addReviewer(reviewer.forge().currentUser().id())
+                                           .addAuthor(author.forge().currentUser().id());
+            var from = EmailAddress.from("test", "test@test.mail");
+            var mlBot = new MailingListBridgeBot(from, author, archive, "master", censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
+                                                 listServer.getArchive(),
+                                                 listServer.getSMTP(),
+                                                 archive, "webrev", Path.of("test"),
+                                                 URIBuilder.base("http://www.test.test/").build(),
+                                                 Set.of(), Map.of(),
+                                                 URIBuilder.base("http://issues.test/browse/").build(),
+                                                 Map.of(), Duration.ZERO);
+
+            // Populate the projects repository
+            var reviewFile = Path.of("reviewfile.txt");
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType(), reviewFile);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.url(), "master", true);
+            localRepo.push(masterHash, archive.url(), "webrev", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(archive, "master", "edit", "This is a pull request");
+            pr.setBody("This is now ready");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            // Make two file specific comments
+            var reviewPr = reviewer.pullRequest(pr.id());
+            var comment1 = reviewPr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review comment");
+            var comment2 = reviewPr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            pr.addReviewCommentReply(comment1, "I agree");
+            pr.addReviewCommentReply(comment2, "I don't agree");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            // Sanity check the archive
+            Repository.materialize(archiveFolder.path(), archive.url(), "master");
+            assertEquals(3, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+        }
+    }
+
     @Test
     void reviewContext(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory();
              var archiveFolder = new TemporaryDirectory();
@@ -799,11 +856,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the updated push
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
-            assertTrue(archiveContains(archiveFolder.path(), "additional changes"));
+            assertTrue(archiveContains(archiveFolder.path(), "1 additional commit"));
             assertTrue(archiveContains(archiveFolder.path(), "full.*/" + pr.id() + "/webrev.01"));
             assertTrue(archiveContains(archiveFolder.path(), "inc.*/" + pr.id() + "/webrev.00-01"));
             assertTrue(archiveContains(archiveFolder.path(), "Patch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fetch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fixing"));
@@ -920,11 +977,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the rebased push
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
-            assertTrue(archiveContains(archiveFolder.path(), "complete new set of changes"));
+            assertTrue(archiveContains(archiveFolder.path(), "updated with a new target base"));
             assertTrue(archiveContains(archiveFolder.path(), pr.id() + "/webrev.01"));
             assertFalse(archiveContains(archiveFolder.path(), "Incremental"));
             assertTrue(archiveContains(archiveFolder.path(), "Patch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fetch"));
             assertTrue(archiveContains(archiveFolder.path(), "Original msg"));
@@ -1094,11 +1151,11 @@
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
             assertEquals(1, archiveContainsCount(archiveFolder.path(), "Approved by "));
             if (author.forge().supportsReviewBody()) {
                 assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 2"));
             }
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Re: \\[Approved\\] RFR:"));
+            assertEquals(2, archiveContainsCount(archiveFolder.path(), "Re: RFR:"));
 
             // Yet another change
             reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 3");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/WebrevStorageTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/WebrevStorageTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/WebrevStorageTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/WebrevStorageTests.java
@@ -60,20 +60,21 @@
             var from = EmailAddress.from("test", "test@test.mail");
             var storage = new WebrevStorage(archive, "webrev", Path.of("test"),
                                             URIBuilder.base("http://www.test.test/").build(), from);
 
             var prFolder = tempFolder.path().resolve("pr");
-            var prInstance = new PullRequestInstance(prFolder, pr, URIBuilder.base("http://issues.test/browse/").build(), "TEST");
+            var prRepo = Repository.materialize(prFolder, pr.repository().url(), "edit");
             var scratchFolder = tempFolder.path().resolve("scratch");
-            storage.createAndArchive(prInstance, scratchFolder, masterHash, editHash, "00");
+            var generator = storage.generator(pr, prRepo, scratchFolder);
+            generator.generate(masterHash, editHash, "00");
 
             // Update the local repository and check that the webrev has been generated
             Repository.materialize(repoFolder, archive.url(), "webrev");
             assertTrue(Files.exists(repoFolder.resolve("test/" + pr.id() + "/webrev.00/index.html")));
 
             // Create it again - it will overwrite the previous one
-            storage.createAndArchive(prInstance, scratchFolder, masterHash, editHash, "00");
+            generator.generate(masterHash, editHash, "00");
             Repository.materialize(repoFolder, archive.url(), "webrev");
             assertTrue(Files.exists(repoFolder.resolve("test/" + pr.id() + "/webrev.00/index.html")));
         }
     }
 }
diff a/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java b/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
--- a/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
+++ b/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
@@ -45,10 +45,20 @@
     EmailBuilder(EmailAddress author, String subject, String body) {
         this(subject, body);
         author(author);
     }
 
+    public EmailBuilder reply(Email parent) {
+        var references = parent.id().toString();
+        if (parent.hasHeader("References")) {
+            references = parent.headerValue("References") + " " + references;
+        }
+        header("In-Reply-To", parent.id().toString());
+        header("References", references);
+        return this;
+    }
+
     public EmailBuilder author(EmailAddress author) {
         this.author = author;
         return this;
     }
 
diff a/forge/src/main/java/org/openjdk/skara/forge/Review.java b/forge/src/main/java/org/openjdk/skara/forge/Review.java
--- a/forge/src/main/java/org/openjdk/skara/forge/Review.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/Review.java
@@ -23,27 +23,34 @@
 package org.openjdk.skara.forge;
 
 import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.vcs.Hash;
 
+import java.time.ZonedDateTime;
 import java.util.Optional;
 
 public class Review {
+    private final ZonedDateTime createdAt;
     private final HostUser reviewer;
     private final Verdict verdict;
     private final Hash hash;
     private final int id;
     private final String body;
 
-    public Review(HostUser reviewer, Verdict verdict, Hash hash, int id, String body) {
+    public Review(ZonedDateTime createdAt, HostUser reviewer, Verdict verdict, Hash hash, int id, String body) {
+        this.createdAt = createdAt;
         this.reviewer = reviewer;
         this.verdict = verdict;
         this.hash = hash;
         this.id = id;
         this.body = body;
     }
 
+    public ZonedDateTime createdAt() {
+        return createdAt;
+    }
+
     public HostUser reviewer() {
         return reviewer;
     }
 
     public Verdict verdict() {
diff a/forge/src/main/java/org/openjdk/skara/forge/ReviewComment.java b/forge/src/main/java/org/openjdk/skara/forge/ReviewComment.java
--- a/forge/src/main/java/org/openjdk/skara/forge/ReviewComment.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/ReviewComment.java
@@ -25,11 +25,11 @@
 import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
 import org.openjdk.skara.vcs.Hash;
 
 import java.time.ZonedDateTime;
-import java.util.Optional;
+import java.util.*;
 
 public class ReviewComment extends Comment {
     private final ReviewComment parent;
     private final String threadId;
     private final Hash hash;
@@ -63,6 +63,30 @@
     }
 
     public String threadId() {
         return threadId;
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if (!super.equals(o)) {
+            return false;
+        }
+        ReviewComment that = (ReviewComment) o;
+        return line == that.line &&
+                Objects.equals(parent, that.parent) &&
+                threadId.equals(that.threadId) &&
+                hash.equals(that.hash) &&
+                path.equals(that.path);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), parent, threadId, hash, path, line);
+    }
 }
diff a/forge/src/main/java/org/openjdk/skara/forge/github/GitHubPullRequest.java b/forge/src/main/java/org/openjdk/skara/forge/github/GitHubPullRequest.java
--- a/forge/src/main/java/org/openjdk/skara/forge/github/GitHubPullRequest.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/github/GitHubPullRequest.java
@@ -90,11 +90,12 @@
                                          verdict = Review.Verdict.NONE;
                                          break;
                                  }
                                  var id = obj.get("id").asInt();
                                  var body = obj.get("body").asString();
-                                 return new Review(reviewer, verdict, hash, id, body);
+                                 var createdAt = ZonedDateTime.parse(obj.get("submitted_at").asString());
+                                 return new Review(createdAt, reviewer, verdict, hash, id, body);
                              })
                              .collect(Collectors.toList());
         return reviews;
     }
 
diff a/forge/src/main/java/org/openjdk/skara/forge/gitlab/GitLabMergeRequest.java b/forge/src/main/java/org/openjdk/skara/forge/gitlab/GitLabMergeRequest.java
--- a/forge/src/main/java/org/openjdk/skara/forge/gitlab/GitLabMergeRequest.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/gitlab/GitLabMergeRequest.java
@@ -121,11 +121,11 @@
                               if (createdAt.isAfter(cd.date)) {
                                   hash = cd.hash;
                               }
                           }
                           var id = obj.get("id").asInt();
-                          return new Review(reviewer, verdict, hash, id, null);
+                          return new Review(createdAt, reviewer, verdict, hash, id, null);
                       })
                       .collect(Collectors.toList());
     }
 
     @Override
diff a/issuetracker/src/main/java/org/openjdk/skara/issuetracker/Comment.java b/issuetracker/src/main/java/org/openjdk/skara/issuetracker/Comment.java
--- a/issuetracker/src/main/java/org/openjdk/skara/issuetracker/Comment.java
+++ b/issuetracker/src/main/java/org/openjdk/skara/issuetracker/Comment.java
@@ -23,10 +23,11 @@
 package org.openjdk.skara.issuetracker;
 
 import org.openjdk.skara.host.HostUser;
 
 import java.time.ZonedDateTime;
+import java.util.Objects;
 
 public class Comment {
     private final String id;
     private final String body;
     private final HostUser author;
@@ -58,6 +59,27 @@
     }
 
     public ZonedDateTime updatedAt() {
         return updatedAt;
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        Comment comment = (Comment) o;
+        return id.equals(comment.id) &&
+                body.equals(comment.body) &&
+                author.equals(comment.author) &&
+                createdAt.equals(comment.createdAt) &&
+                updatedAt.equals(comment.updatedAt);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, body, author, createdAt, updatedAt);
+    }
 }
diff a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
--- a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
+++ b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
@@ -89,11 +89,11 @@
     }
 
     @Override
     public void addReview(Review.Verdict verdict, String body) {
         try {
-            var review = new Review(repository.forge().currentUser(),
+            var review = new Review(ZonedDateTime.now(), repository.forge().currentUser(),
                                     verdict, repository.localRepository().resolve(sourceRef).orElseThrow(),
                                     data.reviews.size(),
                                     body);
 
             data.reviews.add(review);
