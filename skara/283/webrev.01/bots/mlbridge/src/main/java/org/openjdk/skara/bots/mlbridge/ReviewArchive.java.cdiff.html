<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArchiveWorkItem.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WebrevStorage.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,409 ***</span>
  package org.openjdk.skara.bots.mlbridge;
  
<span class="line-removed">- import org.openjdk.skara.census.Contributor;</span>
  import org.openjdk.skara.email.*;
  import org.openjdk.skara.forge.*;
<span class="line-modified">! import org.openjdk.skara.host.*;</span>
  import org.openjdk.skara.issuetracker.Comment;
<span class="line-modified">! import org.openjdk.skara.vcs.Hash;</span>
  
  import java.net.URI;
  import java.nio.charset.StandardCharsets;
  import java.security.*;
  import java.util.*;
  import java.util.stream.*;
  
  class ReviewArchive {
<span class="line-modified">!     private final PullRequestInstance prInstance;</span>
<span class="line-removed">-     private final CensusInstance censusInstance;</span>
      private final EmailAddress sender;
<span class="line-modified">!     private final List&lt;Email&gt; existing;</span>
<span class="line-modified">!     private final Map&lt;String, Email&gt; existingIds = new HashMap&lt;&gt;();</span>
<span class="line-removed">-     private final List&lt;Email&gt; generated = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-     private final Map&lt;String, Email&gt; generatedIds = new HashMap&lt;&gt;();</span>
<span class="line-removed">-     private final Set&lt;EmailAddress&gt; approvalIds = new HashSet&lt;&gt;();</span>
<span class="line-removed">-     private final List&lt;Hash&gt; reportedHeads;</span>
<span class="line-removed">-     private final List&lt;Hash&gt; reportedBases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private EmailAddress getAuthorAddress(HostUser originalAuthor) {</span>
<span class="line-removed">-         var contributor = censusInstance.namespace().get(originalAuthor.id());</span>
<span class="line-removed">-         if (contributor == null) {</span>
<span class="line-removed">-             return EmailAddress.from(originalAuthor.fullName(),</span>
<span class="line-removed">-                                      censusInstance.namespace().name() + &quot;+&quot; +</span>
<span class="line-removed">-                                              originalAuthor.id() + &quot;+&quot; + originalAuthor.userName() + &quot;@&quot; +</span>
<span class="line-removed">-                                              censusInstance.configuration().census().domain());</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return EmailAddress.from(contributor.fullName().orElse(originalAuthor.fullName()),</span>
<span class="line-removed">-                                      contributor.username() + &quot;@&quot; + censusInstance.configuration().census().domain());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private EmailAddress getUniqueMessageId(String identifier) {</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             var prSpecific = prInstance.pr().repository().name().replace(&quot;/&quot;, &quot;.&quot;) + &quot;.&quot; + prInstance.id();</span>
<span class="line-removed">-             var digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="line-removed">-             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));</span>
<span class="line-removed">-             digest.update(identifier.getBytes(StandardCharsets.UTF_8));</span>
<span class="line-removed">-             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return EmailAddress.from(encodedCommon + &quot;.&quot; + UUID.randomUUID() + &quot;@&quot; + prInstance.pr().repository().url().getHost());</span>
<span class="line-removed">-         } catch (NoSuchAlgorithmException e) {</span>
<span class="line-removed">-             throw new RuntimeException(&quot;Cannot find SHA-256&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private EmailAddress getMessageId() {</span>
<span class="line-removed">-         return getUniqueMessageId(&quot;fc&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private EmailAddress getMessageId(Comment comment) {</span>
<span class="line-removed">-         return getUniqueMessageId(&quot;pc&quot; + comment.id());</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     private EmailAddress getMessageId(ReviewComment comment) {</span>
<span class="line-modified">!         return getUniqueMessageId(&quot;rc&quot; + comment.id());</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private EmailAddress getMessageId(Hash hash) {</span>
<span class="line-modified">!         return getUniqueMessageId(&quot;ha&quot; + hash.hex());</span>
      }
  
<span class="line-modified">!     private EmailAddress getMessageId(Review review) {</span>
<span class="line-modified">!         return getUniqueMessageId(&quot;rv&quot; + review.id());</span>
      }
  
<span class="line-modified">!     private String getStableMessageId(EmailAddress uniqueMessageId) {</span>
<span class="line-modified">!         return uniqueMessageId.localPart().split(&quot;\\.&quot;)[0];</span>
      }
  
<span class="line-modified">!     private Set&lt;String&gt; getStableMessageIds(Email email) {</span>
<span class="line-modified">!         var ret = new HashSet&lt;String&gt;();</span>
<span class="line-modified">!         ret.add(getStableMessageId(email.id()));</span>
<span class="line-modified">!         if (email.hasHeader(&quot;PR-Collapsed-IDs&quot;)) {</span>
<span class="line-modified">!             var additional = email.headerValue(&quot;PR-Collapsed-IDs&quot;).split(&quot; &quot;);</span>
<span class="line-modified">!             ret.addAll(Arrays.asList(additional));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return ret;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private Email topEmail() {</span>
<span class="line-modified">!         if (!existing.isEmpty()) {</span>
<span class="line-modified">!             return existing.get(0);</span>
          }
<span class="line-removed">-         return generated.get(0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Returns a suitable parent to use for a general comment</span>
<span class="line-removed">-     private Email latestGeneralComment() {</span>
<span class="line-removed">-         return Stream.concat(existing.stream(), generated.stream())</span>
<span class="line-removed">-                      .filter(email -&gt; !email.hasHeader(&quot;PR-Head-Hash&quot;))</span>
<span class="line-removed">-                      .filter(email -&gt; email.subject().startsWith(&quot;Re: RFR&quot;))</span>
<span class="line-removed">-                      .max(Comparator.comparingInt(email -&gt; Integer.parseInt(email.headerValue(&quot;PR-Sequence&quot;))))</span>
<span class="line-removed">-                      .orElse(topEmail());</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Returns the top-level comment for a certain head hash</span>
<span class="line-modified">!     private Email topCommentForHash(Hash hash) {</span>
<span class="line-modified">!         return Stream.concat(existing.stream(), generated.stream())</span>
<span class="line-modified">!                      .filter(email -&gt; email.hasHeader(&quot;PR-Head-Hash&quot;))</span>
<span class="line-modified">!                      .filter(email -&gt; email.headerValue(&quot;PR-Head-Hash&quot;).equals(hash.hex()))</span>
<span class="line-removed">-                      .findFirst()</span>
<span class="line-removed">-                      .orElse(topEmail());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private Email parentForReviewComment(ReviewComment reviewComment) {</span>
<span class="line-removed">-         var parent = topCommentForHash(reviewComment.hash());</span>
<span class="line-removed">-         if (reviewComment.parent().isPresent()) {</span>
<span class="line-removed">-             var parentId = getStableMessageId(getMessageId(reviewComment.parent().get()));</span>
<span class="line-removed">-             var last = Stream.concat(existing.stream(), generated.stream())</span>
<span class="line-removed">-                              .filter(email -&gt; (email.hasHeader(&quot;References&quot;) &amp;&amp; email.headerValue(&quot;References&quot;).contains(parentId)) ||</span>
<span class="line-removed">-                                      (getStableMessageId(email.id()).equals(parentId)) ||</span>
<span class="line-removed">-                                      (email.hasHeader(&quot;PR-Collapsed-IDs&quot;) &amp;&amp; email.headerValue(&quot;PR-Collapsed-IDs&quot;).contains(parentId)))</span>
<span class="line-removed">-                              .max(Comparator.comparingInt(email -&gt; Integer.parseInt(email.headerValue(&quot;PR-Sequence&quot;))));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (last.isEmpty()) {</span>
<span class="line-removed">-                 throw new RuntimeException(&quot;Failed to find parent&quot;);</span>
              } else {
<span class="line-modified">!                 return last.get();</span>
              }
          }
<span class="line-removed">-         return parent;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     ReviewArchive(EmailAddress sender, PullRequestInstance prInstance, CensusInstance censusInstance, List&lt;Email&gt; sentMails) {</span>
<span class="line-modified">!         this.sender = sender;</span>
<span class="line-modified">!         this.prInstance = prInstance;</span>
<span class="line-modified">!         this.censusInstance = censusInstance;</span>
<span class="line-modified">! </span>
<span class="line-removed">-         existing = sentMails;</span>
<span class="line-removed">-         for (var email : existing) {</span>
<span class="line-removed">-             var stableIds = getStableMessageIds(email);</span>
<span class="line-removed">-             for (var stableId : stableIds) {</span>
<span class="line-removed">-                 existingIds.put(stableId, email);</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         // Determine the latest hashes reported</span>
<span class="line-modified">!         reportedHeads = existing.stream()</span>
<span class="line-modified">!                                 .filter(email -&gt; email.hasHeader(&quot;PR-Head-Hash&quot;))</span>
<span class="line-modified">!                                 .map(email -&gt; email.headerValue(&quot;PR-Head-Hash&quot;))</span>
<span class="line-removed">-                                 .map(Hash::new)</span>
<span class="line-removed">-                                 .collect(Collectors.toList());</span>
<span class="line-removed">-         reportedBases = existing.stream()</span>
<span class="line-removed">-                                 .filter(email -&gt; email.hasHeader(&quot;PR-Base-Hash&quot;))</span>
<span class="line-removed">-                                 .map(email -&gt; email.headerValue(&quot;PR-Base-Hash&quot;))</span>
<span class="line-removed">-                                 .map(Hash::new)</span>
<span class="line-removed">-                                 .collect(Collectors.toList());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Hash latestHead() {</span>
<span class="line-removed">-         if (reportedHeads.isEmpty()) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;No head reported yet&quot;);</span>
          }
<span class="line-modified">!         return reportedHeads.get(reportedHeads.size() - 1);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Hash latestBase() {</span>
<span class="line-modified">!         if (reportedBases.isEmpty()) {</span>
<span class="line-removed">-             throw new IllegalArgumentException(&quot;No base reported yet&quot;);</span>
          }
<span class="line-removed">-         return reportedBases.get(reportedBases.size() - 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int revisionCount() {</span>
<span class="line-removed">-         return reportedHeads.size();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void create(URI webrev) {</span>
<span class="line-removed">-         var body = ArchiveMessages.composeConversation(prInstance, webrev);</span>
<span class="line-removed">-         var id = getMessageId();</span>
<span class="line-removed">-         var email = Email.create(&quot;RFR: &quot; + prInstance.pr().title(), body)</span>
<span class="line-removed">-                          .sender(sender)</span>
<span class="line-removed">-                          .author(getAuthorAddress(prInstance.pr().author()))</span>
<span class="line-removed">-                          .id(id)</span>
<span class="line-removed">-                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())</span>
<span class="line-removed">-                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())</span>
<span class="line-removed">-                          .build();</span>
<span class="line-removed">-         generated.add(email);</span>
<span class="line-removed">-         generatedIds.put(getStableMessageId(id), email);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     private String latestHeadPrefix() {</span>
<span class="line-removed">-         return String.format(&quot;[Rev %02d]&quot;, revisionCount());</span>
      }
  
<span class="line-modified">!     void addFull(URI webrev) {</span>
<span class="line-modified">!         var body = ArchiveMessages.composeRebaseComment(prInstance, webrev);</span>
<span class="line-modified">!         var id = getMessageId(prInstance.headHash());</span>
<span class="line-modified">!         var parent = topEmail();</span>
<span class="line-modified">!         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().title(), body)</span>
<span class="line-modified">!                          .sender(sender)</span>
<span class="line-modified">!                          .author(getAuthorAddress(prInstance.pr().author()))</span>
<span class="line-modified">!                          .recipient(parent.author())</span>
<span class="line-removed">-                          .id(id)</span>
<span class="line-removed">-                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())</span>
<span class="line-removed">-                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())</span>
<span class="line-removed">-                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))</span>
<span class="line-removed">-                          .build();</span>
<span class="line-removed">-         generated.add(email);</span>
<span class="line-removed">-         generatedIds.put(getStableMessageId(id), email);</span>
      }
  
<span class="line-modified">!     void addIncremental(URI fullWebrev, URI incrementalWebrev) {</span>
<span class="line-modified">!         var body = ArchiveMessages.composeIncrementalComment(latestHead(), prInstance, fullWebrev, incrementalWebrev);</span>
<span class="line-modified">!         var id = getMessageId(prInstance.headHash());</span>
<span class="line-modified">!         var parent = topEmail();</span>
<span class="line-modified">!         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().title(), body)</span>
<span class="line-modified">!                          .sender(sender)</span>
<span class="line-removed">-                          .author(getAuthorAddress(prInstance.pr().author()))</span>
<span class="line-removed">-                          .recipient(parent.author())</span>
<span class="line-removed">-                          .id(id)</span>
<span class="line-removed">-                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())</span>
<span class="line-removed">-                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())</span>
<span class="line-removed">-                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))</span>
<span class="line-removed">-                          .build();</span>
<span class="line-removed">-         generated.add(email);</span>
<span class="line-removed">-         generatedIds.put(getStableMessageId(id), email);</span>
      }
  
<span class="line-modified">!     private Optional&lt;Email&gt; findCollapsable(Email parent, HostUser author, String subject) {</span>
<span class="line-modified">!         var parentId = getStableMessageId(parent.id());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Is it a self-reply?</span>
<span class="line-modified">!         if (parent.author().equals(getAuthorAddress(author)) &amp;&amp; generatedIds.containsKey(parentId)) {</span>
<span class="line-modified">!             // But avoid extending top-level parents</span>
<span class="line-modified">!             if (!parent.hasHeader(&quot;PR-Head-Hash&quot;)) {</span>
<span class="line-modified">!                 // And only collapse identical subjects</span>
<span class="line-removed">-                 if (parent.subject().equals(subject)) {</span>
<span class="line-removed">-                     return Optional.of(parent);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Have we already replied to the same parent?</span>
<span class="line-removed">-         for (var candidate : generated) {</span>
<span class="line-removed">-             if (!candidate.hasHeader(&quot;In-Reply-To&quot;)) {</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             var inReplyTo = EmailAddress.parse(candidate.headerValue(&quot;In-Reply-To&quot;));</span>
<span class="line-removed">-             var candidateParentId = getStableMessageId(inReplyTo);</span>
<span class="line-removed">-             if (candidateParentId.equals(parentId) &amp;&amp; candidate.author().equals(getAuthorAddress(author))) {</span>
<span class="line-removed">-                 // Only collapse identical subjects</span>
<span class="line-removed">-                 if (candidate.subject().equals(subject)) {</span>
<span class="line-removed">-                     return Optional.of(candidate);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         return Optional.empty();</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void addReplyCommon(Email parent, HostUser author, String subject, String body, EmailAddress id) {</span>
<span class="line-removed">-         if (!subject.startsWith(&quot;Re: &quot;)) {</span>
<span class="line-removed">-             subject = &quot;Re: &quot; + subject;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         // Collapse self-replies and replies-to-same that have been created in this run</span>
<span class="line-modified">!         var collapsable = findCollapsable(parent, author, subject);</span>
<span class="line-removed">-         if (collapsable.isPresent()) {</span>
<span class="line-removed">-             // Drop the parent</span>
<span class="line-removed">-             var parentEmail = collapsable.get();</span>
<span class="line-removed">-             generated.remove(parentEmail);</span>
<span class="line-removed">-             generatedIds.remove(getStableMessageId(parentEmail.id()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-             var collapsed = parentEmail.hasHeader(&quot;PR-Collapsed-IDs&quot;) ? parentEmail.headerValue(&quot;PR-Collapsed-IDs&quot;) + &quot; &quot; : &quot;&quot;;</span>
<span class="line-removed">-             collapsed += getStableMessageId(parentEmail.id());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             var reply = ArchiveMessages.composeCombinedReply(parentEmail, body, prInstance);</span>
<span class="line-removed">-             var email = Email.from(parentEmail)</span>
<span class="line-removed">-                              .body(reply)</span>
<span class="line-removed">-                              .subject(subject)</span>
<span class="line-removed">-                              .id(id)</span>
<span class="line-removed">-                              .header(&quot;PR-Collapsed-IDs&quot;, collapsed)</span>
<span class="line-removed">-                              .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))</span>
<span class="line-removed">-                              .build();</span>
<span class="line-removed">-             generated.add(email);</span>
<span class="line-removed">-             generatedIds.put(getStableMessageId(id), email);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             var reply = ArchiveMessages.composeReply(parent, body, prInstance);</span>
<span class="line-removed">-             var email = Email.reply(parent, subject, reply)</span>
<span class="line-removed">-                              .sender(sender)</span>
<span class="line-removed">-                              .author(getAuthorAddress(author))</span>
<span class="line-removed">-                              .recipient(parent.author())</span>
<span class="line-removed">-                              .id(id)</span>
<span class="line-removed">-                              .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))</span>
<span class="line-removed">-                              .build();</span>
<span class="line-removed">-             generated.add(email);</span>
<span class="line-removed">-             generatedIds.put(getStableMessageId(id), email);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     void addComment(Comment comment) {</span>
<span class="line-modified">!         var id = getMessageId(comment);</span>
<span class="line-modified">!         if (existingIds.containsKey(getStableMessageId(id))) {</span>
<span class="line-modified">!             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         var parent = latestGeneralComment();</span>
<span class="line-removed">-         addReplyCommon(parent, comment.author(), &quot;Re: RFR: &quot; + prInstance.pr().title(), comment.body(), id);</span>
      }
  
<span class="line-modified">!     private String projectRole(Contributor contributor) {</span>
<span class="line-modified">!         var version = censusInstance.configuration().census().version();</span>
<span class="line-modified">!         if (censusInstance.project().isLead(contributor.username(), version)) {</span>
<span class="line-modified">!             return &quot;Lead&quot;;</span>
<span class="line-modified">!         } else if (censusInstance.project().isReviewer(contributor.username(), version)) {</span>
<span class="line-modified">!             return &quot;Reviewer&quot;;</span>
<span class="line-modified">!         } else if (censusInstance.project().isCommitter(contributor.username(), version)) {</span>
<span class="line-modified">!             return &quot;Committer&quot;;</span>
<span class="line-removed">-         } else if (censusInstance.project().isAuthor(contributor.username(), version)) {</span>
<span class="line-removed">-             return &quot;Author&quot;;</span>
          }
<span class="line-modified">!         return &quot;no project role&quot;;</span>
      }
  
<span class="line-modified">!     void addReview(Review review) {</span>
<span class="line-modified">!         var id = getMessageId(review);</span>
<span class="line-modified">!         if (existingIds.containsKey(getStableMessageId(id))) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Default parent and subject</span>
<span class="line-modified">!         var parent = topCommentForHash(review.hash());</span>
<span class="line-removed">-         var subject = parent.subject();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         var replyBody = ArchiveMessages.reviewCommentBody(review.body().orElse(&quot;&quot;));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         addReplyCommon(parent, review.reviewer(), subject, replyBody, id);</span>
      }
  
<span class="line-modified">!     void addReviewVerdict(Review review) {</span>
<span class="line-modified">!         var id = getMessageId(review);</span>
<span class="line-modified">!         if (existingIds.containsKey(getStableMessageId(id))) {</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         var contributor = censusInstance.namespace().get(review.reviewer().id());</span>
<span class="line-removed">-         var isReviewer = contributor != null &amp;&amp; censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Default parent and subject</span>
<span class="line-removed">-         var parent = topCommentForHash(review.hash());</span>
<span class="line-removed">-         var subject = parent.subject();</span>
  
<span class="line-modified">!         // Approvals by Reviewers get special treatment - post these as top-level comments</span>
<span class="line-modified">!         if (review.verdict() == Review.Verdict.APPROVED &amp;&amp; isReviewer) {</span>
<span class="line-modified">!             approvalIds.add(id);</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         var userName = contributor != null ? contributor.username() : review.reviewer().userName() + &quot;@&quot; + censusInstance.namespace().name();</span>
<span class="line-removed">-         var userRole = contributor != null ? projectRole(contributor) : &quot;no OpenJDK username&quot;;</span>
<span class="line-removed">-         var replyBody = ArchiveMessages.reviewVerdictBody(review.body().orElse(&quot;&quot;), review.verdict(), userName, userRole);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         addReplyCommon(parent, review.reviewer(), subject, replyBody, id);</span>
      }
  
<span class="line-modified">!     void addReviewComment(ReviewComment reviewComment) {</span>
<span class="line-modified">!         var id = getMessageId(reviewComment);</span>
<span class="line-modified">!         if (existingIds.containsKey(getStableMessageId(id))) {</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         var parent = parentForReviewComment(reviewComment);</span>
<span class="line-removed">-         var body = new StringBuilder();</span>
  
<span class="line-modified">!         // Add some context to the first post</span>
<span class="line-modified">!         if (reviewComment.parent().isEmpty()) {</span>
<span class="line-modified">!             body.append(reviewComment.path()).append(&quot; line &quot;).append(reviewComment.line()).append(&quot;:\n\n&quot;);</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 var contents = prInstance.pr().repository().fileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());</span>
<span class="line-modified">!                 for (int i = Math.max(0, reviewComment.line() - 2); i &lt; Math.min(contents.size(), reviewComment.line() + 1); ++i) {</span>
<span class="line-modified">!                     body.append(&quot;&gt; &quot;).append(i + 1).append(&quot;: &quot;).append(contents.get(i)).append(&quot;\n&quot;);</span>
                  }
<span class="line-modified">!                 body.append(&quot;\n&quot;);</span>
<span class="line-removed">-             } catch (RuntimeException e) {</span>
<span class="line-removed">-                 body.append(&quot;&gt; (failed to retrieve contents of file, check the PR for context)\n&quot;);</span>
              }
<span class="line-removed">-         }</span>
<span class="line-removed">-         body.append(reviewComment.body());</span>
  
<span class="line-modified">!         addReplyCommon(parent, reviewComment.author(), parent.subject(), body.toString(), id);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     List&lt;Email&gt; generatedEmails() {</span>
<span class="line-modified">!         var finalEmails = new ArrayList&lt;Email&gt;();</span>
<span class="line-modified">!         for (var email : generated) {</span>
<span class="line-modified">!             for (var approvalId : approvalIds) {</span>
<span class="line-modified">!                 var collapsed = email.hasHeader(&quot;PR-Collapsed-IDs&quot;) ? email.headerValue(&quot;PR-Collapsed-IDs&quot;) + &quot; &quot; : &quot;&quot;;</span>
<span class="line-modified">!                 if (email.id().equals(approvalId) || collapsed.contains(getStableMessageId(approvalId))) {</span>
<span class="line-modified">!                     email = Email.reparent(topEmail(), email)</span>
<span class="line-modified">!                                  .subject(&quot;Re: [Approved] &quot; + &quot;RFR: &quot; + prInstance.pr().title())</span>
<span class="line-modified">!                                  .build();</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
              }
<span class="line-modified">!             finalEmails.add(email);</span>
          }
  
<span class="line-modified">!         return finalEmails;</span>
      }
  }
<span class="line-new-header">--- 1,244 ---</span>
  package org.openjdk.skara.bots.mlbridge;
  
  import org.openjdk.skara.email.*;
  import org.openjdk.skara.forge.*;
<span class="line-modified">! import org.openjdk.skara.host.HostUser;</span>
  import org.openjdk.skara.issuetracker.Comment;
<span class="line-modified">! import org.openjdk.skara.vcs.*;</span>
  
  import java.net.URI;
  import java.nio.charset.StandardCharsets;
  import java.security.*;
  import java.util.*;
<span class="line-added">+ import java.util.regex.Pattern;</span>
  import java.util.stream.*;
  
  class ReviewArchive {
<span class="line-modified">!     private final PullRequest pr;</span>
      private final EmailAddress sender;
<span class="line-modified">!     private final Hash base;</span>
<span class="line-modified">!     private final Hash head;</span>
  
<span class="line-modified">!     private final List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!     private final List&lt;Review&gt; reviews = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!     private final List&lt;ReviewComment&gt; reviewComments = new ArrayList&lt;&gt;();</span>
  
<span class="line-modified">!     ReviewArchive(PullRequest pr, EmailAddress sender, Hash base, Hash head) {</span>
<span class="line-modified">!         this.pr = pr;</span>
<span class="line-added">+         this.sender = sender;</span>
<span class="line-added">+         this.base = base;</span>
<span class="line-added">+         this.head = head;</span>
      }
  
<span class="line-modified">!     void addComment(Comment comment) {</span>
<span class="line-modified">!         comments.add(comment);</span>
      }
  
<span class="line-modified">!     void addReview(Review review) {</span>
<span class="line-modified">!         reviews.add(review);</span>
      }
  
<span class="line-modified">!     void addReviewComment(ReviewComment reviewComment) {</span>
<span class="line-modified">!         reviewComments.add(reviewComment);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Searches for a previous reply to a certain parent by a specific author</span>
<span class="line-modified">!     private Optional&lt;ArchiveItem&gt; findPreviousReplyBy(List&lt;ArchiveItem&gt; generated, HostUser author, ArchiveItem parent) {</span>
<span class="line-modified">!         return generated.stream()</span>
<span class="line-modified">!                         .filter(item -&gt; item.author().equals(author))</span>
<span class="line-modified">!                         .filter(item -&gt; item.parent().isPresent())</span>
<span class="line-added">+                         .filter(item -&gt; item.parent().get().equals(parent))</span>
<span class="line-added">+                         .findAny();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private List&lt;ArchiveItem&gt; generateArchiveItems(List&lt;Email&gt; sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification) {</span>
<span class="line-added">+         var generated = new ArrayList&lt;ArchiveItem&gt;();</span>
<span class="line-added">+         Hash lastBase = null;</span>
<span class="line-added">+         Hash lastHead = null;</span>
<span class="line-added">+         int revisionIndex = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Check existing generated mails to find which hashes have been previously reported</span>
<span class="line-added">+         for (var email : sentEmails) {</span>
<span class="line-added">+             if (email.hasHeader(&quot;PR-Base-Hash&quot;)) {</span>
<span class="line-added">+                 var curBase = new Hash(email.headerValue(&quot;PR-Base-Hash&quot;));</span>
<span class="line-added">+                 var curHead = new Hash(email.headerValue(&quot;PR-Head-Hash&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (generated.isEmpty()) {</span>
<span class="line-added">+                     var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, curBase, curHead);</span>
<span class="line-added">+                     generated.add(first);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0));</span>
<span class="line-added">+                     generated.add(revision);</span>
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 lastBase = curBase;</span>
<span class="line-modified">!                 lastHead = curHead;</span>
<span class="line-modified">!             }</span>
          }
  
<span class="line-modified">!         // Check if we&#39;re at a revision not previously reported</span>
<span class="line-modified">!         if (!base.equals(lastBase) || !head.equals(lastHead)) {</span>
<span class="line-modified">!             if (generated.isEmpty()) {</span>
<span class="line-modified">!                 var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, base, head);</span>
<span class="line-modified">!                 generated.add(first);</span>
              } else {
<span class="line-modified">!                 var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, lastBase, lastHead, base, head, ++revisionIndex, generated.get(0));</span>
<span class="line-added">+                 generated.add(revision);</span>
              }
          }
  
<span class="line-modified">!         // A review always have a revision mail as parent, so start with these</span>
<span class="line-modified">!         for (var review : reviews) {</span>
<span class="line-modified">!             var parent = ArchiveItem.findParent(generated, review);</span>
<span class="line-modified">!             var reply = ArchiveItem.from(pr, review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);</span>
<span class="line-modified">!             generated.add(reply);</span>
          }
<span class="line-modified">!         // Comments have either a comment or a review as parent, the eligible ones have been generated at this point</span>
<span class="line-modified">!         for (var comment : comments) {</span>
<span class="line-modified">!             var parent = ArchiveItem.findParent(generated, comment);</span>
<span class="line-modified">!             var reply = ArchiveItem.from(pr, comment, hostUserToEmailAuthor, parent);</span>
<span class="line-modified">!             generated.add(reply);</span>
          }
<span class="line-modified">!         // Finally, file specific comments should be seen after general review comments</span>
<span class="line-modified">!         for (var reviewComment : reviewComments) {</span>
<span class="line-modified">!             var parent = ArchiveItem.findParent(generated, reviewComments, reviewComment);</span>
<span class="line-modified">!             var reply = ArchiveItem.from(pr, reviewComment, hostUserToEmailAuthor, parent);</span>
<span class="line-modified">!             generated.add(reply);</span>
          }
  
<span class="line-modified">!         return generated;</span>
      }
  
<span class="line-modified">!     private Set&lt;String&gt; sentItemIds(List&lt;Email&gt; sentEmails) {</span>
<span class="line-modified">!         var primary = sentEmails.stream()</span>
<span class="line-modified">!                                 .map(email -&gt; getStableMessageId(email.id()));</span>
<span class="line-modified">!         var collapsed = sentEmails.stream()</span>
<span class="line-modified">!                                   .filter(email -&gt; email.hasHeader(&quot;PR-Collapsed-IDs&quot;))</span>
<span class="line-modified">!                                   .flatMap(email -&gt; Stream.of(email.headerValue(&quot;PR-Collapsed-IDs&quot;).split(&quot; &quot;)));</span>
<span class="line-modified">!         return Stream.concat(primary, collapsed)</span>
<span class="line-modified">!                      .collect(Collectors.toSet());</span>
      }
  
<span class="line-modified">!     // Group items that has the same author and the same parent</span>
<span class="line-modified">!     private List&lt;List&lt;ArchiveItem&gt;&gt; collapsableItems(List&lt;ArchiveItem&gt; items) {</span>
<span class="line-modified">!         var grouped = items.stream()</span>
<span class="line-modified">!                            .collect(Collectors.groupingBy(item -&gt; item.author().id() + &quot;.&quot; + (item.parent().isPresent() ? item.parent().get() : &quot;xxx&quot;),</span>
<span class="line-modified">!                                                           LinkedHashMap::new, Collectors.toList()));</span>
<span class="line-modified">!         return new ArrayList&lt;&gt;(grouped.values());</span>
      }
  
<span class="line-modified">!     private static final Pattern commentPattern = Pattern.compile(&quot;&lt;!--.*?--&gt;&quot;,</span>
<span class="line-modified">!                                                                   Pattern.DOTALL | Pattern.MULTILINE);</span>
<span class="line-modified">!     private static final Pattern cutoffPattern = Pattern.compile(&quot;(.*?)&lt;!-- Anything below this marker will be .*? --&gt;&quot;,</span>
<span class="line-modified">!                                                                  Pattern.DOTALL | Pattern.MULTILINE);</span>
<span class="line-modified">!     private static String filterComments(String body) {</span>
<span class="line-modified">!         var cutoffMatcher = cutoffPattern.matcher(body);</span>
<span class="line-modified">!         if (cutoffMatcher.find()) {</span>
<span class="line-modified">!             body = cutoffMatcher.group(1);</span>
          }
  
<span class="line-modified">!         var commentMatcher = commentPattern.matcher(body);</span>
<span class="line-modified">!         body = commentMatcher.replaceAll(&quot;&quot;);</span>
  
<span class="line-modified">!         body = MarkdownToText.removeFormatting(body);</span>
<span class="line-modified">!         return body.strip();</span>
      }
  
<span class="line-modified">!     private String quoteBody(String body) {</span>
<span class="line-modified">!         return Arrays.stream(body.strip().split(&quot;\\R&quot;))</span>
<span class="line-modified">!                      .map(line -&gt; line.length() &gt; 0 ? line.charAt(0) == &#39;&gt;&#39; ? &quot;&gt;&quot; + line : &quot;&gt; &quot; + line : &quot;&gt; &quot;)</span>
<span class="line-modified">!                      .collect(Collectors.joining(&quot;\n&quot;));</span>
      }
  
<span class="line-modified">!     private String quotedParent(ArchiveItem item, int quoteLevel) {</span>
<span class="line-modified">!         if (item.parent().isPresent() &amp;&amp; quoteLevel &gt; 0) {</span>
<span class="line-modified">!             var quotedParentBody = quotedParent(item.parent().get(), quoteLevel - 1);</span>
<span class="line-modified">!             if (!quotedParentBody.isBlank()) {</span>
<span class="line-modified">!                 return quoteBody(quotedParentBody) + &quot;\n&gt; \n&quot; + quoteBody(item.parent().get().body());</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 return quoteBody(item.parent().get().body());</span>
<span class="line-modified">!             }</span>
          }
<span class="line-modified">!         return &quot;&quot;;</span>
      }
  
<span class="line-modified">!     private Email findArchiveItemEmail(ArchiveItem item, List&lt;Email&gt; sentEmails, List&lt;Email&gt; newEmails) {</span>
<span class="line-modified">!         var uniqueItemId = getUniqueMessageId(item.id());</span>
<span class="line-modified">!         var stableItemId = getStableMessageId(uniqueItemId);</span>
<span class="line-modified">!         return Stream.concat(sentEmails.stream(), newEmails.stream())</span>
<span class="line-modified">!                      .filter(email -&gt; getStableMessageId(email.id()).equals(stableItemId) ||</span>
<span class="line-modified">!                              (email.hasHeader(&quot;PR-Collapsed-IDs&quot;) &amp;&amp; email.headerValue(&quot;PR-Collapsed-IDs&quot;).contains(stableItemId)))</span>
<span class="line-modified">!                      .findAny()</span>
<span class="line-modified">!                      .orElseThrow();</span>
      }
  
<span class="line-modified">!     private EmailAddress getUniqueMessageId(String identifier) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             var prSpecific = pr.repository().name().replace(&quot;/&quot;, &quot;.&quot;) + &quot;.&quot; + pr.id();</span>
<span class="line-modified">!             var digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="line-modified">!             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));</span>
<span class="line-modified">!             digest.update(identifier.getBytes(StandardCharsets.UTF_8));</span>
<span class="line-modified">!             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());</span>
  
<span class="line-modified">!             return EmailAddress.from(encodedCommon + &quot;.&quot; + UUID.randomUUID() + &quot;@&quot; + pr.repository().url().getHost());</span>
<span class="line-modified">!         } catch (NoSuchAlgorithmException e) {</span>
<span class="line-modified">!             throw new RuntimeException(&quot;Cannot find SHA-256&quot;);</span>
          }
      }
  
<span class="line-modified">!     private String getStableMessageId(EmailAddress uniqueMessageId) {</span>
<span class="line-modified">!         return uniqueMessageId.localPart().split(&quot;\\.&quot;)[0];</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     List&lt;Email&gt; generateNewEmails(List&lt;Email&gt; sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole) {</span>
<span class="line-modified">!         var allItems = generateArchiveItems(sentEmails, localRepo, issueTracker, issuePrefix, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, webrevGenerator, webrevNotification);</span>
<span class="line-modified">!         var sentItemIds = sentItemIds(sentEmails);</span>
<span class="line-modified">!         var unsentItems = allItems.stream()</span>
<span class="line-modified">!                                   .filter(item -&gt; !sentItemIds.contains(getStableMessageId(getUniqueMessageId(item.id()))))</span>
<span class="line-modified">!                                   .collect(Collectors.toList());</span>
<span class="line-modified">! </span>
<span class="line-added">+         var combinedItems = collapsableItems(unsentItems);</span>
<span class="line-added">+         var ret = new ArrayList&lt;Email&gt;();</span>
<span class="line-added">+         for (var itemList : combinedItems) {</span>
<span class="line-added">+             var body = new StringBuilder();</span>
<span class="line-added">+             for (var item : itemList) {</span>
<span class="line-added">+                 if (body.length() &gt; 0) {</span>
<span class="line-added">+                     body.append(&quot;\n\n&quot;);</span>
                  }
<span class="line-modified">!                 body.append(item.body());</span>
              }
  
<span class="line-modified">!             // All items have the same parent and author after collapsing -&gt; should have the same header and footer</span>
<span class="line-modified">!             var firstItem = itemList.get(0);</span>
<span class="line-added">+             var header = firstItem.header();</span>
<span class="line-added">+             var quote = quotedParent(firstItem, 2);</span>
<span class="line-added">+             if (!quote.isBlank()) {</span>
<span class="line-added">+                 quote = quote + &quot;\n\n&quot;;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             var footer = firstItem.footer();</span>
  
<span class="line-modified">!             var combined = (header.isBlank() ? &quot;&quot; : header +  &quot;\n\n&quot;) + quote + body.toString() + (footer.isBlank() ? &quot;&quot; : &quot;\n\n-------------\n\n&quot; + footer);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             var emailBuilder = Email.create(firstItem.subject(), combined);</span>
<span class="line-modified">!             if (firstItem.parent().isPresent()) {</span>
<span class="line-modified">!                 emailBuilder.reply(findArchiveItemEmail(firstItem.parent().get(), sentEmails, ret));</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             emailBuilder.sender(sender);</span>
<span class="line-modified">!             emailBuilder.author(hostUserToEmailAuthor.author(firstItem.author()));</span>
<span class="line-modified">!             emailBuilder.id(getUniqueMessageId(firstItem.id()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             var collapsedItems = itemList.stream()</span>
<span class="line-added">+                                          .skip(1)</span>
<span class="line-added">+                                          .map(item -&gt; getStableMessageId(getUniqueMessageId(item.id())))</span>
<span class="line-added">+                                          .collect(Collectors.toSet());</span>
<span class="line-added">+             if (collapsedItems.size() &gt; 0) {</span>
<span class="line-added">+                 emailBuilder.header(&quot;PR-Collapsed-IDs&quot;, String.join(&quot; &quot;, collapsedItems));</span>
              }
<span class="line-modified">!             emailBuilder.headers(firstItem.extraHeaders());</span>
<span class="line-added">+             var email = emailBuilder.build();</span>
<span class="line-added">+             ret.add(email);</span>
          }
  
<span class="line-modified">!         return ret;</span>
      }
  }
</pre>
<center><a href="ArchiveWorkItem.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WebrevStorage.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>