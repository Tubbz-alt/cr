<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.hg;
  24 
  25 import org.openjdk.skara.process.Process;
  26 import org.openjdk.skara.process.Execution;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.nio.file.*;
  32 import java.time.*;
  33 import java.time.format.DateTimeFormatter;
  34 import java.util.*;
  35 import java.util.logging.Logger;
  36 import java.util.stream.*;
  37 import java.net.URI;
  38 
  39 public class HgRepository implements Repository {
  40     private static final String EXT_PY = &quot;ext.py&quot;;
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.hg&quot;);
  43 
  44     private void copyResource(String name, Path p) throws IOException {
  45         Files.copy(this.getClass().getResourceAsStream(&quot;/&quot; + name), p, StandardCopyOption.REPLACE_EXISTING);
  46     }
  47 
  48     private java.lang.Process start(String... cmd) throws IOException {
  49         return start(Arrays.asList(cmd));
  50     }
  51 
  52     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  53         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  54         var pb = new ProcessBuilder(cmd);
  55         pb.directory(dir.toFile());
  56         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  57         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
  58         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
  59         return pb.start();
  60     }
  61 
  62     private static void stop(java.lang.Process p) throws IOException {
  63         if (p != null &amp;&amp; p.isAlive()) {
  64             var stream = p.getInputStream();
  65             var read = 0;
  66             var buf = new byte[128];
  67             while (read != -1) {
  68                 read = stream.read(buf);
  69             }
  70             try {
  71                 p.waitFor();
  72             } catch (InterruptedException e) {
  73                 throw new IOException(e);
  74             }
  75         }
  76     }
  77 
  78     private Execution capture(List&lt;String&gt; cmd) {
  79         return capture(cmd.toArray(new String[0]));
  80     }
  81 
  82     private Execution capture(String... cmd) {
  83         return capture(dir, cmd);
  84     }
  85 
  86     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  87         return capture(cwd, cmd.toArray(new String[0]));
  88     }
  89     private static Execution capture(Path cwd, String... cmd) {
  90         return Process.capture(cmd)
  91                       .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
  92                       .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
  93                       .workdir(cwd)
  94                       .execute();
  95     }
  96 
  97     private static Execution.Result await(Execution e) throws IOException {
  98         var result = e.await();
  99         if (result.status() != 0) {
 100             if (result.exception().isPresent()) {
 101                 throw new IOException(&quot;Unexpected exit code\n&quot; + result, result.exception().get());
 102             } else {
 103                 throw new IOException(&quot;Unexpected exit code\n&quot; + result);
 104             }
 105         }
 106         return result;
 107     }
 108 
 109     private static void await(java.lang.Process p) throws IOException {
 110         try {
 111             var res = p.waitFor();
 112             if (res != 0) {
 113                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 114             }
 115         } catch (InterruptedException e) {
 116             throw new IOException(e);
 117         }
 118     }
 119 
 120     public HgRepository(Path dir) {
 121         this.dir = dir.toAbsolutePath();
 122     }
 123 
 124     @Override
 125     public List&lt;Branch&gt; branches() throws IOException {
 126         try (var p = capture(&quot;hg&quot;, &quot;branches&quot;)) {
 127             return await(p).stdout()
 128                            .stream()
 129                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 130                            .map(Branch::new)
 131                            .collect(Collectors.toList());
 132         }
 133     }
 134 
 135     @Override
 136     public List&lt;Tag&gt; tags() throws IOException {
 137         try (var p = capture(&quot;hg&quot;, &quot;tags&quot;)) {
 138             return await(p).stdout()
 139                            .stream()
 140                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 141                            .map(Tag::new)
 142                            .collect(Collectors.toList());
 143         }
 144     }
 145 
 146     @Override
 147     public Path root() throws IOException {
 148         try (var p = capture(&quot;hg&quot;, &quot;root&quot;)) {
 149             var res = await(p);
 150             if (res.stdout().size() != 1) {
 151                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 152             }
 153             return Paths.get(res.stdout().get(0));
 154         }
 155     }
 156 
 157     private void checkout(String ref, boolean force) throws IOException {
 158         var cmd = new ArrayList&lt;String&gt;();
 159         cmd.addAll(List.of(&quot;hg&quot;, &quot;update&quot;));
 160         if (!force) {
 161             cmd.add(&quot;--check&quot;);
 162         }
 163         cmd.add(ref);
 164         try (var p = capture(cmd)) {
 165             await(p);
 166         }
 167     }
 168 
 169     @Override
 170     public void checkout(Hash h, boolean force) throws IOException {
 171         checkout(h.hex(), force);
 172     }
 173 
 174     @Override
 175     public void checkout(Branch b, boolean force) throws IOException {
 176         checkout(b.name(), force);
 177     }
 178 
 179     @Override
 180     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 181         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + ref, &quot;--template={node}\n&quot;)) {
 182             var res = p.await();
 183             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 184                 return Optional.of(new Hash(res.stdout().get(0)));
 185             }
 186             return Optional.empty();
 187         }
 188     }
 189 
 190     @Override
 191     public Commits commits() throws IOException {
 192         return commits(null, -1, false);
 193     }
 194 
 195     @Override
 196     public Commits commits(boolean reverse) throws IOException {
 197         return commits(null, -1, reverse);
 198     }
 199 
 200     @Override
 201     public Commits commits(int n) throws IOException {
 202         return commits(null, n, false);
 203     }
 204 
 205     @Override
 206     public Commits commits(int n, boolean reverse) throws IOException {
 207         return commits(null, n, reverse);
 208     }
 209 
 210     @Override
 211     public Commits commits(String range) throws IOException {
 212         return commits(range, -1, false);
 213     }
 214 
 215     @Override
 216     public Commits commits(String range, int n) throws IOException {
 217         return commits(range, n, false);
 218     }
 219 
 220     @Override
 221     public Commits commits(String range, boolean reverse) throws IOException {
 222         return commits(range, -1, reverse);
 223     }
 224 
 225     @Override
 226     public Commits commits(String range, int n,  boolean reverse) throws IOException {
 227         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 228         copyResource(EXT_PY, ext);
 229         return new HgCommits(dir, range, ext, reverse, n);
 230     }
 231 
 232     @Override
 233     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 234         var commits = commits(h.hex()).asList();
 235         if (commits.size() != 1) {
 236             return Optional.empty();
 237         }
 238         return Optional.of(commits.get(0));
 239     }
 240 
 241     @Override
 242     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 243         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 244         return lookup(hash);
 245     }
 246 
 247     @Override
 248     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 249         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 250         return lookup(hash);
 251     }
 252 
 253     @Override
 254     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 255         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 256         copyResource(EXT_PY, ext);
 257 
 258         var p = start(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.dump=&quot; + ext.toAbsolutePath().toString(), &quot;metadata&quot;);
 259         var reader = new UnixStreamReader(p.getInputStream());
 260         var result = new ArrayList&lt;CommitMetadata&gt;();
 261 
 262         var line = reader.readLine();
 263         while (line != null) {
 264             result.add(HgCommitMetadata.read(reader));
 265             line = reader.readLine();
 266         }
 267 
 268         await(p);
 269         return result;
 270     }
 271 
 272     @Override
 273     public boolean isEmpty() throws IOException {
 274         var numBranches = branches().size();
 275         var numTags = tags().size();
 276 
 277         if (numBranches &gt; 0 || numTags &gt; 1) {
 278             return false;
 279         }
 280 
 281         var tip = resolve(&quot;tip&quot;);
 282         return tip.isEmpty() || tip.get().hex().equals(&quot;0&quot;.repeat(40));
 283     }
 284 
 285     @Override
 286     public boolean isHealthy() throws IOException {
 287         var root = root().toString();
 288         return !(Files.exists(Path.of(root, &quot;.hg&quot;, &quot;wlock&quot;)) ||
 289                  Files.exists(Path.of(root, &quot;.hg&quot;, &quot;store&quot;, &quot;lock&quot;)));
 290     }
 291 
 292     @Override
 293     public void clean() throws IOException {
 294         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 295             p.await();
 296         }
 297 
 298         try (var p = capture(&quot;hg&quot;, &quot;recover&quot;)) {
 299             p.await();
 300         }
 301 
 302         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--ignored&quot;, &quot;--no-status&quot;)) {
 303             var root = root().toString();
 304             for (var filename : await(p).stdout()) {
 305                 Files.delete(Path.of(root, filename));
 306             }
 307         }
 308 
 309         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 310             var root = root().toString();
 311             for (var filename : await(p).stdout()) {
 312                 Files.delete(Path.of(root, filename));
 313             }
 314         }
 315 
 316         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;)) {
 317             await(p);
 318         }
 319     }
 320 
 321     @Override
 322     public void reset(Hash target, boolean hard) throws IOException {
 323         throw new RuntimeException(&quot;Not implemented yet&quot;);
 324     }
 325 
 326     @Override
 327     public Repository reinitialize() throws IOException {
 328         Files.walk(dir)
 329              .map(Path::toFile)
 330              .sorted(Comparator.reverseOrder())
 331              .forEach(File::delete);
 332 
 333         return init();
 334     }
 335 
 336     @Override
 337     public Hash fetch(URI uri, String refspec) throws IOException {
 338         var oldHeads = new HashSet&lt;Hash&gt;(heads());
 339 
 340         var cmd = new ArrayList&lt;String&gt;();
 341         cmd.add(&quot;hg&quot;);
 342         cmd.add(&quot;pull&quot;);
 343         if (refspec != null) {
 344             cmd.add(&quot;--rev&quot;);
 345             cmd.add(refspec);
 346         }
 347         if (uri != null) {
 348             cmd.add(uri.toString());
 349         }
 350         try (var p = capture(cmd)) {
 351             await(p);
 352         }
 353 
 354         var newHeads = new HashSet&lt;Hash&gt;(heads());
 355         newHeads.removeAll(oldHeads);
 356 
 357         if (newHeads.size() &gt; 1) {
 358             throw new IllegalStateException(&quot;fetching multiple heads is not supported&quot;);
 359         } else if (newHeads.size() == 0) {
 360             // no new head was fetched, return current head
 361             return head();
 362         }
 363         return newHeads.iterator().next();
 364     }
 365 
 366     @Override
 367     public void fetchAll() throws IOException {
 368         var pullPaths = new ArrayList&lt;URI&gt;();
 369         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
 370             var res = await(p);
 371             for (var line : res.stdout()) {
 372                 var parts = line.split(&quot;=&quot;);
 373                 var name = parts[0].trim();
 374                 var uri = parts[1].trim();
 375                 if (!name.endsWith(&quot;-push&quot;)) {
 376                     pullPaths.add(URI.create(uri));
 377                 }
 378             }
 379         }
 380 
 381         for (var uri : pullPaths) {
 382             fetch(uri, null);
 383         }
 384     }
 385 
 386     @Override
 387     public void delete(Branch b) throws IOException {
 388         throw new RuntimeException(&quot;Branches cannot be deleted in Mercurial&quot;);
 389     }
 390 
 391     @Override
 392     public Repository init() throws IOException {
 393         if (!Files.exists(dir)) {
 394             Files.createDirectories(dir);
 395         }
 396 
 397         try (var p = capture(&quot;hg&quot;, &quot;init&quot;)) {
 398             await(p);
 399             return this;
 400         }
 401     }
 402 
 403     @Override
 404     public void pushAll(URI uri) throws IOException {
 405         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--new-branch&quot;, uri.toString())) {
 406             await(p);
 407         }
 408     }
 409 
 410     @Override
 411     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 412         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;push&quot;, &quot;--rev=&quot; + hash.hex()));
 413         if (force) {
 414             cmd.add(&quot;--force&quot;);
 415         }
 416         cmd.add(uri.toString() + &quot;#&quot; + ref);
 417         try (var p = capture(cmd)) {
 418             await(p);
 419         }
 420     }
 421 
 422     @Override
 423     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 424         // ignore setUpstream, no such concept in Mercurial
 425         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--branch&quot;, branch.name(), remote)) {
 426             await(p);
 427         }
 428     }
 429 
 430     @Override
 431     public boolean isClean() throws IOException {
 432         try (var p = capture(&quot;hg&quot;, &quot;status&quot;)) {
 433             var output = await(p);
 434             return output.stdout().size() == 0;
 435         }
 436     }
 437 
 438     @Override
 439     public boolean exists() throws IOException {
 440         if (!Files.exists(dir)) {
 441             return false;
 442         }
 443 
 444         try {
 445             root();
 446             return true;
 447         } catch (IOException e) {
 448             return false;
 449         }
 450     }
 451 
 452     private void export(String revset, Path to) throws IOException {
 453         var cmd = List.of(&quot;hg&quot;, &quot;export&quot;, &quot;--git&quot;, &quot;--rev&quot;, revset);
 454         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
 455         var pb = new ProcessBuilder(cmd);
 456         pb.directory(dir.toFile());
 457         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
 458         pb.redirectOutput(to.toFile());
 459         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
 460         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
 461         var p = pb.start();
 462         try {
 463             await(p);
 464         } catch (Throwable t) {
 465             if (p.isAlive()) {
 466                 try {
 467                     p.waitFor();
 468                 } catch (InterruptedException e) {
 469                     throw new IOException(e);
 470                 }
 471             }
 472 
 473             throw new IOException(t);
 474         }
 475     }
 476 
 477     @Override
 478     public void squash(Hash h) throws IOException {
 479         var revset = &quot;.:&quot; + h.hex() + &quot; and not .&quot;;
 480         var patch = Files.createTempFile(&quot;squash&quot;, &quot;.patch&quot;);
 481         export(revset, patch);
 482 
 483         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.mq=&quot;, &quot;strip&quot;, &quot;--rev&quot;, revset)) {
 484             await(p);
 485         }
 486 
 487         try (var p = capture(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toString())) {
 488             await(p);
 489         }
 490     }
 491 
 492 
 493     @Override
 494     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 495         return commit(message, authorName, authorEmail, null);
 496     }
 497 
 498     @Override
 499     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 500         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 501         var cmd = new ArrayList&lt;String&gt;();
 502         cmd.addAll(List.of(&quot;hg&quot;, &quot;commit&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user));
 503         if (authorDate != null) {
 504             var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
 505             cmd.add(&quot;--date=&quot; + authorDate.format(formatter));
 506         }
 507         try (var p = capture(cmd)) {
 508             await(p);
 509         }
 510         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 511     }
 512 
 513     @Override
 514     public Hash commit(String message,
 515                        String authorName,
 516                        String authorEmail,
 517                        String committerName,
 518                        String committerEmail) throws IOException {
 519         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 520     }
 521 
 522     @Override
 523     public Hash commit(String message,
 524                        String authorName,
 525                        String authorEmail,
 526                        ZonedDateTime authorDate,
 527                        String committerName,
 528                        String committerEmail,
 529                        ZonedDateTime committerDate) throws IOException {
 530         if (!Objects.equals(authorName, committerName) ||
 531             !Objects.equals(authorEmail, committerEmail) ||
 532             !Objects.equals(authorDate, committerDate)) {
 533             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 534         }
 535 
 536         return commit(message, authorName, authorEmail, authorDate);
 537     }
 538 
 539     @Override
 540     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 541         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 542         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user)) {
 543             await(p);
 544         }
 545         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 546     }
 547 
 548     @Override
 549     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 550         if (!Objects.equals(authorName, committerName) ||
 551             !Objects.equals(authorEmail, committerEmail)) {
 552             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 553         }
 554 
 555         return amend(message, authorName, authorEmail);
 556     }
 557 
 558     @Override
 559     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 560         var user = authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 561         try (var p = capture(&quot;hg&quot;, &quot;tag&quot;,
 562                              &quot;--message&quot;, message,
 563                              &quot;--user&quot;, user,
 564                              &quot;--rev&quot;, hash.hex(),
 565                              name)) {
 566             await(p);
 567         }
 568 
 569         return new Tag(name);
 570     }
 571 
 572     @Override
 573     public Branch branch(Hash hash, String name) throws IOException {
 574         // Model a lightweight branch with a bookmark. Not ideal but the
 575         // closest to git branches.
 576         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--rev&quot;, hash.hex(), name)) {
 577             await(p);
 578         }
 579 
 580         return new Branch(name);
 581     }
 582 
 583     @Override
 584     public Hash mergeBase(Hash first, Hash second) throws IOException {
 585         var revset = &quot;ancestor(&quot; + first.hex() + &quot;, &quot; + second.hex() + &quot;)&quot;;
 586         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + revset, &quot;--template={node}\n&quot;)) {
 587             var res = await(p);
 588             if (res.stdout().size() != 1) {
 589                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 590             }
 591             return new Hash(res.stdout().get(0));
 592         }
 593     }
 594 
 595     @Override
 596     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 597         throw new RuntimeException(&quot;Not implemented yet&quot;);
 598     }
 599 
 600     @Override
 601     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 602         var current = currentBranch().name();
 603         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.rebase=&quot;,
 604                              &quot;rebase&quot;, &quot;--dest&quot;, hash.hex(), &quot;--base&quot;, current)) {
 605             await(p);
 606         }
 607     }
 608 
 609     @Override
 610     public Branch currentBranch() throws IOException {
 611         try (var p = capture(&quot;hg&quot;, &quot;branch&quot;)) {
 612             var res = await(p);
 613             if (res.stdout().size() != 1) {
 614                 throw new IllegalStateException(&quot;No current branch\n&quot; + res);
 615             }
 616             return new Branch(res.stdout().get(0));
 617         }
 618     }
 619 
 620     @Override
 621     public Branch defaultBranch() throws IOException {
 622         return new Branch(&quot;default&quot;);
 623     }
 624 
 625     @Override
 626     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 627         return Optional.of(new Tag(&quot;tip&quot;));
 628     }
 629 
 630     @Override
 631     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 632         var output = Files.createTempFile(&quot;hg-cat-rev-&quot; + hash.abbreviate(), &quot;.bin&quot;);
 633         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output, &quot;--rev=&quot; + hash.hex(), path.toString())) {
 634             var res = p.await();
 635             if (res.status() == 0 &amp;&amp; Files.exists(output)) {
 636                 var bytes = Files.readAllBytes(output);
 637                 Files.delete(output);
 638                 return Optional.of(bytes);
 639             }
 640 
 641             if (Files.exists(output)) {
 642                 Files.delete(output);
 643             }
 644             return Optional.empty();
 645         }
 646     }
 647 
 648     @Override
 649     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 650         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 651         copyResource(EXT_PY, ext);
 652 
 653         var include = new HashSet&lt;&gt;(paths);
 654 
 655         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-tree=&quot; + ext, &quot;ls-tree&quot;, hash.hex())) {
 656             var res = await(p);
 657             var entries = new ArrayList&lt;FileEntry&gt;();
 658             for (var line : res.stdout()) {
 659                 var parts = line.split(&quot;\t&quot;);
 660                 var metadata = parts[0].split(&quot; &quot;);
 661                 var path = Path.of(parts[1]);
 662                 if (include.isEmpty() || include.contains(path)) {
 663                     var entry = new FileEntry(hash,
 664                                               FileType.fromOctal(metadata[0]),
 665                                               new Hash(metadata[2]),
 666                                               path);
 667                     entries.add(entry);
 668                 }
 669             }
 670             return entries;
 671         }
 672     }
 673 
 674     @Override
 675     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 676         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 677         copyResource(EXT_PY, ext);
 678 
 679         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath().toString(),
 680                                                &quot;diff-git-raw&quot;, from.hex(), to.hex())) {
 681             var res = await(p);
 682             var entries = new ArrayList&lt;StatusEntry&gt;();
 683             for (var line : res.stdout()) {
 684                 entries.add(StatusEntry.fromRawLine(line));
 685             }
 686             return entries;
 687         }
 688     }
 689 
 690     @Override
 691     public void dump(FileEntry entry, Path to) throws IOException {
 692         var output = to.toAbsolutePath();
 693         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output.toString(),
 694                                           &quot;--rev=&quot; + entry.commit(),
 695                                           entry.path().toString())) {
 696             await(p);
 697         }
 698     }
 699 
 700     @Override
 701     public void revert(Hash parent) throws IOException {
 702         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;, &quot;--rev&quot;, parent.hex())) {
 703             await(p);
 704         }
 705     }
 706 
 707     @Override
 708     public Diff diff(Hash from) throws IOException {
 709         return diff(from, null);
 710     }
 711 
 712     @Override
 713     public Diff diff(Hash from, Hash to) throws IOException {
 714         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 715         copyResource(EXT_PY, ext);
 716 
 717         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath(),
 718                                                 &quot;diff-git-raw&quot;, &quot;--patch&quot;, from.hex()));
 719         if (to != null) {
 720             cmd.add(to.hex());
 721         }
 722 
 723         var p = start(cmd);
 724         try {
 725             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 726             await(p);
 727             return new Diff(from, to, patches);
 728         } catch (Throwable t) {
 729             throw new IOException(t);
 730         }
 731     }
 732 
 733     @Override
 734     public Optional&lt;String&gt; username() throws IOException {
 735         var lines = config(&quot;ui.username&quot;);
 736         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 737     }
 738 
 739     @Override
 740     public Hash head() throws IOException {
 741         return resolve(&quot;.&quot;).orElseThrow(() -&gt; new IOException(&quot;. not available&quot;));
 742     }
 743 
 744     private List&lt;Hash&gt; heads() throws IOException {
 745         var heads = new ArrayList&lt;Hash&gt;();
 746         try (var p = capture(&quot;hg&quot;, &quot;heads&quot;, &quot;--template={node}\n&quot;)) {
 747             var res = p.await();
 748             if (res.status() == 0) {
 749                 for (var hash : res.stdout()) {
 750                     heads.add(new Hash(hash));
 751                 }
 752             }
 753         }
 754         return heads;
 755     }
 756 
 757     @Override
 758     public List&lt;String&gt; config(String key) throws IOException {
 759         // Do not use HgRepository.capture() here, want to run *with*
 760         // hg configuration.
 761         try (var p = Process.capture(&quot;hg&quot;, &quot;showconfig&quot;, key)
 762                             .workdir(dir)
 763                             .execute()) {
 764             var res = p.await();
 765             if (res.status() == 1) {
 766                 return List.of();
 767             }
 768             return res.stdout();
 769         }
 770     }
 771 
 772     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 773         if (!Files.exists(p)) {
 774             return Optional.empty();
 775         }
 776 
 777         var r = new HgRepository(p);
 778         return r.exists() ? Optional.of(new HgRepository(r.root())) : Optional.empty();
 779     }
 780 
 781     @Override
 782     public Repository copyTo(Path destination) throws IOException {
 783         var from = root().toAbsolutePath().toString();
 784         var to = destination.toAbsolutePath().toString();
 785         try (var p = capture(&quot;hg&quot;, &quot;clone&quot;, from, to)) {
 786             await(p);
 787         }
 788 
 789         return new HgRepository(destination.toAbsolutePath());
 790     }
 791 
 792     @Override
 793     public void merge(Hash h) throws IOException {
 794         merge(h, null);
 795     }
 796 
 797     @Override
 798     public void merge(Hash h, String stragegy) throws IOException {
 799         var cmd = new ArrayList&lt;String&gt;();
 800         cmd.addAll(List.of(&quot;hg&quot;, &quot;merge&quot;, &quot;--rev=&quot; + h.hex()));
 801         if (stragegy != null) {
 802             cmd.add(&quot;--tool=&quot; + stragegy);
 803         }
 804         try (var p = capture(cmd)) {
 805             await(p);
 806         }
 807     }
 808 
 809     @Override
 810     public void abortMerge() throws IOException {
 811         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 812             await(p);
 813         }
 814 
 815         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 816             var res = await(p);
 817             for (var path : res.stdout()) {
 818                 if (path.toString().endsWith(&quot;.orig&quot;)) {
 819                     Files.delete(root().resolve(path));
 820                 }
 821             }
 822         }
 823     }
 824 
 825     @Override
 826     public void addRemote(String name, String path) throws IOException {
 827         setPaths(name, path, path);
 828     }
 829 
 830     @Override
 831     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 832         var hgrc = Path.of(root().toString(), &quot;.hg&quot;, &quot;hgrc&quot;);
 833         if (!Files.exists(hgrc)) {
 834             Files.createFile(hgrc);
 835         }
 836 
 837         var lines = Files.readAllLines(hgrc);
 838         var newLines = new ArrayList&lt;String&gt;();
 839 
 840         var isInPathsSection = false;
 841         var hasPathsSection = false;
 842         for (var line : lines) {
 843             var isSectionHeader = line.startsWith(&quot;[&quot;) &amp;&amp; line.endsWith(&quot;]&quot;);
 844             if (isSectionHeader &amp;&amp; !isInPathsSection) {
 845                 isInPathsSection = line.equals(&quot;[paths]&quot;);
 846                 if (isInPathsSection) {
 847                     newLines.add(line);
 848                     newLines.add(remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath));
 849                     newLines.add(remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 850                     hasPathsSection = true;
 851                     continue;
 852                 }
 853             }
 854 
 855             if (isInPathsSection &amp;&amp; line.startsWith(remote)) {
 856                 if (line.startsWith(remote + &quot;-push&quot;)) {
 857                     // skip
 858                 } else if (line.startsWith(remote + &quot;:pushurl&quot;)) {
 859                     // skip
 860                 } else if (line.startsWith(remote + &quot; &quot;) || line.startsWith(remote + &quot;=&quot;)) {
 861                     // skip
 862                 } else {
 863                     newLines.add(line);
 864                 }
 865             } else {
 866                 newLines.add(line);
 867             }
 868         }
 869 
 870         Files.write(hgrc, newLines, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
 871         if (!hasPathsSection) {
 872             var section = List.of(&quot;[paths]&quot;,
 873                                   remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath),
 874                                   remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 875             Files.write(hgrc, section, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
 876         }
 877     }
 878 
 879     @Override
 880     public String pullPath(String remote) throws IOException {
 881         var lines = config(&quot;paths.&quot; + remote);
 882         if (lines.size() != 1) {
 883             throw new IOException(&quot;Pull path not found for remote: &quot; + remote);
 884         }
 885         return lines.get(0);
 886     }
 887 
 888     @Override
 889     public String pushPath(String remote) throws IOException {
 890         var lines = config(&quot;paths.&quot; + remote + &quot;-push&quot;);
 891         if (lines.size() != 1) {
 892             lines = config(&quot;paths.&quot; + remote + &quot;@push&quot;);
 893         }
 894         if (lines.size() != 1) {
 895             return pullPath(remote);
 896         }
 897         return lines.get(0);
 898     }
 899 
 900     @Override
 901     public boolean isValidRevisionRange(String expression) throws IOException {
 902         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot; &quot;, &quot;--rev&quot;, expression)) {
 903             return p.await().status() == 0;
 904         }
 905     }
 906 
 907     private void setPermissions(Patch.Info target) throws IOException {
 908         if (target.path().isPresent() &amp;&amp; target.type().isPresent()) {
 909             var perms = target.type().get().permissions();
 910             if (perms.isPresent()) {
 911                 Files.setPosixFilePermissions(target.path().get(), perms.get());
 912             }
 913         }
 914     }
 915 
 916     @Override
 917     public void apply(Diff diff, boolean force) throws IOException {
 918         var patchFile = Files.createTempFile(&quot;import&quot;, &quot;.patch&quot;);
 919         diff.toFile(patchFile);
 920         var cmd = new ArrayList&lt;String&gt;();
 921         cmd.addAll(List.of(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;));
 922         if (force) {
 923             cmd.add(&quot;--force&quot;);
 924         }
 925         cmd.add(patchFile.toAbsolutePath().toString());
 926         try (var p = capture(cmd)) {
 927             await(p);
 928         }
 929         //Files.delete(patchFile);
 930     }
 931 
 932     @Override
 933     public void copy(Path from, Path to) throws IOException {
 934         try (var p = capture(&quot;hg&quot;, &quot;copy&quot;, from.toString(), to.toString())) {
 935             await(p);
 936         }
 937     }
 938 
 939     @Override
 940     public void move(Path from, Path to) throws IOException {
 941         try (var p = capture(&quot;hg&quot;, &quot;move&quot;, from.toString(), to.toString())) {
 942             await(p);
 943         }
 944     }
 945 
 946     @Override
 947     public void remove(List&lt;Path&gt; paths) throws IOException {
 948         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;rm&quot;));
 949         for (var p : paths) {
 950             cmd.add(p.toString());
 951         }
 952         try (var p = capture(cmd)) {
 953             await(p);
 954         }
 955     }
 956 
 957     @Override
 958     public void add(List&lt;Path&gt; paths) throws IOException {
 959         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;add&quot;));
 960         for (var p : paths) {
 961             cmd.add(p.toString());
 962         }
 963         try (var p = capture(cmd)) {
 964             await(p);
 965         }
 966     }
 967 
 968     @Override
 969     public void addremove() throws IOException {
 970         try (var p = capture(&quot;hg&quot;, &quot;addremove&quot;)) {
 971             await(p);
 972         }
 973     }
 974 
 975     @Override
 976     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
 977         // Mercurial doesn&#39;t have the concept of remotes like git,
 978         // a local branch must have the same name (if present) on the remote
 979         return Optional.of(b.name());
 980     }
 981 
 982     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {
 983         var cmd = new ArrayList&lt;String&gt;();
 984         cmd.addAll(List.of(&quot;hg&quot;, &quot;clone&quot;));
 985         if (isBare) {
 986             cmd.add(&quot;--noupdate&quot;);
 987         }
 988         cmd.addAll(List.of(from.toString(), to.toString()));
 989 
 990         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
 991             await(p);
 992         }
 993         return new HgRepository(to);
 994     }
 995 
 996     @Override
 997     public void pull() throws IOException {
 998         pull(null, null);
 999     }
1000 
1001     @Override
1002     public void pull(String remote) throws IOException {
1003         pull(remote, null);
1004     }
1005 
1006     @Override
1007     public void pull(String remote, String refspec) throws IOException {
1008         var cmd = new ArrayList&lt;String&gt;();
1009         cmd.addAll(List.of(&quot;hg&quot;, &quot;pull&quot;, &quot;--update&quot;));
1010         if (refspec != null) {
1011             cmd.add(&quot;--branch&quot;);
1012             cmd.add(refspec);
1013         }
1014         if (remote != null) {
1015             cmd.add(remote);
1016         }
1017         try (var p = capture(cmd)) {
1018             await(p);
1019         }
1020     }
1021 
1022     @Override
1023     public boolean contains(Branch b, Hash h) throws IOException {
1024         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot;{branch}&quot;, &quot;-r&quot;, h.hex())) {
1025             var res = await(p);
1026             if (res.stdout().size() != 1) {
1027                 throw new IOException(&quot;Unexpected output: &quot; + String.join(&quot;\n&quot;, res.stdout()));
1028             }
1029             var line = res.stdout().get(0);
1030             return line.equals(b.name());
1031         }
1032     }
1033 }
    </pre>
  </body>
</html>