<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames bots/hgbridge/src/test/java/org/openjdk/skara/bots/hgbridge/BridgeBotTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.hgbridge;
 24 
 25 import org.openjdk.skara.host.HostedRepository;
 26 import org.openjdk.skara.host.network.URIBuilder;
 27 import org.openjdk.skara.process.Process;
 28 import org.openjdk.skara.test.*;
 29 import org.openjdk.skara.vcs.Tag;
 30 import org.openjdk.skara.vcs.*;
 31 import org.openjdk.skara.vcs.openjdk.convert.*;
 32 
 33 import org.junit.jupiter.api.*;
 34 
 35 import java.io.*;
<a name="1" id="anc1"></a>
 36 import java.net.URI;
<a name="2" id="anc2"></a>

 37 import java.nio.file.*;
 38 import java.util.*;
 39 import java.util.stream.Collectors;
 40 
 41 import static org.junit.jupiter.api.Assertions.*;
 42 
 43 @TestInstance(TestInstance.Lifecycle.PER_CLASS)
 44 class BridgeBotTests {
<a name="3" id="anc3"></a><span class="line-removed"> 45 </span>
 46     private List&lt;String&gt; runHgCommand(Repository repository, String... params) throws IOException {
 47         List&lt;String&gt; finalParams = new ArrayList&lt;&gt;();
 48         finalParams.add(&quot;hg&quot;);
 49         finalParams.addAll(List.of(&quot;--config&quot;, &quot;extensions.strip=&quot;));
 50 
 51         finalParams.addAll(List.of(params));
 52         try (var p = Process.capture(finalParams.toArray(new String[0]))
 53                             .workdir(repository.root().toString())
 54                             .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
 55                             .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
 56                             .execute()) {
 57             return p.check().stdout();
 58         }
 59     }
 60 
 61     static class TestExporterConfig extends ExporterConfig {
 62         private boolean badAuthors = false;
 63 
 64         TestExporterConfig(URI source, HostedRepository destination) {
 65             this.source(source);
 66             this.destinations(List.of(destination));
 67         }
 68 
 69         void setBadAuthors() {
 70             this.badAuthors = true;
 71         }
 72 
 73         @Override
 74         public Converter resolve(Path scratchPath) {
 75             var replacements = new HashMap&lt;Hash, List&lt;String&gt;&gt;();
 76             var corrections = new HashMap&lt;Hash, Map&lt;String, String&gt;&gt;();
 77             var lowercase = new HashSet&lt;Hash&gt;();
 78             var punctuated = new HashSet&lt;Hash&gt;();
 79 
 80             var authors = Map.of(&quot;jjg&quot;, &quot;JJG &lt;jjg@openjdk.java.net&gt;&quot;,
 81                                  &quot;duke&quot;, &quot;Duke &lt;duke@openjdk.java.net&gt;&quot;);
 82             var contributors = new HashMap&lt;String, String&gt;();
 83             var sponsors = new HashMap&lt;String, List&lt;String&gt;&gt;();
 84 
 85             return new HgToGitConverter(replacements, corrections, lowercase, punctuated, badAuthors ? Map.of() : authors, contributors, sponsors);
 86         }
 87     }
 88 
 89     private Set&lt;String&gt; getTagNames(Repository repo) throws IOException {
 90         var tags = repo.tags().stream()
 91                        .map(Tag::name)
 92                        .collect(Collectors.toSet());
 93         if (repo.defaultTag().isPresent()) {
 94             tags.remove(repo.defaultTag().get().name());
 95         }
 96         return tags;
 97     }
 98 
 99     private Set&lt;String&gt; getCommitHashes(Repository repo) throws IOException {
100         return repo.commits().stream()
101                    .map(c -&gt; c.hash().hex())
102                    .collect(Collectors.toSet());
103     }
104 
105     private TemporaryDirectory sourceFolder;
106     private URI source;
107 
108     @BeforeAll
109     void setup() throws IOException {
110         // Export the beginning of the jtreg repository
111         sourceFolder = new TemporaryDirectory();
112         try {
113             var localRepo = Repository.materialize(sourceFolder.path(), URIBuilder.base(&quot;http://hg.openjdk.java.net/code-tools/jtreg&quot;).build(), &quot;default&quot;);
<a name="4" id="anc4"></a>







114             runHgCommand(localRepo, &quot;strip&quot;, &quot;-r&quot;, &quot;b2511c725d81&quot;);
115         } catch (IOException e) {
116             Assumptions.assumeTrue(false, &quot;Failed to connect to hg.openjdk.java.net - skipping tests&quot;);
117         }
118         this.source = sourceFolder.path().toUri();
119     }
120 
121     @AfterAll
122     void teardown() {
123         sourceFolder.close();
124     }
125 
126     @Test
127     void bridgeTest(TestInfo testInfo) throws IOException {
128         try (var credentials = new HostCredentials(testInfo);
129              var hgFolder = new TemporaryDirectory();
130              var gitFolder = new TemporaryDirectory();
131              var storageFolder = new TemporaryDirectory();
132              var storageFolder2 = new TemporaryDirectory()) {
133             // Export a partial version of a hg repository
<a name="5" id="anc5"></a>
134             var localHgRepo = Repository.materialize(hgFolder.path(), source, &quot;default&quot;);
135             var destinationRepo = credentials.getHostedRepository();
136             var config = new TestExporterConfig(localHgRepo.root().toUri(), destinationRepo);
137             var bridge = new JBridgeBot(config, storageFolder.path());
138 
139             runHgCommand(localHgRepo, &quot;strip&quot;, &quot;-r&quot;, &quot;bd7a3ed1210f&quot;);
140             TestBotRunner.runPeriodicItems(bridge);
141 
142             var localGitRepo = Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
143 
144             // Only a subset of known tags should be present
145             var localGitTags = getTagNames(localGitRepo);
146             assertEquals(getTagNames(localHgRepo), localGitTags);
147             assertTrue(localGitTags.contains(&quot;jtreg4.1-b02&quot;));
148             assertFalse(localGitTags.contains(&quot;jtreg4.1-b05&quot;));
149 
150             // Import more revisions into the local hg repository and export again
151             localHgRepo.fetch(source, &quot;default&quot;);
152             TestBotRunner.runPeriodicItems(bridge);
153 
154             // There should now be more tags present
155             Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
156             localGitTags = getTagNames(localGitRepo);
157             assertEquals(getTagNames(localHgRepo), localGitTags);
158             assertTrue(localGitTags.contains(&quot;jtreg4.1-b02&quot;));
159             assertTrue(localGitTags.contains(&quot;jtreg4.1-b05&quot;));
160 
161             // Export it again with different storage to force an export from scratch
162             bridge = new JBridgeBot(config, storageFolder2.path());
163             TestBotRunner.runPeriodicItems(bridge);
164             Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
165             var newLocalGitTags = getTagNames(localGitRepo);
166             assertEquals(localGitTags, newLocalGitTags);
167 
168             // Export it once more when nothing has changed
169             TestBotRunner.runPeriodicItems(bridge);
170             Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
171             newLocalGitTags = getTagNames(localGitRepo);
172             assertEquals(localGitTags, newLocalGitTags);
173         }
174     }
175 
176     @Test
177     void bridgeCorruptedStorageHg(TestInfo testInfo) throws IOException {
178         try (var credentials = new HostCredentials(testInfo);
179              var storageFolder = new TemporaryDirectory();
180              var gitFolder = new TemporaryDirectory()) {
181             var destinationRepo = credentials.getHostedRepository();
182 
183             // Export an hg repository as is
184             var config = new TestExporterConfig(source, destinationRepo);
185             var bridge = new JBridgeBot(config, storageFolder.path());
186             TestBotRunner.runPeriodicItems(bridge);
187 
188             // Materialize it and ensure that it contains a known commit
189             var localGitRepo = Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
190             var localGitCommits = getCommitHashes(localGitRepo);
191             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
192 
193             // Now corrupt the .hg folder in the permanent storage
194             Files.walk(storageFolder.path())
195                  .filter(p -&gt; p.toString().contains(&quot;/.hg/&quot;))
196                  .filter(p -&gt; p.toFile().isFile())
197                  .forEach(p -&gt; {
198                      try {
199                          Files.delete(p);
200                      } catch (IOException e) {
201                          throw new UncheckedIOException(e);
202                      }
203                  });
204 
205             // Now export it again - should still be intact
206             TestBotRunner.runPeriodicItems(bridge);
207             Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
208             localGitCommits = getCommitHashes(localGitRepo);
209             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
210         }
211     }
212 
213     @Test
214     void bridgeExportScriptFailure(TestInfo testInfo) throws IOException {
215         try (var credentials = new HostCredentials(testInfo);
216              var storageFolder = new TemporaryDirectory();
217              var storageFolder2 = new TemporaryDirectory();
218              var gitFolder = new TemporaryDirectory()) {
219             var destinationRepo = credentials.getHostedRepository();
220 
221             // Export an hg repository but with an empty authors list
222             var config = new TestExporterConfig(source, destinationRepo);
223             config.setBadAuthors();
224             var badBridge = new JBridgeBot(config, storageFolder.path());
225             assertThrows(RuntimeException.class, () -&gt; TestBotRunner.runPeriodicItems(badBridge));
226 
227             // Now once again with a correct configuration
228             config = new TestExporterConfig(source, destinationRepo);
229             var goodBridge = new JBridgeBot(config, storageFolder2.path());
230             TestBotRunner.runPeriodicItems(goodBridge);
231 
232             // Verify that it now contains a known commit
233             var localGitRepo = Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
234             var localGitCommits = getCommitHashes(localGitRepo);
235             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
236         }
237     }
238 
239     @Test
240     void bridgeReuseMarks(TestInfo testInfo) throws IOException {
241         try (var credentials = new HostCredentials(testInfo);
242              var storageFolder = new TemporaryDirectory();
243              var gitFolder = new TemporaryDirectory();
244              var gitFolder2 = new TemporaryDirectory();
245              var gitFolder3 = new TemporaryDirectory();
246              var gitFolder4 = new TemporaryDirectory()) {
247             var destinationRepo = credentials.getHostedRepository();
248             var config = new TestExporterConfig(source, destinationRepo);
249 
250             // Export an hg repository as is
251             var bridge = new JBridgeBot(config, storageFolder.path());
252             TestBotRunner.runPeriodicItems(bridge);
253 
254             // Materialize it and ensure that it contains a known commit
255             var localGitRepo = Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
256             var localGitCommits = getCommitHashes(localGitRepo);
257             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
258 
<a name="6" id="anc6"></a><span class="line-modified">259             // Push something else to overwrite it</span>
<a name="7" id="anc7"></a>
260             var localRepo = CheckableRepository.init(gitFolder2.path(), destinationRepo.getRepositoryType());
261             localRepo.pushAll(destinationRepo.getUrl());
262 
263             // Materialize it again and ensure that the known commit is now gone
264             localGitRepo = Repository.materialize(gitFolder3.path(), destinationRepo.getUrl(), &quot;master&quot;);
265             localGitCommits = getCommitHashes(localGitRepo);
266             assertFalse(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
267 
268             // Now run the exporter again - nothing should happen
269             TestBotRunner.runPeriodicItems(bridge);
270 
271             // Materialize it yet again and ensure that the known commit is still gone
272             localGitRepo = Repository.materialize(gitFolder4.path(), destinationRepo.getUrl(), &quot;master&quot;);
273             localGitCommits = getCommitHashes(localGitRepo);
274             assertFalse(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
275         }
276     }
277 
278     @Test
279     void retryFailedPush(TestInfo testInfo) throws IOException {
280         try (var credentials = new HostCredentials(testInfo);
281              var storageFolder = new TemporaryDirectory();
282              var gitFolder = new TemporaryDirectory();
283              var gitFolder2 = new TemporaryDirectory();
284              var gitFolder3 = new TemporaryDirectory();
285              var gitFolder4 = new TemporaryDirectory();
286              var gitFolder5 = new TemporaryDirectory()) {
287             var destinationRepo = credentials.getHostedRepository();
288             var config = new TestExporterConfig(source, destinationRepo);
289 
290             // Export an hg repository as is
291             var bridge = new JBridgeBot(config, storageFolder.path());
292             TestBotRunner.runPeriodicItems(bridge);
293 
294             // Materialize it and ensure that it contains a known commit
295             var localGitRepo = Repository.materialize(gitFolder.path(), destinationRepo.getUrl(), &quot;master&quot;);
296             var localGitCommits = getCommitHashes(localGitRepo);
297             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
298 
299             // Push something else to overwrite it
300             var localRepo = CheckableRepository.init(gitFolder2.path(), destinationRepo.getRepositoryType());
301             localRepo.pushAll(destinationRepo.getUrl());
302 
303             // Materialize it again and ensure that the known commit is now gone
304             localGitRepo = Repository.materialize(gitFolder3.path(), destinationRepo.getUrl(), &quot;master&quot;);
305             localGitCommits = getCommitHashes(localGitRepo);
306             assertFalse(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
307 
308             // Now run the exporter again - nothing should happen
309             TestBotRunner.runPeriodicItems(bridge);
310 
311             // Materialize it yet again and ensure that the known commit is still gone
312             localGitRepo = Repository.materialize(gitFolder4.path(), destinationRepo.getUrl(), &quot;master&quot;);
313             localGitCommits = getCommitHashes(localGitRepo);
314             assertFalse(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
315 
316             // Remove the successful push markers
317             Files.walk(storageFolder.path())
318                  .filter(p -&gt; p.toString().contains(&quot;.success.txt&quot;))
319                  .filter(p -&gt; p.toFile().isFile())
320                  .forEach(p -&gt; {
321                      try {
322                          Files.delete(p);
323                      } catch (IOException e) {
324                          throw new UncheckedIOException(e);
325                      }
326                  });
327 
328             // Now run the exporter again - it should do the push again
329             TestBotRunner.runPeriodicItems(bridge);
330 
331             // Materialize it and ensure that the known commit is back
332             localGitRepo = Repository.materialize(gitFolder5.path(), destinationRepo.getUrl(), &quot;master&quot;);
333             localGitCommits = getCommitHashes(localGitRepo);
334             assertTrue(localGitCommits.contains(&quot;9cb6a5b843c0e9f6d45273a1a6f5c98979ab0766&quot;));
335         }
336     }
337 
338     @Test
339     void filterUnreachable(TestInfo testInfo) throws IOException {
340         try (var credentials = new HostCredentials(testInfo);
341              var hgFolder = new TemporaryDirectory();
342              var gitFolder = new TemporaryDirectory();
343              var storageFolder = new TemporaryDirectory();
344              var storageFolder2 = new TemporaryDirectory()) {
345             // Export a hg repository with unreachable commits
<a name="8" id="anc8"></a>
346             var localHgRepo = Repository.materialize(hgFolder.path(), source, &quot;default&quot;);
347             var destinationRepo = credentials.getHostedRepository();
348             var config = new TestExporterConfig(localHgRepo.root().toUri(), destinationRepo);
349             var bridge = new JBridgeBot(config, storageFolder.path());
350 
351             runHgCommand(localHgRepo, &quot;update&quot;, &quot;-r&quot;, &quot;5&quot;);
352             var other = localHgRepo.root().resolve(&quot;other.txt&quot;);
353             Files.writeString(other, &quot;Hello&quot;);
354             localHgRepo.add(other);
355             localHgRepo.commit(&quot;Another head&quot;, &quot;duke&quot;, &quot;&quot;);
356             runHgCommand(localHgRepo, &quot;commit&quot;, &quot;--close-branch&quot;, &quot;--user=duke&quot;, &quot;-m&quot;, &quot;closing head&quot;);
357 
358             // Do an initial conversion, it will drop the closed head
359             TestBotRunner.runPeriodicItems(bridge);
360 
361             // The second conversion should not encounter unreachable commits in the marks file
362             TestBotRunner.runPeriodicItems(bridge);
363         }
364     }
365 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>