diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
@@ -77,22 +77,22 @@
         if (bestParent.getValue().size() > 1000) {
             throw new RuntimeException("Excessive amount of unique commits on new branch " + ref.name() +
                                                " detected (" + bestParent.getValue().size() + ") - skipping notifications");
         }
         for (var updater : updaters) {
-            if (updater.idempotent() != runOnlyIdempotent) {
+            if (updater.isIdempotent() != runOnlyIdempotent) {
                 continue;
             }
             var branch = new Branch(ref.name());
             var parent = new Branch(bestParent.getKey().name());
             updater.handleNewBranch(repository, localRepo, bestParent.getValue(), parent, branch);
         }
     }
 
     private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits, boolean runOnlyIdempotent) {
         for (var updater : updaters) {
-            if (updater.idempotent() != runOnlyIdempotent) {
+            if (updater.isIdempotent() != runOnlyIdempotent) {
                 continue;
             }
             var branch = new Branch(ref.name());
             updater.handleCommits(repository, localRepo, commits, branch);
         }
@@ -191,19 +191,19 @@
             Collections.reverse(commits);
             var annotation = localRepo.annotate(tag.tag());
 
             // Run all notifiers that can be safely re-run
             updaters.stream()
-                    .filter(RepositoryUpdateConsumer::idempotent)
+                    .filter(RepositoryUpdateConsumer::isIdempotent)
                     .forEach(updater -> updater.handleOpenJDKTagCommits(repository, localRepo, commits, tag, annotation.orElse(null)));
 
             // Now update the history
             history.addTags(List.of(tag.tag()));
 
             // Finally run all one-shot notifiers
             updaters.stream()
-                    .filter(updater -> !updater.idempotent())
+                    .filter(updater -> !updater.isIdempotent())
                     .forEach(updater -> updater.handleOpenJDKTagCommits(repository, localRepo, commits, tag, annotation.orElse(null)));
         }
 
         var newNonJdkTags = newTags.stream()
                                    .filter(tag -> OpenJDKTag.create(tag).isEmpty())
@@ -216,19 +216,19 @@
 
             var annotation = localRepo.annotate(tag);
 
             // Run all notifiers that can be safely re-run
             updaters.stream()
-                    .filter(RepositoryUpdateConsumer::idempotent)
+                    .filter(RepositoryUpdateConsumer::isIdempotent)
                     .forEach(updater -> updater.handleTagCommit(repository, localRepo, commit.get(), tag, annotation.orElse(null)));
 
             // Now update the history
             history.addTags(List.of(tag));
 
             // Finally run all one-shot notifiers
             updaters.stream()
-                    .filter(updater -> !updater.idempotent())
+                    .filter(updater -> !updater.isIdempotent())
                     .forEach(updater -> updater.handleTagCommit(repository, localRepo, commit.get(), tag, annotation.orElse(null)));
         }
     }
 
     private Repository fetchAll(Path dir, URI remote) throws IOException {
