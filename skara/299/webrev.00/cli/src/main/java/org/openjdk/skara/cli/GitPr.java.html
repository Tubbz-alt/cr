<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.proxy.HttpProxy;
 29 import org.openjdk.skara.vcs.*;
 30 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 31 
 32 import java.io.IOException;
 33 import java.net.URI;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.*;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.function.Supplier;
 39 import java.util.logging.Level;
 40 import java.util.stream.Collectors;
 41 
 42 public class GitPr {
 43     private static void exit(String fmt, Object...args) {
 44         System.err.println(String.format(fmt, args));
 45         System.exit(1);
 46     }
 47 
 48     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 49         return () -&gt; {
 50             exit(fmt, args);
 51             return null;
 52         };
 53     }
 54 
 55     private static void await(Process p) throws IOException {
 56         try {
 57             var res = p.waitFor();
 58             if (res != 0) {
 59                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 60             }
 61         } catch (InterruptedException e) {
 62             throw new IOException(e);
 63         }
 64     }
 65 
 66     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 67         String editor = null;
 68         var lines = repo.config(&quot;core.editor&quot;);
 69         if (lines.size() == 1) {
 70             editor = lines.get(0);
 71         }
 72         if (editor == null) {
 73             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 74         }
 75         if (editor == null) {
 76             editor = System.getenv(&quot;EDITOR&quot;);
 77         }
 78         if (editor == null) {
 79             editor = System.getenv(&quot;VISUAL&quot;);
 80         }
 81         if (editor == null) {
 82             editor = &quot;vi&quot;;
 83         }
 84 
 85         var pb = new ProcessBuilder(editor, file.toString());
 86         pb.inheritIO();
 87         var p = pb.start();
 88         try {
 89             return p.waitFor() == 0;
 90         } catch (InterruptedException e) {
 91             throw new IOException(e);
 92         }
 93     }
 94 
 95     private static String projectName(URI uri) {
 96         var name = uri.getPath().toString().substring(1);
 97         if (name.endsWith(&quot;.git&quot;)) {
 98             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 99         }
100         return name;
101     }
102 
103     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
104         HostedRepository targetRepo = null;
105 
106         try {
107             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
108             targetRepo = host.repository(projectName(upstream)).orElse(null);
109         } catch (IOException e) {
110             // do nothing
111         }
112 
113         if (targetRepo == null) {
114             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
115                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
116             );
117             var parentRepo = remoteRepo.parent();
118             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
119         }
120 
121         return targetRepo;
122     }
123 
124     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
125         if (!prId.isPresent()) {
126             exit(&quot;error: missing pull request identifier&quot;);
127         }
128 
129         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
130         if (pr == null) {
131             exit(&quot;error: could not fetch PR information&quot;);
132         }
133 
134         return pr;
135     }
136 
137     private static void show(String ref, Hash hash) throws IOException {
138         show(ref, hash, null);
139     }
140     private static void show(String ref, Hash hash, Path dir) throws IOException {
141         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
142                                                    &quot;--patch&quot;,
143                                                    &quot;--find-renames=50%&quot;,
144                                                    &quot;--find-copies=50%&quot;,
145                                                    &quot;--find-copies-harder&quot;,
146                                                    &quot;--abbrev&quot;,
147                                                    ref + &quot;...&quot; + hash.hex());
148         if (dir != null) {
149             pb.directory(dir.toFile());
150         }
151         pb.inheritIO();
152         await(pb.start());
153     }
154 
155     private static void gimport() throws IOException {
156         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
157         pb.inheritIO();
158         await(pb.start());
159     }
160 
161     private static void hgImport(Path patch) throws IOException {
162         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
163         pb.inheritIO();
164         await(pb.start());
165     }
166 
167     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
168         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
169         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
170         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
171         var p = pb.start();
172         var bytes = p.getInputStream().readAllBytes();
173         var exited = p.waitFor(1, TimeUnit.MINUTES);
174         var exitValue = p.exitValue();
175         if (!exited || exitValue != 0) {
176             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
177         }
178 
179         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
180     }
181 
182     private static String hgResolve(String ref) throws IOException, InterruptedException {
183         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
184         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
185         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
186         var p = pb.start();
187         var bytes = p.getInputStream().readAllBytes();
188         var exited = p.waitFor(1, TimeUnit.MINUTES);
189         var exitValue = p.exitValue();
190         if (!exited || exitValue != 0) {
191             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
192         }
193 
194         return new String(bytes, StandardCharsets.UTF_8);
195     }
196 
197     private static Path diff(String ref, Hash hash) throws IOException {
198         return diff(ref, hash, null);
199     }
200 
201     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
202         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
203         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
204                                                    &quot;--patch&quot;,
205                                                    &quot;--find-renames=50%&quot;,
206                                                    &quot;--find-copies=50%&quot;,
207                                                    &quot;--find-copies-harder&quot;,
208                                                    &quot;--abbrev&quot;,
209                                                    ref + &quot;...&quot; + hash.hex());
210         if (dir != null) {
211             pb.directory(dir.toFile());
212         }
213         pb.redirectOutput(patch.toFile());
214         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
215         await(pb.start());
216         return patch;
217     }
218 
219     private static void apply(Path patch) throws IOException {
220         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
221         pb.inheritIO();
222         await(pb.start());
223     }
224 
225     private static int longest(List&lt;String&gt; strings) {
226         return strings.stream().mapToInt(String::length).max().orElse(0);
227     }
228 
229     public static void main(String[] args) throws IOException, InterruptedException {
230         var flags = List.of(
231             Option.shortcut(&quot;u&quot;)
232                   .fullname(&quot;username&quot;)
233                   .describe(&quot;NAME&quot;)
234                   .helptext(&quot;Username on host&quot;)
235                   .optional(),
236             Option.shortcut(&quot;r&quot;)
237                   .fullname(&quot;remote&quot;)
238                   .describe(&quot;NAME&quot;)
239                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
240                   .optional(),
241             Option.shortcut(&quot;b&quot;)
242                   .fullname(&quot;branch&quot;)
243                   .describe(&quot;NAME&quot;)
244                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
245                   .optional(),
246             Option.shortcut(&quot;&quot;)
247                   .fullname(&quot;authors&quot;)
248                   .describe(&quot;LIST&quot;)
249                   .helptext(&quot;Comma separated list of authors&quot;)
250                   .optional(),
251             Option.shortcut(&quot;&quot;)
252                   .fullname(&quot;assignees&quot;)
253                   .describe(&quot;LIST&quot;)
254                   .helptext(&quot;Comma separated list of assignees&quot;)
255                   .optional(),
256             Option.shortcut(&quot;&quot;)
257                   .fullname(&quot;labels&quot;)
258                   .describe(&quot;LIST&quot;)
259                   .helptext(&quot;Comma separated list of labels&quot;)
260                   .optional(),
261             Option.shortcut(&quot;&quot;)
262                   .fullname(&quot;columns&quot;)
263                   .describe(&quot;id,title,author,assignees,labels&quot;)
264                   .helptext(&quot;Comma separated list of columns to show&quot;)
265                   .optional(),
266             Switch.shortcut(&quot;&quot;)
267                   .fullname(&quot;no-decoration&quot;)
268                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
269                   .optional(),
270             Switch.shortcut(&quot;&quot;)
271                   .fullname(&quot;no-token&quot;)
272                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
273                   .optional(),
274             Switch.shortcut(&quot;&quot;)
275                   .fullname(&quot;mercurial&quot;)
276                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
277                   .optional(),
278             Switch.shortcut(&quot;&quot;)
279                   .fullname(&quot;verbose&quot;)
280                   .helptext(&quot;Turn on verbose output&quot;)
281                   .optional(),
282             Switch.shortcut(&quot;&quot;)
283                   .fullname(&quot;debug&quot;)
284                   .helptext(&quot;Turn on debugging output&quot;)
285                   .optional(),
286             Switch.shortcut(&quot;&quot;)
287                   .fullname(&quot;version&quot;)
288                   .helptext(&quot;Print the version of this tool&quot;)
289                   .optional());
290 
291         var inputs = List.of(
292             Input.position(0)
293                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
294                  .singular()
295                  .required(),
296             Input.position(1)
297                  .describe(&quot;ID&quot;)
298                  .singular()
299                  .optional()
300         );
301 
302         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
303         var arguments = parser.parse(args);
304 
305         if (arguments.contains(&quot;version&quot;)) {
306             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
307             System.exit(0);
308         }
309 
310         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
311             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
312             Logging.setup(level);
313         }
314 
315         HttpProxy.setup();
316 
317         var isMercurial = arguments.contains(&quot;mercurial&quot;);
318         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
319         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
320         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
321         var remotePullPath = repo.pullPath(remote);
322         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
323         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
324         var uri = Remote.toWebURI(remotePullPath);
325         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
326         var credentials = !shouldUseToken ?
327             null :
328             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
329         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
330         var forge = credentials == null ?
331             Forge.from(forgeURI) :
332             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
333         if (forge.isEmpty()) {
334             if (!shouldUseToken) {
335                 if (arguments.contains(&quot;verbose&quot;)) {
336                     System.err.println(&quot;&quot;);
337                 }
338                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
339                 if (!arguments.contains(&quot;verbose&quot;)) {
340                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
341                     System.err.println(&quot;&quot;);
342                 }
343             }
344             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
345         }
346         var host = forge.get();
347 
348         var action = arguments.at(0).asString();
349         if (!shouldUseToken &amp;&amp;
350             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
351             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
352             System.exit(1);
353         }
354 
355         if (action.equals(&quot;create&quot;)) {
356             if (isMercurial) {
357                 var currentBookmark = repo.currentBookmark();
358                 if (!currentBookmark.isPresent()) {
359                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
360                     System.err.println(&quot;&quot;);
361                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
362                     System.err.println(&quot;&quot;);
363                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
364                     System.err.println(&quot;&quot;);
365                     System.exit(1);
366                 }
367 
368                 var bookmark = currentBookmark.get();
369                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
370                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
371                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
372                     System.err.println(&quot;&quot;);
373                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
374                     System.err.println(&quot;&quot;);
375                     System.exit(1);
376                 }
377 
378                 var tags = hgTags();
379                 var upstreams = tags.stream()
380                                     .filter(t -&gt; t.endsWith(bookmark.name()))
381                                     .collect(Collectors.toList());
382                 if (upstreams.isEmpty()) {
383                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
384                     System.err.println(&quot;&quot;);
385                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
386                     System.err.println(&quot;&quot;);
387                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
388                     System.err.println(&quot;&quot;);
389                     System.exit(1);
390                 }
391 
392                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
393                 for (var tag : tags) {
394                     tagsAndHashes.put(tag, hgResolve(tag));
395                 }
396                 var bookmarkHash = hgResolve(bookmark.name());
397                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
398                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
399                     System.err.println(&quot;&quot;);
400 
401                     if (upstreams.size() == 1) {
402                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
403                         System.err.println(&quot;&quot;);
404                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
405                         System.err.println(&quot;&quot;);
406                     } else {
407                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
408                         System.err.println(&quot;&quot;);
409                         for (var upstream : upstreams) {
410                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
411                         }
412                         System.err.println(&quot;&quot;);
413                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
414                         System.err.println(&quot;&quot;);
415                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
416                         System.err.println(&quot;&quot;);
417                     }
418                     System.exit(1);
419                 }
420 
421                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
422                 var targetHash = hgResolve(targetBranch);
423                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
424                 if (commits.isEmpty()) {
425                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
426                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
427                     System.exit(1);
428                 }
429 
430                 var diff = repo.diff(repo.head());
431                 if (!diff.patches().isEmpty()) {
432                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
433                     System.err.println(&quot;&quot;);
434                     for (var patch : diff.patches()) {
435                         var path = patch.target().path().isPresent() ?
436                             patch.target().path().get() : patch.source().path().get();
437                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
438                     }
439                     System.err.println(&quot;&quot;);
440                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
441                     System.err.println(&quot;&quot;);
442                     System.err.println(&quot;    hg commit --amend&quot;);
443                     System.err.println(&quot;    hg git-cleanup&quot;);
444                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
445                     System.err.println(&quot;    hg gimport&quot;);
446                     System.err.println(&quot;&quot;);
447                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
448                     System.err.println(&quot;&quot;);
449                     System.err.println(&quot;    hg shelve&quot;);
450                     System.err.println(&quot;&quot;);
451                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
452                     System.exit(1);
453                 }
454 
455                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
456                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
457                 );
458                 if (token == null) {
459                     GitCredentials.approve(credentials);
460                 }
461                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
462                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
463 
464                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
465                 if (commits.size() == 1) {
466                     var commit = commits.get(0);
467                     var message = CommitMessageParsers.v1.parse(commit.message());
468                     Files.writeString(file, message.title() + &quot;\n&quot;);
469                     if (!message.summaries().isEmpty()) {
470                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
471                     }
472                     if (!message.additional().isEmpty()) {
473                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
474                     }
475                 } else {
476                     Files.write(file, List.of(&quot;&quot;));
477                 }
478                 Files.write(file, List.of(
479                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
480                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
481                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
482                     &quot;# the subject from the body.&quot;,
483                     &quot;#&quot;,
484                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
485                     ),
486                     StandardOpenOption.APPEND
487                 );
488                 for (var commit : commits) {
489                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
490                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
491                 }
492                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
493                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
494                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
495                 var success = spawnEditor(repo, file);
496                 if (!success) {
497                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
498                     System.exit(1);
499                 }
500                 var lines = Files.readAllLines(file)
501                                  .stream()
502                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
503                                  .collect(Collectors.toList());
504                 var isEmpty = lines.stream().allMatch(String::isEmpty);
505                 if (isEmpty) {
506                     System.err.println(&quot;error: no message present, aborting&quot;);
507                     System.exit(1);
508                 }
509 
510                 var title = lines.get(0);
511                 List&lt;String&gt; body = null;
512                 if (lines.size() &gt; 1) {
513                     body = lines.subList(1, lines.size())
514                                 .stream()
515                                 .dropWhile(String::isEmpty)
516                                 .collect(Collectors.toList());
517                 } else {
518                     body = Collections.emptyList();
519                 }
520 
521                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
522                 if (arguments.contains(&quot;assignees&quot;)) {
523                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
524                     var assignees = usernames.stream()
525                                              .map(u -&gt; host.user(u))
526                                              .collect(Collectors.toList());
527                     pr.setAssignees(assignees);
528                 }
529                 System.out.println(pr.webUrl().toString());
530                 Files.deleteIfExists(file);
531 
532                 System.exit(0);
533             }
534             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
535                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
536                     System.exit(1);
537                     return null;
538             });
539             if (currentBranch.equals(repo.defaultBranch())) {
540                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
541                 System.err.println(&quot;&quot;);
542                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
543                 System.err.println(&quot;&quot;);
544                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
545                 System.err.println(&quot;    git branch --force master origin/master&quot;);
546                 System.err.println(&quot;&quot;);
547                 System.exit(1);
548             }
549 
550             var upstream = repo.upstreamFor(currentBranch);
551             if (upstream.isEmpty()) {
552                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
553                 System.err.println(&quot;&quot;);
554                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
555                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
556                 System.err.println(&quot;&quot;);
557                 System.err.println(&quot;    git publish&quot;);
558                 System.err.println(&quot;&quot;);
559                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
560                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
561                 System.err.println(&quot;&quot;);
562                 System.err.println(&quot;    git fetch &quot; + remote);
563                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
564                 System.err.println(&quot;&quot;);
565                 System.exit(1);
566             }
567 
568             var upstreamRefName = upstream.get().substring(remote.length() + 1);
569             repo.fetch(uri, upstreamRefName);
570             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
571             if (!branchCommits.isEmpty()) {
572                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
573                 System.err.println(&quot;&quot;);
574                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
575                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
576                 System.err.println(&quot;&quot;);
577                 for (var commit : branchCommits) {
578                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
579                 }
580                 System.err.println(&quot;&quot;);
581                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
582                 System.err.println(&quot;&quot;);
583                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
584                 System.err.println(&quot;&quot;);
585                 System.exit(1);
586             }
587 
588             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
589             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
590             if (commits.isEmpty()) {
591                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
592                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
593                 System.exit(1);
594             }
595 
596             var diff = repo.diff(repo.head());
597             if (!diff.patches().isEmpty()) {
598                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
599                 System.err.println(&quot;&quot;);
600                 for (var patch : diff.patches()) {
601                     var path = patch.target().path().isPresent() ?
602                         patch.target().path().get() : patch.source().path().get();
603                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
604                 }
605                 System.err.println(&quot;&quot;);
606                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
607                 System.err.println(&quot;&quot;);
608                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
609                 System.err.println(&quot;&quot;);
610                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
611                 System.err.println(&quot;&quot;);
612                 System.err.println(&quot;    git stash&quot;);
613                 System.err.println(&quot;&quot;);
614                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
615                 System.exit(1);
616             }
617 
618             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
619                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
620             );
621             if (token == null) {
622                 GitCredentials.approve(credentials);
623             }
624             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
625                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
626 
627             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
628             if (commits.size() == 1) {
629                 var commit = commits.get(0);
630                 var message = CommitMessageParsers.v1.parse(commit.message());
631                 Files.writeString(file, message.title() + &quot;\n&quot;);
632                 if (!message.summaries().isEmpty()) {
633                     Files.write(file, message.summaries(), StandardOpenOption.APPEND);
634                 }
635                 if (!message.additional().isEmpty()) {
636                     Files.write(file, message.additional(), StandardOpenOption.APPEND);
637                 }
638             } else {
639                 Files.write(file, List.of(&quot;&quot;));
640             }
641             Files.write(file, List.of(
642                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
643                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
644                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
645                 &quot;# the subject from the body.&quot;,
646                 &quot;#&quot;,
647                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
648                 ),
649                 StandardOpenOption.APPEND
650             );
651             for (var commit : commits) {
652                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
653                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
654             }
655             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
656             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
657             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
658             var success = spawnEditor(repo, file);
659             if (!success) {
660                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
661                 System.exit(1);
662             }
663             var lines = Files.readAllLines(file)
664                              .stream()
665                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
666                              .collect(Collectors.toList());
667             var isEmpty = lines.stream().allMatch(String::isEmpty);
668             if (isEmpty) {
669                 System.err.println(&quot;error: no message present, aborting&quot;);
670                 System.exit(1);
671             }
672 
673             var title = lines.get(0);
674             List&lt;String&gt; body = null;
675             if (lines.size() &gt; 1) {
676                 body = lines.subList(1, lines.size())
677                             .stream()
678                             .dropWhile(String::isEmpty)
679                             .collect(Collectors.toList());
680             } else {
681                 body = Collections.emptyList();
682             }
683 
684             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
685             if (arguments.contains(&quot;assignees&quot;)) {
686                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
687                 var assignees = usernames.stream()
688                                          .map(u -&gt; host.user(u))
689                                          .collect(Collectors.toList());
690                 pr.setAssignees(assignees);
691             }
692             System.out.println(pr.webUrl().toString());
693             Files.deleteIfExists(file);
694         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
695             var pr = getPullRequest(uri, repo, host, arguments.at(1));
696 
697             if (action.equals(&quot;integrate&quot;)) {
698                 pr.addComment(&quot;/integrate&quot;);
699             } else if (action.equals(&quot;test&quot;)) {
700                 pr.addComment(&quot;/test&quot;);
701             } else if (action.equals(&quot;approve&quot;)) {
702                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
703             } else {
704                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
705             }
706         } else if (action.equals(&quot;list&quot;)) {
707             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
708             var prs = remoteRepo.pullRequests();
709             var ids = new ArrayList&lt;String&gt;();
710             var titles = new ArrayList&lt;String&gt;();
711             var authors = new ArrayList&lt;String&gt;();
712             var assignees = new ArrayList&lt;String&gt;();
713             var labels = new ArrayList&lt;String&gt;();
714 
715             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
716                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
717                 Set.of();
718             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
719                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
720                 Set.of();
721             var filterLabels = arguments.contains(&quot;labels&quot;) ?
722                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
723                 Set.of();
724 
725             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
726             var columnValues = Map.of(defaultColumns.get(0), ids,
727                                       defaultColumns.get(1), titles,
728                                       defaultColumns.get(2), authors,
729                                       defaultColumns.get(3), assignees,
730                                       defaultColumns.get(4), labels);
731             var columns = arguments.contains(&quot;columns&quot;) ?
732                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
733                 defaultColumns;
734             if (columns != defaultColumns) {
735                 for (var column : columns) {
736                     if (!defaultColumns.contains(column)) {
737                         System.err.println(&quot;error: unknown column: &quot; + column);
738                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
739                         System.exit(1);
740                     }
741                 }
742             }
743 
744             for (var pr : prs) {
745                 var prAuthor = pr.author().userName();
746                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
747                     continue;
748                 }
749 
750                 var prAssignees = pr.assignees().stream()
751                                     .map(HostUser::userName)
752                                     .collect(Collectors.toSet());
753                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
754                     continue;
755                 }
756 
757                 var prLabels = new HashSet&lt;&gt;(pr.labels());
758                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
759                     continue;
760                 }
761 
762                 ids.add(pr.id());
763                 titles.add(pr.title());
764                 authors.add(prAuthor);
765                 assignees.add(String.join(&quot;,&quot;, prAssignees));
766                 labels.add(String.join(&quot;,&quot;, prLabels));
767             }
768 
769 
770             String fmt = &quot;&quot;;
771             for (var column : columns.subList(0, columns.size() - 1)) {
772                 var values = columnValues.get(column);
773                 var n = Math.max(column.length(), longest(values));
774                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
775             }
776             fmt += &quot;%s\n&quot;;
777 
778             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
779                 var upperCase = columns.stream()
780                                        .map(String::toUpperCase)
781                                        .collect(Collectors.toList());
782                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
783             }
784             for (var i = 0; i &lt; ids.size(); i++) {
785                 final int n = i;
786                 var row = columns.stream()
787                                  .map(columnValues::get)
788                                  .map(values -&gt; values.get(n))
789                                  .collect(Collectors.toList());
790                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
791             }
792         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
793             var prId = arguments.at(1);
794             if (!prId.isPresent()) {
795                 exit(&quot;error: missing pull request identifier&quot;);
796             }
797 
798             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
799             var pr = remoteRepo.pullRequest(prId.asString());
800             var repoUrl = remoteRepo.webUrl();
801             var prHeadRef = pr.sourceRef();
802             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
803             if (isHgGit) {
804                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
805                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
806 
807                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
808                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
809                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
810 
811                     if (action.equals(&quot;show&quot;)) {
812                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
813                     } else {
814                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
815                         hgImport(patch);
816                         Files.delete(patch);
817                     }
818                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
819                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
820                     var hgGitBranches = hgGitRepo.branches();
821                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
822                         hgGitRepo.delete(new Branch(hgGitRef));
823                     }
824                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
825                     gimport();
826                     var hgFetchHead = repo.resolve(hgGitRef).get();
827 
828                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
829                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
830                     } else if (action.equals(&quot;checkout&quot;)) {
831                         repo.checkout(hgFetchHead);
832                         if (arguments.contains(&quot;branch&quot;)) {
833                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
834                         }
835                     }
836                 } else {
837                     exit(&quot;Unexpected action: &quot; + action);
838                 }
839 
840                 return;
841             }
842 
843             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
844             if (action.equals(&quot;fetch&quot;)) {
845                 if (arguments.contains(&quot;branch&quot;)) {
846                     var branchName = arguments.get(&quot;branch&quot;).asString();
847                     repo.branch(fetchHead, branchName);
848                 } else {
849                     System.out.println(fetchHead.hex());
850                 }
851             } else if (action.equals(&quot;checkout&quot;)) {
852                 if (arguments.contains(&quot;branch&quot;)) {
853                     var branchName = arguments.get(&quot;branch&quot;).asString();
854                     var branch = repo.branch(fetchHead, branchName);
855                     repo.checkout(branch, false);
856                 } else {
857                     repo.checkout(fetchHead, false);
858                 }
859             } else if (action.equals(&quot;show&quot;)) {
860                 show(pr.targetRef(), fetchHead);
861             } else if (action.equals(&quot;apply&quot;)) {
862                 var patch = diff(pr.targetRef(), fetchHead);
863                 apply(patch);
864                 Files.deleteIfExists(patch);
865             }
866         } else if (action.equals(&quot;close&quot;)) {
867             var prId = arguments.at(1);
868             if (!prId.isPresent()) {
869                 exit(&quot;error: missing pull request identifier&quot;);
870             }
871 
872             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
873             var pr = remoteRepo.pullRequest(prId.asString());
874             pr.setState(PullRequest.State.CLOSED);
875         } else if (action.equals(&quot;update&quot;)) {
876             var prId = arguments.at(1);
877             if (!prId.isPresent()) {
878                 exit(&quot;error: missing pull request identifier&quot;);
879             }
880 
881             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
882             var pr = remoteRepo.pullRequest(prId.asString());
883             if (arguments.contains(&quot;assignees&quot;)) {
884                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
885                 var assignees = usernames.stream()
886                     .map(u -&gt; host.user(u))
887                     .collect(Collectors.toList());
888                 pr.setAssignees(assignees);
889             }
890         } else {
891             exit(&quot;error: unexpected action: &quot; + action);
892         }
893     }
894 }
    </pre>
  </body>
</html>