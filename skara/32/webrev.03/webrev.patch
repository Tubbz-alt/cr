diff a/args/src/main/java/org/openjdk/skara/args/Command.java b/args/src/main/java/org/openjdk/skara/args/Command.java
--- /dev/null
+++ b/args/src/main/java/org/openjdk/skara/args/Command.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.args;
+
+@FunctionalInterface
+public interface Command {
+    void execute(String[] args) throws Exception;
+}
diff a/args/src/main/java/org/openjdk/skara/args/SubCommandSwitch.java b/args/src/main/java/org/openjdk/skara/args/SubCommandSwitch.java
--- /dev/null
+++ b/args/src/main/java/org/openjdk/skara/args/SubCommandSwitch.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.args;
+
+import java.io.PrintStream;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+public class SubCommandSwitch implements Command {
+
+    private static final SubCommandEntry errorCommand = new SubCommandEntry("", "",
+            args -> System.out.println("error: unknown subcommand: " + args[0]));
+
+    private final String programName;
+    private final String defaultCommand;
+    private final Map<String, SubCommandEntry> subCommands;
+
+    private SubCommandSwitch(String programName, String defaultCommand, Map<String, SubCommandEntry> subCommands) {
+        this.programName = programName;
+        this.subCommands = subCommands;
+        this.subCommands.put("help", helpCommand());
+        this.defaultCommand = defaultCommand;
+    }
+
+    private SubCommandEntry helpCommand() {
+        return new SubCommandEntry("help", "print a help message", args -> showUsage());
+    }
+
+    public static Builder builder(String programName) {
+        return new Builder(programName);
+    }
+
+    @Override
+    public void execute(String[] args) throws Exception {
+        if (args.length != 0) {
+            SubCommandEntry p = subCommands.get(args[0]);
+            if (p != null) {
+                String[] forwardedArgs = Arrays.copyOfRange(args, 1, args.length);
+                p.command.execute(forwardedArgs);
+            } else {
+                subCommands.getOrDefault(defaultCommand, errorCommand).command.execute(args);
+            }
+        } else {
+            showUsage();
+        }
+    }
+
+    private void showUsage() {
+        showUsage(System.out);
+    }
+
+    private void showUsage(PrintStream ps) {
+        ps.print("usage: ");
+        ps.print(programName);
+        ps.print(subCommands.keySet().stream().collect(Collectors.joining("|", " <", ">")));
+        ps.println(" <input>");
+
+        int spacing = subCommands.keySet().stream().mapToInt(String::length).max().orElse(0);
+        spacing += 8; // some room
+
+        for (var subCommand : subCommands.values()) {
+            ps.println(String.format("  %-" + spacing + "s%s", subCommand.name, subCommand.description));
+        }
+    }
+
+    private static class SubCommandEntry {
+        private final String name;
+        private final String description;
+        private final Command command;
+
+        public SubCommandEntry(String name, String description, Command command) {
+            this.name = name;
+            this.description = description;
+            this.command = command;
+        }
+    }
+
+    public static class Builder {
+        private final String programName;
+
+        private String defaultCommand;
+        private final Map<String,  SubCommandEntry> subCommands = new HashMap<>();
+
+        private Builder(String programName) {
+            this.programName = programName;
+        }
+
+        public Builder defaultCommand(String command, String description, Command action) {
+            subCommand(command, description, action);
+            this.defaultCommand = command;
+            return this;
+        }
+
+        public Builder subCommand(String command, String description, Command action) {
+            subCommands.put(command, new SubCommandEntry(command, description, action));
+            return this;
+        }
+
+        public SubCommandSwitch build() {
+            return new SubCommandSwitch(programName, defaultCommand, subCommands);
+        }
+    }
+}
diff a/cli/src/main/java/org/openjdk/skara/cli/GitSkara.java b/cli/src/main/java/org/openjdk/skara/cli/GitSkara.java
--- a/cli/src/main/java/org/openjdk/skara/cli/GitSkara.java
+++ b/cli/src/main/java/org/openjdk/skara/cli/GitSkara.java
@@ -20,10 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.cli;
 
+import org.openjdk.skara.args.Command;
 import org.openjdk.skara.vcs.Repository;
 
 import java.io.IOException;
 import java.nio.file.Path;
 import java.nio.charset.StandardCharsets;
@@ -30,17 +30,12 @@
 import java.util.Arrays;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
-import java.util.function.Consumer;
 
 public class GitSkara {
-    @FunctionalInterface
-    private interface Command {
-        void execute(String[] args) throws Exception;
-    }
 
     private static final Map<String, Command> commands = new TreeMap<>();
 
     private static void usage(String[] args) {
         var names = new ArrayList<String>();
diff a/cli/src/main/java/org/openjdk/skara/cli/GitWebrev.java b/cli/src/main/java/org/openjdk/skara/cli/GitWebrev.java
--- a/cli/src/main/java/org/openjdk/skara/cli/GitWebrev.java
+++ b/cli/src/main/java/org/openjdk/skara/cli/GitWebrev.java
@@ -26,15 +27,16 @@
 import org.openjdk.skara.webrev.*;
 
 import java.io.*;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
 import java.nio.file.*;
 import java.util.*;
-import java.util.jar.Manifest;
-import java.util.stream.*;
+import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 public class GitWebrev {
     private static void clearDirectory(Path directory) {
         try {
@@ -77,11 +79,11 @@
             die(message);
             return null; // impossible
         }
     }
 
-    public static void main(String[] args) throws IOException {
+    private static void generate(String[] args) throws IOException {
         var flags = List.of(
             Option.shortcut("r")
                   .fullname("rev")
                   .describe("REV")
                   .helptext("Compare against a specified revision")
@@ -136,11 +138,11 @@
                 Input.position(0)
                      .describe("rev")
                      .singular()
                      .optional());
 
-        var parser = new ArgumentParser("git webrev", flags, inputs);
+        var parser = new ArgumentParser("git webrev generate", flags, inputs);
         var arguments = parser.parse(args);
 
         var version = Version.fromManifest().orElse("unknown");
         if (arguments.contains("version")) {
             System.out.println("git-webrev version: " + version);
@@ -254,7 +257,80 @@
               .username(username)
               .issue(issue)
               .version(version)
               .generate(rev);
     }
+
+    private static void apply(String[] args) throws Exception {
+        var inputs = List.of(
+            Input.position(0)
+                .describe("webrev url")
+                .singular()
+                .required());
+
+        var parser = new ArgumentParser("git webrev apply", List.of(), inputs);
+        var arguments = parser.parse(args);
+
+        var inputString = arguments.at(0).asString();
+        var webrevMetaData = WebrevMetaData.fromWebrevURL(inputString);
+        var patchFileURI = webrevMetaData.patchURI()
+                .orElseThrow(() -> new IllegalStateException("Could not find patch file in webrev"));
+        var patchFile = downloadPatchFile(patchFileURI);
+
+        var cwd = Paths.get("").toAbsolutePath();
+        var repository = Repository.get(cwd);
+        if (repository.isEmpty()) {
+            System.err.println(String.format("error: %s is not a repository", cwd.toString()));
+            System.exit(1);
+        }
+
+        if (!check(patchFile)) {
+            System.err.println("Patch does not apply cleanly!");
+            System.exit(1);
+        }
+
+        System.out.println("Applying patch file: " + patchFile);
+        stat(patchFile);
+        apply(patchFile);
+    }
+
+    private static Path downloadPatchFile(URI uri) throws IOException, InterruptedException {
+        var client = HttpClient.newHttpClient();
+        var patchFile = Files.createTempFile("patch", ".patch");
+        var patchFileRequest = HttpRequest.newBuilder()
+                .uri(uri)
+                .build();
+        client.send(patchFileRequest, HttpResponse.BodyHandlers.ofFile(patchFile));
+        return patchFile;
+    }
+
+    private static boolean check(Path patchFile) throws IOException, InterruptedException {
+        return applyInternal(patchFile, "--check", "--index") == 0;
+    }
+
+    private static void stat(Path patchFile) throws IOException, InterruptedException {
+        applyInternal(patchFile, "--stat", "--index");
+    }
+
+    private static void apply(Path patchFile) throws IOException, InterruptedException {
+        applyInternal(patchFile, "--index");
+    }
+
+    private static int applyInternal(Path patchFile, String...options) throws IOException, InterruptedException {
+        List<String> args = new ArrayList<>();
+        args.add("git");
+        args.add("apply");
+        args.addAll(Arrays.asList(options));
+        args.add(patchFile.toString());
+        var pb = new ProcessBuilder(args.toArray(String[]::new));
+        pb.inheritIO();
+        return pb.start().waitFor();
+    }
+
+    public static void main(String[] args) throws Exception {
+        SubCommandSwitch.builder("git webrev")
+                .defaultCommand("generate", "generate a webrev", GitWebrev::generate)
+                .subCommand("apply", "apply a webrev from a webrev url", GitWebrev::apply)
+                .build()
+                .execute(args);
+    }
 }
diff a/webrev/src/main/java/module-info.java b/webrev/src/main/java/module-info.java
--- a/webrev/src/main/java/module-info.java
+++ b/webrev/src/main/java/module-info.java
@@ -19,9 +20,9 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 module org.openjdk.skara.webrev {
     requires org.openjdk.skara.vcs;
+    requires java.net.http;
 
     exports org.openjdk.skara.webrev;
 }
diff a/webrev/src/main/java/org/openjdk/skara/webrev/WebrevMetaData.java b/webrev/src/main/java/org/openjdk/skara/webrev/WebrevMetaData.java
--- /dev/null
+++ b/webrev/src/main/java/org/openjdk/skara/webrev/WebrevMetaData.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.webrev;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class WebrevMetaData {
+    private static final Pattern findPatchPattern = Pattern.compile(
+            "[ ]*(?:<td>)?<a href=\".*\">(?<patchName>.*\\.patch)</a></td>(?:</tr>)?$");
+
+    private final Optional<URI> patchURI;
+
+    public WebrevMetaData(Optional<URI> patchURI) {
+        this.patchURI = patchURI;
+    }
+
+    public static WebrevMetaData fromWebrevURL(String uri) throws IOException, URISyntaxException, InterruptedException {
+        var sanatizedUri = sanitizeURI(uri);
+        var patchFile = getPatchFile(sanatizedUri);
+
+        return new WebrevMetaData(patchFile);
+    }
+
+    private static String dropSuffix(String s, String suffix) {
+        if (s.endsWith(suffix)) {
+            s = s.substring(0, s.length() - suffix.length());
+        }
+        return s;
+    }
+
+    private static URI sanitizeURI(String uri) throws URISyntaxException {
+        uri = dropSuffix(uri, "index.html");
+        return new URI(uri);
+    }
+
+    private static Optional<URI> getPatchFile(URI uri) throws IOException, InterruptedException {
+        var client = HttpClient.newHttpClient();
+        var findPatchFileRcequest = HttpRequest.newBuilder()
+                .uri(uri)
+                .build();
+        return client.send(findPatchFileRcequest, HttpResponse.BodyHandlers.ofLines())
+                .body()
+                .map(findPatchPattern::matcher)
+                .filter(Matcher::matches)
+                .findFirst()
+                .map(m -> m.group("patchName"))
+                .map(uri::resolve);
+    }
+
+    public Optional<URI> patchURI() {
+        return patchURI;
+    }
+}
