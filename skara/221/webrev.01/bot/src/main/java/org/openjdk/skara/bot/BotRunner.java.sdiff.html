<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bot/src/main/java/org/openjdk/skara/bot/BotRunner.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/org/openjdk/skara/bot/BotRunnerTests.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bot/src/main/java/org/openjdk/skara/bot/BotRunner.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
160                     } catch (InterruptedException | ExecutionException e) {
161                         log.warning(&quot;Exception during queue drain&quot;);
162                         log.throwing(&quot;BotRunner&quot;, &quot;drain&quot;, e);
163                     }
164                 } else {
165                     log.finest(&quot;Queue is now empty&quot;);
166                     break;
167                 }
168             }
169 
170             synchronized (executor) {
171                 if (pending.isEmpty() &amp;&amp; active.isEmpty()) {
172                     log.fine(&quot;Nothing awaiting scheduling - drain is finished&quot;);
173                     return;
174                 } else {
175                     log.finest(&quot;Waiting for flighted tasks&quot;);
176                 }
177             }
178             try {
179                 Thread.sleep(1);
<span class="line-removed">180                 watchdog();</span>
181             } catch (InterruptedException e) {
182                 log.warning(&quot;Exception during queue drain&quot;);
183                 log.throwing(&quot;BotRunner&quot;, &quot;drain&quot;, e);
184             }
185         }
186 
187         throw new TimeoutException();
188     }
189 
190     private final BotRunnerConfiguration config;
191     private final List&lt;Bot&gt; bots;
192     private final ScheduledThreadPoolExecutor executor;
193     private final Logger log;
194 
195     public BotRunner(BotRunnerConfiguration config, List&lt;Bot&gt; bots) {
196         this.config = config;
197         this.bots = bots;
198 
199         pending = new HashMap&lt;&gt;();
200         active = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
242 
243     private void processRestRequest(JSONValue request) {
244         log.log(Level.FINE, &quot;Starting processing of incoming rest request&quot;, TaskPhases.BEGIN);
245         log.fine(&quot;Request: &quot; + request);
246         try {
247             for (var bot : bots) {
248                 var items = bot.processWebHook(request);
249                 for (var item : items) {
250                     submitOrSchedule(item);
251                 }
252             }
253         } catch (RuntimeException e) {
254             log.severe(&quot;Exception during rest request processing: &quot; + e.getMessage());
255             log.throwing(&quot;BotRunner&quot;, &quot;processRestRequest&quot;, e);
256         } finally {
257             log.log(Level.FINE, &quot;Done processing incoming rest request&quot;, TaskPhases.END);
258         }
259     }
260 
261     public void run() {
<span class="line-modified">262         log.info(&quot;Starting BotRunner execution, will run forever.&quot;);</span>



263         log.info(&quot;Periodic task interval: &quot; + config.scheduledExecutionPeriod());
264         log.info(&quot;Concurrency: &quot; + config.concurrency());
265 
266         RestReceiver restReceiver = null;
267         if (config.restReceiverPort().isPresent()) {
268             log.info(&quot;Listening for webhooks on port: &quot; + config.restReceiverPort().get());
269             try {
270                 restReceiver = new RestReceiver(config.restReceiverPort().get(), this::processRestRequest);
271             } catch (IOException e) {
272                 log.warning(&quot;Failed to create RestReceiver&quot;);
273                 log.throwing(&quot;BotRunner&quot;, &quot;run&quot;, e);
274             }
275         }
276 
277         executor.scheduleAtFixedRate(this::watchdog, 0,
278                                      config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
279         executor.scheduleAtFixedRate(this::checkPeriodicItems, 0,
280                                      config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
281 
282         try {
<span class="line-modified">283             executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);</span>
284         } catch (InterruptedException e) {
285             e.printStackTrace();
286         }
287 
288         if (restReceiver != null) {
289             restReceiver.close();
290         }
291         executor.shutdown();
292     }
293 
294     public void runOnce(Duration timeout) throws TimeoutException {
295         log.info(&quot;Starting BotRunner execution, will run once&quot;);
296         log.info(&quot;Timeout: &quot; + timeout);
297         log.info(&quot;Concurrency: &quot; + config.concurrency());
298 
299         var periodics = executor.submit(this::checkPeriodicItems);
300         try {
301             log.fine(&quot;Make sure periodics execute at least once&quot;);
302             periodics.get();
303             log.fine(&quot;Periodics have now run&quot;);
</pre>
</td>
<td>
<hr />
<pre>
160                     } catch (InterruptedException | ExecutionException e) {
161                         log.warning(&quot;Exception during queue drain&quot;);
162                         log.throwing(&quot;BotRunner&quot;, &quot;drain&quot;, e);
163                     }
164                 } else {
165                     log.finest(&quot;Queue is now empty&quot;);
166                     break;
167                 }
168             }
169 
170             synchronized (executor) {
171                 if (pending.isEmpty() &amp;&amp; active.isEmpty()) {
172                     log.fine(&quot;Nothing awaiting scheduling - drain is finished&quot;);
173                     return;
174                 } else {
175                     log.finest(&quot;Waiting for flighted tasks&quot;);
176                 }
177             }
178             try {
179                 Thread.sleep(1);

180             } catch (InterruptedException e) {
181                 log.warning(&quot;Exception during queue drain&quot;);
182                 log.throwing(&quot;BotRunner&quot;, &quot;drain&quot;, e);
183             }
184         }
185 
186         throw new TimeoutException();
187     }
188 
189     private final BotRunnerConfiguration config;
190     private final List&lt;Bot&gt; bots;
191     private final ScheduledThreadPoolExecutor executor;
192     private final Logger log;
193 
194     public BotRunner(BotRunnerConfiguration config, List&lt;Bot&gt; bots) {
195         this.config = config;
196         this.bots = bots;
197 
198         pending = new HashMap&lt;&gt;();
199         active = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
241 
242     private void processRestRequest(JSONValue request) {
243         log.log(Level.FINE, &quot;Starting processing of incoming rest request&quot;, TaskPhases.BEGIN);
244         log.fine(&quot;Request: &quot; + request);
245         try {
246             for (var bot : bots) {
247                 var items = bot.processWebHook(request);
248                 for (var item : items) {
249                     submitOrSchedule(item);
250                 }
251             }
252         } catch (RuntimeException e) {
253             log.severe(&quot;Exception during rest request processing: &quot; + e.getMessage());
254             log.throwing(&quot;BotRunner&quot;, &quot;processRestRequest&quot;, e);
255         } finally {
256             log.log(Level.FINE, &quot;Done processing incoming rest request&quot;, TaskPhases.END);
257         }
258     }
259 
260     public void run() {
<span class="line-modified">261         run(Duration.ofDays(10 * 365));</span>
<span class="line-added">262     }</span>
<span class="line-added">263 </span>
<span class="line-added">264     public void run(Duration timeout) {</span>
265         log.info(&quot;Periodic task interval: &quot; + config.scheduledExecutionPeriod());
266         log.info(&quot;Concurrency: &quot; + config.concurrency());
267 
268         RestReceiver restReceiver = null;
269         if (config.restReceiverPort().isPresent()) {
270             log.info(&quot;Listening for webhooks on port: &quot; + config.restReceiverPort().get());
271             try {
272                 restReceiver = new RestReceiver(config.restReceiverPort().get(), this::processRestRequest);
273             } catch (IOException e) {
274                 log.warning(&quot;Failed to create RestReceiver&quot;);
275                 log.throwing(&quot;BotRunner&quot;, &quot;run&quot;, e);
276             }
277         }
278 
279         executor.scheduleAtFixedRate(this::watchdog, 0,
280                                      config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
281         executor.scheduleAtFixedRate(this::checkPeriodicItems, 0,
282                                      config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
283 
284         try {
<span class="line-modified">285             executor.awaitTermination(timeout.toMillis(), TimeUnit.MILLISECONDS);</span>
286         } catch (InterruptedException e) {
287             e.printStackTrace();
288         }
289 
290         if (restReceiver != null) {
291             restReceiver.close();
292         }
293         executor.shutdown();
294     }
295 
296     public void runOnce(Duration timeout) throws TimeoutException {
297         log.info(&quot;Starting BotRunner execution, will run once&quot;);
298         log.info(&quot;Timeout: &quot; + timeout);
299         log.info(&quot;Concurrency: &quot; + config.concurrency());
300 
301         var periodics = executor.submit(this::checkPeriodicItems);
302         try {
303             log.fine(&quot;Make sure periodics execute at least once&quot;);
304             periodics.get();
305             log.fine(&quot;Periodics have now run&quot;);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/org/openjdk/skara/bot/BotRunnerTests.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>