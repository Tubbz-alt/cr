<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.hg;
  24 
  25 import org.openjdk.skara.process.Process;
  26 import org.openjdk.skara.process.Execution;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.nio.file.*;
  32 import java.time.*;
  33 import java.time.format.DateTimeFormatter;
  34 import java.util.*;
  35 import java.util.logging.Logger;
  36 import java.util.stream.*;
  37 import java.net.URI;
  38 
  39 public class HgRepository implements Repository {
  40     private static final String EXT_PY = &quot;ext.py&quot;;
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.hg&quot;);
  43 
  44     private void copyResource(String name, Path p) throws IOException {
  45         Files.copy(this.getClass().getResourceAsStream(&quot;/&quot; + name), p, StandardCopyOption.REPLACE_EXISTING);
  46     }
  47 
  48     private java.lang.Process start(String... cmd) throws IOException {
  49         return start(Arrays.asList(cmd));
  50     }
  51 
  52     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  53         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  54         var pb = new ProcessBuilder(cmd);
  55         pb.directory(dir.toFile());
  56         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  57         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
  58         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
  59         return pb.start();
  60     }
  61 
  62     private static void stop(java.lang.Process p) throws IOException {
  63         if (p != null &amp;&amp; p.isAlive()) {
  64             var stream = p.getInputStream();
  65             var read = 0;
  66             var buf = new byte[128];
  67             while (read != -1) {
  68                 read = stream.read(buf);
  69             }
  70             try {
  71                 p.waitFor();
  72             } catch (InterruptedException e) {
  73                 throw new IOException(e);
  74             }
  75         }
  76     }
  77 
  78     private Execution capture(List&lt;String&gt; cmd) {
  79         return capture(cmd.toArray(new String[0]));
  80     }
  81 
  82     private Execution capture(String... cmd) {
  83         return capture(dir, cmd);
  84     }
  85 
  86     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  87         return capture(cwd, cmd.toArray(new String[0]));
  88     }
  89     private static Execution capture(Path cwd, String... cmd) {
  90         return Process.capture(cmd)
  91                       .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
  92                       .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
  93                       .workdir(cwd)
  94                       .execute();
  95     }
  96 
  97     private static Execution.Result await(Execution e) throws IOException {
  98         var result = e.await();
  99         if (result.status() != 0) {
 100             if (result.exception().isPresent()) {
 101                 throw new IOException(&quot;Unexpected exit code\n&quot; + result, result.exception().get());
 102             } else {
 103                 throw new IOException(&quot;Unexpected exit code\n&quot; + result);
 104             }
 105         }
 106         return result;
 107     }
 108 
 109     private static void await(java.lang.Process p) throws IOException {
 110         try {
 111             var res = p.waitFor();
 112             if (res != 0) {
 113                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 114             }
 115         } catch (InterruptedException e) {
 116             throw new IOException(e);
 117         }
 118     }
 119 
 120     public HgRepository(Path dir) {
 121         this.dir = dir.toAbsolutePath();
 122     }
 123 
 124     @Override
 125     public List&lt;Branch&gt; branches() throws IOException {
 126         try (var p = capture(&quot;hg&quot;, &quot;branches&quot;)) {
 127             return await(p).stdout()
 128                            .stream()
 129                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 130                            .map(Branch::new)
 131                            .collect(Collectors.toList());
 132         }
 133     }
 134 
 135     @Override
 136     public List&lt;Tag&gt; tags() throws IOException {
 137         try (var p = capture(&quot;hg&quot;, &quot;tags&quot;)) {
 138             return await(p).stdout()
 139                            .stream()
 140                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 141                            .map(Tag::new)
 142                            .collect(Collectors.toList());
 143         }
 144     }
 145 
 146     @Override
 147     public Path root() throws IOException {
 148         try (var p = capture(&quot;hg&quot;, &quot;root&quot;)) {
 149             var res = await(p);
 150             if (res.stdout().size() != 1) {
 151                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 152             }
 153             return Paths.get(res.stdout().get(0));
 154         }
 155     }
 156 
 157     private void checkout(String ref, boolean force) throws IOException {
 158         var cmd = new ArrayList&lt;String&gt;();
 159         cmd.addAll(List.of(&quot;hg&quot;, &quot;update&quot;));
 160         if (!force) {
 161             cmd.add(&quot;--check&quot;);
 162         }
 163         cmd.add(ref);
 164         try (var p = capture(cmd)) {
 165             await(p);
 166         }
 167     }
 168 
 169     @Override
 170     public void checkout(Hash h, boolean force) throws IOException {
 171         checkout(h.hex(), force);
 172     }
 173 
 174     @Override
 175     public void checkout(Branch b, boolean force) throws IOException {
 176         checkout(b.name(), force);
 177     }
 178 
 179     @Override
 180     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 181         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + ref, &quot;--template={node}\n&quot;)) {
 182             var res = p.await();
 183             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 184                 return Optional.of(new Hash(res.stdout().get(0)));
 185             }
 186             return Optional.empty();
 187         }
 188     }
 189 
 190     @Override
 191     public Commits commits() throws IOException {
 192         return commits(null, -1, false);
 193     }
 194 
 195     @Override
 196     public Commits commits(boolean reverse) throws IOException {
 197         return commits(null, -1, reverse);
 198     }
 199 
 200     @Override
 201     public Commits commits(int n) throws IOException {
 202         return commits(null, n, false);
 203     }
 204 
 205     @Override
 206     public Commits commits(int n, boolean reverse) throws IOException {
 207         return commits(null, n, reverse);
 208     }
 209 
 210     @Override
 211     public Commits commits(String range) throws IOException {
 212         return commits(range, -1, false);
 213     }
 214 
 215     @Override
 216     public Commits commits(String range, int n) throws IOException {
 217         return commits(range, n, false);
 218     }
 219 
 220     @Override
 221     public Commits commits(String range, boolean reverse) throws IOException {
 222         return commits(range, -1, reverse);
 223     }
 224 
 225     @Override
 226     public Commits commits(String range, int n,  boolean reverse) throws IOException {
 227         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 228         copyResource(EXT_PY, ext);
 229         return new HgCommits(dir, range, ext, reverse, n);
 230     }
 231 
 232     @Override
 233     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 234         var commits = commits(h.hex()).asList();
 235         if (commits.size() != 1) {
 236             return Optional.empty();
 237         }
 238         return Optional.of(commits.get(0));
 239     }
 240 
 241     @Override
 242     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 243         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 244         return lookup(hash);
 245     }
 246 
 247     @Override
 248     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 249         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 250         return lookup(hash);
 251     }
 252 
 253     @Override
 254     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 255         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 256         copyResource(EXT_PY, ext);
 257 
 258         var p = start(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.dump=&quot; + ext.toAbsolutePath().toString(), &quot;metadata&quot;);
 259         var reader = new UnixStreamReader(p.getInputStream());
 260         var result = new ArrayList&lt;CommitMetadata&gt;();
 261 
 262         var line = reader.readLine();
 263         while (line != null) {
 264             result.add(HgCommitMetadata.read(reader));
 265             line = reader.readLine();
 266         }
 267 
 268         await(p);
 269         return result;
 270     }
 271 
 272     @Override
 273     public boolean isEmpty() throws IOException {
 274         var numBranches = branches().size();
 275         var numTags = tags().size();
 276 
 277         if (numBranches &gt; 0 || numTags &gt; 1) {
 278             return false;
 279         }
 280 
 281         var tip = resolve(&quot;tip&quot;);
 282         return tip.isEmpty() || tip.get().hex().equals(&quot;0&quot;.repeat(40));
 283     }
 284 
 285     @Override
 286     public boolean isHealthy() throws IOException {
 287         var root = root().toString();
 288         return !(Files.exists(Path.of(root, &quot;.hg&quot;, &quot;wlock&quot;)) ||
 289                  Files.exists(Path.of(root, &quot;.hg&quot;, &quot;store&quot;, &quot;lock&quot;)));
 290     }
 291 
 292     @Override
 293     public void clean() throws IOException {
 294         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 295             p.await();
 296         }
 297 
 298         try (var p = capture(&quot;hg&quot;, &quot;recover&quot;)) {
 299             p.await();
 300         }
 301 
 302         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--ignored&quot;, &quot;--no-status&quot;)) {
 303             var root = root().toString();
 304             for (var filename : await(p).stdout()) {
 305                 Files.delete(Path.of(root, filename));
 306             }
 307         }
 308 
 309         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 310             var root = root().toString();
 311             for (var filename : await(p).stdout()) {
 312                 Files.delete(Path.of(root, filename));
 313             }
 314         }
 315 
 316         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;)) {
 317             await(p);
 318         }
 319     }
 320 
 321     @Override
 322     public void reset(Hash target, boolean hard) throws IOException {
 323         throw new RuntimeException(&quot;Not implemented yet&quot;);
 324     }
 325 
 326     @Override
 327     public Repository reinitialize() throws IOException {
 328         Files.walk(dir)
 329              .map(Path::toFile)
 330              .sorted(Comparator.reverseOrder())
 331              .forEach(File::delete);
 332 
 333         return init();
 334     }
 335 
 336     @Override
 337     public Hash fetch(URI uri, String refspec) throws IOException {
 338         return fetch(uri != null ? uri.toString() : null, refspec);
 339     }
 340 
 341     private Hash fetch(String from, String refspec) throws IOException {
 342         var oldHeads = new HashSet&lt;Hash&gt;(heads());
 343 
 344         var cmd = new ArrayList&lt;String&gt;();
 345         cmd.add(&quot;hg&quot;);
 346         cmd.add(&quot;pull&quot;);
 347         if (refspec != null) {
 348             cmd.add(&quot;--rev&quot;);
 349             cmd.add(refspec);
 350         }
 351         if (from != null) {
 352             cmd.add(from);
 353         }
 354         try (var p = capture(cmd)) {
 355             await(p);
 356         }
 357 
 358         var newHeads = new HashSet&lt;Hash&gt;(heads());
 359         newHeads.removeAll(oldHeads);
 360 
 361         if (newHeads.size() &gt; 1) {
 362             throw new IllegalStateException(&quot;fetching multiple heads is not supported&quot;);
 363         } else if (newHeads.size() == 0) {
 364             // no new head was fetched, return current head
 365             return head();
 366         }
 367         return newHeads.iterator().next();
 368     }
 369 
 370     @Override
 371     public void fetchAll() throws IOException {
 372         var pullPaths = new ArrayList&lt;URI&gt;();
 373         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
 374             var res = await(p);
 375             for (var line : res.stdout()) {
 376                 var parts = line.split(&quot;=&quot;);
 377                 var name = parts[0].trim();
 378                 var uri = parts[1].trim();
 379                 if (!name.endsWith(&quot;-push&quot;)) {
 380                     pullPaths.add(URI.create(uri));
 381                 }
 382             }
 383         }
 384 
 385         for (var uri : pullPaths) {
 386             fetch(uri, null);
 387         }
 388     }
 389 
 390     @Override
 391     public void fetchRemote(String remote) throws IOException {
 392         fetch(remote, null);
 393     }
 394 
 395     @Override
 396     public void delete(Branch b) throws IOException {
 397         throw new RuntimeException(&quot;Branches cannot be deleted in Mercurial&quot;);
 398     }
 399 
 400     @Override
 401     public Repository init() throws IOException {
 402         if (!Files.exists(dir)) {
 403             Files.createDirectories(dir);
 404         }
 405 
 406         try (var p = capture(&quot;hg&quot;, &quot;init&quot;)) {
 407             await(p);
 408             return this;
 409         }
 410     }
 411 
 412     @Override
 413     public void pushAll(URI uri) throws IOException {
 414         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--new-branch&quot;, uri.toString())) {
 415             await(p);
 416         }
 417     }
 418 
 419     @Override
 420     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 421         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;push&quot;, &quot;--rev=&quot; + hash.hex()));
 422         if (force) {
 423             cmd.add(&quot;--force&quot;);
 424         }
 425         cmd.add(uri.toString() + &quot;#&quot; + ref);
 426         try (var p = capture(cmd)) {
 427             await(p);
 428         }
 429     }
 430 
 431     @Override
 432     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 433         // ignore setUpstream, no such concept in Mercurial
 434         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--branch&quot;, branch.name(), remote)) {
 435             await(p);
 436         }
 437     }
 438 
 439     @Override
 440     public boolean isClean() throws IOException {
 441         try (var p = capture(&quot;hg&quot;, &quot;status&quot;)) {
 442             var output = await(p);
 443             return output.stdout().size() == 0;
 444         }
 445     }
 446 
 447     @Override
 448     public boolean exists() throws IOException {
 449         if (!Files.exists(dir)) {
 450             return false;
 451         }
 452 
 453         try {
 454             root();
 455             return true;
 456         } catch (IOException e) {
 457             return false;
 458         }
 459     }
 460 
 461     private void export(String revset, Path to) throws IOException {
 462         var cmd = List.of(&quot;hg&quot;, &quot;export&quot;, &quot;--git&quot;, &quot;--rev&quot;, revset);
 463         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
 464         var pb = new ProcessBuilder(cmd);
 465         pb.directory(dir.toFile());
 466         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
 467         pb.redirectOutput(to.toFile());
 468         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
 469         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
 470         var p = pb.start();
 471         try {
 472             await(p);
 473         } catch (Throwable t) {
 474             if (p.isAlive()) {
 475                 try {
 476                     p.waitFor();
 477                 } catch (InterruptedException e) {
 478                     throw new IOException(e);
 479                 }
 480             }
 481 
 482             throw new IOException(t);
 483         }
 484     }
 485 
 486     @Override
 487     public void squash(Hash h) throws IOException {
 488         var revset = &quot;.:&quot; + h.hex() + &quot; and not .&quot;;
 489         var patch = Files.createTempFile(&quot;squash&quot;, &quot;.patch&quot;);
 490         export(revset, patch);
 491 
 492         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.mq=&quot;, &quot;strip&quot;, &quot;--rev&quot;, revset)) {
 493             await(p);
 494         }
 495 
 496         try (var p = capture(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toString())) {
 497             await(p);
 498         }
 499     }
 500 
 501 
 502     @Override
 503     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 504         return commit(message, authorName, authorEmail, null);
 505     }
 506 
 507     @Override
 508     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 509         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 510         var cmd = new ArrayList&lt;String&gt;();
 511         cmd.addAll(List.of(&quot;hg&quot;, &quot;commit&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user));
 512         if (authorDate != null) {
 513             var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
 514             cmd.add(&quot;--date=&quot; + authorDate.format(formatter));
 515         }
 516         try (var p = capture(cmd)) {
 517             await(p);
 518         }
 519         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 520     }
 521 
 522     @Override
 523     public Hash commit(String message,
 524                        String authorName,
 525                        String authorEmail,
 526                        String committerName,
 527                        String committerEmail) throws IOException {
 528         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 529     }
 530 
 531     @Override
 532     public Hash commit(String message,
 533                        String authorName,
 534                        String authorEmail,
 535                        ZonedDateTime authorDate,
 536                        String committerName,
 537                        String committerEmail,
 538                        ZonedDateTime committerDate) throws IOException {
 539         if (!Objects.equals(authorName, committerName) ||
 540             !Objects.equals(authorEmail, committerEmail) ||
 541             !Objects.equals(authorDate, committerDate)) {
 542             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 543         }
 544 
 545         return commit(message, authorName, authorEmail, authorDate);
 546     }
 547 
 548     @Override
 549     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 550         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 551         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user)) {
 552             await(p);
 553         }
 554         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 555     }
 556 
 557     @Override
 558     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 559         if (!Objects.equals(authorName, committerName) ||
 560             !Objects.equals(authorEmail, committerEmail)) {
 561             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 562         }
 563 
 564         return amend(message, authorName, authorEmail);
 565     }
 566 
 567     @Override
 568     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 569         var user = authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 570         try (var p = capture(&quot;hg&quot;, &quot;tag&quot;,
 571                              &quot;--message&quot;, message,
 572                              &quot;--user&quot;, user,
 573                              &quot;--rev&quot;, hash.hex(),
 574                              name)) {
 575             await(p);
 576         }
 577 
 578         return new Tag(name);
 579     }
 580 
 581     @Override
 582     public Branch branch(Hash hash, String name) throws IOException {
 583         // Model a lightweight branch with a bookmark. Not ideal but the
 584         // closest to git branches.
 585         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--rev&quot;, hash.hex(), name)) {
 586             await(p);
 587         }
 588 
 589         return new Branch(name);
 590     }
 591 
<a name="1" id="anc1"></a>









 592     @Override
 593     public Hash mergeBase(Hash first, Hash second) throws IOException {
 594         var revset = &quot;ancestor(&quot; + first.hex() + &quot;, &quot; + second.hex() + &quot;)&quot;;
 595         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + revset, &quot;--template={node}\n&quot;)) {
 596             var res = await(p);
 597             if (res.stdout().size() != 1) {
 598                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 599             }
 600             return new Hash(res.stdout().get(0));
 601         }
 602     }
 603 
 604     @Override
 605     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 606         throw new RuntimeException(&quot;Not implemented yet&quot;);
 607     }
 608 
 609     @Override
 610     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 611         var current = currentBranch().orElseThrow(() -&gt;
 612                 new IOException(&quot;No current branch to rebase upon&quot;)
 613         );
 614         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.rebase=&quot;,
 615                              &quot;rebase&quot;, &quot;--dest&quot;, hash.hex(), &quot;--base&quot;, current.name())) {
 616             await(p);
 617         }
 618     }
 619 
 620     @Override
 621     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 622         try (var p = capture(&quot;hg&quot;, &quot;branch&quot;)) {
 623             var res = await(p);
 624             if (res.stdout().size() != 1) {
 625                 return Optional.empty();
 626             }
 627             return Optional.of(new Branch(res.stdout().get(0)));
 628         }
 629     }
 630 
 631     @Override
 632     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 633         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, &quot;.&quot;, &quot;--template&quot;, &quot;{activebookmark}\n&quot;)) {
 634             var res = await(p);
 635             if (res.stdout().size() == 1) {
 636                 return Optional.of(new Bookmark(res.stdout().get(0)));
 637             }
 638             return Optional.empty();
 639         }
 640     }
 641 
 642     @Override
 643     public Branch defaultBranch() throws IOException {
 644         return new Branch(&quot;default&quot;);
 645     }
 646 
 647     @Override
 648     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 649         return Optional.of(new Tag(&quot;tip&quot;));
 650     }
 651 
 652     @Override
 653     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 654         var output = Files.createTempFile(&quot;hg-cat-rev-&quot; + hash.abbreviate(), &quot;.bin&quot;);
 655         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output, &quot;--rev=&quot; + hash.hex(), path.toString())) {
 656             var res = p.await();
 657             if (res.status() == 0 &amp;&amp; Files.exists(output)) {
 658                 var bytes = Files.readAllBytes(output);
 659                 Files.delete(output);
 660                 return Optional.of(bytes);
 661             }
 662 
 663             if (Files.exists(output)) {
 664                 Files.delete(output);
 665             }
 666             return Optional.empty();
 667         }
 668     }
 669 
 670     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 671         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 672         copyResource(EXT_PY, ext);
 673 
 674         var include = new HashSet&lt;&gt;(paths);
 675 
 676         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-tree=&quot; + ext, &quot;ls-tree&quot;, hash.hex())) {
 677             var res = await(p);
 678             var entries = new ArrayList&lt;FileEntry&gt;();
 679             for (var line : res.stdout()) {
 680                 var parts = line.split(&quot;\t&quot;);
 681                 var metadata = parts[0].split(&quot; &quot;);
 682                 var path = Path.of(parts[1]);
 683                 if (include.isEmpty() || include.contains(path)) {
 684                     var entry = new FileEntry(hash,
 685                                               FileType.fromOctal(metadata[0]),
 686                                               new Hash(metadata[2]),
 687                                               path);
 688                     entries.add(entry);
 689                 }
 690             }
 691             return entries;
 692         }
 693     }
 694 
 695     @Override
 696     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 697         if (paths.isEmpty()) {
 698             return allFiles(hash, paths);
 699         }
 700 
 701         var entries = new ArrayList&lt;FileEntry&gt;();
 702         var batchSize = 64;
 703         var start = 0;
 704         while (start &lt; paths.size()) {
 705             var end = start + batchSize;
 706             if (end &gt; paths.size()) {
 707                 end = paths.size();
 708             }
 709             entries.addAll(allFiles(hash, paths.subList(start, end)));
 710             start = end;
 711         }
 712         return entries;
 713     }
 714 
 715     @Override
 716     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 717         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 718         copyResource(EXT_PY, ext);
 719 
 720         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath().toString(),
 721                                                &quot;diff-git-raw&quot;, from.hex(), to.hex())) {
 722             var res = await(p);
 723             var entries = new ArrayList&lt;StatusEntry&gt;();
 724             for (var line : res.stdout()) {
 725                 entries.add(StatusEntry.fromRawLine(line));
 726             }
 727             return entries;
 728         }
 729     }
 730 
 731     @Override
 732     public void dump(FileEntry entry, Path to) throws IOException {
 733         var output = to.toAbsolutePath();
 734         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output.toString(),
 735                                           &quot;--rev=&quot; + entry.commit(),
 736                                           entry.path().toString())) {
 737             await(p);
 738         }
 739     }
 740 
 741     @Override
 742     public void revert(Hash parent) throws IOException {
 743         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;, &quot;--rev&quot;, parent.hex())) {
 744             await(p);
 745         }
 746     }
 747 
 748     @Override
 749     public Diff diff(Hash from) throws IOException {
 750         return diff(from, List.of());
 751     }
 752 
 753     @Override
 754     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {
 755         return diff(from, null, files);
 756     }
 757 
 758     @Override
 759     public Diff diff(Hash from, Hash to) throws IOException {
 760         return diff(from, to, List.of());
 761     }
 762 
 763     @Override
 764     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {
 765         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 766         copyResource(EXT_PY, ext);
 767 
 768         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath(),
 769                                                 &quot;diff-git-raw&quot;, &quot;--patch&quot;, from.hex()));
 770         if (to != null) {
 771             cmd.add(to.hex());
 772         }
 773 
 774         if (files != null) {
 775             var filenames = files.stream().map(Path::toString).collect(Collectors.toList());
 776             cmd.add(&quot;--files=&quot; + String.join(&quot;,&quot;, filenames));
 777         }
 778 
 779         var p = start(cmd);
 780         try {
 781             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 782             await(p);
 783             return new Diff(from, to, patches);
 784         } catch (Throwable t) {
 785             throw new IOException(t);
 786         }
 787     }
 788 
 789     @Override
 790     public Optional&lt;String&gt; username() throws IOException {
 791         var lines = config(&quot;ui.username&quot;);
 792         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 793     }
 794 
 795     @Override
 796     public Hash head() throws IOException {
 797         return resolve(&quot;.&quot;).orElseThrow(() -&gt; new IOException(&quot;. not available&quot;));
 798     }
 799 
 800     private List&lt;Hash&gt; heads() throws IOException {
 801         var heads = new ArrayList&lt;Hash&gt;();
 802         try (var p = capture(&quot;hg&quot;, &quot;heads&quot;, &quot;--template={node}\n&quot;)) {
 803             var res = p.await();
 804             if (res.status() == 0) {
 805                 for (var hash : res.stdout()) {
 806                     heads.add(new Hash(hash));
 807                 }
 808             }
 809         }
 810         return heads;
 811     }
 812 
 813     @Override
 814     public List&lt;String&gt; config(String key) throws IOException {
 815         // Do not use HgRepository.capture() here, want to run *with*
 816         // hg configuration.
 817         try (var p = Process.capture(&quot;hg&quot;, &quot;showconfig&quot;, key)
 818                             .workdir(dir)
 819                             .execute()) {
 820             var res = p.await();
 821             if (res.status() == 1) {
 822                 return List.of();
 823             }
 824             return res.stdout();
 825         }
 826     }
 827 
 828     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 829         if (!Files.exists(p)) {
 830             return Optional.empty();
 831         }
 832 
 833         var r = new HgRepository(p);
 834         return r.exists() ? Optional.of(new HgRepository(r.root())) : Optional.empty();
 835     }
 836 
 837     @Override
 838     public Repository copyTo(Path destination) throws IOException {
 839         var from = root().toAbsolutePath().toString();
 840         var to = destination.toAbsolutePath().toString();
 841         try (var p = capture(&quot;hg&quot;, &quot;clone&quot;, from, to)) {
 842             await(p);
 843         }
 844 
 845         return new HgRepository(destination.toAbsolutePath());
 846     }
 847 
 848     @Override
 849     public void merge(Hash h) throws IOException {
 850         merge(h, null);
 851     }
 852 
 853     @Override
 854     public void merge(Hash h, String stragegy) throws IOException {
 855         var cmd = new ArrayList&lt;String&gt;();
 856         cmd.addAll(List.of(&quot;hg&quot;, &quot;merge&quot;, &quot;--rev=&quot; + h.hex()));
 857         if (stragegy != null) {
 858             cmd.add(&quot;--tool=&quot; + stragegy);
 859         }
 860         try (var p = capture(cmd)) {
 861             await(p);
 862         }
 863     }
 864 
 865     @Override
 866     public void abortMerge() throws IOException {
 867         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 868             await(p);
 869         }
 870 
 871         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 872             var res = await(p);
 873             for (var path : res.stdout()) {
 874                 if (path.toString().endsWith(&quot;.orig&quot;)) {
 875                     Files.delete(root().resolve(path));
 876                 }
 877             }
 878         }
 879     }
 880 
 881     @Override
 882     public void addRemote(String name, String path) throws IOException {
 883         setPaths(name, path, path);
 884     }
 885 
 886     @Override
 887     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 888         var hgrc = Path.of(root().toString(), &quot;.hg&quot;, &quot;hgrc&quot;);
 889         if (!Files.exists(hgrc)) {
 890             Files.createFile(hgrc);
 891         }
 892 
 893         var lines = Files.readAllLines(hgrc);
 894         var newLines = new ArrayList&lt;String&gt;();
 895 
 896         var isInPathsSection = false;
 897         var hasPathsSection = false;
 898         for (var line : lines) {
 899             var isSectionHeader = line.startsWith(&quot;[&quot;) &amp;&amp; line.endsWith(&quot;]&quot;);
 900             if (isSectionHeader &amp;&amp; !isInPathsSection) {
 901                 isInPathsSection = line.equals(&quot;[paths]&quot;);
 902                 if (isInPathsSection) {
 903                     newLines.add(line);
 904                     newLines.add(remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath));
 905                     newLines.add(remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 906                     hasPathsSection = true;
 907                     continue;
 908                 }
 909             }
 910 
 911             if (isInPathsSection &amp;&amp; line.startsWith(remote)) {
 912                 if (line.startsWith(remote + &quot;-push&quot;)) {
 913                     // skip
 914                 } else if (line.startsWith(remote + &quot;:pushurl&quot;)) {
 915                     // skip
 916                 } else if (line.startsWith(remote + &quot; &quot;) || line.startsWith(remote + &quot;=&quot;)) {
 917                     // skip
 918                 } else {
 919                     newLines.add(line);
 920                 }
 921             } else {
 922                 newLines.add(line);
 923             }
 924         }
 925 
 926         Files.write(hgrc, newLines, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
 927         if (!hasPathsSection) {
 928             var section = List.of(&quot;[paths]&quot;,
 929                                   remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath),
 930                                   remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 931             Files.write(hgrc, section, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
 932         }
 933     }
 934 
 935     @Override
 936     public String pullPath(String remote) throws IOException {
 937         var lines = config(&quot;paths.&quot; + remote);
 938         if (lines.size() != 1) {
 939             throw new IOException(&quot;Pull path not found for remote: &quot; + remote);
 940         }
 941         return lines.get(0);
 942     }
 943 
 944     @Override
 945     public String pushPath(String remote) throws IOException {
 946         var lines = config(&quot;paths.&quot; + remote + &quot;-push&quot;);
 947         if (lines.size() != 1) {
 948             lines = config(&quot;paths.&quot; + remote + &quot;@push&quot;);
 949         }
 950         if (lines.size() != 1) {
 951             return pullPath(remote);
 952         }
 953         return lines.get(0);
 954     }
 955 
 956     @Override
 957     public boolean isValidRevisionRange(String expression) throws IOException {
 958         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot; &quot;, &quot;--rev&quot;, expression)) {
 959             return p.await().status() == 0;
 960         }
 961     }
 962 
 963     private void setPermissions(Patch.Info target) throws IOException {
 964         if (target.path().isPresent() &amp;&amp; target.type().isPresent()) {
 965             var perms = target.type().get().permissions();
 966             if (perms.isPresent()) {
 967                 Files.setPosixFilePermissions(target.path().get(), perms.get());
 968             }
 969         }
 970     }
 971 
 972     @Override
 973     public void apply(Diff diff, boolean force) throws IOException {
 974         var patchFile = Files.createTempFile(&quot;import&quot;, &quot;.patch&quot;);
 975         diff.toFile(patchFile);
 976         apply(patchFile, force);
 977         Files.delete(patchFile);
 978     }
 979 
 980     @Override
 981     public void apply(Path patchFile, boolean force) throws IOException {
 982         var cmd = new ArrayList&lt;String&gt;();
 983         cmd.addAll(List.of(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;));
 984         if (force) {
 985             cmd.add(&quot;--force&quot;);
 986         }
 987         cmd.add(patchFile.toAbsolutePath().toString());
 988         try (var p = capture(cmd)) {
 989             await(p);
 990         }
 991     }
 992 
 993     @Override
 994     public void copy(Path from, Path to) throws IOException {
 995         try (var p = capture(&quot;hg&quot;, &quot;copy&quot;, from.toString(), to.toString())) {
 996             await(p);
 997         }
 998     }
 999 
1000     @Override
1001     public void move(Path from, Path to) throws IOException {
1002         try (var p = capture(&quot;hg&quot;, &quot;move&quot;, from.toString(), to.toString())) {
1003             await(p);
1004         }
1005     }
1006 
1007     @FunctionalInterface
1008     private static interface Operation {
1009         void execute(List&lt;Path&gt; args) throws IOException;
1010     }
1011 
1012     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
1013         var batchSize = 64;
1014         var start = 0;
1015         while (start &lt; args.size()) {
1016             var end = start + batchSize;
1017             if (end &gt; args.size()) {
1018                 end = args.size();
1019             }
1020             op.execute(args.subList(start, end));
1021             start = end;
1022         }
1023     }
1024 
1025     private void addAll(List&lt;Path&gt; paths) throws IOException {
1026         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;add&quot;));
1027         for (var path : paths) {
1028             cmd.add(path.toString());
1029         }
1030         try (var p = capture(cmd)) {
1031             await(p);
1032         }
1033     }
1034 
1035     private void removeAll(List&lt;Path&gt; paths) throws IOException {
1036         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;rm&quot;));
1037         for (var path : paths) {
1038             cmd.add(path.toString());
1039         }
1040         try (var p = capture(cmd)) {
1041             await(p);
1042         }
1043     }
1044 
1045 
1046     @Override
1047     public void remove(List&lt;Path&gt; paths) throws IOException {
1048         batch(this::removeAll, paths);
1049     }
1050 
1051     @Override
1052     public void add(List&lt;Path&gt; paths) throws IOException {
1053         batch(this::addAll, paths);
1054     }
1055 
1056     @Override
1057     public void addremove() throws IOException {
1058         try (var p = capture(&quot;hg&quot;, &quot;addremove&quot;)) {
1059             await(p);
1060         }
1061     }
1062 
1063     @Override
1064     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1065         // Mercurial doesn&#39;t have the concept of remotes like git,
1066         // a local branch must have the same name (if present) on the remote
1067         return Optional.of(b.name());
1068     }
1069 
1070     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {
1071         var cmd = new ArrayList&lt;String&gt;();
1072         cmd.addAll(List.of(&quot;hg&quot;, &quot;clone&quot;));
1073         if (isBare) {
1074             cmd.add(&quot;--noupdate&quot;);
1075         }
1076         cmd.addAll(List.of(from.toString(), to.toString()));
1077 
1078         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1079             await(p);
1080         }
1081         return new HgRepository(to);
1082     }
1083 
1084     @Override
1085     public void pull() throws IOException {
1086         pull(null, null);
1087     }
1088 
1089     @Override
1090     public void pull(String remote) throws IOException {
1091         pull(remote, null);
1092     }
1093 
1094     @Override
1095     public void pull(String remote, String refspec) throws IOException {
1096         var cmd = new ArrayList&lt;String&gt;();
1097         cmd.addAll(List.of(&quot;hg&quot;, &quot;pull&quot;, &quot;--update&quot;));
1098         if (refspec != null) {
1099             cmd.add(&quot;--branch&quot;);
1100             cmd.add(refspec);
1101         }
1102         if (remote != null) {
1103             cmd.add(remote);
1104         }
1105         try (var p = capture(cmd)) {
1106             await(p);
1107         }
1108     }
1109 
1110     @Override
1111     public boolean contains(Branch b, Hash h) throws IOException {
1112         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot;{branch}&quot;, &quot;-r&quot;, h.hex())) {
1113             var res = await(p);
1114             if (res.stdout().size() != 1) {
1115                 throw new IOException(&quot;Unexpected output: &quot; + String.join(&quot;\n&quot;, res.stdout()));
1116             }
1117             var line = res.stdout().get(0);
1118             return line.equals(b.name());
1119         }
1120     }
1121 
1122     @Override
1123     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1124         var refs = new ArrayList&lt;Reference&gt;();
1125 
1126         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
1127         copyResource(EXT_PY, ext);
1128 
1129         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-remote=&quot; + ext, &quot;ls-remote&quot;, remote)) {
1130             var res = await(p);
1131             for (var line : res.stdout()) {
1132                 var parts = line.split(&quot;\t&quot;);
1133                 refs.add(new Reference(parts[1], new Hash(parts[0])));
1134             }
1135         }
1136         return refs;
1137     }
1138 
1139     @Override
1140     public List&lt;String&gt; remotes() throws IOException {
1141         var remotes = new ArrayList&lt;String&gt;();
1142         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
1143             for (var line : await(p).stdout()) {
1144                 var parts = line.split(&quot; = &quot;);
1145                 var name = parts[0];
1146                 if (name.endsWith(&quot;-push&quot;) || name.endsWith(&quot;:push&quot;)) {
1147                     continue;
1148                 } else {
1149                     remotes.add(name);
1150                 }
1151             }
1152         }
1153         return remotes;
1154     }
1155 
1156     @Override
1157     public void addSubmodule(String pullPath, Path path) throws IOException {
1158         var uri = Files.exists(Path.of(pullPath)) ? Path.of(pullPath).toUri().toString() : pullPath;
1159         HgRepository.clone(URI.create(uri), root().resolve(path).toAbsolutePath(), false);
1160         var hgSub = root().resolve(&quot;.hgsub&quot;);
1161         Files.writeString(hgSub, path.toString() + &quot; = &quot; + pullPath + &quot;\n&quot;,
1162                           StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
1163         add(List.of(hgSub));
1164     }
1165 
1166     @Override
1167     public List&lt;Submodule&gt; submodules() throws IOException {
1168         var hgSub = root().resolve(&quot;.hgsub&quot;);
1169         var hgSubState = root().resolve(&quot;.hgsubstate&quot;);
1170         if (!(Files.exists(hgSub) &amp;&amp; Files.exists(hgSubState))) {
1171             return List.of();
1172         }
1173 
1174         var urls = new HashMap&lt;String, String&gt;();
1175         for (var line : Files.readAllLines(hgSub)) {
1176             var parts = line.split(&quot;=&quot;);
1177             var path = parts[0].trim();
1178             var url = parts[1].trim();
1179             urls.put(path, url);
1180         }
1181 
1182         var hashes = new HashMap&lt;String, String&gt;();
1183         for (var line : Files.readAllLines(hgSubState)) {
1184             var parts = line.split(&quot; &quot;);
1185             var hash = parts[0];
1186             var path = parts[1];
1187             hashes.put(path, hash);
1188         }
1189 
1190         var modules = new ArrayList&lt;Submodule&gt;();
1191         for (var path : urls.keySet()) {
1192             var url = urls.get(path);
1193             var hash = hashes.get(path);
1194             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1195         }
1196 
1197         return modules;
1198     }
1199 
1200     @Override
1201     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1202         var hgtags = root().resolve(&quot;.hgtags&quot;);
1203         if (!Files.exists(hgtags)) {
1204             return Optional.empty();
1205         }
1206         try (var p = capture(&quot;hg&quot;, &quot;annotate&quot;, hgtags.toString())) {
1207             var reversed = new ArrayList&lt;&gt;(await(p).stdout());
1208             Collections.reverse(reversed);
1209             for (var line : reversed) {
1210                 var parts = line.split(&quot; &quot;);
1211                 var tagName = parts[2];
1212                 if (tagName.equals(tag.name())) {
1213                     var target = new Hash(parts[1]);
1214                     var rev = parts[0].substring(0, parts[0].length() - 1).trim(); // skip last &#39;:&#39; and ev. whitespace
1215                     var hash = resolve(rev).orElseThrow(IOException::new);
1216                     var commit = lookup(hash).orElseThrow(IOException::new);
1217                     var message = String.join(&quot;\n&quot;, commit.message()) + &quot;\n&quot;;
1218                     return Optional.of(new Tag.Annotated(tagName, target, commit.author(), commit.date(), message));
1219                 }
1220             }
1221         }
1222         return Optional.empty();
1223     }
1224 
1225     @Override
1226     public void config(String section, String key, String value, boolean global) throws IOException {
1227         var hgrc = global ?
1228             Path.of(System.getProperty(&quot;user.home&quot;), &quot;.hgrc&quot;) :
1229             root().resolve(&quot;.hg&quot;).resolve(&quot;hgrc&quot;);
1230 
1231         var lines = List.of(
1232             &quot;[&quot; + section + &quot;]&quot;,
1233             key + &quot; = &quot; + value
1234         );
1235         if (!Files.exists(hgrc)) {
1236             Files.createFile(hgrc);
1237         }
1238         Files.write(hgrc, lines, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
1239     }
1240 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>