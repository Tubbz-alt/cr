diff a/bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java b/bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java
--- a/bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java
+++ b/bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java
@@ -41,18 +41,20 @@
     private final Path storage;
     private final HostedRepository from;
     private final Branch fromBranch;
     private final HostedRepository to;
     private final Branch toBranch;
+    private final HostedRepository toFork;
 
     MergeBot(Path storage, HostedRepository from, Branch fromBranch,
-              HostedRepository to, Branch toBranch) {
+              HostedRepository to, Branch toBranch, HostedRepository toFork) {
         this.storage = storage;
         this.from = from;
         this.fromBranch = fromBranch;
         this.to = to;
         this.toBranch = toBranch;
+        this.toFork = toFork;
     }
 
     @Override
     public boolean concurrentWith(WorkItem other) {
         if (!(other instanceof MergeBot)) {
@@ -70,31 +72,39 @@
             var dir = storage.resolve(sanitizedUrl);
             Repository repo = null;
             if (!Files.exists(dir)) {
                 log.info("Cloning " + to.name());
                 Files.createDirectories(dir);
-                repo = Repository.clone(to.url(), dir);
+                repo = Repository.clone(toFork.url(), dir);
             } else {
                 log.info("Found existing scratch directory for " + to.name());
                 repo = Repository.get(dir).orElseThrow(() -> {
                         return new RuntimeException("Repository in " + dir + " has vanished");
                 });
             }
 
-            repo.fetchAll();
-            var originToBranch = new Branch("origin/" + toBranch.name());
+            // Sync personal fork
+            var remoteBranches = repo.remoteBranches(to.url().toString());
+            for (var branch : remoteBranches) {
+                var fetchHead = repo.fetch(to.url(), branch.hash().hex());
+                repo.push(fetchHead, toFork.url(), branch.name());
+            }
+
+            // Checkout the branch to merge into
+            repo.pull(toFork.url().toString(), toBranch.name());
+            repo.checkout(toBranch, false);
 
-            // Check if pull request already created
+            // Check if merge conflict pull request is present
             var title = "Cannot automatically merge " + from.name() + ":" + fromBranch.name();
             var marker = "<!-- MERGE CONFLICTS -->";
             for (var pr : to.pullRequests()) {
                 if (pr.title().equals(title) &&
                     pr.body().startsWith(marker) &&
                     to.forge().currentUser().equals(pr.author())) {
                     var lines = pr.body().split("\n");
                     var head = new Hash(lines[1].substring(5, 45));
-                    if (repo.contains(originToBranch, head)) {
+                    if (repo.contains(toBranch, head)) {
                         log.info("Closing resolved merge conflict PR " + pr.id());
                         pr.addComment("Merge conflicts have been resolved, closing this PR");
                         pr.setState(PullRequest.State.CLOSED);
                     } else {
                         log.info("Outstanding unresolved merge already present");
@@ -106,19 +116,18 @@
             log.info("Fetching " + from.name() + ":" + fromBranch.name());
             var fetchHead = repo.fetch(from.url(), fromBranch.name());
             var head = repo.resolve(toBranch.name()).orElseThrow(() ->
                     new IOException("Could not resolve branch " + toBranch.name())
             );
-            if (repo.contains(originToBranch, fetchHead)) {
+            if (repo.contains(toBranch, fetchHead)) {
                 log.info("Nothing to merge");
                 return;
             }
 
             var isAncestor = repo.isAncestor(head, fetchHead);
 
             log.info("Trying to merge into " + toBranch.name());
-            repo.checkout(toBranch, false);
             IOException error = null;
             try {
                 repo.merge(fetchHead);
             } catch (IOException e) {
                 error = e;
@@ -133,10 +142,14 @@
             } else {
                 log.info("Got error: " + error.getMessage());
                 log.info("Aborting unsuccesful merge");
                 repo.abortMerge();
 
+                var fromRepoName = Path.of(from.webUrl().getPath()).getFileName();
+                var fromBranchDesc = fromRepoName + "/" + fromBranch.name();
+                repo.push(fetchHead, toFork.url(), fromBranchDesc, true);
+
                 log.info("Creating pull request to alert");
                 var mergeBase = repo.mergeBase(fetchHead, head);
                 var commits = repo.commits(mergeBase.hex() + ".." + fetchHead.hex(), true).asList();
 
                 var message = new ArrayList<String>();
@@ -162,19 +175,20 @@
                 message.add("```bash");
                 message.add("$ git add paths/to/files/with/conflicts");
                 message.add("$ git commit -m 'Merge'");
                 message.add("```");
                 message.add("");
-                message.add("Push the resulting merge conflict to your personal fork and " +
-                            "create a pull request towards this repository. This pull request " +
-                            "will be closed automatically once the pull request with the resolved " +
-                            "conflicts has been integrated.");
-                var pr = from.createPullRequest(to,
-                                                toBranch.name(),
-                                                fromBranch.name(),
-                                                title,
-                                                message);
+                message.add("Push the resolved merge conflict to your personal fork and " +
+                            "create a pull request towards this repository.");
+                message.add("");
+                message.add("This pull request will be closed automatically by a bot once " +
+                            "the merge conflicts have been resolved.");
+                var pr = toFork.createPullRequest(to,
+                                                  toBranch.name(),
+                                                  fromBranchDesc,
+                                                  title,
+                                                  message);
             }
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
