<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.git;
  24 
  25 import org.openjdk.skara.process.*;
  26 import org.openjdk.skara.process.Process;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.net.URI;
  32 import java.nio.file.*;
  33 import java.nio.charset.StandardCharsets;
  34 import java.time.*;
  35 import java.time.format.DateTimeFormatter;
  36 import java.util.*;
  37 import java.util.logging.Logger;
  38 import java.util.stream.Collectors;
  39 
  40 public class GitRepository implements Repository {
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.git&quot;);
  43     private Path cachedRoot = null;
  44 
  45     private java.lang.Process start(String... cmd) throws IOException {
  46         return start(Arrays.asList(cmd));
  47     }
  48 
  49     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  50         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  51         var pb = new ProcessBuilder(cmd);
  52         pb.directory(dir.toFile());
  53         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  54         return pb.start();
  55     }
  56 
  57     private static void stop(java.lang.Process p) throws IOException {
  58         if (p != null &amp;&amp; p.isAlive()) {
  59             var stream = p.getInputStream();
  60             var read = 0;
  61             var buf = new byte[128];
  62             while (read != -1) {
  63                 read = stream.read(buf);
  64             }
  65             try {
  66                 p.waitFor();
  67             } catch (InterruptedException e) {
  68                 throw new IOException(e);
  69             }
  70         }
  71     }
  72 
  73     private Execution capture(List&lt;String&gt; cmd) {
  74         return capture(cmd.toArray(new String[0]));
  75     }
  76 
  77     private Execution capture(String... cmd) {
  78         return capture(dir, cmd);
  79     }
  80 
  81     private static Execution capture(Path cwd, String... cmd) {
  82         return Process.capture(cmd)
  83                       .workdir(cwd)
  84                       .execute();
  85     }
  86 
  87     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  88         return capture(cwd, cmd.toArray(new String[0]));
  89     }
  90 
  91     private static Execution.Result await(Execution e) throws IOException {
  92         var result = e.await();
  93         if (result.status() != 0) {
  94             throw new IOException(&quot;Unexpected exit code\n&quot; + result);
  95         }
  96         return result;
  97     }
  98 
  99     private static void await(java.lang.Process p) throws IOException {
 100         try {
 101             var res = p.waitFor();
 102             if (res != 0) {
 103                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 104             }
 105         } catch (InterruptedException e) {
 106             throw new IOException(e);
 107         }
 108     }
 109 
 110     public GitRepository(Path dir) {
 111         this.dir = dir.toAbsolutePath();
 112     }
 113 
 114     public List&lt;Branch&gt; branches() throws IOException {
 115         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/heads&quot;)) {
 116             return await(p).stdout()
 117                            .stream()
 118                            .map(Branch::new)
 119                            .collect(Collectors.toList());
 120         }
 121     }
 122 
 123     public List&lt;Tag&gt; tags() throws IOException {
 124         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/tags&quot;)) {
 125             return await(p).stdout()
 126                            .stream()
 127                            .map(Tag::new)
 128                            .collect(Collectors.toList());
 129         }
 130     }
 131 
 132     @Override
 133     public Commits commits() throws IOException {
 134         return new GitCommits(dir, &quot;--all&quot;, false, -1);
 135     }
 136 
 137     @Override
 138     public Commits commits(int n) throws IOException {
 139         return new GitCommits(dir, &quot;--all&quot;, false, n);
 140     }
 141 
 142     @Override
 143     public Commits commits(boolean reverse) throws IOException {
 144         return new GitCommits(dir, &quot;--all&quot;, reverse, -1);
 145     }
 146 
 147     @Override
 148     public Commits commits(int n, boolean reverse) throws IOException {
 149         return new GitCommits(dir, &quot;--all&quot;, reverse, n);
 150     }
 151 
 152     @Override
 153     public Commits commits(String range) throws IOException {
 154         return new GitCommits(dir, range, false, -1);
 155     }
 156 
 157     @Override
 158     public Commits commits(String range, int n) throws IOException {
 159         return new GitCommits(dir, range, false, n);
 160     }
 161 
 162     @Override
 163     public Commits commits(String range, boolean reverse) throws IOException {
 164         return new GitCommits(dir, range, reverse, -1);
 165     }
 166 
 167     @Override
 168     public Commits commits(String range, int n, boolean reverse) throws IOException {
 169         return new GitCommits(dir, range, reverse, n);
 170     }
 171 
 172     @Override
 173     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 174         var commits = commits(h.hex(), 1).asList();
 175         if (commits.size() != 1) {
 176             return Optional.empty();
 177         }
 178         return Optional.of(commits.get(0));
 179     }
 180 
 181     @Override
 182     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 183         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 184         return lookup(hash);
 185     }
 186 
 187     @Override
 188     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 189         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 190         return lookup(hash);
 191     }
 192 
 193     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 194         var revisions = &quot;--all&quot;;
 195         var p = start(&quot;git&quot;, &quot;rev-list&quot;, &quot;--format=&quot; + GitCommitMetadata.FORMAT, &quot;--no-abbrev&quot;, &quot;--reverse&quot;, &quot;--no-color&quot;, revisions);
 196         var reader = new UnixStreamReader(p.getInputStream());
 197         var result = new ArrayList&lt;CommitMetadata&gt;();
 198 
 199         var line = reader.readLine();
 200         while (line != null) {
 201             if (!line.startsWith(&quot;commit&quot;)) {
 202                 throw new IOException(&quot;Unexpected line: &quot; + line);
 203             }
 204 
 205             result.add(GitCommitMetadata.read(reader));
 206             line = reader.readLine();
 207         }
 208 
 209         await(p);
 210         return result;
 211     }
 212 
 213     private List&lt;Hash&gt; refs() throws IOException {
 214         try (var p = capture(&quot;git&quot;, &quot;show-ref&quot;, &quot;--hash&quot;, &quot;--abbrev&quot;)) {
 215             var res = p.await();
 216             if (res.status() == -1) {
 217                 if (res.stdout().size() != 0) {
 218                     throw new IOException(&quot;Unexpected output\n&quot; + res);
 219                 }
 220                 return new ArrayList&lt;&gt;();
 221             } else {
 222                 return res.stdout().stream()
 223                           .map(Hash::new)
 224                           .collect(Collectors.toList());
 225             }
 226         }
 227     }
 228 
 229     @Override
 230     public boolean isEmpty() throws IOException {
 231         int numLooseObjects = -1;
 232         int numPackedObjects = -1;
 233 
 234         try (var p = capture(&quot;git&quot;, &quot;count-objects&quot;, &quot;-v&quot;)) {
 235             var res = await(p);
 236             var stdout = res.stdout();
 237 
 238             for (var line : stdout) {
 239                 if (line.startsWith(&quot;count: &quot;)) {
 240                     try {
 241                         numLooseObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 242                     } catch (NumberFormatException e) {
 243                         throw new IOException(&quot;Unexpected &#39;count&#39; value\n&quot; + res, e);
 244                     }
 245 
 246                 } else if (line.startsWith(&quot;in-pack: &quot;)) {
 247                     try {
 248                         numPackedObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 249                     } catch (NumberFormatException e) {
 250                         throw new IOException(&quot;Unexpected &#39;in-pack&#39; value\n&quot; + res, e);
 251                     }
 252                 }
 253             }
 254         }
 255 
 256         return numLooseObjects == 0 &amp;&amp; numPackedObjects == 0 &amp;&amp; refs().size() == 0;
 257     }
 258 
 259     @Override
 260     public boolean isHealthy() throws IOException {
 261         var refs = refs();
 262         if (refs.size() == 0) {
 263             return true;
 264         }
 265 
 266         var name = &quot;health-check&quot;;
 267         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, name, refs.get(0).hex())) {
 268             if (p.await().status() != 0) {
 269                 return false;
 270             }
 271         }
 272         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;-D&quot;, name)) {
 273             if (p.await().status() != 0) {
 274                 return false;
 275             }
 276         }
 277 
 278         return true;
 279     }
 280 
 281     @Override
 282     public void clean() throws IOException {
 283         cachedRoot = null;
 284 
 285         try (var p = capture(&quot;git&quot;, &quot;clean&quot;, &quot;-x&quot;, &quot;-d&quot;, &quot;--force&quot;, &quot;--force&quot;)) {
 286             await(p);
 287         }
 288 
 289         try (var p = capture(&quot;git&quot;, &quot;reset&quot;, &quot;--hard&quot;)) {
 290             await(p);
 291         }
 292 
 293         try (var p = capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--quit&quot;)) {
 294             p.await(); // Don&#39;t care about the result.
 295         }
 296     }
 297 
 298     @Override
 299     public void reset(Hash target, boolean hard) throws IOException {
 300         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;reset&quot;));
 301         if (hard) {
 302            cmd.add(&quot;--hard&quot;);
 303         }
 304         cmd.add(target.hex());
 305 
 306         try (var p = capture(cmd)) {
 307             await(p);
 308         }
 309     }
 310 
 311 
 312     @Override
 313     public void revert(Hash h) throws IOException {
 314         try (var p = capture(&quot;git&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;, h.hex(), &quot;--&quot;, &quot;.&quot;)) {
 315             await(p);
 316         }
 317     }
 318 
 319     @Override
 320     public Repository reinitialize() throws IOException {
 321         cachedRoot = null;
 322 
 323         Files.walk(dir)
 324              .map(Path::toFile)
 325              .sorted(Comparator.reverseOrder())
 326              .forEach(File::delete);
 327 
 328         return init();
 329     }
 330 
 331     @Override
 332     public Hash fetch(URI uri, String refspec) throws IOException {
 333         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--tags&quot;, uri.toString(), refspec)) {
 334             await(p);
 335             return resolve(&quot;FETCH_HEAD&quot;).get();
 336         }
 337     }
 338 
 339     @Override
 340     public void fetchAll() throws IOException {
 341         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--tags&quot;, &quot;--prune&quot;, &quot;--prune-tags&quot;, &quot;--all&quot;)) {
 342             await(p);
 343         }
 344     }
 345 
 346     private void checkout(String ref, boolean force) throws IOException {
 347         var cmd = new ArrayList&lt;String&gt;();
 348         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;advice.detachedHead=false&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;));
 349         if (force) {
 350             cmd.add(&quot;--force&quot;);
 351         }
 352         cmd.add(ref);
 353         try (var p = capture(cmd)) {
 354             await(p);
 355         }
 356     }
 357 
 358     @Override
 359     public void checkout(Hash h, boolean force) throws IOException {
 360         checkout(h.hex(), force);
 361     }
 362 
 363     @Override
 364     public void checkout(Branch b, boolean force) throws IOException {
 365         checkout(b.name(), force);
 366     }
 367 
 368     @Override
 369     public Repository init() throws IOException {
 370         return init(false);
 371     }
 372 
 373     @Override
 374     public Repository init(boolean isBare) throws IOException {
 375         cachedRoot = null;
 376 
 377         if (!Files.exists(dir)) {
 378             Files.createDirectories(dir);
 379         }
 380 
 381         if (isBare) {
 382             try (var p = capture(&quot;git&quot;, &quot;init&quot;, &quot;--bare&quot;)) {
 383                 await(p);
 384                 return this;
 385             }
 386         } else {
 387             try (var p = capture(&quot;git&quot;, &quot;init&quot;)) {
 388                 await(p);
 389                 return this;
 390             }
 391         }
 392     }
 393 
 394     @Override
 395     public void pushAll(URI uri) throws IOException {
 396         try (var p = capture(&quot;git&quot;, &quot;push&quot;, &quot;--mirror&quot;, uri.toString())) {
 397             await(p);
 398         }
 399     }
 400 
 401     @Override
 402     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 403         String refspec = force ? &quot;+&quot; : &quot;&quot;;
 404         if (!ref.startsWith(&quot;refs/&quot;)) {
 405             ref = &quot;refs/heads/&quot; + ref;
 406         }
 407         refspec += hash.hex() + &quot;:&quot; + ref;
 408 
 409         try (var p = capture(&quot;git&quot;, &quot;push&quot;, uri.toString(), refspec)) {
 410             await(p);
 411         }
 412     }
 413 
 414     @Override
 415     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 416         var cmd = new ArrayList&lt;String&gt;();
 417         cmd.addAll(List.of(&quot;git&quot;, &quot;push&quot;, remote, branch.name()));
 418         if (setUpstream) {
 419             cmd.add(&quot;--set-upstream&quot;);
 420         }
 421 
 422         try (var p = capture(cmd)) {
 423             await(p);
 424         }
 425     }
 426 
 427     @Override
 428     public boolean isClean() throws IOException {
 429         try (var p = capture(&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;)) {
 430             var output = await(p);
 431             return output.stdout().size() == 0;
 432         }
 433     }
 434 
 435     @Override
 436     public boolean exists() throws IOException {
 437         if (!Files.exists(dir)) {
 438             return false;
 439         }
 440 
 441         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 442             return p.await().status() == 0;
 443         }
 444     }
 445 
 446     @Override
 447     public Path root() throws IOException {
 448         if (cachedRoot != null) {
 449             return cachedRoot;
 450         }
 451 
 452         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--show-toplevel&quot;)) {
 453             var res = await(p);
 454             if (res.stdout().size() != 1) {
 455                 // Perhaps this is a bare repository
 456                 try (var p2 = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 457                     var res2 = await(p2);
 458                     if (res2.stdout().size() != 1) {
 459                         throw new IOException(&quot;Unexpected output\n&quot; + res2);
 460                     }
 461                     cachedRoot = dir.resolve(Path.of(res2.stdout().get(0))).normalize();
 462                     return cachedRoot;
 463                 }
 464             }
 465 
 466             cachedRoot = Path.of(res.stdout().get(0));
 467             return cachedRoot;
 468         }
 469     }
 470 
 471     @Override
 472     public void squash(Hash h) throws IOException {
 473         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--squash&quot;, h.hex())) {
 474             await(p);
 475         }
 476     }
 477 
 478     @FunctionalInterface
 479     private static interface Operation {
 480         void execute(List&lt;Path&gt; args) throws IOException;
 481     }
 482 
 483     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
 484         var batchSize = 64;
 485         var start = 0;
 486         while (start &lt; args.size()) {
 487             var end = start + batchSize;
 488             if (end &gt; args.size()) {
 489                 end = args.size();
 490             }
 491             op.execute(args.subList(start, end));
 492             start = end;
 493         }
 494     }
 495 
 496     private void addAll(List&lt;Path&gt; paths) throws IOException {
 497         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;add&quot;));
 498         for (var path : paths) {
 499             cmd.add(path.toString());
 500         }
 501         try (var p = capture(cmd)) {
 502             await(p);
 503         }
 504     }
 505 
 506     @Override
 507     public void add(List&lt;Path&gt; paths) throws IOException {
 508         batch(this::addAll, paths);
 509     }
 510 
 511     private void removeAll(List&lt;Path&gt; paths) throws IOException {
 512         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;rm&quot;));
 513         for (var path : paths) {
 514             cmd.add(path.toString());
 515         }
 516         try (var p = capture(cmd)) {
 517             await(p);
 518         }
 519     }
 520 
 521     @Override
 522     public void remove(List&lt;Path&gt; paths) throws IOException {
 523         batch(this::removeAll, paths);
 524     }
 525 
 526     @Override
 527     public void delete(Branch b) throws IOException {
 528         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;-D&quot;, b.name())) {
 529             await(p);
 530         }
 531     }
 532 
 533     @Override
 534     public void addremove() throws IOException {
 535         try (var p = capture(&quot;git&quot;, &quot;add&quot;, &quot;--all&quot;)) {
 536             await(p);
 537         }
 538     }
 539 
 540     @Override
 541     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 542         return commit(message, authorName, authorEmail, null);
 543     }
 544 
 545     @Override
 546     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 547         return commit(message, authorName, authorEmail, authorDate, authorName, authorEmail, authorDate);
 548     }
 549 
 550     @Override
 551     public Hash commit(String message,
 552                        String authorName,
 553                        String authorEmail,
 554                        String committerName,
 555                        String committerEmail) throws IOException {
 556         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 557     }
 558 
 559     @Override
 560     public Hash commit(String message,
 561                        String authorName,
 562                        String authorEmail,
 563                        ZonedDateTime authorDate,
 564                        String committerName,
 565                        String committerEmail,
 566                        ZonedDateTime committerDate) throws IOException {
 567         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--message=&quot; + message)
 568                          .workdir(dir)
 569                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 570                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 571                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 572                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 573         if (authorDate != null) {
 574             cmd = cmd.environ(&quot;GIT_AUTHOR_DATE&quot;,
 575                               authorDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 576         }
 577         if (committerDate != null) {
 578             cmd = cmd.environ(&quot;GIT_COMMITTER_DATE&quot;,
 579                               committerDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 580         }
 581         try (var p = cmd.execute()) {
 582             await(p);
 583             return head();
 584         }
 585     }
 586 
 587     @Override
 588     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 589         return amend(message, authorName, authorEmail, null, null);
 590     }
 591 
 592     @Override
 593     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 594         if (committerName == null) {
 595             committerName = authorName;
 596             committerEmail = authorEmail;
 597         }
 598         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--reset-author&quot;, &quot;--message=&quot; + message)
 599                          .workdir(dir)
 600                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 601                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 602                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 603                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 604         try (var p = cmd.execute()) {
 605             await(p);
 606             return head();
 607         }
 608     }
 609 
 610     @Override
 611     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 612         var cmd = Process.capture(&quot;git&quot;, &quot;tag&quot;, &quot;--annotate&quot;, &quot;--message=&quot; + message, name, hash.hex())
 613                          .workdir(dir)
 614                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 615                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 616                          .environ(&quot;GIT_COMMITTER_NAME&quot;, authorName)
 617                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, authorEmail);
 618         try (var p = cmd.execute()) {
 619             await(p);
 620         }
 621 
 622         return new Tag(name);
 623     }
 624 
 625     @Override
 626     public Branch branch(Hash hash, String name) throws IOException {
 627         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, name, hash.hex())) {
 628             await(p);
 629         }
 630 
 631         return new Branch(name);
 632     }
 633 
 634     @Override
 635     public Hash mergeBase(Hash first, Hash second) throws IOException {
 636         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, first.hex(), second.hex())) {
 637             var res = await(p);
 638             if (res.stdout().size() != 1) {
 639                  throw new IOException(&quot;Unexpected output\n&quot; + res);
 640             }
 641             return new Hash(res.stdout().get(0));
 642         }
 643     }
 644 
 645     @Override
 646     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 647         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, &quot;--is-ancestor&quot;, ancestor.hex(), descendant.hex())) {
 648             var res = p.await();
 649             return res.status() == 0;
 650         }
 651     }
 652 
 653     @Override
 654     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 655         try (var p = Process.capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--onto&quot;, hash.hex(), &quot;--root&quot;, &quot;--rebase-merges&quot;)
 656                             .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 657                             .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail)
 658                             .workdir(dir)
 659                             .execute()) {
 660             await(p);
 661         }
 662     }
 663 
 664     @Override
 665     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 666         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, ref + &quot;^{commit}&quot;)) {
 667             var res = p.await();
 668             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 669                 return Optional.of(new Hash(res.stdout().get(0)));
 670             }
 671             return Optional.empty();
 672         }
 673     }
 674 
 675     @Override
 676     public Branch currentBranch() throws IOException {
 677         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;HEAD&quot;)) {
 678             var res = await(p);
 679             if (res.stdout().size() != 1) {
 680                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 681             }
 682             return new Branch(res.stdout().get(0));
 683         }
 684     }
 685 
 686     @Override
 687     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 688         throw new RuntimeException(&quot;git does not have bookmarks&quot;);
 689     }
 690 
 691     @Override
 692     public Branch defaultBranch() throws IOException {
 693         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;refs/remotes/origin/HEAD&quot;)) {
 694             var res = p.await();
 695             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 696                 var ref = res.stdout().get(0).substring(&quot;origin/&quot;.length());
 697                 return new Branch(ref);
 698             } else {
 699                 return new Branch(&quot;master&quot;);
 700             }
 701         }
 702     }
 703 
 704     @Override
 705     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 706         return Optional.empty();
 707     }
 708 
 709     @Override
 710     public Optional&lt;String&gt; username() throws IOException {
 711         var lines = config(&quot;user.name&quot;);
 712         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 713     }
 714 
 715     private String treeEntry(Path path, Hash hash) throws IOException {
 716         try (var p = Process.capture(&quot;git&quot;, &quot;ls-tree&quot;, hash.hex(), path.toString())
 717                             .workdir(root())
 718                             .execute()) {
 719             var res = await(p);
 720             if (res.stdout().size() == 0) {
 721                 return null;
 722             }
 723             if (res.stdout().size() &gt; 1) {
 724                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 725             }
 726             return res.stdout().get(0);
 727         }
 728     }
 729 
 730     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 731         var cmd = new ArrayList&lt;String&gt;();
 732         cmd.addAll(List.of(&quot;git&quot;, &quot;ls-tree&quot;, &quot;-r&quot;));
 733         cmd.add(hash.hex());
 734         cmd.addAll(paths.stream().map(Path::toString).collect(Collectors.toList()));
 735         try (var p = Process.capture(cmd.toArray(new String[0]))
 736                             .workdir(root())
 737                             .execute()) {
 738             var res = await(p);
 739             var entries = new ArrayList&lt;FileEntry&gt;();
 740             for (var line : res.stdout()) {
 741                 var parts = line.split(&quot;\t&quot;);
 742                 var metadata = parts[0].split(&quot; &quot;);
 743                 var filename = parts[1];
 744 
 745                 var entry = new FileEntry(hash,
 746                                           FileType.fromOctal(metadata[0]),
 747                                           new Hash(metadata[2]),
 748                                           Path.of(filename));
 749                 entries.add(entry);
 750             }
 751             return entries;
 752         }
 753     }
 754 
 755     @Override
 756     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 757         if (paths.isEmpty()) {
 758             return allFiles(hash, paths);
 759         }
 760 
 761         var entries = new ArrayList&lt;FileEntry&gt;();
 762         var batchSize = 64;
 763         var start = 0;
 764         while (start &lt; paths.size()) {
 765             var end = start + batchSize;
 766             if (end &gt; paths.size()) {
 767                 end = paths.size();
 768             }
 769             entries.addAll(allFiles(hash, paths.subList(start, end)));
 770             start = end;
 771         }
 772         return entries;
 773     }
 774 
 775     private Path unpackFile(String blob) throws IOException {
 776         try (var p = capture(&quot;git&quot;, &quot;unpack-file&quot;, blob)) {
 777             var res = await(p);
 778             if (res.stdout().size() != 1) {
 779                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 780             }
 781 
 782             return Path.of(root().toString(), res.stdout().get(0));
 783         }
 784     }
 785 
 786     @Override
 787     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 788         var entries = files(hash, path);
 789         if (entries.size() == 0) {
 790             return Optional.empty();
 791         } else if (entries.size() &gt; 1) {
 792             throw new IOException(&quot;Multiple files match path &quot; + path.toString() + &quot; in commit &quot; + hash.hex());
 793         }
 794 
 795         var entry = entries.get(0);
 796         var type = entry.type();
 797         if (type.isVCSLink()) {
 798             var content = &quot;Subproject commit &quot; + entry.hash().hex() + &quot; &quot; + entry.path().toString();
 799             return Optional.of(content.getBytes(StandardCharsets.UTF_8));
 800         } else if (type.isRegular()) {
 801             var tmp = unpackFile(entry.hash().hex());
 802             var content = Files.readAllBytes(tmp);
 803             Files.delete(tmp);
 804             return Optional.of(content);
 805         }
 806 
 807         return Optional.empty();
 808     }
 809 
 810     @Override
 811     public void dump(FileEntry entry, Path to) throws IOException {
 812         var type = entry.type();
 813         if (type.isRegular()) {
 814             var path = unpackFile(entry.hash().hex());
 815             Files.createDirectories(to.getParent());
 816             Files.move(path, to, StandardCopyOption.REPLACE_EXISTING);
 817         }
 818     }
 819 
 820     @Override
 821     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 822         try (var p = capture(&quot;git&quot;, &quot;diff&quot;, &quot;--raw&quot;, &quot;--find-renames=99%&quot;, &quot;--find-copies=99%&quot;, &quot;--find-copies-harder&quot;, &quot;--no-abbrev&quot;, &quot;--no-color&quot;, from.hex(), to.hex())) {
 823             var res = await(p);
 824             var entries = new ArrayList&lt;StatusEntry&gt;();
 825             for (var line : res.stdout()) {
 826                 entries.add(StatusEntry.fromRawLine(line));
 827             }
 828             return entries;
 829         }
 830     }
 831 
 832     @Override
 833     public Diff diff(Hash from) throws IOException {
 834         return diff(from, List.of());
 835     }
 836 
 837     @Override
 838     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {
 839         return diff(from, null, files);
 840     }
 841 
 842     @Override
 843     public Diff diff(Hash from, Hash to) throws IOException {
 844         return diff(from, to, List.of());
 845     }
 846 
 847     @Override
 848     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {
 849         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;diff&quot;, &quot;--patch&quot;,
 850                                                          &quot;--find-renames=99%&quot;,
 851                                                          &quot;--find-copies=99%&quot;,
 852                                                          &quot;--find-copies-harder&quot;,
 853                                                          &quot;--binary&quot;,
 854                                                          &quot;--raw&quot;,
 855                                                          &quot;--no-abbrev&quot;,
 856                                                          &quot;--unified=0&quot;,
 857                                                          &quot;--no-color&quot;,
 858                                                          from.hex()));
 859         if (to != null) {
 860             cmd.add(to.hex());
 861         }
 862 
 863         if (files != null &amp;&amp; !files.isEmpty()) {
 864             cmd.add(&quot;--&quot;);
 865             for (var file : files) {
 866                 cmd.add(file.toString());
 867             }
 868         }
 869 
 870         var p = start(cmd);
 871         try {
 872             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 873             await(p);
 874             return new Diff(from, to, patches);
 875         } catch (Throwable t) {
 876             stop(p);
 877             throw t;
 878         }
 879     }
 880 
 881     @Override
 882     public List&lt;String&gt; config(String key) throws IOException {
 883         try (var p = capture(&quot;git&quot;, &quot;config&quot;, key)) {
 884             var res = p.await();
 885             return res.status() == 0 ? res.stdout() : List.of();
 886         }
 887     }
 888 
 889     @Override
 890     public Hash head() throws IOException {
 891         return resolve(&quot;HEAD&quot;).orElseThrow(() -&gt; new IllegalStateException(&quot;HEAD ref is not present&quot;));
 892     }
 893 
 894     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 895         if (!Files.exists(p)) {
 896             return Optional.empty();
 897         }
 898 
 899         var r = new GitRepository(p);
 900         return r.exists() ? Optional.of(new GitRepository(r.root())) : Optional.empty();
 901     }
 902 
 903     @Override
 904     public Repository copyTo(Path destination) throws IOException {
 905         try (var p = capture(&quot;git&quot;, &quot;clone&quot;, &quot;--recurse-submodules&quot;, root().toString(), destination.toString())) {
 906             await(p);
 907         }
 908 
 909         return new GitRepository(destination);
 910     }
 911 
 912     @Override
 913     public void merge(Hash h) throws IOException {
 914         merge(h, null);
 915     }
 916 
 917     @Override
 918     public void merge(Hash h, String strategy) throws IOException {
 919         var cmd = new ArrayList&lt;String&gt;();
 920         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;user.name=unused&quot;, &quot;-c&quot;, &quot;user.email=unused&quot;,
 921                            &quot;merge&quot;, &quot;--no-commit&quot;));
 922         if (strategy != null) {
 923             cmd.add(&quot;-s&quot;);
 924             cmd.add(strategy);
 925         }
 926         cmd.add(h.hex());
 927         try (var p = capture(cmd)) {
 928             await(p);
 929         }
 930     }
 931 
 932     @Override
 933     public void abortMerge() throws IOException {
 934         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 935             await(p);
 936         }
 937     }
 938 
 939     @Override
 940     public void addRemote(String name, String pullPath) throws IOException {
 941         try (var p = capture(&quot;git&quot;, &quot;remote&quot;, &quot;add&quot;, name, pullPath)) {
 942             await(p);
 943         }
 944     }
 945 
 946     @Override
 947     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 948         pullPath = pullPath == null ? &quot;&quot; : pullPath;
 949         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.url&quot;, pullPath)) {
 950             await(p);
 951         }
 952 
 953         pushPath = pushPath == null ? &quot;&quot; : pushPath;
 954         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.pushurl&quot;, pushPath)) {
 955             await(p);
 956         }
 957     }
 958 
 959     @Override
 960     public String pullPath(String remote) throws IOException {
 961         var lines = config(&quot;remote.&quot; + remote + &quot;.url&quot;);
 962         if (lines.size() != 1) {
 963             throw new IOException(&quot;No pull path found for remote &quot; + remote);
 964         }
 965         return lines.get(0);
 966     }
 967 
 968     @Override
 969     public String pushPath(String remote) throws IOException {
 970         var lines = config(&quot;remote.&quot; + remote + &quot;.pushurl&quot;);
 971         if (lines.size() != 1) {
 972             return pullPath(remote);
 973         }
 974         return lines.get(0);
 975     }
 976 
 977     @Override
 978     public boolean isValidRevisionRange(String expression) throws IOException {
 979         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, expression)) {
 980             return p.await().status() == 0;
 981         }
 982     }
 983 
 984     private void applyPatch(Patch patch) throws IOException {
 985         if (patch.isEmpty()) {
 986             return;
 987         }
 988 
 989         if (patch.isTextual()) {
 990         } else {
 991             throw new IllegalArgumentException(&quot;Cannot handle binary patches yet&quot;);
 992         }
 993     }
 994 
 995     @Override
 996     public void apply(Diff diff, boolean force) throws IOException {
 997         // ignore force, no such concept in git
 998         var patchFile = Files.createTempFile(&quot;apply&quot;, &quot;.patch&quot;);
 999         diff.toFile(patchFile);
1000         apply(patchFile, force);
1001         Files.delete(patchFile);
1002     }
1003 
1004     @Override
1005     public void apply(Path patchFile, boolean force)  throws IOException {
1006         var cmd = new ArrayList&lt;String&gt;();
1007         cmd.addAll(List.of(&quot;git&quot;, &quot;apply&quot;, &quot;--index&quot;, &quot;--unidiff-zero&quot;));
1008         cmd.add(patchFile.toAbsolutePath().toString());
1009         try (var p = capture(cmd)) {
1010             await(p);
1011             Files.delete(patchFile);
1012         }
1013     }
1014 
1015     @Override
1016     public void copy(Path from, Path to) throws IOException {
1017         Files.copy(from, to);
1018         add(to);
1019     }
1020 
1021     @Override
1022     public void move(Path from, Path to) throws IOException {
1023         try (var p = capture(&quot;git&quot;, &quot;mv&quot;, from.toString(), to.toString())) {
1024             await(p);
1025         }
1026     }
1027 
1028     @Override
1029     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1030         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(upstream:short)&quot;, &quot;refs/heads/&quot; + b.name())) {
1031             var lines = await(p).stdout();
1032             return lines.size() == 1 &amp;&amp; !lines.get(0).isEmpty()? Optional.of(lines.get(0)) : Optional.empty();
1033         }
1034     }
1035 
1036     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {
1037         var cmd = new ArrayList&lt;String&gt;();
1038         cmd.addAll(List.of(&quot;git&quot;, &quot;clone&quot;));
1039         if (isBare) {
1040             cmd.add(&quot;--bare&quot;);
1041         } else {
1042             cmd.add(&quot;--recurse-submodules&quot;);
1043         }
1044         cmd.addAll(List.of(from.toString(), to.toString()));
1045         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1046             await(p);
1047         }
1048         return new GitRepository(to);
1049     }
1050 
1051     public static Repository mirror(URI from, Path to) throws IOException {
1052         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
1053         try (var p = capture(cwd, &quot;git&quot;, &quot;clone&quot;, &quot;--mirror&quot;, from.toString(), to.toString())) {
1054             await(p);
1055         }
1056         return new GitRepository(to);
1057     }
1058 
1059     @Override
1060     public void pull() throws IOException {
1061         pull(null, null);
1062     }
1063 
1064     @Override
1065     public void pull(String remote) throws IOException {
1066         pull(remote, null);
1067     }
1068 
1069 
1070     @Override
1071     public void pull(String remote, String refspec) throws IOException {
1072         var cmd = new ArrayList&lt;String&gt;();
1073         cmd.add(&quot;git&quot;);
1074         cmd.add(&quot;pull&quot;);
1075         if (remote != null) {
1076             cmd.add(remote);
1077         }
1078         if (refspec != null) {
1079             cmd.add(refspec);
1080         }
1081         try (var p = capture(cmd)) {
1082             await(p);
1083         }
1084     }
1085 
1086     @Override
1087     public boolean contains(Branch b, Hash h) throws IOException {
1088         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--contains&quot;, h.hex(), &quot;--format&quot;, &quot;%(refname:short)&quot;)) {
1089             var res = await(p);
1090             for (var line : res.stdout()) {
1091                 if (line.equals(b.name())) {
1092                     return true;
1093                 }
1094             }
1095         }
1096 
1097         return false;
1098     }
1099 
1100     @Override
1101     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1102         var refs = new ArrayList&lt;Reference&gt;();
1103         try (var p = capture(&quot;git&quot;, &quot;ls-remote&quot;, &quot;--heads&quot;, &quot;--refs&quot;, remote)) {
1104             for (var line : await(p).stdout()) {
1105                 var parts = line.split(&quot;\t&quot;);
1106                 var name = parts[1].replace(&quot;refs/heads/&quot;, &quot;&quot;);
1107                 refs.add(new Reference(name, new Hash(parts[0])));
1108             }
1109         }
1110         return refs;
1111     }
1112 
1113     @Override
1114     public List&lt;String&gt; remotes() throws IOException {
1115         var remotes = new ArrayList&lt;String&gt;();
1116         try (var p = capture(&quot;git&quot;, &quot;remote&quot;)) {
1117             for (var line : await(p).stdout()) {
1118                 remotes.add(line);
1119             }
1120         }
1121         return remotes;
1122     }
1123 
1124     @Override
1125     public void addSubmodule(String pullPath, Path path) throws IOException {
1126         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;add&quot;, pullPath, path.toString())) {
1127             await(p);
1128         }
1129     }
1130 
1131     @Override
1132     public List&lt;Submodule&gt; submodules() throws IOException {
1133         var gitModules = root().resolve(&quot;.gitmodules&quot;);
1134         if (!Files.exists(gitModules)) {
1135             return List.of();
1136         }
1137 
1138         var urls = new HashMap&lt;String, String&gt;();
1139         var paths = new HashMap&lt;String, String&gt;();
1140         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;--file&quot;, gitModules.toAbsolutePath().toString(),
1141                                               &quot;--list&quot;)) {
1142             for (var line : await(p).stdout()) {
1143                 if (line.startsWith(&quot;submodule.&quot;)) {
1144                     line = line.substring(&quot;submodule.&quot;.length());
1145                     var parts = line.split(&quot;=&quot;);
1146                     var nameAndProperty = parts[0].split(&quot;\\.&quot;);
1147                     var name = nameAndProperty[0];
1148                     var prop = nameAndProperty[1];
1149                     var value = parts[1];
1150                     if (prop.equals(&quot;path&quot;)) {
1151                         paths.put(name, value);
1152                     } else if (prop.equals(&quot;url&quot;)) {
1153                         urls.put(name, value);
1154                     } else {
1155                         throw new IOException(&quot;Unexpected submodule property: &quot; + prop);
1156                     }
1157                 }
1158             }
1159         }
1160 
1161         var hashes = new HashMap&lt;String, String&gt;();
1162         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;status&quot;)) {
1163             for (var line : await(p).stdout()) {
1164                 var parts = line.substring(1).split(&quot; &quot;);
1165                 var hash = parts[0];
1166                 var path = parts[1];
1167                 hashes.put(path, hash);
1168             }
1169         }
1170 
1171         var modules = new ArrayList&lt;Submodule&gt;();
1172         for (var name : paths.keySet()) {
1173             var url = urls.get(name);
1174             var path = paths.get(name);
1175             var hash = hashes.get(path);
1176 
1177             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1178         }
1179 
1180         return modules;
1181     }
1182 
1183     @Override
1184     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1185         var ref = &quot;refs/tags/&quot; + tag.name();
1186         var format = &quot;%(refname:short)%0a%(*objectname)%0a%(taggername) %(taggeremail)%0a%(taggerdate:iso-strict)%0a%(contents)&quot;;
1187         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format&quot;, format, ref)) {
1188             var lines = await(p).stdout();
1189             if (lines.size() &gt;= 4) {
1190                 var name = lines.get(0);
1191                 var target = new Hash(lines.get(1));
1192                 var author = Author.fromString(lines.get(2));
1193 
1194                 var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
1195                 var date = ZonedDateTime.parse(lines.get(3), formatter);
1196                 var message = String.join(&quot;\n&quot;, lines.subList(4, lines.size()));
1197 
1198                 return Optional.of(new Tag.Annotated(name, target, author, date, message));
1199             }
1200             return Optional.empty();
1201         }
1202     }
1203 }
    </pre>
  </body>
</html>