<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/notify/UpdaterTests.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  import org.openjdk.skara.forge.*;
  import org.openjdk.skara.issuetracker.Issue;
  import org.openjdk.skara.issuetracker.*;
  import org.openjdk.skara.jcheck.JCheckConfiguration;
<span class="line-added">+ import org.openjdk.skara.json.*;</span>
  import org.openjdk.skara.vcs.*;
  import org.openjdk.skara.vcs.openjdk.*;
  
  import java.io.IOException;
  import java.net.URI;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,15 ***</span>
  
      private final static Set&lt;String&gt; primaryTypes = Set.of(&quot;Bug&quot;, &quot;New Feature&quot;, &quot;Enhancement&quot;, &quot;Task&quot;, &quot;Sub-task&quot;);
  
      private boolean isPrimaryIssue(Issue issue) {
          var properties = issue.properties();
<span class="line-modified">!         if (!properties.containsKey(&quot;type&quot;)) {</span>
              throw new RuntimeException(&quot;Unknown type for issue &quot; + issue);
          }
<span class="line-modified">!         var type = properties.get(&quot;type&quot;);</span>
<span class="line-modified">!         return primaryTypes.contains(type);</span>
      }
  
      private final static Pattern majorVersionPattern = Pattern.compile(&quot;([0-9]+)(u[0-9]+)?&quot;);
  
      /**
<span class="line-new-header">--- 60,15 ---</span>
  
      private final static Set&lt;String&gt; primaryTypes = Set.of(&quot;Bug&quot;, &quot;New Feature&quot;, &quot;Enhancement&quot;, &quot;Task&quot;, &quot;Sub-task&quot;);
  
      private boolean isPrimaryIssue(Issue issue) {
          var properties = issue.properties();
<span class="line-modified">!         if (!properties.containsKey(&quot;issuetype&quot;)) {</span>
              throw new RuntimeException(&quot;Unknown type for issue &quot; + issue);
          }
<span class="line-modified">!         var type = properties.get(&quot;issuetype&quot;);</span>
<span class="line-modified">!         return primaryTypes.contains(type.asString());</span>
      }
  
      private final static Pattern majorVersionPattern = Pattern.compile(&quot;([0-9]+)(u[0-9]+)?&quot;);
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,29 ***</span>
      private List&lt;Issue&gt; findBackports(Issue primary) {
          var links = primary.links();
          return links.stream()
                      .filter(l -&gt; l.issue().isPresent())
                      .map(l -&gt; l.issue().get())
<span class="line-modified">!                     .filter(i -&gt; i.properties().containsKey(&quot;type&quot;))</span>
<span class="line-modified">!                     .filter(i -&gt; i.properties().get(&quot;type&quot;).equals(&quot;Backport&quot;))</span>
                      .collect(Collectors.toList());
      }
  
      private boolean isNonScratchVersion(String version) {
          return !version.startsWith(&quot;tbd&quot;) &amp;&amp; !version.toLowerCase().equals(&quot;unknown&quot;);
      }
  
      /**
       * Return true if the issue&#39;s fixVersionList matches fixVersion.
       *
       * fixVersionsList must contain one entry that is an exact match for fixVersions; any
       * other entries must be scratch values.
       */
      private boolean matchVersion(Issue issue, String fixVersion) {
<span class="line-modified">!         var nonScratch = issue.fixVersions().stream()</span>
<span class="line-modified">!                               .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                               .collect(Collectors.toList());</span>
          return nonScratch.size() == 1 &amp;&amp; nonScratch.get(0).equals(fixVersion);
      }
  
      /**
       * Return true if the issue&#39;s fixVersionList is a match for fixVersion, using &quot;-pool&quot; or &quot;-open&quot;.
<span class="line-new-header">--- 86,38 ---</span>
      private List&lt;Issue&gt; findBackports(Issue primary) {
          var links = primary.links();
          return links.stream()
                      .filter(l -&gt; l.issue().isPresent())
                      .map(l -&gt; l.issue().get())
<span class="line-modified">!                     .filter(i -&gt; i.properties().containsKey(&quot;issuetype&quot;))</span>
<span class="line-modified">!                     .filter(i -&gt; i.properties().get(&quot;issuetype&quot;).asString().equals(&quot;Backport&quot;))</span>
                      .collect(Collectors.toList());
      }
  
      private boolean isNonScratchVersion(String version) {
          return !version.startsWith(&quot;tbd&quot;) &amp;&amp; !version.toLowerCase().equals(&quot;unknown&quot;);
      }
  
<span class="line-added">+     private Set&lt;String&gt; fixVersions(Issue issue) {</span>
<span class="line-added">+         if (!issue.properties().containsKey(&quot;fixVersions&quot;)) {</span>
<span class="line-added">+             return Set.of();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return issue.properties().get(&quot;fixVersions&quot;).stream()</span>
<span class="line-added">+                     .map(JSONValue::asString)</span>
<span class="line-added">+                     .collect(Collectors.toSet());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Return true if the issue&#39;s fixVersionList matches fixVersion.
       *
       * fixVersionsList must contain one entry that is an exact match for fixVersions; any
       * other entries must be scratch values.
       */
      private boolean matchVersion(Issue issue, String fixVersion) {
<span class="line-modified">!         var nonScratch = fixVersions(issue).stream()</span>
<span class="line-modified">!                                            .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                                            .collect(Collectors.toList());</span>
          return nonScratch.size() == 1 &amp;&amp; nonScratch.get(0).equals(fixVersion);
      }
  
      /**
       * Return true if the issue&#39;s fixVersionList is a match for fixVersion, using &quot;-pool&quot; or &quot;-open&quot;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,34 ***</span>
              return false;
          }
          var poolVersion = majorVersion.get() + &quot;-pool&quot;;
          var openVersion = majorVersion.get() + &quot;-open&quot;;
  
<span class="line-modified">!         var nonScratch = issue.fixVersions().stream()</span>
<span class="line-modified">!                               .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                               .collect(Collectors.toList());</span>
          return nonScratch.size() == 1 &amp;&amp; (nonScratch.get(0).equals(poolVersion) || nonScratch.get(0).equals(openVersion));
      }
  
      /**
       * Return true if fixVersionList is empty or contains only scratch values.
       */
      private boolean matchScratchVersion(Issue issue) {
<span class="line-modified">!         var nonScratch = issue.fixVersions().stream()</span>
<span class="line-modified">!                               .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                               .collect(Collectors.toList());</span>
          return nonScratch.size() == 0;
      }
  
      /**
       * Create a backport of issue.
       */
      private Issue createBackportIssue(Issue primary) {
<span class="line-modified">!         var properties = primary.properties();</span>
<span class="line-modified">!         properties.put(&quot;type&quot;, &quot;Backport&quot;);</span>
  
<span class="line-modified">!         var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), properties);</span>
  
          var backportLink = Link.create(backport, &quot;backported by&quot;).build();
          primary.addLink(backportLink);;
          return backport;
      }
<span class="line-new-header">--- 131,41 ---</span>
              return false;
          }
          var poolVersion = majorVersion.get() + &quot;-pool&quot;;
          var openVersion = majorVersion.get() + &quot;-open&quot;;
  
<span class="line-modified">!         var nonScratch = fixVersions(issue).stream()</span>
<span class="line-modified">!                                            .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                                            .collect(Collectors.toList());</span>
          return nonScratch.size() == 1 &amp;&amp; (nonScratch.get(0).equals(poolVersion) || nonScratch.get(0).equals(openVersion));
      }
  
      /**
       * Return true if fixVersionList is empty or contains only scratch values.
       */
      private boolean matchScratchVersion(Issue issue) {
<span class="line-modified">!         var nonScratch = fixVersions(issue).stream()</span>
<span class="line-modified">!                                            .filter(this::isNonScratchVersion)</span>
<span class="line-modified">!                                            .collect(Collectors.toList());</span>
          return nonScratch.size() == 0;
      }
  
<span class="line-added">+     private final static Set&lt;String&gt; propagatedCustomProperties =</span>
<span class="line-added">+             Set.of(&quot;customfield_10008&quot;, &quot;customfield_10000&quot;, &quot;customfield_10005&quot;);</span>
<span class="line-added">+ </span>
      /**
       * Create a backport of issue.
       */
      private Issue createBackportIssue(Issue primary) {
<span class="line-modified">!         var filteredProperties = primary.properties().entrySet().stream()</span>
<span class="line-modified">!                 .filter(entry -&gt; !entry.getKey().startsWith(&quot;customfield_&quot;) || propagatedCustomProperties.contains(entry.getKey()))</span>
<span class="line-added">+                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
<span class="line-added">+ </span>
<span class="line-added">+         var finalProperties = new HashMap&lt;&gt;(filteredProperties);</span>
<span class="line-added">+         finalProperties.put(&quot;issuetype&quot;, JSON.of(&quot;Backport&quot;));</span>
  
<span class="line-modified">!         var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), finalProperties);</span>
  
          var backportLink = Link.create(backport, &quot;backported by&quot;).build();
          primary.addLink(backportLink);;
          return backport;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
       * A &quot;scratch&quot; fixVersion is empty, &quot;tbd.*&quot;, or &quot;unknown&quot;.
       */
      private Issue findIssue(Issue primary, String fixVersion) {
          log.info(&quot;Searching for properly versioned issue for primary issue &quot; + primary.id());
          var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
<span class="line-modified">!         candidates.forEach(c -&gt; log.fine(&quot;Candidate: &quot; + c.id() + &quot; with versions: &quot; + String.join(&quot;,&quot;, c.fixVersions())));</span>
          var matchingVersionIssue = candidates.stream()
                  .filter(i -&gt; matchVersion(i, fixVersion))
                  .findFirst();
          if (matchingVersionIssue.isPresent()) {
              log.info(&quot;Issue &quot; + matchingVersionIssue.get().id() + &quot; has a correct fixVersion&quot;);
<span class="line-new-header">--- 185,11 ---</span>
       * A &quot;scratch&quot; fixVersion is empty, &quot;tbd.*&quot;, or &quot;unknown&quot;.
       */
      private Issue findIssue(Issue primary, String fixVersion) {
          log.info(&quot;Searching for properly versioned issue for primary issue &quot; + primary.id());
          var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
<span class="line-modified">!         candidates.forEach(c -&gt; log.fine(&quot;Candidate: &quot; + c.id() + &quot; with versions: &quot; + String.join(&quot;,&quot;, fixVersions(c))));</span>
          var matchingVersionIssue = candidates.stream()
                  .filter(i -&gt; matchVersion(i, fixVersion))
                  .findFirst();
          if (matchingVersionIssue.isPresent()) {
              log.info(&quot;Issue &quot; + matchingVersionIssue.get().id() + &quot; has a correct fixVersion&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,15 ***</span>
                      issue.addLink(linkBuilder.build());
                  }
  
                  if (setFixVersion) {
                      if (requestedVersion != null) {
<span class="line-modified">!                         // Remove any previously set versions (can only be scratch versions)</span>
<span class="line-removed">-                         for (var oldVersion : issue.fixVersions()) {</span>
<span class="line-removed">-                             issue.removeFixVersion(oldVersion);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         issue.addFixVersion(requestedVersion);</span>
                      }
                  }
              }
          }
      }
<span class="line-new-header">--- 279,11 ---</span>
                      issue.addLink(linkBuilder.build());
                  }
  
                  if (setFixVersion) {
                      if (requestedVersion != null) {
<span class="line-modified">!                         issue.setProperty(&quot;fixVersions&quot;, JSON.of(requestedVersion));</span>
                      }
                  }
              }
          }
      }
</pre>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/notify/UpdaterTests.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>