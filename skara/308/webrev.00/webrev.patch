diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
@@ -20,25 +20,28 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.notify;
 
-import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.issuetracker.*;
 import org.openjdk.skara.issuetracker.Issue;
-import org.openjdk.skara.issuetracker.IssueProject;
 import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.vcs.openjdk.*;
 
+import java.net.URI;
 import java.util.List;
 import java.util.logging.Logger;
 
-public class IssueUpdater implements UpdateConsumer {
+public class IssueUpdater implements RepositoryUpdateConsumer, PullRequestUpdateConsumer {
     private final IssueProject issueProject;
+    private final URI reviewIcon;
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
 
-    IssueUpdater(IssueProject issueProject) {
+    IssueUpdater(IssueProject issueProject, URI reviewIcon) {
         this.issueProject = issueProject;
+        this.reviewIcon = reviewIcon;
     }
 
     @Override
     public void handleCommits(HostedRepository repository, List<Commit> commits, Branch branch) {
         for (var commit : commits) {
@@ -69,6 +72,35 @@
 
     @Override
     public void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch) {
 
     }
+
+    @Override
+    public void handleNewIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
+        var realIssue = issueProject.issue(issue.id());
+        if (realIssue.isEmpty()) {
+            log.warning("Pull request " + pr + " added unknown issue: " + issue.id());
+            return;
+        }
+
+        var linkBuilder = Link.create(pr.webUrl(), "Review")
+                              .summary(pr.repository().name() + "/" + pr.id())
+                              .iconTitle("Review");
+        if (reviewIcon != null) {
+            linkBuilder.iconUrl(reviewIcon);
+        }
+
+        realIssue.get().addLink(linkBuilder.build());
+    }
+
+    @Override
+    public void handleRemovedIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
+        var realIssue = issueProject.issue(issue.id());
+        if (realIssue.isEmpty()) {
+            log.warning("Pull request " + pr + " removed unknown issue: " + issue.id());
+            return;
+        }
+
+        realIssue.get().removeLink(pr.webUrl());
+    }
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
@@ -21,254 +21,101 @@
  * questions.
  */
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.bot.*;
-import org.openjdk.skara.forge.HostedRepository;
-import org.openjdk.skara.storage.StorageBuilder;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.storage.*;
+import org.openjdk.skara.vcs.Tag;
 
-import java.io.*;
-import java.net.*;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.*;
+import java.nio.file.Path;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
-import java.util.stream.*;
 
-class JNotifyBot implements Bot, WorkItem {
+class JNotifyBot implements Bot {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
     private final HostedRepository repository;
     private final Path storagePath;
     private final Pattern branches;
     private final StorageBuilder<Tag> tagStorageBuilder;
     private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
-    private final List<UpdateConsumer> updaters;
-
-    JNotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder, StorageBuilder<ResolvedBranch> branchStorageBuilder, List<UpdateConsumer> updaters) {
+    private final StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
+    private final List<RepositoryUpdateConsumer> updaters;
+    private final List<PullRequestUpdateConsumer> prUpdaters;
+    private final PullRequestUpdateCache updateCache;
+    private final Set<String> readyLabels;
+    private final Map<String, Pattern> readyComments;
+
+    JNotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder,
+               StorageBuilder<ResolvedBranch> branchStorageBuilder, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder,
+               List<RepositoryUpdateConsumer> updaters, List<PullRequestUpdateConsumer> prUpdaters,
+               Set<String> readyLabels, Map<String, Pattern> readyComments) {
         this.repository = repository;
         this.storagePath = storagePath;
         this.branches = branches;
         this.tagStorageBuilder = tagStorageBuilder;
         this.branchStorageBuilder = branchStorageBuilder;
+        this.prIssuesStorageBuilder = prIssuesStorageBuilder;
         this.updaters = updaters;
+        this.prUpdaters = prUpdaters;
+        this.updateCache = new PullRequestUpdateCache();
+        this.readyLabels = readyLabels;
+        this.readyComments = readyComments;
     }
 
-    @Override
-    public boolean concurrentWith(WorkItem other) {
-        if (!(other instanceof JNotifyBot)) {
-            return true;
-        }
-        JNotifyBot otherItem = (JNotifyBot) other;
-        if (!repository.name().equals(otherItem.repository.name())) {
-            return true;
-        }
-        return false;
-    }
-
-    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs) {
-        // Figure out the best parent ref
-        var candidates = new HashSet<>(allRefs);
-        candidates.remove(ref);
-        if (candidates.size() == 0) {
-            log.warning("No parent candidates found for branch '" + ref.name() + "' - ignoring");
-            return;
-        }
-
-        var bestParent = candidates.stream()
-                                   .map(c -> {
-                                       try {
-                                           return new AbstractMap.SimpleEntry<>(c, localRepo.commits(c.hash().hex() + ".." + ref.hash(), true).asList());
-                                       } catch (IOException e) {
-                                           throw new UncheckedIOException(e);
-                                       }
-                                   })
-                                   .min(Comparator.comparingInt(entry -> entry.getValue().size()))
-                                   .orElseThrow();
-        if (bestParent.getValue().size() > 1000) {
-            throw new RuntimeException("Excessive amount of unique commits on new branch " + ref.name() +
-                                               " detected (" + bestParent.getValue().size() + ") - skipping notifications");
-        }
-        for (var updater : updaters) {
-            var branch = new Branch(ref.name());
-            var parent = new Branch(bestParent.getKey().name());
-            updater.handleNewBranch(repository, bestParent.getValue(), parent, branch);
-        }
-    }
-
-    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits) {
-        for (var updater : updaters) {
-            var branch = new Branch(ref.name());
-            updater.handleCommits(repository, commits, branch);
-        }
-    }
-
-    private void handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
-        var branch = new Branch(ref.name());
-        var lastHash = history.branchHash(branch);
-        if (lastHash.isEmpty()) {
-            log.warning("No previous history found for branch '" + branch + "' - resetting mark");
-            history.setBranchHash(branch, ref.hash());
-            handleNewRef(localRepo, ref, allRefs);
-        } else {
-            var commits = localRepo.commits(lastHash.get() + ".." + ref.hash()).asList();
-            if (commits.size() == 0) {
-                return;
-            }
-            history.setBranchHash(branch, ref.hash());
-            if (commits.size() > 1000) {
-                throw new RuntimeException("Excessive amount of new commits on branch " + branch.name() +
-                                                   " detected (" + commits.size() + ") - skipping notifications");
+    private boolean isReady(PullRequest pr) {
+        var labels = new HashSet<>(pr.labels());
+        for (var readyLabel : readyLabels) {
+            if (!labels.contains(readyLabel)) {
+                log.fine("PR is not yet ready - missing label '" + readyLabel + "'");
+                return false;
             }
-            Collections.reverse(commits);
-            handleUpdatedRef(localRepo, ref, commits);
         }
-    }
 
-    private Optional<OpenJDKTag> existingPrevious(OpenJDKTag tag, Set<OpenJDKTag> allJdkTags) {
-        while (true) {
-            var candidate = tag.previous();
-            if (candidate.isEmpty()) {
-                return Optional.empty();
-            }
-            tag = candidate.get();
-            if (!allJdkTags.contains(tag)) {
-                continue;
-            }
-            return Optional.of(tag);
-        }
-    }
-
-    private void handleTags(Repository localRepo, UpdateHistory history) throws IOException {
-        var tags = localRepo.tags();
-        var newTags = tags.stream()
-                          .filter(tag -> !history.hasTag(tag))
-                          .collect(Collectors.toList());
-
-        if (tags.size() == newTags.size()) {
-            if (tags.size() > 0) {
-                log.warning("No previous tag history found - ignoring all current tags");
-                history.addTags(tags);
-            }
-            return;
-        }
-
-        if (newTags.size() > 10) {
-            history.addTags(newTags);
-            throw new RuntimeException("Excessive amount of new tags detected (" + newTags.size() +
-                                               ") - skipping notifications");
-        }
-
-        var allJdkTags = tags.stream()
-                             .map(OpenJDKTag::create)
-                             .filter(Optional::isPresent)
-                             .map(Optional::get)
-                             .collect(Collectors.toSet());
-        var newJdkTags = newTags.stream()
-                                .map(OpenJDKTag::create)
-                                .filter(Optional::isPresent)
-                                .map(Optional::get)
-                                .sorted(Comparator.comparingInt(OpenJDKTag::buildNum))
-                                .collect(Collectors.toList());
-        for (var tag : newJdkTags) {
-            // Update the history first - if there is a problem here we don't want to send out multiple updates
-            history.addTags(List.of(tag.tag()));
-
-            var commits = new ArrayList<Commit>();
-
-            // Try to determine which commits are new since the last build
-            var previous = existingPrevious(tag, allJdkTags);
-            if (previous.isPresent()) {
-                commits.addAll(localRepo.commits(previous.get().tag() + ".." + tag.tag()).asList());
-            }
-
-            // If none are found, just include the commit that was tagged
-            if (commits.isEmpty()) {
-                var commit = localRepo.lookup(tag.tag());
-                if (commit.isEmpty()) {
-                    throw new RuntimeException("Failed to lookup tag '" + tag.toString() + "'");
-                } else {
-                    commits.add(commit.get());
+        var comments = pr.comments();
+        for (var readyComment : readyComments.entrySet()) {
+            var commentFound = false;
+            for (var comment : comments) {
+                if (comment.author().userName().equals(readyComment.getKey())) {
+                    var matcher = readyComment.getValue().matcher(comment.body());
+                    if (matcher.find()) {
+                        commentFound = true;
+                        break;
+                    }
                 }
             }
-
-            Collections.reverse(commits);
-            var annotation = localRepo.annotate(tag.tag());
-            for (var updater : updaters) {
-                updater.handleOpenJDKTagCommits(repository, commits, tag, annotation.orElse(null));
-            }
-        }
-
-        var newNonJdkTags = newTags.stream()
-                                   .filter(tag -> OpenJDKTag.create(tag).isEmpty())
-                                   .collect(Collectors.toList());
-        for (var tag : newNonJdkTags) {
-            // Update the history first - if there is a problem here we don't want to send out multiple updates
-            history.addTags(List.of(tag));
-
-            var commit = localRepo.lookup(tag);
-            if (commit.isEmpty()) {
-                throw new RuntimeException("Failed to lookup tag '" + tag.toString() + "'");
-            }
-
-            var annotation = localRepo.annotate(tag);
-            for (var updater : updaters) {
-                updater.handleTagCommit(repository, commit.get(), tag, annotation.orElse(null));
+            if (!commentFound) {
+                log.fine("PR is not yet ready - missing ready comment from '" + readyComment.getKey() +
+                                 "containing '" + readyComment.getValue().pattern() + "'");
+                return false;
             }
         }
+        return true;
     }
 
-    private Repository fetchAll(Path dir, URI remote) throws IOException {
-        Repository repo = null;
-        if (!Files.exists(dir)) {
-            Files.createDirectories(dir);
-            repo = Repository.clone(remote, dir);
-        } else {
-            repo = Repository.get(dir).orElseThrow(() -> new RuntimeException("Repository in " + dir + " has vanished"));
-        }
-        repo.fetchAll();
-        return repo;
+    @Override
+    public String toString() {
+        return "JNotifyBot@" + repository.name();
     }
 
     @Override
-    public void run(Path scratchPath) {
-        var sanitizedUrl = URLEncoder.encode(repository.webUrl().toString() + "v2", StandardCharsets.UTF_8);
-        var path = storagePath.resolve(sanitizedUrl);
-        var historyPath = scratchPath.resolve("notify").resolve("history");
-
-        try {
-            var localRepo = fetchAll(path, repository.url());
-            var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve("tags"), branchStorageBuilder, historyPath.resolve("branches"));
-            handleTags(localRepo, history);
-
-            var knownRefs = localRepo.remoteBranches("origin")
-                                     .stream()
-                                     .filter(ref -> branches.matcher(ref.name()).matches())
-                                     .collect(Collectors.toList());
-            boolean hasBranchHistory = knownRefs.stream()
-                                                .map(ref -> history.branchHash(new Branch(ref.name())))
-                                                .anyMatch(Optional::isPresent);
-            for (var ref : knownRefs) {
-                if (!hasBranchHistory) {
-                    log.warning("No previous history found for any branch - resetting mark for '" + ref.name() + "'");
-                    history.setBranchHash(new Branch(ref.name()), ref.hash());
-                } else {
-                    handleRef(localRepo, history, ref, knownRefs);
+    public List<WorkItem> getPeriodicItems() {
+        var ret = new LinkedList<WorkItem>();
+
+        // Pull request events
+        var prs = repository.pullRequests();
+        for (var pr : prs) {
+            if (updateCache.needsUpdate(pr)) {
+                if (!isReady(pr)) {
+                    continue;
                 }
+                ret.add(new PullRequestWorkItem(pr, prIssuesStorageBuilder, prUpdaters, e -> updateCache.invalidate(pr)));
             }
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
         }
-    }
 
-    @Override
-    public String toString() {
-        return "JNotifyBot@" + repository.name();
-    }
+        // Repository events
+        ret.add(new RepositoryWorkItem(repository, storagePath, branches, tagStorageBuilder, branchStorageBuilder, updaters));
 
-    @Override
-    public List<WorkItem> getPeriodicItems() {
-        return List.of(this);
+        return ret;
     }
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java
@@ -22,16 +22,17 @@
  */
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.bot.*;
 import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.network.URIBuilder;
-import org.openjdk.skara.json.JSONObject;
+import org.openjdk.skara.json.*;
 import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.network.URIBuilder;
 import org.openjdk.skara.storage.StorageBuilder;
 import org.openjdk.skara.vcs.Tag;
 
+import java.net.URI;
 import java.nio.file.Path;
 import java.time.Duration;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
@@ -54,10 +55,25 @@
         var databaseRepo = configuration.repository(database.get("repository").asString());
         var databaseRef = configuration.repositoryRef(database.get("repository").asString());
         var databaseName = database.get("name").asString();
         var databaseEmail = database.get("email").asString();
 
+        var readyLabels = specific.get("ready").get("labels").stream()
+                                  .map(JSONValue::asString)
+                                  .collect(Collectors.toSet());
+        var readyComments = specific.get("ready").get("comments").stream()
+                                    .map(JSONValue::asObject)
+                                    .collect(Collectors.toMap(obj -> obj.get("user").asString(),
+                                                              obj -> Pattern.compile(obj.get("pattern").asString())));
+
+        URI reviewIcon = null;
+        if (specific.contains("reviews")) {
+            if (specific.get("reviews").contains("icon")) {
+                reviewIcon = URI.create(specific.get("reviews").get("icon").asString());
+            }
+        }
+
         for (var repo : specific.get("repositories").fields()) {
             var repoName = repo.name();
             var branchPattern = Pattern.compile("^master$");
             if (repo.value().contains("branches")) {
                 branchPattern = Pattern.compile(repo.value().get("branches").asString());
@@ -65,12 +81,12 @@
 
             var includeBranchNames = false;
             if (repo.value().contains("branchnames")) {
                 includeBranchNames = repo.value().get("branchnames").asBoolean();
             }
-
-            var updaters = new ArrayList<UpdateConsumer>();
+            var updaters = new ArrayList<RepositoryUpdateConsumer>();
+            var prUpdaters = new ArrayList<PullRequestUpdateConsumer>();
             if (repo.value().contains("json")) {
                 var folder = repo.value().get("folder").asString();
                 var build = repo.value().get("build").asString();
                 var version = repo.value().get("version").asString();
                 updaters.add(new JsonUpdater(Path.of(folder), version, build));
@@ -111,11 +127,13 @@
                                                         includeBranchNames, mode, headers, allowedDomains));
                 }
             }
             if (repo.value().contains("issues")) {
                 var issueProject = configuration.issueProject(repo.value().get("issues").asString());
-                updaters.add(new IssueUpdater(issueProject));
+                var updater = new IssueUpdater(issueProject, reviewIcon);
+                updaters.add(updater);
+                prUpdaters.add(updater);
             }
 
             if (updaters.isEmpty()) {
                 log.warning("No consumers configured for notify bot repository: " + repoName);
                 continue;
@@ -125,11 +143,14 @@
 
             var tagStorageBuilder = new StorageBuilder<Tag>(baseName + ".tags.txt")
                     .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added tag for " + repoName);
             var branchStorageBuilder = new StorageBuilder<ResolvedBranch>(baseName + ".branches.txt")
                     .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added branch hash for " + repoName);
-            var bot = new JNotifyBot(configuration.repository(repoName), configuration.storageFolder(), branchPattern, tagStorageBuilder, branchStorageBuilder, updaters);
+            var issueStorageBuilder = new StorageBuilder<PullRequestIssues>(baseName + ".prissues.txt")
+                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added pull request issue info for " + repoName);
+            var bot = new JNotifyBot(configuration.repository(repoName), configuration.storageFolder(), branchPattern,
+                                     tagStorageBuilder, branchStorageBuilder, issueStorageBuilder, updaters, prUpdaters, readyLabels, readyComments);
             ret.add(bot);
         }
 
         return ret;
     }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
@@ -29,11 +29,11 @@
 
 import java.nio.file.Path;
 import java.time.format.DateTimeFormatter;
 import java.util.*;
 
-public class JsonUpdater implements UpdateConsumer {
+public class JsonUpdater implements RepositoryUpdateConsumer {
     private final Path path;
     private final String version;
     private final String defaultBuild;
 
     JsonUpdater(Path path, String version, String defaultBuild) {
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
@@ -34,11 +34,11 @@
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
-public class MailingListUpdater implements UpdateConsumer {
+public class MailingListUpdater implements RepositoryUpdateConsumer {
     private final MailingList list;
     private final EmailAddress recipient;
     private final EmailAddress sender;
     private final EmailAddress author;
     private final boolean includeBranch;
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestIssues.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestIssues.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestIssues.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.forge.PullRequest;
+
+import java.util.*;
+
+public class PullRequestIssues {
+    private final String prId;
+    private final Set<String> issueIds;
+
+    PullRequestIssues(PullRequest pr, Set<String> issueIds) {
+        this.prId = pr.repository().id() + ":" + pr.id();
+        this.issueIds = issueIds;
+    }
+
+    PullRequestIssues(String prId, Set<String> issueIds) {
+        this.prId = prId;
+        this.issueIds = issueIds;
+    }
+
+    public String prId() {
+        return prId;
+    }
+
+    public Set<String> issueIds() {
+        return issueIds;
+    }
+
+    @Override
+    public String toString() {
+        return "PullRequestIssues{" +
+                "prId='" + prId + '\'' +
+                ", issueIds=" + issueIds +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        PullRequestIssues that = (PullRequestIssues) o;
+        return prId.equals(that.prId) &&
+                issueIds.equals(that.issueIds);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(prId, issueIds);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.vcs.openjdk.Issue;
+
+public interface PullRequestUpdateConsumer {
+    void handleNewIssue(PullRequest pr, Issue issue);
+    void handleRemovedIssue(PullRequest pr, Issue issue);
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestWorkItem.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestWorkItem.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestWorkItem.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.WorkItem;
+import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.json.*;
+import org.openjdk.skara.storage.StorageBuilder;
+import org.openjdk.skara.vcs.openjdk.Issue;
+
+import java.nio.file.Path;
+import java.util.*;
+import java.util.function.*;
+import java.util.regex.Pattern;
+import java.util.stream.*;
+
+public class PullRequestWorkItem implements WorkItem {
+    private final PullRequest pr;
+    private final StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
+    private final List<PullRequestUpdateConsumer> pullRequestUpdateConsumers;
+    private final Consumer<RuntimeException> errorHandler;
+
+    PullRequestWorkItem(PullRequest pr, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder, List<PullRequestUpdateConsumer> pullRequestUpdateConsumers, Consumer<RuntimeException> errorHandler) {
+        this.pr = pr;
+        this.prIssuesStorageBuilder = prIssuesStorageBuilder;
+        this.pullRequestUpdateConsumers = pullRequestUpdateConsumers;
+        this.errorHandler = errorHandler;
+    }
+
+    private Set<PullRequestIssues> loadPrIssues(String current) {
+        if (current.isBlank()) {
+            return Set.of();
+        }
+        var data = JSON.parse(current);
+        return data.stream()
+                   .map(JSONValue::asObject)
+                   .map(obj -> new PullRequestIssues(obj.get("pr").asString(), obj.get("issues").stream()
+                                                                                  .map(JSONValue::asString)
+                                                                                  .collect(Collectors.toSet())))
+                   .collect(Collectors.toSet());
+    }
+
+    private String serializePrIssues(Collection<PullRequestIssues> added, Set<PullRequestIssues> existing) {
+        var addedPrs = added.stream()
+                            .map(PullRequestIssues::prId)
+                            .collect(Collectors.toSet());
+        var nonReplaced = existing.stream()
+                                  .filter(item -> !addedPrs.contains(item.prId()))
+                                  .collect(Collectors.toSet());
+
+        var entries = Stream.concat(nonReplaced.stream(),
+                                    added.stream())
+                            .sorted(Comparator.comparing(PullRequestIssues::prId))
+                            .map(pr -> JSON.object().put("pr", pr.prId()).put("issues", new JSONArray(
+                                    pr.issueIds().stream()
+                                      .map(JSON::of)
+                                      .collect(Collectors.toList()))))
+                            .map(JSONObject::toString)
+                            .collect(Collectors.toList());
+        return "[\n" + String.join(",\n", entries) + "\n]";
+    }
+
+    private final Pattern issuesBlockPattern = Pattern.compile("\\n\\n## Issues?((?:\\n\\[.*)+)", Pattern.MULTILINE);
+    private final Pattern issuePattern = Pattern.compile("^\\[(\\S+)]\\(.*\\): .*$", Pattern.MULTILINE);
+
+    private Set<String> parseIssues() {
+        var issuesBlockMatcher = issuesBlockPattern.matcher(pr.body());
+        if (!issuesBlockMatcher.find()) {
+            return Set.of();
+        }
+        var issueMatcher = issuePattern.matcher(issuesBlockMatcher.group(1));
+        return issueMatcher.results()
+                           .map(mo -> mo.group(1))
+                           .collect(Collectors.toSet());
+    }
+
+    @Override
+    public boolean concurrentWith(WorkItem other) {
+        if (!(other instanceof PullRequestWorkItem)) {
+            return true;
+        }
+        PullRequestWorkItem otherItem = (PullRequestWorkItem)other;
+        if (!pr.id().equals(otherItem.pr.id())) {
+            return true;
+        }
+        if (!pr.repository().name().equals(otherItem.pr.repository().name())) {
+            return true;
+        }
+        return false;
+    }
+
+    private void notifyListenersAdded(String issueId) {
+        pullRequestUpdateConsumers.forEach(c -> c.handleNewIssue(pr, new Issue(issueId, "")));
+    }
+
+    private void notifyListenersRemoved(String issueId) {
+        pullRequestUpdateConsumers.forEach(c -> c.handleRemovedIssue(pr, new Issue(issueId, "")));
+    }
+
+    @Override
+    public void run(Path scratchPath) {
+        var historyPath = scratchPath.resolve("notify").resolve("history");
+        var storage = prIssuesStorageBuilder
+                .serializer(this::serializePrIssues)
+                .deserializer(this::loadPrIssues)
+                .materialize(historyPath);
+
+        var issues = parseIssues();
+        var prIssues = new PullRequestIssues(pr, issues);
+        var current = storage.current();
+        if (current.contains(prIssues)) {
+            // Already up to date
+            return;
+        }
+
+        // Search for an existing
+        var oldPrIssues = current.stream()
+                .filter(p -> p.prId().equals(prIssues.prId()))
+                .findAny();
+        if (oldPrIssues.isPresent()) {
+            var oldIssues = oldPrIssues.get().issueIds();
+            oldIssues.stream()
+                     .filter(issue -> !issues.contains(issue))
+                     .forEach(this::notifyListenersRemoved);
+            issues.stream()
+                  .filter(issue -> !oldIssues.contains(issue))
+                  .forEach(this::notifyListenersAdded);
+        } else {
+            issues.forEach(this::notifyListenersAdded);
+        }
+
+        storage.put(prIssues);
+    }
+
+    @Override
+    public String toString() {
+        return "Notify.PR@" + pr.repository().name() + "#" + pr.id();
+    }
+
+    @Override
+    public void handleRuntimeException(RuntimeException e) {
+        errorHandler.accept(e);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
+
+import java.util.List;
+
+public interface RepositoryUpdateConsumer {
+    void handleCommits(HostedRepository repository, List<Commit> commits, Branch branch);
+    void handleOpenJDKTagCommits(HostedRepository repository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotated);
+    void handleTagCommit(HostedRepository repository, Commit commit, Tag tag, Tag.Annotated annotation);
+    void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch);
+
+    default void handleOpenJDKTagCommits(HostedRepository repository, List<Commit> commits, OpenJDKTag tag) {
+        handleOpenJDKTagCommits(repository, commits, tag, null);
+    }
+    default void handleTagCommit(HostedRepository repository, Commit commit, Tag tag) {
+        handleTagCommit(repository, commit, tag, null);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.WorkItem;
+import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.storage.StorageBuilder;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
+
+import java.io.*;
+import java.net.*;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.*;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class RepositoryWorkItem implements WorkItem {
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
+    private final HostedRepository repository;
+    private final Path storagePath;
+    private final Pattern branches;
+    private final StorageBuilder<Tag> tagStorageBuilder;
+    private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
+    private final List<RepositoryUpdateConsumer> updaters;
+
+    RepositoryWorkItem(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder, StorageBuilder<ResolvedBranch> branchStorageBuilder, List<RepositoryUpdateConsumer> updaters) {
+        this.repository = repository;
+        this.storagePath = storagePath;
+        this.branches = branches;
+        this.tagStorageBuilder = tagStorageBuilder;
+        this.branchStorageBuilder = branchStorageBuilder;
+        this.updaters = updaters;
+    }
+
+    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs) {
+        // Figure out the best parent ref
+        var candidates = new HashSet<>(allRefs);
+        candidates.remove(ref);
+        if (candidates.size() == 0) {
+            log.warning("No parent candidates found for branch '" + ref.name() + "' - ignoring");
+            return;
+        }
+
+        var bestParent = candidates.stream()
+                                   .map(c -> {
+                                       try {
+                                           return new AbstractMap.SimpleEntry<>(c, localRepo.commits(c.hash().hex() + ".." + ref.hash(), true).asList());
+                                       } catch (IOException e) {
+                                           throw new UncheckedIOException(e);
+                                       }
+                                   })
+                                   .min(Comparator.comparingInt(entry -> entry.getValue().size()))
+                                   .orElseThrow();
+        if (bestParent.getValue().size() > 1000) {
+            throw new RuntimeException("Excessive amount of unique commits on new branch " + ref.name() +
+                                               " detected (" + bestParent.getValue().size() + ") - skipping notifications");
+        }
+        for (var updater : updaters) {
+            var branch = new Branch(ref.name());
+            var parent = new Branch(bestParent.getKey().name());
+            updater.handleNewBranch(repository, bestParent.getValue(), parent, branch);
+        }
+    }
+
+    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits) {
+        for (var updater : updaters) {
+            var branch = new Branch(ref.name());
+            updater.handleCommits(repository, commits, branch);
+        }
+    }
+
+    private void handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
+        var branch = new Branch(ref.name());
+        var lastHash = history.branchHash(branch);
+        if (lastHash.isEmpty()) {
+            log.warning("No previous history found for branch '" + branch + "' - resetting mark");
+            history.setBranchHash(branch, ref.hash());
+            handleNewRef(localRepo, ref, allRefs);
+        } else {
+            var commits = localRepo.commits(lastHash.get() + ".." + ref.hash()).asList();
+            if (commits.size() == 0) {
+                return;
+            }
+            history.setBranchHash(branch, ref.hash());
+            if (commits.size() > 1000) {
+                throw new RuntimeException("Excessive amount of new commits on branch " + branch.name() +
+                                                   " detected (" + commits.size() + ") - skipping notifications");
+            }
+            Collections.reverse(commits);
+            handleUpdatedRef(localRepo, ref, commits);
+        }
+    }
+
+    private Optional<OpenJDKTag> existingPrevious(OpenJDKTag tag, Set<OpenJDKTag> allJdkTags) {
+        while (true) {
+            var candidate = tag.previous();
+            if (candidate.isEmpty()) {
+                return Optional.empty();
+            }
+            tag = candidate.get();
+            if (!allJdkTags.contains(tag)) {
+                continue;
+            }
+            return Optional.of(tag);
+        }
+    }
+
+    private void handleTags(Repository localRepo, UpdateHistory history) throws IOException {
+        var tags = localRepo.tags();
+        var newTags = tags.stream()
+                          .filter(tag -> !history.hasTag(tag))
+                          .collect(Collectors.toList());
+
+        if (tags.size() == newTags.size()) {
+            if (tags.size() > 0) {
+                log.warning("No previous tag history found - ignoring all current tags");
+                history.addTags(tags);
+            }
+            return;
+        }
+
+        if (newTags.size() > 10) {
+            history.addTags(newTags);
+            throw new RuntimeException("Excessive amount of new tags detected (" + newTags.size() +
+                                               ") - skipping notifications");
+        }
+
+        var allJdkTags = tags.stream()
+                             .map(OpenJDKTag::create)
+                             .filter(Optional::isPresent)
+                             .map(Optional::get)
+                             .collect(Collectors.toSet());
+        var newJdkTags = newTags.stream()
+                                .map(OpenJDKTag::create)
+                                .filter(Optional::isPresent)
+                                .map(Optional::get)
+                                .sorted(Comparator.comparingInt(OpenJDKTag::buildNum))
+                                .collect(Collectors.toList());
+        for (var tag : newJdkTags) {
+            // Update the history first - if there is a problem here we don't want to send out multiple updates
+            history.addTags(List.of(tag.tag()));
+
+            var commits = new ArrayList<Commit>();
+
+            // Try to determine which commits are new since the last build
+            var previous = existingPrevious(tag, allJdkTags);
+            if (previous.isPresent()) {
+                commits.addAll(localRepo.commits(previous.get().tag() + ".." + tag.tag()).asList());
+            }
+
+            // If none are found, just include the commit that was tagged
+            if (commits.isEmpty()) {
+                var commit = localRepo.lookup(tag.tag());
+                if (commit.isEmpty()) {
+                    throw new RuntimeException("Failed to lookup tag '" + tag.toString() + "'");
+                } else {
+                    commits.add(commit.get());
+                }
+            }
+
+            Collections.reverse(commits);
+            var annotation = localRepo.annotate(tag.tag());
+            for (var updater : updaters) {
+                updater.handleOpenJDKTagCommits(repository, commits, tag, annotation.orElse(null));
+            }
+        }
+
+        var newNonJdkTags = newTags.stream()
+                                   .filter(tag -> OpenJDKTag.create(tag).isEmpty())
+                                   .collect(Collectors.toList());
+        for (var tag : newNonJdkTags) {
+            // Update the history first - if there is a problem here we don't want to send out multiple updates
+            history.addTags(List.of(tag));
+
+            var commit = localRepo.lookup(tag);
+            if (commit.isEmpty()) {
+                throw new RuntimeException("Failed to lookup tag '" + tag.toString() + "'");
+            }
+
+            var annotation = localRepo.annotate(tag);
+            for (var updater : updaters) {
+                updater.handleTagCommit(repository, commit.get(), tag, annotation.orElse(null));
+            }
+        }
+    }
+
+    private Repository fetchAll(Path dir, URI remote) throws IOException {
+        Repository repo = null;
+        if (!Files.exists(dir)) {
+            Files.createDirectories(dir);
+            repo = Repository.clone(remote, dir);
+        } else {
+            repo = Repository.get(dir).orElseThrow(() -> new RuntimeException("Repository in " + dir + " has vanished"));
+        }
+        repo.fetchAll();
+        return repo;
+    }
+
+
+    @Override
+    public boolean concurrentWith(WorkItem other) {
+        if (!(other instanceof RepositoryWorkItem)) {
+            return true;
+        }
+        RepositoryWorkItem otherItem = (RepositoryWorkItem) other;
+        if (!repository.name().equals(otherItem.repository.name())) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void run(Path scratchPath) {
+        var sanitizedUrl = URLEncoder.encode(repository.webUrl().toString() + "v2", StandardCharsets.UTF_8);
+        var path = storagePath.resolve(sanitizedUrl);
+        var historyPath = scratchPath.resolve("notify").resolve("history");
+
+        try {
+            var localRepo = fetchAll(path, repository.url());
+            var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve("tags"), branchStorageBuilder, historyPath.resolve("branches"));
+            handleTags(localRepo, history);
+
+            var knownRefs = localRepo.remoteBranches("origin")
+                                     .stream()
+                                     .filter(ref -> branches.matcher(ref.name()).matches())
+                                     .collect(Collectors.toList());
+            boolean hasBranchHistory = knownRefs.stream()
+                                                .map(ref -> history.branchHash(new Branch(ref.name())))
+                                                .anyMatch(Optional::isPresent);
+            for (var ref : knownRefs) {
+                if (!hasBranchHistory) {
+                    log.warning("No previous history found for any branch - resetting mark for '" + ref.name() + "'");
+                    history.setBranchHash(new Branch(ref.name()), ref.hash());
+                } else {
+                    handleRef(localRepo, history, ref, knownRefs);
+                }
+            }
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.forge.HostedRepository;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
-
-import java.util.List;
-
-public interface UpdateConsumer {
-    void handleCommits(HostedRepository repository, List<Commit> commits, Branch branch);
-    void handleOpenJDKTagCommits(HostedRepository repository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotated);
-    void handleTagCommit(HostedRepository repository, Commit commit, Tag tag, Tag.Annotated annotation);
-    void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch);
-
-    default void handleOpenJDKTagCommits(HostedRepository repository, List<Commit> commits, OpenJDKTag tag) {
-        handleOpenJDKTagCommits(repository, commits, tag, null);
-    }
-    default void handleTagCommit(HostedRepository repository, Commit commit, Tag tag) {
-        handleTagCommit(repository, commit, tag, null);
-    }
-}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
@@ -31,10 +31,11 @@
 import org.openjdk.skara.vcs.Tag;
 
 import org.junit.jupiter.api.*;
 
 import java.io.IOException;
+import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.*;
 import java.time.Duration;
 import java.util.*;
 import java.util.regex.Pattern;
@@ -48,18 +49,23 @@
                     .filter(path -> path.toString().endsWith(".json"))
                     .filter(path -> path.toString().contains(partialName))
                     .collect(Collectors.toList());
     }
 
-    private StorageBuilder<Tag> createTagStorage(HostedRepository repository) throws IOException {
+    private StorageBuilder<Tag> createTagStorage(HostedRepository repository) {
         return new StorageBuilder<Tag>("tags.txt")
-                .remoteRepository(repository, "refs/heads/history", "Duke", "duke@openjdk.java.net", "Updated tags");
+                .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated tags");
     }
 
-    private StorageBuilder<ResolvedBranch> createBranchStorage(HostedRepository repository) throws IOException {
+    private StorageBuilder<ResolvedBranch> createBranchStorage(HostedRepository repository) {
         return new StorageBuilder<ResolvedBranch>("branches.txt")
-                .remoteRepository(repository, "refs/heads/history", "Duke", "duke@openjdk.java.net", "Updated branches");
+                .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated branches");
+    }
+
+    private StorageBuilder<PullRequestIssues> createPullRequestIssuesStorage(HostedRepository repository) {
+        return new StorageBuilder<PullRequestIssues>("prissues.txt")
+                .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated prissues");
     }
 
     @Test
     void testJsonUpdaterBranch(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
@@ -70,16 +76,18 @@
             credentials.commitLock(localRepo);
             localRepo.pushAll(repo.url());
 
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var jsonFolder = tempFolder.path().resolve("json");
             Files.createDirectory(jsonFolder);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             TestBotRunner.runPeriodicItems(notifyBot);
             assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
 
             var editHash = CheckableRepository.appendAndCommit(localRepo, "One more line", "12345678: Fixes");
@@ -109,16 +117,18 @@
             localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke", "duke@openjdk.java.net");
             localRepo.pushAll(repo.url());
 
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var jsonFolder = tempFolder.path().resolve("json");
             Files.createDirectory(jsonFolder);
             var storageFolder =tempFolder.path().resolve("storage");
 
             var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             TestBotRunner.runPeriodicItems(notifyBot);
             assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
 
             var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
@@ -180,16 +190,18 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"), Pattern.compile("none"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -231,16 +243,18 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -284,16 +298,18 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -333,17 +349,19 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var author = EmailAddress.from("author", "author@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, author, true,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|another"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|another"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -406,18 +424,20 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var author = EmailAddress.from("author", "author@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, author, false,
                                                  MailingListUpdater.Mode.PR_ONLY, Map.of("extra1", "value1"),
                                                  Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -485,16 +505,18 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.PR, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -572,20 +594,21 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"),
                                                  Pattern.compile(".*"));
             var prOnlyUpdater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                        MailingListUpdater.Mode.PR_ONLY, Map.of(), Pattern.compile(".*"));
             var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           List.of(updater, prOnlyUpdater));
+                                           prIssuesStorage, List.of(updater, prOnlyUpdater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -670,17 +693,19 @@
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
             var mailmanList = mailmanServer.getList(listAddress.address());
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"),
                                                  Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|newbranch."), tagStorage, branchStorage, List.of(updater));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|newbranch."), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -731,15 +756,17 @@
             credentials.commitLock(localRepo);
             localRepo.pushAll(repo.url());
 
             var tagStorage = createTagStorage(repo);
             var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var issueProject = credentials.getIssueProject();
-            var updater = new IssueUpdater(issueProject);
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage, List.of(updater));
+            var updater = new IssueUpdater(issueProject, null);
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // Initialize history
             TestBotRunner.runPeriodicItems(notifyBot);
 
             // Create an issue and commit a fix
@@ -756,6 +783,95 @@
 
             // There should be no open issues
             assertEquals(0, issueProject.issues().size());
         }
     }
+
+    @Test
+    void testPullRequest(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var issueProject = credentials.getIssueProject();
+            var reviewIcon = URI.create("http://www.example.com/review.png");
+            var updater = new IssueUpdater(issueProject, reviewIcon);
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                           prIssuesStorage, List.of(), List.of(updater), Set.of("rfr"),
+                                           Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")));
+
+            // Initialize history
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Create an issue and a pull request to fix it
+            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"));
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fix that issue");
+            localRepo.push(editHash, repo.url(), "edit", true);
+            var pr = credentials.createPullRequest(repo, "edit", "master", issue.id() + ": Fix that issue");
+            pr.setBody("\n\n## Issue\n[" + issue.id() + "](http://www.test.test/): The issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should not yet contain a link to the PR
+            var links = issue.links();
+            assertEquals(0, links.size());
+
+            // Just a label isn't enough
+            pr.addLabel("rfr");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            links = issue.links();
+            assertEquals(0, links.size());
+
+            // Neither is just a comment
+            pr.removeLabel("rfr");
+            var reviewPr = reviewer.pullRequest(pr.id());
+            reviewPr.addComment("This is now ready");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            links = issue.links();
+            assertEquals(0, links.size());
+
+            // Both are needed
+            pr.addLabel("rfr");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should now contain a link to the PR
+            links = issue.links();
+            assertEquals(1, links.size());
+            assertEquals(pr.webUrl(), links.get(0).uri());
+            assertEquals(reviewIcon, links.get(0).iconUrl().orElseThrow());
+
+            // Add another issue
+            var issue2 = issueProject.createIssue("This is another issue", List.of("Yes indeed"));
+            pr.setBody("\n\n## Issues\n[" + issue.id() + "](http://www.test.test/): The issue\n[" + issue2.id() +
+                               "](http://www.test2.test/): The second issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Both issues should contain a link to the PR
+            var links1 = issue.links();
+            assertEquals(1, links1.size());
+            assertEquals(pr.webUrl(), links1.get(0).uri());
+            var links2 = issue2.links();
+            assertEquals(1, links2.size());
+            assertEquals(pr.webUrl(), links2.get(0).uri());
+
+            // Drop the first one
+            pr.setBody("\n\n## Issue\n[" + issue2.id() + "](http://www.test2.test/): That other issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Only the second issue should now contain a link to the PR
+            links1 = issue.links();
+            assertEquals(0, links1.size());
+            links2 = issue2.links();
+            assertEquals(1, links2.size());
+            assertEquals(pr.webUrl(), links2.get(0).uri());
+        }
+    }
 }
