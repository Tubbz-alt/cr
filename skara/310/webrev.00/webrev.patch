diff a/bots/notify/src/main/java/module-info.java b/bots/notify/src/main/java/module-info.java
--- a/bots/notify/src/main/java/module-info.java
+++ b/bots/notify/src/main/java/module-info.java
@@ -28,7 +28,7 @@
     requires org.openjdk.skara.storage;
     requires org.openjdk.skara.mailinglist;
     requires org.openjdk.skara.network;
     requires java.logging;
 
-    provides org.openjdk.skara.bot.BotFactory with org.openjdk.skara.bots.notify.JNotifyBotFactory;
+    provides org.openjdk.skara.bot.BotFactory with org.openjdk.skara.bots.notify.NotifyBotFactory;
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.bot.*;
-import org.openjdk.skara.forge.*;
-import org.openjdk.skara.storage.*;
-import org.openjdk.skara.vcs.Tag;
-
-import java.nio.file.Path;
-import java.util.*;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-
-class JNotifyBot implements Bot {
-    private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
-    private final HostedRepository repository;
-    private final Path storagePath;
-    private final Pattern branches;
-    private final StorageBuilder<Tag> tagStorageBuilder;
-    private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
-    private final StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
-    private final List<RepositoryUpdateConsumer> updaters;
-    private final List<PullRequestUpdateConsumer> prUpdaters;
-    private final PullRequestUpdateCache updateCache;
-    private final Set<String> readyLabels;
-    private final Map<String, Pattern> readyComments;
-
-    JNotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder,
-               StorageBuilder<ResolvedBranch> branchStorageBuilder, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder,
-               List<RepositoryUpdateConsumer> updaters, List<PullRequestUpdateConsumer> prUpdaters,
-               Set<String> readyLabels, Map<String, Pattern> readyComments) {
-        this.repository = repository;
-        this.storagePath = storagePath;
-        this.branches = branches;
-        this.tagStorageBuilder = tagStorageBuilder;
-        this.branchStorageBuilder = branchStorageBuilder;
-        this.prIssuesStorageBuilder = prIssuesStorageBuilder;
-        this.updaters = updaters;
-        this.prUpdaters = prUpdaters;
-        this.updateCache = new PullRequestUpdateCache();
-        this.readyLabels = readyLabels;
-        this.readyComments = readyComments;
-    }
-
-    private boolean isReady(PullRequest pr) {
-        var labels = new HashSet<>(pr.labels());
-        for (var readyLabel : readyLabels) {
-            if (!labels.contains(readyLabel)) {
-                log.fine("PR is not yet ready - missing label '" + readyLabel + "'");
-                return false;
-            }
-        }
-
-        var comments = pr.comments();
-        for (var readyComment : readyComments.entrySet()) {
-            var commentFound = false;
-            for (var comment : comments) {
-                if (comment.author().userName().equals(readyComment.getKey())) {
-                    var matcher = readyComment.getValue().matcher(comment.body());
-                    if (matcher.find()) {
-                        commentFound = true;
-                        break;
-                    }
-                }
-            }
-            if (!commentFound) {
-                log.fine("PR is not yet ready - missing ready comment from '" + readyComment.getKey() +
-                                 "containing '" + readyComment.getValue().pattern() + "'");
-                return false;
-            }
-        }
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        return "JNotifyBot@" + repository.name();
-    }
-
-    @Override
-    public List<WorkItem> getPeriodicItems() {
-        var ret = new LinkedList<WorkItem>();
-
-        // Pull request events
-        var prs = repository.pullRequests();
-        for (var pr : prs) {
-            if (updateCache.needsUpdate(pr)) {
-                if (!isReady(pr)) {
-                    continue;
-                }
-                ret.add(new PullRequestWorkItem(pr, prIssuesStorageBuilder, prUpdaters, e -> updateCache.invalidate(pr)));
-            }
-        }
-
-        // Repository events
-        ret.add(new RepositoryWorkItem(repository, storagePath, branches, tagStorageBuilder, branchStorageBuilder, updaters));
-
-        return ret;
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBotFactory.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.bot.*;
-import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.json.*;
-import org.openjdk.skara.mailinglist.MailingListServerFactory;
-import org.openjdk.skara.network.URIBuilder;
-import org.openjdk.skara.storage.StorageBuilder;
-import org.openjdk.skara.vcs.Tag;
-
-import java.net.URI;
-import java.nio.file.Path;
-import java.time.Duration;
-import java.util.*;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-public class JNotifyBotFactory implements BotFactory {
-    private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
-
-    @Override
-    public String name() {
-        return "notify";
-    }
-
-    @Override
-    public List<Bot> create(BotConfiguration configuration) {
-        var ret = new ArrayList<Bot>();
-        var specific = configuration.specific();
-
-        var database = specific.get("database").asObject();
-        var databaseRepo = configuration.repository(database.get("repository").asString());
-        var databaseRef = configuration.repositoryRef(database.get("repository").asString());
-        var databaseName = database.get("name").asString();
-        var databaseEmail = database.get("email").asString();
-
-        var readyLabels = specific.get("ready").get("labels").stream()
-                                  .map(JSONValue::asString)
-                                  .collect(Collectors.toSet());
-        var readyComments = specific.get("ready").get("comments").stream()
-                                    .map(JSONValue::asObject)
-                                    .collect(Collectors.toMap(obj -> obj.get("user").asString(),
-                                                              obj -> Pattern.compile(obj.get("pattern").asString())));
-
-        URI reviewIcon = null;
-        if (specific.contains("reviews")) {
-            if (specific.get("reviews").contains("icon")) {
-                reviewIcon = URI.create(specific.get("reviews").get("icon").asString());
-            }
-        }
-
-        for (var repo : specific.get("repositories").fields()) {
-            var repoName = repo.name();
-            var branchPattern = Pattern.compile("^master$");
-            if (repo.value().contains("branches")) {
-                branchPattern = Pattern.compile(repo.value().get("branches").asString());
-            }
-
-            var includeBranchNames = false;
-            if (repo.value().contains("branchnames")) {
-                includeBranchNames = repo.value().get("branchnames").asBoolean();
-            }
-            var updaters = new ArrayList<RepositoryUpdateConsumer>();
-            var prUpdaters = new ArrayList<PullRequestUpdateConsumer>();
-            if (repo.value().contains("json")) {
-                var folder = repo.value().get("folder").asString();
-                var build = repo.value().get("build").asString();
-                var version = repo.value().get("version").asString();
-                updaters.add(new JsonUpdater(Path.of(folder), version, build));
-            }
-            if (repo.value().contains("mailinglists")) {
-                var email = specific.get("email").asObject();
-                var smtp = email.get("smtp").asString();
-                var sender = EmailAddress.parse(email.get("sender").asString());
-                var archive = URIBuilder.base(email.get("archive").asString()).build();
-                var interval = email.contains("interval") ? Duration.parse(email.get("interval").asString()) : Duration.ofSeconds(1);
-                var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
-
-                for (var mailinglist : repo.value().get("mailinglists").asArray()) {
-                    var recipient = mailinglist.get("recipient").asString();
-                    var recipientAddress = EmailAddress.parse(recipient);
-
-                    var mode = MailingListUpdater.Mode.ALL;
-                    if (mailinglist.contains("mode")) {
-                        switch (mailinglist.get("mode").asString()) {
-                            case "pr":
-                                mode = MailingListUpdater.Mode.PR;
-                                break;
-                            case "pr-only":
-                                mode = MailingListUpdater.Mode.PR_ONLY;
-                                break;
-                            default:
-                                throw new RuntimeException("Unknown mode");
-                        }
-                    }
-
-                    Map<String, String> headers = mailinglist.contains("headers") ?
-                            mailinglist.get("headers").fields().stream()
-                                       .collect(Collectors.toMap(JSONObject.Field::name, field -> field.value().asString())) :
-                            Map.of();
-                    var author = mailinglist.contains("author") ? EmailAddress.parse(mailinglist.get("author").asString()) : null;
-                    var allowedDomains = author == null ? Pattern.compile(mailinglist.get("domains").asString()) : null;
-                    updaters.add(new MailingListUpdater(listServer.getList(recipient), recipientAddress, sender, author,
-                                                        includeBranchNames, mode, headers, allowedDomains));
-                }
-            }
-            if (repo.value().contains("issues")) {
-                var issueProject = configuration.issueProject(repo.value().get("issues").asString());
-                var updater = new IssueUpdater(issueProject, reviewIcon);
-                updaters.add(updater);
-                prUpdaters.add(updater);
-            }
-
-            if (updaters.isEmpty()) {
-                log.warning("No consumers configured for notify bot repository: " + repoName);
-                continue;
-            }
-
-            var baseName = repo.value().contains("basename") ? repo.value().get("basename").asString() : configuration.repositoryName(repoName);
-
-            var tagStorageBuilder = new StorageBuilder<Tag>(baseName + ".tags.txt")
-                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added tag for " + repoName);
-            var branchStorageBuilder = new StorageBuilder<ResolvedBranch>(baseName + ".branches.txt")
-                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added branch hash for " + repoName);
-            var issueStorageBuilder = new StorageBuilder<PullRequestIssues>(baseName + ".prissues.txt")
-                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added pull request issue info for " + repoName);
-            var bot = new JNotifyBot(configuration.repository(repoName), configuration.storageFolder(), branchPattern,
-                                     tagStorageBuilder, branchStorageBuilder, issueStorageBuilder, updaters, prUpdaters, readyLabels, readyComments);
-            ret.add(bot);
-        }
-
-        return ret;
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.*;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.storage.*;
+import org.openjdk.skara.vcs.Tag;
+
+import java.nio.file.Path;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+
+class NotifyBot implements Bot {
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
+    private final HostedRepository repository;
+    private final Path storagePath;
+    private final Pattern branches;
+    private final StorageBuilder<Tag> tagStorageBuilder;
+    private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
+    private final StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
+    private final List<RepositoryUpdateConsumer> updaters;
+    private final List<PullRequestUpdateConsumer> prUpdaters;
+    private final PullRequestUpdateCache updateCache;
+    private final Set<String> readyLabels;
+    private final Map<String, Pattern> readyComments;
+
+    NotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder,
+              StorageBuilder<ResolvedBranch> branchStorageBuilder, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder,
+              List<RepositoryUpdateConsumer> updaters, List<PullRequestUpdateConsumer> prUpdaters,
+              Set<String> readyLabels, Map<String, Pattern> readyComments) {
+        this.repository = repository;
+        this.storagePath = storagePath;
+        this.branches = branches;
+        this.tagStorageBuilder = tagStorageBuilder;
+        this.branchStorageBuilder = branchStorageBuilder;
+        this.prIssuesStorageBuilder = prIssuesStorageBuilder;
+        this.updaters = updaters;
+        this.prUpdaters = prUpdaters;
+        this.updateCache = new PullRequestUpdateCache();
+        this.readyLabels = readyLabels;
+        this.readyComments = readyComments;
+    }
+
+    private boolean isReady(PullRequest pr) {
+        var labels = new HashSet<>(pr.labels());
+        for (var readyLabel : readyLabels) {
+            if (!labels.contains(readyLabel)) {
+                log.fine("PR is not yet ready - missing label '" + readyLabel + "'");
+                return false;
+            }
+        }
+
+        var comments = pr.comments();
+        for (var readyComment : readyComments.entrySet()) {
+            var commentFound = false;
+            for (var comment : comments) {
+                if (comment.author().userName().equals(readyComment.getKey())) {
+                    var matcher = readyComment.getValue().matcher(comment.body());
+                    if (matcher.find()) {
+                        commentFound = true;
+                        break;
+                    }
+                }
+            }
+            if (!commentFound) {
+                log.fine("PR is not yet ready - missing ready comment from '" + readyComment.getKey() +
+                                 "containing '" + readyComment.getValue().pattern() + "'");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "JNotifyBot@" + repository.name();
+    }
+
+    @Override
+    public List<WorkItem> getPeriodicItems() {
+        var ret = new LinkedList<WorkItem>();
+
+        // Pull request events
+        var prs = repository.pullRequests();
+        for (var pr : prs) {
+            if (updateCache.needsUpdate(pr)) {
+                if (!isReady(pr)) {
+                    continue;
+                }
+                ret.add(new PullRequestWorkItem(pr, prIssuesStorageBuilder, prUpdaters, e -> updateCache.invalidate(pr)));
+            }
+        }
+
+        // Repository events
+        ret.add(new RepositoryWorkItem(repository, storagePath, branches, tagStorageBuilder, branchStorageBuilder, updaters));
+
+        return ret;
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.*;
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.json.*;
+import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.network.URIBuilder;
+import org.openjdk.skara.storage.StorageBuilder;
+import org.openjdk.skara.vcs.Tag;
+
+import java.net.URI;
+import java.nio.file.Path;
+import java.time.Duration;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class NotifyBotFactory implements BotFactory {
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
+
+    @Override
+    public String name() {
+        return "notify";
+    }
+
+    @Override
+    public List<Bot> create(BotConfiguration configuration) {
+        var ret = new ArrayList<Bot>();
+        var specific = configuration.specific();
+
+        var database = specific.get("database").asObject();
+        var databaseRepo = configuration.repository(database.get("repository").asString());
+        var databaseRef = configuration.repositoryRef(database.get("repository").asString());
+        var databaseName = database.get("name").asString();
+        var databaseEmail = database.get("email").asString();
+
+        var readyLabels = specific.get("ready").get("labels").stream()
+                                  .map(JSONValue::asString)
+                                  .collect(Collectors.toSet());
+        var readyComments = specific.get("ready").get("comments").stream()
+                                    .map(JSONValue::asObject)
+                                    .collect(Collectors.toMap(obj -> obj.get("user").asString(),
+                                                              obj -> Pattern.compile(obj.get("pattern").asString())));
+
+        URI reviewIcon = null;
+        if (specific.contains("reviews")) {
+            if (specific.get("reviews").contains("icon")) {
+                reviewIcon = URI.create(specific.get("reviews").get("icon").asString());
+            }
+        }
+
+        for (var repo : specific.get("repositories").fields()) {
+            var repoName = repo.name();
+            var branchPattern = Pattern.compile("^master$");
+            if (repo.value().contains("branches")) {
+                branchPattern = Pattern.compile(repo.value().get("branches").asString());
+            }
+
+            var includeBranchNames = false;
+            if (repo.value().contains("branchnames")) {
+                includeBranchNames = repo.value().get("branchnames").asBoolean();
+            }
+            var updaters = new ArrayList<RepositoryUpdateConsumer>();
+            var prUpdaters = new ArrayList<PullRequestUpdateConsumer>();
+            if (repo.value().contains("json")) {
+                var folder = repo.value().get("folder").asString();
+                var build = repo.value().get("build").asString();
+                var version = repo.value().get("version").asString();
+                updaters.add(new JsonUpdater(Path.of(folder), version, build));
+            }
+            if (repo.value().contains("mailinglists")) {
+                var email = specific.get("email").asObject();
+                var smtp = email.get("smtp").asString();
+                var sender = EmailAddress.parse(email.get("sender").asString());
+                var archive = URIBuilder.base(email.get("archive").asString()).build();
+                var interval = email.contains("interval") ? Duration.parse(email.get("interval").asString()) : Duration.ofSeconds(1);
+                var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
+
+                for (var mailinglist : repo.value().get("mailinglists").asArray()) {
+                    var recipient = mailinglist.get("recipient").asString();
+                    var recipientAddress = EmailAddress.parse(recipient);
+
+                    var mode = MailingListUpdater.Mode.ALL;
+                    if (mailinglist.contains("mode")) {
+                        switch (mailinglist.get("mode").asString()) {
+                            case "pr":
+                                mode = MailingListUpdater.Mode.PR;
+                                break;
+                            case "pr-only":
+                                mode = MailingListUpdater.Mode.PR_ONLY;
+                                break;
+                            default:
+                                throw new RuntimeException("Unknown mode");
+                        }
+                    }
+
+                    Map<String, String> headers = mailinglist.contains("headers") ?
+                            mailinglist.get("headers").fields().stream()
+                                       .collect(Collectors.toMap(JSONObject.Field::name, field -> field.value().asString())) :
+                            Map.of();
+                    var author = mailinglist.contains("author") ? EmailAddress.parse(mailinglist.get("author").asString()) : null;
+                    var allowedDomains = author == null ? Pattern.compile(mailinglist.get("domains").asString()) : null;
+                    updaters.add(new MailingListUpdater(listServer.getList(recipient), recipientAddress, sender, author,
+                                                        includeBranchNames, mode, headers, allowedDomains));
+                }
+            }
+            if (repo.value().contains("issues")) {
+                var issueProject = configuration.issueProject(repo.value().get("issues").asString());
+                var updater = new IssueUpdater(issueProject, reviewIcon);
+                updaters.add(updater);
+                prUpdaters.add(updater);
+            }
+
+            if (updaters.isEmpty()) {
+                log.warning("No consumers configured for notify bot repository: " + repoName);
+                continue;
+            }
+
+            var baseName = repo.value().contains("basename") ? repo.value().get("basename").asString() : configuration.repositoryName(repoName);
+
+            var tagStorageBuilder = new StorageBuilder<Tag>(baseName + ".tags.txt")
+                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added tag for " + repoName);
+            var branchStorageBuilder = new StorageBuilder<ResolvedBranch>(baseName + ".branches.txt")
+                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added branch hash for " + repoName);
+            var issueStorageBuilder = new StorageBuilder<PullRequestIssues>(baseName + ".prissues.txt")
+                    .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added pull request issue info for " + repoName);
+            var bot = new NotifyBot(configuration.repository(repoName), configuration.storageFolder(), branchPattern,
+                                    tagStorageBuilder, branchStorageBuilder, issueStorageBuilder, updaters, prUpdaters, readyLabels, readyComments);
+            ret.add(bot);
+        }
+
+        return ret;
+    }
+}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
@@ -82,12 +82,12 @@
             var jsonFolder = tempFolder.path().resolve("json");
             Files.createDirectory(jsonFolder);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             TestBotRunner.runPeriodicItems(notifyBot);
             assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
 
             var editHash = CheckableRepository.appendAndCommit(localRepo, "One more line", "12345678: Fixes");
@@ -123,12 +123,12 @@
             var jsonFolder = tempFolder.path().resolve("json");
             Files.createDirectory(jsonFolder);
             var storageFolder =tempFolder.path().resolve("storage");
 
             var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             TestBotRunner.runPeriodicItems(notifyBot);
             assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
 
             var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
@@ -196,12 +196,12 @@
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"), Pattern.compile("none"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -249,12 +249,12 @@
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -304,12 +304,12 @@
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -356,12 +356,12 @@
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var author = EmailAddress.from("author", "author@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, author, true,
                                                  MailingListUpdater.Mode.ALL, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|another"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master|another"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -432,12 +432,12 @@
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var author = EmailAddress.from("author", "author@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, author, false,
                                                  MailingListUpdater.Mode.PR_ONLY, Map.of("extra1", "value1"),
                                                  Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -511,12 +511,12 @@
             var storageFolder = tempFolder.path().resolve("storage");
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                  MailingListUpdater.Mode.PR, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -603,12 +603,12 @@
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"),
                                                  Pattern.compile(".*"));
             var prOnlyUpdater = new MailingListUpdater(mailmanList, listAddress, sender, null, false,
                                                        MailingListUpdater.Mode.PR_ONLY, Map.of(), Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater, prOnlyUpdater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater, prOnlyUpdater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -700,12 +700,12 @@
 
             var sender = EmailAddress.from("duke", "duke@duke.duke");
             var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
                                                  Map.of("extra1", "value1", "extra2", "value2"),
                                                  Pattern.compile(".*"));
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|newbranch."), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master|newbranch."), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // No mail should be sent on the first run as there is no history
             TestBotRunner.runPeriodicItems(notifyBot);
             assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
 
@@ -761,12 +761,12 @@
             var prIssuesStorage = createPullRequestIssuesStorage(repo);
             var storageFolder = tempFolder.path().resolve("storage");
 
             var issueProject = credentials.getIssueProject();
             var updater = new IssueUpdater(issueProject, null);
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(updater), List.of(), Set.of(), Map.of());
 
             // Initialize history
             TestBotRunner.runPeriodicItems(notifyBot);
 
             // Create an issue and commit a fix
@@ -803,13 +803,13 @@
             var storageFolder = tempFolder.path().resolve("storage");
 
             var issueProject = credentials.getIssueProject();
             var reviewIcon = URI.create("http://www.example.com/review.png");
             var updater = new IssueUpdater(issueProject, reviewIcon);
-            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
-                                           prIssuesStorage, List.of(), List.of(updater), Set.of("rfr"),
-                                           Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")));
+            var notifyBot = new NotifyBot(repo, storageFolder, Pattern.compile("master"), tagStorage, branchStorage,
+                                          prIssuesStorage, List.of(), List.of(updater), Set.of("rfr"),
+                                          Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")));
 
             // Initialize history
             TestBotRunner.runPeriodicItems(notifyBot);
 
             // Create an issue and a pull request to fix it
