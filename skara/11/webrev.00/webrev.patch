diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -177,10 +177,43 @@
                 quoteBody(parentBody) +
                 "\n\n" +
                 filterComments(body);
     }
 
+    private String verdictToString(Review.Verdict verdict) {
+        switch (verdict) {
+            case APPROVED:
+                return "changes are approved";
+            case DISAPPROVED:
+                return "more changes are needed";
+            case NONE:
+                return "a comment has been added";
+            default:
+                throw new RuntimeException("Unknown verdict: " + verdict);
+        }
+    }
+
+    private String composeReview(ZonedDateTime date, EmailAddress parentAuthor, String parentBody, Review review) {
+        var body = new StringBuilder();
+        var author = getAuthorAddress(review.reviewer());
+        body.append("This PR has been reviewed by ");
+        body.append(author.fullName().orElse(author.localPart()));
+        body.append(" - ");
+        body.append(verdictToString(review.verdict()));
+        body.append(".");
+        if (review.body().isPresent()) {
+            body.append(" Review comment:\n\n");
+            body.append(review.body().get());
+        }
+
+        return "On " + date.format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + parentAuthor.toString() + " wrote:\n" +
+                "\n" +
+                quoteBody(parentBody) +
+                "\n\n" +
+                filterComments(body.toString());
+    }
+
     private String composeRebaseComment(Hash lastBase, PullRequestInstance prInstance, URI fullWebrev) {
         var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), this::formatCommit);
         return "The pull request has been updated with a complete new set of changes (possibly due to a rebase).\n\n" +
                 infoSeparator + "\n\n" +
                 "Commits:\n" +
@@ -215,45 +248,10 @@
     private String composeReadyForIntegrationComment() {
         return "This PR now fulfills all the requirements for integration, and is only awaiting the final " +
                 "integration command from the author.";
     }
 
-    private String verdictToString(Review.Verdict verdict) {
-        switch (verdict) {
-            case APPROVED:
-                return "changes are approved";
-            case DISAPPROVED:
-                return "more changes needed";
-            case NONE:
-                return "comment added";
-            default:
-                throw new RuntimeException("Unknown verdict: " + verdict);
-        }
-    }
-
-    private String composeNewReviewVerdict(Review review) {
-        var ret = new StringBuilder();
-        var author = getAuthorAddress(review.reviewer);
-        ret.append("This PR has now been reviewed by ");
-        ret.append(author.fullName().orElse(author.localPart()));
-        ret.append(" - ");
-        ret.append(verdictToString(review.verdict));
-        ret.append(".");
-        return ret.toString();
-    }
-
-    private String composeUpdatedReviewVerdict(Review review) {
-        var ret = new StringBuilder();
-        var author = getAuthorAddress(review.reviewer);
-        ret.append("The PR reviewed by ");
-        ret.append(author.fullName().orElse(author.localPart()));
-        ret.append(" has now been updated - ");
-        ret.append(verdictToString(review.verdict));
-        ret.append(".");
-        return ret.toString();
-    }
-
     private Repository materializeArchive(Path scratchPath) {
         try {
             return Repository.materialize(scratchPath, bot.archiveRepo().getUrl(), pr.getTargetRef());
         } catch (IOException e) {
             throw new UncheckedIOException(e);
@@ -312,12 +310,12 @@
 
     private EmailAddress getMessageId(String raw) {
         return getUniqueMessageId("rw" + raw);
     }
 
-    private EmailAddress getMessageId(HostUserDetails reviewer, String verdict, int reviewCount) {
-        return getUniqueMessageId("vd" + reviewer.id() + ";" + verdict + ";" + reviewCount);
+    private EmailAddress getMessageId(Review review) {
+        return getUniqueMessageId("rv" + review.id());
     }
 
     private EmailAddress getAuthorAddress(HostUserDetails originalAuthor) {
         return EmailAddress.from(originalAuthor.fullName() + " via " + pr.repository().getUrl().getHost(),
                                  bot.emailAddress().address());
@@ -350,10 +348,23 @@
                          .header("References", references)
                          .build();
         return email;
     }
 
+    private Email review(Email parent, Review review) {
+        var body = composeReview(parent.date(), parent.author(), parent.body(), review);
+        var email = Email.create(getAuthorAddress(review.reviewer()), "Re: RFR: " + pr.getTitle(), body)
+                         .sender(bot.emailAddress())
+                         .recipient(parent.author())
+                         .id(getMessageId(review))
+                         .header("In-Reply-To", parent.id().toString())
+                         .header("References", parent.id().toString())
+                         .build();
+        return email;
+
+    }
+
     private Email reviewComment(Email parent, ReviewComment comment) {
         var body = new StringBuilder();
 
         // Add some context to the first post
         if (comment.parent().isEmpty()) {
@@ -422,54 +433,10 @@
                          .header("PR-Labels", String.join(";", currentLabels))
                          .build();
         return email;
     }
 
-    private Email reviewVerdictComment(Email parent, HostUserDetails reviewer, String verdict, int reviewCount, String body) {
-        var email = Email.create(getAuthorAddress(reviewer), "Re: RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(reviewer, verdict, reviewCount))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", parent.id().toString())
-                         .header("PR-Review-Verdict", reviewer.id() + ";" + verdict)
-                         .build();
-        return email;
-
-    }
-
-    private List<Email> getReviewVerdictMails(Email parent, List<Email> archiveMails) {
-        // Determine the latest reported reviews
-        var ret = new ArrayList<Email>();
-        var reportedReviews = archiveMails.stream()
-                                          .filter(email -> email.hasHeader("PR-Review-Verdict"))
-                                          .map(email -> email.headerValue("PR-Review-Verdict"))
-                                          .collect(Collectors.toMap(
-                                                  value -> value.substring(0, value.indexOf(";")),
-                                                  value -> value.substring(value.indexOf(";") + 1),
-                                                  (a, b) -> b)
-                                          );
-        var reviews = pr.getReviews();
-        var newReviews = reviews.stream()
-                                .filter(review -> !reportedReviews.containsKey(review.reviewer.id()))
-                                .collect(Collectors.toList());
-        var updatedReviews = reviews.stream()
-                                    .filter(review -> reportedReviews.containsKey(review.reviewer.id()))
-                                    .filter(review -> !reportedReviews.get(review.reviewer.id()).equals(review.verdict.toString()))
-                                    .collect(Collectors.toList());
-
-        for (var newReview : newReviews) {
-            var body = composeNewReviewVerdict(newReview);
-            ret.add(reviewVerdictComment(parent, newReview.reviewer, newReview.verdict.toString(), reportedReviews.size(), body));
-        }
-        for (var updatedReview : updatedReviews) {
-            var body = composeUpdatedReviewVerdict(updatedReview);
-            ret.add(reviewVerdictComment(parent, updatedReview.reviewer, updatedReview.verdict.toString(), reportedReviews.size(), body));
-        }
-        return ret;
-    }
-
     private List<Email> parseArchive(MailingList archive) {
         var conversations = archive.conversations(Duration.ofDays(365));
 
         if (conversations.size() == 0) {
             return new ArrayList<>();
@@ -670,11 +637,30 @@
             newMails.add(commentMail);
             stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
             previous = commentMail;
         }
 
-        // File specific comments
+        // Review comments
         final var first = archiveMails.size() > 0 ? archiveMails.get(0) : newMails.get(0);
+        var reviews = pr.getReviews();
+        for (var review : reviews) {
+            var id = getStableMessageId(getMessageId(review));
+            if (stableIdToMail.containsKey(id)) {
+                continue;
+            }
+            if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
+                continue;
+            }
+
+            var commentMail = review(first, review);
+            archive.post(commentMail);
+            newMails.add(commentMail);
+            stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
+        }
+
+
+        // File specific comments
         var reviewComments = pr.getReviewComments();
         for (var reviewComment : reviewComments) {
             var id = getStableMessageId(getMessageId(reviewComment));
             if (stableIdToMail.containsKey(id)) {
                 continue;
@@ -689,18 +674,10 @@
             archive.post(commentMail);
             newMails.add(commentMail);
             stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
         }
 
-        // Review verdicts
-        var reviewVerdictMails = getReviewVerdictMails(first, archiveMails);
-        for (var reviewVerdictMail : reviewVerdictMails) {
-            archive.post(reviewVerdictMail);
-            newMails.add(reviewVerdictMail);
-            stableIdToMail.put(getStableMessageId(reviewVerdictMail.id()), reviewVerdictMail);
-        }
-
         if (newMails.isEmpty()) {
             return;
         }
 
         // Push all new mails to the archive repository
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -495,10 +495,20 @@
             listServer.processIncoming();
 
             var nextHash = CheckableRepository.appendAndCommit(localRepo, "Yet one more line", "Fixing");
             localRepo.push(nextHash, author.getUrl(), "edit");
 
+            // Make sure that the push registered
+            var lastHeadHash = pr.getHeadHash();
+            var refreshCount = 0;
+            do {
+                pr = author.getPullRequest(pr.getId());
+                if (refreshCount++ > 100) {
+                    fail("The PR did not update after the new push");
+                }
+            } while (pr.getHeadHash().equals(lastHeadHash));
+
             // Run another archive pass
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
@@ -534,10 +544,21 @@
 
             // Ensure that additional updates are only reported once
             for (int i = 0; i < 3; ++i) {
                 var anotherHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fixing");
                 localRepo.push(anotherHash, author.getUrl(), "edit");
+
+                // Make sure that the push registered
+                lastHeadHash = pr.getHeadHash();
+                refreshCount = 0;
+                do {
+                    pr = author.getPullRequest(pr.getId());
+                    if (refreshCount++ > 100) {
+                        fail("The PR did not update after the new push");
+                    }
+                } while (pr.getHeadHash().equals(lastHeadHash));
+
                 TestBotRunner.runPeriodicItems(mlBot);
                 TestBotRunner.runPeriodicItems(mlBot);
                 listServer.processIncoming();
             }
             var updatedConversations = mailmanList.conversations(Duration.ofDays(1));
@@ -584,10 +605,20 @@
 
             var newLocalRepo = Repository.materialize(tempFolder.path().resolve("second"), author.getUrl(), "master");
             var newEditHash = CheckableRepository.appendAndCommit(newLocalRepo, "Another line", "Replaced msg");
             newLocalRepo.push(newEditHash, author.getUrl(), "edit", true);
 
+            // Make sure that the push registered
+            var lastHeadHash = pr.getHeadHash();
+            var refreshCount = 0;
+            do {
+                pr = author.getPullRequest(pr.getId());
+                if (refreshCount++ > 100) {
+                    fail("The PR did not update after the new push");
+                }
+            } while (pr.getHeadHash().equals(lastHeadHash));
+
             // Run another archive pass
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the rebased push
@@ -723,11 +754,12 @@
 
             // Run an archive pass
             TestBotRunner.runPeriodicItems(mlBot);
 
             // First unapprove it
-            pr.addReview(Review.Verdict.DISAPPROVED);
+            var reviewedPr = credentials.getHostedRepository().getPullRequest(pr.getId());
+            reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 1");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain a note
@@ -730,14 +762,15 @@
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain a note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR has now been reviewed.*more changes needed"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR has been reviewed.*more changes are needed"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 1"));
 
             // Then approve it
-            pr.addReview(Review.Verdict.APPROVED);
+            reviewedPr.addReview(Review.Verdict.APPROVED, "Reason 2");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
@@ -740,14 +773,15 @@
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "The PR reviewed by.*has now been updated.*approved"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR.*approved"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 2"));
 
             // Yet another change
-            pr.addReview(Review.Verdict.DISAPPROVED);
+            reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 3");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
@@ -750,9 +785,10 @@
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "The PR reviewed by.*has now been updated.*more changes"));
+            assertEquals(2, archiveContainsCount(archiveFolder.path(), "This PR.*more changes"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 3"));
         }
     }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -36,11 +36,12 @@
 class CheckRun {
     private final CheckWorkItem workItem;
     private final PullRequest pr;
     private final PullRequestInstance prInstance;
     private final List<Comment> comments;
-    private final List<Review> reviews;
+    private final List<Review> allReviews;
+    private final List<Review> activeReviews;
     private final Set<String> labels;
     private final CensusInstance censusInstance;
     private final Map<String, String> blockingLabels;
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
@@ -48,16 +49,18 @@
     private final String mergeReadyMarker = "<!-- PullRequestBot merge is ready comment -->";
     private final Pattern mergeSourcePattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+$)");
     private final Set<String> newLabels;
 
     private CheckRun(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
-                     List<Review> reviews, Set<String> labels, CensusInstance censusInstance, Map<String, String> blockingLabels) {
+                     List<Review> allReviews, List<Review> activeReviews, Set<String> labels,
+                     CensusInstance censusInstance, Map<String, String> blockingLabels) {
         this.workItem = workItem;
         this.pr = pr;
         this.prInstance = prInstance;
         this.comments = comments;
-        this.reviews = reviews;
+        this.allReviews = allReviews;
+        this.activeReviews = activeReviews;
         this.labels = new HashSet<>(labels);
         this.newLabels = new HashSet<>(labels);
         this.censusInstance = censusInstance;
         this.blockingLabels = blockingLabels;
     }
@@ -61,12 +64,12 @@
         this.censusInstance = censusInstance;
         this.blockingLabels = blockingLabels;
     }
 
     static void execute(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
-                        List<Review> reviews, Set<String> labels, CensusInstance censusInstance, Map<String, String> blockingLabels) {
-        var run = new CheckRun(workItem, pr, prInstance, comments, reviews, labels, censusInstance, blockingLabels);
+                        List<Review> allReviews, List<Review> activeReviews, Set<String> labels, CensusInstance censusInstance, Map<String, String> blockingLabels) {
+        var run = new CheckRun(workItem, pr, prInstance, comments, allReviews, activeReviews, labels, censusInstance, blockingLabels);
         run.checkStatus();
     }
 
     // For unknown contributors, check that all commits have the same name and email
     private boolean checkCommitAuthor(List<Commit> commits) throws IOException {
@@ -242,15 +245,15 @@
                       .collect(Collectors.joining("\n"));
     }
 
     private Optional<String> getReviewersList(List<Review> reviews) {
         var reviewers = reviews.stream()
-                               .filter(review -> review.verdict == Review.Verdict.APPROVED)
+                               .filter(review -> review.verdict() == Review.Verdict.APPROVED)
                                .map(review -> {
-                                   var entry = " * " + formatReviewer( review.reviewer);
-                                   if (!review.hash.equals(pr.getHeadHash())) {
-                                       entry += " **Note!** Review applies to " + review.hash;
+                                   var entry = " * " + formatReviewer(review.reviewer());
+                                   if (!review.hash().equals(pr.getHeadHash())) {
+                                       entry += " **Note!** Review applies to " + review.hash();
                                    }
                                    return entry;
                                })
                                .collect(Collectors.joining("\n"));
         if (reviewers.length() > 0) {
@@ -309,19 +312,19 @@
         var reviewTracker = new ReviewTracker(comments, reviews);
 
         for (var added : reviewTracker.newReviews().entrySet()) {
             var body = added.getValue() + "\n" +
                     "This PR has been reviewed by " +
-                    formatReviewer(added.getKey().reviewer) + " - " +
-                    verdictToString(added.getKey().verdict) + ".";
+                    formatReviewer(added.getKey().reviewer()) + " - " +
+                    verdictToString(added.getKey().verdict()) + ".";
             pr.addComment(body);
         }
 
         for (var updated : reviewTracker.updatedReviews().entrySet()) {
             var body = updated.getValue() + "\n" +
-                    "The PR review by " + formatReviewer(updated.getKey().reviewer) +
-                    " has been updated - " + verdictToString(updated.getKey().verdict) + ".";
+                    "The PR review by " + formatReviewer(updated.getKey().reviewer()) +
+                    " has been updated - " + verdictToString(updated.getKey().verdict()) + ".";
             pr.addComment(body);
         }
 
         for (var removed : reviewTracker.removedReviews().entrySet()) {
             var user = pr.repository().host().getUserDetails(removed.getKey());
@@ -394,12 +397,12 @@
             }
 
             message.append("an existing [Committer](http://openjdk.java.net/bylaws#committer) must agree to ");
             message.append("[sponsor](http://openjdk.java.net/sponsor/) your change. ");
             var candidates = reviews.stream()
-                                    .filter(review -> ProjectPermissions.mayCommit(censusInstance, review.reviewer))
-                                    .map(review -> "@" + review.reviewer.userName())
+                                    .filter(review -> ProjectPermissions.mayCommit(censusInstance, review.reviewer()))
+                                    .map(review -> "@" + review.reviewer().userName())
                                     .collect(Collectors.joining(", "));
             if (candidates.length() > 0) {
                 message.append("Possible candidates are the reviewers of this PR (");
                 message.append(candidates);
                 message.append(") but any other Committer may sponsor as well. ");
@@ -461,20 +464,20 @@
             updateCheckBuilder(checkBuilder, visitor, additionalErrors);
             updateReadyForReview(visitor, additionalErrors);
             var rebasePossible = prInstance.rebasePossible(localHash);
 
             // Calculate and update the status message if needed
-            var statusMessage = getStatusMessage(reviews, visitor);
+            var statusMessage = getStatusMessage(activeReviews, visitor);
             var updatedBody = updateStatusMessage(statusMessage);
 
             // Post / update approval messages
-            updateReviewedMessages(comments, reviews);
+            updateReviewedMessages(comments, allReviews);
 
             var commit = prInstance.localRepo().lookup(localHash).orElseThrow();
             var commitMessage = String.join("\n", commit.message());
             updateMergeReadyComment(checkBuilder.build().status() == CheckStatus.SUCCESS, commitMessage,
-                                    comments, reviews, rebasePossible);
+                                    comments, activeReviews, rebasePossible);
             if (checkBuilder.build().status() == CheckStatus.SUCCESS) {
                 newLabels.add("ready");
             } else {
                 newLabels.remove("ready");
             }
@@ -483,16 +486,16 @@
             } else {
                 newLabels.remove("outdated");
             }
 
             // Calculate current metadata to avoid unnecessary future checks
-            var metadata = workItem.getMetadata(pr.getTitle(), updatedBody, pr.getComments(), reviews, newLabels, censusInstance, pr.getTargetHash());
+            var metadata = workItem.getMetadata(pr.getTitle(), updatedBody, pr.getComments(), activeReviews, newLabels, censusInstance, pr.getTargetHash());
             checkBuilder.metadata(metadata);
         } catch (Exception e) {
             log.throwing("CommitChecker", "checkStatus", e);
             newLabels.remove("ready");
-            var metadata = workItem.getMetadata(pr.getTitle(), pr.getBody(), pr.getComments(), reviews, newLabels, censusInstance, pr.getTargetHash());
+            var metadata = workItem.getMetadata(pr.getTitle(), pr.getBody(), pr.getComments(), activeReviews, newLabels, censusInstance, pr.getTargetHash());
             checkBuilder.metadata(metadata);
             checkBuilder.title("Exception occurred during jcheck");
             checkBuilder.summary(e.getMessage());
             checkBuilder.complete(false);
         }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
@@ -70,12 +70,12 @@
 
     String getMetadata(String title, String body, List<Comment> comments, List<Review> reviews, Set<String> labels,
                        CensusInstance censusInstance, Hash target) {
         try {
             var approverString = reviews.stream()
-                                        .filter(review -> review.verdict == Review.Verdict.APPROVED)
-                                        .map(review -> encodeReviewer(review.reviewer, censusInstance) + review.hash.hex())
+                                        .filter(review -> review.verdict() == Review.Verdict.APPROVED)
+                                        .map(review -> encodeReviewer(review.reviewer(), censusInstance) + review.hash().hex())
                                         .sorted()
                                         .collect(Collectors.joining());
             var commentString = comments.stream()
                                         .filter(comment -> comment.author().id().equals(pr.repository().host().getCurrentUserDetails().id()))
                                         .flatMap(comment -> comment.body().lines())
@@ -154,17 +154,19 @@
     @Override
     public void run(Path scratchPath) {
         // First determine if the current state of the PR has already been checked
         var census = CensusInstance.create(censusRepo, censusRef, scratchPath.resolve("census"), pr);
         var comments = pr.getComments();
-        var reviews = pr.getReviews();
-        var labels = new HashSet(pr.getLabels());
+        var allReviews = pr.getReviews();
+        var labels = new HashSet<>(pr.getLabels());
 
-        if (!currentCheckValid(census, comments, reviews, labels)) {
+        // Filter out the active reviews
+        var activeReviews = PullRequestInstance.filterActiveReviews(allReviews);
+        if (!currentCheckValid(census, comments, activeReviews, labels)) {
             try {
                 var prInstance = new PullRequestInstance(scratchPath.resolve("pr"), pr);
-                CheckRun.execute(this, pr, prInstance, comments, reviews, labels, census, blockingLabels);
+                CheckRun.execute(this, pr, prInstance, comments, allReviews, activeReviews, labels, census, blockingLabels);
             } catch (IOException e) {
                 throw new UncheckedIOException(e);
             }
         }
     }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
@@ -48,14 +48,28 @@
         targetHash = localRepo.fetch(repository.getUrl(), pr.getTargetRef());
         headHash = localRepo.fetch(repository.getUrl(), pr.getHeadHash().hex());
         baseHash = localRepo.mergeBase(targetHash, headHash);
     }
 
-    private String commitMessage(Namespace namespace, boolean isMerge) throws IOException {
-        var reviewers = pr.getReviews().stream()
-                          .filter(review -> review.verdict == Review.Verdict.APPROVED)
-                          .map(review -> review.reviewer.id())
+    /**
+     * The Review list is in chronological order, the latest one from a particular reviewer is the
+     * one that is "active".
+     * @param allReviews
+     * @return
+     */
+    static List<Review> filterActiveReviews(List<Review> allReviews) {
+        var reviewPerUser = new LinkedHashMap<HostUserDetails, Review>();
+        for (var review : allReviews) {
+            reviewPerUser.put(review.reviewer(), review);
+        }
+        return new ArrayList<>(reviewPerUser.values());
+    }
+
+    private String commitMessage(List<Review> activeReviews, Namespace namespace, boolean isMerge) throws IOException {
+        var reviewers = activeReviews.stream()
+                          .filter(review -> review.verdict() == Review.Verdict.APPROVED)
+                          .map(review -> review.reviewer().id())
                           .map(namespace::get)
                           .filter(Objects::nonNull)
                           .map(Contributor::username)
                           .collect(Collectors.toList());
 
@@ -68,11 +82,11 @@
                                          .contributors(additionalContributors)
                                          .reviewers(reviewers);
         return String.join("\n", commitMessage.format(CommitMessageFormatters.v1));
     }
 
-    private Hash commitSquashed(Namespace namespace, String censusDomain, String sponsorId) throws IOException {
+    private Hash commitSquashed(List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException {
         localRepo.checkout(baseHash, true);
         localRepo.squash(headHash);
 
         Author committer;
         Author author;
@@ -91,15 +105,15 @@
             committer = new Author(sponsorContributor.fullName().orElseThrow(), sponsorContributor.username() + "@" + censusDomain);
         } else {
             committer = author;
         }
 
-        var commitMessage = commitMessage(namespace, false);
+        var commitMessage = commitMessage(activeReviews, namespace, false);
         return localRepo.commit(commitMessage, author.name(), author.email(), committer.name(), committer.email());
     }
 
-    private Hash commitMerge(Namespace namespace, String censusDomain) throws IOException {
+    private Hash commitMerge(List<Review> activeReviews, Namespace namespace, String censusDomain) throws IOException {
         localRepo.checkout(headHash, true);
 
         var contributor = namespace.get(pr.getAuthor().id());
         if (contributor == null) {
             throw new RuntimeException("Merges can only be performed by Committers");
@@ -105,19 +119,20 @@
             throw new RuntimeException("Merges can only be performed by Committers");
         }
 
         var author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
 
-        var commitMessage = commitMessage(namespace, true);
+        var commitMessage = commitMessage(activeReviews, namespace, true);
         return localRepo.amend(commitMessage, author.name(), author.email(), author.name(), author.email());
     }
 
     Hash commit(Namespace namespace, String censusDomain, String sponsorId) throws IOException {
+        var activeReviews = filterActiveReviews(pr.getReviews());
         if (!pr.getTitle().startsWith("Merge")) {
-            return commitSquashed(namespace, censusDomain, sponsorId);
+            return commitSquashed(activeReviews, namespace, censusDomain, sponsorId);
         } else {
-            return commitMerge(namespace, censusDomain);
+            return commitMerge(activeReviews, namespace, censusDomain);
         }
     }
 
     List<Commit> divergingCommits() {
         try {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewTracker.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewTracker.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewTracker.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewTracker.java
@@ -70,18 +70,18 @@
         }
 
         // Find all reviews without a comment
         for (var review : reviews) {
             // Not notified yet
-            if (!reviewStates.containsKey(review.reviewer.id())) {
-                newComments.put(review, String.format(reviewMarker, review.verdict.ordinal(), review.reviewer.id(), review.reviewer.userName(), review.hash.hex()));
+            if (!reviewStates.containsKey(review.reviewer().id())) {
+                newComments.put(review, String.format(reviewMarker, review.verdict().ordinal(), review.reviewer().id(), review.reviewer().userName(), review.hash().hex()));
             } else {
-                var oldReview = reviewStates.get(review.reviewer.id());
-                if (review.verdict.ordinal() != oldReview.verdict) {
-                    updatedReviews.put(review, String.format(reviewMarker, review.verdict.ordinal(), review.reviewer.id(), review.reviewer.userName(), review.hash.hex()));
+                var oldReview = reviewStates.get(review.reviewer().id());
+                if (review.verdict().ordinal() != oldReview.verdict) {
+                    updatedReviews.put(review, String.format(reviewMarker, review.verdict().ordinal(), review.reviewer().id(), review.reviewer().userName(), review.hash().hex()));
                 }
-                reviewStates.remove(review.reviewer.id());
+                reviewStates.remove(review.reviewer().id());
             }
         }
 
         // Check if there are any states not covered by reviews - these must have been removed
         for (var reviewState : reviewStates.values()) {
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
@@ -69,11 +69,11 @@
             assertTrue(pr.getLabels().contains("rfr"));
             assertFalse(pr.getLabels().contains("ready"));
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Check the status again
             TestBotRunner.runPeriodicItems(checkBot);
 
             // The check should now be successful
@@ -117,11 +117,11 @@
             // The PR should not be flagged as ready for review
             assertFalse(pr.getLabels().contains("rfr"));
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Check the status
             TestBotRunner.runPeriodicItems(checkBot);
 
             // Verify that the check failed
@@ -191,11 +191,11 @@
             TestBotRunner.runPeriodicItems(checkBot);
             assertFalse(authorPr.getBody().contains("Approvers"));
 
             // Approve it
             var reviewerPr = reviewer.getPullRequest(authorPr.getId());
-            reviewerPr.addReview(Review.Verdict.APPROVED);
+            reviewerPr.addReview(Review.Verdict.APPROVED, "Approved");
             TestBotRunner.runPeriodicItems(checkBot);
 
             // Refresh the PR and check that it has been approved
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Approvers"));
@@ -218,11 +218,11 @@
             TestBotRunner.runPeriodicItems(checkBot);
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Note"));
 
             // Now we can approve it again
-            reviewerPr.addReview(Review.Verdict.APPROVED);
+            reviewerPr.addReview(Review.Verdict.APPROVED, "Approved");
             TestBotRunner.runPeriodicItems(checkBot);
 
             // Refresh the PR and check that it has been approved (once) and is no longer stale
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Approvers"));
@@ -225,16 +225,16 @@
 
             // Refresh the PR and check that it has been approved (once) and is no longer stale
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Approvers"));
             assertEquals(1, authorPr.getBody().split("Generated Reviewer", -1).length - 1);
-            assertEquals(1, authorPr.getReviews().size());
+            assertEquals(2, authorPr.getReviews().size());
             assertFalse(authorPr.getBody().contains("Note"));
 
             // Add a review with disapproval
             var commenterPr = commenter.getPullRequest(authorPr.getId());
-            commenterPr.addReview(Review.Verdict.DISAPPROVED);
+            commenterPr.addReview(Review.Verdict.DISAPPROVED, "Disapproved");
             TestBotRunner.runPeriodicItems(checkBot);
 
             // Refresh the PR and check that it still only approved once (but two reviews) and is no longer stale
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Approvers"));
@@ -237,11 +237,11 @@
 
             // Refresh the PR and check that it still only approved once (but two reviews) and is no longer stale
             authorPr = author.getPullRequest(authorPr.getId());
             assertTrue(authorPr.getBody().contains("Approvers"));
             assertEquals(1, authorPr.getBody().split("Generated Reviewer", -1).length - 1);
-            assertEquals(2, authorPr.getReviews().size());
+            assertEquals(3, authorPr.getReviews().size());
             assertFalse(authorPr.getBody().contains("Note"));
         }
     }
 
     @Test
@@ -277,11 +277,11 @@
             var check = checks.get("jcheck");
             assertEquals(CheckStatus.FAILURE, check.status());
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Check the status again
             TestBotRunner.runPeriodicItems(checkBot);
 
             // The check should still be failing
@@ -330,11 +330,11 @@
             assertTrue(pr.getLabels().contains("rfr"));
             assertFalse(pr.getLabels().contains("ready"));
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Check the status again
             TestBotRunner.runPeriodicItems(checkBot);
 
             // The check should now be successful
@@ -394,11 +394,11 @@
             // Check the status
             TestBotRunner.runPeriodicItems(checkBot);
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Check the status again
             TestBotRunner.runPeriodicItems(checkBot);
 
             // There should now be a comment
@@ -407,11 +407,11 @@
             var comment = comments.get(0);
             assertTrue(comment.body().contains(reviewer.host().getCurrentUserDetails().userName()));
             assertTrue(comment.body().contains("approved"));
 
             // Drop the review
-            approvalPr.addReview(Review.Verdict.NONE);
+            approvalPr.addReview(Review.Verdict.NONE, "Unreviewed");
 
             // Check the status again
             TestBotRunner.runPeriodicItems(checkBot);
 
             // There should now be yet another comment
@@ -452,11 +452,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Get all messages up to date
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push something unrelated to master
@@ -503,11 +503,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Get all messages up to date
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push something conflicting to master
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/ContributorTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/ContributorTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/ContributorTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/ContributorTests.java
@@ -90,11 +90,11 @@
             pr.addComment("/contributor add Test Person <test@test.test>");
             TestBotRunner.runPeriodicItems(prBot);
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
             TestBotRunner.runPeriodicItems(prBot);
             TestBotRunner.runPeriodicItems(prBot);
 
             // The commit message preview should contain the contributor
             var creditLine = pr.getComments().stream()
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
@@ -58,11 +58,11 @@
             localRepo.push(editHash, author.getUrl(), "refs/heads/edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Attempt a merge (the bot should only process the first one)
             pr.addComment("/integrate");
             pr.addComment("/integrate");
             pr.addComment("/integrate");
@@ -116,12 +116,12 @@
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Review it twice
             var integratorPr = integrator.getPullRequest(pr.getId());
             var committerPr = committer.getPullRequest(pr.getId());
-            integratorPr.addReview(Review.Verdict.APPROVED);
-            committerPr.addReview(Review.Verdict.APPROVED);
+            integratorPr.addReview(Review.Verdict.APPROVED, "Approved");
+            committerPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Attempt a merge
             pr.addComment("/integrate");
             TestBotRunner.runPeriodicItems(mergeBot);
 
@@ -280,11 +280,11 @@
             localRepo.push(editHash, author.getUrl(), "refs/heads/edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot see it (a few times)
             TestBotRunner.runPeriodicItems(mergeBot);
             TestBotRunner.runPeriodicItems(mergeBot);
             TestBotRunner.runPeriodicItems(mergeBot);
@@ -301,11 +301,11 @@
                           .filter(comment -> comment.body().contains("Only the author"))
                           .count();
             assertEquals(0, error);
 
             // Drop the approval
-            approvalPr.addReview(Review.Verdict.DISAPPROVED);
+            approvalPr.addReview(Review.Verdict.DISAPPROVED, "Disapproved");
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // The instructional message should have been updated
             pushed = pr.getComments().stream()
                        .filter(comment -> comment.body().contains("no longer ready for integration"))
@@ -311,11 +311,11 @@
                        .filter(comment -> comment.body().contains("no longer ready for integration"))
                        .count();
             assertEquals(1, pushed);
 
             // Restore the approval
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // The instructional message should have been updated
             pushed = pr.getComments().stream()
                            .filter(comment -> comment.body().contains("change can now be integrated"))
@@ -323,11 +323,11 @@
                            .count();
             assertEquals(1, pushed);
 
             // Approve it as yet another user
             var reviewerPr = reviewer.getPullRequest(pr.getId());
-            reviewerPr.addReview(Review.Verdict.APPROVED);
+            reviewerPr.addReview(Review.Verdict.APPROVED, "Approved");
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // The instructional message should have been updated
             pushed = pr.getComments().stream()
                            .filter(comment -> comment.body().contains("change can now be integrated"))
@@ -397,11 +397,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Push something unrelated to master
             localRepo.checkout(masterHash, true);
             var unrelated = localRepo.root().resolve("unrelated.txt");
             Files.writeString(unrelated, "Hello");
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
@@ -77,11 +77,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -156,11 +156,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push something new to master
@@ -242,11 +242,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -297,11 +297,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + "xyz" + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -355,11 +355,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":otherxyz");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -418,11 +418,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other2");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -476,11 +476,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
@@ -548,11 +548,11 @@
             localRepo.push(mergeHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "Merge " + credentials.getHostedRepository().getName() + ":other");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot check the status
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Push it
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SponsorTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SponsorTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SponsorTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SponsorTests.java
@@ -60,11 +60,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot see it
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Issue a merge command without being a Committer
@@ -251,11 +251,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = reviewer.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Let the bot see it
             TestBotRunner.runPeriodicItems(mergeBot);
 
             // Flag it as ready for integration
@@ -336,11 +336,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Approve it as another user
             var approvalPr = integrator.getPullRequest(pr.getId());
-            approvalPr.addReview(Review.Verdict.APPROVED);
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
 
             // Push something unrelated to master
             localRepo.checkout(masterHash, true);
             var unrelated = localRepo.root().resolve("unrelated.txt");
             Files.writeString(unrelated, "Hello");
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/VetoTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/VetoTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/VetoTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/VetoTests.java
@@ -181,11 +181,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Place a veto
             var vetoPr = vetoer.getPullRequest(pr.getId());
-            vetoPr.addReview(Review.Verdict.APPROVED);
+            vetoPr.addReview(Review.Verdict.APPROVED, "Approved");
             vetoPr.addComment("/reject");
             TestBotRunner.runPeriodicItems(prBot);
 
             // The bot should acknowledge
             var ack = pr.getComments().stream()
@@ -251,11 +251,11 @@
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
             // Place a veto
             var vetoPr = vetoer.getPullRequest(pr.getId());
-            vetoPr.addReview(Review.Verdict.APPROVED);
+            vetoPr.addReview(Review.Verdict.APPROVED, "Approved");
             vetoPr.addComment("/reject");
             TestBotRunner.runPeriodicItems(prBot);
 
             // The bot should acknowledge
             var ack = pr.getComments().stream()
diff a/host/src/main/java/org/openjdk/skara/host/PullRequest.java b/host/src/main/java/org/openjdk/skara/host/PullRequest.java
--- a/host/src/main/java/org/openjdk/skara/host/PullRequest.java
+++ b/host/src/main/java/org/openjdk/skara/host/PullRequest.java
@@ -43,11 +43,11 @@
      * @return
      */
     HostUserDetails getAuthor();
 
     /**
-     * List of reviews.
+     * List of reviews, in descending chronological order.
      * @return
      */
     List<Review> getReviews();
 
     /**
@@ -51,11 +51,11 @@
     List<Review> getReviews();
 
     /**
      * Adds a review with the given verdict.
      */
-    void addReview(Review.Verdict verdict);
+    void addReview(Review.Verdict verdict, String body);
 
     /**
      * Add a file specific comment.
      * @param hash
      * @param path
diff a/host/src/main/java/org/openjdk/skara/host/Review.java b/host/src/main/java/org/openjdk/skara/host/Review.java
--- a/host/src/main/java/org/openjdk/skara/host/Review.java
+++ b/host/src/main/java/org/openjdk/skara/host/Review.java
@@ -21,15 +22,46 @@
  */
 package org.openjdk.skara.host;
 
 import org.openjdk.skara.vcs.Hash;
 
+import java.util.Optional;
+
 public class Review {
-    public HostUserDetails reviewer;
-    public Verdict verdict;
-    public Hash hash;
+    private final HostUserDetails reviewer;
+    private final Verdict verdict;
+    private final Hash hash;
+    private final int id;
+    private final String body;
+
+    public Review(HostUserDetails reviewer, Verdict verdict, Hash hash, int id, String body) {
+        this.reviewer = reviewer;
+        this.verdict = verdict;
+        this.hash = hash;
+        this.id = id;
+        this.body = body;
+    }
+
+    public HostUserDetails reviewer() {
+        return reviewer;
+    }
+
+    public Verdict verdict() {
+        return verdict;
+    }
+
+    public Hash hash() {
+        return hash;
+    }
+
+    public int id() {
+        return id;
+    }
+
+    public Optional<String> body() {
+        return Optional.ofNullable(body);
+    }
 
     public enum Verdict {
         NONE,
         APPROVED,
         DISAPPROVED
diff a/host/src/main/java/org/openjdk/skara/host/github/GitHubPullRequest.java b/host/src/main/java/org/openjdk/skara/host/github/GitHubPullRequest.java
--- a/host/src/main/java/org/openjdk/skara/host/github/GitHubPullRequest.java
+++ b/host/src/main/java/org/openjdk/skara/host/github/GitHubPullRequest.java
@@ -63,45 +62,39 @@
         return host.parseUserDetails(json);
     }
 
     @Override
     public List<Review> getReviews() {
-        // Reviews are returned in chronological order, we only care about the latest
         var reviews = request.get("pulls/" + json.get("number").toString() + "/reviews").execute().stream()
                              .map(JSONValue::asObject)
+                             .filter(obj -> !(obj.get("state").asString().equals("COMMENTED") && obj.get("body").asString().isEmpty()))
                              .map(obj -> {
-                                 var ret = new Review();
-                                 ret.reviewer = host.parseUserDetails(obj);
-                                 ret.hash = new Hash(obj.get("commit_id").asString());
+                                 var reviewer = host.parseUserDetails(obj);
+                                 var hash = new Hash(obj.get("commit_id").asString());
+                                 Review.Verdict verdict;
                                  switch (obj.get("state").asString()) {
                                      case "APPROVED":
-                                         ret.verdict = Review.Verdict.APPROVED;
+                                         verdict = Review.Verdict.APPROVED;
                                          break;
-                                     case "REQUEST_CHANGES":
-                                         ret.verdict = Review.Verdict.DISAPPROVED;
+                                     case "CHANGES_REQUESTED":
+                                         verdict = Review.Verdict.DISAPPROVED;
                                          break;
                                      default:
-                                         ret.verdict = Review.Verdict.NONE;
+                                         verdict = Review.Verdict.NONE;
                                          break;
                                  }
-                                 return ret;
+                                 var id = obj.get("id").asInt();
+                                 var body = obj.get("body").asString();
+                                 return new Review(reviewer, verdict, hash, id, body);
                              })
                              .collect(Collectors.toList());
-
-        var reviewMap = new HashMap<String, Review>();
-        for (var review : reviews) {
-            reviewMap.put(review.reviewer.id(), review);
-        }
-
-        return reviewMap.entrySet().stream()
-                .sorted(Map.Entry.comparingByKey())
-                .map(Map.Entry::getValue)
-                .collect(Collectors.toList());
+        return reviews;
     }
 
     @Override
-    public void addReview(Review.Verdict verdict) {
+    public void addReview(Review.Verdict verdict, String body) {
         var query = JSON.object();
         switch (verdict) {
             case APPROVED:
                 query.put("event", "APPROVE");
                 break;
@@ -105,16 +97,17 @@
             case APPROVED:
                 query.put("event", "APPROVE");
                 break;
             case DISAPPROVED:
                 query.put("event", "REQUEST_CHANGES");
-                query.put("body", "Disapproved by API function setApproval");
                 break;
             case NONE:
                 query.put("event", "COMMENT");
-                query.put("body", "Review comment by API function setApproval");
                 break;
         }
+        query.put("body", body);
         request.post("pulls/" + json.get("number").toString() + "/reviews")
                .body(query)
                .execute();
     }
 
diff a/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabMergeRequest.java b/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabMergeRequest.java
--- a/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabMergeRequest.java
+++ b/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabMergeRequest.java
@@ -89,29 +89,29 @@
         return request.get("award_emoji").execute().stream()
                       .map(JSONValue::asObject)
                       .filter(obj -> obj.get("name").asString().equals("thumbsup") ||
                                     obj.get("name").asString().equals("thumbsdown"))
                       .map(obj -> {
-                                var ret = new Review();
-                                ret.reviewer = repository.host().getUserDetails(obj.get("user").get("username").asString());
-                                ret.verdict = obj.get("name").asString().equals("thumbsup") ? Review.Verdict.APPROVED : Review.Verdict.DISAPPROVED;
+                                var reviewer = repository.host().getUserDetails(obj.get("user").get("username").asString());
+                                var verdict = obj.get("name").asString().equals("thumbsup") ? Review.Verdict.APPROVED : Review.Verdict.DISAPPROVED;
                                 var createdAt = ZonedDateTime.parse(obj.get("updated_at").asString());
 
                                 // Find the latest commit that isn't created after our review
-                                ret.hash = commits.get(0).hash;
+                                var hash = commits.get(0).hash;
                                 for (var cd : commits) {
                                     if (createdAt.isAfter(cd.date)) {
-                                        ret.hash = cd.hash;
+                                        hash = cd.hash;
                                     }
                                 }
-                                return ret;
+                                var id = obj.get("id").asInt();
+                                return new Review(reviewer, verdict, hash, id, null);
                             })
                       .collect(Collectors.toList());
     }
 
     @Override
-    public void addReview(Review.Verdict verdict) {
+    public void addReview(Review.Verdict verdict, String body) {
         // Remove any previous awards
         var awards = request.get("award_emoji").execute().stream()
                             .map(JSONValue::asObject)
                             .filter(obj -> obj.get("name").asString().equals("thumbsup") ||
                                     obj.get("name").asString().equals("thumbsdown"))
diff a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
--- a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
+++ b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
@@ -103,27 +103,22 @@
     public List<Review> getReviews() {
         return new ArrayList<>(data.reviews);
     }
 
     @Override
-    public void addReview(Review.Verdict verdict) {
-        var reviewer = repository.host().getCurrentUserDetails();
-        var existing = data.reviews.stream()
-                .filter(review -> review.reviewer.equals(reviewer))
-                .findAny();
-        existing.ifPresent(data.reviews::remove);
-
-        var review = new Review();
-        review.reviewer = reviewer;
-        review.verdict = verdict;
+    public void addReview(Review.Verdict verdict, String body) {
         try {
-            review.hash = repository.localRepository().resolve(sourceRef).orElseThrow();
+            var review = new Review(repository.host().getCurrentUserDetails(),
+                                    verdict, repository.localRepository().resolve(sourceRef).orElseThrow(),
+                                    data.reviews.size(),
+                                    body);
+
+            data.reviews.add(review);
+            data.lastUpdate = ZonedDateTime.now();
+
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
-        data.reviews.add(review);
-        data.lastUpdate = ZonedDateTime.now();
     }
 
     @Override
     public ReviewComment addReviewComment(Hash base, Hash hash, String path, int line, String body) {
         var comment = new ReviewComment(null, String.valueOf(data.reviewComments.size()), hash, path, line, String.valueOf(data.reviewComments.size()), body, user, ZonedDateTime.now(), ZonedDateTime.now());
