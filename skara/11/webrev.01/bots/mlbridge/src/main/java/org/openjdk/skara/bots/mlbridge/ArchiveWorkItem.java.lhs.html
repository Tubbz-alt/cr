<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.mlbridge;
 24 
 25 import org.openjdk.skara.bot.WorkItem;
 26 import org.openjdk.skara.email.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.mailinglist.*;
 29 import org.openjdk.skara.vcs.*;
 30 
 31 import java.io.*;
 32 import java.net.URI;
 33 import java.nio.charset.StandardCharsets;
 34 import java.nio.file.Path;
 35 import java.security.*;
 36 import java.time.*;
 37 import java.time.format.DateTimeFormatter;
 38 import java.util.*;
 39 import java.util.function.*;
 40 import java.util.logging.Logger;
 41 import java.util.regex.Pattern;
 42 import java.util.stream.Collectors;
 43 
 44 class ArchiveWorkItem implements WorkItem {
 45     private final PullRequest pr;
 46     private final MailingListBridgeBot bot;
 47     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.bots.mlbridge&quot;);
 48 
 49     ArchiveWorkItem(PullRequest pr, MailingListBridgeBot bot) {
 50         this.pr = pr;
 51         this.bot = bot;
 52     }
 53 
 54     @Override
 55     public String toString() {
 56         return &quot;ArchiveWorkItem@&quot; + bot.codeRepo().getName() + &quot;#&quot; + pr.getId();
 57     }
 58 
 59     @Override
 60     public boolean concurrentWith(WorkItem other) {
 61         if (!(other instanceof ArchiveWorkItem)) {
 62             return true;
 63         }
 64         ArchiveWorkItem otherItem = (ArchiveWorkItem)other;
 65         if (!pr.getId().equals(otherItem.pr.getId())) {
 66             return true;
 67         }
 68         if (!bot.codeRepo().getName().equals(otherItem.bot.codeRepo().getName())) {
 69             return true;
 70         }
 71         return false;
 72     }
 73 
 74     private void pushMbox(Repository localRepo, String message) {
 75         try {
 76             localRepo.addremove(localRepo.root().resolve(&quot;.&quot;));
 77             var hash = localRepo.commit(message, bot.emailAddress().fullName().orElseThrow(), bot.emailAddress().address());
 78             localRepo.push(hash, bot.archiveRepo().getUrl(), &quot;master&quot;);
 79         } catch (IOException e) {
 80             throw new UncheckedIOException(e);
 81         }
 82     }
 83 
 84     private static final Pattern replyToPattern = Pattern.compile(&quot;^\\s*@([-A-Za-z0-9]+)&quot;);
 85 
 86     private Optional&lt;Comment&gt; getParentPost(Comment post, List&lt;Comment&gt; all) {
 87         var matcher = replyToPattern.matcher(post.body());
 88         if (matcher.find()) {
 89             var replyToName = matcher.group(1);
 90             var replyToNamePattern = Pattern.compile(&quot;^&quot; + replyToName + &quot;$&quot;);
 91 
 92             var postIterator = all.listIterator();
 93             while (postIterator.hasNext()) {
 94                 var cur = postIterator.next();
 95                 if (cur == post) {
 96                     break;
 97                 }
 98             }
 99 
100             while (postIterator.hasPrevious()) {
101                 var cur = postIterator.previous();
102                 var userMatcher = replyToNamePattern.matcher(cur.author().userName());
103                 if (userMatcher.matches()) {
104                     return Optional.of(cur);
105                 }
106             }
107         }
108 
109         return Optional.empty();
110     }
111 
112     private String quoteBody(String body) {
113         return Arrays.stream(body.strip().split(&quot;\\R&quot;))
114                      .map(line -&gt; line.length() &gt; 0 ? line.charAt(0) == &#39;&gt;&#39; ? &quot;&gt;&quot; + line : &quot;&gt; &quot; + line : &quot;&gt; &quot;)
115                      .collect(Collectors.joining(&quot;\n&quot;));
116     }
117 
118     private static final Pattern commentPattern = Pattern.compile(&quot;&lt;!--.*?--&gt;&quot;,
119                                                                   Pattern.DOTALL | Pattern.MULTILINE);
120     private static final Pattern cutoffPattern = Pattern.compile(&quot;(.*?)&lt;!-- Anything below this marker will be .*? --&gt;&quot;,
121                                                                  Pattern.DOTALL | Pattern.MULTILINE);
122     private String filterComments(String body) {
123         var cutoffMatcher = cutoffPattern.matcher(body);
124         if (cutoffMatcher.find()) {
125             body = cutoffMatcher.group(1);
126         }
127 
128         var commentMatcher = commentPattern.matcher(body);
129         body = commentMatcher.replaceAll(&quot;&quot;);
130 
131         return body.strip();
132     }
133 
134     private String formatCommit(Commit commit) {
135         var ret = new StringBuilder();
136         var message = commit.message();
137         if (message.size() == 0) {
138             ret.append(&quot;&lt;no commit message found&gt;&quot;);
139         } else {
140             var abbrev = commit.hash().abbreviate();
141             var filler = &quot;\t&quot;.repeat(((abbrev.length() + 4 /* additional spacing */) / 8 /* tab size */) + 1 /* rounding */);
142             ret.append(&quot; - &quot;).append(abbrev).append(&quot;:\t&quot;).append(message.get(0).strip());
143             message.stream()
144                    .skip(1)
145                    .map(String::strip)
146                    .filter(Predicate.not(String::isEmpty))
147                    .forEach(line -&gt; ret.append(&quot;\n&quot;).append(filler).append(&quot;\t&quot;).append(line));
148         }
149         return ret.toString();
150     }
151 
152     private static final String infoSeparator = &quot;----------------&quot;;
153 
154     private String composeConversation(String body, PullRequestInstance prInstance, URI webrev) {
155         var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), this::formatCommit);
156         var filteredBody = filterComments(body);
157         if (filteredBody.isEmpty()) {
158             filteredBody = pr.getTitle().strip();
159         }
160         return filteredBody + &quot;\n\n&quot; +
161                 infoSeparator + &quot;\n\n&quot; +
162                 &quot;Commits:\n&quot; +
163                 commitMessages + &quot;\n\n&quot; +
164                 &quot;Pull request:\n&quot; +
165                 pr.getWebUrl() + &quot;\n\n&quot; +
166                 &quot;Webrev:\n&quot; +
167                 webrev.toString() + &quot;\n\n&quot; +
168                 &quot;Patch:\n&quot; +
169                 prInstance.diffUrl() + &quot;\n\n&quot; +
170                 &quot;Fetch command:\n&quot; +
171                 prInstance.fetchCommand();
172     }
173 
174     private String composeReply(ZonedDateTime date, EmailAddress author, String parentBody, String body) {
175         return &quot;On &quot; + date.format(DateTimeFormatter.RFC_1123_DATE_TIME) + &quot;, &quot; + author.toString() + &quot; wrote:\n&quot; +
176                 &quot;\n&quot; +
177                 quoteBody(parentBody) +
178                 &quot;\n\n&quot; +
179                 filterComments(body);
180     }
<a name="1" id="anc1"></a>
































181 
182     private String composeRebaseComment(Hash lastBase, PullRequestInstance prInstance, URI fullWebrev) {
183         var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), this::formatCommit);
184         return &quot;The pull request has been updated with a complete new set of changes (possibly due to a rebase).\n\n&quot; +
185                 infoSeparator + &quot;\n\n&quot; +
186                 &quot;Commits:\n&quot; +
187                 commitMessages + &quot;\n\n&quot; +
188                 &quot;Pull request:\n&quot; +
189                 pr.getWebUrl() + &quot;\n\n&quot; +
190                 &quot;Webrev:\n&quot; +
191                 fullWebrev.toString() + &quot;\n\n&quot; +
192                 &quot;Updated full patch:\n&quot; +
193                 prInstance.diffUrl() + &quot;\n\n&quot; +
194                 &quot;Fetch command:\n&quot; +
195                 prInstance.fetchCommand();
196     }
197 
198     private String composeIncrementalComment(Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
199         var newCommitMessages = prInstance.formatCommitMessages(lastHead, prInstance.headHash(), this::formatCommit);
200         return &quot;The pull request has been updated with additional changes.\n\n&quot; +
201                 infoSeparator + &quot;\n\n&quot; +
202                 &quot;Added commits:\n&quot; +
203                 newCommitMessages + &quot;\n\n&quot; +
204                 &quot;Pull request:\n&quot; +
205                 pr.getWebUrl() + &quot;\n\n&quot; +
206                 &quot;Webrevs:\n&quot; +
207                 &quot; - full: &quot; + fullWebrev.toString() + &quot;\n&quot; +
208                 &quot; - inc: &quot; + incrementalWebrev.toString() + &quot;\n\n&quot; +
209                 &quot;Updated full patch:\n&quot; +
210                 prInstance.diffUrl() + &quot;\n\n&quot; +
211                 &quot;Fetch command:\n&quot; +
212                 prInstance.fetchCommand();
213     }
214 
215     private String composeReadyForIntegrationComment() {
216         return &quot;This PR now fulfills all the requirements for integration, and is only awaiting the final &quot; +
217                 &quot;integration command from the author.&quot;;
218     }
219 
<a name="2" id="anc2"></a><span class="line-removed">220     private String verdictToString(Review.Verdict verdict) {</span>
<span class="line-removed">221         switch (verdict) {</span>
<span class="line-removed">222             case APPROVED:</span>
<span class="line-removed">223                 return &quot;changes are approved&quot;;</span>
<span class="line-removed">224             case DISAPPROVED:</span>
<span class="line-removed">225                 return &quot;more changes needed&quot;;</span>
<span class="line-removed">226             case NONE:</span>
<span class="line-removed">227                 return &quot;comment added&quot;;</span>
<span class="line-removed">228             default:</span>
<span class="line-removed">229                 throw new RuntimeException(&quot;Unknown verdict: &quot; + verdict);</span>
<span class="line-removed">230         }</span>
<span class="line-removed">231     }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233     private String composeNewReviewVerdict(Review review) {</span>
<span class="line-removed">234         var ret = new StringBuilder();</span>
<span class="line-removed">235         var author = getAuthorAddress(review.reviewer);</span>
<span class="line-removed">236         ret.append(&quot;This PR has now been reviewed by &quot;);</span>
<span class="line-removed">237         ret.append(author.fullName().orElse(author.localPart()));</span>
<span class="line-removed">238         ret.append(&quot; - &quot;);</span>
<span class="line-removed">239         ret.append(verdictToString(review.verdict));</span>
<span class="line-removed">240         ret.append(&quot;.&quot;);</span>
<span class="line-removed">241         return ret.toString();</span>
<span class="line-removed">242     }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     private String composeUpdatedReviewVerdict(Review review) {</span>
<span class="line-removed">245         var ret = new StringBuilder();</span>
<span class="line-removed">246         var author = getAuthorAddress(review.reviewer);</span>
<span class="line-removed">247         ret.append(&quot;The PR reviewed by &quot;);</span>
<span class="line-removed">248         ret.append(author.fullName().orElse(author.localPart()));</span>
<span class="line-removed">249         ret.append(&quot; has now been updated - &quot;);</span>
<span class="line-removed">250         ret.append(verdictToString(review.verdict));</span>
<span class="line-removed">251         ret.append(&quot;.&quot;);</span>
<span class="line-removed">252         return ret.toString();</span>
<span class="line-removed">253     }</span>
<span class="line-removed">254 </span>
255     private Repository materializeArchive(Path scratchPath) {
256         try {
257             return Repository.materialize(scratchPath, bot.archiveRepo().getUrl(), pr.getTargetRef());
258         } catch (IOException e) {
259             throw new UncheckedIOException(e);
260         }
261     }
262 
263     private final static Pattern commandPattern = Pattern.compile(&quot;^/.*$&quot;);
264 
265     private boolean ignoreComment(HostUserDetails author, String body) {
266         if (pr.repository().host().getCurrentUserDetails().equals(author)) {
267             return true;
268         }
269         if (bot.ignoredUsers().contains(author.userName())) {
270             return true;
271         }
272         var commandMatcher = commandPattern.matcher(body);
273         if (commandMatcher.matches()) {
274             return true;
275         }
276         return false;
277     }
278 
279     private EmailAddress getUniqueMessageId(String identifier) {
280         try {
281             var prSpecific = pr.repository().getName().replace(&quot;/&quot;, &quot;.&quot;) + &quot;.&quot; + pr.getId();
282             var digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
283             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
284             digest.update(identifier.getBytes(StandardCharsets.UTF_8));
285             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
286 
287             return EmailAddress.from(encodedCommon + &quot;.&quot; + UUID.randomUUID() + &quot;@&quot; + pr.repository().getUrl().getHost());
288         } catch (NoSuchAlgorithmException e) {
289             throw new RuntimeException(&quot;Cannot find SHA-256&quot;);
290         }
291     }
292 
293     private String getStableMessageId(EmailAddress uniqueMessageId) {
294         return uniqueMessageId.localPart().split(&quot;\\.&quot;)[0];
295     }
296 
297     private EmailAddress getMessageId() {
298         return getUniqueMessageId(&quot;fc&quot;);
299     }
300 
301     private EmailAddress getMessageId(Comment comment) {
302         return getUniqueMessageId(&quot;pc&quot; + comment.id());
303     }
304 
305     private EmailAddress getMessageId(ReviewComment comment) {
306         return getUniqueMessageId(&quot;rc&quot; + comment.id());
307     }
308 
309     private EmailAddress getMessageId(Hash hash) {
310         return getUniqueMessageId(&quot;ha&quot; + hash.hex());
311     }
312 
313     private EmailAddress getMessageId(String raw) {
314         return getUniqueMessageId(&quot;rw&quot; + raw);
315     }
316 
<a name="3" id="anc3"></a><span class="line-modified">317     private EmailAddress getMessageId(HostUserDetails reviewer, String verdict, int reviewCount) {</span>
<span class="line-modified">318         return getUniqueMessageId(&quot;vd&quot; + reviewer.id() + &quot;;&quot; + verdict + &quot;;&quot; + reviewCount);</span>
319     }
320 
321     private EmailAddress getAuthorAddress(HostUserDetails originalAuthor) {
322         return EmailAddress.from(originalAuthor.fullName() + &quot; via &quot; + pr.repository().getUrl().getHost(),
323                                  bot.emailAddress().address());
324     }
325 
326     private Email newConversation(PullRequestInstance prInstance, URI webrev) {
327         var body = composeConversation(pr.getBody(), prInstance, webrev);
328         var email = Email.create(getAuthorAddress(pr.getAuthor()), &quot;RFR: &quot; + pr.getTitle(), body)
329                          .sender(bot.emailAddress())
330                          .id(getMessageId())
331                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
332                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
333                          .build();
334         return email;
335     }
336 
337 
338     private Email comment(Email parent, Comment comment) {
339         var reply = composeReply(parent.date(), parent.author(), parent.body(), comment.body());
340         var references = parent.id().toString();
341         if (parent.hasHeader(&quot;References&quot;)) {
342             references = parent.headerValue(&quot;References&quot;) + &quot; &quot; + references;
343         }
344 
345         var email = Email.create(getAuthorAddress(comment.author()), &quot;Re: RFR: &quot; + pr.getTitle(), reply)
346                          .sender(bot.emailAddress())
347                          .recipient(parent.author())
348                          .id(getMessageId(comment))
349                          .header(&quot;In-Reply-To&quot;, parent.id().toString())
350                          .header(&quot;References&quot;, references)
351                          .build();
352         return email;
353     }
<a name="4" id="anc4"></a>












354 
355     private Email reviewComment(Email parent, ReviewComment comment) {
356         var body = new StringBuilder();
357 
358         // Add some context to the first post
359         if (comment.parent().isEmpty()) {
360             var contents = pr.repository().getFileContents(comment.path(), comment.hash().hex()).lines().collect(Collectors.toList());
361 
362             body.append(comment.path()).append(&quot; line &quot;).append(comment.line()).append(&quot;:\n\n&quot;);
363             for (int i = Math.max(0, comment.line() - 2); i &lt; Math.min(contents.size(), comment.line() + 1); ++i) {
364                 body.append(&quot;&gt; &quot;).append(i + 1).append(&quot;: &quot;).append(contents.get(i)).append(&quot;\n&quot;);
365             }
366             body.append(&quot;\n&quot;);
367         }
368         body.append(comment.body());
369 
370         var reply = composeReply(parent.date(), parent.author(), parent.body(), body.toString());
371         var references = parent.id().toString();
372         if (parent.hasHeader(&quot;References&quot;)) {
373             references = parent.headerValue(&quot;References&quot;) + &quot; &quot; + references;
374         }
375 
376         var email = Email.create(getAuthorAddress(comment.author()), &quot;Re: RFR: &quot; + pr.getTitle(), reply)
377                          .sender(bot.emailAddress())
378                          .recipient(parent.author())
379                          .id(getMessageId(comment))
380                          .header(&quot;In-Reply-To&quot;, parent.id().toString())
381                          .header(&quot;References&quot;, references)
382                          .build();
383         return email;
384     }
385 
386     private Email rebaseComment(Email parent, Hash lastBase, PullRequestInstance prInstance, URI fullWebrev) {
387         var body = composeRebaseComment(lastBase, prInstance, fullWebrev);
388         var email = Email.create(getAuthorAddress(pr.getAuthor()), &quot;Re: RFR: &quot; + pr.getTitle(), body)
389                          .sender(bot.emailAddress())
390                          .recipient(parent.author())
391                          .id(getMessageId(prInstance.headHash()))
392                          .header(&quot;In-Reply-To&quot;, parent.id().toString())
393                          .header(&quot;References&quot;, parent.id().toString())
394                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
395                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
396                          .build();
397         return email;
398     }
399 
400     private Email incrementalComment(Email parent, Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
401         var body = composeIncrementalComment(lastHead, prInstance, fullWebrev, incrementalWebrev);
402         var email = Email.create(getAuthorAddress(pr.getAuthor()), &quot;Re: RFR: &quot; + pr.getTitle(), body)
403                          .sender(bot.emailAddress())
404                          .recipient(parent.author())
405                          .id(getMessageId(prInstance.headHash()))
406                          .header(&quot;In-Reply-To&quot;, parent.id().toString())
407                          .header(&quot;References&quot;, parent.id().toString())
408                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
409                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
410                          .build();
411         return email;
412     }
413 
414     private Email readyForIntegrationComment(Email parent, Set&lt;String&gt; currentLabels, int numLabelComments) {
415         var body = composeReadyForIntegrationComment();
416         var email = Email.create(getAuthorAddress(pr.getAuthor()), &quot;Re: RFR: &quot; + pr.getTitle(), body)
417                          .sender(bot.emailAddress())
418                          .recipient(parent.author())
419                          .id(getMessageId(&quot;labelcomment&quot; + numLabelComments))
420                          .header(&quot;In-Reply-To&quot;, parent.id().toString())
421                          .header(&quot;References&quot;, parent.id().toString())
422                          .header(&quot;PR-Labels&quot;, String.join(&quot;;&quot;, currentLabels))
423                          .build();
424         return email;
425     }
426 
<a name="5" id="anc5"></a><span class="line-removed">427     private Email reviewVerdictComment(Email parent, HostUserDetails reviewer, String verdict, int reviewCount, String body) {</span>
<span class="line-removed">428         var email = Email.create(getAuthorAddress(reviewer), &quot;Re: RFR: &quot; + pr.getTitle(), body)</span>
<span class="line-removed">429                          .sender(bot.emailAddress())</span>
<span class="line-removed">430                          .recipient(parent.author())</span>
<span class="line-removed">431                          .id(getMessageId(reviewer, verdict, reviewCount))</span>
<span class="line-removed">432                          .header(&quot;In-Reply-To&quot;, parent.id().toString())</span>
<span class="line-removed">433                          .header(&quot;References&quot;, parent.id().toString())</span>
<span class="line-removed">434                          .header(&quot;PR-Review-Verdict&quot;, reviewer.id() + &quot;;&quot; + verdict)</span>
<span class="line-removed">435                          .build();</span>
<span class="line-removed">436         return email;</span>
<span class="line-removed">437 </span>
<span class="line-removed">438     }</span>
<span class="line-removed">439 </span>
<span class="line-removed">440     private List&lt;Email&gt; getReviewVerdictMails(Email parent, List&lt;Email&gt; archiveMails) {</span>
<span class="line-removed">441         // Determine the latest reported reviews</span>
<span class="line-removed">442         var ret = new ArrayList&lt;Email&gt;();</span>
<span class="line-removed">443         var reportedReviews = archiveMails.stream()</span>
<span class="line-removed">444                                           .filter(email -&gt; email.hasHeader(&quot;PR-Review-Verdict&quot;))</span>
<span class="line-removed">445                                           .map(email -&gt; email.headerValue(&quot;PR-Review-Verdict&quot;))</span>
<span class="line-removed">446                                           .collect(Collectors.toMap(</span>
<span class="line-removed">447                                                   value -&gt; value.substring(0, value.indexOf(&quot;;&quot;)),</span>
<span class="line-removed">448                                                   value -&gt; value.substring(value.indexOf(&quot;;&quot;) + 1),</span>
<span class="line-removed">449                                                   (a, b) -&gt; b)</span>
<span class="line-removed">450                                           );</span>
<span class="line-removed">451         var reviews = pr.getReviews();</span>
<span class="line-removed">452         var newReviews = reviews.stream()</span>
<span class="line-removed">453                                 .filter(review -&gt; !reportedReviews.containsKey(review.reviewer.id()))</span>
<span class="line-removed">454                                 .collect(Collectors.toList());</span>
<span class="line-removed">455         var updatedReviews = reviews.stream()</span>
<span class="line-removed">456                                     .filter(review -&gt; reportedReviews.containsKey(review.reviewer.id()))</span>
<span class="line-removed">457                                     .filter(review -&gt; !reportedReviews.get(review.reviewer.id()).equals(review.verdict.toString()))</span>
<span class="line-removed">458                                     .collect(Collectors.toList());</span>
<span class="line-removed">459 </span>
<span class="line-removed">460         for (var newReview : newReviews) {</span>
<span class="line-removed">461             var body = composeNewReviewVerdict(newReview);</span>
<span class="line-removed">462             ret.add(reviewVerdictComment(parent, newReview.reviewer, newReview.verdict.toString(), reportedReviews.size(), body));</span>
<span class="line-removed">463         }</span>
<span class="line-removed">464         for (var updatedReview : updatedReviews) {</span>
<span class="line-removed">465             var body = composeUpdatedReviewVerdict(updatedReview);</span>
<span class="line-removed">466             ret.add(reviewVerdictComment(parent, updatedReview.reviewer, updatedReview.verdict.toString(), reportedReviews.size(), body));</span>
<span class="line-removed">467         }</span>
<span class="line-removed">468         return ret;</span>
<span class="line-removed">469     }</span>
<span class="line-removed">470 </span>
471     private List&lt;Email&gt; parseArchive(MailingList archive) {
472         var conversations = archive.conversations(Duration.ofDays(365));
473 
474         if (conversations.size() == 0) {
475             return new ArrayList&lt;&gt;();
476         } else if (conversations.size() == 1) {
477             var conversation = conversations.get(0);
478             return conversation.allMessages();
479         } else {
480             throw new RuntimeException(&quot;Something is wrong with the mbox&quot;);
481         }
482     }
483 
484     private Map&lt;Email, Email&gt; findParents(Map&lt;EmailAddress, Email&gt; emailIds) {
485         var parents = new HashMap&lt;Email, Email&gt;();
486         for (var entry : emailIds.entrySet()) {
487             if (entry.getValue().hasHeader(&quot;In-Reply-To&quot;)) {
488                 var replyId = EmailAddress.parse(entry.getValue().headerValue(&quot;In-Reply-To&quot;));
489             }
490         }
491         return parents;
492     }
493 
494     private final Pattern replyHeaderPattern = Pattern.compile(&quot;^On .* &lt;(.*)&gt; wrote:$.*&quot;,
495                                                                Pattern.DOTALL | Pattern.MULTILINE);
496 
497     // Combine mails from the same author, directed at the same person, into a single mail
498     private List&lt;Email&gt; combineMails(List&lt;Email&gt; emails) {
499         var byAuthor = emails.stream().collect(Collectors.groupingBy(Email::author));
500         var ret = new ArrayList&lt;Email&gt;();
501         for (var authorMails : byAuthor.entrySet()) {
502             var byTarget = authorMails.getValue().stream()
503                                       .collect(Collectors.groupingBy(email -&gt; {
504                                           var matcher = replyHeaderPattern.matcher(email.body());
505                                           if (matcher.matches()) {
506                                               return matcher.group(1);
507                                           } else {
508                                               // No grouping of undirected messages
509                                               return &quot;&quot;;
510                                           }
511                                       }));
512 
513             for (var targetMails : byTarget.entrySet()) {
514                 if (!targetMails.getKey().isEmpty()) {
515                     var first = targetMails.getValue().get(0);
516                     var body = new StringBuilder(first.body());
517                     for (int i = 1; i &lt; targetMails.getValue().size(); ++i) {
518                         var addon = targetMails.getValue().get(i).body().lines()
519                                                .skip(2)
520                                                .dropWhile(line -&gt; line.startsWith(&quot;&gt;&quot;))
521                                                .skip(1)
522                                                .collect(Collectors.joining(&quot;\n&quot;));
523                         body.append(&quot;\n\n&quot;).append(addon);
524                     }
525                     var combined = Email.from(first).body(body.toString()).build();
526                     ret.add(combined);
527 
528                 } else {
529                     ret.addAll(targetMails.getValue());
530                 }
531             }
532         }
533 
534         return ret;
535     }
536 
537     private static final String webrevCommentMarker = &quot;&lt;!-- mlbridge webrev comment --&gt;&quot;;
538     private static final String webrevHeaderMarker = &quot;&lt;!-- mlbridge webrev header --&gt;&quot;;
539     private static final String webrevListMarker = &quot;&lt;!-- mlbridge webrev list --&gt;&quot;;
540 
541     private void updateWebrevComment(List&lt;Comment&gt; comments, int index, URI fullWebrev, URI incWebrev) {
542         var existing = comments.stream()
543                                .filter(comment -&gt; comment.author().equals(pr.repository().host().getCurrentUserDetails()))
544                                .filter(comment -&gt; comment.body().contains(webrevCommentMarker))
545                                .findAny();
546         var comment = webrevCommentMarker + &quot;\n&quot;;
547         comment += webrevHeaderMarker + &quot;\n&quot;;
548         comment += &quot;### Webrevs&quot; + &quot;\n&quot;;
549         comment += webrevListMarker + &quot;\n&quot;;
550         comment += &quot; * &quot; + String.format(&quot;%02d&quot;, index) + &quot;: [Full](&quot; + fullWebrev.toString() + &quot;)&quot;;
551         if (incWebrev != null) {
552             comment += &quot; - [Incremental](&quot; + incWebrev.toString() + &quot;)&quot;;
553         }
554         comment += &quot; (&quot; + pr.getHeadHash() + &quot;)\n&quot;;
555 
556         if (existing.isPresent()) {
557             if (existing.get().body().contains(fullWebrev.toString())) {
558                 log.fine(&quot;Webrev link already posted - skipping update&quot;);
559                 return;
560             }
561             var previousListStart = existing.get().body().indexOf(webrevListMarker) + webrevListMarker.length() + 1;
562             var previousList = existing.get().body().substring(previousListStart);
563             comment += previousList;
564             pr.updateComment(existing.get().id(), comment);
565         } else {
566             pr.addComment(comment);
567         }
568     }
569 
570     @Override
571     public void run(Path scratchPath) {
572         var path = scratchPath.resolve(&quot;mlbridge&quot;);
573         var archiveRepo = materializeArchive(path);
574         var mboxBasePath = path.resolve(bot.codeRepo().getName());
575         var mbox = MailingListServerFactory.createMboxFileServer(mboxBasePath);
576         var archive = mbox.getList(pr.getId());
577         var archiveMails = parseArchive(archive);
578 
579         // First determine if this PR should be inspected further or not
580         if (archiveMails.isEmpty()) {
581             // Wait until the PR is ready for review
582             if (!pr.getLabels().contains(&quot;rfr&quot;)) {
583                 log.fine(&quot;PR is not yet ready for review&quot;);
584                 return;
585             }
586         }
587 
588         var webrevPath = scratchPath.resolve(&quot;mlbridge-webrevs&quot;);
589         var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer());
590         var list = listServer.getList(bot.listAddress().address());
591         var newMails = new ArrayList&lt;Email&gt;();
592         var stableIdToMail = archiveMails.stream().collect(Collectors.toMap(email -&gt; getStableMessageId(email.id()),
593                                                                             Function.identity()));
594         var comments = pr.getComments();
595         var prInstance = new PullRequestInstance(scratchPath.resolve(&quot;mlbridge-mergebase&quot;), pr);
596 
597         // First post
598         if (archiveMails.isEmpty()) {
599             var webrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
600                                                               prInstance.headHash(), &quot;00&quot;);
601             var firstMail = newConversation(prInstance, webrev);
602             archive.post(firstMail);
603             newMails.add(firstMail);
604             stableIdToMail.put(getStableMessageId(firstMail.id()), firstMail);
605             updateWebrevComment(comments, 0, webrev, null);
606             log.fine(&quot;Posting new PR conversation&quot;);
607         } else {
608             // Determine the latest head hash reported
609             var reportedHeads = archiveMails.stream()
610                                             .filter(email -&gt; email.hasHeader(&quot;PR-Head-Hash&quot;))
611                                             .map(email -&gt; email.headerValue(&quot;PR-Head-Hash&quot;))
612                                             .map(Hash::new)
613                                             .collect(Collectors.toList());
614             var latestHead = reportedHeads.size() &gt; 0 ? reportedHeads.get(reportedHeads.size() - 1) : pr.getHeadHash();
615 
616             // Check if the head has changed
617             if (!pr.getHeadHash().equals(latestHead)) {
618                 log.fine(&quot;Head hash change detected: current: &quot; + pr.getHeadHash() + &quot; - existing: &quot; + reportedHeads);
619 
620                 // Determine the latest base hash reported
621                 var reportedBases = archiveMails.stream()
622                                                 .filter(email -&gt; email.hasHeader(&quot;PR-Base-Hash&quot;))
623                                                 .map(email -&gt; email.headerValue(&quot;PR-Base-Hash&quot;))
624                                                 .map(Hash::new)
625                                                 .collect(Collectors.toList());
626                 if (reportedBases.size() == 0) {
627                     throw new RuntimeException(&quot;No previous bases found?&quot;);
628                 }
629                 var latestBase = reportedBases.get(reportedBases.size() - 1);
630                 var firstMail = archiveMails.get(0);
631                 Email commentMail;
632                 if (!prInstance.baseHash().equals(latestBase)) {
633                     var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
634                                                                           prInstance.headHash(), String.format(&quot;%02d&quot;, reportedHeads.size()));
635                     commentMail = rebaseComment(firstMail, latestBase, prInstance, fullWebrev);
636                     updateWebrevComment(comments, reportedHeads.size(), fullWebrev, null);
637                 } else {
638                     var index = reportedHeads.size();
639                     var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
640                                                                           prInstance.headHash(), String.format(&quot;%02d&quot;, index));
641                     var incrementalWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, latestHead,
642                                                                                  prInstance.headHash(), String.format(&quot;%02d-%02d&quot;, index - 1, index));
643                     commentMail = incrementalComment(firstMail, latestHead, prInstance, fullWebrev, incrementalWebrev);
644                     updateWebrevComment(comments, index, fullWebrev, incrementalWebrev);
645                 }
646                 archive.post(commentMail);
647                 newMails.add(commentMail);
648                 stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
649             }
650         }
651 
652         // Regular comments
653         var previous = archiveMails.size() &gt; 0 ? archiveMails.get(0) : newMails.get(0);
654         for (var comment : comments) {
655             var id = getStableMessageId(getMessageId(comment));
656             if (stableIdToMail.containsKey(id)) {
657                 previous = stableIdToMail.get(id);
658                 continue;
659             }
660             if (ignoreComment(comment.author(), comment.body())) {
661                 continue;
662             }
663 
664             // Try to determine a parent post from @mentions
665             var parentComment = getParentPost(comment, comments);
666             var parent = parentComment.map(c -&gt; stableIdToMail.get(getStableMessageId(getMessageId(c)))).orElse(previous);
667 
668             var commentMail = comment(parent, comment);
669             archive.post(commentMail);
670             newMails.add(commentMail);
671             stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
672             previous = commentMail;
673         }
674 
<a name="6" id="anc6"></a><span class="line-modified">675         // File specific comments</span>
<a name="7" id="anc7"></a>

















676         final var first = archiveMails.size() &gt; 0 ? archiveMails.get(0) : newMails.get(0);
677         var reviewComments = pr.getReviewComments();
678         for (var reviewComment : reviewComments) {
679             var id = getStableMessageId(getMessageId(reviewComment));
680             if (stableIdToMail.containsKey(id)) {
681                 continue;
682             }
683             if (ignoreComment(reviewComment.author(), reviewComment.body())) {
684                 continue;
685             }
686 
687             var parent = reviewComment.parent().map(c -&gt; stableIdToMail.get(getStableMessageId(getMessageId(c)))).orElse(first);
688             var commentMail = reviewComment(parent, reviewComment);
689             archive.post(commentMail);
690             newMails.add(commentMail);
691             stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
692         }
693 
<a name="8" id="anc8"></a><span class="line-removed">694         // Review verdicts</span>
<span class="line-removed">695         var reviewVerdictMails = getReviewVerdictMails(first, archiveMails);</span>
<span class="line-removed">696         for (var reviewVerdictMail : reviewVerdictMails) {</span>
<span class="line-removed">697             archive.post(reviewVerdictMail);</span>
<span class="line-removed">698             newMails.add(reviewVerdictMail);</span>
<span class="line-removed">699             stableIdToMail.put(getStableMessageId(reviewVerdictMail.id()), reviewVerdictMail);</span>
<span class="line-removed">700         }</span>
<span class="line-removed">701 </span>
702         if (newMails.isEmpty()) {
703             return;
704         }
705 
706         // Push all new mails to the archive repository
707         pushMbox(archiveRepo, &quot;Adding comments for PR &quot; + bot.codeRepo().getName() + &quot;/&quot; + pr.getId());
708 
709         // Combine and post all new mails to the list
710         var listMails = combineMails(newMails);
711         for (var mail : listMails) {
712             list.post(mail);
713         }
714     }
715 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>