<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.issuetracker.IssueTracker;
 29 import org.openjdk.skara.issuetracker.Issue;
 30 import org.openjdk.skara.jcheck.JCheckConfiguration;
 31 import org.openjdk.skara.proxy.HttpProxy;
 32 import org.openjdk.skara.vcs.*;
 33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 34 
 35 import java.io.IOException;
 36 import java.net.URI;
 37 import java.nio.charset.StandardCharsets;
 38 import java.nio.file.*;
 39 import java.util.*;
 40 import java.util.regex.Pattern;
 41 import java.util.concurrent.TimeUnit;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Level;
 44 import java.util.stream.Collectors;
 45 
 46 public class GitPr {
 47     private static void exit(String fmt, Object...args) {
 48         System.err.println(String.format(fmt, args));
 49         System.exit(1);
 50     }
 51 
 52     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 53         return () -&gt; {
 54             exit(fmt, args);
 55             return null;
 56         };
 57     }
 58 
 59     private static String format(Issue issue) {
 60         var parts = issue.id().split(&quot;-&quot;);
 61         var id = parts.length == 2 ? parts[1] : issue.id();
 62         return id + &quot;: &quot; + issue.title();
 63     }
 64 
 65     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 66         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 67             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 68         ));
 69 
 70         return conf.general().jbs();
 71     }
 72 
 73     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 74         var message = CommitMessageParsers.v1.parse(commit.message());
 75         var issues = message.issues();
 76         if (issues.isEmpty()) {
 77             return getIssue(message.title(), project);
 78         } else if (issues.size() == 1) {
 79             var issue = issues.get(0);
 80             return getIssue(issue.id(), project);
 81         }
 82         return Optional.empty();
 83     }
 84 
 85     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 86         return getIssue(b.name(), project);
 87     }
 88 
 89     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 90         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
 91         var m = issueIdPattern.matcher(s);
 92         if (m.matches()) {
 93             var id = m.group(2);
 94             if (project == null) {
 95                 project = m.group(1);
 96             }
 97             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 98             return issueTracker.project(project).issue(id);
 99         }
100 
101         return Optional.empty();
102     }
103 
104     private static void await(Process p) throws IOException {
105         try {
106             var res = p.waitFor();
107             if (res != 0) {
108                 throw new IOException(&quot;Unexpected exit code &quot; + res);
109             }
110         } catch (InterruptedException e) {
111             throw new IOException(e);
112         }
113     }
114 
115     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
116         String editor = null;
117         var lines = repo.config(&quot;core.editor&quot;);
118         if (lines.size() == 1) {
119             editor = lines.get(0);
120         }
121         if (editor == null) {
122             editor = System.getenv(&quot;GIT_EDITOR&quot;);
123         }
124         if (editor == null) {
125             editor = System.getenv(&quot;EDITOR&quot;);
126         }
127         if (editor == null) {
128             editor = System.getenv(&quot;VISUAL&quot;);
129         }
130         if (editor == null) {
131             editor = &quot;vi&quot;;
132         }
133 
134         var pb = new ProcessBuilder(editor, file.toString());
135         pb.inheritIO();
136         var p = pb.start();
137         try {
138             return p.waitFor() == 0;
139         } catch (InterruptedException e) {
140             throw new IOException(e);
141         }
142     }
143 
144     private static String projectName(URI uri) {
145         var name = uri.getPath().toString().substring(1);
146         if (name.endsWith(&quot;.git&quot;)) {
147             name = name.substring(0, name.length() - &quot;.git&quot;.length());
148         }
149         return name;
150     }
151 
152     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
153         HostedRepository targetRepo = null;
154 
155         try {
156             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
157             targetRepo = host.repository(projectName(upstream)).orElse(null);
158         } catch (IOException e) {
159             // do nothing
160         }
161 
162         if (targetRepo == null) {
163             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
164                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
165             );
166             var parentRepo = remoteRepo.parent();
167             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
168         }
169 
170         return targetRepo;
171     }
172 
173     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
174         if (!prId.isPresent()) {
175             exit(&quot;error: missing pull request identifier&quot;);
176         }
177 
178         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
179         if (pr == null) {
180             exit(&quot;error: could not fetch PR information&quot;);
181         }
182 
183         return pr;
184     }
185 
186     private static void show(String ref, Hash hash) throws IOException {
187         show(ref, hash, null);
188     }
189     private static void show(String ref, Hash hash, Path dir) throws IOException {
190         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
191                                                    &quot;--patch&quot;,
192                                                    &quot;--find-renames=50%&quot;,
193                                                    &quot;--find-copies=50%&quot;,
194                                                    &quot;--find-copies-harder&quot;,
195                                                    &quot;--abbrev&quot;,
196                                                    ref + &quot;...&quot; + hash.hex());
197         if (dir != null) {
198             pb.directory(dir.toFile());
199         }
200         pb.inheritIO();
201         await(pb.start());
202     }
203 
204     private static void gimport() throws IOException {
205         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
206         pb.inheritIO();
207         await(pb.start());
208     }
209 
210     private static void hgImport(Path patch) throws IOException {
211         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
212         pb.inheritIO();
213         await(pb.start());
214     }
215 
216     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
217         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
218         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
219         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
220         var p = pb.start();
221         var bytes = p.getInputStream().readAllBytes();
222         var exited = p.waitFor(1, TimeUnit.MINUTES);
223         var exitValue = p.exitValue();
224         if (!exited || exitValue != 0) {
225             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
226         }
227 
228         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
229     }
230 
231     private static String hgResolve(String ref) throws IOException, InterruptedException {
232         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
233         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
234         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
235         var p = pb.start();
236         var bytes = p.getInputStream().readAllBytes();
237         var exited = p.waitFor(1, TimeUnit.MINUTES);
238         var exitValue = p.exitValue();
239         if (!exited || exitValue != 0) {
240             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
241         }
242 
243         return new String(bytes, StandardCharsets.UTF_8);
244     }
245 
246     private static Path diff(String ref, Hash hash) throws IOException {
247         return diff(ref, hash, null);
248     }
249 
250     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
251         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
252         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
253                                                    &quot;--patch&quot;,
254                                                    &quot;--find-renames=50%&quot;,
255                                                    &quot;--find-copies=50%&quot;,
256                                                    &quot;--find-copies-harder&quot;,
257                                                    &quot;--abbrev&quot;,
258                                                    ref + &quot;...&quot; + hash.hex());
259         if (dir != null) {
260             pb.directory(dir.toFile());
261         }
262         pb.redirectOutput(patch.toFile());
263         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
264         await(pb.start());
265         return patch;
266     }
267 
268     private static void apply(Path patch) throws IOException {
269         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
270         pb.inheritIO();
271         await(pb.start());
272     }
273 
274     private static int longest(List&lt;String&gt; strings) {
275         return strings.stream().mapToInt(String::length).max().orElse(0);
276     }
277 
278     public static void main(String[] args) throws IOException, InterruptedException {
279         var flags = List.of(
280             Option.shortcut(&quot;u&quot;)
281                   .fullname(&quot;username&quot;)
282                   .describe(&quot;NAME&quot;)
283                   .helptext(&quot;Username on host&quot;)
284                   .optional(),
285             Option.shortcut(&quot;r&quot;)
286                   .fullname(&quot;remote&quot;)
287                   .describe(&quot;NAME&quot;)
288                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
289                   .optional(),
290             Option.shortcut(&quot;b&quot;)
291                   .fullname(&quot;branch&quot;)
292                   .describe(&quot;NAME&quot;)
293                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
294                   .optional(),
295             Option.shortcut(&quot;&quot;)
296                   .fullname(&quot;authors&quot;)
297                   .describe(&quot;LIST&quot;)
298                   .helptext(&quot;Comma separated list of authors&quot;)
299                   .optional(),
300             Option.shortcut(&quot;&quot;)
301                   .fullname(&quot;assignees&quot;)
302                   .describe(&quot;LIST&quot;)
303                   .helptext(&quot;Comma separated list of assignees&quot;)
304                   .optional(),
305             Option.shortcut(&quot;&quot;)
306                   .fullname(&quot;labels&quot;)
307                   .describe(&quot;LIST&quot;)
308                   .helptext(&quot;Comma separated list of labels&quot;)
309                   .optional(),
310             Option.shortcut(&quot;&quot;)
311                   .fullname(&quot;columns&quot;)
312                   .describe(&quot;id,title,author,assignees,labels&quot;)
313                   .helptext(&quot;Comma separated list of columns to show&quot;)
314                   .optional(),
315             Switch.shortcut(&quot;&quot;)
316                   .fullname(&quot;no-decoration&quot;)
317                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
318                   .optional(),
319             Switch.shortcut(&quot;&quot;)
320                   .fullname(&quot;ignore-workspace&quot;)
321                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
322                   .optional(),
323             Switch.shortcut(&quot;&quot;)
324                   .fullname(&quot;no-token&quot;)
325                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
326                   .optional(),
327             Switch.shortcut(&quot;&quot;)
328                   .fullname(&quot;mercurial&quot;)
329                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
330                   .optional(),
331             Switch.shortcut(&quot;&quot;)
332                   .fullname(&quot;verbose&quot;)
333                   .helptext(&quot;Turn on verbose output&quot;)
334                   .optional(),
335             Switch.shortcut(&quot;&quot;)
336                   .fullname(&quot;debug&quot;)
337                   .helptext(&quot;Turn on debugging output&quot;)
338                   .optional(),
339             Switch.shortcut(&quot;&quot;)
340                   .fullname(&quot;version&quot;)
341                   .helptext(&quot;Print the version of this tool&quot;)
342                   .optional());
343 
344         var inputs = List.of(
345             Input.position(0)
346                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
347                  .singular()
348                  .required(),
349             Input.position(1)
350                  .describe(&quot;ID&quot;)
351                  .singular()
352                  .optional()
353         );
354 
355         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
356         var arguments = parser.parse(args);
357 
358         if (arguments.contains(&quot;version&quot;)) {
359             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
360             System.exit(0);
361         }
362 
363         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
364             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
365             Logging.setup(level);
366         }
367 
368         HttpProxy.setup();
369 
370         var isMercurial = arguments.contains(&quot;mercurial&quot;);
371         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
372         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
373         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
374         var remotePullPath = repo.pullPath(remote);
375         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
376         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
377         var uri = Remote.toWebURI(remotePullPath);
378         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
379         var credentials = !shouldUseToken ?
380             null :
381             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
382         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
383         var forge = credentials == null ?
384             Forge.from(forgeURI) :
385             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
386         if (forge.isEmpty()) {
387             if (!shouldUseToken) {
388                 if (arguments.contains(&quot;verbose&quot;)) {
389                     System.err.println(&quot;&quot;);
390                 }
391                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
392                 if (!arguments.contains(&quot;verbose&quot;)) {
393                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
394                     System.err.println(&quot;&quot;);
395                 }
396             }
397             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
398         }
399         var host = forge.get();
400 
401         var action = arguments.at(0).asString();
402         if (!shouldUseToken &amp;&amp;
403             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
404             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
405             System.exit(1);
406         }
407 
408         if (action.equals(&quot;create&quot;)) {
409             if (isMercurial) {
410                 var currentBookmark = repo.currentBookmark();
411                 if (!currentBookmark.isPresent()) {
412                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
413                     System.err.println(&quot;&quot;);
414                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
415                     System.err.println(&quot;&quot;);
416                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
417                     System.err.println(&quot;&quot;);
418                     System.exit(1);
419                 }
420 
421                 var bookmark = currentBookmark.get();
422                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
423                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
424                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
425                     System.err.println(&quot;&quot;);
426                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
427                     System.err.println(&quot;&quot;);
428                     System.exit(1);
429                 }
430 
431                 var tags = hgTags();
432                 var upstreams = tags.stream()
433                                     .filter(t -&gt; t.endsWith(bookmark.name()))
434                                     .collect(Collectors.toList());
435                 if (upstreams.isEmpty()) {
436                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
437                     System.err.println(&quot;&quot;);
438                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
439                     System.err.println(&quot;&quot;);
440                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
441                     System.err.println(&quot;&quot;);
442                     System.exit(1);
443                 }
444 
445                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
446                 for (var tag : tags) {
447                     tagsAndHashes.put(tag, hgResolve(tag));
448                 }
449                 var bookmarkHash = hgResolve(bookmark.name());
450                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
451                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
452                     System.err.println(&quot;&quot;);
453 
454                     if (upstreams.size() == 1) {
455                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
456                         System.err.println(&quot;&quot;);
457                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
458                         System.err.println(&quot;&quot;);
459                     } else {
460                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
461                         System.err.println(&quot;&quot;);
462                         for (var upstream : upstreams) {
463                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
464                         }
465                         System.err.println(&quot;&quot;);
466                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
467                         System.err.println(&quot;&quot;);
468                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
469                         System.err.println(&quot;&quot;);
470                     }
471                     System.exit(1);
472                 }
473 
474                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
475                 var targetHash = hgResolve(targetBranch);
476                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
477                 if (commits.isEmpty()) {
478                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
479                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
480                     System.exit(1);
481                 }
482 
483                 var diff = repo.diff(repo.head());
484                 if (!diff.patches().isEmpty()) {
485                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
486                     System.err.println(&quot;&quot;);
487                     for (var patch : diff.patches()) {
488                         var path = patch.target().path().isPresent() ?
489                             patch.target().path().get() : patch.source().path().get();
490                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
491                     }
492                     System.err.println(&quot;&quot;);
493                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
494                     System.err.println(&quot;&quot;);
495                     System.err.println(&quot;    hg commit --amend&quot;);
496                     System.err.println(&quot;    hg git-cleanup&quot;);
497                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
498                     System.err.println(&quot;    hg gimport&quot;);
499                     System.err.println(&quot;&quot;);
500                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
501                     System.err.println(&quot;&quot;);
502                     System.err.println(&quot;    hg shelve&quot;);
503                     System.err.println(&quot;&quot;);
504                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
505                     System.exit(1);
506                 }
507 
508                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
509                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
510                 );
511                 if (token == null) {
512                     GitCredentials.approve(credentials);
513                 }
514                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
515                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
516 
517                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
518                 if (commits.size() == 1) {
519                     var commit = commits.get(0);
520                     var message = CommitMessageParsers.v1.parse(commit.message());
521                     Files.writeString(file, message.title() + &quot;\n&quot;);
522                     if (!message.summaries().isEmpty()) {
523                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
524                     }
525                     if (!message.additional().isEmpty()) {
526                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
527                     }
528                 } else {
529                     Files.write(file, List.of(&quot;&quot;));
530                 }
531                 Files.write(file, List.of(
532                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
533                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
534                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
535                     &quot;# the subject from the body.&quot;,
536                     &quot;#&quot;,
537                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
538                     ),
539                     StandardOpenOption.APPEND
540                 );
541                 for (var commit : commits) {
542                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
543                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
544                 }
545                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
546                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
547                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
548                 var success = spawnEditor(repo, file);
549                 if (!success) {
550                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
551                     System.exit(1);
552                 }
553                 var lines = Files.readAllLines(file)
554                                  .stream()
555                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
556                                  .collect(Collectors.toList());
557                 var isEmpty = lines.stream().allMatch(String::isEmpty);
558                 if (isEmpty) {
559                     System.err.println(&quot;error: no message present, aborting&quot;);
560                     System.exit(1);
561                 }
562 
563                 var title = lines.get(0);
564                 List&lt;String&gt; body = null;
565                 if (lines.size() &gt; 1) {
566                     body = lines.subList(1, lines.size())
567                                 .stream()
568                                 .dropWhile(String::isEmpty)
569                                 .collect(Collectors.toList());
570                 } else {
571                     body = Collections.emptyList();
572                 }
573 
574                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
575                 if (arguments.contains(&quot;assignees&quot;)) {
576                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
577                     var assignees = usernames.stream()
578                                              .map(u -&gt; host.user(u))
579                                              .collect(Collectors.toList());
580                     pr.setAssignees(assignees);
581                 }
582                 System.out.println(pr.webUrl().toString());
583                 Files.deleteIfExists(file);
584 
585                 System.exit(0);
586             }
587             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
588                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
589                     System.exit(1);
590                     return null;
591             });
592             if (currentBranch.equals(repo.defaultBranch())) {
593                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
594                 System.err.println(&quot;&quot;);
595                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
596                 System.err.println(&quot;&quot;);
597                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
598                 System.err.println(&quot;    git branch --force master origin/master&quot;);
599                 System.err.println(&quot;&quot;);
600                 System.exit(1);
601             }
602 
603             var ignoreWorkspace = arguments.contains(&quot;ignore-workspace&quot;);
604             if (!ignoreWorkspace) {
605                 var lines = repo.config(&quot;pr.ignore-workspace&quot;);
606                 ignoreWorkspace = lines.size() == 1 &amp;&amp; lines.get(0).equals(&quot;true&quot;);
607             }
608             if (!ignoreWorkspace) {
609                 var diff = repo.diff(repo.head());
610                 if (!diff.patches().isEmpty()) {
611                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
612                     System.err.println(&quot;&quot;);
613                     for (var patch : diff.patches()) {
614                         var path = patch.target().path().isPresent() ?
615                             patch.target().path().get() : patch.source().path().get();
616                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
617                     }
618                     System.err.println(&quot;&quot;);
619                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
620                     System.err.println(&quot;&quot;);
621                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
622                     System.err.println(&quot;&quot;);
623                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
624                     System.err.println(&quot;&quot;);
625                     System.err.println(&quot;    git stash&quot;);
626                     System.err.println(&quot;&quot;);
627                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
628                     System.exit(1);
629                 }
630             }
631 
632             var upstream = repo.upstreamFor(currentBranch);
633             if (upstream.isEmpty()) {
634                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
635                 System.err.println(&quot;&quot;);
636                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
637                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
638                 System.err.println(&quot;&quot;);
639                 System.err.println(&quot;    git publish&quot;);
640                 System.err.println(&quot;&quot;);
641                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
642                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
643                 System.err.println(&quot;&quot;);
644                 System.err.println(&quot;    git fetch &quot; + remote);
645                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
646                 System.err.println(&quot;&quot;);
647                 System.exit(1);
648             }
649 
650             var upstreamRefName = upstream.get().substring(remote.length() + 1);
651             repo.fetch(uri, upstreamRefName);
652             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
653             if (!branchCommits.isEmpty()) {
654                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
655                 System.err.println(&quot;&quot;);
656                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
657                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
658                 System.err.println(&quot;&quot;);
659                 for (var commit : branchCommits) {
660                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
661                 }
662                 System.err.println(&quot;&quot;);
663                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
664                 System.err.println(&quot;&quot;);
665                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
666                 System.err.println(&quot;&quot;);
667                 System.exit(1);
668             }
669 
670             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
671             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
672             if (commits.isEmpty()) {
673                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
674                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
675                 System.exit(1);
676             }
677 
678             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
679                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
680             );
681             if (token == null) {
682                 GitCredentials.approve(credentials);
683             }
684             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
685                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
686 
687             var project = jbsProjectFromJcheckConf(repo);
688             var issue = getIssue(currentBranch, project);
689             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
690             if (issue.isPresent()) {
691                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
692             } else if (commits.size() == 1) {
693                 var commit = commits.get(0);
694                 issue = getIssue(commit, project);
695                 if (issue.isPresent()) {
696                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
697                 } else {
698                     var message = CommitMessageParsers.v1.parse(commit.message());
699                     Files.writeString(file, message.title() + &quot;\n&quot;);
700                     if (!message.summaries().isEmpty()) {
701                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
702                     }
703                     if (!message.additional().isEmpty()) {
704                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
705                     }
706                 }
707             } else {
708                 Files.write(file, List.of(&quot;&quot;));
709             }
710             Files.write(file, List.of(
711                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
712                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
713                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
714                 &quot;# the subject from the body.&quot;,
715                 &quot;#&quot;,
716                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
717                 ),
718                 StandardOpenOption.APPEND
719             );
720             for (var commit : commits) {
721                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
722                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
723             }
724             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
725             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
726             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
727             var success = spawnEditor(repo, file);
728             if (!success) {
729                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
730                 System.exit(1);
731             }
732             var lines = Files.readAllLines(file)
733                              .stream()
734                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
735                              .collect(Collectors.toList());
736             var isEmpty = lines.stream().allMatch(String::isEmpty);
737             if (isEmpty) {
738                 System.err.println(&quot;error: no message present, aborting&quot;);
739                 System.exit(1);
740             }
741 
742             var title = lines.get(0);
743             List&lt;String&gt; body = null;
744             if (lines.size() &gt; 1) {
745                 body = lines.subList(1, lines.size())
746                             .stream()
747                             .dropWhile(String::isEmpty)
748                             .collect(Collectors.toList());
749             } else {
750                 body = Collections.emptyList();
751             }
752 
753             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
754             if (arguments.contains(&quot;assignees&quot;)) {
755                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
756                 var assignees = usernames.stream()
757                                          .map(u -&gt; host.user(u))
758                                          .collect(Collectors.toList());
759                 pr.setAssignees(assignees);
760             }
761             System.out.println(pr.webUrl().toString());
762             Files.deleteIfExists(file);
763         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
764             var pr = getPullRequest(uri, repo, host, arguments.at(1));
765 
766             if (action.equals(&quot;integrate&quot;)) {
767                 pr.addComment(&quot;/integrate&quot;);
768             } else if (action.equals(&quot;test&quot;)) {
769                 pr.addComment(&quot;/test&quot;);
770             } else if (action.equals(&quot;approve&quot;)) {
771                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
772             } else {
773                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
774             }
775         } else if (action.equals(&quot;list&quot;)) {
776             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
777             var prs = remoteRepo.pullRequests();
778             var ids = new ArrayList&lt;String&gt;();
779             var titles = new ArrayList&lt;String&gt;();
780             var authors = new ArrayList&lt;String&gt;();
781             var assignees = new ArrayList&lt;String&gt;();
782             var labels = new ArrayList&lt;String&gt;();
783 
784             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
785                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
786                 Set.of();
787             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
788                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
789                 Set.of();
790             var filterLabels = arguments.contains(&quot;labels&quot;) ?
791                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
792                 Set.of();
793 
794             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
795             var columnValues = Map.of(defaultColumns.get(0), ids,
796                                       defaultColumns.get(1), titles,
797                                       defaultColumns.get(2), authors,
798                                       defaultColumns.get(3), assignees,
799                                       defaultColumns.get(4), labels);
800             var columns = arguments.contains(&quot;columns&quot;) ?
801                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
802                 defaultColumns;
803             if (columns != defaultColumns) {
804                 for (var column : columns) {
805                     if (!defaultColumns.contains(column)) {
806                         System.err.println(&quot;error: unknown column: &quot; + column);
807                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
808                         System.exit(1);
809                     }
810                 }
811             }
812 
813             for (var pr : prs) {
814                 var prAuthor = pr.author().userName();
815                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
816                     continue;
817                 }
818 
819                 var prAssignees = pr.assignees().stream()
820                                     .map(HostUser::userName)
821                                     .collect(Collectors.toSet());
822                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
823                     continue;
824                 }
825 
826                 var prLabels = new HashSet&lt;&gt;(pr.labels());
827                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
828                     continue;
829                 }
830 
831                 ids.add(pr.id());
832                 titles.add(pr.title());
833                 authors.add(prAuthor);
834                 assignees.add(String.join(&quot;,&quot;, prAssignees));
835                 labels.add(String.join(&quot;,&quot;, prLabels));
836             }
837 
838 
839             String fmt = &quot;&quot;;
840             for (var column : columns.subList(0, columns.size() - 1)) {
841                 var values = columnValues.get(column);
842                 var n = Math.max(column.length(), longest(values));
843                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
844             }
845             fmt += &quot;%s\n&quot;;
846 
847             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
848                 var upperCase = columns.stream()
849                                        .map(String::toUpperCase)
850                                        .collect(Collectors.toList());
851                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
852             }
853             for (var i = 0; i &lt; ids.size(); i++) {
854                 final int n = i;
855                 var row = columns.stream()
856                                  .map(columnValues::get)
857                                  .map(values -&gt; values.get(n))
858                                  .collect(Collectors.toList());
859                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
860             }
861         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
862             var prId = arguments.at(1);
863             if (!prId.isPresent()) {
864                 exit(&quot;error: missing pull request identifier&quot;);
865             }
866 
867             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
868             var pr = remoteRepo.pullRequest(prId.asString());
869             var repoUrl = remoteRepo.webUrl();
870             var prHeadRef = pr.sourceRef();
871             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
872             if (isHgGit) {
873                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
874                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
875 
876                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
877                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
878                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
879 
880                     if (action.equals(&quot;show&quot;)) {
881                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
882                     } else {
883                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
884                         hgImport(patch);
885                         Files.delete(patch);
886                     }
887                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
888                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
889                     var hgGitBranches = hgGitRepo.branches();
890                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
891                         hgGitRepo.delete(new Branch(hgGitRef));
892                     }
893                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
894                     gimport();
895                     var hgFetchHead = repo.resolve(hgGitRef).get();
896 
897                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
898                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
899                     } else if (action.equals(&quot;checkout&quot;)) {
900                         repo.checkout(hgFetchHead);
901                         if (arguments.contains(&quot;branch&quot;)) {
902                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
903                         }
904                     }
905                 } else {
906                     exit(&quot;Unexpected action: &quot; + action);
907                 }
908 
909                 return;
910             }
911 
912             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
913             if (action.equals(&quot;fetch&quot;)) {
914                 if (arguments.contains(&quot;branch&quot;)) {
915                     var branchName = arguments.get(&quot;branch&quot;).asString();
916                     repo.branch(fetchHead, branchName);
917                 } else {
918                     System.out.println(fetchHead.hex());
919                 }
920             } else if (action.equals(&quot;checkout&quot;)) {
921                 if (arguments.contains(&quot;branch&quot;)) {
922                     var branchName = arguments.get(&quot;branch&quot;).asString();
923                     var branch = repo.branch(fetchHead, branchName);
924                     repo.checkout(branch, false);
925                 } else {
926                     repo.checkout(fetchHead, false);
927                 }
928             } else if (action.equals(&quot;show&quot;)) {
929                 show(pr.targetRef(), fetchHead);
930             } else if (action.equals(&quot;apply&quot;)) {
931                 var patch = diff(pr.targetRef(), fetchHead);
932                 apply(patch);
933                 Files.deleteIfExists(patch);
934             }
935         } else if (action.equals(&quot;close&quot;)) {
936             var prId = arguments.at(1);
937             if (!prId.isPresent()) {
938                 exit(&quot;error: missing pull request identifier&quot;);
939             }
940 
941             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
942             var pr = remoteRepo.pullRequest(prId.asString());
943             pr.setState(PullRequest.State.CLOSED);
944         } else if (action.equals(&quot;update&quot;)) {
945             var prId = arguments.at(1);
946             if (!prId.isPresent()) {
947                 exit(&quot;error: missing pull request identifier&quot;);
948             }
949 
950             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
951             var pr = remoteRepo.pullRequest(prId.asString());
952             if (arguments.contains(&quot;assignees&quot;)) {
953                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
954                 var assignees = usernames.stream()
955                     .map(u -&gt; host.user(u))
956                     .collect(Collectors.toList());
957                 pr.setAssignees(assignees);
958             }
959         } else {
960             exit(&quot;error: unexpected action: &quot; + action);
961         }
962     }
963 }
    </pre>
  </body>
</html>