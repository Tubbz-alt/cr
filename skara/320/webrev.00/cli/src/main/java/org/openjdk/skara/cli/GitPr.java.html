<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.issuetracker.IssueTracker;
 29 import org.openjdk.skara.issuetracker.Issue;
 30 import org.openjdk.skara.jcheck.JCheckConfiguration;
 31 import org.openjdk.skara.proxy.HttpProxy;
 32 import org.openjdk.skara.vcs.*;
 33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 34 
 35 import java.io.IOException;
 36 import java.net.URI;
 37 import java.nio.charset.StandardCharsets;
 38 import java.nio.file.*;
 39 import java.util.*;
 40 import java.util.regex.Pattern;
 41 import java.util.concurrent.TimeUnit;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Level;
 44 import java.util.stream.Collectors;
 45 
 46 public class GitPr {
 47     private static void exit(String fmt, Object...args) {
 48         System.err.println(String.format(fmt, args));
 49         System.exit(1);
 50     }
 51 
 52     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 53         return () -&gt; {
 54             exit(fmt, args);
 55             return null;
 56         };
 57     }
 58 
 59     private static String format(Issue issue) {
 60         var parts = issue.id().split(&quot;-&quot;);
 61         var id = parts.length == 2 ? parts[1] : issue.id();
 62         return id + &quot;: &quot; + issue.title();
 63     }
 64 
 65     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 66         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 67             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 68         ));
 69 
 70         return conf.general().jbs();
 71     }
 72 
 73     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 74         var message = CommitMessageParsers.v1.parse(commit.message());
 75         var issues = message.issues();
 76         if (issues.isEmpty()) {
 77             return getIssue(message.title(), project);
 78         } else if (issues.size() == 1) {
 79             var issue = issues.get(0);
 80             return getIssue(issue.id(), project);
 81         }
 82         return Optional.empty();
 83     }
 84 
 85     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 86         return getIssue(b.name(), project);
 87     }
 88 
 89     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 90         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
 91         var m = issueIdPattern.matcher(s);
 92         if (m.matches()) {
 93             var id = m.group(2);
 94             if (project == null) {
 95                 project = m.group(1);
 96             }
 97             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 98             return issueTracker.project(project).issue(id);
 99         }
100 
101         return Optional.empty();
102     }
103 
104     private static void await(Process p) throws IOException {
105         try {
106             var res = p.waitFor();
107             if (res != 0) {
108                 throw new IOException(&quot;Unexpected exit code &quot; + res);
109             }
110         } catch (InterruptedException e) {
111             throw new IOException(e);
112         }
113     }
114 
115     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
116         String editor = null;
117         var lines = repo.config(&quot;core.editor&quot;);
118         if (lines.size() == 1) {
119             editor = lines.get(0);
120         }
121         if (editor == null) {
122             editor = System.getenv(&quot;GIT_EDITOR&quot;);
123         }
124         if (editor == null) {
125             editor = System.getenv(&quot;EDITOR&quot;);
126         }
127         if (editor == null) {
128             editor = System.getenv(&quot;VISUAL&quot;);
129         }
130         if (editor == null) {
131             editor = &quot;vi&quot;;
132         }
133 
134         var pb = new ProcessBuilder(editor, file.toString());
135         pb.inheritIO();
136         var p = pb.start();
137         try {
138             return p.waitFor() == 0;
139         } catch (InterruptedException e) {
140             throw new IOException(e);
141         }
142     }
143 
144     private static String projectName(URI uri) {
145         var name = uri.getPath().toString().substring(1);
146         if (name.endsWith(&quot;.git&quot;)) {
147             name = name.substring(0, name.length() - &quot;.git&quot;.length());
148         }
149         return name;
150     }
151 
152     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
153         HostedRepository targetRepo = null;
154 
155         try {
156             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
157             targetRepo = host.repository(projectName(upstream)).orElse(null);
158         } catch (IOException e) {
159             // do nothing
160         }
161 
162         if (targetRepo == null) {
163             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
164                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
165             );
166             var parentRepo = remoteRepo.parent();
167             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
168         }
169 
170         return targetRepo;
171     }
172 
173     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
174         if (!prId.isPresent()) {
175             exit(&quot;error: missing pull request identifier&quot;);
176         }
177 
178         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
179         if (pr == null) {
180             exit(&quot;error: could not fetch PR information&quot;);
181         }
182 
183         return pr;
184     }
185 
186     private static void show(String ref, Hash hash) throws IOException {
187         show(ref, hash, null);
188     }
189     private static void show(String ref, Hash hash, Path dir) throws IOException {
190         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
191                                                    &quot;--patch&quot;,
192                                                    &quot;--find-renames=50%&quot;,
193                                                    &quot;--find-copies=50%&quot;,
194                                                    &quot;--find-copies-harder&quot;,
195                                                    &quot;--abbrev&quot;,
196                                                    ref + &quot;...&quot; + hash.hex());
197         if (dir != null) {
198             pb.directory(dir.toFile());
199         }
200         pb.inheritIO();
201         await(pb.start());
202     }
203 
204     private static void gimport() throws IOException {
205         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
206         pb.inheritIO();
207         await(pb.start());
208     }
209 
210     private static void hgImport(Path patch) throws IOException {
211         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
212         pb.inheritIO();
213         await(pb.start());
214     }
215 
216     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
217         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
218         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
219         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
220         var p = pb.start();
221         var bytes = p.getInputStream().readAllBytes();
222         var exited = p.waitFor(1, TimeUnit.MINUTES);
223         var exitValue = p.exitValue();
224         if (!exited || exitValue != 0) {
225             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
226         }
227 
228         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
229     }
230 
231     private static String hgResolve(String ref) throws IOException, InterruptedException {
232         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
233         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
234         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
235         var p = pb.start();
236         var bytes = p.getInputStream().readAllBytes();
237         var exited = p.waitFor(1, TimeUnit.MINUTES);
238         var exitValue = p.exitValue();
239         if (!exited || exitValue != 0) {
240             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
241         }
242 
243         return new String(bytes, StandardCharsets.UTF_8);
244     }
245 
246     private static Path diff(String ref, Hash hash) throws IOException {
247         return diff(ref, hash, null);
248     }
249 
250     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
251         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
252         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
253                                                    &quot;--patch&quot;,
254                                                    &quot;--find-renames=50%&quot;,
255                                                    &quot;--find-copies=50%&quot;,
256                                                    &quot;--find-copies-harder&quot;,
257                                                    &quot;--abbrev&quot;,
258                                                    ref + &quot;...&quot; + hash.hex());
259         if (dir != null) {
260             pb.directory(dir.toFile());
261         }
262         pb.redirectOutput(patch.toFile());
263         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
264         await(pb.start());
265         return patch;
266     }
267 
268     private static void apply(Path patch) throws IOException {
269         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
270         pb.inheritIO();
271         await(pb.start());
272     }
273 
274     private static int longest(List&lt;String&gt; strings) {
275         return strings.stream().mapToInt(String::length).max().orElse(0);
276     }
277 
278     public static void main(String[] args) throws IOException, InterruptedException {
279         var flags = List.of(
280             Option.shortcut(&quot;u&quot;)
281                   .fullname(&quot;username&quot;)
282                   .describe(&quot;NAME&quot;)
283                   .helptext(&quot;Username on host&quot;)
284                   .optional(),
285             Option.shortcut(&quot;r&quot;)
286                   .fullname(&quot;remote&quot;)
287                   .describe(&quot;NAME&quot;)
288                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
289                   .optional(),
290             Option.shortcut(&quot;b&quot;)
291                   .fullname(&quot;branch&quot;)
292                   .describe(&quot;NAME&quot;)
293                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
294                   .optional(),
295             Option.shortcut(&quot;&quot;)
296                   .fullname(&quot;authors&quot;)
297                   .describe(&quot;LIST&quot;)
298                   .helptext(&quot;Comma separated list of authors&quot;)
299                   .optional(),
300             Option.shortcut(&quot;&quot;)
301                   .fullname(&quot;assignees&quot;)
302                   .describe(&quot;LIST&quot;)
303                   .helptext(&quot;Comma separated list of assignees&quot;)
304                   .optional(),
305             Option.shortcut(&quot;&quot;)
306                   .fullname(&quot;labels&quot;)
307                   .describe(&quot;LIST&quot;)
308                   .helptext(&quot;Comma separated list of labels&quot;)
309                   .optional(),
310             Option.shortcut(&quot;&quot;)
311                   .fullname(&quot;columns&quot;)
312                   .describe(&quot;id,title,author,assignees,labels&quot;)
313                   .helptext(&quot;Comma separated list of columns to show&quot;)
314                   .optional(),
315             Switch.shortcut(&quot;&quot;)
316                   .fullname(&quot;no-decoration&quot;)
317                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
318                   .optional(),
319             Switch.shortcut(&quot;&quot;)
320                   .fullname(&quot;ignore-workspace&quot;)
321                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
322                   .optional(),
323             Switch.shortcut(&quot;&quot;)
324                   .fullname(&quot;ignore-local-commits&quot;)
325                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
326                   .optional(),
327             Switch.shortcut(&quot;&quot;)
328                   .fullname(&quot;publish&quot;)
329                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
330                   .optional(),
331             Switch.shortcut(&quot;&quot;)
332                   .fullname(&quot;no-token&quot;)
333                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
334                   .optional(),
335             Switch.shortcut(&quot;&quot;)
336                   .fullname(&quot;mercurial&quot;)
337                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
338                   .optional(),
339             Switch.shortcut(&quot;&quot;)
340                   .fullname(&quot;verbose&quot;)
341                   .helptext(&quot;Turn on verbose output&quot;)
342                   .optional(),
343             Switch.shortcut(&quot;&quot;)
344                   .fullname(&quot;debug&quot;)
345                   .helptext(&quot;Turn on debugging output&quot;)
346                   .optional(),
347             Switch.shortcut(&quot;&quot;)
348                   .fullname(&quot;version&quot;)
349                   .helptext(&quot;Print the version of this tool&quot;)
350                   .optional());
351 
352         var inputs = List.of(
353             Input.position(0)
354                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
355                  .singular()
356                  .required(),
357             Input.position(1)
358                  .describe(&quot;ID&quot;)
359                  .singular()
360                  .optional()
361         );
362 
363         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
364         var arguments = parser.parse(args);
365 
366         if (arguments.contains(&quot;version&quot;)) {
367             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
368             System.exit(0);
369         }
370 
371         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
372             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
373             Logging.setup(level);
374         }
375 
376         HttpProxy.setup();
377 
378         var isMercurial = arguments.contains(&quot;mercurial&quot;);
379         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
380         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
381         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
382         var remotePullPath = repo.pullPath(remote);
383         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
384         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
385         var uri = Remote.toWebURI(remotePullPath);
386         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
387         var credentials = !shouldUseToken ?
388             null :
389             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
390         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
391         var forge = credentials == null ?
392             Forge.from(forgeURI) :
393             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
394         if (forge.isEmpty()) {
395             if (!shouldUseToken) {
396                 if (arguments.contains(&quot;verbose&quot;)) {
397                     System.err.println(&quot;&quot;);
398                 }
399                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
400                 if (!arguments.contains(&quot;verbose&quot;)) {
401                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
402                     System.err.println(&quot;&quot;);
403                 }
404             }
405             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
406         }
407         var host = forge.get();
408 
409         var action = arguments.at(0).asString();
410         if (!shouldUseToken &amp;&amp;
411             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
412             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
413             System.exit(1);
414         }
415 
416         if (action.equals(&quot;create&quot;)) {
417             if (isMercurial) {
418                 var currentBookmark = repo.currentBookmark();
419                 if (!currentBookmark.isPresent()) {
420                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
421                     System.err.println(&quot;&quot;);
422                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
423                     System.err.println(&quot;&quot;);
424                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
425                     System.err.println(&quot;&quot;);
426                     System.exit(1);
427                 }
428 
429                 var bookmark = currentBookmark.get();
430                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
431                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
432                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
433                     System.err.println(&quot;&quot;);
434                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
435                     System.err.println(&quot;&quot;);
436                     System.exit(1);
437                 }
438 
439                 var tags = hgTags();
440                 var upstreams = tags.stream()
441                                     .filter(t -&gt; t.endsWith(bookmark.name()))
442                                     .collect(Collectors.toList());
443                 if (upstreams.isEmpty()) {
444                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
445                     System.err.println(&quot;&quot;);
446                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
447                     System.err.println(&quot;&quot;);
448                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
449                     System.err.println(&quot;&quot;);
450                     System.exit(1);
451                 }
452 
453                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
454                 for (var tag : tags) {
455                     tagsAndHashes.put(tag, hgResolve(tag));
456                 }
457                 var bookmarkHash = hgResolve(bookmark.name());
458                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
459                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
460                     System.err.println(&quot;&quot;);
461 
462                     if (upstreams.size() == 1) {
463                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
464                         System.err.println(&quot;&quot;);
465                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
466                         System.err.println(&quot;&quot;);
467                     } else {
468                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
469                         System.err.println(&quot;&quot;);
470                         for (var upstream : upstreams) {
471                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
472                         }
473                         System.err.println(&quot;&quot;);
474                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
475                         System.err.println(&quot;&quot;);
476                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
477                         System.err.println(&quot;&quot;);
478                     }
479                     System.exit(1);
480                 }
481 
482                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
483                 var targetHash = hgResolve(targetBranch);
484                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
485                 if (commits.isEmpty()) {
486                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
487                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
488                     System.exit(1);
489                 }
490 
491                 var diff = repo.diff(repo.head());
492                 if (!diff.patches().isEmpty()) {
493                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
494                     System.err.println(&quot;&quot;);
495                     for (var patch : diff.patches()) {
496                         var path = patch.target().path().isPresent() ?
497                             patch.target().path().get() : patch.source().path().get();
498                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
499                     }
500                     System.err.println(&quot;&quot;);
501                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
502                     System.err.println(&quot;&quot;);
503                     System.err.println(&quot;    hg commit --amend&quot;);
504                     System.err.println(&quot;    hg git-cleanup&quot;);
505                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
506                     System.err.println(&quot;    hg gimport&quot;);
507                     System.err.println(&quot;&quot;);
508                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
509                     System.err.println(&quot;&quot;);
510                     System.err.println(&quot;    hg shelve&quot;);
511                     System.err.println(&quot;&quot;);
512                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
513                     System.exit(1);
514                 }
515 
516                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
517                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
518                 );
519                 if (token == null) {
520                     GitCredentials.approve(credentials);
521                 }
522                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
523                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
524 
525                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
526                 if (commits.size() == 1) {
527                     var commit = commits.get(0);
528                     var message = CommitMessageParsers.v1.parse(commit.message());
529                     Files.writeString(file, message.title() + &quot;\n&quot;);
530                     if (!message.summaries().isEmpty()) {
531                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
532                     }
533                     if (!message.additional().isEmpty()) {
534                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
535                     }
536                 } else {
537                     Files.write(file, List.of(&quot;&quot;));
538                 }
539                 Files.write(file, List.of(
540                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
541                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
542                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
543                     &quot;# the subject from the body.&quot;,
544                     &quot;#&quot;,
545                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
546                     ),
547                     StandardOpenOption.APPEND
548                 );
549                 for (var commit : commits) {
550                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
551                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
552                 }
553                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
554                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
555                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
556                 var success = spawnEditor(repo, file);
557                 if (!success) {
558                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
559                     System.exit(1);
560                 }
561                 var lines = Files.readAllLines(file)
562                                  .stream()
563                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
564                                  .collect(Collectors.toList());
565                 var isEmpty = lines.stream().allMatch(String::isEmpty);
566                 if (isEmpty) {
567                     System.err.println(&quot;error: no message present, aborting&quot;);
568                     System.exit(1);
569                 }
570 
571                 var title = lines.get(0);
572                 List&lt;String&gt; body = null;
573                 if (lines.size() &gt; 1) {
574                     body = lines.subList(1, lines.size())
575                                 .stream()
576                                 .dropWhile(String::isEmpty)
577                                 .collect(Collectors.toList());
578                 } else {
579                     body = Collections.emptyList();
580                 }
581 
582                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
583                 if (arguments.contains(&quot;assignees&quot;)) {
584                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
585                     var assignees = usernames.stream()
586                                              .map(u -&gt; host.user(u))
587                                              .collect(Collectors.toList());
588                     pr.setAssignees(assignees);
589                 }
590                 System.out.println(pr.webUrl().toString());
591                 Files.deleteIfExists(file);
592 
593                 System.exit(0);
594             }
595             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
596                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
597                     System.exit(1);
598                     return null;
599             });
600             if (currentBranch.equals(repo.defaultBranch())) {
601                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
602                 System.err.println(&quot;&quot;);
603                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
604                 System.err.println(&quot;&quot;);
605                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
606                 System.err.println(&quot;    git branch --force master origin/master&quot;);
607                 System.err.println(&quot;&quot;);
608                 System.exit(1);
609             }
610 
611             var ignoreWorkspace = arguments.contains(&quot;ignore-workspace&quot;);
612             if (!ignoreWorkspace) {
613                 var lines = repo.config(&quot;pr.ignore-workspace&quot;);
614                 ignoreWorkspace = lines.size() == 1 &amp;&amp; lines.get(0).equals(&quot;true&quot;);
615             }
616             if (!ignoreWorkspace) {
617                 var diff = repo.diff(repo.head());
618                 if (!diff.patches().isEmpty()) {
619                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
620                     System.err.println(&quot;&quot;);
621                     for (var patch : diff.patches()) {
622                         var path = patch.target().path().isPresent() ?
623                             patch.target().path().get() : patch.source().path().get();
624                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
625                     }
626                     System.err.println(&quot;&quot;);
627                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
628                     System.err.println(&quot;&quot;);
629                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
630                     System.err.println(&quot;&quot;);
631                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
632                     System.err.println(&quot;&quot;);
633                     System.err.println(&quot;    git stash&quot;);
634                     System.err.println(&quot;&quot;);
635                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
636                     System.exit(1);
637                 }
638             }
639 
640             var upstream = repo.upstreamFor(currentBranch);
641             if (upstream.isEmpty()) {
642                 var shouldPublish = arguments.contains(&quot;publish&quot;);
643                 if (!shouldPublish) {
644                     var lines = repo.config(&quot;pr.publish&quot;);
645                     shouldPublish = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
646                 }
647                 if (shouldPublish) {
648                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
649                     upstream = repo.upstreamFor(currentBranch);
650                 } else {
651                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
652                     System.err.println(&quot;&quot;);
653                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
654                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
655                     System.err.println(&quot;&quot;);
656                     System.err.println(&quot;    git publish&quot;);
657                     System.err.println(&quot;&quot;);
658                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
659                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
660                     System.err.println(&quot;&quot;);
661                     System.err.println(&quot;    git fetch &quot; + remote);
662                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
663                     System.err.println(&quot;&quot;);
664                     System.exit(1);
665                 }
666             }
667 
668             var upstreamRefName = upstream.get().substring(remote.length() + 1);
669             repo.fetch(uri, upstreamRefName);
670 
671             var shouldIgnoreLocalCommits = arguments.contains(&quot;ignore-local-commits&quot;);
672             if (!shouldIgnoreLocalCommits) {
673                 var lines = repo.config(&quot;pr.ignore-local-commits&quot;);
674                 shouldIgnoreLocalCommits = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
675             }
676             if (!shouldIgnoreLocalCommits) {
677                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
678                 if (!branchCommits.isEmpty()) {
679                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
680                     System.err.println(&quot;&quot;);
681                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
682                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
683                     System.err.println(&quot;&quot;);
684                     for (var commit : branchCommits) {
685                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
686                     }
687                     System.err.println(&quot;&quot;);
688                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
689                     System.err.println(&quot;&quot;);
690                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
691                     System.err.println(&quot;&quot;);
692                     System.exit(1);
693                 }
694             }
695 
696             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
697             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
698             if (commits.isEmpty()) {
699                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
700                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
701                 System.exit(1);
702             }
703 
704             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
705                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
706             );
707             if (token == null) {
708                 GitCredentials.approve(credentials);
709             }
710             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
711                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
712 
713             var project = jbsProjectFromJcheckConf(repo);
714             var issue = getIssue(currentBranch, project);
715             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
716             if (issue.isPresent()) {
717                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
718             } else if (commits.size() == 1) {
719                 var commit = commits.get(0);
720                 issue = getIssue(commit, project);
721                 if (issue.isPresent()) {
722                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
723                 } else {
724                     var message = CommitMessageParsers.v1.parse(commit.message());
725                     Files.writeString(file, message.title() + &quot;\n&quot;);
726                     if (!message.summaries().isEmpty()) {
727                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
728                     }
729                     if (!message.additional().isEmpty()) {
730                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
731                     }
732                 }
733             } else {
734                 Files.write(file, List.of(&quot;&quot;));
735             }
736             Files.write(file, List.of(
737                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
738                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
739                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
740                 &quot;# the subject from the body.&quot;,
741                 &quot;#&quot;,
742                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
743                 ),
744                 StandardOpenOption.APPEND
745             );
746             for (var commit : commits) {
747                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
748                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
749             }
750             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
751             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
752             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
753             var success = spawnEditor(repo, file);
754             if (!success) {
755                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
756                 System.exit(1);
757             }
758             var lines = Files.readAllLines(file)
759                              .stream()
760                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
761                              .collect(Collectors.toList());
762             var isEmpty = lines.stream().allMatch(String::isEmpty);
763             if (isEmpty) {
764                 System.err.println(&quot;error: no message present, aborting&quot;);
765                 System.exit(1);
766             }
767 
768             var title = lines.get(0);
769             List&lt;String&gt; body = null;
770             if (lines.size() &gt; 1) {
771                 body = lines.subList(1, lines.size())
772                             .stream()
773                             .dropWhile(String::isEmpty)
774                             .collect(Collectors.toList());
775             } else {
776                 body = Collections.emptyList();
777             }
778 
779             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
780             if (arguments.contains(&quot;assignees&quot;)) {
781                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
782                 var assignees = usernames.stream()
783                                          .map(u -&gt; host.user(u))
784                                          .collect(Collectors.toList());
785                 pr.setAssignees(assignees);
786             }
787             System.out.println(pr.webUrl().toString());
788             Files.deleteIfExists(file);
789         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
790             var pr = getPullRequest(uri, repo, host, arguments.at(1));
791 
792             if (action.equals(&quot;integrate&quot;)) {
793                 pr.addComment(&quot;/integrate&quot;);
794             } else if (action.equals(&quot;test&quot;)) {
795                 pr.addComment(&quot;/test&quot;);
796             } else if (action.equals(&quot;approve&quot;)) {
797                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
798             } else {
799                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
800             }
801         } else if (action.equals(&quot;list&quot;)) {
802             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
803             var prs = remoteRepo.pullRequests();
804             var ids = new ArrayList&lt;String&gt;();
805             var titles = new ArrayList&lt;String&gt;();
806             var authors = new ArrayList&lt;String&gt;();
807             var assignees = new ArrayList&lt;String&gt;();
808             var labels = new ArrayList&lt;String&gt;();
809 
810             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
811                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
812                 Set.of();
813             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
814                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
815                 Set.of();
816             var filterLabels = arguments.contains(&quot;labels&quot;) ?
817                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
818                 Set.of();
819 
820             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
821             var columnValues = Map.of(defaultColumns.get(0), ids,
822                                       defaultColumns.get(1), titles,
823                                       defaultColumns.get(2), authors,
824                                       defaultColumns.get(3), assignees,
825                                       defaultColumns.get(4), labels);
826             var columns = arguments.contains(&quot;columns&quot;) ?
827                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
828                 defaultColumns;
829             if (columns != defaultColumns) {
830                 for (var column : columns) {
831                     if (!defaultColumns.contains(column)) {
832                         System.err.println(&quot;error: unknown column: &quot; + column);
833                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
834                         System.exit(1);
835                     }
836                 }
837             }
838 
839             for (var pr : prs) {
840                 var prAuthor = pr.author().userName();
841                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
842                     continue;
843                 }
844 
845                 var prAssignees = pr.assignees().stream()
846                                     .map(HostUser::userName)
847                                     .collect(Collectors.toSet());
848                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
849                     continue;
850                 }
851 
852                 var prLabels = new HashSet&lt;&gt;(pr.labels());
853                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
854                     continue;
855                 }
856 
857                 ids.add(pr.id());
858                 titles.add(pr.title());
859                 authors.add(prAuthor);
860                 assignees.add(String.join(&quot;,&quot;, prAssignees));
861                 labels.add(String.join(&quot;,&quot;, prLabels));
862             }
863 
864 
865             String fmt = &quot;&quot;;
866             for (var column : columns.subList(0, columns.size() - 1)) {
867                 var values = columnValues.get(column);
868                 var n = Math.max(column.length(), longest(values));
869                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
870             }
871             fmt += &quot;%s\n&quot;;
872 
873             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
874                 var upperCase = columns.stream()
875                                        .map(String::toUpperCase)
876                                        .collect(Collectors.toList());
877                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
878             }
879             for (var i = 0; i &lt; ids.size(); i++) {
880                 final int n = i;
881                 var row = columns.stream()
882                                  .map(columnValues::get)
883                                  .map(values -&gt; values.get(n))
884                                  .collect(Collectors.toList());
885                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
886             }
887         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
888             var prId = arguments.at(1);
889             if (!prId.isPresent()) {
890                 exit(&quot;error: missing pull request identifier&quot;);
891             }
892 
893             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
894             var pr = remoteRepo.pullRequest(prId.asString());
895             var repoUrl = remoteRepo.webUrl();
896             var prHeadRef = pr.sourceRef();
897             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
898             if (isHgGit) {
899                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
900                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
901 
902                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
903                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
904                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
905 
906                     if (action.equals(&quot;show&quot;)) {
907                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
908                     } else {
909                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
910                         hgImport(patch);
911                         Files.delete(patch);
912                     }
913                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
914                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
915                     var hgGitBranches = hgGitRepo.branches();
916                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
917                         hgGitRepo.delete(new Branch(hgGitRef));
918                     }
919                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
920                     gimport();
921                     var hgFetchHead = repo.resolve(hgGitRef).get();
922 
923                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
924                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
925                     } else if (action.equals(&quot;checkout&quot;)) {
926                         repo.checkout(hgFetchHead);
927                         if (arguments.contains(&quot;branch&quot;)) {
928                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
929                         }
930                     }
931                 } else {
932                     exit(&quot;Unexpected action: &quot; + action);
933                 }
934 
935                 return;
936             }
937 
938             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
939             if (action.equals(&quot;fetch&quot;)) {
940                 if (arguments.contains(&quot;branch&quot;)) {
941                     var branchName = arguments.get(&quot;branch&quot;).asString();
942                     repo.branch(fetchHead, branchName);
943                 } else {
944                     System.out.println(fetchHead.hex());
945                 }
946             } else if (action.equals(&quot;checkout&quot;)) {
947                 if (arguments.contains(&quot;branch&quot;)) {
948                     var branchName = arguments.get(&quot;branch&quot;).asString();
949                     var branch = repo.branch(fetchHead, branchName);
950                     repo.checkout(branch, false);
951                 } else {
952                     repo.checkout(fetchHead, false);
953                 }
954             } else if (action.equals(&quot;show&quot;)) {
955                 show(pr.targetRef(), fetchHead);
956             } else if (action.equals(&quot;apply&quot;)) {
957                 var patch = diff(pr.targetRef(), fetchHead);
958                 apply(patch);
959                 Files.deleteIfExists(patch);
960             }
961         } else if (action.equals(&quot;close&quot;)) {
962             var prId = arguments.at(1);
963             if (!prId.isPresent()) {
964                 exit(&quot;error: missing pull request identifier&quot;);
965             }
966 
967             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
968             var pr = remoteRepo.pullRequest(prId.asString());
969             pr.setState(PullRequest.State.CLOSED);
970         } else if (action.equals(&quot;update&quot;)) {
971             var prId = arguments.at(1);
972             if (!prId.isPresent()) {
973                 exit(&quot;error: missing pull request identifier&quot;);
974             }
975 
976             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
977             var pr = remoteRepo.pullRequest(prId.asString());
978             if (arguments.contains(&quot;assignees&quot;)) {
979                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
980                 var assignees = usernames.stream()
981                     .map(u -&gt; host.user(u))
982                     .collect(Collectors.toList());
983                 pr.setAssignees(assignees);
984             }
985         } else {
986             exit(&quot;error: unexpected action: &quot; + action);
987         }
988     }
989 }
    </pre>
  </body>
</html>