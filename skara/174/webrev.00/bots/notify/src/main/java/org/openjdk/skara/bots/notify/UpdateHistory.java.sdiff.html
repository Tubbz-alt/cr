<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JNotifyBot.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 
 28 import java.nio.file.Path;
 29 import java.util.*;
 30 import java.util.stream.*;
 31 
 32 class UpdateHistory {
 33 
 34     private final Storage&lt;Tag&gt; tagStorage;
 35     private final Storage&lt;ResolvedBranch&gt; branchStorage;
 36 
 37     private Map&lt;Branch, Hash&gt; branches;
 38     private Set&lt;Tag&gt; tags;
 39 
 40     private Set&lt;ResolvedBranch&gt; loadBranches(String current) {
 41         return current.lines()
 42                       .map(line -&gt; line.split(&quot; &quot;))
 43                       .map(entry -&gt; new ResolvedBranch(new Branch(entry[0]), new Hash(entry[1])))
 44                       .collect(Collectors.toSet());
 45     }
 46 
<span class="line-modified"> 47     private String serializeBranches(ResolvedBranch added, Set&lt;ResolvedBranch&gt; existing) {</span>
 48         var updatedBranches = existing.stream()
<span class="line-modified"> 49                 .collect(Collectors.toMap(ResolvedBranch::branch,</span>
<span class="line-modified"> 50                                           ResolvedBranch::hash));</span>
<span class="line-modified"> 51         updatedBranches.put(added.branch(), added.hash());</span>
 52         return updatedBranches.entrySet().stream()
 53                               .map(entry -&gt; entry.getKey().toString() + &quot; &quot; + entry.getValue().toString())
 54                               .sorted()
 55                               .collect(Collectors.joining(&quot;\n&quot;));
 56     }
 57 
 58     private Set&lt;Tag&gt; loadTags(String current) {
 59         return current.lines()
 60                       .map(Tag::new)
 61                       .collect(Collectors.toSet());
 62     }
 63 
<span class="line-modified"> 64     private String serializeTags(Tag added, Set&lt;Tag&gt; existing) {</span>
 65         return Stream.concat(existing.stream(),
<span class="line-modified"> 66                              Stream.of(added))</span>
 67                      .map(Tag::toString)
 68                      .sorted()
 69                      .collect(Collectors.joining(&quot;\n&quot;));
 70     }
 71 
 72     private Set&lt;Tag&gt; currentTags() {
 73         return tagStorage.current();
 74     }
 75 
 76     private Map&lt;Branch, Hash&gt; currentBranchHashes() {
 77         return branchStorage.current().stream()
 78                 .collect(Collectors.toMap(ResolvedBranch::branch, ResolvedBranch::hash));
 79     }
 80 
 81     private UpdateHistory(StorageBuilder&lt;Tag&gt; tagStorageBuilder, Path tagLocation, StorageBuilder&lt;ResolvedBranch&gt; branchStorageBuilder, Path branchLocation) {
 82         this.tagStorage = tagStorageBuilder
 83                 .serializer(this::serializeTags)
 84                 .deserializer(this::loadTags)
 85                 .materialize(tagLocation);
 86 
 87         this.branchStorage = branchStorageBuilder
 88                 .serializer(this::serializeBranches)
 89                 .deserializer(this::loadBranches)
 90                 .materialize(branchLocation);
 91 
 92         tags = currentTags();
 93         branches = currentBranchHashes();
 94     }
 95 
 96     static UpdateHistory create(StorageBuilder&lt;Tag&gt; tagStorageBuilder, Path tagLocation, StorageBuilder&lt;ResolvedBranch&gt; branchStorageBuilder, Path branchLocation) {
 97         return new UpdateHistory(tagStorageBuilder, tagLocation, branchStorageBuilder, branchLocation);
 98     }
 99 
<span class="line-modified">100     void addTag(Tag tag) {</span>
<span class="line-modified">101         tagStorage.put(tag);</span>
102         var newTags = currentTags();
103 
<span class="line-modified">104         if (tags != null) {</span>
<span class="line-modified">105             for (var existingTag : tags) {</span>
106                 if (!newTags.contains(existingTag)) {
107                     throw new RuntimeException(&quot;Tag &#39;&quot; + existingTag + &quot;&#39; has been removed&quot;);
108                 }
109             }
110         }
111 
112         tags = currentTags();
113     }
114 
115     boolean hasTag(Tag tag) {
116         return tags.contains(tag);
117     }
118 
119     void setBranchHash(Branch branch, Hash hash) {
120         var entry = new ResolvedBranch(branch, hash);
121 
122         branchStorage.put(entry);
123         var newBranchHashes = currentBranchHashes();
124 
125         // Sanity check
</pre>
</td>
<td>
<hr />
<pre>
 27 
 28 import java.nio.file.Path;
 29 import java.util.*;
 30 import java.util.stream.*;
 31 
 32 class UpdateHistory {
 33 
 34     private final Storage&lt;Tag&gt; tagStorage;
 35     private final Storage&lt;ResolvedBranch&gt; branchStorage;
 36 
 37     private Map&lt;Branch, Hash&gt; branches;
 38     private Set&lt;Tag&gt; tags;
 39 
 40     private Set&lt;ResolvedBranch&gt; loadBranches(String current) {
 41         return current.lines()
 42                       .map(line -&gt; line.split(&quot; &quot;))
 43                       .map(entry -&gt; new ResolvedBranch(new Branch(entry[0]), new Hash(entry[1])))
 44                       .collect(Collectors.toSet());
 45     }
 46 
<span class="line-modified"> 47     private String serializeBranches(Collection&lt;ResolvedBranch&gt; added, Set&lt;ResolvedBranch&gt; existing) {</span>
 48         var updatedBranches = existing.stream()
<span class="line-modified"> 49                                       .collect(Collectors.toMap(ResolvedBranch::branch,</span>
<span class="line-modified"> 50                                                                 ResolvedBranch::hash));</span>
<span class="line-modified"> 51         added.forEach(a -&gt; updatedBranches.put(a.branch(), a.hash()));</span>
 52         return updatedBranches.entrySet().stream()
 53                               .map(entry -&gt; entry.getKey().toString() + &quot; &quot; + entry.getValue().toString())
 54                               .sorted()
 55                               .collect(Collectors.joining(&quot;\n&quot;));
 56     }
 57 
 58     private Set&lt;Tag&gt; loadTags(String current) {
 59         return current.lines()
 60                       .map(Tag::new)
 61                       .collect(Collectors.toSet());
 62     }
 63 
<span class="line-modified"> 64     private String serializeTags(Collection&lt;Tag&gt; added, Set&lt;Tag&gt; existing) {</span>
 65         return Stream.concat(existing.stream(),
<span class="line-modified"> 66                              added.stream())</span>
 67                      .map(Tag::toString)
 68                      .sorted()
 69                      .collect(Collectors.joining(&quot;\n&quot;));
 70     }
 71 
 72     private Set&lt;Tag&gt; currentTags() {
 73         return tagStorage.current();
 74     }
 75 
 76     private Map&lt;Branch, Hash&gt; currentBranchHashes() {
 77         return branchStorage.current().stream()
 78                 .collect(Collectors.toMap(ResolvedBranch::branch, ResolvedBranch::hash));
 79     }
 80 
 81     private UpdateHistory(StorageBuilder&lt;Tag&gt; tagStorageBuilder, Path tagLocation, StorageBuilder&lt;ResolvedBranch&gt; branchStorageBuilder, Path branchLocation) {
 82         this.tagStorage = tagStorageBuilder
 83                 .serializer(this::serializeTags)
 84                 .deserializer(this::loadTags)
 85                 .materialize(tagLocation);
 86 
 87         this.branchStorage = branchStorageBuilder
 88                 .serializer(this::serializeBranches)
 89                 .deserializer(this::loadBranches)
 90                 .materialize(branchLocation);
 91 
 92         tags = currentTags();
 93         branches = currentBranchHashes();
 94     }
 95 
 96     static UpdateHistory create(StorageBuilder&lt;Tag&gt; tagStorageBuilder, Path tagLocation, StorageBuilder&lt;ResolvedBranch&gt; branchStorageBuilder, Path branchLocation) {
 97         return new UpdateHistory(tagStorageBuilder, tagLocation, branchStorageBuilder, branchLocation);
 98     }
 99 
<span class="line-modified">100     void addTags(Collection&lt;Tag&gt; addedTags) {</span>
<span class="line-modified">101         tagStorage.put(addedTags);</span>
102         var newTags = currentTags();
103 
<span class="line-modified">104         if (addedTags != null) {</span>
<span class="line-modified">105             for (var existingTag : addedTags) {</span>
106                 if (!newTags.contains(existingTag)) {
107                     throw new RuntimeException(&quot;Tag &#39;&quot; + existingTag + &quot;&#39; has been removed&quot;);
108                 }
109             }
110         }
111 
112         tags = currentTags();
113     }
114 
115     boolean hasTag(Tag tag) {
116         return tags.contains(tag);
117     }
118 
119     void setBranchHash(Branch branch, Hash hash) {
120         var entry = new ResolvedBranch(branch, hash);
121 
122         branchStorage.put(entry);
123         var newBranchHashes = currentBranchHashes();
124 
125         // Sanity check
</pre>
</td>
</tr>
</table>
<center><a href="JNotifyBot.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>