<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UpdateHistory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 96             if (candidate.isEmpty()) {
 97                 return Optional.empty();
 98             }
 99             tag = candidate.get();
100             if (!allJdkTags.contains(tag)) {
101                 continue;
102             }
103             return Optional.of(tag);
104         }
105     }
106 
107     private void handleTags(Repository localRepo, UpdateHistory history) throws IOException {
108         var tags = localRepo.tags();
109         var newTags = tags.stream()
110                           .filter(tag -&gt; !history.hasTag(tag))
111                           .collect(Collectors.toList());
112 
113         if (tags.size() == newTags.size()) {
114             if (tags.size() &gt; 0) {
115                 log.warning(&quot;No previous tag history found - ignoring all current tags&quot;);
<span class="line-modified">116                 tags.forEach(history::addTag);</span>
117             }
118             return;
119         }
120 
121         var allJdkTags = tags.stream()
122                              .map(OpenJDKTag::create)
123                              .filter(Optional::isPresent)
124                              .map(Optional::get)
125                              .collect(Collectors.toSet());
126         var newJdkTags = newTags.stream()
127                              .map(OpenJDKTag::create)
128                              .filter(Optional::isPresent)
129                              .map(Optional::get)
130                              .sorted(Comparator.comparingInt(OpenJDKTag::buildNum))
131                              .collect(Collectors.toList());
132 
133         for (var tag : newJdkTags) {
134             var previous = existingPrevious(tag, allJdkTags);
135             if (previous.isEmpty()) {
136                 log.warning(&quot;No previous tag found for &#39;&quot; + tag.tag() + &quot;&#39; - ignoring&quot;);
137                 continue;
138             }
139             var commits = localRepo.commits(previous.get().tag() + &quot;..&quot; + tag.tag()).asList();
140             if (commits.size() == 0) {
141                 continue;
142             }
143 
144             // Update the history first - if there is a problem here we don&#39;t want to send out multiple updates
<span class="line-modified">145             history.addTag(tag.tag());</span>
146 
147             Collections.reverse(commits);
148             for (var updater : updaters) {
149                 updater.handleTagCommits(repository, commits, tag);
150             }
151         }
152     }
153 
154     @Override
155     public void run(Path scratchPath) {
156         var sanitizedUrl = URLEncoder.encode(repository.getWebUrl().toString(), StandardCharsets.UTF_8);
157         var path = storagePath.resolve(sanitizedUrl);
158         var historyPath = scratchPath.resolve(&quot;notify&quot;).resolve(&quot;history&quot;);
159 
160         try {
161             var localRepo = Repository.materialize(path, repository.getUrl(), &quot;master&quot;, false);
162             var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve(&quot;tags&quot;), branchStorageBuilder, historyPath.resolve(&quot;branches&quot;));
163             handleTags(localRepo, history);
164 
165             for (var branch : branches) {
</pre>
</td>
<td>
<hr />
<pre>
 96             if (candidate.isEmpty()) {
 97                 return Optional.empty();
 98             }
 99             tag = candidate.get();
100             if (!allJdkTags.contains(tag)) {
101                 continue;
102             }
103             return Optional.of(tag);
104         }
105     }
106 
107     private void handleTags(Repository localRepo, UpdateHistory history) throws IOException {
108         var tags = localRepo.tags();
109         var newTags = tags.stream()
110                           .filter(tag -&gt; !history.hasTag(tag))
111                           .collect(Collectors.toList());
112 
113         if (tags.size() == newTags.size()) {
114             if (tags.size() &gt; 0) {
115                 log.warning(&quot;No previous tag history found - ignoring all current tags&quot;);
<span class="line-modified">116                 history.addTags(tags);</span>
117             }
118             return;
119         }
120 
121         var allJdkTags = tags.stream()
122                              .map(OpenJDKTag::create)
123                              .filter(Optional::isPresent)
124                              .map(Optional::get)
125                              .collect(Collectors.toSet());
126         var newJdkTags = newTags.stream()
127                              .map(OpenJDKTag::create)
128                              .filter(Optional::isPresent)
129                              .map(Optional::get)
130                              .sorted(Comparator.comparingInt(OpenJDKTag::buildNum))
131                              .collect(Collectors.toList());
132 
133         for (var tag : newJdkTags) {
134             var previous = existingPrevious(tag, allJdkTags);
135             if (previous.isEmpty()) {
136                 log.warning(&quot;No previous tag found for &#39;&quot; + tag.tag() + &quot;&#39; - ignoring&quot;);
137                 continue;
138             }
139             var commits = localRepo.commits(previous.get().tag() + &quot;..&quot; + tag.tag()).asList();
140             if (commits.size() == 0) {
141                 continue;
142             }
143 
144             // Update the history first - if there is a problem here we don&#39;t want to send out multiple updates
<span class="line-modified">145             history.addTags(List.of(tag.tag()));</span>
146 
147             Collections.reverse(commits);
148             for (var updater : updaters) {
149                 updater.handleTagCommits(repository, commits, tag);
150             }
151         }
152     }
153 
154     @Override
155     public void run(Path scratchPath) {
156         var sanitizedUrl = URLEncoder.encode(repository.getWebUrl().toString(), StandardCharsets.UTF_8);
157         var path = storagePath.resolve(sanitizedUrl);
158         var historyPath = scratchPath.resolve(&quot;notify&quot;).resolve(&quot;history&quot;);
159 
160         try {
161             var localRepo = Repository.materialize(path, repository.getUrl(), &quot;master&quot;, false);
162             var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve(&quot;tags&quot;), branchStorageBuilder, historyPath.resolve(&quot;branches&quot;));
163             handleTags(localRepo, history);
164 
165             for (var branch : branches) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UpdateHistory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>