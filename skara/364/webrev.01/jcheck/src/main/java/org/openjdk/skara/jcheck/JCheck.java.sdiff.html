<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/src/main/java/org/openjdk/skara/test/CheckableRepository.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 import org.openjdk.skara.jcheck.iterators.*;
 27 import org.openjdk.skara.vcs.*;
 28 import org.openjdk.skara.vcs.openjdk.CommitMessageParser;
 29 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;

 46     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 47 
 48     private JCheckConfiguration cachedConfiguration = null;
 49 
 50     JCheck(ReadOnlyRepository repository,
 51            Census census,
 52            CommitMessageParser parser,
 53            String revisionRange,
 54            Pattern allowedBranches,
 55            Pattern allowedTags,
 56            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified"> 57            Set&lt;Hash&gt; blacklist) throws IOException {</span>

 58         this.repository = repository;
 59         this.census = census;
 60         this.parser = parser;
 61         this.revisionRange = revisionRange;
 62         this.whitelist = whitelist;

 63 
 64         var utils = new Utilities();
 65         commitChecks = List.of(
 66             new AuthorCheck(),
 67             new CommitterCheck(census),
 68             new WhitespaceCheck(),
 69             new MergeMessageCheck(),
 70             new HgTagCommitCheck(utils),
 71             new DuplicateIssuesCheck(repository),
 72             new ReviewersCheck(census, utils),
 73             new MessageCheck(utils),
 74             new IssuesCheck(utils),
 75             new ExecutableCheck(),
 76             new BlacklistCheck(blacklist)
 77         );
 78         repositoryChecks = List.of(
 79             new BranchesCheck(allowedBranches),
 80             new TagsCheck(allowedTags)
 81         );
 82     }
 83 
<span class="line-modified"> 84     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h) {</span>
 85         try {
<span class="line-modified"> 86             var content = r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList());</span>

 87             if (content.size() == 0) {
 88                 return Optional.empty();
 89             }
 90             return Optional.of(JCheckConfiguration.parse(content));
 91         } catch (IOException e) {
 92             throw new UncheckedIOException(e);
 93         }
 94     }
 95 
 96     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
 97         var confPath = Paths.get(&quot;.jcheck/conf&quot;);
 98         var changesConfiguration = c.parentDiffs()
 99                                     .stream()
100                                     .map(Diff::patches)
101                                     .flatMap(List::stream)
102                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||
103                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));
104 
105 
106         if (changesConfiguration || cachedConfiguration == null) {
<span class="line-modified">107             var confAtCommit = parseConfiguration(repository, c.hash());</span>
108             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);
109             return confAtCommit;
110         } else {
111             return Optional.of(cachedConfiguration);
112         }
113     }
114 
115     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
116         log.fine(&quot;Checking: &quot; + commit.hash().hex());
117         var configuration = getConfigurationFor(commit);
118         if (!configuration.isPresent()) {
119             log.finer(&quot;No .jcheck/conf present for &quot; + commit.hash().hex());
120             return Collections.emptyIterator();
121         }
122 
123         var conf = configuration.get();
124         var message = parser.parse(commit);
125         var enabled = conf.checks().enabled(commitChecks);
126         var iterator = new MapIterator&lt;CommitCheck, Iterator&lt;Issue&gt;&gt;(enabled.iterator(), c -&gt; {
127             var skip = whitelist.get(c.name());
</pre>
<hr />
<pre>
201         return new FlatMapIterator&lt;Issue&gt;(iterator);
202     }
203 
204     private Issues issues() throws IOException {
205         var commits = repository.commits(revisionRange);
206 
207         var repositoryIssues = repositoryIssues();
208         var commitIssues = commitIssues(commits);
209 
210         var errors = new ConcatIterator&lt;Issue&gt;(repositoryIssues, commitIssues);
211         return new Issues(errors, commits);
212     }
213 
214     private static Issues check(ReadOnlyRepository repository,
215                                 Census census,
216                                 CommitMessageParser parser,
217                                 String branchRegex,
218                                 String tagRegex,
219                                 String revisionRange,
220                                 Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified">221                                 Set&lt;Hash&gt; blacklist) throws IOException {</span>

222 
223         var defaultBranchRegex = &quot;|&quot; + repository.defaultBranch().name();
224         var allowedBranches = Pattern.compile(&quot;^(?:&quot; + branchRegex + defaultBranchRegex + &quot;)$&quot;);
225 
226         var defaultTag = repository.defaultTag();
227         var defaultTagRegex = defaultTag.isPresent() ? &quot;|&quot; + defaultTag.get().name() : &quot;&quot;;
228         var allowedTags = Pattern.compile(&quot;^(?:&quot; + tagRegex + defaultTagRegex + &quot;)$&quot;);
229 
<span class="line-modified">230         var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist);</span>
231         return jcheck.issues();
232     }
233 
234     public static Issues check(ReadOnlyRepository repository,
235                                Census census,
236                                CommitMessageParser parser,
237                                String revisionRange,
238                                Hash configuration,
239                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified">240                                Set&lt;Hash&gt; blacklist) throws IOException {</span>

241         if (repository.isEmpty()) {
242             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);
243         }
244 
<span class="line-modified">245         var conf = parseConfiguration(repository, configuration);</span>
246 
247         var branchRegex = conf.isPresent() ?  conf.get().repository().branches() : &quot;.*&quot;;
248         var tagRegex =  conf.isPresent() ?  conf.get().repository().tags() : &quot;.*&quot;;
249 
<span class="line-modified">250         return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist);</span>










251     }
252 
253     public static Issues check(ReadOnlyRepository repository,
254                                Census census,
255                                CommitMessageParser parser,
256                                String revisionRange) throws IOException {
257         var master = repository.resolve(repository.defaultBranch().name())
258                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
259         var whitelist = new HashMap&lt;String, Set&lt;Hash&gt;&gt;();
260         var blacklist = new HashSet&lt;Hash&gt;();
261         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
262     }
263 
264     public static Issues check(ReadOnlyRepository repository,
265                                Census census,
266                                CommitMessageParser parser,
267                                String revisionRange,
268                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
269                                Set&lt;Hash&gt; blacklist) throws IOException {
270         var master = repository.resolve(repository.defaultBranch().name())
271                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
272         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
273     }
274 
275     public static Set&lt;Check&gt; checks(ReadOnlyRepository repository, Census census, Hash hash) throws IOException {
276         var jcheck = new JCheck(repository,
277                                 census,
278                                 CommitMessageParsers.v1,
279                                 hash.hex() + &quot;^..&quot; + hash.hex(),
280                                 Pattern.compile(&quot;.*&quot;),
281                                 Pattern.compile(&quot;.*&quot;),
282                                 new HashMap&lt;String, Set&lt;Hash&gt;&gt;(),
<span class="line-modified">283                                 new HashSet&lt;Hash&gt;());</span>

284         return jcheck.checksForCommits();
285     }
286 }
</pre>
</td>
<td>
<hr />
<pre>
 26 import org.openjdk.skara.jcheck.iterators.*;
 27 import org.openjdk.skara.vcs.*;
 28 import org.openjdk.skara.vcs.openjdk.CommitMessageParser;
 29 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
<span class="line-added"> 46     private final List&lt;String&gt; additionalConfiguration;</span>
 47     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 48 
 49     private JCheckConfiguration cachedConfiguration = null;
 50 
 51     JCheck(ReadOnlyRepository repository,
 52            Census census,
 53            CommitMessageParser parser,
 54            String revisionRange,
 55            Pattern allowedBranches,
 56            Pattern allowedTags,
 57            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified"> 58            Set&lt;Hash&gt; blacklist,</span>
<span class="line-added"> 59            List&lt;String&gt; additionalConfiguration) throws IOException {</span>
 60         this.repository = repository;
 61         this.census = census;
 62         this.parser = parser;
 63         this.revisionRange = revisionRange;
 64         this.whitelist = whitelist;
<span class="line-added"> 65         this.additionalConfiguration = additionalConfiguration;</span>
 66 
 67         var utils = new Utilities();
 68         commitChecks = List.of(
 69             new AuthorCheck(),
 70             new CommitterCheck(census),
 71             new WhitespaceCheck(),
 72             new MergeMessageCheck(),
 73             new HgTagCommitCheck(utils),
 74             new DuplicateIssuesCheck(repository),
 75             new ReviewersCheck(census, utils),
 76             new MessageCheck(utils),
 77             new IssuesCheck(utils),
 78             new ExecutableCheck(),
 79             new BlacklistCheck(blacklist)
 80         );
 81         repositoryChecks = List.of(
 82             new BranchesCheck(allowedBranches),
 83             new TagsCheck(allowedTags)
 84         );
 85     }
 86 
<span class="line-modified"> 87     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h, List&lt;String&gt; additionalConfiguration) {</span>
 88         try {
<span class="line-modified"> 89             var content = new ArrayList&lt;&gt;(r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList()));</span>
<span class="line-added"> 90             content.addAll(additionalConfiguration);</span>
 91             if (content.size() == 0) {
 92                 return Optional.empty();
 93             }
 94             return Optional.of(JCheckConfiguration.parse(content));
 95         } catch (IOException e) {
 96             throw new UncheckedIOException(e);
 97         }
 98     }
 99 
100     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
101         var confPath = Paths.get(&quot;.jcheck/conf&quot;);
102         var changesConfiguration = c.parentDiffs()
103                                     .stream()
104                                     .map(Diff::patches)
105                                     .flatMap(List::stream)
106                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||
107                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));
108 
109 
110         if (changesConfiguration || cachedConfiguration == null) {
<span class="line-modified">111             var confAtCommit = parseConfiguration(repository, c.hash(), additionalConfiguration);</span>
112             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);
113             return confAtCommit;
114         } else {
115             return Optional.of(cachedConfiguration);
116         }
117     }
118 
119     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
120         log.fine(&quot;Checking: &quot; + commit.hash().hex());
121         var configuration = getConfigurationFor(commit);
122         if (!configuration.isPresent()) {
123             log.finer(&quot;No .jcheck/conf present for &quot; + commit.hash().hex());
124             return Collections.emptyIterator();
125         }
126 
127         var conf = configuration.get();
128         var message = parser.parse(commit);
129         var enabled = conf.checks().enabled(commitChecks);
130         var iterator = new MapIterator&lt;CommitCheck, Iterator&lt;Issue&gt;&gt;(enabled.iterator(), c -&gt; {
131             var skip = whitelist.get(c.name());
</pre>
<hr />
<pre>
205         return new FlatMapIterator&lt;Issue&gt;(iterator);
206     }
207 
208     private Issues issues() throws IOException {
209         var commits = repository.commits(revisionRange);
210 
211         var repositoryIssues = repositoryIssues();
212         var commitIssues = commitIssues(commits);
213 
214         var errors = new ConcatIterator&lt;Issue&gt;(repositoryIssues, commitIssues);
215         return new Issues(errors, commits);
216     }
217 
218     private static Issues check(ReadOnlyRepository repository,
219                                 Census census,
220                                 CommitMessageParser parser,
221                                 String branchRegex,
222                                 String tagRegex,
223                                 String revisionRange,
224                                 Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified">225                                 Set&lt;Hash&gt; blacklist,</span>
<span class="line-added">226                                 List&lt;String&gt; additionalConfiguration) throws IOException {</span>
227 
228         var defaultBranchRegex = &quot;|&quot; + repository.defaultBranch().name();
229         var allowedBranches = Pattern.compile(&quot;^(?:&quot; + branchRegex + defaultBranchRegex + &quot;)$&quot;);
230 
231         var defaultTag = repository.defaultTag();
232         var defaultTagRegex = defaultTag.isPresent() ? &quot;|&quot; + defaultTag.get().name() : &quot;&quot;;
233         var allowedTags = Pattern.compile(&quot;^(?:&quot; + tagRegex + defaultTagRegex + &quot;)$&quot;);
234 
<span class="line-modified">235         var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist, additionalConfiguration);</span>
236         return jcheck.issues();
237     }
238 
239     public static Issues check(ReadOnlyRepository repository,
240                                Census census,
241                                CommitMessageParser parser,
242                                String revisionRange,
243                                Hash configuration,
244                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
<span class="line-modified">245                                Set&lt;Hash&gt; blacklist,</span>
<span class="line-added">246                                List&lt;String&gt; additionalConfiguration) throws IOException {</span>
247         if (repository.isEmpty()) {
248             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);
249         }
250 
<span class="line-modified">251         var conf = parseConfiguration(repository, configuration, additionalConfiguration);</span>
252 
253         var branchRegex = conf.isPresent() ?  conf.get().repository().branches() : &quot;.*&quot;;
254         var tagRegex =  conf.isPresent() ?  conf.get().repository().tags() : &quot;.*&quot;;
255 
<span class="line-modified">256         return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist, additionalConfiguration);</span>
<span class="line-added">257     }</span>
<span class="line-added">258 </span>
<span class="line-added">259     public static Issues check(ReadOnlyRepository repository,</span>
<span class="line-added">260                                Census census,</span>
<span class="line-added">261                                CommitMessageParser parser,</span>
<span class="line-added">262                                String revisionRange,</span>
<span class="line-added">263                                Hash configuration,</span>
<span class="line-added">264                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,</span>
<span class="line-added">265                                Set&lt;Hash&gt; blacklist) throws IOException {</span>
<span class="line-added">266         return check(repository, census, parser, revisionRange, configuration, whitelist, blacklist, List.of());</span>
267     }
268 
269     public static Issues check(ReadOnlyRepository repository,
270                                Census census,
271                                CommitMessageParser parser,
272                                String revisionRange) throws IOException {
273         var master = repository.resolve(repository.defaultBranch().name())
274                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
275         var whitelist = new HashMap&lt;String, Set&lt;Hash&gt;&gt;();
276         var blacklist = new HashSet&lt;Hash&gt;();
277         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
278     }
279 
280     public static Issues check(ReadOnlyRepository repository,
281                                Census census,
282                                CommitMessageParser parser,
283                                String revisionRange,
284                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
285                                Set&lt;Hash&gt; blacklist) throws IOException {
286         var master = repository.resolve(repository.defaultBranch().name())
287                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
288         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);
289     }
290 
291     public static Set&lt;Check&gt; checks(ReadOnlyRepository repository, Census census, Hash hash) throws IOException {
292         var jcheck = new JCheck(repository,
293                                 census,
294                                 CommitMessageParsers.v1,
295                                 hash.hex() + &quot;^..&quot; + hash.hex(),
296                                 Pattern.compile(&quot;.*&quot;),
297                                 Pattern.compile(&quot;.*&quot;),
298                                 new HashMap&lt;String, Set&lt;Hash&gt;&gt;(),
<span class="line-modified">299                                 new HashSet&lt;Hash&gt;(),</span>
<span class="line-added">300                                 List.of());</span>
301         return jcheck.checksForCommits();
302     }
303 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../test/src/main/java/org/openjdk/skara/test/CheckableRepository.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>