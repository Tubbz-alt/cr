diff a/jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java b/jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java
--- a/jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java
+++ b/jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java
@@ -41,10 +41,11 @@
     private final CommitMessageParser parser;
     private final String revisionRange;
     private final Map<String, Set<Hash>> whitelist;
     private final List<CommitCheck> commitChecks;
     private final List<RepositoryCheck> repositoryChecks;
+    private final List<String> additionalConfiguration;
     private final Logger log = Logger.getLogger("org.openjdk.skara.jcheck");
 
     private JCheckConfiguration cachedConfiguration = null;
 
     JCheck(ReadOnlyRepository repository,
@@ -52,16 +53,18 @@
            CommitMessageParser parser,
            String revisionRange,
            Pattern allowedBranches,
            Pattern allowedTags,
            Map<String, Set<Hash>> whitelist,
-           Set<Hash> blacklist) throws IOException {
+           Set<Hash> blacklist,
+           List<String> additionalConfiguration) throws IOException {
         this.repository = repository;
         this.census = census;
         this.parser = parser;
         this.revisionRange = revisionRange;
         this.whitelist = whitelist;
+        this.additionalConfiguration = additionalConfiguration;
 
         var utils = new Utilities();
         commitChecks = List.of(
             new AuthorCheck(),
             new CommitterCheck(census),
@@ -79,13 +82,14 @@
             new BranchesCheck(allowedBranches),
             new TagsCheck(allowedTags)
         );
     }
 
-    private static Optional<JCheckConfiguration> parseConfiguration(ReadOnlyRepository r, Hash h) {
+    private static Optional<JCheckConfiguration> parseConfiguration(ReadOnlyRepository r, Hash h, List<String> additionalConfiguration) {
         try {
-            var content = r.lines(Paths.get(".jcheck/conf"), h).orElse(Collections.emptyList());
+            var content = new ArrayList<>(r.lines(Paths.get(".jcheck/conf"), h).orElse(Collections.emptyList()));
+            content.addAll(additionalConfiguration);
             if (content.size() == 0) {
                 return Optional.empty();
             }
             return Optional.of(JCheckConfiguration.parse(content));
         } catch (IOException e) {
@@ -102,11 +106,11 @@
                                     .anyMatch(p -> p.source().path().isPresent() && p.source().path().get().equals(confPath) ||
                                                    p.target().path().isPresent() && p.target().path().get().equals(confPath));
 
 
         if (changesConfiguration || cachedConfiguration == null) {
-            var confAtCommit = parseConfiguration(repository, c.hash());
+            var confAtCommit = parseConfiguration(repository, c.hash(), additionalConfiguration);
             confAtCommit.ifPresent(jCheckConfiguration -> cachedConfiguration = jCheckConfiguration);
             return confAtCommit;
         } else {
             return Optional.of(cachedConfiguration);
         }
@@ -216,40 +220,52 @@
                                 CommitMessageParser parser,
                                 String branchRegex,
                                 String tagRegex,
                                 String revisionRange,
                                 Map<String, Set<Hash>> whitelist,
-                                Set<Hash> blacklist) throws IOException {
+                                Set<Hash> blacklist,
+                                List<String> additionalConfiguration) throws IOException {
 
         var defaultBranchRegex = "|" + repository.defaultBranch().name();
         var allowedBranches = Pattern.compile("^(?:" + branchRegex + defaultBranchRegex + ")$");
 
         var defaultTag = repository.defaultTag();
         var defaultTagRegex = defaultTag.isPresent() ? "|" + defaultTag.get().name() : "";
         var allowedTags = Pattern.compile("^(?:" + tagRegex + defaultTagRegex + ")$");
 
-        var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist);
+        var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist, additionalConfiguration);
         return jcheck.issues();
     }
 
     public static Issues check(ReadOnlyRepository repository,
                                Census census,
                                CommitMessageParser parser,
                                String revisionRange,
                                Hash configuration,
                                Map<String, Set<Hash>> whitelist,
-                               Set<Hash> blacklist) throws IOException {
+                               Set<Hash> blacklist,
+                               List<String> additionalConfiguration) throws IOException {
         if (repository.isEmpty()) {
             return new Issues(new ArrayList<Issue>().iterator(), null);
         }
 
-        var conf = parseConfiguration(repository, configuration);
+        var conf = parseConfiguration(repository, configuration, additionalConfiguration);
 
         var branchRegex = conf.isPresent() ?  conf.get().repository().branches() : ".*";
         var tagRegex =  conf.isPresent() ?  conf.get().repository().tags() : ".*";
 
-        return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist);
+        return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist, additionalConfiguration);
+    }
+
+    public static Issues check(ReadOnlyRepository repository,
+                               Census census,
+                               CommitMessageParser parser,
+                               String revisionRange,
+                               Hash configuration,
+                               Map<String, Set<Hash>> whitelist,
+                               Set<Hash> blacklist) throws IOException {
+        return check(repository, census, parser, revisionRange, configuration, whitelist, blacklist, List.of());
     }
 
     public static Issues check(ReadOnlyRepository repository,
                                Census census,
                                CommitMessageParser parser,
@@ -278,9 +294,10 @@
                                 CommitMessageParsers.v1,
                                 hash.hex() + "^.." + hash.hex(),
                                 Pattern.compile(".*"),
                                 Pattern.compile(".*"),
                                 new HashMap<String, Set<Hash>>(),
-                                new HashSet<Hash>());
+                                new HashSet<Hash>(),
+                                List.of());
         return jcheck.checksForCommits();
     }
 }
