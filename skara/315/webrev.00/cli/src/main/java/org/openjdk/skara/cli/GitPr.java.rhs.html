<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.issuetracker.IssueTracker;
 29 import org.openjdk.skara.issuetracker.Issue;
<a name="1" id="anc1"></a><span class="line-added"> 30 import org.openjdk.skara.jcheck.JCheckConfiguration;</span>
 31 import org.openjdk.skara.proxy.HttpProxy;
 32 import org.openjdk.skara.vcs.*;
 33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 34 
 35 import java.io.IOException;
 36 import java.net.URI;
 37 import java.nio.charset.StandardCharsets;
 38 import java.nio.file.*;
 39 import java.util.*;
 40 import java.util.regex.Pattern;
 41 import java.util.concurrent.TimeUnit;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Level;
 44 import java.util.stream.Collectors;
 45 
 46 public class GitPr {
 47     private static void exit(String fmt, Object...args) {
 48         System.err.println(String.format(fmt, args));
 49         System.exit(1);
 50     }
 51 
 52     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 53         return () -&gt; {
 54             exit(fmt, args);
 55             return null;
 56         };
 57     }
 58 
<a name="2" id="anc2"></a><span class="line-modified"> 59     private static String format(Issue issue) {</span>
<span class="line-modified"> 60         var parts = issue.id().split(&quot;-&quot;);</span>
<span class="line-modified"> 61         var id = parts.length == 2 ? parts[1] : issue.id();</span>
<span class="line-added"> 62         return id + &quot;: &quot; + issue.title();</span>
<span class="line-added"> 63     }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {</span>
<span class="line-added"> 66         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;</span>
<span class="line-added"> 67             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)</span>
<span class="line-added"> 68         ));</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70         return conf.general().jbs();</span>
<span class="line-added"> 71     }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {</span>
<span class="line-added"> 74         var message = CommitMessageParsers.v1.parse(commit.message());</span>
<span class="line-added"> 75         var issues = message.issues();</span>
<span class="line-added"> 76         if (issues.isEmpty()) {</span>
<span class="line-added"> 77             return getIssue(message.title(), project);</span>
<span class="line-added"> 78         } else if (issues.size() == 1) {</span>
<span class="line-added"> 79             var issue = issues.get(0);</span>
<span class="line-added"> 80             return getIssue(issue.id(), project);</span>
<span class="line-added"> 81         }</span>
<span class="line-added"> 82         return Optional.empty();</span>
<span class="line-added"> 83     }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {</span>
<span class="line-added"> 86         return getIssue(b.name(), project);</span>
<span class="line-added"> 87     }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {</span>
<span class="line-added"> 90         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);</span>
<span class="line-added"> 91         var m = issueIdPattern.matcher(s);</span>
 92         if (m.matches()) {
<a name="3" id="anc3"></a>
 93             var id = m.group(2);
<a name="4" id="anc4"></a><span class="line-added"> 94             if (project == null) {</span>
<span class="line-added"> 95                 project = m.group(1);</span>
<span class="line-added"> 96             }</span>
 97             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 98             return issueTracker.project(project).issue(id);
 99         }
<a name="5" id="anc5"></a>
100 
101         return Optional.empty();
102     }
103 
104     private static void await(Process p) throws IOException {
105         try {
106             var res = p.waitFor();
107             if (res != 0) {
108                 throw new IOException(&quot;Unexpected exit code &quot; + res);
109             }
110         } catch (InterruptedException e) {
111             throw new IOException(e);
112         }
113     }
114 
115     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
116         String editor = null;
117         var lines = repo.config(&quot;core.editor&quot;);
118         if (lines.size() == 1) {
119             editor = lines.get(0);
120         }
121         if (editor == null) {
122             editor = System.getenv(&quot;GIT_EDITOR&quot;);
123         }
124         if (editor == null) {
125             editor = System.getenv(&quot;EDITOR&quot;);
126         }
127         if (editor == null) {
128             editor = System.getenv(&quot;VISUAL&quot;);
129         }
130         if (editor == null) {
131             editor = &quot;vi&quot;;
132         }
133 
134         var pb = new ProcessBuilder(editor, file.toString());
135         pb.inheritIO();
136         var p = pb.start();
137         try {
138             return p.waitFor() == 0;
139         } catch (InterruptedException e) {
140             throw new IOException(e);
141         }
142     }
143 
144     private static String projectName(URI uri) {
145         var name = uri.getPath().toString().substring(1);
146         if (name.endsWith(&quot;.git&quot;)) {
147             name = name.substring(0, name.length() - &quot;.git&quot;.length());
148         }
149         return name;
150     }
151 
152     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
153         HostedRepository targetRepo = null;
154 
155         try {
156             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
157             targetRepo = host.repository(projectName(upstream)).orElse(null);
158         } catch (IOException e) {
159             // do nothing
160         }
161 
162         if (targetRepo == null) {
163             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
164                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
165             );
166             var parentRepo = remoteRepo.parent();
167             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
168         }
169 
170         return targetRepo;
171     }
172 
173     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
174         if (!prId.isPresent()) {
175             exit(&quot;error: missing pull request identifier&quot;);
176         }
177 
178         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
179         if (pr == null) {
180             exit(&quot;error: could not fetch PR information&quot;);
181         }
182 
183         return pr;
184     }
185 
186     private static void show(String ref, Hash hash) throws IOException {
187         show(ref, hash, null);
188     }
189     private static void show(String ref, Hash hash, Path dir) throws IOException {
190         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
191                                                    &quot;--patch&quot;,
192                                                    &quot;--find-renames=50%&quot;,
193                                                    &quot;--find-copies=50%&quot;,
194                                                    &quot;--find-copies-harder&quot;,
195                                                    &quot;--abbrev&quot;,
196                                                    ref + &quot;...&quot; + hash.hex());
197         if (dir != null) {
198             pb.directory(dir.toFile());
199         }
200         pb.inheritIO();
201         await(pb.start());
202     }
203 
204     private static void gimport() throws IOException {
205         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
206         pb.inheritIO();
207         await(pb.start());
208     }
209 
210     private static void hgImport(Path patch) throws IOException {
211         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
212         pb.inheritIO();
213         await(pb.start());
214     }
215 
216     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
217         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
218         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
219         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
220         var p = pb.start();
221         var bytes = p.getInputStream().readAllBytes();
222         var exited = p.waitFor(1, TimeUnit.MINUTES);
223         var exitValue = p.exitValue();
224         if (!exited || exitValue != 0) {
225             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
226         }
227 
228         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
229     }
230 
231     private static String hgResolve(String ref) throws IOException, InterruptedException {
232         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
233         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
234         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
235         var p = pb.start();
236         var bytes = p.getInputStream().readAllBytes();
237         var exited = p.waitFor(1, TimeUnit.MINUTES);
238         var exitValue = p.exitValue();
239         if (!exited || exitValue != 0) {
240             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
241         }
242 
243         return new String(bytes, StandardCharsets.UTF_8);
244     }
245 
246     private static Path diff(String ref, Hash hash) throws IOException {
247         return diff(ref, hash, null);
248     }
249 
250     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
251         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
252         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
253                                                    &quot;--patch&quot;,
254                                                    &quot;--find-renames=50%&quot;,
255                                                    &quot;--find-copies=50%&quot;,
256                                                    &quot;--find-copies-harder&quot;,
257                                                    &quot;--abbrev&quot;,
258                                                    ref + &quot;...&quot; + hash.hex());
259         if (dir != null) {
260             pb.directory(dir.toFile());
261         }
262         pb.redirectOutput(patch.toFile());
263         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
264         await(pb.start());
265         return patch;
266     }
267 
268     private static void apply(Path patch) throws IOException {
269         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
270         pb.inheritIO();
271         await(pb.start());
272     }
273 
274     private static int longest(List&lt;String&gt; strings) {
275         return strings.stream().mapToInt(String::length).max().orElse(0);
276     }
277 
278     public static void main(String[] args) throws IOException, InterruptedException {
279         var flags = List.of(
280             Option.shortcut(&quot;u&quot;)
281                   .fullname(&quot;username&quot;)
282                   .describe(&quot;NAME&quot;)
283                   .helptext(&quot;Username on host&quot;)
284                   .optional(),
285             Option.shortcut(&quot;r&quot;)
286                   .fullname(&quot;remote&quot;)
287                   .describe(&quot;NAME&quot;)
288                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
289                   .optional(),
290             Option.shortcut(&quot;b&quot;)
291                   .fullname(&quot;branch&quot;)
292                   .describe(&quot;NAME&quot;)
293                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
294                   .optional(),
295             Option.shortcut(&quot;&quot;)
296                   .fullname(&quot;authors&quot;)
297                   .describe(&quot;LIST&quot;)
298                   .helptext(&quot;Comma separated list of authors&quot;)
299                   .optional(),
300             Option.shortcut(&quot;&quot;)
301                   .fullname(&quot;assignees&quot;)
302                   .describe(&quot;LIST&quot;)
303                   .helptext(&quot;Comma separated list of assignees&quot;)
304                   .optional(),
305             Option.shortcut(&quot;&quot;)
306                   .fullname(&quot;labels&quot;)
307                   .describe(&quot;LIST&quot;)
308                   .helptext(&quot;Comma separated list of labels&quot;)
309                   .optional(),
310             Option.shortcut(&quot;&quot;)
311                   .fullname(&quot;columns&quot;)
312                   .describe(&quot;id,title,author,assignees,labels&quot;)
313                   .helptext(&quot;Comma separated list of columns to show&quot;)
314                   .optional(),
315             Switch.shortcut(&quot;&quot;)
316                   .fullname(&quot;no-decoration&quot;)
317                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
318                   .optional(),
319             Switch.shortcut(&quot;&quot;)
320                   .fullname(&quot;no-token&quot;)
321                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
322                   .optional(),
323             Switch.shortcut(&quot;&quot;)
324                   .fullname(&quot;mercurial&quot;)
325                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
326                   .optional(),
327             Switch.shortcut(&quot;&quot;)
328                   .fullname(&quot;verbose&quot;)
329                   .helptext(&quot;Turn on verbose output&quot;)
330                   .optional(),
331             Switch.shortcut(&quot;&quot;)
332                   .fullname(&quot;debug&quot;)
333                   .helptext(&quot;Turn on debugging output&quot;)
334                   .optional(),
335             Switch.shortcut(&quot;&quot;)
336                   .fullname(&quot;version&quot;)
337                   .helptext(&quot;Print the version of this tool&quot;)
338                   .optional());
339 
340         var inputs = List.of(
341             Input.position(0)
342                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
343                  .singular()
344                  .required(),
345             Input.position(1)
346                  .describe(&quot;ID&quot;)
347                  .singular()
348                  .optional()
349         );
350 
351         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
352         var arguments = parser.parse(args);
353 
354         if (arguments.contains(&quot;version&quot;)) {
355             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
356             System.exit(0);
357         }
358 
359         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
360             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
361             Logging.setup(level);
362         }
363 
364         HttpProxy.setup();
365 
366         var isMercurial = arguments.contains(&quot;mercurial&quot;);
367         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
368         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
369         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
370         var remotePullPath = repo.pullPath(remote);
371         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
372         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
373         var uri = Remote.toWebURI(remotePullPath);
374         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
375         var credentials = !shouldUseToken ?
376             null :
377             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
378         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
379         var forge = credentials == null ?
380             Forge.from(forgeURI) :
381             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
382         if (forge.isEmpty()) {
383             if (!shouldUseToken) {
384                 if (arguments.contains(&quot;verbose&quot;)) {
385                     System.err.println(&quot;&quot;);
386                 }
387                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
388                 if (!arguments.contains(&quot;verbose&quot;)) {
389                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
390                     System.err.println(&quot;&quot;);
391                 }
392             }
393             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
394         }
395         var host = forge.get();
396 
397         var action = arguments.at(0).asString();
398         if (!shouldUseToken &amp;&amp;
399             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
400             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
401             System.exit(1);
402         }
403 
404         if (action.equals(&quot;create&quot;)) {
405             if (isMercurial) {
406                 var currentBookmark = repo.currentBookmark();
407                 if (!currentBookmark.isPresent()) {
408                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
409                     System.err.println(&quot;&quot;);
410                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
411                     System.err.println(&quot;&quot;);
412                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
413                     System.err.println(&quot;&quot;);
414                     System.exit(1);
415                 }
416 
417                 var bookmark = currentBookmark.get();
418                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
419                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
420                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
421                     System.err.println(&quot;&quot;);
422                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
423                     System.err.println(&quot;&quot;);
424                     System.exit(1);
425                 }
426 
427                 var tags = hgTags();
428                 var upstreams = tags.stream()
429                                     .filter(t -&gt; t.endsWith(bookmark.name()))
430                                     .collect(Collectors.toList());
431                 if (upstreams.isEmpty()) {
432                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
433                     System.err.println(&quot;&quot;);
434                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
435                     System.err.println(&quot;&quot;);
436                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
437                     System.err.println(&quot;&quot;);
438                     System.exit(1);
439                 }
440 
441                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
442                 for (var tag : tags) {
443                     tagsAndHashes.put(tag, hgResolve(tag));
444                 }
445                 var bookmarkHash = hgResolve(bookmark.name());
446                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
447                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
448                     System.err.println(&quot;&quot;);
449 
450                     if (upstreams.size() == 1) {
451                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
452                         System.err.println(&quot;&quot;);
453                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
454                         System.err.println(&quot;&quot;);
455                     } else {
456                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
457                         System.err.println(&quot;&quot;);
458                         for (var upstream : upstreams) {
459                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
460                         }
461                         System.err.println(&quot;&quot;);
462                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
463                         System.err.println(&quot;&quot;);
464                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
465                         System.err.println(&quot;&quot;);
466                     }
467                     System.exit(1);
468                 }
469 
470                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
471                 var targetHash = hgResolve(targetBranch);
472                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
473                 if (commits.isEmpty()) {
474                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
475                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
476                     System.exit(1);
477                 }
478 
479                 var diff = repo.diff(repo.head());
480                 if (!diff.patches().isEmpty()) {
481                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
482                     System.err.println(&quot;&quot;);
483                     for (var patch : diff.patches()) {
484                         var path = patch.target().path().isPresent() ?
485                             patch.target().path().get() : patch.source().path().get();
486                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
487                     }
488                     System.err.println(&quot;&quot;);
489                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
490                     System.err.println(&quot;&quot;);
491                     System.err.println(&quot;    hg commit --amend&quot;);
492                     System.err.println(&quot;    hg git-cleanup&quot;);
493                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
494                     System.err.println(&quot;    hg gimport&quot;);
495                     System.err.println(&quot;&quot;);
496                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
497                     System.err.println(&quot;&quot;);
498                     System.err.println(&quot;    hg shelve&quot;);
499                     System.err.println(&quot;&quot;);
500                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
501                     System.exit(1);
502                 }
503 
504                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
505                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
506                 );
507                 if (token == null) {
508                     GitCredentials.approve(credentials);
509                 }
510                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
511                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
512 
513                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
514                 if (commits.size() == 1) {
515                     var commit = commits.get(0);
516                     var message = CommitMessageParsers.v1.parse(commit.message());
517                     Files.writeString(file, message.title() + &quot;\n&quot;);
518                     if (!message.summaries().isEmpty()) {
519                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
520                     }
521                     if (!message.additional().isEmpty()) {
522                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
523                     }
524                 } else {
525                     Files.write(file, List.of(&quot;&quot;));
526                 }
527                 Files.write(file, List.of(
528                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
529                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
530                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
531                     &quot;# the subject from the body.&quot;,
532                     &quot;#&quot;,
533                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
534                     ),
535                     StandardOpenOption.APPEND
536                 );
537                 for (var commit : commits) {
538                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
539                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
540                 }
541                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
542                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
543                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
544                 var success = spawnEditor(repo, file);
545                 if (!success) {
546                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
547                     System.exit(1);
548                 }
549                 var lines = Files.readAllLines(file)
550                                  .stream()
551                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
552                                  .collect(Collectors.toList());
553                 var isEmpty = lines.stream().allMatch(String::isEmpty);
554                 if (isEmpty) {
555                     System.err.println(&quot;error: no message present, aborting&quot;);
556                     System.exit(1);
557                 }
558 
559                 var title = lines.get(0);
560                 List&lt;String&gt; body = null;
561                 if (lines.size() &gt; 1) {
562                     body = lines.subList(1, lines.size())
563                                 .stream()
564                                 .dropWhile(String::isEmpty)
565                                 .collect(Collectors.toList());
566                 } else {
567                     body = Collections.emptyList();
568                 }
569 
570                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
571                 if (arguments.contains(&quot;assignees&quot;)) {
572                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
573                     var assignees = usernames.stream()
574                                              .map(u -&gt; host.user(u))
575                                              .collect(Collectors.toList());
576                     pr.setAssignees(assignees);
577                 }
578                 System.out.println(pr.webUrl().toString());
579                 Files.deleteIfExists(file);
580 
581                 System.exit(0);
582             }
583             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
584                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
585                     System.exit(1);
586                     return null;
587             });
588             if (currentBranch.equals(repo.defaultBranch())) {
589                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
590                 System.err.println(&quot;&quot;);
591                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
592                 System.err.println(&quot;&quot;);
593                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
594                 System.err.println(&quot;    git branch --force master origin/master&quot;);
595                 System.err.println(&quot;&quot;);
596                 System.exit(1);
597             }
598 
599             var upstream = repo.upstreamFor(currentBranch);
600             if (upstream.isEmpty()) {
601                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
602                 System.err.println(&quot;&quot;);
603                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
604                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
605                 System.err.println(&quot;&quot;);
606                 System.err.println(&quot;    git publish&quot;);
607                 System.err.println(&quot;&quot;);
608                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
609                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
610                 System.err.println(&quot;&quot;);
611                 System.err.println(&quot;    git fetch &quot; + remote);
612                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
613                 System.err.println(&quot;&quot;);
614                 System.exit(1);
615             }
616 
617             var upstreamRefName = upstream.get().substring(remote.length() + 1);
618             repo.fetch(uri, upstreamRefName);
619             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
620             if (!branchCommits.isEmpty()) {
621                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
622                 System.err.println(&quot;&quot;);
623                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
624                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
625                 System.err.println(&quot;&quot;);
626                 for (var commit : branchCommits) {
627                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
628                 }
629                 System.err.println(&quot;&quot;);
630                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
631                 System.err.println(&quot;&quot;);
632                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
633                 System.err.println(&quot;&quot;);
634                 System.exit(1);
635             }
636 
637             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
638             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
639             if (commits.isEmpty()) {
640                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
641                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
642                 System.exit(1);
643             }
644 
645             var diff = repo.diff(repo.head());
646             if (!diff.patches().isEmpty()) {
647                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
648                 System.err.println(&quot;&quot;);
649                 for (var patch : diff.patches()) {
650                     var path = patch.target().path().isPresent() ?
651                         patch.target().path().get() : patch.source().path().get();
652                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
653                 }
654                 System.err.println(&quot;&quot;);
655                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
656                 System.err.println(&quot;&quot;);
657                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
658                 System.err.println(&quot;&quot;);
659                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
660                 System.err.println(&quot;&quot;);
661                 System.err.println(&quot;    git stash&quot;);
662                 System.err.println(&quot;&quot;);
663                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
664                 System.exit(1);
665             }
666 
667             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
668                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
669             );
670             if (token == null) {
671                 GitCredentials.approve(credentials);
672             }
673             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
674                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
675 
<a name="6" id="anc6"></a><span class="line-modified">676             var project = jbsProjectFromJcheckConf(repo);</span>
<span class="line-added">677             var issue = getIssue(currentBranch, project);</span>
678             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
679             if (issue.isPresent()) {
<a name="7" id="anc7"></a><span class="line-modified">680                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);</span>


681             } else if (commits.size() == 1) {
682                 var commit = commits.get(0);
<a name="8" id="anc8"></a><span class="line-modified">683                 issue = getIssue(commit, project);</span>
<span class="line-modified">684                 if (issue.isPresent()) {</span>
<span class="line-modified">685                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);</span>
<span class="line-modified">686                 } else {</span>
<span class="line-modified">687                     var message = CommitMessageParsers.v1.parse(commit.message());</span>
<span class="line-modified">688                     Files.writeString(file, message.title() + &quot;\n&quot;);</span>
<span class="line-modified">689                     if (!message.summaries().isEmpty()) {</span>
<span class="line-added">690                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);</span>
<span class="line-added">691                     }</span>
<span class="line-added">692                     if (!message.additional().isEmpty()) {</span>
<span class="line-added">693                         Files.write(file, message.additional(), StandardOpenOption.APPEND);</span>
<span class="line-added">694                     }</span>
695                 }
696             } else {
697                 Files.write(file, List.of(&quot;&quot;));
698             }
699             Files.write(file, List.of(
700                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
701                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
702                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
703                 &quot;# the subject from the body.&quot;,
704                 &quot;#&quot;,
705                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
706                 ),
707                 StandardOpenOption.APPEND
708             );
709             for (var commit : commits) {
710                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
711                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
712             }
713             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
714             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
715             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
716             var success = spawnEditor(repo, file);
717             if (!success) {
718                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
719                 System.exit(1);
720             }
721             var lines = Files.readAllLines(file)
722                              .stream()
723                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
724                              .collect(Collectors.toList());
725             var isEmpty = lines.stream().allMatch(String::isEmpty);
726             if (isEmpty) {
727                 System.err.println(&quot;error: no message present, aborting&quot;);
728                 System.exit(1);
729             }
730 
731             var title = lines.get(0);
732             List&lt;String&gt; body = null;
733             if (lines.size() &gt; 1) {
734                 body = lines.subList(1, lines.size())
735                             .stream()
736                             .dropWhile(String::isEmpty)
737                             .collect(Collectors.toList());
738             } else {
739                 body = Collections.emptyList();
740             }
741 
742             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
743             if (arguments.contains(&quot;assignees&quot;)) {
744                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
745                 var assignees = usernames.stream()
746                                          .map(u -&gt; host.user(u))
747                                          .collect(Collectors.toList());
748                 pr.setAssignees(assignees);
749             }
750             System.out.println(pr.webUrl().toString());
751             Files.deleteIfExists(file);
752         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
753             var pr = getPullRequest(uri, repo, host, arguments.at(1));
754 
755             if (action.equals(&quot;integrate&quot;)) {
756                 pr.addComment(&quot;/integrate&quot;);
757             } else if (action.equals(&quot;test&quot;)) {
758                 pr.addComment(&quot;/test&quot;);
759             } else if (action.equals(&quot;approve&quot;)) {
760                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
761             } else {
762                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
763             }
764         } else if (action.equals(&quot;list&quot;)) {
765             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
766             var prs = remoteRepo.pullRequests();
767             var ids = new ArrayList&lt;String&gt;();
768             var titles = new ArrayList&lt;String&gt;();
769             var authors = new ArrayList&lt;String&gt;();
770             var assignees = new ArrayList&lt;String&gt;();
771             var labels = new ArrayList&lt;String&gt;();
772 
773             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
774                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
775                 Set.of();
776             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
777                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
778                 Set.of();
779             var filterLabels = arguments.contains(&quot;labels&quot;) ?
780                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
781                 Set.of();
782 
783             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
784             var columnValues = Map.of(defaultColumns.get(0), ids,
785                                       defaultColumns.get(1), titles,
786                                       defaultColumns.get(2), authors,
787                                       defaultColumns.get(3), assignees,
788                                       defaultColumns.get(4), labels);
789             var columns = arguments.contains(&quot;columns&quot;) ?
790                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
791                 defaultColumns;
792             if (columns != defaultColumns) {
793                 for (var column : columns) {
794                     if (!defaultColumns.contains(column)) {
795                         System.err.println(&quot;error: unknown column: &quot; + column);
796                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
797                         System.exit(1);
798                     }
799                 }
800             }
801 
802             for (var pr : prs) {
803                 var prAuthor = pr.author().userName();
804                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
805                     continue;
806                 }
807 
808                 var prAssignees = pr.assignees().stream()
809                                     .map(HostUser::userName)
810                                     .collect(Collectors.toSet());
811                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
812                     continue;
813                 }
814 
815                 var prLabels = new HashSet&lt;&gt;(pr.labels());
816                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
817                     continue;
818                 }
819 
820                 ids.add(pr.id());
821                 titles.add(pr.title());
822                 authors.add(prAuthor);
823                 assignees.add(String.join(&quot;,&quot;, prAssignees));
824                 labels.add(String.join(&quot;,&quot;, prLabels));
825             }
826 
827 
828             String fmt = &quot;&quot;;
829             for (var column : columns.subList(0, columns.size() - 1)) {
830                 var values = columnValues.get(column);
831                 var n = Math.max(column.length(), longest(values));
832                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
833             }
834             fmt += &quot;%s\n&quot;;
835 
836             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
837                 var upperCase = columns.stream()
838                                        .map(String::toUpperCase)
839                                        .collect(Collectors.toList());
840                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
841             }
842             for (var i = 0; i &lt; ids.size(); i++) {
843                 final int n = i;
844                 var row = columns.stream()
845                                  .map(columnValues::get)
846                                  .map(values -&gt; values.get(n))
847                                  .collect(Collectors.toList());
848                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
849             }
850         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
851             var prId = arguments.at(1);
852             if (!prId.isPresent()) {
853                 exit(&quot;error: missing pull request identifier&quot;);
854             }
855 
856             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
857             var pr = remoteRepo.pullRequest(prId.asString());
858             var repoUrl = remoteRepo.webUrl();
859             var prHeadRef = pr.sourceRef();
860             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
861             if (isHgGit) {
862                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
863                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
864 
865                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
866                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
867                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
868 
869                     if (action.equals(&quot;show&quot;)) {
870                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
871                     } else {
872                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
873                         hgImport(patch);
874                         Files.delete(patch);
875                     }
876                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
877                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
878                     var hgGitBranches = hgGitRepo.branches();
879                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
880                         hgGitRepo.delete(new Branch(hgGitRef));
881                     }
882                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
883                     gimport();
884                     var hgFetchHead = repo.resolve(hgGitRef).get();
885 
886                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
887                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
888                     } else if (action.equals(&quot;checkout&quot;)) {
889                         repo.checkout(hgFetchHead);
890                         if (arguments.contains(&quot;branch&quot;)) {
891                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
892                         }
893                     }
894                 } else {
895                     exit(&quot;Unexpected action: &quot; + action);
896                 }
897 
898                 return;
899             }
900 
901             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
902             if (action.equals(&quot;fetch&quot;)) {
903                 if (arguments.contains(&quot;branch&quot;)) {
904                     var branchName = arguments.get(&quot;branch&quot;).asString();
905                     repo.branch(fetchHead, branchName);
906                 } else {
907                     System.out.println(fetchHead.hex());
908                 }
909             } else if (action.equals(&quot;checkout&quot;)) {
910                 if (arguments.contains(&quot;branch&quot;)) {
911                     var branchName = arguments.get(&quot;branch&quot;).asString();
912                     var branch = repo.branch(fetchHead, branchName);
913                     repo.checkout(branch, false);
914                 } else {
915                     repo.checkout(fetchHead, false);
916                 }
917             } else if (action.equals(&quot;show&quot;)) {
918                 show(pr.targetRef(), fetchHead);
919             } else if (action.equals(&quot;apply&quot;)) {
920                 var patch = diff(pr.targetRef(), fetchHead);
921                 apply(patch);
922                 Files.deleteIfExists(patch);
923             }
924         } else if (action.equals(&quot;close&quot;)) {
925             var prId = arguments.at(1);
926             if (!prId.isPresent()) {
927                 exit(&quot;error: missing pull request identifier&quot;);
928             }
929 
930             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
931             var pr = remoteRepo.pullRequest(prId.asString());
932             pr.setState(PullRequest.State.CLOSED);
933         } else if (action.equals(&quot;update&quot;)) {
934             var prId = arguments.at(1);
935             if (!prId.isPresent()) {
936                 exit(&quot;error: missing pull request identifier&quot;);
937             }
938 
939             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
940             var pr = remoteRepo.pullRequest(prId.asString());
941             if (arguments.contains(&quot;assignees&quot;)) {
942                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
943                 var assignees = usernames.stream()
944                     .map(u -&gt; host.user(u))
945                     .collect(Collectors.toList());
946                 pr.setAssignees(assignees);
947             }
948         } else {
949             exit(&quot;error: unexpected action: &quot; + action);
950         }
951     }
952 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>