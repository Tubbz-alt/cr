diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -0,0 +1,160 @@
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.email.Email;
+import org.openjdk.skara.host.Review;
+import org.openjdk.skara.vcs.*;
+
+import java.net.URI;
+import java.time.format.DateTimeFormatter;
+import java.util.Arrays;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+class ArchiveMessages {
+    private static String formatCommit(Commit commit) {
+        var ret = new StringBuilder();
+        var message = commit.message();
+        if (message.size() == 0) {
+            ret.append("<no commit message found>");
+        } else {
+            var abbrev = commit.hash().abbreviate();
+            var filler = "\t".repeat(((abbrev.length() + 4 /* additional spacing */) / 8 /* tab size */) + 1 /* rounding */);
+            ret.append(" - ").append(abbrev).append(":\t").append(message.get(0).strip());
+            message.stream()
+                   .skip(1)
+                   .map(String::strip)
+                   .filter(Predicate.not(String::isEmpty))
+                   .forEach(line -> ret.append("\n").append(filler).append("\t").append(line));
+        }
+        return ret.toString();
+    }
+
+    private static final String infoSeparator = "----------------";
+
+    private static final Pattern commentPattern = Pattern.compile("<!--.*?-->",
+                                                                  Pattern.DOTALL | Pattern.MULTILINE);
+    private static final Pattern cutoffPattern = Pattern.compile("(.*?)<!-- Anything below this marker will be .*? -->",
+                                                                 Pattern.DOTALL | Pattern.MULTILINE);
+    private static String filterComments(String body) {
+        var cutoffMatcher = cutoffPattern.matcher(body);
+        if (cutoffMatcher.find()) {
+            body = cutoffMatcher.group(1);
+        }
+
+        var commentMatcher = commentPattern.matcher(body);
+        body = commentMatcher.replaceAll("");
+
+        return body.strip();
+    }
+
+    private static String quoteBody(String body) {
+        return Arrays.stream(body.strip().split("\\R"))
+                     .map(line -> line.length() > 0 ? line.charAt(0) == '>' ? ">" + line : "> " + line : "> ")
+                     .collect(Collectors.joining("\n"));
+    }
+
+    static String composeConversation(PullRequestInstance prInstance, URI webrev) {
+        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), ArchiveMessages::formatCommit);
+        var filteredBody = filterComments(prInstance.pr().getBody());
+        if (filteredBody.isEmpty()) {
+            filteredBody = prInstance.pr().getTitle().strip();
+        }
+        return filteredBody + "\n\n" +
+                infoSeparator + "\n\n" +
+                "Commits:\n" +
+                commitMessages + "\n\n" +
+                "Pull request:\n" +
+                prInstance.pr().getWebUrl() + "\n\n" +
+                "Webrev:\n" +
+                webrev.toString() + "\n\n" +
+                "Patch:\n" +
+                prInstance.diffUrl() + "\n\n" +
+                "Fetch command:\n" +
+                prInstance.fetchCommand();
+    }
+
+    static String composeRebaseComment(PullRequestInstance prInstance, URI fullWebrev) {
+        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), ArchiveMessages::formatCommit);
+        return "The pull request has been updated with a complete new set of changes (possibly due to a rebase).\n\n" +
+                infoSeparator + "\n\n" +
+                "Commits:\n" +
+                commitMessages + "\n\n" +
+                "Pull request:\n" +
+                prInstance.pr().getWebUrl() + "\n\n" +
+                "Webrev:\n" +
+                fullWebrev.toString() + "\n\n" +
+                "Updated full patch:\n" +
+                prInstance.diffUrl() + "\n\n" +
+                "Fetch command:\n" +
+                prInstance.fetchCommand();
+    }
+
+    static String composeIncrementalComment(Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
+        var newCommitMessages = prInstance.formatCommitMessages(lastHead, prInstance.headHash(), ArchiveMessages::formatCommit);
+        return "The pull request has been updated with additional changes.\n\n" +
+                infoSeparator + "\n\n" +
+                "Added commits:\n" +
+                newCommitMessages + "\n\n" +
+                "Pull request:\n" +
+                prInstance.pr().getWebUrl() + "\n\n" +
+                "Webrevs:\n" +
+                " - full: " + fullWebrev.toString() + "\n" +
+                " - inc: " + incrementalWebrev.toString() + "\n\n" +
+                "Updated full patch:\n" +
+                prInstance.diffUrl() + "\n\n" +
+                "Fetch command:\n" +
+                prInstance.fetchCommand();
+    }
+
+    private static String composeReplyFooter(PullRequestInstance prInstance) {
+        return "PR: " + prInstance.pr().getWebUrl();
+    }
+
+    static String composeReply(Email parent, String body, PullRequestInstance prInstance) {
+        return "On " + parent.date().format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + parent.author().toString() + " wrote:\n" +
+                "\n" +
+                quoteBody(parent.body()) +
+                "\n\n" +
+                filterComments(body) +
+                "\n\n" +
+                composeReplyFooter(prInstance);
+    }
+
+    static String composeCombinedReply(Email parent, String body, PullRequestInstance prInstance) {
+        var parentFooter = ArchiveMessages.composeReplyFooter(prInstance);
+        var filteredParentBody = parent.body().substring(0, parent.body().length() - parentFooter.length()).strip();
+        return filteredParentBody +
+                "\n\n" +
+                filterComments(body) +
+                "\n\n" +
+                parentFooter;
+    }
+
+    static String reviewCommentBody(String body, Review.Verdict verdict, String user, String role) {
+        var result = new StringBuilder(filterComments(body));
+        if (verdict != Review.Verdict.NONE) {
+            if (result.length() > 0) {
+                result.append("\n\n");
+                result.append(infoSeparator);
+                result.append("\n\n");
+            }
+            result.append("Review status set to ");
+            if (verdict == Review.Verdict.APPROVED) {
+                result.append("Approved");
+            } else {
+                result.append("Disapproved");
+            }
+            result.append(" by ");
+            result.append(user);
+            result.append(" (project role: ");
+            result.append(role);
+            result.append(").");
+        }
+        return result.toString();
+    }
+
+    static String reviewApprovalBodyReviewer(String reviewer) {
+        return "This PR has been marked as Reviewed by " + reviewer + ".";
+    }
+}
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -24,24 +24,20 @@
 
 import org.openjdk.skara.bot.WorkItem;
 import org.openjdk.skara.email.*;
 import org.openjdk.skara.host.*;
 import org.openjdk.skara.mailinglist.*;
-import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.Repository;
 
 import java.io.*;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
-import java.security.*;
-import java.time.*;
-import java.time.format.DateTimeFormatter;
+import java.time.Duration;
 import java.util.*;
-import java.util.function.*;
+import java.util.function.Consumer;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
-import java.util.stream.Collectors;
 
 class ArchiveWorkItem implements WorkItem {
     private final PullRequest pr;
     private final MailingListBridgeBot bot;
     private final Consumer<RuntimeException> exceptionConsumer;
@@ -109,157 +105,10 @@
         }
 
         return Optional.empty();
     }
 
-    private String quoteBody(String body) {
-        return Arrays.stream(body.strip().split("\\R"))
-                     .map(line -> line.length() > 0 ? line.charAt(0) == '>' ? ">" + line : "> " + line : "> ")
-                     .collect(Collectors.joining("\n"));
-    }
-
-    private static final Pattern commentPattern = Pattern.compile("<!--.*?-->",
-                                                                  Pattern.DOTALL | Pattern.MULTILINE);
-    private static final Pattern cutoffPattern = Pattern.compile("(.*?)<!-- Anything below this marker will be .*? -->",
-                                                                 Pattern.DOTALL | Pattern.MULTILINE);
-    private String filterComments(String body) {
-        var cutoffMatcher = cutoffPattern.matcher(body);
-        if (cutoffMatcher.find()) {
-            body = cutoffMatcher.group(1);
-        }
-
-        var commentMatcher = commentPattern.matcher(body);
-        body = commentMatcher.replaceAll("");
-
-        return body.strip();
-    }
-
-    private String formatCommit(Commit commit) {
-        var ret = new StringBuilder();
-        var message = commit.message();
-        if (message.size() == 0) {
-            ret.append("<no commit message found>");
-        } else {
-            var abbrev = commit.hash().abbreviate();
-            var filler = "\t".repeat(((abbrev.length() + 4 /* additional spacing */) / 8 /* tab size */) + 1 /* rounding */);
-            ret.append(" - ").append(abbrev).append(":\t").append(message.get(0).strip());
-            message.stream()
-                   .skip(1)
-                   .map(String::strip)
-                   .filter(Predicate.not(String::isEmpty))
-                   .forEach(line -> ret.append("\n").append(filler).append("\t").append(line));
-        }
-        return ret.toString();
-    }
-
-    private static final String infoSeparator = "----------------";
-
-    private String composeConversation(String body, PullRequestInstance prInstance, URI webrev) {
-        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), this::formatCommit);
-        var filteredBody = filterComments(body);
-        if (filteredBody.isEmpty()) {
-            filteredBody = pr.getTitle().strip();
-        }
-        return filteredBody + "\n\n" +
-                infoSeparator + "\n\n" +
-                "Commits:\n" +
-                commitMessages + "\n\n" +
-                "Pull request:\n" +
-                pr.getWebUrl() + "\n\n" +
-                "Webrev:\n" +
-                webrev.toString() + "\n\n" +
-                "Patch:\n" +
-                prInstance.diffUrl() + "\n\n" +
-                "Fetch command:\n" +
-                prInstance.fetchCommand();
-    }
-
-    private String composeReply(ZonedDateTime date, EmailAddress author, String parentBody, String body) {
-        return "On " + date.format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + author.toString() + " wrote:\n" +
-                "\n" +
-                quoteBody(parentBody) +
-                "\n\n" +
-                filterComments(body) +
-                "\n\n" +
-                "PR: " + pr.getWebUrl();
-    }
-
-    private String verdictToString(Review.Verdict verdict) {
-        switch (verdict) {
-            case APPROVED:
-                return "changes are approved";
-            case DISAPPROVED:
-                return "more changes are needed";
-            case NONE:
-                return "a comment has been added";
-            default:
-                throw new RuntimeException("Unknown verdict: " + verdict);
-        }
-    }
-
-    private String composeReview(ZonedDateTime date, EmailAddress parentAuthor, String parentBody, Review review) {
-        var body = new StringBuilder();
-        var author = getAuthorAddress(review.reviewer());
-        body.append("This PR has been reviewed by ");
-        body.append(author.fullName().orElse(author.localPart()));
-        body.append(" - ");
-        body.append(verdictToString(review.verdict()));
-        body.append(".");
-        if (review.body().isPresent()) {
-            body.append(" Review comment:\n\n");
-            body.append(review.body().get());
-        }
-
-        return "On " + date.format(DateTimeFormatter.RFC_1123_DATE_TIME) + ", " + parentAuthor.toString() + " wrote:\n" +
-                "\n" +
-                quoteBody(parentBody) +
-                "\n\n" +
-                filterComments(body.toString()) +
-                "\n\n" +
-                "PR: " + pr.getWebUrl();
-    }
-
-    private String composeRebaseComment(Hash lastBase, PullRequestInstance prInstance, URI fullWebrev) {
-        var commitMessages = prInstance.formatCommitMessages(prInstance.baseHash(), prInstance.headHash(), this::formatCommit);
-        return "The pull request has been updated with a complete new set of changes (possibly due to a rebase).\n\n" +
-                infoSeparator + "\n\n" +
-                "Commits:\n" +
-                commitMessages + "\n\n" +
-                "Pull request:\n" +
-                pr.getWebUrl() + "\n\n" +
-                "Webrev:\n" +
-                fullWebrev.toString() + "\n\n" +
-                "Updated full patch:\n" +
-                prInstance.diffUrl() + "\n\n" +
-                "Fetch command:\n" +
-                prInstance.fetchCommand();
-    }
-
-    private String composeIncrementalComment(Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
-        var newCommitMessages = prInstance.formatCommitMessages(lastHead, prInstance.headHash(), this::formatCommit);
-        return "The pull request has been updated with additional changes.\n\n" +
-                infoSeparator + "\n\n" +
-                "Added commits:\n" +
-                newCommitMessages + "\n\n" +
-                "Pull request:\n" +
-                pr.getWebUrl() + "\n\n" +
-                "Webrevs:\n" +
-                " - full: " + fullWebrev.toString() + "\n" +
-                " - inc: " + incrementalWebrev.toString() + "\n\n" +
-                "Updated full patch:\n" +
-                prInstance.diffUrl() + "\n\n" +
-                "Fetch command:\n" +
-                prInstance.fetchCommand();
-    }
-
-    private String composeReadyForIntegrationComment() {
-        return "This PR now fulfills all the requirements for integration, and is only awaiting the final " +
-                "integration command from the author." +
-                "\n\n" +
-                "PR: " + pr.getWebUrl();
-    }
-
     private Repository materializeArchive(Path scratchPath) {
         try {
             return Repository.materialize(scratchPath, bot.archiveRepo().getUrl(), pr.getTargetRef());
         } catch (IOException e) {
             throw new UncheckedIOException(e);
@@ -277,238 +126,17 @@
         }
         var commandMatcher = commandPattern.matcher(body);
         if (commandMatcher.matches()) {
             return true;
         }
-        return false;
-    }
-
-    private EmailAddress getUniqueMessageId(String identifier) {
-        try {
-            var prSpecific = pr.repository().getName().replace("/", ".") + "." + pr.getId();
-            var digest = MessageDigest.getInstance("SHA-256");
-            digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
-            digest.update(identifier.getBytes(StandardCharsets.UTF_8));
-            var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
-
-            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + pr.repository().getUrl().getHost());
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException("Cannot find SHA-256");
-        }
-    }
-
-    private String getStableMessageId(EmailAddress uniqueMessageId) {
-        return uniqueMessageId.localPart().split("\\.")[0];
-    }
-
-    private EmailAddress getMessageId() {
-        return getUniqueMessageId("fc");
-    }
-
-    private EmailAddress getMessageId(Comment comment) {
-        return getUniqueMessageId("pc" + comment.id());
-    }
-
-    private EmailAddress getMessageId(ReviewComment comment) {
-        return getUniqueMessageId("rc" + comment.id());
-    }
-
-    private EmailAddress getMessageId(Hash hash) {
-        return getUniqueMessageId("ha" + hash.hex());
-    }
-
-    private EmailAddress getMessageId(String raw) {
-        return getUniqueMessageId("rw" + raw);
-    }
-
-    private EmailAddress getMessageId(Review review) {
-        return getUniqueMessageId("rv" + review.id());
-    }
-
-    private EmailAddress getAuthorAddress(HostUserDetails originalAuthor) {
-        return EmailAddress.from(originalAuthor.fullName() + " via " + pr.repository().getUrl().getHost(),
-                                 bot.emailAddress().address());
-    }
-
-    private Email newConversation(PullRequestInstance prInstance, URI webrev) {
-        var body = composeConversation(pr.getBody(), prInstance, webrev);
-        var email = Email.create(getAuthorAddress(pr.getAuthor()), "RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .id(getMessageId())
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .build();
-        return email;
-    }
-
-
-    private Email comment(Email parent, Comment comment) {
-        var reply = composeReply(parent.date(), parent.author(), parent.body(), comment.body());
-        var references = parent.id().toString();
-        if (parent.hasHeader("References")) {
-            references = parent.headerValue("References") + " " + references;
-        }
-
-        var email = Email.create(getAuthorAddress(comment.author()), "Re: RFR: " + pr.getTitle(), reply)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(comment))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", references)
-                         .build();
-        return email;
-    }
-
-    private Email review(Email parent, Review review) {
-        var body = composeReview(parent.date(), parent.author(), parent.body(), review);
-        var email = Email.create(getAuthorAddress(review.reviewer()), "Re: RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(review))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", parent.id().toString())
-                         .build();
-        return email;
-
-    }
-
-    private Email reviewComment(Email parent, ReviewComment comment) {
-        var body = new StringBuilder();
-
-        // Add some context to the first post
-        if (comment.parent().isEmpty()) {
-            var contents = pr.repository().getFileContents(comment.path(), comment.hash().hex()).lines().collect(Collectors.toList());
-
-            body.append(comment.path()).append(" line ").append(comment.line()).append(":\n\n");
-            for (int i = Math.max(0, comment.line() - 2); i < Math.min(contents.size(), comment.line() + 1); ++i) {
-                body.append("> ").append(i + 1).append(": ").append(contents.get(i)).append("\n");
-            }
-            body.append("\n");
-        }
-        body.append(comment.body());
-
-        var reply = composeReply(parent.date(), parent.author(), parent.body(), body.toString());
-        var references = parent.id().toString();
-        if (parent.hasHeader("References")) {
-            references = parent.headerValue("References") + " " + references;
-        }
-
-        var email = Email.create(getAuthorAddress(comment.author()), "Re: RFR: " + pr.getTitle(), reply)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(comment))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", references)
-                         .build();
-        return email;
-    }
-
-    private Email rebaseComment(Email parent, Hash lastBase, PullRequestInstance prInstance, URI fullWebrev) {
-        var body = composeRebaseComment(lastBase, prInstance, fullWebrev);
-        var email = Email.create(getAuthorAddress(pr.getAuthor()), "Re: RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(prInstance.headHash()))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", parent.id().toString())
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .build();
-        return email;
-    }
-
-    private Email incrementalComment(Email parent, Hash lastHead, PullRequestInstance prInstance, URI fullWebrev, URI incrementalWebrev) {
-        var body = composeIncrementalComment(lastHead, prInstance, fullWebrev, incrementalWebrev);
-        var email = Email.create(getAuthorAddress(pr.getAuthor()), "Re: RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId(prInstance.headHash()))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", parent.id().toString())
-                         .header("PR-Head-Hash", prInstance.headHash().hex())
-                         .header("PR-Base-Hash", prInstance.baseHash().hex())
-                         .build();
-        return email;
-    }
-
-    private Email readyForIntegrationComment(Email parent, Set<String> currentLabels, int numLabelComments) {
-        var body = composeReadyForIntegrationComment();
-        var email = Email.create(getAuthorAddress(pr.getAuthor()), "Re: RFR: " + pr.getTitle(), body)
-                         .sender(bot.emailAddress())
-                         .recipient(parent.author())
-                         .id(getMessageId("labelcomment" + numLabelComments))
-                         .header("In-Reply-To", parent.id().toString())
-                         .header("References", parent.id().toString())
-                         .header("PR-Labels", String.join(";", currentLabels))
-                         .build();
-        return email;
-    }
-
-    private List<Email> parseArchive(MailingList archive) {
-        var conversations = archive.conversations(Duration.ofDays(365));
-
-        if (conversations.size() == 0) {
-            return new ArrayList<>();
-        } else if (conversations.size() == 1) {
-            var conversation = conversations.get(0);
-            return conversation.allMessages();
-        } else {
-            throw new RuntimeException("Something is wrong with the mbox");
-        }
-    }
-
-    private Map<Email, Email> findParents(Map<EmailAddress, Email> emailIds) {
-        var parents = new HashMap<Email, Email>();
-        for (var entry : emailIds.entrySet()) {
-            if (entry.getValue().hasHeader("In-Reply-To")) {
-                var replyId = EmailAddress.parse(entry.getValue().headerValue("In-Reply-To"));
+        for (var ignoredCommentPattern : bot.ignoredComments()) {
+            var ignoredCommentMatcher = ignoredCommentPattern.matcher(body);
+            if (ignoredCommentMatcher.find()) {
+                return true;
             }
         }
-        return parents;
-    }
-
-    private final Pattern replyHeaderPattern = Pattern.compile("^On .* <(.*)> wrote:$.*",
-                                                               Pattern.DOTALL | Pattern.MULTILINE);
-
-    // Combine mails from the same author, directed at the same person, into a single mail
-    private List<Email> combineMails(List<Email> emails) {
-        var byAuthor = emails.stream().collect(Collectors.groupingBy(Email::author));
-        var ret = new ArrayList<Email>();
-        for (var authorMails : byAuthor.entrySet()) {
-            var byTarget = authorMails.getValue().stream()
-                                      .collect(Collectors.groupingBy(email -> {
-                                          var matcher = replyHeaderPattern.matcher(email.body());
-                                          if (matcher.matches()) {
-                                              return matcher.group(1);
-                                          } else {
-                                              // No grouping of undirected messages
-                                              return "";
-                                          }
-                                      }));
-
-            for (var targetMails : byTarget.entrySet()) {
-                if (!targetMails.getKey().isEmpty()) {
-                    var first = targetMails.getValue().get(0);
-                    var body = new StringBuilder(first.body());
-                    for (int i = 1; i < targetMails.getValue().size(); ++i) {
-                        var addon = targetMails.getValue().get(i).body().lines()
-                                               .skip(2)
-                                               .dropWhile(line -> line.startsWith(">"))
-                                               .skip(1)
-                                               .collect(Collectors.joining("\n"));
-                        body.append("\n\n").append(addon);
-                    }
-                    var combined = Email.from(first).body(body.toString()).build();
-                    ret.add(combined);
-
-                } else {
-                    ret.addAll(targetMails.getValue());
-                }
-            }
-        }
-
-        return ret;
+        return false;
     }
 
     private static final String webrevCommentMarker = "<!-- mlbridge webrev comment -->";
     private static final String webrevHeaderMarker = "<!-- mlbridge webrev header -->";
     private static final String webrevListMarker = "<!-- mlbridge webrev list -->";
@@ -540,21 +168,34 @@
         } else {
             pr.addComment(comment);
         }
     }
 
+    private List<Email> parseArchive(MailingList archive) {
+        var conversations = archive.conversations(Duration.ofDays(365));
+
+        if (conversations.size() == 0) {
+            return new ArrayList<>();
+        } else if (conversations.size() == 1) {
+            var conversation = conversations.get(0);
+            return conversation.allMessages();
+        } else {
+            throw new RuntimeException("Something is wrong with the mbox");
+        }
+    }
+
     @Override
     public void run(Path scratchPath) {
         var path = scratchPath.resolve("mlbridge");
         var archiveRepo = materializeArchive(path);
         var mboxBasePath = path.resolve(bot.codeRepo().getName());
         var mbox = MailingListServerFactory.createMboxFileServer(mboxBasePath);
-        var archive = mbox.getList(pr.getId());
-        var archiveMails = parseArchive(archive);
+        var reviewArchiveList = mbox.getList(pr.getId());
+        var sentMails = parseArchive(reviewArchiveList);
 
         // First determine if this PR should be inspected further or not
-        if (archiveMails.isEmpty()) {
+        if (sentMails.isEmpty()) {
             var labels = new HashSet<>(pr.getLabels());
             for (var readyLabel : bot.readyLabels()) {
                 if (!labels.contains(readyLabel)) {
                     log.fine("PR is not yet ready - missing label '" + readyLabel + "'");
                     return;
@@ -562,11 +203,11 @@
             }
         }
 
         // Also inspect comments before making the first post
         var comments = pr.getComments();
-        if (archiveMails.isEmpty()) {
+        if (sentMails.isEmpty()) {
             for (var readyComment : bot.readyComments().entrySet()) {
                 var commentFound = false;
                 for (var comment : comments) {
                     if (comment.author().userName().equals(readyComment.getKey())) {
                         var matcher = readyComment.getValue().matcher(comment.body());
@@ -582,145 +223,88 @@
                     return;
                 }
             }
         }
 
+        var census = CensusInstance.create(bot.censusRepo(), bot.censusRef(), scratchPath.resolve("census"), pr);
+        var prInstance = new PullRequestInstance(scratchPath.resolve("mlbridge-mergebase"), pr);
+        var reviewArchive = new ReviewArchive(bot.emailAddress(), prInstance, sentMails,
+                                              " via " + pr.repository().getUrl().getHost());
         var webrevPath = scratchPath.resolve("mlbridge-webrevs");
         var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer());
         var list = listServer.getList(bot.listAddress().address());
-        var newMails = new ArrayList<Email>();
-        var stableIdToMail = archiveMails.stream().collect(Collectors.toMap(email -> getStableMessageId(email.id()),
-                                                                            Function.identity()));
-        var prInstance = new PullRequestInstance(scratchPath.resolve("mlbridge-mergebase"), pr);
 
         // First post
-        if (archiveMails.isEmpty()) {
+        if (sentMails.isEmpty()) {
+            log.fine("Creating new PR review archive");
             var webrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
                                                               prInstance.headHash(), "00");
-            var firstMail = newConversation(prInstance, webrev);
-            archive.post(firstMail);
-            newMails.add(firstMail);
-            stableIdToMail.put(getStableMessageId(firstMail.id()), firstMail);
+            reviewArchive.create(webrev);
             updateWebrevComment(comments, 0, webrev, null);
-            log.fine("Posting new PR conversation");
         } else {
-            // Determine the latest head hash reported
-            var reportedHeads = archiveMails.stream()
-                                            .filter(email -> email.hasHeader("PR-Head-Hash"))
-                                            .map(email -> email.headerValue("PR-Head-Hash"))
-                                            .map(Hash::new)
-                                            .collect(Collectors.toList());
-            var latestHead = reportedHeads.size() > 0 ? reportedHeads.get(reportedHeads.size() - 1) : pr.getHeadHash();
+            var latestHead = reviewArchive.latestHead();
 
             // Check if the head has changed
             if (!pr.getHeadHash().equals(latestHead)) {
-                log.fine("Head hash change detected: current: " + pr.getHeadHash() + " - existing: " + reportedHeads);
-
-                // Determine the latest base hash reported
-                var reportedBases = archiveMails.stream()
-                                                .filter(email -> email.hasHeader("PR-Base-Hash"))
-                                                .map(email -> email.headerValue("PR-Base-Hash"))
-                                                .map(Hash::new)
-                                                .collect(Collectors.toList());
-                if (reportedBases.size() == 0) {
-                    throw new RuntimeException("No previous bases found?");
-                }
-                var latestBase = reportedBases.get(reportedBases.size() - 1);
-                var firstMail = archiveMails.get(0);
-                Email commentMail;
+                log.fine("Head hash change detected: current: " + pr.getHeadHash() + " - last: " + latestHead);
+
+                var latestBase = reviewArchive.latestBase();
                 if (!prInstance.baseHash().equals(latestBase)) {
+                    // FIXME: Could try harder to make an incremental
                     var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
-                                                                          prInstance.headHash(), String.format("%02d", reportedHeads.size()));
-                    commentMail = rebaseComment(firstMail, latestBase, prInstance, fullWebrev);
-                    updateWebrevComment(comments, reportedHeads.size(), fullWebrev, null);
+                                                                          prInstance.headHash(), String.format("%02d", reviewArchive.revisionCount()));
+                    reviewArchive.addFull(fullWebrev);
+                    updateWebrevComment(comments, reviewArchive.revisionCount(), fullWebrev, null);
                 } else {
-                    var index = reportedHeads.size();
+                    var index = reviewArchive.revisionCount();
                     var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
                                                                           prInstance.headHash(), String.format("%02d", index));
                     var incrementalWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, latestHead,
                                                                                  prInstance.headHash(), String.format("%02d-%02d", index - 1, index));
-                    commentMail = incrementalComment(firstMail, latestHead, prInstance, fullWebrev, incrementalWebrev);
+                    reviewArchive.addIncremental(fullWebrev, incrementalWebrev);
                     updateWebrevComment(comments, index, fullWebrev, incrementalWebrev);
                 }
-                archive.post(commentMail);
-                newMails.add(commentMail);
-                stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
             }
         }
 
         // Regular comments
-        var previous = archiveMails.size() > 0 ? archiveMails.get(0) : newMails.get(0);
         for (var comment : comments) {
-            var id = getStableMessageId(getMessageId(comment));
-            if (stableIdToMail.containsKey(id)) {
-                previous = stableIdToMail.get(id);
-                continue;
-            }
             if (ignoreComment(comment.author(), comment.body())) {
                 continue;
             }
-
-            // Try to determine a parent post from @mentions
-            var parentComment = getParentPost(comment, comments);
-            var parent = parentComment.map(c -> stableIdToMail.get(getStableMessageId(getMessageId(c)))).orElse(previous);
-
-            var commentMail = comment(parent, comment);
-            archive.post(commentMail);
-            newMails.add(commentMail);
-            stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
-            previous = commentMail;
+            reviewArchive.addComment(comment);
         }
 
         // Review comments
-        final var first = archiveMails.size() > 0 ? archiveMails.get(0) : newMails.get(0);
         var reviews = pr.getReviews();
         for (var review : reviews) {
-            var id = getStableMessageId(getMessageId(review));
-            if (stableIdToMail.containsKey(id)) {
-                continue;
-            }
             if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
                 continue;
             }
-
-            var commentMail = review(first, review);
-            archive.post(commentMail);
-            newMails.add(commentMail);
-            stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
+            reviewArchive.addReview(review, census);
         }
 
-
         // File specific comments
         var reviewComments = pr.getReviewComments();
         for (var reviewComment : reviewComments) {
-            var id = getStableMessageId(getMessageId(reviewComment));
-            if (stableIdToMail.containsKey(id)) {
-                continue;
-            }
             if (ignoreComment(reviewComment.author(), reviewComment.body())) {
                 continue;
             }
-
-            var parent = reviewComment.parent().map(c -> stableIdToMail.get(getStableMessageId(getMessageId(c)))).orElse(first);
-            var commentMail = reviewComment(parent, reviewComment);
-            archive.post(commentMail);
-            newMails.add(commentMail);
-            stableIdToMail.put(getStableMessageId(commentMail.id()), commentMail);
+            reviewArchive.addReviewComment(reviewComment);
         }
 
+        var newMails = reviewArchive.generatedEmails();
         if (newMails.isEmpty()) {
             return;
         }
 
         // Push all new mails to the archive repository
+        newMails.forEach(reviewArchiveList::post);
         pushMbox(archiveRepo, "Adding comments for PR " + bot.codeRepo().getName() + "/" + pr.getId());
 
-        // Combine and post all new mails to the list
-        var listMails = combineMails(newMails);
-        for (var mail : listMails) {
-            list.post(mail);
-        }
+        // Finally post all new mails to the actual list
+        newMails.forEach(list::post);
     }
 
     @Override
     public void handleRuntimeException(RuntimeException e) {
         exceptionConsumer.accept(e);
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/CensusInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/CensusInstance.java
@@ -18,11 +18,11 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
-package org.openjdk.skara.bots.pr;
+package org.openjdk.skara.bots.mlbridge;
 
 import org.openjdk.skara.census.*;
 import org.openjdk.skara.host.*;
 import org.openjdk.skara.jcheck.JCheckConfiguration;
 import org.openjdk.skara.vcs.*;
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBot.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBot.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBot.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBot.java
@@ -33,29 +33,36 @@
 
 public class MailingListBridgeBot implements Bot {
     private final EmailAddress emailAddress;
     private final HostedRepository codeRepo;
     private final HostedRepository archiveRepo;
+    private final HostedRepository censusRepo;
+    private final String censusRef;
     private final EmailAddress listAddress;
     private final Set<String> ignoredUsers;
+    private final Set<Pattern> ignoredComments;
     private final URI listArchive;
     private final String smtpServer;
     private final WebrevStorage webrevStorage;
     private final Set<String> readyLabels;
     private final Map<String, Pattern> readyComments;
     private final PullRequestUpdateCache updateCache;
 
-    MailingListBridgeBot(EmailAddress from, HostedRepository repo, HostedRepository archive, EmailAddress list,
-                         Set<String> ignoredUsers, URI listArchive, String smtpServer,
+    MailingListBridgeBot(EmailAddress from, HostedRepository repo, HostedRepository archive,
+                         HostedRepository censusRepo, String censusRef, EmailAddress list,
+                         Set<String> ignoredUsers, Set<Pattern> ignoredComments, URI listArchive, String smtpServer,
                          HostedRepository webrevStorageRepository, String webrevStorageRef,
                          Path webrevStorageBase, URI webrevStorageBaseUri, Set<String> readyLabels,
                          Map<String, Pattern> readyComments) {
         emailAddress = from;
         codeRepo = repo;
+        this.censusRepo = censusRepo;
+        this.censusRef = censusRef;
         listAddress = list;
         this.ignoredUsers = ignoredUsers;
+        this.ignoredComments = ignoredComments;
         this.listArchive = listArchive;
         this.smtpServer = smtpServer;
         this.readyLabels = readyLabels;
         this.readyComments = readyComments;
 
@@ -70,10 +77,18 @@
 
     HostedRepository archiveRepo() {
         return archiveRepo;
     }
 
+    HostedRepository censusRepo() {
+        return censusRepo;
+    }
+
+    String censusRef() {
+        return censusRef;
+    }
+
     EmailAddress emailAddress() {
         return emailAddress;
     }
 
     EmailAddress listAddress() {
@@ -82,10 +97,14 @@
 
     Set<String> ignoredUsers() {
         return ignoredUsers;
     }
 
+    Set<Pattern> ignoredComments() {
+        return ignoredComments;
+    }
+
     URI listArchive() {
         return listArchive;
     }
 
     String smtpServer() {
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotFactory.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotFactory.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotFactory.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotFactory.java
@@ -44,13 +44,17 @@
     public List<Bot> create(BotConfiguration configuration) {
         var ret = new ArrayList<Bot>();
         var specific = configuration.specific();
 
         var from = EmailAddress.from(specific.get("name").asString(), specific.get("mail").asString());
-        var ignoredUsers = specific.get("ignored").stream()
+        var ignoredUsers = specific.get("ignored").get("users").stream()
                                    .map(JSONValue::asString)
                                    .collect(Collectors.toSet());
+        var ignoredComments = specific.get("ignored").get("comments").stream()
+                                      .map(JSONValue::asString)
+                                      .map(pattern -> Pattern.compile(pattern, Pattern.MULTILINE | Pattern.DOTALL))
+                                      .collect(Collectors.toSet());
         var listArchive = URIBuilder.base(specific.get("server").get("archive").asString()).build();
         var listSmtp = specific.get("server").get("smtp").asString();
 
         var webrevRepo = configuration.repository(specific.get("webrevs").get("repository").asString());
         var webrevRef = configuration.repositoryRef(specific.get("webrevs").get("repository").asString());
@@ -69,14 +73,18 @@
                 .collect(Collectors.toMap(obj -> obj.get("user").asString(),
                                           obj -> Pattern.compile(obj.get("pattern").asString())));
 
         for (var repoConfig : specific.get("repositories").asArray()) {
             var repo = repoConfig.get("repository").asString();
+            var censusRepo = configuration.repository(repoConfig.get("census").asString());
+            var censusRef = configuration.repositoryRef(repoConfig.get("census").asString());
+
             var list = EmailAddress.parse(repoConfig.get("list").asString());
             var folder = repoConfig.contains("folder") ? repoConfig.get("folder").asString() : configuration.repositoryName(repo);
             var bot = new MailingListBridgeBot(from, configuration.repository(repo), archiveRepo,
-                                               list, ignoredUsers, listArchive, listSmtp,
+                                               censusRepo, censusRef,
+                                               list, ignoredUsers, ignoredComments, listArchive, listSmtp,
                                                webrevRepo, webrevRef, Path.of(folder),
                                                URIBuilder.base(webrevWeb).build(), readyLabels, readyComments);
             ret.add(bot);
 
             allListNames.add(list);
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/PullRequestInstance.java
@@ -88,6 +88,10 @@
     }
 
     String id() {
         return pr.getId();
     }
+
+    PullRequest pr() {
+        return pr;
+    }
 }
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- /dev/null
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -0,0 +1,380 @@
+package org.openjdk.skara.bots.mlbridge;
+
+import org.openjdk.skara.census.Contributor;
+import org.openjdk.skara.email.*;
+import org.openjdk.skara.host.*;
+import org.openjdk.skara.vcs.Hash;
+
+import java.io.*;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.security.*;
+import java.util.*;
+import java.util.stream.*;
+
+class ReviewArchive {
+    private final PullRequestInstance prInstance;
+    private final EmailAddress sender;
+    private final String nameDecoration;
+    private final List<Email> existing;
+    private final Map<String, Email> existingIds = new HashMap<>();
+    private final List<Email> generated = new ArrayList<>();
+    private final Map<String, Email> generatedIds = new HashMap<>();
+    private final List<Hash> reportedHeads;
+    private final List<Hash> reportedBases;
+
+    private EmailAddress getAuthorAddress(HostUserDetails originalAuthor) {
+        return EmailAddress.from(originalAuthor.fullName() + nameDecoration,
+                                 sender.address());
+    }
+
+    private EmailAddress getUniqueMessageId(String identifier) {
+        try {
+            var prSpecific = prInstance.pr().repository().getName().replace("/", ".") + "." + prInstance.id();
+            var digest = MessageDigest.getInstance("SHA-256");
+            digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
+            digest.update(identifier.getBytes(StandardCharsets.UTF_8));
+            var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
+
+            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + prInstance.pr().repository().getUrl().getHost());
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Cannot find SHA-256");
+        }
+    }
+
+    private EmailAddress getMessageId() {
+        return getUniqueMessageId("fc");
+    }
+
+    private EmailAddress getMessageId(Comment comment) {
+        return getUniqueMessageId("pc" + comment.id());
+    }
+
+    private EmailAddress getMessageId(ReviewComment comment) {
+        return getUniqueMessageId("rc" + comment.id());
+    }
+
+    private EmailAddress getMessageId(Hash hash) {
+        return getUniqueMessageId("ha" + hash.hex());
+    }
+
+    private EmailAddress getMessageId(String raw) {
+        return getUniqueMessageId("rw" + raw);
+    }
+
+    private EmailAddress getMessageId(Review review, boolean verdict) {
+        if (verdict) {
+            return getUniqueMessageId("rvvd" + review.id());
+        } else {
+            return getUniqueMessageId("rv" + review.id());
+        }
+    }
+
+    private String getStableMessageId(EmailAddress uniqueMessageId) {
+        return uniqueMessageId.localPart().split("\\.")[0];
+    }
+
+    private Set<String> getStableMessageIds(Email email) {
+        var ret = new HashSet<String>();
+        ret.add(getStableMessageId(email.id()));
+        if (email.hasHeader("PR-Collapsed-IDs")) {
+            var additional = email.headerValue("PR-Collapsed-IDs").split(" ");
+            ret.addAll(Arrays.asList(additional));
+        }
+        return ret;
+    }
+
+    private Email topEmail() {
+        if (!existing.isEmpty()) {
+            return existing.get(0);
+        }
+        return generated.get(0);
+    }
+
+    // Returns a suitable parent to use for a general comment
+    private Email latestGeneralComment() {
+        return Stream.concat(existing.stream(), generated.stream())
+                     .filter(email -> !email.hasHeader("PR-Head-Hash"))
+                     .filter(email -> email.subject().startsWith("Re: RFR"))
+                     .max(Comparator.comparingInt(email -> Integer.parseInt(email.headerValue("PR-Sequence"))))
+                     .orElse(topEmail());
+    }
+
+    // Returns the top-level comment for a certain head hash
+    private Email topCommentForHash(Hash hash) {
+        return Stream.concat(existing.stream(), generated.stream())
+                     .filter(email -> email.hasHeader("PR-Head-Hash"))
+                     .filter(email -> email.headerValue("PR-Head-Hash").equals(hash.hex()))
+                     .findFirst()
+                     .orElse(topEmail());
+    }
+
+    private Email parentForReviewComment(ReviewComment reviewComment) {
+        var parent = topCommentForHash(reviewComment.hash());
+        if (reviewComment.parent().isPresent()) {
+            var parentId = getStableMessageId(getMessageId(reviewComment.parent().get()));
+            var last = Stream.concat(existing.stream(), generated.stream())
+                             .filter(email -> (email.hasHeader("References") && email.headerValue("References").contains(parentId)) ||
+                                     (getStableMessageId(email.id()).equals(parentId)))
+                             .max(Comparator.comparingInt(email -> Integer.parseInt(email.headerValue("PR-Sequence"))));
+
+            if (last.isEmpty()) {
+                throw  new RuntimeException("Failed to find parent");
+            } else {
+                return last.get();
+            }
+        }
+        return parent;
+    }
+
+    ReviewArchive(EmailAddress sender, PullRequestInstance prInstance, List<Email> sentMails, String nameDecoration) {
+        this.sender = sender;
+        this.prInstance = prInstance;
+        this.nameDecoration = nameDecoration;
+
+        existing = sentMails;
+        for (var email : existing) {
+            var stableIds = getStableMessageIds(email);
+            for (var stableId : stableIds) {
+                existingIds.put(stableId, email);
+            }
+        }
+
+        // Determine the latest hashes reported
+        reportedHeads = existing.stream()
+                                .filter(email -> email.hasHeader("PR-Head-Hash"))
+                                .map(email -> email.headerValue("PR-Head-Hash"))
+                                .map(Hash::new)
+                                .collect(Collectors.toList());
+        reportedBases = existing.stream()
+                                .filter(email -> email.hasHeader("PR-Base-Hash"))
+                                .map(email -> email.headerValue("PR-Base-Hash"))
+                                .map(Hash::new)
+                                .collect(Collectors.toList());
+    }
+
+    Hash latestHead() {
+        if (reportedHeads.isEmpty()) {
+            throw new IllegalArgumentException("No head reported yet");
+        }
+        return reportedHeads.get(reportedHeads.size() - 1);
+    }
+
+    Hash latestBase() {
+        if (reportedBases.isEmpty()) {
+            throw new IllegalArgumentException("No base reported yet");
+        }
+        return reportedBases.get(reportedBases.size() - 1);
+    }
+
+    int revisionCount() {
+        return reportedHeads.size();
+    }
+
+    void create(URI webrev) {
+        var body = ArchiveMessages.composeConversation(prInstance, webrev);
+        var id = getMessageId();
+        var email = Email.create("RFR: " + prInstance.pr().getTitle(), body)
+                         .sender(sender)
+                         .author(getAuthorAddress(prInstance.pr().getAuthor()))
+                         .id(id)
+                         .header("PR-Head-Hash", prInstance.headHash().hex())
+                         .header("PR-Base-Hash", prInstance.baseHash().hex())
+                         .build();
+        generated.add(email);
+        generatedIds.put(getStableMessageId(id), email);
+    }
+
+    private String latestHeadSubject() {
+        try {
+            var latestCommit = prInstance.localRepo().lookup(prInstance.headHash()).orElseThrow(RuntimeException::new);
+            var firstLine = latestCommit.message().size() > 0 ? latestCommit.message().get(0) : prInstance.pr().getTitle();
+            return String.format("%02d: %s", revisionCount(), firstLine);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    void addFull(URI webrev) {
+        var body = ArchiveMessages.composeRebaseComment(prInstance, webrev);
+        var id = getMessageId(prInstance.headHash());
+        var parent = topEmail();
+        var email = Email.create(latestHeadSubject(), body)
+                         .sender(sender)
+                         .author(getAuthorAddress(prInstance.pr().getAuthor()))
+                         .recipient(parent.author())
+                         .id(id)
+                         .header("In-Reply-To", parent.id().toString())
+                         .header("References", parent.id().toString())
+                         .header("PR-Head-Hash", prInstance.headHash().hex())
+                         .header("PR-Base-Hash", prInstance.baseHash().hex())
+                         .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
+                         .build();
+        generated.add(email);
+        generatedIds.put(getStableMessageId(id), email);
+    }
+
+    void addIncremental(URI fullWebrev, URI incrementalWebrev) {
+        var body = ArchiveMessages.composeIncrementalComment(latestHead(), prInstance, fullWebrev, incrementalWebrev);
+        var id = getMessageId(prInstance.headHash());
+        var parent = topEmail();
+        var email = Email.create(latestHeadSubject(), body)
+                         .sender(sender)
+                         .author(getAuthorAddress(prInstance.pr().getAuthor()))
+                         .recipient(parent.author())
+                         .id(id)
+                         .header("In-Reply-To", parent.id().toString())
+                         .header("References", parent.id().toString())
+                         .header("PR-Head-Hash", prInstance.headHash().hex())
+                         .header("PR-Base-Hash", prInstance.baseHash().hex())
+                         .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
+                         .build();
+        generated.add(email);
+        generatedIds.put(getStableMessageId(id), email);
+    }
+
+    private Optional<Email> findCollapsable(Email parent, HostUserDetails author) {
+        var parentId = getStableMessageId(parent.id());
+
+        // Is it a self-reply?
+        if (parent.author().equals(getAuthorAddress(author)) && generatedIds.containsKey(parentId)) {
+            return Optional.of(parent);
+        }
+
+        // Have we already replied to the same parent?
+        for (var candidate : generated) {
+            if (!candidate.hasHeader("In-Reply-To")) {
+                continue;
+            }
+            var inReplyTo = EmailAddress.parse(candidate.headerValue("In-Reply-To"));
+            var candidateParentId = getStableMessageId(inReplyTo);
+            if (candidateParentId.equals(parentId) && candidate.author().equals(getAuthorAddress(author))) {
+                return Optional.of(candidate);
+            }
+        }
+
+        return Optional.empty();
+    }
+
+    private void addReplyCommon(Email parent, HostUserDetails author, String subject, String body, EmailAddress id) {
+        var references = parent.id().toString();
+        if (parent.hasHeader("References")) {
+            references = parent.headerValue("References") + " " + references;
+        }
+
+        // Collapse self-replies and replies-to-same that have been created in this run
+        var collapsable = findCollapsable(parent, author);
+        if (collapsable.isPresent()) {
+            // Drop the parent
+            var parentEmail = collapsable.get();
+            generated.remove(parentEmail);
+            generatedIds.remove(getStableMessageId(parentEmail.id()));
+
+            var collapsed = parentEmail.hasHeader("PR-Collapsed-IDs") ? parentEmail.headerValue("PR-Collapsed-IDs") : "";
+            collapsed += getStableMessageId(parentEmail.id());
+
+            var reply = ArchiveMessages.composeCombinedReply(parentEmail, body, prInstance);
+            var email = Email.from(parentEmail)
+                             .body(reply)
+                             .id(id)
+                             .header("PR-Collapsed-IDs", collapsed)
+                             .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
+                             .build();
+            generated.add(email);
+            generatedIds.put(getStableMessageId(id), email);
+        } else {
+            var reply = ArchiveMessages.composeReply(parent, body, prInstance);
+            var email = Email.create(subject, reply)
+                             .sender(sender)
+                             .author(getAuthorAddress(author))
+                             .recipient(parent.author())
+                             .id(id)
+                             .header("In-Reply-To", parent.id().toString())
+                             .header("References", references)
+                             .header("PR-Sequence", Integer.toString(existing.size() + generated.size()))
+                             .build();
+            generated.add(email);
+            generatedIds.put(getStableMessageId(id), email);
+        }
+    }
+
+    void addComment(Comment comment) {
+        var id = getMessageId(comment);
+        if (existingIds.containsKey(getStableMessageId(id))) {
+            return;
+        }
+
+        var parent = latestGeneralComment();
+        addReplyCommon(parent, comment.author(), "Re: RFR: " + prInstance.pr().getTitle(), comment.body(), id);
+    }
+
+    private String projectRole(Contributor contributor, CensusInstance censusInstance) {
+        var version = censusInstance.configuration().census().version();
+        if (censusInstance.project().isLead(contributor.username(), version)) {
+            return "Lead";
+        } else if (censusInstance.project().isReviewer(contributor.username(), version)) {
+            return "Reviewer";
+        } else if (censusInstance.project().isCommitter(contributor.username(), version)) {
+            return "Committer";
+        } else if (censusInstance.project().isAuthor(contributor.username(), version)) {
+            return "Author";
+        }
+        return "none";
+    }
+
+    void addReview(Review review, CensusInstance censusInstance) {
+        var contributor = censusInstance.namespace().get(review.reviewer().id());
+
+        // Post the review body as a regular comment
+        if (review.body().isPresent()) {
+            var id = getMessageId(review, false);
+            if (!existingIds.containsKey(getStableMessageId(id))) {
+                var parent = topCommentForHash(review.hash());
+                var userName = contributor != null ? contributor.username() : review.reviewer().userName() + "@" + censusInstance.namespace().name();
+                var userRole = contributor != null ? projectRole(contributor, censusInstance) : "none";
+                var replyBody = ArchiveMessages.reviewCommentBody(review.body().get(), review.verdict(), userName, userRole);
+                addReplyCommon(parent, review.reviewer(), "Re: RFR: " + prInstance.pr().getTitle(), replyBody, id);
+            }
+        }
+
+        if (contributor != null) {
+            var isReviewer = censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
+            if (review.verdict() == Review.Verdict.APPROVED && isReviewer) {
+                var id = getMessageId(review, true);
+                if (!existingIds.containsKey(getStableMessageId(id))) {
+                    var parent = topEmail();
+                    var replyBody = ArchiveMessages.reviewApprovalBodyReviewer(contributor.username());
+                    addReplyCommon(parent, review.reviewer(), "Approved and Reviewed by " + contributor.username(), replyBody, id);
+                }
+            }
+        }
+    }
+
+    void addReviewComment(ReviewComment reviewComment) {
+        var id = getMessageId(reviewComment);
+        if (existingIds.containsKey(getStableMessageId(id))) {
+            return;
+        }
+
+        var parent = parentForReviewComment(reviewComment);
+        var body = new StringBuilder();
+
+        // Add some context to the first post
+        if (reviewComment.parent().isEmpty()) {
+            var contents = prInstance.pr().repository().getFileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());
+
+            body.append(reviewComment.path()).append(" line ").append(reviewComment.line()).append(":\n\n");
+            for (int i = Math.max(0, reviewComment.line() - 2); i < Math.min(contents.size(), reviewComment.line() + 1); ++i) {
+                body.append("> ").append(i + 1).append(": ").append(contents.get(i)).append("\n");
+            }
+            body.append("\n");
+        }
+        body.append(reviewComment.body());
+
+        addReplyCommon(parent, reviewComment.author(), "Re: RFR: " + prInstance.pr().getTitle(), body.toString(), id);
+    }
+
+    List<Email> generatedEmails() {
+        return generated;
+    }
+}
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListArchiveReaderBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListArchiveReaderBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListArchiveReaderBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListArchiveReaderBotTests.java
@@ -62,12 +62,14 @@
             var ignored = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress,
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress,
                                                  Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -123,12 +125,14 @@
             var ignored = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress,
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress,
                                                  Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -96,12 +96,13 @@
             var ignored = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress,
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master", listAddress,
                                                  Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of("rfr"), Map.of(ignored.host().getCurrentUserDetails().userName(),
                                                                        Pattern.compile("ready")));
@@ -244,12 +245,13 @@
             var ignored = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress,
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master", listAddress,
                                                  Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -328,11 +330,13 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(), listServer.getArchive(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
+                                                 listServer.getArchive(),
                                                  listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -355,15 +359,15 @@
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review comment");
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
-            // The archive should not contain a combined entry
+            // The archive should contain a combined entry
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(2, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
 
-            // But the mailing list should
+            // As well as the mailing list
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP());
             var mailmanList = mailmanServer.getList(listAddress.address());
             var conversations = mailmanList.conversations(Duration.ofDays(1));
             assertEquals(1, conversations.size());
             var mail = conversations.get(0).first();
@@ -377,10 +381,104 @@
             assertTrue(reply.body().contains("Review comment\n\n"), reply.body());
             assertTrue(reply.body().contains("Another review comment"), reply.body());
         }
     }
 
+    @Test
+    void commentThreading(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var archiveFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var author = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+            var archive = credentials.getHostedRepository();
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addReviewer(reviewer.host().getCurrentUserDetails().id())
+                                           .addAuthor(author.host().getCurrentUserDetails().id());
+            var from = EmailAddress.from("test", "test@test.mail");
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
+                                                 listServer.getArchive(),
+                                                 listServer.getSMTP(),
+                                                 archive, "webrev", Path.of("test"),
+                                                 URIBuilder.base("http://www.test.test/").build(),
+                                                 Set.of(), Map.of());
+
+            // Populate the projects repository
+            var reviewFile = Path.of("reviewfile.txt");
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.getRepositoryType(), reviewFile);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.getUrl(), "master", true);
+            localRepo.push(masterHash, archive.getUrl(), "webrev", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.getUrl(), "edit", true);
+            var pr = credentials.createPullRequest(archive, "master", "edit", "This is a pull request");
+            pr.setBody("This is now ready");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            // Make a file specific comment
+            var reviewPr = reviewer.getPullRequest(pr.getId());
+            var comment1 = reviewPr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review comment");
+            pr.addReviewCommentReply(comment1, "I agree");
+            reviewPr.addReviewCommentReply(comment1, "Great");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            // And a second one by ourselves
+            var comment2 = pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
+            reviewPr.addReviewCommentReply(comment2, "Sounds good");
+            pr.addReviewCommentReply(comment2, "Thanks");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            // Sanity check the archive
+            Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
+            assertEquals(6, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+
+            // Check the mailing list
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP());
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(1, conversations.size());
+            var mail = conversations.get(0).first();
+            assertEquals("RFR: This is a pull request", mail.subject());
+            assertEquals(7, conversations.get(0).allMessages().size());
+
+            // There should be two separate threads
+            var thread1 = conversations.get(0).replies(mail).get(0);
+            assertEquals(2, thread1.body().split("^On.*wrote:").length);
+            assertEquals(2, thread1.body().split("> This is now ready").length, thread1.body());
+            assertEquals("Re: RFR: This is a pull request", thread1.subject());
+            assertTrue(thread1.body().contains("Review comment\n\n"), thread1.body());
+            assertFalse(thread1.body().contains("Another review comment"), thread1.body());
+            var thread1reply1 = conversations.get(0).replies(thread1).get(0);
+            assertTrue(thread1reply1.body().contains("I agree"));
+            var thread1reply2 = conversations.get(0).replies(thread1reply1).get(0);
+            assertTrue(thread1reply2.body().contains("Great"));
+
+            var thread2 = conversations.get(0).replies(mail).get(1);
+            assertEquals(2, thread2.body().split("^On.*wrote:").length);
+            assertEquals(2, thread2.body().split("> This is now ready").length, thread2.body());
+            assertEquals("Re: RFR: This is a pull request", thread2.subject());
+            assertFalse(thread2.body().contains("Review comment\n\n"), thread2.body());
+            assertTrue(thread2.body().contains("Another review comment"), thread2.body());
+            var thread2reply1 = conversations.get(0).replies(thread2).get(0);
+            assertTrue(thread2reply1.body().contains("Sounds good"));
+            var thread2reply2 = conversations.get(0).replies(thread2reply1).get(0);
+            assertTrue(thread2reply2.body().contains("Thanks"));
+        }
+    }
+
     @Test
     void reviewContext(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory();
              var archiveFolder = new TemporaryDirectory();
@@ -389,11 +487,13 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(), listServer.getArchive(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
+                                                 listServer.getArchive(),
                                                  listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -436,11 +536,13 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(), listServer.getArchive(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
+                                                 listServer.getArchive(),
                                                  listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -502,11 +604,12 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -557,11 +660,12 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -666,11 +770,12 @@
             var archive = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(),
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -752,12 +857,14 @@
             var ignored = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var censusBuilder = credentials.getCensusBuilder()
                                            .addAuthor(author.host().getCurrentUserDetails().id());
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress,
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress,
                                                  Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -817,13 +924,18 @@
              var tempFolder = new TemporaryDirectory();
              var archiveFolder = new TemporaryDirectory();
              var listServer = new TestMailmanServer()) {
             var author = credentials.getHostedRepository();
             var archive = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
             var listAddress = EmailAddress.parse(listServer.createList("test"));
             var from = EmailAddress.from("test", "test@test.mail");
-            var mlBot = new MailingListBridgeBot(from, author, archive, listAddress, Set.of(),
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addReviewer(reviewer.host().getCurrentUserDetails().id())
+                                           .addAuthor(author.host().getCurrentUserDetails().id());
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress, Set.of(), Set.of(),
                                                  listServer.getArchive(), listServer.getSMTP(),
                                                  archive, "webrev", Path.of("test"),
                                                  URIBuilder.base("http://www.test.test/").build(),
                                                  Set.of(), Map.of());
 
@@ -842,19 +954,20 @@
 
             // Run an archive pass
             TestBotRunner.runPeriodicItems(mlBot);
 
             // First unapprove it
-            var reviewedPr = credentials.getHostedRepository().getPullRequest(pr.getId());
+            var reviewedPr = reviewer.getPullRequest(pr.getId());
             reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 1");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain a note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR has been reviewed.*more changes are needed"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Review status set to Disapproved"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), " by integrationreviewer1"));
             if (author.host().supportsReviewBody()) {
                 assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 1"));
             }
 
             // Then approve it
@@ -863,25 +976,83 @@
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR.*approved"));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Review status set to Approved"));
             if (author.host().supportsReviewBody()) {
                 assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 2"));
             }
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR has been marked as Reviewed by integrationreviewer1."));
 
             // Yet another change
             reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 3");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
 
             // The archive should contain another note
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(2, archiveContainsCount(archiveFolder.path(), "This PR.*more changes"));
+            assertEquals(2, archiveContainsCount(archiveFolder.path(), "Review status set to Disapproved"));
             if (author.host().supportsReviewBody()) {
                 assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 3"));
             }
         }
     }
+
+    @Test
+    void ignoreComments(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var archiveFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var author = credentials.getHostedRepository();
+            var ignored = credentials.getHostedRepository();
+            var archive = credentials.getHostedRepository();
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.host().getCurrentUserDetails().id());
+            var from = EmailAddress.from("test", "test@test.mail");
+            var mlBot = new MailingListBridgeBot(from, author, archive, censusBuilder.build(), "master",
+                                                 listAddress,
+                                                 Set.of(ignored.host().getCurrentUserDetails().userName()),
+                                                 Set.of(Pattern.compile("ignore this comment", Pattern.MULTILINE | Pattern.DOTALL)),
+                                                 listServer.getArchive(), listServer.getSMTP(),
+                                                 archive, "webrev", Path.of("test"),
+                                                 URIBuilder.base("http://www.test.test/").build(),
+                                                 Set.of(), Map.of());
+
+            // Populate the projects repository
+            var reviewFile = Path.of("reviewfile.txt");
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.getRepositoryType(), reviewFile);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.getUrl(), "master", true);
+            localRepo.push(masterHash, archive.getUrl(), "webrev", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.getUrl(), "edit", true);
+            var pr = credentials.createPullRequest(archive, "master", "edit", "This is a pull request");
+            pr.setBody("This is now ready");
+
+            // Make a bunch of comments
+            pr.addComment("Plain comment");
+            pr.addComment("ignore this comment");
+            pr.addComment("I think it is time to\nignore this comment!");
+            pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review ignore this comment");
+
+            var ignoredPR = ignored.getPullRequest(pr.getId());
+            ignoredPR.addComment("Don't mind me");
+
+            TestBotRunner.runPeriodicItems(mlBot);
+            TestBotRunner.runPeriodicItems(mlBot);
+
+            // The archive should not contain the ignored comments
+            Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
+            assertTrue(archiveContains(archiveFolder.path(), "This is now ready"));
+            assertFalse(archiveContains(archiveFolder.path(), "ignore this comment"));
+            assertFalse(archiveContains(archiveFolder.path(), "it is time to"));
+            assertFalse(archiveContains(archiveFolder.path(), "Don't mind me"));
+            assertFalse(archiveContains(archiveFolder.path(), "Review ignore"));
+        }
+    }
 }
diff a/email/src/main/java/org/openjdk/skara/email/Email.java b/email/src/main/java/org/openjdk/skara/email/Email.java
--- a/email/src/main/java/org/openjdk/skara/email/Email.java
+++ b/email/src/main/java/org/openjdk/skara/email/Email.java
@@ -117,10 +117,14 @@
 
     public static EmailBuilder create(EmailAddress author, String subject, String body) {
         return new EmailBuilder(author, subject, body);
     }
 
+    public static EmailBuilder create(String subject, String body) {
+        return new EmailBuilder(subject, body);
+    }
+
     public static EmailBuilder from(Email email) {
         return new EmailBuilder(email.author, email.subject, email.body)
                 .sender(email.sender)
                 .recipients(email.recipients)
                 .id(email.id)
diff a/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java b/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
--- a/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
+++ b/email/src/main/java/org/openjdk/skara/email/EmailBuilder.java
@@ -34,17 +34,20 @@
     private ZonedDateTime date;
 
     private final List<EmailAddress> recipients = new ArrayList<>();
     private final Map<String, String> headers = new HashMap<>();
 
-    EmailBuilder(EmailAddress author, String subject, String body) {
-        this.author = author;
+    EmailBuilder(String subject, String body) {
         this.subject = subject;
         this.body = body;
 
         date = ZonedDateTime.now();
     }
+    EmailBuilder(EmailAddress author, String subject, String body) {
+        this(subject, body);
+        author(author);
+    }
 
     public EmailBuilder author(EmailAddress author) {
         this.author = author;
         return this;
     }
diff a/test/src/main/java/org/openjdk/skara/test/SMTPServer.java b/test/src/main/java/org/openjdk/skara/test/SMTPServer.java
--- a/test/src/main/java/org/openjdk/skara/test/SMTPServer.java
+++ b/test/src/main/java/org/openjdk/skara/test/SMTPServer.java
@@ -51,11 +51,11 @@
             session.sendCommand("354 Enter message now, end with .");
             var message = session.readLinesUntil(messageEndPattern);
             session.sendCommand("250 MESSAGE OK", quitPattern);
 
             var email = Email.parse(String.join("\n", message));
-            emails.push(email);
+            emails.addLast(email);
         }
 
         @Override
         public void run() {
             while (!serverSocket.isClosed()) {
@@ -96,11 +96,11 @@
         }
 
         if (emails.isEmpty()) {
             throw new RuntimeException("No email received");
         }
-        return emails.pop();
+        return emails.removeFirst();
     }
 
     @Override
     public void close() throws IOException {
         serverSocket.close();
diff a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
--- a/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
+++ b/test/src/main/java/org/openjdk/skara/test/TestPullRequest.java
@@ -134,10 +134,13 @@
         return comment;
     }
 
     @Override
     public ReviewComment addReviewCommentReply(ReviewComment parent, String body) {
+        if (parent.parent().isPresent()) {
+            throw new RuntimeException("Can only reply to top-level review comments");
+        }
         var comment = new ReviewComment(parent, parent.threadId(), parent.hash(), parent.path(), parent.line(), String.valueOf(data.reviewComments.size()), body, user, ZonedDateTime.now(), ZonedDateTime.now());
         data.reviewComments.add(comment);
         data.lastUpdate = ZonedDateTime.now();
         return comment;
     }
