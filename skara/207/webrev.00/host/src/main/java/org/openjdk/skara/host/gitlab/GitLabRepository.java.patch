diff a/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabRepository.java b/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabRepository.java
--- a/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabRepository.java
+++ b/host/src/main/java/org/openjdk/skara/host/gitlab/GitLabRepository.java
@@ -21,11 +21,11 @@
  * questions.
  */
 package org.openjdk.skara.host.gitlab;
 
 import org.openjdk.skara.host.*;
-import org.openjdk.skara.host.network.*;
+import org.openjdk.skara.network.*;
 import org.openjdk.skara.json.*;
 import org.openjdk.skara.vcs.*;
 
 import java.net.*;
 import java.nio.charset.StandardCharsets;
@@ -59,31 +59,31 @@
                                    .setPath("/" + projectName + "/merge_requests/").build();
         mergeRequestPattern = Pattern.compile(urlPattern.toString() + "(\\d+)");
     }
 
     @Override
-    public Host host() {
+    public RepositoryHost host() {
         return gitLabHost;
     }
 
     @Override
     public Issue createIssue(String title, List<String> body) {
         throw new RuntimeException("not implemented yet");
     }
 
     @Override
-    public Optional<Issue> getIssue(String id) {
+    public Optional<Issue> issue(String id) {
         throw new RuntimeException("not implemented yet");
     }
 
     @Override
-    public List<Issue> getIssues() {
+    public List<Issue> issues() {
         throw new RuntimeException("not implemented yet");
     }
 
     @Override
-    public Optional<HostedRepository> getParent() {
+    public Optional<HostedRepository> parent() {
         if (json.contains("forked_from_project")) {
             var parent = json.get("forked_from_project").get("path_with_namespace").asString();
             return Optional.of(new GitLabRepository(gitLabHost, parent));
         }
         return Optional.empty();
@@ -103,25 +103,25 @@
         var pr = request.post("merge_requests")
                         .body("source_branch", sourceRef)
                         .body("target_branch", targetRef)
                         .body("title", draft ? "WIP: " : "" + title)
                         .body("description", String.join("\n", body))
-                        .body("target_project_id", Long.toString(target.getId()))
+                        .body("target_project_id", Long.toString(target.id()))
                         .execute();
 
         var targetRepo = (GitLabRepository) target;
         return new GitLabMergeRequest(targetRepo, pr, targetRepo.request);
     }
 
     @Override
-    public PullRequest getPullRequest(String id) {
+    public PullRequest pullRequest(String id) {
         var pr = request.get("merge_requests/" + id).execute();
         return new GitLabMergeRequest(this, pr, request);
     }
 
     @Override
-    public List<PullRequest> getPullRequests() {
+    public List<PullRequest> pullRequests() {
         return request.get("merge_requests")
                       .param("state", "opened")
                       .execute().stream()
                       .map(value -> new GitLabMergeRequest(this, value, request))
                       .collect(Collectors.toList());
@@ -134,51 +134,51 @@
 
     @Override
     public Optional<PullRequest> parsePullRequestUrl(String url) {
         var matcher = mergeRequestPattern.matcher(url);
         if (matcher.find()) {
-            return Optional.of(getPullRequest(matcher.group(1)));
+            return Optional.of(pullRequest(matcher.group(1)));
         } else {
             return Optional.empty();
         }
     }
 
     @Override
-    public String getName() {
+    public String name() {
         return projectName;
     }
 
     @Override
-    public URI getUrl() {
+    public URI url() {
         var builder = URIBuilder
                 .base(gitLabHost.getUri())
                 .setPath("/" + projectName + ".git");
         gitLabHost.getPat().ifPresent(pat -> builder.setAuthentication(pat.userName() + ":" + pat.token()));
         return builder.build();
     }
 
     @Override
-    public URI getWebUrl() {
+    public URI webUrl() {
         return URIBuilder.base(gitLabHost.getUri())
                          .setPath("/" + projectName)
                          .build();
     }
 
     @Override
-    public URI getWebUrl(Hash hash) {
+    public URI webUrl(Hash hash) {
         return URIBuilder.base(gitLabHost.getUri())
                          .setPath("/" + projectName + "/commit/" + hash.abbreviate())
                          .build();
     }
 
     @Override
-    public VCS getRepositoryType() {
+    public VCS repositoryType() {
         return VCS.GIT;
     }
 
     @Override
-    public String getFileContents(String filename, String ref) {
+    public String fileContents(String filename, String ref) {
         var confName = URLEncoder.encode(filename, StandardCharsets.UTF_8);
         var conf = request.get("repository/files/" + confName)
                           .param("ref", ref)
                           .onError(response -> {
                               // Retry once with additional escaping of the path fragment
@@ -190,11 +190,11 @@
         var content = Base64.getDecoder().decode(conf.get("content").asString());
         return new String(content, StandardCharsets.UTF_8);
     }
 
     @Override
-    public String getNamespace() {
+    public String namespace() {
         return URIBuilder.base(gitLabHost.getUri()).build().getHost();
     }
 
     @Override
     public Optional<WebHook> parseWebHook(JSONValue body) {
@@ -223,21 +223,21 @@
             }
             id = body.get("merge_request").get("iid").asInt();
         }
 
         if (id != -1) {
-            var pr = getPullRequest(Integer.toString(id));
+            var pr = pullRequest(Integer.toString(id));
             var webHook = new WebHook(List.of(pr));
             return Optional.of(webHook);
         } else {
             return Optional.empty();
         }
     }
 
     @Override
     public HostedRepository fork() {
-        var namespace = gitLabHost.getCurrentUserDetails().userName();
+        var namespace = gitLabHost.currentUser().userName();
         request.post("fork")
                .body("namespace", namespace)
                .onError(r -> r.statusCode() == 409 ? JSON.object().put("exists", true) : null)
                .execute();
         var nameOnlyStart = projectName.lastIndexOf('/');
@@ -248,19 +248,19 @@
                 Thread.sleep(Duration.ofSeconds(1).toMillis());
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }
-        return gitLabHost.getRepository(forkedRepoName);
+        return gitLabHost.repository(forkedRepoName);
     }
 
     @Override
-    public long getId() {
+    public long id() {
         return json.get("id").asLong();
     }
 
     @Override
-    public Hash getBranchHash(String ref) {
+    public Hash branchHash(String ref) {
         var branch = request.get("repository/branches/" + ref).execute();
         return new Hash(branch.get("commit").get("id").asString());
     }
 }
