diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
@@ -44,24 +44,24 @@
     PullRequestInstance(Path localRepoPath, PullRequest pr) throws IOException  {
         this.pr = pr;
         var repository = pr.repository();
 
         // Materialize the PR's target ref
-        localRepo = Repository.materialize(localRepoPath, repository.getUrl(), pr.getTargetRef());
-        targetHash = localRepo.fetch(repository.getUrl(), pr.getTargetRef());
-        headHash = localRepo.fetch(repository.getUrl(), pr.getHeadHash().hex());
+        localRepo = Repository.materialize(localRepoPath, repository.url(), pr.targetRef());
+        targetHash = localRepo.fetch(repository.url(), pr.targetRef());
+        headHash = localRepo.fetch(repository.url(), pr.headHash().hex());
         baseHash = localRepo.mergeBase(targetHash, headHash);
     }
 
     /**
      * The Review list is in chronological order, the latest one from a particular reviewer is the
      * one that is "active".
      * @param allReviews
      * @return
      */
     static List<Review> filterActiveReviews(List<Review> allReviews) {
-        var reviewPerUser = new LinkedHashMap<HostUserDetails, Review>();
+        var reviewPerUser = new LinkedHashMap<HostUser, Review>();
         for (var review : allReviews) {
             reviewPerUser.put(review.reviewer(), review);
         }
         return new ArrayList<>(reviewPerUser.values());
     }
@@ -73,19 +73,19 @@
                           .map(namespace::get)
                           .filter(Objects::nonNull)
                           .map(Contributor::username)
                           .collect(Collectors.toList());
 
-        var comments = pr.getComments();
-        var additionalContributors = Contributors.contributors(pr.repository().host().getCurrentUserDetails(),
+        var comments = pr.comments();
+        var additionalContributors = Contributors.contributors(pr.repository().host().currentUser(),
                                                                comments).stream()
                                                  .map(email -> Author.fromString(email.toString()))
                                                  .collect(Collectors.toList());
 
-        var summary = Summary.summary(pr.repository().host().getCurrentUserDetails(), comments);
-        var issue = Issue.fromString(pr.getTitle());
-        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(isMerge ? "Merge" : pr.getTitle()));
+        var summary = Summary.summary(pr.repository().host().currentUser(), comments);
+        var issue = Issue.fromString(pr.title());
+        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(isMerge ? "Merge" : pr.title()));
         commitMessageBuilder.contributors(additionalContributors)
                                          .reviewers(reviewers);
         summary.ifPresent(commitMessageBuilder::summary);
 
         return String.join("\n", commitMessageBuilder.format(CommitMessageFormatters.v1));
@@ -95,11 +95,11 @@
         localRepo.checkout(baseHash, true);
         localRepo.squash(headHash);
 
         Author committer;
         Author author;
-        var contributor = namespace.get(pr.getAuthor().id());
+        var contributor = namespace.get(pr.author().id());
 
         if (contributor == null) {
             // Use the information contained in the head commit - jcheck has verified that it contains sane values
             var headCommit = localRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
             author = headCommit.author();
@@ -119,11 +119,11 @@
     }
 
     private Hash commitMerge(List<Review> activeReviews, Namespace namespace, String censusDomain) throws IOException {
         localRepo.checkout(headHash, true);
 
-        var contributor = namespace.get(pr.getAuthor().id());
+        var contributor = namespace.get(pr.author().id());
         if (contributor == null) {
             throw new RuntimeException("Merges can only be performed by Committers");
         }
 
         var author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
@@ -131,12 +131,12 @@
         var commitMessage = commitMessage(activeReviews, namespace, true);
         return localRepo.amend(commitMessage, author.name(), author.email(), author.name(), author.email());
     }
 
     Hash commit(Namespace namespace, String censusDomain, String sponsorId) throws IOException {
-        var activeReviews = filterActiveReviews(pr.getReviews());
-        if (!pr.getTitle().startsWith("Merge")) {
+        var activeReviews = filterActiveReviews(pr.reviews());
+        if (!pr.title().startsWith("Merge")) {
             return commitSquashed(activeReviews, namespace, censusDomain, sponsorId);
         } else {
             return commitMerge(activeReviews, namespace, censusDomain);
         }
     }
@@ -151,11 +151,11 @@
 
     Optional<Hash> rebase(Hash commitHash, PrintWriter reply) {
         var divergingCommits = divergingCommits();
         if (divergingCommits.size() > 0) {
             reply.print("The following commits have been pushed to ");
-            reply.print(pr.getTargetRef());
+            reply.print(pr.targetRef());
             reply.println(" since your change was applied:");
             divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
 
             try {
                 var commit = localRepo.lookup(commitHash).orElseThrow();
@@ -165,11 +165,11 @@
                 var hash = localRepo.head();
                 return Optional.of(hash);
             } catch (IOException e) {
                 reply.println();
                 reply.print("It was not possible to rebase your changes automatically. Please merge `");
-                reply.print(pr.getTargetRef());
+                reply.print(pr.targetRef());
                 reply.println("` into your branch and try again.");
                 try {
                     localRepo.checkout(commitHash, true);
                 } catch (IOException e2) {
                     throw new UncheckedIOException(e2);
