diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -73,11 +73,11 @@
         run.checkStatus();
     }
 
     // For unknown contributors, check that all commits have the same name and email
     private boolean checkCommitAuthor(List<Commit> commits) throws IOException {
-        var author = censusInstance.namespace().get(pr.getAuthor().id());
+        var author = censusInstance.namespace().get(pr.author().id());
         if (author != null) {
             return true;
         }
 
         var names = new HashSet<String>();
@@ -90,19 +90,19 @@
 
         return ((names.size() == 1) && emails.size() == 1);
     }
 
     private Optional<String> mergeSourceRepository() {
-        var repoMatcher = mergeSourcePattern.matcher(pr.getTitle());
+        var repoMatcher = mergeSourcePattern.matcher(pr.title());
         if (!repoMatcher.matches()) {
             return Optional.empty();
         }
         return Optional.of(repoMatcher.group(1));
     }
 
     private Optional<String> mergeSourceBranch() {
-        var branchMatcher = mergeSourcePattern.matcher(pr.getTitle());
+        var branchMatcher = mergeSourcePattern.matcher(pr.title());
         if (!branchMatcher.matches()) {
             return Optional.empty();
         }
         var mergeSourceBranch = branchMatcher.group(2);
         return Optional.of(mergeSourceBranch);
@@ -111,21 +111,21 @@
     // Additional bot-specific checks that are not handled by JCheck
     private List<String> botSpecificChecks() throws IOException {
         var ret = new ArrayList<String>();
 
         var baseHash = prInstance.baseHash();
-        var headHash = pr.getHeadHash();
+        var headHash = pr.headHash();
         var commits = prInstance.localRepo().commits(baseHash + ".." + headHash).asList();
 
         if (!checkCommitAuthor(commits)) {
             var error = "For contributors who are not existing OpenJDK Authors, commit attribution will be taken from " +
                     "the commits in the PR. However, the commits in this PR have inconsistent user names and/or " +
                     "email addresses. Please amend the commits.";
             ret.add(error);
         }
 
-        if (pr.getTitle().startsWith("Merge")) {
+        if (pr.title().startsWith("Merge")) {
             if (commits.size() < 2) {
                 ret.add("A Merge PR must contain at least two commits that are not already present in the target.");
             } else {
                 if (!commits.get(0).isMerge()) {
                     ret.add("The top commit must be a merge commit.");
@@ -133,13 +133,13 @@
 
                 var sourceRepo = mergeSourceRepository();
                 var sourceBranch = mergeSourceBranch();
                 if (sourceBranch.isPresent() && sourceRepo.isPresent()) {
                     try {
-                        var mergeSourceRepo = pr.repository().host().getRepository(sourceRepo.get());
+                        var mergeSourceRepo = pr.repository().host().repository(sourceRepo.get());
                         try {
-                            var sourceHash = prInstance.localRepo().fetch(mergeSourceRepo.getUrl(), sourceBranch.get());
+                            var sourceHash = prInstance.localRepo().fetch(mergeSourceRepo.url(), sourceBranch.get());
                             if (!prInstance.localRepo().isAncestor(commits.get(1).hash(), sourceHash)) {
                                 ret.add("The merge contains commits that are not ancestors of the source");
                             }
                         } catch (IOException e) {
                             ret.add("Could not fetch branch `" + sourceBranch.get() + "` from project `" +
@@ -220,11 +220,11 @@
         } else {
             return "no project role";
         }
     }
 
-    private String formatReviewer(HostUserDetails reviewer) {
+    private String formatReviewer(HostUser reviewer) {
         var namespace = censusInstance.namespace();
         var contributor = namespace.get(reviewer.id());
         if (contributor == null) {
             return reviewer.userName() + " (no known " + namespace.name() + " user name / role)";
         } else {
@@ -243,11 +243,11 @@
     private Optional<String> getReviewersList(List<Review> reviews) {
         var reviewers = reviews.stream()
                                .filter(review -> review.verdict() == Review.Verdict.APPROVED)
                                .map(review -> {
                                    var entry = " * " + formatReviewer(review.reviewer());
-                                   if (!review.hash().equals(pr.getHeadHash())) {
+                                   if (!review.hash().equals(pr.headHash())) {
                                        entry += " **Note!** Review applies to " + review.hash();
                                    }
                                    return entry;
                                })
                                .collect(Collectors.joining("\n"));
@@ -261,21 +261,21 @@
     private String getStatusMessage(List<Review> reviews, PullRequestCheckIssueVisitor visitor) {
         var progressBody = new StringBuilder();
         progressBody.append("## Progress\n");
         progressBody.append(getChecksList(visitor));
 
-        var issue = Issue.fromString(pr.getTitle());
+        var issue = Issue.fromString(pr.title());
         if (issueProject != null && issue.isPresent()) {
             progressBody.append("\n\n## Issue\n");
-            var iss = issueProject.getIssue(issue.get().id());
+            var iss = issueProject.issue(issue.get().id());
             if (iss.isPresent()) {
                 progressBody.append("[");
-                progressBody.append(iss.get().getId());
+                progressBody.append(iss.get().id());
                 progressBody.append("](");
-                progressBody.append(iss.get().getWebUrl());
+                progressBody.append(iss.get().webUrl());
                 progressBody.append("): ");
-                progressBody.append(iss.get().getTitle());
+                progressBody.append(iss.get().title());
                 progressBody.append("\n");
             } else {
                 progressBody.append("⚠️ Failed to retrieve information on issue `");
                 progressBody.append(issue.get().toString());
                 progressBody.append("`.\n");
@@ -289,11 +289,11 @@
 
         return progressBody.toString();
     }
 
     private String updateStatusMessage(String message) {
-        var description = pr.getBody();
+        var description = pr.body();
         var markerIndex = description.lastIndexOf(progressMarker);
 
         if (markerIndex >= 0 && description.substring(markerIndex).equals(message)) {
             log.info("Progress already up to date");
             return description;
@@ -331,21 +331,21 @@
             pr.addComment(body);
         }
     }
 
     private Optional<Comment> findComment(List<Comment> comments, String marker) {
-        var self = pr.repository().host().getCurrentUserDetails();
+        var self = pr.repository().host().currentUser();
         return comments.stream()
                        .filter(comment -> comment.author().equals(self))
                        .filter(comment -> comment.body().contains(marker))
                        .findAny();
     }
 
     private String getMergeReadyComment(String commitMessage, List<Review> reviews, boolean rebasePossible) {
         var message = new StringBuilder();
         message.append("@");
-        message.append(pr.getAuthor().userName());
+        message.append(pr.author().userName());
         message.append(" This change can now be integrated. The commit message will be:\n");
         message.append("```\n");
         message.append(commitMessage);
         message.append("\n```\n");
 
@@ -362,33 +362,33 @@
                 message.append("have been ");
                 message.append(divergingCommits.size());
                 message.append(" commits ");
             }
             message.append("pushed to the `");
-            message.append(pr.getTargetRef());
+            message.append(pr.targetRef());
             message.append("` branch:\n");
             var commitList = divergingCommits.stream()
                     .map(commit -> " * " + commit.hash().hex() + ": " + commit.message().get(0))
                     .collect(Collectors.joining("\n"));
             message.append(commitList);
             message.append("\n\n");
             if (rebasePossible) {
                 message.append("Since there are no conflicts, your changes will automatically be rebased on top of the ");
                 message.append("above commits when integrating. If you prefer to do this manually, please merge `");
-                message.append(pr.getTargetRef());
+                message.append(pr.targetRef());
                 message.append("` into your branch first.\n");
             } else {
                 message.append("Your changes cannot be rebased automatically without conflicts, so you will need to ");
                 message.append("merge `");
-                message.append(pr.getTargetRef());
+                message.append(pr.targetRef());
                 message.append("` into your branch before integrating.\n");
             }
         }
 
-        if (!ProjectPermissions.mayCommit(censusInstance, pr.getAuthor())) {
+        if (!ProjectPermissions.mayCommit(censusInstance, pr.author())) {
             message.append("\n");
-            var contributor = censusInstance.namespace().get(pr.getAuthor().id());
+            var contributor = censusInstance.namespace().get(pr.author().id());
             if (contributor == null) {
                 message.append("As you are not a known OpenJDK [Author](http://openjdk.java.net/bylaws#author), ");
             } else {
                 message.append("As you do not have Committer status in this project, ");
             }
@@ -422,11 +422,11 @@
     }
 
     private String getMergeNoLongerReadyComment() {
         var message = new StringBuilder();
         message.append("@");
-        message.append(pr.getAuthor().userName());
+        message.append(pr.author().userName());
         message.append(" This change is no longer ready for integration - check the PR body for details.\n");
         message.append(mergeReadyMarker);
         return message.toString();
     }
 
@@ -443,11 +443,11 @@
             existing.ifPresent(comment -> pr.updateComment(comment.id(), getMergeNoLongerReadyComment()));
         }
     }
 
     private void checkStatus() {
-        var checkBuilder = CheckBuilder.create("jcheck", pr.getHeadHash());
+        var checkBuilder = CheckBuilder.create("jcheck", pr.headHash());
         checkBuilder.title("Required");
         var censusDomain = censusInstance.configuration().census().domain();
 
         try {
             // Post check in-progress
@@ -495,25 +495,25 @@
                 newLabels.remove("outdated");
             }
 
             // Ensure that the ready for sponsor label is up to date
             newLabels.remove("sponsor");
-            var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().host().getCurrentUserDetails(), comments);
+            var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().host().currentUser(), comments);
             if (readyHash.isPresent() && readyForIntegration) {
                 var acceptedHash = readyHash.get();
-                if (pr.getHeadHash().equals(acceptedHash)) {
+                if (pr.headHash().equals(acceptedHash)) {
                     newLabels.add("sponsor");
                 }
             }
 
             // Calculate current metadata to avoid unnecessary future checks
-            var metadata = workItem.getMetadata(pr.getTitle(), updatedBody, pr.getComments(), activeReviews, newLabels, censusInstance, pr.getTargetHash());
+            var metadata = workItem.getMetadata(pr.title(), updatedBody, pr.comments(), activeReviews, newLabels, censusInstance, pr.targetHash());
             checkBuilder.metadata(metadata);
         } catch (Exception e) {
             log.throwing("CommitChecker", "checkStatus", e);
             newLabels.remove("ready");
-            var metadata = workItem.getMetadata(pr.getTitle(), pr.getBody(), pr.getComments(), activeReviews, newLabels, censusInstance, pr.getTargetHash());
+            var metadata = workItem.getMetadata(pr.title(), pr.body(), pr.comments(), activeReviews, newLabels, censusInstance, pr.targetHash());
             checkBuilder.metadata(metadata);
             checkBuilder.title("Exception occurred during jcheck");
             checkBuilder.summary(e.getMessage());
             checkBuilder.complete(false);
         }
