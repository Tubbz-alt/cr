diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -50,33 +50,33 @@
         this.exceptionConsumer = exceptionConsumer;
     }
 
     @Override
     public String toString() {
-        return "ArchiveWorkItem@" + bot.codeRepo().getName() + "#" + pr.getId();
+        return "ArchiveWorkItem@" + bot.codeRepo().name() + "#" + pr.id();
     }
 
     @Override
     public boolean concurrentWith(WorkItem other) {
         if (!(other instanceof ArchiveWorkItem)) {
             return true;
         }
         ArchiveWorkItem otherItem = (ArchiveWorkItem)other;
-        if (!pr.getId().equals(otherItem.pr.getId())) {
+        if (!pr.id().equals(otherItem.pr.id())) {
             return true;
         }
-        if (!bot.codeRepo().getName().equals(otherItem.bot.codeRepo().getName())) {
+        if (!bot.codeRepo().name().equals(otherItem.bot.codeRepo().name())) {
             return true;
         }
         return false;
     }
 
     private void pushMbox(Repository localRepo, String message) {
         try {
             localRepo.add(localRepo.root().resolve("."));
             var hash = localRepo.commit(message, bot.emailAddress().fullName().orElseThrow(), bot.emailAddress().address());
-            localRepo.push(hash, bot.archiveRepo().getUrl(), "master");
+            localRepo.push(hash, bot.archiveRepo().url(), "master");
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
@@ -108,20 +108,20 @@
         return Optional.empty();
     }
 
     private Repository materializeArchive(Path scratchPath) {
         try {
-            return Repository.materialize(scratchPath, bot.archiveRepo().getUrl(), pr.getTargetRef());
+            return Repository.materialize(scratchPath, bot.archiveRepo().url(), pr.targetRef());
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
     private final static Pattern commandPattern = Pattern.compile("^/.*$");
 
-    private boolean ignoreComment(HostUserDetails author, String body) {
-        if (pr.repository().host().getCurrentUserDetails().equals(author)) {
+    private boolean ignoreComment(HostUser author, String body) {
+        if (pr.repository().host().currentUser().equals(author)) {
             return true;
         }
         if (bot.ignoredUsers().contains(author.userName())) {
             return true;
         }
@@ -142,22 +142,22 @@
     private static final String webrevHeaderMarker = "<!-- mlbridge webrev header -->";
     private static final String webrevListMarker = "<!-- mlbridge webrev list -->";
 
     private void updateWebrevComment(List<Comment> comments, int index, URI fullWebrev, URI incWebrev) {
         var existing = comments.stream()
-                               .filter(comment -> comment.author().equals(pr.repository().host().getCurrentUserDetails()))
+                               .filter(comment -> comment.author().equals(pr.repository().host().currentUser()))
                                .filter(comment -> comment.body().contains(webrevCommentMarker))
                                .findAny();
         var comment = webrevCommentMarker + "\n";
         comment += webrevHeaderMarker + "\n";
         comment += "### Webrevs" + "\n";
         comment += webrevListMarker + "\n";
         comment += " * " + String.format("%02d", index) + ": [Full](" + fullWebrev.toString() + ")";
         if (incWebrev != null) {
             comment += " - [Incremental](" + incWebrev.toString() + ")";
         }
-        comment += " (" + pr.getHeadHash() + ")\n";
+        comment += " (" + pr.headHash() + ")\n";
 
         if (existing.isPresent()) {
             if (existing.get().body().contains(fullWebrev.toString())) {
                 log.fine("Webrev link already posted - skipping update");
                 return;
@@ -186,28 +186,28 @@
 
     @Override
     public void run(Path scratchPath) {
         var path = scratchPath.resolve("mlbridge");
         var archiveRepo = materializeArchive(path);
-        var mboxBasePath = path.resolve(bot.codeRepo().getName());
+        var mboxBasePath = path.resolve(bot.codeRepo().name());
         var mbox = MailingListServerFactory.createMboxFileServer(mboxBasePath);
-        var reviewArchiveList = mbox.getList(pr.getId());
+        var reviewArchiveList = mbox.getList(pr.id());
         var sentMails = parseArchive(reviewArchiveList);
 
         // First determine if this PR should be inspected further or not
         if (sentMails.isEmpty()) {
-            var labels = new HashSet<>(pr.getLabels());
+            var labels = new HashSet<>(pr.labels());
             for (var readyLabel : bot.readyLabels()) {
                 if (!labels.contains(readyLabel)) {
                     log.fine("PR is not yet ready - missing label '" + readyLabel + "'");
                     return;
                 }
             }
         }
 
         // Also inspect comments before making the first post
-        var comments = pr.getComments();
+        var comments = pr.comments();
         if (sentMails.isEmpty()) {
             for (var readyComment : bot.readyComments().entrySet()) {
                 var commentFound = false;
                 for (var comment : comments) {
                     if (comment.author().userName().equals(readyComment.getKey())) {
@@ -247,12 +247,12 @@
             updateWebrevComment(comments, 0, webrev, null);
         } else {
             var latestHead = reviewArchive.latestHead();
 
             // Check if the head has changed
-            if (!pr.getHeadHash().equals(latestHead)) {
-                log.fine("Head hash change detected: current: " + pr.getHeadHash() + " - last: " + latestHead);
+            if (!pr.headHash().equals(latestHead)) {
+                log.fine("Head hash change detected: current: " + pr.headHash() + " - last: " + latestHead);
 
                 var latestBase = reviewArchive.latestBase();
                 if (!prInstance.baseHash().equals(latestBase)) {
                     // FIXME: Could try harder to make an incremental
                     var fullWebrev = bot.webrevStorage().createAndArchive(prInstance, webrevPath, prInstance.baseHash(),
@@ -278,20 +278,20 @@
             }
             reviewArchive.addComment(comment);
         }
 
         // File specific comments
-        var reviewComments = pr.getReviewComments();
+        var reviewComments = pr.reviewComments();
         for (var reviewComment : reviewComments) {
             if (ignoreComment(reviewComment.author(), reviewComment.body())) {
                 continue;
             }
             reviewArchive.addReviewComment(reviewComment);
         }
 
         // Review comments
-        var reviews = pr.getReviews();
+        var reviews = pr.reviews();
         for (var review : reviews) {
             if (ignoreComment(review.reviewer(), review.body().orElse(""))) {
                 continue;
             }
             reviewArchive.addReview(review);
@@ -302,11 +302,11 @@
             return;
         }
 
         // Push all new mails to the archive repository
         newMails.forEach(reviewArchiveList::post);
-        pushMbox(archiveRepo, "Adding comments for PR " + bot.codeRepo().getName() + "/" + pr.getId());
+        pushMbox(archiveRepo, "Adding comments for PR " + bot.codeRepo().name() + "/" + pr.id());
 
         // Finally post all new mails to the actual list
         for (var newMail : newMails) {
             var filteredHeaders = newMail.headers().stream()
                                          .filter(header -> !header.startsWith("PR-"))
