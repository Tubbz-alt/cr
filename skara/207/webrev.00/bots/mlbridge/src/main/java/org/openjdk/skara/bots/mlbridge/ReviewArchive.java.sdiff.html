<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PullRequestInstance.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WebrevStorage.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5 import org.openjdk.skara.host.*;
  6 import org.openjdk.skara.vcs.Hash;
  7 
  8 import java.net.URI;
  9 import java.nio.charset.StandardCharsets;
 10 import java.security.*;
 11 import java.util.*;
 12 import java.util.stream.*;
 13 
 14 class ReviewArchive {
 15     private final PullRequestInstance prInstance;
 16     private final CensusInstance censusInstance;
 17     private final EmailAddress sender;
 18     private final List&lt;Email&gt; existing;
 19     private final Map&lt;String, Email&gt; existingIds = new HashMap&lt;&gt;();
 20     private final List&lt;Email&gt; generated = new ArrayList&lt;&gt;();
 21     private final Map&lt;String, Email&gt; generatedIds = new HashMap&lt;&gt;();
 22     private final List&lt;Hash&gt; reportedHeads;
 23     private final List&lt;Hash&gt; reportedBases;
 24 
<span class="line-modified"> 25     private EmailAddress getAuthorAddress(HostUserDetails originalAuthor) {</span>
 26         var contributor = censusInstance.namespace().get(originalAuthor.id());
 27         if (contributor == null) {
 28             return EmailAddress.from(originalAuthor.fullName(),
 29                                      censusInstance.namespace().name() + &quot;+&quot; +
 30                                              originalAuthor.id() + &quot;+&quot; + originalAuthor.userName() + &quot;@&quot; +
 31                                              censusInstance.configuration().census().domain());
 32         } else {
 33             return EmailAddress.from(contributor.fullName().orElse(originalAuthor.fullName()),
 34                                      contributor.username() + &quot;@&quot; + censusInstance.configuration().census().domain());
 35         }
 36     }
 37 
 38     private EmailAddress getUniqueMessageId(String identifier) {
 39         try {
<span class="line-modified"> 40             var prSpecific = prInstance.pr().repository().getName().replace(&quot;/&quot;, &quot;.&quot;) + &quot;.&quot; + prInstance.id();</span>
 41             var digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
 42             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
 43             digest.update(identifier.getBytes(StandardCharsets.UTF_8));
 44             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
 45 
<span class="line-modified"> 46             return EmailAddress.from(encodedCommon + &quot;.&quot; + UUID.randomUUID() + &quot;@&quot; + prInstance.pr().repository().getUrl().getHost());</span>
 47         } catch (NoSuchAlgorithmException e) {
 48             throw new RuntimeException(&quot;Cannot find SHA-256&quot;);
 49         }
 50     }
 51 
 52     private EmailAddress getMessageId() {
 53         return getUniqueMessageId(&quot;fc&quot;);
 54     }
 55 
 56     private EmailAddress getMessageId(Comment comment) {
 57         return getUniqueMessageId(&quot;pc&quot; + comment.id());
 58     }
 59 
 60     private EmailAddress getMessageId(ReviewComment comment) {
 61         return getUniqueMessageId(&quot;rc&quot; + comment.id());
 62     }
 63 
 64     private EmailAddress getMessageId(Hash hash) {
 65         return getUniqueMessageId(&quot;ha&quot; + hash.hex());
 66     }
</pre>
<hr />
<pre>
157         if (reportedHeads.isEmpty()) {
158             throw new IllegalArgumentException(&quot;No head reported yet&quot;);
159         }
160         return reportedHeads.get(reportedHeads.size() - 1);
161     }
162 
163     Hash latestBase() {
164         if (reportedBases.isEmpty()) {
165             throw new IllegalArgumentException(&quot;No base reported yet&quot;);
166         }
167         return reportedBases.get(reportedBases.size() - 1);
168     }
169 
170     int revisionCount() {
171         return reportedHeads.size();
172     }
173 
174     void create(URI webrev) {
175         var body = ArchiveMessages.composeConversation(prInstance, webrev);
176         var id = getMessageId();
<span class="line-modified">177         var email = Email.create(&quot;RFR: &quot; + prInstance.pr().getTitle(), body)</span>
178                          .sender(sender)
<span class="line-modified">179                          .author(getAuthorAddress(prInstance.pr().getAuthor()))</span>
180                          .id(id)
181                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
182                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
183                          .build();
184         generated.add(email);
185         generatedIds.put(getStableMessageId(id), email);
186     }
187 
188     private String latestHeadPrefix() {
189         return String.format(&quot;[Rev %02d]&quot;, revisionCount());
190     }
191 
192     void addFull(URI webrev) {
193         var body = ArchiveMessages.composeRebaseComment(prInstance, webrev);
194         var id = getMessageId(prInstance.headHash());
195         var parent = topEmail();
<span class="line-modified">196         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().getTitle(), body)</span>
197                          .sender(sender)
<span class="line-modified">198                          .author(getAuthorAddress(prInstance.pr().getAuthor()))</span>
199                          .recipient(parent.author())
200                          .id(id)
201                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
202                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
203                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
204                          .build();
205         generated.add(email);
206         generatedIds.put(getStableMessageId(id), email);
207     }
208 
209     void addIncremental(URI fullWebrev, URI incrementalWebrev) {
210         var body = ArchiveMessages.composeIncrementalComment(latestHead(), prInstance, fullWebrev, incrementalWebrev);
211         var id = getMessageId(prInstance.headHash());
212         var parent = topEmail();
<span class="line-modified">213         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().getTitle(), body)</span>
214                          .sender(sender)
<span class="line-modified">215                          .author(getAuthorAddress(prInstance.pr().getAuthor()))</span>
216                          .recipient(parent.author())
217                          .id(id)
218                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
219                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
220                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
221                          .build();
222         generated.add(email);
223         generatedIds.put(getStableMessageId(id), email);
224     }
225 
<span class="line-modified">226     private Optional&lt;Email&gt; findCollapsable(Email parent, HostUserDetails author, String subject) {</span>
227         var parentId = getStableMessageId(parent.id());
228 
229         // Is it a self-reply?
230         if (parent.author().equals(getAuthorAddress(author)) &amp;&amp; generatedIds.containsKey(parentId)) {
231             // But avoid extending top-level parents
232             if (!parent.hasHeader(&quot;PR-Head-Hash&quot;)) {
233                 // And only collapse identical subjects
234                 if (parent.subject().equals(subject)) {
235                     return Optional.of(parent);
236                 }
237             }
238         }
239 
240         // Have we already replied to the same parent?
241         for (var candidate : generated) {
242             if (!candidate.hasHeader(&quot;In-Reply-To&quot;)) {
243                 continue;
244             }
245             var inReplyTo = EmailAddress.parse(candidate.headerValue(&quot;In-Reply-To&quot;));
246             var candidateParentId = getStableMessageId(inReplyTo);
247             if (candidateParentId.equals(parentId) &amp;&amp; candidate.author().equals(getAuthorAddress(author))) {
248                 // Only collapse identical subjects
249                 if (candidate.subject().equals(subject)) {
250                     return Optional.of(candidate);
251                 }
252             }
253         }
254 
255         return Optional.empty();
256     }
257 
<span class="line-modified">258     private void addReplyCommon(Email parent, HostUserDetails author, String subject, String body, EmailAddress id) {</span>
259         if (!subject.startsWith(&quot;Re: &quot;)) {
260             subject = &quot;Re: &quot; + subject;
261         }
262 
263         // Collapse self-replies and replies-to-same that have been created in this run
264         var collapsable = findCollapsable(parent, author, subject);
265         if (collapsable.isPresent()) {
266             // Drop the parent
267             var parentEmail = collapsable.get();
268             generated.remove(parentEmail);
269             generatedIds.remove(getStableMessageId(parentEmail.id()));
270 
271             var collapsed = parentEmail.hasHeader(&quot;PR-Collapsed-IDs&quot;) ? parentEmail.headerValue(&quot;PR-Collapsed-IDs&quot;) + &quot; &quot; : &quot;&quot;;
272             collapsed += getStableMessageId(parentEmail.id());
273 
274             var reply = ArchiveMessages.composeCombinedReply(parentEmail, body, prInstance);
275             var email = Email.from(parentEmail)
276                              .body(reply)
277                              .subject(subject)
278                              .id(id)
</pre>
<hr />
<pre>
285             var reply = ArchiveMessages.composeReply(parent, body, prInstance);
286             var email = Email.reply(parent, subject, reply)
287                              .sender(sender)
288                              .author(getAuthorAddress(author))
289                              .recipient(parent.author())
290                              .id(id)
291                              .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
292                              .build();
293             generated.add(email);
294             generatedIds.put(getStableMessageId(id), email);
295         }
296     }
297 
298     void addComment(Comment comment) {
299         var id = getMessageId(comment);
300         if (existingIds.containsKey(getStableMessageId(id))) {
301             return;
302         }
303 
304         var parent = latestGeneralComment();
<span class="line-modified">305         addReplyCommon(parent, comment.author(), &quot;Re: RFR: &quot; + prInstance.pr().getTitle(), comment.body(), id);</span>
306     }
307 
308     private String projectRole(Contributor contributor) {
309         var version = censusInstance.configuration().census().version();
310         if (censusInstance.project().isLead(contributor.username(), version)) {
311             return &quot;Lead&quot;;
312         } else if (censusInstance.project().isReviewer(contributor.username(), version)) {
313             return &quot;Reviewer&quot;;
314         } else if (censusInstance.project().isCommitter(contributor.username(), version)) {
315             return &quot;Committer&quot;;
316         } else if (censusInstance.project().isAuthor(contributor.username(), version)) {
317             return &quot;Author&quot;;
318         }
319         return &quot;none&quot;;
320     }
321 
322     void addReview(Review review) {
323         var id = getMessageId(review);
324         if (existingIds.containsKey(getStableMessageId(id))) {
325             return;
326         }
327 
328         var contributor = censusInstance.namespace().get(review.reviewer().id());
329         var isReviewer = contributor != null &amp;&amp; censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
330 
331         // Default parent and subject
332         var parent = topCommentForHash(review.hash());
333         var subject = parent.subject();
334 
335         // Approvals by Reviewers get special treatment - post these as top-level comments
336         if (review.verdict() == Review.Verdict.APPROVED &amp;&amp; isReviewer) {
337             parent = topEmail();
<span class="line-modified">338             subject = &quot;Re: [Approved] &quot; + &quot;RFR: &quot; + prInstance.pr().getTitle();</span>
339         }
340 
341         var userName = contributor != null ? contributor.username() : review.reviewer().userName() + &quot;@&quot; + censusInstance.namespace().name();
342         var userRole = contributor != null ? projectRole(contributor) : &quot;none&quot;;
343         var replyBody = ArchiveMessages.reviewCommentBody(review.body().orElse(&quot;&quot;), review.verdict(), userName, userRole);
344 
345         addReplyCommon(parent, review.reviewer(), subject, replyBody, id);
346     }
347 
348     void addReviewComment(ReviewComment reviewComment) {
349         var id = getMessageId(reviewComment);
350         if (existingIds.containsKey(getStableMessageId(id))) {
351             return;
352         }
353 
354         var parent = parentForReviewComment(reviewComment);
355         var body = new StringBuilder();
356 
357         // Add some context to the first post
358         if (reviewComment.parent().isEmpty()) {
<span class="line-modified">359             var contents = prInstance.pr().repository().getFileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());</span>
360 
361             body.append(reviewComment.path()).append(&quot; line &quot;).append(reviewComment.line()).append(&quot;:\n\n&quot;);
362             for (int i = Math.max(0, reviewComment.line() - 2); i &lt; Math.min(contents.size(), reviewComment.line() + 1); ++i) {
363                 body.append(&quot;&gt; &quot;).append(i + 1).append(&quot;: &quot;).append(contents.get(i)).append(&quot;\n&quot;);
364             }
365             body.append(&quot;\n&quot;);
366         }
367         body.append(reviewComment.body());
368 
369         addReplyCommon(parent, reviewComment.author(), parent.subject(), body.toString(), id);
370     }
371 
372     List&lt;Email&gt; generatedEmails() {
373         return generated;
374     }
375 }
</pre>
</td>
<td>
<hr />
<pre>
  5 import org.openjdk.skara.host.*;
  6 import org.openjdk.skara.vcs.Hash;
  7 
  8 import java.net.URI;
  9 import java.nio.charset.StandardCharsets;
 10 import java.security.*;
 11 import java.util.*;
 12 import java.util.stream.*;
 13 
 14 class ReviewArchive {
 15     private final PullRequestInstance prInstance;
 16     private final CensusInstance censusInstance;
 17     private final EmailAddress sender;
 18     private final List&lt;Email&gt; existing;
 19     private final Map&lt;String, Email&gt; existingIds = new HashMap&lt;&gt;();
 20     private final List&lt;Email&gt; generated = new ArrayList&lt;&gt;();
 21     private final Map&lt;String, Email&gt; generatedIds = new HashMap&lt;&gt;();
 22     private final List&lt;Hash&gt; reportedHeads;
 23     private final List&lt;Hash&gt; reportedBases;
 24 
<span class="line-modified"> 25     private EmailAddress getAuthorAddress(HostUser originalAuthor) {</span>
 26         var contributor = censusInstance.namespace().get(originalAuthor.id());
 27         if (contributor == null) {
 28             return EmailAddress.from(originalAuthor.fullName(),
 29                                      censusInstance.namespace().name() + &quot;+&quot; +
 30                                              originalAuthor.id() + &quot;+&quot; + originalAuthor.userName() + &quot;@&quot; +
 31                                              censusInstance.configuration().census().domain());
 32         } else {
 33             return EmailAddress.from(contributor.fullName().orElse(originalAuthor.fullName()),
 34                                      contributor.username() + &quot;@&quot; + censusInstance.configuration().census().domain());
 35         }
 36     }
 37 
 38     private EmailAddress getUniqueMessageId(String identifier) {
 39         try {
<span class="line-modified"> 40             var prSpecific = prInstance.pr().repository().name().replace(&quot;/&quot;, &quot;.&quot;) + &quot;.&quot; + prInstance.id();</span>
 41             var digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
 42             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
 43             digest.update(identifier.getBytes(StandardCharsets.UTF_8));
 44             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
 45 
<span class="line-modified"> 46             return EmailAddress.from(encodedCommon + &quot;.&quot; + UUID.randomUUID() + &quot;@&quot; + prInstance.pr().repository().url().getHost());</span>
 47         } catch (NoSuchAlgorithmException e) {
 48             throw new RuntimeException(&quot;Cannot find SHA-256&quot;);
 49         }
 50     }
 51 
 52     private EmailAddress getMessageId() {
 53         return getUniqueMessageId(&quot;fc&quot;);
 54     }
 55 
 56     private EmailAddress getMessageId(Comment comment) {
 57         return getUniqueMessageId(&quot;pc&quot; + comment.id());
 58     }
 59 
 60     private EmailAddress getMessageId(ReviewComment comment) {
 61         return getUniqueMessageId(&quot;rc&quot; + comment.id());
 62     }
 63 
 64     private EmailAddress getMessageId(Hash hash) {
 65         return getUniqueMessageId(&quot;ha&quot; + hash.hex());
 66     }
</pre>
<hr />
<pre>
157         if (reportedHeads.isEmpty()) {
158             throw new IllegalArgumentException(&quot;No head reported yet&quot;);
159         }
160         return reportedHeads.get(reportedHeads.size() - 1);
161     }
162 
163     Hash latestBase() {
164         if (reportedBases.isEmpty()) {
165             throw new IllegalArgumentException(&quot;No base reported yet&quot;);
166         }
167         return reportedBases.get(reportedBases.size() - 1);
168     }
169 
170     int revisionCount() {
171         return reportedHeads.size();
172     }
173 
174     void create(URI webrev) {
175         var body = ArchiveMessages.composeConversation(prInstance, webrev);
176         var id = getMessageId();
<span class="line-modified">177         var email = Email.create(&quot;RFR: &quot; + prInstance.pr().title(), body)</span>
178                          .sender(sender)
<span class="line-modified">179                          .author(getAuthorAddress(prInstance.pr().author()))</span>
180                          .id(id)
181                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
182                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
183                          .build();
184         generated.add(email);
185         generatedIds.put(getStableMessageId(id), email);
186     }
187 
188     private String latestHeadPrefix() {
189         return String.format(&quot;[Rev %02d]&quot;, revisionCount());
190     }
191 
192     void addFull(URI webrev) {
193         var body = ArchiveMessages.composeRebaseComment(prInstance, webrev);
194         var id = getMessageId(prInstance.headHash());
195         var parent = topEmail();
<span class="line-modified">196         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().title(), body)</span>
197                          .sender(sender)
<span class="line-modified">198                          .author(getAuthorAddress(prInstance.pr().author()))</span>
199                          .recipient(parent.author())
200                          .id(id)
201                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
202                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
203                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
204                          .build();
205         generated.add(email);
206         generatedIds.put(getStableMessageId(id), email);
207     }
208 
209     void addIncremental(URI fullWebrev, URI incrementalWebrev) {
210         var body = ArchiveMessages.composeIncrementalComment(latestHead(), prInstance, fullWebrev, incrementalWebrev);
211         var id = getMessageId(prInstance.headHash());
212         var parent = topEmail();
<span class="line-modified">213         var email = Email.reply(parent, &quot;Re: &quot; + latestHeadPrefix() + &quot; RFR: &quot; + prInstance.pr().title(), body)</span>
214                          .sender(sender)
<span class="line-modified">215                          .author(getAuthorAddress(prInstance.pr().author()))</span>
216                          .recipient(parent.author())
217                          .id(id)
218                          .header(&quot;PR-Head-Hash&quot;, prInstance.headHash().hex())
219                          .header(&quot;PR-Base-Hash&quot;, prInstance.baseHash().hex())
220                          .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
221                          .build();
222         generated.add(email);
223         generatedIds.put(getStableMessageId(id), email);
224     }
225 
<span class="line-modified">226     private Optional&lt;Email&gt; findCollapsable(Email parent, HostUser author, String subject) {</span>
227         var parentId = getStableMessageId(parent.id());
228 
229         // Is it a self-reply?
230         if (parent.author().equals(getAuthorAddress(author)) &amp;&amp; generatedIds.containsKey(parentId)) {
231             // But avoid extending top-level parents
232             if (!parent.hasHeader(&quot;PR-Head-Hash&quot;)) {
233                 // And only collapse identical subjects
234                 if (parent.subject().equals(subject)) {
235                     return Optional.of(parent);
236                 }
237             }
238         }
239 
240         // Have we already replied to the same parent?
241         for (var candidate : generated) {
242             if (!candidate.hasHeader(&quot;In-Reply-To&quot;)) {
243                 continue;
244             }
245             var inReplyTo = EmailAddress.parse(candidate.headerValue(&quot;In-Reply-To&quot;));
246             var candidateParentId = getStableMessageId(inReplyTo);
247             if (candidateParentId.equals(parentId) &amp;&amp; candidate.author().equals(getAuthorAddress(author))) {
248                 // Only collapse identical subjects
249                 if (candidate.subject().equals(subject)) {
250                     return Optional.of(candidate);
251                 }
252             }
253         }
254 
255         return Optional.empty();
256     }
257 
<span class="line-modified">258     private void addReplyCommon(Email parent, HostUser author, String subject, String body, EmailAddress id) {</span>
259         if (!subject.startsWith(&quot;Re: &quot;)) {
260             subject = &quot;Re: &quot; + subject;
261         }
262 
263         // Collapse self-replies and replies-to-same that have been created in this run
264         var collapsable = findCollapsable(parent, author, subject);
265         if (collapsable.isPresent()) {
266             // Drop the parent
267             var parentEmail = collapsable.get();
268             generated.remove(parentEmail);
269             generatedIds.remove(getStableMessageId(parentEmail.id()));
270 
271             var collapsed = parentEmail.hasHeader(&quot;PR-Collapsed-IDs&quot;) ? parentEmail.headerValue(&quot;PR-Collapsed-IDs&quot;) + &quot; &quot; : &quot;&quot;;
272             collapsed += getStableMessageId(parentEmail.id());
273 
274             var reply = ArchiveMessages.composeCombinedReply(parentEmail, body, prInstance);
275             var email = Email.from(parentEmail)
276                              .body(reply)
277                              .subject(subject)
278                              .id(id)
</pre>
<hr />
<pre>
285             var reply = ArchiveMessages.composeReply(parent, body, prInstance);
286             var email = Email.reply(parent, subject, reply)
287                              .sender(sender)
288                              .author(getAuthorAddress(author))
289                              .recipient(parent.author())
290                              .id(id)
291                              .header(&quot;PR-Sequence&quot;, Integer.toString(existing.size() + generated.size()))
292                              .build();
293             generated.add(email);
294             generatedIds.put(getStableMessageId(id), email);
295         }
296     }
297 
298     void addComment(Comment comment) {
299         var id = getMessageId(comment);
300         if (existingIds.containsKey(getStableMessageId(id))) {
301             return;
302         }
303 
304         var parent = latestGeneralComment();
<span class="line-modified">305         addReplyCommon(parent, comment.author(), &quot;Re: RFR: &quot; + prInstance.pr().title(), comment.body(), id);</span>
306     }
307 
308     private String projectRole(Contributor contributor) {
309         var version = censusInstance.configuration().census().version();
310         if (censusInstance.project().isLead(contributor.username(), version)) {
311             return &quot;Lead&quot;;
312         } else if (censusInstance.project().isReviewer(contributor.username(), version)) {
313             return &quot;Reviewer&quot;;
314         } else if (censusInstance.project().isCommitter(contributor.username(), version)) {
315             return &quot;Committer&quot;;
316         } else if (censusInstance.project().isAuthor(contributor.username(), version)) {
317             return &quot;Author&quot;;
318         }
319         return &quot;none&quot;;
320     }
321 
322     void addReview(Review review) {
323         var id = getMessageId(review);
324         if (existingIds.containsKey(getStableMessageId(id))) {
325             return;
326         }
327 
328         var contributor = censusInstance.namespace().get(review.reviewer().id());
329         var isReviewer = contributor != null &amp;&amp; censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
330 
331         // Default parent and subject
332         var parent = topCommentForHash(review.hash());
333         var subject = parent.subject();
334 
335         // Approvals by Reviewers get special treatment - post these as top-level comments
336         if (review.verdict() == Review.Verdict.APPROVED &amp;&amp; isReviewer) {
337             parent = topEmail();
<span class="line-modified">338             subject = &quot;Re: [Approved] &quot; + &quot;RFR: &quot; + prInstance.pr().title();</span>
339         }
340 
341         var userName = contributor != null ? contributor.username() : review.reviewer().userName() + &quot;@&quot; + censusInstance.namespace().name();
342         var userRole = contributor != null ? projectRole(contributor) : &quot;none&quot;;
343         var replyBody = ArchiveMessages.reviewCommentBody(review.body().orElse(&quot;&quot;), review.verdict(), userName, userRole);
344 
345         addReplyCommon(parent, review.reviewer(), subject, replyBody, id);
346     }
347 
348     void addReviewComment(ReviewComment reviewComment) {
349         var id = getMessageId(reviewComment);
350         if (existingIds.containsKey(getStableMessageId(id))) {
351             return;
352         }
353 
354         var parent = parentForReviewComment(reviewComment);
355         var body = new StringBuilder();
356 
357         // Add some context to the first post
358         if (reviewComment.parent().isEmpty()) {
<span class="line-modified">359             var contents = prInstance.pr().repository().fileContents(reviewComment.path(), reviewComment.hash().hex()).lines().collect(Collectors.toList());</span>
360 
361             body.append(reviewComment.path()).append(&quot; line &quot;).append(reviewComment.line()).append(&quot;:\n\n&quot;);
362             for (int i = Math.max(0, reviewComment.line() - 2); i &lt; Math.min(contents.size(), reviewComment.line() + 1); ++i) {
363                 body.append(&quot;&gt; &quot;).append(i + 1).append(&quot;: &quot;).append(contents.get(i)).append(&quot;\n&quot;);
364             }
365             body.append(&quot;\n&quot;);
366         }
367         body.append(reviewComment.body());
368 
369         addReplyCommon(parent, reviewComment.author(), parent.subject(), body.toString(), id);
370     }
371 
372     List&lt;Email&gt; generatedEmails() {
373         return generated;
374     }
375 }
</pre>
</td>
</tr>
</table>
<center><a href="PullRequestInstance.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WebrevStorage.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>