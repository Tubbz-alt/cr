<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.proxy.HttpProxy;
 29 import org.openjdk.skara.vcs.*;
 30 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 31 
 32 import java.io.IOException;
 33 import java.net.URI;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.*;
 37 import java.util.concurrent.TimeUnit;
 38 import java.util.function.Supplier;
 39 import java.util.logging.Level;
<a name="1" id="anc1"></a><span class="line-added"> 40 import java.util.regex.Matcher;</span>
<span class="line-added"> 41 import java.util.regex.Pattern;</span>
 42 import java.util.stream.Collectors;
 43 
 44 public class GitPr {
 45     private static void exit(String fmt, Object...args) {
 46         System.err.println(String.format(fmt, args));
 47         System.exit(1);
 48     }
 49 
 50     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 51         return () -&gt; {
 52             exit(fmt, args);
 53             return null;
 54         };
 55     }
 56 
 57     private static void await(Process p) throws IOException {
 58         try {
 59             var res = p.waitFor();
 60             if (res != 0) {
 61                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 62             }
 63         } catch (InterruptedException e) {
 64             throw new IOException(e);
 65         }
 66     }
 67 
 68     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 69         String editor = null;
 70         var lines = repo.config(&quot;core.editor&quot;);
 71         if (lines.size() == 1) {
 72             editor = lines.get(0);
 73         }
 74         if (editor == null) {
 75             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 76         }
 77         if (editor == null) {
 78             editor = System.getenv(&quot;EDITOR&quot;);
 79         }
 80         if (editor == null) {
 81             editor = System.getenv(&quot;VISUAL&quot;);
 82         }
 83         if (editor == null) {
 84             editor = &quot;vi&quot;;
 85         }
 86 
<a name="2" id="anc2"></a><span class="line-modified"> 87         List&lt;String&gt; editorParts = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 88         Matcher em = Pattern.compile(&quot;([^\&quot;]\\S*|\&quot;.+?\&quot;)\\s*&quot;).matcher(editor);</span>
<span class="line-added"> 89         while (em.find()) {</span>
<span class="line-added"> 90             editorParts.add(em.group(1));</span>
<span class="line-added"> 91         }</span>
<span class="line-added"> 92         editorParts.add(file.toString());</span>
<span class="line-added"> 93         var pb = new ProcessBuilder(editorParts);</span>
 94         pb.inheritIO();
 95         var p = pb.start();
 96         try {
 97             return p.waitFor() == 0;
 98         } catch (InterruptedException e) {
 99             throw new IOException(e);
100         }
101     }
102 
103     private static String projectName(URI uri) {
104         var name = uri.getPath().toString().substring(1);
105         if (name.endsWith(&quot;.git&quot;)) {
106             name = name.substring(0, name.length() - &quot;.git&quot;.length());
107         }
108         return name;
109     }
110 
111     private static HostedRepository getHostedRepositoryFor(URI uri, GitCredentials credentials) throws IOException {
112         var host = Forge.from(uri, new Credential(credentials.username(), credentials.password()));
113         if (System.getenv(&quot;GIT_TOKEN&quot;) == null) {
114             GitCredentials.approve(credentials);
115         }
116         if (host.isEmpty() || !host.get().isValid()) {
117             exit(&quot;error: failed to connect to host &quot; + uri);
118         }
119         var remoteRepo = host.get().repository(projectName(uri));
120         var parentRepo = remoteRepo.parent();
121         var targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
122         return targetRepo;
123     }
124 
125     private static PullRequest getPullRequest(URI uri, GitCredentials credentials, Argument prId) throws IOException {
126         if (!prId.isPresent()) {
127             exit(&quot;error: missing pull request identifier&quot;);
128         }
129 
130         var pr = getHostedRepositoryFor(uri, credentials).pullRequest(prId.asString());
131         if (pr == null) {
132             exit(&quot;error: could not fetch PR information&quot;);
133         }
134 
135         return pr;
136     }
137 
138     private static void show(String ref, Hash hash) throws IOException {
139         show(ref, hash, null);
140     }
141     private static void show(String ref, Hash hash, Path dir) throws IOException {
142         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
143                                                    &quot;--patch&quot;,
144                                                    &quot;--find-renames=50%&quot;,
145                                                    &quot;--find-copies=50%&quot;,
146                                                    &quot;--find-copies-harder&quot;,
147                                                    &quot;--abbrev&quot;,
148                                                    ref + &quot;...&quot; + hash.hex());
149         if (dir != null) {
150             pb.directory(dir.toFile());
151         }
152         pb.inheritIO();
153         await(pb.start());
154     }
155 
156     private static void gimport() throws IOException {
157         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
158         pb.inheritIO();
159         await(pb.start());
160     }
161 
162     private static void hgImport(Path patch) throws IOException {
163         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
164         pb.inheritIO();
165         await(pb.start());
166     }
167 
168     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
169         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
170         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
171         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
172         var p = pb.start();
173         var bytes = p.getInputStream().readAllBytes();
174         var exited = p.waitFor(1, TimeUnit.MINUTES);
175         var exitValue = p.exitValue();
176         if (!exited || exitValue != 0) {
177             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
178         }
179 
180         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
181     }
182 
183     private static String hgResolve(String ref) throws IOException, InterruptedException {
184         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
185         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
186         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
187         var p = pb.start();
188         var bytes = p.getInputStream().readAllBytes();
189         var exited = p.waitFor(1, TimeUnit.MINUTES);
190         var exitValue = p.exitValue();
191         if (!exited || exitValue != 0) {
192             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
193         }
194 
195         return new String(bytes, StandardCharsets.UTF_8);
196     }
197 
198     private static Path diff(String ref, Hash hash) throws IOException {
199         return diff(ref, hash, null);
200     }
201 
202     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
203         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
204         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
205                                                    &quot;--patch&quot;,
206                                                    &quot;--find-renames=50%&quot;,
207                                                    &quot;--find-copies=50%&quot;,
208                                                    &quot;--find-copies-harder&quot;,
209                                                    &quot;--abbrev&quot;,
210                                                    ref + &quot;...&quot; + hash.hex());
211         if (dir != null) {
212             pb.directory(dir.toFile());
213         }
214         pb.redirectOutput(patch.toFile());
215         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
216         await(pb.start());
217         return patch;
218     }
219 
220     private static void apply(Path patch) throws IOException {
221         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
222         pb.inheritIO();
223         await(pb.start());
224     }
225 
226     private static int longest(List&lt;String&gt; strings) {
227         return strings.stream().mapToInt(String::length).max().orElse(0);
228     }
229 
230     public static void main(String[] args) throws IOException, InterruptedException {
231         var flags = List.of(
232             Option.shortcut(&quot;u&quot;)
233                   .fullname(&quot;username&quot;)
234                   .describe(&quot;NAME&quot;)
235                   .helptext(&quot;Username on host&quot;)
236                   .optional(),
237             Option.shortcut(&quot;r&quot;)
238                   .fullname(&quot;remote&quot;)
239                   .describe(&quot;NAME&quot;)
240                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
241                   .optional(),
242             Option.shortcut(&quot;b&quot;)
243                   .fullname(&quot;branch&quot;)
244                   .describe(&quot;NAME&quot;)
245                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
246                   .optional(),
247             Option.shortcut(&quot;&quot;)
248                   .fullname(&quot;authors&quot;)
249                   .describe(&quot;LIST&quot;)
250                   .helptext(&quot;Comma separated list of authors&quot;)
251                   .optional(),
252             Option.shortcut(&quot;&quot;)
253                   .fullname(&quot;assignees&quot;)
254                   .describe(&quot;LIST&quot;)
255                   .helptext(&quot;Comma separated list of assignees&quot;)
256                   .optional(),
257             Option.shortcut(&quot;&quot;)
258                   .fullname(&quot;labels&quot;)
259                   .describe(&quot;LIST&quot;)
260                   .helptext(&quot;Comma separated list of labels&quot;)
261                   .optional(),
262             Option.shortcut(&quot;&quot;)
263                   .fullname(&quot;columns&quot;)
264                   .describe(&quot;id,title,author,assignees,labels&quot;)
265                   .helptext(&quot;Comma separated list of columns to show&quot;)
266                   .optional(),
267             Switch.shortcut(&quot;&quot;)
268                   .fullname(&quot;no-decoration&quot;)
269                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
270                   .optional(),
271             Switch.shortcut(&quot;&quot;)
272                   .fullname(&quot;mercurial&quot;)
273                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
274                   .optional(),
275             Switch.shortcut(&quot;&quot;)
276                   .fullname(&quot;verbose&quot;)
277                   .helptext(&quot;Turn on verbose output&quot;)
278                   .optional(),
279             Switch.shortcut(&quot;&quot;)
280                   .fullname(&quot;debug&quot;)
281                   .helptext(&quot;Turn on debugging output&quot;)
282                   .optional(),
283             Switch.shortcut(&quot;&quot;)
284                   .fullname(&quot;version&quot;)
285                   .helptext(&quot;Print the version of this tool&quot;)
286                   .optional());
287 
288         var inputs = List.of(
289             Input.position(0)
290                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update&quot;)
291                  .singular()
292                  .required(),
293             Input.position(1)
294                  .describe(&quot;ID&quot;)
295                  .singular()
296                  .optional()
297         );
298 
299         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
300         var arguments = parser.parse(args);
301 
302         if (arguments.contains(&quot;version&quot;)) {
303             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
304             System.exit(0);
305         }
306 
307         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
308             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
309             Logging.setup(level);
310         }
311 
312         HttpProxy.setup();
313 
314         var isMercurial = arguments.contains(&quot;mercurial&quot;);
315         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
316         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
317         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
318         var remotePullPath = repo.pullPath(remote);
319         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
320         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
321         var uri = Remote.toWebURI(remotePullPath);
322         var credentials = GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
323         var host = Forge.from(uri, new Credential(credentials.username(), credentials.password()));
324         if (host.isEmpty() || !host.get().isValid()) {
325             exit(&quot;error: failed to connect to host &quot; + uri);
326         }
327 
328         var action = arguments.at(0).asString();
329         if (action.equals(&quot;create&quot;)) {
330             if (isMercurial) {
331                 var currentBookmark = repo.currentBookmark();
332                 if (!currentBookmark.isPresent()) {
333                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
334                     System.err.println(&quot;&quot;);
335                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
336                     System.err.println(&quot;&quot;);
337                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
338                     System.err.println(&quot;&quot;);
339                     System.exit(1);
340                 }
341 
342                 var bookmark = currentBookmark.get();
343                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
344                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
345                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
346                     System.err.println(&quot;&quot;);
347                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
348                     System.err.println(&quot;&quot;);
349                     System.exit(1);
350                 }
351 
352                 var tags = hgTags();
353                 var upstreams = tags.stream()
354                                     .filter(t -&gt; t.endsWith(bookmark.name()))
355                                     .collect(Collectors.toList());
356                 if (upstreams.isEmpty()) {
357                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
358                     System.err.println(&quot;&quot;);
359                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
360                     System.err.println(&quot;&quot;);
361                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
362                     System.err.println(&quot;&quot;);
363                     System.exit(1);
364                 }
365 
366                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
367                 for (var tag : tags) {
368                     tagsAndHashes.put(tag, hgResolve(tag));
369                 }
370                 var bookmarkHash = hgResolve(bookmark.name());
371                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
372                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
373                     System.err.println(&quot;&quot;);
374 
375                     if (upstreams.size() == 1) {
376                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
377                         System.err.println(&quot;&quot;);
378                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
379                         System.err.println(&quot;&quot;);
380                     } else {
381                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
382                         System.err.println(&quot;&quot;);
383                         for (var upstream : upstreams) {
384                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
385                         }
386                         System.err.println(&quot;&quot;);
387                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
388                         System.err.println(&quot;&quot;);
389                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
390                         System.err.println(&quot;&quot;);
391                     }
392                     System.exit(1);
393                 }
394 
395                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
396                 var targetHash = hgResolve(targetBranch);
397                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
398                 if (commits.isEmpty()) {
399                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
400                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
401                     System.exit(1);
402                 }
403 
404                 var diff = repo.diff(repo.head());
405                 if (!diff.patches().isEmpty()) {
406                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
407                     System.err.println(&quot;&quot;);
408                     for (var patch : diff.patches()) {
409                         var path = patch.target().path().isPresent() ?
410                             patch.target().path().get() : patch.source().path().get();
411                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
412                     }
413                     System.err.println(&quot;&quot;);
414                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
415                     System.err.println(&quot;&quot;);
416                     System.err.println(&quot;    hg commit --amend&quot;);
417                     System.err.println(&quot;    hg git-cleanup&quot;);
418                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
419                     System.err.println(&quot;    hg gimport&quot;);
420                     System.err.println(&quot;&quot;);
421                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
422                     System.err.println(&quot;&quot;);
423                     System.err.println(&quot;    hg shelve&quot;);
424                     System.err.println(&quot;&quot;);
425                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
426                     System.exit(1);
427                 }
428 
429                 var remoteRepo = host.get().repository(projectName(uri));
430                 if (token == null) {
431                     GitCredentials.approve(credentials);
432                 }
433                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
434                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
435 
436                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
437                 if (commits.size() == 1) {
438                     var commit = commits.get(0);
439                     var message = CommitMessageParsers.v1.parse(commit.message());
440                     Files.writeString(file, message.title() + &quot;\n&quot;);
441                     if (!message.summaries().isEmpty()) {
442                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
443                     }
444                     if (!message.additional().isEmpty()) {
445                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
446                     }
447                 } else {
448                     Files.write(file, List.of(&quot;&quot;));
449                 }
450                 Files.write(file, List.of(
451                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
452                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
453                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
454                     &quot;# the subject from the body.&quot;,
455                     &quot;#&quot;,
456                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
457                     ),
458                     StandardOpenOption.APPEND
459                 );
460                 for (var commit : commits) {
461                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
462                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
463                 }
464                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
465                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
466                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
467                 var success = spawnEditor(repo, file);
468                 if (!success) {
469                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
470                     System.exit(1);
471                 }
472                 var lines = Files.readAllLines(file)
473                                  .stream()
474                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
475                                  .collect(Collectors.toList());
476                 var isEmpty = lines.stream().allMatch(String::isEmpty);
477                 if (isEmpty) {
478                     System.err.println(&quot;error: no message present, aborting&quot;);
479                     System.exit(1);
480                 }
481 
482                 var title = lines.get(0);
483                 List&lt;String&gt; body = null;
484                 if (lines.size() &gt; 1) {
485                     body = lines.subList(1, lines.size())
486                                 .stream()
487                                 .dropWhile(String::isEmpty)
488                                 .collect(Collectors.toList());
489                 } else {
490                     body = Collections.emptyList();
491                 }
492 
493                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
494                 if (arguments.contains(&quot;assignees&quot;)) {
495                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
496                     var assignees = usernames.stream()
497                                              .map(u -&gt; host.get().user(u))
498                                              .collect(Collectors.toList());
499                     pr.setAssignees(assignees);
500                 }
501                 System.out.println(pr.webUrl().toString());
502                 Files.deleteIfExists(file);
503 
504                 System.exit(0);
505             }
506             var currentBranch = repo.currentBranch();
507             if (currentBranch.equals(repo.defaultBranch())) {
508                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
509                 System.err.println(&quot;&quot;);
510                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
511                 System.err.println(&quot;&quot;);
512                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
513                 System.err.println(&quot;    git branch --force master origin/master&quot;);
514                 System.err.println(&quot;&quot;);
515                 System.exit(1);
516             }
517 
518             var upstream = repo.upstreamFor(currentBranch);
519             if (upstream.isEmpty()) {
520                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
521                 System.err.println(&quot;&quot;);
522                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
523                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
524                 System.err.println(&quot;&quot;);
525                 System.err.println(&quot;    git push --set-upstream &quot; + remote + &quot; &quot; + currentBranch.name());
526                 System.err.println(&quot;&quot;);
527                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
528                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
529                 System.err.println(&quot;&quot;);
530                 System.err.println(&quot;    git fetch &quot; + remote);
531                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
532                 System.err.println(&quot;&quot;);
533                 System.exit(1);
534             }
535 
536             var upstreamRefName = upstream.get().substring(remote.length() + 1);
537             repo.fetch(uri, upstreamRefName);
538             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
539             if (!branchCommits.isEmpty()) {
540                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
541                 System.err.println(&quot;&quot;);
542                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
543                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
544                 System.err.println(&quot;&quot;);
545                 for (var commit : branchCommits) {
546                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
547                 }
548                 System.err.println(&quot;&quot;);
549                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
550                 System.err.println(&quot;&quot;);
551                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
552                 System.err.println(&quot;&quot;);
553                 System.exit(1);
554             }
555 
556             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
557             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
558             if (commits.isEmpty()) {
559                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
560                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
561                 System.exit(1);
562             }
563 
564             var diff = repo.diff(repo.head());
565             if (!diff.patches().isEmpty()) {
566                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
567                 System.err.println(&quot;&quot;);
568                 for (var patch : diff.patches()) {
569                     var path = patch.target().path().isPresent() ?
570                         patch.target().path().get() : patch.source().path().get();
571                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
572                 }
573                 System.err.println(&quot;&quot;);
574                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
575                 System.err.println(&quot;&quot;);
576                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
577                 System.err.println(&quot;&quot;);
578                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
579                 System.err.println(&quot;&quot;);
580                 System.err.println(&quot;    git stash&quot;);
581                 System.err.println(&quot;&quot;);
582                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
583                 System.exit(1);
584             }
585 
586             var remoteRepo = host.get().repository(projectName(uri));
587             if (token == null) {
588                 GitCredentials.approve(credentials);
589             }
590             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
591                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
592 
593             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
594             if (commits.size() == 1) {
595                 var commit = commits.get(0);
596                 var message = CommitMessageParsers.v1.parse(commit.message());
597                 Files.writeString(file, message.title() + &quot;\n&quot;);
598                 if (!message.summaries().isEmpty()) {
599                     Files.write(file, message.summaries(), StandardOpenOption.APPEND);
600                 }
601                 if (!message.additional().isEmpty()) {
602                     Files.write(file, message.additional(), StandardOpenOption.APPEND);
603                 }
604             } else {
605                 Files.write(file, List.of(&quot;&quot;));
606             }
607             Files.write(file, List.of(
608                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
609                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
610                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
611                 &quot;# the subject from the body.&quot;,
612                 &quot;#&quot;,
613                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
614                 ),
615                 StandardOpenOption.APPEND
616             );
617             for (var commit : commits) {
618                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
619                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
620             }
621             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
622             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
623             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
624             var success = spawnEditor(repo, file);
625             if (!success) {
626                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
627                 System.exit(1);
628             }
629             var lines = Files.readAllLines(file)
630                              .stream()
631                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
632                              .collect(Collectors.toList());
633             var isEmpty = lines.stream().allMatch(String::isEmpty);
634             if (isEmpty) {
635                 System.err.println(&quot;error: no message present, aborting&quot;);
636                 System.exit(1);
637             }
638 
639             var title = lines.get(0);
640             List&lt;String&gt; body = null;
641             if (lines.size() &gt; 1) {
642                 body = lines.subList(1, lines.size())
643                             .stream()
644                             .dropWhile(String::isEmpty)
645                             .collect(Collectors.toList());
646             } else {
647                 body = Collections.emptyList();
648             }
649 
650             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
651             if (arguments.contains(&quot;assignees&quot;)) {
652                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
653                 var assignees = usernames.stream()
654                                          .map(u -&gt; host.get().user(u))
655                                          .collect(Collectors.toList());
656                 pr.setAssignees(assignees);
657             }
658             System.out.println(pr.webUrl().toString());
659             Files.deleteIfExists(file);
660         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;)) {
661             var pr = getPullRequest(uri, credentials, arguments.at(1));
662 
663             if (action.equals(&quot;integrate&quot;)) {
664                 pr.addComment(&quot;/integrate&quot;);
665             } else if (action.equals(&quot;approve&quot;)) {
666                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
667             } else {
668                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
669             }
670         } else if (action.equals(&quot;list&quot;)) {
671             var remoteRepo = getHostedRepositoryFor(uri, credentials);
672             var prs = remoteRepo.pullRequests();
673 
674             var ids = new ArrayList&lt;String&gt;();
675             var titles = new ArrayList&lt;String&gt;();
676             var authors = new ArrayList&lt;String&gt;();
677             var assignees = new ArrayList&lt;String&gt;();
678             var labels = new ArrayList&lt;String&gt;();
679 
680             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
681                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
682                 Set.of();
683             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
684                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
685                 Set.of();
686             var filterLabels = arguments.contains(&quot;labels&quot;) ?
687                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
688                 Set.of();
689 
690             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
691             var columnValues = Map.of(defaultColumns.get(0), ids,
692                                       defaultColumns.get(1), titles,
693                                       defaultColumns.get(2), authors,
694                                       defaultColumns.get(3), assignees,
695                                       defaultColumns.get(4), labels);
696             var columns = arguments.contains(&quot;columns&quot;) ?
697                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
698                 defaultColumns;
699             if (columns != defaultColumns) {
700                 for (var column : columns) {
701                     if (!defaultColumns.contains(column)) {
702                         System.err.println(&quot;error: unknown column: &quot; + column);
703                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
704                         System.exit(1);
705                     }
706                 }
707             }
708 
709             for (var pr : remoteRepo.pullRequests()) {
710                 var prAuthor = pr.author().userName();
711                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
712                     continue;
713                 }
714 
715                 var prAssignees = pr.assignees().stream()
716                                     .map(HostUser::userName)
717                                     .collect(Collectors.toSet());
718                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
719                     continue;
720                 }
721 
722                 var prLabels = new HashSet&lt;&gt;(pr.labels());
723                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
724                     continue;
725                 }
726 
727                 ids.add(pr.id());
728                 titles.add(pr.title());
729                 authors.add(prAuthor);
730                 assignees.add(String.join(&quot;,&quot;, prAssignees));
731                 labels.add(String.join(&quot;,&quot;, prLabels));
732             }
733 
734 
735             String fmt = &quot;&quot;;
736             for (var column : columns.subList(0, columns.size() - 1)) {
737                 var values = columnValues.get(column);
738                 var n = Math.max(column.length(), longest(values));
739                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
740             }
741             fmt += &quot;%s\n&quot;;
742 
743             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
744                 var upperCase = columns.stream()
745                                        .map(String::toUpperCase)
746                                        .collect(Collectors.toList());
747                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
748             }
749             for (var i = 0; i &lt; ids.size(); i++) {
750                 final int n = i;
751                 var row = columns.stream()
752                                  .map(columnValues::get)
753                                  .map(values -&gt; values.get(n))
754                                  .collect(Collectors.toList());
755                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
756             }
757         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
758             var prId = arguments.at(1);
759             if (!prId.isPresent()) {
760                 exit(&quot;error: missing pull request identifier&quot;);
761             }
762 
763             var remoteRepo = getHostedRepositoryFor(uri, credentials);
764             var pr = remoteRepo.pullRequest(prId.asString());
765             var repoUrl = remoteRepo.webUrl();
766             var prHeadRef = pr.sourceRef();
767             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
768             if (isHgGit) {
769                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
770                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
771 
772                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
773                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
774                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
775 
776                     if (action.equals(&quot;show&quot;)) {
777                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
778                     } else {
779                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
780                         hgImport(patch);
781                         Files.delete(patch);
782                     }
783                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
784                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
785                     var hgGitBranches = hgGitRepo.branches();
786                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
787                         hgGitRepo.delete(new Branch(hgGitRef));
788                     }
789                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
790                     gimport();
791                     var hgFetchHead = repo.resolve(hgGitRef).get();
792 
793                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
794                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
795                     } else if (action.equals(&quot;checkout&quot;)) {
796                         repo.checkout(hgFetchHead);
797                         if (arguments.contains(&quot;branch&quot;)) {
798                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
799                         }
800                     }
801                 } else {
802                     exit(&quot;Unexpected action: &quot; + action);
803                 }
804 
805                 return;
806             }
807 
808             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
809             if (action.equals(&quot;fetch&quot;)) {
810                 if (arguments.contains(&quot;branch&quot;)) {
811                     var branchName = arguments.get(&quot;branch&quot;).asString();
812                     repo.branch(fetchHead, branchName);
813                 } else {
814                     System.out.println(fetchHead.hex());
815                 }
816             } else if (action.equals(&quot;checkout&quot;)) {
817                 if (arguments.contains(&quot;branch&quot;)) {
818                     var branchName = arguments.get(&quot;branch&quot;).asString();
819                     var branch = repo.branch(fetchHead, branchName);
820                     repo.checkout(branch, false);
821                 } else {
822                     repo.checkout(fetchHead, false);
823                 }
824             } else if (action.equals(&quot;show&quot;)) {
825                 show(pr.targetRef(), fetchHead);
826             } else if (action.equals(&quot;apply&quot;)) {
827                 var patch = diff(pr.targetRef(), fetchHead);
828                 apply(patch);
829                 Files.deleteIfExists(patch);
830             }
831         } else if (action.equals(&quot;close&quot;)) {
832             var prId = arguments.at(1);
833             if (!prId.isPresent()) {
834                 exit(&quot;error: missing pull request identifier&quot;);
835             }
836 
837             var remoteRepo = getHostedRepositoryFor(uri, credentials);
838             var pr = remoteRepo.pullRequest(prId.asString());
839             pr.setState(PullRequest.State.CLOSED);
840         } else if (action.equals(&quot;update&quot;)) {
841             var prId = arguments.at(1);
842             if (!prId.isPresent()) {
843                 exit(&quot;error: missing pull request identifier&quot;);
844             }
845 
846             var remoteRepo = getHostedRepositoryFor(uri, credentials);
847             var pr = remoteRepo.pullRequest(prId.asString());
848             if (arguments.contains(&quot;assignees&quot;)) {
849                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
850                 var assignees = usernames.stream()
851                     .map(u -&gt; host.get().user(u))
852                     .collect(Collectors.toList());
853                 pr.setAssignees(assignees);
854             }
855         } else {
856             exit(&quot;error: unexpected action: &quot; + action);
857         }
858     }
859 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>