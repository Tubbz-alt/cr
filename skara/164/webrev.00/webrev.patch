diff a/bot/src/main/java/org/openjdk/skara/bot/BotRunner.java b/bot/src/main/java/org/openjdk/skara/bot/BotRunner.java
--- a/bot/src/main/java/org/openjdk/skara/bot/BotRunner.java
+++ b/bot/src/main/java/org/openjdk/skara/bot/BotRunner.java
@@ -42,11 +42,10 @@
         addSuppressed(suppressed);
     }
 }
 
 public class BotRunner {
-
     enum TaskPhases {
         BEGIN,
         END
     }
 
@@ -89,18 +88,18 @@
                 scratchPaths.addLast(scratchPath);
                 active.remove(item);
 
                 // Some of the pending items may now be eligible for execution
                 var candidateItems = pending.entrySet().stream()
-                                            .filter(e -> !e.getValue().isPresent() || !active.contains(e.getValue().get()))
+                                            .filter(e -> e.getValue().isEmpty() || !active.containsKey(e.getValue().get()))
                                             .map(Map.Entry::getKey)
                                             .collect(Collectors.toList());
 
                 // Try the candidates against the current active set
                 for (var candidate : candidateItems) {
                     boolean maySubmit = true;
-                    for (var activeItem : active) {
+                    for (var activeItem : active.keySet()) {
                         if (!activeItem.concurrentWith(candidate)) {
                             // Still can't run this candidate, leave it pending
                             log.finer("Cannot submit candidate " + candidate + " - not concurrent with " + activeItem);
                             maySubmit = false;
                             break;
@@ -108,27 +107,25 @@
                     }
 
                     if (maySubmit) {
                         pending.remove(candidate);
                         executor.submit(new RunnableWorkItem(candidate));
-                        active.add(candidate);
+                        active.put(candidate, Instant.now());
                         log.finer("Submitting candidate: " + candidate);
                     }
                 }
             }
-
         }
     }
 
     private final Map<WorkItem, Optional<WorkItem>> pending;
-    private final Set<WorkItem> active;
+    private final Map<WorkItem, Instant> active;
     private final Deque<Path> scratchPaths;
 
     private void submitOrSchedule(WorkItem item) {
-
         synchronized (executor) {
-            for (var activeItem : active) {
+            for (var activeItem : active.keySet()) {
                 if (!activeItem.concurrentWith(item)) {
 
                     for (var pendingItem : pending.entrySet()) {
                         // If there are pending items of the same type that we cannot run concurrently with, replace them.
                         if (pendingItem.getKey().getClass().equals(item.getClass()) && !pendingItem.getKey().concurrentWith(item)) {
@@ -144,16 +141,15 @@
                     return;
                 }
             }
 
             executor.submit(new RunnableWorkItem(item));
-            active.add(item);
+            active.put(item, Instant.now());
         }
     }
 
     private void drain(Duration timeout) throws TimeoutException {
-
         Instant start = Instant.now();
 
         while (Instant.now().isBefore(start.plus(timeout))) {
             while (true) {
                 var head = (ScheduledFuture<?>) executor.getQueue().peek();
@@ -179,10 +175,11 @@
                     log.finest("Waiting for flighted tasks");
                 }
             }
             try {
                 Thread.sleep(1);
+                watchdog();
             } catch (InterruptedException e) {
                 log.warning("Exception during queue drain");
                 log.throwing("BotRunner", "drain", e);
             }
         }
@@ -198,11 +195,11 @@
     public BotRunner(BotRunnerConfiguration config, List<Bot> bots) {
         this.config = config;
         this.bots = bots;
 
         pending = new HashMap<>();
-        active = new HashSet<>();
+        active = new HashMap<>();
         scratchPaths = new LinkedList<>();
 
         for (int i = 0; i < config.concurrency(); ++i) {
             var folder = config.scratchFolder().resolve("scratch-" + i);
             scratchPaths.addLast(folder);
@@ -227,10 +224,24 @@
         } finally {
             log.log(Level.FINE, "Done checking periodic items", TaskPhases.END);
         }
     }
 
+    private void watchdog() {
+        synchronized (executor) {
+            for (var activeItem : active.entrySet()) {
+                var activeDuration = Duration.between(activeItem.getValue(), Instant.now());
+                if (activeDuration.compareTo(config.watchdogTimeout()) > 0) {
+                    log.severe("Item " + activeItem.getKey() + " has been active more than " + activeDuration +
+                                       " - this may be an error!");
+                    // Reset the counter to avoid continuous reporting - once every watchdogTimeout is enough
+                    activeItem.setValue(Instant.now());
+                }
+            }
+        }
+    }
+
     private void processRestRequest(JSONValue request) {
         log.log(Level.FINE, "Starting processing of incoming rest request", TaskPhases.BEGIN);
         log.fine("Request: " + request);
         try {
             for (var bot : bots) {
@@ -261,10 +272,12 @@
                 log.warning("Failed to create RestReceiver");
                 log.throwing("BotRunner", "run", e);
             }
         }
 
+        executor.scheduleAtFixedRate(this::watchdog, 0,
+                                     config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
         executor.scheduleAtFixedRate(this::checkPeriodicItems, 0,
                                      config.scheduledExecutionPeriod().toMillis(), TimeUnit.MILLISECONDS);
 
         try {
             executor.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);
diff a/bot/src/main/java/org/openjdk/skara/bot/BotRunnerConfiguration.java b/bot/src/main/java/org/openjdk/skara/bot/BotRunnerConfiguration.java
--- a/bot/src/main/java/org/openjdk/skara/bot/BotRunnerConfiguration.java
+++ b/bot/src/main/java/org/openjdk/skara/bot/BotRunnerConfiguration.java
@@ -261,6 +261,15 @@
         if (!config.contains("webhooks")) {
             return Optional.empty();
         }
         return Optional.of(config.get("webhooks").get("port").asInt());
     }
+
+    Duration watchdogTimeout() {
+        if (!config.contains("runner") || !config.get("runner").contains("watchdog")) {
+            log.info("No WorkItem watchdog timeout defined, using default value");
+            return Duration.ofHours(1);
+        } else {
+            return Duration.parse(config.get("runner").get("watchdog").asString());
+        }
+    }
 }
diff a/bot/src/test/java/org/openjdk/skara/bot/BotRunnerTests.java b/bot/src/test/java/org/openjdk/skara/bot/BotRunnerTests.java
--- a/bot/src/test/java/org/openjdk/skara/bot/BotRunnerTests.java
+++ b/bot/src/test/java/org/openjdk/skara/bot/BotRunnerTests.java
@@ -20,21 +20,23 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bot;
 
+import org.openjdk.skara.json.JSON;
+
 import org.junit.jupiter.api.*;
-import org.openjdk.skara.host.HostedRepository;
-import org.openjdk.skara.json.*;
 
-import java.nio.file.*;
+import java.nio.file.Path;
 import java.time.Duration;
 import java.util.*;
-import java.util.concurrent.TimeoutException;
+import java.util.concurrent.*;
 import java.util.function.Supplier;
 import java.util.logging.*;
 
+import static org.junit.jupiter.api.Assertions.*;
+
 class TestWorkItem implements WorkItem {
     private final ConcurrencyCheck concurrencyCheck;
     private final String description;
     boolean hasRun = false;
 
@@ -73,16 +75,40 @@
     TestWorkItemChild(ConcurrencyCheck concurrencyCheck, String description) {
         super(concurrencyCheck, description);
     }
 }
 
+class TestBlockedWorkItem implements WorkItem {
+    private final CountDownLatch countDownLatch;
+
+    TestBlockedWorkItem(CountDownLatch countDownLatch) {
+        this.countDownLatch = countDownLatch;
+    }
+
+    @Override
+    public boolean concurrentWith(WorkItem other) {
+        return false;
+    }
+
+    @Override
+    public void run(Path scratchPath) {
+        System.out.println("Starting to wait...");;
+        try {
+            countDownLatch.await();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+        System.out.println("Done waiting");
+    }
+}
+
 class TestBot implements Bot {
 
     private final List<WorkItem> items;
     private final Supplier<List<WorkItem>> itemSupplier;
 
-    TestBot(TestWorkItem... items) {
+    TestBot(WorkItem... items) {
         this.items = Arrays.asList(items);
         itemSupplier = null;
     }
 
     TestBot(Supplier<List<WorkItem>> itemSupplier) {
@@ -120,21 +146,29 @@
         } catch (ConfigurationError configurationError) {
             throw new RuntimeException(configurationError);
         }
     }
 
+    private BotRunnerConfiguration config(String json) {
+        var config = JSON.parse(json).asObject();
+        try {
+            return BotRunnerConfiguration.parse(config);
+        } catch (ConfigurationError configurationError) {
+            throw new RuntimeException(configurationError);
+        }
+    }
     @Test
     void simpleConcurrent() throws TimeoutException {
         var item1 = new TestWorkItem(i -> true, "Item 1");
         var item2 = new TestWorkItem(i -> true, "Item 2");
         var bot = new TestBot(item1, item2);
         var runner = new BotRunner(config(), List.of(bot));
 
         runner.runOnce(Duration.ofSeconds(10));
 
-        Assertions.assertTrue(item1.hasRun);
-        Assertions.assertTrue(item2.hasRun);
+        assertTrue(item1.hasRun);
+        assertTrue(item2.hasRun);
     }
 
     @Test
     void simpleSerial() throws TimeoutException {
         var item1 = new TestWorkItem(i -> false, "Item 1");
@@ -142,12 +176,12 @@
         var bot = new TestBot(item1, item2);
         var runner = new BotRunner(config(), List.of(bot));
 
         runner.runOnce(Duration.ofSeconds(10));
 
-        Assertions.assertTrue(item1.hasRun);
-        Assertions.assertTrue(item2.hasRun);
+        assertTrue(item1.hasRun);
+        assertTrue(item2.hasRun);
     }
 
     @Test
     void moreItemsThanScratchPaths() throws TimeoutException {
         List<TestWorkItem> items = new LinkedList<>();
@@ -158,11 +192,11 @@
         var runner = new BotRunner(config(), List.of(bot));
 
         runner.runOnce(Duration.ofSeconds(10));
 
         for (var item : items) {
-            Assertions.assertTrue(item.hasRun);
+            assertTrue(item.hasRun);
         }
     }
 
     static class ThrowingItemProvider {
         private final List<WorkItem> items;
@@ -193,12 +227,12 @@
         new BotRunner(config(), List.of(bot)).runOnce(Duration.ofSeconds(10));
         Assertions.assertFalse(item1.hasRun);
         Assertions.assertFalse(item2.hasRun);
 
         new BotRunner(config(), List.of(bot)).runOnce(Duration.ofSeconds(10));
-        Assertions.assertTrue(item1.hasRun);
-        Assertions.assertTrue(item2.hasRun);
+        assertTrue(item1.hasRun);
+        assertTrue(item2.hasRun);
     }
 
     @Test
     void discardAdditionalBlockedItems() throws TimeoutException {
         var item1 = new TestWorkItem(i -> false, "Item 1");
@@ -208,14 +242,14 @@
         var bot = new TestBot(item1, item2, item3, item4);
         var runner = new BotRunner(config(), List.of(bot));
 
         runner.runOnce(Duration.ofSeconds(10));
 
-        Assertions.assertTrue(item1.hasRun);
+        assertTrue(item1.hasRun);
         Assertions.assertFalse(item2.hasRun);
         Assertions.assertFalse(item3.hasRun);
-        Assertions.assertTrue(item4.hasRun);
+        assertTrue(item4.hasRun);
     }
 
     @Test
     void dontDiscardDifferentBlockedItems() throws TimeoutException {
         var item1 = new TestWorkItem(i -> false, "Item 1");
@@ -228,14 +262,46 @@
         var bot = new TestBot(item1, item2, item3, item4, item5, item6, item7);
         var runner = new BotRunner(config(), List.of(bot));
 
         runner.runOnce(Duration.ofSeconds(10));
 
-        Assertions.assertTrue(item1.hasRun);
+        assertTrue(item1.hasRun);
         Assertions.assertFalse(item2.hasRun);
         Assertions.assertFalse(item3.hasRun);
-        Assertions.assertTrue(item4.hasRun);
+        assertTrue(item4.hasRun);
         Assertions.assertFalse(item5.hasRun);
         Assertions.assertFalse(item6.hasRun);
-        Assertions.assertTrue(item7.hasRun);
+        assertTrue(item7.hasRun);
+    }
+
+    @Test
+    void watchdogTrigger() throws TimeoutException {
+        var countdownLatch = new CountDownLatch(1);
+        var item = new TestBlockedWorkItem(countdownLatch);
+        var bot = new TestBot(item);
+        var runner = new BotRunner(config("{ \"runner\": { \"watchdog\": \"PT0.01S\" } }"), List.of(bot));
+
+        var errors = new ArrayList<String>();
+        var log = Logger.getLogger("org.openjdk.skara.bot");
+        log.addHandler(new Handler() {
+            @Override
+            public void publish(LogRecord record) {
+                if (record.getLevel().equals(Level.SEVERE)) {
+                    errors.add(record.getMessage());
+                }
+            }
+
+            @Override
+            public void flush() {
+            }
+
+            @Override
+            public void close() throws SecurityException {
+            }
+        });
+
+        assertThrows(TimeoutException.class, () -> runner.runOnce(Duration.ofMillis(100)));
+        assertTrue(errors.size() > 0);
+        assertTrue(errors.size() <= 10);
+        countdownLatch.countDown();
     }
 }
