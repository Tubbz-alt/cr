diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JNotifyBot.java
@@ -65,29 +65,58 @@
             return true;
         }
         return false;
     }
 
-    private void handleBranch(Repository localRepo, UpdateHistory history, Branch branch, Hash curHead) throws IOException {
-        var lastRef = history.branchHash(branch);
-        if (lastRef.isEmpty()) {
-            log.warning("No previous history found for branch '" + branch + "' - resetting mark");
-            history.setBranchHash(branch, curHead);
+    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs) {
+        // Figure out the best parent ref
+        var candidates = new HashSet<>(allRefs);
+        candidates.remove(ref);
+        if (candidates.size() == 0) {
+            log.warning("No parent candidates found for branch '" + ref.name() + "' - ignoring");
             return;
         }
 
-        var newCommits = localRepo.commits(lastRef.get() + ".." + curHead).asList();
-        if (newCommits.size() == 0) {
-            return;
+        var bestParent = candidates.stream()
+                                   .map(c -> {
+                                       try {
+                                           return new AbstractMap.SimpleEntry<>(c, localRepo.commits(c.hash().hex() + ".." + ref.hash(), true).asList());
+                                       } catch (IOException e) {
+                                           throw new UncheckedIOException(e);
+                                       }
+                                   })
+                                   .min(Comparator.comparingInt(entry -> entry.getValue().size()))
+                                   .orElseThrow();
+        for (var updater : updaters) {
+            var branch = new Branch(ref.name());
+            var parent = new Branch(bestParent.getKey().name());
+            updater.handleNewBranch(repository, bestParent.getValue(), parent, branch);
         }
+    }
 
-        // Update the history first - if there is a problem here we don't want to send out multiple updates
-        history.setBranchHash(branch, curHead);
-
-        Collections.reverse(newCommits);
+    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits) {
         for (var updater : updaters) {
-            updater.handleCommits(repository, newCommits, branch);
+            var branch = new Branch(ref.name());
+            updater.handleCommits(repository, commits, branch);
+        }
+    }
+
+    private void handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
+        var branch = new Branch(ref.name());
+        var lastHash = history.branchHash(branch);
+        if (lastHash.isEmpty()) {
+            log.warning("No previous history found for branch '" + branch + "' - resetting mark");
+            history.setBranchHash(branch, ref.hash());
+            handleNewRef(localRepo, ref, allRefs);
+        } else {
+            var commits = localRepo.commits(lastHash.get() + ".." + ref.hash()).asList();
+            if (commits.size() == 0) {
+                return;
+            }
+            history.setBranchHash(branch, ref.hash());
+            Collections.reverse(commits);
+            handleUpdatedRef(localRepo, ref, commits);
         }
     }
 
     private Optional<OpenJDKTag> existingPrevious(OpenJDKTag tag, Set<OpenJDKTag> allJdkTags) {
         while (true) {
@@ -175,15 +204,16 @@
         try {
             var localRepo = fetchAll(path, repository.getUrl());
             var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve("tags"), branchStorageBuilder, historyPath.resolve("branches"));
             handleTags(localRepo, history);
 
-            for (var ref : localRepo.remoteBranches("origin")) {
-                if (branches.matcher(ref.name()).matches()) {
-                    var branch = new Branch(ref.name());
-                    handleBranch(localRepo, history, branch, ref.hash());
-                }
+            var knownRefs = localRepo.remoteBranches("origin")
+                                     .stream()
+                                     .filter(ref -> branches.matcher(ref.name()).matches())
+                                     .collect(Collectors.toList());
+            for (var ref : knownRefs) {
+                handleRef(localRepo, history, ref, knownRefs);
             }
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
@@ -96,6 +96,11 @@
             }
             var json = issuesToChanges(repository, issues, build);
             writer.write(json);
         }
     }
+
+    @Override
+    public void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch) {
+
+    }
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
@@ -240,6 +240,55 @@
                          .headers(headers)
                          .build();
 
         list.post(email);
     }
+
+    private String newBranchSubject(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch) {
+        var subject = new StringBuilder();
+        subject.append(repository.getRepositoryType().shortName());
+        subject.append(": ");
+        subject.append(repository.getName());
+        subject.append(": created branch ");
+        subject.append(branch);
+        subject.append(" based on the branch ");
+        subject.append(parent);
+        subject.append(" containing ");
+        subject.append(commits.size());
+        subject.append(" unique commit");
+        if (commits.size() != 1) {
+            subject.append("s");
+        }
+
+        return subject.toString();
+    }
+
+    @Override
+    public void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch) {
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        if (commits.size() > 0) {
+            printer.println("The following commits are unique to the " + branch.name() + " branch");
+            printer.println("========================================================");
+            for (var commit : commits) {
+                printer.print(commit.hash().abbreviate());
+                if (commit.message().size() > 0) {
+                    printer.print(": " + commit.message().get(0));
+                }
+                printer.println();
+            }
+        } else {
+            printer.println("The new branch " + branch.name() + " is currently identical to the " + parent.name() + " branch.");
+        }
+
+        var subject = newBranchSubject(repository, commits, parent, branch);
+        var finalAuthor = author != null ? author : commits.size() > 0 ? commitsToAuthor(commits) : sender;
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .author(finalAuthor)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .build();
+        list.post(email);
+    }
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateConsumer.java
@@ -29,6 +29,7 @@
 import java.util.List;
 
 public interface UpdateConsumer {
     void handleCommits(HostedRepository repository, List<Commit> commits, Branch branch);
     void handleTagCommits(HostedRepository repository, List<Commit> commits, OpenJDKTag tag);
+    void handleNewBranch(HostedRepository repository, List<Commit> commits, Branch parent, Branch branch);
 }
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
@@ -641,6 +641,71 @@
                 assertTrue(email.hasHeader("extra2"));
                 assertEquals("value2", email.headerValue("extra2"));
             }
         }
     }
+
+    @Test
+    void testMailingListBranch(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.getRepositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.getUrl());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP());
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = new MailingListUpdater(mailmanList, listAddress, sender, null, false, MailingListUpdater.Mode.ALL,
+                                                 Map.of("extra1", "value1", "extra2", "value2"));
+            var notifyBot = new JNotifyBot(repo, storageFolder, Pattern.compile("master|newbranch."), tagStorage, branchStorage, List.of(updater));
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            CheckableRepository.appendAndCommit(localRepo, "Another line", "12345678: Some fixes");
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.getUrl(), "newbranch1");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(sender, email.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch1 based on the branch master containing 2 unique commits", email.subject());
+            assertTrue(email.body().contains("12345678: Some fixes"));
+            assertTrue(email.hasHeader("extra1"));
+            assertEquals("value1", email.headerValue("extra1"));
+            assertTrue(email.hasHeader("extra2"));
+            assertEquals("value2", email.headerValue("extra2"));
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.push(editHash, repo.getUrl(), "newbranch2");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var newConversation = mailmanList.conversations(Duration.ofDays(1)).stream()
+                                             .filter(c -> !c.equals(conversations.get(0)))
+                                             .findFirst().orElseThrow();
+            email = newConversation.first();
+            assertEquals(sender, email.sender());
+            assertEquals(sender, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch2 based on the branch newbranch1 containing 0 unique commits", email.subject());
+            assertEquals("The new branch newbranch2 is currently identical to the newbranch1 branch.", email.body());
+        }
+    }
 }
