<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 
  35 import java.io.IOException;
  36 import java.net.URI;
  37 import java.nio.charset.StandardCharsets;
  38 import java.nio.file.*;
  39 import java.util.*;
  40 import java.util.regex.Pattern;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.function.Supplier;
  43 import java.util.logging.Level;
  44 import java.util.stream.Collectors;
  45 
  46 public class GitPr {
  47     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;
  48     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  49     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  50         Pattern.compile(&quot;^\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  51 
  52     private static void exit(String fmt, Object...args) {
  53         System.err.println(String.format(fmt, args));
  54         System.exit(1);
  55     }
  56 
  57     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  58         return () -&gt; {
  59             exit(fmt, args);
  60             return null;
  61         };
  62     }
  63 
  64     private static String gitConfig(String key) {
  65         try {
  66             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  67             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  68             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  69             var p = pb.start();
  70 
  71             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  72             var res = p.waitFor();
  73             if (res != 0) {
  74                 return null;
  75             }
  76 
  77             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  78         } catch (InterruptedException e) {
  79             return null;
  80         } catch (IOException e) {
  81             return null;
  82         }
  83     }
  84 
  85     private static String getOption(String name, Arguments arguments) {
  86         return getOption(name, null, arguments);
  87     }
  88 
  89     private static String getOption(String name, String subsection, Arguments arguments) {
  90         if (arguments.contains(name)) {
  91             return arguments.get(name).asString();
  92         }
  93 
  94         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  95             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  96             if (subsectionSpecific != null) {
  97                 return subsectionSpecific;
  98             }
  99         }
 100 
 101         return gitConfig(&quot;fork.&quot; + name);
 102     }
 103 
 104     private static boolean getSwitch(String name, Arguments arguments) {
 105         return getSwitch(name, null, arguments);
 106     }
 107 
 108     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 109         if (arguments.contains(name)) {
 110             return true;
 111         }
 112 
 113         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 114             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 115             if (subsectionSpecific != null) {
 116                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 117             }
 118         }
 119 
 120         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 121         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 122     }
 123 
 124     private static String rightPad(String s, int length) {
 125         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 126     }
 127 
 128     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 129         var end = &quot; --&gt;&quot;;
 130         var pad = 79 - end.length();
 131         var newLine = &quot;\n&quot;;
 132         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 133     }
 134 
 135     private static String format(Issue issue) {
 136         var parts = issue.id().split(&quot;-&quot;);
 137         var id = parts.length == 2 ? parts[1] : issue.id();
 138         return id + &quot;: &quot; + issue.title();
 139     }
 140 
 141 
 142     private static String pullRequestIdArgument(Arguments arguments, ReadOnlyRepository repo) throws IOException {
 143         if (arguments.at(1).isPresent()) {
 144             return arguments.at(1).asString();
 145         }
 146 
 147         var currentBranch = repo.currentBranch();
 148         if (currentBranch.isPresent()) {
 149             var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 150             if (lines.size() == 1) {
 151                 return lines.get(0);
 152             }
 153         }
 154 
 155         exit(&quot;error: you must provide a pull request id&quot;);
 156         return null;
 157     }
 158 
 159     private static String statusForPullRequest(PullRequest pr) {
 160         var labels = pr.labels();
 161         if (pr.isDraft()) {
 162             return &quot;DRAFT&quot;;
 163         } else if (labels.contains(&quot;rfr&quot;)) {
 164             return &quot;RFR&quot;;
 165         } else if (labels.contains(&quot;ready&quot;)) {
 166             return &quot;READY&quot;;
 167         } else if (labels.contains(&quot;outdated&quot;)) {
 168             return &quot;OUTDATED&quot;;
 169         } else if (labels.contains(&quot;oca&quot;)) {
 170             return &quot;OCA&quot;;
 171         } else if (labels.contains(&quot;integrated&quot;)) {
 172             return &quot;INTEGRATED&quot;;
 173         } else {
 174             var checks = pr.checks(pr.headHash());
 175             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
 176             if (jcheck.isPresent()) {
 177                 var checkStatus = jcheck.get().status();
 178                 if (checkStatus == CheckStatus.IN_PROGRESS) {
 179                     return &quot;CHECKING&quot;;
 180                 } else if (checkStatus == CheckStatus.SUCCESS) {
 181                     return &quot;RFR&quot;;
 182                 } else if (checkStatus == CheckStatus.FAILURE) {
 183                     return &quot;FAILURE&quot;;
 184                 }
 185             } else {
 186                 return &quot;CHECKING&quot;;
 187             }
 188         }
 189 
 190         return &quot;UNKNOWN&quot;;
 191     }
 192 
 193     private static String statusForCheck(Check check) {
 194         var checkStatus = check.status();
 195         if (checkStatus == CheckStatus.IN_PROGRESS) {
 196             return &quot;RUNNING&quot;;
 197         } else if (checkStatus == CheckStatus.SUCCESS) {
 198             return &quot;OK&quot;;
 199         } else if (checkStatus == CheckStatus.FAILURE) {
 200             return &quot;FAILED&quot;;
 201         } else if (checkStatus == CheckStatus.CANCELLED) {
 202             return &quot;CANCELLED&quot;;
 203         }
 204 
 205         return &quot;UNKNOWN&quot;;
 206     }
 207 
 208     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 209         var issueTitleIndex = -1;
 210         var lines = pr.body().split(&quot;\n&quot;);
 211         for (var i = 0; i &lt; lines.length; i++) {
 212             if (lines[i].startsWith(&quot;## Issue&quot;)) {
 213                 issueTitleIndex = i;
 214                 break;
 215             }
 216         }
 217 
 218         if (issueTitleIndex == -1) {
 219             return List.of();
 220         }
 221 
 222         var issues = new ArrayList&lt;String&gt;();
 223         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 224             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 225             if (m.matches()) {
 226                 issues.add(m.group(1));
 227             } else {
 228                 break;
 229             }
 230         }
 231 
 232         return issues;
 233     }
 234 
 235     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 236         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 237             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 238         ));
 239 
 240         return conf.general().jbs();
 241     }
 242 
 243     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 244         var message = CommitMessageParsers.v1.parse(commit.message());
 245         var issues = message.issues();
 246         if (issues.isEmpty()) {
 247             return getIssue(message.title(), project);
 248         } else if (issues.size() == 1) {
 249             var issue = issues.get(0);
 250             return getIssue(issue.id(), project);
 251         }
 252         return Optional.empty();
 253     }
 254 
 255     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 256         return getIssue(b.name(), project);
 257     }
 258 
 259     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 260         var m = ISSUE_ID_PATTERN.matcher(s);
 261         if (m.matches()) {
 262             var id = m.group(2);
 263             if (project == null) {
 264                 project = m.group(1);
 265             }
 266             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 267             return issueTracker.project(project).issue(id);
 268         }
 269 
 270         return Optional.empty();
 271     }
 272 
 273     private static void await(Process p) throws IOException {
 274         try {
 275             var res = p.waitFor();
 276             if (res != 0) {
 277                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 278             }
 279         } catch (InterruptedException e) {
 280             throw new IOException(e);
 281         }
 282     }
 283 
 284     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 285         String editor = null;
 286         var lines = repo.config(&quot;core.editor&quot;);
 287         if (lines.size() == 1) {
 288             editor = lines.get(0);
 289         }
 290         if (editor == null) {
 291             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 292         }
 293         if (editor == null) {
 294             editor = System.getenv(&quot;EDITOR&quot;);
 295         }
 296         if (editor == null) {
 297             editor = System.getenv(&quot;VISUAL&quot;);
 298         }
 299         if (editor == null) {
 300             editor = &quot;vi&quot;;
 301         }
 302 
 303         var pb = new ProcessBuilder(editor, file.toString());
 304         pb.inheritIO();
 305         var p = pb.start();
 306         try {
 307             return p.waitFor() == 0;
 308         } catch (InterruptedException e) {
 309             throw new IOException(e);
 310         }
 311     }
 312 
 313     private static String projectName(URI uri) {
 314         var name = uri.getPath().toString().substring(1);
 315         if (name.endsWith(&quot;.git&quot;)) {
 316             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 317         }
 318         return name;
 319     }
 320 
 321     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 322         HostedRepository targetRepo = null;
 323 
 324         try {
 325             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 326             targetRepo = host.repository(projectName(upstream)).orElse(null);
 327         } catch (IOException e) {
 328             // do nothing
 329         }
 330 
 331         if (targetRepo == null) {
 332             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 333                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 334             );
 335             var parentRepo = remoteRepo.parent();
 336             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 337         }
 338 
 339         return targetRepo;
 340     }
 341 
 342     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 343         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 344         if (pr == null) {
 345             exit(&quot;error: could not fetch PR information&quot;);
 346         }
 347 
 348         return pr;
 349     }
 350 
 351     private static void show(String ref, Hash hash) throws IOException {
 352         show(ref, hash, null);
 353     }
 354     private static void show(String ref, Hash hash, Path dir) throws IOException {
 355         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 356                                                    &quot;--patch&quot;,
 357                                                    &quot;--find-renames=50%&quot;,
 358                                                    &quot;--find-copies=50%&quot;,
 359                                                    &quot;--find-copies-harder&quot;,
 360                                                    &quot;--abbrev&quot;,
 361                                                    ref + &quot;...&quot; + hash.hex());
 362         if (dir != null) {
 363             pb.directory(dir.toFile());
 364         }
 365         pb.inheritIO();
 366         await(pb.start());
 367     }
 368 
 369     private static void gimport() throws IOException {
 370         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 371         pb.inheritIO();
 372         await(pb.start());
 373     }
 374 
 375     private static void hgImport(Path patch) throws IOException {
 376         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 377         pb.inheritIO();
 378         await(pb.start());
 379     }
 380 
 381     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 382         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 383         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 384         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 385         var p = pb.start();
 386         var bytes = p.getInputStream().readAllBytes();
 387         var exited = p.waitFor(1, TimeUnit.MINUTES);
 388         var exitValue = p.exitValue();
 389         if (!exited || exitValue != 0) {
 390             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 391         }
 392 
 393         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 394     }
 395 
 396     private static String hgResolve(String ref) throws IOException, InterruptedException {
 397         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 398         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 399         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 400         var p = pb.start();
 401         var bytes = p.getInputStream().readAllBytes();
 402         var exited = p.waitFor(1, TimeUnit.MINUTES);
 403         var exitValue = p.exitValue();
 404         if (!exited || exitValue != 0) {
 405             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 406         }
 407 
 408         return new String(bytes, StandardCharsets.UTF_8);
 409     }
 410 
 411     private static Path diff(String ref, Hash hash) throws IOException {
 412         return diff(ref, hash, null);
 413     }
 414 
 415     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 416         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 417         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 418                                                    &quot;--patch&quot;,
 419                                                    &quot;--find-renames=50%&quot;,
 420                                                    &quot;--find-copies=50%&quot;,
 421                                                    &quot;--find-copies-harder&quot;,
 422                                                    &quot;--abbrev&quot;,
 423                                                    ref + &quot;...&quot; + hash.hex());
 424         if (dir != null) {
 425             pb.directory(dir.toFile());
 426         }
 427         pb.redirectOutput(patch.toFile());
 428         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 429         await(pb.start());
 430         return patch;
 431     }
 432 
 433     private static void apply(Path patch) throws IOException {
 434         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 435         pb.inheritIO();
 436         await(pb.start());
 437     }
 438 
 439     private static int longest(List&lt;String&gt; strings) {
 440         return strings.stream().mapToInt(String::length).max().orElse(0);
 441     }
 442 
 443     public static void main(String[] args) throws IOException, InterruptedException {
 444         var flags = List.of(
 445             Option.shortcut(&quot;u&quot;)
 446                   .fullname(&quot;username&quot;)
 447                   .describe(&quot;NAME&quot;)
 448                   .helptext(&quot;Username on host&quot;)
 449                   .optional(),
 450             Option.shortcut(&quot;r&quot;)
 451                   .fullname(&quot;remote&quot;)
 452                   .describe(&quot;NAME&quot;)
 453                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 454                   .optional(),
 455             Option.shortcut(&quot;b&quot;)
 456                   .fullname(&quot;branch&quot;)
 457                   .describe(&quot;NAME&quot;)
 458                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 459                   .optional(),
 460             Option.shortcut(&quot;&quot;)
 461                   .fullname(&quot;authors&quot;)
 462                   .describe(&quot;LIST&quot;)
 463                   .helptext(&quot;Comma separated list of authors&quot;)
 464                   .optional(),
 465             Option.shortcut(&quot;&quot;)
 466                   .fullname(&quot;assignees&quot;)
 467                   .describe(&quot;LIST&quot;)
 468                   .helptext(&quot;Comma separated list of assignees&quot;)
 469                   .optional(),
 470             Option.shortcut(&quot;&quot;)
 471                   .fullname(&quot;labels&quot;)
 472                   .describe(&quot;LIST&quot;)
 473                   .helptext(&quot;Comma separated list of labels&quot;)
 474                   .optional(),
 475             Option.shortcut(&quot;&quot;)
 476                   .fullname(&quot;issues&quot;)
 477                   .describe(&quot;LIST&quot;)
 478                   .helptext(&quot;Comma separated list of issues&quot;)
 479                   .optional(),
 480             Option.shortcut(&quot;&quot;)
 481                   .fullname(&quot;columns&quot;)
 482                   .describe(&quot;id,title,author,assignees,labels&quot;)
 483                   .helptext(&quot;Comma separated list of columns to show&quot;)
 484                   .optional(),
 485             Switch.shortcut(&quot;&quot;)
 486                   .fullname(&quot;no-decoration&quot;)
 487                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 488                   .optional(),
 489             Switch.shortcut(&quot;&quot;)
 490                   .fullname(&quot;ignore-workspace&quot;)
 491                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 492                   .optional(),
 493             Switch.shortcut(&quot;&quot;)
 494                   .fullname(&quot;ignore-local-commits&quot;)
 495                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 496                   .optional(),
 497             Switch.shortcut(&quot;&quot;)
 498                   .fullname(&quot;publish&quot;)
 499                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 500                   .optional(),
 501             Switch.shortcut(&quot;&quot;)
 502                   .fullname(&quot;jcheck&quot;)
 503                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 504                   .optional(),
 505             Switch.shortcut(&quot;&quot;)
 506                   .fullname(&quot;no-token&quot;)
 507                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 508                   .optional(),
 509             Switch.shortcut(&quot;&quot;)
 510                   .fullname(&quot;no-checks&quot;)
 511                   .helptext(&quot;Do not show check status as part of the &#39;git pr status&#39; output&quot;)
 512                   .optional(),
 513             Switch.shortcut(&quot;&quot;)
 514                   .fullname(&quot;mercurial&quot;)
 515                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 516                   .optional(),
 517             Switch.shortcut(&quot;&quot;)
 518                   .fullname(&quot;verbose&quot;)
 519                   .helptext(&quot;Turn on verbose output&quot;)
 520                   .optional(),
 521             Switch.shortcut(&quot;&quot;)
 522                   .fullname(&quot;debug&quot;)
 523                   .helptext(&quot;Turn on debugging output&quot;)
 524                   .optional(),
 525             Switch.shortcut(&quot;&quot;)
 526                   .fullname(&quot;version&quot;)
 527                   .helptext(&quot;Print the version of this tool&quot;)
 528                   .optional());
 529 
 530         var inputs = List.of(
 531             Input.position(0)
 532                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
 533                  .singular()
 534                  .optional(),
 535             Input.position(1)
 536                  .describe(&quot;ID&quot;)
 537                  .singular()
 538                  .optional()
 539         );
 540 
 541         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 542         var arguments = parser.parse(args);
 543 
 544         if (arguments.contains(&quot;version&quot;)) {
 545             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 546             System.exit(0);
 547         }
 548 
 549         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 550             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 551             Logging.setup(level);
 552         }
 553 
 554         HttpProxy.setup();
 555 
 556         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 557         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 558         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 559         var remote = getOption(&quot;remote&quot;, arguments);
 560         if (remote == null) {
 561             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 562         }
 563         var remotePullPath = repo.pullPath(remote);
 564         var username = getOption(&quot;username&quot;, arguments);
 565         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 566         var uri = Remote.toWebURI(remotePullPath);
 567         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 568         var credentials = !shouldUseToken ?
 569             null :
 570             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 571         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 572         var forge = credentials == null ?
 573             Forge.from(forgeURI) :
 574             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 575         if (forge.isEmpty()) {
 576             if (!shouldUseToken) {
 577                 if (arguments.contains(&quot;verbose&quot;)) {
 578                     System.err.println(&quot;&quot;);
 579                 }
 580                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 581                 if (!arguments.contains(&quot;verbose&quot;)) {
 582                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 583                     System.err.println(&quot;&quot;);
 584                 }
 585             }
 586             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 587         }
 588         var host = forge.get();
 589 
 590         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 591         if (action == null) {
 592             var lines = repo.config(&quot;pr.default&quot;);
 593             if (lines.size() == 1) {
 594                 action = lines.get(0);
 595             }
 596         }
 597 
 598         if (!shouldUseToken &amp;&amp;
 599             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 600             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 601             System.exit(1);
 602         }
 603 
 604         if (action.equals(&quot;create&quot;)) {
 605             if (isMercurial) {
 606                 var currentBookmark = repo.currentBookmark();
 607                 if (!currentBookmark.isPresent()) {
 608                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 609                     System.err.println(&quot;&quot;);
 610                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 611                     System.err.println(&quot;&quot;);
 612                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 613                     System.err.println(&quot;&quot;);
 614                     System.exit(1);
 615                 }
 616 
 617                 var bookmark = currentBookmark.get();
 618                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 619                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 620                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 621                     System.err.println(&quot;&quot;);
 622                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 623                     System.err.println(&quot;&quot;);
 624                     System.exit(1);
 625                 }
 626 
 627                 var tags = hgTags();
 628                 var upstreams = tags.stream()
 629                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 630                                     .collect(Collectors.toList());
 631                 if (upstreams.isEmpty()) {
 632                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 633                     System.err.println(&quot;&quot;);
 634                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 635                     System.err.println(&quot;&quot;);
 636                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 637                     System.err.println(&quot;&quot;);
 638                     System.exit(1);
 639                 }
 640 
 641                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 642                 for (var tag : tags) {
 643                     tagsAndHashes.put(tag, hgResolve(tag));
 644                 }
 645                 var bookmarkHash = hgResolve(bookmark.name());
 646                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 647                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 648                     System.err.println(&quot;&quot;);
 649 
 650                     if (upstreams.size() == 1) {
 651                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 652                         System.err.println(&quot;&quot;);
 653                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 654                         System.err.println(&quot;&quot;);
 655                     } else {
 656                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 657                         System.err.println(&quot;&quot;);
 658                         for (var upstream : upstreams) {
 659                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 660                         }
 661                         System.err.println(&quot;&quot;);
 662                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 663                         System.err.println(&quot;&quot;);
 664                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 665                         System.err.println(&quot;&quot;);
 666                     }
 667                     System.exit(1);
 668                 }
 669 
 670                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 671                 var targetHash = hgResolve(targetBranch);
 672                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 673                 if (commits.isEmpty()) {
 674                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 675                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 676                     System.exit(1);
 677                 }
 678 
 679                 var diff = repo.diff(repo.head());
 680                 if (!diff.patches().isEmpty()) {
 681                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 682                     System.err.println(&quot;&quot;);
 683                     for (var patch : diff.patches()) {
 684                         var path = patch.target().path().isPresent() ?
 685                             patch.target().path().get() : patch.source().path().get();
 686                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 687                     }
 688                     System.err.println(&quot;&quot;);
 689                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 690                     System.err.println(&quot;&quot;);
 691                     System.err.println(&quot;    hg commit --amend&quot;);
 692                     System.err.println(&quot;    hg git-cleanup&quot;);
 693                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 694                     System.err.println(&quot;    hg gimport&quot;);
 695                     System.err.println(&quot;&quot;);
 696                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 697                     System.err.println(&quot;&quot;);
 698                     System.err.println(&quot;    hg shelve&quot;);
 699                     System.err.println(&quot;&quot;);
 700                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 701                     System.exit(1);
 702                 }
 703 
 704                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 705                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 706                 );
 707                 if (token == null) {
 708                     GitCredentials.approve(credentials);
 709                 }
 710                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 711                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 712 
 713                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 714                 if (commits.size() == 1) {
 715                     var commit = commits.get(0);
 716                     var message = CommitMessageParsers.v1.parse(commit.message());
 717                     Files.writeString(file, message.title() + &quot;\n&quot;);
 718                     if (!message.summaries().isEmpty()) {
 719                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 720                     }
 721                     if (!message.additional().isEmpty()) {
 722                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 723                     }
 724                 } else {
 725                     Files.write(file, List.of(&quot;&quot;));
 726                 }
 727                 Files.write(file, List.of(
 728                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 729                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 730                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 731                     &quot;# the subject from the body.&quot;,
 732                     &quot;#&quot;,
 733                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 734                     ),
 735                     StandardOpenOption.APPEND
 736                 );
 737                 for (var commit : commits) {
 738                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 739                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 740                 }
 741                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 742                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 743                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 744                 var success = spawnEditor(repo, file);
 745                 if (!success) {
 746                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 747                     System.exit(1);
 748                 }
 749                 var lines = Files.readAllLines(file)
 750                                  .stream()
 751                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 752                                  .collect(Collectors.toList());
 753                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 754                 if (isEmpty) {
 755                     System.err.println(&quot;error: no message present, aborting&quot;);
 756                     System.exit(1);
 757                 }
 758 
 759                 var title = lines.get(0);
 760                 List&lt;String&gt; body = null;
 761                 if (lines.size() &gt; 1) {
 762                     body = lines.subList(1, lines.size())
 763                                 .stream()
 764                                 .dropWhile(String::isEmpty)
 765                                 .collect(Collectors.toList());
 766                 } else {
 767                     body = Collections.emptyList();
 768                 }
 769 
 770                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 771                 if (arguments.contains(&quot;assignees&quot;)) {
 772                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 773                     var assignees = usernames.stream()
 774                                              .map(u -&gt; host.user(u))
 775                                              .collect(Collectors.toList());
 776                     pr.setAssignees(assignees);
 777                 }
 778                 System.out.println(pr.webUrl().toString());
 779                 Files.deleteIfExists(file);
 780 
 781                 System.exit(0);
 782             }
 783             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 784                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 785                     System.exit(1);
 786                     return null;
 787             });
 788             if (currentBranch.equals(repo.defaultBranch())) {
 789                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 790                 System.err.println(&quot;&quot;);
 791                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 792                 System.err.println(&quot;&quot;);
 793                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 794                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 795                 System.err.println(&quot;&quot;);
 796                 System.exit(1);
 797             }
 798 
 799             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 800             if (!ignoreWorkspace) {
 801                 var diff = repo.diff(repo.head());
 802                 if (!diff.patches().isEmpty()) {
 803                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 804                     System.err.println(&quot;&quot;);
 805                     for (var patch : diff.patches()) {
 806                         var path = patch.target().path().isPresent() ?
 807                             patch.target().path().get() : patch.source().path().get();
 808                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 809                     }
 810                     System.err.println(&quot;&quot;);
 811                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 812                     System.err.println(&quot;&quot;);
 813                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 814                     System.err.println(&quot;&quot;);
 815                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 816                     System.err.println(&quot;&quot;);
 817                     System.err.println(&quot;    git stash&quot;);
 818                     System.err.println(&quot;&quot;);
 819                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 820                     System.exit(1);
 821                 }
 822             }
 823 
 824             var upstream = repo.upstreamFor(currentBranch);
 825             if (upstream.isEmpty()) {
 826                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 827                 if (shouldPublish) {
 828                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 829                     upstream = repo.upstreamFor(currentBranch);
 830                 } else {
 831                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 832                     System.err.println(&quot;&quot;);
 833                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 834                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 835                     System.err.println(&quot;&quot;);
 836                     System.err.println(&quot;    git publish&quot;);
 837                     System.err.println(&quot;&quot;);
 838                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 839                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 840                     System.err.println(&quot;&quot;);
 841                     System.err.println(&quot;    git fetch &quot; + remote);
 842                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 843                     System.err.println(&quot;&quot;);
 844                     System.exit(1);
 845                 }
 846             }
 847 
 848             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 849             repo.fetch(uri, upstreamRefName);
 850 
 851             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 852             if (!shouldIgnoreLocalCommits) {
 853                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 854                 if (!branchCommits.isEmpty()) {
 855                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 856                     System.err.println(&quot;&quot;);
 857                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 858                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 859                     System.err.println(&quot;&quot;);
 860                     for (var commit : branchCommits) {
 861                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 862                     }
 863                     System.err.println(&quot;&quot;);
 864                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 865                     System.err.println(&quot;&quot;);
 866                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 867                     System.err.println(&quot;&quot;);
 868                     System.exit(1);
 869                 }
 870             }
 871 
 872             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 873             if (targetBranch == null) {
 874                 targetBranch = &quot;master&quot;;
 875             }
 876             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 877             if (commits.isEmpty()) {
 878                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 879                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 880                 System.exit(1);
 881             }
 882 
 883             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 884             if (shouldRunJCheck) {
 885                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 886                 var err = GitJCheck.run(jcheckArgs);
 887                 if (err != 0) {
 888                     System.exit(err);
 889                 }
 890             }
 891 
 892             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 893                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 894             );
 895             if (token == null) {
 896                 GitCredentials.approve(credentials);
 897             }
 898             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 899                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 900 
 901             var project = jbsProjectFromJcheckConf(repo);
 902             var issue = getIssue(currentBranch, project);
 903             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 904             if (issue.isPresent()) {
 905                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 906             } else if (commits.size() == 1) {
 907                 var commit = commits.get(0);
 908                 issue = getIssue(commit, project);
 909                 if (issue.isPresent()) {
 910                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 911                 } else {
 912                     var message = CommitMessageParsers.v1.parse(commit.message());
 913                     Files.writeString(file, message.title() + &quot;\n&quot;);
 914                     if (!message.summaries().isEmpty()) {
 915                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 916                     }
 917                     if (!message.additional().isEmpty()) {
 918                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 919                     }
 920                 }
 921             } else {
 922                 Files.write(file, List.of(&quot;&quot;));
 923             }
 924 
 925             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 926             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 927             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 928             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 929             appendPaddedHTMLComment(file, &quot;&quot;);
 930             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 931             for (var commit : commits) {
 932                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 933                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 934                 if (!commit.isMerge()) {
 935                     var diff = commit.parentDiffs().get(0);
 936                     for (var patch : diff.patches()) {
 937                         var status = patch.status();
 938                         if (status.isModified()) {
 939                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 940                         } else if (status.isAdded()) {
 941                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 942                         } else if (status.isDeleted()) {
 943                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 944                         } else if (status.isRenamed()) {
 945                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 946                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 947                         } else if (status.isCopied()) {
 948                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 949                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 950                         }
 951                     }
 952                 }
 953             }
 954             appendPaddedHTMLComment(file, &quot;&quot;);
 955             if (issue.isPresent()) {
 956                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 957             }
 958             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 959             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 960 
 961             var success = spawnEditor(repo, file);
 962             if (!success) {
 963                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 964                 System.exit(1);
 965             }
 966             var lines = Files.readAllLines(file)
 967                              .stream()
 968                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 969                              .collect(Collectors.toList());
 970             var isEmpty = lines.stream().allMatch(String::isEmpty);
 971             if (isEmpty) {
 972                 System.err.println(&quot;error: no message present, aborting&quot;);
 973                 System.exit(1);
 974             }
 975 
 976             var title = lines.get(0);
 977             List&lt;String&gt; body = null;
 978             if (lines.size() &gt; 1) {
 979                 body = lines.subList(1, lines.size())
 980                             .stream()
 981                             .dropWhile(String::isEmpty)
 982                             .collect(Collectors.toList());
 983             } else {
 984                 body = Collections.emptyList();
 985             }
 986 
 987             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 988             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
 989             if (assigneesOption != null) {
 990                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
 991                 var assignees = usernames.stream()
 992                                          .map(u -&gt; host.user(u))
 993                                          .collect(Collectors.toList());
 994                 pr.setAssignees(assignees);
 995             }
 996             System.out.println(pr.webUrl().toString());
 997             Files.deleteIfExists(file);
 998 
 999             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
1000         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;test&quot;)) {
1001             var id = pullRequestIdArgument(arguments, repo);
1002             var pr = getPullRequest(uri, repo, host, id);
1003 
1004             if (action.equals(&quot;integrate&quot;)) {
1005                 pr.addComment(&quot;/integrate&quot;);
1006             } else if (action.equals(&quot;test&quot;)) {
1007                 pr.addComment(&quot;/test&quot;);
1008             } else {
1009                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
1010             }
1011         } else if (action.equals(&quot;approve&quot;)) {
1012             var id = arguments.at(1).isPresent() ? arguments.at(1).asString() : null;
1013             if (id == null) {
1014                 exit(&quot;error: you must provide a pull request id&quot;);
1015             }
1016             var pr = getPullRequest(uri, repo, host, id);
1017             pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
1018         } else if (action.equals(&quot;list&quot;)) {
1019             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1020             var prs = remoteRepo.pullRequests();
1021             var ids = new ArrayList&lt;String&gt;();
1022             var titles = new ArrayList&lt;String&gt;();
1023             var authors = new ArrayList&lt;String&gt;();
1024             var assignees = new ArrayList&lt;String&gt;();
1025             var labels = new ArrayList&lt;String&gt;();
1026             var issues = new ArrayList&lt;String&gt;();
1027             var branches = new ArrayList&lt;String&gt;();
1028             var statuses = new ArrayList&lt;String&gt;();
1029 
1030             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
1031             var filterAuthors = authorsOption == null ?
1032                 Set.of() :
1033                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
1034 
1035             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
1036             var filterAssignees = assigneesOption == null ?
1037                 Set.of() :
1038                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
1039 
1040             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
1041             var filterLabels = labelsOption == null ?
1042                 Set.of() :
1043                 Arrays.asList(labelsOption.split(&quot;,&quot;));
1044 
1045             var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
1046             var filterIssues = issuesOption == null ?
1047                 Set.of() :
1048                 Arrays.asList(issuesOption.split(&quot;,&quot;));
1049 
1050             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;, &quot;status&quot;);
1051             var columnValues = Map.of(defaultColumns.get(0), ids,
1052                                       defaultColumns.get(1), titles,
1053                                       defaultColumns.get(2), authors,
1054                                       defaultColumns.get(3), assignees,
1055                                       defaultColumns.get(4), labels,
1056                                       defaultColumns.get(5), issues,
1057                                       defaultColumns.get(6), branches,
1058                                       defaultColumns.get(7), statuses);
1059             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1060             var columns = columnsOption == null ?
1061                 defaultColumns :
1062                 Arrays.asList(columnsOption.split(&quot;,&quot;));
1063             if (columns != defaultColumns) {
1064                 for (var column : columns) {
1065                     if (!defaultColumns.contains(column)) {
1066                         System.err.println(&quot;error: unknown column: &quot; + column);
1067                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
1068                         System.exit(1);
1069                     }
1070                 }
1071             }
1072 
1073             for (var pr : prs) {
1074                 var prAuthor = pr.author().userName();
1075                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1076                     continue;
1077                 }
1078 
1079                 var prAssignees = pr.assignees().stream()
1080                                     .map(HostUser::userName)
1081                                     .collect(Collectors.toSet());
1082                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1083                     continue;
1084                 }
1085 
1086                 var prLabels = new HashSet&lt;&gt;(pr.labels());
1087                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1088                     continue;
1089                 }
1090 
1091                 var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1092                 if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1093                     continue;
1094                 }
1095 
1096 
1097                 ids.add(pr.id());
1098                 titles.add(pr.title());
1099                 authors.add(prAuthor);
1100                 assignees.add(String.join(&quot;,&quot;, prAssignees));
1101                 labels.add(String.join(&quot;,&quot;, prLabels));
1102                 issues.add(String.join(&quot;,&quot;, prIssues));
1103 
1104                 if (pr.author().userName().equals(credentials.username()) &amp;&amp;
1105                     pr.sourceRepository().webUrl().equals(uri)) {
1106                     branches.add(pr.sourceRef());
1107                 } else {
1108                     branches.add(&quot;&quot;);
1109                 }
1110 
1111                 if (columns.contains(&quot;status&quot;)) {
1112                     statuses.add(statusForPullRequest(pr).toLowerCase());
1113                 } else {
1114                     statuses.add(&quot;&quot;);
1115                 }
1116             }
1117 
1118 
1119             String fmt = &quot;&quot;;
1120             for (var column : columns.subList(0, columns.size() - 1)) {
1121                 var values = columnValues.get(column);
1122                 var n = Math.max(column.length(), longest(values));
1123                 fmt += &quot;%-&quot; + n + &quot;s    &quot;;
1124             }
1125             fmt += &quot;%s\n&quot;;
1126 
1127             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1128             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1129                 var upperCase = columns.stream()
1130                                        .map(String::toUpperCase)
1131                                        .collect(Collectors.toList());
1132                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1133             }
1134             for (var i = 0; i &lt; ids.size(); i++) {
1135                 final int n = i;
1136                 var row = columns.stream()
1137                                  .map(columnValues::get)
1138                                  .map(values -&gt; values.get(n))
1139                                  .collect(Collectors.toList());
1140                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1141             }
1142         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1143             var prId = arguments.at(1);
1144             if (!prId.isPresent()) {
1145                 exit(&quot;error: missing pull request identifier&quot;);
1146             }
1147 
1148             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1149             var pr = remoteRepo.pullRequest(prId.asString());
1150             var repoUrl = remoteRepo.webUrl();
1151             var prHeadRef = pr.fetchRef();
1152             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1153             if (isHgGit) {
1154                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1155                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1156 
1157                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1158                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1159                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1160 
1161                     if (action.equals(&quot;show&quot;)) {
1162                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1163                     } else {
1164                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1165                         hgImport(patch);
1166                         Files.delete(patch);
1167                     }
1168                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1169                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1170                     var hgGitBranches = hgGitRepo.branches();
1171                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1172                         hgGitRepo.delete(new Branch(hgGitRef));
1173                     }
1174                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1175                     gimport();
1176                     var hgFetchHead = repo.resolve(hgGitRef).get();
1177 
1178                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1179                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1180                     } else if (action.equals(&quot;checkout&quot;)) {
1181                         repo.checkout(hgFetchHead);
1182                         if (arguments.contains(&quot;branch&quot;)) {
1183                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1184                         }
1185                     }
1186                 } else {
1187                     exit(&quot;Unexpected action: &quot; + action);
1188                 }
1189 
1190                 return;
1191             }
1192 
1193             var fetchHead = repo.fetch(repoUrl, pr.fetchRef());
1194             if (action.equals(&quot;fetch&quot;)) {
1195                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1196                 if (branchName != null) {
1197                     repo.branch(fetchHead, branchName);
1198                 } else {
1199                     System.out.println(fetchHead.hex());
1200                 }
1201             } else if (action.equals(&quot;checkout&quot;)) {
1202                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1203                 if (branchName != null) {
1204                     var branch = repo.branch(fetchHead, branchName);
1205                     repo.checkout(branch, false);
1206                 } else {
1207                     repo.checkout(fetchHead, false);
1208                 }
1209             } else if (action.equals(&quot;show&quot;)) {
1210                 show(pr.targetRef(), fetchHead);
1211             } else if (action.equals(&quot;apply&quot;)) {
1212                 var patch = diff(pr.targetRef(), fetchHead);
1213                 apply(patch);
1214                 Files.deleteIfExists(patch);
1215             }
1216         } else if (action.equals(&quot;close&quot;)) {
1217             var prId = arguments.at(1);
1218             if (!prId.isPresent()) {
1219                 exit(&quot;error: missing pull request identifier&quot;);
1220             }
1221 
1222             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1223             var pr = remoteRepo.pullRequest(prId.asString());
1224             pr.setState(PullRequest.State.CLOSED);
1225         } else if (action.equals(&quot;update&quot;)) {
1226             var prId = arguments.at(1);
1227             if (!prId.isPresent()) {
1228                 exit(&quot;error: missing pull request identifier&quot;);
1229             }
1230 
1231             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1232             var pr = remoteRepo.pullRequest(prId.asString());
1233             var assigneesOption = getOption(&quot;assignees&quot;, &quot;update&quot;, arguments);
1234             if (assigneesOption != null) {
1235                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1236                 var assignees = usernames.stream()
1237                     .map(u -&gt; host.user(u))
1238                     .collect(Collectors.toList());
1239                 pr.setAssignees(assignees);
1240             }
1241         } else if (action.equals(&quot;status&quot;)) {
1242             String id = pullRequestIdArgument(arguments, repo);
1243             var pr = getPullRequest(uri, repo, host, id);
1244             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;status&quot;, arguments);
1245             var decoration = noDecoration ? &quot;&quot; : &quot;Status: &quot;;
1246             System.out.println(decoration + statusForPullRequest(pr));
1247 
1248             var noChecks = getSwitch(&quot;no-checks&quot;, &quot;status&quot;, arguments);
1249             if (!noChecks) {
1250                 var checks = pr.checks(pr.headHash());
1251                 var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
1252                 var submit = Optional.ofNullable(checks.get(&quot;submit&quot;));
1253                 var showChecks = jcheck.isPresent() || submit.isPresent();
1254                 if (showChecks) {
1255                     System.out.println(&quot;Checks:&quot;);
1256                     if (jcheck.isPresent()) {
1257                         System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1258                     }
1259                     if (submit.isPresent()) {
1260                         System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1261                     }
1262                 }
1263             }
1264         } else {
1265             exit(&quot;error: unexpected action: &quot; + action);
1266         }
1267     }
1268 }
    </pre>
  </body>
</html>