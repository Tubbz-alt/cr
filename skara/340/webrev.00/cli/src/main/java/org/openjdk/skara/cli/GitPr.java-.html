<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 
  35 import java.io.IOException;
  36 import java.net.URI;
  37 import java.nio.charset.StandardCharsets;
  38 import java.nio.file.*;
  39 import java.util.*;
  40 import java.util.regex.Pattern;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.function.Supplier;
  43 import java.util.logging.Level;
  44 import java.util.stream.Collectors;
  45 
  46 public class GitPr {
  47     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;
  48     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  49     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  50         Pattern.compile(&quot;^\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  51 
  52     private static void exit(String fmt, Object...args) {
  53         System.err.println(String.format(fmt, args));
  54         System.exit(1);
  55     }
  56 
  57     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  58         return () -&gt; {
  59             exit(fmt, args);
  60             return null;
  61         };
  62     }
  63 
  64     private static String gitConfig(String key) {
  65         try {
  66             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  67             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  68             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  69             var p = pb.start();
  70 
  71             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  72             var res = p.waitFor();
  73             if (res != 0) {
  74                 return null;
  75             }
  76 
  77             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  78         } catch (InterruptedException e) {
  79             return null;
  80         } catch (IOException e) {
  81             return null;
  82         }
  83     }
  84 
  85     private static String getOption(String name, Arguments arguments) {
  86         return getOption(name, null, arguments);
  87     }
  88 
  89     private static String getOption(String name, String subsection, Arguments arguments) {
  90         if (arguments.contains(name)) {
  91             return arguments.get(name).asString();
  92         }
  93 
  94         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  95             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  96             if (subsectionSpecific != null) {
  97                 return subsectionSpecific;
  98             }
  99         }
 100 
 101         return gitConfig(&quot;fork.&quot; + name);
 102     }
 103 
 104     private static boolean getSwitch(String name, Arguments arguments) {
 105         return getSwitch(name, null, arguments);
 106     }
 107 
 108     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 109         if (arguments.contains(name)) {
 110             return true;
 111         }
 112 
 113         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 114             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 115             if (subsectionSpecific != null) {
 116                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 117             }
 118         }
 119 
 120         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 121         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 122     }
 123 
 124     private static String rightPad(String s, int length) {
 125         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 126     }
 127 
 128     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 129         var end = &quot; --&gt;&quot;;
 130         var pad = 79 - end.length();
 131         var newLine = &quot;\n&quot;;
 132         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 133     }
 134 
 135     private static String format(Issue issue) {
 136         var parts = issue.id().split(&quot;-&quot;);
 137         var id = parts.length == 2 ? parts[1] : issue.id();
 138         return id + &quot;: &quot; + issue.title();
 139     }
 140 
 141     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 142         var issueTitleIndex = -1;
 143         var lines = pr.body().split(&quot;\n&quot;);
 144         for (var i = 0; i &lt; lines.length; i++) {
 145             if (lines[i].startsWith(&quot;## Issue&quot;)) {
 146                 issueTitleIndex = i;
 147                 break;
 148             }
 149         }
 150 
 151         if (issueTitleIndex == -1) {
 152             return List.of();
 153         }
 154 
 155         var issues = new ArrayList&lt;String&gt;();
 156         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 157             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 158             if (m.matches()) {
 159                 issues.add(m.group(1));
 160             } else {
 161                 break;
 162             }
 163         }
 164 
 165         return issues;
 166     }
 167 
 168     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 169         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 170             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 171         ));
 172 
 173         return conf.general().jbs();
 174     }
 175 
 176     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 177         var message = CommitMessageParsers.v1.parse(commit.message());
 178         var issues = message.issues();
 179         if (issues.isEmpty()) {
 180             return getIssue(message.title(), project);
 181         } else if (issues.size() == 1) {
 182             var issue = issues.get(0);
 183             return getIssue(issue.id(), project);
 184         }
 185         return Optional.empty();
 186     }
 187 
 188     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 189         return getIssue(b.name(), project);
 190     }
 191 
 192     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 193         var m = ISSUE_ID_PATTERN.matcher(s);
 194         if (m.matches()) {
 195             var id = m.group(2);
 196             if (project == null) {
 197                 project = m.group(1);
 198             }
 199             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 200             return issueTracker.project(project).issue(id);
 201         }
 202 
 203         return Optional.empty();
 204     }
 205 
 206     private static void await(Process p) throws IOException {
 207         try {
 208             var res = p.waitFor();
 209             if (res != 0) {
 210                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 211             }
 212         } catch (InterruptedException e) {
 213             throw new IOException(e);
 214         }
 215     }
 216 
 217     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 218         String editor = null;
 219         var lines = repo.config(&quot;core.editor&quot;);
 220         if (lines.size() == 1) {
 221             editor = lines.get(0);
 222         }
 223         if (editor == null) {
 224             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 225         }
 226         if (editor == null) {
 227             editor = System.getenv(&quot;EDITOR&quot;);
 228         }
 229         if (editor == null) {
 230             editor = System.getenv(&quot;VISUAL&quot;);
 231         }
 232         if (editor == null) {
 233             editor = &quot;vi&quot;;
 234         }
 235 
 236         var pb = new ProcessBuilder(editor, file.toString());
 237         pb.inheritIO();
 238         var p = pb.start();
 239         try {
 240             return p.waitFor() == 0;
 241         } catch (InterruptedException e) {
 242             throw new IOException(e);
 243         }
 244     }
 245 
 246     private static String projectName(URI uri) {
 247         var name = uri.getPath().toString().substring(1);
 248         if (name.endsWith(&quot;.git&quot;)) {
 249             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 250         }
 251         return name;
 252     }
 253 
 254     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 255         HostedRepository targetRepo = null;
 256 
 257         try {
 258             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 259             targetRepo = host.repository(projectName(upstream)).orElse(null);
 260         } catch (IOException e) {
 261             // do nothing
 262         }
 263 
 264         if (targetRepo == null) {
 265             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 266                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 267             );
 268             var parentRepo = remoteRepo.parent();
 269             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 270         }
 271 
 272         return targetRepo;
 273     }
 274 
 275     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 276         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 277         if (pr == null) {
 278             exit(&quot;error: could not fetch PR information&quot;);
 279         }
 280 
 281         return pr;
 282     }
 283 
 284     private static void show(String ref, Hash hash) throws IOException {
 285         show(ref, hash, null);
 286     }
 287     private static void show(String ref, Hash hash, Path dir) throws IOException {
 288         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 289                                                    &quot;--patch&quot;,
 290                                                    &quot;--find-renames=50%&quot;,
 291                                                    &quot;--find-copies=50%&quot;,
 292                                                    &quot;--find-copies-harder&quot;,
 293                                                    &quot;--abbrev&quot;,
 294                                                    ref + &quot;...&quot; + hash.hex());
 295         if (dir != null) {
 296             pb.directory(dir.toFile());
 297         }
 298         pb.inheritIO();
 299         await(pb.start());
 300     }
 301 
 302     private static void gimport() throws IOException {
 303         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 304         pb.inheritIO();
 305         await(pb.start());
 306     }
 307 
 308     private static void hgImport(Path patch) throws IOException {
 309         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 310         pb.inheritIO();
 311         await(pb.start());
 312     }
 313 
 314     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 315         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 316         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 317         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 318         var p = pb.start();
 319         var bytes = p.getInputStream().readAllBytes();
 320         var exited = p.waitFor(1, TimeUnit.MINUTES);
 321         var exitValue = p.exitValue();
 322         if (!exited || exitValue != 0) {
 323             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 324         }
 325 
 326         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 327     }
 328 
 329     private static String hgResolve(String ref) throws IOException, InterruptedException {
 330         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 331         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 332         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 333         var p = pb.start();
 334         var bytes = p.getInputStream().readAllBytes();
 335         var exited = p.waitFor(1, TimeUnit.MINUTES);
 336         var exitValue = p.exitValue();
 337         if (!exited || exitValue != 0) {
 338             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 339         }
 340 
 341         return new String(bytes, StandardCharsets.UTF_8);
 342     }
 343 
 344     private static Path diff(String ref, Hash hash) throws IOException {
 345         return diff(ref, hash, null);
 346     }
 347 
 348     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 349         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 350         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 351                                                    &quot;--patch&quot;,
 352                                                    &quot;--find-renames=50%&quot;,
 353                                                    &quot;--find-copies=50%&quot;,
 354                                                    &quot;--find-copies-harder&quot;,
 355                                                    &quot;--abbrev&quot;,
 356                                                    ref + &quot;...&quot; + hash.hex());
 357         if (dir != null) {
 358             pb.directory(dir.toFile());
 359         }
 360         pb.redirectOutput(patch.toFile());
 361         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 362         await(pb.start());
 363         return patch;
 364     }
 365 
 366     private static void apply(Path patch) throws IOException {
 367         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 368         pb.inheritIO();
 369         await(pb.start());
 370     }
 371 
 372     private static int longest(List&lt;String&gt; strings) {
 373         return strings.stream().mapToInt(String::length).max().orElse(0);
 374     }
 375 
 376     public static void main(String[] args) throws IOException, InterruptedException {
 377         var flags = List.of(
 378             Option.shortcut(&quot;u&quot;)
 379                   .fullname(&quot;username&quot;)
 380                   .describe(&quot;NAME&quot;)
 381                   .helptext(&quot;Username on host&quot;)
 382                   .optional(),
 383             Option.shortcut(&quot;r&quot;)
 384                   .fullname(&quot;remote&quot;)
 385                   .describe(&quot;NAME&quot;)
 386                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 387                   .optional(),
 388             Option.shortcut(&quot;b&quot;)
 389                   .fullname(&quot;branch&quot;)
 390                   .describe(&quot;NAME&quot;)
 391                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 392                   .optional(),
 393             Option.shortcut(&quot;&quot;)
 394                   .fullname(&quot;authors&quot;)
 395                   .describe(&quot;LIST&quot;)
 396                   .helptext(&quot;Comma separated list of authors&quot;)
 397                   .optional(),
 398             Option.shortcut(&quot;&quot;)
 399                   .fullname(&quot;assignees&quot;)
 400                   .describe(&quot;LIST&quot;)
 401                   .helptext(&quot;Comma separated list of assignees&quot;)
 402                   .optional(),
 403             Option.shortcut(&quot;&quot;)
 404                   .fullname(&quot;labels&quot;)
 405                   .describe(&quot;LIST&quot;)
 406                   .helptext(&quot;Comma separated list of labels&quot;)
 407                   .optional(),
 408             Option.shortcut(&quot;&quot;)
 409                   .fullname(&quot;issues&quot;)
 410                   .describe(&quot;LIST&quot;)
 411                   .helptext(&quot;Comma separated list of issues&quot;)
 412                   .optional(),
 413             Option.shortcut(&quot;&quot;)
 414                   .fullname(&quot;columns&quot;)
 415                   .describe(&quot;id,title,author,assignees,labels&quot;)
 416                   .helptext(&quot;Comma separated list of columns to show&quot;)
 417                   .optional(),
 418             Switch.shortcut(&quot;&quot;)
 419                   .fullname(&quot;no-decoration&quot;)
 420                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 421                   .optional(),
 422             Switch.shortcut(&quot;&quot;)
 423                   .fullname(&quot;ignore-workspace&quot;)
 424                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 425                   .optional(),
 426             Switch.shortcut(&quot;&quot;)
 427                   .fullname(&quot;ignore-local-commits&quot;)
 428                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 429                   .optional(),
 430             Switch.shortcut(&quot;&quot;)
 431                   .fullname(&quot;publish&quot;)
 432                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 433                   .optional(),
 434             Switch.shortcut(&quot;&quot;)
 435                   .fullname(&quot;jcheck&quot;)
 436                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 437                   .optional(),
 438             Switch.shortcut(&quot;&quot;)
 439                   .fullname(&quot;no-token&quot;)
 440                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 441                   .optional(),
 442             Switch.shortcut(&quot;&quot;)
 443                   .fullname(&quot;mercurial&quot;)
 444                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 445                   .optional(),
 446             Switch.shortcut(&quot;&quot;)
 447                   .fullname(&quot;verbose&quot;)
 448                   .helptext(&quot;Turn on verbose output&quot;)
 449                   .optional(),
 450             Switch.shortcut(&quot;&quot;)
 451                   .fullname(&quot;debug&quot;)
 452                   .helptext(&quot;Turn on debugging output&quot;)
 453                   .optional(),
 454             Switch.shortcut(&quot;&quot;)
 455                   .fullname(&quot;version&quot;)
 456                   .helptext(&quot;Print the version of this tool&quot;)
 457                   .optional());
 458 
 459         var inputs = List.of(
 460             Input.position(0)
 461                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
 462                  .singular()
 463                  .optional(),
 464             Input.position(1)
 465                  .describe(&quot;ID&quot;)
 466                  .singular()
 467                  .optional()
 468         );
 469 
 470         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 471         var arguments = parser.parse(args);
 472 
 473         if (arguments.contains(&quot;version&quot;)) {
 474             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 475             System.exit(0);
 476         }
 477 
 478         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 479             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 480             Logging.setup(level);
 481         }
 482 
 483         HttpProxy.setup();
 484 
 485         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 486         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 487         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 488         var remote = getOption(&quot;remote&quot;, arguments);
 489         if (remote == null) {
 490             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 491         }
 492         var remotePullPath = repo.pullPath(remote);
 493         var username = getOption(&quot;username&quot;, arguments);
 494         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 495         var uri = Remote.toWebURI(remotePullPath);
 496         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 497         var credentials = !shouldUseToken ?
 498             null :
 499             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 500         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 501         var forge = credentials == null ?
 502             Forge.from(forgeURI) :
 503             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 504         if (forge.isEmpty()) {
 505             if (!shouldUseToken) {
 506                 if (arguments.contains(&quot;verbose&quot;)) {
 507                     System.err.println(&quot;&quot;);
 508                 }
 509                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 510                 if (!arguments.contains(&quot;verbose&quot;)) {
 511                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 512                     System.err.println(&quot;&quot;);
 513                 }
 514             }
 515             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 516         }
 517         var host = forge.get();
 518 
 519         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 520         if (action == null) {
 521             var lines = repo.config(&quot;pr.default&quot;);
 522             if (lines.size() == 1) {
 523                 action = lines.get(0);
 524             }
 525         }
 526 
 527         if (!shouldUseToken &amp;&amp;
 528             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 529             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 530             System.exit(1);
 531         }
 532 
 533         if (action.equals(&quot;create&quot;)) {
 534             if (isMercurial) {
 535                 var currentBookmark = repo.currentBookmark();
 536                 if (!currentBookmark.isPresent()) {
 537                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 538                     System.err.println(&quot;&quot;);
 539                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 540                     System.err.println(&quot;&quot;);
 541                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 542                     System.err.println(&quot;&quot;);
 543                     System.exit(1);
 544                 }
 545 
 546                 var bookmark = currentBookmark.get();
 547                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 548                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 549                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 550                     System.err.println(&quot;&quot;);
 551                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 552                     System.err.println(&quot;&quot;);
 553                     System.exit(1);
 554                 }
 555 
 556                 var tags = hgTags();
 557                 var upstreams = tags.stream()
 558                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 559                                     .collect(Collectors.toList());
 560                 if (upstreams.isEmpty()) {
 561                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 562                     System.err.println(&quot;&quot;);
 563                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 564                     System.err.println(&quot;&quot;);
 565                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 566                     System.err.println(&quot;&quot;);
 567                     System.exit(1);
 568                 }
 569 
 570                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 571                 for (var tag : tags) {
 572                     tagsAndHashes.put(tag, hgResolve(tag));
 573                 }
 574                 var bookmarkHash = hgResolve(bookmark.name());
 575                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 576                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 577                     System.err.println(&quot;&quot;);
 578 
 579                     if (upstreams.size() == 1) {
 580                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 581                         System.err.println(&quot;&quot;);
 582                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 583                         System.err.println(&quot;&quot;);
 584                     } else {
 585                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 586                         System.err.println(&quot;&quot;);
 587                         for (var upstream : upstreams) {
 588                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 589                         }
 590                         System.err.println(&quot;&quot;);
 591                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 592                         System.err.println(&quot;&quot;);
 593                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 594                         System.err.println(&quot;&quot;);
 595                     }
 596                     System.exit(1);
 597                 }
 598 
 599                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 600                 var targetHash = hgResolve(targetBranch);
 601                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 602                 if (commits.isEmpty()) {
 603                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 604                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 605                     System.exit(1);
 606                 }
 607 
 608                 var diff = repo.diff(repo.head());
 609                 if (!diff.patches().isEmpty()) {
 610                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 611                     System.err.println(&quot;&quot;);
 612                     for (var patch : diff.patches()) {
 613                         var path = patch.target().path().isPresent() ?
 614                             patch.target().path().get() : patch.source().path().get();
 615                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 616                     }
 617                     System.err.println(&quot;&quot;);
 618                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 619                     System.err.println(&quot;&quot;);
 620                     System.err.println(&quot;    hg commit --amend&quot;);
 621                     System.err.println(&quot;    hg git-cleanup&quot;);
 622                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 623                     System.err.println(&quot;    hg gimport&quot;);
 624                     System.err.println(&quot;&quot;);
 625                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 626                     System.err.println(&quot;&quot;);
 627                     System.err.println(&quot;    hg shelve&quot;);
 628                     System.err.println(&quot;&quot;);
 629                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 630                     System.exit(1);
 631                 }
 632 
 633                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 634                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 635                 );
 636                 if (token == null) {
 637                     GitCredentials.approve(credentials);
 638                 }
 639                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 640                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 641 
 642                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 643                 if (commits.size() == 1) {
 644                     var commit = commits.get(0);
 645                     var message = CommitMessageParsers.v1.parse(commit.message());
 646                     Files.writeString(file, message.title() + &quot;\n&quot;);
 647                     if (!message.summaries().isEmpty()) {
 648                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 649                     }
 650                     if (!message.additional().isEmpty()) {
 651                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 652                     }
 653                 } else {
 654                     Files.write(file, List.of(&quot;&quot;));
 655                 }
 656                 Files.write(file, List.of(
 657                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 658                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 659                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 660                     &quot;# the subject from the body.&quot;,
 661                     &quot;#&quot;,
 662                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 663                     ),
 664                     StandardOpenOption.APPEND
 665                 );
 666                 for (var commit : commits) {
 667                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 668                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 669                 }
 670                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 671                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 672                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 673                 var success = spawnEditor(repo, file);
 674                 if (!success) {
 675                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 676                     System.exit(1);
 677                 }
 678                 var lines = Files.readAllLines(file)
 679                                  .stream()
 680                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 681                                  .collect(Collectors.toList());
 682                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 683                 if (isEmpty) {
 684                     System.err.println(&quot;error: no message present, aborting&quot;);
 685                     System.exit(1);
 686                 }
 687 
 688                 var title = lines.get(0);
 689                 List&lt;String&gt; body = null;
 690                 if (lines.size() &gt; 1) {
 691                     body = lines.subList(1, lines.size())
 692                                 .stream()
 693                                 .dropWhile(String::isEmpty)
 694                                 .collect(Collectors.toList());
 695                 } else {
 696                     body = Collections.emptyList();
 697                 }
 698 
 699                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 700                 if (arguments.contains(&quot;assignees&quot;)) {
 701                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 702                     var assignees = usernames.stream()
 703                                              .map(u -&gt; host.user(u))
 704                                              .collect(Collectors.toList());
 705                     pr.setAssignees(assignees);
 706                 }
 707                 System.out.println(pr.webUrl().toString());
 708                 Files.deleteIfExists(file);
 709 
 710                 System.exit(0);
 711             }
 712             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 713                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 714                     System.exit(1);
 715                     return null;
 716             });
 717             if (currentBranch.equals(repo.defaultBranch())) {
 718                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 719                 System.err.println(&quot;&quot;);
 720                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 721                 System.err.println(&quot;&quot;);
 722                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 723                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 724                 System.err.println(&quot;&quot;);
 725                 System.exit(1);
 726             }
 727 
 728             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 729             if (!ignoreWorkspace) {
 730                 var diff = repo.diff(repo.head());
 731                 if (!diff.patches().isEmpty()) {
 732                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 733                     System.err.println(&quot;&quot;);
 734                     for (var patch : diff.patches()) {
 735                         var path = patch.target().path().isPresent() ?
 736                             patch.target().path().get() : patch.source().path().get();
 737                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 738                     }
 739                     System.err.println(&quot;&quot;);
 740                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 741                     System.err.println(&quot;&quot;);
 742                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 743                     System.err.println(&quot;&quot;);
 744                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 745                     System.err.println(&quot;&quot;);
 746                     System.err.println(&quot;    git stash&quot;);
 747                     System.err.println(&quot;&quot;);
 748                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 749                     System.exit(1);
 750                 }
 751             }
 752 
 753             var upstream = repo.upstreamFor(currentBranch);
 754             if (upstream.isEmpty()) {
 755                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 756                 if (shouldPublish) {
 757                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 758                     upstream = repo.upstreamFor(currentBranch);
 759                 } else {
 760                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 761                     System.err.println(&quot;&quot;);
 762                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 763                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 764                     System.err.println(&quot;&quot;);
 765                     System.err.println(&quot;    git publish&quot;);
 766                     System.err.println(&quot;&quot;);
 767                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 768                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 769                     System.err.println(&quot;&quot;);
 770                     System.err.println(&quot;    git fetch &quot; + remote);
 771                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 772                     System.err.println(&quot;&quot;);
 773                     System.exit(1);
 774                 }
 775             }
 776 
 777             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 778             repo.fetch(uri, upstreamRefName);
 779 
 780             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 781             if (!shouldIgnoreLocalCommits) {
 782                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 783                 if (!branchCommits.isEmpty()) {
 784                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 785                     System.err.println(&quot;&quot;);
 786                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 787                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 788                     System.err.println(&quot;&quot;);
 789                     for (var commit : branchCommits) {
 790                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 791                     }
 792                     System.err.println(&quot;&quot;);
 793                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 794                     System.err.println(&quot;&quot;);
 795                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 796                     System.err.println(&quot;&quot;);
 797                     System.exit(1);
 798                 }
 799             }
 800 
 801             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 802             if (targetBranch == null) {
 803                 targetBranch = &quot;master&quot;;
 804             }
 805             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 806             if (commits.isEmpty()) {
 807                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 808                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 809                 System.exit(1);
 810             }
 811 
 812             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 813             if (shouldRunJCheck) {
 814                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 815                 var err = GitJCheck.run(jcheckArgs);
 816                 if (err != 0) {
 817                     System.exit(err);
 818                 }
 819             }
 820 
 821             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 822                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 823             );
 824             if (token == null) {
 825                 GitCredentials.approve(credentials);
 826             }
 827             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 828                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 829 
 830             var project = jbsProjectFromJcheckConf(repo);
 831             var issue = getIssue(currentBranch, project);
 832             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 833             if (issue.isPresent()) {
 834                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 835             } else if (commits.size() == 1) {
 836                 var commit = commits.get(0);
 837                 issue = getIssue(commit, project);
 838                 if (issue.isPresent()) {
 839                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 840                 } else {
 841                     var message = CommitMessageParsers.v1.parse(commit.message());
 842                     Files.writeString(file, message.title() + &quot;\n&quot;);
 843                     if (!message.summaries().isEmpty()) {
 844                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 845                     }
 846                     if (!message.additional().isEmpty()) {
 847                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 848                     }
 849                 }
 850             } else {
 851                 Files.write(file, List.of(&quot;&quot;));
 852             }
 853 
 854             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 855             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 856             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 857             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 858             appendPaddedHTMLComment(file, &quot;&quot;);
 859             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 860             for (var commit : commits) {
 861                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 862                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 863                 if (!commit.isMerge()) {
 864                     var diff = commit.parentDiffs().get(0);
 865                     for (var patch : diff.patches()) {
 866                         var status = patch.status();
 867                         if (status.isModified()) {
 868                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 869                         } else if (status.isAdded()) {
 870                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 871                         } else if (status.isDeleted()) {
 872                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 873                         } else if (status.isRenamed()) {
 874                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 875                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 876                         } else if (status.isCopied()) {
 877                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 878                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 879                         }
 880                     }
 881                 }
 882             }
 883             appendPaddedHTMLComment(file, &quot;&quot;);
 884             if (issue.isPresent()) {
 885                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 886             }
 887             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 888             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 889 
 890             var success = spawnEditor(repo, file);
 891             if (!success) {
 892                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 893                 System.exit(1);
 894             }
 895             var lines = Files.readAllLines(file)
 896                              .stream()
 897                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 898                              .collect(Collectors.toList());
 899             var isEmpty = lines.stream().allMatch(String::isEmpty);
 900             if (isEmpty) {
 901                 System.err.println(&quot;error: no message present, aborting&quot;);
 902                 System.exit(1);
 903             }
 904 
 905             var title = lines.get(0);
 906             List&lt;String&gt; body = null;
 907             if (lines.size() &gt; 1) {
 908                 body = lines.subList(1, lines.size())
 909                             .stream()
 910                             .dropWhile(String::isEmpty)
 911                             .collect(Collectors.toList());
 912             } else {
 913                 body = Collections.emptyList();
 914             }
 915 
 916             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 917             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
 918             if (assigneesOption != null) {
 919                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
 920                 var assignees = usernames.stream()
 921                                          .map(u -&gt; host.user(u))
 922                                          .collect(Collectors.toList());
 923                 pr.setAssignees(assignees);
 924             }
 925             System.out.println(pr.webUrl().toString());
 926             Files.deleteIfExists(file);
 927 
 928             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
 929         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
 930             String id = null;
 931             if (arguments.at(1).isPresent()) {
 932                 id = arguments.at(1).asString();
 933             } else {
 934                 if (action.equals(&quot;approve&quot;)) {
 935                     exit(&quot;error: you must provide a pull request id&quot;);
 936                 } else {
 937                     var currentBranch = repo.currentBranch();
 938                     if (currentBranch.isPresent()) {
 939                         var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 940                         if (lines.size() == 1) {
 941                             id = lines.get(0);
 942                         } else {
 943                             exit(&quot;error: you must provide a pull request id&quot;);
 944                         }
 945                     }
 946                 }
 947             }
 948 
 949             var pr = getPullRequest(uri, repo, host, id);
 950 
 951             if (action.equals(&quot;integrate&quot;)) {
 952                 pr.addComment(&quot;/integrate&quot;);
 953             } else if (action.equals(&quot;test&quot;)) {
 954                 pr.addComment(&quot;/test&quot;);
 955             } else if (action.equals(&quot;approve&quot;)) {
 956                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
 957             } else {
 958                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
 959             }
 960         } else if (action.equals(&quot;list&quot;)) {
 961             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 962             var prs = remoteRepo.pullRequests();
 963             var ids = new ArrayList&lt;String&gt;();
 964             var titles = new ArrayList&lt;String&gt;();
 965             var authors = new ArrayList&lt;String&gt;();
 966             var assignees = new ArrayList&lt;String&gt;();
 967             var labels = new ArrayList&lt;String&gt;();
 968             var issues = new ArrayList&lt;String&gt;();
 969             var branches = new ArrayList&lt;String&gt;();
 970 
 971             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
 972             var filterAuthors = authorsOption == null ?
 973                 Set.of() :
 974                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
 975 
 976             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
 977             var filterAssignees = assigneesOption == null ?
 978                 Set.of() :
 979                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
 980 
 981             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
 982             var filterLabels = labelsOption == null ?
 983                 Set.of() :
 984                 Arrays.asList(labelsOption.split(&quot;,&quot;));
 985 
 986             var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
 987             var filterIssues = issuesOption == null ?
 988                 Set.of() :
 989                 Arrays.asList(issuesOption.split(&quot;,&quot;));
 990 
 991             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;);
 992             var columnValues = Map.of(defaultColumns.get(0), ids,
 993                                       defaultColumns.get(1), titles,
 994                                       defaultColumns.get(2), authors,
 995                                       defaultColumns.get(3), assignees,
 996                                       defaultColumns.get(4), labels,
 997                                       defaultColumns.get(5), issues,
 998                                       defaultColumns.get(6), branches);
 999             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1000             var columns = columnsOption == null ?
1001                 defaultColumns :
1002                 Arrays.asList(columnsOption.split(&quot;,&quot;));
1003             if (columns != defaultColumns) {
1004                 for (var column : columns) {
1005                     if (!defaultColumns.contains(column)) {
1006                         System.err.println(&quot;error: unknown column: &quot; + column);
1007                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
1008                         System.exit(1);
1009                     }
1010                 }
1011             }
1012 
1013             for (var pr : prs) {
1014                 var prAuthor = pr.author().userName();
1015                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1016                     continue;
1017                 }
1018 
1019                 var prAssignees = pr.assignees().stream()
1020                                     .map(HostUser::userName)
1021                                     .collect(Collectors.toSet());
1022                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1023                     continue;
1024                 }
1025 
1026                 var prLabels = new HashSet&lt;&gt;(pr.labels());
1027                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1028                     continue;
1029                 }
1030 
1031                 var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1032                 if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1033                     continue;
1034                 }
1035 
1036 
1037                 ids.add(pr.id());
1038                 titles.add(pr.title());
1039                 authors.add(prAuthor);
1040                 assignees.add(String.join(&quot;,&quot;, prAssignees));
1041                 labels.add(String.join(&quot;,&quot;, prLabels));
1042                 issues.add(String.join(&quot;,&quot;, prIssues));
1043 
1044                 if (pr.author().userName().equals(credentials.username()) &amp;&amp;
1045                     pr.sourceRepository().webUrl().equals(uri)) {
1046                     branches.add(pr.sourceRef());
1047                 } else {
1048                     branches.add(&quot;&quot;);
1049                 }
1050             }
1051 
1052 
1053             String fmt = &quot;&quot;;
1054             for (var column : columns.subList(0, columns.size() - 1)) {
1055                 var values = columnValues.get(column);
1056                 var n = Math.max(column.length(), longest(values));
1057                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
1058             }
1059             fmt += &quot;%s\n&quot;;
1060 
1061             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1062             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1063                 var upperCase = columns.stream()
1064                                        .map(String::toUpperCase)
1065                                        .collect(Collectors.toList());
1066                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1067             }
1068             for (var i = 0; i &lt; ids.size(); i++) {
1069                 final int n = i;
1070                 var row = columns.stream()
1071                                  .map(columnValues::get)
1072                                  .map(values -&gt; values.get(n))
1073                                  .collect(Collectors.toList());
1074                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1075             }
1076         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1077             var prId = arguments.at(1);
1078             if (!prId.isPresent()) {
1079                 exit(&quot;error: missing pull request identifier&quot;);
1080             }
1081 
1082             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1083             var pr = remoteRepo.pullRequest(prId.asString());
1084             var repoUrl = remoteRepo.webUrl();
1085             var prHeadRef = pr.fetchRef();
1086             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1087             if (isHgGit) {
1088                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1089                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1090 
1091                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1092                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1093                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1094 
1095                     if (action.equals(&quot;show&quot;)) {
1096                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1097                     } else {
1098                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1099                         hgImport(patch);
1100                         Files.delete(patch);
1101                     }
1102                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1103                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1104                     var hgGitBranches = hgGitRepo.branches();
1105                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1106                         hgGitRepo.delete(new Branch(hgGitRef));
1107                     }
1108                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1109                     gimport();
1110                     var hgFetchHead = repo.resolve(hgGitRef).get();
1111 
1112                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1113                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1114                     } else if (action.equals(&quot;checkout&quot;)) {
1115                         repo.checkout(hgFetchHead);
1116                         if (arguments.contains(&quot;branch&quot;)) {
1117                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1118                         }
1119                     }
1120                 } else {
1121                     exit(&quot;Unexpected action: &quot; + action);
1122                 }
1123 
1124                 return;
1125             }
1126 
1127             var fetchHead = repo.fetch(repoUrl, pr.fetchRef());
1128             if (action.equals(&quot;fetch&quot;)) {
1129                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1130                 if (branchName != null) {
1131                     repo.branch(fetchHead, branchName);
1132                 } else {
1133                     System.out.println(fetchHead.hex());
1134                 }
1135             } else if (action.equals(&quot;checkout&quot;)) {
1136                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1137                 if (branchName != null) {
1138                     var branch = repo.branch(fetchHead, branchName);
1139                     repo.checkout(branch, false);
1140                 } else {
1141                     repo.checkout(fetchHead, false);
1142                 }
1143             } else if (action.equals(&quot;show&quot;)) {
1144                 show(pr.targetRef(), fetchHead);
1145             } else if (action.equals(&quot;apply&quot;)) {
1146                 var patch = diff(pr.targetRef(), fetchHead);
1147                 apply(patch);
1148                 Files.deleteIfExists(patch);
1149             }
1150         } else if (action.equals(&quot;close&quot;)) {
1151             var prId = arguments.at(1);
1152             if (!prId.isPresent()) {
1153                 exit(&quot;error: missing pull request identifier&quot;);
1154             }
1155 
1156             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1157             var pr = remoteRepo.pullRequest(prId.asString());
1158             pr.setState(PullRequest.State.CLOSED);
1159         } else if (action.equals(&quot;update&quot;)) {
1160             var prId = arguments.at(1);
1161             if (!prId.isPresent()) {
1162                 exit(&quot;error: missing pull request identifier&quot;);
1163             }
1164 
1165             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1166             var pr = remoteRepo.pullRequest(prId.asString());
1167             var assigneesOption = getOption(&quot;assignees&quot;, &quot;update&quot;, arguments);
1168             if (assigneesOption != null) {
1169                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1170                 var assignees = usernames.stream()
1171                     .map(u -&gt; host.user(u))
1172                     .collect(Collectors.toList());
1173                 pr.setAssignees(assignees);
1174             }
1175         } else {
1176             exit(&quot;error: unexpected action: &quot; + action);
1177         }
1178     }
1179 }
    </pre>
  </body>
</html>