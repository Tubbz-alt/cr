<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.issuetracker.IssueTracker;
 29 import org.openjdk.skara.issuetracker.Issue;
 30 import org.openjdk.skara.proxy.HttpProxy;
 31 import org.openjdk.skara.vcs.*;
 32 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 33 
 34 import java.io.IOException;
 35 import java.net.URI;
 36 import java.nio.charset.StandardCharsets;
 37 import java.nio.file.*;
 38 import java.util.*;
 39 import java.util.regex.Pattern;
 40 import java.util.concurrent.TimeUnit;
 41 import java.util.function.Supplier;
 42 import java.util.logging.Level;
 43 import java.util.stream.Collectors;
 44 
 45 public class GitPr {
 46     private static void exit(String fmt, Object...args) {
 47         System.err.println(String.format(fmt, args));
 48         System.exit(1);
 49     }
 50 
 51     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 52         return () -&gt; {
 53             exit(fmt, args);
 54             return null;
 55         };
 56     }
 57 
 58     private static Optional&lt;Issue&gt; getIssue(Branch b) throws IOException {
 59         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)-([0-9]+)&quot;);
 60         var m = issueIdPattern.matcher(b.name());
 61         if (m.matches()) {
 62             var project = m.group(1);
 63             var id = m.group(2);
 64             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 65             return issueTracker.project(project).issue(id);
 66         }
 67         System.out.println(&quot;pattern did not match&quot;);
 68 
 69         return Optional.empty();
 70     }
 71 
 72     private static void await(Process p) throws IOException {
 73         try {
 74             var res = p.waitFor();
 75             if (res != 0) {
 76                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 77             }
 78         } catch (InterruptedException e) {
 79             throw new IOException(e);
 80         }
 81     }
 82 
 83     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 84         String editor = null;
 85         var lines = repo.config(&quot;core.editor&quot;);
 86         if (lines.size() == 1) {
 87             editor = lines.get(0);
 88         }
 89         if (editor == null) {
 90             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 91         }
 92         if (editor == null) {
 93             editor = System.getenv(&quot;EDITOR&quot;);
 94         }
 95         if (editor == null) {
 96             editor = System.getenv(&quot;VISUAL&quot;);
 97         }
 98         if (editor == null) {
 99             editor = &quot;vi&quot;;
100         }
101 
102         var pb = new ProcessBuilder(editor, file.toString());
103         pb.inheritIO();
104         var p = pb.start();
105         try {
106             return p.waitFor() == 0;
107         } catch (InterruptedException e) {
108             throw new IOException(e);
109         }
110     }
111 
112     private static String projectName(URI uri) {
113         var name = uri.getPath().toString().substring(1);
114         if (name.endsWith(&quot;.git&quot;)) {
115             name = name.substring(0, name.length() - &quot;.git&quot;.length());
116         }
117         return name;
118     }
119 
120     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
121         HostedRepository targetRepo = null;
122 
123         try {
124             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
125             targetRepo = host.repository(projectName(upstream)).orElse(null);
126         } catch (IOException e) {
127             // do nothing
128         }
129 
130         if (targetRepo == null) {
131             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
132                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
133             );
134             var parentRepo = remoteRepo.parent();
135             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
136         }
137 
138         return targetRepo;
139     }
140 
141     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
142         if (!prId.isPresent()) {
143             exit(&quot;error: missing pull request identifier&quot;);
144         }
145 
146         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
147         if (pr == null) {
148             exit(&quot;error: could not fetch PR information&quot;);
149         }
150 
151         return pr;
152     }
153 
154     private static void show(String ref, Hash hash) throws IOException {
155         show(ref, hash, null);
156     }
157     private static void show(String ref, Hash hash, Path dir) throws IOException {
158         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
159                                                    &quot;--patch&quot;,
160                                                    &quot;--find-renames=50%&quot;,
161                                                    &quot;--find-copies=50%&quot;,
162                                                    &quot;--find-copies-harder&quot;,
163                                                    &quot;--abbrev&quot;,
164                                                    ref + &quot;...&quot; + hash.hex());
165         if (dir != null) {
166             pb.directory(dir.toFile());
167         }
168         pb.inheritIO();
169         await(pb.start());
170     }
171 
172     private static void gimport() throws IOException {
173         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
174         pb.inheritIO();
175         await(pb.start());
176     }
177 
178     private static void hgImport(Path patch) throws IOException {
179         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
180         pb.inheritIO();
181         await(pb.start());
182     }
183 
184     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
185         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
186         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
187         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
188         var p = pb.start();
189         var bytes = p.getInputStream().readAllBytes();
190         var exited = p.waitFor(1, TimeUnit.MINUTES);
191         var exitValue = p.exitValue();
192         if (!exited || exitValue != 0) {
193             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
194         }
195 
196         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
197     }
198 
199     private static String hgResolve(String ref) throws IOException, InterruptedException {
200         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
201         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
202         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
203         var p = pb.start();
204         var bytes = p.getInputStream().readAllBytes();
205         var exited = p.waitFor(1, TimeUnit.MINUTES);
206         var exitValue = p.exitValue();
207         if (!exited || exitValue != 0) {
208             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
209         }
210 
211         return new String(bytes, StandardCharsets.UTF_8);
212     }
213 
214     private static Path diff(String ref, Hash hash) throws IOException {
215         return diff(ref, hash, null);
216     }
217 
218     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
219         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
220         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
221                                                    &quot;--patch&quot;,
222                                                    &quot;--find-renames=50%&quot;,
223                                                    &quot;--find-copies=50%&quot;,
224                                                    &quot;--find-copies-harder&quot;,
225                                                    &quot;--abbrev&quot;,
226                                                    ref + &quot;...&quot; + hash.hex());
227         if (dir != null) {
228             pb.directory(dir.toFile());
229         }
230         pb.redirectOutput(patch.toFile());
231         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
232         await(pb.start());
233         return patch;
234     }
235 
236     private static void apply(Path patch) throws IOException {
237         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
238         pb.inheritIO();
239         await(pb.start());
240     }
241 
242     private static int longest(List&lt;String&gt; strings) {
243         return strings.stream().mapToInt(String::length).max().orElse(0);
244     }
245 
246     public static void main(String[] args) throws IOException, InterruptedException {
247         var flags = List.of(
248             Option.shortcut(&quot;u&quot;)
249                   .fullname(&quot;username&quot;)
250                   .describe(&quot;NAME&quot;)
251                   .helptext(&quot;Username on host&quot;)
252                   .optional(),
253             Option.shortcut(&quot;r&quot;)
254                   .fullname(&quot;remote&quot;)
255                   .describe(&quot;NAME&quot;)
256                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
257                   .optional(),
258             Option.shortcut(&quot;b&quot;)
259                   .fullname(&quot;branch&quot;)
260                   .describe(&quot;NAME&quot;)
261                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
262                   .optional(),
263             Option.shortcut(&quot;&quot;)
264                   .fullname(&quot;authors&quot;)
265                   .describe(&quot;LIST&quot;)
266                   .helptext(&quot;Comma separated list of authors&quot;)
267                   .optional(),
268             Option.shortcut(&quot;&quot;)
269                   .fullname(&quot;assignees&quot;)
270                   .describe(&quot;LIST&quot;)
271                   .helptext(&quot;Comma separated list of assignees&quot;)
272                   .optional(),
273             Option.shortcut(&quot;&quot;)
274                   .fullname(&quot;labels&quot;)
275                   .describe(&quot;LIST&quot;)
276                   .helptext(&quot;Comma separated list of labels&quot;)
277                   .optional(),
278             Option.shortcut(&quot;&quot;)
279                   .fullname(&quot;columns&quot;)
280                   .describe(&quot;id,title,author,assignees,labels&quot;)
281                   .helptext(&quot;Comma separated list of columns to show&quot;)
282                   .optional(),
283             Switch.shortcut(&quot;&quot;)
284                   .fullname(&quot;no-decoration&quot;)
285                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
286                   .optional(),
287             Switch.shortcut(&quot;&quot;)
288                   .fullname(&quot;no-token&quot;)
289                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
290                   .optional(),
291             Switch.shortcut(&quot;&quot;)
292                   .fullname(&quot;mercurial&quot;)
293                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
294                   .optional(),
295             Switch.shortcut(&quot;&quot;)
296                   .fullname(&quot;verbose&quot;)
297                   .helptext(&quot;Turn on verbose output&quot;)
298                   .optional(),
299             Switch.shortcut(&quot;&quot;)
300                   .fullname(&quot;debug&quot;)
301                   .helptext(&quot;Turn on debugging output&quot;)
302                   .optional(),
303             Switch.shortcut(&quot;&quot;)
304                   .fullname(&quot;version&quot;)
305                   .helptext(&quot;Print the version of this tool&quot;)
306                   .optional());
307 
308         var inputs = List.of(
309             Input.position(0)
310                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
311                  .singular()
312                  .required(),
313             Input.position(1)
314                  .describe(&quot;ID&quot;)
315                  .singular()
316                  .optional()
317         );
318 
319         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
320         var arguments = parser.parse(args);
321 
322         if (arguments.contains(&quot;version&quot;)) {
323             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
324             System.exit(0);
325         }
326 
327         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
328             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
329             Logging.setup(level);
330         }
331 
332         HttpProxy.setup();
333 
334         var isMercurial = arguments.contains(&quot;mercurial&quot;);
335         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
336         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
337         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
338         var remotePullPath = repo.pullPath(remote);
339         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
340         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
341         var uri = Remote.toWebURI(remotePullPath);
342         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
343         var credentials = !shouldUseToken ?
344             null :
345             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
346         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
347         var forge = credentials == null ?
348             Forge.from(forgeURI) :
349             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
350         if (forge.isEmpty()) {
351             if (!shouldUseToken) {
352                 if (arguments.contains(&quot;verbose&quot;)) {
353                     System.err.println(&quot;&quot;);
354                 }
355                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
356                 if (!arguments.contains(&quot;verbose&quot;)) {
357                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
358                     System.err.println(&quot;&quot;);
359                 }
360             }
361             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
362         }
363         var host = forge.get();
364 
365         var action = arguments.at(0).asString();
366         if (!shouldUseToken &amp;&amp;
367             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
368             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
369             System.exit(1);
370         }
371 
372         if (action.equals(&quot;create&quot;)) {
373             if (isMercurial) {
374                 var currentBookmark = repo.currentBookmark();
375                 if (!currentBookmark.isPresent()) {
376                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
377                     System.err.println(&quot;&quot;);
378                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
379                     System.err.println(&quot;&quot;);
380                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
381                     System.err.println(&quot;&quot;);
382                     System.exit(1);
383                 }
384 
385                 var bookmark = currentBookmark.get();
386                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
387                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
388                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
389                     System.err.println(&quot;&quot;);
390                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
391                     System.err.println(&quot;&quot;);
392                     System.exit(1);
393                 }
394 
395                 var tags = hgTags();
396                 var upstreams = tags.stream()
397                                     .filter(t -&gt; t.endsWith(bookmark.name()))
398                                     .collect(Collectors.toList());
399                 if (upstreams.isEmpty()) {
400                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
401                     System.err.println(&quot;&quot;);
402                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
403                     System.err.println(&quot;&quot;);
404                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
405                     System.err.println(&quot;&quot;);
406                     System.exit(1);
407                 }
408 
409                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
410                 for (var tag : tags) {
411                     tagsAndHashes.put(tag, hgResolve(tag));
412                 }
413                 var bookmarkHash = hgResolve(bookmark.name());
414                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
415                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
416                     System.err.println(&quot;&quot;);
417 
418                     if (upstreams.size() == 1) {
419                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
420                         System.err.println(&quot;&quot;);
421                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
422                         System.err.println(&quot;&quot;);
423                     } else {
424                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
425                         System.err.println(&quot;&quot;);
426                         for (var upstream : upstreams) {
427                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
428                         }
429                         System.err.println(&quot;&quot;);
430                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
431                         System.err.println(&quot;&quot;);
432                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
433                         System.err.println(&quot;&quot;);
434                     }
435                     System.exit(1);
436                 }
437 
438                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
439                 var targetHash = hgResolve(targetBranch);
440                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
441                 if (commits.isEmpty()) {
442                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
443                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
444                     System.exit(1);
445                 }
446 
447                 var diff = repo.diff(repo.head());
448                 if (!diff.patches().isEmpty()) {
449                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
450                     System.err.println(&quot;&quot;);
451                     for (var patch : diff.patches()) {
452                         var path = patch.target().path().isPresent() ?
453                             patch.target().path().get() : patch.source().path().get();
454                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
455                     }
456                     System.err.println(&quot;&quot;);
457                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
458                     System.err.println(&quot;&quot;);
459                     System.err.println(&quot;    hg commit --amend&quot;);
460                     System.err.println(&quot;    hg git-cleanup&quot;);
461                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
462                     System.err.println(&quot;    hg gimport&quot;);
463                     System.err.println(&quot;&quot;);
464                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
465                     System.err.println(&quot;&quot;);
466                     System.err.println(&quot;    hg shelve&quot;);
467                     System.err.println(&quot;&quot;);
468                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
469                     System.exit(1);
470                 }
471 
472                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
473                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
474                 );
475                 if (token == null) {
476                     GitCredentials.approve(credentials);
477                 }
478                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
479                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
480 
481                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
482                 if (commits.size() == 1) {
483                     var commit = commits.get(0);
484                     var message = CommitMessageParsers.v1.parse(commit.message());
485                     Files.writeString(file, message.title() + &quot;\n&quot;);
486                     if (!message.summaries().isEmpty()) {
487                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
488                     }
489                     if (!message.additional().isEmpty()) {
490                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
491                     }
492                 } else {
493                     Files.write(file, List.of(&quot;&quot;));
494                 }
495                 Files.write(file, List.of(
496                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
497                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
498                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
499                     &quot;# the subject from the body.&quot;,
500                     &quot;#&quot;,
501                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
502                     ),
503                     StandardOpenOption.APPEND
504                 );
505                 for (var commit : commits) {
506                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
507                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
508                 }
509                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
510                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
511                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
512                 var success = spawnEditor(repo, file);
513                 if (!success) {
514                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
515                     System.exit(1);
516                 }
517                 var lines = Files.readAllLines(file)
518                                  .stream()
519                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
520                                  .collect(Collectors.toList());
521                 var isEmpty = lines.stream().allMatch(String::isEmpty);
522                 if (isEmpty) {
523                     System.err.println(&quot;error: no message present, aborting&quot;);
524                     System.exit(1);
525                 }
526 
527                 var title = lines.get(0);
528                 List&lt;String&gt; body = null;
529                 if (lines.size() &gt; 1) {
530                     body = lines.subList(1, lines.size())
531                                 .stream()
532                                 .dropWhile(String::isEmpty)
533                                 .collect(Collectors.toList());
534                 } else {
535                     body = Collections.emptyList();
536                 }
537 
538                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
539                 if (arguments.contains(&quot;assignees&quot;)) {
540                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
541                     var assignees = usernames.stream()
542                                              .map(u -&gt; host.user(u))
543                                              .collect(Collectors.toList());
544                     pr.setAssignees(assignees);
545                 }
546                 System.out.println(pr.webUrl().toString());
547                 Files.deleteIfExists(file);
548 
549                 System.exit(0);
550             }
551             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
552                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
553                     System.exit(1);
554                     return null;
555             });
556             if (currentBranch.equals(repo.defaultBranch())) {
557                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
558                 System.err.println(&quot;&quot;);
559                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
560                 System.err.println(&quot;&quot;);
561                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
562                 System.err.println(&quot;    git branch --force master origin/master&quot;);
563                 System.err.println(&quot;&quot;);
564                 System.exit(1);
565             }
566 
567             var upstream = repo.upstreamFor(currentBranch);
568             if (upstream.isEmpty()) {
569                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
570                 System.err.println(&quot;&quot;);
571                 System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
572                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
573                 System.err.println(&quot;&quot;);
574                 System.err.println(&quot;    git publish&quot;);
575                 System.err.println(&quot;&quot;);
576                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
577                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
578                 System.err.println(&quot;&quot;);
579                 System.err.println(&quot;    git fetch &quot; + remote);
580                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
581                 System.err.println(&quot;&quot;);
582                 System.exit(1);
583             }
584 
585             var upstreamRefName = upstream.get().substring(remote.length() + 1);
586             repo.fetch(uri, upstreamRefName);
587             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
588             if (!branchCommits.isEmpty()) {
589                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
590                 System.err.println(&quot;&quot;);
591                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
592                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
593                 System.err.println(&quot;&quot;);
594                 for (var commit : branchCommits) {
595                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
596                 }
597                 System.err.println(&quot;&quot;);
598                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
599                 System.err.println(&quot;&quot;);
600                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
601                 System.err.println(&quot;&quot;);
602                 System.exit(1);
603             }
604 
605             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
606             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
607             if (commits.isEmpty()) {
608                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
609                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
610                 System.exit(1);
611             }
612 
613             var diff = repo.diff(repo.head());
614             if (!diff.patches().isEmpty()) {
615                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
616                 System.err.println(&quot;&quot;);
617                 for (var patch : diff.patches()) {
618                     var path = patch.target().path().isPresent() ?
619                         patch.target().path().get() : patch.source().path().get();
620                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
621                 }
622                 System.err.println(&quot;&quot;);
623                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
624                 System.err.println(&quot;&quot;);
625                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
626                 System.err.println(&quot;&quot;);
627                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
628                 System.err.println(&quot;&quot;);
629                 System.err.println(&quot;    git stash&quot;);
630                 System.err.println(&quot;&quot;);
631                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
632                 System.exit(1);
633             }
634 
635             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
636                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
637             );
638             if (token == null) {
639                 GitCredentials.approve(credentials);
640             }
641             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
642                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
643 
644             var issue = getIssue(currentBranch);
645             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
646             if (issue.isPresent()) {
647                 var parts = issue.get().id().split(&quot;-&quot;);
648                 var id = parts.length == 2 ? parts[1] : issue.get().id();
649                 Files.writeString(file, id + &quot;: &quot; + issue.get().title() + &quot;\n\n&quot;);
650             } else if (commits.size() == 1) {
651                 var commit = commits.get(0);
652                 var message = CommitMessageParsers.v1.parse(commit.message());
653                 Files.writeString(file, message.title() + &quot;\n&quot;);
654                 if (!message.summaries().isEmpty()) {
655                     Files.write(file, message.summaries(), StandardOpenOption.APPEND);
656                 }
657                 if (!message.additional().isEmpty()) {
658                     Files.write(file, message.additional(), StandardOpenOption.APPEND);
659                 }
660             } else {
661                 Files.write(file, List.of(&quot;&quot;));
662             }
663             Files.write(file, List.of(
664                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
665                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
666                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
667                 &quot;# the subject from the body.&quot;,
668                 &quot;#&quot;,
669                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
670                 ),
671                 StandardOpenOption.APPEND
672             );
673             for (var commit : commits) {
674                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
675                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
676             }
677             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
678             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
679             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
680             var success = spawnEditor(repo, file);
681             if (!success) {
682                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
683                 System.exit(1);
684             }
685             var lines = Files.readAllLines(file)
686                              .stream()
687                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
688                              .collect(Collectors.toList());
689             var isEmpty = lines.stream().allMatch(String::isEmpty);
690             if (isEmpty) {
691                 System.err.println(&quot;error: no message present, aborting&quot;);
692                 System.exit(1);
693             }
694 
695             var title = lines.get(0);
696             List&lt;String&gt; body = null;
697             if (lines.size() &gt; 1) {
698                 body = lines.subList(1, lines.size())
699                             .stream()
700                             .dropWhile(String::isEmpty)
701                             .collect(Collectors.toList());
702             } else {
703                 body = Collections.emptyList();
704             }
705 
706             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
707             if (arguments.contains(&quot;assignees&quot;)) {
708                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
709                 var assignees = usernames.stream()
710                                          .map(u -&gt; host.user(u))
711                                          .collect(Collectors.toList());
712                 pr.setAssignees(assignees);
713             }
714             System.out.println(pr.webUrl().toString());
715             Files.deleteIfExists(file);
716         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
717             var pr = getPullRequest(uri, repo, host, arguments.at(1));
718 
719             if (action.equals(&quot;integrate&quot;)) {
720                 pr.addComment(&quot;/integrate&quot;);
721             } else if (action.equals(&quot;test&quot;)) {
722                 pr.addComment(&quot;/test&quot;);
723             } else if (action.equals(&quot;approve&quot;)) {
724                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
725             } else {
726                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
727             }
728         } else if (action.equals(&quot;list&quot;)) {
729             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
730             var prs = remoteRepo.pullRequests();
731             var ids = new ArrayList&lt;String&gt;();
732             var titles = new ArrayList&lt;String&gt;();
733             var authors = new ArrayList&lt;String&gt;();
734             var assignees = new ArrayList&lt;String&gt;();
735             var labels = new ArrayList&lt;String&gt;();
736 
737             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
738                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
739                 Set.of();
740             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
741                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
742                 Set.of();
743             var filterLabels = arguments.contains(&quot;labels&quot;) ?
744                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
745                 Set.of();
746 
747             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
748             var columnValues = Map.of(defaultColumns.get(0), ids,
749                                       defaultColumns.get(1), titles,
750                                       defaultColumns.get(2), authors,
751                                       defaultColumns.get(3), assignees,
752                                       defaultColumns.get(4), labels);
753             var columns = arguments.contains(&quot;columns&quot;) ?
754                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
755                 defaultColumns;
756             if (columns != defaultColumns) {
757                 for (var column : columns) {
758                     if (!defaultColumns.contains(column)) {
759                         System.err.println(&quot;error: unknown column: &quot; + column);
760                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
761                         System.exit(1);
762                     }
763                 }
764             }
765 
766             for (var pr : prs) {
767                 var prAuthor = pr.author().userName();
768                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
769                     continue;
770                 }
771 
772                 var prAssignees = pr.assignees().stream()
773                                     .map(HostUser::userName)
774                                     .collect(Collectors.toSet());
775                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
776                     continue;
777                 }
778 
779                 var prLabels = new HashSet&lt;&gt;(pr.labels());
780                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
781                     continue;
782                 }
783 
784                 ids.add(pr.id());
785                 titles.add(pr.title());
786                 authors.add(prAuthor);
787                 assignees.add(String.join(&quot;,&quot;, prAssignees));
788                 labels.add(String.join(&quot;,&quot;, prLabels));
789             }
790 
791 
792             String fmt = &quot;&quot;;
793             for (var column : columns.subList(0, columns.size() - 1)) {
794                 var values = columnValues.get(column);
795                 var n = Math.max(column.length(), longest(values));
796                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
797             }
798             fmt += &quot;%s\n&quot;;
799 
800             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
801                 var upperCase = columns.stream()
802                                        .map(String::toUpperCase)
803                                        .collect(Collectors.toList());
804                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
805             }
806             for (var i = 0; i &lt; ids.size(); i++) {
807                 final int n = i;
808                 var row = columns.stream()
809                                  .map(columnValues::get)
810                                  .map(values -&gt; values.get(n))
811                                  .collect(Collectors.toList());
812                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
813             }
814         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
815             var prId = arguments.at(1);
816             if (!prId.isPresent()) {
817                 exit(&quot;error: missing pull request identifier&quot;);
818             }
819 
820             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
821             var pr = remoteRepo.pullRequest(prId.asString());
822             var repoUrl = remoteRepo.webUrl();
823             var prHeadRef = pr.sourceRef();
824             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
825             if (isHgGit) {
826                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
827                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
828 
829                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
830                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
831                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
832 
833                     if (action.equals(&quot;show&quot;)) {
834                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
835                     } else {
836                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
837                         hgImport(patch);
838                         Files.delete(patch);
839                     }
840                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
841                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
842                     var hgGitBranches = hgGitRepo.branches();
843                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
844                         hgGitRepo.delete(new Branch(hgGitRef));
845                     }
846                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
847                     gimport();
848                     var hgFetchHead = repo.resolve(hgGitRef).get();
849 
850                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
851                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
852                     } else if (action.equals(&quot;checkout&quot;)) {
853                         repo.checkout(hgFetchHead);
854                         if (arguments.contains(&quot;branch&quot;)) {
855                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
856                         }
857                     }
858                 } else {
859                     exit(&quot;Unexpected action: &quot; + action);
860                 }
861 
862                 return;
863             }
864 
865             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
866             if (action.equals(&quot;fetch&quot;)) {
867                 if (arguments.contains(&quot;branch&quot;)) {
868                     var branchName = arguments.get(&quot;branch&quot;).asString();
869                     repo.branch(fetchHead, branchName);
870                 } else {
871                     System.out.println(fetchHead.hex());
872                 }
873             } else if (action.equals(&quot;checkout&quot;)) {
874                 if (arguments.contains(&quot;branch&quot;)) {
875                     var branchName = arguments.get(&quot;branch&quot;).asString();
876                     var branch = repo.branch(fetchHead, branchName);
877                     repo.checkout(branch, false);
878                 } else {
879                     repo.checkout(fetchHead, false);
880                 }
881             } else if (action.equals(&quot;show&quot;)) {
882                 show(pr.targetRef(), fetchHead);
883             } else if (action.equals(&quot;apply&quot;)) {
884                 var patch = diff(pr.targetRef(), fetchHead);
885                 apply(patch);
886                 Files.deleteIfExists(patch);
887             }
888         } else if (action.equals(&quot;close&quot;)) {
889             var prId = arguments.at(1);
890             if (!prId.isPresent()) {
891                 exit(&quot;error: missing pull request identifier&quot;);
892             }
893 
894             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
895             var pr = remoteRepo.pullRequest(prId.asString());
896             pr.setState(PullRequest.State.CLOSED);
897         } else if (action.equals(&quot;update&quot;)) {
898             var prId = arguments.at(1);
899             if (!prId.isPresent()) {
900                 exit(&quot;error: missing pull request identifier&quot;);
901             }
902 
903             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
904             var pr = remoteRepo.pullRequest(prId.asString());
905             if (arguments.contains(&quot;assignees&quot;)) {
906                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
907                 var assignees = usernames.stream()
908                     .map(u -&gt; host.user(u))
909                     .collect(Collectors.toList());
910                 pr.setAssignees(assignees);
911             }
912         } else {
913             exit(&quot;error: unexpected action: &quot; + action);
914         }
915     }
916 }
    </pre>
  </body>
</html>