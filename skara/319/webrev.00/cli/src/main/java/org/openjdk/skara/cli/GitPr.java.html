<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.cli;
 24 
 25 import org.openjdk.skara.args.*;
 26 import org.openjdk.skara.forge.*;
 27 import org.openjdk.skara.host.*;
 28 import org.openjdk.skara.issuetracker.IssueTracker;
 29 import org.openjdk.skara.issuetracker.Issue;
 30 import org.openjdk.skara.jcheck.JCheckConfiguration;
 31 import org.openjdk.skara.proxy.HttpProxy;
 32 import org.openjdk.skara.vcs.*;
 33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 34 
 35 import java.io.IOException;
 36 import java.net.URI;
 37 import java.nio.charset.StandardCharsets;
 38 import java.nio.file.*;
 39 import java.util.*;
 40 import java.util.regex.Pattern;
 41 import java.util.concurrent.TimeUnit;
 42 import java.util.function.Supplier;
 43 import java.util.logging.Level;
 44 import java.util.stream.Collectors;
 45 
 46 public class GitPr {
 47     private static void exit(String fmt, Object...args) {
 48         System.err.println(String.format(fmt, args));
 49         System.exit(1);
 50     }
 51 
 52     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
 53         return () -&gt; {
 54             exit(fmt, args);
 55             return null;
 56         };
 57     }
 58 
 59     private static String format(Issue issue) {
 60         var parts = issue.id().split(&quot;-&quot;);
 61         var id = parts.length == 2 ? parts[1] : issue.id();
 62         return id + &quot;: &quot; + issue.title();
 63     }
 64 
 65     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 66         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 67             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 68         ));
 69 
 70         return conf.general().jbs();
 71     }
 72 
 73     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 74         var message = CommitMessageParsers.v1.parse(commit.message());
 75         var issues = message.issues();
 76         if (issues.isEmpty()) {
 77             return getIssue(message.title(), project);
 78         } else if (issues.size() == 1) {
 79             var issue = issues.get(0);
 80             return getIssue(issue.id(), project);
 81         }
 82         return Optional.empty();
 83     }
 84 
 85     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 86         return getIssue(b.name(), project);
 87     }
 88 
 89     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 90         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
 91         var m = issueIdPattern.matcher(s);
 92         if (m.matches()) {
 93             var id = m.group(2);
 94             if (project == null) {
 95                 project = m.group(1);
 96             }
 97             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 98             return issueTracker.project(project).issue(id);
 99         }
100 
101         return Optional.empty();
102     }
103 
104     private static void await(Process p) throws IOException {
105         try {
106             var res = p.waitFor();
107             if (res != 0) {
108                 throw new IOException(&quot;Unexpected exit code &quot; + res);
109             }
110         } catch (InterruptedException e) {
111             throw new IOException(e);
112         }
113     }
114 
115     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
116         String editor = null;
117         var lines = repo.config(&quot;core.editor&quot;);
118         if (lines.size() == 1) {
119             editor = lines.get(0);
120         }
121         if (editor == null) {
122             editor = System.getenv(&quot;GIT_EDITOR&quot;);
123         }
124         if (editor == null) {
125             editor = System.getenv(&quot;EDITOR&quot;);
126         }
127         if (editor == null) {
128             editor = System.getenv(&quot;VISUAL&quot;);
129         }
130         if (editor == null) {
131             editor = &quot;vi&quot;;
132         }
133 
134         var pb = new ProcessBuilder(editor, file.toString());
135         pb.inheritIO();
136         var p = pb.start();
137         try {
138             return p.waitFor() == 0;
139         } catch (InterruptedException e) {
140             throw new IOException(e);
141         }
142     }
143 
144     private static String projectName(URI uri) {
145         var name = uri.getPath().toString().substring(1);
146         if (name.endsWith(&quot;.git&quot;)) {
147             name = name.substring(0, name.length() - &quot;.git&quot;.length());
148         }
149         return name;
150     }
151 
152     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
153         HostedRepository targetRepo = null;
154 
155         try {
156             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
157             targetRepo = host.repository(projectName(upstream)).orElse(null);
158         } catch (IOException e) {
159             // do nothing
160         }
161 
162         if (targetRepo == null) {
163             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
164                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
165             );
166             var parentRepo = remoteRepo.parent();
167             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
168         }
169 
170         return targetRepo;
171     }
172 
173     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, Argument prId) throws IOException {
174         if (!prId.isPresent()) {
175             exit(&quot;error: missing pull request identifier&quot;);
176         }
177 
178         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId.asString());
179         if (pr == null) {
180             exit(&quot;error: could not fetch PR information&quot;);
181         }
182 
183         return pr;
184     }
185 
186     private static void show(String ref, Hash hash) throws IOException {
187         show(ref, hash, null);
188     }
189     private static void show(String ref, Hash hash, Path dir) throws IOException {
190         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
191                                                    &quot;--patch&quot;,
192                                                    &quot;--find-renames=50%&quot;,
193                                                    &quot;--find-copies=50%&quot;,
194                                                    &quot;--find-copies-harder&quot;,
195                                                    &quot;--abbrev&quot;,
196                                                    ref + &quot;...&quot; + hash.hex());
197         if (dir != null) {
198             pb.directory(dir.toFile());
199         }
200         pb.inheritIO();
201         await(pb.start());
202     }
203 
204     private static void gimport() throws IOException {
205         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
206         pb.inheritIO();
207         await(pb.start());
208     }
209 
210     private static void hgImport(Path patch) throws IOException {
211         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
212         pb.inheritIO();
213         await(pb.start());
214     }
215 
216     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
217         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
218         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
219         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
220         var p = pb.start();
221         var bytes = p.getInputStream().readAllBytes();
222         var exited = p.waitFor(1, TimeUnit.MINUTES);
223         var exitValue = p.exitValue();
224         if (!exited || exitValue != 0) {
225             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
226         }
227 
228         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
229     }
230 
231     private static String hgResolve(String ref) throws IOException, InterruptedException {
232         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
233         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
234         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
235         var p = pb.start();
236         var bytes = p.getInputStream().readAllBytes();
237         var exited = p.waitFor(1, TimeUnit.MINUTES);
238         var exitValue = p.exitValue();
239         if (!exited || exitValue != 0) {
240             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
241         }
242 
243         return new String(bytes, StandardCharsets.UTF_8);
244     }
245 
246     private static Path diff(String ref, Hash hash) throws IOException {
247         return diff(ref, hash, null);
248     }
249 
250     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
251         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
252         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
253                                                    &quot;--patch&quot;,
254                                                    &quot;--find-renames=50%&quot;,
255                                                    &quot;--find-copies=50%&quot;,
256                                                    &quot;--find-copies-harder&quot;,
257                                                    &quot;--abbrev&quot;,
258                                                    ref + &quot;...&quot; + hash.hex());
259         if (dir != null) {
260             pb.directory(dir.toFile());
261         }
262         pb.redirectOutput(patch.toFile());
263         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
264         await(pb.start());
265         return patch;
266     }
267 
268     private static void apply(Path patch) throws IOException {
269         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
270         pb.inheritIO();
271         await(pb.start());
272     }
273 
274     private static int longest(List&lt;String&gt; strings) {
275         return strings.stream().mapToInt(String::length).max().orElse(0);
276     }
277 
278     public static void main(String[] args) throws IOException, InterruptedException {
279         var flags = List.of(
280             Option.shortcut(&quot;u&quot;)
281                   .fullname(&quot;username&quot;)
282                   .describe(&quot;NAME&quot;)
283                   .helptext(&quot;Username on host&quot;)
284                   .optional(),
285             Option.shortcut(&quot;r&quot;)
286                   .fullname(&quot;remote&quot;)
287                   .describe(&quot;NAME&quot;)
288                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
289                   .optional(),
290             Option.shortcut(&quot;b&quot;)
291                   .fullname(&quot;branch&quot;)
292                   .describe(&quot;NAME&quot;)
293                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
294                   .optional(),
295             Option.shortcut(&quot;&quot;)
296                   .fullname(&quot;authors&quot;)
297                   .describe(&quot;LIST&quot;)
298                   .helptext(&quot;Comma separated list of authors&quot;)
299                   .optional(),
300             Option.shortcut(&quot;&quot;)
301                   .fullname(&quot;assignees&quot;)
302                   .describe(&quot;LIST&quot;)
303                   .helptext(&quot;Comma separated list of assignees&quot;)
304                   .optional(),
305             Option.shortcut(&quot;&quot;)
306                   .fullname(&quot;labels&quot;)
307                   .describe(&quot;LIST&quot;)
308                   .helptext(&quot;Comma separated list of labels&quot;)
309                   .optional(),
310             Option.shortcut(&quot;&quot;)
311                   .fullname(&quot;columns&quot;)
312                   .describe(&quot;id,title,author,assignees,labels&quot;)
313                   .helptext(&quot;Comma separated list of columns to show&quot;)
314                   .optional(),
315             Switch.shortcut(&quot;&quot;)
316                   .fullname(&quot;no-decoration&quot;)
317                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
318                   .optional(),
319             Switch.shortcut(&quot;&quot;)
320                   .fullname(&quot;ignore-workspace&quot;)
321                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
322                   .optional(),
323             Switch.shortcut(&quot;&quot;)
324                   .fullname(&quot;publish&quot;)
325                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
326                   .optional(),
327             Switch.shortcut(&quot;&quot;)
328                   .fullname(&quot;no-token&quot;)
329                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
330                   .optional(),
331             Switch.shortcut(&quot;&quot;)
332                   .fullname(&quot;mercurial&quot;)
333                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
334                   .optional(),
335             Switch.shortcut(&quot;&quot;)
336                   .fullname(&quot;verbose&quot;)
337                   .helptext(&quot;Turn on verbose output&quot;)
338                   .optional(),
339             Switch.shortcut(&quot;&quot;)
340                   .fullname(&quot;debug&quot;)
341                   .helptext(&quot;Turn on debugging output&quot;)
342                   .optional(),
343             Switch.shortcut(&quot;&quot;)
344                   .fullname(&quot;version&quot;)
345                   .helptext(&quot;Print the version of this tool&quot;)
346                   .optional());
347 
348         var inputs = List.of(
349             Input.position(0)
350                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
351                  .singular()
352                  .required(),
353             Input.position(1)
354                  .describe(&quot;ID&quot;)
355                  .singular()
356                  .optional()
357         );
358 
359         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
360         var arguments = parser.parse(args);
361 
362         if (arguments.contains(&quot;version&quot;)) {
363             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
364             System.exit(0);
365         }
366 
367         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
368             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
369             Logging.setup(level);
370         }
371 
372         HttpProxy.setup();
373 
374         var isMercurial = arguments.contains(&quot;mercurial&quot;);
375         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
376         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
377         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
378         var remotePullPath = repo.pullPath(remote);
379         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
380         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
381         var uri = Remote.toWebURI(remotePullPath);
382         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
383         var credentials = !shouldUseToken ?
384             null :
385             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
386         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
387         var forge = credentials == null ?
388             Forge.from(forgeURI) :
389             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
390         if (forge.isEmpty()) {
391             if (!shouldUseToken) {
392                 if (arguments.contains(&quot;verbose&quot;)) {
393                     System.err.println(&quot;&quot;);
394                 }
395                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
396                 if (!arguments.contains(&quot;verbose&quot;)) {
397                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
398                     System.err.println(&quot;&quot;);
399                 }
400             }
401             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
402         }
403         var host = forge.get();
404 
405         var action = arguments.at(0).asString();
406         if (!shouldUseToken &amp;&amp;
407             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
408             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
409             System.exit(1);
410         }
411 
412         if (action.equals(&quot;create&quot;)) {
413             if (isMercurial) {
414                 var currentBookmark = repo.currentBookmark();
415                 if (!currentBookmark.isPresent()) {
416                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
417                     System.err.println(&quot;&quot;);
418                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
419                     System.err.println(&quot;&quot;);
420                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
421                     System.err.println(&quot;&quot;);
422                     System.exit(1);
423                 }
424 
425                 var bookmark = currentBookmark.get();
426                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
427                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
428                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
429                     System.err.println(&quot;&quot;);
430                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
431                     System.err.println(&quot;&quot;);
432                     System.exit(1);
433                 }
434 
435                 var tags = hgTags();
436                 var upstreams = tags.stream()
437                                     .filter(t -&gt; t.endsWith(bookmark.name()))
438                                     .collect(Collectors.toList());
439                 if (upstreams.isEmpty()) {
440                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
441                     System.err.println(&quot;&quot;);
442                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
443                     System.err.println(&quot;&quot;);
444                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
445                     System.err.println(&quot;&quot;);
446                     System.exit(1);
447                 }
448 
449                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
450                 for (var tag : tags) {
451                     tagsAndHashes.put(tag, hgResolve(tag));
452                 }
453                 var bookmarkHash = hgResolve(bookmark.name());
454                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
455                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
456                     System.err.println(&quot;&quot;);
457 
458                     if (upstreams.size() == 1) {
459                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
460                         System.err.println(&quot;&quot;);
461                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
462                         System.err.println(&quot;&quot;);
463                     } else {
464                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
465                         System.err.println(&quot;&quot;);
466                         for (var upstream : upstreams) {
467                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
468                         }
469                         System.err.println(&quot;&quot;);
470                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
471                         System.err.println(&quot;&quot;);
472                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
473                         System.err.println(&quot;&quot;);
474                     }
475                     System.exit(1);
476                 }
477 
478                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
479                 var targetHash = hgResolve(targetBranch);
480                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
481                 if (commits.isEmpty()) {
482                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
483                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
484                     System.exit(1);
485                 }
486 
487                 var diff = repo.diff(repo.head());
488                 if (!diff.patches().isEmpty()) {
489                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
490                     System.err.println(&quot;&quot;);
491                     for (var patch : diff.patches()) {
492                         var path = patch.target().path().isPresent() ?
493                             patch.target().path().get() : patch.source().path().get();
494                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
495                     }
496                     System.err.println(&quot;&quot;);
497                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
498                     System.err.println(&quot;&quot;);
499                     System.err.println(&quot;    hg commit --amend&quot;);
500                     System.err.println(&quot;    hg git-cleanup&quot;);
501                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
502                     System.err.println(&quot;    hg gimport&quot;);
503                     System.err.println(&quot;&quot;);
504                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
505                     System.err.println(&quot;&quot;);
506                     System.err.println(&quot;    hg shelve&quot;);
507                     System.err.println(&quot;&quot;);
508                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
509                     System.exit(1);
510                 }
511 
512                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
513                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
514                 );
515                 if (token == null) {
516                     GitCredentials.approve(credentials);
517                 }
518                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
519                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
520 
521                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
522                 if (commits.size() == 1) {
523                     var commit = commits.get(0);
524                     var message = CommitMessageParsers.v1.parse(commit.message());
525                     Files.writeString(file, message.title() + &quot;\n&quot;);
526                     if (!message.summaries().isEmpty()) {
527                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
528                     }
529                     if (!message.additional().isEmpty()) {
530                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
531                     }
532                 } else {
533                     Files.write(file, List.of(&quot;&quot;));
534                 }
535                 Files.write(file, List.of(
536                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
537                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
538                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
539                     &quot;# the subject from the body.&quot;,
540                     &quot;#&quot;,
541                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
542                     ),
543                     StandardOpenOption.APPEND
544                 );
545                 for (var commit : commits) {
546                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
547                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
548                 }
549                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
550                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
551                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
552                 var success = spawnEditor(repo, file);
553                 if (!success) {
554                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
555                     System.exit(1);
556                 }
557                 var lines = Files.readAllLines(file)
558                                  .stream()
559                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
560                                  .collect(Collectors.toList());
561                 var isEmpty = lines.stream().allMatch(String::isEmpty);
562                 if (isEmpty) {
563                     System.err.println(&quot;error: no message present, aborting&quot;);
564                     System.exit(1);
565                 }
566 
567                 var title = lines.get(0);
568                 List&lt;String&gt; body = null;
569                 if (lines.size() &gt; 1) {
570                     body = lines.subList(1, lines.size())
571                                 .stream()
572                                 .dropWhile(String::isEmpty)
573                                 .collect(Collectors.toList());
574                 } else {
575                     body = Collections.emptyList();
576                 }
577 
578                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
579                 if (arguments.contains(&quot;assignees&quot;)) {
580                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
581                     var assignees = usernames.stream()
582                                              .map(u -&gt; host.user(u))
583                                              .collect(Collectors.toList());
584                     pr.setAssignees(assignees);
585                 }
586                 System.out.println(pr.webUrl().toString());
587                 Files.deleteIfExists(file);
588 
589                 System.exit(0);
590             }
591             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
592                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
593                     System.exit(1);
594                     return null;
595             });
596             if (currentBranch.equals(repo.defaultBranch())) {
597                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
598                 System.err.println(&quot;&quot;);
599                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
600                 System.err.println(&quot;&quot;);
601                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
602                 System.err.println(&quot;    git branch --force master origin/master&quot;);
603                 System.err.println(&quot;&quot;);
604                 System.exit(1);
605             }
606 
607             var ignoreWorkspace = arguments.contains(&quot;ignore-workspace&quot;);
608             if (!ignoreWorkspace) {
609                 var lines = repo.config(&quot;pr.ignore-workspace&quot;);
610                 ignoreWorkspace = lines.size() == 1 &amp;&amp; lines.get(0).equals(&quot;true&quot;);
611             }
612             if (!ignoreWorkspace) {
613                 var diff = repo.diff(repo.head());
614                 if (!diff.patches().isEmpty()) {
615                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
616                     System.err.println(&quot;&quot;);
617                     for (var patch : diff.patches()) {
618                         var path = patch.target().path().isPresent() ?
619                             patch.target().path().get() : patch.source().path().get();
620                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
621                     }
622                     System.err.println(&quot;&quot;);
623                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
624                     System.err.println(&quot;&quot;);
625                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
626                     System.err.println(&quot;&quot;);
627                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
628                     System.err.println(&quot;&quot;);
629                     System.err.println(&quot;    git stash&quot;);
630                     System.err.println(&quot;&quot;);
631                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
632                     System.exit(1);
633                 }
634             }
635 
636             var upstream = repo.upstreamFor(currentBranch);
637             if (upstream.isEmpty()) {
638                 var shouldPublish = arguments.contains(&quot;publish&quot;);
639                 if (!shouldPublish) {
640                     var lines = repo.config(&quot;pr.publish&quot;);
641                     shouldPublish = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
642                 }
643                 if (shouldPublish) {
644                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
645                     upstream = repo.upstreamFor(currentBranch);
646                 } else {
647                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
648                     System.err.println(&quot;&quot;);
649                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
650                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
651                     System.err.println(&quot;&quot;);
652                     System.err.println(&quot;    git publish&quot;);
653                     System.err.println(&quot;&quot;);
654                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
655                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
656                     System.err.println(&quot;&quot;);
657                     System.err.println(&quot;    git fetch &quot; + remote);
658                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
659                     System.err.println(&quot;&quot;);
660                     System.exit(1);
661                 }
662             }
663 
664             var upstreamRefName = upstream.get().substring(remote.length() + 1);
665             repo.fetch(uri, upstreamRefName);
666             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
667             if (!branchCommits.isEmpty()) {
668                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
669                 System.err.println(&quot;&quot;);
670                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
671                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
672                 System.err.println(&quot;&quot;);
673                 for (var commit : branchCommits) {
674                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
675                 }
676                 System.err.println(&quot;&quot;);
677                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
678                 System.err.println(&quot;&quot;);
679                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
680                 System.err.println(&quot;&quot;);
681                 System.exit(1);
682             }
683 
684             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
685             var commits = repo.commits(targetBranch + &quot;..&quot; + currentBranch.name()).asList();
686             if (commits.isEmpty()) {
687                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
688                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
689                 System.exit(1);
690             }
691 
692             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
693                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
694             );
695             if (token == null) {
696                 GitCredentials.approve(credentials);
697             }
698             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
699                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
700 
701             var project = jbsProjectFromJcheckConf(repo);
702             var issue = getIssue(currentBranch, project);
703             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
704             if (issue.isPresent()) {
705                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
706             } else if (commits.size() == 1) {
707                 var commit = commits.get(0);
708                 issue = getIssue(commit, project);
709                 if (issue.isPresent()) {
710                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
711                 } else {
712                     var message = CommitMessageParsers.v1.parse(commit.message());
713                     Files.writeString(file, message.title() + &quot;\n&quot;);
714                     if (!message.summaries().isEmpty()) {
715                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
716                     }
717                     if (!message.additional().isEmpty()) {
718                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
719                     }
720                 }
721             } else {
722                 Files.write(file, List.of(&quot;&quot;));
723             }
724             Files.write(file, List.of(
725                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
726                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
727                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
728                 &quot;# the subject from the body.&quot;,
729                 &quot;#&quot;,
730                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
731                 ),
732                 StandardOpenOption.APPEND
733             );
734             for (var commit : commits) {
735                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
736                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
737             }
738             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
739             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
740             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
741             var success = spawnEditor(repo, file);
742             if (!success) {
743                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
744                 System.exit(1);
745             }
746             var lines = Files.readAllLines(file)
747                              .stream()
748                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
749                              .collect(Collectors.toList());
750             var isEmpty = lines.stream().allMatch(String::isEmpty);
751             if (isEmpty) {
752                 System.err.println(&quot;error: no message present, aborting&quot;);
753                 System.exit(1);
754             }
755 
756             var title = lines.get(0);
757             List&lt;String&gt; body = null;
758             if (lines.size() &gt; 1) {
759                 body = lines.subList(1, lines.size())
760                             .stream()
761                             .dropWhile(String::isEmpty)
762                             .collect(Collectors.toList());
763             } else {
764                 body = Collections.emptyList();
765             }
766 
767             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
768             if (arguments.contains(&quot;assignees&quot;)) {
769                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
770                 var assignees = usernames.stream()
771                                          .map(u -&gt; host.user(u))
772                                          .collect(Collectors.toList());
773                 pr.setAssignees(assignees);
774             }
775             System.out.println(pr.webUrl().toString());
776             Files.deleteIfExists(file);
777         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
778             var pr = getPullRequest(uri, repo, host, arguments.at(1));
779 
780             if (action.equals(&quot;integrate&quot;)) {
781                 pr.addComment(&quot;/integrate&quot;);
782             } else if (action.equals(&quot;test&quot;)) {
783                 pr.addComment(&quot;/test&quot;);
784             } else if (action.equals(&quot;approve&quot;)) {
785                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
786             } else {
787                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
788             }
789         } else if (action.equals(&quot;list&quot;)) {
790             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
791             var prs = remoteRepo.pullRequests();
792             var ids = new ArrayList&lt;String&gt;();
793             var titles = new ArrayList&lt;String&gt;();
794             var authors = new ArrayList&lt;String&gt;();
795             var assignees = new ArrayList&lt;String&gt;();
796             var labels = new ArrayList&lt;String&gt;();
797 
798             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
799                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
800                 Set.of();
801             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
802                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
803                 Set.of();
804             var filterLabels = arguments.contains(&quot;labels&quot;) ?
805                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
806                 Set.of();
807 
808             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
809             var columnValues = Map.of(defaultColumns.get(0), ids,
810                                       defaultColumns.get(1), titles,
811                                       defaultColumns.get(2), authors,
812                                       defaultColumns.get(3), assignees,
813                                       defaultColumns.get(4), labels);
814             var columns = arguments.contains(&quot;columns&quot;) ?
815                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
816                 defaultColumns;
817             if (columns != defaultColumns) {
818                 for (var column : columns) {
819                     if (!defaultColumns.contains(column)) {
820                         System.err.println(&quot;error: unknown column: &quot; + column);
821                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
822                         System.exit(1);
823                     }
824                 }
825             }
826 
827             for (var pr : prs) {
828                 var prAuthor = pr.author().userName();
829                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
830                     continue;
831                 }
832 
833                 var prAssignees = pr.assignees().stream()
834                                     .map(HostUser::userName)
835                                     .collect(Collectors.toSet());
836                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
837                     continue;
838                 }
839 
840                 var prLabels = new HashSet&lt;&gt;(pr.labels());
841                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
842                     continue;
843                 }
844 
845                 ids.add(pr.id());
846                 titles.add(pr.title());
847                 authors.add(prAuthor);
848                 assignees.add(String.join(&quot;,&quot;, prAssignees));
849                 labels.add(String.join(&quot;,&quot;, prLabels));
850             }
851 
852 
853             String fmt = &quot;&quot;;
854             for (var column : columns.subList(0, columns.size() - 1)) {
855                 var values = columnValues.get(column);
856                 var n = Math.max(column.length(), longest(values));
857                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
858             }
859             fmt += &quot;%s\n&quot;;
860 
861             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
862                 var upperCase = columns.stream()
863                                        .map(String::toUpperCase)
864                                        .collect(Collectors.toList());
865                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
866             }
867             for (var i = 0; i &lt; ids.size(); i++) {
868                 final int n = i;
869                 var row = columns.stream()
870                                  .map(columnValues::get)
871                                  .map(values -&gt; values.get(n))
872                                  .collect(Collectors.toList());
873                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
874             }
875         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
876             var prId = arguments.at(1);
877             if (!prId.isPresent()) {
878                 exit(&quot;error: missing pull request identifier&quot;);
879             }
880 
881             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
882             var pr = remoteRepo.pullRequest(prId.asString());
883             var repoUrl = remoteRepo.webUrl();
884             var prHeadRef = pr.sourceRef();
885             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
886             if (isHgGit) {
887                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
888                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
889 
890                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
891                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
892                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
893 
894                     if (action.equals(&quot;show&quot;)) {
895                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
896                     } else {
897                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
898                         hgImport(patch);
899                         Files.delete(patch);
900                     }
901                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
902                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
903                     var hgGitBranches = hgGitRepo.branches();
904                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
905                         hgGitRepo.delete(new Branch(hgGitRef));
906                     }
907                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
908                     gimport();
909                     var hgFetchHead = repo.resolve(hgGitRef).get();
910 
911                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
912                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
913                     } else if (action.equals(&quot;checkout&quot;)) {
914                         repo.checkout(hgFetchHead);
915                         if (arguments.contains(&quot;branch&quot;)) {
916                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
917                         }
918                     }
919                 } else {
920                     exit(&quot;Unexpected action: &quot; + action);
921                 }
922 
923                 return;
924             }
925 
926             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
927             if (action.equals(&quot;fetch&quot;)) {
928                 if (arguments.contains(&quot;branch&quot;)) {
929                     var branchName = arguments.get(&quot;branch&quot;).asString();
930                     repo.branch(fetchHead, branchName);
931                 } else {
932                     System.out.println(fetchHead.hex());
933                 }
934             } else if (action.equals(&quot;checkout&quot;)) {
935                 if (arguments.contains(&quot;branch&quot;)) {
936                     var branchName = arguments.get(&quot;branch&quot;).asString();
937                     var branch = repo.branch(fetchHead, branchName);
938                     repo.checkout(branch, false);
939                 } else {
940                     repo.checkout(fetchHead, false);
941                 }
942             } else if (action.equals(&quot;show&quot;)) {
943                 show(pr.targetRef(), fetchHead);
944             } else if (action.equals(&quot;apply&quot;)) {
945                 var patch = diff(pr.targetRef(), fetchHead);
946                 apply(patch);
947                 Files.deleteIfExists(patch);
948             }
949         } else if (action.equals(&quot;close&quot;)) {
950             var prId = arguments.at(1);
951             if (!prId.isPresent()) {
952                 exit(&quot;error: missing pull request identifier&quot;);
953             }
954 
955             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
956             var pr = remoteRepo.pullRequest(prId.asString());
957             pr.setState(PullRequest.State.CLOSED);
958         } else if (action.equals(&quot;update&quot;)) {
959             var prId = arguments.at(1);
960             if (!prId.isPresent()) {
961                 exit(&quot;error: missing pull request identifier&quot;);
962             }
963 
964             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
965             var pr = remoteRepo.pullRequest(prId.asString());
966             if (arguments.contains(&quot;assignees&quot;)) {
967                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
968                 var assignees = usernames.stream()
969                     .map(u -&gt; host.user(u))
970                     .collect(Collectors.toList());
971                 pr.setAssignees(assignees);
972             }
973         } else {
974             exit(&quot;error: unexpected action: &quot; + action);
975         }
976     }
977 }
    </pre>
  </body>
</html>