<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 
  35 import java.io.IOException;
  36 import java.net.URI;
  37 import java.nio.charset.StandardCharsets;
  38 import java.nio.file.*;
  39 import java.util.*;
  40 import java.util.regex.Pattern;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.function.Supplier;
  43 import java.util.logging.Level;
  44 import java.util.stream.Collectors;
  45 
  46 public class GitPr {
  47     private static void exit(String fmt, Object...args) {
  48         System.err.println(String.format(fmt, args));
  49         System.exit(1);
  50     }
  51 
  52     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  53         return () -&gt; {
  54             exit(fmt, args);
  55             return null;
  56         };
  57     }
  58 
  59     private static String format(Issue issue) {
  60         var parts = issue.id().split(&quot;-&quot;);
  61         var id = parts.length == 2 ? parts[1] : issue.id();
  62         return id + &quot;: &quot; + issue.title();
  63     }
  64 
  65     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
  66         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
  67             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
  68         ));
  69 
  70         return conf.general().jbs();
  71     }
  72 
  73     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
  74         var message = CommitMessageParsers.v1.parse(commit.message());
  75         var issues = message.issues();
  76         if (issues.isEmpty()) {
  77             return getIssue(message.title(), project);
  78         } else if (issues.size() == 1) {
  79             var issue = issues.get(0);
  80             return getIssue(issue.id(), project);
  81         }
  82         return Optional.empty();
  83     }
  84 
  85     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
  86         return getIssue(b.name(), project);
  87     }
  88 
  89     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
  90         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  91         var m = issueIdPattern.matcher(s);
  92         if (m.matches()) {
  93             var id = m.group(2);
  94             if (project == null) {
  95                 project = m.group(1);
  96             }
  97             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
  98             return issueTracker.project(project).issue(id);
  99         }
 100 
 101         return Optional.empty();
 102     }
 103 
 104     private static void await(Process p) throws IOException {
 105         try {
 106             var res = p.waitFor();
 107             if (res != 0) {
 108                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 109             }
 110         } catch (InterruptedException e) {
 111             throw new IOException(e);
 112         }
 113     }
 114 
 115     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 116         String editor = null;
 117         var lines = repo.config(&quot;core.editor&quot;);
 118         if (lines.size() == 1) {
 119             editor = lines.get(0);
 120         }
 121         if (editor == null) {
 122             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 123         }
 124         if (editor == null) {
 125             editor = System.getenv(&quot;EDITOR&quot;);
 126         }
 127         if (editor == null) {
 128             editor = System.getenv(&quot;VISUAL&quot;);
 129         }
 130         if (editor == null) {
 131             editor = &quot;vi&quot;;
 132         }
 133 
 134         var pb = new ProcessBuilder(editor, file.toString());
 135         pb.inheritIO();
 136         var p = pb.start();
 137         try {
 138             return p.waitFor() == 0;
 139         } catch (InterruptedException e) {
 140             throw new IOException(e);
 141         }
 142     }
 143 
 144     private static String projectName(URI uri) {
 145         var name = uri.getPath().toString().substring(1);
 146         if (name.endsWith(&quot;.git&quot;)) {
 147             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 148         }
 149         return name;
 150     }
 151 
 152     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 153         HostedRepository targetRepo = null;
 154 
 155         try {
 156             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 157             targetRepo = host.repository(projectName(upstream)).orElse(null);
 158         } catch (IOException e) {
 159             // do nothing
 160         }
 161 
 162         if (targetRepo == null) {
 163             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 164                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 165             );
 166             var parentRepo = remoteRepo.parent();
 167             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 168         }
 169 
 170         return targetRepo;
 171     }
 172 
 173     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 174         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 175         if (pr == null) {
 176             exit(&quot;error: could not fetch PR information&quot;);
 177         }
 178 
 179         return pr;
 180     }
 181 
 182     private static void show(String ref, Hash hash) throws IOException {
 183         show(ref, hash, null);
 184     }
 185     private static void show(String ref, Hash hash, Path dir) throws IOException {
 186         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 187                                                    &quot;--patch&quot;,
 188                                                    &quot;--find-renames=50%&quot;,
 189                                                    &quot;--find-copies=50%&quot;,
 190                                                    &quot;--find-copies-harder&quot;,
 191                                                    &quot;--abbrev&quot;,
 192                                                    ref + &quot;...&quot; + hash.hex());
 193         if (dir != null) {
 194             pb.directory(dir.toFile());
 195         }
 196         pb.inheritIO();
 197         await(pb.start());
 198     }
 199 
 200     private static void gimport() throws IOException {
 201         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 202         pb.inheritIO();
 203         await(pb.start());
 204     }
 205 
 206     private static void hgImport(Path patch) throws IOException {
 207         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 208         pb.inheritIO();
 209         await(pb.start());
 210     }
 211 
 212     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 213         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 214         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 215         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 216         var p = pb.start();
 217         var bytes = p.getInputStream().readAllBytes();
 218         var exited = p.waitFor(1, TimeUnit.MINUTES);
 219         var exitValue = p.exitValue();
 220         if (!exited || exitValue != 0) {
 221             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 222         }
 223 
 224         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 225     }
 226 
 227     private static String hgResolve(String ref) throws IOException, InterruptedException {
 228         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 229         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 230         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 231         var p = pb.start();
 232         var bytes = p.getInputStream().readAllBytes();
 233         var exited = p.waitFor(1, TimeUnit.MINUTES);
 234         var exitValue = p.exitValue();
 235         if (!exited || exitValue != 0) {
 236             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 237         }
 238 
 239         return new String(bytes, StandardCharsets.UTF_8);
 240     }
 241 
 242     private static Path diff(String ref, Hash hash) throws IOException {
 243         return diff(ref, hash, null);
 244     }
 245 
 246     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 247         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 248         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 249                                                    &quot;--patch&quot;,
 250                                                    &quot;--find-renames=50%&quot;,
 251                                                    &quot;--find-copies=50%&quot;,
 252                                                    &quot;--find-copies-harder&quot;,
 253                                                    &quot;--abbrev&quot;,
 254                                                    ref + &quot;...&quot; + hash.hex());
 255         if (dir != null) {
 256             pb.directory(dir.toFile());
 257         }
 258         pb.redirectOutput(patch.toFile());
 259         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 260         await(pb.start());
 261         return patch;
 262     }
 263 
 264     private static void apply(Path patch) throws IOException {
 265         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 266         pb.inheritIO();
 267         await(pb.start());
 268     }
 269 
 270     private static int longest(List&lt;String&gt; strings) {
 271         return strings.stream().mapToInt(String::length).max().orElse(0);
 272     }
 273 
 274     public static void main(String[] args) throws IOException, InterruptedException {
 275         var flags = List.of(
 276             Option.shortcut(&quot;u&quot;)
 277                   .fullname(&quot;username&quot;)
 278                   .describe(&quot;NAME&quot;)
 279                   .helptext(&quot;Username on host&quot;)
 280                   .optional(),
 281             Option.shortcut(&quot;r&quot;)
 282                   .fullname(&quot;remote&quot;)
 283                   .describe(&quot;NAME&quot;)
 284                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 285                   .optional(),
 286             Option.shortcut(&quot;b&quot;)
 287                   .fullname(&quot;branch&quot;)
 288                   .describe(&quot;NAME&quot;)
 289                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 290                   .optional(),
 291             Option.shortcut(&quot;&quot;)
 292                   .fullname(&quot;authors&quot;)
 293                   .describe(&quot;LIST&quot;)
 294                   .helptext(&quot;Comma separated list of authors&quot;)
 295                   .optional(),
 296             Option.shortcut(&quot;&quot;)
 297                   .fullname(&quot;assignees&quot;)
 298                   .describe(&quot;LIST&quot;)
 299                   .helptext(&quot;Comma separated list of assignees&quot;)
 300                   .optional(),
 301             Option.shortcut(&quot;&quot;)
 302                   .fullname(&quot;labels&quot;)
 303                   .describe(&quot;LIST&quot;)
 304                   .helptext(&quot;Comma separated list of labels&quot;)
 305                   .optional(),
 306             Option.shortcut(&quot;&quot;)
 307                   .fullname(&quot;columns&quot;)
 308                   .describe(&quot;id,title,author,assignees,labels&quot;)
 309                   .helptext(&quot;Comma separated list of columns to show&quot;)
 310                   .optional(),
 311             Switch.shortcut(&quot;&quot;)
 312                   .fullname(&quot;no-decoration&quot;)
 313                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 314                   .optional(),
 315             Switch.shortcut(&quot;&quot;)
 316                   .fullname(&quot;ignore-workspace&quot;)
 317                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 318                   .optional(),
 319             Switch.shortcut(&quot;&quot;)
 320                   .fullname(&quot;ignore-local-commits&quot;)
 321                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 322                   .optional(),
 323             Switch.shortcut(&quot;&quot;)
 324                   .fullname(&quot;publish&quot;)
 325                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 326                   .optional(),
 327             Switch.shortcut(&quot;&quot;)
 328                   .fullname(&quot;no-token&quot;)
 329                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 330                   .optional(),
 331             Switch.shortcut(&quot;&quot;)
 332                   .fullname(&quot;mercurial&quot;)
 333                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 334                   .optional(),
 335             Switch.shortcut(&quot;&quot;)
 336                   .fullname(&quot;verbose&quot;)
 337                   .helptext(&quot;Turn on verbose output&quot;)
 338                   .optional(),
 339             Switch.shortcut(&quot;&quot;)
 340                   .fullname(&quot;debug&quot;)
 341                   .helptext(&quot;Turn on debugging output&quot;)
 342                   .optional(),
 343             Switch.shortcut(&quot;&quot;)
 344                   .fullname(&quot;version&quot;)
 345                   .helptext(&quot;Print the version of this tool&quot;)
 346                   .optional());
 347 
 348         var inputs = List.of(
 349             Input.position(0)
 350                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
 351                  .singular()
 352                  .required(),
 353             Input.position(1)
 354                  .describe(&quot;ID&quot;)
 355                  .singular()
 356                  .optional()
 357         );
 358 
 359         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 360         var arguments = parser.parse(args);
 361 
 362         if (arguments.contains(&quot;version&quot;)) {
 363             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 364             System.exit(0);
 365         }
 366 
 367         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 368             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 369             Logging.setup(level);
 370         }
 371 
 372         HttpProxy.setup();
 373 
 374         var isMercurial = arguments.contains(&quot;mercurial&quot;);
 375         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 376         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 377         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
 378         var remotePullPath = repo.pullPath(remote);
 379         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
 380         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
 381         var uri = Remote.toWebURI(remotePullPath);
 382         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
 383         var credentials = !shouldUseToken ?
 384             null :
 385             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 386         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 387         var forge = credentials == null ?
 388             Forge.from(forgeURI) :
 389             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 390         if (forge.isEmpty()) {
 391             if (!shouldUseToken) {
 392                 if (arguments.contains(&quot;verbose&quot;)) {
 393                     System.err.println(&quot;&quot;);
 394                 }
 395                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 396                 if (!arguments.contains(&quot;verbose&quot;)) {
 397                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 398                     System.err.println(&quot;&quot;);
 399                 }
 400             }
 401             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 402         }
 403         var host = forge.get();
 404 
 405         var action = arguments.at(0).asString();
 406         if (!shouldUseToken &amp;&amp;
 407             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 408             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 409             System.exit(1);
 410         }
 411 
 412         if (action.equals(&quot;create&quot;)) {
 413             if (isMercurial) {
 414                 var currentBookmark = repo.currentBookmark();
 415                 if (!currentBookmark.isPresent()) {
 416                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 417                     System.err.println(&quot;&quot;);
 418                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 419                     System.err.println(&quot;&quot;);
 420                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 421                     System.err.println(&quot;&quot;);
 422                     System.exit(1);
 423                 }
 424 
 425                 var bookmark = currentBookmark.get();
 426                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 427                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 428                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 429                     System.err.println(&quot;&quot;);
 430                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 431                     System.err.println(&quot;&quot;);
 432                     System.exit(1);
 433                 }
 434 
 435                 var tags = hgTags();
 436                 var upstreams = tags.stream()
 437                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 438                                     .collect(Collectors.toList());
 439                 if (upstreams.isEmpty()) {
 440                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 441                     System.err.println(&quot;&quot;);
 442                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 443                     System.err.println(&quot;&quot;);
 444                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 445                     System.err.println(&quot;&quot;);
 446                     System.exit(1);
 447                 }
 448 
 449                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 450                 for (var tag : tags) {
 451                     tagsAndHashes.put(tag, hgResolve(tag));
 452                 }
 453                 var bookmarkHash = hgResolve(bookmark.name());
 454                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 455                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 456                     System.err.println(&quot;&quot;);
 457 
 458                     if (upstreams.size() == 1) {
 459                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 460                         System.err.println(&quot;&quot;);
 461                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 462                         System.err.println(&quot;&quot;);
 463                     } else {
 464                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 465                         System.err.println(&quot;&quot;);
 466                         for (var upstream : upstreams) {
 467                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 468                         }
 469                         System.err.println(&quot;&quot;);
 470                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 471                         System.err.println(&quot;&quot;);
 472                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 473                         System.err.println(&quot;&quot;);
 474                     }
 475                     System.exit(1);
 476                 }
 477 
 478                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 479                 var targetHash = hgResolve(targetBranch);
 480                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 481                 if (commits.isEmpty()) {
 482                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 483                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 484                     System.exit(1);
 485                 }
 486 
 487                 var diff = repo.diff(repo.head());
 488                 if (!diff.patches().isEmpty()) {
 489                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 490                     System.err.println(&quot;&quot;);
 491                     for (var patch : diff.patches()) {
 492                         var path = patch.target().path().isPresent() ?
 493                             patch.target().path().get() : patch.source().path().get();
 494                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 495                     }
 496                     System.err.println(&quot;&quot;);
 497                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 498                     System.err.println(&quot;&quot;);
 499                     System.err.println(&quot;    hg commit --amend&quot;);
 500                     System.err.println(&quot;    hg git-cleanup&quot;);
 501                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 502                     System.err.println(&quot;    hg gimport&quot;);
 503                     System.err.println(&quot;&quot;);
 504                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 505                     System.err.println(&quot;&quot;);
 506                     System.err.println(&quot;    hg shelve&quot;);
 507                     System.err.println(&quot;&quot;);
 508                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 509                     System.exit(1);
 510                 }
 511 
 512                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 513                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 514                 );
 515                 if (token == null) {
 516                     GitCredentials.approve(credentials);
 517                 }
 518                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 519                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 520 
 521                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 522                 if (commits.size() == 1) {
 523                     var commit = commits.get(0);
 524                     var message = CommitMessageParsers.v1.parse(commit.message());
 525                     Files.writeString(file, message.title() + &quot;\n&quot;);
 526                     if (!message.summaries().isEmpty()) {
 527                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 528                     }
 529                     if (!message.additional().isEmpty()) {
 530                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 531                     }
 532                 } else {
 533                     Files.write(file, List.of(&quot;&quot;));
 534                 }
 535                 Files.write(file, List.of(
 536                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 537                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 538                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 539                     &quot;# the subject from the body.&quot;,
 540                     &quot;#&quot;,
 541                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 542                     ),
 543                     StandardOpenOption.APPEND
 544                 );
 545                 for (var commit : commits) {
 546                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 547                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 548                 }
 549                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 550                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 551                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 552                 var success = spawnEditor(repo, file);
 553                 if (!success) {
 554                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 555                     System.exit(1);
 556                 }
 557                 var lines = Files.readAllLines(file)
 558                                  .stream()
 559                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 560                                  .collect(Collectors.toList());
 561                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 562                 if (isEmpty) {
 563                     System.err.println(&quot;error: no message present, aborting&quot;);
 564                     System.exit(1);
 565                 }
 566 
 567                 var title = lines.get(0);
 568                 List&lt;String&gt; body = null;
 569                 if (lines.size() &gt; 1) {
 570                     body = lines.subList(1, lines.size())
 571                                 .stream()
 572                                 .dropWhile(String::isEmpty)
 573                                 .collect(Collectors.toList());
 574                 } else {
 575                     body = Collections.emptyList();
 576                 }
 577 
 578                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 579                 if (arguments.contains(&quot;assignees&quot;)) {
 580                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 581                     var assignees = usernames.stream()
 582                                              .map(u -&gt; host.user(u))
 583                                              .collect(Collectors.toList());
 584                     pr.setAssignees(assignees);
 585                 }
 586                 System.out.println(pr.webUrl().toString());
 587                 Files.deleteIfExists(file);
 588 
 589                 System.exit(0);
 590             }
 591             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 592                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 593                     System.exit(1);
 594                     return null;
 595             });
 596             if (currentBranch.equals(repo.defaultBranch())) {
 597                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 598                 System.err.println(&quot;&quot;);
 599                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 600                 System.err.println(&quot;&quot;);
 601                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 602                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 603                 System.err.println(&quot;&quot;);
 604                 System.exit(1);
 605             }
 606 
 607             var ignoreWorkspace = arguments.contains(&quot;ignore-workspace&quot;);
 608             if (!ignoreWorkspace) {
 609                 var lines = repo.config(&quot;pr.ignore-workspace&quot;);
 610                 ignoreWorkspace = lines.size() == 1 &amp;&amp; lines.get(0).equals(&quot;true&quot;);
 611             }
 612             if (!ignoreWorkspace) {
 613                 var diff = repo.diff(repo.head());
 614                 if (!diff.patches().isEmpty()) {
 615                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 616                     System.err.println(&quot;&quot;);
 617                     for (var patch : diff.patches()) {
 618                         var path = patch.target().path().isPresent() ?
 619                             patch.target().path().get() : patch.source().path().get();
 620                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 621                     }
 622                     System.err.println(&quot;&quot;);
 623                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 624                     System.err.println(&quot;&quot;);
 625                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 626                     System.err.println(&quot;&quot;);
 627                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 628                     System.err.println(&quot;&quot;);
 629                     System.err.println(&quot;    git stash&quot;);
 630                     System.err.println(&quot;&quot;);
 631                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 632                     System.exit(1);
 633                 }
 634             }
 635 
 636             var upstream = repo.upstreamFor(currentBranch);
 637             if (upstream.isEmpty()) {
 638                 var shouldPublish = arguments.contains(&quot;publish&quot;);
 639                 if (!shouldPublish) {
 640                     var lines = repo.config(&quot;pr.publish&quot;);
 641                     shouldPublish = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
 642                 }
 643                 if (shouldPublish) {
 644                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 645                     upstream = repo.upstreamFor(currentBranch);
 646                 } else {
 647                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 648                     System.err.println(&quot;&quot;);
 649                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 650                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 651                     System.err.println(&quot;&quot;);
 652                     System.err.println(&quot;    git publish&quot;);
 653                     System.err.println(&quot;&quot;);
 654                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 655                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 656                     System.err.println(&quot;&quot;);
 657                     System.err.println(&quot;    git fetch &quot; + remote);
 658                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 659                     System.err.println(&quot;&quot;);
 660                     System.exit(1);
 661                 }
 662             }
 663 
 664             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 665             repo.fetch(uri, upstreamRefName);
 666 
 667             var shouldIgnoreLocalCommits = arguments.contains(&quot;ignore-local-commits&quot;);
 668             if (!shouldIgnoreLocalCommits) {
 669                 var lines = repo.config(&quot;pr.ignore-local-commits&quot;);
 670                 shouldIgnoreLocalCommits = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
 671             }
 672             if (!shouldIgnoreLocalCommits) {
 673                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 674                 if (!branchCommits.isEmpty()) {
 675                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 676                     System.err.println(&quot;&quot;);
 677                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 678                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 679                     System.err.println(&quot;&quot;);
 680                     for (var commit : branchCommits) {
 681                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 682                     }
 683                     System.err.println(&quot;&quot;);
 684                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 685                     System.err.println(&quot;&quot;);
 686                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 687                     System.err.println(&quot;&quot;);
 688                     System.exit(1);
 689                 }
 690             }
 691 
 692             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 693             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 694             if (commits.isEmpty()) {
 695                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 696                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 697                 System.exit(1);
 698             }
 699 
 700             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 701                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 702             );
 703             if (token == null) {
 704                 GitCredentials.approve(credentials);
 705             }
 706             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 707                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 708 
 709             var project = jbsProjectFromJcheckConf(repo);
 710             var issue = getIssue(currentBranch, project);
 711             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 712             if (issue.isPresent()) {
 713                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 714             } else if (commits.size() == 1) {
 715                 var commit = commits.get(0);
 716                 issue = getIssue(commit, project);
 717                 if (issue.isPresent()) {
 718                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 719                 } else {
 720                     var message = CommitMessageParsers.v1.parse(commit.message());
 721                     Files.writeString(file, message.title() + &quot;\n&quot;);
 722                     if (!message.summaries().isEmpty()) {
 723                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 724                     }
 725                     if (!message.additional().isEmpty()) {
 726                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 727                     }
 728                 }
 729             } else {
 730                 Files.write(file, List.of(&quot;&quot;));
 731             }
 732             Files.write(file, List.of(
 733                 &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 734                 &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 735                 &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 736                 &quot;# the subject from the body.&quot;,
 737                 &quot;#&quot;,
 738                 &quot;# Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;
 739                 ),
 740                 StandardOpenOption.APPEND
 741             );
 742             for (var commit : commits) {
 743                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 744                 Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 745             }
 746             Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 747             Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 748             Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 749             var success = spawnEditor(repo, file);
 750             if (!success) {
 751                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 752                 System.exit(1);
 753             }
 754             var lines = Files.readAllLines(file)
 755                              .stream()
 756                              .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 757                              .collect(Collectors.toList());
 758             var isEmpty = lines.stream().allMatch(String::isEmpty);
 759             if (isEmpty) {
 760                 System.err.println(&quot;error: no message present, aborting&quot;);
 761                 System.exit(1);
 762             }
 763 
 764             var title = lines.get(0);
 765             List&lt;String&gt; body = null;
 766             if (lines.size() &gt; 1) {
 767                 body = lines.subList(1, lines.size())
 768                             .stream()
 769                             .dropWhile(String::isEmpty)
 770                             .collect(Collectors.toList());
 771             } else {
 772                 body = Collections.emptyList();
 773             }
 774 
 775             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 776             if (arguments.contains(&quot;assignees&quot;)) {
 777                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 778                 var assignees = usernames.stream()
 779                                          .map(u -&gt; host.user(u))
 780                                          .collect(Collectors.toList());
 781                 pr.setAssignees(assignees);
 782             }
 783             System.out.println(pr.webUrl().toString());
 784             Files.deleteIfExists(file);
 785 
 786             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
 787         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
 788             String id = null;
<a name="1" id="anc1"></a><span class="line-modified"> 789             if (arguments.at(0).isPresent()) {</span>
<span class="line-modified"> 790                 id = arguments.at(0).asString();</span>
 791             } else {
 792                 if (action.equals(&quot;approve&quot;)) {
 793                     exit(&quot;error: you must provide a pull request id&quot;);
 794                 } else {
 795                     var currentBranch = repo.currentBranch();
 796                     if (currentBranch.isPresent()) {
 797                         var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 798                         if (lines.size() == 1) {
 799                             id = lines.get(0);
 800                         } else {
 801                             exit(&quot;error: you must provide a pull request id&quot;);
 802                         }
 803                     }
 804                 }
 805             }
 806 
 807             var pr = getPullRequest(uri, repo, host, id);
 808 
 809             if (action.equals(&quot;integrate&quot;)) {
 810                 pr.addComment(&quot;/integrate&quot;);
 811             } else if (action.equals(&quot;test&quot;)) {
 812                 pr.addComment(&quot;/test&quot;);
 813             } else if (action.equals(&quot;approve&quot;)) {
 814                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
 815             } else {
 816                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
 817             }
 818         } else if (action.equals(&quot;list&quot;)) {
 819             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 820             var prs = remoteRepo.pullRequests();
 821             var ids = new ArrayList&lt;String&gt;();
 822             var titles = new ArrayList&lt;String&gt;();
 823             var authors = new ArrayList&lt;String&gt;();
 824             var assignees = new ArrayList&lt;String&gt;();
 825             var labels = new ArrayList&lt;String&gt;();
 826 
 827             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
 828                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
 829                 Set.of();
 830             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
 831                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
 832                 Set.of();
 833             var filterLabels = arguments.contains(&quot;labels&quot;) ?
 834                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
 835                 Set.of();
 836 
 837             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
 838             var columnValues = Map.of(defaultColumns.get(0), ids,
 839                                       defaultColumns.get(1), titles,
 840                                       defaultColumns.get(2), authors,
 841                                       defaultColumns.get(3), assignees,
 842                                       defaultColumns.get(4), labels);
 843             var columns = arguments.contains(&quot;columns&quot;) ?
 844                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
 845                 defaultColumns;
 846             if (columns != defaultColumns) {
 847                 for (var column : columns) {
 848                     if (!defaultColumns.contains(column)) {
 849                         System.err.println(&quot;error: unknown column: &quot; + column);
 850                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
 851                         System.exit(1);
 852                     }
 853                 }
 854             }
 855 
 856             for (var pr : prs) {
 857                 var prAuthor = pr.author().userName();
 858                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
 859                     continue;
 860                 }
 861 
 862                 var prAssignees = pr.assignees().stream()
 863                                     .map(HostUser::userName)
 864                                     .collect(Collectors.toSet());
 865                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
 866                     continue;
 867                 }
 868 
 869                 var prLabels = new HashSet&lt;&gt;(pr.labels());
 870                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
 871                     continue;
 872                 }
 873 
 874                 ids.add(pr.id());
 875                 titles.add(pr.title());
 876                 authors.add(prAuthor);
 877                 assignees.add(String.join(&quot;,&quot;, prAssignees));
 878                 labels.add(String.join(&quot;,&quot;, prLabels));
 879             }
 880 
 881 
 882             String fmt = &quot;&quot;;
 883             for (var column : columns.subList(0, columns.size() - 1)) {
 884                 var values = columnValues.get(column);
 885                 var n = Math.max(column.length(), longest(values));
 886                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
 887             }
 888             fmt += &quot;%s\n&quot;;
 889 
 890             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
 891                 var upperCase = columns.stream()
 892                                        .map(String::toUpperCase)
 893                                        .collect(Collectors.toList());
 894                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
 895             }
 896             for (var i = 0; i &lt; ids.size(); i++) {
 897                 final int n = i;
 898                 var row = columns.stream()
 899                                  .map(columnValues::get)
 900                                  .map(values -&gt; values.get(n))
 901                                  .collect(Collectors.toList());
 902                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
 903             }
 904         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
 905             var prId = arguments.at(1);
 906             if (!prId.isPresent()) {
 907                 exit(&quot;error: missing pull request identifier&quot;);
 908             }
 909 
 910             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 911             var pr = remoteRepo.pullRequest(prId.asString());
 912             var repoUrl = remoteRepo.webUrl();
 913             var prHeadRef = pr.sourceRef();
 914             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
 915             if (isHgGit) {
 916                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
 917                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
 918 
 919                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
 920                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
 921                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
 922 
 923                     if (action.equals(&quot;show&quot;)) {
 924                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
 925                     } else {
 926                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
 927                         hgImport(patch);
 928                         Files.delete(patch);
 929                     }
 930                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
 931                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
 932                     var hgGitBranches = hgGitRepo.branches();
 933                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
 934                         hgGitRepo.delete(new Branch(hgGitRef));
 935                     }
 936                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
 937                     gimport();
 938                     var hgFetchHead = repo.resolve(hgGitRef).get();
 939 
 940                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
 941                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
 942                     } else if (action.equals(&quot;checkout&quot;)) {
 943                         repo.checkout(hgFetchHead);
 944                         if (arguments.contains(&quot;branch&quot;)) {
 945                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
 946                         }
 947                     }
 948                 } else {
 949                     exit(&quot;Unexpected action: &quot; + action);
 950                 }
 951 
 952                 return;
 953             }
 954 
 955             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
 956             if (action.equals(&quot;fetch&quot;)) {
 957                 if (arguments.contains(&quot;branch&quot;)) {
 958                     var branchName = arguments.get(&quot;branch&quot;).asString();
 959                     repo.branch(fetchHead, branchName);
 960                 } else {
 961                     System.out.println(fetchHead.hex());
 962                 }
 963             } else if (action.equals(&quot;checkout&quot;)) {
 964                 if (arguments.contains(&quot;branch&quot;)) {
 965                     var branchName = arguments.get(&quot;branch&quot;).asString();
 966                     var branch = repo.branch(fetchHead, branchName);
 967                     repo.checkout(branch, false);
 968                 } else {
 969                     repo.checkout(fetchHead, false);
 970                 }
 971             } else if (action.equals(&quot;show&quot;)) {
 972                 show(pr.targetRef(), fetchHead);
 973             } else if (action.equals(&quot;apply&quot;)) {
 974                 var patch = diff(pr.targetRef(), fetchHead);
 975                 apply(patch);
 976                 Files.deleteIfExists(patch);
 977             }
 978         } else if (action.equals(&quot;close&quot;)) {
 979             var prId = arguments.at(1);
 980             if (!prId.isPresent()) {
 981                 exit(&quot;error: missing pull request identifier&quot;);
 982             }
 983 
 984             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 985             var pr = remoteRepo.pullRequest(prId.asString());
 986             pr.setState(PullRequest.State.CLOSED);
 987         } else if (action.equals(&quot;update&quot;)) {
 988             var prId = arguments.at(1);
 989             if (!prId.isPresent()) {
 990                 exit(&quot;error: missing pull request identifier&quot;);
 991             }
 992 
 993             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 994             var pr = remoteRepo.pullRequest(prId.asString());
 995             if (arguments.contains(&quot;assignees&quot;)) {
 996                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 997                 var assignees = usernames.stream()
 998                     .map(u -&gt; host.user(u))
 999                     .collect(Collectors.toList());
1000                 pr.setAssignees(assignees);
1001             }
1002         } else {
1003             exit(&quot;error: unexpected action: &quot; + action);
1004         }
1005     }
1006 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>