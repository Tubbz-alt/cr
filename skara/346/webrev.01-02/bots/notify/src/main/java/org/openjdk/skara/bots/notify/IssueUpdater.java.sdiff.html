<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93     }
 94 
 95     private boolean isNonScratchVersion(String version) {
 96         return !version.startsWith(&quot;tbd&quot;) &amp;&amp; !version.toLowerCase().equals(&quot;unknown&quot;);
 97     }
 98 
 99     /**
100      * Return true if the issue&#39;s fixVersionList matches fixVersion.
101      *
102      * fixVersionsList must contain one entry that is an exact match for fixVersions; any
103      * other entries must be scratch values.
104      */
105     private boolean matchVersion(Issue issue, String fixVersion) {
106         var nonScratch = issue.fixVersions().stream()
107                               .filter(this::isNonScratchVersion)
108                               .collect(Collectors.toList());
109         return nonScratch.size() == 1 &amp;&amp; nonScratch.get(0).equals(fixVersion);
110     }
111 
112     /**
<span class="line-modified">113      * Return True if the issue&#39;s fixVersionList is a match for fixVersion, using &quot;-pool&quot; or &quot;-open&quot;.</span>
114      *
115      * If fixVersion has a major release of &lt;N&gt;, it matches the fixVersionList has an
116      * &lt;N&gt;-pool or &lt;N&gt;-open entry and all other entries are scratch values.
117      */
118     private boolean matchPoolVersion(Issue issue, String fixVersion) {
119         var majorVersion = majorVersion(fixVersion);
120         if (majorVersion.isEmpty()) {
121             return false;
122         }
123         var poolVersion = majorVersion.get() + &quot;-pool&quot;;
124         var openVersion = majorVersion.get() + &quot;-open&quot;;
125 
126         var nonScratch = issue.fixVersions().stream()
127                               .filter(this::isNonScratchVersion)
128                               .collect(Collectors.toList());
129         return nonScratch.size() == 1 &amp;&amp; (nonScratch.get(0).equals(poolVersion) || nonScratch.get(0).equals(openVersion));
130     }
131 
132     /**
<span class="line-modified">133      * Return True if fixVersionList is empty or contains only scratch values.</span>
134      */
135     private boolean matchScratchVersion(Issue issue) {
136         var nonScratch = issue.fixVersions().stream()
137                               .filter(this::isNonScratchVersion)
138                               .collect(Collectors.toList());
139         return nonScratch.size() == 0;
140     }
141 
142     /**
143      * Create a backport of issue.
144      */
145     private Issue createBackportIssue(Issue primary) {
146         var properties = primary.properties();
147         properties.put(&quot;type&quot;, &quot;Backport&quot;);
148 
149         var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), properties);
150 
151         var backportLink = Link.create(backport, &quot;backported by&quot;).build();
152         primary.addLink(backportLink);;
153         return backport;
154     }
155 
156     /**
<span class="line-modified">157      * Return issue or one of its backports that applies to fixver.</span>
158      *
159      * If the main issue       has the correct fixVersion, use it.
160      * If an existing Backport has the correct fixVersion, use it.
<span class="line-modified">161      * If the main issue       has a matching &lt;N&gt;-pool fixVersion, use it.</span>
<span class="line-modified">162      * If an existing Backport has a matching &lt;N&gt;-pool fixVersion, use it.</span>
163      * If the main issue       has a &quot;scratch&quot; fixVersion, use it.
164      * If an existing Backport has a &quot;scratch&quot; fixVersion, use it.
165      *
166      * Otherwise, create a new Backport.
167      *
168      * A &quot;scratch&quot; fixVersion is empty, &quot;tbd.*&quot;, or &quot;unknown&quot;.
169      */
170     private Issue findIssue(Issue primary, String fixVersion) {
171         log.info(&quot;Searching for properly versioned issue for primary issue &quot; + primary.id());
172         var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
173         candidates.forEach(c -&gt; log.fine(&quot;Candidate: &quot; + c.id() + &quot; with versions: &quot; + String.join(&quot;,&quot;, c.fixVersions())));
174         var matchingVersionIssue = candidates.stream()
175                 .filter(i -&gt; matchVersion(i, fixVersion))
176                 .findFirst();
177         if (matchingVersionIssue.isPresent()) {
178             log.info(&quot;Issue &quot; + matchingVersionIssue.get().id() + &quot; has a correct fixVersion&quot;);
179             return matchingVersionIssue.get();
180         }
181 
182         var matchingPoolVersionIssue = candidates.stream()
</pre>
<hr />
<pre>
247                 var alreadyPostedComment = existingComments.stream()
248                                                            .filter(comment -&gt; comment.author().equals(issueProject.issueTracker().currentUser()))
249                                                            .anyMatch(comment -&gt; comment.body().contains(hashUrl));
250                 if (!alreadyPostedComment) {
251                     issue.addComment(commitNotification);
252                 }
253                 issue.setState(Issue.State.RESOLVED);
254 
255                 if (commitLink) {
256                     var linkBuilder = Link.create(repository.webUrl(commit.hash()), &quot;Commit&quot;)
257                                           .summary(repository.name() + &quot;/&quot; + commit.hash().abbreviate());
258                     if (commitIcon != null) {
259                         linkBuilder.iconTitle(&quot;Commit&quot;);
260                         linkBuilder.iconUrl(commitIcon);
261                     }
262                     issue.addLink(linkBuilder.build());
263                 }
264 
265                 if (setFixVersion) {
266                     if (requestedVersion != null) {

267                         for (var oldVersion : issue.fixVersions()) {
268                             issue.removeFixVersion(oldVersion);
269                         }
270                         issue.addFixVersion(requestedVersion);
271                     }
272                 }
273             }
274         }
275     }
276 
277     @Override
278     public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List&lt;Commit&gt; commits, OpenJDKTag tag, Tag.Annotated annotated) {
279 
280     }
281 
282     @Override
283     public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
284 
285     }
286 
</pre>
</td>
<td>
<hr />
<pre>
 93     }
 94 
 95     private boolean isNonScratchVersion(String version) {
 96         return !version.startsWith(&quot;tbd&quot;) &amp;&amp; !version.toLowerCase().equals(&quot;unknown&quot;);
 97     }
 98 
 99     /**
100      * Return true if the issue&#39;s fixVersionList matches fixVersion.
101      *
102      * fixVersionsList must contain one entry that is an exact match for fixVersions; any
103      * other entries must be scratch values.
104      */
105     private boolean matchVersion(Issue issue, String fixVersion) {
106         var nonScratch = issue.fixVersions().stream()
107                               .filter(this::isNonScratchVersion)
108                               .collect(Collectors.toList());
109         return nonScratch.size() == 1 &amp;&amp; nonScratch.get(0).equals(fixVersion);
110     }
111 
112     /**
<span class="line-modified">113      * Return true if the issue&#39;s fixVersionList is a match for fixVersion, using &quot;-pool&quot; or &quot;-open&quot;.</span>
114      *
115      * If fixVersion has a major release of &lt;N&gt;, it matches the fixVersionList has an
116      * &lt;N&gt;-pool or &lt;N&gt;-open entry and all other entries are scratch values.
117      */
118     private boolean matchPoolVersion(Issue issue, String fixVersion) {
119         var majorVersion = majorVersion(fixVersion);
120         if (majorVersion.isEmpty()) {
121             return false;
122         }
123         var poolVersion = majorVersion.get() + &quot;-pool&quot;;
124         var openVersion = majorVersion.get() + &quot;-open&quot;;
125 
126         var nonScratch = issue.fixVersions().stream()
127                               .filter(this::isNonScratchVersion)
128                               .collect(Collectors.toList());
129         return nonScratch.size() == 1 &amp;&amp; (nonScratch.get(0).equals(poolVersion) || nonScratch.get(0).equals(openVersion));
130     }
131 
132     /**
<span class="line-modified">133      * Return true if fixVersionList is empty or contains only scratch values.</span>
134      */
135     private boolean matchScratchVersion(Issue issue) {
136         var nonScratch = issue.fixVersions().stream()
137                               .filter(this::isNonScratchVersion)
138                               .collect(Collectors.toList());
139         return nonScratch.size() == 0;
140     }
141 
142     /**
143      * Create a backport of issue.
144      */
145     private Issue createBackportIssue(Issue primary) {
146         var properties = primary.properties();
147         properties.put(&quot;type&quot;, &quot;Backport&quot;);
148 
149         var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), properties);
150 
151         var backportLink = Link.create(backport, &quot;backported by&quot;).build();
152         primary.addLink(backportLink);;
153         return backport;
154     }
155 
156     /**
<span class="line-modified">157      * Return issue or one of its backports that applies to fixVersion.</span>
158      *
159      * If the main issue       has the correct fixVersion, use it.
160      * If an existing Backport has the correct fixVersion, use it.
<span class="line-modified">161      * If the main issue       has a matching &lt;N&gt;-pool/open fixVersion, use it.</span>
<span class="line-modified">162      * If an existing Backport has a matching &lt;N&gt;-pool/open fixVersion, use it.</span>
163      * If the main issue       has a &quot;scratch&quot; fixVersion, use it.
164      * If an existing Backport has a &quot;scratch&quot; fixVersion, use it.
165      *
166      * Otherwise, create a new Backport.
167      *
168      * A &quot;scratch&quot; fixVersion is empty, &quot;tbd.*&quot;, or &quot;unknown&quot;.
169      */
170     private Issue findIssue(Issue primary, String fixVersion) {
171         log.info(&quot;Searching for properly versioned issue for primary issue &quot; + primary.id());
172         var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
173         candidates.forEach(c -&gt; log.fine(&quot;Candidate: &quot; + c.id() + &quot; with versions: &quot; + String.join(&quot;,&quot;, c.fixVersions())));
174         var matchingVersionIssue = candidates.stream()
175                 .filter(i -&gt; matchVersion(i, fixVersion))
176                 .findFirst();
177         if (matchingVersionIssue.isPresent()) {
178             log.info(&quot;Issue &quot; + matchingVersionIssue.get().id() + &quot; has a correct fixVersion&quot;);
179             return matchingVersionIssue.get();
180         }
181 
182         var matchingPoolVersionIssue = candidates.stream()
</pre>
<hr />
<pre>
247                 var alreadyPostedComment = existingComments.stream()
248                                                            .filter(comment -&gt; comment.author().equals(issueProject.issueTracker().currentUser()))
249                                                            .anyMatch(comment -&gt; comment.body().contains(hashUrl));
250                 if (!alreadyPostedComment) {
251                     issue.addComment(commitNotification);
252                 }
253                 issue.setState(Issue.State.RESOLVED);
254 
255                 if (commitLink) {
256                     var linkBuilder = Link.create(repository.webUrl(commit.hash()), &quot;Commit&quot;)
257                                           .summary(repository.name() + &quot;/&quot; + commit.hash().abbreviate());
258                     if (commitIcon != null) {
259                         linkBuilder.iconTitle(&quot;Commit&quot;);
260                         linkBuilder.iconUrl(commitIcon);
261                     }
262                     issue.addLink(linkBuilder.build());
263                 }
264 
265                 if (setFixVersion) {
266                     if (requestedVersion != null) {
<span class="line-added">267                         // Remove any previously set versions (can only be scratch versions)</span>
268                         for (var oldVersion : issue.fixVersions()) {
269                             issue.removeFixVersion(oldVersion);
270                         }
271                         issue.addFixVersion(requestedVersion);
272                     }
273                 }
274             }
275         }
276     }
277 
278     @Override
279     public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List&lt;Commit&gt; commits, OpenJDKTag tag, Tag.Annotated annotated) {
280 
281     }
282 
283     @Override
284     public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
285 
286     }
287 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>