<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 
  35 import java.io.IOException;
  36 import java.net.URI;
  37 import java.nio.charset.StandardCharsets;
  38 import java.nio.file.*;
  39 import java.util.*;
  40 import java.util.regex.Pattern;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.function.Supplier;
  43 import java.util.logging.Level;
  44 import java.util.stream.Collectors;
  45 
  46 public class GitPr {
  47     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;
  48 
  49     private static void exit(String fmt, Object...args) {
  50         System.err.println(String.format(fmt, args));
  51         System.exit(1);
  52     }
  53 
  54     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  55         return () -&gt; {
  56             exit(fmt, args);
  57             return null;
  58         };
  59     }
  60 
  61     private static String rightPad(String s, int length) {
  62         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
  63     }
  64 
  65     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
  66         var end = &quot; --&gt;&quot;;
  67         var pad = 79 - end.length();
  68         var newLine = &quot;\n&quot;;
  69         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
  70     }
  71 
  72     private static String format(Issue issue) {
  73         var parts = issue.id().split(&quot;-&quot;);
  74         var id = parts.length == 2 ? parts[1] : issue.id();
  75         return id + &quot;: &quot; + issue.title();
  76     }
  77 
  78     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
  79         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
  80             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
  81         ));
  82 
  83         return conf.general().jbs();
  84     }
  85 
  86     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
  87         var message = CommitMessageParsers.v1.parse(commit.message());
  88         var issues = message.issues();
  89         if (issues.isEmpty()) {
  90             return getIssue(message.title(), project);
  91         } else if (issues.size() == 1) {
  92             var issue = issues.get(0);
  93             return getIssue(issue.id(), project);
  94         }
  95         return Optional.empty();
  96     }
  97 
  98     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
  99         return getIssue(b.name(), project);
 100     }
 101 
 102     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 103         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
 104         var m = issueIdPattern.matcher(s);
 105         if (m.matches()) {
 106             var id = m.group(2);
 107             if (project == null) {
 108                 project = m.group(1);
 109             }
 110             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 111             return issueTracker.project(project).issue(id);
 112         }
 113 
 114         return Optional.empty();
 115     }
 116 
 117     private static void await(Process p) throws IOException {
 118         try {
 119             var res = p.waitFor();
 120             if (res != 0) {
 121                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 122             }
 123         } catch (InterruptedException e) {
 124             throw new IOException(e);
 125         }
 126     }
 127 
 128     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 129         String editor = null;
 130         var lines = repo.config(&quot;core.editor&quot;);
 131         if (lines.size() == 1) {
 132             editor = lines.get(0);
 133         }
 134         if (editor == null) {
 135             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 136         }
 137         if (editor == null) {
 138             editor = System.getenv(&quot;EDITOR&quot;);
 139         }
 140         if (editor == null) {
 141             editor = System.getenv(&quot;VISUAL&quot;);
 142         }
 143         if (editor == null) {
 144             editor = &quot;vi&quot;;
 145         }
 146 
 147         var pb = new ProcessBuilder(editor, file.toString());
 148         pb.inheritIO();
 149         var p = pb.start();
 150         try {
 151             return p.waitFor() == 0;
 152         } catch (InterruptedException e) {
 153             throw new IOException(e);
 154         }
 155     }
 156 
 157     private static String projectName(URI uri) {
 158         var name = uri.getPath().toString().substring(1);
 159         if (name.endsWith(&quot;.git&quot;)) {
 160             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 161         }
 162         return name;
 163     }
 164 
 165     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 166         HostedRepository targetRepo = null;
 167 
 168         try {
 169             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 170             targetRepo = host.repository(projectName(upstream)).orElse(null);
 171         } catch (IOException e) {
 172             // do nothing
 173         }
 174 
 175         if (targetRepo == null) {
 176             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 177                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 178             );
 179             var parentRepo = remoteRepo.parent();
 180             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 181         }
 182 
 183         return targetRepo;
 184     }
 185 
 186     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 187         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 188         if (pr == null) {
 189             exit(&quot;error: could not fetch PR information&quot;);
 190         }
 191 
 192         return pr;
 193     }
 194 
 195     private static void show(String ref, Hash hash) throws IOException {
 196         show(ref, hash, null);
 197     }
 198     private static void show(String ref, Hash hash, Path dir) throws IOException {
 199         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 200                                                    &quot;--patch&quot;,
 201                                                    &quot;--find-renames=50%&quot;,
 202                                                    &quot;--find-copies=50%&quot;,
 203                                                    &quot;--find-copies-harder&quot;,
 204                                                    &quot;--abbrev&quot;,
 205                                                    ref + &quot;...&quot; + hash.hex());
 206         if (dir != null) {
 207             pb.directory(dir.toFile());
 208         }
 209         pb.inheritIO();
 210         await(pb.start());
 211     }
 212 
 213     private static void gimport() throws IOException {
 214         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 215         pb.inheritIO();
 216         await(pb.start());
 217     }
 218 
 219     private static void hgImport(Path patch) throws IOException {
 220         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 221         pb.inheritIO();
 222         await(pb.start());
 223     }
 224 
 225     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 226         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 227         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 228         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 229         var p = pb.start();
 230         var bytes = p.getInputStream().readAllBytes();
 231         var exited = p.waitFor(1, TimeUnit.MINUTES);
 232         var exitValue = p.exitValue();
 233         if (!exited || exitValue != 0) {
 234             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 235         }
 236 
 237         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 238     }
 239 
 240     private static String hgResolve(String ref) throws IOException, InterruptedException {
 241         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 242         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 243         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 244         var p = pb.start();
 245         var bytes = p.getInputStream().readAllBytes();
 246         var exited = p.waitFor(1, TimeUnit.MINUTES);
 247         var exitValue = p.exitValue();
 248         if (!exited || exitValue != 0) {
 249             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 250         }
 251 
 252         return new String(bytes, StandardCharsets.UTF_8);
 253     }
 254 
 255     private static Path diff(String ref, Hash hash) throws IOException {
 256         return diff(ref, hash, null);
 257     }
 258 
 259     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 260         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 261         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 262                                                    &quot;--patch&quot;,
 263                                                    &quot;--find-renames=50%&quot;,
 264                                                    &quot;--find-copies=50%&quot;,
 265                                                    &quot;--find-copies-harder&quot;,
 266                                                    &quot;--abbrev&quot;,
 267                                                    ref + &quot;...&quot; + hash.hex());
 268         if (dir != null) {
 269             pb.directory(dir.toFile());
 270         }
 271         pb.redirectOutput(patch.toFile());
 272         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 273         await(pb.start());
 274         return patch;
 275     }
 276 
 277     private static void apply(Path patch) throws IOException {
 278         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 279         pb.inheritIO();
 280         await(pb.start());
 281     }
 282 
 283     private static int longest(List&lt;String&gt; strings) {
 284         return strings.stream().mapToInt(String::length).max().orElse(0);
 285     }
 286 
 287     public static void main(String[] args) throws IOException, InterruptedException {
 288         var flags = List.of(
 289             Option.shortcut(&quot;u&quot;)
 290                   .fullname(&quot;username&quot;)
 291                   .describe(&quot;NAME&quot;)
 292                   .helptext(&quot;Username on host&quot;)
 293                   .optional(),
 294             Option.shortcut(&quot;r&quot;)
 295                   .fullname(&quot;remote&quot;)
 296                   .describe(&quot;NAME&quot;)
 297                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 298                   .optional(),
 299             Option.shortcut(&quot;b&quot;)
 300                   .fullname(&quot;branch&quot;)
 301                   .describe(&quot;NAME&quot;)
 302                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 303                   .optional(),
 304             Option.shortcut(&quot;&quot;)
 305                   .fullname(&quot;authors&quot;)
 306                   .describe(&quot;LIST&quot;)
 307                   .helptext(&quot;Comma separated list of authors&quot;)
 308                   .optional(),
 309             Option.shortcut(&quot;&quot;)
 310                   .fullname(&quot;assignees&quot;)
 311                   .describe(&quot;LIST&quot;)
 312                   .helptext(&quot;Comma separated list of assignees&quot;)
 313                   .optional(),
 314             Option.shortcut(&quot;&quot;)
 315                   .fullname(&quot;labels&quot;)
 316                   .describe(&quot;LIST&quot;)
 317                   .helptext(&quot;Comma separated list of labels&quot;)
 318                   .optional(),
 319             Option.shortcut(&quot;&quot;)
 320                   .fullname(&quot;columns&quot;)
 321                   .describe(&quot;id,title,author,assignees,labels&quot;)
 322                   .helptext(&quot;Comma separated list of columns to show&quot;)
 323                   .optional(),
 324             Switch.shortcut(&quot;&quot;)
 325                   .fullname(&quot;no-decoration&quot;)
 326                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 327                   .optional(),
 328             Switch.shortcut(&quot;&quot;)
 329                   .fullname(&quot;ignore-workspace&quot;)
 330                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 331                   .optional(),
 332             Switch.shortcut(&quot;&quot;)
 333                   .fullname(&quot;ignore-local-commits&quot;)
 334                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 335                   .optional(),
 336             Switch.shortcut(&quot;&quot;)
 337                   .fullname(&quot;publish&quot;)
 338                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 339                   .optional(),
 340             Switch.shortcut(&quot;&quot;)
 341                   .fullname(&quot;jcheck&quot;)
 342                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 343                   .optional(),
 344             Switch.shortcut(&quot;&quot;)
 345                   .fullname(&quot;no-token&quot;)
 346                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 347                   .optional(),
 348             Switch.shortcut(&quot;&quot;)
 349                   .fullname(&quot;mercurial&quot;)
 350                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 351                   .optional(),
 352             Switch.shortcut(&quot;&quot;)
 353                   .fullname(&quot;verbose&quot;)
 354                   .helptext(&quot;Turn on verbose output&quot;)
 355                   .optional(),
 356             Switch.shortcut(&quot;&quot;)
 357                   .fullname(&quot;debug&quot;)
 358                   .helptext(&quot;Turn on debugging output&quot;)
 359                   .optional(),
 360             Switch.shortcut(&quot;&quot;)
 361                   .fullname(&quot;version&quot;)
 362                   .helptext(&quot;Print the version of this tool&quot;)
 363                   .optional());
 364 
 365         var inputs = List.of(
 366             Input.position(0)
 367                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
 368                  .singular()
<a name="1" id="anc1"></a><span class="line-modified"> 369                  .required(),</span>
 370             Input.position(1)
 371                  .describe(&quot;ID&quot;)
 372                  .singular()
 373                  .optional()
 374         );
 375 
 376         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 377         var arguments = parser.parse(args);
 378 
 379         if (arguments.contains(&quot;version&quot;)) {
 380             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 381             System.exit(0);
 382         }
 383 
 384         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 385             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 386             Logging.setup(level);
 387         }
 388 
 389         HttpProxy.setup();
 390 
 391         var isMercurial = arguments.contains(&quot;mercurial&quot;);
 392         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 393         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 394         var remote = arguments.get(&quot;remote&quot;).orString(isMercurial ? &quot;default&quot; : &quot;origin&quot;);
 395         var remotePullPath = repo.pullPath(remote);
 396         var username = arguments.contains(&quot;username&quot;) ? arguments.get(&quot;username&quot;).asString() : null;
 397         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) :  System.getenv(&quot;GIT_TOKEN&quot;);
 398         var uri = Remote.toWebURI(remotePullPath);
 399         var shouldUseToken = !arguments.contains(&quot;no-token&quot;);
 400         var credentials = !shouldUseToken ?
 401             null :
 402             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 403         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 404         var forge = credentials == null ?
 405             Forge.from(forgeURI) :
 406             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 407         if (forge.isEmpty()) {
 408             if (!shouldUseToken) {
 409                 if (arguments.contains(&quot;verbose&quot;)) {
 410                     System.err.println(&quot;&quot;);
 411                 }
 412                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 413                 if (!arguments.contains(&quot;verbose&quot;)) {
 414                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 415                     System.err.println(&quot;&quot;);
 416                 }
 417             }
 418             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 419         }
 420         var host = forge.get();
 421 
<a name="2" id="anc2"></a><span class="line-modified"> 422         var action = arguments.at(0).asString();</span>







 423         if (!shouldUseToken &amp;&amp;
 424             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 425             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 426             System.exit(1);
 427         }
 428 
 429         if (action.equals(&quot;create&quot;)) {
 430             if (isMercurial) {
 431                 var currentBookmark = repo.currentBookmark();
 432                 if (!currentBookmark.isPresent()) {
 433                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 434                     System.err.println(&quot;&quot;);
 435                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 436                     System.err.println(&quot;&quot;);
 437                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 438                     System.err.println(&quot;&quot;);
 439                     System.exit(1);
 440                 }
 441 
 442                 var bookmark = currentBookmark.get();
 443                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 444                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 445                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 446                     System.err.println(&quot;&quot;);
 447                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 448                     System.err.println(&quot;&quot;);
 449                     System.exit(1);
 450                 }
 451 
 452                 var tags = hgTags();
 453                 var upstreams = tags.stream()
 454                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 455                                     .collect(Collectors.toList());
 456                 if (upstreams.isEmpty()) {
 457                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 458                     System.err.println(&quot;&quot;);
 459                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 460                     System.err.println(&quot;&quot;);
 461                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 462                     System.err.println(&quot;&quot;);
 463                     System.exit(1);
 464                 }
 465 
 466                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 467                 for (var tag : tags) {
 468                     tagsAndHashes.put(tag, hgResolve(tag));
 469                 }
 470                 var bookmarkHash = hgResolve(bookmark.name());
 471                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 472                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 473                     System.err.println(&quot;&quot;);
 474 
 475                     if (upstreams.size() == 1) {
 476                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 477                         System.err.println(&quot;&quot;);
 478                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 479                         System.err.println(&quot;&quot;);
 480                     } else {
 481                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 482                         System.err.println(&quot;&quot;);
 483                         for (var upstream : upstreams) {
 484                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 485                         }
 486                         System.err.println(&quot;&quot;);
 487                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 488                         System.err.println(&quot;&quot;);
 489                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 490                         System.err.println(&quot;&quot;);
 491                     }
 492                     System.exit(1);
 493                 }
 494 
 495                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 496                 var targetHash = hgResolve(targetBranch);
 497                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 498                 if (commits.isEmpty()) {
 499                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 500                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 501                     System.exit(1);
 502                 }
 503 
 504                 var diff = repo.diff(repo.head());
 505                 if (!diff.patches().isEmpty()) {
 506                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 507                     System.err.println(&quot;&quot;);
 508                     for (var patch : diff.patches()) {
 509                         var path = patch.target().path().isPresent() ?
 510                             patch.target().path().get() : patch.source().path().get();
 511                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 512                     }
 513                     System.err.println(&quot;&quot;);
 514                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 515                     System.err.println(&quot;&quot;);
 516                     System.err.println(&quot;    hg commit --amend&quot;);
 517                     System.err.println(&quot;    hg git-cleanup&quot;);
 518                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 519                     System.err.println(&quot;    hg gimport&quot;);
 520                     System.err.println(&quot;&quot;);
 521                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 522                     System.err.println(&quot;&quot;);
 523                     System.err.println(&quot;    hg shelve&quot;);
 524                     System.err.println(&quot;&quot;);
 525                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 526                     System.exit(1);
 527                 }
 528 
 529                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 530                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 531                 );
 532                 if (token == null) {
 533                     GitCredentials.approve(credentials);
 534                 }
 535                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 536                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 537 
 538                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 539                 if (commits.size() == 1) {
 540                     var commit = commits.get(0);
 541                     var message = CommitMessageParsers.v1.parse(commit.message());
 542                     Files.writeString(file, message.title() + &quot;\n&quot;);
 543                     if (!message.summaries().isEmpty()) {
 544                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 545                     }
 546                     if (!message.additional().isEmpty()) {
 547                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 548                     }
 549                 } else {
 550                     Files.write(file, List.of(&quot;&quot;));
 551                 }
 552                 Files.write(file, List.of(
 553                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 554                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 555                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 556                     &quot;# the subject from the body.&quot;,
 557                     &quot;#&quot;,
 558                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 559                     ),
 560                     StandardOpenOption.APPEND
 561                 );
 562                 for (var commit : commits) {
 563                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 564                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 565                 }
 566                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 567                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 568                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 569                 var success = spawnEditor(repo, file);
 570                 if (!success) {
 571                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 572                     System.exit(1);
 573                 }
 574                 var lines = Files.readAllLines(file)
 575                                  .stream()
 576                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 577                                  .collect(Collectors.toList());
 578                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 579                 if (isEmpty) {
 580                     System.err.println(&quot;error: no message present, aborting&quot;);
 581                     System.exit(1);
 582                 }
 583 
 584                 var title = lines.get(0);
 585                 List&lt;String&gt; body = null;
 586                 if (lines.size() &gt; 1) {
 587                     body = lines.subList(1, lines.size())
 588                                 .stream()
 589                                 .dropWhile(String::isEmpty)
 590                                 .collect(Collectors.toList());
 591                 } else {
 592                     body = Collections.emptyList();
 593                 }
 594 
 595                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 596                 if (arguments.contains(&quot;assignees&quot;)) {
 597                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 598                     var assignees = usernames.stream()
 599                                              .map(u -&gt; host.user(u))
 600                                              .collect(Collectors.toList());
 601                     pr.setAssignees(assignees);
 602                 }
 603                 System.out.println(pr.webUrl().toString());
 604                 Files.deleteIfExists(file);
 605 
 606                 System.exit(0);
 607             }
 608             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 609                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 610                     System.exit(1);
 611                     return null;
 612             });
 613             if (currentBranch.equals(repo.defaultBranch())) {
 614                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 615                 System.err.println(&quot;&quot;);
 616                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 617                 System.err.println(&quot;&quot;);
 618                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 619                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 620                 System.err.println(&quot;&quot;);
 621                 System.exit(1);
 622             }
 623 
 624             var ignoreWorkspace = arguments.contains(&quot;ignore-workspace&quot;);
 625             if (!ignoreWorkspace) {
 626                 var lines = repo.config(&quot;pr.ignore-workspace&quot;);
 627                 ignoreWorkspace = lines.size() == 1 &amp;&amp; lines.get(0).equals(&quot;true&quot;);
 628             }
 629             if (!ignoreWorkspace) {
 630                 var diff = repo.diff(repo.head());
 631                 if (!diff.patches().isEmpty()) {
 632                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 633                     System.err.println(&quot;&quot;);
 634                     for (var patch : diff.patches()) {
 635                         var path = patch.target().path().isPresent() ?
 636                             patch.target().path().get() : patch.source().path().get();
 637                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 638                     }
 639                     System.err.println(&quot;&quot;);
 640                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 641                     System.err.println(&quot;&quot;);
 642                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 643                     System.err.println(&quot;&quot;);
 644                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 645                     System.err.println(&quot;&quot;);
 646                     System.err.println(&quot;    git stash&quot;);
 647                     System.err.println(&quot;&quot;);
 648                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 649                     System.exit(1);
 650                 }
 651             }
 652 
 653             var upstream = repo.upstreamFor(currentBranch);
 654             if (upstream.isEmpty()) {
 655                 var shouldPublish = arguments.contains(&quot;publish&quot;);
 656                 if (!shouldPublish) {
 657                     var lines = repo.config(&quot;pr.publish&quot;);
 658                     shouldPublish = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
 659                 }
 660                 if (shouldPublish) {
 661                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 662                     upstream = repo.upstreamFor(currentBranch);
 663                 } else {
 664                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 665                     System.err.println(&quot;&quot;);
 666                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 667                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 668                     System.err.println(&quot;&quot;);
 669                     System.err.println(&quot;    git publish&quot;);
 670                     System.err.println(&quot;&quot;);
 671                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 672                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 673                     System.err.println(&quot;&quot;);
 674                     System.err.println(&quot;    git fetch &quot; + remote);
 675                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 676                     System.err.println(&quot;&quot;);
 677                     System.exit(1);
 678                 }
 679             }
 680 
 681             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 682             repo.fetch(uri, upstreamRefName);
 683 
 684             var shouldIgnoreLocalCommits = arguments.contains(&quot;ignore-local-commits&quot;);
 685             if (!shouldIgnoreLocalCommits) {
 686                 var lines = repo.config(&quot;pr.ignore-local-commits&quot;);
 687                 shouldIgnoreLocalCommits = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
 688             }
 689             if (!shouldIgnoreLocalCommits) {
 690                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 691                 if (!branchCommits.isEmpty()) {
 692                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 693                     System.err.println(&quot;&quot;);
 694                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 695                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 696                     System.err.println(&quot;&quot;);
 697                     for (var commit : branchCommits) {
 698                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 699                     }
 700                     System.err.println(&quot;&quot;);
 701                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 702                     System.err.println(&quot;&quot;);
 703                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 704                     System.err.println(&quot;&quot;);
 705                     System.exit(1);
 706                 }
 707             }
 708 
 709             var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 710             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 711             if (commits.isEmpty()) {
 712                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 713                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 714                 System.exit(1);
 715             }
 716 
 717             var shouldRunJCheck = arguments.contains(&quot;jcheck&quot;);
 718             if (!shouldRunJCheck) {
 719                 var lines = repo.config(&quot;pr.jcheck&quot;);
 720                 shouldRunJCheck = lines.size() == 1 &amp;&amp; lines.get(0).toLowerCase().equals(&quot;true&quot;);
 721             }
 722             if (shouldRunJCheck) {
 723                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 724                 var err = GitJCheck.run(jcheckArgs);
 725                 if (err != 0) {
 726                     System.exit(err);
 727                 }
 728             }
 729 
 730             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 731                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 732             );
 733             if (token == null) {
 734                 GitCredentials.approve(credentials);
 735             }
 736             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 737                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 738 
 739             var project = jbsProjectFromJcheckConf(repo);
 740             var issue = getIssue(currentBranch, project);
 741             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 742             if (issue.isPresent()) {
 743                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 744             } else if (commits.size() == 1) {
 745                 var commit = commits.get(0);
 746                 issue = getIssue(commit, project);
 747                 if (issue.isPresent()) {
 748                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 749                 } else {
 750                     var message = CommitMessageParsers.v1.parse(commit.message());
 751                     Files.writeString(file, message.title() + &quot;\n&quot;);
 752                     if (!message.summaries().isEmpty()) {
 753                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 754                     }
 755                     if (!message.additional().isEmpty()) {
 756                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 757                     }
 758                 }
 759             } else {
 760                 Files.write(file, List.of(&quot;&quot;));
 761             }
 762 
 763             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 764             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 765             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 766             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 767             appendPaddedHTMLComment(file, &quot;&quot;);
 768             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 769             for (var commit : commits) {
 770                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 771                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 772                 if (!commit.isMerge()) {
 773                     var diff = commit.parentDiffs().get(0);
 774                     for (var patch : diff.patches()) {
 775                         var status = patch.status();
 776                         if (status.isModified()) {
 777                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 778                         } else if (status.isAdded()) {
 779                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 780                         } else if (status.isDeleted()) {
 781                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 782                         } else if (status.isRenamed()) {
 783                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 784                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 785                         } else if (status.isCopied()) {
 786                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 787                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 788                         }
 789                     }
 790                 }
 791             }
 792             appendPaddedHTMLComment(file, &quot;&quot;);
 793             if (issue.isPresent()) {
 794                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 795             }
 796             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 797             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 798 
 799             var success = spawnEditor(repo, file);
 800             if (!success) {
 801                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 802                 System.exit(1);
 803             }
 804             var lines = Files.readAllLines(file)
 805                              .stream()
 806                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 807                              .collect(Collectors.toList());
 808             var isEmpty = lines.stream().allMatch(String::isEmpty);
 809             if (isEmpty) {
 810                 System.err.println(&quot;error: no message present, aborting&quot;);
 811                 System.exit(1);
 812             }
 813 
 814             var title = lines.get(0);
 815             List&lt;String&gt; body = null;
 816             if (lines.size() &gt; 1) {
 817                 body = lines.subList(1, lines.size())
 818                             .stream()
 819                             .dropWhile(String::isEmpty)
 820                             .collect(Collectors.toList());
 821             } else {
 822                 body = Collections.emptyList();
 823             }
 824 
 825             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 826             if (arguments.contains(&quot;assignees&quot;)) {
 827                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 828                 var assignees = usernames.stream()
 829                                          .map(u -&gt; host.user(u))
 830                                          .collect(Collectors.toList());
 831                 pr.setAssignees(assignees);
 832             }
 833             System.out.println(pr.webUrl().toString());
 834             Files.deleteIfExists(file);
 835 
 836             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
 837         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
 838             String id = null;
 839             if (arguments.at(1).isPresent()) {
 840                 id = arguments.at(1).asString();
 841             } else {
 842                 if (action.equals(&quot;approve&quot;)) {
 843                     exit(&quot;error: you must provide a pull request id&quot;);
 844                 } else {
 845                     var currentBranch = repo.currentBranch();
 846                     if (currentBranch.isPresent()) {
 847                         var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 848                         if (lines.size() == 1) {
 849                             id = lines.get(0);
 850                         } else {
 851                             exit(&quot;error: you must provide a pull request id&quot;);
 852                         }
 853                     }
 854                 }
 855             }
 856 
 857             var pr = getPullRequest(uri, repo, host, id);
 858 
 859             if (action.equals(&quot;integrate&quot;)) {
 860                 pr.addComment(&quot;/integrate&quot;);
 861             } else if (action.equals(&quot;test&quot;)) {
 862                 pr.addComment(&quot;/test&quot;);
 863             } else if (action.equals(&quot;approve&quot;)) {
 864                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
 865             } else {
 866                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
 867             }
 868         } else if (action.equals(&quot;list&quot;)) {
 869             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 870             var prs = remoteRepo.pullRequests();
 871             var ids = new ArrayList&lt;String&gt;();
 872             var titles = new ArrayList&lt;String&gt;();
 873             var authors = new ArrayList&lt;String&gt;();
 874             var assignees = new ArrayList&lt;String&gt;();
 875             var labels = new ArrayList&lt;String&gt;();
 876 
 877             var filterAuthors = arguments.contains(&quot;authors&quot;) ?
 878                 new HashSet&lt;&gt;(Arrays.asList(arguments.get(&quot;authors&quot;).asString().split(&quot;,&quot;))) :
 879                 Set.of();
 880             var filterAssignees = arguments.contains(&quot;assignees&quot;) ?
 881                 Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;)) :
 882                 Set.of();
 883             var filterLabels = arguments.contains(&quot;labels&quot;) ?
 884                 Arrays.asList(arguments.get(&quot;labels&quot;).asString().split(&quot;,&quot;)) :
 885                 Set.of();
 886 
 887             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
 888             var columnValues = Map.of(defaultColumns.get(0), ids,
 889                                       defaultColumns.get(1), titles,
 890                                       defaultColumns.get(2), authors,
 891                                       defaultColumns.get(3), assignees,
 892                                       defaultColumns.get(4), labels);
 893             var columns = arguments.contains(&quot;columns&quot;) ?
 894                 Arrays.asList(arguments.get(&quot;columns&quot;).asString().split(&quot;,&quot;)) :
 895                 defaultColumns;
 896             if (columns != defaultColumns) {
 897                 for (var column : columns) {
 898                     if (!defaultColumns.contains(column)) {
 899                         System.err.println(&quot;error: unknown column: &quot; + column);
 900                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
 901                         System.exit(1);
 902                     }
 903                 }
 904             }
 905 
 906             for (var pr : prs) {
 907                 var prAuthor = pr.author().userName();
 908                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
 909                     continue;
 910                 }
 911 
 912                 var prAssignees = pr.assignees().stream()
 913                                     .map(HostUser::userName)
 914                                     .collect(Collectors.toSet());
 915                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
 916                     continue;
 917                 }
 918 
 919                 var prLabels = new HashSet&lt;&gt;(pr.labels());
 920                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
 921                     continue;
 922                 }
 923 
 924                 ids.add(pr.id());
 925                 titles.add(pr.title());
 926                 authors.add(prAuthor);
 927                 assignees.add(String.join(&quot;,&quot;, prAssignees));
 928                 labels.add(String.join(&quot;,&quot;, prLabels));
 929             }
 930 
 931 
 932             String fmt = &quot;&quot;;
 933             for (var column : columns.subList(0, columns.size() - 1)) {
 934                 var values = columnValues.get(column);
 935                 var n = Math.max(column.length(), longest(values));
 936                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
 937             }
 938             fmt += &quot;%s\n&quot;;
 939 
 940             if (!ids.isEmpty() &amp;&amp; !arguments.contains(&quot;no-decoration&quot;)) {
 941                 var upperCase = columns.stream()
 942                                        .map(String::toUpperCase)
 943                                        .collect(Collectors.toList());
 944                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
 945             }
 946             for (var i = 0; i &lt; ids.size(); i++) {
 947                 final int n = i;
 948                 var row = columns.stream()
 949                                  .map(columnValues::get)
 950                                  .map(values -&gt; values.get(n))
 951                                  .collect(Collectors.toList());
 952                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
 953             }
 954         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
 955             var prId = arguments.at(1);
 956             if (!prId.isPresent()) {
 957                 exit(&quot;error: missing pull request identifier&quot;);
 958             }
 959 
 960             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 961             var pr = remoteRepo.pullRequest(prId.asString());
 962             var repoUrl = remoteRepo.webUrl();
 963             var prHeadRef = pr.sourceRef();
 964             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
 965             if (isHgGit) {
 966                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
 967                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
 968 
 969                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
 970                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
 971                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
 972 
 973                     if (action.equals(&quot;show&quot;)) {
 974                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
 975                     } else {
 976                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
 977                         hgImport(patch);
 978                         Files.delete(patch);
 979                     }
 980                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
 981                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
 982                     var hgGitBranches = hgGitRepo.branches();
 983                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
 984                         hgGitRepo.delete(new Branch(hgGitRef));
 985                     }
 986                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
 987                     gimport();
 988                     var hgFetchHead = repo.resolve(hgGitRef).get();
 989 
 990                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
 991                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
 992                     } else if (action.equals(&quot;checkout&quot;)) {
 993                         repo.checkout(hgFetchHead);
 994                         if (arguments.contains(&quot;branch&quot;)) {
 995                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
 996                         }
 997                     }
 998                 } else {
 999                     exit(&quot;Unexpected action: &quot; + action);
1000                 }
1001 
1002                 return;
1003             }
1004 
1005             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
1006             if (action.equals(&quot;fetch&quot;)) {
1007                 if (arguments.contains(&quot;branch&quot;)) {
1008                     var branchName = arguments.get(&quot;branch&quot;).asString();
1009                     repo.branch(fetchHead, branchName);
1010                 } else {
1011                     System.out.println(fetchHead.hex());
1012                 }
1013             } else if (action.equals(&quot;checkout&quot;)) {
1014                 if (arguments.contains(&quot;branch&quot;)) {
1015                     var branchName = arguments.get(&quot;branch&quot;).asString();
1016                     var branch = repo.branch(fetchHead, branchName);
1017                     repo.checkout(branch, false);
1018                 } else {
1019                     repo.checkout(fetchHead, false);
1020                 }
1021             } else if (action.equals(&quot;show&quot;)) {
1022                 show(pr.targetRef(), fetchHead);
1023             } else if (action.equals(&quot;apply&quot;)) {
1024                 var patch = diff(pr.targetRef(), fetchHead);
1025                 apply(patch);
1026                 Files.deleteIfExists(patch);
1027             }
1028         } else if (action.equals(&quot;close&quot;)) {
1029             var prId = arguments.at(1);
1030             if (!prId.isPresent()) {
1031                 exit(&quot;error: missing pull request identifier&quot;);
1032             }
1033 
1034             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1035             var pr = remoteRepo.pullRequest(prId.asString());
1036             pr.setState(PullRequest.State.CLOSED);
1037         } else if (action.equals(&quot;update&quot;)) {
1038             var prId = arguments.at(1);
1039             if (!prId.isPresent()) {
1040                 exit(&quot;error: missing pull request identifier&quot;);
1041             }
1042 
1043             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1044             var pr = remoteRepo.pullRequest(prId.asString());
1045             if (arguments.contains(&quot;assignees&quot;)) {
1046                 var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
1047                 var assignees = usernames.stream()
1048                     .map(u -&gt; host.user(u))
1049                     .collect(Collectors.toList());
1050                 pr.setAssignees(assignees);
1051             }
1052         } else {
1053             exit(&quot;error: unexpected action: &quot; + action);
1054         }
1055     }
1056 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>