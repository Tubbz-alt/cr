<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 
  35 import java.io.IOException;
  36 import java.net.URI;
  37 import java.nio.charset.StandardCharsets;
  38 import java.nio.file.*;
  39 import java.util.*;
  40 import java.util.regex.Pattern;
  41 import java.util.concurrent.TimeUnit;
  42 import java.util.function.Supplier;
  43 import java.util.logging.Level;
  44 import java.util.stream.Collectors;
  45 
  46 public class GitPr {
  47     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;
  48 
  49     private static void exit(String fmt, Object...args) {
  50         System.err.println(String.format(fmt, args));
  51         System.exit(1);
  52     }
  53 
  54     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  55         return () -&gt; {
  56             exit(fmt, args);
  57             return null;
  58         };
  59     }
  60 
  61     private static String gitConfig(String key) {
  62         try {
  63             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  64             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  65             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  66             var p = pb.start();
  67 
  68             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  69             var res = p.waitFor();
  70             if (res != 0) {
  71                 return null;
  72             }
  73 
  74             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  75         } catch (InterruptedException e) {
  76             return null;
  77         } catch (IOException e) {
  78             return null;
  79         }
  80     }
  81 
  82     private static String getOption(String name, Arguments arguments) {
  83         return getOption(name, null, arguments);
  84     }
  85 
  86     private static String getOption(String name, String subsection, Arguments arguments) {
  87         if (arguments.contains(name)) {
  88             return arguments.get(name).asString();
  89         }
  90 
  91         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  92             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  93             if (subsectionSpecific != null) {
  94                 return subsectionSpecific;
  95             }
  96         }
  97 
  98         return gitConfig(&quot;fork.&quot; + name);
  99     }
 100 
 101     private static boolean getSwitch(String name, Arguments arguments) {
 102         return getSwitch(name, null, arguments);
 103     }
 104 
 105     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 106         if (arguments.contains(name)) {
 107             return true;
 108         }
 109 
 110         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 111             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 112             if (subsectionSpecific != null) {
 113                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 114             }
 115         }
 116 
 117         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 118         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 119     }
 120 
 121     private static String rightPad(String s, int length) {
 122         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 123     }
 124 
 125     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 126         var end = &quot; --&gt;&quot;;
 127         var pad = 79 - end.length();
 128         var newLine = &quot;\n&quot;;
 129         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 130     }
 131 
 132     private static String format(Issue issue) {
 133         var parts = issue.id().split(&quot;-&quot;);
 134         var id = parts.length == 2 ? parts[1] : issue.id();
 135         return id + &quot;: &quot; + issue.title();
 136     }
 137 
 138     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 139         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 140             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 141         ));
 142 
 143         return conf.general().jbs();
 144     }
 145 
 146     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 147         var message = CommitMessageParsers.v1.parse(commit.message());
 148         var issues = message.issues();
 149         if (issues.isEmpty()) {
 150             return getIssue(message.title(), project);
 151         } else if (issues.size() == 1) {
 152             var issue = issues.get(0);
 153             return getIssue(issue.id(), project);
 154         }
 155         return Optional.empty();
 156     }
 157 
 158     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 159         return getIssue(b.name(), project);
 160     }
 161 
 162     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 163         var issueIdPattern = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
 164         var m = issueIdPattern.matcher(s);
 165         if (m.matches()) {
 166             var id = m.group(2);
 167             if (project == null) {
 168                 project = m.group(1);
 169             }
 170             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 171             return issueTracker.project(project).issue(id);
 172         }
 173 
 174         return Optional.empty();
 175     }
 176 
 177     private static void await(Process p) throws IOException {
 178         try {
 179             var res = p.waitFor();
 180             if (res != 0) {
 181                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 182             }
 183         } catch (InterruptedException e) {
 184             throw new IOException(e);
 185         }
 186     }
 187 
 188     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 189         String editor = null;
 190         var lines = repo.config(&quot;core.editor&quot;);
 191         if (lines.size() == 1) {
 192             editor = lines.get(0);
 193         }
 194         if (editor == null) {
 195             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 196         }
 197         if (editor == null) {
 198             editor = System.getenv(&quot;EDITOR&quot;);
 199         }
 200         if (editor == null) {
 201             editor = System.getenv(&quot;VISUAL&quot;);
 202         }
 203         if (editor == null) {
 204             editor = &quot;vi&quot;;
 205         }
 206 
 207         var pb = new ProcessBuilder(editor, file.toString());
 208         pb.inheritIO();
 209         var p = pb.start();
 210         try {
 211             return p.waitFor() == 0;
 212         } catch (InterruptedException e) {
 213             throw new IOException(e);
 214         }
 215     }
 216 
 217     private static String projectName(URI uri) {
 218         var name = uri.getPath().toString().substring(1);
 219         if (name.endsWith(&quot;.git&quot;)) {
 220             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 221         }
 222         return name;
 223     }
 224 
 225     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 226         HostedRepository targetRepo = null;
 227 
 228         try {
 229             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 230             targetRepo = host.repository(projectName(upstream)).orElse(null);
 231         } catch (IOException e) {
 232             // do nothing
 233         }
 234 
 235         if (targetRepo == null) {
 236             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 237                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 238             );
 239             var parentRepo = remoteRepo.parent();
 240             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 241         }
 242 
 243         return targetRepo;
 244     }
 245 
 246     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 247         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 248         if (pr == null) {
 249             exit(&quot;error: could not fetch PR information&quot;);
 250         }
 251 
 252         return pr;
 253     }
 254 
 255     private static void show(String ref, Hash hash) throws IOException {
 256         show(ref, hash, null);
 257     }
 258     private static void show(String ref, Hash hash, Path dir) throws IOException {
 259         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 260                                                    &quot;--patch&quot;,
 261                                                    &quot;--find-renames=50%&quot;,
 262                                                    &quot;--find-copies=50%&quot;,
 263                                                    &quot;--find-copies-harder&quot;,
 264                                                    &quot;--abbrev&quot;,
 265                                                    ref + &quot;...&quot; + hash.hex());
 266         if (dir != null) {
 267             pb.directory(dir.toFile());
 268         }
 269         pb.inheritIO();
 270         await(pb.start());
 271     }
 272 
 273     private static void gimport() throws IOException {
 274         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 275         pb.inheritIO();
 276         await(pb.start());
 277     }
 278 
 279     private static void hgImport(Path patch) throws IOException {
 280         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 281         pb.inheritIO();
 282         await(pb.start());
 283     }
 284 
 285     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 286         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 287         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 288         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 289         var p = pb.start();
 290         var bytes = p.getInputStream().readAllBytes();
 291         var exited = p.waitFor(1, TimeUnit.MINUTES);
 292         var exitValue = p.exitValue();
 293         if (!exited || exitValue != 0) {
 294             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 295         }
 296 
 297         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 298     }
 299 
 300     private static String hgResolve(String ref) throws IOException, InterruptedException {
 301         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 302         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 303         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 304         var p = pb.start();
 305         var bytes = p.getInputStream().readAllBytes();
 306         var exited = p.waitFor(1, TimeUnit.MINUTES);
 307         var exitValue = p.exitValue();
 308         if (!exited || exitValue != 0) {
 309             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 310         }
 311 
 312         return new String(bytes, StandardCharsets.UTF_8);
 313     }
 314 
 315     private static Path diff(String ref, Hash hash) throws IOException {
 316         return diff(ref, hash, null);
 317     }
 318 
 319     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 320         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 321         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 322                                                    &quot;--patch&quot;,
 323                                                    &quot;--find-renames=50%&quot;,
 324                                                    &quot;--find-copies=50%&quot;,
 325                                                    &quot;--find-copies-harder&quot;,
 326                                                    &quot;--abbrev&quot;,
 327                                                    ref + &quot;...&quot; + hash.hex());
 328         if (dir != null) {
 329             pb.directory(dir.toFile());
 330         }
 331         pb.redirectOutput(patch.toFile());
 332         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 333         await(pb.start());
 334         return patch;
 335     }
 336 
 337     private static void apply(Path patch) throws IOException {
 338         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 339         pb.inheritIO();
 340         await(pb.start());
 341     }
 342 
 343     private static int longest(List&lt;String&gt; strings) {
 344         return strings.stream().mapToInt(String::length).max().orElse(0);
 345     }
 346 
 347     public static void main(String[] args) throws IOException, InterruptedException {
 348         var flags = List.of(
 349             Option.shortcut(&quot;u&quot;)
 350                   .fullname(&quot;username&quot;)
 351                   .describe(&quot;NAME&quot;)
 352                   .helptext(&quot;Username on host&quot;)
 353                   .optional(),
 354             Option.shortcut(&quot;r&quot;)
 355                   .fullname(&quot;remote&quot;)
 356                   .describe(&quot;NAME&quot;)
 357                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 358                   .optional(),
 359             Option.shortcut(&quot;b&quot;)
 360                   .fullname(&quot;branch&quot;)
 361                   .describe(&quot;NAME&quot;)
 362                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 363                   .optional(),
 364             Option.shortcut(&quot;&quot;)
 365                   .fullname(&quot;authors&quot;)
 366                   .describe(&quot;LIST&quot;)
 367                   .helptext(&quot;Comma separated list of authors&quot;)
 368                   .optional(),
 369             Option.shortcut(&quot;&quot;)
 370                   .fullname(&quot;assignees&quot;)
 371                   .describe(&quot;LIST&quot;)
 372                   .helptext(&quot;Comma separated list of assignees&quot;)
 373                   .optional(),
 374             Option.shortcut(&quot;&quot;)
 375                   .fullname(&quot;labels&quot;)
 376                   .describe(&quot;LIST&quot;)
 377                   .helptext(&quot;Comma separated list of labels&quot;)
 378                   .optional(),
 379             Option.shortcut(&quot;&quot;)
 380                   .fullname(&quot;columns&quot;)
 381                   .describe(&quot;id,title,author,assignees,labels&quot;)
 382                   .helptext(&quot;Comma separated list of columns to show&quot;)
 383                   .optional(),
 384             Switch.shortcut(&quot;&quot;)
 385                   .fullname(&quot;no-decoration&quot;)
 386                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 387                   .optional(),
 388             Switch.shortcut(&quot;&quot;)
 389                   .fullname(&quot;ignore-workspace&quot;)
 390                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 391                   .optional(),
 392             Switch.shortcut(&quot;&quot;)
 393                   .fullname(&quot;ignore-local-commits&quot;)
 394                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 395                   .optional(),
 396             Switch.shortcut(&quot;&quot;)
 397                   .fullname(&quot;publish&quot;)
 398                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 399                   .optional(),
 400             Switch.shortcut(&quot;&quot;)
 401                   .fullname(&quot;jcheck&quot;)
 402                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 403                   .optional(),
 404             Switch.shortcut(&quot;&quot;)
 405                   .fullname(&quot;no-token&quot;)
 406                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 407                   .optional(),
 408             Switch.shortcut(&quot;&quot;)
 409                   .fullname(&quot;mercurial&quot;)
 410                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 411                   .optional(),
 412             Switch.shortcut(&quot;&quot;)
 413                   .fullname(&quot;verbose&quot;)
 414                   .helptext(&quot;Turn on verbose output&quot;)
 415                   .optional(),
 416             Switch.shortcut(&quot;&quot;)
 417                   .fullname(&quot;debug&quot;)
 418                   .helptext(&quot;Turn on debugging output&quot;)
 419                   .optional(),
 420             Switch.shortcut(&quot;&quot;)
 421                   .fullname(&quot;version&quot;)
 422                   .helptext(&quot;Print the version of this tool&quot;)
 423                   .optional());
 424 
 425         var inputs = List.of(
 426             Input.position(0)
 427                  .describe(&quot;list|fetch|show|checkout|apply|integrate|approve|create|close|update|test&quot;)
 428                  .singular()
 429                  .optional(),
 430             Input.position(1)
 431                  .describe(&quot;ID&quot;)
 432                  .singular()
 433                  .optional()
 434         );
 435 
 436         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 437         var arguments = parser.parse(args);
 438 
 439         if (arguments.contains(&quot;version&quot;)) {
 440             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 441             System.exit(0);
 442         }
 443 
 444         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 445             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 446             Logging.setup(level);
 447         }
 448 
 449         HttpProxy.setup();
 450 
 451         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 452         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 453         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 454         var remote = getOption(&quot;remote&quot;, arguments);
 455         if (remote == null) {
 456             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 457         }
 458         var remotePullPath = repo.pullPath(remote);
 459         var username = getOption(&quot;username&quot;, arguments);
 460         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 461         var uri = Remote.toWebURI(remotePullPath);
 462         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 463         var credentials = !shouldUseToken ?
 464             null :
 465             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 466         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 467         var forge = credentials == null ?
 468             Forge.from(forgeURI) :
 469             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 470         if (forge.isEmpty()) {
 471             if (!shouldUseToken) {
 472                 if (arguments.contains(&quot;verbose&quot;)) {
 473                     System.err.println(&quot;&quot;);
 474                 }
 475                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 476                 if (!arguments.contains(&quot;verbose&quot;)) {
 477                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 478                     System.err.println(&quot;&quot;);
 479                 }
 480             }
 481             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 482         }
 483         var host = forge.get();
 484 
 485         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 486         if (action == null) {
 487             var lines = repo.config(&quot;pr.default&quot;);
 488             if (lines.size() == 1) {
 489                 action = lines.get(0);
 490             }
 491         }
 492 
 493         if (!shouldUseToken &amp;&amp;
 494             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 495             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 496             System.exit(1);
 497         }
 498 
 499         if (action.equals(&quot;create&quot;)) {
 500             if (isMercurial) {
 501                 var currentBookmark = repo.currentBookmark();
 502                 if (!currentBookmark.isPresent()) {
 503                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 504                     System.err.println(&quot;&quot;);
 505                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 506                     System.err.println(&quot;&quot;);
 507                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 508                     System.err.println(&quot;&quot;);
 509                     System.exit(1);
 510                 }
 511 
 512                 var bookmark = currentBookmark.get();
 513                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 514                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 515                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 516                     System.err.println(&quot;&quot;);
 517                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 518                     System.err.println(&quot;&quot;);
 519                     System.exit(1);
 520                 }
 521 
 522                 var tags = hgTags();
 523                 var upstreams = tags.stream()
 524                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 525                                     .collect(Collectors.toList());
 526                 if (upstreams.isEmpty()) {
 527                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 528                     System.err.println(&quot;&quot;);
 529                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 530                     System.err.println(&quot;&quot;);
 531                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 532                     System.err.println(&quot;&quot;);
 533                     System.exit(1);
 534                 }
 535 
 536                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 537                 for (var tag : tags) {
 538                     tagsAndHashes.put(tag, hgResolve(tag));
 539                 }
 540                 var bookmarkHash = hgResolve(bookmark.name());
 541                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 542                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 543                     System.err.println(&quot;&quot;);
 544 
 545                     if (upstreams.size() == 1) {
 546                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 547                         System.err.println(&quot;&quot;);
 548                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 549                         System.err.println(&quot;&quot;);
 550                     } else {
 551                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 552                         System.err.println(&quot;&quot;);
 553                         for (var upstream : upstreams) {
 554                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 555                         }
 556                         System.err.println(&quot;&quot;);
 557                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 558                         System.err.println(&quot;&quot;);
 559                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 560                         System.err.println(&quot;&quot;);
 561                     }
 562                     System.exit(1);
 563                 }
 564 
 565                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 566                 var targetHash = hgResolve(targetBranch);
 567                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 568                 if (commits.isEmpty()) {
 569                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 570                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 571                     System.exit(1);
 572                 }
 573 
 574                 var diff = repo.diff(repo.head());
 575                 if (!diff.patches().isEmpty()) {
 576                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 577                     System.err.println(&quot;&quot;);
 578                     for (var patch : diff.patches()) {
 579                         var path = patch.target().path().isPresent() ?
 580                             patch.target().path().get() : patch.source().path().get();
 581                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 582                     }
 583                     System.err.println(&quot;&quot;);
 584                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 585                     System.err.println(&quot;&quot;);
 586                     System.err.println(&quot;    hg commit --amend&quot;);
 587                     System.err.println(&quot;    hg git-cleanup&quot;);
 588                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 589                     System.err.println(&quot;    hg gimport&quot;);
 590                     System.err.println(&quot;&quot;);
 591                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 592                     System.err.println(&quot;&quot;);
 593                     System.err.println(&quot;    hg shelve&quot;);
 594                     System.err.println(&quot;&quot;);
 595                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 596                     System.exit(1);
 597                 }
 598 
 599                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 600                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 601                 );
 602                 if (token == null) {
 603                     GitCredentials.approve(credentials);
 604                 }
 605                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 606                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 607 
 608                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 609                 if (commits.size() == 1) {
 610                     var commit = commits.get(0);
 611                     var message = CommitMessageParsers.v1.parse(commit.message());
 612                     Files.writeString(file, message.title() + &quot;\n&quot;);
 613                     if (!message.summaries().isEmpty()) {
 614                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 615                     }
 616                     if (!message.additional().isEmpty()) {
 617                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 618                     }
 619                 } else {
 620                     Files.write(file, List.of(&quot;&quot;));
 621                 }
 622                 Files.write(file, List.of(
 623                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 624                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 625                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 626                     &quot;# the subject from the body.&quot;,
 627                     &quot;#&quot;,
 628                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 629                     ),
 630                     StandardOpenOption.APPEND
 631                 );
 632                 for (var commit : commits) {
 633                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 634                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 635                 }
 636                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 637                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 638                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 639                 var success = spawnEditor(repo, file);
 640                 if (!success) {
 641                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 642                     System.exit(1);
 643                 }
 644                 var lines = Files.readAllLines(file)
 645                                  .stream()
 646                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 647                                  .collect(Collectors.toList());
 648                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 649                 if (isEmpty) {
 650                     System.err.println(&quot;error: no message present, aborting&quot;);
 651                     System.exit(1);
 652                 }
 653 
 654                 var title = lines.get(0);
 655                 List&lt;String&gt; body = null;
 656                 if (lines.size() &gt; 1) {
 657                     body = lines.subList(1, lines.size())
 658                                 .stream()
 659                                 .dropWhile(String::isEmpty)
 660                                 .collect(Collectors.toList());
 661                 } else {
 662                     body = Collections.emptyList();
 663                 }
 664 
 665                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 666                 if (arguments.contains(&quot;assignees&quot;)) {
 667                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 668                     var assignees = usernames.stream()
 669                                              .map(u -&gt; host.user(u))
 670                                              .collect(Collectors.toList());
 671                     pr.setAssignees(assignees);
 672                 }
 673                 System.out.println(pr.webUrl().toString());
 674                 Files.deleteIfExists(file);
 675 
 676                 System.exit(0);
 677             }
 678             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 679                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 680                     System.exit(1);
 681                     return null;
 682             });
 683             if (currentBranch.equals(repo.defaultBranch())) {
 684                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 685                 System.err.println(&quot;&quot;);
 686                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 687                 System.err.println(&quot;&quot;);
 688                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 689                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 690                 System.err.println(&quot;&quot;);
 691                 System.exit(1);
 692             }
 693 
 694             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 695             if (!ignoreWorkspace) {
 696                 var diff = repo.diff(repo.head());
 697                 if (!diff.patches().isEmpty()) {
 698                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 699                     System.err.println(&quot;&quot;);
 700                     for (var patch : diff.patches()) {
 701                         var path = patch.target().path().isPresent() ?
 702                             patch.target().path().get() : patch.source().path().get();
 703                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 704                     }
 705                     System.err.println(&quot;&quot;);
 706                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 707                     System.err.println(&quot;&quot;);
 708                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 709                     System.err.println(&quot;&quot;);
 710                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 711                     System.err.println(&quot;&quot;);
 712                     System.err.println(&quot;    git stash&quot;);
 713                     System.err.println(&quot;&quot;);
 714                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 715                     System.exit(1);
 716                 }
 717             }
 718 
 719             var upstream = repo.upstreamFor(currentBranch);
 720             if (upstream.isEmpty()) {
 721                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 722                 if (shouldPublish) {
 723                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 724                     upstream = repo.upstreamFor(currentBranch);
 725                 } else {
 726                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 727                     System.err.println(&quot;&quot;);
 728                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 729                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 730                     System.err.println(&quot;&quot;);
 731                     System.err.println(&quot;    git publish&quot;);
 732                     System.err.println(&quot;&quot;);
 733                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 734                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 735                     System.err.println(&quot;&quot;);
 736                     System.err.println(&quot;    git fetch &quot; + remote);
 737                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 738                     System.err.println(&quot;&quot;);
 739                     System.exit(1);
 740                 }
 741             }
 742 
 743             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 744             repo.fetch(uri, upstreamRefName);
 745 
 746             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 747             if (!shouldIgnoreLocalCommits) {
 748                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 749                 if (!branchCommits.isEmpty()) {
 750                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 751                     System.err.println(&quot;&quot;);
 752                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 753                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 754                     System.err.println(&quot;&quot;);
 755                     for (var commit : branchCommits) {
 756                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 757                     }
 758                     System.err.println(&quot;&quot;);
 759                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 760                     System.err.println(&quot;&quot;);
 761                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 762                     System.err.println(&quot;&quot;);
 763                     System.exit(1);
 764                 }
 765             }
 766 
 767             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 768             if (targetBranch == null) {
 769                 targetBranch = &quot;master&quot;;
 770             }
 771             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 772             if (commits.isEmpty()) {
 773                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 774                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 775                 System.exit(1);
 776             }
 777 
 778             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 779             if (shouldRunJCheck) {
 780                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 781                 var err = GitJCheck.run(jcheckArgs);
 782                 if (err != 0) {
 783                     System.exit(err);
 784                 }
 785             }
 786 
 787             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 788                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 789             );
 790             if (token == null) {
 791                 GitCredentials.approve(credentials);
 792             }
 793             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 794                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 795 
 796             var project = jbsProjectFromJcheckConf(repo);
 797             var issue = getIssue(currentBranch, project);
 798             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 799             if (issue.isPresent()) {
 800                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 801             } else if (commits.size() == 1) {
 802                 var commit = commits.get(0);
 803                 issue = getIssue(commit, project);
 804                 if (issue.isPresent()) {
 805                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 806                 } else {
 807                     var message = CommitMessageParsers.v1.parse(commit.message());
 808                     Files.writeString(file, message.title() + &quot;\n&quot;);
 809                     if (!message.summaries().isEmpty()) {
 810                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 811                     }
 812                     if (!message.additional().isEmpty()) {
 813                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 814                     }
 815                 }
 816             } else {
 817                 Files.write(file, List.of(&quot;&quot;));
 818             }
 819 
 820             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 821             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 822             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 823             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 824             appendPaddedHTMLComment(file, &quot;&quot;);
 825             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 826             for (var commit : commits) {
 827                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 828                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 829                 if (!commit.isMerge()) {
 830                     var diff = commit.parentDiffs().get(0);
 831                     for (var patch : diff.patches()) {
 832                         var status = patch.status();
 833                         if (status.isModified()) {
 834                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 835                         } else if (status.isAdded()) {
 836                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 837                         } else if (status.isDeleted()) {
 838                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 839                         } else if (status.isRenamed()) {
 840                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 841                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 842                         } else if (status.isCopied()) {
 843                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 844                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 845                         }
 846                     }
 847                 }
 848             }
 849             appendPaddedHTMLComment(file, &quot;&quot;);
 850             if (issue.isPresent()) {
 851                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 852             }
 853             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 854             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 855 
 856             var success = spawnEditor(repo, file);
 857             if (!success) {
 858                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 859                 System.exit(1);
 860             }
 861             var lines = Files.readAllLines(file)
 862                              .stream()
 863                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 864                              .collect(Collectors.toList());
 865             var isEmpty = lines.stream().allMatch(String::isEmpty);
 866             if (isEmpty) {
 867                 System.err.println(&quot;error: no message present, aborting&quot;);
 868                 System.exit(1);
 869             }
 870 
 871             var title = lines.get(0);
 872             List&lt;String&gt; body = null;
 873             if (lines.size() &gt; 1) {
 874                 body = lines.subList(1, lines.size())
 875                             .stream()
 876                             .dropWhile(String::isEmpty)
 877                             .collect(Collectors.toList());
 878             } else {
 879                 body = Collections.emptyList();
 880             }
 881 
 882             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 883             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
 884             if (assigneesOption != null) {
 885                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
 886                 var assignees = usernames.stream()
 887                                          .map(u -&gt; host.user(u))
 888                                          .collect(Collectors.toList());
 889                 pr.setAssignees(assignees);
 890             }
 891             System.out.println(pr.webUrl().toString());
 892             Files.deleteIfExists(file);
 893 
 894             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
 895         } else if (action.equals(&quot;integrate&quot;) || action.equals(&quot;approve&quot;) || action.equals(&quot;test&quot;)) {
 896             String id = null;
 897             if (arguments.at(1).isPresent()) {
 898                 id = arguments.at(1).asString();
 899             } else {
 900                 if (action.equals(&quot;approve&quot;)) {
 901                     exit(&quot;error: you must provide a pull request id&quot;);
 902                 } else {
 903                     var currentBranch = repo.currentBranch();
 904                     if (currentBranch.isPresent()) {
 905                         var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 906                         if (lines.size() == 1) {
 907                             id = lines.get(0);
 908                         } else {
 909                             exit(&quot;error: you must provide a pull request id&quot;);
 910                         }
 911                     }
 912                 }
 913             }
 914 
 915             var pr = getPullRequest(uri, repo, host, id);
 916 
 917             if (action.equals(&quot;integrate&quot;)) {
 918                 pr.addComment(&quot;/integrate&quot;);
 919             } else if (action.equals(&quot;test&quot;)) {
 920                 pr.addComment(&quot;/test&quot;);
 921             } else if (action.equals(&quot;approve&quot;)) {
 922                 pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
 923             } else {
 924                 throw new IllegalStateException(&quot;unexpected action: &quot; + action);
 925             }
 926         } else if (action.equals(&quot;list&quot;)) {
 927             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
 928             var prs = remoteRepo.pullRequests();
 929             var ids = new ArrayList&lt;String&gt;();
 930             var titles = new ArrayList&lt;String&gt;();
 931             var authors = new ArrayList&lt;String&gt;();
 932             var assignees = new ArrayList&lt;String&gt;();
 933             var labels = new ArrayList&lt;String&gt;();
 934 
 935             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
 936             var filterAuthors = authorsOption == null ?
 937                 Set.of() :
 938                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
 939 
 940             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
 941             var filterAssignees = assigneesOption == null ?
 942                 Set.of() :
 943                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
 944 
 945             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
 946             var filterLabels = labelsOption == null ?
 947                 Set.of() :
 948                 Arrays.asList(labelsOption.split(&quot;,&quot;));
 949 
 950             var defaultColumns = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;);
 951             var columnValues = Map.of(defaultColumns.get(0), ids,
 952                                       defaultColumns.get(1), titles,
 953                                       defaultColumns.get(2), authors,
 954                                       defaultColumns.get(3), assignees,
 955                                       defaultColumns.get(4), labels);
 956             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
 957             var columns = columnsOption == null ?
 958                 defaultColumns :
 959                 Arrays.asList(columnsOption.split(&quot;,&quot;));
 960             if (columns != defaultColumns) {
 961                 for (var column : columns) {
 962                     if (!defaultColumns.contains(column)) {
 963                         System.err.println(&quot;error: unknown column: &quot; + column);
 964                         System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, defaultColumns));
 965                         System.exit(1);
 966                     }
 967                 }
 968             }
 969 
 970             for (var pr : prs) {
 971                 var prAuthor = pr.author().userName();
 972                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
 973                     continue;
 974                 }
 975 
 976                 var prAssignees = pr.assignees().stream()
 977                                     .map(HostUser::userName)
 978                                     .collect(Collectors.toSet());
 979                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
 980                     continue;
 981                 }
 982 
 983                 var prLabels = new HashSet&lt;&gt;(pr.labels());
 984                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
 985                     continue;
 986                 }
 987 
 988                 ids.add(pr.id());
 989                 titles.add(pr.title());
 990                 authors.add(prAuthor);
 991                 assignees.add(String.join(&quot;,&quot;, prAssignees));
 992                 labels.add(String.join(&quot;,&quot;, prLabels));
 993             }
 994 
 995 
 996             String fmt = &quot;&quot;;
 997             for (var column : columns.subList(0, columns.size() - 1)) {
 998                 var values = columnValues.get(column);
 999                 var n = Math.max(column.length(), longest(values));
1000                 fmt += &quot;%-&quot; + n + &quot;s\t&quot;;
1001             }
1002             fmt += &quot;%s\n&quot;;
1003 
1004             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1005             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1006                 var upperCase = columns.stream()
1007                                        .map(String::toUpperCase)
1008                                        .collect(Collectors.toList());
1009                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1010             }
1011             for (var i = 0; i &lt; ids.size(); i++) {
1012                 final int n = i;
1013                 var row = columns.stream()
1014                                  .map(columnValues::get)
1015                                  .map(values -&gt; values.get(n))
1016                                  .collect(Collectors.toList());
1017                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1018             }
1019         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1020             var prId = arguments.at(1);
1021             if (!prId.isPresent()) {
1022                 exit(&quot;error: missing pull request identifier&quot;);
1023             }
1024 
1025             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1026             var pr = remoteRepo.pullRequest(prId.asString());
1027             var repoUrl = remoteRepo.webUrl();
1028             var prHeadRef = pr.sourceRef();
1029             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1030             if (isHgGit) {
1031                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1032                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1033 
1034                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1035                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1036                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1037 
1038                     if (action.equals(&quot;show&quot;)) {
1039                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1040                     } else {
1041                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1042                         hgImport(patch);
1043                         Files.delete(patch);
1044                     }
1045                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1046                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1047                     var hgGitBranches = hgGitRepo.branches();
1048                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1049                         hgGitRepo.delete(new Branch(hgGitRef));
1050                     }
1051                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1052                     gimport();
1053                     var hgFetchHead = repo.resolve(hgGitRef).get();
1054 
1055                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1056                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1057                     } else if (action.equals(&quot;checkout&quot;)) {
1058                         repo.checkout(hgFetchHead);
1059                         if (arguments.contains(&quot;branch&quot;)) {
1060                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1061                         }
1062                     }
1063                 } else {
1064                     exit(&quot;Unexpected action: &quot; + action);
1065                 }
1066 
1067                 return;
1068             }
1069 
1070             var fetchHead = repo.fetch(repoUrl, pr.sourceRef());
1071             if (action.equals(&quot;fetch&quot;)) {
1072                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1073                 if (branchName != null) {
1074                     repo.branch(fetchHead, branchName);
1075                 } else {
1076                     System.out.println(fetchHead.hex());
1077                 }
1078             } else if (action.equals(&quot;checkout&quot;)) {
1079                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1080                 if (branchName != null) {
1081                     var branch = repo.branch(fetchHead, branchName);
1082                     repo.checkout(branch, false);
1083                 } else {
1084                     repo.checkout(fetchHead, false);
1085                 }
1086             } else if (action.equals(&quot;show&quot;)) {
1087                 show(pr.targetRef(), fetchHead);
1088             } else if (action.equals(&quot;apply&quot;)) {
1089                 var patch = diff(pr.targetRef(), fetchHead);
1090                 apply(patch);
1091                 Files.deleteIfExists(patch);
1092             }
1093         } else if (action.equals(&quot;close&quot;)) {
1094             var prId = arguments.at(1);
1095             if (!prId.isPresent()) {
1096                 exit(&quot;error: missing pull request identifier&quot;);
1097             }
1098 
1099             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1100             var pr = remoteRepo.pullRequest(prId.asString());
1101             pr.setState(PullRequest.State.CLOSED);
1102         } else if (action.equals(&quot;update&quot;)) {
1103             var prId = arguments.at(1);
1104             if (!prId.isPresent()) {
1105                 exit(&quot;error: missing pull request identifier&quot;);
1106             }
1107 
1108             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1109             var pr = remoteRepo.pullRequest(prId.asString());
1110             var assigneesOption = getOption(&quot;assignees&quot;, &quot;update&quot;, arguments);
1111             if (assigneesOption != null) {
1112                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1113                 var assignees = usernames.stream()
1114                     .map(u -&gt; host.user(u))
1115                     .collect(Collectors.toList());
1116                 pr.setAssignees(assignees);
1117             }
1118         } else {
1119             exit(&quot;error: unexpected action: &quot; + action);
1120         }
1121     }
1122 }
    </pre>
  </body>
</html>