diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -152,10 +152,6 @@
             result.append(role);
             result.append(").");
         }
         return result.toString();
     }
-
-    static String reviewApprovalBodyReviewer(String reviewer) {
-        return "This PR has been marked as Reviewed by " + reviewer + ".";
-    }
 }
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -62,20 +62,12 @@
 
     private EmailAddress getMessageId(Hash hash) {
         return getUniqueMessageId("ha" + hash.hex());
     }
 
-    private EmailAddress getMessageId(String raw) {
-        return getUniqueMessageId("rw" + raw);
-    }
-
-    private EmailAddress getMessageId(Review review, boolean verdict) {
-        if (verdict) {
-            return getUniqueMessageId("rvvd" + review.id());
-        } else {
-            return getUniqueMessageId("rv" + review.id());
-        }
+    private EmailAddress getMessageId(Review review) {
+        return getUniqueMessageId("rv" + review.id());
     }
 
     private String getStableMessageId(EmailAddress uniqueMessageId) {
         return uniqueMessageId.localPart().split("\\.")[0];
     }
@@ -237,27 +229,36 @@
                          .build();
         generated.add(email);
         generatedIds.put(getStableMessageId(id), email);
     }
 
-    private Optional<Email> findCollapsable(Email parent, HostUserDetails author) {
+    private Optional<Email> findCollapsable(Email parent, HostUserDetails author, String subject) {
         var parentId = getStableMessageId(parent.id());
 
         // Is it a self-reply?
         if (parent.author().equals(getAuthorAddress(author)) && generatedIds.containsKey(parentId)) {
-            return Optional.of(parent);
+            // But avoid extending top-level parents
+            if (!parent.hasHeader("PR-Head-Hash")) {
+                // And only collapse identical subjects
+                if (parent.subject().equals(subject)) {
+                    return Optional.of(parent);
+                }
+            }
         }
 
         // Have we already replied to the same parent?
         for (var candidate : generated) {
             if (!candidate.hasHeader("In-Reply-To")) {
                 continue;
             }
             var inReplyTo = EmailAddress.parse(candidate.headerValue("In-Reply-To"));
             var candidateParentId = getStableMessageId(inReplyTo);
             if (candidateParentId.equals(parentId) && candidate.author().equals(getAuthorAddress(author))) {
-                return Optional.of(candidate);
+                // Only collapse identical subjects
+                if (candidate.subject().equals(subject)) {
+                    return Optional.of(candidate);
+                }
             }
         }
 
         return Optional.empty();
     }
@@ -270,11 +271,11 @@
         if (!subject.startsWith("Re: ")) {
             subject = "Re: " + subject;
         }
 
         // Collapse self-replies and replies-to-same that have been created in this run
-        var collapsable = findCollapsable(parent, author);
+        var collapsable = findCollapsable(parent, author, subject);
         if (collapsable.isPresent()) {
             // Drop the parent
             var parentEmail = collapsable.get();
             generated.remove(parentEmail);
             generatedIds.remove(getStableMessageId(parentEmail.id()));
@@ -331,35 +332,33 @@
         }
         return "none";
     }
 
     void addReview(Review review) {
+        var id = getMessageId(review);
+        if (existingIds.containsKey(getStableMessageId(id))) {
+            return;
+        }
+
         var contributor = censusInstance.namespace().get(review.reviewer().id());
+        var isReviewer = contributor != null && censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
 
-        // Post the review body as a regular comment
-        if (review.body().isPresent()) {
-            var id = getMessageId(review, false);
-            if (!existingIds.containsKey(getStableMessageId(id))) {
-                var parent = topCommentForHash(review.hash());
-                var userName = contributor != null ? contributor.username() : review.reviewer().userName() + "@" + censusInstance.namespace().name();
-                var userRole = contributor != null ? projectRole(contributor) : "none";
-                var replyBody = ArchiveMessages.reviewCommentBody(review.body().get(), review.verdict(), userName, userRole);
-                addReplyCommon(parent, review.reviewer(), parent.subject(), replyBody, id);
-            }
-        }
+        // Default parent and subject
+        var parent = topCommentForHash(review.hash());
+        var subject = parent.subject();
 
-        if (contributor != null) {
-            var isReviewer = censusInstance.project().isReviewer(contributor.username(), censusInstance.configuration().census().version());
-            if (review.verdict() == Review.Verdict.APPROVED && isReviewer) {
-                var id = getMessageId(review, true);
-                if (!existingIds.containsKey(getStableMessageId(id))) {
-                    var parent = topEmail();
-                    var replyBody = ArchiveMessages.reviewApprovalBodyReviewer(contributor.username());
-                    addReplyCommon(parent, review.reviewer(), "Approved and Reviewed by " + contributor.username(), replyBody, id);
-                }
-            }
+        // Approvals by Reviewers get special treatment - post these as top-level comments
+        if (review.verdict() == Review.Verdict.APPROVED && isReviewer) {
+            parent = topEmail();
+            subject = "Approved and Reviewed by " + contributor.username();
         }
+
+        var userName = contributor != null ? contributor.username() : review.reviewer().userName() + "@" + censusInstance.namespace().name();
+        var userRole = contributor != null ? projectRole(contributor) : "none";
+        var replyBody = ArchiveMessages.reviewCommentBody(review.body().orElse(""), review.verdict(), userName, userRole);
+
+        addReplyCommon(parent, review.reviewer(), subject, replyBody, id);
     }
 
     void addReviewComment(ReviewComment reviewComment) {
         var id = getMessageId(reviewComment);
         if (existingIds.containsKey(getStableMessageId(id))) {
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -357,38 +357,45 @@
             // Make a change with a corresponding PR
             var editHash = CheckableRepository.appendAndCommit(localRepo);
             localRepo.push(editHash, author.getUrl(), "edit", true);
             var pr = credentials.createPullRequest(archive, "master", "edit", "This is a pull request");
             pr.setBody("This is now ready");
+            pr.addComment("Avoid combining");
+
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
+            listServer.processIncoming();
 
             // Make two file specific comments
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review comment");
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should contain a combined entry
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+            assertEquals(2, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
 
             // As well as the mailing list
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP());
             var mailmanList = mailmanServer.getList(listAddress.address());
             var conversations = mailmanList.conversations(Duration.ofDays(1));
             assertEquals(1, conversations.size());
             var mail = conversations.get(0).first();
             assertEquals("RFR: This is a pull request", mail.subject());
-            assertEquals(2, conversations.get(0).allMessages().size());
+            assertEquals(3, conversations.get(0).allMessages().size());
+
+            var commentReply = conversations.get(0).replies(mail).get(0);
+            assertEquals(2, commentReply.body().split("^On.*wrote:").length);
+            assertTrue(commentReply.body().contains("Avoid combining\n\n"), commentReply.body());
 
-            var reply = conversations.get(0).replies(mail).get(0);
-            assertEquals(2, reply.body().split("^On.*wrote:").length);
-            assertEquals(2, reply.body().split("> This is now ready").length, reply.body());
-            assertEquals("Re: RFR: This is a pull request", reply.subject());
-            assertTrue(reply.body().contains("Review comment\n\n"), reply.body());
-            assertTrue(reply.body().contains("Another review comment"), reply.body());
+            var reviewReply = conversations.get(0).replies(mail).get(1);
+            assertEquals(2, reviewReply.body().split("^On.*wrote:").length);
+            assertEquals(2, reviewReply.body().split("> This is now ready").length, reviewReply.body());
+            assertEquals("Re: RFR: This is a pull request", reviewReply.subject());
+            assertTrue(reviewReply.body().contains("Review comment\n\n"), reviewReply.body());
+            assertTrue(reviewReply.body().contains("Another review comment"), reviewReply.body());
         }
     }
 
     @Test
     void commentThreading(TestInfo testInfo) throws IOException {
@@ -444,24 +451,31 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
             listServer.processIncoming();
             listServer.processIncoming();
 
+            // Finally some approvals
+            pr.addReview(Review.Verdict.APPROVED, "Nice");
+            reviewPr.addReview(Review.Verdict.APPROVED, "Looks fine");
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+
             // Sanity check the archive
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
-            assertEquals(6, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+            assertEquals(8, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
 
             // Check the mailing list
             var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP());
             var mailmanList = mailmanServer.getList(listAddress.address());
             var conversations = mailmanList.conversations(Duration.ofDays(1));
             assertEquals(1, conversations.size());
             var mail = conversations.get(0).first();
             assertEquals("RFR: This is a pull request", mail.subject());
-            assertEquals(7, conversations.get(0).allMessages().size());
+            assertEquals(9, conversations.get(0).allMessages().size());
 
-            // There should be two separate threads
+            // There should be four separate threads
             var thread1 = conversations.get(0).replies(mail).get(0);
             assertEquals(2, thread1.body().split("^On.*wrote:").length);
             assertEquals(2, thread1.body().split("> This is now ready").length, thread1.body());
             assertEquals("Re: RFR: This is a pull request", thread1.subject());
             assertTrue(thread1.body().contains("Review comment\n\n"), thread1.body());
@@ -483,10 +497,15 @@
             assertTrue(thread2.body().contains("Another review comment"), thread2.body());
             var thread2reply1 = conversations.get(0).replies(thread2).get(0);
             assertTrue(thread2reply1.body().contains("Sounds good"));
             var thread2reply2 = conversations.get(0).replies(thread2reply1).get(0);
             assertTrue(thread2reply2.body().contains("Thanks"));
+
+            var thread3 = conversations.get(0).replies(mail).get(2);
+            assertEquals("Re: RFR: This is a pull request", thread3.subject());
+            var thread4 = conversations.get(0).replies(mail).get(3);
+            assertEquals("Re: Approved and Reviewed by integrationreviewer1", thread4.subject());
         }
     }
 
     @Test
     void reviewContext(TestInfo testInfo) throws IOException {
@@ -1002,11 +1021,11 @@
             Repository.materialize(archiveFolder.path(), archive.getUrl(), "master");
             assertEquals(1, archiveContainsCount(archiveFolder.path(), "Review status set to Approved"));
             if (author.host().supportsReviewBody()) {
                 assertEquals(1, archiveContainsCount(archiveFolder.path(), "Reason 2"));
             }
-            assertEquals(1, archiveContainsCount(archiveFolder.path(), "This PR has been marked as Reviewed by integrationreviewer1."));
+            assertEquals(1, archiveContainsCount(archiveFolder.path(), "Re: Approved and Reviewed by integrationreviewer1"));
 
             // Yet another change
             reviewedPr.addReview(Review.Verdict.DISAPPROVED, "Reason 3");
             TestBotRunner.runPeriodicItems(mlBot);
             TestBotRunner.runPeriodicItems(mlBot);
