diff a/core/coverage/pom.xml b/core/coverage/pom.xml
--- a/core/coverage/pom.xml
+++ b/core/coverage/pom.xml
@@ -41,10 +41,14 @@
 	</parent>
 	<artifactId>coverage</artifactId>
 	<name>Code coverage report jmc/core</name>
 	<packaging>pom</packaging>
 
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
+
 	<dependencies>
 		<!-- First all the modules in core/ -->
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>common</artifactId>
diff a/core/org.openjdk.jmc.agent/pom.xml b/core/org.openjdk.jmc.agent/pom.xml
--- a/core/org.openjdk.jmc.agent/pom.xml
+++ b/core/org.openjdk.jmc.agent/pom.xml
@@ -43,10 +43,11 @@
 		<maven.compiler.source>1.7</maven.compiler.source>
 		<maven.compiler.target>1.7</maven.compiler.target>
 		<asm.version>7.1</asm.version>
 		<junit.version>4.12</junit.version>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
 	</properties>
 	<build>
 		<plugins>
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
diff a/core/org.openjdk.jmc.common/pom.xml b/core/org.openjdk.jmc.common/pom.xml
--- a/core/org.openjdk.jmc.common/pom.xml
+++ b/core/org.openjdk.jmc.common/pom.xml
@@ -37,6 +37,9 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>common</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 </project>
diff a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/unit/UnitLookup.java b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/unit/UnitLookup.java
--- a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/unit/UnitLookup.java
+++ b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/unit/UnitLookup.java
@@ -446,11 +446,11 @@
 		memory.addFormatter(new KindOfQuantity.ExactFormatter<>(memory));
 		memory.addFormatter(new KindOfQuantity.VerboseFormatter<>(memory));
 
 		return memory;
 	}
-	
+
 	private static LinearKindOfQuantity createFrequency() {
 		LinearKindOfQuantity frequency = new LinearKindOfQuantity("frequency", "Hz", EnumSet.range(NONE, TERA),
 				EnumSet.range(YOCTO, YOTTA));
 
 		frequency.addFormatter(new LinearKindOfQuantity.AutoFormatter(frequency, "Dynamic"));
@@ -479,11 +479,11 @@
 		// UCUM defines the symbol "wk" for the week.
 		LinearUnit week = timeSpan.makeUnit("wk", day.quantity(7));
 		// The Julian year (annum, symbol "a") is defined by UCUM for use with SI, since it is the basis for the light year (so this is exact).
 		LinearUnit year = timeSpan.makeUnit("a", hour.quantity(8766));
 		// A mean Julian month is 1/12 of a Julian year = 365.25*24/12 h = 730.5 h = 43 830 min (exactly).
-//		LinearUnit month = timeSpan.makeUnit("mo", minute.quantity(43830));
+		// LinearUnit month = timeSpan.makeUnit("mo", minute.quantity(43830));
 
 		LinearUnit[] units = {minute, hour, day, week, year};
 		for (LinearUnit unit : units) {
 			timeSpan.addUnit(unit);
 		}
diff a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/util/TypeHandling.java b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/util/TypeHandling.java
--- a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/util/TypeHandling.java
+++ b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/util/TypeHandling.java
@@ -231,21 +231,14 @@
 		}
 		return false;
 	}
 
 	/**
-	 * Check for missing values, and return the numeric value in string format
-	 *
-	 * JMC-6256: JMC doesn't respect Long.MIN_VALUE as a missing value
-	 *
-	 * As per the bug report, the following values should be considered "missing"
-	 * - Integer.MIN_VALUE
-	 * - Long.MIN_VALUE
-	 * - Double.NaN
-	 * - Double.NEGATIVE_INFINITY
-	 * - Float.NaN
-	 * - Float.NEGATIVE_INFINITY
+	 * Check for missing values, and return the numeric value in string format JMC-6256: JMC doesn't
+	 * respect Long.MIN_VALUE as a missing value As per the bug report, the following values should
+	 * be considered "missing" - Integer.MIN_VALUE - Long.MIN_VALUE - Double.NaN -
+	 * Double.NEGATIVE_INFINITY - Float.NaN - Float.NEGATIVE_INFINITY
 	 *
 	 * @param value
 	 *            the numeric value to be converted to a string
 	 * @return a string with the numeric value, or a N/A message
 	 */
@@ -259,20 +252,21 @@
 			if (value.longValue() == Long.MIN_VALUE) {
 				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP), LONG_MIN_VALUE));
 			}
 		} else if (value.getClass() == Double.class) {
 			if (value.doubleValue() == Double.NEGATIVE_INFINITY) {
-				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP), DOUBLE_NEGATIVE_INFINITY));
+				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP),
+						DOUBLE_NEGATIVE_INFINITY));
 			} else if (Double.isNaN(value.doubleValue())) {
 				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP), DOUBLE_NAN));
 			}
 		} else if (value.getClass() == Float.class) {
 			if (Float.isNaN(value.floatValue())) {
 				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP), FLOAT_NAN));
-			}
-			else if (value.floatValue() == Float.NEGATIVE_INFINITY) {
-				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP), FLOAT_NEGATIVE_INFINITY));
+			} else if (value.floatValue() == Float.NEGATIVE_INFINITY) {
+				sb.append(MessageFormat.format(Messages.getString(Messages.MISSING_VALUE_TOOLTIP),
+						FLOAT_NEGATIVE_INFINITY));
 			}
 		}
 		if (sb.length() == 0) {
 			sb.append(TypeHandling.getValueString(value));
 		}
diff a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/version/JavaVersionSupport.java b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/version/JavaVersionSupport.java
--- a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/version/JavaVersionSupport.java
+++ b/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/version/JavaVersionSupport.java
@@ -60,8 +60,8 @@
 	public static final JavaVersion DEBUG_NON_SAFEPOINTS_IMPLICITLY_ENABLED = JDK_9;
 	// FIXME: Update this if JDK-8054307 is ever backported to 8uX.
 	public static final JavaVersion STRING_IS_BYTE_ARRAY = JDK_9;
 	public static final JavaVersion JDK_11_EA = new JavaVersion(true, 11);
 	public static final JavaVersion JFR_NOT_COMMERCIAL = JDK_11_EA;
-	public static final JavaVersion JDK_11 = new JavaVersion(11,0);
-	public static final JavaVersion JDK_12 = new JavaVersion(12,0);
+	public static final JavaVersion JDK_11 = new JavaVersion(11, 0);
+	public static final JavaVersion JDK_12 = new JavaVersion(12, 0);
 }
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/pom.xml b/core/org.openjdk.jmc.flightrecorder.rules.jdk/pom.xml
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/pom.xml
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/pom.xml
@@ -37,10 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>flightrecorder.rules.jdk</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>common</artifactId>
 			<version>${project.version}</version>
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/cpu/CompareCpuRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/cpu/CompareCpuRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/cpu/CompareCpuRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/cpu/CompareCpuRule.java
@@ -90,12 +90,12 @@
 			return RulesToolkit.getMissingAttributeResult(this, cpuLoadType, JdkAttributes.JVM_TOTAL);
 		}
 		// FIXME: Could consider using the infoLimit for the span instead?
 		SpanLimit maxOtherCpu = SpanToolkit.getMaxSpanLimit(cpuItems, JdkAttributes.OTHER_CPU, JfrAttributes.END_TIME,
 				warningLimit);
-		SpanLimit maxOtherCpuRatio = SpanToolkit.getMaxSpanLimit(cpuItems, JdkAttributes.OTHER_CPU_RATIO, JfrAttributes.END_TIME,
-				warningLimit);
+		SpanLimit maxOtherCpuRatio = SpanToolkit.getMaxSpanLimit(cpuItems, JdkAttributes.OTHER_CPU_RATIO,
+				JfrAttributes.END_TIME, warningLimit);
 
 		if (maxOtherCpu == null || maxOtherCpuRatio == null) {
 			return RulesToolkit.getNotApplicableResult(this,
 					Messages.getString(Messages.CompareCpuRule_TEXT_TOO_FEW_SAMPLES));
 		}
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/dataproviders/JvmInternalsDataProvider.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/dataproviders/JvmInternalsDataProvider.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/dataproviders/JvmInternalsDataProvider.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/dataproviders/JvmInternalsDataProvider.java
@@ -55,11 +55,10 @@
 	 * comparison is done with 'c:/myjar.jar').
 	 */
 	private static final String[] OPTIONS = new String[] {"-XX", "-javaagent", "-agent"};
 	private static final Map<String, String> EQUIVALENT = new HashMap<>();
 
-
 	static {
 		putBiMap("-Xbatch", "BackgroundCompilation");
 		putBiMap("-Xmaxjitcodesize", "ReservedCodeCacheSize");
 		putBiMap("-Xmx", "MaxHeapSize");
 		putBiMap("-Xmn", "NewSize");
@@ -153,14 +152,13 @@
 					dupes.put(flag, new ArrayList<String>());
 					dupes.get(flag).add(seenFlags.get(flag));
 				}
 				dupes.get(flag).add(fullArgument);
 
-			}
-			else {
+			} else {
 				seenFlags.put(flag, fullArgument);
-			}		
+			}
 		}
 		return dupes.values();
 	}
 
 	private static String scrubPrefix(String argument, String prefix) {
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/exceptions/FatalErrorRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/exceptions/FatalErrorRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/exceptions/FatalErrorRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/exceptions/FatalErrorRule.java
@@ -52,16 +52,16 @@
 import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;
 import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;
 import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;
 
 public class FatalErrorRule implements IRule {
-	
+
 	private static final String RESULT_ID = "Fatal Errors"; //$NON-NLS-1$
-	
+
 	private static final String ERROR_REASON = "VM Error"; //$NON-NLS-1$
 	private static final String INFO_REASON = "No remaining non-daemon Java threads"; //$NON-NLS-1$
-	
+
 	private FutureTask<Result> evaluationTask;
 
 	@Override
 	public RunnableFuture<Result> evaluate(final IItemCollection items, final IPreferenceValueProvider valueProvider) {
 		evaluationTask = new FutureTask<>(new Callable<Result>() {
@@ -70,31 +70,32 @@
 				return getResult(items, valueProvider);
 			}
 		});
 		return evaluationTask;
 	}
-	
+
 	private Result getResult(IItemCollection items, IPreferenceValueProvider valueProvider) {
 		EventAvailability eventAvailability = RulesToolkit.getEventAvailability(items, JdkTypeIDs.VM_SHUTDOWN);
 		if (eventAvailability != EventAvailability.AVAILABLE) {
 			return RulesToolkit.getEventAvailabilityResult(this, items, eventAvailability, JdkTypeIDs.VM_SHUTDOWN);
 		}
-		
+
 		IItemFilter shutdownFilter = ItemFilters.type(JdkTypeIDs.VM_SHUTDOWN);
 		IItemCollection shutdownItems = items.apply(shutdownFilter);
-		
+
 		if (shutdownItems.hasItems()) {
 			// Check the type of VM Shutdown, if it was a VM Error we should report it.
 			if (shutdownItems.apply(ItemFilters.contains(JdkAttributes.SHUTDOWN_REASON, ERROR_REASON)).hasItems()) {
 				String message = Messages.getString(Messages.FatalErrorRule_TEXT_WARN);
 				return new Result(this, 100, message);
-			} else if (shutdownItems.apply(ItemFilters.contains(JdkAttributes.SHUTDOWN_REASON, INFO_REASON)).hasItems()) {
+			} else if (shutdownItems.apply(ItemFilters.contains(JdkAttributes.SHUTDOWN_REASON, INFO_REASON))
+					.hasItems()) {
 				String message = Messages.getString(Messages.FatalErrorRule_TEXT_INFO);
 				return new Result(this, 25, message);
 			}
 		}
-		
+
 		return new Result(this, 0, Messages.getString(Messages.FatalErrorRule_TEXT_OK));
 	}
 
 	@Override
 	public Collection<TypedPreference<?>> getConfigurationAttributes() {
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/DuplicateFlagsRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/DuplicateFlagsRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/DuplicateFlagsRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/DuplicateFlagsRule.java
@@ -72,13 +72,12 @@
 		IItemCollection jvmInfoItems = items.apply(JdkFilters.VM_INFO);
 
 		// FIXME: Should we check if there are different jvm args in different chunks?
 		Set<String> args = jvmInfoItems.getAggregate(Aggregators.distinct(JdkAttributes.JVM_ARGUMENTS));
 		if (args != null && !args.isEmpty()) {
-			
-			Collection<ArrayList<String>> dupes = JvmInternalsDataProvider.
-					checkDuplicates(args.iterator().next());
+
+			Collection<ArrayList<String>> dupes = JvmInternalsDataProvider.checkDuplicates(args.iterator().next());
 
 			if (!dupes.isEmpty()) {
 				StringBuilder sb = new StringBuilder();
 				sb.append("<ul>"); //$NON-NLS-1$
 				for (ArrayList<String> dupe : dupes) {
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/FlightRecordingSupportRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/FlightRecordingSupportRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/FlightRecordingSupportRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/general/FlightRecordingSupportRule.java
@@ -77,11 +77,11 @@
 
 		double versionScore = versionResult.getScore();
 		double timeConversionScore = timeConversionResult.getScore();
 
 		if (versionScore > 0 || timeConversionScore > 0) {
-			return versionResult.getScore() > timeConversionResult.getScore() ? versionResult : timeConversionResult;			
+			return versionResult.getScore() > timeConversionResult.getScore() ? versionResult : timeConversionResult;
 		}
 		// If no rule reported a warning or error, return the rule with the lowest score,
 		// meaning it was NotApplicable, Failed or Ignored.
 		return versionScore < timeConversionScore ? versionResult : timeConversionResult;
 	}
@@ -120,11 +120,11 @@
 	private Result getVersionResult(String versionString) {
 		JavaVersion usedVersion = RulesToolkit.getJavaVersion(versionString);
 
 		if (usedVersion == null) {
 			return RulesToolkit.getNotApplicableResult(this,
-                    Messages.getString(Messages.General_TEXT_COULD_NOT_DETERMINE_JAVA_VERSION));
+					Messages.getString(Messages.General_TEXT_COULD_NOT_DETERMINE_JAVA_VERSION));
 		}
 
 		if (!usedVersion.isGreaterOrEqualThan(JDK_7_U_40)) {
 			return new Result(this, 100,
 					Messages.getString(Messages.FlightRecordingSupportRule_UNSUPPORTED_TEXT_WARN_SHORT),
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/JavaBlockingRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/JavaBlockingRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/JavaBlockingRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/JavaBlockingRule.java
@@ -127,15 +127,15 @@
 
 		// Significant blocking detected - do more calculations
 		String mostBlockingText;
 		if (byThread.compareTo(byInstance) > 0) {
 			List<IntEntry<IMCThread>> groupedByThread = RulesToolkit.calculateGroupingScore(
-					items.apply(ItemFilters.type(JdkTypeIDs.MONITOR_ENTER)),JfrAttributes.EVENT_THREAD);
+					items.apply(ItemFilters.type(JdkTypeIDs.MONITOR_ENTER)), JfrAttributes.EVENT_THREAD);
 			IntEntry<IMCThread> mostBlockedThread = groupedByThread.get(groupedByThread.size() - 1);
 
-			IItemCollection mostBlockedThreadOccurences = items.apply(
-					ItemFilters.equals(JfrAttributes.EVENT_THREAD, mostBlockedThread.getKey()));
+			IItemCollection mostBlockedThreadOccurences = items
+					.apply(ItemFilters.equals(JfrAttributes.EVENT_THREAD, mostBlockedThread.getKey()));
 			IQuantity mostBlockingTime = mostBlockedThreadOccurences.getAggregate(JdkAggregators.TOTAL_BLOCKED_TIME);
 
 			mostBlockingText = MessageFormat.format(
 					Messages.getString(Messages.JavaBlockingRule_TEXT_MOST_BLOCKED_THREAD),
 					Encode.forHtml(mostBlockedThread.getKey().getThreadName()), mostBlockedThread.getValue(),
@@ -143,12 +143,12 @@
 		} else {
 			List<IntEntry<IMCType>> groupedByClass = RulesToolkit.calculateGroupingScore(
 					items.apply(ItemFilters.type(JdkTypeIDs.MONITOR_ENTER)), JdkAttributes.MONITOR_CLASS);
 			IntEntry<IMCType> mostBlockingClass = groupedByClass.get(groupedByClass.size() - 1);
 
-			IItemCollection mostBlockedClassOccurences = items.apply(
-					ItemFilters.equals(JdkAttributes.MONITOR_CLASS, mostBlockingClass.getKey()));
+			IItemCollection mostBlockedClassOccurences = items
+					.apply(ItemFilters.equals(JdkAttributes.MONITOR_CLASS, mostBlockingClass.getKey()));
 			IQuantity mostBlockingTime = mostBlockedClassOccurences.getAggregate(JdkAggregators.TOTAL_BLOCKED_TIME);
 
 			mostBlockingText = MessageFormat.format(
 					Messages.getString(Messages.JavaBlockingRule_TEXT_MOST_BLOCKED_CLASS),
 					Encode.forHtml(mostBlockingClass.getKey().getTypeName()), mostBlockingClass.getValue(),
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
@@ -150,11 +150,12 @@
 		IMCStackTrace path;
 		IQuantity ratioOfAllPossibleSamples;
 		IQuantity ratioOfActualSamples;
 		IRange<IQuantity> window;
 
-		public MethodProfilingWindowResult(IMCMethod method, IMCStackTrace path, IQuantity ratio, IQuantity actualRatio, IRange<IQuantity> window) {
+		public MethodProfilingWindowResult(IMCMethod method, IMCStackTrace path, IQuantity ratio, IQuantity actualRatio,
+				IRange<IQuantity> window) {
 			this.method = method;
 			this.path = path;
 			this.ratioOfAllPossibleSamples = ratio;
 			this.ratioOfActualSamples = actualRatio;
 			this.window = window;
@@ -177,11 +178,12 @@
 	public static final TypedPreference<String> EXCLUDED_PACKAGE_REGEXP = new TypedPreference<>(
 			"method.profiling.evaluation.excluded.package", //$NON-NLS-1$
 			Messages.getString(Messages.MethodProfilingRule_EXCLUDED_PACKAGES),
 			Messages.getString(Messages.MethodProfilingRule_EXCLUDED_PACKAGES_DESC),
 			UnitLookup.PLAIN_TEXT.getPersister(), "java\\.(lang|util)"); //$NON-NLS-1$
-	private static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays.<TypedPreference<?>> asList(WINDOW_SIZE, EXCLUDED_PACKAGE_REGEXP);
+	private static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays.<TypedPreference<?>> asList(WINDOW_SIZE,
+			EXCLUDED_PACKAGE_REGEXP);
 
 	/**
 	 * Private Callable implementation specifically used to avoid storing the FutureTask as a field.
 	 */
 	private class MethodProfilingCallable implements Callable<Result> {
@@ -267,16 +269,14 @@
 					mostInterestingResult.ratioOfActualSamples.displayUsing(IDisplayable.AUTO));
 			String formattedPath = "<ul>" + //$NON-NLS-1$
 					FormatToolkit.getHumanReadable(mostInterestingResult.path, false, false, true, true, true, false,
 							MAX_STACK_DEPTH, null, "<li>", //$NON-NLS-1$
 							"</li>" //$NON-NLS-1$
-							) + "</ul>"; //$NON-NLS-1$
+					) + "</ul>"; //$NON-NLS-1$
 			String longDescription = MessageFormat.format(
-					Messages.getString(Messages.HotMethodsRuleFactory_TEXT_INFO_LONG),
-					buildResultList(percentByMethod),
-					formattedPath
-					);
+					Messages.getString(Messages.HotMethodsRuleFactory_TEXT_INFO_LONG), buildResultList(percentByMethod),
+					formattedPath);
 			result = new Result(this, mappedScore, shortDescription, shortDescription + "<p>" + longDescription); //$NON-NLS-1$
 		}
 		return result;
 	}
 
@@ -337,20 +337,22 @@
 	 * @return an IUnorderedWindowVisitor implementation that will populate the rawScores list with
 	 *         raw score values
 	 */
 	private IUnorderedWindowVisitor createWindowVisitor(
 		final PeriodRangeMap settings, final IItemFilter settingsFilter, final IQuantity windowSize,
-		final List<MethodProfilingWindowResult> rawScores, final FutureTask<Result> evaluationTask, final Pattern excludes) {
+		final List<MethodProfilingWindowResult> rawScores, final FutureTask<Result> evaluationTask,
+		final Pattern excludes) {
 		return new IUnorderedWindowVisitor() {
 			@Override
 			public void visitWindow(IItemCollection items, IQuantity startTime, IQuantity endTime) {
 				IRange<IQuantity> windowRange = QuantityRange.createWithEnd(startTime, endTime);
 				if (RulesToolkit.getSettingMaxPeriod(items, JdkTypeIDs.EXECUTION_SAMPLE) == null) {
-					Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> resultPair = performCalculation(items, settings.getSetting(startTime));
+					Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> resultPair = performCalculation(items,
+							settings.getSetting(startTime));
 					if (resultPair != null) {
-						rawScores.add(new MethodProfilingWindowResult(resultPair.right.getFrames().get(0).getMethod(), resultPair.right,
-								resultPair.left.left, resultPair.left.right, windowRange));
+						rawScores.add(new MethodProfilingWindowResult(resultPair.right.getFrames().get(0).getMethod(),
+								resultPair.right, resultPair.left.left, resultPair.left.right, windowRange));
 					}
 				} else {
 					Set<IQuantity> settingTimes = items.apply(settingsFilter)
 							.getAggregate(Aggregators.distinct(JfrAttributes.START_TIME));
 					IQuantity start = startTime;
@@ -365,12 +367,13 @@
 					for (Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> score : scores) {
 						if (score != null) {
 							if (scoresByMethod.get(score.right) == null) {
 								scoresByMethod.put(score.right, score.left);
 							} else {
-								scoresByMethod.put(score.right, new Pair<>(score.left.left.add(scoresByMethod.get(score.right).left),
-										score.left.right.add(scoresByMethod.get(score.right).right)));
+								scoresByMethod.put(score.right,
+										new Pair<>(score.left.left.add(scoresByMethod.get(score.right).left),
+												score.left.right.add(scoresByMethod.get(score.right).right)));
 							}
 						}
 					}
 					IQuantity sumScore = UnitLookup.PERCENT_UNITY.quantity(0);
 					IQuantity actualScore = UnitLookup.PERCENT_UNITY.quantity(0);
@@ -382,11 +385,12 @@
 							sumScore = sumScore.add(entry.getValue().left);
 						}
 					}
 					IQuantity averageOfAllPossibleSamples = sumScore.multiply(1d / scores.size());
 					IMCMethod hottestMethod = (hottestPath == null ? null : hottestPath.getFrames().get(0).getMethod());
-					rawScores.add(new MethodProfilingWindowResult(hottestMethod, hottestPath, averageOfAllPossibleSamples, actualScore, windowRange));
+					rawScores.add(new MethodProfilingWindowResult(hottestMethod, hottestPath,
+							averageOfAllPossibleSamples, actualScore, windowRange));
 				}
 			}
 
 			@Override
 			public boolean shouldContinue() {
@@ -401,11 +405,12 @@
 			 * @param period
 			 *            the periodicity to base the relevancy calculation on
 			 * @return a double value in the interval [0,1] with 1 being a system in completely
 			 *         saturated load with only one method called
 			 */
-			private Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> performCalculation(IItemCollection items, IQuantity period) {
+			private Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> performCalculation(
+				IItemCollection items, IQuantity period) {
 				IItemCollection filteredItems = items.apply(JdkFilters.EXECUTION_SAMPLE);
 				final IMCMethod[] maxMethod = new IMCMethod[1];
 				final IMCStackTrace[] maxPath = new IMCStackTrace[1];
 				// Using this GroupingAggregator because it's the only way to extract the keys from the aggregation along with values
 				IAggregator<IQuantity, ?> aggregator = GroupingAggregator.build("", "", //$NON-NLS-1$ //$NON-NLS-2$
@@ -416,11 +421,12 @@
 							public IType<IQuantity> getValueType() {
 								return UnitLookup.NUMBER;
 							}
 
 							@Override
-							public IQuantity getValue(Iterable<? extends GroupEntry<IMCStackTrace, CountConsumer>> groupEntries) {
+							public IQuantity getValue(
+								Iterable<? extends GroupEntry<IMCStackTrace, CountConsumer>> groupEntries) {
 								HashMap<IMCMethod, IQuantity> map = new HashMap<>();
 								HashMap<IMCMethod, IMCStackTrace> pathMap = new HashMap<>();
 								int total = 0;
 								// When we group by stack trace we can run into situations where the top frames are otherwise the same
 								// for our purposes (finding the hottest method), but they differ by BCI, throwing off the count.
@@ -429,29 +435,33 @@
 									IMCStackTrace trace = processPath(group.getKey());
 									total += group.getConsumer().getCount();
 									if (!trace.getFrames().isEmpty()) {
 										IMCMethod topFrameMethod = trace.getFrames().get(0).getMethod();
 										if (map.get(topFrameMethod) == null) {
-											map.put(topFrameMethod, UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount()));
+											map.put(topFrameMethod,
+													UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount()));
 											pathMap.put(topFrameMethod, trace);
 										} else {
 											IQuantity old = map.get(topFrameMethod);
-											map.put(topFrameMethod, old.add(UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount())));
+											map.put(topFrameMethod, old.add(
+													UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount())));
 										}
 									}
 								}
 								if (!pathMap.isEmpty() && !map.isEmpty()) {
-									Entry<IMCMethod, IQuantity> topEntry = Collections.max(map.entrySet(), new Comparator<Entry<IMCMethod, IQuantity>>() {
-										@Override
-										public int compare(Entry<IMCMethod, IQuantity> arg0,
-												Entry<IMCMethod, IQuantity> arg1) {
-											return arg0.getValue().compareTo(arg1.getValue());
-										}
-									});
+									Entry<IMCMethod, IQuantity> topEntry = Collections.max(map.entrySet(),
+											new Comparator<Entry<IMCMethod, IQuantity>>() {
+												@Override
+												public int compare(
+													Entry<IMCMethod, IQuantity> arg0,
+													Entry<IMCMethod, IQuantity> arg1) {
+													return arg0.getValue().compareTo(arg1.getValue());
+												}
+											});
 									maxPath[0] = pathMap.get(topEntry.getKey());
 									maxMethod[0] = topEntry.getKey();
-									return topEntry.getValue().multiply(1d/total);
+									return topEntry.getValue().multiply(1d / total);
 								}
 								return UnitLookup.NUMBER_UNITY.quantity(0);
 							}
 
 							private IMCStackTrace processPath(IMCStackTrace path) {
@@ -469,11 +479,11 @@
 									}
 								}
 								frames.removeAll(framesToDrop);
 								return new MCStackTrace(frames, path.getTruncationState());
 							}
-				});
+						});
 
 				IQuantity maxRatio = filteredItems.getAggregate(aggregator);
 				Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> result = null;
 				if (maxMethod[0] != null && maxRatio != null && period != null) { // ignoring if there are no samples or if we don't yet know the periodicity
 					double periodsPerSecond = 1 / period.doubleValueIn(UnitLookup.SECOND);
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
@@ -66,21 +66,21 @@
  * Rule that checks how much of the total allocation is caused by possible primitive to object
  * conversion. Looks at top frames and searches for java.lang.BoxType.valueOf.
  */
 // FIXME: Rename class (and message constants) from autoboxing to something more generic?
 public class AutoBoxingRule extends AbstractRule {
-	
+
 	private static final String VALUE_OF_METHOD_NAME = "valueOf";
 	private static final String SHORT = "java.lang.Short";
 	private static final String LONG = "java.lang.Long";
 	private static final String INTEGER = "java.lang.Integer";
 	private static final String FLOAT = "java.lang.Float";
 	private static final String DOUBLE = "java.lang.Double";
 	private static final String CHARACTER = "java.lang.Character";
 	private static final String BYTE = "java.lang.Byte";
 	private static final String BOOLEAN = "java.lang.Boolean";
-	
+
 	private static final IPredicate<IMCMethod> IS_AUTOBOXED_PREDICATE = new IPredicate<IMCMethod>() {
 		@Override
 		public boolean evaluate(IMCMethod method) {
 			String type = method.getType().getFullName();
 			if (VALUE_OF_METHOD_NAME.equals(method.getMethodName())) {
@@ -103,11 +103,11 @@
 				}
 			}
 			return false;
 		}
 	};
-	
+
 	private static final TypedPreference<IQuantity> AUTOBOXING_RATIO_INFO_LIMIT = new TypedPreference<>(
 			"autoboxing.ratio.info.limit", //$NON-NLS-1$
 			Messages.getString(Messages.AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT),
 			Messages.getString(Messages.AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT_DESC), UnitLookup.PERCENTAGE,
 			UnitLookup.PERCENT.quantity(20));
@@ -160,11 +160,12 @@
 					if (firstBranch.getTailFrames().length > 0) {
 						secondFrame = firstBranch.getTailFrames()[0];
 					} else if (firstBranch.getEndFork().getBranchCount() > 0) {
 						secondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();
 					}
-					secondFrameFromMostAllocated = StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep, false, false, true, true, true, false);
+					secondFrameFromMostAllocated = StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep,
+							false, false, true, true, true, false);
 				}
 				allocationSizeByType.put(method.getType(), total);
 			}
 		}
 		if (allocationSizeByType.size() == 0) {
@@ -183,11 +184,12 @@
 			String fullName = largestAllocatedType.getFullName();
 			mostAllocatedTypeInfo = " " + MessageFormat //$NON-NLS-1$
 					.format(Messages.getString(Messages.AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE), fullName);
 			mostAllocatedTypeInfoLong = "<p>" //$NON-NLS-1$
 					+ MessageFormat.format(Messages.getString(Messages.AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE_LONG),
-							fullName, largestAllocatedByType.displayUsing(IDisplayable.AUTO), secondFrameFromMostAllocated);
+							fullName, largestAllocatedByType.displayUsing(IDisplayable.AUTO),
+							secondFrameFromMostAllocated);
 		}
 
 		String shortIntro = MessageFormat.format(Messages.getString(Messages.AutoboxingRule_RESULT_AUTOBOXING_RATIO),
 				Math.round(possibleAutoboxingRatio), sizeOfAllBoxedAllocations.displayUsing(IDisplayable.AUTO));
 		String shortMessage = shortIntro + mostAllocatedTypeInfo;
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/FullGcRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/FullGcRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/FullGcRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/FullGcRule.java
@@ -71,51 +71,40 @@
 		return new FutureTask<>(new Callable<Result>() {
 			@Override
 			public Result call() throws Exception {
 				final CollectorType collectorType = CollectorType.getOldCollectorType(items);
 				if (!(CollectorType.CMS.equals(collectorType) || CollectorType.G1_OLD.equals(collectorType))) {
-					return RulesToolkit.getNotApplicableResult(
-							FullGcRule.this,
-							Messages.getString(Messages.FullGcRule_OTHER_COLLECTOR_IN_USE)
-							);
+					return RulesToolkit.getNotApplicableResult(FullGcRule.this,
+							Messages.getString(Messages.FullGcRule_OTHER_COLLECTOR_IN_USE));
 				}
 
 				final String[] eventTypes;
 				if (CollectorType.CMS.equals(collectorType)) {
-					eventTypes = new String[] { JdkTypeIDs.GC_COLLECTOR_OLD_GARBAGE_COLLECTION };
+					eventTypes = new String[] {JdkTypeIDs.GC_COLLECTOR_OLD_GARBAGE_COLLECTION};
 				} else {
 					eventTypes = G1Aggregator.EVENT_TYPES;
 				}
 				if (!hasAvailableEvents(items, eventTypes)) {
-					return RulesToolkit.getEventAvailabilityResult(
-							FullGcRule.this,
-							items,
-							RulesToolkit.getEventAvailability(items, eventTypes),
-							eventTypes
-							);
+					return RulesToolkit.getEventAvailabilityResult(FullGcRule.this, items,
+							RulesToolkit.getEventAvailability(items, eventTypes), eventTypes);
 				}
 
 				final int fullGCs;
 				if (CollectorType.CMS.equals(collectorType)) {
-					final IQuantity c = items.getAggregate(Aggregators.count(null, null, JdkFilters.OLD_GARBAGE_COLLECTION));
+					final IQuantity c = items
+							.getAggregate(Aggregators.count(null, null, JdkFilters.OLD_GARBAGE_COLLECTION));
 					fullGCs = c == null ? 0 : c.clampedIntFloorIn(NUMBER_UNITY);
 				} else {
 					fullGCs = items.getAggregate(new G1Aggregator()).fullGCs;
 				}
 
 				if (fullGCs > 0) {
-					return new Result(
-							FullGcRule.this, 100,
+					return new Result(FullGcRule.this, 100,
 							Messages.getString(Messages.FullGcRule_FULL_GC_OCCURRED_TITLE),
-							Messages.getString(Messages.FullGcRule_FULL_GC_OCCURRED_DESC)
-							);
+							Messages.getString(Messages.FullGcRule_FULL_GC_OCCURRED_DESC));
 				} else {
-					return new Result(
-							FullGcRule.this,
-							0,
-							Messages.getString(Messages.FullGcRule_NO_FULL_GC_OCCURRED)
-							);
+					return new Result(FullGcRule.this, 0, Messages.getString(Messages.FullGcRule_NO_FULL_GC_OCCURRED));
 				}
 			}
 		});
 	}
 
@@ -142,11 +131,11 @@
 	public String getTopic() {
 		return JfrRuleTopics.GARBAGE_COLLECTION_TOPIC;
 	}
 
 	private static class G1Aggregator extends MergingAggregator<G1FullGCInfo, G1FullGCInfo> {
-		static final String[] EVENT_TYPES = new String[] { JdkTypeIDs.GARBAGE_COLLECTION };
+		static final String[] EVENT_TYPES = new String[] {JdkTypeIDs.GARBAGE_COLLECTION};
 
 		G1Aggregator() {
 			super(null, null, UnitLookup.UNKNOWN);
 		}
 
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GarbageCollectionsInfo.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GarbageCollectionsInfo.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GarbageCollectionsInfo.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GarbageCollectionsInfo.java
@@ -87,11 +87,12 @@
 			systemGcCount++;
 		} else {
 			if (cause.contains("gclocker")) { //$NON-NLS-1$
 				gcLockers++;
 			}
-			if (!nonRequestedSerialOldGc && CollectorType.SERIAL_OLD.getCollectorName().equals(nameAccessor.getMember(item))) {
+			if (!nonRequestedSerialOldGc
+					&& CollectorType.SERIAL_OLD.getCollectorName().equals(nameAccessor.getMember(item))) {
 				nonRequestedSerialOldGc = true;
 			}
 		}
 		gcCount++;
 
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcStallRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcStallRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcStallRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcStallRule.java
@@ -95,12 +95,11 @@
 					JdkQueries.CONCURRENT_MODE_FAILURE);
 		}
 
 		EventAvailability eventAvailability = RulesToolkit.getEventAvailability(items,
 				JdkTypeIDs.CONCURRENT_MODE_FAILURE, JdkTypeIDs.GC_CONF, JdkTypeIDs.GARBAGE_COLLECTION);
-		if (eventAvailability != EventAvailability.AVAILABLE
-				&& eventAvailability != EventAvailability.ENABLED) {
+		if (eventAvailability != EventAvailability.AVAILABLE && eventAvailability != EventAvailability.ENABLED) {
 			return RulesToolkit.getEventAvailabilityResult(this, items, eventAvailability,
 					JdkTypeIDs.CONCURRENT_MODE_FAILURE, JdkTypeIDs.GC_CONF, JdkTypeIDs.GARBAGE_COLLECTION);
 		}
 		return new Result(this, 0, Messages.getString(Messages.GcStallRule_TEXT_OK));
 	}
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/HighGcRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/HighGcRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/HighGcRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/HighGcRule.java
@@ -84,12 +84,12 @@
 			String message = MessageFormat.format(Messages.getString(Messages.HighGcRuleFactory_TEXT_INFO), duration,
 					startTime, pausePercent.displayUsing(IDisplayable.AUTO));
 			String longMessage = message + " " + Messages.getString(Messages.HighGcRuleFactory_TEXT_INFO_LONG); //$NON-NLS-1$
 			if (!RulesToolkit.isEventsEnabled(items, JdkTypeIDs.ALLOC_INSIDE_TLAB, JdkTypeIDs.ALLOC_OUTSIDE_TLAB)) {
 				longMessage = longMessage + "<p>" //$NON-NLS-1$
-						+ RulesToolkit.getEnabledEventTypesRecommendation(items,
-								JdkTypeIDs.ALLOC_INSIDE_TLAB, JdkTypeIDs.ALLOC_OUTSIDE_TLAB);
+						+ RulesToolkit.getEnabledEventTypesRecommendation(items, JdkTypeIDs.ALLOC_INSIDE_TLAB,
+								JdkTypeIDs.ALLOC_OUTSIDE_TLAB);
 			}
 			return new Result(this, score, message, longMessage, JdkQueries.GC_PAUSE);
 		}
 		return new Result(this, 0, Messages.getString(Messages.HighGcRuleFactory_TEXT_OK), null, JdkQueries.GC_PAUSE);
 	}
diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/IncreasingLiveSetRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/IncreasingLiveSetRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/IncreasingLiveSetRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/IncreasingLiveSetRule.java
@@ -93,12 +93,12 @@
 	public static final TypedPreference<IQuantity> RELEVANCE_THRESHOLD = new TypedPreference<>(
 			"memleak.reference.tree.depth", Messages.getString(Messages.IncreasingLiveSetRule_RELEVANCE_THRESHOLD), //$NON-NLS-1$
 			Messages.getString(Messages.IncreasingLiveSetRule_RELEVANCE_THRESHOLD_DESC), NUMBER,
 			NUMBER_UNITY.quantity(0.5d));
 	public static final TypedPreference<IQuantity> YOUNG_COLLECTION_THRESHOLD = new TypedPreference<IQuantity>(
-			"memleak.young.collections", Messages.getString(Messages.IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD), 
-			Messages.getString(Messages.IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD_DESC), NUMBER, 
+			"memleak.young.collections", Messages.getString(Messages.IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD),
+			Messages.getString(Messages.IncreasingLiveSetRule_YOUNG_COLLECTION_THRESHOLD_DESC), NUMBER,
 			NUMBER_UNITY.quantity(4));
 	private static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays
 			.<TypedPreference<?>> asList(CLASSES_LOADED_PERCENT, RELEVANCE_THRESHOLD, YOUNG_COLLECTION_THRESHOLD);
 
 	private Result getResult(IItemCollection items, IPreferenceValueProvider valueProvider) {
@@ -131,17 +131,19 @@
 				return RulesToolkit.getTooFewEventsResult(this);
 			}
 			double relativeIncreasePerSecond = liveSetIncreasePerSecond.ratioTo(postWarmupHeapSize);
 			score = RulesToolkit.mapExp100(relativeIncreasePerSecond, PERCENT_OF_HEAP_INCREASE_PER_SECOND);
 		}
-		
-		IQuantity youngCollections = items.getAggregate(Aggregators.count(ItemFilters.type(JdkTypeIDs.GC_COLLECTOR_YOUNG_GARBAGE_COLLECTION)));
+
+		IQuantity youngCollections = items
+				.getAggregate(Aggregators.count(ItemFilters.type(JdkTypeIDs.GC_COLLECTOR_YOUNG_GARBAGE_COLLECTION)));
 		IQuantity oldCollections = items.getAggregate(Aggregators.count(JdkFilters.OLD_GARBAGE_COLLECTION));
-		if (oldCollections.longValue() == 0) { 
+		if (oldCollections.longValue() == 0) {
 			// If there are no old collections we cannot accurately determine whether or not there is a leak
 			// but a stable increase in live set over a recording is still interesting, since it could force a full GC eventually.
-			if (youngCollections.longValue() <= valueProvider.getPreferenceValue(YOUNG_COLLECTION_THRESHOLD).longValue()) {
+			if (youngCollections.longValue() <= valueProvider.getPreferenceValue(YOUNG_COLLECTION_THRESHOLD)
+					.longValue()) {
 				// If we have too few collections at all we shouldn't even try to guess at the live set
 				return RulesToolkit.getTooFewEventsResult(this);
 			}
 			score = Math.min(score, 74);
 		}
@@ -149,11 +151,12 @@
 		// otherwise we just return the basic increasing live set score
 		EventAvailability ea = RulesToolkit.getEventAvailability(items, JdkTypeIDs.OLD_OBJECT_SAMPLE);
 		// FIXME: Should construct an message using memoryIncrease, not use a hard limit
 		if (ea == EventAvailability.DISABLED || ea == EventAvailability.UNKNOWN) {
 			if (score >= 25) {
-				IQuantity timeAfterJVMStart = items.getAggregate(JdkAggregators.FIRST_ITEM_START).subtract(items.getAggregate(JdkAggregators.JVM_START_TIME));
+				IQuantity timeAfterJVMStart = items.getAggregate(JdkAggregators.FIRST_ITEM_START)
+						.subtract(items.getAggregate(JdkAggregators.JVM_START_TIME));
 				String shortMessage = MessageFormat.format(
 						Messages.getString(Messages.IncreasingLiveSetRuleFactory_TEXT_INFO),
 						liveSetIncreasePerSecond.displayUsing(IDisplayable.AUTO));
 				String longMessage = shortMessage + "<p>" //$NON-NLS-1$
 						+ MessageFormat.format(Messages.getString(Messages.IncreasingLiveSetRuleFactory_TEXT_INFO_LONG),
diff a/core/org.openjdk.jmc.flightrecorder.rules/pom.xml b/core/org.openjdk.jmc.flightrecorder.rules/pom.xml
--- a/core/org.openjdk.jmc.flightrecorder.rules/pom.xml
+++ b/core/org.openjdk.jmc.flightrecorder.rules/pom.xml
@@ -37,11 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>flightrecorder.rules</artifactId>
-
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>common</artifactId>
 			<version>${project.version}</version>
diff a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/ItemTreeBuilder.java b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/ItemTreeBuilder.java
--- a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/ItemTreeBuilder.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/ItemTreeBuilder.java
@@ -45,25 +45,25 @@
 
 /**
  * Helper for building item trees.
  */
 public class ItemTreeBuilder {
-	
+
 	/**
 	 * Interface used to allow interrupting slow builds of encapsulation trees.
 	 */
 	public interface IItemTreeBuilderCallback {
 		boolean shouldContinue();
 	}
-	
+
 	private static IItemTreeBuilderCallback DEFAULT_CALLBACK = new IItemTreeBuilderCallback() {
 		@Override
 		public boolean shouldContinue() {
 			return true;
 		}
 	};
-	
+
 	/**
 	 * Builds a tree where events that wrap other events, time wise, are higher up in the hierarchy.
 	 *
 	 * @param items
 	 *            the items to build a tree from
@@ -85,11 +85,12 @@
 	 * @param ignoreThread
 	 *            {@code true} to make the algorithm not care about event thread, can be used for VM
 	 *            level events. It's up to the caller to make sure this is safe to do.
 	 * @return the root node for the resulting tree.
 	 */
-	public static ITreeNode<IItem> buildEncapsulationTree(IItemCollection items, boolean allowInstants, boolean ignoreThread) {
+	public static ITreeNode<IItem> buildEncapsulationTree(
+		IItemCollection items, boolean allowInstants, boolean ignoreThread) {
 		return buildEncapsulationTree(items, allowInstants, ignoreThread, DEFAULT_CALLBACK);
 	}
 
 	/**
 	 * Builds a tree where events that wrap other events, time wise, are higher up in the hierarchy.
@@ -100,53 +101,58 @@
 	 *            {@code true} to allow instant events in the resulting tree
 	 * @param ignoreThread
 	 *            {@code true} to make the algorithm not care about event thread, can be used for VM
 	 *            level events. It's up to the caller to make sure this is safe to do.
 	 * @param callback
-	 *            callback used to determine whether or not to continue building the encapsulation tree
+	 *            callback used to determine whether or not to continue building the encapsulation
+	 *            tree
 	 * @return the root node for the resulting tree.
 	 */
 	public static ITreeNode<IItem> buildEncapsulationTree(
 		IItemCollection items, boolean allowInstants, boolean ignoreThread, IItemTreeBuilderCallback callback) {
 		// FIXME: Consider introducing a maxdepth at which to stop adding nodes
 		TreeNode<IItem> root = new TreeNode<>(null);
 		for (IItemIterable itemIterable : items) {
-			IMemberAccessor<IQuantity, IItem> durationAccessor = JfrAttributes.DURATION.getAccessor(itemIterable.getType());
-			IMemberAccessor<IQuantity, IItem> startTimeAccessor = JfrAttributes.START_TIME.getAccessor(itemIterable.getType());
-			IMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME.getAccessor(itemIterable.getType());
-			IMemberAccessor<IMCThread, IItem> threadAccessor = JfrAttributes.EVENT_THREAD.getAccessor(itemIterable.getType());
+			IMemberAccessor<IQuantity, IItem> durationAccessor = JfrAttributes.DURATION
+					.getAccessor(itemIterable.getType());
+			IMemberAccessor<IQuantity, IItem> startTimeAccessor = JfrAttributes.START_TIME
+					.getAccessor(itemIterable.getType());
+			IMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME
+					.getAccessor(itemIterable.getType());
+			IMemberAccessor<IMCThread, IItem> threadAccessor = JfrAttributes.EVENT_THREAD
+					.getAccessor(itemIterable.getType());
 			for (IItem item : itemIterable) {
 				if (!callback.shouldContinue()) {
 					return root;
 				}
 				IQuantity duration = durationAccessor.getMember(item);
 				boolean hasDuration = duration.longValue() != 0;
 				IMCThread thread = threadAccessor == null ? null : threadAccessor.getMember(item);
 				if (hasDuration || allowInstants) {
-					addTimeSplitNode(root, item, hasDuration, startTimeAccessor.getMember(item), endTimeAccessor.getMember(item), thread, callback, ignoreThread);
+					addTimeSplitNode(root, item, hasDuration, startTimeAccessor.getMember(item),
+							endTimeAccessor.getMember(item), thread, callback, ignoreThread);
 				}
 			}
 		}
 		return root;
 	}
 
-	private static void addTimeSplitNode(TreeNode<IItem> node, IItem item,
-			boolean itemHasDuration,
-			IQuantity itemStartTime,
-			IQuantity itemEndTime,
-			IMCThread itemThread, 
-			IItemTreeBuilderCallback callback, boolean ignoreThread) {
+	private static void addTimeSplitNode(
+		TreeNode<IItem> node, IItem item, boolean itemHasDuration, IQuantity itemStartTime, IQuantity itemEndTime,
+		IMCThread itemThread, IItemTreeBuilderCallback callback, boolean ignoreThread) {
 		TreeNode<IItem> addedNode = null;
 		List<ITreeNode<IItem>> children = new ArrayList<>(node.getChildren());
 		for (ITreeNode<IItem> child : children) {
 			if (!callback.shouldContinue()) {
 				return;
 			}
 			if (treeItemEncloses((TreeNode<IItem>) child, itemStartTime, itemEndTime, itemThread, ignoreThread)) {
-				addTimeSplitNode((TreeNode<IItem>) child, item, itemHasDuration, itemStartTime, itemEndTime, itemThread, callback, ignoreThread);
+				addTimeSplitNode((TreeNode<IItem>) child, item, itemHasDuration, itemStartTime, itemEndTime, itemThread,
+						callback, ignoreThread);
 				return;
-			} else if (enclosesTreeItem(itemHasDuration, itemStartTime, itemEndTime, itemThread, (TreeNode<IItem>) child, ignoreThread)) {
+			} else if (enclosesTreeItem(itemHasDuration, itemStartTime, itemEndTime, itemThread,
+					(TreeNode<IItem>) child, ignoreThread)) {
 				((TreeNode<IItem>) child).detach();
 				if (addedNode == null) {
 					addedNode = new TreeNode<>(item, itemHasDuration, itemStartTime, itemEndTime, itemThread);
 					node.addChild(addedNode);
 				}
@@ -155,22 +161,25 @@
 		}
 		if (addedNode == null) {
 			node.addChild(new TreeNode<>(item, itemHasDuration, itemStartTime, itemEndTime, itemThread));
 		}
 	}
-	
-	private static boolean enclosesTreeItem(boolean encloserHasDuration, IQuantity encloserStartTime, IQuantity encloserEndTime,
-			IMCThread encloserThread, TreeNode<IItem> enclosee, boolean ignoreThread) {
+
+	private static boolean enclosesTreeItem(
+		boolean encloserHasDuration, IQuantity encloserStartTime, IQuantity encloserEndTime, IMCThread encloserThread,
+		TreeNode<IItem> enclosee, boolean ignoreThread) {
 		if (encloserHasDuration) {
 			return encloserStartTime.compareTo(enclosee.getStartTime()) <= 0
 					&& encloserEndTime.compareTo(enclosee.getEndTime()) >= 0
 					&& (ignoreThread || encloserThread.equals(enclosee.getThread()));
 		}
 		return false;
 	}
-	
-	private static boolean treeItemEncloses(TreeNode<IItem> encloser, IQuantity encloseeStartTime, IQuantity encloseeEndTime, IMCThread encloseeThread, boolean ignoreThread) {
+
+	private static boolean treeItemEncloses(
+		TreeNode<IItem> encloser, IQuantity encloseeStartTime, IQuantity encloseeEndTime, IMCThread encloseeThread,
+		boolean ignoreThread) {
 		if (encloser.hasDuration()) {
 			return encloser.getStartTime().compareTo(encloseeStartTime) <= 0
 					&& encloser.getEndTime().compareTo(encloseeEndTime) >= 0
 					&& (ignoreThread || encloser.getThread().equals(encloseeThread));
 		}
diff a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/TreeNode.java b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/TreeNode.java
--- a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/TreeNode.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/tree/TreeNode.java
@@ -60,11 +60,11 @@
 	 *            node payload
 	 */
 	public TreeNode(T item) {
 		this.item = item;
 	}
-	
+
 	public TreeNode(T item, boolean hasDuration, IQuantity startTime, IQuantity endTime, IMCThread thread) {
 		this.item = item;
 		this.hasDuration = hasDuration;
 		this.startTime = startTime;
 		this.endTime = endTime;
@@ -83,27 +83,27 @@
 
 	@Override
 	public T getValue() {
 		return item;
 	}
-	
+
 	public boolean hasDuration() {
 		return hasDuration;
 	}
 
 	public IQuantity getStartTime() {
 		return startTime;
 	}
-	
+
 	public IQuantity getEndTime() {
 		return endTime;
 	}
-	
+
 	public IMCThread getThread() {
 		return thread;
 	}
-	
+
 	@Override
 	public void accept(ITreeVisitor<T> visitor) {
 		visitor.visit(this);
 	}
 
diff a/core/org.openjdk.jmc.flightrecorder/pom.xml b/core/org.openjdk.jmc.flightrecorder/pom.xml
--- a/core/org.openjdk.jmc.flightrecorder/pom.xml
+++ b/core/org.openjdk.jmc.flightrecorder/pom.xml
@@ -36,12 +36,14 @@
 	<parent>
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
-
 	<artifactId>flightrecorder</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>common</artifactId>
 			<version>${project.version}</version>
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/JfrAttributes.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/JfrAttributes.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/JfrAttributes.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/JfrAttributes.java
@@ -64,19 +64,20 @@
 		@Override
 		public <U> IMemberAccessor<IType<?>, U> customAccessor(final IType<U> type) {
 			return MemberAccessorToolkit.constant(type);
 		}
 	});
-	
+
 	IAttribute<String> EVENT_TYPE_ID = Attribute.canonicalize(new Attribute<String>("(eventTypeId)", //$NON-NLS-1$
-			Messages.getString(Messages.ATTR_EVENT_TYPE_ID), Messages.getString(Messages.ATTR_EVENT_TYPE_ID_DESC), PLAIN_TEXT) {
+			Messages.getString(Messages.ATTR_EVENT_TYPE_ID), Messages.getString(Messages.ATTR_EVENT_TYPE_ID_DESC),
+			PLAIN_TEXT) {
 		@Override
 		public <U> IMemberAccessor<String, U> customAccessor(final IType<U> type) {
 			return MemberAccessorToolkit.constant(type.getIdentifier());
 		}
 	});
-	
+
 	IAttribute<IQuantity> END_TIME = Attribute.canonicalize(
 			new Attribute<IQuantity>("(endTime)", Messages.getString(Messages.ATTR_END_TIME), null, TIMESTAMP) { //$NON-NLS-1$
 				@Override
 				public <U> IMemberAccessor<IQuantity, U> customAccessor(IType<U> type) {
 					IMemberAccessor<IQuantity, U> stAccessor = type.getAccessor(START_TIME.getKey());
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkAttributes.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkAttributes.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkAttributes.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkAttributes.java
@@ -368,30 +368,33 @@
 					return jvmTotal != null && machineTotal != null ? machineTotal.subtract(jvmTotal) : null;
 				}
 			};
 		}
 	});
-	public static final IAttribute<IQuantity> OTHER_CPU_RATIO = Attribute.canonicalize(new Attribute<IQuantity>("otherCpuRatio", //$NON-NLS-1$
-			Messages.getString(Messages.ATTR_OTHER_CPU_RATIO), Messages.getString(Messages.ATTR_OTHER_CPU_RATIO_DESC), PERCENTAGE) {
-		@Override
-		public <U> IMemberAccessor<IQuantity, U> customAccessor(IType<U> type) {
-			final IMemberAccessor<IQuantity, U> otherCpuAccessor = OTHER_CPU.getAccessor(type);
-			// Avoid possible future circularity by asking the type directly.
-			final IMemberAccessor<IQuantity, U> machineTotalAccessor = type.getAccessor(MACHINE_TOTAL.getKey());
-			if ((otherCpuAccessor == null) || (machineTotalAccessor == null)) {
-				return null;
-			}
-			return new IMemberAccessor<IQuantity, U>() {
+	public static final IAttribute<IQuantity> OTHER_CPU_RATIO = Attribute
+			.canonicalize(new Attribute<IQuantity>("otherCpuRatio", //$NON-NLS-1$
+					Messages.getString(Messages.ATTR_OTHER_CPU_RATIO),
+					Messages.getString(Messages.ATTR_OTHER_CPU_RATIO_DESC), PERCENTAGE) {
 				@Override
-				public IQuantity getMember(U i) {
-					IQuantity machineTotal = machineTotalAccessor.getMember(i);
-					IQuantity otherCpu = otherCpuAccessor.getMember(i);
-					return otherCpu != null && machineTotal != null ? otherCpu.multiply(machineTotal.doubleValue()) : null;
+				public <U> IMemberAccessor<IQuantity, U> customAccessor(IType<U> type) {
+					final IMemberAccessor<IQuantity, U> otherCpuAccessor = OTHER_CPU.getAccessor(type);
+					// Avoid possible future circularity by asking the type directly.
+					final IMemberAccessor<IQuantity, U> machineTotalAccessor = type.getAccessor(MACHINE_TOTAL.getKey());
+					if ((otherCpuAccessor == null) || (machineTotalAccessor == null)) {
+						return null;
+					}
+					return new IMemberAccessor<IQuantity, U>() {
+						@Override
+						public IQuantity getMember(U i) {
+							IQuantity machineTotal = machineTotalAccessor.getMember(i);
+							IQuantity otherCpu = otherCpuAccessor.getMember(i);
+							return otherCpu != null && machineTotal != null
+									? otherCpu.multiply(machineTotal.doubleValue()) : null;
+						}
+					};
 				}
-			};
-		}
-	});
+			});
 
 	public static final IAttribute<IQuantity> RECORDING_ID = attr("id", Messages.getString(Messages.ATTR_RECORDING_ID), //$NON-NLS-1$
 			NUMBER);
 	public static final IAttribute<String> RECORDING_NAME = attr("name", //$NON-NLS-1$
 			Messages.getString(Messages.ATTR_RECORDING_NAME), PLAIN_TEXT);
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkFilters.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkFilters.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkFilters.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkFilters.java
@@ -77,11 +77,12 @@
 	public static final IItemFilter ALLOC_INSIDE_TLAB = ItemFilters.type(JdkTypeIDs.ALLOC_INSIDE_TLAB);
 	public static final IItemFilter ALLOC_ALL = ItemFilters.type(JdkTypeIDs.ALLOC_INSIDE_TLAB,
 			JdkTypeIDs.ALLOC_OUTSIDE_TLAB);
 	public static final IItemFilter REFERENCE_STATISTICS = ItemFilters.type(JdkTypeIDs.GC_REFERENCE_STATISTICS);
 	public static final IItemFilter GARBAGE_COLLECTION = ItemFilters.type(JdkTypeIDs.GARBAGE_COLLECTION);
-	public static final IItemFilter OLD_GARBAGE_COLLECTION = ItemFilters.type(JdkTypeIDs.GC_COLLECTOR_OLD_GARBAGE_COLLECTION);
+	public static final IItemFilter OLD_GARBAGE_COLLECTION = ItemFilters
+			.type(JdkTypeIDs.GC_COLLECTOR_OLD_GARBAGE_COLLECTION);
 	public static final IItemFilter CONCURRENT_MODE_FAILURE = ItemFilters.type(JdkTypeIDs.CONCURRENT_MODE_FAILURE);
 	public static final IItemFilter ERRORS = ItemFilters.type(JdkTypeIDs.ERRORS_THROWN);
 	public static final IItemFilter EXCEPTIONS = ItemFilters.type(JdkTypeIDs.EXCEPTIONS_THROWN);
 	public static final IItemFilter THROWABLES = ItemFilters.or(EXCEPTIONS, ERRORS);
 	public static final IItemFilter THROWABLES_STATISTICS = ItemFilters.type(JdkTypeIDs.THROWABLES_STATISTICS);
@@ -89,11 +90,12 @@
 	public static final IItemFilter CLASS_LOAD_STATISTICS = ItemFilters.type(JdkTypeIDs.CLASS_LOAD_STATISTICS);
 	public static final IItemFilter CLASS_LOADER_STATISTICS = ItemFilters.type(JdkTypeIDs.CLASS_LOADER_STATISTICS);
 	public static final IItemFilter CLASS_LOAD = ItemFilters.type(JdkTypeIDs.CLASS_LOAD);
 	public static final IItemFilter CLASS_LOAD_OR_UNLOAD = ItemFilters.or(CLASS_LOAD, CLASS_UNLOAD);
 	public static final IItemFilter CLASS_DEFINE = ItemFilters.type(JdkTypeIDs.CLASS_DEFINE);
-	public static final IItemFilter CLASS_LOADER_EVENTS = ItemFilters.or(CLASS_LOAD, CLASS_UNLOAD, CLASS_DEFINE, CLASS_LOADER_STATISTICS);
+	public static final IItemFilter CLASS_LOADER_EVENTS = ItemFilters.or(CLASS_LOAD, CLASS_UNLOAD, CLASS_DEFINE,
+			CLASS_LOADER_STATISTICS);
 	public static final IItemFilter MONITOR_ENTER = ItemFilters.type(JdkTypeIDs.MONITOR_ENTER);
 	public static final IItemFilter FILE_OR_SOCKET_IO = ItemFilters.type(JdkTypeIDs.SOCKET_READ,
 			JdkTypeIDs.SOCKET_WRITE, JdkTypeIDs.FILE_READ, JdkTypeIDs.FILE_WRITE);
 	// NOTE: Are there more types to add (i.e. relevant types with duration)?
 	public static final IItemFilter THREAD_LATENCIES = ItemFilters.type(JdkTypeIDs.MONITOR_ENTER,
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkTypeIDs.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkTypeIDs.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkTypeIDs.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkTypeIDs.java
@@ -194,8 +194,8 @@
 	// Safepointing end
 	public static final String SAFEPOINT_END = PREFIX + "SafepointEnd";
 
 	public static final String MODULE_EXPORT = PREFIX + "ModuleExport";
 	public static final String MODULE_REQUIRE = PREFIX + "ModuleRequire";
-	
-	public static final String NATIVE_LIBRARY = PREFIX + "NativeLibrary";	
+
+	public static final String NATIVE_LIBRARY = PREFIX + "NativeLibrary";
 }
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/messages/internal/Messages.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/messages/internal/Messages.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/messages/internal/Messages.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/messages/internal/Messages.java
@@ -229,11 +229,11 @@
 	public static final String ATTR_FLAG_NAME = "ATTR_FLAG_NAME"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_NEW_VALUE_BOOLEAN = "ATTR_FLAG_NEW_VALUE BOOLEAN"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_NEW_VALUE_NUMBER = "ATTR_FLAG_NEW_VALUE_NUMBER"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_NEW_VALUE_TEXT = "ATTR_FLAG_NEW_VALUE_TEXT"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_OLD_VALUE_BOOLEAN = "ATTR_FLAG_OLD_VALUE_BOOLEAN"; //$NON-NLS-1$
-	public static final String ATTR_FLAG_OLD_VALUE_NUMBER= "ATTR_FLAG_OLD_VALUE_NUMBER"; //$NON-NLS-1$
+	public static final String ATTR_FLAG_OLD_VALUE_NUMBER = "ATTR_FLAG_OLD_VALUE_NUMBER"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_OLD_VALUE_TEXT = "ATTR_FLAG_OLD_VALUE_TEXT"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_ORIGIN = "ATTR_FLAG_ORIGIN"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_VALUE_BOOLEAN = "ATTR_FLAG_VALUE_BOOLEAN"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_VALUE_NUMBER = "ATTR_FLAG_VALUE_NUMBER"; //$NON-NLS-1$
 	public static final String ATTR_FLAG_VALUE_TEXT = "ATTR_FLAG_VALUE_TEXT"; //$NON-NLS-1$
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeModel.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeModel.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeModel.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeModel.java
@@ -256,22 +256,23 @@
 		return objects;
 	}
 
 	/**
 	 * A helper method to calculate number of Referenced Object within specified period.
+	 * 
 	 * @param timerange
 	 *            a range of time that specifies which root objects to retrieve
 	 * @param referenceTreeObject
 	 *            leak candidate
-	 * @return number of leaked object during the specified timerange for a given
-	 * 			  leak candidate
+	 * @return number of leaked object during the specified timerange for a given leak candidate
 	 */
 	public int getLeakCountInRange(IRange<IQuantity> timerange, ReferenceTreeObject referenceTreeObject) {
 		int referencecount = 0;
 		for (ReferenceTreeObject rtObject : leakObjects) {
-			if (rtObject.getRootObject().equals(referenceTreeObject.getRootObject()) &&
-					timerange.getStart().compareTo(rtObject.getTimestamp()) <= 0 && timerange.getEnd().compareTo(rtObject.getTimestamp()) >= 0) {
+			if (rtObject.getRootObject().equals(referenceTreeObject.getRootObject())
+					&& timerange.getStart().compareTo(rtObject.getTimestamp()) <= 0
+					&& timerange.getEnd().compareTo(rtObject.getTimestamp()) >= 0) {
 				++referencecount;
 			}
 		}
 		return referencecount;
 	}
@@ -354,12 +355,11 @@
 
 					// Update Root Object with oldObjectSample ref
 					ReferenceTreeObject parent = node.getParent();
 					if (parent == null) {
 						node.updateOldObjectSamples(map.get(objectAccessor.getMember(item).getAddress()));
-					}
-					else {
+					} else {
 						while (parent.getParent() != null) {
 							parent = parent.getParent();
 						}
 						parent.updateOldObjectSamples(map.get(objectAccessor.getMember(item).getAddress()));
 					}
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeObject.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeObject.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeObject.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/memleak/ReferenceTreeObject.java
@@ -303,15 +303,15 @@
 	public Map<IQuantity, ReferenceTreeObject> getOldObjectSamples() {
 		return Collections.unmodifiableMap(oldObjectSamples);
 	}
 
 	/**
-	 * This method updates the Root object's Map with allocationTime and its oldObjectReference object (leaves). 
-	 *  
+	 * This method updates the Root object's Map with allocationTime and its oldObjectReference
+	 * object (leaves).
+	 * 
 	 * @param oldobjectrefnode
 	 *            oldObjectReference leaf node
-	 *            
 	 */
 	public void updateOldObjectSamples(ReferenceTreeObject oldobjectrefnode) {
 		oldObjectSamples.put(oldobjectrefnode.getTimestamp(), oldobjectrefnode);
 	}
 
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/JdkTypeIDsPreJdk11.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/JdkTypeIDsPreJdk11.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/JdkTypeIDsPreJdk11.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/JdkTypeIDsPreJdk11.java
@@ -205,11 +205,11 @@
 			+ "vm/gc/metaspace/chunk_free_list_summary";
 	private final static String GC_METASPACE_GC_THRESHOLD = JVM_EVENT_ID_ROOT + "vm/gc/metaspace/gc_threshold";
 
 	final static String RECORDINGS = JFR_INFO_EVENT_ID_ROOT + "recordings/recording";
 	final static String RECORDING_SETTING = JFR_INFO_EVENT_ID_ROOT + "recordings/recording_setting";
-        final static String JDK9_RECORDING_SETTING = PREFIX_9_10 + "ActiveSetting";
+	final static String JDK9_RECORDING_SETTING = PREFIX_9_10 + "ActiveSetting";
 
 	/**
 	 * Translate a pre-JDK 11 type id into a JDK 11 type id.
 	 *
 	 * @param typeId
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/SettingsTransformer.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/SettingsTransformer.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/SettingsTransformer.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/parser/synthetic/SettingsTransformer.java
@@ -213,11 +213,11 @@
 	@Override
 	public void addEvent(Object[] values) {
 		LabeledIdentifier type = (LabeledIdentifier) values[typeIndex];
 		if (type != null) {
 			type = new LabeledIdentifier(JdkTypeIDsPreJdk11.translate(type.getInterfaceId()),
-				type.getImplementationId(), type.getName(), type.getDeclaredDescription());
+					type.getImplementationId(), type.getName(), type.getDeclaredDescription());
 			if (endTimeIndex < 0) {
 				values[typeIndex] = type;
 				sink.addEvent(values);
 				return;
 			}
@@ -276,18 +276,16 @@
 
 			@Override
 			public IEventSink create(
 				String identifier, String label, String[] category, String description,
 				List<ValueField> dataStructure) {
-				if (JdkTypeIDsPreJdk11.RECORDING_SETTING.equals(identifier) ||
-					JdkTypeIDsPreJdk11.JDK9_RECORDING_SETTING.equals(identifier)) {
+				if (JdkTypeIDsPreJdk11.RECORDING_SETTING.equals(identifier)
+						|| JdkTypeIDsPreJdk11.JDK9_RECORDING_SETTING.equals(identifier)) {
 					SettingsTransformer st = new SettingsTransformer(subFactory, label, category, description,
 							dataStructure);
-					if ((JdkTypeIDsPreJdk11.RECORDING_SETTING.equals(identifier) &&
-					     st.isValid()) ||
-						(JdkTypeIDsPreJdk11.JDK9_RECORDING_SETTING.equals(identifier) &&
-						 st.isValidV1())) {
+					if ((JdkTypeIDsPreJdk11.RECORDING_SETTING.equals(identifier) && st.isValid())
+							|| (JdkTypeIDsPreJdk11.JDK9_RECORDING_SETTING.equals(identifier) && st.isValidV1())) {
 						return st;
 					} else {
 						// FIXME: Avoid System.err.println
 						System.err
 								.println("Cannot create SettingsTransformer from fields: " + dataStructure.toString()); //$NON-NLS-1$
diff a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/util/ChunkReader.java b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/util/ChunkReader.java
--- a/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/util/ChunkReader.java
+++ b/core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/util/ChunkReader.java
@@ -67,11 +67,11 @@
 			+ DataInputToolkit.LONG_SIZE;
 
 	private ChunkReader() {
 		throw new UnsupportedOperationException("Not to be instantiated"); //$NON-NLS-1$
 	}
-	
+
 	/**
 	 * Chunk iterator for an uncompressed JFR file. Efficiently reads a JFR file, chunk by chunk,
 	 * into memory as byte arrays by memory mapping the JFR file, finding the chunk boundaries with
 	 * a minimum of parsing, and then block-transferring the byte arrays. The transfers will be done
 	 * on {@link Iterator#next()}, and the resulting byte array will only be reachable for as long
diff a/core/pom.xml b/core/pom.xml
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -42,10 +42,12 @@
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
 		<maven.compiler.source>1.7</maven.compiler.source>
 		<maven.compiler.target>1.7</maven.compiler.target>
 		<manifest-location>META-INF</manifest-location>
+		<spotless.version>1.26.0</spotless.version>
+		<spotless.config.path>${basedir}/../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
 	</properties>
 
 	<modules>
 		<module>org.openjdk.jmc.common</module>
 		<module>org.openjdk.jmc.flightrecorder</module>
@@ -80,10 +82,23 @@
 					<version>3.5.1</version>
 					<configuration>
 						<manifestLocation>${manifest-location}</manifestLocation>
 					</configuration>
 				</plugin>
+				<plugin>
+  				<groupId>com.diffplug.spotless</groupId>
+  					<artifactId>spotless-maven-plugin</artifactId>
+  					<version>${spotless.version}</version>
+  					<configuration>
+    				<java>
+      				<eclipse>
+        				<file>${spotless.config.path}</file>
+        				<version>4.8.0</version>
+      				</eclipse>
+    				</java>
+  				</configuration>
+				</plugin>
 			</plugins>
 		</pluginManagement>
 		<plugins>
 		<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
diff a/core/tests/org.openjdk.jmc.common.test/pom.xml b/core/tests/org.openjdk.jmc.common.test/pom.xml
--- a/core/tests/org.openjdk.jmc.common.test/pom.xml
+++ b/core/tests/org.openjdk.jmc.common.test/pom.xml
@@ -37,10 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core.tests</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>common.test</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<packaging>jar</packaging>
 	<dependencies>
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>common</artifactId>
diff a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/MCTestCase.java b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/MCTestCase.java
--- a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/MCTestCase.java
+++ b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/MCTestCase.java
@@ -77,12 +77,12 @@
 	 * Asserts that with respect to all bits in the mask, a long is equal to the given value. If it
 	 * is not an AssertionFailedError is thrown with the given message.
 	 */
 	static public void assertMaskedEquals(String message, long expected, long actual, long mask) {
 		if (((expected ^ actual) & mask) != 0) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "masked with " + hex(mask) + " expected:<" + hex(expected) + "> was not:<" + hex(actual) + ">");
+			Assert.fail(((message != null) ? message + ' ' : "") + "masked with " + hex(mask) + " expected:<"
+					+ hex(expected) + "> was not:<" + hex(actual) + ">");
 		}
 	}
 
 	/**
 	 * Asserts that with respect to all bits in the mask, a long is equal to the given value.
@@ -99,12 +99,12 @@
 	 * Asserts that a {@link Comparable} is within the given (inclusive) range. If it is not an
 	 * AssertionFailedError is thrown with the given message.
 	 */
 	static public <T extends Comparable<T>> void assertBetween(String message, T min, T max, T actual) {
 		if ((min.compareTo(actual) > 0) || (max.compareTo(actual) < 0)) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "expected in:[" + min + ", " + max + "] was not:<" + actual + ">");
+			Assert.fail(((message != null) ? message + ' ' : "") + "expected in:[" + min + ", " + max + "] was not:<"
+					+ actual + ">");
 		}
 	}
 
 	/**
 	 * Asserts that a {@link Comparable} is within the given (inclusive) range.
@@ -117,12 +117,12 @@
 	 * Asserts that a {@link Comparable} is less or equal than the given value. If it is not an
 	 * AssertionFailedError is thrown with the given message.
 	 */
 	static public <T extends Comparable<T>> void assertMax(String message, T max, T actual) {
 		if (max.compareTo(actual) < 0) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "expected max:<" + max + "> was not:<" + actual + ">");
+			Assert.fail(
+					((message != null) ? message + ' ' : "") + "expected max:<" + max + "> was not:<" + actual + ">");
 		}
 	}
 
 	/**
 	 * Asserts that a {@link Comparable} is less or equal than the given value.
@@ -135,12 +135,12 @@
 	 * Asserts that a {@link Comparable} is greater or equal than the given value. If it is not an
 	 * AssertionFailedError is thrown with the given message.
 	 */
 	static public <T extends Comparable<T>> void assertMin(String message, T min, T actual) {
 		if (min.compareTo(actual) > 0) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "expected min:<" + min + "> was not:<" + actual + ">");
+			Assert.fail(
+					((message != null) ? message + ' ' : "") + "expected min:<" + min + "> was not:<" + actual + ">");
 		}
 	}
 
 	/**
 	 * Asserts that a {@link Comparable} is greater or equal than the given value.
@@ -153,12 +153,12 @@
 	 * Asserts that a {@link Comparable} is less than the given value. If it is not an
 	 * AssertionFailedError is thrown with the given message.
 	 */
 	static public <T extends Comparable<T>> void assertLessThan(String message, T greaterVal, T actual) {
 		if (greaterVal.compareTo(actual) <= 0) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "expected less than:<" + greaterVal + "> was not:<" + actual + ">");
+			Assert.fail(((message != null) ? message + ' ' : "") + "expected less than:<" + greaterVal + "> was not:<"
+					+ actual + ">");
 		}
 	}
 
 	/**
 	 * Asserts that a {@link Comparable} is less than the given value.
@@ -171,12 +171,12 @@
 	 * Asserts that a {@link Comparable} is greater than the given value. If it is not an
 	 * AssertionFailedError is thrown with the given message.
 	 */
 	static public <T extends Comparable<? super T>> void assertGreaterThan(String message, T lesserVal, T actual) {
 		if (lesserVal.compareTo(actual) >= 0) {
-			Assert.fail(((message != null) ? message + ' ' : "")
-					+ "expected greater than:<" + lesserVal + "> was not:<" + actual + ">");
+			Assert.fail(((message != null) ? message + ' ' : "") + "expected greater than:<" + lesserVal + "> was not:<"
+					+ actual + ">");
 		}
 	}
 
 	/**
 	 * Asserts that a {@link Comparable} is greater than the given value.
diff a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/TestToolkit.java b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/TestToolkit.java
--- a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/TestToolkit.java
+++ b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/TestToolkit.java
@@ -91,11 +91,11 @@
 			IOToolkit.closeSilently(in);
 			IOToolkit.closeSilently(br);
 		}
 		return new IOResourceSet(resources);
 	}
-	
+
 	public static IOResource getNamedResource(Class<?> clazz, String directory, String fileName) throws IOException {
 		String resourceName = directory + '/' + fileName;
 		if (clazz.getClassLoader().getResource(resourceName) == null) {
 			throw new IOException("Resource not found: " + resourceName);
 		}
@@ -155,11 +155,11 @@
 	}
 
 	private static URL getLocation(Class<?> clazz) {
 		return clazz.getProtectionDomain().getCodeSource().getLocation();
 	}
-	
+
 	private static File createFile(URL url) throws IOException {
 		try {
 			return new File(url.toURI());
 		} catch (URISyntaxException e) {
 			throw new IOException("Invalid filename " + url);
diff a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/unit/DeriveUnitTest.java b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/unit/DeriveUnitTest.java
--- a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/unit/DeriveUnitTest.java
+++ b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/test/unit/DeriveUnitTest.java
@@ -67,11 +67,11 @@
 		min = UnitLookup.MINUTE;
 		h = span.getUnit("h");
 		d = span.getUnit("d");
 		wk = span.getUnit("wk");
 		y = span.getUnit("a");
-		
+
 		Hz = UnitLookup.HERTZ;
 		LinearKindOfQuantity freq = UnitLookup.FREQUENCY;
 		kHz = freq.getUnit(DecimalPrefix.KILO);
 		MHz = freq.getUnit(DecimalPrefix.MEGA);
 		mHz = freq.getUnit(DecimalPrefix.MILLI);
@@ -104,19 +104,19 @@
 		// FIXME: One could argue that the expected unit should be B here.
 		assertDerivedUnit(null, B.quantity(0.5));
 
 		assertDerivedUnit(null, B.quantity(0.1));
 	}
-	
+
 	@Test
 	public void testFrequencies() throws Exception {
 		assertDerivedUnit(Hz, Hz.quantity(1));
 		assertDerivedUnit(Hz, Hz.quantity(999));
 		assertDerivedUnit(kHz, Hz.quantity(1000));
 		assertDerivedUnit(kHz, kHz.quantity(999));
 		assertDerivedUnit(MHz, kHz.quantity(1000));
-		
+
 		assertDerivedUnit(mHz, Hz.quantity(0.5));
 		assertDerivedUnit(uHz, mHz.quantity(0.5));
 	}
 
 	@Test
diff a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/version/JavaVersionTest.java b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/version/JavaVersionTest.java
--- a/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/version/JavaVersionTest.java
+++ b/core/tests/org.openjdk.jmc.common.test/src/test/java/org/openjdk/jmc/common/version/JavaVersionTest.java
@@ -187,11 +187,11 @@
 		JavaVersion version17u0 = new JavaVersion("1.7.0_0");
 		JavaVersion version17 = new JavaVersion("1.7");
 
 		assertTrue(version17u0.equals(version17));
 	}
-	
+
 	@Test
 	public void testNullStringArgument() {
 		JavaVersion nullVersion = new JavaVersion((String) null);
 		assertEquals(JavaVersion.UNKNOWN, nullVersion.getMajorVersion());
 	}
diff a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/pom.xml b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/pom.xml
--- a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/pom.xml
+++ b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/pom.xml
@@ -37,11 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core.tests</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>flightrecorder.rules.jdk.test</artifactId>
-
+	<properties>
+		<spotless.config.path>${basedir}/../../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
 		<dependency>
 			<groupId>org.openjdk.jmc</groupId>
 			<artifactId>flightrecorder.rules.test</artifactId>
 			<type>test-jar</type>
diff a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/dataproviders/TestJvmInternalsDataProvider.java b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/dataproviders/TestJvmInternalsDataProvider.java
--- a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/dataproviders/TestJvmInternalsDataProvider.java
+++ b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/dataproviders/TestJvmInternalsDataProvider.java
@@ -10,31 +10,32 @@
 
 public class TestJvmInternalsDataProvider {
 
 	@Test
 	public void testJavaAgentDuplicateFlags() {
-		assertEquals("same jar, no option", 1, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar -javaagent:myjar.jar").toArray().length);
-		assertEquals("different jar, no option", 0, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar -javaagent:anotherjar.jar").toArray().length);
-
-		assertEquals("same jar, same option", 1, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar=option -javaagent:myjar.jar=option").toArray().length);
-		assertEquals("different jar, same option", 0, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar=option -javaagent:anotherjar.jar=option").toArray().length);
-
-		assertEquals("same jar, different option", 1, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar=option -javaagent:myjar.jar=anotheroption").toArray().length);
-		assertEquals("different jar, different option", 0, JvmInternalsDataProvider.checkDuplicates(
-				"-javaagent:myjar.jar=option -javaagent:anotherjar.jar=anotheroption").toArray().length);
+		assertEquals("same jar, no option", 1,
+				JvmInternalsDataProvider.checkDuplicates("-javaagent:myjar.jar -javaagent:myjar.jar").toArray().length);
+		assertEquals("different jar, no option", 0, JvmInternalsDataProvider
+				.checkDuplicates("-javaagent:myjar.jar -javaagent:anotherjar.jar").toArray().length);
+
+		assertEquals("same jar, same option", 1, JvmInternalsDataProvider
+				.checkDuplicates("-javaagent:myjar.jar=option -javaagent:myjar.jar=option").toArray().length);
+		assertEquals("different jar, same option", 0, JvmInternalsDataProvider
+				.checkDuplicates("-javaagent:myjar.jar=option -javaagent:anotherjar.jar=option").toArray().length);
+
+		assertEquals("same jar, different option", 1, JvmInternalsDataProvider
+				.checkDuplicates("-javaagent:myjar.jar=option -javaagent:myjar.jar=anotheroption").toArray().length);
+		assertEquals("different jar, different option", 0,
+				JvmInternalsDataProvider
+						.checkDuplicates("-javaagent:myjar.jar=option -javaagent:anotherjar.jar=anotheroption")
+						.toArray().length);
 	}
 
 	@Test
 	@SuppressWarnings("unchecked")
 	public void testJavaAgentPathIsParsedCorrectly() {
-		String arguments = "-javagent:c:/path/to/archive/myjar.jar "
-				+ "-javagent:c:/path/to/archive/myjar.jar";
+		String arguments = "-javagent:c:/path/to/archive/myjar.jar " + "-javagent:c:/path/to/archive/myjar.jar";
 		String expectedResult = "-javagent:c:/path/to/archive/myjar.jar";
 
 		Collection<ArrayList<String>> result = JvmInternalsDataProvider.checkDuplicates(arguments);
 		String actualResult = ((ArrayList<String>) result.toArray()[0]).get(0);
 		assertEquals(expectedResult, actualResult);
diff a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/jdk/TestRulesWithJfr.java b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/jdk/TestRulesWithJfr.java
--- a/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/jdk/TestRulesWithJfr.java
+++ b/core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/jdk/TestRulesWithJfr.java
@@ -103,20 +103,20 @@
 	private static final String BASELINE_DIR = "baseline";
 	static final String RECORDINGS_DIR = "jfr";
 	static final String RECORDINGS_INDEXFILE = "index.txt";
 
 	private TimeZone defaultTimeZone;
-	
+
 	@Before
 	public void before() {
 		// empty the log before each test
 		DetailsTracker.clear();
 		// force UTC time zone during test
 		defaultTimeZone = TimeZone.getDefault();
 		TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
 	}
-	
+
 	@After
 	public void after() {
 		// restore previous default time zone
 		TimeZone.setDefault(defaultTimeZone);
 	}
@@ -131,11 +131,12 @@
 	public void verifyAllResults() throws IOException {
 		verifyRuleResults(false);
 	}
 
 	private void verifyRuleResults(boolean onlyOneRecording) throws IOException {
-		IOResourceSet jfrs = TestToolkit.getResourcesInDirectory(TestRulesWithJfr.class, RECORDINGS_DIR, RECORDINGS_INDEXFILE);
+		IOResourceSet jfrs = TestToolkit.getResourcesInDirectory(TestRulesWithJfr.class, RECORDINGS_DIR,
+				RECORDINGS_INDEXFILE);
 		String reportName = null;
 		if (onlyOneRecording) {
 			IOResource firstJfr = jfrs.iterator().next();
 			jfrs = new IOResourceSet(firstJfr);
 			reportName = firstJfr.getName();
@@ -239,12 +240,11 @@
 		try {
 			IItemCollection events = JfrLoaderToolkit.loadEvents(jfr.open());
 
 			for (IRule rule : RuleRegistry.getRules()) {
 				try {
-					RunnableFuture<Result> future = rule.evaluate(events,
-							IPreferenceValueProvider.DEFAULT_VALUES);
+					RunnableFuture<Result> future = rule.evaluate(events, IPreferenceValueProvider.DEFAULT_VALUES);
 					future.run();
 					Result result = future.get();
 //					for (Result result : results) {
 					if (minSeverity == null || Severity.get(result.getScore()).compareTo(minSeverity) >= 0) {
 						ItemSet itemSet = null;
@@ -528,12 +528,12 @@
 		public boolean compareAndLog(Object other) {
 			RuleResult otherRule = (RuleResult) other;
 			boolean scoreEquals = Objects.equals(score, otherRule.score);
 			if (!scoreEquals) {
 				// determine if this is just a rounding error
-				scoreEquals = (Math.abs(Float.valueOf(score) - Float.valueOf(otherRule.score)) < 0.0000000000001f) ? true
-						: false;
+				scoreEquals = (Math.abs(Float.valueOf(score) - Float.valueOf(otherRule.score)) < 0.0000000000001f)
+						? true : false;
 				if (scoreEquals) {
 					// apparently a rounding issue. Print it out for informational purposes
 					System.out
 							.println("Rule \"" + id + "\": Encountered rounding issue for score when comparing values "
 									+ score + " and " + otherRule.score);
diff a/core/tests/org.openjdk.jmc.flightrecorder.rules.test/pom.xml b/core/tests/org.openjdk.jmc.flightrecorder.rules.test/pom.xml
--- a/core/tests/org.openjdk.jmc.flightrecorder.rules.test/pom.xml
+++ b/core/tests/org.openjdk.jmc.flightrecorder.rules.test/pom.xml
@@ -37,10 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core.tests</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>flightrecorder.rules.test</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
            <dependency>
                    <groupId>org.openjdk.jmc</groupId>
                    <artifactId>flightrecorder.test</artifactId>
                    <type>test-jar</type>
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml b/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
--- a/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
@@ -37,10 +37,13 @@
 		<groupId>org.openjdk.jmc</groupId>
 		<artifactId>missioncontrol.core.tests</artifactId>
 		<version>8.0.0-SNAPSHOT</version>
 	</parent>
 	<artifactId>flightrecorder.test</artifactId>
+	<properties>
+		<spotless.config.path>${basedir}/../../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
+	</properties>
 	<dependencies>
            <dependency>
                    <groupId>org.openjdk.jmc</groupId>
                    <artifactId>common.test</artifactId>
                    <type>test-jar</type>
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/JfrAttributesTest.java b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/JfrAttributesTest.java
--- a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/JfrAttributesTest.java
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/JfrAttributesTest.java
@@ -48,16 +48,16 @@
 
 /**
  * Class to test JfrAttributes
  */
 public class JfrAttributesTest {
-	
+
 	@Test
 	public void testGetEventTypes() throws IOException, CouldNotLoadRecordingException {
 		IItemCollection events = RecordingToolkit.getFlightRecording(RecordingToolkit.getRecordings());
 		String typesStr = events.getAggregate(Aggregators.distinctAsString(JfrAttributes.EVENT_TYPE_ID, ", "));
-		
+
 		IAggregator<Set<IType<?>>, ?> distinct = Aggregators.distinct(JfrAttributes.EVENT_TYPE);
 		Set<IType<?>> types = events.getAggregate(distinct);
 		assertEquals(types.size(), typesStr.split(",").length);
 	}
 }
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/util/RecordingToolkit.java b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/util/RecordingToolkit.java
--- a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/util/RecordingToolkit.java
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/util/RecordingToolkit.java
@@ -65,18 +65,20 @@
 
 	public static IOResourceSet getRecordings() throws IOException {
 		return TestToolkit.getResourcesInDirectory(RecordingToolkit.class, RECORDINGS_DIRECTORY, RECORDINGS_INDEXFILE);
 	}
 
-	public static IItemCollection getNamedRecording(String recordingName) throws IOException, CouldNotLoadRecordingException {
-		return getFlightRecording(TestToolkit.getNamedResource(RecordingToolkit.class, RECORDINGS_DIRECTORY, recordingName));
+	public static IItemCollection getNamedRecording(String recordingName)
+			throws IOException, CouldNotLoadRecordingException {
+		return getFlightRecording(
+				TestToolkit.getNamedResource(RecordingToolkit.class, RECORDINGS_DIRECTORY, recordingName));
 	}
-	
+
 	public static InputStream getNamedRecordingResource(String recordingName) throws IOException {
 		return TestToolkit.getNamedResource(RecordingToolkit.class, RECORDINGS_DIRECTORY, recordingName).open();
 	}
-	
+
 	public static IItemCollection getFlightRecording(IOResourceSet resourceSet)
 			throws IOException, CouldNotLoadRecordingException {
 		return getFlightRecording(resourceSet.getResource(0));
 	}
 
@@ -92,11 +94,11 @@
 		}
 		IOToolkit.closeSilently(os);
 		IOToolkit.closeSilently(is);
 		return JfrLoaderToolkit.loadEvents(tmpRecording);
 	}
-	
+
 	public static File createResultFile(String prefix, String suffix, boolean deleteTempOnExit) throws IOException {
 		String resultDir = System.getProperty("results.dir");
 		File resultFile;
 		if (resultDir != null) {
 			resultFile = new File(resultDir, prefix + '.' + System.currentTimeMillis() + '.' + suffix);
diff a/core/tests/pom.xml b/core/tests/pom.xml
--- a/core/tests/pom.xml
+++ b/core/tests/pom.xml
@@ -51,10 +51,11 @@
 		<test.includes.default>**/Test*.java,**/*Test.java,**/*TestCase.java</test.includes.default>
 		<test.excludes.default>**/*$*</test.excludes.default>
 		<fail.if.no.tests>true</fail.if.no.tests>
 		<maven.compiler.source>1.7</maven.compiler.source>
 		<maven.compiler.target>1.7</maven.compiler.target>
+		<spotless.config.path>${basedir}/../../configuration/ide/eclipse/formatting/formatting.xml</spotless.config.path>
 	</properties>
 	<profiles>
 		<profile>
 			<id>TestIncludesDefined</id>
 			<activation>
