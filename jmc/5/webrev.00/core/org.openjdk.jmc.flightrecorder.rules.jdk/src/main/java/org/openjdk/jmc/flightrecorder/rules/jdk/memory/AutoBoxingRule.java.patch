diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/AutoBoxingRule.java
@@ -66,21 +66,21 @@
  * Rule that checks how much of the total allocation is caused by possible primitive to object
  * conversion. Looks at top frames and searches for java.lang.BoxType.valueOf.
  */
 // FIXME: Rename class (and message constants) from autoboxing to something more generic?
 public class AutoBoxingRule extends AbstractRule {
-	
+
 	private static final String VALUE_OF_METHOD_NAME = "valueOf";
 	private static final String SHORT = "java.lang.Short";
 	private static final String LONG = "java.lang.Long";
 	private static final String INTEGER = "java.lang.Integer";
 	private static final String FLOAT = "java.lang.Float";
 	private static final String DOUBLE = "java.lang.Double";
 	private static final String CHARACTER = "java.lang.Character";
 	private static final String BYTE = "java.lang.Byte";
 	private static final String BOOLEAN = "java.lang.Boolean";
-	
+
 	private static final IPredicate<IMCMethod> IS_AUTOBOXED_PREDICATE = new IPredicate<IMCMethod>() {
 		@Override
 		public boolean evaluate(IMCMethod method) {
 			String type = method.getType().getFullName();
 			if (VALUE_OF_METHOD_NAME.equals(method.getMethodName())) {
@@ -103,11 +103,11 @@
 				}
 			}
 			return false;
 		}
 	};
-	
+
 	private static final TypedPreference<IQuantity> AUTOBOXING_RATIO_INFO_LIMIT = new TypedPreference<>(
 			"autoboxing.ratio.info.limit", //$NON-NLS-1$
 			Messages.getString(Messages.AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT),
 			Messages.getString(Messages.AutoboxingRule_AUTOBOXING_RATIO_INFO_LIMIT_DESC), UnitLookup.PERCENTAGE,
 			UnitLookup.PERCENT.quantity(20));
@@ -160,11 +160,12 @@
 					if (firstBranch.getTailFrames().length > 0) {
 						secondFrame = firstBranch.getTailFrames()[0];
 					} else if (firstBranch.getEndFork().getBranchCount() > 0) {
 						secondFrame = firstBranch.getEndFork().getBranch(0).getFirstFrame();
 					}
-					secondFrameFromMostAllocated = StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep, false, false, true, true, true, false);
+					secondFrameFromMostAllocated = StacktraceFormatToolkit.formatFrame(secondFrame.getFrame(), sep,
+							false, false, true, true, true, false);
 				}
 				allocationSizeByType.put(method.getType(), total);
 			}
 		}
 		if (allocationSizeByType.size() == 0) {
@@ -183,11 +184,12 @@
 			String fullName = largestAllocatedType.getFullName();
 			mostAllocatedTypeInfo = " " + MessageFormat //$NON-NLS-1$
 					.format(Messages.getString(Messages.AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE), fullName);
 			mostAllocatedTypeInfoLong = "<p>" //$NON-NLS-1$
 					+ MessageFormat.format(Messages.getString(Messages.AutoboxingRule_RESULT_MOST_AUTOBOXED_TYPE_LONG),
-							fullName, largestAllocatedByType.displayUsing(IDisplayable.AUTO), secondFrameFromMostAllocated);
+							fullName, largestAllocatedByType.displayUsing(IDisplayable.AUTO),
+							secondFrameFromMostAllocated);
 		}
 
 		String shortIntro = MessageFormat.format(Messages.getString(Messages.AutoboxingRule_RESULT_AUTOBOXING_RATIO),
 				Math.round(possibleAutoboxingRatio), sizeOfAllBoxedAllocations.displayUsing(IDisplayable.AUTO));
 		String shortMessage = shortIntro + mostAllocatedTypeInfo;
