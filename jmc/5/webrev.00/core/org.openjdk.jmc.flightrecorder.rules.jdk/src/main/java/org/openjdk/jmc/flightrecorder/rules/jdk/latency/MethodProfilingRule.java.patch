diff a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
--- a/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/MethodProfilingRule.java
@@ -150,11 +150,12 @@
 		IMCStackTrace path;
 		IQuantity ratioOfAllPossibleSamples;
 		IQuantity ratioOfActualSamples;
 		IRange<IQuantity> window;
 
-		public MethodProfilingWindowResult(IMCMethod method, IMCStackTrace path, IQuantity ratio, IQuantity actualRatio, IRange<IQuantity> window) {
+		public MethodProfilingWindowResult(IMCMethod method, IMCStackTrace path, IQuantity ratio, IQuantity actualRatio,
+				IRange<IQuantity> window) {
 			this.method = method;
 			this.path = path;
 			this.ratioOfAllPossibleSamples = ratio;
 			this.ratioOfActualSamples = actualRatio;
 			this.window = window;
@@ -177,11 +178,12 @@
 	public static final TypedPreference<String> EXCLUDED_PACKAGE_REGEXP = new TypedPreference<>(
 			"method.profiling.evaluation.excluded.package", //$NON-NLS-1$
 			Messages.getString(Messages.MethodProfilingRule_EXCLUDED_PACKAGES),
 			Messages.getString(Messages.MethodProfilingRule_EXCLUDED_PACKAGES_DESC),
 			UnitLookup.PLAIN_TEXT.getPersister(), "java\\.(lang|util)"); //$NON-NLS-1$
-	private static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays.<TypedPreference<?>> asList(WINDOW_SIZE, EXCLUDED_PACKAGE_REGEXP);
+	private static final List<TypedPreference<?>> CONFIG_ATTRIBUTES = Arrays.<TypedPreference<?>> asList(WINDOW_SIZE,
+			EXCLUDED_PACKAGE_REGEXP);
 
 	/**
 	 * Private Callable implementation specifically used to avoid storing the FutureTask as a field.
 	 */
 	private class MethodProfilingCallable implements Callable<Result> {
@@ -267,16 +269,14 @@
 					mostInterestingResult.ratioOfActualSamples.displayUsing(IDisplayable.AUTO));
 			String formattedPath = "<ul>" + //$NON-NLS-1$
 					FormatToolkit.getHumanReadable(mostInterestingResult.path, false, false, true, true, true, false,
 							MAX_STACK_DEPTH, null, "<li>", //$NON-NLS-1$
 							"</li>" //$NON-NLS-1$
-							) + "</ul>"; //$NON-NLS-1$
+					) + "</ul>"; //$NON-NLS-1$
 			String longDescription = MessageFormat.format(
-					Messages.getString(Messages.HotMethodsRuleFactory_TEXT_INFO_LONG),
-					buildResultList(percentByMethod),
-					formattedPath
-					);
+					Messages.getString(Messages.HotMethodsRuleFactory_TEXT_INFO_LONG), buildResultList(percentByMethod),
+					formattedPath);
 			result = new Result(this, mappedScore, shortDescription, shortDescription + "<p>" + longDescription); //$NON-NLS-1$
 		}
 		return result;
 	}
 
@@ -337,20 +337,22 @@
 	 * @return an IUnorderedWindowVisitor implementation that will populate the rawScores list with
 	 *         raw score values
 	 */
 	private IUnorderedWindowVisitor createWindowVisitor(
 		final PeriodRangeMap settings, final IItemFilter settingsFilter, final IQuantity windowSize,
-		final List<MethodProfilingWindowResult> rawScores, final FutureTask<Result> evaluationTask, final Pattern excludes) {
+		final List<MethodProfilingWindowResult> rawScores, final FutureTask<Result> evaluationTask,
+		final Pattern excludes) {
 		return new IUnorderedWindowVisitor() {
 			@Override
 			public void visitWindow(IItemCollection items, IQuantity startTime, IQuantity endTime) {
 				IRange<IQuantity> windowRange = QuantityRange.createWithEnd(startTime, endTime);
 				if (RulesToolkit.getSettingMaxPeriod(items, JdkTypeIDs.EXECUTION_SAMPLE) == null) {
-					Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> resultPair = performCalculation(items, settings.getSetting(startTime));
+					Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> resultPair = performCalculation(items,
+							settings.getSetting(startTime));
 					if (resultPair != null) {
-						rawScores.add(new MethodProfilingWindowResult(resultPair.right.getFrames().get(0).getMethod(), resultPair.right,
-								resultPair.left.left, resultPair.left.right, windowRange));
+						rawScores.add(new MethodProfilingWindowResult(resultPair.right.getFrames().get(0).getMethod(),
+								resultPair.right, resultPair.left.left, resultPair.left.right, windowRange));
 					}
 				} else {
 					Set<IQuantity> settingTimes = items.apply(settingsFilter)
 							.getAggregate(Aggregators.distinct(JfrAttributes.START_TIME));
 					IQuantity start = startTime;
@@ -365,12 +367,13 @@
 					for (Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> score : scores) {
 						if (score != null) {
 							if (scoresByMethod.get(score.right) == null) {
 								scoresByMethod.put(score.right, score.left);
 							} else {
-								scoresByMethod.put(score.right, new Pair<>(score.left.left.add(scoresByMethod.get(score.right).left),
-										score.left.right.add(scoresByMethod.get(score.right).right)));
+								scoresByMethod.put(score.right,
+										new Pair<>(score.left.left.add(scoresByMethod.get(score.right).left),
+												score.left.right.add(scoresByMethod.get(score.right).right)));
 							}
 						}
 					}
 					IQuantity sumScore = UnitLookup.PERCENT_UNITY.quantity(0);
 					IQuantity actualScore = UnitLookup.PERCENT_UNITY.quantity(0);
@@ -382,11 +385,12 @@
 							sumScore = sumScore.add(entry.getValue().left);
 						}
 					}
 					IQuantity averageOfAllPossibleSamples = sumScore.multiply(1d / scores.size());
 					IMCMethod hottestMethod = (hottestPath == null ? null : hottestPath.getFrames().get(0).getMethod());
-					rawScores.add(new MethodProfilingWindowResult(hottestMethod, hottestPath, averageOfAllPossibleSamples, actualScore, windowRange));
+					rawScores.add(new MethodProfilingWindowResult(hottestMethod, hottestPath,
+							averageOfAllPossibleSamples, actualScore, windowRange));
 				}
 			}
 
 			@Override
 			public boolean shouldContinue() {
@@ -401,11 +405,12 @@
 			 * @param period
 			 *            the periodicity to base the relevancy calculation on
 			 * @return a double value in the interval [0,1] with 1 being a system in completely
 			 *         saturated load with only one method called
 			 */
-			private Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> performCalculation(IItemCollection items, IQuantity period) {
+			private Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> performCalculation(
+				IItemCollection items, IQuantity period) {
 				IItemCollection filteredItems = items.apply(JdkFilters.EXECUTION_SAMPLE);
 				final IMCMethod[] maxMethod = new IMCMethod[1];
 				final IMCStackTrace[] maxPath = new IMCStackTrace[1];
 				// Using this GroupingAggregator because it's the only way to extract the keys from the aggregation along with values
 				IAggregator<IQuantity, ?> aggregator = GroupingAggregator.build("", "", //$NON-NLS-1$ //$NON-NLS-2$
@@ -416,11 +421,12 @@
 							public IType<IQuantity> getValueType() {
 								return UnitLookup.NUMBER;
 							}
 
 							@Override
-							public IQuantity getValue(Iterable<? extends GroupEntry<IMCStackTrace, CountConsumer>> groupEntries) {
+							public IQuantity getValue(
+								Iterable<? extends GroupEntry<IMCStackTrace, CountConsumer>> groupEntries) {
 								HashMap<IMCMethod, IQuantity> map = new HashMap<>();
 								HashMap<IMCMethod, IMCStackTrace> pathMap = new HashMap<>();
 								int total = 0;
 								// When we group by stack trace we can run into situations where the top frames are otherwise the same
 								// for our purposes (finding the hottest method), but they differ by BCI, throwing off the count.
@@ -429,29 +435,33 @@
 									IMCStackTrace trace = processPath(group.getKey());
 									total += group.getConsumer().getCount();
 									if (!trace.getFrames().isEmpty()) {
 										IMCMethod topFrameMethod = trace.getFrames().get(0).getMethod();
 										if (map.get(topFrameMethod) == null) {
-											map.put(topFrameMethod, UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount()));
+											map.put(topFrameMethod,
+													UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount()));
 											pathMap.put(topFrameMethod, trace);
 										} else {
 											IQuantity old = map.get(topFrameMethod);
-											map.put(topFrameMethod, old.add(UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount())));
+											map.put(topFrameMethod, old.add(
+													UnitLookup.NUMBER_UNITY.quantity(group.getConsumer().getCount())));
 										}
 									}
 								}
 								if (!pathMap.isEmpty() && !map.isEmpty()) {
-									Entry<IMCMethod, IQuantity> topEntry = Collections.max(map.entrySet(), new Comparator<Entry<IMCMethod, IQuantity>>() {
-										@Override
-										public int compare(Entry<IMCMethod, IQuantity> arg0,
-												Entry<IMCMethod, IQuantity> arg1) {
-											return arg0.getValue().compareTo(arg1.getValue());
-										}
-									});
+									Entry<IMCMethod, IQuantity> topEntry = Collections.max(map.entrySet(),
+											new Comparator<Entry<IMCMethod, IQuantity>>() {
+												@Override
+												public int compare(
+													Entry<IMCMethod, IQuantity> arg0,
+													Entry<IMCMethod, IQuantity> arg1) {
+													return arg0.getValue().compareTo(arg1.getValue());
+												}
+											});
 									maxPath[0] = pathMap.get(topEntry.getKey());
 									maxMethod[0] = topEntry.getKey();
-									return topEntry.getValue().multiply(1d/total);
+									return topEntry.getValue().multiply(1d / total);
 								}
 								return UnitLookup.NUMBER_UNITY.quantity(0);
 							}
 
 							private IMCStackTrace processPath(IMCStackTrace path) {
@@ -469,11 +479,11 @@
 									}
 								}
 								frames.removeAll(framesToDrop);
 								return new MCStackTrace(frames, path.getTruncationState());
 							}
-				});
+						});
 
 				IQuantity maxRatio = filteredItems.getAggregate(aggregator);
 				Pair<Pair<IQuantity, IQuantity>, IMCStackTrace> result = null;
 				if (maxMethod[0] != null && maxRatio != null && period != null) { // ignoring if there are no samples or if we don't yet know the periodicity
 					double periodsPerSecond = 1 / period.doubleValueIn(UnitLookup.SECOND);
