<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames core/org.openjdk.jmc.flightrecorder/src/main/java/org/openjdk/jmc/flightrecorder/jdk/JdkAggregators.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  *
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  *
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  *
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  *
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  *
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.jdk;
 34 
 35 import static org.openjdk.jmc.common.item.Aggregators.avg;
 36 import static org.openjdk.jmc.common.item.Aggregators.distinctAsString;
 37 import static org.openjdk.jmc.common.item.Aggregators.filter;
 38 import static org.openjdk.jmc.common.item.Aggregators.max;
 39 import static org.openjdk.jmc.common.item.Aggregators.min;
 40 import static org.openjdk.jmc.common.item.Aggregators.or;
 41 import static org.openjdk.jmc.common.item.Aggregators.sum;
 42 import static org.openjdk.jmc.flightrecorder.JfrAttributes.DURATION;
 43 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.CONCURRENT_GC_THREADS;
 44 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.FLAG_NAME;
 45 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.FLAG_VALUE_BOOLEAN;
 46 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.FLAG_VALUE_NUMBER;
 47 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.GC_TIME_RATIO;
 48 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_ADDRESS_SIZE;
 49 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_INITIAL_SIZE;
 50 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_MAX_SIZE;
 51 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_MIN_SIZE;
 52 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_OBJECT_ALIGNMENT;
 53 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_TOTAL;
 54 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HEAP_USED;
 55 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.HW_THREADS;
 56 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_ADDRESS;
 57 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_FILE_BYTES_READ;
 58 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_FILE_BYTES_WRITTEN;
 59 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_HOST;
 60 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_PORT;
 61 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_SOCKET_BYTES_READ;
 62 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.IO_SOCKET_BYTES_WRITTEN;
 63 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.NEW_RATIO;
 64 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.NUMBER_OF_CORES;
 65 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.NUMBER_OF_SOCKETS;
 66 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.PARALLEL_GC_THREADS;
 67 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.TENURING_THRESHOLD_INITIAL;
 68 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.TENURING_THRESHOLD_MAXIMUM;
 69 import static org.openjdk.jmc.flightrecorder.jdk.JdkAttributes.TLAB_REFILL_WASTE_LIMIT;
 70 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.AFTER_GC;
 71 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.ALLOC_INSIDE_TLAB;
 72 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.ALLOC_OUTSIDE_TLAB;
 73 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.BEFORE_GC;
 74 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.CODE_CACHE_FULL;
 75 import static org.openjdk.jmc.flightrecorder.jdk.JdkFilters.SOCKET_READ_OR_WRITE;
 76 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.BOOLEAN_FLAG;
 77 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.CPU_INFORMATION;
 78 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.FILE_READ;
 79 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.FILE_WRITE;
 80 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.GC_CONF;
 81 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.GC_CONF_SURVIVOR;
 82 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.GC_CONF_TLAB;
 83 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.GC_CONF_YOUNG_GENERATION;
 84 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.GC_PAUSE;
 85 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.HEAP_CONF;
 86 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.HEAP_SUMMARY;
 87 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.OBJECT_COUNT;
 88 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.OS_INFORMATION;
 89 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.OS_MEMORY_SUMMARY;
 90 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.SOCKET_READ;
 91 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.SOCKET_WRITE;
 92 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.ULONG_FLAG;
 93 import static org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs.VM_INFO;
 94 
 95 import java.text.MessageFormat;
 96 
 97 import org.openjdk.jmc.common.item.Aggregators;
<a name="1" id="anc1"></a><span class="line-removed"> 98 import org.openjdk.jmc.common.item.IAccessorFactory;</span>
 99 import org.openjdk.jmc.common.item.IAggregator;
100 import org.openjdk.jmc.common.item.IAttribute;
<a name="2" id="anc2"></a><span class="line-removed">101 import org.openjdk.jmc.common.item.IMemberAccessor;</span>
<span class="line-removed">102 import org.openjdk.jmc.common.item.IType;</span>
103 import org.openjdk.jmc.common.item.ItemFilters;
104 import org.openjdk.jmc.common.unit.IQuantity;
105 import org.openjdk.jmc.common.unit.UnitLookup;
106 import org.openjdk.jmc.flightrecorder.JfrAttributes;
107 import org.openjdk.jmc.flightrecorder.jdk.messages.internal.Messages;
108 
109 /**
110  * Various useful aggregators based on JDK flight recorder data.
111  */
112 public final class JdkAggregators {
113 
114 	// VM Info
115 	public static final IAggregator&lt;String, ?&gt; JVM_NAME = distinctAsString(VM_INFO, JdkAttributes.JVM_NAME);
116 	public static final IAggregator&lt;IQuantity, ?&gt; JVM_PID = min(JdkAttributes.JVM_PID.getName(), null, VM_INFO,
117 			JdkAttributes.JVM_PID);
118 	public static final IAggregator&lt;IQuantity, ?&gt; JVM_START_TIME = min(JdkAttributes.JVM_START_TIME.getName(), null,
119 			VM_INFO, JdkAttributes.JVM_START_TIME);
120 	public static final IAggregator&lt;String, ?&gt; JVM_VERSION = distinctAsString(VM_INFO, JdkAttributes.JVM_VERSION);
121 	public static final IAggregator&lt;String, ?&gt; JAVA_ARGUMENTS = distinctAsString(VM_INFO, JdkAttributes.JAVA_ARGUMENTS);
122 	public static final IAggregator&lt;String, ?&gt; JVM_ARGUMENTS = distinctAsString(VM_INFO, JdkAttributes.JVM_ARGUMENTS);
123 
124 	public static final IAggregator&lt;IQuantity, ?&gt; JVM_SHUTDOWN_TIME = min(
125 			Messages.getString(Messages.ATTR_SHUTDOWN_TIME), null, JdkTypeIDs.VM_SHUTDOWN, JfrAttributes.START_TIME);
126 	public static final IAggregator&lt;String, ?&gt; JVM_SHUTDOWN_REASON = distinctAsString(JdkTypeIDs.VM_SHUTDOWN,
127 			JdkAttributes.SHUTDOWN_REASON);
128 	// CPU info
129 	public static final IAggregator&lt;IQuantity, ?&gt; MIN_HW_THREADS = min(HW_THREADS.getName(), null, CPU_INFORMATION,
130 			HW_THREADS);
131 	public static final IAggregator&lt;IQuantity, ?&gt; MIN_NUMBER_OF_CORES = min(NUMBER_OF_CORES.getName(), null,
132 			CPU_INFORMATION, NUMBER_OF_CORES);
133 	public static final IAggregator&lt;IQuantity, ?&gt; MIN_NUMBER_OF_SOCKETS = min(NUMBER_OF_SOCKETS.getName(), null,
134 			CPU_INFORMATION, NUMBER_OF_SOCKETS);
135 	public static final IAggregator&lt;String, ?&gt; CPU_DESCRIPTION = distinctAsString(CPU_INFORMATION,
136 			JdkAttributes.CPU_DESCRIPTION);
137 	public static final IAggregator&lt;String, ?&gt; CPU_TYPE = distinctAsString(CPU_INFORMATION, JdkAttributes.CPU_TYPE);
138 	// OS info
139 	public static final IAggregator&lt;String, ?&gt; OS_VERSION = distinctAsString(OS_INFORMATION, JdkAttributes.OS_VERSION);
140 	public static final IAggregator&lt;IQuantity, ?&gt; MAX_USED_MEMORY = max(
141 			Messages.getString(Messages.AGGR_MAX_USED_MEMORY), null, OS_MEMORY_SUMMARY, JdkAttributes.OS_MEMORY_USED);
142 	public static final IAggregator&lt;IQuantity, ?&gt; MIN_TOTAL_MEMORY = min(
143 			Messages.getString(Messages.AGGR_MIN_TOTAL_MEMORY), null, OS_MEMORY_SUMMARY, JdkAttributes.OS_MEMORY_TOTAL);
144 	// Heap config
145 	public static final IAggregator&lt;IQuantity, ?&gt; HEAP_CONF_MAX_SIZE = max(HEAP_MAX_SIZE.getName(), null, HEAP_CONF,
146 			HEAP_MAX_SIZE);
147 	public static final IAggregator&lt;IQuantity, ?&gt; HEAP_CONF_MIN_SIZE = min(HEAP_MIN_SIZE.getName(), null, HEAP_CONF,
148 			HEAP_MIN_SIZE);
149 	public static final IAggregator&lt;IQuantity, ?&gt; HEAP_CONF_INITIAL_SIZE_MIN = min(HEAP_INITIAL_SIZE.getName(), null,
150 			HEAP_CONF, HEAP_INITIAL_SIZE);
151 	public static final IAggregator&lt;IQuantity, ?&gt; HEAP_OBJECT_ALIGNMENT_MIN = min(HEAP_OBJECT_ALIGNMENT.getName(), null,
152 			HEAP_CONF, HEAP_OBJECT_ALIGNMENT);
153 	public static final IAggregator&lt;IQuantity, ?&gt; HEAP_ADDRESS_SIZE_MIN = min(HEAP_ADDRESS_SIZE.getName(), null,
154 			HEAP_CONF, HEAP_ADDRESS_SIZE);
155 	public static final IAggregator&lt;Boolean, ?&gt; USE_COMPRESSED_OOPS = or(HEAP_CONF,
156 			JdkAttributes.HEAP_USE_COMPRESSED_OOPS);
157 	public static final IAggregator&lt;String, ?&gt; COMPRESSED_OOPS_MODE = distinctAsString(HEAP_CONF,
158 			JdkAttributes.HEAP_COMPRESSED_OOPS_MODE);
159 	// GC config
160 	public static final IAggregator&lt;String, ?&gt; OLD_COLLECTOR = distinctAsString(GC_CONF, JdkAttributes.OLD_COLLECTOR);
161 	public static final IAggregator&lt;String, ?&gt; YOUNG_COLLECTOR = distinctAsString(GC_CONF,
162 			JdkAttributes.YOUNG_COLLECTOR);
163 	public static final IAggregator&lt;IQuantity, ?&gt; PARALLEL_GC_THREAD_COUNT_MAX = max(GC_CONF, PARALLEL_GC_THREADS);
164 	public static final IAggregator&lt;IQuantity, ?&gt; PARALLEL_GC_THREAD_COUNT_MIN = min(PARALLEL_GC_THREADS.getName(),
165 			null, GC_CONF, PARALLEL_GC_THREADS);
166 	public static final IAggregator&lt;IQuantity, ?&gt; CONCURRENT_GC_THREAD_COUNT_MIN = min(CONCURRENT_GC_THREADS.getName(),
167 			null, GC_CONF, CONCURRENT_GC_THREADS);
168 	public static final IAggregator&lt;Boolean, ?&gt; EXPLICIT_GC_CONCURRENT = or(GC_CONF,
169 			JdkAttributes.EXPLICIT_GC_CONCURRENT);
170 	public static final IAggregator&lt;Boolean, ?&gt; EXPLICIT_GC_DISABLED = or(GC_CONF, JdkAttributes.EXPLICIT_GC_DISABLED);
171 	public static final IAggregator&lt;Boolean, ?&gt; USE_DYNAMIC_GC_THREADS = or(GC_CONF,
172 			JdkAttributes.USE_DYNAMIC_GC_THREADS);
173 	public static final IAggregator&lt;IQuantity, ?&gt; GC_TIME_RATIO_MIN = min(GC_TIME_RATIO.getName(), null, GC_CONF,
174 			GC_TIME_RATIO);
175 	public static final IAggregator&lt;IQuantity, ?&gt; YOUNG_GENERATION_MIN_SIZE = max(
176 			JdkAttributes.YOUNG_GENERATION_MIN_SIZE.getName(), null, GC_CONF_YOUNG_GENERATION,
177 			JdkAttributes.YOUNG_GENERATION_MIN_SIZE);
178 	public static final IAggregator&lt;IQuantity, ?&gt; YOUNG_GENERATION_MAX_SIZE = min(
179 			JdkAttributes.YOUNG_GENERATION_MAX_SIZE.getName(), null, GC_CONF_YOUNG_GENERATION,
180 			JdkAttributes.YOUNG_GENERATION_MIN_SIZE);
181 	public static final IAggregator&lt;IQuantity, ?&gt; NEW_RATIO_MIN = min(NEW_RATIO.getName(), null,
182 			GC_CONF_YOUNG_GENERATION, NEW_RATIO);
183 	public static final IAggregator&lt;IQuantity, ?&gt; TENURING_THRESHOLD_INITIAL_MIN = min(
184 			TENURING_THRESHOLD_INITIAL.getName(), null, GC_CONF_SURVIVOR, TENURING_THRESHOLD_INITIAL);
185 	public static final IAggregator&lt;IQuantity, ?&gt; TENURING_THRESHOLD_MAX = max(TENURING_THRESHOLD_MAXIMUM.getName(),
186 			null, GC_CONF_SURVIVOR, TENURING_THRESHOLD_MAXIMUM);
187 	public static final IAggregator&lt;Boolean, ?&gt; USES_TLABS = or(GC_CONF_TLAB, JdkAttributes.USES_TLABS);
188 	public static final IAggregator&lt;IQuantity, ?&gt; TLAB_MIN_SIZE = min(JdkAttributes.TLAB_MIN_SIZE.getName(), null,
189 			GC_CONF_TLAB, JdkAttributes.TLAB_MIN_SIZE);
190 	public static final IAggregator&lt;IQuantity, ?&gt; TLAB_REFILL_WASTE_LIMIT_MIN = min(TLAB_REFILL_WASTE_LIMIT.getName(),
191 			null, GC_CONF_TLAB, TLAB_REFILL_WASTE_LIMIT);
192 	// Other
193 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_HEAP_USED_BEFORE_GC = filter(
194 			Messages.getString(Messages.AGGR_AVG_HEAP_USED_BEFORE_GC), null, avg(HEAP_SUMMARY, HEAP_USED), BEFORE_GC);
195 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_HEAP_USED_AFTER_GC = filter(
196 			Messages.getString(Messages.AGGR_AVG_HEAP_USED_AFTER_GC), null, avg(HEAP_SUMMARY, HEAP_USED), AFTER_GC);
197 	public static final IAggregator&lt;IQuantity, ?&gt; SUM_HEAP_USED_BEFORE_GC = filter(&quot;SUM_HEAP_USED_BEFORE_GC&quot;, null, //$NON-NLS-1$
198 			sum(HEAP_SUMMARY, HEAP_USED), BEFORE_GC);
199 	public static final IAggregator&lt;IQuantity, ?&gt; SUM_HEAP_USED_AFTER_GC = filter(&quot;SUM_HEAP_USED_AFTER_GC&quot;, null, //$NON-NLS-1$
200 			sum(HEAP_SUMMARY, HEAP_USED), AFTER_GC);
201 
202 	public static final IAggregator&lt;IQuantity, ?&gt; OBJECT_COUNT_MAX_SIZE = max(
203 			Messages.getString(Messages.AGGR_OBJECT_COUNT_MAX_SIZE),
204 			Messages.getString(Messages.AGGR_OBJECT_COUNT_MAX_SIZE_DESC), OBJECT_COUNT, HEAP_TOTAL);
205 	public static final IAggregator&lt;IQuantity, ?&gt; OBJECT_COUNT_MAX_INSTANCES = max(
206 			Messages.getString(Messages.AGGR_OBJECT_COUNT_MAX_INSTANCES),
207 			Messages.getString(Messages.AGGR_OBJECT_COUNT_MAX_INSTANCES_DESC), OBJECT_COUNT, JdkAttributes.COUNT);
208 	public static final IAggregator&lt;Boolean, ?&gt; UNLOCK_EXPERIMENTAL_VM_OPTIONS = filter(
209 			Messages.getString(Messages.AGGR_UNLOCK_EXPERIMENTAL_VM_OPTIONS), null,
210 			or(BOOLEAN_FLAG, FLAG_VALUE_BOOLEAN), ItemFilters.equals(FLAG_NAME, &quot;UnlockExperimentalVMOptions&quot;)); //$NON-NLS-1$
211 	public static final IAggregator&lt;Boolean, ?&gt; IGNORE_UNRECOGNIZED_VM_OPTIONS = filter(
212 			Messages.getString(Messages.AGGR_IGNORE_UNRECOGNIZED_VM_OPTIONS), null,
213 			or(BOOLEAN_FLAG, FLAG_VALUE_BOOLEAN), ItemFilters.equals(FLAG_NAME, &quot;IgnoreUnrecognizedVMOptions&quot;)); //$NON-NLS-1$
214 	public static final IAggregator&lt;Boolean, ?&gt; USE_STRING_DEDUPLICATION = filter(&quot;UseStringDeduplication&quot;, null, //$NON-NLS-1$
215 			or(BOOLEAN_FLAG, FLAG_VALUE_BOOLEAN), ItemFilters.equals(FLAG_NAME, &quot;UseStringDeduplication&quot;)); //$NON-NLS-1$
216 	public static final IAggregator&lt;Boolean, ?&gt; USE_G1_GC = filter(&quot;UseG1GC&quot;, null, //$NON-NLS-1$
217 			or(BOOLEAN_FLAG, FLAG_VALUE_BOOLEAN), ItemFilters.equals(FLAG_NAME, &quot;UseG1GC&quot;)); //$NON-NLS-1$
218 	public static final IAggregator&lt;Boolean, ?&gt; COMPACT_STRINGS = filter(&quot;CompactStrings&quot;, null, //$NON-NLS-1$
219 			or(BOOLEAN_FLAG, FLAG_VALUE_BOOLEAN), ItemFilters.equals(FLAG_NAME, &quot;CompactStrings&quot;)); //$NON-NLS-1$
220 	public static final IAggregator&lt;IQuantity, ?&gt; LARGEST_MAX_HEAP_SIZE_FROM_FLAG = filter(
221 			Messages.getString(Messages.AGGR_LARGEST_MAX_HEAP_SIZE_FROM_FLAG), null, max(ULONG_FLAG, FLAG_VALUE_NUMBER),
222 			ItemFilters.equals(FLAG_NAME, &quot;MaxHeapSize&quot;)); //$NON-NLS-1$
223 	public static final IAggregator&lt;IQuantity, ?&gt; OUTSIDE_TLAB_COUNT = Aggregators.count(
224 			Messages.getString(Messages.AGGR_OUTSIDE_TLAB_COUNT),
225 			Messages.getString(Messages.AGGR_OUTSIDE_TLAB_COUNT_DESC), ALLOC_OUTSIDE_TLAB);
226 	public static final IAggregator&lt;IQuantity, ?&gt; INSIDE_TLAB_COUNT = Aggregators.count(
227 			Messages.getString(Messages.AGGR_INSIDE_TLAB_COUNT),
228 			Messages.getString(Messages.AGGR_INSIDE_TLAB_COUNT_DESC), ALLOC_INSIDE_TLAB);
229 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_WRITE_LONGEST = Aggregators.max(FILE_WRITE, DURATION);
230 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_WRITE_LARGEST = Aggregators.max(FILE_WRITE,
231 			IO_FILE_BYTES_WRITTEN);
232 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_READ_LONGEST = Aggregators.max(FILE_READ, DURATION);
233 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_READ_LARGEST = Aggregators.max(FILE_READ, IO_FILE_BYTES_READ);
234 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_WRITE_SIZE = Aggregators.sum(
235 			Messages.getString(Messages.AGGR_FILE_WRITE_SIZE), Messages.getString(Messages.AGGR_FILE_WRITE_SIZE_DESC),
236 			FILE_WRITE, IO_FILE_BYTES_WRITTEN);
237 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_READ_SIZE = Aggregators.sum(
238 			Messages.getString(Messages.AGGR_FILE_READ_SIZE), Messages.getString(Messages.AGGR_FILE_READ_SIZE_DESC),
239 			FILE_READ, IO_FILE_BYTES_READ);
240 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_WRITE_COUNT = Aggregators.count(
241 			Messages.getString(Messages.AGGR_FILE_WRITE_COUNT), Messages.getString(Messages.AGGR_FILE_WRITE_COUNT_DESC),
242 			JdkFilters.FILE_WRITE);
243 	public static final IAggregator&lt;IQuantity, ?&gt; FILE_READ_COUNT = Aggregators.count(
244 			Messages.getString(Messages.AGGR_FILE_READ_COUNT), Messages.getString(Messages.AGGR_FILE_READ_COUNT_DESC),
245 			JdkFilters.FILE_READ);
246 	public static final IAggregator&lt;IQuantity, ?&gt; ERROR_COUNT = Aggregators.count(
247 			Messages.getString(Messages.AGGR_ERROR_COUNT), Messages.getString(Messages.AGGR_ERROR_COUNT_DESC),
248 			JdkFilters.ERRORS);
249 	public static final IAggregator&lt;IQuantity, ?&gt; EXCEPTIONS_COUNT = Aggregators.count(
250 			Messages.getString(Messages.AGGR_EXCEPTIONS_COUNT), Messages.getString(Messages.AGGR_EXCEPTIONS_COUNT_DESC),
251 			JdkFilters.EXCEPTIONS);
252 	public static final IAggregator&lt;IQuantity, ?&gt; THROWABLES_COUNT = Aggregators.count(
253 			Messages.getString(Messages.AGGR_THROWABLES_COUNT), Messages.getString(Messages.AGGR_THROWABLES_COUNT_DESC),
254 			JdkFilters.THROWABLES);
255 	public static final IAggregator&lt;IQuantity, ?&gt; CODE_CACHE_FULL_COUNT = Aggregators.count(
256 			Messages.getString(Messages.AGGR_CODE_CACHE_FULL_COUNT),
257 			Messages.getString(Messages.AGGR_CODE_CACHE_FULL_COUNT_DESC), CODE_CACHE_FULL);
258 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_WRITE_LONGEST = Aggregators.max(SOCKET_WRITE, DURATION);
259 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_WRITE_LARGEST = Aggregators.max(SOCKET_WRITE,
260 			IO_SOCKET_BYTES_WRITTEN);
261 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_READ_LONGEST = Aggregators.max(SOCKET_READ, DURATION);
262 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_READ_LARGEST = Aggregators.max(SOCKET_READ,
263 			IO_SOCKET_BYTES_READ);
264 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_WRITE_SIZE = Aggregators.sum(
265 			Messages.getString(Messages.AGGR_SOCKET_WRITE_SIZE),
266 			Messages.getString(Messages.AGGR_SOCKET_WRITE_SIZE_DESC), SOCKET_WRITE, IO_SOCKET_BYTES_WRITTEN);
267 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_READ_SIZE = Aggregators.sum(
268 			Messages.getString(Messages.AGGR_SOCKET_READ_SIZE), Messages.getString(Messages.AGGR_SOCKET_READ_SIZE_DESC),
269 			SOCKET_READ, IO_SOCKET_BYTES_READ);
270 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_WRITE_COUNT = Aggregators.count(
271 			Messages.getString(Messages.AGGR_SOCKET_WRITE_COUNT),
272 			Messages.getString(Messages.AGGR_SOCKET_WRITE_COUNT_DESC), JdkFilters.SOCKET_WRITE);
273 	public static final IAggregator&lt;IQuantity, ?&gt; SOCKET_READ_COUNT = Aggregators.count(
274 			Messages.getString(Messages.AGGR_SOCKET_READ_COUNT),
275 			Messages.getString(Messages.AGGR_SOCKET_READ_COUNT_DESC), JdkFilters.SOCKET_READ);
276 	public static final IAggregator&lt;IQuantity, ?&gt; NUMBER_OF_DISTINCT_PORTS = Aggregators
277 			.filter(Aggregators.countDistinct(Messages.getString(Messages.AGGR_NUMBER_OF_DISTINCT_PORTS),
278 					Messages.getString(Messages.AGGR_NUMBER_OF_DISTINCT_PORTS_DESC), IO_PORT), SOCKET_READ_OR_WRITE);
279 	public static final IAggregator&lt;IQuantity, ?&gt; NUMBER_OF_DISTINCT_HOSTS = Aggregators
280 			.filter(Aggregators.countDistinct(Messages.getString(Messages.AGGR_NUMBER_OF_DISTINCT_HOSTS),
281 					Messages.getString(Messages.AGGR_NUMBER_OF_DISTINCT_HOSTS_DESC), IO_ADDRESS), SOCKET_READ_OR_WRITE);
282 	public static final IAggregator&lt;String, ?&gt; HOST_NAMES_DISTINCT = Aggregators
283 			.filter(Aggregators.distinctAsString(IO_HOST, &quot;,&quot;), SOCKET_READ_OR_WRITE); //$NON-NLS-1$
284 	public static final IAggregator&lt;IQuantity, ?&gt; LONGEST_GC_PAUSE = Aggregators.max(
285 			Messages.getString(Messages.AGGR_LONGEST_GC_PAUSE), Messages.getString(Messages.AGGR_LONGEST_GC_PAUSE_DESC),
286 			GC_PAUSE, DURATION);
287 	public static final IAggregator&lt;IQuantity, ?&gt; TOTAL_GC_PAUSE = Aggregators.sum(
288 			Messages.getString(Messages.AGGR_TOTAL_GC_PAUSE), Messages.getString(Messages.AGGR_TOTAL_GC_PAUSE_DESC),
289 			GC_PAUSE, DURATION);
290 
291 	public static final IAggregator&lt;IQuantity, ?&gt; JFR_DATA_LOST_COUNT = Aggregators.count(
292 			Messages.getString(Messages.AGGR_JFR_DATA_LOST_COUNT),
293 			Messages.getString(Messages.AGGR_JFR_DATA_LOST_COUNT_DESC), JdkFilters.JFR_DATA_LOST);
294 	public static final IAggregator&lt;IQuantity, ?&gt; FLR_DATA_LOST_SIZE = Aggregators.sum(
295 			Messages.getString(Messages.AGGR_FLR_DATA_LOST_SIZE),
296 			Messages.getString(Messages.AGGR_FLR_DATA_LOST_SIZE_DESC), JdkTypeIDs.JFR_DATA_LOST,
297 			JfrAttributes.FLR_DATA_LOST);
298 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_JVM_USER_CPU = Aggregators.avg(JdkTypeIDs.CPU_LOAD,
299 			JdkAttributes.JVM_USER);
300 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_JVM_TOTAL_CPU = Aggregators.avg(JdkTypeIDs.CPU_LOAD,
301 			JdkAttributes.JVM_TOTAL);
302 	public static final IAggregator&lt;IQuantity, ?&gt; EXECUTION_SAMPLE_COUNT = Aggregators.count(
303 			Messages.getString(Messages.AGGR_EXECUTION_SAMPLE_COUNT),
304 			Messages.getString(Messages.AGGR_EXECUTION_SAMPLE_COUNT_DESC), JdkFilters.EXECUTION_SAMPLE);
305 	public static final IAggregator&lt;IQuantity, ?&gt; METASPACE_OOM_COUNT = Aggregators.count(
306 			Messages.getString(Messages.AGGR_METASPACE_OOM_COUNT),
307 			Messages.getString(Messages.AGGR_METASPACE_OOM_COUNT_DESC), JdkFilters.METASPACE_OOM);
308 	public static final IAggregator&lt;IQuantity, ?&gt; TOTAL_BLOCKED_TIME = Aggregators.sum(
309 			Messages.getString(Messages.AGGR_TOTAL_BLOCKED_TIME),
310 			Messages.getString(Messages.AGGR_TOTAL_BLOCKED_TIME_DESC), JdkTypeIDs.MONITOR_ENTER, DURATION);
311 	public static final IAggregator&lt;IQuantity, ?&gt; TOTAL_BLOCKED_COUNT = Aggregators.count(
312 			Messages.getString(Messages.AGGR_TOTAL_BLOCKED_COUNT),
313 			Messages.getString(Messages.AGGR_TOTAL_BLOCKED_COUNT_DESC), JdkFilters.MONITOR_ENTER);
314 	public static final IAggregator&lt;IQuantity, ?&gt; MAX_BLOCKED_TIME = Aggregators.max(
315 			Messages.getString(Messages.AGGR_MAX_BLOCKED_TIME), Messages.getString(Messages.AGGR_MAX_BLOCKED_TIME_DESC),
316 			JdkTypeIDs.MONITOR_ENTER, DURATION);
317 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_BLOCKED_TIME = Aggregators.avg(
318 			Messages.getString(Messages.AGGR_AVG_BLOCKED_TIME), Messages.getString(Messages.AGGR_AVG_BLOCKED_TIME_DESC),
319 			JdkTypeIDs.MONITOR_ENTER, DURATION);
320 	public static final IAggregator&lt;IQuantity, ?&gt; STDDEV_BLOCKED_TIME = Aggregators.stddevp(
321 			Messages.getString(Messages.AGGR_STDDEV_BLOCKED_TIME),
322 			Messages.getString(Messages.AGGR_STDDEV_BLOCKED_TIME_DESC), DURATION);
323 	public static final IAggregator&lt;IQuantity, ?&gt; ALLOC_INSIDE_TLAB_AVG = Aggregators.avg(
324 			Messages.getString(Messages.AGGR_ALLOC_INSIDE_TLAB_AVG),
325 			Messages.getString(Messages.AGGR_ALLOC_INSIDE_TLAB_AVG_DESC), JdkTypeIDs.ALLOC_INSIDE_TLAB,
326 			JdkAttributes.ALLOCATION_SIZE);
327 	public static final IAggregator&lt;IQuantity, ?&gt; ALLOC_OUTSIDE_TLAB_AVG = Aggregators.avg(
328 			Messages.getString(Messages.AGGR_ALLOC_OUTSIDE_TLAB_AVG),
329 			Messages.getString(Messages.AGGR_ALLOC_OUTSIDE_TLAB_AVG_DESC), JdkTypeIDs.ALLOC_OUTSIDE_TLAB,
330 			JdkAttributes.ALLOCATION_SIZE);
331 	public static final IAggregator&lt;IQuantity, ?&gt; ALLOC_INSIDE_TLAB_SUM = Aggregators.sum(
332 			Messages.getString(Messages.AGGR_ALLOC_INSIDE_TLAB_SUM),
333 			Messages.getString(Messages.AGGR_ALLOC_INSIDE_TLAB_SUM_DESC), JdkTypeIDs.ALLOC_INSIDE_TLAB,
334 			JdkAttributes.TLAB_SIZE);
335 	public static final IAggregator&lt;IQuantity, ?&gt; ALLOC_OUTSIDE_TLAB_SUM = Aggregators.sum(
336 			Messages.getString(Messages.AGGR_ALLOC_OUTSIDE_TLAB_SUM),
337 			Messages.getString(Messages.AGGR_ALLOC_OUTSIDE_TLAB_SUM_DESC), JdkTypeIDs.ALLOC_OUTSIDE_TLAB,
338 			JdkAttributes.ALLOCATION_SIZE);
339 	public static final IAggregator&lt;IQuantity, ?&gt; SWEEP_METHOD_SUM = Aggregators.sum(
340 			Messages.getString(Messages.AGGR_SWEEP_METHOD_SUM), Messages.getString(Messages.AGGR_SWEEP_METHOD_SUM_DESC),
341 			JdkTypeIDs.SWEEP_CODE_CACHE, JdkAttributes.SWEEP_METHOD_SWEPT);
342 	public static final IAggregator&lt;IQuantity, ?&gt; SWEEP_FLUSHED_SUM = Aggregators.sum(
343 			Messages.getString(Messages.AGGR_SWEEP_FLUSHED_SUM),
344 			Messages.getString(Messages.AGGR_SWEEP_FLUSHED_SUM_DESC), JdkTypeIDs.SWEEP_CODE_CACHE,
345 			JdkAttributes.SWEEP_METHOD_FLUSHED);
346 	public static final IAggregator&lt;IQuantity, ?&gt; SWEEP_ZOMBIFIED_SUM = Aggregators.sum(
347 			Messages.getString(Messages.AGGR_SWEEP_ZOMBIFIED_SUM),
348 			Messages.getString(Messages.AGGR_SWEEP_ZOMBIFIED_SUM_DESC), JdkTypeIDs.SWEEP_CODE_CACHE,
349 			JdkAttributes.SWEEP_METHOD_ZOMBIFIED);
350 	public static final IAggregator&lt;IQuantity, ?&gt; SWEEP_RECLAIMED_SUM = Aggregators.sum(
351 			Messages.getString(Messages.AGGR_SWEEP_RECLAIMED_SUM),
352 			Messages.getString(Messages.AGGR_SWEEP_RECLAIMED_SUM_DESC), JdkTypeIDs.SWEEP_CODE_CACHE,
353 			JdkAttributes.SWEEP_METHOD_RECLAIMED);
354 	public static final IAggregator&lt;IQuantity, ?&gt; FIRST_ITEM_START = Aggregators.min(JfrAttributes.START_TIME);
355 	public static final IAggregator&lt;IQuantity, ?&gt; FIRST_ITEM_END = Aggregators.min(JfrAttributes.END_TIME);
356 	public static final IAggregator&lt;IQuantity, ?&gt; LAST_ITEM_END = Aggregators.max(JfrAttributes.END_TIME);
357 	public static final IAggregator&lt;IQuantity, ?&gt; LONGEST_EVENT = Aggregators.max(DURATION);
358 	public static final IAggregator&lt;IQuantity, ?&gt; ITEM_COUNT = Aggregators
359 			.count(Messages.getString(Messages.AGGR_ITEM_COUNT), Messages.getString(Messages.AGGR_ITEM_COUNT_DESC));
360 
361 	public static final IAggregator&lt;IQuantity, ?&gt; ALLOCATION_TOTAL = Aggregators.sum(
362 			Messages.getString(Messages.AGGR_ALLOCATION_TOTAL), Messages.getString(Messages.AGGR_ALLOCATION_TOTAL_DESC),
<a name="3" id="anc3"></a><span class="line-modified">363 			UnitLookup.MEMORY, new IAccessorFactory&lt;IQuantity&gt;() {</span>
<span class="line-removed">364 </span>
<span class="line-removed">365 				@Override</span>
<span class="line-removed">366 				public &lt;T&gt; IMemberAccessor&lt;? extends IQuantity, T&gt; getAccessor(IType&lt;T&gt; type) {</span>
<span class="line-removed">367 					if (type.getIdentifier().equals(JdkTypeIDs.ALLOC_INSIDE_TLAB)) {</span>
<span class="line-removed">368 						return JdkAttributes.TLAB_SIZE.getAccessor(type);</span>
<span class="line-removed">369 					} else if (type.getIdentifier().equals(JdkTypeIDs.ALLOC_OUTSIDE_TLAB)) {</span>
<span class="line-removed">370 						return JdkAttributes.ALLOCATION_SIZE.getAccessor(type);</span>
<span class="line-removed">371 					}</span>
<span class="line-removed">372 					return null;</span>
<span class="line-removed">373 				}</span>
<span class="line-removed">374 			});</span>
375 	public static final IAggregator&lt;IQuantity, ?&gt; TOTAL_IO_TIME = Aggregators.filter(
376 			Aggregators.sum(Messages.getString(Messages.AGGR_TOTAL_IO_TIME),
377 					Messages.getString(Messages.AGGR_TOTAL_IO_TIME_DESC), JfrAttributes.DURATION),
378 			JdkFilters.FILE_OR_SOCKET_IO);
379 	public static final IAggregator&lt;IQuantity, ?&gt; MAX_IO_TIME = Aggregators.filter(
380 			Aggregators.max(Messages.getString(Messages.AGGR_MAX_IO_TIME),
381 					Messages.getString(Messages.AGGR_MAX_IO_TIME_DESC), JfrAttributes.DURATION),
382 			JdkFilters.FILE_OR_SOCKET_IO);
383 	public static final IAggregator&lt;IQuantity, ?&gt; AVG_IO_TIME = Aggregators.filter(
384 			Aggregators.avg(Messages.getString(Messages.AGGR_AVG_IO_TIME),
385 					Messages.getString(Messages.AGGR_AVG_IO_TIME_DESC), JfrAttributes.DURATION),
386 			JdkFilters.FILE_OR_SOCKET_IO);
387 	public static final IAggregator&lt;IQuantity, ?&gt; STDDEV_IO_TIME = Aggregators.filter(
388 			Aggregators.stddevp(Messages.getString(Messages.AGGR_STDDEV_IO_TIME),
389 					Messages.getString(Messages.AGGR_STDDEV_IO_TIME_DESC), JfrAttributes.DURATION),
390 			JdkFilters.FILE_OR_SOCKET_IO);
391 	public static final IAggregator&lt;IQuantity, ?&gt; TOTAL_IO_COUNT = Aggregators.count(
392 			Messages.getString(Messages.AGGR_TOTAL_IO_COUNT), Messages.getString(Messages.AGGR_TOTAL_IO_COUNT_DESC),
393 			JdkFilters.FILE_OR_SOCKET_IO);
394 	public static final IAggregator&lt;IQuantity, ?&gt; CLASS_LOADING_COUNT = Aggregators.count(
395 			Messages.getString(Messages.AGGR_CLASS_LOADING_COUNT),
396 			Messages.getString(Messages.AGGR_CLASS_LOADING_COUNT_DESC), JdkFilters.CLASS_LOAD);
397 	public static final IAggregator&lt;IQuantity, ?&gt; CLASS_LOADING_TIME_SUM = Aggregators.sum(
398 			Messages.getString(Messages.AGGR_CLASS_LOADING_TIME_SUM),
399 			Messages.getString(Messages.AGGR_CLASS_LOADING_TIME_SUM_DESC), JdkTypeIDs.CLASS_LOAD,
400 			JfrAttributes.DURATION);
401 
402 	public static final IAggregator&lt;IQuantity, ?&gt; VM_OPERATION_COUNT = Aggregators.count(
403 			Messages.getString(Messages.AGGR_VM_OPERATION_COUNT),
404 			Messages.getString(Messages.AGGR_VM_OPERATION_COUNT_DESC), JdkFilters.VM_OPERATIONS);
405 	public static final IAggregator&lt;IQuantity, ?&gt; VM_OPERATION_DURATION = Aggregators.sum(
406 			Messages.getString(Messages.AGGR_VM_OPERATION_DURATION),
407 			Messages.getString(Messages.AGGR_VM_OPERATION_DURATION_DESC), JfrAttributes.DURATION);
408 
409 	public static final IAggregator&lt;IQuantity, ?&gt; COMPILATIONS_COUNT = Aggregators.count(
410 			Messages.getString(Messages.AGGR_COMPILATIONS_COUNT),
411 			Messages.getString(Messages.AGGR_COMPILATIONS_COUNT_DESC), JdkFilters.COMPILATION);
412 	public static final IAggregator&lt;IQuantity, ?&gt; LONGEST_COMPILATION = Aggregators.filter(Aggregators.max(DURATION),
413 			JdkFilters.COMPILATION);
414 
415 	public static final IAggregator&lt;String, ?&gt; DUMP_REASON = distinctAsString(JdkTypeIDs.DUMP_REASON,
416 			JdkAttributes.DUMP_REASON);
417 
418 	public static final IAggregator&lt;IQuantity, ?&gt; ADDRESSES_COUNT = Aggregators.countDistinct(
419 			Messages.getString(Messages.AGGR_ADDRESSES_COUNT), Messages.getString(Messages.AGGR_ADDRESSES_COUNT_DESC),
420 			JdkAttributes.MONITOR_ADDRESS);
421 	public static final IAggregator&lt;IQuantity, ?&gt; OLD_OBJECT_ADDRESSES_COUNT = Aggregators.countDistinct(
422 			Messages.getString(Messages.AGGR_ADDRESSES_COUNT), Messages.getString(Messages.AGGR_ADDRESSES_COUNT_DESC),
423 			JdkAttributes.OLD_OBJECT_ADDRESS);
424 
425 	public static final IAggregator&lt;?, ?&gt; BASE_ADDRESS = Aggregators.min(JdkTypeIDs.NATIVE_LIBRARY,
426 			JdkAttributes.BASE_ADDRESS);
427 	public static final IAggregator&lt;?, ?&gt; TOP_ADDRESS = Aggregators.min(JdkTypeIDs.NATIVE_LIBRARY,
428 			JdkAttributes.TOP_ADDRESS);
429 
430 	/**
431 	 * Aggregator for getting the first value, ie. the value from the event with the first occurring
432 	 * start time.
433 	 *
434 	 * @param attribute
435 	 *            attribute to get value from
436 	 * @return the value provided by the very first event
437 	 */
438 	public static &lt;V&gt; IAggregator&lt;V, ?&gt; first(IAttribute&lt;V&gt; attribute) {
439 		return new Aggregators.AdvancedMinAggregator&lt;&gt;(
440 				MessageFormat.format(Messages.getString(Messages.AGGR_FIRST_ATTRIBUTE), attribute.getName()),
441 				MessageFormat.format(Messages.getString(Messages.AGGR_FIRST_ATTRIBUTE_DESC), attribute.getName()),
442 				attribute, JfrAttributes.START_TIME);
443 	}
444 
445 	/**
446 	 * Aggregator for getting the last value, ie. the value from the event with the last occurring
447 	 * end time.
448 	 *
449 	 * @param attribute
450 	 *            attribute to get value from
451 	 * @return the value provided by the very last event
452 	 */
453 	public static &lt;V&gt; IAggregator&lt;V, ?&gt; last(IAttribute&lt;V&gt; attribute) {
454 		return new Aggregators.AdvancedMaxAggregator&lt;&gt;(
455 				MessageFormat.format(Messages.getString(Messages.AGGR_LAST_ATTRIBUTE), attribute.getName()),
456 				MessageFormat.format(Messages.getString(Messages.AGGR_LAST_ATTRIBUTE_DESC), attribute.getName()),
457 				attribute, JfrAttributes.END_TIME);
458 	}
459 
460 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>