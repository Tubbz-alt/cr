<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/io/IOToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/util/TestToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../util/XmlToolkit.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/io/IOToolkit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
154 			ZipInputStream zin = new ZipInputStream(in);
155 			zin.getNextEntry();
156 			return zin;
157 		}
158 		in.reset();
159 		return in;
160 	}
161 
162 	/**
163 	 * Checks if a file begins with a specified array of bytes.
164 	 *
165 	 * @param file
166 	 *            the file to examine
167 	 * @param magic
168 	 *            the magic data, an array with values between 0 and 255
169 	 * @return {@code true} if the file begins with the magic, {@code false} otherwise
170 	 * @throws IOException
171 	 *             if an error occurred when trying to read from the file
172 	 */
173 	public static boolean hasMagic(File file, int[] magic) throws IOException {
<span class="line-modified">174 		FileInputStream fis = null;</span>
<span class="line-removed">175 		try {</span>
<span class="line-removed">176 			fis = new FileInputStream(file);</span>
177 			return hasMagic(fis, magic);
<span class="line-removed">178 		} finally {</span>
<span class="line-removed">179 			closeSilently(fis);</span>
180 		}
181 	}
182 
183 	/**
184 	 * Checks if an input stream begins with a specified array of bytes. The input stream will be
185 	 * positioned at the first byte after the magic data after this call.
186 	 *
187 	 * @param is
188 	 *            the input stream to examine
189 	 * @param magic
190 	 *            the magic data, an array with values between 0 and 255
191 	 * @return {@code true} if the input stream begins with the magic, {@code false} otherwise
192 	 * @throws IOException
193 	 *             if an error occurred when trying to read from the stream
194 	 */
195 	public static boolean hasMagic(InputStream is, int[] magic) throws IOException {
196 		for (int element : magic) {
197 			int b = is.read();
198 			if (b != element) {
199 				return false;
</pre>
<hr />
<pre>
243 	 * cache this to avoid excessive allocations.
244 	 * 
245 	 * @return a copy of the magic bytes for Zip.
246 	 */
247 	public static int[] getZipMagic() {
248 		return MAGIC_ZIP.clone();
249 	}
250 
251 	/**
252 	 * Checks if the file is compressed in a way compatible with
253 	 * {@link #openUncompressedStream(File)}.
254 	 *
255 	 * @param file
256 	 *            the file to examine
257 	 * @return {@code true} if the file is compressed in a manner which can be uncompressed by
258 	 *         {@link #openUncompressedStream(File)}, {@code false} otherwise
259 	 * @throws IOException
260 	 *             if an error occurred when trying to read from the file
261 	 */
262 	public static boolean isCompressedFile(File file) throws IOException {
<span class="line-modified">263 		BufferedInputStream is = null;</span>
<span class="line-removed">264 		try {</span>
<span class="line-removed">265 			is = new BufferedInputStream(new FileInputStream(file), MAGIC_ZIP.length + 1);</span>
266 			is.mark(MAGIC_ZIP.length + 1);
267 			if (hasMagic(is, MAGIC_GZ)) {
268 				return true;
269 			}
270 			is.reset();
271 			return hasMagic(is, MAGIC_ZIP);
<span class="line-removed">272 		} finally {</span>
<span class="line-removed">273 			closeSilently(is);</span>
274 		}
275 	}
276 
277 	/**
278 	 * Read lines from a text file.
279 	 *
280 	 * @see #saveToFile(File, List)
281 	 * @param file
282 	 *            file to read lines from
283 	 * @return a list of strings, one for each line in the file
284 	 * @throws IOException
285 	 *             on I/O error
286 	 */
287 	public static List&lt;String&gt; loadFromFile(File file) throws IOException {
<span class="line-modified">288 		FileReader fr = new FileReader(file);</span>
<span class="line-removed">289 		try {</span>
290 			return loadFromReader(fr);
<span class="line-removed">291 		} catch (IOException e) {</span>
<span class="line-removed">292 			throw e;</span>
<span class="line-removed">293 		} finally {</span>
<span class="line-removed">294 			closeSilently(fr);</span>
295 		}
296 	}
297 
298 	private static List&lt;String&gt; loadFromReader(Reader reader) throws IOException {
299 		List&lt;String&gt; lines = new ArrayList&lt;&gt;();
<span class="line-modified">300 		BufferedReader br = new BufferedReader(reader);</span>
<span class="line-modified">301 		while (br.ready()) {</span>
<span class="line-modified">302 			lines.add(br.readLine());</span>


303 		}
<span class="line-removed">304 		return lines;</span>
305 	}
306 
307 	/**
308 	 * Write lines to a text file. If the file already exists, it will be overwritten.
309 	 *
310 	 * @see #loadFromFile(File)
311 	 * @param file
312 	 *            file to write lines to
313 	 * @param lines
314 	 *            a list of strings that will be written on one line each
315 	 * @throws IOException
316 	 *             on I/O error
317 	 */
318 	public static void saveToFile(File file, List&lt;String&gt; lines) throws IOException {
<span class="line-modified">319 		PrintWriter pr = null;</span>
<span class="line-removed">320 		try {</span>
<span class="line-removed">321 			pr = new PrintWriter(new FileWriter(file));</span>
322 			for (String line : lines) {
323 				pr.println(line);
324 			}
<span class="line-removed">325 		} finally {</span>
<span class="line-removed">326 			closeSilently(pr);</span>
327 		}
328 	}
329 
330 	/**
331 	 * Read lines from an input stream.
332 	 *
333 	 * @see #saveToFile(File, List)
334 	 * @param is
335 	 *            input stream to read lines from
336 	 * @return a list of strings, one for each line in the stream
337 	 * @throws IOException
338 	 *             on I/O error
339 	 */
340 	public static List&lt;String&gt; loadFromStream(InputStream is) throws IOException {
<span class="line-modified">341 		try {</span>

342 			List&lt;String&gt; lines = new ArrayList&lt;&gt;();
<span class="line-removed">343 			BufferedInputStream bis = new BufferedInputStream(is);</span>
<span class="line-removed">344 			BufferedReader r = new BufferedReader(new InputStreamReader(bis));</span>
345 			while (r.ready()) {
346 				lines.add(r.readLine());
347 			}
348 			return lines;
349 		} finally {
350 			closeSilently(is);
351 		}
352 	}
353 
354 	/**
355 	 * Copy all data from an input stream to a file.
356 	 *
357 	 * @param in
358 	 *            input stream to read from
359 	 * @param toOutput
360 	 *            file to write to
361 	 * @param append
362 	 *            {@code true} if the file should be appended to, {@code false} if it should be
363 	 *            overwritten
364 	 * @throws IOException
365 	 *             on I/O error
366 	 */
367 	public static void write(InputStream in, File toOutput, boolean append) throws IOException {
<span class="line-modified">368 		FileOutputStream fos = new FileOutputStream(toOutput, append);</span>
<span class="line-modified">369 		BufferedOutputStream os = null;</span>
<span class="line-removed">370 		try {</span>
<span class="line-removed">371 			os = new BufferedOutputStream(fos);</span>
372 			copy(in, os);
<span class="line-removed">373 		} finally {</span>
<span class="line-removed">374 			closeSilently(os);</span>
<span class="line-removed">375 			closeSilently(fos);</span>
376 		}
377 	}
378 
379 	/**
380 	 * Copy all data from an input stream to an output stream.
381 	 *
382 	 * @param is
383 	 *            input stream to read from
384 	 * @param os
385 	 *            output stream to write to
386 	 * @throws IOException
387 	 *             on I/O error
388 	 */
389 	public static void copy(InputStream is, OutputStream os) throws IOException {
390 		copy(is, os, 1024);
391 	}
392 
393 	/**
394 	 * Copy all data from an input stream to an output stream.
395 	 *
</pre>
<hr />
<pre>
420 	 * @param targetFile
421 	 *            target file to copy data to
422 	 * @throws IOException
423 	 *             if something goes wrong during the copy
424 	 */
425 	public static void copyFile(File srcFile, File targetFile) throws IOException {
426 		Files.copy(srcFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING,
427 				StandardCopyOption.COPY_ATTRIBUTES);
428 	}
429 
430 	/**
431 	 * Calculates an MD5 hash on ten evenly distributed 1kB blocks from the file.
432 	 *
433 	 * @param file
434 	 *            file to calculate hash for
435 	 * @return MD5 hash string
436 	 * @throws IOException
437 	 *             if something goes wrong when reading file data
438 	 */
439 	public static String calculateFileHash(File file) throws IOException {
<span class="line-modified">440 		RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;); //$NON-NLS-1$</span>
<span class="line-removed">441 		try {</span>
442 			long seek = raf.length() / 10;
443 			byte[] buffer = new byte[1024];
444 			MessageDigest hash = MessageDigest.getInstance(&quot;MD5&quot;); //$NON-NLS-1$
445 			int read;
446 			while ((read = raf.read(buffer)) &gt; 0) {
447 				hash.update(buffer, 0, read);
448 				raf.seek(raf.getFilePointer() + seek);
449 			}
450 			return new BigInteger(1, hash.digest()).toString();
451 		} catch (NoSuchAlgorithmException e) {
452 			throw new RuntimeException(e);
<span class="line-removed">453 		} finally {</span>
<span class="line-removed">454 			closeSilently(raf);</span>
455 		}
456 	}
457 }
</pre>
</td>
<td>
<hr />
<pre>
154 			ZipInputStream zin = new ZipInputStream(in);
155 			zin.getNextEntry();
156 			return zin;
157 		}
158 		in.reset();
159 		return in;
160 	}
161 
162 	/**
163 	 * Checks if a file begins with a specified array of bytes.
164 	 *
165 	 * @param file
166 	 *            the file to examine
167 	 * @param magic
168 	 *            the magic data, an array with values between 0 and 255
169 	 * @return {@code true} if the file begins with the magic, {@code false} otherwise
170 	 * @throws IOException
171 	 *             if an error occurred when trying to read from the file
172 	 */
173 	public static boolean hasMagic(File file, int[] magic) throws IOException {
<span class="line-modified">174 		try (FileInputStream fis = new FileInputStream(file)) {</span>


175 			return hasMagic(fis, magic);


176 		}
177 	}
178 
179 	/**
180 	 * Checks if an input stream begins with a specified array of bytes. The input stream will be
181 	 * positioned at the first byte after the magic data after this call.
182 	 *
183 	 * @param is
184 	 *            the input stream to examine
185 	 * @param magic
186 	 *            the magic data, an array with values between 0 and 255
187 	 * @return {@code true} if the input stream begins with the magic, {@code false} otherwise
188 	 * @throws IOException
189 	 *             if an error occurred when trying to read from the stream
190 	 */
191 	public static boolean hasMagic(InputStream is, int[] magic) throws IOException {
192 		for (int element : magic) {
193 			int b = is.read();
194 			if (b != element) {
195 				return false;
</pre>
<hr />
<pre>
239 	 * cache this to avoid excessive allocations.
240 	 * 
241 	 * @return a copy of the magic bytes for Zip.
242 	 */
243 	public static int[] getZipMagic() {
244 		return MAGIC_ZIP.clone();
245 	}
246 
247 	/**
248 	 * Checks if the file is compressed in a way compatible with
249 	 * {@link #openUncompressedStream(File)}.
250 	 *
251 	 * @param file
252 	 *            the file to examine
253 	 * @return {@code true} if the file is compressed in a manner which can be uncompressed by
254 	 *         {@link #openUncompressedStream(File)}, {@code false} otherwise
255 	 * @throws IOException
256 	 *             if an error occurred when trying to read from the file
257 	 */
258 	public static boolean isCompressedFile(File file) throws IOException {
<span class="line-modified">259 		try (BufferedInputStream is = new BufferedInputStream(new FileInputStream(file), MAGIC_ZIP.length + 1)) {</span>


260 			is.mark(MAGIC_ZIP.length + 1);
261 			if (hasMagic(is, MAGIC_GZ)) {
262 				return true;
263 			}
264 			is.reset();
265 			return hasMagic(is, MAGIC_ZIP);


266 		}
267 	}
268 
269 	/**
270 	 * Read lines from a text file.
271 	 *
272 	 * @see #saveToFile(File, List)
273 	 * @param file
274 	 *            file to read lines from
275 	 * @return a list of strings, one for each line in the file
276 	 * @throws IOException
277 	 *             on I/O error
278 	 */
279 	public static List&lt;String&gt; loadFromFile(File file) throws IOException {
<span class="line-modified">280 		try (FileReader fr = new FileReader(file)) {</span>

281 			return loadFromReader(fr);




282 		}
283 	}
284 
285 	private static List&lt;String&gt; loadFromReader(Reader reader) throws IOException {
286 		List&lt;String&gt; lines = new ArrayList&lt;&gt;();
<span class="line-modified">287 		try (BufferedReader br = new BufferedReader(reader)) {</span>
<span class="line-modified">288 			while (br.ready()) {</span>
<span class="line-modified">289 				lines.add(br.readLine());</span>
<span class="line-added">290 			}</span>
<span class="line-added">291 			return lines;</span>
292 		}

293 	}
294 
295 	/**
296 	 * Write lines to a text file. If the file already exists, it will be overwritten.
297 	 *
298 	 * @see #loadFromFile(File)
299 	 * @param file
300 	 *            file to write lines to
301 	 * @param lines
302 	 *            a list of strings that will be written on one line each
303 	 * @throws IOException
304 	 *             on I/O error
305 	 */
306 	public static void saveToFile(File file, List&lt;String&gt; lines) throws IOException {
<span class="line-modified">307 		try (PrintWriter pr = new PrintWriter(new FileWriter(file))) {</span>


308 			for (String line : lines) {
309 				pr.println(line);
310 			}


311 		}
312 	}
313 
314 	/**
315 	 * Read lines from an input stream.
316 	 *
317 	 * @see #saveToFile(File, List)
318 	 * @param is
319 	 *            input stream to read lines from
320 	 * @return a list of strings, one for each line in the stream
321 	 * @throws IOException
322 	 *             on I/O error
323 	 */
324 	public static List&lt;String&gt; loadFromStream(InputStream is) throws IOException {
<span class="line-modified">325 		try (BufferedInputStream bis = new BufferedInputStream(is);</span>
<span class="line-added">326 				BufferedReader r = new BufferedReader(new InputStreamReader(bis))) {</span>
327 			List&lt;String&gt; lines = new ArrayList&lt;&gt;();


328 			while (r.ready()) {
329 				lines.add(r.readLine());
330 			}
331 			return lines;
332 		} finally {
333 			closeSilently(is);
334 		}
335 	}
336 
337 	/**
338 	 * Copy all data from an input stream to a file.
339 	 *
340 	 * @param in
341 	 *            input stream to read from
342 	 * @param toOutput
343 	 *            file to write to
344 	 * @param append
345 	 *            {@code true} if the file should be appended to, {@code false} if it should be
346 	 *            overwritten
347 	 * @throws IOException
348 	 *             on I/O error
349 	 */
350 	public static void write(InputStream in, File toOutput, boolean append) throws IOException {
<span class="line-modified">351 		try (FileOutputStream fos = new FileOutputStream(toOutput, append);</span>
<span class="line-modified">352 				BufferedOutputStream os = new BufferedOutputStream(fos)) {</span>


353 			copy(in, os);



354 		}
355 	}
356 
357 	/**
358 	 * Copy all data from an input stream to an output stream.
359 	 *
360 	 * @param is
361 	 *            input stream to read from
362 	 * @param os
363 	 *            output stream to write to
364 	 * @throws IOException
365 	 *             on I/O error
366 	 */
367 	public static void copy(InputStream is, OutputStream os) throws IOException {
368 		copy(is, os, 1024);
369 	}
370 
371 	/**
372 	 * Copy all data from an input stream to an output stream.
373 	 *
</pre>
<hr />
<pre>
398 	 * @param targetFile
399 	 *            target file to copy data to
400 	 * @throws IOException
401 	 *             if something goes wrong during the copy
402 	 */
403 	public static void copyFile(File srcFile, File targetFile) throws IOException {
404 		Files.copy(srcFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING,
405 				StandardCopyOption.COPY_ATTRIBUTES);
406 	}
407 
408 	/**
409 	 * Calculates an MD5 hash on ten evenly distributed 1kB blocks from the file.
410 	 *
411 	 * @param file
412 	 *            file to calculate hash for
413 	 * @return MD5 hash string
414 	 * @throws IOException
415 	 *             if something goes wrong when reading file data
416 	 */
417 	public static String calculateFileHash(File file) throws IOException {
<span class="line-modified">418 		try (RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;)) { //$NON-NLS-1$</span>

419 			long seek = raf.length() / 10;
420 			byte[] buffer = new byte[1024];
421 			MessageDigest hash = MessageDigest.getInstance(&quot;MD5&quot;); //$NON-NLS-1$
422 			int read;
423 			while ((read = raf.read(buffer)) &gt; 0) {
424 				hash.update(buffer, 0, read);
425 				raf.seek(raf.getFilePointer() + seek);
426 			}
427 			return new BigInteger(1, hash.digest()).toString();
428 		} catch (NoSuchAlgorithmException e) {
429 			throw new RuntimeException(e);


430 		}
431 	}
432 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../org.openjdk.jmc.agent/src/test/java/org/openjdk/jmc/agent/test/util/TestToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../util/XmlToolkit.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>