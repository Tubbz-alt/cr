<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcFreedRatioRule.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../latency/JavaBlockingRule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="IncreasingLiveSetRule.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/memory/GcFreedRatioRule.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
208 			 */
209 			private Pair&lt;IItemCollection, IRange&lt;IQuantity&gt;&gt; getWindowWithPairedHeapSummaryEvents(
210 				IItemCollection windowItems, IQuantity startTime, IQuantity endTime) {
211 				IQuantity newStartTime = null;
212 				IQuantity newEndTime = null;
213 				IItemCollection heapSummaryWindowItems = windowItems.apply(JdkFilters.HEAP_SUMMARY);
214 				IItemCollection heapSummaryAllItems = allItems.apply(JdkFilters.HEAP_SUMMARY);
215 				IQuantity lowestGcId = heapSummaryWindowItems.getAggregate(Aggregators.min(JdkAttributes.GC_ID));
216 				IItemCollection lowestGcIdWindowItems = heapSummaryWindowItems
217 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, lowestGcId));
218 				IItemCollection lowestGcIdAllItems = heapSummaryAllItems
219 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, lowestGcId));
220 				IItemCollection lowestGcIdBeforeWindowItems = lowestGcIdWindowItems
221 						.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
222 				IItemCollection lowestGcIdAfterWindowItems = lowestGcIdWindowItems
223 						.apply(JdkFilters.HEAP_SUMMARY_AFTER_GC);
224 				IItemCollection lowestGcIdBeforeAllItems = lowestGcIdAllItems.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
225 				// If the beginning of the window is between a &#39;before&#39; and an &#39;after&#39; event.
226 				if (lowestGcIdAfterWindowItems.hasItems() &amp;&amp; !lowestGcIdBeforeWindowItems.hasItems()) {
227 					if (lowestGcIdBeforeAllItems.hasItems()) {
<span class="line-modified">228 						newStartTime = lowestGcIdBeforeAllItems.getAggregate(JdkAggregators.FIRST_ITEM_END);</span>
229 					}
230 				}
231 				IQuantity highestGcId = heapSummaryWindowItems.getAggregate(Aggregators.max(JdkAttributes.GC_ID));
232 				IItemCollection highestGcIdWindowItems = heapSummaryWindowItems
233 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, highestGcId));
234 				IItemCollection highestGcIdAllItems = heapSummaryAllItems
235 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, highestGcId));
236 				IItemCollection highestGcIdBeforeWindowItems = highestGcIdWindowItems
237 						.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
238 				IItemCollection highestGcIdAfterWindowItems = lowestGcIdWindowItems
239 						.apply(JdkFilters.HEAP_SUMMARY_AFTER_GC);
240 				IItemCollection highestGcIdAfterAllItems = highestGcIdAllItems.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
241 				if (highestGcIdBeforeWindowItems.hasItems() &amp;&amp; !highestGcIdAfterWindowItems.hasItems()) {
242 					if (highestGcIdAfterAllItems.hasItems()) {
<span class="line-modified">243 						newEndTime = highestGcIdAfterAllItems.getAggregate(JdkAggregators.FIRST_ITEM_START);</span>
244 					}
245 				}
246 
247 				if (newStartTime != null || newEndTime != null) {
248 					if (newStartTime != null) {
249 						startTime = newStartTime;
250 					}
251 					if (newEndTime != null) {
252 						endTime = newEndTime;
253 					}
254 					windowItems = allItems
255 							.apply(ItemFilters.interval(JfrAttributes.END_TIME, startTime, false, endTime, false));
256 				}
257 
258 				// Filter out those that don&#39;t have matching before/after pairs
259 				Set&lt;IQuantity&gt; gcIds = windowItems.apply(JdkFilters.HEAP_SUMMARY)
260 						.getAggregate(Aggregators.distinct(JdkAttributes.GC_ID));
261 				for (Iterator&lt;IQuantity&gt; iterator = gcIds.iterator(); iterator.hasNext();) {
262 					IQuantity gcId = iterator.next();
263 					IItemCollection gcItems = windowItems.apply(ItemFilters.equals(JdkAttributes.GC_ID, gcId));
</pre>
</td>
<td>
<hr />
<pre>
208 			 */
209 			private Pair&lt;IItemCollection, IRange&lt;IQuantity&gt;&gt; getWindowWithPairedHeapSummaryEvents(
210 				IItemCollection windowItems, IQuantity startTime, IQuantity endTime) {
211 				IQuantity newStartTime = null;
212 				IQuantity newEndTime = null;
213 				IItemCollection heapSummaryWindowItems = windowItems.apply(JdkFilters.HEAP_SUMMARY);
214 				IItemCollection heapSummaryAllItems = allItems.apply(JdkFilters.HEAP_SUMMARY);
215 				IQuantity lowestGcId = heapSummaryWindowItems.getAggregate(Aggregators.min(JdkAttributes.GC_ID));
216 				IItemCollection lowestGcIdWindowItems = heapSummaryWindowItems
217 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, lowestGcId));
218 				IItemCollection lowestGcIdAllItems = heapSummaryAllItems
219 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, lowestGcId));
220 				IItemCollection lowestGcIdBeforeWindowItems = lowestGcIdWindowItems
221 						.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
222 				IItemCollection lowestGcIdAfterWindowItems = lowestGcIdWindowItems
223 						.apply(JdkFilters.HEAP_SUMMARY_AFTER_GC);
224 				IItemCollection lowestGcIdBeforeAllItems = lowestGcIdAllItems.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
225 				// If the beginning of the window is between a &#39;before&#39; and an &#39;after&#39; event.
226 				if (lowestGcIdAfterWindowItems.hasItems() &amp;&amp; !lowestGcIdBeforeWindowItems.hasItems()) {
227 					if (lowestGcIdBeforeAllItems.hasItems()) {
<span class="line-modified">228 						newStartTime = RulesToolkit.getEarliestEndTime(lowestGcIdBeforeAllItems);</span>
229 					}
230 				}
231 				IQuantity highestGcId = heapSummaryWindowItems.getAggregate(Aggregators.max(JdkAttributes.GC_ID));
232 				IItemCollection highestGcIdWindowItems = heapSummaryWindowItems
233 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, highestGcId));
234 				IItemCollection highestGcIdAllItems = heapSummaryAllItems
235 						.apply(ItemFilters.equals(JdkAttributes.GC_ID, highestGcId));
236 				IItemCollection highestGcIdBeforeWindowItems = highestGcIdWindowItems
237 						.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
238 				IItemCollection highestGcIdAfterWindowItems = lowestGcIdWindowItems
239 						.apply(JdkFilters.HEAP_SUMMARY_AFTER_GC);
240 				IItemCollection highestGcIdAfterAllItems = highestGcIdAllItems.apply(JdkFilters.HEAP_SUMMARY_BEFORE_GC);
241 				if (highestGcIdBeforeWindowItems.hasItems() &amp;&amp; !highestGcIdAfterWindowItems.hasItems()) {
242 					if (highestGcIdAfterAllItems.hasItems()) {
<span class="line-modified">243 						newEndTime = RulesToolkit.getEarliestStartTime(highestGcIdAfterAllItems);</span>
244 					}
245 				}
246 
247 				if (newStartTime != null || newEndTime != null) {
248 					if (newStartTime != null) {
249 						startTime = newStartTime;
250 					}
251 					if (newEndTime != null) {
252 						endTime = newEndTime;
253 					}
254 					windowItems = allItems
255 							.apply(ItemFilters.interval(JfrAttributes.END_TIME, startTime, false, endTime, false));
256 				}
257 
258 				// Filter out those that don&#39;t have matching before/after pairs
259 				Set&lt;IQuantity&gt; gcIds = windowItems.apply(JdkFilters.HEAP_SUMMARY)
260 						.getAggregate(Aggregators.distinct(JdkAttributes.GC_ID));
261 				for (Iterator&lt;IQuantity&gt; iterator = gcIds.iterator(); iterator.hasNext();) {
262 					IQuantity gcId = iterator.next();
263 					IItemCollection gcItems = windowItems.apply(ItemFilters.equals(JdkAttributes.GC_ID, gcId));
</pre>
</td>
</tr>
</table>
<center><a href="../latency/JavaBlockingRule.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="IncreasingLiveSetRule.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>