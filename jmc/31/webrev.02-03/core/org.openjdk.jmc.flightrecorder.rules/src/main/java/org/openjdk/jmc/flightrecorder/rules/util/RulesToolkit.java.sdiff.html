<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF.sdiff.html" target="_top">next &gt;</a></center>    <h2>core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1382 					.getAccessor(iItemIterable.getType());
1383 			if (iItemIterable.iterator().hasNext()) {
1384 				IItem next = iItemIterable.iterator().next();
1385 				if (next != null &amp;&amp; startTimeAccessor != null) {
1386 					IQuantity startTime = startTimeAccessor.getMember(next);
1387 					if (earliestStartTime == null) {
1388 						earliestStartTime = startTime;
1389 					} else {
1390 						if (earliestStartTime.compareTo(startTime) &gt;= 0) {
1391 							earliestStartTime = startTime;
1392 						}
1393 					}
1394 				}
1395 			}
1396 		}
1397 		return earliestStartTime;
1398 	}
1399 
1400 	/**
1401 	 * Returns the earliest end time in the provided item collection. This method is based on the
<span class="line-modified">1402 	 * assumption that item collection lanes are sorted by timestamp.</span>
1403 	 * 
1404 	 * @param items
1405 	 *            the item collection to find the earliest end time in
1406 	 * @return the earliest end time in the provided collection
1407 	 */
1408 	public static IQuantity getEarliestEndTime(IItemCollection items) {
1409 		IQuantity earliestEndTime = null;
1410 		for (IItemIterable iItemIterable : items) {
1411 			IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME
1412 					.getAccessor(iItemIterable.getType());
1413 			if (iItemIterable.iterator().hasNext()) {
1414 				IItem next = iItemIterable.iterator().next();
1415 				if (next != null &amp;&amp; endTimeAccessor != null) {
1416 					IQuantity endTime = endTimeAccessor.getMember(next);
1417 					if (earliestEndTime == null) {
1418 						earliestEndTime = endTime;
1419 					} else {
1420 						if (earliestEndTime.compareTo(endTime) &gt;= 0) {
1421 							earliestEndTime = endTime;
1422 						}
1423 					}
1424 				}
1425 			}
1426 		}
1427 		return earliestEndTime;
1428 	}
1429 
1430 	/**
1431 	 * Returns the latest end time in the provided item collection. This method is based on the
<span class="line-modified">1432 	 * assumption that item collection lanes are sorted by timestamp.</span>
1433 	 * 
1434 	 * @param items
1435 	 *            the item collection to find the latest end time in
1436 	 * @return the latest end time in the provided collection
1437 	 */
1438 	public static IQuantity getLatestEndTime(IItemCollection items) {
1439 		IQuantity latestEndTime = null;
1440 		for (IItemIterable iItemIterable : items) {
1441 			IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME
1442 					.getAccessor(iItemIterable.getType());
1443 			Iterator&lt;IItem&gt; iterator = iItemIterable.iterator();
1444 			IItem next = null;
1445 			while (iterator.hasNext()) {
1446 				next = iterator.next();
1447 			}
1448 			if (next != null &amp;&amp; endTimeAccessor != null) {
1449 				IQuantity startTime = endTimeAccessor.getMember(next);
1450 				if (latestEndTime == null) {
1451 					latestEndTime = startTime;
1452 				} else {
</pre>
</td>
<td>
<hr />
<pre>
1382 					.getAccessor(iItemIterable.getType());
1383 			if (iItemIterable.iterator().hasNext()) {
1384 				IItem next = iItemIterable.iterator().next();
1385 				if (next != null &amp;&amp; startTimeAccessor != null) {
1386 					IQuantity startTime = startTimeAccessor.getMember(next);
1387 					if (earliestStartTime == null) {
1388 						earliestStartTime = startTime;
1389 					} else {
1390 						if (earliestStartTime.compareTo(startTime) &gt;= 0) {
1391 							earliestStartTime = startTime;
1392 						}
1393 					}
1394 				}
1395 			}
1396 		}
1397 		return earliestStartTime;
1398 	}
1399 
1400 	/**
1401 	 * Returns the earliest end time in the provided item collection. This method is based on the
<span class="line-modified">1402 	 * assumption that item collection lanes are sorted by timestamp and are not overlapping.</span>
1403 	 * 
1404 	 * @param items
1405 	 *            the item collection to find the earliest end time in
1406 	 * @return the earliest end time in the provided collection
1407 	 */
1408 	public static IQuantity getEarliestEndTime(IItemCollection items) {
1409 		IQuantity earliestEndTime = null;
1410 		for (IItemIterable iItemIterable : items) {
1411 			IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME
1412 					.getAccessor(iItemIterable.getType());
1413 			if (iItemIterable.iterator().hasNext()) {
1414 				IItem next = iItemIterable.iterator().next();
1415 				if (next != null &amp;&amp; endTimeAccessor != null) {
1416 					IQuantity endTime = endTimeAccessor.getMember(next);
1417 					if (earliestEndTime == null) {
1418 						earliestEndTime = endTime;
1419 					} else {
1420 						if (earliestEndTime.compareTo(endTime) &gt;= 0) {
1421 							earliestEndTime = endTime;
1422 						}
1423 					}
1424 				}
1425 			}
1426 		}
1427 		return earliestEndTime;
1428 	}
1429 
1430 	/**
1431 	 * Returns the latest end time in the provided item collection. This method is based on the
<span class="line-modified">1432 	 * assumption that item collection lanes are sorted by timestamp and are not overlapping.</span>
1433 	 * 
1434 	 * @param items
1435 	 *            the item collection to find the latest end time in
1436 	 * @return the latest end time in the provided collection
1437 	 */
1438 	public static IQuantity getLatestEndTime(IItemCollection items) {
1439 		IQuantity latestEndTime = null;
1440 		for (IItemIterable iItemIterable : items) {
1441 			IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME
1442 					.getAccessor(iItemIterable.getType());
1443 			Iterator&lt;IItem&gt; iterator = iItemIterable.iterator();
1444 			IItem next = null;
1445 			while (iterator.hasNext()) {
1446 				next = iterator.next();
1447 			}
1448 			if (next != null &amp;&amp; endTimeAccessor != null) {
1449 				IQuantity startTime = endTimeAccessor.getMember(next);
1450 				if (latestEndTime == null) {
1451 					latestEndTime = startTime;
1452 				} else {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../../tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>