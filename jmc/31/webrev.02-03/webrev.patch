diff a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java
--- a/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java
+++ b/core/org.openjdk.jmc.flightrecorder.rules/src/main/java/org/openjdk/jmc/flightrecorder/rules/util/RulesToolkit.java
@@ -1397,11 +1397,11 @@
 		return earliestStartTime;
 	}
 
 	/**
 	 * Returns the earliest end time in the provided item collection. This method is based on the
-	 * assumption that item collection lanes are sorted by timestamp.
+	 * assumption that item collection lanes are sorted by timestamp and are not overlapping.
 	 * 
 	 * @param items
 	 *            the item collection to find the earliest end time in
 	 * @return the earliest end time in the provided collection
 	 */
@@ -1427,11 +1427,11 @@
 		return earliestEndTime;
 	}
 
 	/**
 	 * Returns the latest end time in the provided item collection. This method is based on the
-	 * assumption that item collection lanes are sorted by timestamp.
+	 * assumption that item collection lanes are sorted by timestamp and are not overlapping.
 	 * 
 	 * @param items
 	 *            the item collection to find the latest end time in
 	 * @return the latest end time in the provided collection
 	 */
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF b/core/tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF
--- a/core/tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/META-INF/MANIFEST.MF
@@ -6,7 +6,8 @@
 Bundle-Vendor: Oracle Corporation
 Bundle-RequiredExecutionEnvironment: JavaSE-1.7
 Bundle-ActivationPolicy: lazy
 Require-Bundle: org.junit,
  org.openjdk.jmc.common.test,
- org.openjdk.jmc.flightrecorder
+ org.openjdk.jmc.flightrecorder,
+ org.openjdk.jmc.flightrecorder.rules
 Automatic-Module-Name: org.openjdk.jmc.flightrecorder.test
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml b/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
--- a/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/pom.xml
@@ -58,10 +58,15 @@
            <dependency>
                    <groupId>org.openjdk.jmc</groupId>
                    <artifactId>flightrecorder</artifactId>
                    <version>${project.version}</version>
            </dependency>
+           <dependency>
+                   <groupId>org.openjdk.jmc</groupId>
+                   <artifactId>flightrecorder.rules</artifactId>
+                   <version>${project.version}</version>
+           </dependency>
            <dependency>
                    <groupId>junit</groupId>
                    <artifactId>junit</artifactId>
                    <scope>test</scope>
            </dependency>
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/OverlappingEventsTest.java b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/OverlappingEventsTest.java
--- /dev/null
+++ b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/java/org/openjdk/jmc/flightrecorder/test/OverlappingEventsTest.java
@@ -0,0 +1,80 @@
+package org.openjdk.jmc.flightrecorder.test;
+
+import java.io.IOException;
+
+import org.junit.Test;
+import org.junit.Assert;
+import org.openjdk.jmc.common.IDisplayable;
+import org.openjdk.jmc.common.item.IAggregator;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItem;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemIterable;
+import org.openjdk.jmc.common.item.IMemberAccessor;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.UnitLookup;
+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;
+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;
+import org.openjdk.jmc.flightrecorder.test.util.RecordingToolkit;
+
+public class OverlappingEventsTest {
+
+	private IQuantity earliestGoldenValue(IItemCollection events, IAttribute<IQuantity> attr) {
+		IQuantity earliest = UnitLookup.EPOCH_NS.quantity(Long.MAX_VALUE);
+		for (IItemIterable eventIterable : events) {
+			IMemberAccessor<IQuantity, IItem> accessor = attr.getAccessor(eventIterable.getType());
+			for (IItem event : eventIterable) {
+				IQuantity time = accessor.getMember(event);
+				if (earliest.compareTo(time) > 0) {
+					earliest = time;
+				}
+			}
+		}
+		return earliest.in(UnitLookup.EPOCH_NS);
+	}
+
+	private IQuantity latestGoldenValue(IItemCollection events, IAttribute<IQuantity> attr) {
+		IQuantity earliest = UnitLookup.EPOCH_NS.quantity(0);
+		for (IItemIterable eventIterable : events) {
+			IMemberAccessor<IQuantity, IItem> accessor = attr.getAccessor(eventIterable.getType());
+			for (IItem event : eventIterable) {
+				IQuantity time = accessor.getMember(event);
+				if (earliest.compareTo(time) < 0) {
+					earliest = time;
+				}
+			}
+		}
+		return earliest.in(UnitLookup.EPOCH_NS);
+	}
+
+	@Test
+	public void testStartTime() throws IOException, CouldNotLoadRecordingException {
+		IItemCollection overlap = RecordingToolkit.getNamedRecording("overlap.jfr");
+		IAggregator<IQuantity, ?> first = JdkAggregators.first(JfrAttributes.START_TIME);
+		IQuantity expected = overlap.getAggregate(first);
+		IQuantity actual = RulesToolkit.getEarliestStartTime(overlap).in(expected.getUnit());
+		Assert.assertEquals("expected: " + expected.displayUsing(IDisplayable.AUTO) + ", actual: "
+				+ actual.displayUsing(IDisplayable.AUTO), expected, actual);
+	}
+
+	@Test
+	public void testFirstEndTime() throws IOException, CouldNotLoadRecordingException {
+		IItemCollection overlap = RecordingToolkit.getNamedRecording("overlap.jfr");
+		IQuantity expected = earliestGoldenValue(overlap, JfrAttributes.END_TIME);
+		IQuantity actual = RulesToolkit.getEarliestEndTime(overlap).in(expected.getUnit());
+		Assert.assertEquals("expected: " + expected.displayUsing(IDisplayable.AUTO) + ", actual: "
+				+ actual.displayUsing(IDisplayable.AUTO), expected, actual);
+	}
+
+	@Test
+	public void testLastEndTime() throws IOException, CouldNotLoadRecordingException {
+		IItemCollection overlap = RecordingToolkit.getNamedRecording("overlap.jfr");
+		IQuantity expected = latestGoldenValue(overlap, JfrAttributes.END_TIME);
+		IQuantity actual = RulesToolkit.getLatestEndTime(overlap).in(expected.getUnit());
+		Assert.assertEquals("expected: " + expected.displayUsing(IDisplayable.AUTO) + ", actual: "
+				+ actual.displayUsing(IDisplayable.AUTO), expected, actual);
+	}
+
+}
diff a/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/resources/recordings/overlap.jfr b/core/tests/org.openjdk.jmc.flightrecorder.test/src/test/resources/recordings/overlap.jfr
Binary files /dev/null and core/tests/org.openjdk.jmc.flightrecorder.test/src/test/resources/recordings/overlap.jfr differ
