<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/resources/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/messages.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/resources/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/messages.properties</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18 #  conditions and the following disclaimer in the documentation and/or other materials provided with
 19 #  the distribution.
 20 #
 21 #  3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22 #  endorse or promote products derived from this software without specific prior written permission.
 23 #
 24 #  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25 #  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26 #  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27 #  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28 #  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29 #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31 #  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 #
 33 Preference_SHORT_RECORDING=Short recording limit
 34 Preference_SHORT_RECORDING_LONG=Minimum length of a recording to be considered useful for rules to work on.
 35 
 36 AllocationByClassRule_RULE_NAME=Allocated Classes
 37 # {0} is a class name
<span class="line-modified"> 38 AllocationByClassRule_TEXT_MESSAGE=The most allocated type is likely &#39;&#39;{0}&#39;&#39;, mostly commonly allocated by: {1}</span>
 39 AllocationByThreadRule_RULE_NAME=Threads Allocating
 40 # {0} is a thread name
 41 AllocationByThreadRule_TEXT_MESSAGE=The most allocations were likely done by thread &#39;&#39;{0}&#39;&#39; at: {1}
 42 AllocationRuleFactory_TEXT_CLASS_INFO_LONG=Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.
 43 AllocationRuleFactory_TEXT_THREAD_INFO_LONG=Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.
 44 ApplicationHaltsRule_HALTS_INFO_LIMIT=Application halts info limit
 45 ApplicationHaltsRule_HALTS_INFO_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger an info notice
 46 ApplicationHaltsRule_HALTS_WARNING_LIMIT=Application halts warning limit
 47 ApplicationHaltsRule_HALTS_WARNING_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger a warning
 48 ApplicationHaltsRule_HALTS_WINDOW_SIZE=Application halts time window size
 49 ApplicationHaltsRule_HALTS_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
 50 # {0} is a concatenated string of event type ids
 51 ApplicationHaltsRule_EXTRA_EVENT_TYPES=Enabling the following event types would improve the accuracy of this rule: {0}
 52 ApplicationHaltsRule_RULE_NAME=Application Halts
 53 ApplicationHaltsRule_RULE_TEXT=Application efficiency was affected by halts
 54 # {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
 55 ApplicationHaltsRule_RULE_TEXT_LONG=The highest ratio of application halts to execution time was {0} % for {1} at {2}. {3} % of the halts were for reasons other than GC.&lt;p&gt;The halts ratio for the entire recording was {4} %. {5} % of the total halts were for reasons other than GC.&lt;/p&gt;
 56 ApplicationHaltsRule_RULE_TEXT_RECOMMENDATION=Application halts are often caused by garbage collections, but can also be caused by excessive thread dumps or heap dumps. Investigate the VM Operation information and possibly the safepoint specific information.
 57 ApplicationHaltsRule_RULE_TEXT_OK=Application efficiency was not highly affected by halts.
 58 
</pre>
<hr />
<pre>
107 ClassLoadingRule_CONFIG_DURATION_LIMIT=Classloading duration limit
108 ClassLoadingRule_CONFIG_DURATION_LIMIT_LONG=The shortest classloading duration that should trigger a warning
109 ClassLoadingRule_CONFIG_RATIO_LIMIT=Classloading ratio limit
110 ClassLoadingRule_CONFIG_RATIO_LIMIT_LONG=The minimum ratio between time spent in classloading and the total duration of the recording
111 ClassLoadingRuleFactory_RULE_NAME=Class Loading Pressure
112 ClassLoadingRuleFactory_RULE_TEXT_OK=No significant time was spent loading new classes during this recording.
113 ClassLoadingRuleFactory_TEXT_INFO={0} was spent loading {1} new classes during this recording.
114 ClassLoadingRuleFactory_TEXT_INFO_LONG={0} was spent loading {1} new classes during this recording. The longest class loading event took {2}.&lt;p&gt;If the recording occurred during the warm-up phase of the application, this is to be expected. If not, it might be good to check why these classes were being loaded.
115 CodeCacheRuleFactory_DEFAULT_LONG_DESCRIPTION=If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. To avoid this, either increase the size of the code cache (&#39;-XX:ReservedCodeCacheSize&#39;) or increase the compilation threshold (&#39;-XX:CompileThreshold&#39;).
116 CodeCacheRuleFactory_JDK8_TEXT_WARN=The code cache was around {0} free during the recording. This could potentially become an issue.
117 CodeCacheRuleFactory_RULE_NAME=Code Cache
118 CodeCacheRuleFactory_BLOG_REFERENCE=See &lt;a href=&quot;https://blogs.oracle.com/poonam/why-do-i-get-message-codecache-is-full-compiler-has-been-disabled&quot;&gt;this blog post&lt;/a&gt; for a longer discussion on the code cache.
119 CodeCacheRuleFactory_SIZE_INFO_LIMIT=Code cache occupancy info limit
120 CodeCacheRuleFactory_SIZE_INFO_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return an Info result
121 CodeCacheRuleFactory_SIZE_WARN_LIMIT=Code cache occupancy warning limit
122 CodeCacheRuleFactory_SIZE_WARN_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return a Warning result
123 CodeCacheRuleFactory_TEXT_OK=No problems with the code cache were detected in the recording.
124 CodeCacheRuleFactory_TEXT_WARN=The code cache was filled during this recording.
125 CodeCacheRuleFactory_TEXT_WARN_LONG=This can happen if you have a lot of code in your application or if the code cache is too small. If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. Increase the size of the code cache with &#39;-XX:ReservedCodeCacheSize&#39;, for example &#39;-XX:ReservedCodeCacheSize=128M&#39;.
126 CodeCacheRuleFactory_WARN_LONG_DESCRIPTION=This causes the code cache to be swept more frequently, with even higher occupancy causing more frequent sweeps.
<span class="line-modified">127 CodeCacheRuleFactory_WARN_SEGMENTED_HEAP_SHORT_DESCRIPTION=The {0} code heap reached more than 50% occupancy during the recording.</span>
<span class="line-modified">128 CodeCacheRuleFactory_WARN_SEGMENTED_HEAPS_SHORT_DESCRIPTION=The {0} code heaps reached more than 50% occupancy during the recording.</span>
129 CompareCpuRule_RULE_NAME=Competing CPU Ratio Usage
130 CompareCpuRule_TEXT_INFO_LONG=The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.
131 CompareCpuRule_TEXT_TOO_FEW_SAMPLES=Not enough samples available to calculate result.
132 # {0} is a time period, {1} is a time stamp, {2} is a percentage
133 CompareCpuRule_TEXT_MESSAGE=An average CPU load of {2} was caused by other processes for {0} at {1}.
134 CompareCpuRule_INFO_LIMIT=Competing CPU Ratio usage info limit
135 CompareCpuRule_INFO_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger an info notice
136 CompareCpuRule_WARNING_LIMIT=Competing CPU Ratio usage warning limit
137 CompareCpuRule_WARNING_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger a warning
138 CompressedOopsRuleFactory_RULE_NAME=Compressed Oops
139 CompressedOopsRuleFactory_TEXT_INFO=The Java Heap Size is below 32 GB and Compressed Oops is turned off.
140 CompressedOopsRuleFactory_TEXT_INFO_LONG=Not using Compressed Ordinary Object Pointers when the heap size is below 32 GB wastes memory and will lead to unnecessary cache pressure. Use the JVM argument &#39;-XX:+UseCompressedOops&#39; to enable this feature.
141 CompressedOopsRuleFactory_TEXT_OK=The settings for Compressed Oops were OK.
142 ConcurrentFailedRuleFactory_TEXT_WARN=There occurred Concurrent Mode failures during certain garbage collections.
143 ConcurrentFailedRuleFactory_TEXT_WARN_LONG=Concurrent Mode failures means that the Garbage Collector hasn&#39;t been able to keep up with the Java Program. Try lowering the value of &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html&quot;&gt;-XX:InitiatingHeapOccupancyPercent&lt;/a&gt;.
144 ContextSwitchRule_AGGR_MAX_BLOCKS=Max Blocks
145 ContextSwitchRule_CONFIG_WARNING_LIMIT=Context switch rate warning limit
146 ContextSwitchRule_CONFIG_WARNING_LIMIT_LONG=The context switch rate (switches/second) needed to trigger a warning
147 ContextSwitchRuleFactory_RULE_NAME=Context Switches
148 ContextSwitchRuleFactory_TEXT_INFO=The program causes many context switches during the recording.
</pre>
<hr />
<pre>
375 IncreasingLiveSetRule_LEAK_CANDIDATES=An analysis of the reference tree found {0} leak candidates.
376 IncreasingLiveSetRuleFactory_RULE_NAME=Heap Live Set Trend
377 # {0} is a number denoted in Mebibytes per second
378 IncreasingLiveSetRuleFactory_TEXT_INFO=The live set on the heap seems to increase with a speed of about {0} per second during the recording.
379 IncreasingLiveSetRuleFactory_TEXT_INFO_LONG=This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began {0} after the JVM was started. More information can be gathered by using the &#39;Old Object Sample&#39; event, if available.
380 IncreasingMetaspaceLiveSetRuleFactory_RULE_NAME=Metaspace Live Set Trend
381 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO=The class data seems to increase constantly in the metaspace during the recording.
382 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO_LONG=This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.
383 IncreasingMetaspaceLiveSetRuleFactory_TEXT_OK=The class data does not seem to increase during the recording.
384 JavaBlocking_RULE_NAME=Java Blocking
385 JavaBlockingRule_AGGR_BALANCE_BY_INSTANCE=By Instance
386 JavaBlockingRule_AGGR_BALANCE_BY_THREAD=By Thread
387 JavaBlockingRule_CONFIG_EXCLUDED_THREADS=Java blocked excluded thread names
388 JavaBlockingRule_CONFIG_EXCLUDED_THREADS_LONG=Regular expression describing which thread names to exclude, for example &#39;(.*weblogic\\.socket\\.Muxer.*|MyExcludedThreadName)&#39;
389 # {0} is a regexp exclude string
390 JavaBlockingRule_TEXT_EXCLUDED_THREADS=The following regular expression was used to exclude threads from this rule: &#39;&#39;{0}&#39;&#39;
391 # {0} is a time period
392 JavaBlockingRule_TEXT_INFO=Threads in the application were blocked on locks for a total of {0}.
393 JavaBlockingRule_TEXT_MESSAGE=No excessive problems with lock contention found.
394 # {0} is a class name, {1} is a number, {2} is a time period
<span class="line-modified">395 JavaBlockingRule_TEXT_MOST_BLOCKED_CLASS=The most blacking monitor class was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.</span>
396 # {0} is a thread name, {1} is a number, {2} is a time period
397 JavaBlockingRule_TEXT_MOST_BLOCKED_THREAD=The most blocking thread was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.
398 JavaBlockingRule_TEXT_OK=No problems with lock contention were found.
399 LongGcPauseRuleFactory_RULE_NAME=GC Pause Peak Duration
400 # {0} is a time period
401 LongGcPauseRuleFactory_TEXT_INFO=The longest GC pause was {0}.
402 LongGcPauseRuleFactory_TEXT_INFO_G1=You may want to use the G1 garbage collector which is built to reduce garbage collector pauses. To enable G1, add &#39;-XX:+UseG1GC&#39; to the command line.
403 # {0} is a size in bytes, {1} is a size in bytes
404 LongGcPauseRuleFactory_TEXT_INFO_MX=The application ran with a live set of {0} and a heap size of {1}. Decreasing the heap size may decrease the garbage collection pause times.
405 LongGcPauseRuleFactory_TEXT_INFO_REFERENCES=Processing reference objects was a considerable part of the garbage collector pauses. You may be able to decrease this by reducing the amount of references or by enabling parallel reference processing with &#39;-XX:+ParallelRefProcEnabled&#39;.
406 LongGcPauseRuleFactory_TEXT_OK=The application did not cause any long GC pause times.
407 LongGcPauseRule_CONFIG_INFO_LIMIT=GC pause warning limit
408 LongGcPauseRule_CONFIG_INFO_LIMIT_LONG=The GC pause time needed to trigger a warning
409 LowOnPhysicalMemoryFactory_RULE_NAME=Free Physical Memory
410 # {0} is a percentage
411 LowOnPhysicalMemoryFactory_TEXT_INFO=The maximum amount of used memory was {0} of the physical memory available.
412 # {0} is a size in bytes, {1} is a percentage, {2} is a size in bytes
413 LowOnPhysicalMemoryFactory_TEXT_INFO_LONG=The maximum amount of memory used was {0}. This is {1} of the {2} of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.
414 LowOnPhysicalMemoryFactory_TEXT_OK=The system did not run low on physical memory during this recording.
415 ManagementAgentRule_TEXT_INFO=Management agent settings (port, authentication and/or SSL) were changed during runtime.
</pre>
</td>
<td>
<hr />
<pre>
 18 #  conditions and the following disclaimer in the documentation and/or other materials provided with
 19 #  the distribution.
 20 #
 21 #  3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22 #  endorse or promote products derived from this software without specific prior written permission.
 23 #
 24 #  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25 #  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26 #  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27 #  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28 #  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29 #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31 #  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32 #
 33 Preference_SHORT_RECORDING=Short recording limit
 34 Preference_SHORT_RECORDING_LONG=Minimum length of a recording to be considered useful for rules to work on.
 35 
 36 AllocationByClassRule_RULE_NAME=Allocated Classes
 37 # {0} is a class name
<span class="line-modified"> 38 AllocationByClassRule_TEXT_MESSAGE=The most allocated type is likely &#39;&#39;{0}&#39;&#39;, most commonly allocated by: {1}</span>
 39 AllocationByThreadRule_RULE_NAME=Threads Allocating
 40 # {0} is a thread name
 41 AllocationByThreadRule_TEXT_MESSAGE=The most allocations were likely done by thread &#39;&#39;{0}&#39;&#39; at: {1}
 42 AllocationRuleFactory_TEXT_CLASS_INFO_LONG=Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.
 43 AllocationRuleFactory_TEXT_THREAD_INFO_LONG=Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.
 44 ApplicationHaltsRule_HALTS_INFO_LIMIT=Application halts info limit
 45 ApplicationHaltsRule_HALTS_INFO_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger an info notice
 46 ApplicationHaltsRule_HALTS_WARNING_LIMIT=Application halts warning limit
 47 ApplicationHaltsRule_HALTS_WARNING_LIMIT_DESC=Ratio between application halts and execution time within a time window needed to trigger a warning
 48 ApplicationHaltsRule_HALTS_WINDOW_SIZE=Application halts time window size
 49 ApplicationHaltsRule_HALTS_WINDOW_SIZE_DESC=The time window size used when evaluating the rule
 50 # {0} is a concatenated string of event type ids
 51 ApplicationHaltsRule_EXTRA_EVENT_TYPES=Enabling the following event types would improve the accuracy of this rule: {0}
 52 ApplicationHaltsRule_RULE_NAME=Application Halts
 53 ApplicationHaltsRule_RULE_TEXT=Application efficiency was affected by halts
 54 # {0} is a percentage, {1} is a timespan, {2} is a timestamp, {3} is a percentage
 55 ApplicationHaltsRule_RULE_TEXT_LONG=The highest ratio of application halts to execution time was {0} % for {1} at {2}. {3} % of the halts were for reasons other than GC.&lt;p&gt;The halts ratio for the entire recording was {4} %. {5} % of the total halts were for reasons other than GC.&lt;/p&gt;
 56 ApplicationHaltsRule_RULE_TEXT_RECOMMENDATION=Application halts are often caused by garbage collections, but can also be caused by excessive thread dumps or heap dumps. Investigate the VM Operation information and possibly the safepoint specific information.
 57 ApplicationHaltsRule_RULE_TEXT_OK=Application efficiency was not highly affected by halts.
 58 
</pre>
<hr />
<pre>
107 ClassLoadingRule_CONFIG_DURATION_LIMIT=Classloading duration limit
108 ClassLoadingRule_CONFIG_DURATION_LIMIT_LONG=The shortest classloading duration that should trigger a warning
109 ClassLoadingRule_CONFIG_RATIO_LIMIT=Classloading ratio limit
110 ClassLoadingRule_CONFIG_RATIO_LIMIT_LONG=The minimum ratio between time spent in classloading and the total duration of the recording
111 ClassLoadingRuleFactory_RULE_NAME=Class Loading Pressure
112 ClassLoadingRuleFactory_RULE_TEXT_OK=No significant time was spent loading new classes during this recording.
113 ClassLoadingRuleFactory_TEXT_INFO={0} was spent loading {1} new classes during this recording.
114 ClassLoadingRuleFactory_TEXT_INFO_LONG={0} was spent loading {1} new classes during this recording. The longest class loading event took {2}.&lt;p&gt;If the recording occurred during the warm-up phase of the application, this is to be expected. If not, it might be good to check why these classes were being loaded.
115 CodeCacheRuleFactory_DEFAULT_LONG_DESCRIPTION=If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. To avoid this, either increase the size of the code cache (&#39;-XX:ReservedCodeCacheSize&#39;) or increase the compilation threshold (&#39;-XX:CompileThreshold&#39;).
116 CodeCacheRuleFactory_JDK8_TEXT_WARN=The code cache was around {0} free during the recording. This could potentially become an issue.
117 CodeCacheRuleFactory_RULE_NAME=Code Cache
118 CodeCacheRuleFactory_BLOG_REFERENCE=See &lt;a href=&quot;https://blogs.oracle.com/poonam/why-do-i-get-message-codecache-is-full-compiler-has-been-disabled&quot;&gt;this blog post&lt;/a&gt; for a longer discussion on the code cache.
119 CodeCacheRuleFactory_SIZE_INFO_LIMIT=Code cache occupancy info limit
120 CodeCacheRuleFactory_SIZE_INFO_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return an Info result
121 CodeCacheRuleFactory_SIZE_WARN_LIMIT=Code cache occupancy warning limit
122 CodeCacheRuleFactory_SIZE_WARN_LIMIT_DESC=If the occupancy exceeds this limit then the rule will return a Warning result
123 CodeCacheRuleFactory_TEXT_OK=No problems with the code cache were detected in the recording.
124 CodeCacheRuleFactory_TEXT_WARN=The code cache was filled during this recording.
125 CodeCacheRuleFactory_TEXT_WARN_LONG=This can happen if you have a lot of code in your application or if the code cache is too small. If the code cache is filled, the JVM will stop compiling new methods which means that your code will run slower than necessary. Increase the size of the code cache with &#39;-XX:ReservedCodeCacheSize&#39;, for example &#39;-XX:ReservedCodeCacheSize=128M&#39;.
126 CodeCacheRuleFactory_WARN_LONG_DESCRIPTION=This causes the code cache to be swept more frequently, with even higher occupancy causing more frequent sweeps.
<span class="line-modified">127 CodeCacheRuleFactory_WARN_SEGMENTED_HEAP_SHORT_DESCRIPTION=The {0} code heap reached more than 50 % occupancy during the recording.</span>
<span class="line-modified">128 CodeCacheRuleFactory_WARN_SEGMENTED_HEAPS_SHORT_DESCRIPTION=The {0} code heaps reached more than 50 % occupancy during the recording.</span>
129 CompareCpuRule_RULE_NAME=Competing CPU Ratio Usage
130 CompareCpuRule_TEXT_INFO_LONG=The application performance can be affected when the machine is under heavy load and there are other processes that use CPU or other resources on the same computer. To profile representatively or get higher throughput, shut down other resource intensive processes running on the machine.
131 CompareCpuRule_TEXT_TOO_FEW_SAMPLES=Not enough samples available to calculate result.
132 # {0} is a time period, {1} is a time stamp, {2} is a percentage
133 CompareCpuRule_TEXT_MESSAGE=An average CPU load of {2} was caused by other processes for {0} at {1}.
134 CompareCpuRule_INFO_LIMIT=Competing CPU Ratio usage info limit
135 CompareCpuRule_INFO_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger an info notice
136 CompareCpuRule_WARNING_LIMIT=Competing CPU Ratio usage warning limit
137 CompareCpuRule_WARNING_LIMIT_LONG=The amount of CPU used by other processes times the overall CPU usage needed to trigger a warning
138 CompressedOopsRuleFactory_RULE_NAME=Compressed Oops
139 CompressedOopsRuleFactory_TEXT_INFO=The Java Heap Size is below 32 GB and Compressed Oops is turned off.
140 CompressedOopsRuleFactory_TEXT_INFO_LONG=Not using Compressed Ordinary Object Pointers when the heap size is below 32 GB wastes memory and will lead to unnecessary cache pressure. Use the JVM argument &#39;-XX:+UseCompressedOops&#39; to enable this feature.
141 CompressedOopsRuleFactory_TEXT_OK=The settings for Compressed Oops were OK.
142 ConcurrentFailedRuleFactory_TEXT_WARN=There occurred Concurrent Mode failures during certain garbage collections.
143 ConcurrentFailedRuleFactory_TEXT_WARN_LONG=Concurrent Mode failures means that the Garbage Collector hasn&#39;t been able to keep up with the Java Program. Try lowering the value of &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html&quot;&gt;-XX:InitiatingHeapOccupancyPercent&lt;/a&gt;.
144 ContextSwitchRule_AGGR_MAX_BLOCKS=Max Blocks
145 ContextSwitchRule_CONFIG_WARNING_LIMIT=Context switch rate warning limit
146 ContextSwitchRule_CONFIG_WARNING_LIMIT_LONG=The context switch rate (switches/second) needed to trigger a warning
147 ContextSwitchRuleFactory_RULE_NAME=Context Switches
148 ContextSwitchRuleFactory_TEXT_INFO=The program causes many context switches during the recording.
</pre>
<hr />
<pre>
375 IncreasingLiveSetRule_LEAK_CANDIDATES=An analysis of the reference tree found {0} leak candidates.
376 IncreasingLiveSetRuleFactory_RULE_NAME=Heap Live Set Trend
377 # {0} is a number denoted in Mebibytes per second
378 IncreasingLiveSetRuleFactory_TEXT_INFO=The live set on the heap seems to increase with a speed of about {0} per second during the recording.
379 IncreasingLiveSetRuleFactory_TEXT_INFO_LONG=This may be due to a memory leak in the application or it may be an artifact of a short recording if the JVM has recently been started. The recording began {0} after the JVM was started. More information can be gathered by using the &#39;Old Object Sample&#39; event, if available.
380 IncreasingMetaspaceLiveSetRuleFactory_RULE_NAME=Metaspace Live Set Trend
381 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO=The class data seems to increase constantly in the metaspace during the recording.
382 IncreasingMetaspaceLiveSetRuleFactory_TEXT_INFO_LONG=This behavior may indicate a memory leak in the metaspace, this could be due to the application not unloading classes as needed.
383 IncreasingMetaspaceLiveSetRuleFactory_TEXT_OK=The class data does not seem to increase during the recording.
384 JavaBlocking_RULE_NAME=Java Blocking
385 JavaBlockingRule_AGGR_BALANCE_BY_INSTANCE=By Instance
386 JavaBlockingRule_AGGR_BALANCE_BY_THREAD=By Thread
387 JavaBlockingRule_CONFIG_EXCLUDED_THREADS=Java blocked excluded thread names
388 JavaBlockingRule_CONFIG_EXCLUDED_THREADS_LONG=Regular expression describing which thread names to exclude, for example &#39;(.*weblogic\\.socket\\.Muxer.*|MyExcludedThreadName)&#39;
389 # {0} is a regexp exclude string
390 JavaBlockingRule_TEXT_EXCLUDED_THREADS=The following regular expression was used to exclude threads from this rule: &#39;&#39;{0}&#39;&#39;
391 # {0} is a time period
392 JavaBlockingRule_TEXT_INFO=Threads in the application were blocked on locks for a total of {0}.
393 JavaBlockingRule_TEXT_MESSAGE=No excessive problems with lock contention found.
394 # {0} is a class name, {1} is a number, {2} is a time period
<span class="line-modified">395 JavaBlockingRule_TEXT_MOST_BLOCKED_CLASS=The most blocking monitor class was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.</span>
396 # {0} is a thread name, {1} is a number, {2} is a time period
397 JavaBlockingRule_TEXT_MOST_BLOCKED_THREAD=The most blocking thread was &#39;&#39;{0}&#39;&#39;, which was blocked {1} times for a total of {2}.
398 JavaBlockingRule_TEXT_OK=No problems with lock contention were found.
399 LongGcPauseRuleFactory_RULE_NAME=GC Pause Peak Duration
400 # {0} is a time period
401 LongGcPauseRuleFactory_TEXT_INFO=The longest GC pause was {0}.
402 LongGcPauseRuleFactory_TEXT_INFO_G1=You may want to use the G1 garbage collector which is built to reduce garbage collector pauses. To enable G1, add &#39;-XX:+UseG1GC&#39; to the command line.
403 # {0} is a size in bytes, {1} is a size in bytes
404 LongGcPauseRuleFactory_TEXT_INFO_MX=The application ran with a live set of {0} and a heap size of {1}. Decreasing the heap size may decrease the garbage collection pause times.
405 LongGcPauseRuleFactory_TEXT_INFO_REFERENCES=Processing reference objects was a considerable part of the garbage collector pauses. You may be able to decrease this by reducing the amount of references or by enabling parallel reference processing with &#39;-XX:+ParallelRefProcEnabled&#39;.
406 LongGcPauseRuleFactory_TEXT_OK=The application did not cause any long GC pause times.
407 LongGcPauseRule_CONFIG_INFO_LIMIT=GC pause warning limit
408 LongGcPauseRule_CONFIG_INFO_LIMIT_LONG=The GC pause time needed to trigger a warning
409 LowOnPhysicalMemoryFactory_RULE_NAME=Free Physical Memory
410 # {0} is a percentage
411 LowOnPhysicalMemoryFactory_TEXT_INFO=The maximum amount of used memory was {0} of the physical memory available.
412 # {0} is a size in bytes, {1} is a percentage, {2} is a size in bytes
413 LowOnPhysicalMemoryFactory_TEXT_INFO_LONG=The maximum amount of memory used was {0}. This is {1} of the {2} of physical memory available. Having little free memory may lead to swapping, which is very expensive. To avoid this, either decrease the memory usage or increase the amount of available memory.
414 LowOnPhysicalMemoryFactory_TEXT_OK=The system did not run low on physical memory during this recording.
415 ManagementAgentRule_TEXT_INFO=Management agent settings (port, authentication and/or SSL) were changed during runtime.
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>