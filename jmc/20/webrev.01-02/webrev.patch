diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/AccessUtils.java
@@ -40,11 +40,26 @@
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
-public class AccessUtils {
+/**
+ * Helper methods for checking accessibility, implied as modifiers, from various contexts.
+ */
+public final class AccessUtils {
+	private AccessUtils() {
+		throw new UnsupportedOperationException("Toolkit!"); //$NON-NLS-1$
+	}
+
+	/**
+	 * Like Class.getDeclaredField, but also gets fields declared by ancestors and interfaces.
+	 * 
+	 * @param clazz the class to lookup from
+	 * @param name the name of the field
+	 * @return the {@code Field} object for the specified field in this class
+	 * @throws NoSuchFieldException if a field with the specified name is not found.
+	 */
 	public static Field getFieldOnHierarchy(Class<?> clazz, String name) throws NoSuchFieldException {
 		Queue<Class<?>> q = new LinkedList<>();
 		q.add(clazz);
 
 		while (!q.isEmpty()) {
@@ -63,10 +78,18 @@
 		}
 
 		throw new NoSuchFieldException(String.format("cannot find field %s in class %s", name, clazz.getName()));
 	}
 
+	/**
+	 * Checks whether a field can be accessed from a caller context.
+	 * 
+	 * @param targetClass the class being referenced
+	 * @param field the field being accessed
+	 * @param currentClass the caller class
+	 * @return whether the field is accessible from given context
+	 */
 	public static boolean isAccessible(Class<?> targetClass, Field field, Class<?> currentClass) {
 		int modifiers = field.getModifiers();
 
 		Class<?> memberClass = field.getDeclaringClass();
 		if (Modifier.isStatic(modifiers)) {
@@ -74,10 +97,19 @@
 		}
 
 		return verifyMemberAccess(targetClass, memberClass, currentClass, modifiers);
 	}
 
+	/**
+	 * Checks whether the field/method/inner class modifier allows access from a caller context
+	 * 
+	 * @param targetClass the class being referenced
+	 * @param memberClass the class declaring the field/method/inner class
+	 * @param currentClass the caller class
+	 * @param modifiers member access modifiers in bit flags as a integer
+	 * @return
+	 */
 	public static boolean verifyMemberAccess(Class<?> targetClass, Class<?> memberClass, Class<?> currentClass, 
 			int modifiers) {
 		if (currentClass == memberClass) {
 			return true;
 		}
@@ -148,10 +180,19 @@
 		}
 
 		return true;
 	}
 
+	/**
+	 * Check whether the module has the class exported for the caller to access.
+	 * 
+	 * For Pre-9 Java runtime, this function always returns <code>true</code>.
+	 * 
+	 * @param targetClass the class being accessed
+	 * @param callerClass the caller class
+	 * @return whether the class is accessible
+	 */
 	public static boolean verifyModuleAccess(Class<?> targetClass, Class<?> callerClass) {
 		String version = System.getProperty("java.version");
 		if (Integer.parseInt(version.substring(0, version.indexOf("."))) < 9) {
 			return true; // There is no module for pre-java 9
 		}
@@ -178,40 +219,71 @@
 		} catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
 			throw new RuntimeException(e); // this should not happen
 		}
 	}
 
-	// polyfill for Class.getPackageName(Class<?>)
+	/**
+	 * polyfill for <code>Class.getPackageName(Class<?>)</code> for pre-9 Java.
+	 * 
+	 * @param clazz the class to lookup the package name against
+	 * @return the name of the package containing the class
+	 */
 	public static String getPackageName(Class<?> clazz) {
 		return clazz.getPackage().getName();
 		
 	}
 
-	// polyfill for Reflection.getClassAccessFlags(Class<?>)
+	/**
+	 * Polyfill for <code>Reflection.getClassAccessFlags(Class<?>)</code> as 
+	 * <code>jdk.internal.reflect.Reflection</code> is not exported.
+	 * 
+	 * @param c the class being inspected
+	 * @return the access flags written to the class file
+	 */
 	public static int getClassAccessFlags(Class<?> c) {
 		return c.getModifiers();
 	}
 
+	/**
+	 * Check whether the two classes exist in the same package
+	 * 
+	 * @param lhs the first class
+	 * @param rhs the second class
+	 * @return whether the given classes exist in the same package
+	 */
 	public static boolean isSameClassPackage(Class<?> lhs, Class<?> rhs) {
 		if (lhs.getClassLoader() != rhs.getClassLoader())
 			return false;
 		return getPackageName(lhs).equals(getPackageName(rhs));
 	}
 
+	/**
+	 * Check whether a class is a subclass of the other
+	 * 
+	 * @param queryClass the subclass
+	 * @param ofClass the superclass
+	 * @return whether it's a subclass-superclass relationship
+	 */
 	public static boolean isSubclassOf(Class<?> queryClass, Class<?> ofClass) {
 		while (queryClass != null) {
 			if (queryClass == ofClass) {
 				return true;
 			}
 			queryClass = queryClass.getSuperclass();
 		}
 		return false;
 	}
 
-	// Polyfill Class.getNestMembers() for pre-11 runtime.
-	// This function does not fully respect the definition of nesting from JVM's perspective. It's only used for 
-	// validating access. 
+	/**
+	 * Polyfill Class.getNestMembers() for pre-11 runtime. 
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for 
+	 * validating access.
+	 * 
+	 * @param clazz the class to inspect against
+	 * @return an array of all nest members
+	 */
 	public static Class<?>[] getNestMembers(Class<?> clazz) {
 		List<Class<?>> classes = new ArrayList<>();
 		classes.add(getNestHost(clazz));
 		int i = 0;
 		while (i < classes.size()) {
@@ -220,20 +292,33 @@
 		}
 
 		return classes.toArray(new Class[0]);
 	}
 
-	// Polyfill Class.isNestMateOf() for pre-11 runtime
-	// This function does not fully respect the definition of nesting from JVM's perspective. It's only used for 
-	// validating access.
+	/**
+	 * Polyfill Class.isNestMateOf() for pre-11 runtime.
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for
+	 * validating access.
+	 * 
+	 * @param lhs the first class
+	 * @param rhs the second class
+	 * @return whether the given classes are nestmates
+	 */
 	public static boolean areNestMates(Class<?> lhs, Class<?> rhs) {
 		return getNestHost(lhs).equals(getNestHost(rhs));
 	}
 
-	// Polyfill Class.getNestHost() for pre-11 runtime
-	// This function does not fully respect the definition of nesting from JVM's perspective. It's only used for 
-	// validating access.
+	/**
+	 * Polyfill Class.getNestHost() for pre-11 runtime.
+	 * 
+	 * This function does not fully respect the definition of nesting from JVM's perspective. It's only used for
+	 * validating access.
+	 * 
+	 * @param clazz the class the inspect against
+	 * @return the nesthost of the class
+	 */
 	public static Class<?> getNestHost(Class<?> clazz) {
 		// array types, primitive types, and void belong to the nests consisting only of theme, and are the nest hosts.
 		if (clazz.isArray()) {
 			return clazz;
 		}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/InspectionClassLoader.java
@@ -34,11 +34,13 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
-// One-time use loader for reflective class inspection. Don't keep static reference to one of these.
+/**
+ * One-time use loader for reflective class inspection. Don't keep static reference to one of these.
+ */
 public class InspectionClassLoader extends ClassLoader {
 
 	public InspectionClassLoader(ClassLoader parent) {
 		super(parent);
 	}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
@@ -233,18 +233,41 @@
 	 */
 	public static String parameterize(String className) {
 		return "L" + className + ";"; //$NON-NLS-1$ //$NON-NLS-2$
 	}
 
+	/**
+	 * Converts a canonical class name into the internal form (binary name).
+	 * 
+	 * eg. <code>com.company.project</code> converts into <code>com/company/project</code>
+	 * 
+	 * @param className the canonical class name
+	 * @return the internal form
+	 */
 	public static String getInternalName(String className) {
 		return className.replace('.', '/');
 	}
 
+	/**
+	 * Converts a internal class name (binary name) into the canonical form.
+	 *
+	 * ie. <code>com/company/project</code> converts into <code>com.company.project</code> 
+	 * 
+	 * @param binaryName the internal class name
+	 * @return in canonical form
+	 */
 	public static String getCanonicalName(String binaryName) {
 		return binaryName.replace('/', '.');
 	}
 
+	/**
+	 * Returns the constant loading instruction that pushes a zero value of the given type onto the operand stack. A 
+	 * null reference is pushed if the given type is an object or an array.
+	 * 
+	 * @param type the type of the operand
+	 * @return the instruction
+	 */
 	public static int getConstZeroOpcode(Type type) {
 		switch (type.getSort()) {
 		case Type.BOOLEAN:
 		case Type.BYTE:
 		case Type.CHAR:
@@ -266,10 +289,17 @@
 		default:
 			throw new AssertionError();
 		}
 	}
 
+	/**
+	 * Returns a array element for ASM's <code>MethodVisitor.visitFrame()</code> method used for frame verification of 
+	 * a given type.
+	 * 
+	 * @param type the type of the element on the operand stack or in the local variable table
+	 * @return a array element for <code>MethodVisitor.visitFrame()</code>'s parameter
+	 */
 	public static Object getFrameVerificationType(Type type) {
 		switch (type.getSort()) {
 		case Type.BOOLEAN:
 		case Type.BYTE:
 		case Type.CHAR:
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java
@@ -35,27 +35,49 @@
 import org.objectweb.asm.Type;
 
 import java.util.LinkedList;
 import java.util.List;
 
-public class ReferenceChain {
+/**
+ * A ReferenceChain instance presents a field reference expression.
+ * 
+ * eg. <code>OuterClass.this.field.STATIC_FIELD</code> is a reference chain consisting elements: a qualified-this 
+ * reference and two field reference (<code>field</code> and <code>STATIC_FIELD</code>).
+ * 
+ */
+public final class ReferenceChain {
 	private final Class<?> callerClass;
 	private final List<ReferenceChainElement> references;
 
+	/**
+	 * @param callerClass the caller class making this reference
+	 */
 	public ReferenceChain(Class<?> callerClass) {
 		this.callerClass = callerClass;
 		this.references = new LinkedList<>();
 	}
 
+	/**
+	 * @return the caller class making this reference
+	 */
 	public Class<?> getCallerClass() {
 		return callerClass;
 	}
 
+	/**
+	 * @return all elements on the reference chain
+	 */
 	public List<ReferenceChainElement> getReferences() {
 		return references;
 	}
 
+	/**
+	 * Reduces the reference chain to prepend "this" or qualified-this references if necessary, and short-circuits on
+	 * static references
+	 * 
+	 * @return the normalized reference chain
+	 */
 	public ReferenceChain normalize() {
 		List<ReferenceChainElement> oldRefs = getReferences();
 		List<ReferenceChainElement> newRefs = new LinkedList<>();
 
 		// Take shortcuts on static references
@@ -80,21 +102,31 @@
 		ReferenceChain ret = new ReferenceChain(callerClass);
 		ret.references.addAll(newRefs);
 		return ret;
 	}
 
+	/**
+	 * @return the type of the last reference element
+	 */
 	public Type getType() {
 		if (references.isEmpty()) {
 			return Type.getType(callerClass);
 		}
 		return references.get(references.size() - 1).getReferencedType();
 	}
 
+	/**
+	 * Appends a ReferenceChainElement to the chain
+	 * @param ref ReferenceChainElement to be appended
+	 */
 	public void append(ReferenceChainElement ref) {
 		references.add(ref);
 	}
 
+	/**
+	 * @return whether the reference is valid from a static context
+	 */
 	public boolean isStatic() {
 		if (references.isEmpty()) {
 			return false;
 		}
 
