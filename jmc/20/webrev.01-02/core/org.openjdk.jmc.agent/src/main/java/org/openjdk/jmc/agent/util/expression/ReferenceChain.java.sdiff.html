<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TypeUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/expression/ReferenceChain.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  *
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  *
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.agent.util.expression;
 34 
 35 import org.objectweb.asm.Type;
 36 
 37 import java.util.LinkedList;
 38 import java.util.List;
 39 
<span class="line-modified"> 40 public class ReferenceChain {</span>







 41 	private final Class&lt;?&gt; callerClass;
 42 	private final List&lt;ReferenceChainElement&gt; references;
 43 



 44 	public ReferenceChain(Class&lt;?&gt; callerClass) {
 45 		this.callerClass = callerClass;
 46 		this.references = new LinkedList&lt;&gt;();
 47 	}
 48 



 49 	public Class&lt;?&gt; getCallerClass() {
 50 		return callerClass;
 51 	}
 52 



 53 	public List&lt;ReferenceChainElement&gt; getReferences() {
 54 		return references;
 55 	}
 56 






 57 	public ReferenceChain normalize() {
 58 		List&lt;ReferenceChainElement&gt; oldRefs = getReferences();
 59 		List&lt;ReferenceChainElement&gt; newRefs = new LinkedList&lt;&gt;();
 60 
 61 		// Take shortcuts on static references
 62 		for (ReferenceChainElement ref : oldRefs) {
 63 			if (ref.isStatic()) {
 64 				newRefs.clear();
 65 			}
 66 
 67 			newRefs.add(ref);
 68 		}
 69 
 70 		// Don&#39;t reduce static final references to constants. The value could be different, or even stochastic, if 
 71 		// loaded via different class loaders. (eg. logic in static initializers)
 72 
 73 		// prepend &quot;this&quot; if starts with non-static field reference
 74 		if (newRefs.isEmpty()) {
 75 			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // implicit &quot;this&quot;
 76 		} else if (newRefs.get(0) instanceof ReferenceChainElement.FieldReference &amp;&amp; !newRefs.get(0).isStatic()) {
 77 			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // prop =&gt; this.prop
 78 		}
 79 
 80 		ReferenceChain ret = new ReferenceChain(callerClass);
 81 		ret.references.addAll(newRefs);
 82 		return ret;
 83 	}
 84 



 85 	public Type getType() {
 86 		if (references.isEmpty()) {
 87 			return Type.getType(callerClass);
 88 		}
 89 		return references.get(references.size() - 1).getReferencedType();
 90 	}
 91 




 92 	public void append(ReferenceChainElement ref) {
 93 		references.add(ref);
 94 	}
 95 



 96 	public boolean isStatic() {
 97 		if (references.isEmpty()) {
 98 			return false;
 99 		}
100 
101 		return references.get(0).isStatic();
102 	}
103 }
</pre>
</td>
<td>
<hr />
<pre>
 20  *
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  *
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.agent.util.expression;
 34 
 35 import org.objectweb.asm.Type;
 36 
 37 import java.util.LinkedList;
 38 import java.util.List;
 39 
<span class="line-modified"> 40 /**</span>
<span class="line-added"> 41  * A ReferenceChain instance presents a field reference expression.</span>
<span class="line-added"> 42  * </span>
<span class="line-added"> 43  * eg. &lt;code&gt;OuterClass.this.field.STATIC_FIELD&lt;/code&gt; is a reference chain consisting elements: a qualified-this </span>
<span class="line-added"> 44  * reference and two field reference (&lt;code&gt;field&lt;/code&gt; and &lt;code&gt;STATIC_FIELD&lt;/code&gt;).</span>
<span class="line-added"> 45  * </span>
<span class="line-added"> 46  */</span>
<span class="line-added"> 47 public final class ReferenceChain {</span>
 48 	private final Class&lt;?&gt; callerClass;
 49 	private final List&lt;ReferenceChainElement&gt; references;
 50 
<span class="line-added"> 51 	/**</span>
<span class="line-added"> 52 	 * @param callerClass the caller class making this reference</span>
<span class="line-added"> 53 	 */</span>
 54 	public ReferenceChain(Class&lt;?&gt; callerClass) {
 55 		this.callerClass = callerClass;
 56 		this.references = new LinkedList&lt;&gt;();
 57 	}
 58 
<span class="line-added"> 59 	/**</span>
<span class="line-added"> 60 	 * @return the caller class making this reference</span>
<span class="line-added"> 61 	 */</span>
 62 	public Class&lt;?&gt; getCallerClass() {
 63 		return callerClass;
 64 	}
 65 
<span class="line-added"> 66 	/**</span>
<span class="line-added"> 67 	 * @return all elements on the reference chain</span>
<span class="line-added"> 68 	 */</span>
 69 	public List&lt;ReferenceChainElement&gt; getReferences() {
 70 		return references;
 71 	}
 72 
<span class="line-added"> 73 	/**</span>
<span class="line-added"> 74 	 * Reduces the reference chain to prepend &quot;this&quot; or qualified-this references if necessary, and short-circuits on</span>
<span class="line-added"> 75 	 * static references</span>
<span class="line-added"> 76 	 * </span>
<span class="line-added"> 77 	 * @return the normalized reference chain</span>
<span class="line-added"> 78 	 */</span>
 79 	public ReferenceChain normalize() {
 80 		List&lt;ReferenceChainElement&gt; oldRefs = getReferences();
 81 		List&lt;ReferenceChainElement&gt; newRefs = new LinkedList&lt;&gt;();
 82 
 83 		// Take shortcuts on static references
 84 		for (ReferenceChainElement ref : oldRefs) {
 85 			if (ref.isStatic()) {
 86 				newRefs.clear();
 87 			}
 88 
 89 			newRefs.add(ref);
 90 		}
 91 
 92 		// Don&#39;t reduce static final references to constants. The value could be different, or even stochastic, if 
 93 		// loaded via different class loaders. (eg. logic in static initializers)
 94 
 95 		// prepend &quot;this&quot; if starts with non-static field reference
 96 		if (newRefs.isEmpty()) {
 97 			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // implicit &quot;this&quot;
 98 		} else if (newRefs.get(0) instanceof ReferenceChainElement.FieldReference &amp;&amp; !newRefs.get(0).isStatic()) {
 99 			newRefs.add(0, new ReferenceChainElement.ThisReference(callerClass)); // prop =&gt; this.prop
100 		}
101 
102 		ReferenceChain ret = new ReferenceChain(callerClass);
103 		ret.references.addAll(newRefs);
104 		return ret;
105 	}
106 
<span class="line-added">107 	/**</span>
<span class="line-added">108 	 * @return the type of the last reference element</span>
<span class="line-added">109 	 */</span>
110 	public Type getType() {
111 		if (references.isEmpty()) {
112 			return Type.getType(callerClass);
113 		}
114 		return references.get(references.size() - 1).getReferencedType();
115 	}
116 
<span class="line-added">117 	/**</span>
<span class="line-added">118 	 * Appends a ReferenceChainElement to the chain</span>
<span class="line-added">119 	 * @param ref ReferenceChainElement to be appended</span>
<span class="line-added">120 	 */</span>
121 	public void append(ReferenceChainElement ref) {
122 		references.add(ref);
123 	}
124 
<span class="line-added">125 	/**</span>
<span class="line-added">126 	 * @return whether the reference is valid from a static context</span>
<span class="line-added">127 	 */</span>
128 	public boolean isStatic() {
129 		if (references.isEmpty()) {
130 			return false;
131 		}
132 
133 		return references.get(0).isStatic();
134 	}
135 }
</pre>
</td>
</tr>
</table>
<center><a href="../TypeUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>