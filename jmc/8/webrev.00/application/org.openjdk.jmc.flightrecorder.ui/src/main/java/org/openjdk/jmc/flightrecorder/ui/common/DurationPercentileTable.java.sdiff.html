<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DurationPercentileTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DurationHdrHistogram.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadGraphLanes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DurationPercentileTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57 import org.openjdk.jmc.common.item.IMemberAccessor;
 58 import org.openjdk.jmc.common.item.IType;
 59 import org.openjdk.jmc.common.item.ItemFilters;
 60 import org.openjdk.jmc.common.unit.IQuantity;
 61 import org.openjdk.jmc.common.unit.UnitLookup;
 62 import org.openjdk.jmc.common.util.Pair;
 63 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 64 import org.openjdk.jmc.flightrecorder.ui.common.DurationHdrHistogram.DurationItemConsumer;
 65 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
 66 import org.openjdk.jmc.ui.UIPlugin;
 67 import org.openjdk.jmc.ui.accessibility.FocusTracker;
 68 import org.openjdk.jmc.ui.column.ColumnBuilder;
 69 import org.openjdk.jmc.ui.column.ColumnManager;
 70 import org.openjdk.jmc.ui.column.IColumn;
 71 import org.openjdk.jmc.ui.column.TableSettings;
 72 import org.openjdk.jmc.ui.misc.BackgroundFractionDrawer;
 73 import org.openjdk.jmc.ui.misc.DelegatingLabelProvider;
 74 import org.openjdk.jmc.ui.misc.OptimisticComparator;
 75 
 76 /**
<span class="line-modified"> 77  * A table containing Flight Recorder event durations at various pre-defined percentiles.</span>
<span class="line-modified"> 78  * Each row in the table contains values for a different percentile, and the columns contain</span>
<span class="line-modified"> 79  * series of durations and event counts.</span>
 80  *
 81  * @see DurationPercentileTableBuilder
 82  */
 83 public class DurationPercentileTable {
 84 
 85 	public static final String TABLE_NAME = &quot;DurationPercentileTable&quot;; //$NON-NLS-1$
 86 	private static final String COL_ID_PERCENTILE = TABLE_NAME + &quot;.percentile&quot;; //$NON-NLS-1$
 87 
<span class="line-modified"> 88 	private static final IQuantity[] PERCENTILES = {</span>
<span class="line-modified"> 89 			UnitLookup.NUMBER_UNITY.quantity(0.0),</span>
<span class="line-modified"> 90 			UnitLookup.NUMBER_UNITY.quantity(90.0),</span>
<span class="line-modified"> 91 			UnitLookup.NUMBER_UNITY.quantity(99.0),</span>
<span class="line-removed"> 92 			UnitLookup.NUMBER_UNITY.quantity(99.9),</span>
<span class="line-removed"> 93 			UnitLookup.NUMBER_UNITY.quantity(99.99),</span>
<span class="line-removed"> 94 			UnitLookup.NUMBER_UNITY.quantity(99.999),</span>
<span class="line-removed"> 95 			UnitLookup.NUMBER_UNITY.quantity(100.0),</span>
<span class="line-removed"> 96 	};</span>
 97 
 98 	private final DurationPercentileAggregator[] aggregators; // Correspond to column order
 99 	private final ColumnManager manager;
100 
101 	private DurationPercentileTable(ColumnManager manager, DurationPercentileAggregator[] aggregators) {
102 		this.manager = manager;
103 		this.aggregators = aggregators;
104 	}
105 
106 	/**
107 	 * Builder class that is the sole means of creating {@link DurationPercentileTable} instances.
108 	 */
109 	public static class DurationPercentileTableBuilder {
110 
111 		private final List&lt;IColumn&gt; columns;
112 		private final List&lt;DurationPercentileAggregator&gt; aggregators;
113 
114 		public DurationPercentileTableBuilder() {
115 			this.columns = new ArrayList&lt;&gt;();
116 			this.aggregators = new ArrayList&lt;&gt;();
117 		}
118 
119 		/**
120 		 * Adds a data series to this table, corresponding to an event type with a duration
<span class="line-modified">121 		 * associated with it. Calling this method adds two columns to the resulting table.</span>
<span class="line-modified">122 		 * The first column contains duration values for the event at different percentiles,</span>
<span class="line-modified">123 		 * and the second column contains the number of events with duration &lt;= the duration</span>
<span class="line-modified">124 		 * at that percentile.</span>
125 		 *
<span class="line-modified">126 		 * @param durationColId - the ID to be used for the duration column of this series</span>
<span class="line-modified">127 		 * @param durationColName - the user-visible name to appear for the duration column header</span>
<span class="line-modified">128 		 * @param countColId - the ID to be used for the event count column of this series</span>
<span class="line-modified">129 		 * @param countColName - the user-visible name to appear for the event count column header</span>
<span class="line-modified">130 		 * @param typeId - the event type ID used to match events belonging to this series</span>





131 		 */
<span class="line-modified">132 		public void addSeries(String durationColId, String durationColName,</span>
<span class="line-modified">133 				String countColId, String countColName, String typeId) {</span>
<span class="line-modified">134 			IColumn column = new ColumnBuilder(durationColName, durationColId, new ValueAccessor(durationColId)).style(SWT.RIGHT).build();</span>

135 			columns.add(column);
136 
137 			Function&lt;DurationPercentileTableRow, IQuantity&gt; fractionFunc = row -&gt; row.getCountFraction(countColId);
138 			column = new ColumnBuilder(countColName, countColId, new ValueAccessor(countColId)).style(SWT.RIGHT)
139 					.columnDrawer(BackgroundFractionDrawer.unchecked(fractionFunc)).build();
140 			columns.add(column);
141 
<span class="line-modified">142 			DurationPercentileAggregator aggregator = new DurationPercentileAggregator(typeId, durationColId, countColId);</span>

143 			aggregators.add(aggregator);
144 		}
145 
146 		/**
<span class="line-modified">147 		 * Builds the {@link DurationPercentileTable} after all series have been added.</span>
<span class="line-modified">148 		 * Calling this method results in the creation of the underlying {@link TableViewer}.</span>
<span class="line-modified">149 		 * Further changes to this builder will not affect the returned table.</span>
<span class="line-modified">150 		 * @param parent - the parent SWT composite that will contain this table</span>
<span class="line-modified">151 		 * @param ts - settings to adjust various attributes of the created table</span>



152 		 * @return a fully constructed {@link DurationPercentileTable} with no data
153 		 */
154 		public DurationPercentileTable build(Composite parent, TableSettings ts) {
155 			TableViewer tableViewer = new TableViewer(parent,
156 					SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION);
157 			tableViewer.getControl().setData(&quot;name&quot;, TABLE_NAME); //$NON-NLS-1$
158 			tableViewer.setContentProvider(ArrayContentProvider.getInstance());
159 			ColumnViewerToolTipSupport.enableFor(tableViewer);
160 			if (UIPlugin.getDefault().getAccessibilityMode()) {
161 				FocusTracker.enableFocusTracking(tableViewer.getTable());
162 			}
163 
164 			List&lt;IColumn&gt; columns = new ArrayList&lt;&gt;();
165 			ItemHistogram.KeyLabelProvider keyLP = new ItemHistogram.KeyLabelProvider(UnitLookup.NUMBER);
166 			PercentileAccessor cellAccessor = new PercentileAccessor();
167 			OptimisticComparator comp = new OptimisticComparator(cellAccessor, keyLP);
168 			columns.add(new ColumnBuilder(Messages.DurationPercentileTable_PERCENTILE_COL_NAME, COL_ID_PERCENTILE,
169 					new DelegatingLabelProvider(keyLP, cellAccessor)).comparator(comp).build());
170 			columns.addAll(this.columns);
171 
172 			ColumnManager manager = ColumnManager.build(tableViewer, columns, ts);
<span class="line-modified">173 			DurationPercentileAggregator[] aggregatorsCopy = aggregators.toArray(new DurationPercentileAggregator[aggregators.size()]);</span>

174 			return new DurationPercentileTable(manager, aggregatorsCopy);
175 		}
176 	}
177 
178 	/**
<span class="line-modified">179 	 * Updates the data in this table with events from the item collection.</span>
<span class="line-modified">180 	 * Calling this method stores the input data into a histogram, which is then</span>
<span class="line-modified">181 	 * used to generate duration values at various percentiles.</span>
182 	 *
<span class="line-modified">183 	 * @param itemCol - a collection of events to use as input for this table</span>

184 	 */
185 	public void update(IItemCollection itemCol) {
186 		// Add the value of each aggregate to our data model
187 		DurationPercentileTableModel model = new DurationPercentileTableModel(itemCol);
188 		Arrays.stream(aggregators).parallel().forEach(model::addAggregate);
189 
190 		// Build rows for each percentile and set in the table
191 		List&lt;DurationPercentileTableRow&gt; rows = model.buildRows();
192 		updateColumnVisibilty(rows.get(0));
193 		manager.getViewer().setInput(rows);
194 	}
195 
196 	private void updateColumnVisibilty(DurationPercentileTableRow row) {
197 		manager.getColumnStates().forEach(c -&gt; {
198 			String id = c.getColumn().getId();
199 			if (!COL_ID_PERCENTILE.equals(id)) { // Percentile column always shown
200 				boolean shouldShow = row.hasValue(id);
201 				// Don&#39;t show if already shown, will duplicate column
202 				if (shouldShow != c.isVisible()) {
203 					manager.setColumnHidden(id, !shouldShow);
204 				}
205 			}
206 		});
207 	}
208 
209 	/**
210 	 * Get the {@link ColumnManager} responsible for the underlying {@link TableViewer}.

211 	 * @return the manager
212 	 */
213 	public ColumnManager getManager() {
214 		return manager;
215 	}
216 
217 	/**
<span class="line-modified">218 	 * Gets a collection of items whose duration is at least as long as the percentile value</span>
<span class="line-modified">219 	 * in the currently selected row.</span>

220 	 * @return the collection of matching items
221 	 */
222 	public IItemCollection getSelectedItems() {
223 		IStructuredSelection selection = manager.getViewer().getStructuredSelection();
224 		Object firstSelection = selection.getFirstElement();
225 		if (firstSelection instanceof DurationPercentileTableRow) {
226 			DurationPercentileTableRow row = (DurationPercentileTableRow) firstSelection;
227 			return row.getItemsForRow(aggregators);
228 		}
229 		return null;
230 	}
231 
232 	private static class PercentileAccessor implements IMemberAccessor&lt;IQuantity, Object&gt; {
233 
234 		@Override
235 		public IQuantity getMember(Object inObject) {
236 			if (inObject instanceof DurationPercentileTableRow) {
237 				return ((DurationPercentileTableRow) inObject).getPercentile();
238 			}
239 			return null;
</pre>
<hr />
<pre>
242 	}
243 
244 	private static class ValueAccessor implements IMemberAccessor&lt;IQuantity, DurationPercentileTableRow&gt; {
245 
246 		private final String columnId;
247 
248 		public ValueAccessor(String columnId) {
249 			this.columnId = columnId;
250 		}
251 
252 		@Override
253 		public IQuantity getMember(DurationPercentileTableRow inObject) {
254 			return inObject.getValue(columnId);
255 		}
256 
257 	}
258 
259 	/**
260 	 * Aggregator that inserts event durations into a histogram.
261 	 */
<span class="line-modified">262 	private static class DurationPercentileAggregator extends AggregatorBase&lt;Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt;, DurationItemConsumer&gt; {</span>

263 
264 		private final DurationHdrHistogram histogram;
265 		private final String typeId;
266 		private final String durationColId;
267 		private final String countColId;
268 
269 		/**
270 		 * Creates a new aggregator.
<span class="line-modified">271 		 * @param typeId - type ID used to match events</span>
<span class="line-modified">272 		 * @param durationColId - the column ID for the duration column of this series</span>
<span class="line-modified">273 		 * @param countColId - the column ID for the item count column of this series</span>




274 		 */
275 		public DurationPercentileAggregator(String typeId, String durationColId, String countColId) {
276 			super(null, null, UnitLookup.UNKNOWN);
277 			this.histogram = new DurationHdrHistogram();
278 			this.typeId = typeId;
279 			this.durationColId = durationColId;
280 			this.countColId = countColId;
281 		}
282 
283 		@Override
284 		public boolean acceptType(IType&lt;IItem&gt; type) {
285 			return typeId.equals(type.getIdentifier());
286 		}
287 
288 		@Override
289 		public DurationItemConsumer newItemConsumer(IType&lt;IItem&gt; itemType) {
290 			return new DurationItemConsumer(histogram, JfrAttributes.DURATION.getAccessor(itemType));
291 		}
292 
293 		@Override
</pre>
<hr />
<pre>
324 		 */
325 		public String getDurationColId() {
326 			return durationColId;
327 		}
328 
329 		/**
330 		 * @return the ID for the item count column using this aggregator
331 		 */
332 		public String getCountColId() {
333 			return countColId;
334 		}
335 
336 		/**
337 		 * @return the type ID used to match items accepted by this aggregator
338 		 */
339 		public String getTypeId() {
340 			return typeId;
341 		}
342 
343 		/**
<span class="line-modified">344 		 * @param duration - a {@link UnitLookup#TIMESPAN} quantity</span>
<span class="line-modified">345 		 * @return a lower bound on values considered equivalent by this</span>
<span class="line-modified">346 		 * aggregator&#39;s underlying histogram</span>

347 		 */
348 		public IQuantity getLowestEquivalentDuration(IQuantity duration) {
349 			return histogram.getLowestEquivalentDuration(duration);
350 		}
351 
352 		/**
353 		 * Resets this aggregator&#39;s histogram to its initial state
354 		 */
355 		public void resetHistogram() {
356 			histogram.reset();
357 		}
358 
359 	}
360 
361 	/**
362 	 * A data model representing the content to be displayed in the {@link DurationPercentileTable}.
363 	 */
364 	private static class DurationPercentileTableModel {
365 
366 		private final IItemCollection items;
367 		private final Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; valuesByPercentile;
368 		private final Map&lt;String, IQuantity&gt; itemTotals;
369 
370 		public DurationPercentileTableModel(IItemCollection items) {
371 			this.items = items;
372 			this.valuesByPercentile = new ConcurrentHashMap&lt;&gt;();
373 			this.itemTotals = new ConcurrentHashMap&lt;&gt;();
374 		}
375 
376 		/**
377 		 * Computes the aggregate of this model&#39;s items and adds the results to this model.
<span class="line-modified">378 		 * @param aggregator - the aggregator to use</span>


379 		 */
380 		public void addAggregate(DurationPercentileAggregator aggregator) {
381 			aggregator.resetHistogram();
382 
383 			Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; newData = items.getAggregate(aggregator);
384 			addData(newData);
385 
386 			String countCol = aggregator.getCountColId();
387 			IQuantity itemCount = aggregator.getItemCount();
388 			itemTotals.put(countCol, itemCount);
389 		}
390 
391 		private void addData(Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; newValues) {
392 			newValues.forEach((key, val) -&gt; valuesByPercentile.merge(key, val, (oldVal, newVal) -&gt; {
393 				oldVal.putAll(newVal);
394 				return oldVal;
395 			}));
396 		}
397 
398 		/**
<span class="line-modified">399 		 * Builds a list of table rows from the data in this model, suitable as input</span>
<span class="line-modified">400 		 * to the {@link DurationPercentileTable}&#39;s {@link ColumnViewer}.</span>

401 		 * @return the list of rows
402 		 */
403 		public List&lt;DurationPercentileTableRow&gt; buildRows() {
404 			List&lt;DurationPercentileTableRow&gt; rows = new ArrayList&lt;&gt;();
405 			for (IQuantity percentile : PERCENTILES) {
406 				DurationPercentileTableRow row = new DurationPercentileTableRow(percentile,
407 						valuesByPercentile.get(percentile), itemTotals, items);
408 				rows.add(row);
409 			}
410 			return rows;
411 		}
412 
413 	}
414 
415 	/**
<span class="line-modified">416 	 * Roughly equivalent to a row in the table, containing the percentile and list of</span>
<span class="line-modified">417 	 * associated quantities in column order.</span>
418 	 */
419 	private static class DurationPercentileTableRow {
420 
421 		private final IQuantity percentile;
422 		private final Map&lt;String, IQuantity&gt; valuesByColId;
423 		private final Map&lt;String, IQuantity&gt; totalsById;
424 		private final IItemCollection items;
425 
426 		public DurationPercentileTableRow(IQuantity percentile, Map&lt;String, IQuantity&gt; values,
427 				Map&lt;String, IQuantity&gt; totals, IItemCollection items) {
428 			this.percentile = percentile;
429 			this.valuesByColId = values;
430 			this.totalsById = totals;
431 			this.items = items;
432 		}
433 
434 		public IQuantity getPercentile() {
435 			return percentile;
436 		}
437 
438 		public IQuantity getValue(String columnId) {
439 			return valuesByColId.get(columnId);
440 		}
441 
442 		public boolean hasValue(String columnId) {
443 			return valuesByColId.containsKey(columnId);
444 		}
445 
446 		/**
<span class="line-modified">447 		 * Calculates the fraction of items in this row, compared to the total</span>
<span class="line-modified">448 		 * number of items in the series.</span>
<span class="line-modified">449 		 * @param columnId - the ID of the item count column</span>


450 		 * @return a fraction quantity between 0 and 1
451 		 */
452 		public IQuantity getCountFraction(String columnId) {
453 			IQuantity count = valuesByColId.get(columnId);
454 			IQuantity total = totalsById.get(columnId);
455 			double fraction = 0.0;
456 			if (count != null &amp;&amp; total != null &amp;&amp; total.longValue() &gt; 0) {
457 				fraction = count.doubleValue() / total.doubleValue();
458 			}
459 			return UnitLookup.NUMBER_UNITY.quantity(fraction);
460 		}
461 
462 		/**
<span class="line-modified">463 		 * Computes the collection of items that have duration at least as long as the</span>
<span class="line-modified">464 		 * corresponding values in this row.</span>
<span class="line-modified">465 		 * @param aggregators - an array of aggregators that produced the content of this row</span>


466 		 * @return the matching items
467 		 */
468 		public IItemCollection getItemsForRow(DurationPercentileAggregator[] aggregators) {
469 			// Select all events with matching Type ID and duration greater or equal to the value
470 			// for the selected percentile in the histogram, subject to the histogram&#39;s precision.
471 			IItemFilter filter = Arrays.stream(aggregators).parallel().filter(a -&gt; hasValue(a.getDurationColId()))
472 					.map(a -&gt; ItemFilters.and(ItemFilters.type(a.getTypeId()),
473 							ItemFilters.moreOrEqual(JfrAttributes.DURATION,
474 									a.getLowestEquivalentDuration(getValue(a.getDurationColId())))))
475 					.reduce(ItemFilters::or).orElse(ItemFilters.none());
476 			return items.apply(filter);
477 		}
478 
479 	}
480 
481 }
</pre>
</td>
<td>
<hr />
<pre>
 57 import org.openjdk.jmc.common.item.IMemberAccessor;
 58 import org.openjdk.jmc.common.item.IType;
 59 import org.openjdk.jmc.common.item.ItemFilters;
 60 import org.openjdk.jmc.common.unit.IQuantity;
 61 import org.openjdk.jmc.common.unit.UnitLookup;
 62 import org.openjdk.jmc.common.util.Pair;
 63 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 64 import org.openjdk.jmc.flightrecorder.ui.common.DurationHdrHistogram.DurationItemConsumer;
 65 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
 66 import org.openjdk.jmc.ui.UIPlugin;
 67 import org.openjdk.jmc.ui.accessibility.FocusTracker;
 68 import org.openjdk.jmc.ui.column.ColumnBuilder;
 69 import org.openjdk.jmc.ui.column.ColumnManager;
 70 import org.openjdk.jmc.ui.column.IColumn;
 71 import org.openjdk.jmc.ui.column.TableSettings;
 72 import org.openjdk.jmc.ui.misc.BackgroundFractionDrawer;
 73 import org.openjdk.jmc.ui.misc.DelegatingLabelProvider;
 74 import org.openjdk.jmc.ui.misc.OptimisticComparator;
 75 
 76 /**
<span class="line-modified"> 77  * A table containing Flight Recorder event durations at various pre-defined percentiles. Each row</span>
<span class="line-modified"> 78  * in the table contains values for a different percentile, and the columns contain series of</span>
<span class="line-modified"> 79  * durations and event counts.</span>
 80  *
 81  * @see DurationPercentileTableBuilder
 82  */
 83 public class DurationPercentileTable {
 84 
 85 	public static final String TABLE_NAME = &quot;DurationPercentileTable&quot;; //$NON-NLS-1$
 86 	private static final String COL_ID_PERCENTILE = TABLE_NAME + &quot;.percentile&quot;; //$NON-NLS-1$
 87 
<span class="line-modified"> 88 	private static final IQuantity[] PERCENTILES = {UnitLookup.NUMBER_UNITY.quantity(0.0),</span>
<span class="line-modified"> 89 			UnitLookup.NUMBER_UNITY.quantity(90.0), UnitLookup.NUMBER_UNITY.quantity(99.0),</span>
<span class="line-modified"> 90 			UnitLookup.NUMBER_UNITY.quantity(99.9), UnitLookup.NUMBER_UNITY.quantity(99.99),</span>
<span class="line-modified"> 91 			UnitLookup.NUMBER_UNITY.quantity(99.999), UnitLookup.NUMBER_UNITY.quantity(100.0),};</span>





 92 
 93 	private final DurationPercentileAggregator[] aggregators; // Correspond to column order
 94 	private final ColumnManager manager;
 95 
 96 	private DurationPercentileTable(ColumnManager manager, DurationPercentileAggregator[] aggregators) {
 97 		this.manager = manager;
 98 		this.aggregators = aggregators;
 99 	}
100 
101 	/**
102 	 * Builder class that is the sole means of creating {@link DurationPercentileTable} instances.
103 	 */
104 	public static class DurationPercentileTableBuilder {
105 
106 		private final List&lt;IColumn&gt; columns;
107 		private final List&lt;DurationPercentileAggregator&gt; aggregators;
108 
109 		public DurationPercentileTableBuilder() {
110 			this.columns = new ArrayList&lt;&gt;();
111 			this.aggregators = new ArrayList&lt;&gt;();
112 		}
113 
114 		/**
115 		 * Adds a data series to this table, corresponding to an event type with a duration
<span class="line-modified">116 		 * associated with it. Calling this method adds two columns to the resulting table. The</span>
<span class="line-modified">117 		 * first column contains duration values for the event at different percentiles, and the</span>
<span class="line-modified">118 		 * second column contains the number of events with duration &lt;= the duration at that</span>
<span class="line-modified">119 		 * percentile.</span>
120 		 *
<span class="line-modified">121 		 * @param durationColId</span>
<span class="line-modified">122 		 *            - the ID to be used for the duration column of this series</span>
<span class="line-modified">123 		 * @param durationColName</span>
<span class="line-modified">124 		 *            - the user-visible name to appear for the duration column header</span>
<span class="line-modified">125 		 * @param countColId</span>
<span class="line-added">126 		 *            - the ID to be used for the event count column of this series</span>
<span class="line-added">127 		 * @param countColName</span>
<span class="line-added">128 		 *            - the user-visible name to appear for the event count column header</span>
<span class="line-added">129 		 * @param typeId</span>
<span class="line-added">130 		 *            - the event type ID used to match events belonging to this series</span>
131 		 */
<span class="line-modified">132 		public void addSeries(</span>
<span class="line-modified">133 			String durationColId, String durationColName, String countColId, String countColName, String typeId) {</span>
<span class="line-modified">134 			IColumn column = new ColumnBuilder(durationColName, durationColId, new ValueAccessor(durationColId))</span>
<span class="line-added">135 					.style(SWT.RIGHT).build();</span>
136 			columns.add(column);
137 
138 			Function&lt;DurationPercentileTableRow, IQuantity&gt; fractionFunc = row -&gt; row.getCountFraction(countColId);
139 			column = new ColumnBuilder(countColName, countColId, new ValueAccessor(countColId)).style(SWT.RIGHT)
140 					.columnDrawer(BackgroundFractionDrawer.unchecked(fractionFunc)).build();
141 			columns.add(column);
142 
<span class="line-modified">143 			DurationPercentileAggregator aggregator = new DurationPercentileAggregator(typeId, durationColId,</span>
<span class="line-added">144 					countColId);</span>
145 			aggregators.add(aggregator);
146 		}
147 
148 		/**
<span class="line-modified">149 		 * Builds the {@link DurationPercentileTable} after all series have been added. Calling this</span>
<span class="line-modified">150 		 * method results in the creation of the underlying {@link TableViewer}. Further changes to</span>
<span class="line-modified">151 		 * this builder will not affect the returned table.</span>
<span class="line-modified">152 		 * </span>
<span class="line-modified">153 		 * @param parent</span>
<span class="line-added">154 		 *            - the parent SWT composite that will contain this table</span>
<span class="line-added">155 		 * @param ts</span>
<span class="line-added">156 		 *            - settings to adjust various attributes of the created table</span>
157 		 * @return a fully constructed {@link DurationPercentileTable} with no data
158 		 */
159 		public DurationPercentileTable build(Composite parent, TableSettings ts) {
160 			TableViewer tableViewer = new TableViewer(parent,
161 					SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION);
162 			tableViewer.getControl().setData(&quot;name&quot;, TABLE_NAME); //$NON-NLS-1$
163 			tableViewer.setContentProvider(ArrayContentProvider.getInstance());
164 			ColumnViewerToolTipSupport.enableFor(tableViewer);
165 			if (UIPlugin.getDefault().getAccessibilityMode()) {
166 				FocusTracker.enableFocusTracking(tableViewer.getTable());
167 			}
168 
169 			List&lt;IColumn&gt; columns = new ArrayList&lt;&gt;();
170 			ItemHistogram.KeyLabelProvider keyLP = new ItemHistogram.KeyLabelProvider(UnitLookup.NUMBER);
171 			PercentileAccessor cellAccessor = new PercentileAccessor();
172 			OptimisticComparator comp = new OptimisticComparator(cellAccessor, keyLP);
173 			columns.add(new ColumnBuilder(Messages.DurationPercentileTable_PERCENTILE_COL_NAME, COL_ID_PERCENTILE,
174 					new DelegatingLabelProvider(keyLP, cellAccessor)).comparator(comp).build());
175 			columns.addAll(this.columns);
176 
177 			ColumnManager manager = ColumnManager.build(tableViewer, columns, ts);
<span class="line-modified">178 			DurationPercentileAggregator[] aggregatorsCopy = aggregators</span>
<span class="line-added">179 					.toArray(new DurationPercentileAggregator[aggregators.size()]);</span>
180 			return new DurationPercentileTable(manager, aggregatorsCopy);
181 		}
182 	}
183 
184 	/**
<span class="line-modified">185 	 * Updates the data in this table with events from the item collection. Calling this method</span>
<span class="line-modified">186 	 * stores the input data into a histogram, which is then used to generate duration values at</span>
<span class="line-modified">187 	 * various percentiles.</span>
188 	 *
<span class="line-modified">189 	 * @param itemCol</span>
<span class="line-added">190 	 *            - a collection of events to use as input for this table</span>
191 	 */
192 	public void update(IItemCollection itemCol) {
193 		// Add the value of each aggregate to our data model
194 		DurationPercentileTableModel model = new DurationPercentileTableModel(itemCol);
195 		Arrays.stream(aggregators).parallel().forEach(model::addAggregate);
196 
197 		// Build rows for each percentile and set in the table
198 		List&lt;DurationPercentileTableRow&gt; rows = model.buildRows();
199 		updateColumnVisibilty(rows.get(0));
200 		manager.getViewer().setInput(rows);
201 	}
202 
203 	private void updateColumnVisibilty(DurationPercentileTableRow row) {
204 		manager.getColumnStates().forEach(c -&gt; {
205 			String id = c.getColumn().getId();
206 			if (!COL_ID_PERCENTILE.equals(id)) { // Percentile column always shown
207 				boolean shouldShow = row.hasValue(id);
208 				// Don&#39;t show if already shown, will duplicate column
209 				if (shouldShow != c.isVisible()) {
210 					manager.setColumnHidden(id, !shouldShow);
211 				}
212 			}
213 		});
214 	}
215 
216 	/**
217 	 * Get the {@link ColumnManager} responsible for the underlying {@link TableViewer}.
<span class="line-added">218 	 * </span>
219 	 * @return the manager
220 	 */
221 	public ColumnManager getManager() {
222 		return manager;
223 	}
224 
225 	/**
<span class="line-modified">226 	 * Gets a collection of items whose duration is at least as long as the percentile value in the</span>
<span class="line-modified">227 	 * currently selected row.</span>
<span class="line-added">228 	 * </span>
229 	 * @return the collection of matching items
230 	 */
231 	public IItemCollection getSelectedItems() {
232 		IStructuredSelection selection = manager.getViewer().getStructuredSelection();
233 		Object firstSelection = selection.getFirstElement();
234 		if (firstSelection instanceof DurationPercentileTableRow) {
235 			DurationPercentileTableRow row = (DurationPercentileTableRow) firstSelection;
236 			return row.getItemsForRow(aggregators);
237 		}
238 		return null;
239 	}
240 
241 	private static class PercentileAccessor implements IMemberAccessor&lt;IQuantity, Object&gt; {
242 
243 		@Override
244 		public IQuantity getMember(Object inObject) {
245 			if (inObject instanceof DurationPercentileTableRow) {
246 				return ((DurationPercentileTableRow) inObject).getPercentile();
247 			}
248 			return null;
</pre>
<hr />
<pre>
251 	}
252 
253 	private static class ValueAccessor implements IMemberAccessor&lt;IQuantity, DurationPercentileTableRow&gt; {
254 
255 		private final String columnId;
256 
257 		public ValueAccessor(String columnId) {
258 			this.columnId = columnId;
259 		}
260 
261 		@Override
262 		public IQuantity getMember(DurationPercentileTableRow inObject) {
263 			return inObject.getValue(columnId);
264 		}
265 
266 	}
267 
268 	/**
269 	 * Aggregator that inserts event durations into a histogram.
270 	 */
<span class="line-modified">271 	private static class DurationPercentileAggregator</span>
<span class="line-added">272 			extends AggregatorBase&lt;Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt;, DurationItemConsumer&gt; {</span>
273 
274 		private final DurationHdrHistogram histogram;
275 		private final String typeId;
276 		private final String durationColId;
277 		private final String countColId;
278 
279 		/**
280 		 * Creates a new aggregator.
<span class="line-modified">281 		 * </span>
<span class="line-modified">282 		 * @param typeId</span>
<span class="line-modified">283 		 *            - type ID used to match events</span>
<span class="line-added">284 		 * @param durationColId</span>
<span class="line-added">285 		 *            - the column ID for the duration column of this series</span>
<span class="line-added">286 		 * @param countColId</span>
<span class="line-added">287 		 *            - the column ID for the item count column of this series</span>
288 		 */
289 		public DurationPercentileAggregator(String typeId, String durationColId, String countColId) {
290 			super(null, null, UnitLookup.UNKNOWN);
291 			this.histogram = new DurationHdrHistogram();
292 			this.typeId = typeId;
293 			this.durationColId = durationColId;
294 			this.countColId = countColId;
295 		}
296 
297 		@Override
298 		public boolean acceptType(IType&lt;IItem&gt; type) {
299 			return typeId.equals(type.getIdentifier());
300 		}
301 
302 		@Override
303 		public DurationItemConsumer newItemConsumer(IType&lt;IItem&gt; itemType) {
304 			return new DurationItemConsumer(histogram, JfrAttributes.DURATION.getAccessor(itemType));
305 		}
306 
307 		@Override
</pre>
<hr />
<pre>
338 		 */
339 		public String getDurationColId() {
340 			return durationColId;
341 		}
342 
343 		/**
344 		 * @return the ID for the item count column using this aggregator
345 		 */
346 		public String getCountColId() {
347 			return countColId;
348 		}
349 
350 		/**
351 		 * @return the type ID used to match items accepted by this aggregator
352 		 */
353 		public String getTypeId() {
354 			return typeId;
355 		}
356 
357 		/**
<span class="line-modified">358 		 * @param duration</span>
<span class="line-modified">359 		 *            - a {@link UnitLookup#TIMESPAN} quantity</span>
<span class="line-modified">360 		 * @return a lower bound on values considered equivalent by this aggregator&#39;s underlying</span>
<span class="line-added">361 		 *         histogram</span>
362 		 */
363 		public IQuantity getLowestEquivalentDuration(IQuantity duration) {
364 			return histogram.getLowestEquivalentDuration(duration);
365 		}
366 
367 		/**
368 		 * Resets this aggregator&#39;s histogram to its initial state
369 		 */
370 		public void resetHistogram() {
371 			histogram.reset();
372 		}
373 
374 	}
375 
376 	/**
377 	 * A data model representing the content to be displayed in the {@link DurationPercentileTable}.
378 	 */
379 	private static class DurationPercentileTableModel {
380 
381 		private final IItemCollection items;
382 		private final Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; valuesByPercentile;
383 		private final Map&lt;String, IQuantity&gt; itemTotals;
384 
385 		public DurationPercentileTableModel(IItemCollection items) {
386 			this.items = items;
387 			this.valuesByPercentile = new ConcurrentHashMap&lt;&gt;();
388 			this.itemTotals = new ConcurrentHashMap&lt;&gt;();
389 		}
390 
391 		/**
392 		 * Computes the aggregate of this model&#39;s items and adds the results to this model.
<span class="line-modified">393 		 * </span>
<span class="line-added">394 		 * @param aggregator</span>
<span class="line-added">395 		 *            - the aggregator to use</span>
396 		 */
397 		public void addAggregate(DurationPercentileAggregator aggregator) {
398 			aggregator.resetHistogram();
399 
400 			Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; newData = items.getAggregate(aggregator);
401 			addData(newData);
402 
403 			String countCol = aggregator.getCountColId();
404 			IQuantity itemCount = aggregator.getItemCount();
405 			itemTotals.put(countCol, itemCount);
406 		}
407 
408 		private void addData(Map&lt;IQuantity, Map&lt;String, IQuantity&gt;&gt; newValues) {
409 			newValues.forEach((key, val) -&gt; valuesByPercentile.merge(key, val, (oldVal, newVal) -&gt; {
410 				oldVal.putAll(newVal);
411 				return oldVal;
412 			}));
413 		}
414 
415 		/**
<span class="line-modified">416 		 * Builds a list of table rows from the data in this model, suitable as input to the</span>
<span class="line-modified">417 		 * {@link DurationPercentileTable}&#39;s {@link ColumnViewer}.</span>
<span class="line-added">418 		 * </span>
419 		 * @return the list of rows
420 		 */
421 		public List&lt;DurationPercentileTableRow&gt; buildRows() {
422 			List&lt;DurationPercentileTableRow&gt; rows = new ArrayList&lt;&gt;();
423 			for (IQuantity percentile : PERCENTILES) {
424 				DurationPercentileTableRow row = new DurationPercentileTableRow(percentile,
425 						valuesByPercentile.get(percentile), itemTotals, items);
426 				rows.add(row);
427 			}
428 			return rows;
429 		}
430 
431 	}
432 
433 	/**
<span class="line-modified">434 	 * Roughly equivalent to a row in the table, containing the percentile and list of associated</span>
<span class="line-modified">435 	 * quantities in column order.</span>
436 	 */
437 	private static class DurationPercentileTableRow {
438 
439 		private final IQuantity percentile;
440 		private final Map&lt;String, IQuantity&gt; valuesByColId;
441 		private final Map&lt;String, IQuantity&gt; totalsById;
442 		private final IItemCollection items;
443 
444 		public DurationPercentileTableRow(IQuantity percentile, Map&lt;String, IQuantity&gt; values,
445 				Map&lt;String, IQuantity&gt; totals, IItemCollection items) {
446 			this.percentile = percentile;
447 			this.valuesByColId = values;
448 			this.totalsById = totals;
449 			this.items = items;
450 		}
451 
452 		public IQuantity getPercentile() {
453 			return percentile;
454 		}
455 
456 		public IQuantity getValue(String columnId) {
457 			return valuesByColId.get(columnId);
458 		}
459 
460 		public boolean hasValue(String columnId) {
461 			return valuesByColId.containsKey(columnId);
462 		}
463 
464 		/**
<span class="line-modified">465 		 * Calculates the fraction of items in this row, compared to the total number of items in</span>
<span class="line-modified">466 		 * the series.</span>
<span class="line-modified">467 		 * </span>
<span class="line-added">468 		 * @param columnId</span>
<span class="line-added">469 		 *            - the ID of the item count column</span>
470 		 * @return a fraction quantity between 0 and 1
471 		 */
472 		public IQuantity getCountFraction(String columnId) {
473 			IQuantity count = valuesByColId.get(columnId);
474 			IQuantity total = totalsById.get(columnId);
475 			double fraction = 0.0;
476 			if (count != null &amp;&amp; total != null &amp;&amp; total.longValue() &gt; 0) {
477 				fraction = count.doubleValue() / total.doubleValue();
478 			}
479 			return UnitLookup.NUMBER_UNITY.quantity(fraction);
480 		}
481 
482 		/**
<span class="line-modified">483 		 * Computes the collection of items that have duration at least as long as the corresponding</span>
<span class="line-modified">484 		 * values in this row.</span>
<span class="line-modified">485 		 * </span>
<span class="line-added">486 		 * @param aggregators</span>
<span class="line-added">487 		 *            - an array of aggregators that produced the content of this row</span>
488 		 * @return the matching items
489 		 */
490 		public IItemCollection getItemsForRow(DurationPercentileAggregator[] aggregators) {
491 			// Select all events with matching Type ID and duration greater or equal to the value
492 			// for the selected percentile in the histogram, subject to the histogram&#39;s precision.
493 			IItemFilter filter = Arrays.stream(aggregators).parallel().filter(a -&gt; hasValue(a.getDurationColId()))
494 					.map(a -&gt; ItemFilters.and(ItemFilters.type(a.getTypeId()),
495 							ItemFilters.moreOrEqual(JfrAttributes.DURATION,
496 									a.getLowestEquivalentDuration(getValue(a.getDurationColId())))))
497 					.reduce(ItemFilters::or).orElse(ItemFilters.none());
498 			return items.apply(filter);
499 		}
500 
501 	}
502 
503 }
</pre>
</td>
</tr>
</table>
<center><a href="DurationHdrHistogram.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ThreadGraphLanes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>