<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/FilterEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
   3  * 
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * The contents of this file are subject to the terms of either the Universal Permissive License
   7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
   8  *
   9  * or the following license:
  10  *
  11  * Redistribution and use in source and binary forms, with or without modification, are permitted
  12  * provided that the following conditions are met:
  13  * 
  14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
  15  * and the following disclaimer.
  16  * 
  17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
  18  * conditions and the following disclaimer in the documentation and/or other materials provided with
  19  * the distribution.
  20  * 
  21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
  22  * endorse or promote products derived from this software without specific prior written permission.
  23  * 
  24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
  25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 package org.openjdk.jmc.ui.misc;
  34 
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.InvocationTargetException;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collection;
  40 import java.util.Collections;
  41 import java.util.HashMap;
  42 import java.util.HashSet;
  43 import java.util.List;
  44 import java.util.Map;
  45 import java.util.Set;
  46 import java.util.function.Consumer;
  47 import java.util.function.Function;
  48 import java.util.function.Supplier;
  49 import java.util.logging.Level;
  50 import java.util.regex.Pattern;
  51 import java.util.regex.PatternSyntaxException;
  52 import java.util.stream.Stream;
  53 
  54 import org.eclipse.jface.action.IAction;
  55 import org.eclipse.jface.fieldassist.ControlDecoration;
  56 import org.eclipse.jface.preference.JFacePreferences;
  57 import org.eclipse.jface.resource.JFaceResources;
  58 import org.eclipse.jface.util.LocalSelectionTransfer;
  59 import org.eclipse.jface.viewers.ArrayContentProvider;
  60 import org.eclipse.jface.viewers.CellEditor;
  61 import org.eclipse.jface.viewers.CheckboxCellEditor;
  62 import org.eclipse.jface.viewers.ColumnLabelProvider;
  63 import org.eclipse.jface.viewers.ColumnViewer;
  64 import org.eclipse.jface.viewers.ColumnViewerEditor;
  65 import org.eclipse.jface.viewers.ColumnViewerEditorActivationEvent;
  66 import org.eclipse.jface.viewers.ColumnViewerEditorActivationStrategy;
  67 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
  68 import org.eclipse.jface.viewers.ComboBoxViewerCellEditor;
  69 import org.eclipse.jface.viewers.EditingSupport;
  70 import org.eclipse.jface.viewers.FocusCellOwnerDrawHighlighter;
  71 import org.eclipse.jface.viewers.ISelection;
  72 import org.eclipse.jface.viewers.ISelectionChangedListener;
  73 import org.eclipse.jface.viewers.ITreeContentProvider;
  74 import org.eclipse.jface.viewers.ITreeSelection;
  75 import org.eclipse.jface.viewers.SelectionChangedEvent;
  76 import org.eclipse.jface.viewers.StructuredSelection;
  77 import org.eclipse.jface.viewers.TextCellEditor;
  78 import org.eclipse.jface.viewers.TreePath;
  79 import org.eclipse.jface.viewers.TreeViewer;
  80 import org.eclipse.jface.viewers.TreeViewerColumn;
  81 import org.eclipse.jface.viewers.TreeViewerEditor;
  82 import org.eclipse.jface.viewers.TreeViewerFocusCellManager;
  83 import org.eclipse.jface.viewers.ViewerDropAdapter;
  84 import org.eclipse.osgi.util.NLS;
  85 import org.eclipse.swt.SWT;
  86 import org.eclipse.swt.dnd.DND;
  87 import org.eclipse.swt.dnd.Transfer;
  88 import org.eclipse.swt.events.FocusAdapter;
  89 import org.eclipse.swt.events.FocusEvent;
  90 import org.eclipse.swt.events.ModifyEvent;
  91 import org.eclipse.swt.events.MouseEvent;
  92 import org.eclipse.swt.graphics.Color;
  93 import org.eclipse.swt.graphics.Font;
  94 import org.eclipse.swt.graphics.Image;
  95 import org.eclipse.swt.widgets.Control;
  96 import org.eclipse.swt.widgets.TreeColumn;
  97 import org.eclipse.ui.IWorkbenchCommandConstants;
  98 import org.openjdk.jmc.common.IDisplayable;
  99 import org.openjdk.jmc.common.IState;
 100 import org.openjdk.jmc.common.IWritableState;
 101 import org.openjdk.jmc.common.item.IAttribute;
 102 import org.openjdk.jmc.common.item.ICanonicalAccessorFactory;
 103 import org.openjdk.jmc.common.item.IItemFilter;
 104 import org.openjdk.jmc.common.item.ItemFilters;
 105 import org.openjdk.jmc.common.item.ItemFilters.AttributeFilter;
 106 import org.openjdk.jmc.common.item.ItemFilters.AttributeValue;
 107 import org.openjdk.jmc.common.item.ItemFilters.Composite;
 108 import org.openjdk.jmc.common.item.ItemFilters.Contains;
 109 import org.openjdk.jmc.common.item.ItemFilters.Matches;
 110 import org.openjdk.jmc.common.item.ItemFilters.Not;
 111 import org.openjdk.jmc.common.item.ItemFilters.Type;
 112 import org.openjdk.jmc.common.item.ItemFilters.TypeMatches;
 113 import org.openjdk.jmc.common.item.PersistableItemFilter.Kind;
 114 import org.openjdk.jmc.common.unit.ContentType;
 115 import org.openjdk.jmc.common.unit.IQuantity;
 116 import org.openjdk.jmc.common.unit.IRange;
 117 import org.openjdk.jmc.common.unit.KindOfQuantity;
 118 import org.openjdk.jmc.common.unit.RangeContentType;
 119 import org.openjdk.jmc.common.unit.UnitLookup;
 120 import org.openjdk.jmc.common.util.StateToolkit;
 121 import org.openjdk.jmc.ui.TypeAppearance;
 122 import org.openjdk.jmc.ui.UIPlugin;
 123 import org.openjdk.jmc.ui.accessibility.FocusTracker;
 124 import org.openjdk.jmc.ui.celleditors.CommonCellEditors;
 125 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 126 import org.openjdk.jmc.ui.handlers.InFocusHandlerActivator;
 127 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 128 
 129 public class FilterEditor {
 130 
 131 	private final static Kind[] EQUALS_OPERATIONS = {Kind.EQUALS, Kind.NOT_EQUALS, Kind.EXISTS, Kind.NOT_EXISTS,
 132 			Kind.IS_NULL, Kind.IS_NOT_NULL};
 133 	private final static Kind[] COMPARE_OPERATIONS = {Kind.EQUALS, Kind.NOT_EQUALS, Kind.LESS, Kind.LESS_OR_EQUAL,
 134 			Kind.MORE, Kind.MORE_OR_EQUAL, Kind.EXISTS, Kind.NOT_EXISTS, Kind.IS_NULL, Kind.IS_NOT_NULL};
 135 	private final static Kind[] STRING_OPERATIONS = {Kind.EQUALS, Kind.NOT_EQUALS, Kind.LESS, Kind.LESS_OR_EQUAL,
 136 			Kind.MORE, Kind.MORE_OR_EQUAL, Kind.MATCHES, Kind.NOT_MATCHES, Kind.CONTAINS, Kind.NOT_CONTAINS,
 137 			Kind.EXISTS, Kind.NOT_EXISTS, Kind.IS_NULL, Kind.IS_NOT_NULL};
 138 	private final static Kind[] RANGE_OPERATIONS = {Kind.RANGE_CONTAINED, Kind.RANGE_INTERSECTS, Kind.CENTER_CONTAINED,
 139 			Kind.RANGE_NOT_CONTAINED, Kind.RANGE_NOT_INTERSECTS, Kind.CENTER_NOT_CONTAINED};
 140 	private final static List&lt;Kind&gt; REGEX_OPERATIONS = Arrays.asList(Kind.MATCHES, Kind.NOT_MATCHES, Kind.CONTAINS,
 141 			Kind.NOT_CONTAINS);
 142 
 143 	private static final String SHOW_COLUMN_HEADERS = &quot;showColumnHeaders&quot;; //$NON-NLS-1$
 144 	private static final String COLUMN_WIDTHS = &quot;columnWidths&quot;; //$NON-NLS-1$
 145 	private static final String WIDTH = &quot;width&quot;; //$NON-NLS-1$
 146 
 147 	private abstract static class FilterNode {
 148 
 149 		abstract FilterNode copy();
 150 
 151 		abstract IItemFilter doBuildFilter();
 152 
 153 		IItemFilter buildFilter() {
 154 			return doBuildFilter();
 155 		}
 156 
 157 	}
 158 
 159 	private static class EmptyNode extends FilterNode {
 160 
 161 		@Override
 162 		FilterNode copy() {
 163 			return new EmptyNode();
 164 		}
 165 
 166 		@Override
 167 		IItemFilter doBuildFilter() {
 168 			return null;
 169 		}
 170 	}
 171 
 172 	private static class LeafNode extends FilterNode {
 173 		IItemFilter filter;
 174 
 175 		public LeafNode(IItemFilter filter) {
 176 			this.filter = filter;
 177 		}
 178 
 179 		@Override
 180 		FilterNode copy() {
 181 			return new LeafNode(filter);
 182 		}
 183 
 184 		@Override
 185 		IItemFilter doBuildFilter() {
 186 			return filter;
 187 		}
 188 	}
 189 
 190 	private static class CompositeNode extends FilterNode {
 191 		List&lt;FilterNode&gt; children = new ArrayList&lt;&gt;(3);
 192 		boolean union;
 193 		boolean negated;
 194 
 195 		public CompositeNode(Stream&lt;FilterNode&gt; children, boolean union, boolean negated) {
 196 			this.union = union;
 197 			children.forEach(this.children::add);
 198 			this.negated = negated;
 199 		}
 200 
 201 		@Override
 202 		FilterNode copy() {
 203 			return new CompositeNode(children.stream().map(FilterNode::copy), union, negated);
 204 		}
 205 
 206 		@Override
 207 		IItemFilter doBuildFilter() {
 208 			IItemFilter[] filters = new IItemFilter[children.size()];
 209 			for (int i = 0; i &lt; filters.length; i++) {
 210 				filters[i] = children.get(i).buildFilter();
 211 			}
 212 			IItemFilter compositeFilter = union ? ItemFilters.or(filters) : ItemFilters.and(filters);
 213 			return negated ? ItemFilters.not(compositeFilter) : compositeFilter;
 214 		}
 215 	}
 216 
 217 	private static final class FilterNodeToolkit {
 218 		private FilterNodeToolkit() {
 219 			throw new IllegalAccessError(&quot;Do not implement!&quot;); //$NON-NLS-1$
 220 		}
 221 
 222 		private static Map&lt;FilterNode, CompositeNode&gt; lookupParentRelations(CompositeNode root) {
 223 			Map&lt;FilterNode, CompositeNode&gt; parentRelations = new HashMap&lt;&gt;();
 224 			addParentRelationsOfChildren(parentRelations, root);
 225 			return parentRelations;
 226 		}
 227 
 228 		private static void addParentRelationsOfChildren(
 229 			Map&lt;FilterNode, CompositeNode&gt; parentRelations, CompositeNode parent) {
 230 			for (FilterNode child : parent.children) {
 231 				parentRelations.put(child, parent);
 232 				if (child instanceof CompositeNode) {
 233 					addParentRelationsOfChildren(parentRelations, (CompositeNode) child);
 234 				}
 235 			}
 236 		}
 237 
 238 		public static void deleteFilters(CompositeNode root, List&lt;FilterNode&gt; filters) {
 239 			Map&lt;FilterNode, CompositeNode&gt; parentRelations = lookupParentRelations(root);
 240 			for (FilterNode filter : filters) {
 241 				CompositeNode parent = parentRelations.get(filter);
 242 				parent.children.remove(getPosition(filter, parent));
 243 			}
 244 		}
 245 
 246 		public static boolean unwrapFilter(CompositeNode root, CompositeNode filter) {
 247 			CompositeNode parent = getParent(filter, root);
 248 			int position = getPosition(filter, parent);
 249 			parent.children.remove(position);
 250 			for (FilterNode child : filter.children) {
 251 				parent.children.add(position++, child);
 252 			}
 253 			return true;
 254 		}
 255 
 256 		public static CompositeNode wrapFilters(CompositeNode root, List&lt;FilterNode&gt; filters, boolean union) {
 257 			FilterNode first = filters.get(0);
 258 			CompositeNode parent = getParent(first, root);
 259 			int position = getPosition(first, parent);
 260 			CompositeNode wrapper = new CompositeNode(filters.stream(), union, false);
 261 			for (int i = filters.size(); i &gt; 0; i -= 1) {
 262 				parent.children.remove(position);
 263 			}
 264 			parent.children.add(position, wrapper);
 265 			return wrapper;
 266 		}
 267 
 268 		public static int getPosition(FilterNode node, CompositeNode parent) {
 269 			return parent.children.indexOf(node);
 270 		}
 271 
 272 		public static CompositeNode getParent(FilterNode node, CompositeNode root) {
 273 			for (FilterNode child : root.children) {
 274 				if (child == node) {
 275 					return root;
 276 				} else if (child instanceof CompositeNode) {
 277 					CompositeNode result = getParent(node, (CompositeNode) child);
 278 					if (result != null) {
 279 						return result;
 280 					}
 281 				}
 282 			}
 283 			return null;
 284 		}
 285 	}
 286 
 287 	/**
 288 	 * Tiny interface to circumvent limitations of lambdas with generics.
 289 	 */
 290 	public static interface AttributeValueProvider {
 291 		&lt;V&gt; V defaultValue(ICanonicalAccessorFactory&lt;V&gt; attribute);
 292 	}
 293 
 294 	private final TreeViewer tree;
 295 	private final CompositeNode root = new CompositeNode(Stream.empty(), false, false);
 296 	private final Consumer&lt;IItemFilter&gt; onChange;
 297 	private final MCContextMenuManager mm;
 298 	private final Supplier&lt;Collection&lt;IAttribute&lt;?&gt;&gt;&gt; attributeSupplier;
 299 	private Collection&lt;IAttribute&lt;?&gt;&gt; attributes;
 300 	private final AttributeValueProvider attributeValueProvider;
 301 	private IAction showColumnHeadersAction;
 302 
 303 	/**
 304 	 * @param &lt;M&gt;
 305 	 * @param parent
 306 	 *            parent composite
 307 	 * @param onChange
 308 	 *            consumer of filter changes
 309 	 * @param initial
 310 	 *            initial filter
 311 	 * @param attributeSupplier
 312 	 *            supplier of an attribute collection
 313 	 * @param attributeValueProvider
 314 	 *            function to supply a default value for an attribute.
 315 	 * @param typeColorProvider
 316 	 *            provider for color
 317 	 * @param style
 318 	 *            style for the underlying viewer
 319 	 */
 320 	public &lt;M&gt; FilterEditor(org.eclipse.swt.widgets.Composite parent, Consumer&lt;IItemFilter&gt; onChange,
 321 			IItemFilter initial, Supplier&lt;Collection&lt;IAttribute&lt;?&gt;&gt;&gt; attributeSupplier,
 322 			AttributeValueProvider attributeValueProvider, Function&lt;String, java.awt.Color&gt; typeColorProvider,
 323 			int style) {
 324 		this.attributeSupplier = attributeSupplier;
 325 		this.attributeValueProvider = attributeValueProvider;
 326 		this.tree = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | style);
 327 		this.onChange = onChange;
 328 		tree.setContentProvider(new FilterArrayContentProvider());
 329 		FocusTracker.enableFocusTracking(tree.getTree());
 330 		initializeCellFocus();
 331 
 332 		addColumn(tree, Messages.FilterEditor_COLUMN_ATTRIBUTE, 150, new NameLabelProvider(typeColorProvider),
 333 				new AttributeEditingSupport(tree));
 334 		addColumn(tree, Messages.FilterEditor_COLUMN_OPERATION, 100, new OperationLabelProvider(),
 335 				new OperationEditingSupport(tree));
 336 		addColumn(tree, Messages.FilterEditor_COLUMN_VALUE, 500, new ValueLabelProvider(),
 337 				new ValueEditingSupport(tree));
 338 
 339 		mm = MCContextMenuManager.create(tree.getControl());
 340 
 341 		showColumnHeadersAction = ActionToolkit.checkAction(this::toggleColumnHeaders,
 342 				Messages.FilterEditor_ACTION_SHOW_COLUMN_HEADERS, null);
 343 		mm.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, showColumnHeadersAction);
 344 
 345 		mm.appendToGroup(MCContextMenuManager.GROUP_NEW, ActionToolkit.forListSelection(tree,
 346 				Messages.FilterEditor_ACTION_COMBINE_OR, false, forNonEmptyFilterSelection(filters -&gt; {
 347 					Set&lt;Object&gt; expanded = asSet(tree.getExpandedElements());
 348 					expanded.add(FilterNodeToolkit.wrapFilters(root, filters, true));
 349 					tree.setInput(root);
 350 					tree.setExpandedElements(expanded.toArray());
 351 					notifyListener();
 352 				})));
 353 		mm.appendToGroup(MCContextMenuManager.GROUP_NEW, ActionToolkit.forListSelection(tree,
 354 				Messages.FilterEditor_ACTION_COMBINE_AND, false, forNonEmptyFilterSelection(filters -&gt; {
 355 					Set&lt;Object&gt; expanded = asSet(tree.getExpandedElements());
 356 					expanded.add(FilterNodeToolkit.wrapFilters(root, filters, false));
 357 					tree.setInput(root);
 358 					tree.setExpandedElements(expanded.toArray());
 359 					notifyListener();
 360 				})));
 361 		mm.appendToGroup(MCContextMenuManager.GROUP_NEW,
 362 				ActionToolkit.forListSelection(tree, Messages.FilterEditor_ACTION_REMOVE, false,
 363 						(List&lt;FilterNode&gt; selection) -&gt; onlyCompositeNodesSelected(selection) ? () -&gt; {
 364 							Object[] expanded = tree.getExpandedElements();
 365 							for (FilterNode node : selection) {
 366 								FilterNodeToolkit.unwrapFilter(root, (CompositeNode) node);
 367 							}
 368 							tree.setInput(root);
 369 							tree.setExpandedElements(expanded);
 370 							notifyListener();
 371 						} : null));
 372 		// FIXME: This action does not update its enablement until it has been unselected and reselected (list selection has changed)
 373 		mm.appendToGroup(MCContextMenuManager.GROUP_NEW,
 374 				ActionToolkit.forListSelection(tree, Messages.FilterEditor_ACTION_NEGATE, true,
 375 						(List&lt;FilterNode&gt; filters) -&gt; filtersNegatable(filters) ? () -&gt; {
 376 							for (FilterNode filter : filters) {
 377 								if (filter instanceof CompositeNode) {
 378 									CompositeNode composite = (CompositeNode) filter;
 379 									composite.negated = !composite.negated;
 380 								} else if (isAttributeFilter(filter)) {
 381 									AttributeFilter&lt;M&gt; attributeFilter = asAttributeFilterM(filter);
 382 									M value = attributeFilter instanceof AttributeValue
 383 											? ((AttributeValue&lt;M&gt;) attributeFilter).getValue() : null;
 384 									Kind kind = attributeFilter.getKind();
 385 									Kind newKind = kind.negate();
 386 									if (newKind != null) {
 387 										((LeafNode) filter).filter = buildFilter(newKind,
 388 												attributeFilter.getAttribute(), value);
 389 									}
 390 								}
 391 							}
 392 							notifyListener();
 393 						} : null));
 394 
 395 		IAction cutAction = ActionToolkit.forListSelection(tree, null, false,
 396 				forNonEmptyFilterSelection(this::cutNodes));
 397 		ActionToolkit.convertToCommandAction(cutAction, IWorkbenchCommandConstants.EDIT_CUT);
 398 		InFocusHandlerActivator.install(tree.getControl(), cutAction);
 399 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, cutAction);
 400 
 401 		IAction copyAction = ActionToolkit.forListSelection(tree, null, false,
 402 				forNonEmptyFilterSelection(this::copyNodes));
 403 		ActionToolkit.convertToCommandAction(copyAction, IWorkbenchCommandConstants.EDIT_COPY);
 404 		InFocusHandlerActivator.install(tree.getControl(), copyAction);
 405 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, copyAction);
 406 
 407 		IAction pasteAction = ActionToolkit.forListSelection(tree, null, false,
 408 				(List&lt;FilterNode&gt; selection) -&gt; (selection.size() &lt;= 1) ? () -&gt; pasteNodes(selection) : null);
 409 		ActionToolkit.convertToCommandAction(pasteAction, IWorkbenchCommandConstants.EDIT_PASTE);
 410 		InFocusHandlerActivator.install(tree.getControl(), pasteAction);
 411 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, pasteAction);
 412 
 413 		IAction removeAction = ActionToolkit.forTreeSelection(tree, null, false,
 414 				selection -&gt; selection.isEmpty() || selection.getFirstElement() instanceof EmptyNode ? null
 415 						: () -&gt; deleteNodes(selection));
 416 		ActionToolkit.convertToCommandAction(removeAction, IWorkbenchCommandConstants.EDIT_DELETE);
 417 		InFocusHandlerActivator.install(tree.getControl(), removeAction);
 418 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, removeAction);
 419 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT,
 420 				ActionToolkit.action(this::clearNodes, Messages.FilterEditor_ACTION_CLEAR_ALL));
 421 
 422 		if (initial instanceof Composite &amp;&amp; !((Composite) initial).isUnion()) {
 423 			for (IItemFilter f : ((Composite) initial).getFilters()) {
 424 				root.children.add(buildTreeNode(f));
 425 			}
 426 		} else if (initial != null) {
 427 			root.children.add(buildTreeNode(initial));
 428 		}
 429 		Transfer[] localTransfer = new Transfer[] {LocalSelectionTransfer.getTransfer()};
 430 		tree.addDragSupport(DND.DROP_MOVE | DND.DROP_COPY, localTransfer,
 431 				DndToolkit.createLocalDragSource(tree, this::deleteNodes));
 432 		ViewerDropAdapter dropTarget = DndToolkit.createLocalDropListTarget(tree, CompositeNode.class, FilterNode.class,
 433 				this::performDrop, this::validateDrop);
 434 		dropTarget.setFeedbackEnabled(false);
 435 		tree.addDropSupport(DND.DROP_MOVE | DND.DROP_COPY, localTransfer, dropTarget);
 436 		ColumnViewerToolTipSupport.enableFor(tree);
 437 
 438 		tree.setInput(root);
 439 	}
 440 
 441 	private void initializeCellFocus() {
 442 		FocusCellOwnerDrawHighlighter focusCellHighlighter;
 443 		try {
 444 			/*
 445 			 * Create a focus cell highlighter with the two argument constructor if available.
 446 			 * Second argument is &#39;removeNonFocusedSelectionInformation&#39;, which we want to set to
 447 			 * false.
 448 			 */
 449 			Class&lt;?&gt; fchClass = FocusCellOwnerDrawHighlighter.class;
 450 			Constructor&lt;?&gt; constructor = fchClass.getDeclaredConstructor(ColumnViewer.class, Boolean.TYPE);
 451 			focusCellHighlighter = (FocusCellOwnerDrawHighlighter) constructor.newInstance(tree, false);
 452 		} catch (NoSuchMethodException
 453 				| SecurityException
 454 				| InstantiationException
 455 				| IllegalAccessException
 456 				| IllegalArgumentException
 457 				| InvocationTargetException e) {
 458 			focusCellHighlighter = new FocusCellOwnerDrawHighlighter(tree);
 459 			UIPlugin.getDefault().getLogger().log(Level.INFO,
 460 					&quot;Failed to use the new two argument constructor for FocusCellOwnerDrawHighlighter, likely using Eclipse version pre 4.8. Using one argument constructor&quot;); //$NON-NLS-1$
 461 		}
 462 		TreeViewerFocusCellManager focusCellManager = new TreeViewerFocusCellManager(tree, focusCellHighlighter);
 463 
 464 		ColumnViewerEditorActivationStrategy actSupport = new ColumnViewerEditorActivationStrategy(tree) {
 465 			@Override
 466 			protected boolean isEditorActivationEvent(ColumnViewerEditorActivationEvent event) {
 467 				return (event.eventType == ColumnViewerEditorActivationEvent.MOUSE_CLICK_SELECTION
 468 						&amp;&amp; ((MouseEvent) event.sourceEvent).button == 1)
 469 						|| (event.eventType == ColumnViewerEditorActivationEvent.KEY_PRESSED &amp;&amp; event.keyCode == SWT.CR)
 470 						|| event.eventType == ColumnViewerEditorActivationEvent.PROGRAMMATIC;
 471 			}
 472 		};
 473 
 474 		int feature = ColumnViewerEditor.TABBING_HORIZONTAL | ColumnViewerEditor.TABBING_MOVE_TO_ROW_NEIGHBOR
 475 				| ColumnViewerEditor.TABBING_VERTICAL | ColumnViewerEditor.KEYBOARD_ACTIVATION
 476 				| ColumnViewerEditor.KEEP_EDITOR_ON_DOUBLE_CLICK;
 477 
 478 		TreeViewerEditor.create(tree, focusCellManager, actSupport, feature);
 479 		tree.getTree().addFocusListener(new FocusAdapter() {
 480 			@Override
 481 			public void focusGained(FocusEvent e) {
 482 				if (tree.getSelection().isEmpty()) {
 483 					tree.setSelection(new StructuredSelection(tree.getTree().getItem(0).getData()));
 484 				}
 485 			}
 486 		});
 487 	}
 488 
 489 	public TreeViewer getTree() {
 490 		return tree;
 491 	}
 492 
 493 	private Function&lt;List&lt;FilterNode&gt;, Runnable&gt; forNonEmptyFilterSelection(Consumer&lt;List&lt;FilterNode&gt;&gt; action) {
 494 		return (List&lt;FilterNode&gt; selection) -&gt; selection.isEmpty() || selection.get(0) instanceof EmptyNode ? null
 495 				: () -&gt; action.accept(selection);
 496 	}
 497 
 498 	private boolean filtersNegatable(List&lt;FilterNode&gt; filters) {
 499 		for (FilterNode filter : filters) {
 500 			if (isAttributeFilter(filter)) {
 501 				Kind kind = asAttributeFilter(filter).getKind();
 502 				if (kind.negate() == null) {
 503 					return false;
 504 				}
 505 			} else if (!(filter instanceof CompositeNode)) {
 506 				return false;
 507 			}
 508 		}
 509 		return filters.size() &gt; 0;
 510 	}
 511 
 512 	private Set&lt;Object&gt; asSet(Object[] expandedElements) {
 513 		Set&lt;Object&gt; set = new HashSet&lt;&gt;();
 514 		Collections.addAll(set, expandedElements);
 515 		return set;
 516 	}
 517 
 518 	private boolean onlyCompositeNodesSelected(List&lt;FilterNode&gt; selection) {
 519 		for (FilterNode filter : selection) {
 520 			if (!(filter instanceof CompositeNode)) {
 521 				return false;
 522 			}
 523 		}
 524 		return selection.size() &gt; 0;
 525 	}
 526 
 527 	public MCContextMenuManager getContextMenu() {
 528 		return mm;
 529 	}
 530 
 531 	public Control getControl() {
 532 		return tree.getControl();
 533 	}
 534 
 535 	private static void addColumn(TreeViewer tree, String text, int width, ColumnLabelProvider lp, EditingSupport es) {
 536 		TreeViewerColumn nameCol = new TreeViewerColumn(tree, SWT.NONE);
 537 		nameCol.getColumn().setText(text);
 538 		nameCol.setLabelProvider(lp);
 539 		nameCol.setEditingSupport(es);
 540 		nameCol.getColumn().setWidth(width);
 541 	}
 542 
 543 	public void notifyListener() {
 544 		onChange.accept(getFilter());
 545 	}
 546 
 547 	public IItemFilter getFilter() {
 548 		return root.buildFilter();
 549 	}
 550 
 551 	public void addRoot(IItemFilter filter) {
 552 		root.children.add(buildTreeNode(filter));
 553 		tree.refresh();
 554 		notifyListener();
 555 	}
 556 
 557 	private int validateDrop(List&lt;? extends FilterNode&gt; src, CompositeNode target, int operation) {
 558 		if (target == null ? root.children.containsAll(src) : target.children.containsAll(src)) {
 559 			return DND.DROP_NONE;
 560 		} else if (find(target, src)) {
 561 			return DND.DROP_NONE;
 562 		}
 563 		return operation;
 564 	}
 565 
 566 	private static boolean find(CompositeNode needle, List&lt;? extends FilterNode&gt; inHaystack) {
 567 		for (FilterNode n : inHaystack) {
 568 			if (n == needle) {
 569 				return true;
 570 			} else if (n instanceof CompositeNode) {
 571 				return find(needle, ((CompositeNode) n).children);
 572 			}
 573 		}
 574 		return false;
 575 	}
 576 
 577 	private boolean performDrop(List&lt;? extends FilterNode&gt; src, CompositeNode target, int operation, int location) {
 578 		if (target == null) {
 579 			target = root;
 580 		}
 581 		src.stream().map(FilterNode::copy).forEach(target.children::add);
 582 		tree.refresh(target);
 583 		notifyListener();
 584 		return true;
 585 	}
 586 
 587 	private void cutNodes(List&lt;FilterNode&gt; filters) {
 588 		Object[] expanded = tree.getExpandedElements();
 589 		copyNodes(filters);
 590 		FilterNodeToolkit.deleteFilters(root, filters);
 591 		tree.setInput(root);
 592 		tree.setExpandedElements(expanded);
 593 		notifyListener();
 594 	}
 595 
 596 	private void copyNodes(List&lt;FilterNode&gt; filters) {
 597 		FilterNode[] nodes = filters.toArray(new FilterNode[filters.size()]);
 598 		ClipboardManager.setClipboardContents(new Object[] {nodes},
 599 				new Transfer[] {ClipboardManager.getClipboardLocalTransfer()});
 600 	}
 601 
 602 	private void pasteNodes(List&lt;FilterNode&gt; selection) {
 603 		FilterNode[] nodes = (FilterNode[]) ClipboardManager
 604 				.getClipboardContents(ClipboardManager.getClipboardLocalTransfer());
 605 		if (nodes == null) {
 606 			return;
 607 		}
 608 
 609 		Set&lt;Object&gt; expanded = asSet(tree.getExpandedElements());
 610 		CompositeNode insertNode;
 611 		int insertIndex;
 612 		FilterNode selectedNode = selection.isEmpty() ? null : selection.get(0);
 613 		if (selectedNode == null || selectedNode instanceof EmptyNode) {
 614 			insertNode = root;
 615 			insertIndex = root.children.size();
 616 		} else if (selectedNode instanceof CompositeNode) {
 617 			insertNode = (CompositeNode) selectedNode;
 618 			insertIndex = insertNode.children.size();
 619 			expanded.add(insertNode);
 620 		} else {
 621 			insertNode = FilterNodeToolkit.getParent(selectedNode, root);
 622 			insertIndex = FilterNodeToolkit.getPosition(selectedNode, insertNode) + 1;
 623 		}
 624 
 625 		for (FilterNode node : nodes) {
 626 			insertNode.children.add(insertIndex++, node.copy());
 627 		}
 628 		tree.setInput(root);
 629 		tree.setExpandedElements(expanded.toArray());
 630 		notifyListener();
 631 	}
 632 
 633 	private void deleteNodes(ITreeSelection selectedNodes) {
 634 		for (TreePath path : selectedNodes.getPaths()) {
 635 			int segmentCount = path.getSegmentCount();
 636 			if (segmentCount &lt; 2) {
 637 				root.children.remove(path.getLastSegment());
 638 			} else {
 639 				((CompositeNode) path.getSegment(segmentCount - 2)).children.remove(path.getSegment(segmentCount - 1));
 640 			}
 641 		}
 642 		tree.refresh();
 643 		notifyListener();
 644 	}
 645 
 646 	private void clearNodes() {
 647 		root.children.clear();
 648 		tree.setInput(root);
 649 		notifyListener();
 650 	}
 651 
 652 	private void toggleColumnHeaders(boolean newValue) {
 653 		showColumnHeadersAction.setChecked(newValue);
 654 		tree.getTree().setHeaderVisible(newValue);
 655 	}
 656 
 657 	private static class FilterArrayContentProvider extends AbstractStructuredContentProvider
 658 			implements ITreeContentProvider {
 659 
 660 		@Override
 661 		public boolean hasChildren(Object element) {
 662 			return element instanceof CompositeNode &amp;&amp; !((CompositeNode) element).children.isEmpty();
 663 		}
 664 
 665 		@Override
 666 		public Object getParent(Object element) {
 667 			return null;
 668 		}
 669 
 670 		@Override
 671 		public Object[] getChildren(Object parentElement) {
 672 			if (parentElement instanceof CompositeNode) {
 673 				return ((CompositeNode) parentElement).children.toArray();
 674 			}
 675 			return new Object[0];
 676 		}
 677 
 678 		@Override
 679 		public Object[] getElements(Object inputElement) {
 680 			CompositeNode root = (CompositeNode) inputElement;
 681 			if (root.children.isEmpty()) {
 682 				return new Object[] {new EmptyNode()};
 683 			}
 684 			return getChildren(inputElement);
 685 		}
 686 	}
 687 
 688 	private static class NameLabelProvider extends ColumnLabelProvider {
 689 
 690 		private final Function&lt;String, java.awt.Color&gt; typeColorProvider;
 691 
 692 		NameLabelProvider(Function&lt;String, java.awt.Color&gt; typeColorProvider) {
 693 			this.typeColorProvider = typeColorProvider;
 694 		}
 695 
 696 		@Override
 697 		public String getText(Object element) {
 698 			if (element instanceof EmptyNode) {
 699 				return Messages.FilterEditor_LABEL_EMPTY;
 700 			} else if (element instanceof CompositeNode) {
 701 				CompositeNode filter = (CompositeNode) element;
 702 				if (filter.union) {
 703 					return filter.negated ? Messages.FilterEditor_LABEL_NAME_NOT_OR
 704 							: Messages.FilterEditor_LABEL_NAME_OR;
 705 				} else {
 706 					return filter.negated ? Messages.FilterEditor_LABEL_NAME_NOT_AND
 707 							: Messages.FilterEditor_LABEL_NAME_AND;
 708 				}
 709 			} else {
 710 				return getTextForFilter(((LeafNode) element).filter);
 711 			}
 712 		}
 713 
 714 		private String getTextForFilter(IItemFilter filter) {
 715 			if (filter instanceof Not) {
 716 				return getTextForFilter(((Not) filter).getFilter());
 717 			} else if (filter instanceof AttributeFilter) {
 718 				AttributeFilter&lt;?&gt; af = (AttributeFilter&lt;?&gt;) filter;
 719 				return getAttributeName(af.getAttribute());
 720 			} else if (filter instanceof Type) {
 721 				return Messages.FilterEditor_LABEL_NAME_TYPE;
 722 			} else if (filter instanceof TypeMatches) {
 723 				return Messages.FilterEditor_LABEL_NAME_TYPE;
 724 			}
 725 			return Messages.FilterEditor_LABEL_NAME_UNKNOWN_FILTER;
 726 		}
 727 
 728 		@Override
 729 		public Image getImage(Object element) {
 730 			if (element instanceof EmptyNode) {
 731 				return null;
 732 			} else if (element instanceof CompositeNode) {
 733 				return UIPlugin.getDefault()
 734 						.getImage(((CompositeNode) element).union ? UIPlugin.ICON_ADD : UIPlugin.ICON_AMPERSAND);
 735 			} else {
 736 				return getImageForFilter(((LeafNode) element).filter);
 737 			}
 738 		}
 739 
 740 		private Image getImageForFilter(IItemFilter element) {
 741 			if (element instanceof Not) {
 742 				return getImageForFilter(((Not) element).getFilter());
 743 			} else if (element instanceof AttributeFilter) {
 744 				return getImageForType(((AttributeFilter&lt;?&gt;) element).getAttribute().getContentType().getIdentifier());
 745 			} else if (element instanceof Type) {
 746 				String typeId = ((Type) element).getTypeId();
 747 				Image icon = TypeAppearance.getImage(typeId);
 748 				if (icon == null) {
 749 					return SWTColorToolkit.getColorThumbnail(SWTColorToolkit.asRGB(typeColorProvider.apply(typeId)));
 750 				}
 751 				return icon;
 752 			} else if (element instanceof TypeMatches) {
 753 				return UIPlugin.getDefault().getImage(UIPlugin.ICON_REGEX);
 754 			}
 755 			return null;
 756 		}
 757 
 758 		private Image getImageForType(String typeId) {
 759 			Image icon = TypeAppearance.getImage(typeId);
 760 			return icon == null ? UIPlugin.getDefault().getImage(UIPlugin.ICON_PROPERTY_OBJECT) : icon;
 761 		}
 762 
 763 		@Override
 764 		public Color getForeground(Object element) {
 765 			if (element instanceof EmptyNode) {
 766 				return JFaceResources.getColorRegistry().get(JFacePreferences.QUALIFIER_COLOR);
 767 			}
 768 			return null;
 769 		}
 770 
 771 		@Override
 772 		public String getToolTipText(Object element) {
 773 			if (element instanceof EmptyNode) {
 774 				return Messages.FilterEditor_TOOLTIP_EMPTY;
 775 			}
 776 			if (element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof AttributeFilter) {
 777 				AttributeFilter&lt;?&gt; af = (AttributeFilter&lt;?&gt;) ((LeafNode) element).filter;
 778 				return getAttributeDescription(af.getAttribute());
 779 			}
 780 			return getText(element);
 781 		}
 782 	}
 783 
 784 	private static class OperationLabelProvider extends ColumnLabelProvider {
 785 		@Override
 786 		public String getText(Object element) {
 787 			if (isAttributeFilter(element)) {
 788 				return getKindText(asAttributeFilter(element).getKind());
 789 			}
 790 			if (isTypeMatches(element)) {
 791 				return getKindText(Kind.TYPE_MATCHES);
 792 			}
 793 			if (isType(element)) {
 794 				return getKindText(Kind.TYPE);
 795 			}
 796 			return &quot;&quot;; //$NON-NLS-1$
 797 		}
 798 
 799 		@Override
 800 		public String getToolTipText(Object element) {
 801 			return getText(element);
 802 		}
 803 	}
 804 
 805 	private static class ValueLabelProvider extends TypedLabelProvider&lt;LeafNode&gt; {
 806 
 807 		public ValueLabelProvider() {
 808 			super(LeafNode.class);
 809 		}
 810 
 811 		@Override
 812 		protected String getTextTyped(LeafNode element) {
 813 			if (element.filter instanceof AttributeFilter) {
 814 				return getValueText(((AttributeFilter&lt;?&gt;) element.filter));
 815 			} else if (element.filter instanceof Type) {
 816 				return getTypeName(((Type) element.filter).getTypeId());
 817 			} else if (element.filter instanceof TypeMatches) {
 818 				return ((TypeMatches) element.filter).getTypeMatch();
 819 			}
 820 			return Messages.FilterEditor_LABEL_VALUE_UNKNOWN;
 821 		}
 822 
 823 		protected &lt;V&gt; String getValueText(AttributeFilter&lt;V&gt; filter) {
 824 			if (filter instanceof AttributeValue) {
 825 				// FIXME: Should we rely on formatter or TypeHandling.getValueString here?
 826 				return filter.getAttribute().getContentType().getDefaultFormatter()
 827 						.format(((AttributeValue&lt;V&gt;) filter).getValue());
 828 			}
 829 			return &quot;&quot;; //$NON-NLS-1$
 830 		}
 831 
 832 		protected &lt;V&gt; String getValueTooltipText(AttributeValue&lt;V&gt; value) {
 833 			return value.getAttribute().getContentType().getFormatter(IDisplayable.EXACT).format(value.getValue());
 834 		}
 835 
 836 		protected String getTypeName(String typeID) {
 837 			return typeID;
 838 		}
<a name="1" id="anc1"></a><span class="line-added"> 839 </span>
 840 		@Override
 841 		public Font getFont(Object element) {
 842 			if (element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof AttributeValue) {
 843 				AttributeValue&lt;?&gt; value = (AttributeValue&lt;?&gt;) (((LeafNode) element).filter);
 844 				if (value.getValue() == null) {
 845 					return JFaceResources.getFontRegistry().getItalic(JFaceResources.DEFAULT_FONT);
 846 				}
 847 			}
 848 			return super.getFont(element);
 849 		}
 850 
 851 		@Override
 852 		public String getToolTipText(Object element) {
 853 			if (element instanceof LeafNode) {
 854 				if (((LeafNode) element).filter instanceof AttributeValue) {
 855 					AttributeValue&lt;?&gt; value = (AttributeValue&lt;?&gt;) (((LeafNode) element).filter);
 856 					return getValueTooltipText(value);
 857 				}
 858 				return getTextTyped((LeafNode) element);
 859 			}
 860 			return super.getToolTipText(element);
 861 		}
 862 	}
 863 
 864 	private class AttributeEditingSupport extends EditingSupport {
 865 
 866 		public AttributeEditingSupport(ColumnViewer viewer) {
 867 			super(viewer);
 868 		}
 869 
 870 		@Override
 871 		protected boolean canEdit(Object element) {
 872 			return isAttributeFilter(element);
 873 		}
 874 
 875 		@Override
 876 		protected CellEditor getCellEditor(Object ignored) {
 877 			ComboBoxViewerCellEditor ce = new ComboBoxViewerCellEditor(tree.getTree(),
 878 					SWT.FULL_SELECTION | SWT.READ_ONLY);
 879 			ce.setContentProvider(ArrayContentProvider.getInstance());
 880 			if (attributes == null) {
 881 				attributes = attributeSupplier.get();
 882 			}
 883 			ce.setInput(attributes.toArray());
 884 			ce.setLabelProvider(DelegatingLabelProvider.build(FilterEditor::getAttributeName));
 885 			return ce;
 886 		}
 887 
 888 		@Override
 889 		protected Object getValue(Object element) {
 890 			return asAttributeFilter(element).getAttribute();
 891 		}
 892 
 893 		@Override
 894 		protected void setValue(Object element, Object value) {
 895 			doSetValue((LeafNode) element, (IAttribute&lt;?&gt;) value);
 896 		}
 897 
 898 		private &lt;M&gt; void doSetValue(LeafNode element, IAttribute&lt;M&gt; attr) {
 899 			if (attr != null) {
 900 				ContentType&lt;M&gt; type = attr.getContentType();
 901 				Kind[] allowedKinds = getApplicableOperations(type);
 902 				AttributeFilter&lt;?&gt; oldFilter = (AttributeFilter&lt;?&gt;) element.filter;
 903 				Kind kind = oldFilter.getKind();
 904 				if (!Arrays.asList(allowedKinds).contains(kind)) {
 905 					kind = allowedKinds[0];
 906 				}
 907 				M value = null;
 908 				if (type.equals(oldFilter.getAttribute().getContentType()) &amp;&amp; (oldFilter instanceof AttributeValue)) {
 909 					@SuppressWarnings(&quot;unchecked&quot;)
 910 					M oldValue = ((AttributeValue&lt;M&gt;) oldFilter).getValue();
 911 					value = oldValue;
 912 				}
 913 				if (value == null) {
 914 					value = attributeValueProvider.defaultValue(attr);
 915 				}
 916 				element.filter = buildFilter(kind, attr, value);
 917 				tree.update(element, null);
 918 				notifyListener();
 919 			}
 920 		}
 921 	}
 922 
 923 	private Kind[] getApplicableOperations(ContentType&lt;?&gt; ct) {
 924 		if (ct.equals(UnitLookup.PLAIN_TEXT)) {
 925 			return STRING_OPERATIONS;
 926 		} else if (ct instanceof RangeContentType) {
 927 			return RANGE_OPERATIONS;
 928 		} else if (ct instanceof KindOfQuantity) {
 929 			return COMPARE_OPERATIONS;
 930 		}
 931 		return EQUALS_OPERATIONS;
 932 	}
 933 
 934 	private class OperationEditingSupport extends EditingSupport {
 935 		public OperationEditingSupport(ColumnViewer viewer) {
 936 			super(viewer);
 937 		}
 938 
 939 		@Override
 940 		protected boolean canEdit(Object element) {
 941 			if (isAttributeFilter(element)) {
 942 				return true;
 943 			}
 944 
 945 			return false;
 946 		}
 947 
 948 		@Override
 949 		protected CellEditor getCellEditor(Object element) {
 950 			ContentType&lt;?&gt; ct = getAttribute(element).getContentType();
 951 			OperationCellEditor ce = new OperationCellEditor(tree.getTree(), SWT.FULL_SELECTION | SWT.READ_ONLY,
 952 					element);
 953 			ce.setContentProvider(ArrayContentProvider.getInstance());
 954 			ce.setInput(getApplicableOperations(ct));
 955 			ce.setLabelProvider(DelegatingLabelProvider.build(FilterEditor::getKindText));
 956 			return ce;
 957 		}
 958 
 959 		private ICanonicalAccessorFactory&lt;?&gt; getAttribute(Object element) {
 960 			return ((AttributeFilter&lt;?&gt;) ((LeafNode) element).filter).getAttribute();
 961 		}
 962 
 963 		@Override
 964 		protected Kind getValue(Object element) {
 965 			if (isAttributeFilter(element)) {
 966 				return asAttributeFilter(element).getKind();
 967 			}
 968 			return null;
 969 		}
 970 
 971 		@Override
 972 		protected void setValue(Object element, Object value) {
 973 			if (value != null) {
 974 				doSetValue((LeafNode) element, asAttributeFilter(element), (Kind) value);
 975 			}
 976 		}
 977 
 978 		private &lt;M&gt; void doSetValue(LeafNode element, AttributeFilter&lt;M&gt; current, Kind newKind) {
 979 			M value = null;
 980 			if (current instanceof AttributeValue) {
 981 				value = ((AttributeValue&lt;M&gt;) current).getValue();
 982 			} else {
 983 				value = attributeValueProvider.defaultValue(current.getAttribute());
 984 			}
 985 
 986 			element.filter = buildFilter(newKind, current.getAttribute(), value);
 987 			tree.update(element, null);
 988 			notifyListener();
 989 		}
 990 
 991 	}
 992 
 993 	static class OperationCellEditor extends ComboBoxViewerCellEditor {
 994 		private final ControlDecoration errorDecorator;
 995 		private Object element;
 996 
 997 		public OperationCellEditor(org.eclipse.swt.widgets.Composite parent, int style, Object element) {
 998 			super(parent, style);
 999 			this.element = element;
1000 			errorDecorator = ControlDecorationToolkit.createErrorDecorator(getViewer().getControl());
1001 			getViewer().addSelectionChangedListener(new ISelectionChangedListener() {
1002 				@Override
1003 				public void selectionChanged(SelectionChangedEvent event) {
1004 					validate();
1005 				}
1006 			});
1007 		}
1008 
1009 		@Override
1010 		public void activate() {
1011 			super.activate();
1012 			validate();
1013 		}
1014 
1015 		@Override
1016 		protected void doSetValue(Object value) {
1017 			super.doSetValue(value);
1018 			validate(value);
1019 		}
1020 
1021 		private void validate() {
1022 			ISelection selection = getViewer().getSelection();
1023 			if (selection instanceof StructuredSelection) {
1024 				validate(((StructuredSelection) getViewer().getSelection()).getFirstElement());
1025 			}
1026 		}
1027 
1028 		private void validate(Object value) {
1029 			errorDecorator.hide();
1030 			if (REGEX_OPERATIONS.contains(value) &amp;&amp; isAttributeValue(element)) {
1031 				String str = asAttributeValue(element).getValue().toString();
1032 				validateRegex(str, errorDecorator);
1033 			}
1034 		}
1035 	}
1036 
1037 	private class ValueEditingSupport extends EditingSupport {
1038 
1039 		public ValueEditingSupport(ColumnViewer viewer) {
1040 			super(viewer);
1041 		}
1042 
1043 		@Override
1044 		protected boolean canEdit(Object element) {
1045 			return isAttributeValue(element) || isTypeMatches(element) || isType(element);
1046 		}
1047 
1048 		@Override
1049 		protected CellEditor getCellEditor(Object element) {
1050 			if (isAttributeValue(element)) {
1051 				ContentType&lt;?&gt; contentType = asAttributeValue(element).getAttribute().getContentType();
1052 				if (contentType.equals(UnitLookup.FLAG)) {
1053 					return new CheckboxCellEditor();
1054 				} else if (contentType instanceof KindOfQuantity) {
1055 					return CommonCellEditors.create(tree.getTree(), (KindOfQuantity&lt;?&gt;) contentType);
1056 				} else if (contentType instanceof RangeContentType) {
1057 					return CommonCellEditors.create(tree.getTree(), (RangeContentType&lt;?&gt;) contentType);
1058 				} else if (isRegexFilter(element)) {
1059 					return new RegexCellEditor(tree.getTree());
1060 				} else if (contentType.getPersister() != null) {
1061 					return CommonCellEditors.create(tree.getTree(), contentType.getPersister());
1062 				}
1063 			} else if (isTypeMatches(element)) {
1064 				return new RegexCellEditor(tree.getTree());
1065 			} else if (isType(element)) {
1066 				return new TextCellEditor(tree.getTree());
1067 			}
1068 			return null;
1069 		}
1070 
1071 		@Override
1072 		protected Object getValue(Object element) {
1073 			if (isAttributeValue(element)) {
1074 				return asAttributeValue(element).getValue();
1075 			} else if (isTypeMatches(element)) {
1076 				return asTypeMatches(element).getTypeMatch();
1077 			} else if (isType(element)) {
1078 				return asType(element).getTypeId();
1079 			}
1080 			return null;
1081 		}
1082 
1083 		@Override
1084 		protected void setValue(Object element, Object value) {
1085 			doSetValue((LeafNode) element, value);
1086 		}
1087 
1088 		private &lt;M&gt; void doSetValue(LeafNode element, M value) {
1089 			if (value != null) {
1090 				if (isAttributeValue(element)) {
1091 					@SuppressWarnings(&quot;unchecked&quot;)
1092 					AttributeValue&lt;M&gt; currentFilter = (AttributeValue&lt;M&gt;) element.filter;
1093 					element.filter = buildFilter(currentFilter.getKind(), currentFilter.getAttribute(), value);
1094 				} else if (isTypeMatches(element)) {
1095 					element.filter = ItemFilters.typeMatches((String) value);
1096 				} else if (isType(element)) {
1097 					element.filter = ItemFilters.type((String) value);
1098 				}
1099 				tree.update(element, null);
1100 				notifyListener();
1101 			} else {
1102 				// FIXME: Remove the node?
1103 			}
1104 		}
1105 	}
1106 
1107 	private static class RegexCellEditor extends TextCellEditor {
1108 		private final ControlDecoration errorDecorator;
1109 
1110 		RegexCellEditor(org.eclipse.swt.widgets.Composite parent) {
1111 			super(parent);
1112 			errorDecorator = ControlDecorationToolkit.createErrorDecorator(text);
1113 		}
1114 
1115 		@Override
1116 		public void activate() {
1117 			super.activate();
1118 			validate();
1119 		}
1120 
1121 		@Override
1122 		protected void editOccured(ModifyEvent e) {
1123 			validate();
1124 		}
1125 
1126 		private void validate() {
1127 			String str = text.getText();
1128 			errorDecorator.hide();
1129 			validateRegex(str, errorDecorator);
1130 		}
1131 	}
1132 
1133 	private static void validateRegex(String regex, ControlDecoration errorDecorator) {
1134 		try {
1135 			Pattern.compile(regex);
1136 			errorDecorator.hide();
1137 		} catch (PatternSyntaxException ex) {
1138 			errorDecorator.setDescriptionText(NLS.bind(Messages.FilterEditor_INVALID_REGEX, ex.getLocalizedMessage()));
1139 			errorDecorator.show();
1140 		}
1141 	}
1142 
1143 	private static FilterNode buildTreeNode(IItemFilter filter) {
1144 		return buildTreeNode(filter, false);
1145 	}
1146 
1147 	private static FilterNode buildTreeNode(IItemFilter filter, boolean negate) {
1148 		if (filter instanceof Not) {
1149 			return buildTreeNode(((Not) filter).getFilter(), !negate);
1150 		} else if (filter instanceof Composite) {
1151 			Composite cf = (Composite) filter;
1152 			return new CompositeNode(Stream.of(cf.getFilters()).map(FilterEditor::buildTreeNode), cf.isUnion(), negate);
1153 		} else {
1154 			// FIXME: Ignoring negate here, hopefully there are no negated leaf filters, but might cause bugs.
1155 			return new LeafNode(filter);
1156 		}
1157 	}
1158 
1159 	private static &lt;V&gt; IItemFilter buildFilter(Kind comparisonKind, ICanonicalAccessorFactory&lt;V&gt; attribute, V value) {
1160 		ContentType&lt;V&gt; contentType = attribute.getContentType();
1161 		if (contentType.equals(UnitLookup.PLAIN_TEXT)) {
1162 			@SuppressWarnings(&quot;unchecked&quot;)
1163 			ICanonicalAccessorFactory&lt;String&gt; stringAttribute = (ICanonicalAccessorFactory&lt;String&gt;) attribute;
1164 			return ItemFilters.buildStringFilter(comparisonKind, stringAttribute, (String) value);
1165 		} else if (contentType instanceof KindOfQuantity) {
1166 			@SuppressWarnings(&quot;unchecked&quot;)
1167 			ICanonicalAccessorFactory&lt;IQuantity&gt; quantityAttribute = (ICanonicalAccessorFactory&lt;IQuantity&gt;) attribute;
1168 			return ItemFilters.buildComparisonFilter(comparisonKind, quantityAttribute, (IQuantity) value);
1169 		} else if (contentType instanceof RangeContentType) {
1170 			@SuppressWarnings(&quot;unchecked&quot;)
1171 			ICanonicalAccessorFactory&lt;IRange&lt;IQuantity&gt;&gt; rangeAttribute = (ICanonicalAccessorFactory&lt;IRange&lt;IQuantity&gt;&gt;) attribute;
1172 			@SuppressWarnings(&quot;unchecked&quot;)
1173 			IRange&lt;IQuantity&gt; rangeValue = (IRange&lt;IQuantity&gt;) value;
1174 			return ItemFilters.matchRange(comparisonKind, rangeAttribute, rangeValue);
1175 		} else {
1176 			return ItemFilters.buildEqualityFilter(comparisonKind, attribute, value);
1177 		}
1178 	}
1179 
1180 	private static boolean isAttributeFilter(Object element) {
1181 		return element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof AttributeFilter;
1182 	}
1183 
1184 	private static AttributeFilter&lt;?&gt; asAttributeFilter(Object element) {
1185 		return (AttributeFilter&lt;?&gt;) ((LeafNode) element).filter;
1186 	}
1187 
1188 	// Eclipse complained about unnecessary suppress but if it was removed it complained about unchecked cast.
1189 	// Workaround by wrapping asAttributeFilter in this method which does the suppressed unchecked cast.
1190 	@SuppressWarnings(&quot;unchecked&quot;)
1191 	private static &lt;M&gt; AttributeFilter&lt;M&gt; asAttributeFilterM(Object element) {
1192 		return (AttributeFilter&lt;M&gt;) asAttributeFilter(element);
1193 	}
1194 
1195 	private static boolean isAttributeValue(Object element) {
1196 		return element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof AttributeValue;
1197 	}
1198 
1199 	private static AttributeValue&lt;?&gt; asAttributeValue(Object element) {
1200 		return (AttributeValue&lt;?&gt;) ((LeafNode) element).filter;
1201 	}
1202 
1203 	private static boolean isRegexFilter(Object element) {
1204 		return element instanceof LeafNode
1205 				&amp;&amp; (((LeafNode) element).filter instanceof Matches || ((LeafNode) element).filter instanceof Contains);
1206 	}
1207 
1208 	private static boolean isTypeMatches(Object element) {
1209 		return element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof TypeMatches;
1210 	}
1211 
1212 	private static TypeMatches asTypeMatches(Object element) {
1213 		return (TypeMatches) ((LeafNode) element).filter;
1214 	}
1215 
1216 	private static boolean isType(Object element) {
1217 		return element instanceof LeafNode &amp;&amp; ((LeafNode) element).filter instanceof Type;
1218 	}
1219 
1220 	private static Type asType(Object element) {
1221 		return (Type) ((LeafNode) element).filter;
1222 	}
1223 
1224 	protected static String getAttributeName(ICanonicalAccessorFactory&lt;?&gt; attribute) {
1225 		return attribute instanceof IAttribute ? ((IAttribute&lt;?&gt;) attribute).getName() : attribute.getIdentifier();
1226 	}
1227 
1228 	protected static String getAttributeDescription(ICanonicalAccessorFactory&lt;?&gt; attribute) {
1229 		if (attribute instanceof IAttribute) {
1230 			IAttribute&lt;?&gt; ia = ((IAttribute&lt;?&gt;) attribute);
1231 			return ia.getDescription() != null &amp;&amp; !ia.getDescription().isEmpty() ? ia.getDescription() : ia.getName();
1232 		}
1233 		return attribute.getIdentifier();
1234 	}
1235 
1236 	private static String getKindText(Kind kind) {
1237 		switch (kind) {
1238 		case TYPE:
1239 			return Messages.FilterEditor_KIND_IS;
1240 		case TYPE_MATCHES:
1241 		case MATCHES:
1242 			return Messages.FilterEditor_KIND_MATCHES;
1243 		case NOT_MATCHES:
1244 			return Messages.FilterEditor_KIND_NOT_MATCHES;
1245 		case CONTAINS:
1246 			return Messages.FilterEditor_KIND_CONTAINS;
1247 		case NOT_CONTAINS:
1248 			return Messages.FilterEditor_KIND_NOT_CONTAINS;
1249 		case IS_NULL:
1250 			return Messages.FilterEditor_KIND_IS_NULL;
1251 		case IS_NOT_NULL:
1252 			return Messages.FilterEditor_KIND_ISNT_NULL;
1253 		case EQUALS:
1254 			return &quot;==&quot;; //$NON-NLS-1$
1255 		case NOT_EQUALS:
1256 			return &quot;!=&quot;; //$NON-NLS-1$
1257 		case LESS:
1258 			return &quot;&lt;&quot;; //$NON-NLS-1$
1259 		case LESS_OR_EQUAL:
1260 			return &quot;&lt;=&quot;; //$NON-NLS-1$
1261 		case MORE:
1262 			return &quot;&gt;&quot;; //$NON-NLS-1$
1263 		case MORE_OR_EQUAL:
1264 			return &quot;&gt;=&quot;; //$NON-NLS-1$
1265 		case RANGE_INTERSECTS:
1266 			return Messages.FilterEditor_KIND_INTERSECTS;
1267 		case RANGE_CONTAINED:
1268 			return Messages.FilterEditor_KIND_IS_CONTAINED_IN;
1269 		case CENTER_CONTAINED:
1270 			return Messages.FilterEditor_KIND_HAS_CENTER_IN;
1271 		case RANGE_NOT_INTERSECTS:
1272 			return Messages.FilterEditor_KIND_NOT_INTERSECTS;
1273 		case RANGE_NOT_CONTAINED:
1274 			return Messages.FilterEditor_KIND_NOT_IS_CONTAINED_IN;
1275 		case CENTER_NOT_CONTAINED:
1276 			return Messages.FilterEditor_KIND_NOT_HAS_CENTER_IN;
1277 		case EXISTS:
1278 			return Messages.FilterEditor_KIND_EXISTS;
1279 		case NOT_EXISTS:
1280 			return Messages.FilterEditor_KIND_DOESNT_EXIST;
1281 		default:
1282 			return Messages.FilterEditor_KIND_UNKNOWN;
1283 		}
1284 	}
1285 
1286 	public void loadState(IState state) {
1287 		toggleColumnHeaders(StateToolkit.readBoolean(state, SHOW_COLUMN_HEADERS, false));
1288 		if (state != null) {
1289 			IState columnWidths = state.getChild(COLUMN_WIDTHS);
1290 			TreeColumn[] columns = tree.getTree().getColumns();
1291 			for (int i = 0; i &lt; columns.length; i++) {
1292 				columns[i].setWidth(StateToolkit.readInt(columnWidths, WIDTH + i, columns[i].getWidth()));
1293 			}
1294 		}
1295 	}
1296 
1297 	public void saveState(IWritableState state) {
1298 		StateToolkit.writeBoolean(state, SHOW_COLUMN_HEADERS, showColumnHeadersAction.isChecked());
1299 		TreeColumn[] columns = tree.getTree().getColumns();
1300 		IWritableState columnWidths = state.createChild(COLUMN_WIDTHS);
1301 		for (int i = 0; i &lt; columns.length; i++) {
1302 			StateToolkit.writeInt(columnWidths, WIDTH + i, columns[i].getWidth());
1303 		}
1304 	}
1305 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>