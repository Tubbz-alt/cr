<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/JvmBrowser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.test.jemmy.misc.wrappers;
 34 
 35 import static org.openjdk.jmc.browser.wizards.Messages.ConnectionWizardPage_STORE_CAPTION;
 36 import static org.openjdk.jmc.ui.security.Messages.MasterPasswordWizardPage_SET_MASTER_PASSWORD_TITLE;
 37 import static org.openjdk.jmc.ui.security.Messages.MasterPasswordWizardPage_VERIFY_MASTER_PASSWORD_TITLE;
 38 
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.List;
 42 import java.util.stream.Collectors;
 43 
 44 import org.jemmy.TimeoutExpiredException;
 45 import org.junit.Assert;
 46 
 47 import org.openjdk.jmc.browser.wizards.ConnectionWizardPage;
 48 import org.openjdk.jmc.test.jemmy.MCJemmyTestBase;
 49 import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;
 50 import org.openjdk.jmc.test.jemmy.misc.helpers.ConnectionHelper;
 51 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCButton.Labels;
 52 import org.openjdk.jmc.ui.misc.FileSelector;
 53 import org.openjdk.jmc.ui.security.Constants;
 54 
 55 /**
 56  * The Jemmy wrapper class for the JVM Browser
 57  */
 58 public class JvmBrowser extends MCJemmyBase {
 59 	private static final String ExportTreeToFileWizardPage_TREE_NAME = org.openjdk.jmc.ui.wizards.ExportTreeToFileWizardPage.TREE_NAME;
 60 	private static final String ACTION_EDIT_TEXT = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_EDIT_TEXT;
 61 	private static final String ACTION_DISCONNECT_TEXT = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_DISCONNECT_TEXT;
 62 	private static final String ACTION_TREE_LAYOUT_TOOLTIP = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_TREE_LAYOUT_TOOLTIP;
 63 	private static final String ACTION_NEW_CONNECTION_TEXT = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_NEW_CONNECTION_TEXT;
 64 	private static final String ACTION_NEW_CONNECTION_TOOLTIP = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_NEW_CONNECTION_TOOLTIP;
 65 	private static final String ACTION_NEW_FOLDER_TEXT = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_NEW_FOLDER_TEXT;
 66 	private static final String ACTION_NEW_FOLDER_TOOLTIP = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_NEW_FOLDER_TOOLTIP;
 67 	private static final String ACTION_REMOVE_TEXT = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_ACTION_REMOVE_TEXT;
 68 	private static final String CONNECTION_WIZARD_STORE_CAPTION = org.openjdk.jmc.browser.wizards.Messages.ConnectionWizardPage_STORE_CAPTION;
 69 	private static final String DIALOG_FOLDER_PROPERTIES_TITLE = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_FOLDER_PROPERTIES_TITLE_TEXT;
 70 	private static final String DIALOG_NEW_FOLDER_DEFAULT_VALUE = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_DIALOG_NEW_FOLDER_DEFAULT_VALUE;
 71 	private static final String DIALOG_NEW_FOLDER_TITLE = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_DIALOG_NEW_FOLDER_TITLE;
 72 	private static final String DIALOG_REMOVE_TITLE = org.openjdk.jmc.browser.views.Messages.JVMBrowserView_DIALOG_REMOVE_TITLE;
 73 	private static final String TOO_OLD_JVM_TITLE = org.openjdk.jmc.rjmx.messages.internal.Messages.JVMSupport_TITLE_LEGACY_JVM_CONSOLE;
 74 	private static final String LOCAL_PROVIDER_NAME = org.openjdk.jmc.browser.attach.Messages.LocalDescriptorProvider_PROVIDER_NAME;
 75 	private static final String COMMERCIAL_FEATURES_QUESTION_TITLE = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.COMMERCIAL_FEATURES_QUESTION_TITLE;
 76 	private static final String DIALOG_NEW_CONNECTION_TITLE = org.openjdk.jmc.browser.wizards.Messages.ConnectionWizard_TITLE_NEW_CONNECTION;
 77 	private static final String DIALOG_CONNECTION_PROPERTIES_TITLE = org.openjdk.jmc.browser.wizards.Messages.ConnectionWizard_TITLE_CONNECTION_PROPERTIES;
 78 	private static final String ExportToFileWizardPage_WARN_IF_OVERWRITE_TEXT = org.openjdk.jmc.ui.wizards.Messages.ExportToFileWizardPage_WARN_IF_OVERWRITE_TEXT;
 79 	private static final String JVM_BROWSER_TREE_NAME = org.openjdk.jmc.browser.views.JVMBrowserView.JVMBrowserView_TREE_NAME;
 80 	private static final String ACTION_DUMP_LAST_PART_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_DUMP_LAST_PART_RECORDING_LABEL;
 81 	private static final String ACTION_DUMP_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_DUMP_RECORDING_LABEL;
 82 	private static final String ACTION_DUMP_ANY_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_DUMP_ANY_RECORDING_LABEL;
 83 	private static final String ACTION_DUMP_WHOLE_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_DUMP_WHOLE_RECORDING_LABEL;
 84 	private static final String ACTION_STOP_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_STOP_RECORDING_LABEL;
 85 	private static final String ACTION_CLOSE_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_CLOSE_RECORDING_LABEL;
 86 	private static final String ACTION_EDIT_RECORDING_LABEL = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.ACTION_EDIT_RECORDING_LABEL;
 87 	private static final String DUMP_RECORDING_WIZARD_PAGE_TITLE = org.openjdk.jmc.flightrecorder.controlpanel.ui.messages.internal.Messages.DUMP_RECORDING_WIZARD_PAGE_TITLE;
 88 
 89 	private static final String TREE_ITEM_CONSOLE = &quot;MBean Server&quot;;
 90 	private static final String TREE_ITEM_FLIGHTRECORDER = &quot;Flight Recorder&quot;;
 91 	private static final String ACTION_START_CONSOLE_LABEL = &quot;Start JMX Console&quot;;
 92 	private static final String ACTION_START_FLIGHTRECORDER_LABEL = &quot;Start Flight Recording...&quot;;
 93 	private static final String ACTION_OPEN_PERSISTED_JMX_DATA = &quot;Open Persisted JMX Data&quot;;
 94 
 95 	private void ensureVisibleJvmBrowser() {
 96 		MC.closeWelcome();
 97 		MCMenu.ensureJvmBrowserVisible();
 98 	}
 99 
100 	private MCTree getTree() {
101 		ensureVisibleJvmBrowser();
102 		return MCTree.getByName(getShell(), JVM_BROWSER_TREE_NAME);
103 	}
104 
105 	private MCToolBar getToolBar() {
106 		ensureVisibleJvmBrowser();
107 		return MCToolBar.getByToolTip(getShell(), ACTION_TREE_LAYOUT_TOOLTIP);
108 	}
109 
110 	/**
111 	 * Opens a JMX console to the Test VM.
112 	 */
113 	public void connect() {
114 		connect(MCJemmyTestBase.TEST_CONNECTION);
115 	}
116 
117 	/**
118 	 * Opens a JMX console to the specified connection name. Will, depending on the layout of the
119 	 * JVM Browser, resolve the path to the connection
120 	 *
121 	 * @param name
122 	 *            the name of the process (local) to connect to
123 	 */
124 	public void connect(String name) {
125 		connect(true, createPathToLocalProcess(name));
126 	}
127 
128 	/**
129 	 * Opens a JMX console to the specified connection path. This will, contrary to method
130 	 * {@code connect(String name)}, NOT resolve the path depending of the JVM Browser layout.
131 	 *
132 	 * @param path
133 	 *            the path of the connection
134 	 */
135 	public void connectRaw(String ... path) {
136 		connect(true, path);
137 	}
138 
139 	/**
140 	 * Creates a new connection in the JVM Browser with the specified host and port, optionally with
141 	 * a specific name. This method doesn&#39;t validate the inputs, but it does attempt to validate
142 	 * that the connection is created, so if a test needs to verify the new connection dialog,
143 	 * specific code needs to be written for that with a {@link MCDialog}.
144 	 *
145 	 * @param host
146 	 *            the hostname for the connection
147 	 * @param port
148 	 *            the port for the connection
149 	 * @param user
150 	 *            the user name
151 	 * @param passwd
152 	 *            the password
153 	 * @param storeCredentials
154 	 *            {@code true} if credentials should be stored
155 	 * @param path
156 	 *            The path of the new connection, this can be either empty, in which case the
157 	 *            default naming scheme is used and the connection is created at the root level, or
158 	 *            it can be a list of strings representing the path of the new connection. If the
159 	 *            path is of length 1 and there is no item with that name, the new connection has
160 	 *            that string as the name, however, if that item exists then the new connection is
<a name="1" id="anc1"></a><span class="line-modified">161 	 *            created beneath that item using the default name. This is basically the same</span>
<span class="line-modified">162 	 *            for strings of length n &gt; 1.</span>
163 	 */
164 	public void createConnection(
165 		String host, String port, String user, String passwd, Boolean storeCredentials, String ... path) {
166 		String connectionName = null;
167 		String[] finalPath = null;
168 		if (itemExists(path)) { // if the path specified already exists then it&#39;s a folder
169 			getTree().select(path);
170 			getTree().contextChoose(ACTION_NEW_CONNECTION_TEXT);
171 			finalPath = Arrays.copyOf(path, path.length + 1); // we need to save the name of the folder path
172 			finalPath[finalPath.length - 1] = getDefaultConnectionName(host, port); // with auto generated name
173 		} else if (path.length &gt; 1) { // since the path doesn&#39;t exist, we have been specified a specific name
174 			String[] subPath = Arrays.copyOf(path, path.length - 1);
175 			getTree().select(subPath);
176 			getTree().contextChoose(ACTION_NEW_CONNECTION_TEXT);
177 			finalPath = path;
178 			connectionName = path[path.length - 1];
179 		} else {
180 			if (path.length == 1) {
181 				finalPath = Arrays.copyOf(path, path.length);
182 				connectionName = path[0];
183 			}
184 			getToolBar().clickToolItem(ACTION_NEW_CONNECTION_TOOLTIP);
185 		}
186 		MCDialog newConnection = new MCDialog(DIALOG_NEW_CONNECTION_TITLE);
187 		newConnection.enterText(ConnectionWizardPage.HOSTNAME_FIELD_NAME, host);
188 		newConnection.enterText(ConnectionWizardPage.PORT_FIELD_NAME, port);
189 		if (connectionName != null) {
190 			newConnection.enterText(ConnectionWizardPage.CONNECTIONNAME_FIELD_NAME, connectionName);
191 		}
192 		if (user != null) {
193 			newConnection.enterText(ConnectionWizardPage.USERNAME_FIELD_NAME, user);
194 		}
195 		if (passwd != null) {
196 			newConnection.enterText(ConnectionWizardPage.PASSWORD_FIELD_NAME, passwd);
197 		}
198 		if (storeCredentials != null) {
199 			MCButton.getByLabel(newConnection, ConnectionWizardPage_STORE_CAPTION, false).setState(storeCredentials);
200 		}
201 		newConnection.clickButton(MCButton.Labels.FINISH);
202 		waitForIdle();
203 		if (storeCredentials != null &amp;&amp; storeCredentials == true) {
204 			handleSetMasterPassword(passwd);
205 		}
206 		Assert.assertTrue(&quot;Unable to create item &quot; + Arrays.toString(finalPath) + &quot; from &quot; + Arrays.toString(path),
207 				itemExists(finalPath));
208 	}
209 
210 	/**
211 	 * Creates a new connection in the JVM Browser with the specified host and port, optionally with
212 	 * a specific name. This method doesn&#39;t validate the inputs, but it does attempt to validate
213 	 * that the connection is created, so if a test needs to verify the new connection dialog,
214 	 * specific code needs to be written for that with a {@link MCDialog}.
215 	 *
216 	 * @param host
217 	 *            the hostname for the connection
218 	 * @param port
219 	 *            the port for the connection
220 	 * @param path
221 	 *            The path of the new connection, this can be either empty, in which case the
222 	 *            default naming scheme is used and the connection is created at the root level, or
223 	 *            it can be a list of strings representing the path of the new connection. If the
224 	 *            path is of length 1 and there is no item with that name, the new connection has
225 	 *            that string as the name, however, if that item exists then the new connection is
<a name="2" id="anc2"></a><span class="line-modified">226 	 *            created beneath that item using the default name. This is basically the same</span>
<span class="line-modified">227 	 *            for strings of length n &gt; 1.</span>
228 	 */
229 	public void createConnection(String host, String port, String ... path) {
230 		createConnection(host, port, null, null, null, path);
231 	}
232 
233 	private String getDefaultConnectionName(String host, String port) {
234 		String name = &quot;&quot;;
235 		name += (host == null) ? &quot;localhost&quot; : host;
236 		name += &quot;:&quot;;
237 		name += (port == null) ? &quot;7091&quot; : port;
238 		return name;
239 	}
240 
241 	/**
242 	 * Creates a folder at the specified path
243 	 *
244 	 * @param path
245 	 *            the name/path of the folder, the new name will always be the last string entered
246 	 */
247 	public void createFolder(String ... path) {
248 		if (path.length &gt; 1) {
249 			String[] subPath = Arrays.copyOf(path, path.length - 1);
250 			getTree().select(subPath);
251 			getTree().contextChoose(ACTION_NEW_FOLDER_TEXT);
252 		} else {
253 			getToolBar().clickToolItem(ACTION_NEW_FOLDER_TOOLTIP);
254 		}
255 		MCDialog newFolder = new MCDialog(DIALOG_NEW_FOLDER_TITLE);
256 		newFolder.replaceText(DIALOG_NEW_FOLDER_DEFAULT_VALUE, path[path.length - 1]);
257 		newFolder.clickButton(MCButton.Labels.OK);
258 		waitForIdle();
259 		Assert.assertTrue(&quot;Failed creating new folder&quot;, itemExists(path));
260 	}
261 
262 	/**
263 	 * Deletes an item at the specified path.
264 	 *
265 	 * @param path
266 	 *            the path of the item to delete
267 	 */
268 	public void deleteItem(String ... path) {
269 		selectContextOption(ACTION_REMOVE_TEXT, path);
270 		MCDialog delete = new MCDialog(DIALOG_REMOVE_TITLE);
271 		delete.clickButton(MCButton.Labels.YES);
272 		waitForIdle();
273 		Assert.assertFalse(&quot;Failed deleting&quot;, itemExists(path));
274 	}
275 
276 	/**
277 	 * Makes sure that the JVM Browser is in non-tree (flat) mode
278 	 */
279 	public void disableTreeLayout() {
280 		setLayout(false);
281 	}
282 
283 	/**
284 	 * Finds out if the JVM Browser in tree layout mode
285 	 * 
286 	 * @return {@code true} if in tree mode, otherwise {@code false}
287 	 */
288 	public boolean isTreeLayout() {
289 		return getTree().hasItem(LOCAL_PROVIDER_NAME);
290 	}
291 
292 	private String[] createPathToLocalProcess(String processName) {
293 		if (isTreeLayout()) {
294 			return new String[] {LOCAL_PROVIDER_NAME, processName};
295 		} else {
296 			return new String[] {processName};
297 		}
298 	}
299 
300 	/**
301 	 * Closes the JMX console for the default test connection
302 	 */
303 	public void disconnect() {
304 		disconnect(createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
305 	}
306 
307 	/**
308 	 * Closes the JMX console of the specified connection name
309 	 *
310 	 * @param path
311 	 *            the name of the connection
312 	 */
313 	public void disconnect(String ... path) {
314 		selectContextOption(ACTION_DISCONNECT_TEXT, path);
315 		MCDialog disconnectDialog = new MCDialog(ACTION_DISCONNECT_TEXT);
316 		disconnectDialog.clickButton(MCButton.Labels.OK);
317 	}
318 
319 	/**
320 	 * Stops the named recording on the default test connection
321 	 *
322 	 * @param name
323 	 *            the name of the running recording
324 	 */
325 	public void stopRecording(String name) {
326 		stopRecording(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
327 	}
328 
329 	/**
330 	 * Stops the named recording on the specified connection path
331 	 *
332 	 * @param name
333 	 *            the name of the running recording
334 	 * @param path
335 	 *            the path to the connection for the running recording
336 	 */
337 	public void stopRecording(String name, String ... path) {
338 		selectContextOption(ACTION_STOP_RECORDING_LABEL, createRecordingPath(name, path));
339 	}
340 
341 	/**
342 	 * Closes the named recording on the default test connection
343 	 *
344 	 * @param name
345 	 *            the name of the running recording
346 	 */
347 	public void closeRecording(String name) {
348 		closeRecording(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
349 	}
350 
351 	/**
352 	 * Closes the named recording on the specified connection path
353 	 *
354 	 * @param name
355 	 *            the name of the running recording
356 	 * @param path
357 	 *            the path to the connection for the running recording
358 	 */
359 	public void closeRecording(String name, String ... path) {
360 		selectContextOption(ACTION_CLOSE_RECORDING_LABEL, createRecordingPath(name, path));
361 	}
362 
363 	/**
364 	 * Starts the dump default recording wizard on the default test connection
365 	 *
366 	 * @return a {@link MCDialog}
367 	 */
368 	public MCDialog dumpDefaultRecording() {
369 		return dumpDefaultRecording(createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
370 	}
371 
372 	/**
373 	 * Starts the dump default recording wizard on the specified connection path
374 	 *
375 	 * @param path
376 	 *            the path to the connection for the running recording
377 	 * @return a {@link MCDialog}
378 	 */
379 	public MCDialog dumpDefaultRecording(String ... path) {
380 		return doDumpRecording(ACTION_DUMP_ANY_RECORDING_LABEL, path);
381 	}
382 
383 	/**
384 	 * Double clicks a recording for the default test connection and returns immediately
385 	 *
386 	 * @param name
387 	 *            the name of the recording
388 	 * @return a {@link MCDialog}
389 	 */
390 	public MCDialog doubleClickRecording(String name) {
391 		return doubleClickRecording(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
392 	}
393 
394 	/**
395 	 * Double-clicks a recording for the specified connection and returns immediately
396 	 *
397 	 * @param name
398 	 *            the name of the recording
399 	 * @param path
400 	 *            the path of the connection
401 	 * @return a {@link MCDialog}
402 	 */
403 	public MCDialog doubleClickRecording(String name, String ... path) {
404 		getTree().selectAndClick(2, createRecordingPath(name, path));
405 		return MCDialog.getByAnyDialogTitle(false, DUMP_RECORDING_WIZARD_PAGE_TITLE);
406 	}
407 
408 	/**
409 	 * Starts the dump recording wizard on the named recording on the default test connection
410 	 *
411 	 * @param name
412 	 *            the name of the running recording
413 	 * @return a {@link MCDialog}
414 	 */
415 	public MCDialog dumpRecording(String name) {
416 		return dumpRecording(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
417 	}
418 
419 	/**
420 	 * Starts the dump recording wizard on the named recording on the specified connection path
421 	 *
422 	 * @param name
423 	 *            the name of the running recording
424 	 * @param path
425 	 *            the path to the connection or recording
426 	 * @return a {@link MCDialog}
427 	 */
428 	public MCDialog dumpRecording(String name, String ... path) {
429 		return doDumpRecording(ACTION_DUMP_RECORDING_LABEL, createRecordingPath(name, path));
430 	}
431 
432 	private MCDialog doDumpRecording(String actionName, String ... path) {
433 		selectContextOption(actionName, path);
434 		return MCDialog.getByAnyDialogTitle(false, DUMP_RECORDING_WIZARD_PAGE_TITLE);
435 	}
436 
437 	/**
438 	 * Starts the edit recording wizard on the named recording on the default test connection
439 	 *
440 	 * @param name
441 	 *            the name of the running recording
442 	 * @return a {@link JfrWizard}
443 	 */
444 	public JfrWizard editRecording(String name) {
445 		return editRecording(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
446 	}
447 
448 	/**
449 	 * Starts the edit recording wizard on the named recording on the specified connection path
450 	 *
451 	 * @param name
452 	 *            the name of the running recording
453 	 * @param path
454 	 *            the path to the connection for the running recording
455 	 * @return a {@link JfrWizard}
456 	 */
457 	public JfrWizard editRecording(String name, String ... path) {
458 		selectContextOption(ACTION_EDIT_RECORDING_LABEL, createRecordingPath(name, path));
459 		return new JfrWizard(JfrWizard.EDIT_RECORDING_WIZARD_PAGE_TITLE);
460 	}
461 
462 	/**
463 	 * Dumps all of the named recording on the default test connection
464 	 *
465 	 * @param name
466 	 *            the name of the running recording
467 	 */
468 	public void dumpWholeRecording(String name) {
469 		dumpWholeRecording(name, MCJemmyTestBase.TEST_CONNECTION);
470 	}
471 
472 	/**
473 	 * Dumps all of the named recording on the specified connection path
474 	 *
475 	 * @param name
476 	 *            the name of the running recording
477 	 * @param connection
478 	 *            the path to the connection for the running recording
479 	 */
480 	public void dumpWholeRecording(String name, String connection) {
481 		selectContextOption(ACTION_DUMP_WHOLE_RECORDING_LABEL,
482 				createRecordingPath(name, createPathToLocalProcess(connection)));
483 		waitForSubstringMatchedEditor(cleanConnectionName(connection));
484 	}
485 
486 	/**
487 	 * Dumps the last part of the named recording on the default test connection
488 	 *
489 	 * @param name
490 	 *            the name of the running recording
491 	 */
492 	public void dumpLastPartOfRecording(String name) {
493 		dumpLastPartOfRecording(name, MCJemmyTestBase.TEST_CONNECTION);
494 	}
495 
496 	/**
497 	 * Dumps the last part of the named recording on the specified connection path
498 	 *
499 	 * @param name
500 	 *            the name of the running recording
501 	 * @param connection
502 	 *            the path to the connection for the running recording
503 	 */
504 	public void dumpLastPartOfRecording(String name, String connection) {
505 		selectContextOption(ACTION_DUMP_LAST_PART_RECORDING_LABEL,
506 				createRecordingPath(name, createPathToLocalProcess(connection)));
507 		waitForSubstringMatchedEditor(cleanConnectionName(connection));
508 	}
509 
510 	private String cleanConnectionName(String connection) {
511 		return connection.replaceAll(&quot;[^A-Za-z0-9]&quot;, &quot;&quot;);
512 	}
513 
514 	/**
515 	 * Returns the filename of a currently running recording (on the default test connection)
516 	 *
517 	 * @param name
518 	 *            the name of the recording
519 	 * @return the file name
520 	 */
521 	public String getRunningRecordingFileName(String name) {
522 		return getRunningRecordingFileName(name, createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
523 	}
524 
525 	/**
526 	 * Returns the filename of a currently running recording
527 	 *
528 	 * @param name
529 	 *            the name of the recording
530 	 * @param path
531 	 *            the connection path
532 	 * @return the file name
533 	 */
534 	public String getRunningRecordingFileName(String name, String ... path) {
535 		// Open the editor on the recording to get the file name
536 		JfrWizard recordingwizard = editRecording(name, path);
537 		String fileName = recordingwizard.getFileName();
538 		recordingwizard.cancelWizard();
539 		return fileName;
540 	}
541 
542 	/**
543 	 * Edits a connection with the specified parameters. If a parameter is not null then that field
544 	 * is set to the parameter value
545 	 *
546 	 * @param name
547 	 *            the new name to give the connection
548 	 * @param host
549 	 *            the new host
550 	 * @param port
551 	 *            the new port
552 	 * @param user
553 	 *            the username to use in the jmx connection
554 	 * @param serverPasswd
555 	 *            the server password for the specified username
556 	 * @param mcPasswd
557 	 *            the password Mission Control uses to save the credentials locally
558 	 * @param save
559 	 *            whether or not to save the credentials locally
560 	 * @param path
561 	 *            the path of the connection to edit
562 	 */
563 	public void editConnection(
564 		String name, String host, String port, String user, String serverPasswd, String mcPasswd, Boolean save,
565 		String ... path) {
566 		MCMenu.ensureJvmBrowserVisible();
567 		getTree().select(path);
568 		getTree().contextChoose(ACTION_EDIT_TEXT);
569 		MCDialog properties = new MCDialog(DIALOG_CONNECTION_PROPERTIES_TITLE);
570 		if (host != null) {
571 			properties.enterText(ConnectionWizardPage.HOSTNAME_FIELD_NAME, host);
572 		}
573 		if (port != null) {
574 			properties.enterText(ConnectionWizardPage.PORT_FIELD_NAME, port);
575 		}
576 		if (user != null) {
577 			properties.enterText(ConnectionWizardPage.USERNAME_FIELD_NAME, user);
578 		}
579 		if (serverPasswd != null) {
580 			properties.enterText(ConnectionWizardPage.PASSWORD_FIELD_NAME, serverPasswd);
581 		}
582 		if (name != null) {
583 			properties.enterText(ConnectionWizardPage.CONNECTIONNAME_FIELD_NAME, name);
584 		}
585 		if (save != null) {
586 			properties.setButtonState(CONNECTION_WIZARD_STORE_CAPTION, save);
587 		}
588 		properties.clickButton(MCButton.Labels.FINISH);
589 	}
590 
591 	/**
592 	 * Makes sure that the JVM Browser is in tree mode
593 	 */
594 	public void enableTreeLayout() {
595 		setLayout(true);
596 	}
597 
598 	/**
<a name="3" id="anc3"></a><span class="line-modified">599 	 * Finds out whether or not a connection with the specified path exists </span>
600 	 *
601 	 * @param path
602 	 *            the path to find
603 	 * @return {@code true} if a connection is found, {@code false} if not.
604 	 */
605 	public boolean itemExists(String ... path) {
606 		return getTree().hasItem(path);
607 	}
608 
609 	/**
610 	 * Opens the persisted JMX data editor for the JVM running Mission Control.
611 	 */
612 	public void openPersistedJMXData() {
613 		openPersistedJMXData(createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
614 	}
615 
616 	/**
617 	 * Opens the persisted JMX data editor for the named connection.
618 	 *
619 	 * @param path
620 	 *            the path to the connection
621 	 */
622 	public void openPersistedJMXData(String ... path) {
623 		MCMenu.ensureJvmBrowserVisible();
624 		selectAction(TREE_ITEM_CONSOLE, path);
625 		getTree().contextChoose(ACTION_OPEN_PERSISTED_JMX_DATA);
626 		Assert.assertTrue(&quot;Unable to find console editor \&quot;Persisted JMX Data\&quot;&quot;,
627 				MCJemmyBase.waitForSubstringMatchedEditor(&quot;Persisted JMX Data&quot;));
628 	}
629 
630 	/**
631 	 * Renames a folder at the specified path
632 	 *
633 	 * @param newName
634 	 *            the new name for the folder
635 	 * @param path
636 	 *            the path of the folder to rename
637 	 */
638 	public void renameFolder(String newName, String ... path) {
639 		String[] finalPath = Arrays.copyOf(path, path.length);
640 		finalPath[path.length - 1] = newName;
641 		getTree().select(path);
642 		getTree().contextChoose(ACTION_EDIT_TEXT);
643 		MCDialog rename = new MCDialog(DIALOG_FOLDER_PROPERTIES_TITLE);
644 		rename.replaceText(path[path.length - 1], newName);
645 		rename.closeWithButton(MCButton.Labels.OK);
646 		waitForIdle();
647 		Assert.assertTrue(&quot;Failed to properly rename folder&quot;, itemExists(finalPath));
648 	}
649 
650 	/**
651 	 * Method used to start non-standard features. Also used to start standard-features with
652 	 * non-standard expected behavior, i.e. dynamic enablement dialog.
653 	 *
654 	 * @param path
655 	 *            the name of the connection to use
656 	 * @param option
657 	 *            the name of the feature to start
658 	 */
659 	public void selectContextOption(String option, String ... path) {
660 		MCMenu.ensureJvmBrowserVisible();
661 		getTree().select(path);
662 		getTree().contextChoose(option);
663 	}
664 
665 	/**
666 	 * Attempts to connect to an MBean Server without verifying the connection. If connecting to a
667 	 * pre-7u4 JVM the calling code may need to handle the resulting dialog
668 	 *
669 	 * @param path
670 	 *            the path of the connection
671 	 */
672 	public void unverifiedConnect(String ... path) {
673 		connect(false, path);
674 	}
675 
676 	/**
677 	 * Starts the Flight Recording wizard for the test connection
678 	 *
679 	 * @return the Flight Recording wizard dialog ({@link JfrWizard})
680 	 */
681 	public JfrWizard startFlightRecordingWizard() {
682 		return startFlightRecordingWizard(createPathToLocalProcess(MCJemmyTestBase.TEST_CONNECTION));
683 	}
684 
685 	/**
686 	 * Starts the Flight Recording wizard for the connection with the given path
687 	 *
688 	 * @param path
689 	 *            the path to the connection for which to start the flight recording
690 	 * @return the Flight Recording wizard dialog ({@link JfrWizard})
691 	 */
692 	public JfrWizard startFlightRecordingWizard(String ... path) {
693 		return startFlightRecordingWizard(false, path);
694 	}
695 
696 	/**
697 	 * Starts the Flight Recording wizard for the connection with the given path
698 	 *
699 	 * @param enableCommercialFeatures
700 	 *            {@code true} if a dialog for dynamically enabling commercial features is expected.
701 	 *            Otherwise {@code false}
702 	 * @param path
703 	 *            the path to the connection for which to start the flight recording
704 	 * @return the Flight Recording wizard dialog ({@link JfrWizard})
705 	 */
706 	public JfrWizard startFlightRecordingWizard(boolean enableCommercialFeatures, String ... path) {
707 		MCMenu.ensureJvmBrowserVisible();
708 		selectAction(TREE_ITEM_FLIGHTRECORDER, path);
709 		getTree().contextChoose(ACTION_START_FLIGHTRECORDER_LABEL);
710 		if (enableCommercialFeatures) {
711 			MCDialog dialog = new MCDialog(COMMERCIAL_FEATURES_QUESTION_TITLE);
712 			dialog.closeWithButton(Labels.YES);
713 		}
714 		return new JfrWizard(JfrWizard.START_RECORDING_WIZARD_PAGE_TITLE);
715 	}
716 
717 	/**
718 	 * Exports connections to file, it does not assert that the file exists.
719 	 *
720 	 * @param fileName
721 	 *            the name of the file to export the connection(s) to
722 	 * @param names
723 	 *            the connection(s) to export.
724 	 */
725 	public void exportConnections(String fileName, String ... names) {
726 		MCDialog dialog = MCMenu.openExportDialog();
727 		MCTree tree = MCTree.getFirstVisible(dialog);
728 		tree.select(&quot;Mission Control&quot;, &quot;Connections&quot;);
729 		MCButton.getByLabel(dialog, MCButton.Labels.NEXT, false).click();
730 		tree = MCTree.getByName(dialog.getDialogShell(), ExportTreeToFileWizardPage_TREE_NAME);
731 		MCButton.getByLabel(dialog, ExportToFileWizardPage_WARN_IF_OVERWRITE_TEXT, false).setState(false);
732 		for (String name : names) {
733 			tree.select(name);
734 			tree.setSelectedItemState(true);
735 		}
736 		MCText.getByName(dialog, FileSelector.FILENAME_FIELD_NAME).setText(fileName);
737 		MCButton.getByLabel(dialog, MCButton.Labels.FINISH, false).click();
738 		sleep(1000);
739 	}
740 
741 	/**
742 	 * Attempts to import connections from the given filename.
743 	 *
744 	 * @param fileName
745 	 *            absolute URI for the file to import.
746 	 * @param fileExists
747 	 *            specifies if the file is expected to be found
748 	 */
749 	public void importConnections(String fileName, Boolean fileExists) {
750 		MCDialog dialog = MCMenu.openImportDialog();
751 		MCTree tree = MCTree.getFirstVisible(dialog);
752 		tree.select(&quot;Mission Control&quot;, &quot;Connections&quot;);
753 		MCButton.getByLabel(dialog, MCButton.Labels.NEXT, false).click();
754 		MCText.getByName(dialog, FileSelector.FILENAME_FIELD_NAME).setText(fileName);
755 
756 		if (fileExists) {
757 			MCButton.getByLabel(dialog, MCButton.Labels.FINISH, false).click();
758 		} else {
759 			Assert.assertFalse(&quot;Finish button not disabled&quot;,
760 					MCButton.getByLabel(dialog, MCButton.Labels.FINISH, false).isEnabled());
761 			Assert.assertFalse(&quot;Next button not disabled&quot;,
762 					MCButton.getByLabel(dialog, MCButton.Labels.NEXT, false).isEnabled());
763 			MCButton.getByLabel(dialog, MCButton.Labels.CANCEL, false).click();
764 		}
765 		sleep(1000);
766 	}
767 
768 	/**
769 	 * Handles the Set Master Password dialog.
770 	 *
771 	 * @param password
772 	 *            the password used as a new master password. Must be longer than five characters.
773 	 */
774 	public void handleSetMasterPassword(String password) {
<a name="4" id="anc4"></a><span class="line-modified">775 		MCDialog masterPasswordShell = MCDialog.getByAnyDialogTitle(</span>
<span class="line-removed">776 				MasterPasswordWizardPage_SET_MASTER_PASSWORD_TITLE,</span>
777 				MasterPasswordWizardPage_VERIFY_MASTER_PASSWORD_TITLE);
778 		if (masterPasswordShell.getText().equals(MasterPasswordWizardPage_SET_MASTER_PASSWORD_TITLE)) {
779 			masterPasswordShell.enterText(Constants.PASSWORD1_FIELD_NAME, password);
780 			masterPasswordShell.enterText(Constants.PASSWORD2_FIELD_NAME, password);
781 		} else {
782 			masterPasswordShell.enterText(Constants.PASSWORD1_FIELD_NAME, password);
783 		}
784 		masterPasswordShell.clickButton(MCButton.Labels.OK);
785 		sleep(1000);
786 	}
787 
788 	/**
789 	 * Opens a JMX console to the specified connection name. Will, depending on the layout of the
790 	 * JVM Browser, resolve the path to the connection
791 	 * 
792 	 * @param valid
793 	 *            will, if {@code true}, validate that an appropriate dialog or console editor is
794 	 *            opened
795 	 * @param path
796 	 *            the path of the connection
797 	 */
798 	public void connect(boolean valid, String ... path) {
799 		MCMenu.ensureJvmBrowserVisible();
800 		String connectionName = path[path.length - 1];
801 		selectAction(TREE_ITEM_CONSOLE, path);
802 		getTree().contextChoose(ACTION_START_CONSOLE_LABEL);
803 		if (valid) {
804 			if (!ConnectionHelper.is7u40orLater(connectionName)) {
805 				try {
806 					MCDialog dialog = new MCDialog(TOO_OLD_JVM_TITLE);
807 					dialog.closeWithButton(MCButton.Labels.OK);
808 				} catch (TimeoutExpiredException tee) {
809 					Assert.fail(&quot;JVM Too Old warning did not show.&quot;);
810 				}
811 			}
812 			Assert.assertTrue(&quot;Could not find JMX Console for connection \&quot;&quot; + connectionName + &quot;\&quot;&quot;,
813 					waitForSubstringMatchedEditor(connectionName));
814 		}
815 	}
816 
817 	/**
818 	 * Does substring matching of the specified recording name against the currently running
819 	 * recordings for the specified connection
820 	 *
821 	 * @param name
822 	 *            the name of the recording to search for
823 	 * @param path
824 	 *            the path to the connection
825 	 * @return {@code true} if there is a matching recording. Otherwise {@code false}
826 	 */
827 	public boolean hasRecording(String name, String ... path) {
828 		return checkHasRecording(name, getCurrentRecordings(path));
829 	}
830 
831 	/**
832 	 * Does substring matching of the specified recording name against the currently running
833 	 * recordings
834 	 *
835 	 * @param name
836 	 *            the name of the recording to search for
837 	 * @return {@code true} if there is a matching recording. Otherwise {@code false}
838 	 */
839 	public boolean hasRecording(String name) {
840 		return checkHasRecording(name, getCurrentRecordings());
841 	}
842 
843 	private boolean checkHasRecording(String name, List&lt;String&gt; recordings) {
844 		boolean result = false;
845 		for (String recording : recordings) {
846 			if (recording.contains(name)) {
847 				result = true;
848 				break;
849 			}
850 		}
851 		return result;
852 	}
853 
854 	/**
855 	 * Returns a list of currently running recordings for the default test connection
856 	 *
857 	 * @return a {@link List} of {@link String} of the currently running recordings. {@code null} if
858 	 *         no recordings could be found
859 	 */
860 	public List&lt;String&gt; getCurrentRecordings() {
861 		return getCurrentRecordings(MCJemmyTestBase.TEST_CONNECTION);
862 	}
863 
864 	/**
865 	 * Returns a list of strings containing the currently running recordings on this JVM
866 	 *
867 	 * @param path
868 	 *            the path to the connection
869 	 * @return a {@link List} of {@link String} of the currently running recordings. {@code null} if
870 	 *         no recordings could be found
871 	 */
872 	public List&lt;String&gt; getCurrentRecordings(String ... path) {
873 		MCMenu.ensureJvmBrowserVisible();
874 		getTree().select(createRecordingPath(null, path));
875 		getTree().expand();
876 		// wait for the node to expand and be populated (info retrieved from the JVM) before looking for an error dialog
877 		sleep(1000);
878 		MCDialog error = MCDialog.getByAnyDialogTitle(false, &quot;Problem retrieving information for&quot;);
879 		List&lt;String&gt; result = null;
880 		if (error != null) {
881 			error.closeWithButton(Labels.OK);
882 			// create and return an empty list
883 			result = new ArrayList&lt;&gt;();
884 		} else {
885 			result = getTree().getSelectedItemChildrenTexts();
886 		}
887 		return result;
888 	}
889 
890 	private String[] createRecordingPath(String recordingName, String ... path) {
891 		List&lt;String&gt; completePath = Arrays.asList(path).stream().collect(Collectors.toList());
892 		completePath.add(&quot;Flight Recorder&quot;);
893 		if (recordingName != null) {
894 			completePath.add(recordingName);
895 		}
896 		return completePath.toArray(new String[completePath.size()]);
897 	}
898 
899 	private void selectAction(String action, String ... path) {
900 		String[] actionPath = Arrays.copyOf(path, path.length + 1);
901 		actionPath[path.length] = action;
902 		getTree().select(actionPath);
903 	}
904 
905 	private void setLayout(boolean tree) {
906 		if (tree) {
907 			getToolBar().selectToolItem(ACTION_TREE_LAYOUT_TOOLTIP);
908 		} else {
909 			getToolBar().unselectToolItem(ACTION_TREE_LAYOUT_TOOLTIP);
910 		}
911 	}
912 
913 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>