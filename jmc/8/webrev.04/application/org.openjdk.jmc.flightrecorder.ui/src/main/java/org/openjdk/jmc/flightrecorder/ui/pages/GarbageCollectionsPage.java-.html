<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/GarbageCollectionsPage.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.pages;
 34 
 35 import static org.openjdk.jmc.common.item.Attribute.attr;
 36 import static org.openjdk.jmc.common.item.ItemQueryBuilder.fromWhere;
 37 import static org.openjdk.jmc.common.unit.UnitLookup.MEMORY;
 38 import static org.openjdk.jmc.flightrecorder.jdk.JdkAggregators.LONGEST_GC_PAUSE;
 39 import static org.openjdk.jmc.flightrecorder.jdk.JdkAggregators.TOTAL_GC_PAUSE;
 40 import static org.openjdk.jmc.flightrecorder.jdk.JdkQueries.HEAP_SUMMARY;
 41 import static org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit.createAggregatorCheckAction;
 42 import static org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit.createAttributeCheckAction;
 43 
 44 import java.awt.Color;
 45 import java.util.ArrayList;
 46 import java.util.Arrays;
 47 import java.util.HashMap;
 48 import java.util.Iterator;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Set;
 52 import java.util.function.Predicate;
 53 import java.util.function.Supplier;
 54 import java.util.stream.Collectors;
 55 import java.util.stream.Stream;
 56 
 57 import org.eclipse.jface.action.IAction;
 58 import org.eclipse.jface.resource.ImageDescriptor;
 59 import org.eclipse.jface.viewers.ArrayContentProvider;
 60 import org.eclipse.jface.viewers.CheckboxTableViewer;
 61 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 62 import org.eclipse.jface.viewers.IStructuredSelection;
 63 import org.eclipse.jface.viewers.TableViewer;
 64 import org.eclipse.swt.SWT;
 65 import org.eclipse.swt.custom.CTabFolder;
 66 import org.eclipse.swt.custom.SashForm;
 67 import org.eclipse.swt.layout.GridData;
 68 import org.eclipse.swt.layout.GridLayout;
 69 import org.eclipse.swt.widgets.Composite;
 70 import org.eclipse.ui.forms.widgets.Form;
 71 import org.eclipse.ui.forms.widgets.FormToolkit;
 72 
 73 import org.openjdk.jmc.common.IMCThread;
 74 import org.openjdk.jmc.common.IState;
 75 import org.openjdk.jmc.common.IWritableState;
 76 import org.openjdk.jmc.common.item.Aggregators;
 77 import org.openjdk.jmc.common.item.IAggregator;
 78 import org.openjdk.jmc.common.item.IAttribute;
 79 import org.openjdk.jmc.common.item.IItem;
 80 import org.openjdk.jmc.common.item.IItemCollection;
 81 import org.openjdk.jmc.common.item.IItemFilter;
 82 import org.openjdk.jmc.common.item.IItemIterable;
 83 import org.openjdk.jmc.common.item.IItemQuery;
 84 import org.openjdk.jmc.common.item.IMemberAccessor;
 85 import org.openjdk.jmc.common.item.IType;
 86 import org.openjdk.jmc.common.item.ItemFilters;
 87 import org.openjdk.jmc.common.item.ItemQueryBuilder;
 88 import org.openjdk.jmc.common.item.ItemToolkit;
 89 import org.openjdk.jmc.common.unit.IQuantity;
 90 import org.openjdk.jmc.common.unit.IRange;
 91 import org.openjdk.jmc.common.unit.LinearKindOfQuantity;
 92 import org.openjdk.jmc.common.unit.UnitLookup;
 93 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 94 import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
 95 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 96 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 97 import org.openjdk.jmc.flightrecorder.rules.jdk.memory.ReferenceStatisticsType;
 98 import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;
 99 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
100 import org.openjdk.jmc.flightrecorder.ui.IDataPageFactory;
101 import org.openjdk.jmc.flightrecorder.ui.IDisplayablePage;
102 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
103 import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
104 import org.openjdk.jmc.flightrecorder.ui.IPageUI;
105 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
106 import org.openjdk.jmc.flightrecorder.ui.StreamModel;
107 import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
108 import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
109 import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
110 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
111 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
112 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
113 import org.openjdk.jmc.flightrecorder.ui.common.ItemList;
114 import org.openjdk.jmc.flightrecorder.ui.common.ItemList.ItemListBuilder;
115 import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
116 import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
117 import org.openjdk.jmc.flightrecorder.ui.common.TypeLabelProvider;
118 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
119 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
120 import org.openjdk.jmc.ui.charts.AWTChartToolkit;
121 import org.openjdk.jmc.ui.charts.ISpanSeries;
122 import org.openjdk.jmc.ui.charts.IXDataRenderer;
123 import org.openjdk.jmc.ui.charts.QuantitySeries;
124 import org.openjdk.jmc.ui.charts.RendererToolkit;
125 import org.openjdk.jmc.ui.charts.SpanRenderer;
126 import org.openjdk.jmc.ui.charts.XYChart;
127 import org.openjdk.jmc.ui.column.ColumnBuilder;
128 import org.openjdk.jmc.ui.column.ColumnManager;
129 import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
130 import org.openjdk.jmc.ui.column.ColumnMenusFactory;
131 import org.openjdk.jmc.ui.column.IColumn;
132 import org.openjdk.jmc.ui.column.TableSettings;
133 import org.openjdk.jmc.ui.handlers.ActionToolkit;
134 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
135 import org.openjdk.jmc.ui.misc.ActionUiToolkit;
136 import org.openjdk.jmc.ui.misc.ChartCanvas;
137 import org.openjdk.jmc.ui.misc.PersistableSashForm;
138 
139 public class GarbageCollectionsPage extends AbstractDataPage {
140 	public static class GarbageCollectionPageFactory implements IDataPageFactory {
141 
142 		@Override
143 		public String getName(IState state) {
144 			return Messages.GarbageCollectionsPage_PAGE_NAME;
145 		}
146 
147 		@Override
148 		public ImageDescriptor getImageDescriptor(IState state) {
149 			return FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.PAGE_GC);
150 		}
151 
152 		@Override
153 		public String[] getTopics(IState state) {
154 			return new String[] {JfrRuleTopics.GARBAGE_COLLECTION_TOPIC};
155 		}
156 
157 		@Override
158 		public IDisplayablePage createPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {
159 			return new GarbageCollectionsPage(dpd, items, editor);
160 		}
161 	}
162 
163 	private static final ReferenceStatisticsType[] REF_TYPE = ReferenceStatisticsType.values();
164 	private static final String SASH = &quot;sash&quot;; //$NON-NLS-1$
165 	private static final String TABLE_SASH = &quot;tableSash&quot;; //$NON-NLS-1$
166 	private static final String THREAD_LANES = &quot;threadLane&quot;; //$NON-NLS-1$
167 	private static final String GCS = &quot;gcs&quot;; //$NON-NLS-1$
168 	private static final String CHART = &quot;chart&quot;; //$NON-NLS-1$
169 	private static final String PHASE_TABLE_FILTER = &quot;phaseTableFilter&quot;; //$NON-NLS-1$
170 	private static final String GC_TABLE_FILTER = &quot;gcTableFilter&quot;; //$NON-NLS-1$
171 	private static final String METASPACE_TABLE_FILTER = &quot;metaspaceTableFilter&quot;; //$NON-NLS-1$
172 	private static final String PHASE_LIST = &quot;phaseList&quot;; //$NON-NLS-1$
173 	private static final String METASPACE_LIST = &quot;metaspaceList&quot;; //$NON-NLS-1$
174 	private static final String ACTIVITY_LANES_ID = &quot;threadActivityLanes&quot;; //$NON-NLS-1$
175 
176 	private final static Color LONGEST_PAUSE_COLOR = DataPageToolkit.GC_BASE_COLOR.brighter();
177 	private final static Color SUM_OF_PAUSES_COLOR = DataPageToolkit.GC_BASE_COLOR.brighter().brighter();
178 
179 	public static final IAttribute&lt;IQuantity&gt; HEAP_USED_POST_GC = attr(&quot;heapUsed&quot;, Messages.ATTR_HEAP_USED_POST_GC, //$NON-NLS-1$
180 			Messages.ATTR_HEAP_USED_POST_GC_DESC, MEMORY);
181 
182 	public static final IItemQuery HEAP_SUMMARY_POST_GC = fromWhere(JdkFilters.HEAP_SUMMARY_AFTER_GC)
183 			.select(HEAP_USED_POST_GC).build();
184 	private final static IItemQuery METASPACE_SUMMARY = ItemQueryBuilder.fromWhere(JdkFilters.METASPACE_SUMMARY)
185 			.select(JdkAttributes.GC_METASPACE_USED, JdkAttributes.GC_METASPACE_CAPACITY,
186 					JdkAttributes.GC_METASPACE_COMMITTED, JdkAttributes.GC_METASPACE_RESERVED)
187 			.build();
188 
189 	private static class GC {
190 		final IType&lt;IItem&gt; type;
191 		final IItem gcItem;
192 		final Object[] referenceStatisticsData;
193 		IQuantity gcId;
194 		IQuantity duration;
195 		String gcCause;
196 		String gcName;
197 		IQuantity longestPause;
198 		IQuantity sumOfPauses;
199 		IQuantity startTime;
200 		IQuantity endTime;
201 		IQuantity usedDelta;
202 		IQuantity committedDelta;
203 		IQuantity usedMetaspaceDelta;
204 		IQuantity committedMetaspaceDelta;
205 
206 		GC(IItem gcItem, IType&lt;IItem&gt; type) {
207 			this.type = type;
208 			this.gcItem = gcItem;
209 			referenceStatisticsData = new Object[REF_TYPE.length];
210 			usedDelta = UnitLookup.BYTE.quantity(0);
211 			committedDelta = UnitLookup.BYTE.quantity(0);
212 			usedMetaspaceDelta = UnitLookup.BYTE.quantity(0);
213 			committedMetaspaceDelta = UnitLookup.BYTE.quantity(0);
214 		}
215 
216 		Object getRefCount(ReferenceStatisticsType type) {
217 			return referenceStatisticsData[type.ordinal()];
218 		}
219 
220 		void setRefCount(Object type, Object count) {
221 			for (int i = 0; i &lt; REF_TYPE.length; i++) {
222 				if (REF_TYPE[i].typeValue.equals(type)) {
223 					referenceStatisticsData[i] = count;
224 					break;
225 				}
226 			}
227 		}
228 	}
229 
230 	private static final ItemListBuilder PHASES = new ItemListBuilder();
231 	private static final ItemListBuilder METASPACE = new ItemListBuilder();
232 	static {
233 		PHASES.addColumn(JfrAttributes.EVENT_TYPE);
234 		PHASES.addColumn(JdkAttributes.GC_PHASE_NAME);
235 		PHASES.addColumn(JfrAttributes.DURATION);
236 		PHASES.addColumn(JfrAttributes.START_TIME);
237 		PHASES.addColumn(JfrAttributes.EVENT_THREAD);
238 		PHASES.addColumn(JdkAttributes.GC_ID);
239 
240 		METASPACE.addColumn(JdkAttributes.GC_METASPACE_USED);
241 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_COMMITTED);
242 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_RESERVED);
243 		METASPACE.addColumn(JdkAttributes.GC_DATASPACE_USED);
244 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_COMMITTED);
245 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_RESERVED);
246 		METASPACE.addColumn(JdkAttributes.GC_CLASSSPACE_USED);
247 		METASPACE.addColumn(JdkAttributes.GC_THRESHOLD);
248 		METASPACE.addColumn(JdkAttributes.GC_WHEN);
249 		METASPACE.addColumn(JdkAttributes.GC_ID);
250 		METASPACE.addColumn(JfrAttributes.START_TIME);
251 	}
252 
253 	private class GarbageCollectionsUi implements IPageUI {
254 
255 		private final SashForm sash;
256 		private final SashForm tableSash;
257 		private final IPageContainer pageContainer;
258 		private final ChartCanvas chartCanvas;
259 		private final ColumnManager gcList;
260 		private IXDataRenderer renderRoot = RendererToolkit.empty();
261 		private IAction GCEventThread = DataPageToolkit.createCheckAction(
262 				Messages.JavaApplicationPage_THREAD_ACTIVITY_ACTION,
263 				Messages.JavaApplicationPage_THREAD_ACTIVITY_ACTION_DESC, ACTIVITY_LANES_ID,
264 				FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES), b -&gt; buildChart());
265 		private final IAction enablePhases = ActionToolkit.checkAction(b -&gt; buildChart(),
266 				Messages.GarbageCollectionsPage_ROW_PAUSE_PHASES, Messages.GarbageCollectionsPage_ROW_PAUSE_PHASES_DESC,
267 				FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_PARTS), &quot;phases&quot;); //$NON-NLS-1$
268 		private final IAction longestPause = createAggregatorCheckAction(LONGEST_GC_PAUSE, &quot;longestPause&quot;, //$NON-NLS-1$
269 				LONGEST_PAUSE_COLOR, b -&gt; buildChart());
270 		private final IAction sumOfPauses = createAggregatorCheckAction(TOTAL_GC_PAUSE, &quot;sumOfPauses&quot;, //$NON-NLS-1$
271 				SUM_OF_PAUSES_COLOR, b -&gt; buildChart());
272 		private final List&lt;IAction&gt; allChartSeriesActions = Stream.concat(
273 				Stream.concat(HEAP_SUMMARY.getAttributes().stream(),
274 						Stream.concat(HEAP_SUMMARY_POST_GC.getAttributes().stream(), METASPACE_SUMMARY.getAttributes().stream()))
275 						.map(a -&gt; createAttributeCheckAction(a, b -&gt; buildChart())),
276 				Stream.of(longestPause, sumOfPauses, enablePhases, GCEventThread)).collect(Collectors.toList());
277 		private final Set&lt;String&gt; excludedAttributeIds;
278 		private FilterComponent tableFilter;
279 		private XYChart gcChart;
280 		private IRange&lt;IQuantity&gt; currentRange;
281 		private ItemList phasesList;
282 		private FilterComponent phasesFilter;
283 		private ItemList metaspaceList;
284 		private FilterComponent metaspaceFilter;
285 		private CTabFolder gcInfoFolder;
286 		private IItemCollection selectionItems;
287 		private FlavorSelector flavorSelector;
288 		private ThreadGraphLanes lanes;
289 		private MCContextMenuManager mm;
290 
291 		GarbageCollectionsUi(Composite parent, FormToolkit toolkit, IPageContainer pageContainer, IState state) {
292 			this.pageContainer = pageContainer;
293 			excludedAttributeIds = calculateExcludedAttributeIds(getDataSource().getItems());
294 			Form form = DataPageToolkit.createForm(parent, toolkit, getName(), getIcon());
295 			sash = new SashForm(form.getBody(), SWT.VERTICAL);
296 			toolkit.adapt(sash);
297 			tableSash = new SashForm(sash, SWT.HORIZONTAL);
298 			toolkit.adapt(tableSash);
299 
300 			TableViewer tableViewer = new TableViewer(tableSash,
301 					SWT.MULTI | SWT.VIRTUAL | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION);
302 			tableViewer.setContentProvider(ArrayContentProvider.getInstance());
303 			ColumnViewerToolTipSupport.enableFor(tableViewer);
304 			List&lt;IColumn&gt; columns = new ArrayList&lt;&gt;();
305 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_ID, o -&gt; ((GC) o).gcId));
306 			columns.add(buildGCItemAttributeColumn(JfrAttributes.DURATION, o -&gt; ((GC) o).duration));
307 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_CAUSE, o -&gt; ((GC) o).gcCause));
308 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_NAME, o -&gt; ((GC) o).gcName));
309 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_LONGEST_PAUSE, o -&gt; ((GC) o).longestPause));
310 			columns.add(buildGCItemAttributeColumn(JdkAttributes.GC_SUM_OF_PAUSES, o -&gt; ((GC) o).sumOfPauses));
311 			columns.add(buildGCItemAttributeColumn(JfrAttributes.START_TIME, o -&gt; ((GC) o).startTime));
312 			columns.add(buildGCItemAttributeColumn(JfrAttributes.END_TIME, o -&gt; ((GC) o).endTime));
313 			for (ReferenceStatisticsType t : REF_TYPE) {
314 				columns.add(new ColumnBuilder(t.localizedName, &quot;ReferenceStatisticsType-&quot; + t.name(), //$NON-NLS-1$
315 						o -&gt; ((GC) o).getRefCount(t)).style(SWT.RIGHT).build());
316 			}
317 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_USED_HEAP_DELTA, &quot;usedHeapDelta&quot;, //$NON-NLS-1$
318 					o -&gt; ((GC) o).usedDelta).style(SWT.RIGHT).build());
319 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_COMMITTED_HEAP_DELTA, &quot;committedHeapDelta&quot;, //$NON-NLS-1$
320 					o -&gt; ((GC) o).committedDelta).style(SWT.RIGHT).build());
321 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_USED_METASPACE_DELTA, &quot;usedMetaspaceDelta&quot;, //$NON-NLS-1$
322 					o -&gt; ((GC) o).usedMetaspaceDelta).style(SWT.RIGHT).build());
323 			columns.add(new ColumnBuilder(Messages.GarbageCollectionsPage_COMMITTED_METASPACE_DELTA,
324 					&quot;committedMetaspaceDelta&quot;, o -&gt; ((GC) o).committedMetaspaceDelta).style(SWT.RIGHT).build()); //$NON-NLS-1$
325 
326 			gcList = ColumnManager.build(tableViewer, columns, TableSettings.forState(state.getChild(GCS)));
327 			MCContextMenuManager itemListMm = MCContextMenuManager.create(gcList.getViewer().getControl());
328 			ColumnMenusFactory.addDefaultMenus(gcList, itemListMm);
329 			gcList.getViewer().addSelectionChangedListener(e -&gt; {
330 				buildChart();
331 				pageContainer.showSelection(ItemCollectionToolkit.build(gcSelectedGcItems()));
332 				updatePhaseList();
333 				updateMetaspaceList();
334 			});
335 
336 			SelectionStoreActionToolkit.addSelectionStoreActions(gcList.getViewer(), pageContainer.getSelectionStore(),
337 					() -&gt; ItemCollectionToolkit.build(gcSelectedGcItems()),
338 					Messages.GarbageCollectionsPage_LIST_SELECTION, itemListMm);
339 			tableFilter = FilterComponent.createFilterComponent(tableViewer.getControl(), gcList, tableFilterState,
340 					getDataSource().getItems().apply(JdkFilters.GARBAGE_COLLECTION),
341 					pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
342 			itemListMm.add(tableFilter.getShowFilterAction());
343 			itemListMm.add(tableFilter.getShowSearchAction());
344 
345 			gcInfoFolder = new CTabFolder(tableSash, SWT.NONE);
346 			phasesList = PHASES.buildWithoutBorder(gcInfoFolder, TableSettings.forState(state.getChild(PHASE_LIST)));
347 			phasesList.getManager().getViewer().addSelectionChangedListener(e -&gt; {
348 					buildChart();	
349 					pageContainer.showSelection(ItemCollectionToolkit.build(phasesList.getSelection().get()));
350 			});
351 			phasesFilter = FilterComponent.createFilterComponent(phasesList, phasesFilterState,
352 					getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE),
353 					pageContainer.getSelectionStore()::getSelections, this::onPhasesFilterChange);
354 			MCContextMenuManager phasesMm = MCContextMenuManager
355 					.create(phasesList.getManager().getViewer().getControl());
356 			ColumnMenusFactory.addDefaultMenus(phasesList.getManager(), phasesMm);
357 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), phasesList,
358 					Messages.GarbageCollectionsPage_PAUSE_PHASE_SELECTION, phasesMm);
359 			phasesMm.add(phasesFilter.getShowFilterAction());
360 			phasesMm.add(phasesFilter.getShowSearchAction());
361 			DataPageToolkit.addTabItem(gcInfoFolder, phasesFilter.getComponent(),
362 					Messages.GarbageCollectionsPage_PAUSE_PHASES_TITLE);
363 
364 			metaspaceList = METASPACE.buildWithoutBorder(gcInfoFolder,
365 					TableSettings.forState(state.getChild(METASPACE_LIST)));
366 			metaspaceList.getManager().getViewer().addSelectionChangedListener(
367 					e -&gt; pageContainer.showSelection(ItemCollectionToolkit.build(metaspaceList.getSelection().get())));
368 			metaspaceFilter = FilterComponent.createFilterComponent(metaspaceList, metaspaceFilterState,
369 					getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY),
370 					pageContainer.getSelectionStore()::getSelections, this::onMetaspaceFilterChange);
371 			MCContextMenuManager metaspaceMm = MCContextMenuManager
372 					.create(metaspaceList.getManager().getViewer().getControl());
373 			ColumnMenusFactory.addDefaultMenus(metaspaceList.getManager(), metaspaceMm);
374 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), metaspaceList,
375 					Messages.GarbageCollectionsPage_METASPACE_SELECTION, metaspaceMm);
376 			metaspaceMm.add(metaspaceFilter.getShowFilterAction());
377 			metaspaceMm.add(metaspaceFilter.getShowSearchAction());
378 			DataPageToolkit.addTabItem(gcInfoFolder, metaspaceFilter.getComponent(),
379 					Messages.GarbageCollectionsPage_METASPACE_TITLE);
380 
381 			Composite chartContainer = toolkit.createComposite(sash);
382 			chartContainer.setLayout(new GridLayout(2, false));
383 			chartCanvas = new ChartCanvas(chartContainer);
384 			chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
385 			ActionToolkit.loadCheckState(state.getChild(CHART), allChartSeriesActions.stream());
386 			CheckboxTableViewer chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer,
387 					allChartSeriesActions.stream().filter(a -&gt; includeAttribute(a.getId())));
388 			GridData gd = new GridData(SWT.FILL, SWT.FILL, false, true);
389 			gd.widthHint = 180;
390 			chartLegend.getControl().setLayoutData(gd);
391 			lanes = new ThreadGraphLanes(() -&gt; getDataSource(), () -&gt; buildChart());
392 			lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANES)));
393 			IAction editLanesAction = ActionToolkit.action(() -&gt; lanes.openEditLanesDialog(mm, false),
394 					Messages.ThreadsPage_EDIT_LANES, FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT));
395 			form.getToolBarManager().add(editLanesAction);
396 			
397 			DataPageToolkit.createChartTimestampTooltip(chartCanvas);
398 			gcChart = new XYChart(pageContainer.getRecordingRange(), renderRoot, 180);
399 			gcChart.setVisibleRange(timelineRange.getStart(), timelineRange.getEnd());
400 			gcChart.addVisibleRangeListener(r -&gt; timelineRange = r);
401 
402 			PersistableSashForm.loadState(sash, state.getChild(SASH));
403 			PersistableSashForm.loadState(tableSash, state.getChild(TABLE_SASH));
404 
405 			flavorSelector = FlavorSelector.itemsWithTimerange(form, JdkFilters.GARBAGE_COLLECTION,
406 					getDataSource().getItems(), pageContainer, this::onInputSelected, this::onShow,
407 					flavorSelectorState);
408 
409 			gcInfoFolder.setSelection(gcInfoTabSelection);
410 			addResultActions(form);
411 			tableFilter.loadState(state.getChild(GC_TABLE_FILTER));
412 			phasesFilter.loadState(state.getChild(PHASE_TABLE_FILTER));
413 			metaspaceFilter.loadState(state.getChild(METASPACE_TABLE_FILTER));
414 			gcList.setSelectionState(gcListSelection);
415 			phasesList.getManager().setSelectionState(phasesSelection);
416 			metaspaceList.getManager().setSelectionState(metaspaceSelection);
417 			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
418 			lanes.updateContextMenu(mm, false);
419 			lanes.updateContextMenu(MCContextMenuManager.create(chartLegend.getControl()), true);
420 			
421 			// Older recordings may not have thread information in pause events.
422 			// In those cases there is no need for the thread activity actions.
423 			if (!getDataSource().getItems().apply(ItemFilters.and(ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD),
424 					JdkFilters.GC_PAUSE)).hasItems()) {
425 				editLanesAction.setEnabled(false);
426 				editLanesAction.setToolTipText(Messages.GarbageCollectionsPage_DISABLED_TOOLTIP);
427 				GCEventThread.setEnabled(false);
428 				GCEventThread.setDescription(Messages.GarbageCollectionsPage_DISABLED_TOOLTIP);
429 				for (IAction action : lanes.getContextMenuActions()) {
430 					action.setEnabled(false);
431 				}
432 			}
433 		}
434 
435 		private void updatePhaseList() {
436 			phasesList.show(ItemCollectionToolkit.filterIfNotNull(getPhaseItems(), phasesFilterState));
437 		}
438 
439 		private void updateMetaspaceList() {
440 			metaspaceList.show(ItemCollectionToolkit.filterIfNotNull(getMetaspaceItems(), metaspaceFilterState));
441 		}
442 
443 		private IItemCollection getMetaspaceItems() {
444 			Set&lt;IQuantity&gt; selectedGcIds = getSelectedGcIds();
445 			IItemCollection metaspaceItems = getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY)
446 					.apply(ItemFilters.memberOf(JdkAttributes.GC_ID, selectedGcIds));
447 			return metaspaceItems;
448 		}
449 
450 		private IItemCollection getPhaseItems() {
451 			Set&lt;IQuantity&gt; gcIds = getSelectedGcIds();
452 			IItemCollection gcIdPausePhases = getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE)
453 					.apply(ItemFilters.memberOf(JdkAttributes.GC_ID, gcIds));
454 			return gcIdPausePhases;
455 		}
456 
457 		private Set&lt;IQuantity&gt; getSelectedGcIds() {
458 			@SuppressWarnings(&quot;unchecked&quot;)
459 			List&lt;GC&gt; selected = ((IStructuredSelection) gcList.getViewer().getSelection()).toList();
460 			Set&lt;IQuantity&gt; gcIds = selected.stream()
461 					.map(gc -&gt; gc.type.getAccessor(JdkAttributes.GC_ID.getKey()).getMember(gc.gcItem))
462 					.collect(Collectors.toSet());
463 			return gcIds;
464 		}
465 
466 		private void onFilterChange(IItemFilter newFilter) {
467 			IItemCollection items = selectionItems != null ? selectionItems : getDataSource().getItems();
468 			items = items.apply(JdkFilters.GARBAGE_COLLECTION);
469 			if (tableFilter.isVisible()) {
470 				updateTable(ItemCollectionToolkit.filterIfNotNull(items, newFilter));
471 				Object input = gcList.getViewer().getInput();
472 				tableFilter.setColor(input instanceof Object[] &amp;&amp; ((Object[]) input).length &gt; 0 ? 1 : 0);
473 			} else {
474 				updateTable(items);
475 			}
476 			tableFilterState = newFilter;
477 		}
478 
479 		private void onPhasesFilterChange(IItemFilter filter) {
480 			phasesFilter.filterChangeHelper(filter, phasesList,
481 					getDataSource().getItems().apply(JdkFilters.GC_PAUSE_PHASE));
482 			phasesFilterState = filter;
483 		}
484 
485 		private void onMetaspaceFilterChange(IItemFilter filter) {
486 			metaspaceFilter.filterChangeHelper(filter, metaspaceList,
487 					getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY));
488 			metaspaceFilterState = filter;
489 		}
490 
491 		private ItemRow buildSpanRow(IItemCollection items, String typeId) {
492 			IItemCollection filtered = items.apply(ItemFilters.type(typeId));
493 			return new ItemRow(DataPageToolkit.buildSpanRenderer(filtered,
494 					AWTChartToolkit.staticColor(TypeLabelProvider.getColorOrDefault(typeId))), filtered);
495 		}
496 
497 		private void buildChart() {
498 			IItemCollection allItems = getDataSource().getItems();
499 			List&lt;IXDataRenderer&gt; rows = new ArrayList&lt;&gt;();
500 			Predicate&lt;IAttribute&lt;IQuantity&gt;&gt; legendFilter = this::isAttributeEnabled;
501 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_HEAP,
502 					Messages.GarbageCollectionsPage_ROW_HEAP_DESC, allItems, false, HEAP_SUMMARY, legendFilter,
503 					UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
504 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_HEAP_POST_GC,
505 					Messages.GarbageCollectionsPage_ROW_HEAP_POST_GC_DESC, allItems, false, HEAP_SUMMARY_POST_GC, legendFilter,
506 					UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
507 			DataPageToolkit.buildLinesRow(Messages.GarbageCollectionsPage_ROW_METASPACE,
508 					Messages.GarbageCollectionsPage_ROW_METASPACE_DESC, allItems, false, METASPACE_SUMMARY,
509 					legendFilter, UnitLookup.BYTE.quantity(0), null).ifPresent(rows::add);
510 			// Pauses
511 			List&lt;IXDataRenderer&gt; gcPauseRows = new ArrayList&lt;&gt;();
512 			IItemCollection pauseEvents = allItems.apply(JdkFilters.GC_PAUSE);
513 			if (longestPause.isChecked()) {
514 				gcPauseRows.add(DataPageToolkit.buildTimestampHistogramRenderer(pauseEvents, LONGEST_GC_PAUSE,
515 						LONGEST_PAUSE_COLOR));
516 			}
517 			if (sumOfPauses.isChecked()) {
518 				gcPauseRows.add(DataPageToolkit.buildTimestampHistogramRenderer(pauseEvents, TOTAL_GC_PAUSE,
519 						SUM_OF_PAUSES_COLOR));
520 			}
521 			if (!gcPauseRows.isEmpty()) {
522 				rows.add(RendererToolkit.layers(DataPageToolkit.buildGcPauseRow(allItems),
523 						RendererToolkit.uniformRows(gcPauseRows)));
524 			}
525 			// Phases
526 			if (enablePhases.isChecked()) {
527 				ItemRow pauses = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE);
528 				ItemRow l1 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L1);
529 				ItemRow l2 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L2);
530 				ItemRow l3 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L3);
531 				ItemRow l4 = buildSpanRow(allItems, JdkTypeIDs.GC_PAUSE_L4);
532 				rows.add(RendererToolkit.uniformRows(Arrays.asList(pauses, l1, l2, l3, l4), enablePhases.getText()));
533 			}
534 			IItemFilter pauseThreadsFilter = ItemFilters.and(JdkFilters.GC_PAUSE, ItemFilters.hasAttribute(JfrAttributes.EVENT_THREAD));
535 			// Thread information may not be available in earlier recordings, ensure we actually have items before proceeding
536 			if (GCEventThread.isChecked() &amp;&amp; phasesList.getSelection().get().count() &gt; 0 
537 					&amp;&amp; allItems.apply(pauseThreadsFilter).hasItems()) {
538 				// Get the event threads from the selected events
539 				IAggregator&lt;Set&lt;IMCThread&gt;, ?&gt; distinctThreadsAggregator = Aggregators.distinct(JfrAttributes.EVENT_THREAD);
540 				IItemCollection items = ItemCollectionToolkit.build(phasesList.getSelection().get());
541 				Set&lt;IMCThread&gt; threads = items.getAggregate(distinctThreadsAggregator);
542 				List&lt;IXDataRenderer&gt; renderers = threads.stream().map((thread) -&gt;lanes.buildThreadRenderer(thread,
543 						getDataSource().getItems().apply(ItemFilters.equals(JfrAttributes.EVENT_THREAD, thread))))
544 						.collect(Collectors.toList());
545 				rows.add(RendererToolkit.uniformRows(renderers));
546 			}
547 
548 			renderRoot = RendererToolkit.layers(RendererToolkit.uniformRows(rows), buildTableSelectionRenderer());
549 			chartCanvas.replaceRenderer(renderRoot);
550 		}
551 
552 		private boolean isAttributeEnabled(IAttribute&lt;IQuantity&gt; attr) {
553 			String id = attr.getIdentifier();
554 			String name = attr.getName();
555 			return includeAttribute(id)
556 					&amp;&amp; allChartSeriesActions.stream().filter(a -&gt; name.equals(a.getText())).findAny().get().isChecked();
557 		}
558 
559 		private boolean includeAttribute(String attrId) {
560 			return !excludedAttributeIds.contains(attrId);
561 		}
562 
563 		private IXDataRenderer buildTableSelectionRenderer() {
564 			Supplier&lt;Stream&lt;? extends IItem&gt;&gt; phaseSelection = phasesList.getSelection();
565 			Stream&lt;? extends IItem&gt; gcItems = phaseSelection.get().count() &gt; 0 ? phaseSelection.get()
566 					: gcSelectedGcItems();
567 			ISpanSeries&lt;IItem&gt; gcBackdrop = QuantitySeries.max(ItemCollectionToolkit.build(gcItems),
568 					JfrAttributes.START_TIME, JfrAttributes.END_TIME);
569 			return SpanRenderer.build(gcBackdrop, AWTChartToolkit.staticColor(new Color(100, 180, 220, 150)));
570 		}
571 
572 		@Override
573 		public void saveTo(IWritableState memento) {
574 			PersistableSashForm.saveState(sash, memento.createChild(SASH));
575 			PersistableSashForm.saveState(tableSash, memento.createChild(TABLE_SASH));
576 			gcList.getSettings().saveState(memento.createChild(GCS));
577 			phasesList.getManager().getSettings().saveState(memento.createChild(PHASE_LIST));
578 			metaspaceList.getManager().getSettings().saveState(memento.createChild(METASPACE_LIST));
579 			ActionToolkit.saveCheckState(memento.createChild(CHART), allChartSeriesActions.stream());
580 			tableFilter.saveState(memento.createChild(GC_TABLE_FILTER));
581 			phasesFilter.saveState(memento.createChild(PHASE_TABLE_FILTER));
582 			metaspaceFilter.saveState(memento.createChild(METASPACE_TABLE_FILTER));
583 
584 			saveToLocal();
585 		}
586 
587 		private void saveToLocal() {
588 			gcListSelection = gcList.getSelectionState();
589 			phasesSelection = phasesList.getManager().getSelectionState();
590 			metaspaceSelection = metaspaceList.getManager().getSelectionState();
591 			gcInfoTabSelection = gcInfoFolder.getSelectionIndex();
592 			flavorSelectorState = flavorSelector.getFlavorSelectorState();
593 		}
594 
595 		private void updateTable(IItemCollection gcs) {
596 			Map&lt;Object, GC&gt; gcMap = new HashMap&lt;&gt;();
597 			gcs.forEach(is -&gt; {
598 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
599 				IMemberAccessor&lt;IQuantity, IItem&gt; durationAccessor = JfrAttributes.DURATION.getAccessor(is.getType());
600 				IMemberAccessor&lt;String, IItem&gt; causeAccessor = JdkAttributes.GC_CAUSE.getAccessor(is.getType());
601 				IMemberAccessor&lt;String, IItem&gt; nameAccessor = JdkAttributes.GC_NAME.getAccessor(is.getType());
602 				IMemberAccessor&lt;IQuantity, IItem&gt; longestPauseAccessor = JdkAttributes.GC_LONGEST_PAUSE
603 						.getAccessor(is.getType());
604 				IMemberAccessor&lt;IQuantity, IItem&gt; sumPauseAccessor = JdkAttributes.GC_SUM_OF_PAUSES
605 						.getAccessor(is.getType());
606 				IMemberAccessor&lt;IQuantity, IItem&gt; startTimeAccessor = JfrAttributes.START_TIME
607 						.getAccessor(is.getType());
608 				IMemberAccessor&lt;IQuantity, IItem&gt; endTimeAccessor = JfrAttributes.END_TIME.getAccessor(is.getType());
609 
610 				is.forEach(item -&gt; {
611 					GC value = new GC(item, is.getType());
612 					value.gcId = gcIdAccessor.getMember(item);
613 					value.duration = durationAccessor.getMember(item);
614 					value.gcCause = causeAccessor.getMember(item);
615 					value.gcName = nameAccessor.getMember(item);
616 					value.longestPause = longestPauseAccessor.getMember(item);
617 					value.sumOfPauses = sumPauseAccessor.getMember(item);
618 					value.startTime = startTimeAccessor.getMember(item);
619 					value.endTime = endTimeAccessor.getMember(item);
620 					logDuplicateGcId(gcMap.put(gcIdAccessor.getMember(item), value));
621 				});
622 			});
623 			IItemCollection refItems = getDataSource().getItems().apply(JdkFilters.REFERENCE_STATISTICS);
624 			refItems.forEach(is -&gt; {
625 				IMemberAccessor&lt;IQuantity, IItem&gt; gdIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
626 				IMemberAccessor&lt;String, IItem&gt; typeAccessor = JdkAttributes.REFERENCE_STATISTICS_TYPE
627 						.getAccessor(is.getType());
628 				IMemberAccessor&lt;IQuantity, IItem&gt; countAccessor = JdkAttributes.REFERENCE_STATISTICS_COUNT
629 						.getAccessor(is.getType());
630 				is.forEach(item -&gt; {
631 					GC gc = gcMap.get(gdIdAccessor.getMember(item));
632 					if (gc != null) {
633 						gc.setRefCount(typeAccessor.getMember(item), countAccessor.getMember(item));
634 					}
635 				});
636 			});
637 			IItemCollection heapItems = getDataSource().getItems().apply(JdkFilters.HEAP_SUMMARY);
638 			heapItems.forEach(is -&gt; {
639 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
640 				IMemberAccessor&lt;String, IItem&gt; gcWhenAccessor = JdkAttributes.GC_WHEN.getAccessor(is.getType());
641 				IMemberAccessor&lt;IQuantity, IItem&gt; usedHeapAccessor = JdkAttributes.HEAP_USED.getAccessor(is.getType());
642 				IMemberAccessor&lt;IQuantity, IItem&gt; committedHeapAccessor = JdkAttributes.GC_HEAPSPACE_COMMITTED
643 						.getAccessor(is.getType());
644 
645 				is.forEach(item -&gt; {
646 					GC gc = gcMap.get(gcIdAccessor.getMember(item));
647 					if (gc != null) {
648 						String when = gcWhenAccessor.getMember(item);
649 						if (&quot;Before GC&quot;.equals(when)) { //$NON-NLS-1$
650 							gc.usedDelta = gc.usedDelta.subtract(usedHeapAccessor.getMember(item));
651 							gc.committedDelta = gc.committedDelta.subtract(committedHeapAccessor.getMember(item));
652 						} else {
653 							gc.usedDelta = gc.usedDelta.add(usedHeapAccessor.getMember(item));
654 							gc.committedDelta = gc.committedDelta.add(committedHeapAccessor.getMember(item));
655 						}
656 					}
657 				});
658 			});
659 
660 			IItemCollection metaspaceItems = getDataSource().getItems().apply(JdkFilters.METASPACE_SUMMARY);
661 			metaspaceItems.forEach(is -&gt; {
662 				IMemberAccessor&lt;IQuantity, IItem&gt; gcIdAccessor = JdkAttributes.GC_ID.getAccessor(is.getType());
663 				IMemberAccessor&lt;String, IItem&gt; gcWhenAccessor = JdkAttributes.GC_WHEN.getAccessor(is.getType());
664 				IMemberAccessor&lt;IQuantity, IItem&gt; usedMetaspaceAccessor = JdkAttributes.GC_METASPACE_USED
665 						.getAccessor(is.getType());
666 				IMemberAccessor&lt;IQuantity, IItem&gt; committedMetaspaceAccessor = JdkAttributes.GC_METASPACE_COMMITTED
667 						.getAccessor(is.getType());
668 
669 				is.forEach(item -&gt; {
670 					GC gc = gcMap.get(gcIdAccessor.getMember(item));
671 					if (gc != null &amp;&amp; usedMetaspaceAccessor != null &amp;&amp; committedMetaspaceAccessor != null
672 							&amp;&amp; gcWhenAccessor != null) {
673 						String when = gcWhenAccessor.getMember(item);
674 						if (&quot;Before GC&quot;.equals(when)) { //$NON-NLS-1$
675 							gc.usedMetaspaceDelta = gc.usedMetaspaceDelta
676 									.subtract(usedMetaspaceAccessor.getMember(item));
677 							gc.committedMetaspaceDelta = gc.committedMetaspaceDelta
678 									.subtract(committedMetaspaceAccessor.getMember(item));
679 						} else {
680 							gc.usedMetaspaceDelta = gc.usedMetaspaceDelta.add(usedMetaspaceAccessor.getMember(item));
681 							gc.committedMetaspaceDelta = gc.committedMetaspaceDelta
682 									.add(committedMetaspaceAccessor.getMember(item));
683 						}
684 					}
685 				});
686 			});
687 			gcList.getViewer().setInput(gcMap.values().toArray());
688 		}
689 
690 		private void onShow(Boolean show) {
691 			IRange&lt;IQuantity&gt; range = show ? currentRange : pageContainer.getRecordingRange();
692 			gcChart.setVisibleRange(range.getStart(), range.getEnd());
693 			buildChart();
694 		}
695 
696 		private void updateChart() {
697 			DataPageToolkit.setChart(chartCanvas, gcChart, pageContainer::showSelection);
698 			SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), gcChart,
699 					JfrAttributes.LIFETIME, Messages.GarbageCollectionsPage_TIMELINE_SELECTION,
700 					chartCanvas.getContextMenu());
701 			buildChart();
702 		}
703 
704 		private void onInputSelected(IItemCollection items, IRange&lt;IQuantity&gt; timeRange) {
705 			this.currentRange = timeRange;
706 			selectionItems = items;
707 			IItemCollection gcs = items != null ? items : getDataSource().getItems();
708 			updateTable(gcs.apply(JdkFilters.GARBAGE_COLLECTION));
709 			updateChart();
710 		}
711 
712 		private Stream&lt;? extends IItem&gt; gcSelectedGcItems() {
713 			@SuppressWarnings(&quot;unchecked&quot;)
714 			List&lt;GC&gt; sel = ((IStructuredSelection) gcList.getViewer().getSelection()).toList();
715 			return sel.stream().map(gc -&gt; gc.gcItem);
716 		}
717 	}
718 
719 	private static void logDuplicateGcId(GC duplicateGC) {
720 		if (duplicateGC != null) {
721 			IQuantity gcID = JdkAttributes.GC_ID.getAccessor(ItemToolkit.getItemType(duplicateGC.gcItem))
722 					.getMember(duplicateGC.gcItem);
723 			FlightRecorderUI.getDefault().getLogger().severe(&quot;GC with id &quot; + gcID + &quot; is duplicated&quot;); //$NON-NLS-1$ //$NON-NLS-2$
724 		}
725 	}
726 
727 	private static IColumn buildGCItemAttributeColumn(IAttribute&lt;?&gt; a, IMemberAccessor&lt;?, Object&gt; cellAccessor) {
728 		int style = a.getContentType() instanceof LinearKindOfQuantity ? SWT.RIGHT : SWT.NONE;
729 		return new ColumnBuilder(a.getName(), a.getIdentifier(), cellAccessor).description(a.getDescription())
730 				.style(style).build();
731 	}
732 
733 	@Override
734 	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer pageContainer, IState state) {
735 		return new GarbageCollectionsUi(parent, toolkit, pageContainer, state);
736 	}
737 
738 	private IItemFilter tableFilterState;
739 	private IItemFilter phasesFilterState;
740 	private IItemFilter metaspaceFilterState;
741 	private IRange&lt;IQuantity&gt; timelineRange;
742 	private SelectionState gcListSelection;
743 	private SelectionState phasesSelection;
744 	private SelectionState metaspaceSelection;
745 	private int gcInfoTabSelection = 0;
746 	public FlavorSelectorState flavorSelectorState;
747 
748 	public GarbageCollectionsPage(IPageDefinition dpd, StreamModel items, IPageContainer editor) {
749 		super(dpd, items, editor);
750 		timelineRange = editor.getRecordingRange();
751 	}
752 
753 	@Override
754 	public IItemFilter getDefaultSelectionFilter() {
755 		return ItemFilters.or(JdkFilters.GC_PAUSE, JdkFilters.GC_PAUSE_PHASE, JdkFilters.HEAP_SUMMARY,
756 				JdkFilters.METASPACE_SUMMARY);
757 	}
758 
759 	private static Set&lt;String&gt; calculateExcludedAttributeIds(IItemCollection items) {
760 		// In JDK7 there are no metaspace events. In early JDK8
761 		// metaspace:committed is missing. In later JDK8 metaspace:capacity is
762 		// missing.
763 		Stream&lt;IAttribute&lt;?&gt;&gt; exclude = METASPACE_SUMMARY.getAttributes().stream();
764 		Iterator&lt;IItemIterable&gt; iterator = items.apply(METASPACE_SUMMARY.getFilter()).iterator();
765 		if (iterator.hasNext()) {
766 			IType&lt;IItem&gt; type = iterator.next().getType();
767 			exclude = exclude.filter(a -&gt; a.getAccessor(type) == null);
768 		}
769 		return exclude.map(IAttribute::getIdentifier).collect(Collectors.toSet());
770 	}
771 }
    </pre>
  </body>
</html>