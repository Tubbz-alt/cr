<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../jfrnext/impl/JFRNextClassVisitor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.agent.jfr;
 34 
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.logging.Level;
 38 import java.util.logging.Logger;
 39 
 40 import org.objectweb.asm.Type;
 41 import org.openjdk.jmc.agent.Method;
 42 import org.openjdk.jmc.agent.Parameter;
 43 import org.openjdk.jmc.agent.ReturnValue;
 44 import org.openjdk.jmc.agent.TransformDescriptor;

 45 import org.openjdk.jmc.agent.util.TypeUtils;
 46 
 47 public class JFRTransformDescriptor extends TransformDescriptor {
 48 	private final static String ATTRIBUTE_EVENT_NAME = &quot;name&quot;; //$NON-NLS-1$
 49 	private final static String ATTRIBUTE_JFR_EVENT_DESCRIPTION = &quot;description&quot;; //$NON-NLS-1$
 50 	private final static String ATTRIBUTE_JFR_EVENT_PATH = &quot;path&quot;; //$NON-NLS-1$
 51 	private final static String ATTRIBUTE_STACK_TRACE = &quot;stacktrace&quot;; //$NON-NLS-1$
 52 	private final static String ATTRIBUTE_RETHROW = &quot;rethrow&quot;; //$NON-NLS-1$
 53 
 54 	private final String classPrefix;
 55 	private final String eventDescription;
 56 	private final String eventClassName;
 57 	private final String eventName;
 58 	private final String eventPath;
 59 	private final boolean recordStackTrace;
 60 	private final boolean useRethrow;
 61 	private final boolean allowToString;
 62 	private final boolean allowConverter;
 63 	private final List&lt;Parameter&gt; parameters;
 64 	private final ReturnValue returnValue;
</pre>
<hr />
<pre>
126 	private String initializeEventName() {
127 		String eventName = getTransformationAttribute(ATTRIBUTE_EVENT_NAME);
128 		if (eventName == null || eventName.length() == 0) {
129 			eventName = getMethod().getName();
130 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
131 					&quot;Could not find an event name, generated one: &quot; + eventName); //$NON-NLS-1$
132 		}
133 		return eventName;
134 	}
135 
136 	private String initializeEventDescription() {
137 		String eventDescription = getTransformationAttribute(ATTRIBUTE_JFR_EVENT_DESCRIPTION);
138 		if (eventDescription == null || eventDescription.length() == 0) {
139 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
140 					&quot;Could not find an event description for &quot; + eventClassName); //$NON-NLS-1$
141 		}
142 		return eventDescription;
143 	}
144 
145 	private String initializeEventClassName() {
<span class="line-modified">146 		return TypeUtils.getPathPart(getClassName()) + getClassPrefix()</span>
147 				+ TypeUtils.deriveIdentifierPart(getEventName());
148 	}
149 
150 	private String initializeEventPath() {
151 		String eventPath = getTransformationAttribute(ATTRIBUTE_JFR_EVENT_PATH);
152 		if (eventPath == null || eventPath.length() == 0) {
153 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
154 					&quot;Could not find an event path for &quot; + eventClassName + &quot; Will use the class name as path.&quot;); //$NON-NLS-1$ //$NON-NLS-2$
155 			eventPath = eventClassName;
156 		}
157 		return eventPath;
158 	}
159 
160 	private boolean getBoolean(String attribute, boolean defaultValue) {
161 		String strVal = getTransformationAttribute(attribute);
162 		if (strVal == null || strVal.isEmpty()) {
163 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.FINE,
164 					&quot;The boolean attribute &quot; + attribute //$NON-NLS-1$
165 							+ &quot; was not set for the event &quot; + eventName + &quot;. Assuming &quot; + defaultValue + &quot;.&quot;); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
166 			return defaultValue;
</pre>
</td>
<td>
<hr />
<pre>
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.agent.jfr;
 34 
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.logging.Level;
 38 import java.util.logging.Logger;
 39 
 40 import org.objectweb.asm.Type;
 41 import org.openjdk.jmc.agent.Method;
 42 import org.openjdk.jmc.agent.Parameter;
 43 import org.openjdk.jmc.agent.ReturnValue;
 44 import org.openjdk.jmc.agent.TransformDescriptor;
<span class="line-added"> 45 import org.openjdk.jmc.agent.generated_events.Dummy;</span>
 46 import org.openjdk.jmc.agent.util.TypeUtils;
 47 
 48 public class JFRTransformDescriptor extends TransformDescriptor {
 49 	private final static String ATTRIBUTE_EVENT_NAME = &quot;name&quot;; //$NON-NLS-1$
 50 	private final static String ATTRIBUTE_JFR_EVENT_DESCRIPTION = &quot;description&quot;; //$NON-NLS-1$
 51 	private final static String ATTRIBUTE_JFR_EVENT_PATH = &quot;path&quot;; //$NON-NLS-1$
 52 	private final static String ATTRIBUTE_STACK_TRACE = &quot;stacktrace&quot;; //$NON-NLS-1$
 53 	private final static String ATTRIBUTE_RETHROW = &quot;rethrow&quot;; //$NON-NLS-1$
 54 
 55 	private final String classPrefix;
 56 	private final String eventDescription;
 57 	private final String eventClassName;
 58 	private final String eventName;
 59 	private final String eventPath;
 60 	private final boolean recordStackTrace;
 61 	private final boolean useRethrow;
 62 	private final boolean allowToString;
 63 	private final boolean allowConverter;
 64 	private final List&lt;Parameter&gt; parameters;
 65 	private final ReturnValue returnValue;
</pre>
<hr />
<pre>
127 	private String initializeEventName() {
128 		String eventName = getTransformationAttribute(ATTRIBUTE_EVENT_NAME);
129 		if (eventName == null || eventName.length() == 0) {
130 			eventName = getMethod().getName();
131 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
132 					&quot;Could not find an event name, generated one: &quot; + eventName); //$NON-NLS-1$
133 		}
134 		return eventName;
135 	}
136 
137 	private String initializeEventDescription() {
138 		String eventDescription = getTransformationAttribute(ATTRIBUTE_JFR_EVENT_DESCRIPTION);
139 		if (eventDescription == null || eventDescription.length() == 0) {
140 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
141 					&quot;Could not find an event description for &quot; + eventClassName); //$NON-NLS-1$
142 		}
143 		return eventDescription;
144 	}
145 
146 	private String initializeEventClassName() {
<span class="line-modified">147 		return TypeUtils.getPathPart(Dummy.class.getName().replace(&#39;.&#39;, &#39;/&#39;)) + getClassPrefix()</span>
148 				+ TypeUtils.deriveIdentifierPart(getEventName());
149 	}
150 
151 	private String initializeEventPath() {
152 		String eventPath = getTransformationAttribute(ATTRIBUTE_JFR_EVENT_PATH);
153 		if (eventPath == null || eventPath.length() == 0) {
154 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.INFO,
155 					&quot;Could not find an event path for &quot; + eventClassName + &quot; Will use the class name as path.&quot;); //$NON-NLS-1$ //$NON-NLS-2$
156 			eventPath = eventClassName;
157 		}
158 		return eventPath;
159 	}
160 
161 	private boolean getBoolean(String attribute, boolean defaultValue) {
162 		String strVal = getTransformationAttribute(attribute);
163 		if (strVal == null || strVal.isEmpty()) {
164 			Logger.getLogger(JFRTransformDescriptor.class.getName()).log(Level.FINE,
165 					&quot;The boolean attribute &quot; + attribute //$NON-NLS-1$
166 							+ &quot; was not set for the event &quot; + eventName + &quot;. Assuming &quot; + defaultValue + &quot;.&quot;); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
167 			return defaultValue;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../jfrnext/impl/JFRNextClassVisitor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>