diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/Parameter.java
@@ -36,12 +36,11 @@
 
 /**
  * Metadata for a parameter to be logged by the agent.
  */
 public final class Parameter {
-	public static final int INDEX_INVALID = -2;
-	public static final int INDEX_RETURN = -1;
+	public static final int INDEX_INVALID = -1;
 
 	private final int index;
 	private final String name;
 	private final String fieldName;
 	private final String description;
@@ -82,14 +81,10 @@
 
 	public String getFieldName() {
 		return fieldName;
 	}
 
-	public boolean isReturn() {
-		return index == INDEX_RETURN;
-	}
-
 	public boolean isInvalid() {
 		return index == INDEX_INVALID;
 	}
 
 	public String getConverterClassName() {
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java
--- /dev/null
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/ReturnValue.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.agent;
+
+import org.openjdk.jmc.agent.util.TypeUtils;
+
+/**
+ * Metadata for a return value to be logged by the agent.
+ */
+public final class ReturnValue {
+	private final String name;
+	private final String fieldName;
+	private final String description;
+	private final String contentType;
+
+	public ReturnValue(String name, String description, String contentType) {
+		this.name = name == null ? "Return Value" : name;
+		this.description = description;
+		this.contentType = contentType;
+		this.fieldName = "field" + TypeUtils.deriveIdentifierPart(this.name); //$NON-NLS-1$
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getDescription() {
+		return description;
+	}
+
+	public String getContentType() {
+		return contentType;
+	}
+
+	public String getFieldName() {
+		return fieldName;
+	}
+
+}
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/TransformDescriptor.java
@@ -103,12 +103,12 @@
 	 * @param parameters
 	 *            the parameters to include (see {@link Parameter}).
 	 * @return the instantiated {@link TransformDescriptor}.
 	 */
 	public static TransformDescriptor create(
-		String id, String internalName, Method method, Map<String, String> values, List<Parameter> parameters) {
-		return new JFRTransformDescriptor(id, internalName, method, values, parameters);
+		String id, String internalName, Method method, Map<String, String> values, List<Parameter> parameters, ReturnValue returnValue) {
+		return new JFRTransformDescriptor(id, internalName, method, values, parameters, returnValue);
 	}
 
 	@Override
 	public String toString() {
 		return String.format("TransformDescriptor [method:%s]", method.toString()); //$NON-NLS-1$
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java
@@ -48,19 +48,21 @@
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
 import org.openjdk.jmc.agent.Method;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.TransformDescriptor;
 import org.openjdk.jmc.agent.TransformRegistry;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 
 public class DefaultTransformRegistry implements TransformRegistry {
 	private static final String XML_ATTRIBUTE_NAME_ID = "id"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_NAME_EVENT = "event"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_METHOD_NAME = "method"; //$NON-NLS-1$
 	private static final String XML_ELEMENT_PARAMETER_NAME = "parameter"; //$NON-NLS-1$
+	private static final String XML_ELEMENT_RETURN_VALUE_NAME = "returnvalue"; //$NON-NLS-1$
 
 	// Global override section
 	private static final String XML_ELEMENT_CONFIGURATION = "config"; //$NON-NLS-1$
 	
 	// Logging
@@ -148,15 +150,16 @@
 		String id = streamReader.getAttributeValue("", XML_ATTRIBUTE_NAME_ID); //$NON-NLS-1$
 		streamReader.next();
 		Map<String, String> values = new HashMap<>();
 		List<Parameter> parameters = new LinkedList<>();
 		Method method = null;
+		ReturnValue[] returnValue = new ReturnValue[1];
 		while (streamReader.hasNext()) {
 			if (streamReader.isStartElement()) {
 				String name = streamReader.getName().getLocalPart();
 				if (XML_ELEMENT_METHOD_NAME.equals(name)) {
-					method = parseMethod(streamReader, parameters);
+					method = parseMethod(streamReader, parameters, returnValue);
 					continue;
 				}
 				streamReader.next();
 				if (streamReader.hasText()) {
 					String value = streamReader.getText();
@@ -172,11 +175,11 @@
 				}
 			}
 			streamReader.next();
 		}
 		transfer(globalDefaults, values);
-		return TransformDescriptor.create(id, getInternalName(values.get("class")), method, values, parameters); //$NON-NLS-1$
+		return TransformDescriptor.create(id, getInternalName(values.get("class")), method, values, parameters, returnValue[0]); //$NON-NLS-1$
 	}
 
 	private static void transfer(HashMap<String, String> globalDefaults, Map<String, String> values) {
 		for (Entry<String, String> entry : globalDefaults.entrySet()) {
 			if (!values.containsKey(entry.getKey())) {
@@ -254,15 +257,48 @@
 			streamReader.next();
 		}
 		return new Parameter(index, name, description, contentType, relationKey, converterClassName);
 	}
 
+	private static ReturnValue parseReturnValue(XMLStreamReader streamReader) throws XMLStreamException {
+		streamReader.next();
+		String name = null;
+		String description = null;
+		String contentType = null;
+
+		while (streamReader.hasNext()) {
+			if (streamReader.isStartElement()) {
+				String key = streamReader.getName().getLocalPart();
+				streamReader.next();
+				if (streamReader.hasText()) {
+					String value = streamReader.getText();
+					if (value != null) {
+						value = value.trim();
+					}
+					if ("name".equals(key)) { //$NON-NLS-1$
+						name = value;
+					} else if ("description".equals(key)) { //$NON-NLS-1$
+						description = value;
+					} else if ("contenttype".equals(key)) { //$NON-NLS-1$
+						contentType = value;
+					}
+				}
+			} else if (streamReader.isEndElement()) {
+				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(streamReader.getName().getLocalPart())) {
+					break;
+				}
+			}
+			streamReader.next();
+		}
+		return new ReturnValue(name, description, contentType);
+	}
+
 	private static String getInternalName(String className) {
 		return className.replace('.', '/');
 	}
 
-	private static Method parseMethod(XMLStreamReader streamReader, List<Parameter> parameters)
+	private static Method parseMethod(XMLStreamReader streamReader, List<Parameter> parameters, ReturnValue[] returnValue)
 			throws XMLStreamException {
 		streamReader.next();
 		String name = null;
 		String descriptor = null;
 		while (streamReader.hasNext()) {
@@ -273,10 +309,14 @@
 						String indexAttribute = streamReader.getAttributeValue(0);
 						parameters.add(parseParameter(Integer.parseInt(indexAttribute), streamReader));
 					}
 					continue;
 				}
+				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(key)) {
+					returnValue[0] = parseReturnValue(streamReader);
+					continue;
+				}
 				streamReader.next();
 				if (streamReader.hasText()) {
 					String value = streamReader.getText();
 					if ("name".equals(key)) { //$NON-NLS-1$
 						name = value;
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/JFRTransformDescriptor.java
@@ -38,10 +38,11 @@
 import java.util.logging.Logger;
 
 import org.objectweb.asm.Type;
 import org.openjdk.jmc.agent.Method;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.TransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class JFRTransformDescriptor extends TransformDescriptor {
 	private final static String ATTRIBUTE_EVENT_NAME = "name"; //$NON-NLS-1$
@@ -58,13 +59,14 @@
 	private final boolean recordStackTrace;
 	private final boolean useRethrow;
 	private final boolean allowToString;
 	private final boolean allowConverter;
 	private final List<Parameter> parameters;
+	private final ReturnValue returnValue;
 
 	public JFRTransformDescriptor(String id, String className, Method method,
-			Map<String, String> transformationAttributes, List<Parameter> parameters) {
+			Map<String, String> transformationAttributes, List<Parameter> parameters, ReturnValue returnValue) {
 		super(id, className, method, transformationAttributes);
 		classPrefix = initializeClassPrefix();
 		eventName = initializeEventName();
 		eventClassName = initializeEventClassName();
 		eventPath = initializeEventPath();
@@ -72,10 +74,11 @@
 		recordStackTrace = getBoolean(ATTRIBUTE_STACK_TRACE, true);
 		useRethrow = getBoolean(ATTRIBUTE_RETHROW, false);
 		allowToString = getBoolean(ATTRIBUTE_ALLOW_TO_STRING, false);
 		allowConverter = getBoolean(ATTRIBUTE_ALLOW_CONVERTER, false);
 		this.parameters = parameters;
+		this.returnValue = returnValue;
 	}
 
 	public String getEventClassName() {
 		return eventClassName;
 	}
@@ -173,10 +176,14 @@
 
 	public List<Parameter> getParameters() {
 		return parameters;
 	}
 
+	public ReturnValue getReturnValue() {
+		return returnValue;
+	}
+
 	public boolean isAllowedFieldType(Type type) {
 		if (isAllowToString()) {
 			return true;
 		}
 		return type.getSort() != Type.OBJECT && type.getSort() != Type.ARRAY;
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFREventClassGenerator.java
@@ -40,10 +40,11 @@
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class JFREventClassGenerator {
 	private static final String CLASS_NAME_INSTANT_EVENT = "com/oracle/jrockit/jfr/InstantEvent"; //$NON-NLS-1$
@@ -79,15 +80,14 @@
 	}
 
 	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td) {
 		Type[] args = Type.getArgumentTypes(td.getMethod().getSignature());
 		for (Parameter param : td.getParameters()) {
-			if (param.isReturn()) {
-				createField(cw, td, param, Type.getReturnType(td.getMethod().getSignature()));
-			} else {
-				createField(cw, td, param, args[param.getIndex()]);
-			}
+			createField(cw, td, param, args[param.getIndex()]);
+		}
+		if (td.getReturnValue() != null) {
+			createField(cw, td, td.getReturnValue(), Type.getReturnType(td.getMethod().getSignature()));
 		}
 	}
 
 	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Parameter param, Type type) {
 		if (!td.isAllowedFieldType(type)) {
@@ -115,10 +115,35 @@
 		}
 		av.visitEnd();
 		fv.visitEnd();
 	}
 
+	private static void createField(ClassWriter cw, JFRTransformDescriptor td, ReturnValue returnValue, Type type) {
+		if (!td.isAllowedFieldType(type)) {
+			Logger.getLogger(JFREventClassGenerator.class.getName())
+					.warning("Skipped generating field in event class for return value " + returnValue + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
+							+ " because of configuration settings!"); //$NON-NLS-1$
+			return;
+		}
+
+		String fieldType = getFieldType(type);
+
+		FieldVisitor fv = cw.visitField(Opcodes.ACC_PUBLIC, returnValue.getFieldName(), fieldType, null, null);
+		AnnotationVisitor av = fv.visitAnnotation("Lcom/oracle/jrockit/jfr/ValueDefinition;", true); //$NON-NLS-1$
+		if (returnValue.getName() != null) {
+			av.visit("name", returnValue.getName()); //$NON-NLS-1$
+		}
+		if (returnValue.getDescription() != null) {
+			av.visit("description", returnValue.getDescription()); //$NON-NLS-1$
+		}
+		if (returnValue.getContentType() != null) {
+			av.visitEnum("contentType", "Lcom/oracle/jrockit/jfr/ContentType;", returnValue.getContentType()); //$NON-NLS-1$ //$NON-NLS-2$
+		}
+		av.visitEnd();
+		fv.visitEnd();
+	}
+
 	private static String getFieldType(Type type) {
 		if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
 			return "Ljava/lang/String;"; //$NON-NLS-1$
 		}
 
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfr/impl/JFRMethodAdvisor.java
@@ -36,10 +36,11 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.commons.AdviceAdapter;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 /**
  * Code emitter for JFR distributed with pre-JDK 9 releases. Probably works with JRockit too. ;)
@@ -104,60 +105,66 @@
 		mv.visitTypeInsn(NEW, transformDescriptor.getEventClassName());
 		mv.visitInsn(DUP);
 		mv.visitInsn(DUP);
 		mv.visitMethodInsn(INVOKESPECIAL, transformDescriptor.getEventClassName(), "<init>", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		for (Parameter param : transformDescriptor.getParameters()) {
-			if (!param.isReturn()) {
-				Type argumentType = argumentTypesRef[param.getIndex()];
-				if (transformDescriptor.isAllowedFieldType(argumentType)) {
-					mv.visitInsn(DUP);
-					loadArg(param.getIndex());
-					writeParameter(param, argumentType);
-				}
+			Type argumentType = argumentTypesRef[param.getIndex()];
+			if (transformDescriptor.isAllowedFieldType(argumentType)) {
+				mv.visitInsn(DUP);
+				loadArg(param.getIndex());
+				writeParameter(param, argumentType);
 			}
 		}
 
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "begin", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		eventLocal = newLocal(eventType);
 		mv.visitVarInsn(ASTORE, eventLocal);
 	}
 
 	private void writeParameter(Parameter param, Type type) {
-		if (TypeUtils.shouldStringify(param, type)) {
-			TypeUtils.stringify(mv, param, type);
+		if (TypeUtils.shouldStringify(type)) {
+			TypeUtils.stringify(mv);
 			type = TypeUtils.STRING_TYPE;
 		}
 		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
 	}
 
+	private void writeReturnValue(ReturnValue returnValue, Type type) {
+		if (TypeUtils.shouldStringify(type)) {
+			TypeUtils.stringify(mv);
+			type = TypeUtils.STRING_TYPE;
+		}
+		putField(Type.getObjectType(transformDescriptor.getEventClassName()), returnValue.getFieldName(), type);
+	}
+
 	@Override
 	protected void onMethodExit(int opcode) {
 		if (opcode == ATHROW && !shouldInstrumentThrow) {
 			return;
 		}
 
 		if (returnTypeRef.getSort() != Type.VOID && opcode != ATHROW) {
-			Parameter returnParam = TypeUtils.findReturnParam(transformDescriptor.getParameters());
-			if (returnParam != null) {
-				emitSettingReturnParam(opcode, returnParam);
+			ReturnValue returnValue = transformDescriptor.getReturnValue();
+			if (returnValue != null) {
+				emitSettingReturnParam(opcode, returnValue);
 			}
 		}
 		commitEvent();
 	}
 
-	private void emitSettingReturnParam(int opcode, Parameter returnParam) {
+	private void emitSettingReturnParam(int opcode, ReturnValue returnValue) {
 		if (returnTypeRef.getSize() == 1) {
 			dup();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			swap();
 		} else {
 			dup2();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			dupX2();
 			pop();
 		}
-		writeParameter(returnParam, returnTypeRef);
+		writeReturnValue(returnValue, returnTypeRef);
 	}
 
 	private void commitEvent() {
 		mv.visitVarInsn(ALOAD, eventLocal);
 		mv.visitInsn(DUP);
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextEventClassGenerator.java
@@ -41,10 +41,11 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.openjdk.jmc.agent.Agent;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 public class JFRNextEventClassGenerator {
 	private static final String CLASS_EVENT = "jdk/jfr/Event"; //$NON-NLS-1$
@@ -65,15 +66,14 @@
 	}
 
 	private static void generateAttributeFields(ClassWriter cw, JFRTransformDescriptor td) {
 		Type[] args = Type.getArgumentTypes(td.getMethod().getSignature());
 		for (Parameter param : td.getParameters()) {
-			if (param.isReturn()) {
-				createField(cw, td, param, Type.getReturnType(td.getMethod().getSignature()));
-			} else {
-				createField(cw, td, param, args[param.getIndex()]);
-			}
+			createField(cw, td, param, args[param.getIndex()]);
+		}
+		if (td.getReturnValue() != null) {
+			createField(cw, td, td.getReturnValue(), Type.getReturnType(td.getMethod().getSignature()));
 		}
 	}
 
 	private static void createField(ClassWriter cw, JFRTransformDescriptor td, Parameter param, Type type) {
 		if (!td.isAllowedFieldType(type)) {
@@ -112,10 +112,49 @@
 
 		// FIXME: RelKey
 		fv.visitEnd();
 	}
 
+	private static void createField(ClassWriter cw, JFRTransformDescriptor td, ReturnValue returnValue, Type type) {
+		if (!td.isAllowedFieldType(type)) {
+			Logger.getLogger(JFRNextEventClassGenerator.class.getName())
+					.warning("Skipped generating field in event class for return value " + returnValue + " and type " + type //$NON-NLS-1$ //$NON-NLS-2$
+							+ " because of configuration settings!"); //$NON-NLS-1$
+			return;
+		}
+
+		String fieldType = getFieldType(type);
+
+		FieldVisitor fv = cw.visitField(Opcodes.ACC_PROTECTED, returnValue.getFieldName(), fieldType, null, null);
+
+		// Name
+		AnnotationVisitor av = fv.visitAnnotation("Ljdk/jfr/Label;", true);
+		av.visit("value", returnValue.getName());
+		av.visitEnd();
+
+		// Description
+		av = fv.visitAnnotation("Ljdk/jfr/Description;", true);
+		av.visit("value", returnValue.getDescription());
+		av.visitEnd();
+
+		// "ContentType"
+		// We support the old JDK 7 style content types transparently.
+		// We also support user defined content types and a single string value annotation parameter to the annotation.
+		String contentTypeAnnotation = getContentTypeAnnotation(returnValue.getContentType());
+		if (contentTypeAnnotation != null) {
+			String[] contentTypeAnnotationInfo = contentTypeAnnotation.split(";");
+			av = fv.visitAnnotation(contentTypeAnnotationInfo[0] + ";", true);
+			if (contentTypeAnnotationInfo.length > 1) {
+				av.visit("value", contentTypeAnnotationInfo[1]);
+			}
+			av.visitEnd();
+		}
+
+		// FIXME: RelKey
+		fv.visitEnd();
+	}
+
 	private static String getContentTypeAnnotation(String contentType) {
 		if (contentType == null) {
 			return null;
 		}
 		switch (contentType) {
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/jfrnext/impl/JFRNextMethodAdvisor.java
@@ -36,10 +36,11 @@
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.objectweb.asm.commons.AdviceAdapter;
 import org.openjdk.jmc.agent.Parameter;
+import org.openjdk.jmc.agent.ReturnValue;
 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
 import org.openjdk.jmc.agent.util.TypeUtils;
 
 /**
  * Code emitter for JFR next, i.e. the version of JFR distributed with JDK 9 and later.
@@ -104,60 +105,66 @@
 		mv.visitTypeInsn(NEW, transformDescriptor.getEventClassName());
 		mv.visitInsn(DUP);
 		mv.visitInsn(DUP);
 		mv.visitMethodInsn(INVOKESPECIAL, transformDescriptor.getEventClassName(), "<init>", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		for (Parameter param : transformDescriptor.getParameters()) {
-			if (!param.isReturn()) {
-				Type argumentType = argumentTypesRef[param.getIndex()];
-				if (transformDescriptor.isAllowedFieldType(argumentType)) {
-					mv.visitInsn(DUP);
-					loadArg(param.getIndex());
-					writeParameter(param, argumentType);
-				}
+			Type argumentType = argumentTypesRef[param.getIndex()];
+			if (transformDescriptor.isAllowedFieldType(argumentType)) {
+				mv.visitInsn(DUP);
+				loadArg(param.getIndex());
+				writeParameter(param, argumentType);
 			}
 		}
 
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "begin", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
 		eventLocal = newLocal(eventType);
 		mv.visitVarInsn(ASTORE, eventLocal);
 	}
 
 	private void writeParameter(Parameter param, Type type) {
-		if (TypeUtils.shouldStringify(param, type)) {
-			TypeUtils.stringify(mv, param, type);
+		if (TypeUtils.shouldStringify(type)) {
+			TypeUtils.stringify(mv);
 			type = TypeUtils.STRING_TYPE;
 		}
 		putField(Type.getObjectType(transformDescriptor.getEventClassName()), param.getFieldName(), type);
 	}
 
+	private void writeReturnValue(ReturnValue returnValue, Type type) {
+		if (TypeUtils.shouldStringify(type)) {
+			TypeUtils.stringify(mv);
+			type = TypeUtils.STRING_TYPE;
+		}
+		putField(Type.getObjectType(transformDescriptor.getEventClassName()), returnValue.getFieldName(), type);
+	}
+
 	@Override
 	protected void onMethodExit(int opcode) {
 		if (opcode == ATHROW && !shouldInstrumentThrow) {
 			return;
 		}
 
 		if (returnTypeRef.getSort() != Type.VOID && opcode != ATHROW) {
-			Parameter returnParam = TypeUtils.findReturnParam(transformDescriptor.getParameters());
-			if (returnParam != null) {
-				emitSettingReturnParam(opcode, returnParam);
+			ReturnValue returnValue = transformDescriptor.getReturnValue();
+			if (returnValue != null) {
+				emitSettingReturnParam(opcode, returnValue);
 			}
 		}
 		commitEvent();
 	}
 
-	private void emitSettingReturnParam(int opcode, Parameter returnParam) {
+	private void emitSettingReturnParam(int opcode, ReturnValue returnValue) {
 		if (returnTypeRef.getSize() == 1) {
 			dup();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			swap();
 		} else {
 			dup2();
 			mv.visitVarInsn(ALOAD, eventLocal);
 			dupX2();
 			pop();
 		}
-		writeParameter(returnParam, returnTypeRef);
+		writeReturnValue(returnValue, returnTypeRef);
 	}
 
 	private void commitEvent() {
 		mv.visitVarInsn(ALOAD, eventLocal);
 		mv.visitMethodInsn(INVOKEVIRTUAL, transformDescriptor.getEventClassName(), "commit", "()V", false); //$NON-NLS-1$ //$NON-NLS-2$
diff a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
--- a/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
+++ b/core/org.openjdk.jmc.agent/src/main/java/org/openjdk/jmc/agent/util/TypeUtils.java
@@ -35,19 +35,17 @@
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.security.ProtectionDomain;
-import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 import org.objectweb.asm.Type;
 import org.openjdk.jmc.agent.Agent;
-import org.openjdk.jmc.agent.Parameter;
 import org.openjdk.jmc.agent.jfr.impl.JFRUtils;
 
 /**
  * Helper methods for doing transforms.
  */
@@ -212,31 +210,22 @@
 			return fqcn.substring(lastSlashIndex + 1);
 		}
 		return fqcn;
 	}
 
-	public static void stringify(MethodVisitor mv, Parameter param, Type argumentType) {
+	public static void stringify(MethodVisitor mv) {
 		mv.visitMethodInsn(Opcodes.INVOKESTATIC, INAME, "toString", //$NON-NLS-1$
 				"(Ljava/lang/Object;)Ljava/lang/String;", false); //$NON-NLS-1$
 	}
 
-	public static boolean shouldStringify(Parameter param, Type argumentType) {
+	public static boolean shouldStringify(Type argumentType) {
 		if (argumentType.getSort() == Type.ARRAY || argumentType.getSort() == Type.OBJECT) {
 			return !argumentType.getInternalName().equals(STRING_INTERNAL_NAME);
 		}
 		return false;
 	}
 
-	public static Parameter findReturnParam(List<Parameter> parameters) {
-		for (Parameter p : parameters) {
-			if (p.isReturn()) {
-				return p;
-			}
-		}
-		return null;
-	}
-
 	/**
 	 * Transforms a FQN in internal form, so that it can be used in e.g. formal descriptors.
 	 *
 	 * @param className
 	 *            the fully qualified class name in internal form.
diff a/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml b/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
--- a/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
+++ b/core/org.openjdk.jmc.agent/src/test/resources/org/openjdk/jmc/agent/test/jfrprobes_template.xml
@@ -76,15 +76,14 @@
 				<parameter index="1">
 					<name>Long Attribute</name>
 					<description>The second parameter</description>
 					<contenttype>Bytes</contenttype>	
 				</parameter>
-				<parameter index="-1">
-					<name>Return Value</name>
+				<returnvalue>
 					<description>The return value</description>
 					<contenttype>None</contenttype>	
-				</parameter>				
+				</returnvalue>
 			</method>
 			<!-- location {ENTRY, EXIT, WRAP}-->
 			<location>WRAP</location>
 		</event>
 		<event id="demo.jfr.testI1">
@@ -117,15 +116,14 @@
 				<parameter index="1">
 					<name>Long Attribute</name>
 					<description>The second parameter</description>
 					<contenttype>Bytes</contenttype>	
 				</parameter>
-				<parameter index="-1">
-					<name>Return Value</name>
+				<returnvalue>
 					<description>The return value</description>
 					<contenttype>None</contenttype>	
-				</parameter>				
+				</returnvalue>
 			</method>
 		</event>
 		<event id="demo.jfr.testI3">
 			<name>JFR Hello World Instance Event 3 %TEST_NAME%</name>
 			<description>Defined in the xml file and added by the agent. Should record the parameters.</description>
@@ -185,15 +183,14 @@
 			<class>org.openjdk.jmc.agent.test.InstrumentMe</class>
 			<method>
 				<name>printInstanceHelloWorldJFR6</name>						
 				<descriptor>()D</descriptor>
 				<!-- Note that this will only work if we allow toString -->
-				<parameter index="-1">
-					<name>Return Value</name>
+				<returnvalue>
 					<description>A value between 0 and 100 (double)</description>
 					<contenttype>Percentage</contenttype>	
-				</parameter>
+				</returnvalue>
 			</method>
 		</event>
 		<event id="demo.jfr.testI7">
 			<name>JFR Hello World Instance Event 7 %TEST_NAME%</name>
 			<description>Defined in the xml file and added by the agent. The original method contains a try-catch clause.</description>
