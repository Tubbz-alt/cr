<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/scene/Parent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  29 import javafx.beans.property.ReadOnlyBooleanProperty;
  30 import javafx.beans.property.ReadOnlyBooleanWrapper;
  31 import javafx.collections.FXCollections;
  32 import javafx.collections.ListChangeListener.Change;
  33 import javafx.collections.ObservableList;
  34 import java.util.ArrayList;
  35 import java.util.HashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 
  39 import com.sun.javafx.util.TempState;
  40 import com.sun.javafx.util.Utils;
  41 import com.sun.javafx.collections.TrackableObservableList;
  42 import com.sun.javafx.collections.VetoableListDecorator;
  43 import javafx.css.Selector;
  44 import com.sun.javafx.css.StyleManager;
  45 import com.sun.javafx.geom.BaseBounds;
  46 import com.sun.javafx.geom.PickRay;
  47 import com.sun.javafx.geom.Point2D;
  48 import com.sun.javafx.geom.RectBounds;
  49 import com.sun.javafx.geom.transform.BaseTransform;
  50 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  51 import com.sun.javafx.scene.CssFlags;
  52 import com.sun.javafx.scene.DirtyBits;
  53 import com.sun.javafx.scene.input.PickResultChooser;
  54 import com.sun.javafx.sg.prism.NGGroup;
  55 import com.sun.javafx.sg.prism.NGNode;
  56 import com.sun.javafx.tk.Toolkit;
  57 import com.sun.javafx.scene.LayoutFlags;
  58 import com.sun.javafx.scene.NodeHelper;
  59 import com.sun.javafx.scene.ParentHelper;
  60 import com.sun.javafx.stage.WindowHelper;
  61 import java.util.Collections;
  62 import javafx.stage.Window;
  63 
  64 /**
  65  * The base class for all nodes that have children in the scene graph.
  66  * &lt;p&gt;
  67  * This class handles all hierarchical scene graph operations, including adding/removing
  68  * child nodes, marking branches dirty for layout and rendering, picking,
  69  * bounds calculations, and executing the layout pass on each pulse.
  70  * &lt;p&gt;
  71  * There are two direct concrete Parent subclasses
  72  * &lt;ul&gt;
  73  * &lt;li&gt;{@link Group} effects and transforms to be applied to a collection of child nodes.&lt;/li&gt;
  74  * &lt;li&gt;{@link javafx.scene.layout.Region} class for nodes that can be styled with CSS and layout children. &lt;/li&gt;
  75  * &lt;/ul&gt;
  76  *
  77  * @since JavaFX 2.0
  78  */
  79 public abstract class Parent extends Node {
  80     // package private for testing
  81     static final int DIRTY_CHILDREN_THRESHOLD = 10;
  82 
  83     // If set to true, generate a warning message whenever adding a node to a
  84     // parent if it is currently a child of another parent.
  85     private static final boolean warnOnAutoMove = PropertyHelper.getBooleanProperty(&quot;javafx.sg.warn&quot;);
  86 
  87     /**
  88      * Threshold when it&#39;s worth to populate list of removed children.
  89      */
  90     private static final int REMOVED_CHILDREN_THRESHOLD = 20;
  91 
  92     /**
  93      * Do not populate list of removed children when its number exceeds threshold,
  94      * but mark whole parent dirty.
  95      */
  96     private boolean removedChildrenOptimizationDisabled = false;
  97 
  98     static {
  99         // This is used by classes in different packages to get access to
 100         // private and package private methods.
 101         ParentHelper.setParentAccessor(new ParentHelper.ParentAccessor() {
 102             @Override
 103             public NGNode doCreatePeer(Node node) {
 104                 return ((Parent) node).doCreatePeer();
 105             }
 106 
 107             @Override
 108             public void doUpdatePeer(Node node) {
 109                 ((Parent) node).doUpdatePeer();
 110             }
 111 
 112             @Override
 113             public BaseBounds doComputeGeomBounds(Node node,
 114                     BaseBounds bounds, BaseTransform tx) {
 115                 return ((Parent) node).doComputeGeomBounds(bounds, tx);
 116             }
 117 
 118             @Override
 119             public boolean doComputeContains(Node node, double localX, double localY) {
 120                 return ((Parent) node).doComputeContains(localX, localY);
 121             }
 122 
 123             @Override
 124             public void doProcessCSS(Node node) {
 125                 ((Parent) node).doProcessCSS();
 126             }
 127 
 128             @Override
 129             public void doPickNodeLocal(Node node, PickRay localPickRay,
 130                     PickResultChooser result) {
 131                 ((Parent) node).doPickNodeLocal(localPickRay, result);
 132             }
 133 
 134             @Override
 135             public boolean pickChildrenNode(Parent parent, PickRay pickRay, PickResultChooser result) {
 136                 return parent.pickChildrenNode(pickRay, result);
 137             }
 138 
 139             @Override
 140             public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {
 141                 parent.setTraversalEngine(value);
 142             }
 143 
 144             @Override
 145             public ParentTraversalEngine getTraversalEngine(Parent parent) {
 146                 return parent.getTraversalEngine();
 147             }
 148 
 149             @Override
 150             public List&lt;String&gt; doGetAllParentStylesheets(Parent parent) {
 151                 return parent.doGetAllParentStylesheets();
 152             }
 153         });
 154     }
 155 
 156     /*
 157      * Note: This method MUST only be called via its accessor method.
 158      */
 159     private void doUpdatePeer() {
 160         final NGGroup peer = getPeer();
 161 
 162         if (Utils.assertionEnabled()) {
 163             List&lt;NGNode&gt; pgnodes = peer.getChildren();
 164             if (pgnodes.size() != pgChildrenSize) {
 165                 java.lang.System.err.println(&quot;*** pgnodes.size() [&quot; + pgnodes.size() + &quot;] != pgChildrenSize [&quot; + pgChildrenSize + &quot;]&quot;);
 166             }
 167         }
 168 
 169         if (isDirty(DirtyBits.PARENT_CHILDREN)) {
 170             // Whether a permutation, or children having been added or
 171             // removed, we&#39;ll want to clear out the PG side starting
 172             // from startIdx. We know that everything up to but not
 173             // including startIdx is identical between the FX and PG
 174             // sides, so we only need to update the remaining portion.
 175             peer.clearFrom(startIdx);
 176             for (int idx = startIdx; idx &lt; children.size(); idx++) {
 177                 peer.add(idx, children.get(idx).getPeer());
 178             }
 179             if (removedChildrenOptimizationDisabled) {
 180                 peer.markDirty();
 181                 removedChildrenOptimizationDisabled = false;
 182             } else {
 183                 if (removed != null &amp;&amp; !removed.isEmpty()) {
 184                     for(int i = 0; i &lt; removed.size(); i++) {
 185                         peer.addToRemoved(removed.get(i).getPeer());
 186                     }
 187                 }
 188             }
 189             if (removed != null) {
 190                 removed.clear();
 191             }
 192             pgChildrenSize = children.size();
 193             startIdx = pgChildrenSize;
 194         }
 195 
 196         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 197             computeViewOrderChildren();
 198             peer.setViewOrderChildren(viewOrderChildren);
 199         }
 200 
 201         if (Utils.assertionEnabled()) validatePG();
 202     }
 203 
 204 
 205     /***********************************************************************
 206      *                        Scenegraph Structure                         *
 207      *                                                                     *
 208      *  Functions and variables related to the scenegraph structure,       *
 209      *  modifying the structure, and walking the structure.                *
 210      *                                                                     *
 211      **********************************************************************/
 212 
 213     // Used to check for duplicate nodes
 214     private final Set&lt;Node&gt; childSet = new HashSet&lt;Node&gt;();
 215 
 216     // starting child index from which we need to send the children to the PGGroup
 217     private int startIdx = 0;
 218 
 219     // double of children in the PGGroup as of the last update
 220     private int pgChildrenSize = 0;
 221 
 222     void validatePG() {
 223         boolean assertionFailed = false;
 224         final NGGroup peer = getPeer();
 225         List&lt;NGNode&gt; pgnodes = peer.getChildren();
 226         if (pgnodes.size() != children.size()) {
 227             java.lang.System.err.println(&quot;*** pgnodes.size validatePG() [&quot; + pgnodes.size() + &quot;] != children.size() [&quot; + children.size() + &quot;]&quot;);
 228             assertionFailed = true;
 229         } else {
 230             for (int idx = 0; idx &lt; children.size(); idx++) {
 231                 Node n = children.get(idx);
 232                 if (n.getParent() != this) {
 233                     java.lang.System.err.println(&quot;*** this=&quot; + this + &quot; validatePG children[&quot; + idx + &quot;].parent= &quot; + n.getParent());
 234                     assertionFailed = true;
 235                 }
 236                 if (n.getPeer() != pgnodes.get(idx)) {
 237                     java.lang.System.err.println(&quot;*** pgnodes[&quot; + idx + &quot;] validatePG != children[&quot; + idx + &quot;]&quot;);
 238                     assertionFailed = true;
 239                 }
 240             }
 241         }
 242         if (assertionFailed) {
 243             throw new java.lang.AssertionError(&quot;validation of PGGroup children failed&quot;);
 244         }
 245 
 246     }
 247 
 248     void printSeq(String prefix, List&lt;Node&gt; nodes) {
 249         String str = prefix;
 250         for (Node nn : nodes) {
 251             str += nn + &quot; &quot;;
 252         }
 253         System.out.println(str);
 254     }
 255 
 256     /**
 257      * The viewOrderChildren is a list children sorted in decreasing viewOrder
 258      * order if it is not empty. Its size should always be equal to
 259      * children.size(). If viewOrderChildren is empty it implies that the
 260      * rendering order of the children is the same as the order in the children
 261      * list.
 262      */
 263     private final List&lt;Node&gt; viewOrderChildren = new ArrayList(1);
 264 
 265     void markViewOrderChildrenDirty() {
 266         NodeHelper.markDirty(this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
 267     }
 268 
 269     private void computeViewOrderChildren() {
 270         boolean viewOrderSet = false;
 271         for (Node child : children) {
 272             double vo = child.getViewOrder();
 273 
 274             if (!viewOrderSet &amp;&amp; vo != 0) {
 275                 viewOrderSet = true;
 276             }
 277         }
 278 
 279         viewOrderChildren.clear();
 280         if (viewOrderSet) {
 281             viewOrderChildren.addAll(children);
 282 
 283             // Sort in descending order (or big-to-small order)
 284             Collections.sort(viewOrderChildren, (Node a, Node b)
 285                     -&gt; a.getViewOrder() &lt; b.getViewOrder() ? 1
 286                             : a.getViewOrder() == b.getViewOrder() ? 0 : -1);
 287         }
 288     }
 289 
 290     // Call this method if children view order is needed for picking.
 291     // The returned list should be treated as read only.
 292     private List&lt;Node&gt; getOrderedChildren() {
 293         if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
 294             //Fix for JDK-8205092
 295             computeViewOrderChildren();
 296         }
 297         if (!viewOrderChildren.isEmpty()) {
 298             return viewOrderChildren;
 299         }
 300         return children;
 301     }
 302 
 303     // Variable used to indicate that the change to the children ObservableList is
 304     // a simple permutation as the result of a toFront or toBack operation.
 305     // We can avoid almost all of the processing of the on replace trigger in
 306     // this case.
 307     private boolean childrenTriggerPermutation = false;
 308 
 309     //accumulates all removed nodes between pulses, for dirty area calculation.
 310     private List&lt;Node&gt; removed;
 311 
 312     // set to true if either childRemoved or childAdded returns
 313     // true. These functions will indicate whether the geom
 314     // bounds for the parent have changed
 315     private boolean geomChanged;
 316     private boolean childSetModified;
 317     private final ObservableList&lt;Node&gt; children = new VetoableListDecorator&lt;Node&gt;(new TrackableObservableList&lt;Node&gt;() {
 318 
 319 
 320         protected void onChanged(Change&lt;Node&gt; c) {
 321             // proceed with updating the scene graph
 322             unmodifiableManagedChildren = null;
 323             boolean relayout = false;
 324             boolean viewOrderChildrenDirty = false;
 325 
 326             if (childSetModified) {
 327                 while (c.next()) {
 328                     int from = c.getFrom();
 329                     int to = c.getTo();
 330                     for (int i = from; i &lt; to; ++i) {
 331                         Node n = children.get(i);
 332                         if (n.getParent() != null &amp;&amp; n.getParent() != Parent.this) {
 333                             if (warnOnAutoMove) {
 334                                 java.lang.System.err.println(&quot;WARNING added to a new parent without first removing it from its current&quot;);
 335                                 java.lang.System.err.println(&quot;    parent. It will be automatically removed from its current parent.&quot;);
 336                                 java.lang.System.err.println(&quot;    node=&quot; + n + &quot; oldparent= &quot; + n.getParent() + &quot; newparent=&quot; + this);
 337                             }
 338                             n.getParent().children.remove(n);
 339                             if (warnOnAutoMove) {
 340                                 Thread.dumpStack();
 341                             }
 342                         }
 343                     }
 344 
 345                     List&lt;Node&gt; removed = c.getRemoved();
 346                     int removedSize = removed.size();
 347                     for (int i = 0; i &lt; removedSize; ++i) {
 348                         final Node n = removed.get(i);
 349                         if (n.isManaged()) {
 350                             relayout = true;
 351                         }
 352                     }
 353 
 354                     // Mark viewOrderChildrenDirty if there is modification to children list
 355                     // and view order was set on one or more of the children prior to this change
 356                     if (((removedSize &gt; 0) || (to - from) &gt; 0) &amp;&amp; !viewOrderChildren.isEmpty()) {
 357                         viewOrderChildrenDirty = true;
 358                     }
 359                     // update the parent and scene for each new node
 360                     for (int i = from; i &lt; to; ++i) {
 361                         Node node = children.get(i);
 362 
 363                         // Newly added node has view order set.
 364                         if (node.getViewOrder() != 0) {
 365                             viewOrderChildrenDirty = true;
 366                         }
 367                         if (node.isManaged() || (node instanceof Parent &amp;&amp; ((Parent) node).layoutFlag != LayoutFlags.CLEAN)) {
 368                             relayout = true;
 369                         }
 370                         node.setParent(Parent.this);
 371                         node.setScenes(getScene(), getSubScene(), /* reapplyCSS */ true);
 372                         // assert !node.boundsChanged;
 373                         if (node.isVisible()) {
 374                             geomChanged = true;
 375                             childIncluded(node);
 376                         }
 377                     }
 378                 }
 379 
 380                 // check to see if the number of children exceeds
 381                 // DIRTY_CHILDREN_THRESHOLD and dirtyChildren is null.
 382                 // If so, then we need to create dirtyChildren and
 383                 // populate it.
 384                 if (dirtyChildren == null &amp;&amp; children.size() &gt; DIRTY_CHILDREN_THRESHOLD) {
 385                     dirtyChildren
 386                             = new ArrayList&lt;Node&gt;(2 * DIRTY_CHILDREN_THRESHOLD);
 387                     // only bother populating children if geom has
 388                     // changed, otherwise there is no need
 389                     if (dirtyChildrenCount &gt; 0) {
 390                         int size = children.size();
 391                         for (int i = 0; i &lt; size; ++i) {
 392                             Node ch = children.get(i);
 393                             if (ch.isVisible() &amp;&amp; ch.boundsChanged) {
 394                                 dirtyChildren.add(ch);
 395                             }
 396                         }
 397                     }
 398                 }
 399             } else {
 400                 // If childSet was not modified, we still need to check whether the permutation
 401                 // did change the layout
 402                 layout_loop:while (c.next()) {
 403                     List&lt;Node&gt; removed = c.getRemoved();
 404                     for (int i = 0, removedSize = removed.size(); i &lt; removedSize; ++i) {
 405                         if (removed.get(i).isManaged()) {
 406                             relayout = true;
 407                             break layout_loop;
 408                         }
 409                     }
 410 
 411                     for (int i = c.getFrom(), to = c.getTo(); i &lt; to; ++i) {
 412                         if (children.get(i).isManaged()) {
 413                             relayout = true;
 414                             break layout_loop;
 415                         }
 416                     }
 417                 }
 418             }
 419 
 420 
 421             //
 422             // Note that the styles of a child do not affect the parent or
 423             // its siblings. Thus, it is only necessary to reapply css to
 424             // the Node just added and not to this parent and all of its
 425             // children. So the following call to reapplyCSS was moved
 426             // to Node.parentProperty. The original comment and code were
 427             // purposely left here as documentation should there be any
 428             // question about how the code used to work and why the change
 429             // was made.
 430             //
 431             // if children have changed then I need to reapply
 432             // CSS from this node on down
 433 //                reapplyCSS();
 434             //
 435 
 436             // request layout if a Group subclass has overridden doLayout OR
 437             // if one of the new children needs layout, in which case need to ensure
 438             // the needsLayout flag is set all the way to the root so the next layout
 439             // pass will reach the child.
 440             if (relayout) {
 441                 requestLayout();
 442             }
 443 
 444             if (geomChanged) {
 445                 NodeHelper.geomChanged(Parent.this);
 446             }
 447 
 448             // Note the starting index at which we need to update the
 449             // PGGroup on the next update, and mark the children dirty
 450             c.reset();
 451             c.next();
 452             if (startIdx &gt; c.getFrom()) {
 453                 startIdx = c.getFrom();
 454             }
 455 
 456             NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN);
 457             // Force synchronization to include the handling of invisible node
 458             // so that removed list will get cleanup to prevent memory leak.
 459             NodeHelper.markDirty(Parent.this, DirtyBits.NODE_FORCE_SYNC);
 460 
 461             if (viewOrderChildrenDirty) {
 462                 NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
 463             }
 464         }
 465 
 466     }) {
 467         @Override
 468         protected void onProposedChange(final List&lt;Node&gt; newNodes, int[] toBeRemoved) {
 469             final Scene scene = getScene();
 470             if (scene != null) {
 471                 Window w = scene.getWindow();
 472                 if (w != null &amp;&amp; WindowHelper.getPeer(w) != null) {
 473                     Toolkit.getToolkit().checkFxUserThread();
 474                 }
 475             }
 476             geomChanged = false;
 477 
 478             long newLength = children.size() + newNodes.size();
 479             int removedLength = 0;
 480             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 481                 removedLength += toBeRemoved[i + 1] - toBeRemoved[i];
 482             }
 483             newLength -= removedLength;
 484 
 485             // If the childrenTriggerPermutation flag is set, then we know it
 486             // is a simple permutation and no further checking is needed.
 487             if (childrenTriggerPermutation) {
 488                 childSetModified = false;
 489                 return;
 490             }
 491 
 492             // If the childrenTriggerPermutation flag is not set, then we will
 493             // check to see whether any element in the ObservableList has changed,
 494             // or whether the new ObservableList is a permutation on the existing
 495             // ObservableList. Note that even if the childrenModified flag is false,
 496             // we still have to check for duplicates. If it is a simple
 497             // permutation, we can avoid checking for cycles or other parents.
 498             childSetModified = true;
 499             if (newLength == childSet.size()) {
 500                 childSetModified = false;
 501                 for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 502                     Node n = newNodes.get(i);
 503                     if (!childSet.contains(n)) {
 504                         childSetModified = true;
 505                         break;
 506                     }
 507                 }
 508             }
 509 
 510             // Enforce scene graph invariants, and check for structural errors.
 511             //
 512             // 1. If a child has been added to this parent more than once,
 513             // then it is an error
 514             //
 515             // 2. If a child is a target of a clip, then it is an error.
 516             //
 517             // 3. If a node would cause a cycle, then it is an error.
 518             //
 519             // 4. If a node is null
 520             //
 521             // Note that if a node is the child of another parent, we will
 522             // implicitly remove the node from its former Parent after first
 523             // checking for errors.
 524 
 525             // iterate over the nodes that were removed and remove them from
 526             // the hash set.
 527             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 528                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 529                     childSet.remove(children.get(j));
 530                 }
 531             }
 532 
 533             try {
 534                 if (childSetModified) {
 535                     // check individual children before duplication test
 536                     // if done in this order, the exception is more specific
 537                     for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
 538                         Node node = newNodes.get(i);
 539                         if (node == null) {
 540                             throw new NullPointerException(
 541                                     constructExceptionMessage(
 542                                         &quot;child node is null&quot;, null));
 543                         }
 544                         if (node.getClipParent() != null) {
 545                             throw new IllegalArgumentException(
 546                                     constructExceptionMessage(
 547                                         &quot;node already used as a clip&quot;, node));
 548                         }
 549                         if (wouldCreateCycle(Parent.this, node)) {
 550                             throw new IllegalArgumentException(
 551                                     constructExceptionMessage(
 552                                         &quot;cycle detected&quot;, node));
 553                         }
 554                     }
 555                 }
 556 
 557                 childSet.addAll(newNodes);
 558                 if (childSet.size() != newLength) {
 559                     throw new IllegalArgumentException(
 560                             constructExceptionMessage(
 561                                 &quot;duplicate children added&quot;, null));
 562                 }
 563             } catch (RuntimeException e) {
 564                 //Return children to it&#39;s original state
 565                 childSet.clear();
 566                 childSet.addAll(children);
 567 
 568                 // rethrow
 569                 throw e;
 570             }
 571 
 572             // Done with error checking
 573 
 574             if (!childSetModified) {
 575                 return;
 576             }
 577 
 578             // iterate over the nodes that were removed and clear their
 579             // parent and scene. Add to them also to removed list for further
 580             // dirty regions calculation.
 581             if (removed == null) {
 582                 removed = new ArrayList&lt;Node&gt;();
 583             }
 584             if (removed.size() + removedLength &gt; REMOVED_CHILDREN_THRESHOLD || !isTreeVisible()) {
 585                 //do not populate too many children in removed list
 586                 removedChildrenOptimizationDisabled = true;
 587             }
 588             for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
 589                 for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
 590                     Node old = children.get(j);
 591                     final Scene oldScene = old.getScene();
 592                     if (oldScene != null) {
 593                         oldScene.generateMouseExited(old);
 594                     }
 595                     if (dirtyChildren != null) {
 596                         dirtyChildren.remove(old);
 597                     }
 598                     if (old.isVisible()) {
 599                         geomChanged = true;
 600                         childExcluded(old);
 601                     }
 602                     if (old.getParent() == Parent.this) {
 603                         old.setParent(null);
 604                         old.setScenes(null, null, /* reapplyCSS */ false);
 605                     }
 606                     // Do not add node with null scene to the removed list.
 607                     // It will not be processed in the list and its memory
 608                     // will not be freed.
 609                     if (scene != null &amp;&amp; !removedChildrenOptimizationDisabled) {
 610                         removed.add(old);
 611                     }
 612                 }
 613             }
 614         }
 615 
 616         private String constructExceptionMessage(
 617                 String cause, Node offendingNode) {
 618             final StringBuilder sb = new StringBuilder(&quot;Children: &quot;);
 619             sb.append(cause);
 620             sb.append(&quot;: parent = &quot;).append(Parent.this);
 621             if (offendingNode != null) {
 622                 sb.append(&quot;, node = &quot;).append(offendingNode);
 623             }
 624 
 625             return sb.toString();
 626         }
 627     };
 628 
 629     /**
 630      * A constant reference to an unmodifiable view of the children, such that every time
 631      * we ask for an unmodifiable list of children, we don&#39;t actually create a new
 632      * collection and return it. The memory overhead is pretty lightweight compared
 633      * to all the garbage we would otherwise generate.
 634      */
 635     private final ObservableList&lt;Node&gt; unmodifiableChildren =
 636             FXCollections.unmodifiableObservableList(children);
 637 
 638     /**
 639      * A cached reference to the unmodifiable managed children of this Parent. This is
 640      * created whenever first asked for, and thrown away whenever children are added
 641      * or removed or when their managed state changes. This could be written
 642      * differently, such that this list is essentially a filtered copy of the
 643      * main children, but that additional overhead might not be worth it.
 644      */
 645     private List&lt;Node&gt; unmodifiableManagedChildren = null;
 646 
 647     /**
 648      * Gets the list of children of this {@code Parent}.
 649      *
 650      * &lt;p&gt;
 651      * See the class documentation for {@link Node} for scene graph structure
 652      * restrictions on setting a {@link Parent}&#39;s children list.
 653      * If these restrictions are violated by a change to the list of children,
 654      * the change is ignored and the previous value of the children list is
 655      * restored. An {@link IllegalArgumentException} is thrown in this case.
 656      *
 657      * &lt;p&gt;
 658      * If this {@link Parent} node is attached to a {@link Scene} attached to a {@link Window}
 659      * that is showning ({@link javafx.stage.Window#isShowing()}), then its
 660      * list of children must only be modified on the JavaFX Application Thread.
 661      * An {@link IllegalStateException} is thrown if this restriction is
 662      * violated.
 663      *
 664      * &lt;p&gt;
 665      * Note to subclasses: if you override this method, you must return from
 666      * your implementation the result of calling this super method. The actual
 667      * list instance returned from any getChildren() implementation must be
 668      * the list owned and managed by this Parent. The only typical purpose
 669      * for overriding this method is to promote the method to be public.
 670      *
 671      * @return the list of children of this {@code Parent}.
 672      */
 673     protected ObservableList&lt;Node&gt; getChildren() {
 674         return children;
 675     }
 676 
 677     /**
 678      * Gets the list of children of this {@code Parent} as a read-only
 679      * list.
 680      *
 681      * @return read-only access to this parent&#39;s children ObservableList
 682      */
 683     public ObservableList&lt;Node&gt; getChildrenUnmodifiable() {
 684         return unmodifiableChildren;
 685     }
 686 
 687     /**
 688      * Gets the list of all managed children of this {@code Parent}.
 689      *
 690      * @param &lt;E&gt; the type of the children nodes
 691      * @return list of all managed children in this parent
 692      */
 693     protected &lt;E extends Node&gt; List&lt;E&gt; getManagedChildren() {
 694         if (unmodifiableManagedChildren == null) {
 695             unmodifiableManagedChildren = new ArrayList&lt;Node&gt;();
 696             for (int i=0, max=children.size(); i&lt;max; i++) {
 697                 Node e = children.get(i);
 698                 if (e.isManaged()) {
 699                     unmodifiableManagedChildren.add(e);
 700                 }
 701             }
 702         }
 703         return (List&lt;E&gt;)unmodifiableManagedChildren;
 704     }
 705 
 706     /**
 707      * Called by Node whenever its managed state may have changed, this
 708      * method will cause the view of managed children to be updated
 709      * such that it properly includes or excludes this child.
 710      */
 711     final void managedChildChanged() {
 712         requestLayout();
 713         unmodifiableManagedChildren = null;
 714     }
 715 
 716     // implementation of Node.toFront function
 717     final void toFront(Node node) {
 718         if (Utils.assertionEnabled()) {
 719             if (!childSet.contains(node)) {
 720                 throw new java.lang.AssertionError(
 721                         &quot;specified node is not in the list of children&quot;);
 722             }
 723         }
 724 
 725         if (children.get(children.size() - 1) != node) {
 726             childrenTriggerPermutation = true;
 727             try {
 728                 children.remove(node);
 729                 children.add(node);
 730             } finally {
 731                 childrenTriggerPermutation = false;
 732             }
 733         }
 734     }
 735 
 736     // implementation of Node.toBack function
 737     final void toBack(Node node) {
 738         if (Utils.assertionEnabled()) {
 739             if (!childSet.contains(node)) {
 740                 throw new java.lang.AssertionError(
 741                         &quot;specified node is not in the list of children&quot;);
 742             }
 743         }
 744 
 745         if (children.get(0) != node) {
 746             childrenTriggerPermutation = true;
 747             try {
 748                 children.remove(node);
 749                 children.add(0, node);
 750             } finally {
 751                 childrenTriggerPermutation = false;
 752             }
 753         }
 754     }
 755 
 756     @Override
 757     void scenesChanged(final Scene newScene, final SubScene newSubScene,
 758                        final Scene oldScene, final SubScene oldSubScene) {
 759         super.scenesChanged(newScene, newSubScene, oldScene, oldSubScene);
 760 
 761         if (oldScene != null &amp;&amp; newScene == null) {
 762             // RT-34863 - clean up CSS cache when Parent is removed from scene-graph
 763             StyleManager.getInstance().forget(this);
 764 
 765             // Clear removed list on parent who is no longer in a scene
 766             if (removed != null) {
 767                 removed.clear();
 768             }
 769         }
 770 
 771         for (int i=0; i&lt;children.size(); i++) {
 772             children.get(i).setScenes(newScene, newSubScene, /* reapplyCSS */ false);
 773         }
 774 
 775         final boolean awaitingLayout = layoutFlag != LayoutFlags.CLEAN;
 776 
 777         sceneRoot = (newSubScene != null &amp;&amp; newSubScene.getRoot() == this) ||
 778                     (newScene != null &amp;&amp; newScene.getRoot() == this);
 779         layoutRoot = !isManaged() || sceneRoot;
 780 
 781 
 782         if (awaitingLayout) {
 783             // If this node is dirty and the new scene or subScene is not null
 784             // then add this node to the new scene&#39;s dirty list
 785             if (newScene != null &amp;&amp; layoutRoot) {
 786                 if (newSubScene != null) {
 787                     newSubScene.setDirtyLayout(this);
 788                 }
 789             }
 790         }
 791 
 792     }
 793 
 794     @Override
 795     void setDerivedDepthTest(boolean value) {
 796         super.setDerivedDepthTest(value);
 797 
 798         for (int i=0, max=children.size(); i&lt;max; i++) {
 799             final Node node = children.get(i);
 800             node.computeDerivedDepthTest();
 801         }
 802     }
 803 
 804     boolean pickChildrenNode(PickRay pickRay, PickResultChooser result) {
 805         List&lt;Node&gt; orderedChildren = getOrderedChildren();
 806         for (int i = orderedChildren.size() - 1; i &gt;= 0; i--) {
 807             orderedChildren.get(i).pickNode(pickRay, result);
 808             if (result.isClosed()) {
 809                 return false;
 810             }
 811         }
 812         return true;
 813     }
 814 
 815     /*
 816      * Note: This method MUST only be called via its accessor method.
 817      */
 818     private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
 819          double boundsDistance = intersectsBounds(pickRay);
 820 
 821         if (!Double.isNaN(boundsDistance) &amp;&amp; pickChildrenNode(pickRay, result)) {
 822             if (isPickOnBounds()) {
 823                 result.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 824             }
 825         }
 826     }
 827 
 828     @Override boolean isConnected() {
 829         return super.isConnected() || sceneRoot;
 830     }
 831 
 832     @Override public Node lookup(String selector) {
 833         Node n = super.lookup(selector);
 834         if (n == null) {
 835             for (int i=0, max=children.size(); i&lt;max; i++) {
 836                 final Node node = children.get(i);
 837                 n = node.lookup(selector);
 838                 if (n != null) return n;
 839             }
 840         }
 841         return n;
 842     }
 843 
 844     /**
 845      * Please Note: This method should never create the results set,
 846      * let the Node class implementation do this!
 847      */
 848     @Override List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 849         results = super.lookupAll(selector, results);
 850         for (int i=0, max=children.size(); i&lt;max; i++) {
 851             final Node node = children.get(i);
 852             results = node.lookupAll(selector, results);
 853         }
 854         return results;
 855     }
 856 
 857     private ParentTraversalEngine traversalEngine;
 858 
 859     private final void setTraversalEngine(ParentTraversalEngine value) {
 860         this.traversalEngine = value;
 861     }
 862 
 863     private final ParentTraversalEngine getTraversalEngine() {
 864         return traversalEngine;
 865     }
 866 
 867     /***********************************************************************
 868      *                               Layout                                *
 869      *                                                                     *
 870      *  Functions and variables related to the layout scheme used by       *
 871      *  JavaFX. Includes both public and private API.                      *
 872      *                                                                     *
 873      **********************************************************************/
 874     /**
 875      * Indicates that this Node and its subnodes requires a layout pass on
 876      * the next pulse.
 877      */
 878     private ReadOnlyBooleanWrapper needsLayout;
 879     LayoutFlags layoutFlag = LayoutFlags.CLEAN;
 880 
 881     protected final void setNeedsLayout(boolean value) {
 882         if (value) {
 883             markDirtyLayout(true, false);
 884         } else if (layoutFlag == LayoutFlags.NEEDS_LAYOUT) {
 885             boolean hasBranch = false;
 886             for (int i = 0, max = children.size(); i &lt; max; i++) {
 887                 final Node child = children.get(i);
 888                 if (child instanceof Parent) {
 889                     if (((Parent)child).layoutFlag != LayoutFlags.CLEAN) {
 890                         hasBranch = true;
 891                         break;
 892                     }
 893 
 894                 }
 895             }
 896             setLayoutFlag(hasBranch ? LayoutFlags.DIRTY_BRANCH : LayoutFlags.CLEAN);
 897         }
 898     }
 899 
 900     public final boolean isNeedsLayout() {
 901         return layoutFlag == LayoutFlags.NEEDS_LAYOUT;
 902     }
 903 
 904     public final ReadOnlyBooleanProperty needsLayoutProperty() {
 905         if (needsLayout == null) {
 906             needsLayout = new ReadOnlyBooleanWrapper(this, &quot;needsLayout&quot;, layoutFlag == LayoutFlags.NEEDS_LAYOUT);
 907         }
 908         return needsLayout;
 909     }
 910 
 911     /**
 912      * This is used only by CCS in Node. It is set to true while
 913      * the layout() function is processing and set to false on the conclusion.
 914      * It is used by the Node to decide whether to perform CSS updates
 915      * synchronously or asynchronously.
 916      */
 917     private boolean performingLayout = false;
 918 
 919     boolean isPerformingLayout() {
 920         return performingLayout;
 921     }
 922 
 923     private boolean sizeCacheClear = true;
 924     private double prefWidthCache = -1;
 925     private double prefHeightCache = -1;
 926     private double minWidthCache = -1;
 927     private double minHeightCache = -1;
 928 
 929     void setLayoutFlag(LayoutFlags flag) {
 930         if (needsLayout != null) {
 931             needsLayout.set(flag == LayoutFlags.NEEDS_LAYOUT);
 932         }
 933         layoutFlag = flag;
 934     }
 935 
 936     private void markDirtyLayout(boolean local, boolean forceParentLayout) {
 937         setLayoutFlag(LayoutFlags.NEEDS_LAYOUT);
 938         if (local || layoutRoot) {
 939             if (sceneRoot) {
 940                 Toolkit.getToolkit().requestNextPulse();
 941                 if (getSubScene() != null) {
 942                     getSubScene().setDirtyLayout(this);
 943                 }
 944             } else {
 945                 markDirtyLayoutBranch();
 946             }
 947         } else {
 948             requestParentLayout(forceParentLayout);
 949         }
 950     }
 951 
 952     /**
 953      * Requests a layout pass to be performed before the next scene is
 954      * rendered. This is batched up asynchronously to happen once per
 955      * &quot;pulse&quot;, or frame of animation.
 956      * &lt;p&gt;
 957      * If this parent is either a layout root or unmanaged, then it will be
 958      * added directly to the scene&#39;s dirty layout list, otherwise requestParentLayout
 959      * will be invoked.
 960      * @since JavaFX 8.0
 961      */
 962     public void requestLayout() {
 963         clearSizeCache();
 964         markDirtyLayout(false, forceParentLayout);
 965     }
 966 
 967     private boolean forceParentLayout = false;
 968     /**
 969      * A package scope method used by Node and serves as a helper method for
 970      * requestLayout() (see above). If forceParentLayout is true it will
 971      * propagate this force layout flag to its parent.
 972      */
 973     void requestLayout(boolean forceParentLayout) {
 974         boolean savedForceParentLayout = this.forceParentLayout;
 975         this.forceParentLayout = forceParentLayout;
 976         requestLayout();
 977         this.forceParentLayout = savedForceParentLayout;
 978     }
 979 
 980     /**
 981      * Requests a layout pass of the parent to be performed before the next scene is
 982      * rendered. This is batched up asynchronously to happen once per
 983      * &quot;pulse&quot;, or frame of animation.
 984      * &lt;p&gt;
 985      * This may be used when the current parent have changed it&#39;s min/max/preferred width/height,
 986      * but doesn&#39;t know yet if the change will lead to it&#39;s actual size change. This will be determined
 987      * when it&#39;s parent recomputes the layout with the new hints.
 988      */
 989     protected final void requestParentLayout() {
 990        requestParentLayout(false);
 991     }
 992 
 993     /**
 994      * A package scope method used by Node and serves as a helper method for
 995      * requestParentLayout() (see above). If forceParentLayout is true it will
 996      * force a request layout call on its parent if its parent is not null.
 997      */
 998     void requestParentLayout(boolean forceParentLayout) {
 999         if (!layoutRoot) {
1000             final Parent p = getParent();
1001             if (p != null &amp;&amp; (!p.performingLayout || forceParentLayout)) {
1002                 p.requestLayout();
1003             }
1004         }
1005     }
1006 
1007     void clearSizeCache() {
1008         if (sizeCacheClear) {
1009             return;
1010         }
1011         sizeCacheClear = true;
1012         prefWidthCache = -1;
1013         prefHeightCache = -1;
1014         minWidthCache = -1;
1015         minHeightCache = -1;
1016     }
1017 
1018     @Override public double prefWidth(double height) {
1019         if (height == -1) {
1020             if (prefWidthCache == -1) {
1021                 prefWidthCache = computePrefWidth(-1);
1022                 if (Double.isNaN(prefWidthCache) || prefWidthCache &lt; 0) prefWidthCache = 0;
1023                 sizeCacheClear = false;
1024             }
1025             return prefWidthCache;
1026         } else {
1027             double result = computePrefWidth(height);
1028             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1029         }
1030     }
1031 
1032     @Override public double prefHeight(double width) {
1033         if (width == -1) {
1034             if (prefHeightCache == -1) {
1035                 prefHeightCache = computePrefHeight(-1);
1036                 if (Double.isNaN(prefHeightCache) || prefHeightCache &lt; 0) prefHeightCache = 0;
1037                 sizeCacheClear = false;
1038             }
1039             return prefHeightCache;
1040         } else {
1041             double result = computePrefHeight(width);
1042             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1043         }
1044     }
1045 
1046     @Override public double minWidth(double height) {
1047         if (height == -1) {
1048             if (minWidthCache == -1) {
1049                 minWidthCache = computeMinWidth(-1);
1050                 if (Double.isNaN(minWidthCache) || minWidthCache &lt; 0) minWidthCache = 0;
1051                 sizeCacheClear = false;
1052             }
1053             return minWidthCache;
1054         } else {
1055             double result = computeMinWidth(height);
1056             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1057         }
1058     }
1059 
1060     @Override public double minHeight(double width) {
1061         if (width == -1) {
1062             if (minHeightCache == -1) {
1063                 minHeightCache = computeMinHeight(-1);
1064                 if (Double.isNaN(minHeightCache) || minHeightCache &lt; 0) minHeightCache = 0;
1065                 sizeCacheClear = false;
1066             }
1067             return minHeightCache;
1068         } else {
1069             double result = computeMinHeight(width);
1070             return Double.isNaN(result) || result &lt; 0 ? 0 : result;
1071         }
1072     }
1073 
1074     // PENDING_DOC_REVIEW
1075     /**
1076      * Calculates the preferred width of this {@code Parent}. The default
1077      * implementation calculates this width as the width of the area occupied
1078      * by its managed children when they are positioned at their
1079      * current positions at their preferred widths.
1080      *
1081      * @param height the height that should be used if preferred width depends
1082      *      on it
1083      * @return the calculated preferred width
1084      */
1085     protected double computePrefWidth(double height) {
1086         double minX = 0;
1087         double maxX = 0;
1088         for (int i=0, max=children.size(); i&lt;max; i++) {
1089             Node node = children.get(i);
1090             if (node.isManaged()) {
1091                 final double x = node.getLayoutBounds().getMinX() + node.getLayoutX();
1092                 minX = Math.min(minX, x);
1093                 maxX = Math.max(maxX, x + boundedSize(node.prefWidth(-1), node.minWidth(-1), node.maxWidth(-1)));
1094             }
1095         }
1096         return maxX - minX;
1097     }
1098 
1099     // PENDING_DOC_REVIEW
1100     /**
1101      * Calculates the preferred height of this {@code Parent}. The default
1102      * implementation calculates this height as the height of the area occupied
1103      * by its managed children when they are positioned at their current
1104      * positions at their preferred heights.
1105      *
1106      * @param width the width that should be used if preferred height depends
1107      *      on it
1108      * @return the calculated preferred height
1109      */
1110     protected double computePrefHeight(double width) {
1111         double minY = 0;
1112         double maxY = 0;
1113         for (int i=0, max=children.size(); i&lt;max; i++) {
1114             Node node = children.get(i);
1115             if (node.isManaged()) {
1116                 final double y = node.getLayoutBounds().getMinY() + node.getLayoutY();
1117                 minY = Math.min(minY, y);
1118                 maxY = Math.max(maxY, y + boundedSize(node.prefHeight(-1), node.minHeight(-1), node.maxHeight(-1)));
1119             }
1120         }
1121         return maxY - minY;
1122     }
1123 
1124     /**
1125      * Calculates the minimum width of this {@code Parent}. The default
1126      * implementation simply returns the pref width.
1127      *
1128      * @param height the height that should be used if min width depends
1129      *      on it
1130      * @return the calculated min width
1131      * @since JavaFX 2.1
1132      */
1133     protected double computeMinWidth(double height) {
1134         return prefWidth(height);
1135     }
1136 
1137     // PENDING_DOC_REVIEW
1138     /**
1139      * Calculates the min height of this {@code Parent}. The default
1140      * implementation simply returns the pref height;
1141      *
1142      * @param width the width that should be used if min height depends
1143      *      on it
1144      * @return the calculated min height
1145      * @since JavaFX 2.1
1146      */
1147     protected double computeMinHeight(double width) {
1148         return prefHeight(width);
1149     }
1150 
1151     /**
1152      * Calculates the baseline offset based on the first managed child. If there
1153      * is no such child, returns {@link Node#getBaselineOffset()}.
1154      *
1155      * @return baseline offset
1156      */
1157     @Override public double getBaselineOffset() {
1158         for (int i=0, max=children.size(); i&lt;max; i++) {
1159             final Node child = children.get(i);
1160             if (child.isManaged()) {
1161                 double offset = child.getBaselineOffset();
1162                 if (offset == BASELINE_OFFSET_SAME_AS_HEIGHT) {
1163                     continue;
1164                 }
1165                 return child.getLayoutBounds().getMinY() + child.getLayoutY() + offset;
1166             }
1167         }
1168         return super.getBaselineOffset();
1169     }
1170 
1171     /***
1172      * It stores the reference to the current child being laid out by its parent.
1173      * This reference is important to differentiate whether a layout is triggered
1174      * by its parent or other events.
1175      */
1176     private Node currentLayoutChild = null;
1177 
1178     boolean isCurrentLayoutChild(Node node) {
1179         return node == currentLayoutChild;
1180     }
1181 
1182     /**
1183      * Executes a top-down layout pass on the scene graph under this parent.
1184      *
1185      * Calling this method while the Parent is doing layout is a no-op.
1186      */
1187     public final void layout() {
1188         // layoutFlag can be accessed or changed during layout processing.
1189         // Hence we need to cache and reset it before performing layout.
1190         LayoutFlags flag = layoutFlag;
1191         setLayoutFlag(LayoutFlags.CLEAN);
1192         switch(flag) {
1193             case CLEAN:
1194                 break;
1195             case NEEDS_LAYOUT:
1196                 if (performingLayout) {
1197                     /* This code is here mainly to avoid infinite loops as layout() is public and the call might be (indirectly) invoked accidentally
1198                      * while doing the layout.
1199                      * One example might be an invocation from Group layout bounds recalculation
1200                      *  (e.g. during the localToScene/localToParent calculation).
1201                      * The layout bounds will thus return layout bounds that are &quot;old&quot; (i.e. before the layout changes, that are just being done),
1202                      * which is likely what the code would expect.
1203                      * The changes will invalidate the layout bounds again however, so the layout bounds query after layout pass will return correct answer.
1204                      */
1205                     break;
1206                 }
1207                 performingLayout = true;
1208                 layoutChildren();
1209                 // Intended fall-through
1210             case DIRTY_BRANCH:
1211                 for (int i = 0, max = children.size(); i &lt; max; i++) {
1212                     final Node child = children.get(i);
1213                     currentLayoutChild = child;
1214                     if (child instanceof Parent) {
1215                         ((Parent)child).layout();
1216                     } else if (child instanceof SubScene) {
1217                         ((SubScene)child).layoutPass();
1218                     }
1219                 }
1220                 currentLayoutChild = null;
1221                 performingLayout = false;
1222                 break;
1223         }
1224     }
1225 
1226     /**
1227      * Invoked during the layout pass to layout the children in this
1228      * {@code Parent}. By default it will only set the size of managed,
1229      * resizable content to their preferred sizes and does not do any node
1230      * positioning.
1231      * &lt;p&gt;
1232      * Subclasses should override this function to layout content as needed.
1233      */
1234     protected void layoutChildren() {
1235         for (int i=0, max=children.size(); i&lt;max; i++) {
1236             final Node node = children.get(i);
1237             currentLayoutChild = node;
1238             if (node.isResizable() &amp;&amp; node.isManaged()) {
1239                 node.autosize();
1240             }
1241         }
1242         currentLayoutChild = null;
1243     }
1244 
1245     /**
1246      * This field is managed by the Scene, and set on any node which is the
1247      * root of a Scene.
1248      */
1249     private boolean sceneRoot = false;
1250 
1251     /**
1252      * Keeps track of whether this node is a layout root. This is updated
1253      * whenever the sceneRoot field changes, or whenever the managed
1254      * property changes.
1255      */
1256     boolean layoutRoot = false;
1257     @Override final void notifyManagedChanged() {
1258         layoutRoot = !isManaged() || sceneRoot;
1259     }
1260 
1261     final boolean isSceneRoot() {
1262         return sceneRoot;
1263     }
1264 
1265     /***********************************************************************
1266      *                                                                     *
1267      *                         Stylesheet Handling                         *
1268      *                                                                     *
1269      **********************************************************************/
1270 
1271 
1272     /**
1273      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1274      * contents. For additional information about using CSS with the
1275      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1276      * Guide&lt;/a&gt;.
1277      */
1278     private final ObservableList&lt;String&gt; stylesheets = new TrackableObservableList&lt;String&gt;() {
1279         @Override
1280         protected void onChanged(Change&lt;String&gt; c) {
1281             final Scene scene = getScene();
1282             if (scene != null) {
1283 
1284                 // Notify the StyleManager if stylesheets change. This Parent&#39;s
1285                 // styleManager will get recreated in NodeHelper.processCSS.
1286                 StyleManager.getInstance().stylesheetsChanged(Parent.this, c);
1287 
1288                 // RT-9784 - if stylesheet is removed, reset styled properties to
1289                 // their initial value.
1290                 c.reset();
1291                 while(c.next()) {
1292                     if (c.wasRemoved() == false) {
1293                         continue;
1294                     }
1295                     break; // no point in resetting more than once...
1296                 }
1297 
1298                 reapplyCSS();
1299             }
1300         }
1301     };
1302 
1303     /**
1304      * Gets an observable list of string URLs linking to the stylesheets to use
1305      * with this Parent&#39;s contents. See {@link Scene#getStylesheets()} for details.
1306      * &lt;p&gt;For additional information about using CSS
1307      * with the scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1308      * Guide&lt;/a&gt;.&lt;/p&gt;
1309      *
1310      * @return the list of stylesheets to use with this Parent
1311      * @since JavaFX 2.1
1312      */
1313     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1314 
1315     /*
1316      * This method recurses up the parent chain until parent is null. As the
1317      * stack unwinds, if the Parent has stylesheets, they are added to the
1318      * list.
1319      *
1320      * It is possible to override this method to stop the recursion. This allows
1321      * a Parent to have a set of stylesheets distinct from its Parent.
1322      *
1323      * Note: This method MUST only be called via its accessor method.
1324      */
1325      // SB-dependency: RT-21247 has been filed to track this
1326     private List&lt;String&gt; doGetAllParentStylesheets() {
1327 
1328         List&lt;String&gt; list = null;
1329         final Parent myParent = getParent();
1330         if (myParent != null) {
1331 
1332             //
1333             // recurse so that stylesheets of Parents closest to the root are
1334             // added to the list first. The ensures that declarations for
1335             // stylesheets further down the tree (closer to the leaf) have
1336             // a higer ordinal in the cascade.
1337             //
1338             list = ParentHelper.getAllParentStylesheets(myParent);
1339         }
1340 
1341         if (stylesheets != null &amp;&amp; stylesheets.isEmpty() == false) {
1342             if (list == null) {
1343                 list = new ArrayList&lt;String&gt;(stylesheets.size());
1344             }
1345             for (int n=0,nMax=stylesheets.size(); n&lt;nMax; n++) {
1346                 list.add(stylesheets.get(n));
1347             }
1348         }
1349 
1350         return list;
1351 
1352     }
1353 
1354     /*
1355      * Note: This method MUST only be called via its accessor method.
1356      */
1357     private void doProcessCSS() {
1358 
1359         // Nothing to do...
1360         if (cssFlag == CssFlags.CLEAN) return;
1361 
1362         // RT-29254 - If DIRTY_BRANCH, pass control to Node#processCSS. This avoids calling NodeHelper.processCSS on
1363         // this node and all of its children when css doesn&#39;t need updated, recalculated, or reapplied.
1364         if (cssFlag == CssFlags.DIRTY_BRANCH) {
1365             super.processCSS();
1366             return;
1367         }
1368 
1369         // Let the super implementation handle CSS for this node
1370         ParentHelper.superProcessCSS(this);
1371 
1372         // avoid the following call to children.toArray if there are no children
1373         if (children.isEmpty()) return;
1374 
1375         //
1376         // RT-33103
1377         //
1378         // It is possible for a child to be removed from children in the middle of
1379         // the following loop. Iterating over the children may result in an IndexOutOfBoundsException.
1380         // So a copy is made and the copy is iterated over.
1381         //
1382         // Note that we don&#39;t want the fail-fast feature of an iterator, not to mention the general iterator overhead.
1383         //
1384         final Node[] childArray = children.toArray(new Node[children.size()]);
1385 
1386         // For each child, process CSS
1387         for (int i=0; i&lt;childArray.length; i++) {
1388 
1389             final Node child = childArray[i];
1390 
1391             //  If a child no longer has this as its parent, then it is skipped.
1392             final Parent childParent = child.getParent();
1393             if (childParent == null || childParent != this) continue;
1394 
1395             // If the parent styles are being updated, recalculated or
1396             // reapplied, then make sure the children get the same treatment.
1397             // Unless the child is already more dirty than this parent (RT-29074).
1398             if(CssFlags.UPDATE.compareTo(child.cssFlag) &gt; 0) {
1399                 child.cssFlag = CssFlags.UPDATE;
1400             }
1401             NodeHelper.processCSS(child);
1402         }
1403     }
1404 
1405     /***********************************************************************
1406      *                               Misc                                  *
1407      *                                                                     *
1408      *  Initialization and other functions                                 *
1409      *                                                                     *
1410      **********************************************************************/
1411     {
1412         // To initialize the class helper at the begining each constructor of this class
1413         ParentHelper.initHelper(this);
1414     }
1415 
1416     /**
1417      * Constructs a new {@code Parent}.
1418      */
1419     protected Parent() {
1420         layoutFlag = LayoutFlags.NEEDS_LAYOUT;
1421         setAccessibleRole(AccessibleRole.PARENT);
1422     }
1423 
1424     private NGNode doCreatePeer() {
1425         return new NGGroup();
1426     }
1427 
1428     @Override
1429     void nodeResolvedOrientationChanged() {
1430         for (int i = 0, max = children.size(); i &lt; max; ++i) {
1431             children.get(i).parentResolvedOrientationInvalidated();
1432         }
1433     }
1434 
1435     /***************************************************************************
1436      *                                                                         *
1437      *                         Bounds Computations                             *
1438      *                                                                         *
1439      *  This code originated in GroupBoundsHelper (part of javafx-sg-common)   *
1440      *  but has been ported here to the FX side since we cannot rely on the PG *
1441      *  side for computing the bounds (due to the decoupling of the two        *
1442      *  scenegraphs for threading and other purposes).                         *
1443      *                                                                         *
1444      *  Unfortunately, we cannot simply reuse GroupBoundsHelper without some  *
1445      *  major (and hacky) modification due to the fact that GroupBoundsHelper  *
1446      *  relies on PG state and we need to do similar things here that rely on  *
1447      *  core scenegraph state. Unfortunately, that means we made a port.       *
1448      *                                                                         *
1449      **************************************************************************/
1450 
1451     private BaseBounds tmp = new RectBounds();
1452 
1453     /**
1454      * The cached bounds for the Group. If the cachedBounds are invalid
1455      * then we have no history of what the bounds are, or were.
1456      */
1457     private BaseBounds cachedBounds = new RectBounds();
1458 
1459     /**
1460      * Indicates that the cachedBounds is invalid (or old) and need to be recomputed.
1461      * If cachedBoundsInvalid is true and dirtyChildrenCount is non-zero,
1462      * then when we recompute the cachedBounds we can consider the
1463      * values in cachedBounds to represent the last valid bounds for the group.
1464      * This is useful for several fast paths.
1465      */
1466     private boolean cachedBoundsInvalid;
1467 
1468     /**
1469      * The number of dirty children which bounds haven&#39;t been incorporated
1470      * into the cached bounds yet. Can be used even when dirtyChildren is null.
1471      */
1472     private int dirtyChildrenCount;
1473 
1474     /**
1475      * This set is used to track all of the children of this group which are
1476      * dirty. It is only used in cases where the number of children is &gt; some
1477      * value (currently 10). For very wide trees, this can provide a very
1478      * important speed boost. For the sake of memory consumption, this is
1479      * null unless the number of children ever crosses the threshold where
1480      * it will be activated.
1481      */
1482     private ArrayList&lt;Node&gt; dirtyChildren;
1483 
1484     private Node top;
1485     private Node left;
1486     private Node bottom;
1487     private Node right;
1488     private Node near;
1489     private Node far;
1490 
1491     private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
1492         // If we have no children, our bounds are invalid
1493         if (children.isEmpty()) {
1494             return bounds.makeEmpty();
1495         }
1496 
1497         if (tx.isTranslateOrIdentity()) {
1498             // this is a transform which is only doing translations, or nothing
1499             // at all (no scales, rotates, or shears)
1500             // so in this case we can easily use the cached bounds
1501             if (cachedBoundsInvalid) {
1502                 recomputeBounds();
1503 
1504                 if (dirtyChildren != null) {
1505                     dirtyChildren.clear();
1506                 }
1507                 cachedBoundsInvalid = false;
1508                 dirtyChildrenCount = 0;
1509             }
1510             if (!tx.isIdentity()) {
1511                 bounds = bounds.deriveWithNewBounds((float)(cachedBounds.getMinX() + tx.getMxt()),
1512                                  (float)(cachedBounds.getMinY() + tx.getMyt()),
1513                                  (float)(cachedBounds.getMinZ() + tx.getMzt()),
1514                                  (float)(cachedBounds.getMaxX() + tx.getMxt()),
1515                                  (float)(cachedBounds.getMaxY() + tx.getMyt()),
1516                                  (float)(cachedBounds.getMaxZ() + tx.getMzt()));
1517             } else {
1518                 bounds = bounds.deriveWithNewBounds(cachedBounds);
1519             }
1520 
1521             return bounds;
1522         } else {
1523             // there is a scale, shear, or rotation happening, so need to
1524             // do the full transform!
1525             double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
1526             double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;
1527             boolean first = true;
1528             for (int i=0, max=children.size(); i&lt;max; i++) {
1529                 final Node node = children.get(i);
1530                 if (node.isVisible()) {
1531                     bounds = getChildTransformedBounds(node, tx, bounds);
1532                     // if the bounds of the child are invalid, we don&#39;t want
1533                     // to use those in the remaining computations.
1534                     if (bounds.isEmpty()) continue;
1535                     if (first) {
1536                         minX = bounds.getMinX();
1537                         minY = bounds.getMinY();
1538                         minZ = bounds.getMinZ();
1539                         maxX = bounds.getMaxX();
1540                         maxY = bounds.getMaxY();
1541                         maxZ = bounds.getMaxZ();
1542                         first = false;
1543                     } else {
1544                         minX = Math.min(bounds.getMinX(), minX);
1545                         minY = Math.min(bounds.getMinY(), minY);
1546                         minZ = Math.min(bounds.getMinZ(), minZ);
1547                         maxX = Math.max(bounds.getMaxX(), maxX);
1548                         maxY = Math.max(bounds.getMaxY(), maxY);
1549                         maxZ = Math.max(bounds.getMaxZ(), maxZ);
1550                     }
1551                 }
1552             }
1553             // if &quot;first&quot; is still true, then we didn&#39;t have any children with
1554             // non-empty bounds and thus we must return an empty bounds,
1555             // otherwise we have non-empty bounds so go for it.
1556             if (first)
1557                 bounds.makeEmpty();
1558             else
1559                 bounds = bounds.deriveWithNewBounds((float)minX, (float)minY, (float)minZ,
1560                         (float)maxX, (float)maxY, (float)maxZ);
1561 
1562             return bounds;
1563         }
1564     }
1565 
1566     private void setChildDirty(final Node node, final boolean dirty) {
1567         if (node.boundsChanged == dirty) {
1568             return;
1569         }
1570 
1571         node.boundsChanged = dirty;
1572         if (dirty) {
1573             if (dirtyChildren != null) {
1574                 dirtyChildren.add(node);
1575             }
1576             ++dirtyChildrenCount;
1577         } else {
1578             if (dirtyChildren != null) {
1579                 dirtyChildren.remove(node);
1580             }
1581             --dirtyChildrenCount;
1582         }
1583     }
1584 
1585     private void childIncluded(final Node node) {
1586         // assert node.isVisible();
1587         cachedBoundsInvalid = true;
1588         setChildDirty(node, true);
1589     }
1590 
1591     // This is called when either the child is actually removed, OR IF IT IS
1592     // TOGGLED TO BE INVISIBLE. This is because in both cases it needs to be
1593     // cleared from the state which manages bounds.
1594     private void childExcluded(final Node node) {
1595         if (node == left) {
1596             left = null;
1597             cachedBoundsInvalid = true;
1598         }
1599         if (node == top) {
1600             top = null;
1601             cachedBoundsInvalid = true;
1602         }
1603         if (node == near) {
1604             near = null;
1605             cachedBoundsInvalid = true;
1606         }
1607         if (node == right) {
1608             right = null;
1609             cachedBoundsInvalid = true;
1610         }
1611         if (node == bottom) {
1612             bottom = null;
1613             cachedBoundsInvalid = true;
1614         }
1615         if (node == far) {
1616             far = null;
1617             cachedBoundsInvalid = true;
1618         }
1619 
1620         setChildDirty(node, false);
1621     }
1622 
1623     /**
1624      * Recomputes the bounds from scratch and saves the cached bounds.
1625      */
1626     private void recomputeBounds() {
1627         // fast path for case of no children
1628         if (children.isEmpty()) {
1629             cachedBounds.makeEmpty();
1630             return;
1631         }
1632 
1633         // fast path for case of 1 child
1634         if (children.size() == 1) {
1635             Node node = children.get(0);
1636             node.boundsChanged = false;
1637             if (node.isVisible()) {
1638                 cachedBounds = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, cachedBounds);
1639                 top = left = bottom = right = near = far = node;
1640             } else {
1641                 cachedBounds.makeEmpty();
1642                 // no need to null edge nodes here, it was done in childExcluded
1643                 // top = left = bottom = right = near = far = null;
1644             }
1645             return;
1646         }
1647 
1648         if ((dirtyChildrenCount == 0) ||
1649                 !updateCachedBounds(dirtyChildren != null
1650                                         ? dirtyChildren : children,
1651                                     dirtyChildrenCount)) {
1652             // failed to update cached bounds, recreate them
1653             createCachedBounds(children);
1654         }
1655     }
1656 
1657     private final int LEFT_INVALID = 1;
1658     private final int TOP_INVALID = 1 &lt;&lt; 1;
1659     private final int NEAR_INVALID = 1 &lt;&lt; 2;
1660     private final int RIGHT_INVALID = 1 &lt;&lt; 3;
1661     private final int BOTTOM_INVALID = 1 &lt;&lt; 4;
1662     private final int FAR_INVALID = 1 &lt;&lt; 5;
1663 
1664     private boolean updateCachedBounds(final List&lt;Node&gt; dirtyNodes,
1665                                        int remainingDirtyNodes) {
1666         // fast path for untransformed bounds calculation
1667         if (cachedBounds.isEmpty()) {
1668             createCachedBounds(dirtyNodes);
1669             return true;
1670         }
1671 
1672         int invalidEdges = 0;
1673 
1674         if ((left == null) || left.boundsChanged) {
1675             invalidEdges |= LEFT_INVALID;
1676         }
1677         if ((top == null) || top.boundsChanged) {
1678             invalidEdges |= TOP_INVALID;
1679         }
1680         if ((near == null) || near.boundsChanged) {
1681             invalidEdges |= NEAR_INVALID;
1682         }
1683         if ((right == null) || right.boundsChanged) {
1684             invalidEdges |= RIGHT_INVALID;
1685         }
1686         if ((bottom == null) || bottom.boundsChanged) {
1687             invalidEdges |= BOTTOM_INVALID;
1688         }
1689         if ((far == null) || far.boundsChanged) {
1690             invalidEdges |= FAR_INVALID;
1691         }
1692 
1693         // These indicate the bounds of the Group as computed by this
1694         // function
1695         float minX = cachedBounds.getMinX();
1696         float minY = cachedBounds.getMinY();
1697         float minZ = cachedBounds.getMinZ();
1698         float maxX = cachedBounds.getMaxX();
1699         float maxY = cachedBounds.getMaxY();
1700         float maxZ = cachedBounds.getMaxZ();
1701 
1702         // this checks the newly added nodes first, so if dirtyNodes is the
1703         // whole children list, we can end early
1704         for (int i = dirtyNodes.size() - 1; remainingDirtyNodes &gt; 0; --i) {
1705             final Node node = dirtyNodes.get(i);
1706             if (node.boundsChanged) {
1707                 // assert node.isVisible();
1708                 node.boundsChanged = false;
1709                 --remainingDirtyNodes;
1710                 tmp = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, tmp);
1711                 if (!tmp.isEmpty()) {
1712                     float tmpx = tmp.getMinX();
1713                     float tmpy = tmp.getMinY();
1714                     float tmpz = tmp.getMinZ();
1715                     float tmpx2 = tmp.getMaxX();
1716                     float tmpy2 = tmp.getMaxY();
1717                     float tmpz2 = tmp.getMaxZ();
1718 
1719                     // If this node forms an edge, then we will set it to be the
1720                     // node for this edge and update the min/max values
1721                     if (tmpx &lt;= minX) {
1722                         minX = tmpx;
1723                         left = node;
1724                         invalidEdges &amp;= ~LEFT_INVALID;
1725                     }
1726                     if (tmpy &lt;= minY) {
1727                         minY = tmpy;
1728                         top = node;
1729                         invalidEdges &amp;= ~TOP_INVALID;
1730                     }
1731                     if (tmpz &lt;= minZ) {
1732                         minZ = tmpz;
1733                         near = node;
1734                         invalidEdges &amp;= ~NEAR_INVALID;
1735                     }
1736                     if (tmpx2 &gt;= maxX) {
1737                         maxX = tmpx2;
1738                         right = node;
1739                         invalidEdges &amp;= ~RIGHT_INVALID;
1740                     }
1741                     if (tmpy2 &gt;= maxY) {
1742                         maxY = tmpy2;
1743                         bottom = node;
1744                         invalidEdges &amp;= ~BOTTOM_INVALID;
1745                     }
1746                     if (tmpz2 &gt;= maxZ) {
1747                         maxZ = tmpz2;
1748                         far = node;
1749                         invalidEdges &amp;= ~FAR_INVALID;
1750                     }
1751                 }
1752             }
1753         }
1754 
1755         if (invalidEdges != 0) {
1756             // failed to validate some edges
1757             return false;
1758         }
1759 
1760         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1761                                                         maxX, maxY, maxZ);
1762         return true;
1763     }
1764 
1765     private void createCachedBounds(final List&lt;Node&gt; fromNodes) {
1766         // These indicate the bounds of the Group as computed by this function
1767         float minX, minY, minZ;
1768         float maxX, maxY, maxZ;
1769 
1770         final int nodeCount = fromNodes.size();
1771         int i;
1772 
1773         // handle first visible non-empty node
1774         for (i = 0; i &lt; nodeCount; ++i) {
1775             final Node node = fromNodes.get(i);
1776             node.boundsChanged = false;
1777             if (node.isVisible()) {
1778                 tmp = node.getTransformedBounds(
1779                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1780                 if (!tmp.isEmpty()) {
1781                     left = top = near = right = bottom = far = node;
1782                     break;
1783                 }
1784             }
1785         }
1786 
1787         if (i == nodeCount) {
1788             left = top = near = right = bottom = far = null;
1789             cachedBounds.makeEmpty();
1790             return;
1791         }
1792 
1793         minX = tmp.getMinX();
1794         minY = tmp.getMinY();
1795         minZ = tmp.getMinZ();
1796         maxX = tmp.getMaxX();
1797         maxY = tmp.getMaxY();
1798         maxZ = tmp.getMaxZ();
1799 
1800         // handle remaining visible non-empty nodes
1801         for (++i; i &lt; nodeCount; ++i) {
1802             final Node node = fromNodes.get(i);
1803             node.boundsChanged = false;
1804             if (node.isVisible()) {
1805                 tmp = node.getTransformedBounds(
1806                                tmp, BaseTransform.IDENTITY_TRANSFORM);
1807                 if (!tmp.isEmpty()) {
1808                     final float tmpx = tmp.getMinX();
1809                     final float tmpy = tmp.getMinY();
1810                     final float tmpz = tmp.getMinZ();
1811                     final float tmpx2 = tmp.getMaxX();
1812                     final float tmpy2 = tmp.getMaxY();
1813                     final float tmpz2 = tmp.getMaxZ();
1814 
1815                     if (tmpx &lt; minX) { minX = tmpx; left = node; }
1816                     if (tmpy &lt; minY) { minY = tmpy; top = node; }
1817                     if (tmpz &lt; minZ) { minZ = tmpz; near = node; }
1818                     if (tmpx2 &gt; maxX) { maxX = tmpx2; right = node; }
1819                     if (tmpy2 &gt; maxY) { maxY = tmpy2; bottom = node; }
1820                     if (tmpz2 &gt; maxZ) { maxZ = tmpz2; far = node; }
1821                 }
1822             }
1823         }
1824 
1825         cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
1826                                                         maxX, maxY, maxZ);
1827     }
1828 
1829     /**
1830      * Updates the bounds of this {@code Parent} and its children.
1831      */
1832     @Override protected void updateBounds() {
1833         for (int i=0, max=children.size(); i&lt;max; i++) {
1834             children.get(i).updateBounds();
1835         }
1836         super.updateBounds();
1837     }
1838 
1839     // Note: this marks the currently processed child in terms of transformed bounds. In rare situations like
1840     // in RT-37879, it might happen that the child bounds will be marked as invalid. Due to optimizations,
1841     // the invalidation must *always* be propagated to the parent, because the parent with some transformation
1842     // calls child&#39;s getTransformedBounds non-idenitity transform and the child&#39;s transformed bounds are thus not validated.
1843     // This does not apply to the call itself however, because the call will yield the correct result even if something
1844     // was invalidated during the computation. We can safely ignore such invalidations from that Node in this case
1845     private Node currentlyProcessedChild;
1846 
1847     private BaseBounds getChildTransformedBounds(Node node, BaseTransform tx, BaseBounds bounds) {
1848         currentlyProcessedChild = node;
1849         bounds = node.getTransformedBounds(bounds, tx);
1850         currentlyProcessedChild = null;
1851         return bounds;
1852     }
1853 
1854     /**
1855      * Called by Node whenever its bounds have changed.
1856      */
1857     void childBoundsChanged(Node node) {
1858         // See comment above at &quot;currentlyProcessedChild&quot; field
1859         if (node == currentlyProcessedChild) {
1860             return;
1861         }
1862 
1863         cachedBoundsInvalid = true;
1864 
1865         // mark the node such that the parent knows that the child&#39;s bounds
1866         // are not in sync with this parent. In this way, when the bounds
1867         // need to be computed, we&#39;ll come back and figure out the new bounds
1868         // for all the children which have boundsChanged set to true
1869         setChildDirty(node, true);
1870 
1871         // go ahead and indicate that the geom has changed for this parent,
1872         // even though once we figure it all out it may be that the bounds
1873         // have not changed
1874         NodeHelper.geomChanged(this);
1875     }
1876 
1877     /**
1878      * Called by node whenever the visibility of the node changes.
1879      */
1880     void childVisibilityChanged(Node node) {
1881         if (node.isVisible()) {
1882             childIncluded(node);
1883         } else {
1884             childExcluded(node);
1885         }
1886 
1887         NodeHelper.geomChanged(this);
1888     }
1889 
1890     /*
1891      * Note: This method MUST only be called via its accessor method.
1892      */
1893     private boolean doComputeContains(double localX, double localY) {
1894         final Point2D tempPt = TempState.getInstance().point;
1895         for (int i=0, max=children.size(); i&lt;max; i++) {
1896             final Node node = children.get(i);
1897             tempPt.x = (float)localX;
1898             tempPt.y = (float)localY;
1899             try {
1900                 node.parentToLocal(tempPt);
1901             } catch (NoninvertibleTransformException e) {
1902                 continue;
1903             }
1904             if (node.contains(tempPt.x, tempPt.y)) {
1905                 return true;
1906             }
1907         }
1908         return false;
1909     }
1910 
1911     /** {@inheritDoc} */
1912     @Override
1913     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1914         switch (attribute) {
1915             case CHILDREN: return getChildrenUnmodifiable();
1916             default: return super.queryAccessibleAttribute(attribute, parameters);
1917         }
1918     }
1919 
1920     void releaseAccessible() {
1921         for (int i=0, max=children.size(); i&lt;max; i++) {
1922             final Node node = children.get(i);
1923             node.releaseAccessible();
1924         }
1925         super.releaseAccessible();
1926     }
1927 
1928     /**
1929      * Note: The only user of this method is in unit test: Parent_structure_sync_Test.
1930      */
1931     List&lt;Node&gt; test_getRemoved() {
1932         return removed;
1933     }
1934 
1935     /**
1936      * Note: The only user of this method is in unit test:
1937      * Parent_viewOrderChildren_sync_Test.
1938      */
1939     List&lt;Node&gt; test_getViewOrderChildren() {
1940         return viewOrderChildren;
1941     }
1942 }
    </pre>
  </body>
</html>