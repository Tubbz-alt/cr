diff a/modules/javafx.graphics/src/main/java/javafx/scene/Node.java b/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
@@ -1049,19 +1049,17 @@
         public void fireSuperValueChangedEvent() {
             super.fireValueChangedEvent();
         }
     }
 
-    // reapplyCSS should be true for root elements when they are added, and is false for children
-    // of the root element. This prevents CSS being reapplied recursively, as noted in JDK-8151756.
-    private void invalidatedScenes(Scene oldScene, SubScene oldSubScene, boolean reapplyCSS) {
+    private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
         Scene newScene = sceneProperty().get();
         boolean sceneChanged = oldScene != newScene;
         SubScene newSubScene = subScene;
 
         if (getClip() != null) {
-            getClip().setScenes(newScene, newSubScene, reapplyCSS);
+            getClip().setScenes(newScene, newSubScene);
         }
         if (sceneChanged) {
             updateCanReceiveFocus();
             if (isFocusTraversable()) {
                 if (newScene != null) {
@@ -1091,13 +1089,11 @@
             }
 
         }
         updateTreeShowing();
 
-        if (sceneChanged && reapplyCSS) {
-            reapplyCSS();
-        }
+        if (sceneChanged) reapplyCSS();
 
         if (sceneChanged && !isDirtyEmpty()) {
             //Note: no need to remove from scene's dirty list
             //Scene's is checking if the node's scene is correct
             /* TODO: looks like an existing bug when a node is moved from one
@@ -1152,20 +1148,20 @@
              */
             accessible = null;
         }
     }
 
-    final void setScenes(Scene newScene, SubScene newSubScene, boolean reapplyCSS) {
+    final void setScenes(Scene newScene, SubScene newSubScene) {
         Scene oldScene = sceneProperty().get();
         if (newScene != oldScene || newSubScene != subScene) {
             scene.set(newScene);
             SubScene oldSubScene = subScene;
             subScene = newSubScene;
-            invalidatedScenes(oldScene, oldSubScene, reapplyCSS);
+            invalidatedScenes(oldScene, oldSubScene);
             if (this instanceof SubScene) { // TODO: find better solution
                 SubScene thisSubScene = (SubScene)this;
-                thisSubScene.getRoot().setScenes(newScene, thisSubScene, reapplyCSS);
+                thisSubScene.getRoot().setScenes(newScene, thisSubScene);
             }
         }
     }
 
     final SubScene getSubScene() {
@@ -1182,14 +1178,12 @@
 
     /**
      * Exists for Parent and LightBase
      */
     void scenesChanged(final Scene newScene, final SubScene newSubScene,
-                       final Scene oldScene, final SubScene oldSubScene) {
-        // On scenes change, reapply CSS for this Node
-        reapplyCSS();
-    }
+                       final Scene oldScene, final SubScene oldSubScene) { }
+
 
     /**
      * The id of this {@code Node}. This simple string identifier is useful for
      * finding a specific Node within the scene graph. While the id of a Node
      * should be unique within the scene graph, this uniqueness is not enforced.
@@ -6980,17 +6974,17 @@
                                                    + clip + ").");
                             }
                         } else {
                             if (oldClip != null) {
                                 oldClip.clipParent = null;
-                                oldClip.setScenes(null, null, /* reapplyCSS */ false);
+                                oldClip.setScenes(null, null);
                                 oldClip.updateTreeVisible(false);
                             }
 
                             if (newClip != null) {
                                 newClip.clipParent = Node.this;
-                                newClip.setScenes(getScene(), getSubScene(), /* reapplyCSS */ false);
+                                newClip.setScenes(getScene(), getSubScene());
                                 newClip.updateTreeVisible(true);
                             }
 
                             NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);
 
@@ -9419,10 +9413,17 @@
 
         if (getScene() == null) return;
 
         if (cssFlag == CssFlags.REAPPLY) return;
 
+        if (cssFlag == CssFlags.DIRTY_BRANCH) {
+            // JDK-8193445 - don't reapply CSS from here
+            // Defer CSS application to this Node by marking cssFlag as REAPPLY
+            cssFlag = CssFlags.REAPPLY;
+            return;
+        }
+
         // RT-36838 - don't reapply CSS in the middle of an update
         if (cssFlag == CssFlags.UPDATE) {
             cssFlag = CssFlags.REAPPLY;
             notifyParentsOfInvalidatedCSS();
             return;
