<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
   23  * questions.
   24  */
   25 
   26 package javafx.scene;
   27 
   28 
   29 import com.sun.javafx.geometry.BoundsUtils;
   30 import javafx.application.Platform;
   31 import javafx.beans.InvalidationListener;
   32 import javafx.beans.Observable;
   33 import javafx.beans.binding.BooleanExpression;
   34 import javafx.beans.property.BooleanProperty;
   35 import javafx.beans.property.BooleanPropertyBase;
   36 import javafx.beans.property.DoubleProperty;
   37 import javafx.beans.property.DoublePropertyBase;
   38 import javafx.beans.property.IntegerProperty;
   39 import javafx.beans.property.ObjectProperty;
   40 import javafx.beans.property.ObjectPropertyBase;
   41 import javafx.beans.property.ReadOnlyBooleanProperty;
   42 import javafx.beans.property.ReadOnlyBooleanPropertyBase;
   43 import javafx.beans.property.ReadOnlyBooleanWrapper;
   44 import javafx.beans.property.ReadOnlyObjectProperty;
   45 import javafx.beans.property.ReadOnlyObjectPropertyBase;
   46 import javafx.beans.property.ReadOnlyObjectWrapper;
   47 import javafx.beans.property.SimpleBooleanProperty;
   48 import javafx.beans.property.SimpleObjectProperty;
   49 import javafx.beans.property.StringProperty;
   50 import javafx.beans.property.StringPropertyBase;
   51 import javafx.beans.value.ChangeListener;
   52 import javafx.collections.FXCollections;
   53 import javafx.collections.ListChangeListener.Change;
   54 import javafx.collections.ObservableList;
   55 import javafx.collections.ObservableMap;
   56 import javafx.collections.ObservableSet;
   57 import javafx.css.CssMetaData;
   58 import javafx.css.ParsedValue;
   59 import javafx.css.PseudoClass;
   60 import javafx.css.StyleConverter;
   61 import javafx.css.Styleable;
   62 import javafx.css.StyleableBooleanProperty;
   63 import javafx.css.StyleableDoubleProperty;
   64 import javafx.css.StyleableObjectProperty;
   65 import javafx.css.StyleableProperty;
   66 import javafx.event.Event;
   67 import javafx.event.EventDispatchChain;
   68 import javafx.event.EventDispatcher;
   69 import javafx.event.EventHandler;
   70 import javafx.event.EventTarget;
   71 import javafx.event.EventType;
   72 import javafx.geometry.BoundingBox;
   73 import javafx.geometry.Bounds;
   74 import javafx.geometry.NodeOrientation;
   75 import javafx.geometry.Orientation;
   76 import javafx.geometry.Point2D;
   77 import javafx.geometry.Point3D;
   78 import javafx.geometry.Rectangle2D;
   79 import javafx.scene.effect.BlendMode;
   80 import javafx.scene.effect.Effect;
   81 import javafx.scene.image.WritableImage;
   82 import javafx.scene.input.ContextMenuEvent;
   83 import javafx.scene.input.DragEvent;
   84 import javafx.scene.input.Dragboard;
   85 import javafx.scene.input.InputEvent;
   86 import javafx.scene.input.InputMethodEvent;
   87 import javafx.scene.input.InputMethodRequests;
   88 import javafx.scene.input.KeyEvent;
   89 import javafx.scene.input.MouseDragEvent;
   90 import javafx.scene.input.MouseEvent;
   91 import javafx.scene.input.PickResult;
   92 import javafx.scene.input.RotateEvent;
   93 import javafx.scene.input.ScrollEvent;
   94 import javafx.scene.input.SwipeEvent;
   95 import javafx.scene.input.TouchEvent;
   96 import javafx.scene.input.TransferMode;
   97 import javafx.scene.input.ZoomEvent;
   98 import javafx.scene.text.Font;
   99 import javafx.scene.transform.Rotate;
  100 import javafx.scene.transform.Transform;
  101 import javafx.stage.Window;
  102 import javafx.util.Callback;
  103 import java.security.AccessControlContext;
  104 
  105 import java.util.ArrayList;
  106 import java.util.Collections;
  107 import java.util.EnumSet;
  108 import java.util.HashMap;
  109 import java.util.LinkedList;
  110 import java.util.List;
  111 import java.util.Map;
  112 import java.util.Set;
  113 
  114 import com.sun.glass.ui.Accessible;
  115 import com.sun.glass.ui.Application;
  116 import com.sun.javafx.util.Logging;
  117 import com.sun.javafx.util.TempState;
  118 import com.sun.javafx.util.Utils;
  119 import com.sun.javafx.beans.IDProperty;
  120 import com.sun.javafx.beans.event.AbstractNotifyListener;
  121 import com.sun.javafx.binding.ExpressionHelper;
  122 import com.sun.javafx.collections.TrackableObservableList;
  123 import com.sun.javafx.collections.UnmodifiableListSet;
  124 import com.sun.javafx.css.PseudoClassState;
  125 import javafx.css.Selector;
  126 import javafx.css.Style;
  127 import javafx.css.converter.BooleanConverter;
  128 import javafx.css.converter.CursorConverter;
  129 import javafx.css.converter.EffectConverter;
  130 import javafx.css.converter.EnumConverter;
  131 import javafx.css.converter.SizeConverter;
  132 import com.sun.javafx.effect.EffectDirtyBits;
  133 import com.sun.javafx.geom.BaseBounds;
  134 import com.sun.javafx.geom.BoxBounds;
  135 import com.sun.javafx.geom.PickRay;
  136 import com.sun.javafx.geom.RectBounds;
  137 import com.sun.javafx.geom.Vec3d;
  138 import com.sun.javafx.geom.transform.Affine3D;
  139 import com.sun.javafx.geom.transform.BaseTransform;
  140 import com.sun.javafx.geom.transform.GeneralTransform3D;
  141 import com.sun.javafx.geom.transform.NoninvertibleTransformException;
  142 import com.sun.javafx.perf.PerformanceTracker;
  143 import com.sun.javafx.scene.BoundsAccessor;
  144 import com.sun.javafx.scene.CameraHelper;
  145 import com.sun.javafx.scene.CssFlags;
  146 import com.sun.javafx.scene.DirtyBits;
  147 import com.sun.javafx.scene.EventHandlerProperties;
  148 import com.sun.javafx.scene.LayoutFlags;
  149 import com.sun.javafx.scene.NodeEventDispatcher;
  150 import com.sun.javafx.scene.NodeHelper;
  151 import com.sun.javafx.scene.SceneHelper;
  152 import com.sun.javafx.scene.SceneUtils;
  153 import com.sun.javafx.scene.input.PickResultChooser;
  154 import com.sun.javafx.scene.transform.TransformHelper;
  155 import com.sun.javafx.scene.transform.TransformUtils;
  156 import com.sun.javafx.scene.traversal.Direction;
  157 import com.sun.javafx.sg.prism.NGNode;
  158 import com.sun.javafx.tk.Toolkit;
  159 import com.sun.prism.impl.PrismSettings;
  160 import com.sun.scenario.effect.EffectHelper;
  161 
  162 import javafx.scene.shape.Shape3D;
  163 import com.sun.javafx.logging.PlatformLogger;
  164 import com.sun.javafx.logging.PlatformLogger.Level;
  165 
  166 /**
  167  * Base class for scene graph nodes. A scene graph is a set of tree data structures
  168  * where every item has zero or one parent, and each item is either
  169  * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
  170  * &lt;p&gt;
  171  * Each item in the scene graph is called a {@code Node}. Branch nodes are
  172  * of type {@link Parent}, whose concrete subclasses are {@link Group},
  173  * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
  174  * or subclasses thereof.
  175  * &lt;p&gt;
  176  * Leaf nodes are classes such as
  177  * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
  178  * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
  179  * or other such leaf classes which cannot have children. Only a single node within
  180  * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
  181  * &lt;p&gt;
  182  * There may be several trees in the scene graph. Some trees may be part of
  183  * a {@link Scene}, in which case they are eligible to be displayed.
  184  * Other trees might not be part of any {@link Scene}.
  185  * &lt;p&gt;
  186  * A node may occur at most once anywhere in the scene graph. Specifically,
  187  * a node must appear no more than once in all of the following:
  188  * as the root node of a {@link Scene},
  189  * the children ObservableList of a {@link Parent},
  190  * or as the clip of a {@link Node}.
  191  * &lt;p&gt;
  192  * The scene graph must not have cycles. A cycle would exist if a node is
  193  * an ancestor of itself in the tree, considering the {@link Group} content
  194  * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
  195  * mentioned above.
  196  * &lt;p&gt;
  197  * If a program adds a child node to a Parent (including Group, Region, etc)
  198  * and that node is already a child of a different Parent or the root of a Scene,
  199  * the node is automatically (and silently) removed from its former parent.
  200  * If a program attempts to modify the scene graph in any other way that violates
  201  * the above rules, an exception is thrown, the modification attempt is ignored
  202  * and the scene graph is restored to its previous state.
  203  * &lt;p&gt;
  204  * It is possible to rearrange the structure of the scene graph, for
  205  * example, to move a subtree from one location in the scene graph to
  206  * another. In order to do this, one would normally remove the subtree from
  207  * its old location before inserting it at the new location. However, the
  208  * subtree will be automatically removed as described above if the application
  209  * doesn&#39;t explicitly remove it.
  210  * &lt;p&gt;
  211  * Node objects may be constructed and modified on any thread as long they are
  212  * not yet attached to a {@link Scene} in a {@link Window} that is
  213  * {@link Window#isShowing showing}.
  214  * An application must attach nodes to such a Scene or modify them on the JavaFX
  215  * Application Thread.
  216  *
  217  * &lt;p&gt;
  218  * The JavaFX Application Thread is created as part of the startup process for
  219  * the JavaFX runtime. See the {@link javafx.application.Application} class and
  220  * the {@link Platform#startup(Runnable)} method for more information.
  221  * &lt;/p&gt;
  222  *
  223  * &lt;p&gt;
  224  * An application should not extend the Node class directly. Doing so may lead to
  225  * an UnsupportedOperationException being thrown.
  226  * &lt;/p&gt;
  227  *
  228  * &lt;h3&gt;String ID&lt;/h3&gt;
  229  * &lt;p&gt;
  230  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  231  * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
  232  * and developer to ensure that the {@code id} is unique within the scene graph.
  233  * A convenience function called {@link #lookup(String)} can be used to find
  234  * a node with a unique id within the scene graph, or within a subtree of the
  235  * scene graph. The id can also be used identify nodes for applying styles; see
  236  * the CSS section below.
  237  *
  238  * &lt;h3&gt;Coordinate System&lt;/h3&gt;
  239  * &lt;p&gt;
  240  * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
  241  * coordinate system in which the {@code x} axis increases to the right and the
  242  * {@code y} axis increases downwards.  The concrete node classes for shapes
  243  * provide variables for defining the geometry and location of the shape
  244  * within this local coordinate space.  For example,
  245  * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
  246  * {@code width}, {@code height} variables while
  247  * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
  248  * and {@code radius}.
  249  * &lt;p&gt;
  250  * At the device pixel level, integer coordinates map onto the corners and
  251  * cracks between the pixels and the centers of the pixels appear at the
  252  * midpoints between integer pixel locations.  Because all coordinate values
  253  * are specified with floating point numbers, coordinates can precisely
  254  * point to these corners (when the floating point values have exact integer
  255  * values) or to any location on the pixel.  For example, a coordinate of
  256  * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
  257  * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
  258  * of {@code 10} by {@code 10} would span from the upper left corner of the
  259  * upper left pixel on the {@code Stage} to the lower right corner of the
  260  * 10th pixel on the 10th scanline.  The pixel center of the last pixel
  261  * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
  262  * &lt;p&gt;
  263  * In practice, most nodes have transformations applied to their coordinate
  264  * system as mentioned below.  As a result, the information above describing
  265  * the alignment of device coordinates to the pixel grid is relative to
  266  * the transformed coordinates, not the local coordinates of the nodes.
  267  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  268  * important context-specific information about coordinate mapping and how
  269  * it can affect rendering.
  270  *
  271  * &lt;h3&gt;Transformations&lt;/h3&gt;
  272  * &lt;p&gt;
  273  * Any {@code Node} can have transformations applied to it. These include
  274  * translation, rotation, scaling, or shearing.
  275  * &lt;p&gt;
  276  * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
  277  * node&#39;s coordinate space along either the x or y axis. For example, if you
  278  * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
  279  * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
  280  * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
  281  * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
  282  * 100 points wide and 50 tall. Note that the origin was shifted, not the
  283  * {@code x} variable of the rectangle.
  284  * &lt;p&gt;
  285  * A common node transform is a translation by an integer distance, most often
  286  * used to lay out nodes on the stage.  Such integer translations maintain the
  287  * device pixel mapping so that local coordinates that are integers still
  288  * map to the cracks between pixels.
  289  * &lt;p&gt;
  290  * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
  291  * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
  292  * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
  293  * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
  294  * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
  295  * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
  296  * the rectangle will be drawn as if its x and y were zero but its height was
  297  * 100 and its width -30. That is, it is as if a pin is being stuck at the top
  298  * left corner and the rectangle is rotating 90 degrees clockwise around that
  299  * pin. If the pivot point is instead placed in the center of the rectangle
  300  * (at point x=50, y=15) then the rectangle will instead appear to rotate about
  301  * its center.
  302  * &lt;p&gt;
  303  * Note that as with all transformations, the x, y, width, and height variables
  304  * of the rectangle (which remain relative to the local coordinate space) have
  305  * not changed, but rather the transformation alters the entire coordinate space
  306  * of the rectangle.
  307  * &lt;p&gt;
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
  313  * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
  328  * &lt;h3&gt;Bounding Rectangles&lt;/h3&gt;
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
  334  * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
  335  * variable which specifies the bounding rectangle of the {@code Node} in
  336  * untransformed local coordinates. {@code boundsInLocal} includes the
  337  * Node&#39;s shape geometry, including any space required for a
  338  * non-zero stroke that may fall outside the local position/size variables,
  339  * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
  340  * &lt;p&gt;
  341  * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
  342  * specifies the bounding rectangle of the {@code Node} after all transformations
  343  * have been applied, including those set in {@link #getTransforms transforms},
  344  * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
  345  * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
  346  * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
  347  * parent&#39;s coordinate system.  This is the &#39;visual&#39; bounds of the node.
  348  * &lt;p&gt;
  349  * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
  350  * the {@code Node} that should be used as the basis for layout calculations and
  351  * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
  352  * layoutBounds by default includes only the shape geometry, including space required
  353  * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
  354  * clip, or any transforms. For resizable classes (Regions and Controls)
  355  * layoutBounds will always map to {@code 0,0 width x height}.
  356  *
  357  * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
  358  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
  359  * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
  360  * If we rotate the image by 20 degrees we get following result:
  361  * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
  362  * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
  363  * The red rectangle represents {@code boundsInParent} in the
  364  * coordinate space of the Node&#39;s parent. The {@code boundsInLocal} stays the same
  365  * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
  366  * in the coordinate space of the Node.
  367  *
  368  * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
  369  * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
  370  * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
  371  *
  372  * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
  373  * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
  374  * (the stroke is centered by default, so only half of it is outside
  375  * of the original bounds; it is also possible to create inside or outside
  376  * stroke).
  377  *
  378  * Since neither of the rectangles has any transformation applied,
  379  * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
  380  * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
  381  * respective bounds&quot;&gt; &lt;/p&gt;
  382  *
  383  *
  384  * &lt;h3&gt;CSS&lt;/h3&gt;
  385  * &lt;p&gt;
  386  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  387  * {@code style} variables that are used in styling this node from
  388  * CSS. The {@code id} and {@code styleClass} variables are used in
  389  * CSS style sheets to identify nodes to which styles should be
  390  * applied. The {@code style} variable contains style properties and
  391  * values that are applied directly to this node.
  392  * &lt;p&gt;
  393  * For further information about CSS and how to apply CSS styles
  394  * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
  395  * Guide&lt;/a&gt;.
  396  * @since JavaFX 2.0
  397  */
  398 @IDProperty(&quot;id&quot;)
  399 public abstract class Node implements EventTarget, Styleable {
  400 
  401     /*
  402      * Store the singleton instance of the NodeHelper subclass corresponding
  403      * to the subclass of this instance of Node
  404      */
  405     private NodeHelper nodeHelper = null;
  406 
  407     static {
  408         PerformanceTracker.logEvent(&quot;Node class loaded&quot;);
  409 
  410         // This is used by classes in different packages to get access to
  411         // private and package private methods.
  412         NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
  413             @Override
  414             public NodeHelper getHelper(Node node) {
  415                 return node.nodeHelper;
  416             }
  417 
  418             @Override
  419             public void setHelper(Node node, NodeHelper nodeHelper) {
  420                 node.nodeHelper = nodeHelper;
  421             }
  422 
  423             @Override
  424             public void doMarkDirty(Node node, DirtyBits dirtyBit) {
  425                 node.doMarkDirty(dirtyBit);
  426             }
  427 
  428             @Override
  429             public void doUpdatePeer(Node node) {
  430                 node.doUpdatePeer();
  431             }
  432 
  433             @Override
  434             public BaseTransform getLeafTransform(Node node) {
  435                 return node.getLeafTransform();
  436             }
  437 
  438             @Override
  439             public Bounds doComputeLayoutBounds(Node node) {
  440                 return node.doComputeLayoutBounds();
  441             }
  442 
  443             @Override
  444             public void doTransformsChanged(Node node) {
  445                 node.doTransformsChanged();
  446             }
  447 
  448             @Override
  449             public void doPickNodeLocal(Node node, PickRay localPickRay,
  450                     PickResultChooser result) {
  451                 node.doPickNodeLocal(localPickRay, result);
  452             }
  453 
  454             @Override
  455             public boolean doComputeIntersects(Node node, PickRay pickRay,
  456                     PickResultChooser pickResult) {
  457                 return node.doComputeIntersects(pickRay, pickResult);
  458             }
  459 
  460             @Override
  461             public void doGeomChanged(Node node) {
  462                 node.doGeomChanged();
  463             }
  464 
  465             @Override
  466             public void doNotifyLayoutBoundsChanged(Node node) {
  467                 node.doNotifyLayoutBoundsChanged();
  468             }
  469 
  470             @Override
  471             public void doProcessCSS(Node node) {
  472                 node.doProcessCSS();
  473             }
  474 
  475             @Override
  476             public boolean isDirty(Node node, DirtyBits dirtyBit) {
  477                 return node.isDirty(dirtyBit);
  478             }
  479 
  480             @Override
  481             public boolean isDirtyEmpty(Node node) {
  482                 return node.isDirtyEmpty();
  483             }
  484 
  485             @Override
  486             public void syncPeer(Node node) {
  487                 node.syncPeer();
  488             }
  489 
  490             @Override
  491             public void layoutBoundsChanged(Node node) {
  492                 node.layoutBoundsChanged();
  493             }
  494 
  495             @Override
  496             public &lt;P extends NGNode&gt; P getPeer(Node node) {
  497                 return node.getPeer();
  498             }
  499 
  500             @Override
  501             public void setShowMnemonics(Node node, boolean value) {
  502                 node.setShowMnemonics(value);
  503             }
  504 
  505             @Override
  506             public boolean isShowMnemonics(Node node) {
  507                 return node.isShowMnemonics();
  508             }
  509 
  510             @Override
  511             public BooleanProperty showMnemonicsProperty(Node node) {
  512                 return node.showMnemonicsProperty();
  513             }
  514 
  515             @Override
  516             public boolean traverse(Node node, Direction direction) {
  517                 return node.traverse(direction);
  518             }
  519 
  520             @Override
  521             public double getPivotX(Node node) {
  522                 return node.getPivotX();
  523             }
  524 
  525             @Override
  526             public double getPivotY(Node node) {
  527                 return node.getPivotY();
  528             }
  529 
  530             @Override
  531             public double getPivotZ(Node node) {
  532                 return node.getPivotZ();
  533             }
  534 
  535             @Override
  536             public void pickNode(Node node,PickRay pickRay,
  537                     PickResultChooser result) {
  538                 node.pickNode(pickRay, result);
  539             }
  540 
  541             @Override
  542             public boolean intersects(Node node, PickRay pickRay,
  543                     PickResultChooser pickResult) {
  544                 return node.intersects(pickRay, pickResult);
  545             }
  546 
  547             @Override
  548             public double intersectsBounds(Node node, PickRay pickRay) {
  549                 return node.intersectsBounds(pickRay);
  550             }
  551 
  552             @Override
  553             public void layoutNodeForPrinting(Node node) {
  554                 node.doCSSLayoutSyncForSnapshot();
  555             }
  556 
  557             @Override
  558             public boolean isDerivedDepthTest(Node node) {
  559                 return node.isDerivedDepthTest();
  560             }
  561 
  562             @Override
  563             public SubScene getSubScene(Node node) {
  564                 return node.getSubScene();
  565             }
  566 
  567             @Override
  568             public void setLabeledBy(Node node, Node labeledBy) {
  569                 node.labeledBy = labeledBy;
  570             }
  571 
  572             @Override
  573             public Accessible getAccessible(Node node) {
  574                 return node.getAccessible();
  575             }
  576 
  577             @Override
  578             public void reapplyCSS(Node node) {
  579                 node.reapplyCSS();
  580             }
  581 
  582             @Override
  583             public boolean isTreeVisible(Node node) {
  584                 return node.isTreeVisible();
  585             }
  586 
  587             @Override
  588             public BooleanExpression treeVisibleProperty(Node node) {
  589                 return node.treeVisibleProperty();
  590             }
  591 
  592             @Override
  593             public boolean isTreeShowing(Node node) {
  594                 return node.isTreeShowing();
  595             }
  596 
  597             @Override
  598             public BooleanExpression treeShowingProperty(Node node) {
  599                 return node.treeShowingProperty();
  600             }
  601 
  602             @Override
  603             public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
  604                     Styleable styleable) {
  605                 return Node.getMatchingStyles(cssMetaData, styleable);
  606             }
  607 
  608             @Override
  609             public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
  610                     Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
  611                 return node.findStyles(styleMap);
  612             }
  613         });
  614     }
  615 
  616     /**************************************************************************
  617      *                                                                        *
  618      * Methods and state for managing the dirty bits of a Node. The dirty     *
  619      * bits are flags used to keep track of what things are dirty on the      *
  620      * node and therefore need processing on the next pulse. Since the pulse  *
  621      * happens asynchronously to the change that made the node dirty (for     *
  622      * performance reasons), we need to keep track of what things have        *
  623      * changed.                                                               *
  624      *                                                                        *
  625      *************************************************************************/
  626 
  627     /**
  628      * Set of dirty bits that are set when state is invalidated and cleared by
  629      * the updateState method, which is called from the synchronizer.
  630      * &lt;p&gt;
  631      * A node starts dirty.
  632      */
  633     private Set&lt;DirtyBits&gt; dirtyBits = EnumSet.allOf(DirtyBits.class);
  634 
  635     /**
  636      * Mark the specified bit as dirty, and add this node to the scene&#39;s dirty list.
  637      *
  638      * Note: This method MUST only be called via its accessor method.
  639      */
  640     private void doMarkDirty(DirtyBits dirtyBit) {
  641         if (isDirtyEmpty()) {
  642             addToSceneDirtyList();
  643         }
  644 
  645         dirtyBits.add(dirtyBit);
  646     }
  647 
  648     private void addToSceneDirtyList() {
  649         Scene s = getScene();
  650         if (s != null) {
  651             s.addToDirtyList(this);
  652             if (getSubScene() != null) {
  653                 getSubScene().setDirty(this);
  654             }
  655         }
  656     }
  657 
  658     /**
  659      * Test whether the specified dirty bit is set
  660      */
  661     final boolean isDirty(DirtyBits dirtyBit) {
  662         return dirtyBits.contains(dirtyBit);
  663     }
  664 
  665     /**
  666      * Clear the specified dirty bit
  667      */
  668     final void clearDirty(DirtyBits dirtyBit) {
  669         dirtyBits.remove(dirtyBit);
  670     }
  671 
  672     /**
  673      * Clear all dirty bits
  674      */
  675     private void clearDirty() {
  676         dirtyBits.clear();
  677     }
  678 
  679     /**
  680      * Test whether the set of dirty bits is empty
  681      */
  682     private boolean isDirtyEmpty() {
  683         return dirtyBits.isEmpty();
  684     }
  685 
  686     /**************************************************************************
  687      *                                                                        *
  688      * Methods for synchronizing state from this Node to its PG peer. This    *
  689      * should only *ever* be called during synchronization initialized as a   *
  690      * result of a pulse. Any attempt to synchronize at any other time may    *
  691      * cause rendering artifacts.                                             *
  692      *                                                                        *
  693      *************************************************************************/
  694 
  695     /**
  696      * Called by the synchronizer to update the state and
  697      * clear dirtybits of this node in the PG graph
  698      */
  699     final void syncPeer() {
  700         // Do not synchronize invisible nodes unless their visibility has changed
  701         // or they have requested a forced synchronization
  702         if (!isDirtyEmpty() &amp;&amp; (treeVisible
  703                                      || isDirty(DirtyBits.NODE_VISIBLE)
  704                                      || isDirty(DirtyBits.NODE_FORCE_SYNC)))
  705         {
  706             NodeHelper.updatePeer(this);
  707             clearDirty();
  708         }
  709     }
  710 
  711     /**
  712      * A temporary rect used for computing bounds by the various bounds
  713      * variables. This bounds starts life as a RectBounds, but may be promoted
  714      * to a BoxBounds if there is a 3D transform mixed into its computation.
  715      * These two fields were held in a thread local, but were then pulled
  716      * out of it so that we could compute bounds before holding the
  717      * synchronization lock. These objects have to be per-instance so
  718      * that we can pass the right data down to the PG side later during
  719      * synchronization (rather than statics as they were before).
  720      */
  721     private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
  722     private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);
  723 
  724     private boolean pendingUpdateBounds = false;
  725 
  726     // Happens before we hold the sync lock
  727     void updateBounds() {
  728         // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
  729         // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
  730         Node n = getClip();
  731         if (n != null) {
  732             n.updateBounds();
  733         }
  734 
  735         // See syncPeer()
  736         if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {
  737 
  738             // Need to save the dirty bits since they will be cleared even for the
  739             // case of short circuiting dirty bit processing.
  740             if (isDirty(DirtyBits.NODE_TRANSFORM)
  741                     || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
  742                     || isDirty(DirtyBits.NODE_BOUNDS)) {
  743                 pendingUpdateBounds = true;
  744             }
  745 
  746             return;
  747         }
  748 
  749         // Set transform and bounds dirty bits when this node becomes visible
  750         if (pendingUpdateBounds) {
  751             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
  752             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
  753             NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
  754 
  755             pendingUpdateBounds = false;
  756         }
  757 
  758         if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  759             if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  760                 updateLocalToParentTransform();
  761             }
  762             _txBounds = getTransformedBounds(_txBounds,
  763                                              BaseTransform.IDENTITY_TRANSFORM);
  764         }
  765 
  766         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  767             _geomBounds = getGeomBounds(_geomBounds,
  768                     BaseTransform.IDENTITY_TRANSFORM);
  769         }
  770 
  771     }
  772 
  773     /*
  774      * This function is called during synchronization to update the state of the
  775      * NG Node from the FX Node. Subclasses of Node should override this method
  776      * and must call NodeHelper.updatePeer(this)
  777      *
  778      * Note: This method MUST only be called via its accessor method.
  779      */
  780     private void doUpdatePeer() {
  781         final NGNode peer = getPeer();
  782 
  783         // For debug / diagnostic purposes, we will copy across a name for this node down to
  784         // the NG layer, where we can use the name to figure out what the NGNode represents.
  785         // An alternative would be to have a back-reference from the NGNode back to the Node it
  786         // is a peer to, however it was felt that this would make it too easy to communicate back
  787         // to the Node and possibly violate thread invariants. But of course, we only need to do this
  788         // if we&#39;re going to print the render graph (otherwise all the work we&#39;d do to keep the name
  789         // properly updated would be a waste).
  790         if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
  791             final String id = getId();
  792             String className = getClass().getSimpleName();
  793             if (className.isEmpty()) {
  794                 className = getClass().getName();
  795             }
  796             peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
  797         }
  798 
  799         if (isDirty(DirtyBits.NODE_TRANSFORM)) {
  800             peer.setTransformMatrix(localToParentTx);
  801         }
  802 
  803         if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
  804             peer.setViewOrder(getViewOrder());
  805         }
  806 
  807         if (isDirty(DirtyBits.NODE_BOUNDS)) {
  808             peer.setContentBounds(_geomBounds);
  809         }
  810 
  811         if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
  812             peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
  813         }
  814 
  815         if (isDirty(DirtyBits.NODE_OPACITY)) {
  816             peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
  817         }
  818 
  819         if (isDirty(DirtyBits.NODE_CACHE)) {
  820             peer.setCachedAsBitmap(isCache(), getCacheHint());
  821         }
  822 
  823         if (isDirty(DirtyBits.NODE_CLIP)) {
  824             peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
  825         }
  826 
  827         if (isDirty(DirtyBits.EFFECT_EFFECT)) {
  828             if (getEffect() != null) {
  829                 EffectHelper.sync(getEffect());
  830                 peer.effectChanged();
  831             }
  832         }
  833 
  834         if (isDirty(DirtyBits.NODE_EFFECT)) {
  835             peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
  836         }
  837 
  838         if (isDirty(DirtyBits.NODE_VISIBLE)) {
  839             peer.setVisible(isVisible());
  840         }
  841 
  842         if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
  843             peer.setDepthTest(isDerivedDepthTest());
  844         }
  845 
  846         if (isDirty(DirtyBits.NODE_BLENDMODE)) {
  847             BlendMode mode = getBlendMode();
  848             peer.setNodeBlendMode((mode == null)
  849                                   ? null
  850                                   : EffectHelper.getToolkitBlendMode(mode));
  851         }
  852     }
  853 
  854     /*************************************************************************
  855     *                                                                        *
  856     *                                                                        *
  857     *                                                                        *
  858     *************************************************************************/
  859 
  860     private static final Object USER_DATA_KEY = new Object();
  861     // A map containing a set of properties for this node
  862     private ObservableMap&lt;Object, Object&gt; properties;
  863 
  864     /**
  865       * Returns an observable map of properties on this node for use primarily
  866       * by application developers.
  867       *
  868       * @return an observable map of properties on this node for use primarily
  869       * by application developers
  870       */
  871      public final ObservableMap&lt;Object, Object&gt; getProperties() {
  872         if (properties == null) {
  873             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
  874         }
  875         return properties;
  876     }
  877 
  878     /**
  879      * Tests if Node has properties.
  880      * @return true if node has properties.
  881      */
  882      public boolean hasProperties() {
  883         return properties != null &amp;&amp; !properties.isEmpty();
  884     }
  885 
  886     /**
  887      * Convenience method for setting a single Object property that can be
  888      * retrieved at a later date. This is functionally equivalent to calling
  889      * the getProperties().put(Object key, Object value) method. This can later
  890      * be retrieved by calling {@link Node#getUserData()}.
  891      *
  892      * @param value The value to be stored - this can later be retrieved by calling
  893      *          {@link Node#getUserData()}.
  894      */
  895     public void setUserData(Object value) {
  896         getProperties().put(USER_DATA_KEY, value);
  897     }
  898 
  899     /**
  900      * Returns a previously set Object property, or null if no such property
  901      * has been set using the {@link Node#setUserData(java.lang.Object)} method.
  902      *
  903      * @return The Object that was previously set, or null if no property
  904      *          has been set or if null was set.
  905      */
  906     public Object getUserData() {
  907         return getProperties().get(USER_DATA_KEY);
  908     }
  909 
  910     /**************************************************************************
  911      *                                                                        *
  912      *
  913      *                                                                        *
  914      *************************************************************************/
  915 
  916     /**
  917      * The parent of this {@code Node}. If this {@code Node} has not been added
  918      * to a scene graph, then parent will be null.
  919      *
  920      * @defaultValue null
  921      */
  922     private ReadOnlyObjectWrapper&lt;Parent&gt; parent;
  923 
  924     final void setParent(Parent value) {
  925         parentPropertyImpl().set(value);
  926     }
  927 
  928     public final Parent getParent() {
  929         return parent == null ? null : parent.get();
  930     }
  931 
  932     public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
  933         return parentPropertyImpl().getReadOnlyProperty();
  934     }
  935 
  936     private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
  937         if (parent == null) {
  938             parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
  939                 private Parent oldParent;
  940 
  941                 @Override
  942                 protected void invalidated() {
  943                     if (oldParent != null) {
  944                         oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
  945                         oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
  946                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  947                             ((Node) oldParent).localToSceneTransformProperty().removeListener(
  948                                     nodeTransformation.getLocalToSceneInvalidationListener());
  949                         }
  950                     }
  951                     updateDisabled();
  952                     computeDerivedDepthTest();
  953                     final Parent newParent = get();
  954                     if (newParent != null) {
  955                         newParent.disabledProperty().addListener(parentDisabledChangedListener);
  956                         newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
  957                         if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
  958                             ((Node) newParent).localToSceneTransformProperty().addListener(
  959                                     nodeTransformation.getLocalToSceneInvalidationListener());
  960                         }
  961                         //
  962                         // if parent changed, then CSS needs to be reapplied so
  963                         // that this node will get the right styles. This used
  964                         // to be done from Parent.children&#39;s onChanged method.
  965                         // See the comments there, also.
  966                         //
  967                         reapplyCSS();
  968                     } else {
  969                         // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
  970                         // If flag is REAPPLY, then reapplyCSS() will just return and the call to
  971                         // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
  972                         cssFlag = CssFlags.CLEAN;
  973                     }
  974                     updateTreeVisible(true);
  975                     oldParent = newParent;
  976                     invalidateLocalToSceneTransform();
  977                     parentResolvedOrientationInvalidated();
  978                     notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
  979                 }
  980 
  981                 @Override
  982                 public Object getBean() {
  983                     return Node.this;
  984                 }
  985 
  986                 @Override
  987                 public String getName() {
  988                     return &quot;parent&quot;;
  989                 }
  990             };
  991         }
  992         return parent;
  993     }
  994 
  995     private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();
  996 
  997     private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);
  998 
  999     private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
 1000             = (win, oldVal, newVal) -&gt; updateTreeShowing();
 1001 
 1002     private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
 1003         // Replace the windowShowingListener and call updateTreeShowing()
 1004         if (oldWindow != null) {
 1005             oldWindow.showingProperty().removeListener(windowShowingChangedListener);
 1006         }
 1007         if (newWindow != null) {
 1008             newWindow.showingProperty().addListener(windowShowingChangedListener);
 1009         }
 1010         updateTreeShowing();
 1011     };
 1012 
 1013     private SubScene subScene = null;
 1014 
 1015     /**
 1016      * The {@link Scene} that this {@code Node} is part of. If the Node is not
 1017      * part of a scene, then this variable will be null.
 1018      *
 1019      * @defaultValue null
 1020      */
 1021     private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();
 1022 
 1023     private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
 1024         @Override
 1025         public Object getBean() {
 1026             return Node.this;
 1027         }
 1028 
 1029         @Override
 1030         public String getName() {
 1031             return &quot;scene&quot;;
 1032         }
 1033 
 1034         @Override
 1035         protected void fireValueChangedEvent() {
 1036             /*
 1037              * Note: This method has been intentionally made into a no-op. In
 1038              * order to override the default set behavior. By default calling
 1039              * set(...) on a different scene will trigger:
 1040              * - invalidated();
 1041              * - fireValueChangedEvent();
 1042              * Both of the above are no-ops, but are handled manually via
 1043              * - Node.this.setScenes(...)
 1044              * - Node.this.invalidatedScenes(...)
 1045              * - forceValueChangedEvent()
 1046              */
 1047         }
 1048 
 1049         public void fireSuperValueChangedEvent() {
 1050             super.fireValueChangedEvent();
 1051         }
 1052     }
 1053 
<a name="1" id="anc1"></a><span class="line-modified"> 1054     // reapplyCSS should be true for root elements when they are added, and is false for children</span>
<span class="line-removed"> 1055     // of the root element. This prevents CSS being reapplied recursively, as noted in JDK-8151756.</span>
<span class="line-removed"> 1056     private void invalidatedScenes(Scene oldScene, SubScene oldSubScene, boolean reapplyCSS) {</span>
 1057         Scene newScene = sceneProperty().get();
 1058         boolean sceneChanged = oldScene != newScene;
 1059         SubScene newSubScene = subScene;
 1060 
 1061         if (getClip() != null) {
<a name="2" id="anc2"></a><span class="line-modified"> 1062             getClip().setScenes(newScene, newSubScene, reapplyCSS);</span>
 1063         }
 1064         if (sceneChanged) {
 1065             updateCanReceiveFocus();
 1066             if (isFocusTraversable()) {
 1067                 if (newScene != null) {
 1068                     newScene.initializeInternalEventDispatcher();
 1069                 }
 1070             }
 1071             focusSetDirty(oldScene);
 1072             focusSetDirty(newScene);
 1073         }
 1074         scenesChanged(newScene, newSubScene, oldScene, oldSubScene);
 1075 
 1076         // isTreeShowing needs to take into account of Window&#39;s showing
 1077         if (oldScene != null) {
 1078             oldScene.windowProperty().removeListener(sceneWindowChangedListener);
 1079 
 1080             Window window = oldScene.windowProperty().get();
 1081             if (window != null) {
 1082                 window.showingProperty().removeListener(windowShowingChangedListener);
 1083             }
 1084         }
 1085         if (newScene != null) {
 1086             newScene.windowProperty().addListener(sceneWindowChangedListener);
 1087 
 1088             Window window = newScene.windowProperty().get();
 1089             if (window != null) {
 1090                 window.showingProperty().addListener(windowShowingChangedListener);
 1091             }
 1092 
 1093         }
 1094         updateTreeShowing();
 1095 
<a name="3" id="anc3"></a><span class="line-modified"> 1096         if (sceneChanged &amp;&amp; reapplyCSS) {</span>
<span class="line-removed"> 1097             reapplyCSS();</span>
<span class="line-removed"> 1098         }</span>
 1099 
 1100         if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
 1101             //Note: no need to remove from scene&#39;s dirty list
 1102             //Scene&#39;s is checking if the node&#39;s scene is correct
 1103             /* TODO: looks like an existing bug when a node is moved from one
 1104              * location to another, setScenes will be called twice by
 1105              * Parent.VetoableListDecorator onProposedChange and onChanged
 1106              * respectively. Removing the node and setting setScense(null,null)
 1107              * then adding it back to potentially the same scene. Causing the
 1108              * same node to being added twice to the same scene.
 1109              */
 1110             addToSceneDirtyList();
 1111         }
 1112 
 1113         if (newScene == null &amp;&amp; peer != null) {
 1114             peer.release();
 1115         }
 1116 
 1117         if (oldScene != null) {
 1118             oldScene.clearNodeMnemonics(this);
 1119         }
 1120         if (getParent() == null) {
 1121             // if we are the root we need to handle scene change
 1122             parentResolvedOrientationInvalidated();
 1123         }
 1124 
 1125         if (sceneChanged) { scene.fireSuperValueChangedEvent(); }
 1126 
 1127         /* Dispose the accessible peer, if any. If AT ever needs this node again
 1128          * a new accessible peer is created. */
 1129         if (accessible != null) {
 1130             /* Generally accessibility does not retain any state, therefore deleting objects
 1131              * generally does not cause problems (AT just asks everything back).
 1132              * The exception to this rule is when the object sends a notifications to the AT,
 1133              * in which case it is expected to be around to answer request for the new values.
 1134              * It is possible that a object is reparented (within the scene) in the middle of
 1135              * this process. For example, when a tree item is expanded, the notification is
 1136              * sent to the AT by the cell. But when the TreeView relayouts the cell can be
 1137              * reparented before AT can query the relevant information about the expand event.
 1138              * If the accessible was disposed, AT can&#39;t properly report the event.
 1139              *
 1140              * The fix is to defer the disposal of the accessible to the next pulse.
 1141              * If at that time the node is placed back to the scene, then the accessible is hooked
 1142              * to Node and AT requests are processed. Otherwise the accessible is disposed.
 1143              */
 1144             if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
 1145                 // Strictly speaking we need some type of accessible.thaw() at this point.
 1146                 oldScene.addAccessible(Node.this, accessible);
 1147             } else {
 1148                 accessible.dispose();
 1149             }
 1150             /* Always set to null to ensure this accessible is never on more than one
 1151              * Scene#accMap at the same time (At lest not with the same accessible).
 1152              */
 1153             accessible = null;
 1154         }
 1155     }
 1156 
<a name="4" id="anc4"></a><span class="line-modified"> 1157     final void setScenes(Scene newScene, SubScene newSubScene, boolean reapplyCSS) {</span>
 1158         Scene oldScene = sceneProperty().get();
 1159         if (newScene != oldScene || newSubScene != subScene) {
 1160             scene.set(newScene);
 1161             SubScene oldSubScene = subScene;
 1162             subScene = newSubScene;
<a name="5" id="anc5"></a><span class="line-modified"> 1163             invalidatedScenes(oldScene, oldSubScene, reapplyCSS);</span>
 1164             if (this instanceof SubScene) { // TODO: find better solution
 1165                 SubScene thisSubScene = (SubScene)this;
<a name="6" id="anc6"></a><span class="line-modified"> 1166                 thisSubScene.getRoot().setScenes(newScene, thisSubScene, reapplyCSS);</span>
 1167             }
 1168         }
 1169     }
 1170 
 1171     final SubScene getSubScene() {
 1172         return subScene;
 1173     }
 1174 
 1175     public final Scene getScene() {
 1176         return scene.get();
 1177     }
 1178 
 1179     public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
 1180         return scene.getReadOnlyProperty();
 1181     }
 1182 
 1183     /**
 1184      * Exists for Parent and LightBase
 1185      */
 1186     void scenesChanged(final Scene newScene, final SubScene newSubScene,
<a name="7" id="anc7"></a><span class="line-modified"> 1187                        final Scene oldScene, final SubScene oldSubScene) {</span>
<span class="line-modified"> 1188         // On scenes change, reapply CSS for this Node</span>
<span class="line-removed"> 1189         reapplyCSS();</span>
<span class="line-removed"> 1190     }</span>
 1191 
 1192     /**
 1193      * The id of this {@code Node}. This simple string identifier is useful for
 1194      * finding a specific Node within the scene graph. While the id of a Node
 1195      * should be unique within the scene graph, this uniqueness is not enforced.
 1196      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1197      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1198      * &lt;p&gt;
 1199      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1200      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1201      * &lt;/p&gt;
 1202      *
 1203      * @defaultValue null
 1204      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1205      */
 1206     private StringProperty id;
 1207 
 1208     public final void setId(String value) {
 1209         idProperty().set(value);
 1210     }
 1211 
 1212     //TODO: this is copied from the property in order to add the @return statement.
 1213     //      We should have a better, general solution without the need to copy it.
 1214     /**
 1215      * The id of this {@code Node}. This simple string identifier is useful for
 1216      * finding a specific Node within the scene graph. While the id of a Node
 1217      * should be unique within the scene graph, this uniqueness is not enforced.
 1218      * This is analogous to the &quot;id&quot; attribute on an HTML element
 1219      * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
 1220      *
 1221      * @return the id assigned to this {@code Node} using the {@code setId}
 1222      *         method or {@code null}, if no id has been assigned.
 1223      * @defaultValue null
 1224      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1225      */
 1226     public final String getId() {
 1227         return id == null ? null : id.get();
 1228     }
 1229 
 1230     public final StringProperty idProperty() {
 1231         if (id == null) {
 1232             id = new StringPropertyBase() {
 1233 
 1234                 @Override
 1235                 protected void invalidated() {
 1236                     reapplyCSS();
 1237                     if (PrismSettings.printRenderGraph) {
 1238                         NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
 1239                     }
 1240                 }
 1241 
 1242                 @Override
 1243                 public Object getBean() {
 1244                     return Node.this;
 1245                 }
 1246 
 1247                 @Override
 1248                 public String getName() {
 1249                     return &quot;id&quot;;
 1250                 }
 1251             };
 1252         }
 1253         return id;
 1254     }
 1255 
 1256     /**
 1257      * A list of String identifiers which can be used to logically group
 1258      * Nodes, specifically for an external style engine. This variable is
 1259      * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
 1260      * each element of the list is a style class to which this Node belongs.
 1261      *
 1262      * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
 1263      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1264      * @defaultValue null
 1265      */
 1266     private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
 1267         @Override
 1268         protected void onChanged(Change&lt;String&gt; c) {
 1269             reapplyCSS();
 1270         }
 1271 
 1272         @Override
 1273         public String toString() {
 1274             if (size() == 0) {
 1275                 return &quot;&quot;;
 1276             } else if (size() == 1) {
 1277                 return get(0);
 1278             } else {
 1279                 StringBuilder buf = new StringBuilder();
 1280                 for (int i = 0; i &lt; size(); i++) {
 1281                     buf.append(get(i));
 1282                     if (i + 1 &lt; size()) {
 1283                         buf.append(&#39; &#39;);
 1284                     }
 1285                 }
 1286                 return buf.toString();
 1287             }
 1288         }
 1289     };
 1290 
 1291     @Override
 1292     public final ObservableList&lt;String&gt; getStyleClass() {
 1293         return styleClass;
 1294     }
 1295 
 1296     /**
 1297      * A string representation of the CSS style associated with this
 1298      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1299      * HTML element. Note that, like the HTML style attribute, this
 1300      * variable contains style properties and values and not the
 1301      * selector portion of a style rule.
 1302      * @defaultValue empty string
 1303      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
 1304      */
 1305     private StringProperty style;
 1306 
 1307     /**
 1308      * A string representation of the CSS style associated with this
 1309      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1310      * HTML element. Note that, like the HTML style attribute, this
 1311      * variable contains style properties and values and not the
 1312      * selector portion of a style rule.
 1313      * @param value The inline CSS style to use for this {@code Node}.
 1314      *         {@code null} is implicitly converted to an empty String.
 1315      * @defaultValue empty string
 1316      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1317      */
 1318     public final void setStyle(String value) {
 1319         styleProperty().set(value);
 1320     }
 1321 
 1322     // TODO: javadoc copied from property for the sole purpose of providing a return tag
 1323     /**
 1324      * A string representation of the CSS style associated with this
 1325      * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
 1326      * HTML element. Note that, like the HTML style attribute, this
 1327      * variable contains style properties and values and not the
 1328      * selector portion of a style rule.
 1329      * @defaultValue empty string
 1330      * @return The inline CSS style associated with this {@code Node}.
 1331      *         If this {@code Node} does not have an inline style,
 1332      *         an empty String is returned.
 1333      * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
 1334      */
 1335     public final String getStyle() {
 1336         return style == null ? &quot;&quot; : style.get();
 1337     }
 1338 
 1339     public final StringProperty styleProperty() {
 1340         if (style == null) {
 1341             style = new StringPropertyBase(&quot;&quot;) {
 1342 
 1343                 @Override public void set(String value) {
 1344                     // getStyle returns an empty string if the style property
 1345                     // is null. To be consistent, getStyle should also return
 1346                     // an empty string when the style property&#39;s value is null.
 1347                     super.set((value != null) ? value : &quot;&quot;);
 1348                 }
 1349 
 1350                 @Override
 1351                 protected void invalidated() {
 1352                     // If the style has changed, then styles of this node
 1353                     // and child nodes might be affected.
 1354                     reapplyCSS();
 1355                 }
 1356 
 1357                 @Override
 1358                 public Object getBean() {
 1359                     return Node.this;
 1360                 }
 1361 
 1362                 @Override
 1363                 public String getName() {
 1364                     return &quot;style&quot;;
 1365                 }
 1366             };
 1367         }
 1368         return style;
 1369     }
 1370 
 1371     /**
 1372      * Specifies whether this {@code Node} and any subnodes should be rendered
 1373      * as part of the scene graph. A node may be visible and yet not be shown
 1374      * in the rendered scene if, for instance, it is off the screen or obscured
 1375      * by another Node. Invisible nodes never receive mouse events or
 1376      * keyboard focus and never maintain keyboard focus when they become
 1377      * invisible.
 1378      *
 1379      * @defaultValue true
 1380      */
 1381     private BooleanProperty visible;
 1382 
 1383     public final void setVisible(boolean value) {
 1384         visibleProperty().set(value);
 1385     }
 1386 
 1387     public final boolean isVisible() {
 1388         return visible == null ? true : visible.get();
 1389     }
 1390 
 1391     public final BooleanProperty visibleProperty() {
 1392         if (visible == null) {
 1393             visible = new StyleableBooleanProperty(true) {
 1394                 boolean oldValue = true;
 1395                 @Override
 1396                 protected void invalidated() {
 1397                     if (oldValue != get()) {
 1398                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
 1399                         NodeHelper.geomChanged(Node.this);
 1400                         updateTreeVisible(false);
 1401                         if (getParent() != null) {
 1402                             // notify the parent of the potential change in visibility
 1403                             // of this node, since visibility affects bounds of the
 1404                             // parent node
 1405                             getParent().childVisibilityChanged(Node.this);
 1406                         }
 1407                         oldValue = get();
 1408                     }
 1409                 }
 1410 
 1411                 @Override
 1412                 public CssMetaData getCssMetaData() {
 1413                     return StyleableProperties.VISIBILITY;
 1414                 }
 1415 
 1416                 @Override
 1417                 public Object getBean() {
 1418                     return Node.this;
 1419                 }
 1420 
 1421                 @Override
 1422                 public String getName() {
 1423                     return &quot;visible&quot;;
 1424                 }
 1425             };
 1426         }
 1427         return visible;
 1428     }
 1429 
 1430     public final void setCursor(Cursor value) {
 1431         cursorProperty().set(value);
 1432     }
 1433 
 1434     public final Cursor getCursor() {
 1435         return (miscProperties == null) ? DEFAULT_CURSOR
 1436                                         : miscProperties.getCursor();
 1437     }
 1438 
 1439     /**
 1440      * Defines the mouse cursor for this {@code Node} and subnodes. If null,
 1441      * then the cursor of the first parent node with a non-null cursor will be
 1442      * used. If no Node in the scene graph defines a cursor, then the cursor
 1443      * of the {@code Scene} will be used.
 1444      *
 1445      * @return the mouse cursor for this {@code Node} and subnodes
 1446      * @defaultValue null
 1447      */
 1448     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 1449         return getMiscProperties().cursorProperty();
 1450     }
 1451 
 1452     /**
 1453      * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
 1454      * with 0% opacity is fully translucent. That is, while it is still
 1455      * {@link #visibleProperty visible} and rendered, you generally won&#39;t be able to see it. The
 1456      * exception to this rule is when the {@code Node} is combined with a
 1457      * blending mode and blend effect in which case a translucent Node may still
 1458      * have an impact in rendering. An opacity of 50% will render the node as
 1459      * being 50% transparent.
 1460      * &lt;p&gt;
 1461      * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
 1462      * events and can receive keyboard focus. For example, if you want to have
 1463      * a large invisible rectangle overlay all {@code Node}s in the scene graph
 1464      * in order to intercept mouse events but not be visible to the user, you could
 1465      * create a large {@code Rectangle} that had an opacity of 0%.
 1466      * &lt;p&gt;
 1467      * Opacity is specified as a value between 0 and 1. Values less than 0 are
 1468      * treated as 0, values greater than 1 are treated as 1.
 1469      * &lt;p&gt;
 1470      * On some platforms ImageView might not support opacity variable.
 1471      *
 1472      * &lt;p&gt;
 1473      * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
 1474      * Opacity/Blending is essentially a 2D image operation. The result of
 1475      * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
 1476      * will cause its children to be rendered in order without Z-buffering
 1477      * applied between those children.
 1478      *
 1479      * @defaultValue 1.0
 1480      */
 1481     private DoubleProperty opacity;
 1482 
 1483     public final void setOpacity(double value) {
 1484         opacityProperty().set(value);
 1485     }
 1486     public final double getOpacity() {
 1487         return opacity == null ? 1 : opacity.get();
 1488     }
 1489 
 1490     public final DoubleProperty opacityProperty() {
 1491         if (opacity == null) {
 1492             opacity = new StyleableDoubleProperty(1) {
 1493 
 1494                 @Override
 1495                 public void invalidated() {
 1496                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
 1497                 }
 1498 
 1499                 @Override
 1500                 public CssMetaData getCssMetaData() {
 1501                     return StyleableProperties.OPACITY;
 1502                 }
 1503 
 1504                 @Override
 1505                 public Object getBean() {
 1506                     return Node.this;
 1507                 }
 1508 
 1509                 @Override
 1510                 public String getName() {
 1511                     return &quot;opacity&quot;;
 1512                 }
 1513             };
 1514         }
 1515         return opacity;
 1516     }
 1517 
 1518     /**
 1519      * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
 1520      * into the scene behind it. If this node is a {@code Group}, then all of the
 1521      * children will be composited individually into a temporary buffer using their
 1522      * own blend modes and then that temporary buffer will be composited into the
 1523      * scene using the specified blend mode.
 1524      *
 1525      * A value of {@code null} is treated as pass-through. This means no effect on a
 1526      * parent (such as a {@code Group}), and the equivalent of {@code SRC_OVER} for a single {@code Node}.
 1527      *
 1528      * @defaultValue {@code null}
 1529      */
 1530     private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;
 1531 
 1532     public final void setBlendMode(BlendMode value) {
 1533         blendModeProperty().set(value);
 1534     }
 1535     public final BlendMode getBlendMode() {
 1536         return blendMode == null ? null : blendMode.get();
 1537     }
 1538 
 1539     public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
 1540         if (blendMode == null) {
 1541             blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
 1542                 @Override public void invalidated() {
 1543                     NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
 1544                 }
 1545 
 1546                 @Override
 1547                 public CssMetaData getCssMetaData() {
 1548                     return StyleableProperties.BLEND_MODE;
 1549                 }
 1550 
 1551                 @Override
 1552                 public Object getBean() {
 1553                     return Node.this;
 1554                 }
 1555 
 1556                 @Override
 1557                 public String getName() {
 1558                     return &quot;blendMode&quot;;
 1559                 }
 1560             };
 1561         }
 1562         return blendMode;
 1563     }
 1564 
 1565     public final void setClip(Node value) {
 1566         clipProperty().set(value);
 1567     }
 1568 
 1569     public final Node getClip() {
 1570         return (miscProperties == null) ? DEFAULT_CLIP
 1571                                         : miscProperties.getClip();
 1572     }
 1573 
 1574     /**
 1575      * Specifies a {@code Node} to use to define the the clipping shape for this
 1576      * Node. This clipping Node is not a child of this {@code Node} in the scene
 1577      * graph sense. Rather, it is used to define the clip for this {@code Node}.
 1578      * &lt;p&gt;
 1579      * For example, you can use an {@link javafx.scene.image.ImageView} Node as
 1580      * a mask to represent the Clip. Or you could use one of the geometric shape
 1581      * Nodes such as {@link javafx.scene.shape.Rectangle} or
 1582      * {@link javafx.scene.shape.Circle}. Or you could use a
 1583      * {@link javafx.scene.text.Text} node to represent the Clip.
 1584      * &lt;p&gt;
 1585      * See the class documentation for {@link Node} for scene graph structure
 1586      * restrictions on setting the clip. If these restrictions are violated by
 1587      * a change to the clip variable, the change is ignored and the
 1588      * previous value of the clip variable is restored.
 1589      * &lt;p&gt;
 1590      * Note that this is a conditional feature. See
 1591      * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
 1592      * for more information.
 1593      * &lt;p&gt;
 1594      * There is a known limitation of mixing Clip with a 3D Transform.
 1595      * Clipping is essentially a 2D image operation. The result of
 1596      * a Clip set on a {@link Group} node with 3D transformed children
 1597      * will cause its children to be rendered in order without Z-buffering
 1598      * applied between those children.
 1599      *
 1600      * @return the the clipping shape for this {@code Node}
 1601      * @defaultValue null
 1602      */
 1603     public final ObjectProperty&lt;Node&gt; clipProperty() {
 1604         return getMiscProperties().clipProperty();
 1605     }
 1606 
 1607     public final void setCache(boolean value) {
 1608         cacheProperty().set(value);
 1609     }
 1610 
 1611     public final boolean isCache() {
 1612         return (miscProperties == null) ? DEFAULT_CACHE
 1613                                         : miscProperties.isCache();
 1614     }
 1615 
 1616     /**
 1617      * A performance hint to the system to indicate that this {@code Node}
 1618      * should be cached as a bitmap. Rendering a bitmap representation of a node
 1619      * will be faster than rendering primitives in many cases, especially in the
 1620      * case of primitives with effects applied (such as a blur). However, it
 1621      * also increases memory usage. This hint indicates whether that trade-off
 1622      * (increased memory usage for increased performance) is worthwhile. Also
 1623      * note that on some platforms such as GPU accelerated platforms there is
 1624      * little benefit to caching Nodes as bitmaps when blurs and other effects
 1625      * are used since they are very fast to render on the GPU.
 1626      *
 1627      * The {@link #cacheHintProperty} variable provides additional options for enabling
 1628      * more aggressive bitmap caching.
 1629      *
 1630      * &lt;p&gt;
 1631      * Caching may be disabled for any node that has a 3D transform on itself,
 1632      * any of its ancestors, or any of its descendants.
 1633      *
 1634      * @return the hint to cache for this {@code Node}
 1635      * @see #cacheHintProperty
 1636      * @defaultValue false
 1637      */
 1638     public final BooleanProperty cacheProperty() {
 1639         return getMiscProperties().cacheProperty();
 1640     }
 1641 
 1642     public final void setCacheHint(CacheHint value) {
 1643         cacheHintProperty().set(value);
 1644     }
 1645 
 1646     public final CacheHint getCacheHint() {
 1647         return (miscProperties == null) ? DEFAULT_CACHE_HINT
 1648                                         : miscProperties.getCacheHint();
 1649     }
 1650 
 1651     /**
 1652      * Additional hint for controlling bitmap caching.
 1653      * &lt;p&gt;
 1654      * Under certain circumstances, such as animating nodes that are very
 1655      * expensive to render, it is desirable to be able to perform
 1656      * transformations on the node without having to regenerate the cached
 1657      * bitmap.  An option in such cases is to perform the transforms on the
 1658      * cached bitmap itself.
 1659      * &lt;p&gt;
 1660      * This technique can provide a dramatic improvement to animation
 1661      * performance, though may also result in a reduction in visual quality.
 1662      * The {@code cacheHint} variable provides a hint to the system about how
 1663      * and when that trade-off (visual quality for animation performance) is
 1664      * acceptable.
 1665      * &lt;p&gt;
 1666      * It is possible to enable the cacheHint only at times when your node is
 1667      * animating.  In this way, expensive nodes can appear on screen with full
 1668      * visual quality, yet still animate smoothly.
 1669      * &lt;p&gt;
 1670      * Example:
 1671      * &lt;pre&gt;{@code
 1672         expensiveNode.setCache(true);
 1673         expensiveNode.setCacheHint(CacheHint.QUALITY);
 1674         ...
 1675         // Do an animation
 1676         expensiveNode.setCacheHint(CacheHint.SPEED);
 1677         new Timeline(
 1678             new KeyFrame(Duration.seconds(2),
 1679                 new KeyValue(expensiveNode.scaleXProperty(), 2.0),
 1680                 new KeyValue(expensiveNode.scaleYProperty(), 2.0),
 1681                 new KeyValue(expensiveNode.rotateProperty(), 360),
 1682                 new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
 1683             )
 1684         ).play();
 1685      }&lt;/pre&gt;
 1686      *
 1687      * Note that {@code cacheHint} is only a hint to the system.  Depending on
 1688      * the details of the node or the transform, this hint may be ignored.
 1689      *
 1690      * &lt;p&gt;
 1691      * If {@code Node.cache} is false, cacheHint is ignored.
 1692      * Caching may be disabled for any node that has a 3D transform on itself,
 1693      * any of its ancestors, or any of its descendants.
 1694      *
 1695      * @return the {@code CacheHint} for this {@code Node}
 1696      * @see #cacheProperty
 1697      * @defaultValue CacheHint.DEFAULT
 1698      */
 1699     public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 1700         return getMiscProperties().cacheHintProperty();
 1701     }
 1702 
 1703     public final void setEffect(Effect value) {
 1704         effectProperty().set(value);
 1705     }
 1706 
 1707     public final Effect getEffect() {
 1708         return (miscProperties == null) ? DEFAULT_EFFECT
 1709                                         : miscProperties.getEffect();
 1710     }
 1711 
 1712     /**
 1713      * Specifies an effect to apply to this {@code Node}.
 1714      * &lt;p&gt;
 1715      * Note that this is a conditional feature. See
 1716      * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
 1717      * for more information.
 1718      *
 1719      * &lt;p&gt;
 1720      * There is a known limitation of mixing Effect with a 3D Transform. Effect is
 1721      * essentially a 2D image operation. The result of an Effect set on
 1722      * a {@link Group} node with 3D transformed children will cause its children
 1723      * to be rendered in order without Z-buffering applied between those
 1724      * children.
 1725      *
 1726      * @return the effect for this {@code Node}
 1727      * @defaultValue null
 1728      */
 1729     public final ObjectProperty&lt;Effect&gt; effectProperty() {
 1730         return getMiscProperties().effectProperty();
 1731     }
 1732 
 1733     public final void setDepthTest(DepthTest value) {
 1734         depthTestProperty().set(value);
 1735     }
 1736 
 1737     public final DepthTest getDepthTest() {
 1738         return (miscProperties == null) ? DEFAULT_DEPTH_TEST
 1739                                         : miscProperties.getDepthTest();
 1740     }
 1741 
 1742     /**
 1743      * Indicates whether depth testing is used when rendering this node.
 1744      * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
 1745      * is disabled for this node.
 1746      * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
 1747      * is enabled for this node.
 1748      * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
 1749      * is enabled for this node if it is enabled for the parent node or the
 1750      * parent node is null.
 1751      * &lt;p&gt;
 1752      * The depthTest flag is only used when the depthBuffer flag for
 1753      * the {@link Scene} is true (meaning that the
 1754      * {@link Scene} has an associated depth buffer)
 1755      * &lt;p&gt;
 1756      * Depth test comparison is only done among nodes with depthTest enabled.
 1757      * A node with depthTest disabled does not read, test, or write the depth buffer,
 1758      * that is to say its Z value will not be considered for depth testing
 1759      * with other nodes.
 1760      * &lt;p&gt;
 1761      * Note that this is a conditional feature. See
 1762      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 1763      * for more information.
 1764      * &lt;p&gt;
 1765      * See the constructor in Scene with depthBuffer as one of its input
 1766      * arguments.
 1767      *
 1768      * @return the depth test setting for this {@code Node}
 1769      * @see javafx.scene.Scene
 1770      * @defaultValue INHERIT
 1771      */
 1772     public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 1773         return getMiscProperties().depthTestProperty();
 1774     }
 1775 
 1776     /**
 1777      * Recompute the derived depth test flag. This flag is true
 1778      * if the depthTest flag for this node is true and the
 1779      * depth test flag for each ancestor node is true. It is false
 1780      * otherwise. Equivalently, the derived depth flag is true
 1781      * if the depthTest flag for this node is true and the derivedDepthTest
 1782      * flag for its parent is true.
 1783      */
 1784     void computeDerivedDepthTest() {
 1785         boolean newDDT;
 1786         if (getDepthTest() == DepthTest.INHERIT) {
 1787             if (getParent() != null) {
 1788                 newDDT = getParent().isDerivedDepthTest();
 1789             } else {
 1790                 newDDT = true;
 1791             }
 1792         } else if (getDepthTest() == DepthTest.ENABLE) {
 1793             newDDT = true;
 1794         } else {
 1795             newDDT = false;
 1796         }
 1797 
 1798         if (isDerivedDepthTest() != newDDT) {
 1799             NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
 1800             setDerivedDepthTest(newDDT);
 1801         }
 1802     }
 1803 
 1804     // This is the derived depthTest value to pass to PG level
 1805     private boolean derivedDepthTest = true;
 1806 
 1807     void setDerivedDepthTest(boolean value) {
 1808         derivedDepthTest = value;
 1809     }
 1810 
 1811     boolean isDerivedDepthTest() {
 1812         return derivedDepthTest;
 1813     }
 1814 
 1815     public final void setDisable(boolean value) {
 1816         disableProperty().set(value);
 1817     }
 1818 
 1819     public final boolean isDisable() {
 1820         return (miscProperties == null) ? DEFAULT_DISABLE
 1821                                         : miscProperties.isDisable();
 1822     }
 1823 
 1824     /**
 1825      * Defines the individual disabled state of this {@code Node}. Setting
 1826      * {@code disable} to true will cause this {@code Node} and any subnodes to
 1827      * become disabled. This property should be used only to set the disabled
 1828      * state of a {@code Node}.  For querying the disabled state of a
 1829      * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
 1830      * since it is possible that a {@code Node} was disabled as a result of an
 1831      * ancestor being disabled even if the individual {@code disable} state on
 1832      * this {@code Node} is {@code false}.
 1833      *
 1834      * @return the disabled state for this {@code Node}
 1835      * @defaultValue false
 1836      */
 1837     public final BooleanProperty disableProperty() {
 1838         return getMiscProperties().disableProperty();
 1839     }
 1840 
 1841 
 1842 //    /**
 1843 //     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
 1844 //     */
 1845 //    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
 1846 //        if (inputMap == null) {
 1847 //            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
 1848 //                private InputMap&lt;?&gt; currentMap = get();
 1849 //                @Override protected void invalidated() {
 1850 //                    if (currentMap != null) {
 1851 //                        currentMap.dispose();
 1852 //                    }
 1853 //                    currentMap = get();
 1854 //                }
 1855 //            };
 1856 //        }
 1857 //        return inputMap;
 1858 //    }
 1859 //    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
 1860 //    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
 1861 //    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;
 1862 
 1863 
 1864     /**************************************************************************
 1865      *                                                                        *
 1866      *
 1867      *                                                                        *
 1868      *************************************************************************/
 1869     /**
 1870      * Defines how the picking computation is done for this node when
 1871      * triggered by a {@code MouseEvent} or a {@code contains} function call.
 1872      *
 1873      * If {@code pickOnBounds} is {@code true}, then picking is computed by
 1874      * intersecting with the bounds of this node, else picking is computed
 1875      * by intersecting with the geometric shape of this node.
 1876      *
 1877      * The default value of this property is {@code false} unless
 1878      * overridden by a subclass. The default value is {@code true}
 1879      * for {@link javafx.scene.layout.Region}.
 1880      *
 1881      * @defaultValue false; true for {@code Region}
 1882      */
 1883     private BooleanProperty pickOnBounds;
 1884 
 1885     public final void setPickOnBounds(boolean value) {
 1886         pickOnBoundsProperty().set(value);
 1887     }
 1888 
 1889     public final boolean isPickOnBounds() {
 1890         return pickOnBounds == null ? false : pickOnBounds.get();
 1891     }
 1892 
 1893     public final BooleanProperty pickOnBoundsProperty() {
 1894         if (pickOnBounds == null) {
 1895             pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
 1896         }
 1897         return pickOnBounds;
 1898     }
 1899 
 1900     /**
 1901      * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
 1902      * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
 1903      * itself or one of its ancestors in the scene graph.
 1904      * &lt;p&gt;
 1905      * A disabled {@code Node} should render itself differently to indicate its
 1906      * disabled state to the user.
 1907      * Such disabled rendering is dependent on the implementation of the
 1908      * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
 1909      * do not implement such rendering by default, therefore applications using
 1910      * shapes for handling input must implement appropriate disabled rendering
 1911      * themselves. The user-interface controls defined in
 1912      * {@code javafx.scene.control} will implement disabled-sensitive rendering,
 1913      * however.
 1914      * &lt;p&gt;
 1915      * A disabled {@code Node} does not receive mouse or key events.
 1916      *
 1917      * @defaultValue false
 1918      */
 1919     private ReadOnlyBooleanWrapper disabled;
 1920 
 1921     protected final void setDisabled(boolean value) {
 1922         disabledPropertyImpl().set(value);
 1923     }
 1924 
 1925     public final boolean isDisabled() {
 1926         return disabled == null ? false : disabled.get();
 1927     }
 1928 
 1929     public final ReadOnlyBooleanProperty disabledProperty() {
 1930         return disabledPropertyImpl().getReadOnlyProperty();
 1931     }
 1932 
 1933     private ReadOnlyBooleanWrapper disabledPropertyImpl() {
 1934         if (disabled == null) {
 1935             disabled = new ReadOnlyBooleanWrapper() {
 1936 
 1937                 @Override
 1938                 protected void invalidated() {
 1939                     pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
 1940                     updateCanReceiveFocus();
 1941                     focusSetDirty(getScene());
 1942                 }
 1943 
 1944                 @Override
 1945                 public Object getBean() {
 1946                     return Node.this;
 1947                 }
 1948 
 1949                 @Override
 1950                 public String getName() {
 1951                     return &quot;disabled&quot;;
 1952                 }
 1953             };
 1954         }
 1955         return disabled;
 1956     }
 1957 
 1958     private void updateDisabled() {
 1959         boolean isDisabled = isDisable();
 1960         if (!isDisabled) {
 1961             isDisabled = getParent() != null ? getParent().isDisabled() :
 1962                     getSubScene() != null &amp;&amp; getSubScene().isDisabled();
 1963         }
 1964         setDisabled(isDisabled);
 1965         if (this instanceof SubScene) {
 1966             ((SubScene)this).getRoot().setDisabled(isDisabled);
 1967         }
 1968     }
 1969 
 1970     /**
 1971      * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
 1972      * If this node is a {@code Parent}, then this function will traverse down
 1973      * into the branch until it finds a match. If more than one sub-node matches the
 1974      * specified selector, this function returns the first of them.
 1975      * &lt;p&gt;
 1976      *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
 1977      *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
 1978      * &lt;/p&gt;
 1979      *
 1980      * @param selector The css selector of the node to find
 1981      * @return The first node, starting from this {@code Node}, which matches
 1982      *         the CSS {@code selector}, null if none is found.
 1983      */
 1984     public Node lookup(String selector) {
 1985         if (selector == null) return null;
 1986         Selector s = Selector.createSelector(selector);
 1987         return s != null &amp;&amp; s.applies(this) ? this : null;
 1988     }
 1989 
 1990     /**
 1991      * Finds all {@code Node}s, including this one and any children, which match
 1992      * the given CSS selector. If no matches are found, an empty unmodifiable set is
 1993      * returned. The set is explicitly unordered.
 1994      *
 1995      * @param selector The css selector of the nodes to find
 1996      * @return All nodes, starting from and including this {@code Node}, which match
 1997      *         the CSS {@code selector}. The returned set is always unordered and
 1998      *         unmodifiable, and never null.
 1999      */
 2000     public Set&lt;Node&gt; lookupAll(String selector) {
 2001         final Selector s = Selector.createSelector(selector);
 2002         final Set&lt;Node&gt; empty = Collections.emptySet();
 2003         if (s == null) return empty;
 2004         List&lt;Node&gt; results = lookupAll(s, null);
 2005         return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
 2006     }
 2007 
 2008     /**
 2009      * Used by Node and Parent for traversing the tree and adding all nodes which
 2010      * match the given selector.
 2011      *
 2012      * @param selector The Selector. This will never be null.
 2013      * @param results The results. This will never be null.
 2014      */
 2015     List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
 2016         if (selector.applies(this)) {
 2017             // Lazily create the set to reduce some trash.
 2018             if (results == null) {
 2019                 results = new LinkedList&lt;Node&gt;();
 2020             }
 2021             results.add(this);
 2022         }
 2023         return results;
 2024     }
 2025 
 2026     /**
 2027      * Moves this {@code Node} to the back of its sibling nodes in terms of
 2028      * z-order.  This is accomplished by moving this {@code Node} to the
 2029      * first position in its parent&#39;s {@code content} ObservableList.
 2030      * This function has no effect if this {@code Node} is not part of a group.
 2031      */
 2032     public void toBack() {
 2033         if (getParent() != null) {
 2034             getParent().toBack(this);
 2035         }
 2036     }
 2037 
 2038     /**
 2039      * Moves this {@code Node} to the front of its sibling nodes in terms of
 2040      * z-order.  This is accomplished by moving this {@code Node} to the
 2041      * last position in its parent&#39;s {@code content} ObservableList.
 2042      * This function has no effect if this {@code Node} is not part of a group.
 2043      */
 2044     public void toFront() {
 2045         if (getParent() != null) {
 2046             getParent().toFront(this);
 2047         }
 2048     }
 2049 
 2050     // TODO: need to verify whether this is OK to do starting from a node in
 2051     // the scene graph other than the root.
 2052     private void doCSSPass() {
 2053         if (this.cssFlag != CssFlags.CLEAN) {
 2054             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 2055             // The cssFlag is set to clean in either Node.processCSS or
 2056             // NodeHelper.processCSS
 2057 
 2058             // Don&#39;t clear the dirty bit in case it will cause problems
 2059             // with a full CSS pass on the scene.
 2060             // TODO: is this the right thing to do?
 2061             // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 2062 
 2063             this.processCSS();
 2064         }
 2065     }
 2066 
 2067     /**
 2068      * Recursive function for synchronizing a node and all descendents
 2069      */
 2070     private static void syncAll(Node node) {
 2071         node.syncPeer();
 2072         if (node instanceof Parent) {
 2073             Parent p = (Parent) node;
 2074             final int childrenCount = p.getChildren().size();
 2075 
 2076             for (int i = 0; i &lt; childrenCount; i++) {
 2077                 Node n = p.getChildren().get(i);
 2078                 if (n != null) {
 2079                     syncAll(n);
 2080                 }
 2081             }
 2082         }
 2083         if (node.getClip() != null) {
 2084             syncAll(node.getClip());
 2085         }
 2086     }
 2087 
 2088     private void doLayoutPass() {
 2089         if (this instanceof Parent) {
 2090             // TODO: As an optimization we only need to layout those dirty
 2091             // roots that are descendants of this node
 2092             Parent p = (Parent)this;
 2093             for (int i = 0; i &lt; 3; i++) {
 2094                 p.layout();
 2095             }
 2096         }
 2097     }
 2098 
 2099     private void doCSSLayoutSyncForSnapshot() {
 2100         doCSSPass();
 2101         doLayoutPass();
 2102         updateBounds();
 2103         Scene.setAllowPGAccess(true);
 2104         syncAll(this);
 2105         Scene.setAllowPGAccess(false);
 2106     }
 2107 
 2108     private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
 2109         if (getScene() != null) {
 2110             getScene().doCSSLayoutSyncForSnapshot(this);
 2111         } else {
 2112             doCSSLayoutSyncForSnapshot();
 2113         }
 2114 
 2115         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
 2116         if (params.getTransform() != null) {
 2117             Affine3D tempTx = new Affine3D();
 2118             TransformHelper.apply(params.getTransform(), tempTx);
 2119             transform = tempTx;
 2120         }
 2121         double x;
 2122         double y;
 2123         double w;
 2124         double h;
 2125         Rectangle2D viewport = params.getViewport();
 2126         if (viewport != null) {
 2127             // Use the specified viewport
 2128             x = viewport.getMinX();
 2129             y = viewport.getMinY();
 2130             w = viewport.getWidth();
 2131             h = viewport.getHeight();
 2132         } else {
 2133             // Get the bounds in parent of this node, transformed by the
 2134             // specified transform.
 2135             BaseBounds tempBounds = TempState.getInstance().bounds;
 2136             tempBounds = getTransformedBounds(tempBounds, transform);
 2137             x = tempBounds.getMinX();
 2138             y = tempBounds.getMinY();
 2139             w = tempBounds.getWidth();
 2140             h = tempBounds.getHeight();
 2141         }
 2142         WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
 2143                 this, transform, params.isDepthBufferInternal(),
 2144                 params.getFill(), params.getEffectiveCamera(), img);
 2145 
 2146         return result;
 2147     }
 2148 
 2149     /**
 2150      * Takes a snapshot of this node and returns the rendered image when
 2151      * it is ready.
 2152      * CSS and layout processing will be done for the node, and any of its
 2153      * children, prior to rendering it.
 2154      * The entire destination image is cleared to the fill {@code Paint}
 2155      * specified by the SnapshotParameters. This node is then rendered to
 2156      * the image.
 2157      * If the viewport specified by the SnapshotParameters is null, the
 2158      * upper-left pixel of the {@code boundsInParent} of this
 2159      * node, after first applying the transform specified by the
 2160      * SnapshotParameters,
 2161      * is mapped to the upper-left pixel (0,0) in the image.
 2162      * If a non-null viewport is specified,
 2163      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2164      * (0,0) in the image.
 2165      * In both cases, this mapping to (0,0) of the image is done with an integer
 2166      * translation. The portion of the node that is outside of the rendered
 2167      * image will be clipped by the image.
 2168      *
 2169      * &lt;p&gt;
 2170      * When taking a snapshot of a scene that is being animated, either
 2171      * explicitly by the application or implicitly (such as chart animation),
 2172      * the snapshot will be rendered based on the state of the scene graph at
 2173      * the moment the snapshot is taken and will not reflect any subsequent
 2174      * animation changes.
 2175      * &lt;/p&gt;
 2176      *
 2177      * &lt;p&gt;
 2178      * NOTE: In order for CSS and layout to function correctly, the node
 2179      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2180      * not be).
 2181      * &lt;/p&gt;
 2182      *
 2183      * @param params the snapshot parameters containing attributes that
 2184      * will control the rendering. If the SnapshotParameters object is null,
 2185      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2186      * or default attributes will be used if this node is not part of a scene.
 2187      *
 2188      * @param image the writable image that will be used to hold the rendered node.
 2189      * It may be null in which case a new WritableImage will be constructed.
 2190      * The new image is constructed using integer width and
 2191      * height values that are derived either from the transformed bounds of this
 2192      * Node or from the size of the viewport as specified in the
 2193      * SnapShotParameters. These integer values are chosen such that the image
 2194      * will wholly contain the bounds of this Node or the specified viewport.
 2195      * If the image is non-null, the node will be rendered into the
 2196      * existing image.
 2197      * In this case, the width and height of the image determine the area
 2198      * that is rendered instead of the width and height of the bounds or
 2199      * viewport.
 2200      *
 2201      * @throws IllegalStateException if this method is called on a thread
 2202      *     other than the JavaFX Application Thread.
 2203      *
 2204      * @return the rendered image
 2205      * @since JavaFX 2.2
 2206      */
 2207     public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
 2208         Toolkit.getToolkit().checkFxUserThread();
 2209 
 2210         if (params == null) {
 2211             params = new SnapshotParameters();
 2212             Scene s = getScene();
 2213             if (s != null) {
 2214                 params.setCamera(s.getEffectiveCamera());
 2215                 params.setDepthBuffer(s.isDepthBufferInternal());
 2216                 params.setFill(s.getFill());
 2217             }
 2218         }
 2219 
 2220         return doSnapshot(params, image);
 2221     }
 2222 
 2223     /**
 2224      * Takes a snapshot of this node at the next frame and calls the
 2225      * specified callback method when the image is ready.
 2226      * CSS and layout processing will be done for the node, and any of its
 2227      * children, prior to rendering it.
 2228      * The entire destination image is cleared to the fill {@code Paint}
 2229      * specified by the SnapshotParameters. This node is then rendered to
 2230      * the image.
 2231      * If the viewport specified by the SnapshotParameters is null, the
 2232      * upper-left pixel of the {@code boundsInParent} of this
 2233      * node, after first applying the transform specified by the
 2234      * SnapshotParameters,
 2235      * is mapped to the upper-left pixel (0,0) in the image.
 2236      * If a non-null viewport is specified,
 2237      * the upper-left pixel of the viewport is mapped to upper-left pixel
 2238      * (0,0) in the image.
 2239      * In both cases, this mapping to (0,0) of the image is done with an integer
 2240      * translation. The portion of the node that is outside of the rendered
 2241      * image will be clipped by the image.
 2242      *
 2243      * &lt;p&gt;
 2244      * This is an asynchronous call, which means that other
 2245      * events or animation might be processed before the node is rendered.
 2246      * If any such events modify the node, or any of its children, that
 2247      * modification will be reflected in the rendered image (just like it
 2248      * will also be reflected in the frame rendered to the Stage, if this node
 2249      * is part of a live scene graph).
 2250      * &lt;/p&gt;
 2251      *
 2252      * &lt;p&gt;
 2253      * When taking a snapshot of a node that is being animated, either
 2254      * explicitly by the application or implicitly (such as chart animation),
 2255      * the snapshot will be rendered based on the state of the scene graph at
 2256      * the moment the snapshot is taken and will not reflect any subsequent
 2257      * animation changes.
 2258      * &lt;/p&gt;
 2259      *
 2260      * &lt;p&gt;
 2261      * NOTE: In order for CSS and layout to function correctly, the node
 2262      * must be part of a Scene (the Scene may be attached to a Stage, but need
 2263      * not be).
 2264      * &lt;/p&gt;
 2265      *
 2266      * @param callback a class whose call method will be called when the image
 2267      * is ready. The SnapshotResult that is passed into the call method of
 2268      * the callback will contain the rendered image, the source node
 2269      * that was rendered, and a copy of the SnapshotParameters.
 2270      * The callback parameter must not be null.
 2271      *
 2272      * @param params the snapshot parameters containing attributes that
 2273      * will control the rendering. If the SnapshotParameters object is null,
 2274      * then the Scene&#39;s attributes will be used if this node is part of a scene,
 2275      * or default attributes will be used if this node is not part of a scene.
 2276      *
 2277      * @param image the writable image that will be used to hold the rendered node.
 2278      * It may be null in which case a new WritableImage will be constructed.
 2279      * The new image is constructed using integer width and
 2280      * height values that are derived either from the transformed bounds of this
 2281      * Node or from the size of the viewport as specified in the
 2282      * SnapShotParameters. These integer values are chosen such that the image
 2283      * will wholly contain the bounds of this Node or the specified viewport.
 2284      * If the image is non-null, the node will be rendered into the
 2285      * existing image.
 2286      * In this case, the width and height of the image determine the area
 2287      * that is rendered instead of the width and height of the bounds or
 2288      * viewport.
 2289      *
 2290      * @throws IllegalStateException if this method is called on a thread
 2291      *     other than the JavaFX Application Thread.
 2292      *
 2293      * @throws NullPointerException if the callback parameter is null.
 2294      * @since JavaFX 2.2
 2295      */
 2296     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
 2297             SnapshotParameters params, WritableImage image) {
 2298 
 2299         Toolkit.getToolkit().checkFxUserThread();
 2300         if (callback == null) {
 2301             throw new NullPointerException(&quot;The callback must not be null&quot;);
 2302         }
 2303 
 2304         if (params == null) {
 2305             params = new SnapshotParameters();
 2306             Scene s = getScene();
 2307             if (s != null) {
 2308                 params.setCamera(s.getEffectiveCamera());
 2309                 params.setDepthBuffer(s.isDepthBufferInternal());
 2310                 params.setFill(s.getFill());
 2311             }
 2312         } else {
 2313             params = params.copy();
 2314         }
 2315 
 2316         final SnapshotParameters theParams = params;
 2317         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
 2318         final WritableImage theImage = image;
 2319 
 2320         // Create a deferred runnable that will be run from a pulse listener
 2321         // that is called after all of the scenes have been synced but before
 2322         // any of them have been rendered.
 2323         final Runnable snapshotRunnable = () -&gt; {
 2324             WritableImage img = doSnapshot(theParams, theImage);
 2325             SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
 2326 //                System.err.println(&quot;Calling snapshot callback&quot;);
 2327             try {
 2328                 Void v = theCallback.call(result);
 2329             } catch (Throwable th) {
 2330                 System.err.println(&quot;Exception in snapshot callback&quot;);
 2331                 th.printStackTrace(System.err);
 2332             }
 2333         };
 2334 
 2335 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
 2336         Scene.addSnapshotRunnable(snapshotRunnable);
 2337     }
 2338 
 2339     /* ************************************************************************
 2340      *                                                                        *
 2341      *
 2342      *                                                                        *
 2343      *************************************************************************/
 2344 
 2345     public final void setOnDragEntered(
 2346             EventHandler&lt;? super DragEvent&gt; value) {
 2347         onDragEnteredProperty().set(value);
 2348     }
 2349 
 2350     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
 2351         return (eventHandlerProperties == null)
 2352                 ? null : eventHandlerProperties.getOnDragEntered();
 2353     }
 2354 
 2355     /**
 2356      * Defines a function to be called when drag gesture
 2357      * enters this {@code Node}.
 2358      * @return the event handler that is called when drag gesture enters this
 2359      * {@code Node}
 2360      */
 2361     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2362             onDragEnteredProperty() {
 2363         return getEventHandlerProperties().onDragEnteredProperty();
 2364     }
 2365 
 2366     public final void setOnDragExited(
 2367             EventHandler&lt;? super DragEvent&gt; value) {
 2368         onDragExitedProperty().set(value);
 2369     }
 2370 
 2371     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
 2372         return (eventHandlerProperties == null)
 2373                 ? null : eventHandlerProperties.getOnDragExited();
 2374     }
 2375 
 2376     /**
 2377      * Defines a function to be called when drag gesture
 2378      * exits this {@code Node}.
 2379      * @return the event handler that is called when drag gesture exits this
 2380      * {@code Node}
 2381      */
 2382     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2383             onDragExitedProperty() {
 2384         return getEventHandlerProperties().onDragExitedProperty();
 2385     }
 2386 
 2387     public final void setOnDragOver(
 2388             EventHandler&lt;? super DragEvent&gt; value) {
 2389         onDragOverProperty().set(value);
 2390     }
 2391 
 2392     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
 2393         return (eventHandlerProperties == null)
 2394                 ? null : eventHandlerProperties.getOnDragOver();
 2395     }
 2396 
 2397     /**
 2398      * Defines a function to be called when drag gesture progresses within
 2399      * this {@code Node}.
 2400      * @return the event handler that is called when drag gesture progresses
 2401      * within this {@code Node}
 2402      */
 2403     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2404             onDragOverProperty() {
 2405         return getEventHandlerProperties().onDragOverProperty();
 2406     }
 2407 
 2408     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
 2409 //    public final void setOnDragTransferModeChanged(
 2410 //            EventHandler&lt;? super DragEvent&gt; value) {
 2411 //        onDragTransferModeChangedProperty().set(value);
 2412 //    }
 2413 //
 2414 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
 2415 //        return (eventHandlerProperties == null)
 2416 //                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
 2417 //    }
 2418 //
 2419 //    /**
 2420 //     * Defines a function to be called this {@code Node} if it is a potential
 2421 //     * drag-and-drop target when the user takes action to change the intended
 2422 //     * {@code TransferMode}.
 2423 //     * The user can change the intended {@link TransferMode} by holding down
 2424 //     * or releasing key modifiers.
 2425 //     */
 2426 //    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2427 //            onDragTransferModeChangedProperty() {
 2428 //        return getEventHandlerProperties().onDragTransferModeChangedProperty();
 2429 //    }
 2430 
 2431     public final void setOnDragDropped(
 2432             EventHandler&lt;? super DragEvent&gt; value) {
 2433         onDragDroppedProperty().set(value);
 2434     }
 2435 
 2436     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
 2437         return (eventHandlerProperties == null)
 2438                 ? null : eventHandlerProperties.getOnDragDropped();
 2439     }
 2440 
 2441     /**
 2442      * Defines a function to be called when the mouse button is released
 2443      * on this {@code Node} during drag and drop gesture. Transfer of data from
 2444      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
 2445      * happen in this function.
 2446      * @return the event handler that is called when the mouse button is
 2447      * released on this {@code Node}
 2448      */
 2449     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2450             onDragDroppedProperty() {
 2451         return getEventHandlerProperties().onDragDroppedProperty();
 2452     }
 2453 
 2454     public final void setOnDragDone(
 2455             EventHandler&lt;? super DragEvent&gt; value) {
 2456         onDragDoneProperty().set(value);
 2457     }
 2458 
 2459     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
 2460         return (eventHandlerProperties == null)
 2461                 ? null : eventHandlerProperties.getOnDragDone();
 2462     }
 2463 
 2464     /**
 2465      * Defines a function to be called when this {@code Node} is a
 2466      * drag and drop gesture source after its data has
 2467      * been dropped on a drop target. The {@code transferMode} of the
 2468      * event shows what just happened at the drop target.
 2469      * If {@code transferMode} has the value {@code MOVE}, then the source can
 2470      * clear out its data. Clearing the source&#39;s data gives the appropriate
 2471      * appearance to a user that the data has been moved by the drag and drop
 2472      * gesture. A {@code transferMode} that has the value {@code NONE}
 2473      * indicates that no data was transferred during the drag and drop gesture.
 2474      * @return the event handler that is called when this {@code Node} is a drag
 2475      * and drop gesture source after its data has been dropped on a drop target
 2476      */
 2477     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
 2478             onDragDoneProperty() {
 2479         return getEventHandlerProperties().onDragDoneProperty();
 2480     }
 2481 
 2482     /**
 2483      * Confirms a potential drag and drop gesture that is recognized over this
 2484      * {@code Node}.
 2485      * Can be called only from a DRAG_DETECTED event handler. The returned
 2486      * {@link Dragboard} is used to transfer data during
 2487      * the drag and drop gesture. Placing this {@code Node}&#39;s data on the
 2488      * {@link Dragboard} also identifies this {@code Node} as the source of
 2489      * the drag and drop gesture.
 2490      * More detail about drag and drop gestures is described in the overivew
 2491      * of {@link DragEvent}.
 2492      *
 2493      * @see DragEvent
 2494      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
 2495      * @return A {@code Dragboard} to place this {@code Node}&#39;s data on
 2496      * @throws IllegalStateException if drag and drop cannot be started at this
 2497      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling or
 2498      * this node is not in scene).
 2499      */
 2500     public Dragboard startDragAndDrop(TransferMode... transferModes) {
 2501         if (getScene() != null) {
 2502             return getScene().startDragAndDrop(this, transferModes);
 2503         }
 2504 
 2505         throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
 2506                 + &quot;that is not in scene&quot;);
 2507     }
 2508 
 2509     /**
 2510      * Starts a full press-drag-release gesture with this node as gesture
 2511      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
 2512      * event handler. More detail about dragging gestures can be found
 2513      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
 2514      *
 2515      * @see MouseEvent
 2516      * @see MouseDragEvent
 2517      * @throws IllegalStateException if the full press-drag-release gesture
 2518      * cannot be started at this moment (it&#39;s called outside of
 2519      * {@code DRAG_DETECTED} event handling or this node is not in scene).
 2520      * @since JavaFX 2.1
 2521      */
 2522     public void startFullDrag() {
 2523         if (getScene() != null) {
 2524             getScene().startFullDrag(this);
 2525             return;
 2526         }
 2527 
 2528         throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
 2529                 + &quot;that is not in scene&quot;);
 2530     }
 2531 
 2532     ////////////////////////////
 2533     //  Private Implementation
 2534     ////////////////////////////
 2535 
 2536     /**
 2537      * If this Node is being used as the clip of another Node, that other node
 2538      * is referred to as the clipParent. If the boundsInParent of this Node
 2539      * changes, it must update the clipParent&#39;s bounds as well.
 2540      */
 2541     private Node clipParent;
 2542     // Use a getter function instead of giving clipParent package access,
 2543     // so that clipParent doesn&#39;t get turned into a Location.
 2544     final Node getClipParent() {
 2545         return clipParent;
 2546     }
 2547 
 2548     /**
 2549      * Determines whether this node is connected anywhere in the scene graph.
 2550      */
 2551     boolean isConnected() {
 2552         // don&#39;t need to check scene, because if scene is non-null
 2553         // parent must also be non-null
 2554         return getParent() != null || clipParent != null;
 2555     }
 2556 
 2557     /**
 2558      * Tests whether creating a parent-child relationship between these
 2559      * nodes would cause a cycle. The parent relationship includes not only
 2560      * the &quot;real&quot; parent (child of Group) but also the clipParent.
 2561      */
 2562     boolean wouldCreateCycle(Node parent, Node child) {
 2563         if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
 2564             return false;
 2565     }
 2566 
 2567         Node n = parent;
 2568         while (n != child) {
 2569             if (n.getParent() != null) {
 2570                 n = n.getParent();
 2571             } else if (n.getSubScene() != null) {
 2572                 n = n.getSubScene();
 2573             } else if (n.clipParent != null) {
 2574                 n = n.clipParent;
 2575             } else {
 2576                 return false;
 2577             }
 2578         }
 2579         return true;
 2580     }
 2581 
 2582     /**
 2583      * The peer node created by the graphics Toolkit/Pipeline implementation
 2584      */
 2585     private NGNode peer;
 2586 
 2587     @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
 2588     &lt;P extends NGNode&gt; P getPeer() {
 2589         if (Utils.assertionEnabled()) {
 2590             // Assertion checking code
 2591             if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
 2592                 java.lang.System.err.println();
 2593                 java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
 2594                 java.lang.Thread.dumpStack();
 2595             }
 2596         }
 2597 
 2598         if (peer == null) {
 2599             //if (PerformanceTracker.isLoggingEnabled()) {
 2600             //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2601             //}
 2602             peer = NodeHelper.createPeer(this);
 2603             //if (PerformanceTracker.isLoggingEnabled()) {
 2604             //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
 2605             //}
 2606         }
 2607         return (P) peer;
 2608     }
 2609 
 2610     /***************************************************************************
 2611      *                                                                         *
 2612      *                              Initialization                             *
 2613      *                                                                         *
 2614      *  To Note limit the number of bounds computations and improve startup    *
 2615      *  performance.                                                           *
 2616      *                                                                         *
 2617      **************************************************************************/
 2618 
 2619     /**
 2620      * Creates a new instance of Node.
 2621      */
 2622     protected Node() {
 2623         //if (PerformanceTracker.isLoggingEnabled()) {
 2624         //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
 2625         //}
 2626         updateTreeVisible(false);
 2627         //if (PerformanceTracker.isLoggingEnabled()) {
 2628         //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
 2629         //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
 2630         //}
 2631     }
 2632 
 2633     /***************************************************************************
 2634      *                                                                         *
 2635      * Layout related APIs.                                                    *
 2636      *                                                                         *
 2637      **************************************************************************/
 2638     /**
 2639      * Defines whether or not this node&#39;s layout will be managed by it&#39;s parent.
 2640      * If the node is managed, it&#39;s parent will factor the node&#39;s geometry
 2641      * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
 2642      * calculations and will lay it
 2643      * out during the scene&#39;s layout pass.  If a managed node&#39;s layoutBounds
 2644      * changes, it will automatically trigger relayout up the scene-graph
 2645      * to the nearest layout root (which is typically the scene&#39;s root node).
 2646      * &lt;p&gt;
 2647      * If the node is unmanaged, its parent will ignore the child in both preferred
 2648      * size computations and layout.   Changes in layoutBounds will not trigger
 2649      * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
 2650      * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
 2651      * beneath it will cause only the branch rooted by the node to be relayed out,
 2652      * thereby isolating layout changes to that root and below.  It&#39;s the application&#39;s
 2653      * responsibility to set the size and position of an unmanaged node.
 2654      * &lt;p&gt;
 2655      * By default all nodes are managed.
 2656      * &lt;/p&gt;
 2657      *
 2658      * @see #isResizable()
 2659      * @see #layoutBoundsProperty()
 2660      * @see Parent#requestLayout()
 2661      *
 2662      */
 2663     private BooleanProperty managed;
 2664 
 2665     public final void setManaged(boolean value) {
 2666         managedProperty().set(value);
 2667     }
 2668 
 2669     public final boolean isManaged() {
 2670         return managed == null ? true : managed.get();
 2671     }
 2672 
 2673     public final BooleanProperty managedProperty() {
 2674         if (managed == null) {
 2675             managed = new BooleanPropertyBase(true) {
 2676 
 2677                 @Override
 2678                 protected void invalidated() {
 2679                     final Parent parent = getParent();
 2680                     if (parent != null) {
 2681                         parent.managedChildChanged();
 2682                     }
 2683                     notifyManagedChanged();
 2684                 }
 2685 
 2686                 @Override
 2687                 public Object getBean() {
 2688                     return Node.this;
 2689                 }
 2690 
 2691                 @Override
 2692                 public String getName() {
 2693                     return &quot;managed&quot;;
 2694                 }
 2695 
 2696             };
 2697         }
 2698         return managed;
 2699     }
 2700 
 2701     /**
 2702      * Called whenever the &quot;managed&quot; flag has changed. This is only
 2703      * used by Parent as an optimization to keep track of whether a
 2704      * Parent node is a layout root or not.
 2705      */
 2706     void notifyManagedChanged() { }
 2707 
 2708     /**
 2709      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 2710      * transform for the purpose of layout. The value should be computed as the
 2711      * offset required to adjust the position of the node from its current
 2712      * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
 2713      *
 2714      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
 2715      * &lt;pre&gt;{@code
 2716      *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
 2717      * }&lt;/pre&gt;
 2718      * &lt;p&gt;
 2719      * Failure to subtract {@code layoutBounds minX} may result in misplacement
 2720      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2721      * correct computation and should generally be used over setting layoutX directly.
 2722      * &lt;p&gt;
 2723      * The node&#39;s final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
 2724      * where {@code layoutX} establishes the node&#39;s stable position
 2725      * and {@code translateX} optionally makes dynamic adjustments to that
 2726      * position.
 2727      * &lt;p&gt;
 2728      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2729      * as its parent, then the layout region will set {@code layoutX} according to its
 2730      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2731      * then the application may set {@code layoutX} directly to position it.
 2732      *
 2733      * @see #relocate(double, double)
 2734      * @see #layoutBoundsProperty()
 2735      *
 2736      */
 2737     private DoubleProperty layoutX;
 2738 
 2739     public final void setLayoutX(double value) {
 2740         layoutXProperty().set(value);
 2741     }
 2742 
 2743     public final double getLayoutX() {
 2744         return layoutX == null ? 0.0 : layoutX.get();
 2745     }
 2746 
 2747     public final DoubleProperty layoutXProperty() {
 2748         if (layoutX == null) {
 2749             layoutX = new DoublePropertyBase(0.0) {
 2750 
 2751                 @Override
 2752                 protected void invalidated() {
 2753                     NodeHelper.transformsChanged(Node.this);
 2754                     final Parent p = getParent();
 2755 
 2756                     // Propagate layout if this change isn&#39;t triggered by its parent
 2757                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2758                         if (isManaged()) {
 2759                             // Force its parent to fix the layout since it is a managed child.
 2760                             p.requestLayout(true);
 2761                         } else {
 2762                             // Parent size changed, parent&#39;s parent might need to re-layout
 2763                             p.clearSizeCache();
 2764                             p.requestParentLayout();
 2765                         }
 2766                     }
 2767                 }
 2768 
 2769                 @Override
 2770                 public Object getBean() {
 2771                     return Node.this;
 2772                 }
 2773 
 2774                 @Override
 2775                 public String getName() {
 2776                     return &quot;layoutX&quot;;
 2777                 }
 2778             };
 2779         }
 2780         return layoutX;
 2781     }
 2782 
 2783     /**
 2784      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 2785      * transform for the purpose of layout. The value should be computed as the
 2786      * offset required to adjust the position of the node from its current
 2787      * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
 2788      *
 2789      * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
 2790      * &lt;pre&gt;{@code
 2791      *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
 2792      * }&lt;/pre&gt;
 2793      * &lt;p&gt;
 2794      * Failure to subtract {@code layoutBounds minY} may result in misplacement
 2795      * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
 2796      * correct computation and should generally be used over setting layoutY directly.
 2797      * &lt;p&gt;
 2798      * The node&#39;s final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
 2799      * where {@code layoutY} establishes the node&#39;s stable position
 2800      * and {@code translateY} optionally makes dynamic adjustments to that
 2801      * position.
 2802      * &lt;p&gt;
 2803      * If the node is managed and has a {@link javafx.scene.layout.Region}
 2804      * as its parent, then the region will set {@code layoutY} according to its
 2805      * own layout policy.   If the node is unmanaged or parented by a {@link Group},
 2806      * then the application may set {@code layoutY} directly to position it.
 2807      *
 2808      * @see #relocate(double, double)
 2809      * @see #layoutBoundsProperty()
 2810      */
 2811     private DoubleProperty layoutY;
 2812 
 2813     public final void setLayoutY(double value) {
 2814         layoutYProperty().set(value);
 2815     }
 2816 
 2817     public final double getLayoutY() {
 2818         return layoutY == null ? 0.0 : layoutY.get();
 2819     }
 2820 
 2821     public final DoubleProperty layoutYProperty() {
 2822         if (layoutY == null) {
 2823             layoutY = new DoublePropertyBase(0.0) {
 2824 
 2825                 @Override
 2826                 protected void invalidated() {
 2827                     NodeHelper.transformsChanged(Node.this);
 2828                     final Parent p = getParent();
 2829 
 2830                     // Propagate layout if this change isn&#39;t triggered by its parent
 2831                     if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
 2832                         if (isManaged()) {
 2833                             // Force its parent to fix the layout since it is a managed child.
 2834                             p.requestLayout(true);
 2835                         } else {
 2836                             // Parent size changed, parent&#39;s parent might need to re-layout
 2837                             p.clearSizeCache();
 2838                             p.requestParentLayout();
 2839                         }
 2840                     }
 2841                 }
 2842 
 2843                 @Override
 2844                 public Object getBean() {
 2845                     return Node.this;
 2846                 }
 2847 
 2848                 @Override
 2849                 public String getName() {
 2850                     return &quot;layoutY&quot;;
 2851                 }
 2852 
 2853             };
 2854         }
 2855         return layoutY;
 2856     }
 2857 
 2858     /**
 2859      * Sets the node&#39;s layoutX and layoutY translation properties in order to
 2860      * relocate this node to the x,y location in the parent.
 2861      * &lt;p&gt;
 2862      * This method does not alter translateX or translateY, which if also set
 2863      * will be added to layoutX and layoutY, adjusting the final location by
 2864      * corresponding amounts.
 2865      *
 2866      * @param x the target x coordinate location
 2867      * @param y the target y coordinate location
 2868      */
 2869     public void relocate(double x, double y) {
 2870         setLayoutX(x - getLayoutBounds().getMinX());
 2871         setLayoutY(y - getLayoutBounds().getMinY());
 2872 
 2873         PlatformLogger logger = Logging.getLayoutLogger();
 2874         if (logger.isLoggable(Level.FINER)) {
 2875             logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
 2876         }
 2877     }
 2878 
 2879     /**
 2880      * Indicates whether this node is a type which can be resized by its parent.
 2881      * If this method returns true, then the parent will resize the node (ideally
 2882      * within its size range) by calling node.resize(width,height) during the
 2883      * layout pass.  All Regions, Controls, and WebView are resizable classes
 2884      * which depend on their parents resizing them during layout once all sizing
 2885      * and CSS styling information has been applied.
 2886      * &lt;p&gt;
 2887      * If this method returns false, then the parent cannot resize it during
 2888      * layout (resize() is a no-op) and it should return its layoutBounds for
 2889      * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
 2890      * resizable and hence depend on the application to establish their sizing
 2891      * by setting appropriate properties (e.g.  width/height for Rectangle,
 2892      * text on Text, and so on).  Non-resizable nodes may still be relocated
 2893      * during layout.
 2894      *
 2895      * @see #getContentBias()
 2896      * @see #minWidth(double)
 2897      * @see #minHeight(double)
 2898      * @see #prefWidth(double)
 2899      * @see #prefHeight(double)
 2900      * @see #maxWidth(double)
 2901      * @see #maxHeight(double)
 2902      * @see #resize(double, double)
 2903      * @see #getLayoutBounds()
 2904      *
 2905      * @return whether or not this node type can be resized by its parent during layout
 2906      */
 2907     public boolean isResizable() {
 2908         return false;
 2909     }
 2910 
 2911     /**
 2912      * Returns the orientation of a node&#39;s resizing bias for layout purposes.
 2913      * If the node type has no bias, returns null.  If the node is resizable and
 2914      * it&#39;s height depends on its width, returns HORIZONTAL, else if its width
 2915      * depends on its height, returns VERTICAL.
 2916      * &lt;p&gt;
 2917      * Resizable subclasses should override this method to return an
 2918      * appropriate value.
 2919      *
 2920      * @see #isResizable()
 2921      * @see #minWidth(double)
 2922      * @see #minHeight(double)
 2923      * @see #prefWidth(double)
 2924      * @see #prefHeight(double)
 2925      * @see #maxWidth(double)
 2926      * @see #maxHeight(double)
 2927      *
 2928      * @return orientation of width/height dependency or null if there is none
 2929      */
 2930     public Orientation getContentBias() {
 2931         return null;
 2932     }
 2933 
 2934     /**
 2935      * Returns the node&#39;s minimum width for use in layout calculations.
 2936      * If the node is resizable, its parent should not resize its width any
 2937      * smaller than this value.  If the node is not resizable, returns its
 2938      * layoutBounds width.
 2939      * &lt;p&gt;
 2940      * Layout code which calls this method should first check the content-bias
 2941      * of the node.  If the node has a vertical content-bias, then callers
 2942      * should pass in a height value that the minimum width should be based on.
 2943      * If the node has either a horizontal or null content-bias, then the caller
 2944      * should pass in -1.
 2945      * &lt;p&gt;
 2946      * Node subclasses with a vertical content-bias should honor the height
 2947      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2948      * the height parameter (which will likely be -1).
 2949      * &lt;p&gt;
 2950      * If Node&#39;s {@link #maxWidth(double)} is lower than this number,
 2951      * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
 2952      *
 2953      * @see #isResizable()
 2954      * @see #getContentBias()
 2955      *
 2956      * @param height the height that should be used if minimum width depends on it
 2957      * @return the minimum width that the node should be resized to during layout.
 2958      *         The result will never be NaN, nor will it ever be negative.
 2959      */
 2960     public double minWidth(double height) {
 2961         return prefWidth(height);
 2962     }
 2963 
 2964     /**
 2965      * Returns the node&#39;s minimum height for use in layout calculations.
 2966      * If the node is resizable, its parent should not resize its height any
 2967      * smaller than this value.  If the node is not resizable, returns its
 2968      * layoutBounds height.
 2969      * &lt;p&gt;
 2970      * Layout code which calls this method should first check the content-bias
 2971      * of the node.  If the node has a horizontal content-bias, then callers
 2972      * should pass in a width value that the minimum height should be based on.
 2973      * If the node has either a vertical or null content-bias, then the caller
 2974      * should pass in -1.
 2975      * &lt;p&gt;
 2976      * Node subclasses with a horizontal content-bias should honor the width
 2977      * parameter whether -1 or a positive value.   All other subclasses may ignore
 2978      * the width parameter (which will likely be -1).
 2979      * &lt;p&gt;
 2980      * If Node&#39;s {@link #maxHeight(double)} is lower than this number,
 2981      * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
 2982      *
 2983      * @see #isResizable()
 2984      * @see #getContentBias()
 2985      *
 2986      * @param width the width that should be used if minimum height depends on it
 2987      * @return the minimum height that the node should be resized to during layout
 2988      *         The result will never be NaN, nor will it ever be negative.
 2989      */
 2990     public double minHeight(double width) {
 2991         return prefHeight(width);
 2992     }
 2993 
 2994     /**
 2995      * Returns the node&#39;s preferred width for use in layout calculations.
 2996      * If the node is resizable, its parent should treat this value as the
 2997      * node&#39;s ideal width within its range.  If the node is not resizable,
 2998      * just returns its layoutBounds width, which should be treated as the rigid
 2999      * width of the node.
 3000      * &lt;p&gt;
 3001      * Layout code which calls this method should first check the content-bias
 3002      * of the node.  If the node has a vertical content-bias, then callers
 3003      * should pass in a height value that the preferred width should be based on.
 3004      * If the node has either a horizontal or null content-bias, then the caller
 3005      * should pass in -1.
 3006      * &lt;p&gt;
 3007      * Node subclasses with a vertical content-bias should honor the height
 3008      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3009      * the height parameter (which will likely be -1).
 3010      *
 3011      * @see #isResizable()
 3012      * @see #getContentBias()
 3013      * @see #autosize()
 3014      *
 3015      * @param height the height that should be used if preferred width depends on it
 3016      * @return the preferred width that the node should be resized to during layout
 3017      *         The result will never be NaN, nor will it ever be negative.
 3018      */
 3019     public double prefWidth(double height) {
 3020         final double result = getLayoutBounds().getWidth();
 3021         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3022     }
 3023 
 3024     /**
 3025      * Returns the node&#39;s preferred height for use in layout calculations.
 3026      * If the node is resizable, its parent should treat this value as the
 3027      * node&#39;s ideal height within its range.  If the node is not resizable,
 3028      * just returns its layoutBounds height, which should be treated as the rigid
 3029      * height of the node.
 3030      * &lt;p&gt;
 3031      * Layout code which calls this method should first check the content-bias
 3032      * of the node.  If the node has a horizontal content-bias, then callers
 3033      * should pass in a width value that the preferred height should be based on.
 3034      * If the node has either a vertical or null content-bias, then the caller
 3035      * should pass in -1.
 3036      * &lt;p&gt;
 3037      * Node subclasses with a horizontal content-bias should honor the height
 3038      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3039      * the height parameter (which will likely be -1).
 3040      *
 3041      * @see #getContentBias()
 3042      * @see #autosize()
 3043      *
 3044      * @param width the width that should be used if preferred height depends on it
 3045      * @return the preferred height that the node should be resized to during layout
 3046      *         The result will never be NaN, nor will it ever be negative.
 3047      */
 3048     public double prefHeight(double width) {
 3049         final double result = getLayoutBounds().getHeight();
 3050         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 3051     }
 3052 
 3053     /**
 3054      * Returns the node&#39;s maximum width for use in layout calculations.
 3055      * If the node is resizable, its parent should not resize its width any
 3056      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3057      * parent may expand the node&#39;s width beyond its preferred without limits.
 3058      * &lt;p&gt;
 3059      * If the node is not resizable, returns its layoutBounds width.
 3060      * &lt;p&gt;
 3061      * Layout code which calls this method should first check the content-bias
 3062      * of the node.  If the node has a vertical content-bias, then callers
 3063      * should pass in a height value that the maximum width should be based on.
 3064      * If the node has either a horizontal or null content-bias, then the caller
 3065      * should pass in -1.
 3066      * &lt;p&gt;
 3067      * Node subclasses with a vertical content-bias should honor the height
 3068      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3069      * the height parameter (which will likely be -1).
 3070      * &lt;p&gt;
 3071      * If Node&#39;s {@link #minWidth(double)} is greater, it should take precedence
 3072      * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
 3073      *
 3074      * @see #isResizable()
 3075      * @see #getContentBias()
 3076      *
 3077      * @param height the height that should be used if maximum width depends on it
 3078      * @return the maximum width that the node should be resized to during layout
 3079      *         The result will never be NaN, nor will it ever be negative.
 3080      */
 3081     public double maxWidth(double height) {
 3082         return prefWidth(height);
 3083     }
 3084 
 3085     /**
 3086      * Returns the node&#39;s maximum height for use in layout calculations.
 3087      * If the node is resizable, its parent should not resize its height any
 3088      * larger than this value.  A value of Double.MAX_VALUE indicates the
 3089      * parent may expand the node&#39;s height beyond its preferred without limits.
 3090      * &lt;p&gt;
 3091      * If the node is not resizable, returns its layoutBounds height.
 3092      * &lt;p&gt;
 3093      * Layout code which calls this method should first check the content-bias
 3094      * of the node.  If the node has a horizontal content-bias, then callers
 3095      * should pass in a width value that the maximum height should be based on.
 3096      * If the node has either a vertical or null content-bias, then the caller
 3097      * should pass in -1.
 3098      * &lt;p&gt;
 3099      * Node subclasses with a horizontal content-bias should honor the width
 3100      * parameter whether -1 or a positive value.   All other subclasses may ignore
 3101      * the width parameter (which will likely be -1).
 3102      * &lt;p&gt;
 3103      * If Node&#39;s {@link #minHeight(double)} is greater, it should take precedence
 3104      * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
 3105      *
 3106      * @see #isResizable()
 3107      * @see #getContentBias()
 3108      *
 3109      * @param width the width that should be used if maximum height depends on it
 3110      * @return the maximum height that the node should be resized to during layout
 3111      *         The result will never be NaN, nor will it ever be negative.
 3112      */
 3113     public double maxHeight(double width) {
 3114         return prefHeight(width);
 3115     }
 3116 
 3117     /**
 3118      * If the node is resizable, will set its layout bounds to the specified
 3119      * width and height.   If the node is not resizable, this method is a no-op.
 3120      * &lt;p&gt;
 3121      * This method should generally only be called by parent nodes from their
 3122      * layoutChildren() methods.   All Parent classes will automatically resize
 3123      * resizable children, so resizing done directly by the application will be
 3124      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3125      * &lt;p&gt;
 3126      * Parents are responsible for ensuring the width and height values fall
 3127      * within the resizable node&#39;s preferred range.  The autosize() method may
 3128      * be used if the parent just needs to resize the node to its preferred size.
 3129      *
 3130      * @see #isResizable()
 3131      * @see #getContentBias()
 3132      * @see #autosize()
 3133      * @see #minWidth(double)
 3134      * @see #minHeight(double)
 3135      * @see #prefWidth(double)
 3136      * @see #prefHeight(double)
 3137      * @see #maxWidth(double)
 3138      * @see #maxHeight(double)
 3139      * @see #getLayoutBounds()
 3140      *
 3141      * @param width the target layout bounds width
 3142      * @param height the target layout bounds height
 3143      */
 3144     public void resize(double width, double height) {
 3145     }
 3146 
 3147     /**
 3148      * If the node is resizable, will set its layout bounds to its current preferred
 3149      * width and height. If the node is not resizable, this method is a no-op.
 3150      * &lt;p&gt;
 3151      * This method automatically queries the node&#39;s content-bias and if it&#39;s
 3152      * horizontal, will pass in the node&#39;s preferred width to get the preferred
 3153      * height; if vertical, will pass in the node&#39;s preferred height to get the width,
 3154      * and if null, will compute the preferred width/height independently.
 3155      * &lt;/p&gt;
 3156      *
 3157      * @see #isResizable()
 3158      * @see #getContentBias()
 3159      *
 3160      */
 3161     public final void autosize() {
 3162         if (isResizable()) {
 3163             Orientation contentBias = getContentBias();
 3164             double w, h;
 3165             if (contentBias == null) {
 3166                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3167                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3168             } else if (contentBias == Orientation.HORIZONTAL) {
 3169                 w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
 3170                 h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
 3171             } else { // bias == VERTICAL
 3172                 h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
 3173                 w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
 3174             }
 3175             resize(w,h);
 3176         }
 3177     }
 3178 
 3179     double boundedSize(double value, double min, double max) {
 3180         // if max &lt; value, return max
 3181         // if min &gt; value, return min
 3182         // if min &gt; max, return min
 3183         return Math.min(Math.max(value, min), Math.max(min,max));
 3184     }
 3185 
 3186     /**
 3187      * If the node is resizable, will set its layout bounds to the specified
 3188      * width and height.   If the node is not resizable, the resize step is skipped.
 3189      * &lt;p&gt;
 3190      * Once the node has been resized (if resizable) then sets the node&#39;s layoutX
 3191      * and layoutY translation properties in order to relocate it to x,y in the
 3192      * parent&#39;s coordinate space.
 3193      * &lt;p&gt;
 3194      * This method should generally only be called by parent nodes from their
 3195      * layoutChildren() methods.   All Parent classes will automatically resize
 3196      * resizable children, so resizing done directly by the application will be
 3197      * overridden by the node&#39;s parent, unless the child is unmanaged.
 3198      * &lt;p&gt;
 3199      * Parents are responsible for ensuring the width and height values fall
 3200      * within the resizable node&#39;s preferred range.  The autosize() and relocate()
 3201      * methods may be used if the parent just needs to resize the node to its
 3202      * preferred size and reposition it.
 3203      *
 3204      * @see #isResizable()
 3205      * @see #getContentBias()
 3206      * @see #autosize()
 3207      * @see #minWidth(double)
 3208      * @see #minHeight(double)
 3209      * @see #prefWidth(double)
 3210      * @see #prefHeight(double)
 3211      * @see #maxWidth(double)
 3212      * @see #maxHeight(double)
 3213      *
 3214      * @param x the target x coordinate location
 3215      * @param y the target y coordinate location
 3216      * @param width the target layout bounds width
 3217      * @param height the target layout bounds height
 3218      *
 3219      */
 3220     public void resizeRelocate(double x, double y, double width, double height) {
 3221         resize(width, height);
 3222         relocate(x,y);
 3223     }
 3224 
 3225     /**
 3226      * This is a special value that might be returned by {@link #getBaselineOffset()}.
 3227      * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
 3228      */
 3229     public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;
 3230 
 3231     /**
 3232      * The &#39;alphabetic&#39; (or &#39;roman&#39;) baseline offset from the node&#39;s layoutBounds.minY location
 3233      * that should be used when this node is being vertically aligned by baseline with
 3234      * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
 3235      * and layoutBounds height for non-resizable.  Subclasses
 3236      * which contain text should override this method to return their actual text baseline offset.
 3237      *
 3238      * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
 3239      */
 3240     public double getBaselineOffset() {
 3241         if (isResizable()) {
 3242             return BASELINE_OFFSET_SAME_AS_HEIGHT;
 3243         } else {
 3244             return getLayoutBounds().getHeight();
 3245         }
 3246     }
 3247 
 3248     /**
 3249      * Returns the area of this {@code Node} projected onto the
 3250      * physical screen in pixel units.
 3251      * @return the area of this {@code Node} projected onto the physical screen
 3252      * @since JavaFX 8.0
 3253      */
 3254     public double computeAreaInScreen() {
 3255         return doComputeAreaInScreen();
 3256     }
 3257 
 3258     /*
 3259      * Help application or utility to implement LOD support by returning the
 3260      * projected area of a Node in pixel unit. The projected area is not clipped.
 3261      *
 3262      * For perspective camera, this method first exams node&#39;s bounds against
 3263      * camera&#39;s clipping plane to cut off those out of viewing frustrum. After
 3264      * computing areaInScreen, it applies a tight viewing frustrum check using
 3265      * canonical view volume.
 3266      *
 3267      * The result of areaInScreen comes from the product of
 3268      * (projViewTx x localToSceneTransform x localBounds).
 3269      *
 3270      * Returns 0 for those fall outside viewing frustrum.
 3271      */
 3272     private double doComputeAreaInScreen() {
 3273         Scene tmpScene = getScene();
 3274         if (tmpScene != null) {
 3275             Bounds bounds = getBoundsInLocal();
 3276             Camera camera = tmpScene.getEffectiveCamera();
 3277             boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
 3278             Transform localToSceneTx = getLocalToSceneTransform();
 3279             Affine3D tempTx = TempState.getInstance().tempTx;
 3280             BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
 3281                                                    (float) bounds.getMinY(),
 3282                                                    (float) bounds.getMinZ(),
 3283                                                    (float) bounds.getMaxX(),
 3284                                                    (float) bounds.getMaxY(),
 3285                                                    (float) bounds.getMaxZ());
 3286 
 3287             // NOTE: Viewing frustrum check on camera&#39;s clipping plane is now only
 3288             // for perspective camera.
 3289             // TODO: Need to hook up parallel camera&#39;s nearClip and farClip.
 3290             if (isPerspective) {
 3291                 Transform cameraL2STx = camera.getLocalToSceneTransform();
 3292 
 3293                 // If camera transform only contains translate, compare in scene
 3294                 // coordinate. Otherwise, compare in camera coordinate.
 3295                 if (cameraL2STx.getMxx() == 1.0
 3296                         &amp;&amp; cameraL2STx.getMxy() == 0.0
 3297                         &amp;&amp; cameraL2STx.getMxz() == 0.0
 3298                         &amp;&amp; cameraL2STx.getMyx() == 0.0
 3299                         &amp;&amp; cameraL2STx.getMyy() == 1.0
 3300                         &amp;&amp; cameraL2STx.getMyz() == 0.0
 3301                         &amp;&amp; cameraL2STx.getMzx() == 0.0
 3302                         &amp;&amp; cameraL2STx.getMzy() == 0.0
 3303                         &amp;&amp; cameraL2STx.getMzz() == 1.0) {
 3304 
 3305                     double minZ, maxZ;
 3306 
 3307                     // If node transform only contains translate, only convert
 3308                     // minZ and maxZ to scene coordinate. Otherwise, convert
 3309                     // node bounds to scene coordinate.
 3310                     if (localToSceneTx.getMxx() == 1.0
 3311                             &amp;&amp; localToSceneTx.getMxy() == 0.0
 3312                             &amp;&amp; localToSceneTx.getMxz() == 0.0
 3313                             &amp;&amp; localToSceneTx.getMyx() == 0.0
 3314                             &amp;&amp; localToSceneTx.getMyy() == 1.0
 3315                             &amp;&amp; localToSceneTx.getMyz() == 0.0
 3316                             &amp;&amp; localToSceneTx.getMzx() == 0.0
 3317                             &amp;&amp; localToSceneTx.getMzy() == 0.0
 3318                             &amp;&amp; localToSceneTx.getMzz() == 1.0) {
 3319 
 3320                         Vec3d tempV3D = TempState.getInstance().vec3d;
 3321                         tempV3D.set(0, 0, bounds.getMinZ());
 3322                         localToScene(tempV3D);
 3323                         minZ = tempV3D.z;
 3324 
 3325                         tempV3D.set(0, 0, bounds.getMaxZ());
 3326                         localToScene(tempV3D);
 3327                         maxZ = tempV3D.z;
 3328                     } else {
 3329                         Bounds nodeInSceneBounds = localToScene(bounds);
 3330                         minZ = nodeInSceneBounds.getMinZ();
 3331                         maxZ = nodeInSceneBounds.getMaxZ();
 3332                     }
 3333 
 3334                     if (minZ &gt; camera.getFarClipInScene()
 3335                             || maxZ &lt; camera.getNearClipInScene()) {
 3336                         return 0;
 3337                     }
 3338 
 3339                 } else {
 3340                     BaseBounds nodeInCameraBounds = new BoxBounds();
 3341 
 3342                     // We need to set tempTx to identity since it is a recycled transform.
 3343                     // This is because TransformHelper.apply() is a matrix concatenation operation.
 3344                     tempTx.setToIdentity();
 3345                     TransformHelper.apply(localToSceneTx, tempTx);
 3346 
 3347                     // Convert node from local coordinate to camera coordinate
 3348                     tempTx.preConcatenate(camera.getSceneToLocalTransform());
 3349                     tempTx.transform(localBounds, nodeInCameraBounds);
 3350 
 3351                     // Compare in camera coordinate
 3352                     if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
 3353                             || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
 3354                         return 0;
 3355                     }
 3356                 }
 3357             }
 3358 
 3359             GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
 3360             projViewTx.set(camera.getProjViewTransform());
 3361 
 3362             // We need to set tempTx to identity since it is a recycled transform.
 3363             // This is because TransformHelper.apply() is a matrix concatenation operation.
 3364             tempTx.setToIdentity();
 3365             TransformHelper.apply(localToSceneTx, tempTx);
 3366 
 3367             // The product of projViewTx * localToSceneTransform
 3368             GeneralTransform3D tx = projViewTx.mul(tempTx);
 3369 
 3370             // Transform localBounds to projected bounds
 3371             localBounds = tx.transform(localBounds, localBounds);
 3372             double area = localBounds.getWidth() * localBounds.getHeight();
 3373 
 3374             // Use canonical view volume to check whether object is outside the
 3375             // viewing frustrum
 3376             if (isPerspective) {
 3377                 localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
 3378                 area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
 3379             }
 3380             return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
 3381         }
 3382         return 0;
 3383     }
 3384 
 3385     /* *************************************************************************
 3386      *                                                                         *
 3387      * Bounds related APIs                                                     *
 3388      *                                                                         *
 3389      **************************************************************************/
 3390 
 3391     public final Bounds getBoundsInParent() {
 3392         return boundsInParentProperty().get();
 3393     }
 3394 
 3395     /**
 3396      * The rectangular bounds of this {@code Node} which include its transforms.
 3397      * {@code boundsInParent} is calculated by
 3398      * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
 3399      * the transform created by setting the following additional variables
 3400      * &lt;ol&gt;
 3401      * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
 3402      * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
 3403      * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
 3404      * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY}&lt;/li&gt;
 3405      * &lt;li&gt;{@link #translateXProperty translateX}, {@link #translateYProperty translateY},
 3406      * {@link #translateZProperty translateZ}&lt;/li&gt;
 3407      * &lt;/ol&gt;
 3408      * &lt;p&gt;
 3409      * The resulting bounds will be conceptually in the coordinate space of the
 3410      * {@code Node}&#39;s parent, however the node need not have a parent to calculate
 3411      * these bounds.
 3412      * &lt;p&gt;
 3413      * Note that this method does not take the node&#39;s visibility into account;
 3414      * the computation is based on the geometry of this {@code Node} only.
 3415      * &lt;p&gt;
 3416      * This property will always have a non-null value.
 3417      * &lt;p&gt;
 3418      * Note that {@code boundsInParent} is automatically recomputed whenever the
 3419      * geometry of a node changes, or when any of the following the change:
 3420      * transforms {@code ObservableList}, any of the translate, layout or scale
 3421      * variables, or the rotate variable. For this reason, it is an error
 3422      * to bind any of these values in a node to an expression that depends upon
 3423      * this variable. For example, the x or y variables of a shape, or
 3424      * {@code translateX}, {@code translateY} should never be bound to
 3425      * {@code boundsInParent} for the purpose of positioning the node.
 3426      * @return the boundsInParent for this {@code Node}
 3427      */
 3428     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 3429         return getMiscProperties().boundsInParentProperty();
 3430     }
 3431 
 3432     private void invalidateBoundsInParent() {
 3433         if (miscProperties != null) {
 3434             miscProperties.invalidateBoundsInParent();
 3435         }
 3436     }
 3437 
 3438     public final Bounds getBoundsInLocal() {
 3439         return boundsInLocalProperty().get();
 3440     }
 3441 
 3442     /**
 3443      * The rectangular bounds of this {@code Node} in the node&#39;s
 3444      * untransformed local coordinate space.  For nodes that extend
 3445      * {@link javafx.scene.shape.Shape}, the local bounds will also include
 3446      * space required for a non-zero stroke that may fall outside the shape&#39;s
 3447      * geometry that is defined by position and size attributes.
 3448      * The local bounds will also include any clipping set with {@link #clipProperty clip}
 3449      * as well as effects set with {@link #effectProperty effect}.
 3450      *
 3451      * &lt;p&gt;
 3452      * Note that this method does not take the node&#39;s visibility into account;
 3453      * the computation is based on the geometry of this {@code Node} only.
 3454      * &lt;p&gt;
 3455      * This property will always have a non-null value.
 3456      * &lt;p&gt;
 3457      * Note that boundsInLocal is automatically recomputed whenever the
 3458      * geometry of a node changes. For this reason, it is an error to bind any
 3459      * of these values in a node to an expression that depends upon this variable.
 3460      * For example, the x or y variables of a shape should never be bound
 3461      * to boundsInLocal for the purpose of positioning the node.
 3462      * @return the boundsInLocal for this {@code Node}
 3463      */
 3464     public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 3465         return getMiscProperties().boundsInLocalProperty();
 3466     }
 3467 
 3468     private void invalidateBoundsInLocal() {
 3469         if (miscProperties != null) {
 3470             miscProperties.invalidateBoundsInLocal();
 3471         }
 3472     }
 3473 
 3474     /**
 3475      * The rectangular bounds that should be used for layout calculations for
 3476      * this node. {@code layoutBounds} may differ from the visual bounds
 3477      * of the node and is computed differently depending on the node type.
 3478      * &lt;p&gt;
 3479      * If the node type is resizable ({@link javafx.scene.layout.Region Region},
 3480      * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
 3481      * then the layoutBounds will always be {@code 0,0 width x height}.
 3482      * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
 3483      * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
 3484      * are computed based on the node&#39;s geometric properties and does not include the
 3485      * node&#39;s clip, effect, or transforms.  See individual class documentation
 3486      * for details.
 3487      * &lt;p&gt;
 3488      * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
 3489      * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
 3490      * variables are not included in the layoutBounds.
 3491      * This is important because layout code must first determine the current
 3492      * size and location of the node (using {@code layoutBounds}) and then set
 3493      * {@code layoutX} and {@code layoutY} to adjust the translation of the
 3494      * node so that it will have the desired layout position.
 3495      * &lt;p&gt;
 3496      * Because the computation of layoutBounds is often tied to a node&#39;s
 3497      * geometric variables, it is an error to bind any such variables to an
 3498      * expression that depends upon {@code layoutBounds}. For example, the
 3499      * x or y variables of a shape should never be bound to {@code layoutBounds}
 3500      * for the purpose of positioning the node.
 3501      * &lt;p&gt;
 3502      * Note that for 3D shapes, the layout bounds is actually a rectangular box
 3503      * with X, Y, and Z values, although only X and Y are used in layout calculations.
 3504      * &lt;p&gt;
 3505      * The {@code layoutBounds} will never be null.
 3506      *
 3507      */
 3508     private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
 3509         @Override
 3510         protected Bounds computeBounds() {
 3511             return NodeHelper.computeLayoutBounds(Node.this);
 3512         }
 3513 
 3514         @Override
 3515         public Object getBean() {
 3516             return Node.this;
 3517         }
 3518 
 3519         @Override
 3520         public String getName() {
 3521             return &quot;layoutBounds&quot;;
 3522         }
 3523     };
 3524 
 3525     public final Bounds getLayoutBounds() {
 3526         return layoutBoundsProperty().get();
 3527     }
 3528 
 3529     public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
 3530         return layoutBounds;
 3531     }
 3532 
 3533     /*
 3534      *                  Bounds And Transforms Computation
 3535      *
 3536      *  This section of the code is responsible for computing and caching
 3537      *  various bounds and transforms. For optimal performance and minimal
 3538      *  recomputation of bounds (which can be quite expensive), we cache
 3539      *  values on two different levels. We expose two public immutable
 3540      *  Bounds boundsInParent objects and boundsInLocal. Because they are
 3541      *  immutable and because they may change quite frequently (especially
 3542      *  in the case of a Parent whose children are animated), it is
 3543      *  important that the system does not rely on these variables, because
 3544      *  doing so would produce a large amount of garbage. Rather, these
 3545      *  variables are provided solely for the convenience of application
 3546      *  developers and, being lazily bound, should generally be created at
 3547      *  most once per frame.
 3548      *
 3549      *  The second level of caching are within local Bounds2D variables.
 3550      *  These variables, txBounds and geomBounds, are mutable and as such
 3551      *  can be cached and updated as frequently as necessary without creating
 3552      *  excessive garbage. However, since the computation of bounds is still
 3553      *  expensive, it is desirable to cache both the geometric bounds and
 3554      *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
 3555      *  Cached txBounds is particularly useful when computing the geometric
 3556      *  bounds of a Parent since it would not require complete or partial
 3557      *  recomputation of each child.
 3558      *
 3559      *  Finally, we cache the complete transform for this node which converts
 3560      *  its coord system from local to parent coords. This is useful both for
 3561      *  minimizing bounds recomputations in the case of the geometry having
 3562      *  changed but the transform not having changed, and also because the tx
 3563      *  is required for several different computations (for example, it must
 3564      *  be computed once during state synchronization with the PG peer, and
 3565      *  must also be computed when the pivot point changes, and also when
 3566      *  deriving the txBounds of the Node).
 3567      *
 3568      *  As with any caching system, a subtle and non-trivial amount of code
 3569      *  is devoted to invalidating the bounds / transforms at appropriate
 3570      *  times and in appropriate places to make sure bounds / transforms
 3571      *  are recomputed at all necessary times.
 3572      *
 3573      *  There are three computeXXX functions. One is for computing the
 3574      *  boundsInParent, the second for computing boundsInLocal, and the
 3575      *  third for computing the default layout bounds (which, by default,
 3576      *  is based on the geometric bounds). These functions are all prefixed
 3577      *  with &quot;compute&quot; because they create and return new immutable
 3578      *  Bounds objects.
 3579      *
 3580      *  There are three getXXXBounds functions. One is for returning the
 3581      *  complete transformed bounds. The second is for returning the
 3582      *  local bounds. The last is for returning the geometric bounds. These
 3583      *  functions are all prefixed with &quot;get&quot; because they may well return
 3584      *  a cached value, or may actually compute the bounds if necessary. These
 3585      *  functions all have the same signature. They take a Bounds2D and
 3586      *  BaseTransform, and return a Bounds2D (the same as they took). These
 3587      *  functions essentially populate the supplied bounds2D with the
 3588      *  appropriate bounds information, leveraging cached bounds if possible.
 3589      *
 3590      *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
 3591      *  This must be implemented in each subclass, and is responsible for
 3592      *  computing the actual geometric bounds for the Node. For example, Parent
 3593      *  is written such that this function is the union of the transformed
 3594      *  bounds of each child. Rectangle is written such that this takes into
 3595      *  account the size and stroke. Text is written such that it is computed
 3596      *  based on the actual glyphs.
 3597      *
 3598      *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
 3599      *  These functions are for ensuring that geomBounds and txBounds are
 3600      *  valid. They only execute in the case of the cached value being invalid,
 3601      *  so the function call is very cheap in cases where the cached bounds
 3602      *  values are still valid.
 3603      */
 3604 
 3605     /**
 3606      * An affine transform that holds the computed local-to-parent transform.
 3607      * This is the concatenation of all transforms in this node, including all
 3608      * of the convenience transforms.
 3609      */
 3610     private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;
 3611 
 3612     /**
 3613      * This flag is used to indicate that localToParentTx is dirty and needs
 3614      * to be recomputed.
 3615      */
 3616     private boolean transformDirty = true;
 3617 
 3618     /**
 3619      * The cached transformed bounds. This is never null, but is frequently set
 3620      * to be invalid whenever the bounds for the node have changed. These are
 3621      * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
 3622      * Note that this is equivalent to boundsInParent
 3623      */
 3624     private BaseBounds txBounds = new RectBounds();
 3625 
 3626     /**
 3627      * The cached bounds. This is never null, but is frequently set to be
 3628      * invalid whenever the bounds for the node have changed. These are the
 3629      * &quot;content&quot; bounds, that is, without transforms or effects applied.
 3630      */
 3631     private BaseBounds geomBounds = new RectBounds();
 3632 
 3633     /**
 3634      * The cached local bounds (without transforms, with clip and effects).
 3635      * If there is neither clip nor effect
 3636      * local bounds are equal to geom bounds, so in this case we don&#39;t keep
 3637      * the extra instance and set null to this variable.
 3638      */
 3639     private BaseBounds localBounds = null;
 3640 
 3641     /**
 3642      * This special flag is used only by Parent to flag whether or not
 3643      * the *parent* has processed the fact that bounds have changed for this
 3644      * child Node. We need some way of flagging this on a per-node basis to
 3645      * enable the significant performance optimizations and fast paths that
 3646      * are in the Parent code.
 3647      * &lt;p&gt;
 3648      * To reduce confusion, although this variable is defined on Node, it
 3649      * really belongs to the Parent of the node and should *only* be modified
 3650      * by the parent.
 3651      */
 3652     boolean boundsChanged;
 3653 
 3654     /*
 3655      * Returns geometric bounds, but may be over-ridden by a subclass.
 3656      */
 3657     private Bounds doComputeLayoutBounds() {
 3658         BaseBounds tempBounds = TempState.getInstance().bounds;
 3659         tempBounds = getGeomBounds(tempBounds,
 3660                                    BaseTransform.IDENTITY_TRANSFORM);
 3661         return new BoundingBox(tempBounds.getMinX(),
 3662                                tempBounds.getMinY(),
 3663                                tempBounds.getMinZ(),
 3664                                tempBounds.getWidth(),
 3665                                tempBounds.getHeight(),
 3666                                tempBounds.getDepth());
 3667     }
 3668 
 3669     /*
 3670      * Subclasses may customize the layoutBounds by means of overriding the
 3671      * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
 3672      * recomputed, the subclass must notify the Node implementation of this
 3673      * fact so that appropriate notifications and internal state can be
 3674      * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
 3675      * let Node know that the layout bounds are invalid and need to be
 3676      * recomputed.
 3677      */
 3678     final void layoutBoundsChanged() {
 3679         if (!layoutBounds.valid) {
 3680             return;
 3681         }
 3682         layoutBounds.invalidate();
 3683         if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
 3684             // if either the scale or rotate convenience variables are used,
 3685             // then we need a valid pivot point. Since the layoutBounds
 3686             // affects the pivot we need to invalidate the transform
 3687             NodeHelper.transformsChanged(this);
 3688         }
 3689     }
 3690 
 3691     /**
 3692      * Loads the given bounds object with the transformed bounds relative to,
 3693      * and based on, the given transform. That is, this is the local bounds
 3694      * with the local-to-parent transform applied.
 3695      *
 3696      * We *never* pass null in as a bounds. This method will
 3697      * NOT take a null bounds object. The returned value may be
 3698      * the same bounds object passed in, or it may be a new object.
 3699      * The reason for this object promotion is in the case of needing
 3700      * to promote from a RectBounds to a BoxBounds (3D).
 3701      */
 3702     BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
 3703         updateLocalToParentTransform();
 3704         if (tx.isTranslateOrIdentity()) {
 3705             updateTxBounds();
 3706             bounds = bounds.deriveWithNewBounds(txBounds);
 3707             if (!tx.isIdentity()) {
 3708                 final double translateX = tx.getMxt();
 3709                 final double translateY = tx.getMyt();
 3710                 final double translateZ = tx.getMzt();
 3711                 bounds = bounds.deriveWithNewBounds(
 3712                                     (float) (bounds.getMinX() + translateX),
 3713                                     (float) (bounds.getMinY() + translateY),
 3714                                     (float) (bounds.getMinZ() + translateZ),
 3715                                     (float) (bounds.getMaxX() + translateX),
 3716                                     (float) (bounds.getMaxY() + translateY),
 3717                                     (float) (bounds.getMaxZ() + translateZ));
 3718             }
 3719             return bounds;
 3720         } else if (localToParentTx.isIdentity()) {
 3721             return getLocalBounds(bounds, tx);
 3722         } else {
 3723             double mxx = tx.getMxx();
 3724             double mxy = tx.getMxy();
 3725             double mxz = tx.getMxz();
 3726             double mxt = tx.getMxt();
 3727             double myx = tx.getMyx();
 3728             double myy = tx.getMyy();
 3729             double myz = tx.getMyz();
 3730             double myt = tx.getMyt();
 3731             double mzx = tx.getMzx();
 3732             double mzy = tx.getMzy();
 3733             double mzz = tx.getMzz();
 3734             double mzt = tx.getMzt();
 3735             BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
 3736             bounds = getLocalBounds(bounds, boundsTx);
 3737             if (boundsTx == tx) {
 3738                 tx.restoreTransform(mxx, mxy, mxz, mxt,
 3739                                     myx, myy, myz, myt,
 3740                                     mzx, mzy, mzz, mzt);
 3741             }
 3742             return bounds;
 3743         }
 3744     }
 3745 
 3746     /**
 3747      * Loads the given bounds object with the local bounds relative to,
 3748      * and based on, the given transform. That is, these are the geometric
 3749      * bounds + clip and effect.
 3750      *
 3751      * We *never* pass null in as a bounds. This method will
 3752      * NOT take a null bounds object. The returned value may be
 3753      * the same bounds object passed in, or it may be a new object.
 3754      * The reason for this object promotion is in the case of needing
 3755      * to promote from a RectBounds to a BoxBounds (3D).
 3756      */
 3757     BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3758         if (getEffect() == null &amp;&amp; getClip() == null) {
 3759             return getGeomBounds(bounds, tx);
 3760         }
 3761 
 3762         if (tx.isTranslateOrIdentity()) {
 3763             // we can take a fast path since we know tx is either a simple
 3764             // translation or is identity
 3765             updateLocalBounds();
 3766             bounds = bounds.deriveWithNewBounds(localBounds);
 3767             if (!tx.isIdentity()) {
 3768                 double translateX = tx.getMxt();
 3769                 double translateY = tx.getMyt();
 3770                 double translateZ = tx.getMzt();
 3771                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3772                         (float) (bounds.getMinY() + translateY),
 3773                         (float) (bounds.getMinZ() + translateZ),
 3774                         (float) (bounds.getMaxX() + translateX),
 3775                         (float) (bounds.getMaxY() + translateY),
 3776                         (float) (bounds.getMaxZ() + translateZ));
 3777             }
 3778             return bounds;
 3779         } else if (tx.is2D()
 3780                 &amp;&amp; (tx.getType()
 3781                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3782                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3783             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3784             return computeLocalBounds(bounds, tx);
 3785         } else {
 3786             // 3D transformations and
 3787             // selected 2D transformations (uniform transform, flip, quadrant rotation).
 3788             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3789             // geomBounds
 3790             // Note: Transforming the local bounds into a 3D space will yield a bounds
 3791             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3792             updateLocalBounds();
 3793             return tx.transform(localBounds, bounds);
 3794         }
 3795     }
 3796 
 3797     /**
 3798      * Loads the given bounds object with the geometric bounds relative to,
 3799      * and based on, the given transform.
 3800      *
 3801      * We *never* pass null in as a bounds. This method will
 3802      * NOT take a null bounds object. The returned value may be
 3803      * the same bounds object passed in, or it may be a new object.
 3804      * The reason for this object promotion is in the case of needing
 3805      * to promote from a RectBounds to a BoxBounds (3D).
 3806      */
 3807     BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
 3808         if (tx.isTranslateOrIdentity()) {
 3809             // we can take a fast path since we know tx is either a simple
 3810             // translation or is identity
 3811             updateGeomBounds();
 3812             bounds = bounds.deriveWithNewBounds(geomBounds);
 3813             if (!tx.isIdentity()) {
 3814                 double translateX = tx.getMxt();
 3815                 double translateY = tx.getMyt();
 3816                 double translateZ = tx.getMzt();
 3817                 bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
 3818                         (float) (bounds.getMinY() + translateY),
 3819                         (float) (bounds.getMinZ() + translateZ),
 3820                         (float) (bounds.getMaxX() + translateX),
 3821                         (float) (bounds.getMaxY() + translateY),
 3822                         (float) (bounds.getMaxZ() + translateZ));
 3823             }
 3824             return bounds;
 3825         } else if (tx.is2D()
 3826                 &amp;&amp; (tx.getType()
 3827                 &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
 3828                 | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
 3829             // this is a non-uniform scale / non-quadrant rotate / skew transform
 3830             return NodeHelper.computeGeomBounds(this, bounds, tx);
 3831         } else {
 3832             // 3D transformations and
 3833             // selected 2D transformations (unifrom transform, flip, quadrant rotation).
 3834             // These 2D transformation will yield tight bounds when applied on the pre-computed
 3835             // geomBounds
 3836             // Note: Transforming the local geomBounds into a 3D space will yield a bounds
 3837             // that isn&#39;t as tight as transforming its geometry and compute it bounds.
 3838             updateGeomBounds();
 3839             return tx.transform(geomBounds, bounds);
 3840         }
 3841     }
 3842 
 3843     /**
 3844      * If necessary, recomputes the cached geom bounds. If the bounds are not
 3845      * invalid, then this method is a no-op.
 3846      */
 3847     void updateGeomBounds() {
 3848         if (geomBoundsInvalid) {
 3849             geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
 3850             geomBoundsInvalid = false;
 3851         }
 3852     }
 3853 
 3854     /**
 3855      * Computes the local bounds of this Node.
 3856      */
 3857     private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
 3858         // We either get the bounds of the effect (if it isn&#39;t null)
 3859         // or we get the geom bounds (if effect is null). We will then
 3860         // intersect this with the clip.
 3861         if (getEffect() != null) {
 3862             BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
 3863             bounds = bounds.deriveWithNewBounds(b);
 3864         } else {
 3865             bounds = getGeomBounds(bounds, tx);
 3866         }
 3867         // intersect with the clip. Take care with &quot;bounds&quot; as it may
 3868         // actually be TEMP_BOUNDS, so we save off state
 3869         if (getClip() != null
 3870                 // FIXME: All 3D picking is currently ignored by rendering.
 3871                 // Until this is fixed or defined differently (RT-28510),
 3872                 // we follow this behavior.
 3873                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
 3874             double x1 = bounds.getMinX();
 3875             double y1 = bounds.getMinY();
 3876             double x2 = bounds.getMaxX();
 3877             double y2 = bounds.getMaxY();
 3878             double z1 = bounds.getMinZ();
 3879             double z2 = bounds.getMaxZ();
 3880             bounds = getClip().getTransformedBounds(bounds, tx);
 3881             bounds.intersectWith((float)x1, (float)y1, (float)z1,
 3882                     (float)x2, (float)y2, (float)z2);
 3883         }
 3884         return bounds;
 3885     }
 3886 
 3887 
 3888     /**
 3889      * If necessary, recomputes the cached local bounds. If the bounds are not
 3890      * invalid, then this method is a no-op.
 3891      */
 3892     private void updateLocalBounds() {
 3893         if (localBoundsInvalid) {
 3894             if (getClip() != null || getEffect() != null) {
 3895                 localBounds = computeLocalBounds(
 3896                         localBounds == null ? new RectBounds() : localBounds,
 3897                         BaseTransform.IDENTITY_TRANSFORM);
 3898             } else {
 3899                 localBounds = null;
 3900             }
 3901             localBoundsInvalid = false;
 3902         }
 3903     }
 3904 
 3905     /**
 3906      * If necessary, recomputes the cached transformed bounds.
 3907      * If the cached transformed bounds are not invalid, then
 3908      * this method is a no-op.
 3909      */
 3910     void updateTxBounds() {
 3911         if (txBoundsInvalid) {
 3912             updateLocalToParentTransform();
 3913             txBounds = getLocalBounds(txBounds, localToParentTx);
 3914             txBoundsInvalid = false;
 3915         }
 3916     }
 3917 
 3918     /*
 3919      *                   Bounds Invalidation And Notification
 3920      *
 3921      *  The goal of this section is to efficiently propagate bounds
 3922      *  invalidation through the scenegraph while also being semantically
 3923      *  correct.
 3924      *
 3925      *  The code path for invalidation of layout bounds is somewhat confusing
 3926      *  primarily due to performance enhancements and the desire to reduce the
 3927      *  number of requestLayout() calls that are performed when layout bounds
 3928      *  change. Before diving into layout bounds, I will first describe how
 3929      *  normal bounds invalidation occurs.
 3930      *
 3931      *  When a node&#39;s geometry changes (for example, if the width of a
 3932      *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
 3933      *  Invoking this function will eventually clear all cached bounds and
 3934      *  notify to each parent up the tree that their bounds may have changed.
 3935      *
 3936      *  After invalidating geomBounds (and after kicking off layout bounds
 3937      *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
 3938      *  be noted that NodeHelper.geomChanged should only be called when the geometry
 3939      *  of the node has changed such that it may result in the geom bounds
 3940      *  actually changing.
 3941      *
 3942      *  localBoundsChanged() simply invalidates boundsInLocal and then calls
 3943      *  transformedBoundsChanged().
 3944      *
 3945      *  transformedBoundsChanged() is responsible for invalidating
 3946      *  boundsInParent and txBounds. If the Node is not visible, then there is
 3947      *  no need to notify the parent of the bounds change because the parent&#39;s
 3948      *  bounds do not include invisible nodes. If the node is visible, then
 3949      *  it must tell the parent that this child node&#39;s bounds have changed.
 3950      *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
 3951      *  function. If instead of a parent this node has a clipParent, then the
 3952      *  clipParent&#39;s localBoundsChanged() is called instead.
 3953      *
 3954      *  There are a few other ways in which we enter the invalidate steps
 3955      *  beyond just the geometry changes. If the visibility of a Node changes,
 3956      *  its own bounds are not affected but its parent&#39;s bounds are. So a
 3957      *  special call to parent.childVisibilityChanged is made so the parent
 3958      *  can react accordingly.
 3959      *
 3960      *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
 3961      *  then the transform must be invalidated. When a transform is invalidated,
 3962      *  it must also invalidate the txBounds by invoking
 3963      *  transformedBoundsChanged, which will in turn notify the parent as
 3964      *  before.
 3965      *
 3966      *  If an effect is changed or replaced then the local bounds must be
 3967      *  invalidated, as well as the transformedBounds and the parent notified
 3968      *  of the change in bounds.
 3969      *
 3970      *  layoutBound is somewhat unique in that it can be redefined in
 3971      *  subclasses. By default, the layoutBounds is the geomBounds, and so
 3972      *  whenever the geomBounds() function is called the layoutBounds
 3973      *  must be invalidated. However in subclasses, especially Resizables,
 3974      *  the layout bounds may not be defined to be the same as the geometric
 3975      *  bounds. This is both useful and provides a very nice performance
 3976      *  optimization for regions and controls. In this case, subclasses
 3977      *  need some way to interpose themselves such that a call to
 3978      *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
 3979      *
 3980      *  This interposition happens by providing the
 3981      *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
 3982      *  simply invalidates boundsInLocal. Subclasses (such as Region and
 3983      *  Control) can override this function so that it does not invalidate
 3984      *  the layout bounds.
 3985      *
 3986      *  An on invalidate trigger on layoutBounds handles kicking off the rest
 3987      *  of the invalidate process for layoutBounds. Because the layout bounds
 3988      *  define the pivot point, if scaleX, scaleY, or rotate contain
 3989      *  non-identity values then whenever the layoutBounds change the
 3990      *  transformed bounds also change. Finally, if this node&#39;s parent is
 3991      *  a Region and if the Node is being managed by the Region, then
 3992      *  we must call requestLayout on the Region whenever the layout bounds
 3993      *  have changed.
 3994      */
 3995 
 3996     /*
 3997      * Invoked by subclasses whenever their geometric bounds have changed.
 3998      * Because the default layout bounds is based on the node geometry, this
 3999      * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
 4000      * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
 4001      * layoutBounds. Resizable subclasses will want to override this function
 4002      * in most cases to be a no-op.
 4003      *
 4004      * This function will also invalidate the cached geom bounds, and then
 4005      * invoke localBoundsChanged() which will eventually end up invoking a
 4006      * chain of functions up the tree to ensure that each parent of this
 4007      * Node is notified that its bounds may have also changed.
 4008      *
 4009      * This function should be treated as though it were final. It is not
 4010      * intended to be overridden by subclasses.
 4011      *
 4012      * Note: This method MUST only be called via its accessor method.
 4013      */
 4014     private void doGeomChanged() {
 4015         if (geomBoundsInvalid) {
 4016             // GeomBoundsInvalid is false when node geometry changed and
 4017             // the untransformed node bounds haven&#39;t been recalculated yet.
 4018             // Most of the time, the recalculation of layout and transformed
 4019             // node bounds don&#39;t require validation of untransformed bounds
 4020             // and so we can not skip the following notifications.
 4021             NodeHelper.notifyLayoutBoundsChanged(this);
 4022             transformedBoundsChanged();
 4023             return;
 4024         }
 4025         geomBounds.makeEmpty();
 4026         geomBoundsInvalid = true;
 4027         NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
 4028         NodeHelper.notifyLayoutBoundsChanged(this);
 4029         localBoundsChanged();
 4030     }
 4031 
 4032     private boolean geomBoundsInvalid = true;
 4033     private boolean localBoundsInvalid = true;
 4034     private boolean txBoundsInvalid = true;
 4035 
 4036     /**
 4037      * Responds to changes in the local bounds by invalidating boundsInLocal
 4038      * and notifying this node that its transformed bounds have changed.
 4039      */
 4040     void localBoundsChanged() {
 4041         localBoundsInvalid = true;
 4042         invalidateBoundsInLocal();
 4043         transformedBoundsChanged();
 4044     }
 4045 
 4046     /**
 4047      * Responds to changes in the transformed bounds by invalidating txBounds
 4048      * and boundsInParent. If this Node is not visible, then we have no need
 4049      * to walk further up the tree but can instead simply invalidate state.
 4050      * Otherwise, this function will notify parents (either the parent or the
 4051      * clipParent) that this child Node&#39;s bounds have changed.
 4052      */
 4053     void transformedBoundsChanged() {
 4054         if (!txBoundsInvalid) {
 4055             txBounds.makeEmpty();
 4056             txBoundsInvalid = true;
 4057             invalidateBoundsInParent();
 4058             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
 4059         }
 4060         if (isVisible()) {
 4061             notifyParentOfBoundsChange();
 4062         }
 4063     }
 4064 
 4065     /*
 4066      * Invoked by geomChanged(). Since layoutBounds is by default based
 4067      * on the geometric bounds, the default implementation of this function will
 4068      * invalidate the layoutBounds. Resizable Node subclasses generally base
 4069      * layoutBounds on the width/height instead of the geometric bounds, and so
 4070      * will generally want to override this function to be a no-op.
 4071      *
 4072      * Note: This method MUST only be called via its accessor method.
 4073      */
 4074     private void doNotifyLayoutBoundsChanged() {
 4075         layoutBoundsChanged();
 4076         // notify the parent
 4077         // Group instanceof check a little hoaky, but it allows us to disable
 4078         // unnecessary layout for the case of a non-resizable within a group
 4079         Parent p = getParent();
 4080 
 4081         // Need to propagate layout if parent isn&#39;t part of performing layout
 4082         if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
 4083                 &amp;&amp; !p.isPerformingLayout()) {
 4084             // Force its parent to fix the layout since it is a managed child.
 4085             p.requestLayout(true);
 4086         }
 4087     }
 4088 
 4089     /**
 4090      * Notifies both the real parent and the clip parent (if they exist) that
 4091      * the bounds of the child has changed. Note that since FX doesn&#39;t throw
 4092      * NPE&#39;s, things actually are faster if we don&#39;t check twice for Null
 4093      * (we check once, the compiler checks again)
 4094      */
 4095     void notifyParentOfBoundsChange() {
 4096         // let the parent know which node has changed and the parent will
 4097         // deal with marking itself invalid correctly
 4098         Parent p = getParent();
 4099         if (p != null) {
 4100             p.childBoundsChanged(this);
 4101         }
 4102         // since the clip is used to compute the local bounds (and not the
 4103         // geom bounds), we just need to notify that local bounds on the
 4104         // clip parent have changed
 4105         if (clipParent != null) {
 4106             clipParent.localBoundsChanged();
 4107         }
 4108     }
 4109 
 4110     /***************************************************************************
 4111      *                                                                         *
 4112      * Geometry and coordinate system related APIs. For example, methods       *
 4113      * related to containment, intersection, coordinate space conversion, etc. *
 4114      *                                                                         *
 4115      **************************************************************************/
 4116 
 4117     /**
 4118      * Returns {@code true} if the given point (specified in the local
 4119      * coordinate space of this {@code Node}) is contained within the shape of
 4120      * this {@code Node}. Note that this method does not take visibility into
 4121      * account; the test is based on the geometry of this {@code Node} only.
 4122      * @param localX the x coordinate of the point in Node&#39;s space
 4123      * @param localY the y coordinate of the point in Node&#39;s space
 4124      * @return the result of contains for this {@code Node}
 4125      */
 4126     public boolean contains(double localX, double localY) {
 4127         if (containsBounds(localX, localY)) {
 4128             return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
 4129         }
 4130         return false;
 4131     }
 4132 
 4133     /*
 4134      * This method only does the contains check based on the bounds, clip and
 4135      * effect of this node, excluding its shape (or geometry).
 4136      *
 4137      * Returns true if the given point (specified in the local
 4138      * coordinate space of this {@code Node}) is contained within the bounds,
 4139      * clip and effect of this node.
 4140      */
 4141     private boolean containsBounds(double localX, double localY) {
 4142         final TempState tempState = TempState.getInstance();
 4143         BaseBounds tempBounds = tempState.bounds;
 4144 
 4145         // first, we do a quick test to see if the point is contained in
 4146         // our local bounds. If so, then we will go the next step and check
 4147         // the clip, effect, and geometry for containment.
 4148         tempBounds = getLocalBounds(tempBounds,
 4149                                     BaseTransform.IDENTITY_TRANSFORM);
 4150         if (tempBounds.contains((float)localX, (float)localY)) {
 4151             // if the clip is defined, then check it for containment, being
 4152             // sure to convert from this node&#39;s local coordinate system
 4153             // to the local coordinate system of the clip node
 4154             if (getClip() != null) {
 4155                 tempState.point.x = (float)localX;
 4156                 tempState.point.y = (float)localY;
 4157                 try {
 4158                     getClip().parentToLocal(tempState.point);
 4159                 } catch (NoninvertibleTransformException e) {
 4160                     return false;
 4161                 }
 4162                 if (!getClip().contains(tempState.point.x, tempState.point.y)) {
 4163                     return false;
 4164                 }
 4165             }
 4166             return true;
 4167         }
 4168         return false;
 4169     }
 4170 
 4171     /**
 4172      * Returns {@code true} if the given point (specified in the local
 4173      * coordinate space of this {@code Node}) is contained within the shape of
 4174      * this {@code Node}. Note that this method does not take visibility into
 4175      * account; the test is based on the geometry of this {@code Node} only.
 4176      * @param localPoint the 2D point in Node&#39;s space
 4177      * @return the result of contains for this {@code Node}
 4178      */
 4179     public boolean contains(Point2D localPoint) {
 4180         return contains(localPoint.getX(), localPoint.getY());
 4181     }
 4182 
 4183     /**
 4184      * Returns {@code true} if the given rectangle (specified in the local
 4185      * coordinate space of this {@code Node}) intersects the shape of this
 4186      * {@code Node}. Note that this method does not take visibility into
 4187      * account; the test is based on the geometry of this {@code Node} only.
 4188      * The default behavior of this function is simply to check if the
 4189      * given coordinates intersect with the local bounds.
 4190      * @param localX the x coordinate of a rectangle in Node&#39;s space
 4191      * @param localY the y coordinate of a rectangle in Node&#39;s space
 4192      * @param localWidth the width of a rectangle in Node&#39;s space
 4193      * @param localHeight the height of a rectangle in Node&#39;s space
 4194      * @return the result of intersects for this {@code Node}
 4195      */
 4196     public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
 4197         BaseBounds tempBounds = TempState.getInstance().bounds;
 4198         tempBounds = getLocalBounds(tempBounds,
 4199                                     BaseTransform.IDENTITY_TRANSFORM);
 4200         return tempBounds.intersects((float)localX,
 4201                                      (float)localY,
 4202                                      (float)localWidth,
 4203                                      (float)localHeight);
 4204     }
 4205 
 4206     /**
 4207      * Returns {@code true} if the given bounds (specified in the local
 4208      * coordinate space of this {@code Node}) intersects the shape of this
 4209      * {@code Node}. Note that this method does not take visibility into
 4210      * account; the test is based on the geometry of this {@code Node} only.
 4211      * The default behavior of this function is simply to check if the
 4212      * given coordinates intersect with the local bounds.
 4213      * @param localBounds the bounds
 4214      * @return the result of intersects for this {@code Node}
 4215      */
 4216     public boolean intersects(Bounds localBounds) {
 4217         return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
 4218     }
 4219 
 4220     /**
 4221      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4222      * into the local coordinate space of this {@code Node}.
 4223      * @param screenX x coordinate of a point on a Screen
 4224      * @param screenY y coordinate of a point on a Screen
 4225      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4226      * Null is also returned if the transformation from local to Scene is not invertible.
 4227      * @since JavaFX 8.0
 4228      */
 4229     public Point2D screenToLocal(double screenX, double screenY) {
 4230         Scene scene = getScene();
 4231         if (scene == null) return null;
 4232         Window window = scene.getWindow();
 4233         if (window == null) return null;
 4234 
 4235         final com.sun.javafx.geom.Point2D tempPt =
 4236                 TempState.getInstance().point;
 4237 
 4238         tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
 4239                            (float)(screenY - scene.getY() - window.getY()));
 4240 
 4241         final SubScene subScene = getSubScene();
 4242         if (subScene != null) {
 4243             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4244                     new Point2D(tempPt.x, tempPt.y));
 4245             if (ssCoord == null) {
 4246                 return null;
 4247             }
 4248             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4249         }
 4250 
 4251         final Point3D ppIntersect =
 4252                 scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
 4253         tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());
 4254 
 4255         try {
 4256             sceneToLocal(tempPt);
 4257         } catch (NoninvertibleTransformException e) {
 4258             return null;
 4259         }
 4260         return new Point2D(tempPt.x, tempPt.y);
 4261     }
 4262 
 4263     /**
 4264      * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
 4265      * into the local coordinate space of this {@code Node}.
 4266      * @param screenPoint a point on a Screen
 4267      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4268      * Null is also returned if the transformation from local to Scene is not invertible.
 4269      * @since JavaFX 8.0
 4270      */
 4271     public Point2D screenToLocal(Point2D screenPoint) {
 4272         return screenToLocal(screenPoint.getX(), screenPoint.getY());
 4273     }
 4274 
 4275     /**
 4276      * Transforms a rectangle from the coordinate space of the
 4277      * {@link javafx.stage.Screen} into the local coordinate space of this
 4278      * {@code Node}. Returns reasonable result only in 2D space.
 4279      * @param screenBounds bounds on a Screen
 4280      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4281      * Null is also returned if the transformation from local to Scene is not invertible.
 4282      * @since JavaFX 8.0
 4283      */
 4284     public Bounds screenToLocal(Bounds screenBounds) {
 4285         final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
 4286         final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
 4287         final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
 4288         final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());
 4289 
 4290         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4291     }
 4292 
 4293 
 4294     /**
 4295      * Transforms a point from the coordinate space of the scene
 4296      * into the local coordinate space of this {@code Node}.
 4297      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4298      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4299      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4300      * {@link #sceneToLocal(double, double)}.
 4301      *
 4302      * @param x the x coordinate
 4303      * @param y the y coordinate
 4304      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4305      * @return local coordinates of the point
 4306      * @since JavaFX 8u40
 4307      */
 4308     public Point2D sceneToLocal(double x, double y, boolean rootScene) {
 4309         if (!rootScene) {
 4310             return sceneToLocal(x, y);
 4311         }
 4312         final com.sun.javafx.geom.Point2D tempPt =
 4313                 TempState.getInstance().point;
 4314 
 4315         tempPt.setLocation((float)(x), (float)y);
 4316 
 4317         final SubScene subScene = getSubScene();
 4318         if (subScene != null) {
 4319             final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
 4320                     new Point2D(tempPt.x, tempPt.y));
 4321             if (ssCoord == null) {
 4322                 return null;
 4323             }
 4324             tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
 4325         }
 4326 
 4327         try {
 4328             sceneToLocal(tempPt);
 4329             return new Point2D(tempPt.x, tempPt.y);
 4330         } catch (NoninvertibleTransformException e) {
 4331             return null;
 4332         }
 4333     }
 4334 
 4335     /**
 4336      * Transforms a point from the coordinate space of the scene
 4337      * into the local coordinate space of this {@code Node}.
 4338      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4339      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4340      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4341      * {@link #sceneToLocal(javafx.geometry.Point2D)}.
 4342      *
 4343      * @param point the point
 4344      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4345      * @return local coordinates of the point
 4346      * @since JavaFX 8u40
 4347      */
 4348     public Point2D sceneToLocal(Point2D point, boolean rootScene) {
 4349         return sceneToLocal(point.getX(), point.getY(), rootScene);
 4350     }
 4351 
 4352     /**
 4353      * Transforms a bounds from the coordinate space of the scene
 4354      * into the local coordinate space of this {@code Node}.
 4355      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4356      * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4357      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4358      * {@link #sceneToLocal(javafx.geometry.Bounds)}.
 4359      * &lt;p&gt;
 4360      *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
 4361      * &lt;/p&gt;
 4362      * @param bounds the bounds
 4363      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4364      * @return local coordinates of the bounds
 4365      * @since JavaFX 8u40
 4366      */
 4367     public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
 4368         if (!rootScene) {
 4369             return sceneToLocal(bounds);
 4370         }
 4371         if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
 4372             return null;
 4373         }
 4374         final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
 4375         final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
 4376         final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
 4377         final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);
 4378 
 4379         return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4380     }
 4381 
 4382     /**
 4383      * Transforms a point from the coordinate space of the scene
 4384      * into the local coordinate space of this {@code Node}.
 4385      *
 4386      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4387      * not that of {@link javafx.scene.Scene}.
 4388      *
 4389      * @param sceneX x coordinate of a point on a Scene
 4390      * @param sceneY y coordinate of a point on a Scene
 4391      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4392      * Null is also returned if the transformation from local to Scene is not invertible.
 4393      */
 4394     public Point2D sceneToLocal(double sceneX, double sceneY) {
 4395         final com.sun.javafx.geom.Point2D tempPt =
 4396                 TempState.getInstance().point;
 4397         tempPt.setLocation((float)sceneX, (float)sceneY);
 4398         try {
 4399             sceneToLocal(tempPt);
 4400         } catch (NoninvertibleTransformException e) {
 4401             return null;
 4402         }
 4403         return new Point2D(tempPt.x, tempPt.y);
 4404     }
 4405 
 4406     /**
 4407      * Transforms a point from the coordinate space of the scene
 4408      * into the local coordinate space of this {@code Node}.
 4409      *
 4410      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4411      * not that of {@link javafx.scene.Scene}.
 4412      *
 4413      * @param scenePoint a point on a Scene
 4414      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4415      * Null is also returned if the transformation from local to Scene is not invertible.
 4416      */
 4417     public Point2D sceneToLocal(Point2D scenePoint) {
 4418         return sceneToLocal(scenePoint.getX(), scenePoint.getY());
 4419     }
 4420 
 4421     /**
 4422      * Transforms a point from the coordinate space of the scene
 4423      * into the local coordinate space of this {@code Node}.
 4424      *
 4425      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4426      * not that of {@link javafx.scene.Scene}.
 4427      *
 4428      * @param scenePoint a point on a Scene
 4429      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4430      * Null is also returned if the transformation from local to Scene is not invertible.
 4431      * @since JavaFX 8.0
 4432      */
 4433     public Point3D sceneToLocal(Point3D scenePoint) {
 4434         return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
 4435     }
 4436 
 4437     /**
 4438      * Transforms a point from the coordinate space of the scene
 4439      * into the local coordinate space of this {@code Node}.
 4440      *
 4441      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4442      * not that of {@link javafx.scene.Scene}.
 4443      *
 4444      * @param sceneX x coordinate of a point on a Scene
 4445      * @param sceneY y coordinate of a point on a Scene
 4446      * @param sceneZ z coordinate of a point on a Scene
 4447      * @return local Node&#39;s coordinates of the point or null if Node is not in a {@link Window}.
 4448      * Null is also returned if the transformation from local to Scene is not invertible.
 4449      * @since JavaFX 8.0
 4450      */
 4451     public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
 4452         try {
 4453             return sceneToLocal0(sceneX, sceneY, sceneZ);
 4454         } catch (NoninvertibleTransformException ex) {
 4455             return null;
 4456         }
 4457     }
 4458 
 4459     /**
 4460      * Internal method to transform a point from scene to local coordinates.
 4461      */
 4462     private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
 4463         final com.sun.javafx.geom.Vec3d tempV3D =
 4464                 TempState.getInstance().vec3d;
 4465         tempV3D.set(x, y, z);
 4466         sceneToLocal(tempV3D);
 4467         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4468     }
 4469 
 4470     /**
 4471      * Transforms a rectangle from the coordinate space of the
 4472      * scene into the local coordinate space of this
 4473      * {@code Node}.
 4474      *
 4475      * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
 4476      * not that of {@link javafx.scene.Scene}.
 4477      *
 4478      * @param sceneBounds bounds on a Scene
 4479      * @return bounds in the local Node&#39;space or null if Node is not in a {@link Window}.
 4480      * Null is also returned if the transformation from local to Scene is not invertible.
 4481      */
 4482     public Bounds sceneToLocal(Bounds sceneBounds) {
 4483         // Do a quick update of localToParentTransform so that we can determine
 4484         // if this tx is 2D transform
 4485         updateLocalToParentTransform();
 4486         if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
 4487             Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
 4488             Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
 4489             Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
 4490             Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());
 4491 
 4492             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4493         }
 4494         try {
 4495             Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4496             Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4497             Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4498             Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4499             Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
 4500             Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
 4501             Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
 4502             Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
 4503             return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4504         } catch (NoninvertibleTransformException e) {
 4505             return null;
 4506         }
 4507     }
 4508 
 4509     /**
 4510      * Transforms a point from the local coordinate space of this {@code Node}
 4511      * into the coordinate space of its {@link javafx.stage.Screen}.
 4512      * @param localX x coordinate of a point in Node&#39;s space
 4513      * @param localY y coordinate of a point in Node&#39;s space
 4514      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4515      * @since JavaFX 8.0
 4516      */
 4517     public Point2D localToScreen(double localX, double localY) {
 4518         return localToScreen(localX, localY, 0.0);
 4519     }
 4520 
 4521     /**
 4522      * Transforms a point from the local coordinate space of this {@code Node}
 4523      * into the coordinate space of its {@link javafx.stage.Screen}.
 4524      * @param localPoint a point in Node&#39;s space
 4525      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4526      * @since JavaFX 8.0
 4527      */
 4528     public Point2D localToScreen(Point2D localPoint) {
 4529         return localToScreen(localPoint.getX(), localPoint.getY());
 4530     }
 4531 
 4532     /**
 4533      * Transforms a point from the local coordinate space of this {@code Node}
 4534      * into the coordinate space of its {@link javafx.stage.Screen}.
 4535      * @param localX x coordinate of a point in Node&#39;s space
 4536      * @param localY y coordinate of a point in Node&#39;s space
 4537      * @param localZ z coordinate of a point in Node&#39;s space
 4538      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4539      * @since JavaFX 8.0
 4540      */
 4541     public Point2D localToScreen(double localX, double localY, double localZ) {
 4542         Scene scene = getScene();
 4543         if (scene == null) return null;
 4544         Window window = scene.getWindow();
 4545         if (window == null) return null;
 4546 
 4547         Point3D pt = localToScene(localX, localY, localZ);
 4548         final SubScene subScene = getSubScene();
 4549         if (subScene != null) {
 4550             pt = SceneUtils.subSceneToScene(subScene, pt);
 4551         }
 4552         final Point2D projection = CameraHelper.project(
 4553                 SceneHelper.getEffectiveCamera(getScene()), pt);
 4554 
 4555         return new Point2D(projection.getX() + scene.getX() + window.getX(),
 4556                            projection.getY() + scene.getY() + window.getY());
 4557     }
 4558 
 4559     /**
 4560      * Transforms a point from the local coordinate space of this {@code Node}
 4561      * into the coordinate space of its {@link javafx.stage.Screen}.
 4562      * @param localPoint a point in Node&#39;s space
 4563      * @return screen coordinates of the point or null if Node is not in a {@link Window}
 4564      * @since JavaFX 8.0
 4565      */
 4566     public Point2D localToScreen(Point3D localPoint) {
 4567         return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4568     }
 4569 
 4570     /**
 4571      * Transforms a bounds from the local coordinate space of this
 4572      * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
 4573      * @param localBounds bounds in Node&#39;s space
 4574      * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
 4575      * @since JavaFX 8.0
 4576      */
 4577     public Bounds localToScreen(Bounds localBounds) {
 4578         final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4579         final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4580         final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4581         final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4582         final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4583         final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4584         final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4585         final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4586 
 4587         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4588     }
 4589 
 4590     /**
 4591      * Transforms a point from the local coordinate space of this {@code Node}
 4592      * into the coordinate space of its scene.
 4593      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4594      * not that of {@link javafx.scene.Scene}.
 4595      * @param localX x coordinate of a point in Node&#39;s space
 4596      * @param localY y coordinate of a point in Node&#39;s space
 4597      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4598      */
 4599     public Point2D localToScene(double localX, double localY) {
 4600         final com.sun.javafx.geom.Point2D tempPt =
 4601                 TempState.getInstance().point;
 4602         tempPt.setLocation((float)localX, (float)localY);
 4603         localToScene(tempPt);
 4604         return new Point2D(tempPt.x, tempPt.y);
 4605     }
 4606 
 4607     /**
 4608      * Transforms a point from the local coordinate space of this {@code Node}
 4609      * into the coordinate space of its scene.
 4610      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4611      * not that of {@link javafx.scene.Scene}.
 4612      * @param localPoint a point in Node&#39;s space
 4613      * @return scene coordinates of the point or null if Node is not in a {@link Window}
 4614      */
 4615     public Point2D localToScene(Point2D localPoint) {
 4616         return localToScene(localPoint.getX(), localPoint.getY());
 4617     }
 4618 
 4619     /**
 4620      * Transforms a point from the local coordinate space of this {@code Node}
 4621      * into the coordinate space of its scene.
 4622      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4623      * not that of {@link javafx.scene.Scene}.
 4624      * @param localPoint a 3D point in Node&#39;s space
 4625      * @return the transformed 3D point in Scene&#39;s space
 4626      * @see #localToScene(javafx.geometry.Point3D, boolean)
 4627      * @since JavaFX 8.0
 4628      */
 4629     public Point3D localToScene(Point3D localPoint) {
 4630         return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4631     }
 4632 
 4633     /**
 4634      * Transforms a point from the local coordinate space of this {@code Node}
 4635      * into the coordinate space of its scene.
 4636      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4637      * not that of {@link javafx.scene.Scene}.
 4638      * @param x the x coordinate of a point in Node&#39;s space
 4639      * @param y the y coordinate of a point in Node&#39;s space
 4640      * @param z the z coordinate of a point in Node&#39;s space
 4641      * @return the transformed 3D point in Scene&#39;s space
 4642      * @see #localToScene(double, double, double, boolean)
 4643      * @since JavaFX 8.0
 4644      */
 4645     public Point3D localToScene(double x, double y, double z) {
 4646         final com.sun.javafx.geom.Vec3d tempV3D =
 4647                 TempState.getInstance().vec3d;
 4648         tempV3D.set(x, y, z);
 4649         localToScene(tempV3D);
 4650         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4651     }
 4652 
 4653     /**
 4654      * Transforms a point from the local coordinate space of this {@code Node}
 4655      * into the coordinate space of its scene.
 4656      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4657      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4658      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4659      * {@link #localToScene(javafx.geometry.Point3D)}.
 4660      *
 4661      * @param localPoint the point in local coordinates
 4662      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4663      * @return transformed point
 4664      *
 4665      * @see #localToScene(javafx.geometry.Point3D)
 4666      * @since JavaFX 8u40
 4667      */
 4668     public Point3D localToScene(Point3D localPoint, boolean rootScene) {
 4669         Point3D pt = localToScene(localPoint);
 4670         if (rootScene) {
 4671             final SubScene subScene = getSubScene();
 4672             if (subScene != null) {
 4673                 pt = SceneUtils.subSceneToScene(subScene, pt);
 4674             }
 4675         }
 4676         return pt;
 4677     }
 4678 
 4679     /**
 4680      * Transforms a point from the local coordinate space of this {@code Node}
 4681      * into the coordinate space of its scene.
 4682      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4683      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4684      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4685      * {@link #localToScene(double, double, double)}.
 4686      *
 4687      * @param x the x coordinate of the point in local coordinates
 4688      * @param y the y coordinate of the point in local coordinates
 4689      * @param z the z coordinate of the point in local coordinates
 4690      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4691      * @return transformed point
 4692      *
 4693      * @see #localToScene(double, double, double)
 4694      * @since JavaFX 8u40
 4695      */
 4696     public Point3D localToScene(double x, double y, double z, boolean rootScene) {
 4697         return localToScene(new Point3D(x, y, z), rootScene);
 4698     }
 4699 
 4700     /**
 4701      * Transforms a point from the local coordinate space of this {@code Node}
 4702      * into the coordinate space of its scene.
 4703      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4704      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4705      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4706      * {@link #localToScene(javafx.geometry.Point2D)}.
 4707      *
 4708      * @param localPoint the point in local coordinates
 4709      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4710      * @return transformed point
 4711      *
 4712      * @see #localToScene(javafx.geometry.Point2D)
 4713      * @since JavaFX 8u40
 4714      */
 4715     public Point2D localToScene(Point2D localPoint, boolean rootScene) {
 4716         if (!rootScene) {
 4717             return localToScene(localPoint);
 4718         }
 4719         Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
 4720         return new Point2D(pt.getX(), pt.getY());
 4721     }
 4722 
 4723     /**
 4724      * Transforms a point from the local coordinate space of this {@code Node}
 4725      * into the coordinate space of its scene.
 4726      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4727      * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4728      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4729      * {@link #localToScene(double, double)}.
 4730      *
 4731      * @param x the x coordinate of the point in local coordinates
 4732      * @param y the y coordinate of the point in local coordinates
 4733      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4734      * @return transformed point
 4735      *
 4736      * @see #localToScene(double, double)
 4737      * @since JavaFX 8u40
 4738      */
 4739     public Point2D localToScene(double x, double y, boolean rootScene) {
 4740         return localToScene(new Point2D(x, y), rootScene);
 4741     }
 4742 
 4743     /**
 4744      * Transforms a bounds from the local coordinate space of this {@code Node}
 4745      * into the coordinate space of its scene.
 4746      * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
 4747      * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
 4748      * Otherwise, the subscene coordinates are used, which is equivalent to calling
 4749      * {@link #localToScene(javafx.geometry.Bounds)}.
 4750      *
 4751      * @param localBounds the bounds in local coordinates
 4752      * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
 4753      * @return transformed bounds
 4754      *
 4755      * @see #localToScene(javafx.geometry.Bounds)
 4756      * @since JavaFX 8u40
 4757      */
 4758     public Bounds localToScene(Bounds localBounds, boolean rootScene) {
 4759         if (!rootScene) {
 4760             return localToScene(localBounds);
 4761         }
 4762         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4763         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4764         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4765         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4766         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
 4767         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
 4768         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
 4769         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
 4770         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4771     }
 4772 
 4773     /**
 4774      * Transforms a bounds from the local coordinate space of this
 4775      * {@code Node} into the coordinate space of its scene.
 4776      * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
 4777      * not that of {@link javafx.scene.Scene}.
 4778      * @param localBounds bounds in Node&#39;s space
 4779      * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
 4780      * @see #localToScene(javafx.geometry.Bounds, boolean)
 4781      */
 4782     public Bounds localToScene(Bounds localBounds) {
 4783         // Do a quick update of localToParentTransform so that we can determine
 4784         // if this tx is 2D transform
 4785         updateLocalToParentTransform();
 4786         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4787             Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
 4788             Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
 4789             Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
 4790             Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());
 4791 
 4792             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4793         }
 4794         Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4795         Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4796         Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4797         Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4798         Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4799         Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4800         Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4801         Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4802         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4803 
 4804     }
 4805 
 4806     /**
 4807      * Transforms a point from the coordinate space of the parent into the
 4808      * local coordinate space of this {@code Node}.
 4809      * @param parentX the x coordinate in Parent&#39;s space
 4810      * @param parentY the y coordinate in Parent&#39;s space
 4811      * @return the transformed 2D point in Node&#39;s space
 4812      */
 4813     public Point2D parentToLocal(double parentX, double parentY) {
 4814         final com.sun.javafx.geom.Point2D tempPt =
 4815                 TempState.getInstance().point;
 4816         tempPt.setLocation((float)parentX, (float)parentY);
 4817         try {
 4818             parentToLocal(tempPt);
 4819         } catch (NoninvertibleTransformException e) {
 4820             return null;
 4821         }
 4822         return new Point2D(tempPt.x, tempPt.y);
 4823     }
 4824 
 4825     /**
 4826      * Transforms a point from the coordinate space of the parent into the
 4827      * local coordinate space of this {@code Node}.
 4828      * @param parentPoint the 2D point in Parent&#39;s space
 4829      * @return the transformed 2D point in Node&#39;s space
 4830      */
 4831     public Point2D parentToLocal(Point2D parentPoint) {
 4832         return parentToLocal(parentPoint.getX(), parentPoint.getY());
 4833     }
 4834 
 4835     /**
 4836      * Transforms a point from the coordinate space of the parent into the
 4837      * local coordinate space of this {@code Node}.
 4838      * @param parentPoint parentPoint the 3D point in Parent&#39;s space
 4839      * @return the transformed 3D point in Node&#39;s space
 4840      * @since JavaFX 8.0
 4841      */
 4842     public Point3D parentToLocal(Point3D parentPoint) {
 4843         return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
 4844     }
 4845 
 4846     /**
 4847      * Transforms a point from the coordinate space of the parent into the
 4848      * local coordinate space of this {@code Node}.
 4849      * @param parentX the x coordinate in Parent&#39;s space
 4850      * @param parentY the y coordinate in Parent&#39;s space
 4851      * @param parentZ the z coordinate in Parent&#39;s space
 4852      * @return the transformed 3D point in Node&#39;s space
 4853      * @since JavaFX 8.0
 4854      */
 4855     public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
 4856         final com.sun.javafx.geom.Vec3d tempV3D =
 4857                 TempState.getInstance().vec3d;
 4858         tempV3D.set(parentX, parentY, parentZ);
 4859         try {
 4860             parentToLocal(tempV3D);
 4861         } catch (NoninvertibleTransformException e) {
 4862             return null;
 4863         }
 4864         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4865     }
 4866 
 4867     /**
 4868      * Transforms a rectangle from the coordinate space of the parent into the
 4869      * local coordinate space of this {@code Node}.
 4870      * @param parentBounds the bounds in Parent&#39;s space
 4871      * @return the transformed bounds in Node&#39;s space
 4872      */
 4873     public Bounds parentToLocal(Bounds parentBounds) {
 4874         // Do a quick update of localToParentTransform so that we can determine
 4875         // if this tx is 2D transform
 4876         updateLocalToParentTransform();
 4877         if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
 4878             Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
 4879             Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
 4880             Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
 4881             Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());
 4882 
 4883             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4884         }
 4885         Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4886         Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4887         Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4888         Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4889         Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
 4890         Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
 4891         Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
 4892         Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
 4893         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4894     }
 4895 
 4896     /**
 4897      * Transforms a point from the local coordinate space of this {@code Node}
 4898      * into the coordinate space of its parent.
 4899      * @param localX the x coordinate of the point in Node&#39;s space
 4900      * @param localY the y coordinate of the point in Node&#39;s space
 4901      * @return the transformed 2D point in Parent&#39;s space
 4902      */
 4903     public Point2D localToParent(double localX, double localY) {
 4904         final com.sun.javafx.geom.Point2D tempPt =
 4905                 TempState.getInstance().point;
 4906         tempPt.setLocation((float)localX, (float)localY);
 4907         localToParent(tempPt);
 4908         return new Point2D(tempPt.x, tempPt.y);
 4909     }
 4910 
 4911     /**
 4912      * Transforms a point from the local coordinate space of this {@code Node}
 4913      * into the coordinate space of its parent.
 4914      * @param localPoint the 2D point in Node&#39;s space
 4915      * @return the transformed 2D point in Parent&#39;s space
 4916      */
 4917     public Point2D localToParent(Point2D localPoint) {
 4918         return localToParent(localPoint.getX(), localPoint.getY());
 4919     }
 4920 
 4921     /**
 4922      * Transforms a point from the local coordinate space of this {@code Node}
 4923      * into the coordinate space of its parent.
 4924      * @param localPoint the 3D point in Node&#39;s space
 4925      * @return the transformed 3D point in Parent&#39;s space
 4926      * @since JavaFX 8.0
 4927      */
 4928     public Point3D localToParent(Point3D localPoint) {
 4929         return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
 4930     }
 4931 
 4932     /**
 4933      * Transforms a point from the local coordinate space of this {@code Node}
 4934      * into the coordinate space of its parent.
 4935      * @param x the x coordinate of the point in Node&#39;s space
 4936      * @param y the y coordinate of the point in Node&#39;s space
 4937      * @param z the z coordinate of the point in Node&#39;s space
 4938      * @return the transformed 3D point in Parent&#39;s space
 4939      * @since JavaFX 8.0
 4940      */
 4941     public Point3D localToParent(double x, double y, double z) {
 4942         final com.sun.javafx.geom.Vec3d tempV3D =
 4943                 TempState.getInstance().vec3d;
 4944         tempV3D.set(x, y, z);
 4945         localToParent(tempV3D);
 4946         return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
 4947     }
 4948 
 4949     /**
 4950      * Transforms a bounds from the local coordinate space of this
 4951      * {@code Node} into the coordinate space of its parent.
 4952      * @param localBounds the bounds in Node&#39;s space
 4953      * @return the transformed bounds in Parent&#39;s space
 4954      */
 4955     public Bounds localToParent(Bounds localBounds) {
 4956         // Do a quick update of localToParentTransform so that we can determine
 4957         // if this tx is 2D transform
 4958         updateLocalToParentTransform();
 4959         if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
 4960             Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
 4961             Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
 4962             Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
 4963             Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());
 4964 
 4965             return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
 4966         }
 4967         Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
 4968         Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
 4969         Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
 4970         Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4971         Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
 4972         Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
 4973         Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
 4974         Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
 4975         return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
 4976     }
 4977 
 4978     /**
 4979      * Copy the localToParent transform into specified transform.
 4980      */
 4981     BaseTransform getLocalToParentTransform(BaseTransform tx) {
 4982         updateLocalToParentTransform();
 4983         tx.setTransform(localToParentTx);
 4984         return tx;
 4985     }
 4986 
 4987     /*
 4988      * Currently used only by PathTransition
 4989      */
 4990     final BaseTransform getLeafTransform() {
 4991         return getLocalToParentTransform(TempState.getInstance().leafTx);
 4992     }
 4993 
 4994     /*
 4995      * Invoked whenever the transforms[] ObservableList changes, or by the transforms
 4996      * in that ObservableList whenever they are changed.
 4997      *
 4998      * Note: This method MUST only be called via its accessor method.
 4999      */
 5000     private void doTransformsChanged() {
 5001         if (!transformDirty) {
 5002             NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
 5003             transformDirty = true;
 5004             transformedBoundsChanged();
 5005         }
 5006         invalidateLocalToParentTransform();
 5007         invalidateLocalToSceneTransform();
 5008     }
 5009 
 5010     final double getPivotX() {
 5011         final Bounds bounds = getLayoutBounds();
 5012         return bounds.getMinX() + bounds.getWidth()/2;
 5013     }
 5014 
 5015     final double getPivotY() {
 5016         final Bounds bounds = getLayoutBounds();
 5017         return bounds.getMinY() + bounds.getHeight()/2;
 5018     }
 5019 
 5020     final double getPivotZ() {
 5021         final Bounds bounds = getLayoutBounds();
 5022         return bounds.getMinZ() + bounds.getDepth()/2;
 5023     }
 5024 
 5025     /**
 5026      * This helper function will update the transform matrix on the peer based
 5027      * on the &quot;complete&quot; transform for this node.
 5028      */
 5029     void updateLocalToParentTransform() {
 5030         if (transformDirty) {
 5031             localToParentTx.setToIdentity();
 5032 
 5033             boolean mirror = false;
 5034             double mirroringCenter = 0;
 5035             if (hasMirroring()) {
 5036                 final Scene sceneValue = getScene();
 5037                 if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
 5038                     // handle scene mirroring in this branch
 5039                     // (must be the last transformation)
 5040                     mirroringCenter = sceneValue.getWidth() / 2;
 5041                     if (mirroringCenter == 0.0) {
 5042                         mirroringCenter = getPivotX();
 5043                     }
 5044 
 5045                     localToParentTx = localToParentTx.deriveWithTranslation(
 5046                             mirroringCenter, 0.0);
 5047                     localToParentTx = localToParentTx.deriveWithScale(
 5048                             -1.0, 1.0, 1.0);
 5049                     localToParentTx = localToParentTx.deriveWithTranslation(
 5050                             -mirroringCenter, 0.0);
 5051                 } else {
 5052                     // mirror later
 5053                     mirror = true;
 5054                     mirroringCenter = getPivotX();
 5055                 }
 5056             }
 5057 
 5058             if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
 5059                 // recompute pivotX, pivotY and pivotZ
 5060                 double pivotX = getPivotX();
 5061                 double pivotY = getPivotY();
 5062                 double pivotZ = getPivotZ();
 5063 
 5064                 localToParentTx = localToParentTx.deriveWithTranslation(
 5065                         getTranslateX() + getLayoutX() + pivotX,
 5066                         getTranslateY() + getLayoutY() + pivotY,
 5067                         getTranslateZ() + pivotZ);
 5068                 localToParentTx = localToParentTx.deriveWithRotation(
 5069                         Math.toRadians(getRotate()), getRotationAxis().getX(),
 5070                         getRotationAxis().getY(), getRotationAxis().getZ());
 5071                 localToParentTx = localToParentTx.deriveWithScale(
 5072                         getScaleX(), getScaleY(), getScaleZ());
 5073                 localToParentTx = localToParentTx.deriveWithTranslation(
 5074                         -pivotX, -pivotY, -pivotZ);
 5075             } else {
 5076                 localToParentTx = localToParentTx.deriveWithTranslation(
 5077                         getTranslateX() + getLayoutX(),
 5078                         getTranslateY() + getLayoutY(),
 5079                         getTranslateZ());
 5080             }
 5081 
 5082             if (hasTransforms()) {
 5083                 for (Transform t : getTransforms()) {
 5084                     localToParentTx = TransformHelper.derive(t, localToParentTx);
 5085                 }
 5086             }
 5087 
 5088             // Check to see whether the node requires mirroring
 5089             if (mirror) {
 5090                 localToParentTx = localToParentTx.deriveWithTranslation(
 5091                         mirroringCenter, 0);
 5092                 localToParentTx = localToParentTx.deriveWithScale(
 5093                         -1.0, 1.0, 1.0);
 5094                 localToParentTx = localToParentTx.deriveWithTranslation(
 5095                         -mirroringCenter, 0);
 5096             }
 5097 
 5098             transformDirty = false;
 5099         }
 5100     }
 5101 
 5102     /**
 5103      * Transforms in place the specified point from parent coords to local
 5104      * coords. Made package private for the sake of testing.
 5105      */
 5106     void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5107         updateLocalToParentTransform();
 5108         localToParentTx.inverseTransform(pt, pt);
 5109     }
 5110 
 5111     void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5112         updateLocalToParentTransform();
 5113         localToParentTx.inverseTransform(pt, pt);
 5114     }
 5115 
 5116     void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
 5117         if (getParent() != null) {
 5118             getParent().sceneToLocal(pt);
 5119         }
 5120         parentToLocal(pt);
 5121     }
 5122 
 5123     void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
 5124         if (getParent() != null) {
 5125             getParent().sceneToLocal(pt);
 5126         }
 5127         parentToLocal(pt);
 5128     }
 5129 
 5130     void localToScene(com.sun.javafx.geom.Point2D pt) {
 5131         localToParent(pt);
 5132         if (getParent() != null) {
 5133             getParent().localToScene(pt);
 5134         }
 5135     }
 5136 
 5137     void localToScene(com.sun.javafx.geom.Vec3d pt) {
 5138         localToParent(pt);
 5139         if (getParent() != null) {
 5140             getParent().localToScene(pt);
 5141         }
 5142     }
 5143 
 5144     /***************************************************************************
 5145      *                                                                         *
 5146      * Mouse event related APIs                                                *
 5147      *                                                                         *
 5148      **************************************************************************/
 5149 
 5150     /**
 5151      * Transforms in place the specified point from local coords to parent
 5152      * coords. Made package private for the sake of testing.
 5153      */
 5154     void localToParent(com.sun.javafx.geom.Point2D pt) {
 5155         updateLocalToParentTransform();
 5156         localToParentTx.transform(pt, pt);
 5157     }
 5158 
 5159     void localToParent(com.sun.javafx.geom.Vec3d pt) {
 5160         updateLocalToParentTransform();
 5161         localToParentTx.transform(pt, pt);
 5162     }
 5163 
 5164     /*
 5165      * Finds a top-most child node that contains the given local coordinates.
 5166      *
 5167      * The result argument is used for storing the picking result.
 5168      *
 5169      * Note: This method MUST only be called via its accessor method.
 5170      */
 5171     private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
 5172         intersects(localPickRay, result);
 5173     }
 5174 
 5175     /*
 5176      * Finds a top-most child node that intersects the given ray.
 5177      *
 5178      * The result argument is used for storing the picking result.
 5179      */
 5180     final void pickNode(PickRay pickRay, PickResultChooser result) {
 5181 
 5182         // In some conditions we can omit picking this node or subgraph
 5183         if (!isVisible() || isDisable() || isMouseTransparent()) {
 5184             return;
 5185         }
 5186 
 5187         final Vec3d o = pickRay.getOriginNoClone();
 5188         final double ox = o.x;
 5189         final double oy = o.y;
 5190         final double oz = o.z;
 5191         final Vec3d d = pickRay.getDirectionNoClone();
 5192         final double dx = d.x;
 5193         final double dy = d.y;
 5194         final double dz = d.z;
 5195 
 5196         updateLocalToParentTransform();
 5197         try {
 5198             localToParentTx.inverseTransform(o, o);
 5199             localToParentTx.inverseDeltaTransform(d, d);
 5200 
 5201             // Delegate to a function which can be overridden by subclasses which
 5202             // actually does the pick. The implementation is markedly different
 5203             // for leaf nodes vs. parent nodes vs. region nodes.
 5204             NodeHelper.pickNodeLocal(this, pickRay, result);
 5205         } catch (NoninvertibleTransformException e) {
 5206             // in this case we just don&#39;t pick anything
 5207         }
 5208 
 5209         pickRay.setOrigin(ox, oy, oz);
 5210         pickRay.setDirection(dx, dy, dz);
 5211     }
 5212 
 5213     /*
 5214      * Returns {@code true} if the given ray (start, dir), specified in the
 5215      * local coordinate space of this {@code Node}, intersects the
 5216      * shape of this {@code Node}. Note that this method does not take visibility
 5217      * into account; the test is based on the geometry of this {@code Node} only.
 5218      * &lt;p&gt;
 5219      * The pickResult is updated if the found intersection is closer than
 5220      * the currently held one.
 5221      * &lt;p&gt;
 5222      * Note that this is a conditional feature. See
 5223      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5224      * for more information.
 5225      */
 5226     final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
 5227         double boundsDistance = intersectsBounds(pickRay);
 5228         if (!Double.isNaN(boundsDistance)) {
 5229             if (isPickOnBounds()) {
 5230                 if (pickResult != null) {
 5231                     pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
 5232                 }
 5233                 return true;
 5234             } else {
 5235                 return NodeHelper.computeIntersects(this, pickRay, pickResult);
 5236             }
 5237         }
 5238         return false;
 5239     }
 5240 
 5241     /*
 5242      * Computes the intersection of the pickRay with this node.
 5243      * The pickResult argument is updated if the found intersection
 5244      * is closer than the passed one. On the other hand, the return value
 5245      * specifies whether the intersection exists, regardless of its comparison
 5246      * with the given pickResult.
 5247      */
 5248     private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
 5249         double origZ = pickRay.getOriginNoClone().z;
 5250         double dirZ = pickRay.getDirectionNoClone().z;
 5251         // Handle the case where pickRay is almost parallel to the Z-plane
 5252         if (almostZero(dirZ)) {
 5253             return false;
 5254         }
 5255         double t = -origZ / dirZ;
 5256         if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
 5257             return false;
 5258         }
 5259         double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
 5260         double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);
 5261 
 5262         if (contains((float) x, (float) y)) {
 5263             if (pickResult != null) {
 5264                 pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
 5265             }
 5266             return true;
 5267         }
 5268         return false;
 5269     }
 5270 
 5271     /*
 5272      * Computes the intersection of the pickRay with the bounds of this node.
 5273      * The return value is the distance between the camera and the intersection
 5274      * point, measured in pickRay direction magnitudes. If there is
 5275      * no intersection, it returns NaN.
 5276      *
 5277      * @param pickRay The pick ray
 5278      * @return Distance of the intersection point, a NaN if there
 5279      *         is no intersection
 5280      */
 5281     final double intersectsBounds(PickRay pickRay) {
 5282 
 5283         final Vec3d dir = pickRay.getDirectionNoClone();
 5284         double tmin, tmax;
 5285 
 5286         final Vec3d origin = pickRay.getOriginNoClone();
 5287         final double originX = origin.x;
 5288         final double originY = origin.y;
 5289         final double originZ = origin.z;
 5290 
 5291         final TempState tempState = TempState.getInstance();
 5292         BaseBounds tempBounds = tempState.bounds;
 5293 
 5294         tempBounds = getLocalBounds(tempBounds,
 5295                                     BaseTransform.IDENTITY_TRANSFORM);
 5296 
 5297         if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
 5298             // fast path for the usual 2D picking
 5299 
 5300             if (dir.z == 0.0) {
 5301                 return Double.NaN;
 5302             }
 5303 
 5304             if (originX &lt; tempBounds.getMinX() ||
 5305                     originX &gt; tempBounds.getMaxX() ||
 5306                     originY &lt; tempBounds.getMinY() ||
 5307                     originY &gt; tempBounds.getMaxY()) {
 5308                 return Double.NaN;
 5309             }
 5310 
 5311             final double invDirZ = 1.0 / dir.z;
 5312             final boolean signZ = invDirZ &lt; 0.0;
 5313 
 5314             final double minZ = tempBounds.getMinZ();
 5315             final double maxZ = tempBounds.getMaxZ();
 5316             tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5317             tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5318 
 5319         } else if (tempBounds.getDepth() == 0.0) {
 5320             // fast path for 3D picking of 2D bounds
 5321 
 5322             if (almostZero(dir.z)) {
 5323                 return Double.NaN;
 5324             }
 5325 
 5326             final double t = (tempBounds.getMinZ() - originZ) / dir.z;
 5327             final double x = originX + (dir.x * t);
 5328             final double y = originY + (dir.y * t);
 5329 
 5330             if (x &lt; tempBounds.getMinX() ||
 5331                     x &gt; tempBounds.getMaxX() ||
 5332                     y &lt; tempBounds.getMinY() ||
 5333                     y &gt; tempBounds.getMaxY()) {
 5334                 return Double.NaN;
 5335             }
 5336 
 5337             tmin = tmax = t;
 5338 
 5339         } else {
 5340 
 5341             final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
 5342             final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
 5343             final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
 5344             final boolean signX = invDirX &lt; 0.0;
 5345             final boolean signY = invDirY &lt; 0.0;
 5346             final boolean signZ = invDirZ &lt; 0.0;
 5347             final double minX = tempBounds.getMinX();
 5348             final double minY = tempBounds.getMinY();
 5349             final double maxX = tempBounds.getMaxX();
 5350             final double maxY = tempBounds.getMaxY();
 5351 
 5352             tmin = Double.NEGATIVE_INFINITY;
 5353             tmax = Double.POSITIVE_INFINITY;
 5354             if (Double.isInfinite(invDirX)) {
 5355                 if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
 5356                     // move on, we are inside for the whole length
 5357                 } else {
 5358                     return Double.NaN;
 5359                 }
 5360             } else {
 5361                 tmin = ((signX ? maxX : minX) - originX) * invDirX;
 5362                 tmax = ((signX ? minX : maxX) - originX) * invDirX;
 5363             }
 5364 
 5365             if (Double.isInfinite(invDirY)) {
 5366                 if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
 5367                     // move on, we are inside for the whole length
 5368                 } else {
 5369                     return Double.NaN;
 5370                 }
 5371             } else {
 5372                 final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
 5373                 final double tymax = ((signY ? minY : maxY) - originY) * invDirY;
 5374 
 5375                 if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
 5376                     return Double.NaN;
 5377                 }
 5378                 if (tymin &gt; tmin) {
 5379                     tmin = tymin;
 5380                 }
 5381                 if (tymax &lt; tmax) {
 5382                     tmax = tymax;
 5383                 }
 5384             }
 5385 
 5386             final double minZ = tempBounds.getMinZ();
 5387             final double maxZ = tempBounds.getMaxZ();
 5388             if (Double.isInfinite(invDirZ)) {
 5389                 if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
 5390                     // move on, we are inside for the whole length
 5391                 } else {
 5392                     return Double.NaN;
 5393                 }
 5394             } else {
 5395                 final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
 5396                 final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;
 5397 
 5398                 if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
 5399                     return Double.NaN;
 5400                 }
 5401                 if (tzmin &gt; tmin) {
 5402                     tmin = tzmin;
 5403                 }
 5404                 if (tzmax &lt; tmax) {
 5405                     tmax = tzmax;
 5406                 }
 5407             }
 5408         }
 5409 
 5410         // For clip we use following semantics: pick the node normally
 5411         // if there is an intersection with the clip node. We don&#39;t consider
 5412         // clip node distance.
 5413         Node clip = getClip();
 5414         if (clip != null
 5415                 // FIXME: All 3D picking is currently ignored by rendering.
 5416                 // Until this is fixed or defined differently (RT-28510),
 5417                 // we follow this behavior.
 5418                 &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
 5419             final double dirX = dir.x;
 5420             final double dirY = dir.y;
 5421             final double dirZ = dir.z;
 5422 
 5423             clip.updateLocalToParentTransform();
 5424 
 5425             boolean hitClip = true;
 5426             try {
 5427                 clip.localToParentTx.inverseTransform(origin, origin);
 5428                 clip.localToParentTx.inverseDeltaTransform(dir, dir);
 5429             } catch (NoninvertibleTransformException e) {
 5430                 hitClip = false;
 5431             }
 5432             hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
 5433             pickRay.setOrigin(originX, originY, originZ);
 5434             pickRay.setDirection(dirX, dirY, dirZ);
 5435 
 5436             if (!hitClip) {
 5437                 return Double.NaN;
 5438             }
 5439         }
 5440 
 5441         if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
 5442             // We&#39;ve got a nonsense pick ray or bounds.
 5443             return Double.NaN;
 5444         }
 5445 
 5446         final double minDistance = pickRay.getNearClip();
 5447         final double maxDistance = pickRay.getFarClip();
 5448         if (tmin &lt; minDistance) {
 5449             if (tmax &gt;= minDistance) {
 5450                 // we are inside bounds
 5451                 return 0.0;
 5452             } else {
 5453                 return Double.NaN;
 5454             }
 5455         } else if (tmin &gt; maxDistance) {
 5456             return Double.NaN;
 5457         }
 5458 
 5459         return tmin;
 5460     }
 5461 
 5462 
 5463     // Good to find a home for commonly use util. code such as EPS.
 5464     // and almostZero. This code currently defined in multiple places,
 5465     // such as Affine3D and GeneralTransform3D.
 5466     private static final double EPSILON_ABSOLUTE = 1.0e-5;
 5467 
 5468     static boolean almostZero(double a) {
 5469         return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
 5470     }
 5471 
 5472     /***************************************************************************
 5473      *                                                                         *
 5474      *                      viewOrder property handling                        *
 5475      *                                                                         *
 5476      **************************************************************************/
 5477 
 5478     /**
 5479      * Defines the rendering and picking order of this {@code Node} within its
 5480      * parent.
 5481      * &lt;p&gt;
 5482      * This property is used to alter the rendering and picking order of a node
 5483      * within its parent without reordering the parent&#39;s {@code children} list.
 5484      * For example, this can be used as a more efficient way to implement
 5485      * transparency sorting. To do this, an application can assign the viewOrder
 5486      * value of each node to the computed distance between that node and the
 5487      * viewer.
 5488      * &lt;/p&gt;
 5489      * &lt;p&gt;
 5490      * The parent will traverse its {@code children} in decreasing
 5491      * {@code viewOrder} order. This means that a child with a lower
 5492      * {@code viewOrder} will be in front of a child with a higher
 5493      * {@code viewOrder}. If two children have the same {@code viewOrder}, the
 5494      * parent will traverse them in the order they appear in the parent&#39;s
 5495      * {@code children} list.
 5496      * &lt;/p&gt;
 5497      * &lt;p&gt;
 5498      * However, {@code viewOrder} does not alter the layout and focus traversal
 5499      * order of this Node within its parent. A parent always traverses its
 5500      * {@code children} list in order when doing layout or focus traversal.
 5501      * &lt;/p&gt;
 5502      *
 5503      * @return the view order for this {@code Node}
 5504      * @defaultValue 0.0
 5505      *
 5506      * @since 9
 5507      */
 5508     public final DoubleProperty viewOrderProperty() {
 5509         return getMiscProperties().viewOrderProperty();
 5510     }
 5511 
 5512     public final void setViewOrder(double value) {
 5513         viewOrderProperty().set(value);
 5514     }
 5515 
 5516     public final double getViewOrder() {
 5517         return (miscProperties == null) ? DEFAULT_VIEW_ORDER
 5518                 : miscProperties.getViewOrder();
 5519     }
 5520 
 5521     /***************************************************************************
 5522      *                                                                         *
 5523      *                             Transformations                             *
 5524      *                                                                         *
 5525      **************************************************************************/
 5526     /**
 5527      * Defines the ObservableList of {@link javafx.scene.transform.Transform} objects
 5528      * to be applied to this {@code Node}. This ObservableList of transforms is applied
 5529      * before {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #scaleXProperty scaleX}, and
 5530      * {@link #scaleYProperty scaleY}, {@link #rotateProperty rotate} transforms.
 5531      *
 5532      * @return the transforms for this {@code Node}
 5533      * @defaultValue empty
 5534      */
 5535     public final ObservableList&lt;Transform&gt; getTransforms() {
 5536         return transformsProperty();
 5537     }
 5538 
 5539     private ObservableList&lt;Transform&gt; transformsProperty() {
 5540         return getNodeTransformation().getTransforms();
 5541     }
 5542 
 5543     public final void setTranslateX(double value) {
 5544         translateXProperty().set(value);
 5545     }
 5546 
 5547     public final double getTranslateX() {
 5548         return (nodeTransformation == null)
 5549                 ? DEFAULT_TRANSLATE_X
 5550                 : nodeTransformation.getTranslateX();
 5551     }
 5552 
 5553     /**
 5554      * Defines the x coordinate of the translation that is added to this {@code Node}&#39;s
 5555      * transform.
 5556      * &lt;p&gt;
 5557      * The node&#39;s final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
 5558      * where {@code layoutX} establishes the node&#39;s stable position and {@code translateX}
 5559      * optionally makes dynamic adjustments to that position.
 5560      *&lt;p&gt;
 5561      * This variable can be used to alter the location of a node without disturbing
 5562      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5563      *
 5564      * @return the translateX for this {@code Node}
 5565      * @defaultValue 0
 5566      */
 5567     public final DoubleProperty translateXProperty() {
 5568         return getNodeTransformation().translateXProperty();
 5569     }
 5570 
 5571     public final void setTranslateY(double value) {
 5572         translateYProperty().set(value);
 5573     }
 5574 
 5575     public final double getTranslateY() {
 5576         return (nodeTransformation == null)
 5577                 ? DEFAULT_TRANSLATE_Y
 5578                 : nodeTransformation.getTranslateY();
 5579     }
 5580 
 5581     /**
 5582      * Defines the y coordinate of the translation that is added to this {@code Node}&#39;s
 5583      * transform.
 5584      * &lt;p&gt;
 5585      * The node&#39;s final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
 5586      * where {@code layoutY} establishes the node&#39;s stable position and {@code translateY}
 5587      * optionally makes dynamic adjustments to that position.
 5588      * &lt;p&gt;
 5589      * This variable can be used to alter the location of a node without disturbing
 5590      * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node&#39;s location.
 5591      *
 5592      * @return the translateY for this {@code Node}
 5593      * @defaultValue 0
 5594      */
 5595     public final DoubleProperty translateYProperty() {
 5596         return getNodeTransformation().translateYProperty();
 5597     }
 5598 
 5599     public final void setTranslateZ(double value) {
 5600         translateZProperty().set(value);
 5601     }
 5602 
 5603     public final double getTranslateZ() {
 5604         return (nodeTransformation == null)
 5605                 ? DEFAULT_TRANSLATE_Z
 5606                 : nodeTransformation.getTranslateZ();
 5607     }
 5608 
 5609     /**
 5610      * Defines the Z coordinate of the translation that is added to the
 5611      * transformed coordinates of this {@code Node}.  This value will be added
 5612      * to any translation defined by the {@code transforms} ObservableList and
 5613      * {@code layoutZ}.
 5614      * &lt;p&gt;
 5615      * This variable can be used to alter the location of a Node without
 5616      * disturbing its layout bounds, which makes it useful for animating a
 5617      * node&#39;s location.
 5618      * &lt;p&gt;
 5619      * Note that this is a conditional feature. See
 5620      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5621      * for more information.
 5622      *
 5623      * @return the translateZ for this {@code Node}
 5624      * @defaultValue 0
 5625      */
 5626     public final DoubleProperty translateZProperty() {
 5627         return getNodeTransformation().translateZProperty();
 5628     }
 5629 
 5630     public final void setScaleX(double value) {
 5631         scaleXProperty().set(value);
 5632     }
 5633 
 5634     public final double getScaleX() {
 5635         return (nodeTransformation == null) ? DEFAULT_SCALE_X
 5636                                             : nodeTransformation.getScaleX();
 5637     }
 5638 
 5639     /**
 5640      * Defines the factor by which coordinates are scaled about the center of the
 5641      * object along the X axis of this {@code Node}. This is used to stretch or
 5642      * shrink the node either manually or by using an animation.
 5643      * &lt;p&gt;
 5644      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5645      * default, which makes it ideal for scaling the entire node after
 5646      * all effects and transforms have been taken into account.
 5647      * &lt;p&gt;
 5648      * The pivot point about which the scale occurs is the center of the
 5649      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5650      *
 5651      * @return the scaleX for this {@code Node}
 5652      * @defaultValue 1.0
 5653      */
 5654     public final DoubleProperty scaleXProperty() {
 5655         return getNodeTransformation().scaleXProperty();
 5656     }
 5657 
 5658     public final void setScaleY(double value) {
 5659         scaleYProperty().set(value);
 5660     }
 5661 
 5662     public final double getScaleY() {
 5663         return (nodeTransformation == null) ? DEFAULT_SCALE_Y
 5664                                             : nodeTransformation.getScaleY();
 5665     }
 5666 
 5667     /**
 5668      * Defines the factor by which coordinates are scaled about the center of the
 5669      * object along the Y axis of this {@code Node}. This is used to stretch or
 5670      * shrink the node either manually or by using an animation.
 5671      * &lt;p&gt;
 5672      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5673      * default, which makes it ideal for scaling the entire node after
 5674      * all effects and transforms have been taken into account.
 5675      * &lt;p&gt;
 5676      * The pivot point about which the scale occurs is the center of the
 5677      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5678      *
 5679      * @return the scaleY for this {@code Node}
 5680      * @defaultValue 1.0
 5681      */
 5682     public final DoubleProperty scaleYProperty() {
 5683         return getNodeTransformation().scaleYProperty();
 5684     }
 5685 
 5686     public final void setScaleZ(double value) {
 5687         scaleZProperty().set(value);
 5688     }
 5689 
 5690     public final double getScaleZ() {
 5691         return (nodeTransformation == null) ? DEFAULT_SCALE_Z
 5692                                             : nodeTransformation.getScaleZ();
 5693     }
 5694 
 5695     /**
 5696      * Defines the factor by which coordinates are scaled about the center of the
 5697      * object along the Z axis of this {@code Node}. This is used to stretch or
 5698      * shrink the node either manually or by using an animation.
 5699      * &lt;p&gt;
 5700      * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5701      * default, which makes it ideal for scaling the entire node after
 5702      * all effects and transforms have been taken into account.
 5703      * &lt;p&gt;
 5704      * The pivot point about which the scale occurs is the center of the
 5705      * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
 5706      * all the transforms in the {@link #getTransforms transforms} ObservableList.
 5707      * &lt;p&gt;
 5708      * Note that this is a conditional feature. See
 5709      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5710      * for more information.
 5711      *
 5712      * @return the scaleZ for this {@code Node}
 5713      * @defaultValue 1.0
 5714      */
 5715     public final DoubleProperty scaleZProperty() {
 5716         return getNodeTransformation().scaleZProperty();
 5717     }
 5718 
 5719     public final void setRotate(double value) {
 5720         rotateProperty().set(value);
 5721     }
 5722 
 5723     public final double getRotate() {
 5724         return (nodeTransformation == null) ? DEFAULT_ROTATE
 5725                                             : nodeTransformation.getRotate();
 5726     }
 5727 
 5728     /**
 5729      * Defines the angle of rotation about the {@code Node}&#39;s center, measured in
 5730      * degrees. This is used to rotate the {@code Node}.
 5731      * &lt;p&gt;
 5732      * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
 5733      * default, which makes it ideal for rotating the entire node after
 5734      * all effects and transforms have been taken into account.
 5735      * &lt;p&gt;
 5736      * The pivot point about which the rotation occurs is the center of the
 5737      * untransformed {@link #layoutBoundsProperty layoutBounds}.
 5738      * &lt;p&gt;
 5739      * Note that because the pivot point is computed as the center of this
 5740      * {@code Node}&#39;s layout bounds, any change to the layout bounds will cause
 5741      * the pivot point to change, which can move the object. For a leaf node,
 5742      * any change to the geometry will cause the layout bounds to change.
 5743      * For a group node, any change to any of its children, including a
 5744      * change in a child&#39;s geometry, clip, effect, position, orientation, or
 5745      * scale, will cause the group&#39;s layout bounds to change. If this movement
 5746      * of the pivot point is not
 5747      * desired, applications should instead use the Node&#39;s {@link #getTransforms transforms}
 5748      * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
 5749      * which has a user-specifiable pivot point.
 5750      *
 5751      * @return the rotate for this {@code Node}
 5752      * @defaultValue 0.0
 5753      */
 5754     public final DoubleProperty rotateProperty() {
 5755         return getNodeTransformation().rotateProperty();
 5756     }
 5757 
 5758     public final void setRotationAxis(Point3D value) {
 5759         rotationAxisProperty().set(value);
 5760     }
 5761 
 5762     public final Point3D getRotationAxis() {
 5763         return (nodeTransformation == null)
 5764                 ? DEFAULT_ROTATION_AXIS
 5765                 : nodeTransformation.getRotationAxis();
 5766     }
 5767 
 5768     /**
 5769      * Defines the axis of rotation of this {@code Node}.
 5770      * &lt;p&gt;
 5771      * Note that this is a conditional feature. See
 5772      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 5773      * for more information.
 5774      *
 5775      * @return the rotationAxis for this {@code Node}
 5776      * @defaultValue Rotate.Z_AXIS
 5777      */
 5778     public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 5779         return getNodeTransformation().rotationAxisProperty();
 5780     }
 5781 
 5782     /**
 5783      * An affine transform that holds the computed local-to-parent transform.
 5784      * This is the concatenation of all transforms in this node, including all
 5785      * of the convenience transforms.
 5786      * @return the localToParent transform for this {@code Node}
 5787      * @since JavaFX 2.2
 5788      */
 5789     public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5790         return getNodeTransformation().localToParentTransformProperty();
 5791     }
 5792 
 5793     private void invalidateLocalToParentTransform() {
 5794         if (nodeTransformation != null) {
 5795             nodeTransformation.invalidateLocalToParentTransform();
 5796         }
 5797     }
 5798 
 5799     public final Transform getLocalToParentTransform() {
 5800         return localToParentTransformProperty().get();
 5801     }
 5802 
 5803     /**
 5804      * An affine transform that holds the computed local-to-scene transform.
 5805      * This is the concatenation of all transforms in this node&#39;s parents and
 5806      * in this node, including all of the convenience transforms up to the root.
 5807      * If this node is in a {@link javafx.scene.SubScene}, this property represents
 5808      * transforms up to the subscene, not the root scene.
 5809      *
 5810      * &lt;p&gt;
 5811      * Note that when you register a listener or a binding to this property,
 5812      * it needs to listen for invalidation on all its parents to the root node.
 5813      * This means that registering a listener on this
 5814      * property on many nodes may negatively affect performance of
 5815      * transformation changes in their common parents.
 5816      * &lt;/p&gt;
 5817      *
 5818      * @return the localToScene transform for this {@code Node}
 5819      * @since JavaFX 2.2
 5820      */
 5821     public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 5822         return getNodeTransformation().localToSceneTransformProperty();
 5823     }
 5824 
 5825     private void invalidateLocalToSceneTransform() {
 5826         if (nodeTransformation != null) {
 5827             nodeTransformation.invalidateLocalToSceneTransform();
 5828         }
 5829     }
 5830 
 5831     public final Transform getLocalToSceneTransform() {
 5832         return localToSceneTransformProperty().get();
 5833     }
 5834 
 5835     private NodeTransformation nodeTransformation;
 5836 
 5837     private NodeTransformation getNodeTransformation() {
 5838         if (nodeTransformation == null) {
 5839             nodeTransformation = new NodeTransformation();
 5840         }
 5841 
 5842         return nodeTransformation;
 5843     }
 5844 
 5845     private boolean hasTransforms() {
 5846         return (nodeTransformation != null)
 5847                 &amp;&amp; nodeTransformation.hasTransforms();
 5848     }
 5849 
 5850     // for tests only
 5851     Transform getCurrentLocalToSceneTransformState() {
 5852         if (nodeTransformation == null ||
 5853                 nodeTransformation.localToSceneTransform == null) {
 5854             return null;
 5855         }
 5856 
 5857         return nodeTransformation.localToSceneTransform.transform;
 5858     }
 5859 
 5860     private static final double DEFAULT_TRANSLATE_X = 0;
 5861     private static final double DEFAULT_TRANSLATE_Y = 0;
 5862     private static final double DEFAULT_TRANSLATE_Z = 0;
 5863     private static final double DEFAULT_SCALE_X = 1;
 5864     private static final double DEFAULT_SCALE_Y = 1;
 5865     private static final double DEFAULT_SCALE_Z = 1;
 5866     private static final double DEFAULT_ROTATE = 0;
 5867     private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;
 5868 
 5869     private final class NodeTransformation {
 5870         private DoubleProperty translateX;
 5871         private DoubleProperty translateY;
 5872         private DoubleProperty translateZ;
 5873         private DoubleProperty scaleX;
 5874         private DoubleProperty scaleY;
 5875         private DoubleProperty scaleZ;
 5876         private DoubleProperty rotate;
 5877         private ObjectProperty&lt;Point3D&gt; rotationAxis;
 5878         private ObservableList&lt;Transform&gt; transforms;
 5879         private LazyTransformProperty localToParentTransform;
 5880         private LazyTransformProperty localToSceneTransform;
 5881         private int listenerReasons = 0;
 5882         private InvalidationListener localToSceneInvLstnr;
 5883 
 5884         private InvalidationListener getLocalToSceneInvalidationListener() {
 5885             if (localToSceneInvLstnr == null) {
 5886                 localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
 5887             }
 5888             return localToSceneInvLstnr;
 5889         }
 5890 
 5891         public void incListenerReasons() {
 5892             if (listenerReasons == 0) {
 5893                 Node n = Node.this.getParent();
 5894                 if (n != null) {
 5895                     n.localToSceneTransformProperty().addListener(
 5896                             getLocalToSceneInvalidationListener());
 5897                 }
 5898             }
 5899             listenerReasons++;
 5900         }
 5901 
 5902         public void decListenerReasons() {
 5903             listenerReasons--;
 5904             if (listenerReasons == 0) {
 5905                 Node n = Node.this.getParent();
 5906                 if (n != null) {
 5907                     n.localToSceneTransformProperty().removeListener(
 5908                             getLocalToSceneInvalidationListener());
 5909                 }
 5910                 if (localToSceneTransform != null) {
 5911                     localToSceneTransform.validityUnknown();
 5912                 }
 5913             }
 5914         }
 5915 
 5916         public final Transform getLocalToParentTransform() {
 5917             return localToParentTransformProperty().get();
 5918         }
 5919 
 5920         public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
 5921             if (localToParentTransform == null) {
 5922                 localToParentTransform = new LazyTransformProperty() {
 5923                     @Override
 5924                     protected Transform computeTransform(Transform reuse) {
 5925                         updateLocalToParentTransform();
 5926                         return TransformUtils.immutableTransform(reuse,
 5927                                 localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
 5928                                 localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
 5929                                 localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
 5930                     }
 5931 
 5932                     @Override
 5933                     protected boolean validityKnown() {
 5934                         return true;
 5935                     }
 5936 
 5937                     @Override
 5938                     protected int computeValidity() {
 5939                         return valid;
 5940                     }
 5941 
 5942                     @Override
 5943                     public Object getBean() {
 5944                         return Node.this;
 5945                     }
 5946 
 5947                     @Override
 5948                     public String getName() {
 5949                         return &quot;localToParentTransform&quot;;
 5950                     }
 5951                 };
 5952             }
 5953 
 5954             return localToParentTransform;
 5955         }
 5956 
 5957         public void invalidateLocalToParentTransform() {
 5958             if (localToParentTransform != null) {
 5959                 localToParentTransform.invalidate();
 5960             }
 5961         }
 5962 
 5963         public final Transform getLocalToSceneTransform() {
 5964             return localToSceneTransformProperty().get();
 5965         }
 5966 
 5967         class LocalToSceneTransformProperty extends LazyTransformProperty {
 5968             // need this to track number of listeners
 5969             private List localToSceneListeners;
 5970             // stamps to watch for parent changes when the listeners
 5971             // are not present
 5972             private long stamp, parentStamp;
 5973 
 5974             @Override
 5975             protected Transform computeTransform(Transform reuse) {
 5976                 stamp++;
 5977                 updateLocalToParentTransform();
 5978 
 5979                 Node parentNode = Node.this.getParent();
 5980                 if (parentNode != null) {
 5981                     final LocalToSceneTransformProperty parentProperty =
 5982                             (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
 5983                     final Transform parentTransform = parentProperty.getInternalValue();
 5984 
 5985                     parentStamp = parentProperty.stamp;
 5986 
 5987                     return TransformUtils.immutableTransform(reuse,
 5988                             parentTransform,
 5989                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5990                 } else {
 5991                     return TransformUtils.immutableTransform(reuse,
 5992                             ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
 5993                 }
 5994             }
 5995 
 5996             @Override
 5997             public Object getBean() {
 5998                 return Node.this;
 5999             }
 6000 
 6001             @Override
 6002             public String getName() {
 6003                 return &quot;localToSceneTransform&quot;;
 6004             }
 6005 
 6006             @Override
 6007             protected boolean validityKnown() {
 6008                 return listenerReasons &gt; 0;
 6009             }
 6010 
 6011             @Override
 6012             protected int computeValidity() {
 6013                 if (valid != VALIDITY_UNKNOWN) {
 6014                     return valid;
 6015                 }
 6016 
 6017                 Node n = (Node) getBean();
 6018                 Node parent = n.getParent();
 6019 
 6020                 if (parent != null) {
 6021                     final LocalToSceneTransformProperty parentProperty =
 6022                             (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();
 6023 
 6024                     if (parentStamp != parentProperty.stamp) {
 6025                         valid = INVALID;
 6026                         return INVALID;
 6027                     }
 6028 
 6029                     int parentValid = parentProperty.computeValidity();
 6030                     if (parentValid == INVALID) {
 6031                         valid = INVALID;
 6032                     }
 6033                     return parentValid;
 6034                 }
 6035 
 6036                 // Validity unknown for root means it is valid
 6037                 return VALID;
 6038             }
 6039 
 6040             @Override
 6041             public void addListener(InvalidationListener listener) {
 6042                 incListenerReasons();
 6043                 if (localToSceneListeners == null) {
 6044                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6045                 }
 6046                 localToSceneListeners.add(listener);
 6047                 super.addListener(listener);
 6048             }
 6049 
 6050             @Override
 6051             public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 6052                 incListenerReasons();
 6053                 if (localToSceneListeners == null) {
 6054                     localToSceneListeners = new LinkedList&lt;Object&gt;();
 6055                 }
 6056                 localToSceneListeners.add(listener);
 6057                 super.addListener(listener);
 6058             }
 6059 
 6060             @Override
 6061             public void removeListener(InvalidationListener listener) {
 6062                 if (localToSceneListeners != null &amp;&amp;
 6063                         localToSceneListeners.remove(listener)) {
 6064                     decListenerReasons();
 6065                 }
 6066                 super.removeListener(listener);
 6067             }
 6068 
 6069             @Override
 6070             public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 6071                 if (localToSceneListeners != null &amp;&amp;
 6072                         localToSceneListeners.remove(listener)) {
 6073                     decListenerReasons();
 6074                 }
 6075                 super.removeListener(listener);
 6076             }
 6077         }
 6078 
 6079         public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
 6080             if (localToSceneTransform == null) {
 6081                 localToSceneTransform = new LocalToSceneTransformProperty();
 6082             }
 6083 
 6084             return localToSceneTransform;
 6085         }
 6086 
 6087         public void invalidateLocalToSceneTransform() {
 6088             if (localToSceneTransform != null) {
 6089                 localToSceneTransform.invalidate();
 6090             }
 6091         }
 6092 
 6093         public double getTranslateX() {
 6094             return (translateX == null) ? DEFAULT_TRANSLATE_X
 6095                                         : translateX.get();
 6096         }
 6097 
 6098         public final DoubleProperty translateXProperty() {
 6099             if (translateX == null) {
 6100                 translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
 6101                     @Override
 6102                     public void invalidated() {
 6103                         NodeHelper.transformsChanged(Node.this);
 6104                     }
 6105 
 6106                     @Override
 6107                     public CssMetaData getCssMetaData() {
 6108                         return StyleableProperties.TRANSLATE_X;
 6109                     }
 6110 
 6111                     @Override
 6112                     public Object getBean() {
 6113                         return Node.this;
 6114                     }
 6115 
 6116                     @Override
 6117                     public String getName() {
 6118                         return &quot;translateX&quot;;
 6119                     }
 6120                 };
 6121             }
 6122             return translateX;
 6123         }
 6124 
 6125         public double getTranslateY() {
 6126             return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
 6127         }
 6128 
 6129         public final DoubleProperty translateYProperty() {
 6130             if (translateY == null) {
 6131                 translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
 6132                     @Override
 6133                     public void invalidated() {
 6134                         NodeHelper.transformsChanged(Node.this);
 6135                     }
 6136 
 6137                     @Override
 6138                     public CssMetaData getCssMetaData() {
 6139                         return StyleableProperties.TRANSLATE_Y;
 6140                     }
 6141 
 6142                     @Override
 6143                     public Object getBean() {
 6144                         return Node.this;
 6145                     }
 6146 
 6147                     @Override
 6148                     public String getName() {
 6149                         return &quot;translateY&quot;;
 6150                     }
 6151                 };
 6152             }
 6153             return translateY;
 6154         }
 6155 
 6156         public double getTranslateZ() {
 6157             return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
 6158         }
 6159 
 6160         public final DoubleProperty translateZProperty() {
 6161             if (translateZ == null) {
 6162                 translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
 6163                     @Override
 6164                     public void invalidated() {
 6165                         NodeHelper.transformsChanged(Node.this);
 6166                     }
 6167 
 6168                     @Override
 6169                     public CssMetaData getCssMetaData() {
 6170                         return StyleableProperties.TRANSLATE_Z;
 6171                     }
 6172 
 6173                     @Override
 6174                     public Object getBean() {
 6175                         return Node.this;
 6176                     }
 6177 
 6178                     @Override
 6179                     public String getName() {
 6180                         return &quot;translateZ&quot;;
 6181                     }
 6182                 };
 6183             }
 6184             return translateZ;
 6185         }
 6186 
 6187         public double getScaleX() {
 6188             return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
 6189         }
 6190 
 6191         public final DoubleProperty scaleXProperty() {
 6192             if (scaleX == null) {
 6193                 scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
 6194                     @Override
 6195                     public void invalidated() {
 6196                         NodeHelper.transformsChanged(Node.this);
 6197                     }
 6198 
 6199                     @Override
 6200                     public CssMetaData getCssMetaData() {
 6201                         return StyleableProperties.SCALE_X;
 6202                     }
 6203 
 6204                     @Override
 6205                     public Object getBean() {
 6206                         return Node.this;
 6207                     }
 6208 
 6209                     @Override
 6210                     public String getName() {
 6211                         return &quot;scaleX&quot;;
 6212                     }
 6213                 };
 6214             }
 6215             return scaleX;
 6216         }
 6217 
 6218         public double getScaleY() {
 6219             return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
 6220         }
 6221 
 6222         public final DoubleProperty scaleYProperty() {
 6223             if (scaleY == null) {
 6224                 scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
 6225                     @Override
 6226                     public void invalidated() {
 6227                         NodeHelper.transformsChanged(Node.this);
 6228                     }
 6229 
 6230                     @Override
 6231                     public CssMetaData getCssMetaData() {
 6232                         return StyleableProperties.SCALE_Y;
 6233                     }
 6234 
 6235                     @Override
 6236                     public Object getBean() {
 6237                         return Node.this;
 6238                     }
 6239 
 6240                     @Override
 6241                     public String getName() {
 6242                         return &quot;scaleY&quot;;
 6243                     }
 6244                 };
 6245             }
 6246             return scaleY;
 6247         }
 6248 
 6249         public double getScaleZ() {
 6250             return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
 6251         }
 6252 
 6253         public final DoubleProperty scaleZProperty() {
 6254             if (scaleZ == null) {
 6255                 scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
 6256                     @Override
 6257                     public void invalidated() {
 6258                         NodeHelper.transformsChanged(Node.this);
 6259                     }
 6260 
 6261                     @Override
 6262                     public CssMetaData getCssMetaData() {
 6263                         return StyleableProperties.SCALE_Z;
 6264                     }
 6265 
 6266                     @Override
 6267                     public Object getBean() {
 6268                         return Node.this;
 6269                     }
 6270 
 6271                     @Override
 6272                     public String getName() {
 6273                         return &quot;scaleZ&quot;;
 6274                     }
 6275                 };
 6276             }
 6277             return scaleZ;
 6278         }
 6279 
 6280         public double getRotate() {
 6281             return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
 6282         }
 6283 
 6284         public final DoubleProperty rotateProperty() {
 6285             if (rotate == null) {
 6286                 rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
 6287                     @Override
 6288                     public void invalidated() {
 6289                         NodeHelper.transformsChanged(Node.this);
 6290                     }
 6291 
 6292                     @Override
 6293                     public CssMetaData getCssMetaData() {
 6294                         return StyleableProperties.ROTATE;
 6295                     }
 6296 
 6297                     @Override
 6298                     public Object getBean() {
 6299                         return Node.this;
 6300                     }
 6301 
 6302                     @Override
 6303                     public String getName() {
 6304                         return &quot;rotate&quot;;
 6305                     }
 6306                 };
 6307             }
 6308             return rotate;
 6309         }
 6310 
 6311         public Point3D getRotationAxis() {
 6312             return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
 6313                                           : rotationAxis.get();
 6314         }
 6315 
 6316         public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
 6317             if (rotationAxis == null) {
 6318                 rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
 6319                                            DEFAULT_ROTATION_AXIS) {
 6320                     @Override
 6321                     protected void invalidated() {
 6322                         NodeHelper.transformsChanged(Node.this);
 6323                     }
 6324 
 6325                     @Override
 6326                     public Object getBean() {
 6327                         return Node.this;
 6328                     }
 6329 
 6330                     @Override
 6331                     public String getName() {
 6332                         return &quot;rotationAxis&quot;;
 6333                     }
 6334                 };
 6335             }
 6336             return rotationAxis;
 6337         }
 6338 
 6339         public ObservableList&lt;Transform&gt; getTransforms() {
 6340             if (transforms == null) {
 6341                 transforms = new TrackableObservableList&lt;Transform&gt;() {
 6342                     @Override
 6343                     protected void onChanged(Change&lt;Transform&gt; c) {
 6344                         while (c.next()) {
 6345                             for (Transform t : c.getRemoved()) {
 6346                                 TransformHelper.remove(t, Node.this);
 6347                             }
 6348                             for (Transform t : c.getAddedSubList()) {
 6349                                 TransformHelper.add(t, Node.this);
 6350                             }
 6351                         }
 6352 
 6353                         NodeHelper.transformsChanged(Node.this);
 6354                     }
 6355                 };
 6356             }
 6357 
 6358             return transforms;
 6359         }
 6360 
 6361         public boolean canSetTranslateX() {
 6362             return (translateX == null) || !translateX.isBound();
 6363         }
 6364 
 6365         public boolean canSetTranslateY() {
 6366             return (translateY == null) || !translateY.isBound();
 6367         }
 6368 
 6369         public boolean canSetTranslateZ() {
 6370             return (translateZ == null) || !translateZ.isBound();
 6371         }
 6372 
 6373         public boolean canSetScaleX() {
 6374             return (scaleX == null) || !scaleX.isBound();
 6375         }
 6376 
 6377         public boolean canSetScaleY() {
 6378             return (scaleY == null) || !scaleY.isBound();
 6379         }
 6380 
 6381         public boolean canSetScaleZ() {
 6382             return (scaleZ == null) || !scaleZ.isBound();
 6383         }
 6384 
 6385         public boolean canSetRotate() {
 6386             return (rotate == null) || !rotate.isBound();
 6387         }
 6388 
 6389         public boolean hasTransforms() {
 6390             return (transforms != null &amp;&amp; !transforms.isEmpty());
 6391         }
 6392 
 6393         public boolean hasScaleOrRotate() {
 6394             if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
 6395                 return true;
 6396             }
 6397             if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
 6398                 return true;
 6399             }
 6400             if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
 6401                 return true;
 6402             }
 6403             if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
 6404                 return true;
 6405             }
 6406             return false;
 6407         }
 6408 
 6409     }
 6410 
 6411     ////////////////////////////
 6412     //  Private Implementation
 6413     ////////////////////////////
 6414 
 6415     /***************************************************************************
 6416      *                                                                         *
 6417      *                        Event Handler Properties                         *
 6418      *                                                                         *
 6419      **************************************************************************/
 6420 
 6421     private EventHandlerProperties eventHandlerProperties;
 6422 
 6423     private EventHandlerProperties getEventHandlerProperties() {
 6424         if (eventHandlerProperties == null) {
 6425             eventHandlerProperties =
 6426                     new EventHandlerProperties(
 6427                         getInternalEventDispatcher().getEventHandlerManager(),
 6428                         this);
 6429         }
 6430 
 6431         return eventHandlerProperties;
 6432     }
 6433 
 6434     /***************************************************************************
 6435      *                                                                         *
 6436      *                       Component Orientation Properties                  *
 6437      *                                                                         *
 6438      **************************************************************************/
 6439 
 6440     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
 6441     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
 6442 
 6443     private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
 6444     private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
 6445     private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
 6446     private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
 6447     private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
 6448     private static final byte AUTOMATIC_ORIENTATION_MASK = 2;
 6449 
 6450     private byte resolvedNodeOrientation =
 6451             EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;
 6452 
 6453     public final void setNodeOrientation(NodeOrientation orientation) {
 6454         nodeOrientationProperty().set(orientation);
 6455     }
 6456 
 6457     public final NodeOrientation getNodeOrientation() {
 6458         return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
 6459     }
 6460     /**
 6461      * Property holding NodeOrientation.
 6462      * &lt;p&gt;
 6463      * Node orientation describes the flow of visual data within a node.
 6464      * In the English speaking world, visual data normally flows from
 6465      * left-to-right. In an Arabic or Hebrew world, visual data flows
 6466      * from right-to-left.  This is consistent with the reading order
 6467      * of text in both worlds.  The default value is left-to-right.
 6468      * &lt;/p&gt;
 6469      *
 6470      * @return NodeOrientation
 6471      * @since JavaFX 8.0
 6472      */
 6473     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
 6474         if (nodeOrientation == null) {
 6475             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
 6476                 @Override
 6477                 protected void invalidated() {
 6478                     nodeResolvedOrientationInvalidated();
 6479                 }
 6480 
 6481                 @Override
 6482                 public Object getBean() {
 6483                     return Node.this;
 6484                 }
 6485 
 6486                 @Override
 6487                 public String getName() {
 6488                     return &quot;nodeOrientation&quot;;
 6489                 }
 6490 
 6491                 @Override
 6492                 public CssMetaData getCssMetaData() {
 6493                     //TODO - not supported
 6494                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
 6495                 }
 6496 
 6497             };
 6498         }
 6499         return nodeOrientation;
 6500     }
 6501 
 6502     public final NodeOrientation getEffectiveNodeOrientation() {
 6503         return (getEffectiveOrientation(resolvedNodeOrientation)
 6504                     == EFFECTIVE_ORIENTATION_LTR)
 6505                        ? NodeOrientation.LEFT_TO_RIGHT
 6506                        : NodeOrientation.RIGHT_TO_LEFT;
 6507     }
 6508 
 6509     /**
 6510      * The effective orientation of a node resolves the inheritance of
 6511      * node orientation, returning either left-to-right or right-to-left.
 6512      * @return the node orientation for this {@code Node}
 6513      * @since JavaFX 8.0
 6514      */
 6515     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
 6516             effectiveNodeOrientationProperty() {
 6517         if (effectiveNodeOrientationProperty == null) {
 6518             effectiveNodeOrientationProperty =
 6519                     new EffectiveOrientationProperty();
 6520         }
 6521 
 6522         return effectiveNodeOrientationProperty;
 6523     }
 6524 
 6525     /**
 6526      * Determines whether a node should be mirrored when node orientation
 6527      * is right-to-left.
 6528      * &lt;p&gt;
 6529      * When a node is mirrored, the origin is automatically moved to the
 6530      * top right corner causing the node to layout children and draw from
 6531      * right to left using a mirroring transformation.  Some nodes may wish
 6532      * to draw from right to left without using a transformation.  These
 6533      * nodes will will answer {@code false} and implement right-to-left
 6534      * orientation without using the automatic transformation.
 6535      * &lt;/p&gt;
 6536      * @return true if this {@code Node} should be mirrored
 6537      * @since JavaFX 8.0
 6538      */
 6539     public boolean usesMirroring() {
 6540         return true;
 6541     }
 6542 
 6543     final void parentResolvedOrientationInvalidated() {
 6544         if (getNodeOrientation() == NodeOrientation.INHERIT) {
 6545             nodeResolvedOrientationInvalidated();
 6546         } else {
 6547             // mirroring changed
 6548             NodeHelper.transformsChanged(this);
 6549         }
 6550     }
 6551 
 6552     final void nodeResolvedOrientationInvalidated() {
 6553         final byte oldResolvedNodeOrientation =
 6554                 resolvedNodeOrientation;
 6555 
 6556         resolvedNodeOrientation =
 6557                 (byte) (calcEffectiveNodeOrientation()
 6558                             | calcAutomaticNodeOrientation());
 6559 
 6560         if ((effectiveNodeOrientationProperty != null)
 6561                 &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
 6562                         != getEffectiveOrientation(
 6563                                oldResolvedNodeOrientation))) {
 6564             effectiveNodeOrientationProperty.invalidate();
 6565         }
 6566 
 6567         // mirroring changed
 6568         NodeHelper.transformsChanged(this);
 6569 
 6570         if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
 6571             nodeResolvedOrientationChanged();
 6572         }
 6573     }
 6574 
 6575     void nodeResolvedOrientationChanged() {
 6576         // overriden in Parent
 6577     }
 6578 
 6579     private Node getMirroringOrientationParent() {
 6580         Node parentValue = getParent();
 6581         while (parentValue != null) {
 6582             if (parentValue.usesMirroring()) {
 6583                 return parentValue;
 6584             }
 6585             parentValue = parentValue.getParent();
 6586         }
 6587 
 6588         final Node subSceneValue = getSubScene();
 6589         if (subSceneValue != null) {
 6590             return subSceneValue;
 6591         }
 6592 
 6593         return null;
 6594     }
 6595 
 6596     private Node getOrientationParent() {
 6597         final Node parentValue = getParent();
 6598         if (parentValue != null) {
 6599             return parentValue;
 6600         }
 6601 
 6602         final Node subSceneValue = getSubScene();
 6603         if (subSceneValue != null) {
 6604             return subSceneValue;
 6605         }
 6606 
 6607         return null;
 6608     }
 6609 
 6610     private byte calcEffectiveNodeOrientation() {
 6611         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6612         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6613             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6614                        ? EFFECTIVE_ORIENTATION_LTR
 6615                        : EFFECTIVE_ORIENTATION_RTL;
 6616         }
 6617 
 6618         final Node parentValue = getOrientationParent();
 6619         if (parentValue != null) {
 6620             return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
 6621         }
 6622 
 6623         final Scene sceneValue = getScene();
 6624         if (sceneValue != null) {
 6625             return (sceneValue.getEffectiveNodeOrientation()
 6626                         == NodeOrientation.LEFT_TO_RIGHT)
 6627                            ? EFFECTIVE_ORIENTATION_LTR
 6628                            : EFFECTIVE_ORIENTATION_RTL;
 6629         }
 6630 
 6631         return EFFECTIVE_ORIENTATION_LTR;
 6632     }
 6633 
 6634     private byte calcAutomaticNodeOrientation() {
 6635         if (!usesMirroring()) {
 6636             return AUTOMATIC_ORIENTATION_LTR;
 6637         }
 6638 
 6639         final NodeOrientation nodeOrientationValue = getNodeOrientation();
 6640         if (nodeOrientationValue != NodeOrientation.INHERIT) {
 6641             return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
 6642                        ? AUTOMATIC_ORIENTATION_LTR
 6643                        : AUTOMATIC_ORIENTATION_RTL;
 6644         }
 6645 
 6646         final Node parentValue = getMirroringOrientationParent();
 6647         if (parentValue != null) {
 6648             // automatic node orientation is inherited
 6649             return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
 6650         }
 6651 
 6652         final Scene sceneValue = getScene();
 6653         if (sceneValue != null) {
 6654             return (sceneValue.getEffectiveNodeOrientation()
 6655                         == NodeOrientation.LEFT_TO_RIGHT)
 6656                            ? AUTOMATIC_ORIENTATION_LTR
 6657                            : AUTOMATIC_ORIENTATION_RTL;
 6658         }
 6659 
 6660         return AUTOMATIC_ORIENTATION_LTR;
 6661     }
 6662 
 6663     // Return true if the node needs to be mirrored.
 6664     // A node has mirroring if the orientation differs from the parent
 6665     // package private for testing
 6666     final boolean hasMirroring() {
 6667         final Node parentValue = getOrientationParent();
 6668 
 6669         final byte thisOrientation =
 6670                 getAutomaticOrientation(resolvedNodeOrientation);
 6671         final byte parentOrientation =
 6672                 (parentValue != null)
 6673                     ? getAutomaticOrientation(
 6674                           parentValue.resolvedNodeOrientation)
 6675                     : AUTOMATIC_ORIENTATION_LTR;
 6676 
 6677         return thisOrientation != parentOrientation;
 6678     }
 6679 
 6680     private static byte getEffectiveOrientation(
 6681             final byte resolvedNodeOrientation) {
 6682         return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
 6683     }
 6684 
 6685     private static byte getAutomaticOrientation(
 6686             final byte resolvedNodeOrientation) {
 6687         return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
 6688     }
 6689 
 6690     private final class EffectiveOrientationProperty
 6691             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
 6692         @Override
 6693         public NodeOrientation get() {
 6694             return getEffectiveNodeOrientation();
 6695         }
 6696 
 6697         @Override
 6698         public Object getBean() {
 6699             return Node.this;
 6700         }
 6701 
 6702         @Override
 6703         public String getName() {
 6704             return &quot;effectiveNodeOrientation&quot;;
 6705         }
 6706 
 6707         public void invalidate() {
 6708             fireValueChangedEvent();
 6709         }
 6710     }
 6711 
 6712     /***************************************************************************
 6713      *                                                                         *
 6714      *                       Misc Seldom Used Properties                       *
 6715      *                                                                         *
 6716      **************************************************************************/
 6717 
 6718     private MiscProperties miscProperties;
 6719 
 6720     private MiscProperties getMiscProperties() {
 6721         if (miscProperties == null) {
 6722             miscProperties = new MiscProperties();
 6723         }
 6724 
 6725         return miscProperties;
 6726     }
 6727 
 6728     private static final double DEFAULT_VIEW_ORDER = 0;
 6729     private static final boolean DEFAULT_CACHE = false;
 6730     private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
 6731     private static final Node DEFAULT_CLIP = null;
 6732     private static final Cursor DEFAULT_CURSOR = null;
 6733     private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
 6734     private static final boolean DEFAULT_DISABLE = false;
 6735     private static final Effect DEFAULT_EFFECT = null;
 6736     private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
 6737             null;
 6738     private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;
 6739 
 6740     private final class MiscProperties {
 6741         private LazyBoundsProperty boundsInParent;
 6742         private LazyBoundsProperty boundsInLocal;
 6743         private BooleanProperty cache;
 6744         private ObjectProperty&lt;CacheHint&gt; cacheHint;
 6745         private ObjectProperty&lt;Node&gt; clip;
 6746         private ObjectProperty&lt;Cursor&gt; cursor;
 6747         private ObjectProperty&lt;DepthTest&gt; depthTest;
 6748         private BooleanProperty disable;
 6749         private ObjectProperty&lt;Effect&gt; effect;
 6750         private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
 6751         private BooleanProperty mouseTransparent;
 6752         private DoubleProperty viewOrder;
 6753 
 6754         public double getViewOrder() {
 6755             return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
 6756         }
 6757 
 6758         public final DoubleProperty viewOrderProperty() {
 6759             if (viewOrder == null) {
 6760                 viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
 6761                     @Override
 6762                     public void invalidated() {
 6763                         Parent p = getParent();
 6764                         if (p != null) {
 6765                             // Parent will be responsible to update sorted children list
 6766                             p.markViewOrderChildrenDirty();
 6767                         }
 6768                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
 6769                     }
 6770 
 6771                     @Override
 6772                     public CssMetaData getCssMetaData() {
 6773                         return StyleableProperties.VIEW_ORDER;
 6774                     }
 6775 
 6776                     @Override
 6777                     public Object getBean() {
 6778                         return Node.this;
 6779                     }
 6780 
 6781                     @Override
 6782                     public String getName() {
 6783                         return &quot;viewOrder&quot;;
 6784                     }
 6785                 };
 6786             }
 6787             return viewOrder;
 6788         }
 6789 
 6790         public final Bounds getBoundsInParent() {
 6791             return boundsInParentProperty().get();
 6792         }
 6793 
 6794         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
 6795             if (boundsInParent == null) {
 6796                 boundsInParent = new LazyBoundsProperty() {
 6797                     /**
 6798                      * Computes the bounds including the clip, effects, and all
 6799                      * transforms. This function is essentially how to compute
 6800                      * the boundsInParent. Optimizations are made to compute as
 6801                      * little as possible and create as little trash as
 6802                      * possible.
 6803                      */
 6804                     @Override
 6805                     protected Bounds computeBounds() {
 6806                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6807                         tempBounds = getTransformedBounds(
 6808                                              tempBounds,
 6809                                              BaseTransform.IDENTITY_TRANSFORM);
 6810                         return new BoundingBox(tempBounds.getMinX(),
 6811                                                tempBounds.getMinY(),
 6812                                                tempBounds.getMinZ(),
 6813                                                tempBounds.getWidth(),
 6814                                                tempBounds.getHeight(),
 6815                                                tempBounds.getDepth());
 6816                     }
 6817 
 6818                     @Override
 6819                     public Object getBean() {
 6820                         return Node.this;
 6821                     }
 6822 
 6823                     @Override
 6824                     public String getName() {
 6825                         return &quot;boundsInParent&quot;;
 6826                     }
 6827                 };
 6828             }
 6829 
 6830             return boundsInParent;
 6831         }
 6832 
 6833         public void invalidateBoundsInParent() {
 6834             if (boundsInParent != null) {
 6835                 boundsInParent.invalidate();
 6836             }
 6837         }
 6838 
 6839         public final Bounds getBoundsInLocal() {
 6840             return boundsInLocalProperty().get();
 6841         }
 6842 
 6843         public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
 6844             if (boundsInLocal == null) {
 6845                 boundsInLocal = new LazyBoundsProperty() {
 6846                     @Override
 6847                     protected Bounds computeBounds() {
 6848                         BaseBounds tempBounds = TempState.getInstance().bounds;
 6849                         tempBounds = getLocalBounds(
 6850                                              tempBounds,
 6851                                              BaseTransform.IDENTITY_TRANSFORM);
 6852                         return new BoundingBox(tempBounds.getMinX(),
 6853                                                tempBounds.getMinY(),
 6854                                                tempBounds.getMinZ(),
 6855                                                tempBounds.getWidth(),
 6856                                                tempBounds.getHeight(),
 6857                                                tempBounds.getDepth());
 6858                     }
 6859 
 6860                     @Override
 6861                     public Object getBean() {
 6862                         return Node.this;
 6863                     }
 6864 
 6865                     @Override
 6866                     public String getName() {
 6867                         return &quot;boundsInLocal&quot;;
 6868                     }
 6869                 };
 6870             }
 6871 
 6872             return boundsInLocal;
 6873         }
 6874 
 6875         public void invalidateBoundsInLocal() {
 6876             if (boundsInLocal != null) {
 6877                 boundsInLocal.invalidate();
 6878             }
 6879         }
 6880 
 6881         public final boolean isCache() {
 6882             return (cache == null) ? DEFAULT_CACHE
 6883                                    : cache.get();
 6884         }
 6885 
 6886         public final BooleanProperty cacheProperty() {
 6887             if (cache == null) {
 6888                 cache = new BooleanPropertyBase(DEFAULT_CACHE) {
 6889                     @Override
 6890                     protected void invalidated() {
 6891                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6892                     }
 6893 
 6894                     @Override
 6895                     public Object getBean() {
 6896                         return Node.this;
 6897                     }
 6898 
 6899                     @Override
 6900                     public String getName() {
 6901                         return &quot;cache&quot;;
 6902                     }
 6903                 };
 6904             }
 6905             return cache;
 6906         }
 6907 
 6908         public final CacheHint getCacheHint() {
 6909             return (cacheHint == null) ? DEFAULT_CACHE_HINT
 6910                                        : cacheHint.get();
 6911         }
 6912 
 6913         public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
 6914             if (cacheHint == null) {
 6915                 cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
 6916                     @Override
 6917                     protected void invalidated() {
 6918                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
 6919                     }
 6920 
 6921                     @Override
 6922                     public Object getBean() {
 6923                         return Node.this;
 6924                     }
 6925 
 6926                     @Override
 6927                     public String getName() {
 6928                         return &quot;cacheHint&quot;;
 6929                     }
 6930                 };
 6931             }
 6932             return cacheHint;
 6933         }
 6934 
 6935         public final Node getClip() {
 6936             return (clip == null) ? DEFAULT_CLIP : clip.get();
 6937         }
 6938 
 6939         public final ObjectProperty&lt;Node&gt; clipProperty() {
 6940             if (clip == null) {
 6941                 clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {
 6942 
 6943                     //temp variables used when clip was invalid to rollback to
 6944                     // last value
 6945                     private Node oldClip;
 6946 
 6947                     @Override
 6948                     protected void invalidated() {
 6949                         final Node newClip = get();
 6950                         if ((newClip != null)
 6951                                 &amp;&amp; ((newClip.isConnected()
 6952                                            &amp;&amp; newClip.clipParent != Node.this)
 6953                                        || wouldCreateCycle(Node.this,
 6954                                                            newClip))) {
 6955                             // Assigning this node to clip is illegal.
 6956                             // Roll back to the previous state and throw an
 6957                             // exception.
 6958                             final String cause =
 6959                                     newClip.isConnected()
 6960                                         &amp;&amp; (newClip.clipParent != Node.this)
 6961                                             ? &quot;node already connected&quot;
 6962                                             : &quot;cycle detected&quot;;
 6963 
 6964                             if (isBound()) {
 6965                                 unbind();
 6966                                 set(oldClip);
 6967                                 throw new IllegalArgumentException(
 6968                                         &quot;Node&#39;s clip set to incorrect value &quot;
 6969                                             + &quot; through binding&quot;
 6970                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6971                                                    + Node.this + &quot;, clip = &quot;
 6972                                                    + clip + &quot;).&quot;
 6973                                             + &quot; Binding has been removed.&quot;);
 6974                             } else {
 6975                                 set(oldClip);
 6976                                 throw new IllegalArgumentException(
 6977                                         &quot;Node&#39;s clip set to incorrect value&quot;
 6978                                             + &quot; (&quot; + cause + &quot;, node  = &quot;
 6979                                                    + Node.this + &quot;, clip = &quot;
 6980                                                    + clip + &quot;).&quot;);
 6981                             }
 6982                         } else {
 6983                             if (oldClip != null) {
 6984                                 oldClip.clipParent = null;
<a name="8" id="anc8"></a><span class="line-modified"> 6985                                 oldClip.setScenes(null, null, /* reapplyCSS */ false);</span>
 6986                                 oldClip.updateTreeVisible(false);
 6987                             }
 6988 
 6989                             if (newClip != null) {
 6990                                 newClip.clipParent = Node.this;
<a name="9" id="anc9"></a><span class="line-modified"> 6991                                 newClip.setScenes(getScene(), getSubScene(), /* reapplyCSS */ false);</span>
 6992                                 newClip.updateTreeVisible(true);
 6993                             }
 6994 
 6995                             NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);
 6996 
 6997                             // the local bounds have (probably) changed
 6998                             localBoundsChanged();
 6999 
 7000                             oldClip = newClip;
 7001                         }
 7002                     }
 7003 
 7004                     @Override
 7005                     public Object getBean() {
 7006                         return Node.this;
 7007                     }
 7008 
 7009                     @Override
 7010                     public String getName() {
 7011                         return &quot;clip&quot;;
 7012                     }
 7013                 };
 7014             }
 7015             return clip;
 7016         }
 7017 
 7018         public final Cursor getCursor() {
 7019             return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
 7020         }
 7021 
 7022         public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
 7023             if (cursor == null) {
 7024                 cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {
 7025 
 7026                     @Override
 7027                     protected void invalidated() {
 7028                         final Scene sceneValue = getScene();
 7029                         if (sceneValue != null) {
 7030                             sceneValue.markCursorDirty();
 7031                         }
 7032                     }
 7033 
 7034                     @Override
 7035                     public CssMetaData getCssMetaData() {
 7036                         return StyleableProperties.CURSOR;
 7037                     }
 7038 
 7039                     @Override
 7040                     public Object getBean() {
 7041                         return Node.this;
 7042                     }
 7043 
 7044                     @Override
 7045                     public String getName() {
 7046                         return &quot;cursor&quot;;
 7047                     }
 7048 
 7049                 };
 7050             }
 7051             return cursor;
 7052         }
 7053 
 7054         public final DepthTest getDepthTest() {
 7055             return (depthTest == null) ? DEFAULT_DEPTH_TEST
 7056                                        : depthTest.get();
 7057         }
 7058 
 7059         public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
 7060             if (depthTest == null) {
 7061                 depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
 7062                     @Override protected void invalidated() {
 7063                         computeDerivedDepthTest();
 7064                     }
 7065 
 7066                     @Override
 7067                     public Object getBean() {
 7068                         return Node.this;
 7069                     }
 7070 
 7071                     @Override
 7072                     public String getName() {
 7073                         return &quot;depthTest&quot;;
 7074                     }
 7075                 };
 7076             }
 7077             return depthTest;
 7078         }
 7079 
 7080         public final boolean isDisable() {
 7081             return (disable == null) ? DEFAULT_DISABLE : disable.get();
 7082         }
 7083 
 7084         public final BooleanProperty disableProperty() {
 7085             if (disable == null) {
 7086                 disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
 7087                     @Override
 7088                     protected void invalidated() {
 7089                         updateDisabled();
 7090                     }
 7091 
 7092                     @Override
 7093                     public Object getBean() {
 7094                         return Node.this;
 7095                     }
 7096 
 7097                     @Override
 7098                     public String getName() {
 7099                         return &quot;disable&quot;;
 7100                     }
 7101                 };
 7102             }
 7103             return disable;
 7104         }
 7105 
 7106         public final Effect getEffect() {
 7107             return (effect == null) ? DEFAULT_EFFECT : effect.get();
 7108         }
 7109 
 7110         public final ObjectProperty&lt;Effect&gt; effectProperty() {
 7111             if (effect == null) {
 7112                 effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
 7113                     private Effect oldEffect = null;
 7114                     private int oldBits;
 7115 
 7116                     private final AbstractNotifyListener effectChangeListener =
 7117                             new AbstractNotifyListener() {
 7118 
 7119                         @Override
 7120                         public void invalidated(Observable valueModel) {
 7121                             int newBits = ((IntegerProperty) valueModel).get();
 7122                             int changedBits = newBits ^ oldBits;
 7123                             oldBits = newBits;
 7124                             if (EffectDirtyBits.isSet(
 7125                                     changedBits,
 7126                                     EffectDirtyBits.EFFECT_DIRTY)
 7127                                 &amp;&amp; EffectDirtyBits.isSet(
 7128                                        newBits,
 7129                                        EffectDirtyBits.EFFECT_DIRTY)) {
 7130                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7131                             }
 7132                             if (EffectDirtyBits.isSet(
 7133                                     changedBits,
 7134                                     EffectDirtyBits.BOUNDS_CHANGED)) {
 7135                                 localBoundsChanged();
 7136                             }
 7137                         }
 7138                     };
 7139 
 7140                     @Override
 7141                     protected void invalidated() {
 7142                         Effect _effect = get();
 7143                         if (oldEffect != null) {
 7144                             EffectHelper.effectDirtyProperty(oldEffect).removeListener(
 7145                                     effectChangeListener.getWeakListener());
 7146                         }
 7147                         oldEffect = _effect;
 7148                         if (_effect != null) {
 7149                             EffectHelper.effectDirtyProperty(_effect)
 7150                                    .addListener(
 7151                                        effectChangeListener.getWeakListener());
 7152                             if (EffectHelper.isEffectDirty(_effect)) {
 7153                                 NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
 7154                             }
 7155                             oldBits = EffectHelper.effectDirtyProperty(_effect).get();
 7156                         }
 7157 
 7158                         NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
 7159                         // bounds may have changed regardless whether
 7160                         // the dirty flag on effect is set
 7161                         localBoundsChanged();
 7162                     }
 7163 
 7164                     @Override
 7165                     public CssMetaData getCssMetaData() {
 7166                         return StyleableProperties.EFFECT;
 7167                     }
 7168 
 7169                     @Override
 7170                     public Object getBean() {
 7171                         return Node.this;
 7172                     }
 7173 
 7174                     @Override
 7175                     public String getName() {
 7176                         return &quot;effect&quot;;
 7177                     }
 7178                 };
 7179             }
 7180             return effect;
 7181         }
 7182 
 7183         public final InputMethodRequests getInputMethodRequests() {
 7184             return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
 7185                                                  : inputMethodRequests.get();
 7186         }
 7187 
 7188         public ObjectProperty&lt;InputMethodRequests&gt;
 7189                 inputMethodRequestsProperty() {
 7190             if (inputMethodRequests == null) {
 7191                 inputMethodRequests =
 7192                         new SimpleObjectProperty&lt;InputMethodRequests&gt;(
 7193                                 Node.this,
 7194                                 &quot;inputMethodRequests&quot;,
 7195                                 DEFAULT_INPUT_METHOD_REQUESTS);
 7196             }
 7197             return inputMethodRequests;
 7198         }
 7199 
 7200         public final boolean isMouseTransparent() {
 7201             return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
 7202                                               : mouseTransparent.get();
 7203         }
 7204 
 7205         public final BooleanProperty mouseTransparentProperty() {
 7206             if (mouseTransparent == null) {
 7207                 mouseTransparent =
 7208                         new SimpleBooleanProperty(
 7209                                 Node.this,
 7210                                 &quot;mouseTransparent&quot;,
 7211                                 DEFAULT_MOUSE_TRANSPARENT);
 7212             }
 7213             return mouseTransparent;
 7214         }
 7215 
 7216         public boolean canSetCursor() {
 7217             return (cursor == null) || !cursor.isBound();
 7218         }
 7219 
 7220         public boolean canSetEffect() {
 7221             return (effect == null) || !effect.isBound();
 7222         }
 7223     }
 7224 
 7225     /* *************************************************************************
 7226      *                                                                         *
 7227      *                             Mouse Handling                              *
 7228      *                                                                         *
 7229      **************************************************************************/
 7230 
 7231     public final void setMouseTransparent(boolean value) {
 7232         mouseTransparentProperty().set(value);
 7233     }
 7234 
 7235     public final boolean isMouseTransparent() {
 7236         return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
 7237                                         : miscProperties.isMouseTransparent();
 7238     }
 7239 
 7240     /**
 7241      * If {@code true}, this node (together with all its children) is completely
 7242      * transparent to mouse events. When choosing target for mouse event, nodes
 7243      * with {@code mouseTransparent} set to {@code true} and their subtrees
 7244      * won&#39;t be taken into account.
 7245      * @return is this {@code Node} (together with all its children) is completely
 7246      * transparent to mouse events.
 7247      */
 7248     public final BooleanProperty mouseTransparentProperty() {
 7249         return getMiscProperties().mouseTransparentProperty();
 7250     }
 7251 
 7252     /**
 7253      * Whether or not this {@code Node} is being hovered over. Typically this is
 7254      * due to the mouse being over the node, though it could be due to a pen
 7255      * hovering on a graphics tablet or other form of input.
 7256      *
 7257      * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
 7258      * exit events to determine whether this Node is in the hover state; this
 7259      * means that this feature is currently supported only on systems that
 7260      * have a mouse. Future implementations may provide alternative means of
 7261      * supporting hover.
 7262      *
 7263      * @defaultValue false
 7264      */
 7265     private ReadOnlyBooleanWrapper hover;
 7266 
 7267     protected final void setHover(boolean value) {
 7268         hoverPropertyImpl().set(value);
 7269     }
 7270 
 7271     public final boolean isHover() {
 7272         return hover == null ? false : hover.get();
 7273     }
 7274 
 7275     public final ReadOnlyBooleanProperty hoverProperty() {
 7276         return hoverPropertyImpl().getReadOnlyProperty();
 7277     }
 7278 
 7279     private ReadOnlyBooleanWrapper hoverPropertyImpl() {
 7280         if (hover == null) {
 7281             hover = new ReadOnlyBooleanWrapper() {
 7282 
 7283                 @Override
 7284                 protected void invalidated() {
 7285                     PlatformLogger logger = Logging.getInputLogger();
 7286                     if (logger.isLoggable(Level.FINER)) {
 7287                         logger.finer(this + &quot; hover=&quot; + get());
 7288                     }
 7289                     pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
 7290                 }
 7291 
 7292                 @Override
 7293                 public Object getBean() {
 7294                     return Node.this;
 7295                 }
 7296 
 7297                 @Override
 7298                 public String getName() {
 7299                     return &quot;hover&quot;;
 7300                 }
 7301             };
 7302         }
 7303         return hover;
 7304     }
 7305 
 7306     /**
 7307      * Whether or not the {@code Node} is pressed. Typically this is true when
 7308      * the primary mouse button is down, though subclasses may define other
 7309      * mouse button state or key state to cause the node to be &quot;pressed&quot;.
 7310      *
 7311      * @defaultValue false
 7312      */
 7313     private ReadOnlyBooleanWrapper pressed;
 7314 
 7315     protected final void setPressed(boolean value) {
 7316         pressedPropertyImpl().set(value);
 7317     }
 7318 
 7319     public final boolean isPressed() {
 7320         return pressed == null ? false : pressed.get();
 7321     }
 7322 
 7323     public final ReadOnlyBooleanProperty pressedProperty() {
 7324         return pressedPropertyImpl().getReadOnlyProperty();
 7325     }
 7326 
 7327     private ReadOnlyBooleanWrapper pressedPropertyImpl() {
 7328         if (pressed == null) {
 7329             pressed = new ReadOnlyBooleanWrapper() {
 7330 
 7331                 @Override
 7332                 protected void invalidated() {
 7333                     PlatformLogger logger = Logging.getInputLogger();
 7334                     if (logger.isLoggable(Level.FINER)) {
 7335                         logger.finer(this + &quot; pressed=&quot; + get());
 7336                     }
 7337                     pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
 7338                 }
 7339 
 7340                 @Override
 7341                 public Object getBean() {
 7342                     return Node.this;
 7343                 }
 7344 
 7345                 @Override
 7346                 public String getName() {
 7347                     return &quot;pressed&quot;;
 7348                 }
 7349             };
 7350         }
 7351         return pressed;
 7352     }
 7353 
 7354     public final void setOnContextMenuRequested(
 7355             EventHandler&lt;? super ContextMenuEvent&gt; value) {
 7356         onContextMenuRequestedProperty().set(value);
 7357     }
 7358 
 7359     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
 7360         return (eventHandlerProperties == null)
 7361                 ? null : eventHandlerProperties.onContextMenuRequested();
 7362     }
 7363 
 7364     /**
 7365      * Defines a function to be called when a context menu
 7366      * has been requested on this {@code Node}.
 7367      * @return the event handler that is called when a context menu has been
 7368      * requested on this {@code Node}
 7369      * @since JavaFX 2.1
 7370      */
 7371     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
 7372             onContextMenuRequestedProperty() {
 7373         return getEventHandlerProperties().onContextMenuRequestedProperty();
 7374     }
 7375 
 7376     public final void setOnMouseClicked(
 7377             EventHandler&lt;? super MouseEvent&gt; value) {
 7378         onMouseClickedProperty().set(value);
 7379     }
 7380 
 7381     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
 7382         return (eventHandlerProperties == null)
 7383                 ? null : eventHandlerProperties.getOnMouseClicked();
 7384     }
 7385 
 7386     /**
 7387      * Defines a function to be called when a mouse button has been clicked
 7388      * (pressed and released) on this {@code Node}.
 7389      * @return the event handler that is called when a mouse button has been
 7390      * clicked (pressed and released) on this {@code Node}
 7391      */
 7392     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7393             onMouseClickedProperty() {
 7394         return getEventHandlerProperties().onMouseClickedProperty();
 7395     }
 7396 
 7397     public final void setOnMouseDragged(
 7398             EventHandler&lt;? super MouseEvent&gt; value) {
 7399         onMouseDraggedProperty().set(value);
 7400     }
 7401 
 7402     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
 7403         return (eventHandlerProperties == null)
 7404                 ? null : eventHandlerProperties.getOnMouseDragged();
 7405     }
 7406 
 7407     /**
 7408      * Defines a function to be called when a mouse button is pressed
 7409      * on this {@code Node} and then dragged.
 7410      * @return the event handler that is called when a mouse button is pressed
 7411      * on this {@code Node} and then dragged
 7412      */
 7413     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7414             onMouseDraggedProperty() {
 7415         return getEventHandlerProperties().onMouseDraggedProperty();
 7416     }
 7417 
 7418     public final void setOnMouseEntered(
 7419             EventHandler&lt;? super MouseEvent&gt; value) {
 7420         onMouseEnteredProperty().set(value);
 7421     }
 7422 
 7423     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
 7424         return (eventHandlerProperties == null)
 7425                 ? null : eventHandlerProperties.getOnMouseEntered();
 7426     }
 7427 
 7428     /**
 7429      * Defines a function to be called when the mouse enters this {@code Node}.
 7430      * @return the event handler that is called when a mouse enters this
 7431      * {@code Node}
 7432      */
 7433     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7434             onMouseEnteredProperty() {
 7435         return getEventHandlerProperties().onMouseEnteredProperty();
 7436     }
 7437 
 7438     public final void setOnMouseExited(
 7439             EventHandler&lt;? super MouseEvent&gt; value) {
 7440         onMouseExitedProperty().set(value);
 7441     }
 7442 
 7443     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
 7444         return (eventHandlerProperties == null)
 7445                 ? null : eventHandlerProperties.getOnMouseExited();
 7446     }
 7447 
 7448     /**
 7449      * Defines a function to be called when the mouse exits this {@code Node}.
 7450      * @return the event handler that is called when a mouse exits this
 7451      * {@code Node}
 7452      */
 7453     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7454             onMouseExitedProperty() {
 7455         return getEventHandlerProperties().onMouseExitedProperty();
 7456     }
 7457 
 7458     public final void setOnMouseMoved(
 7459             EventHandler&lt;? super MouseEvent&gt; value) {
 7460         onMouseMovedProperty().set(value);
 7461     }
 7462 
 7463     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
 7464         return (eventHandlerProperties == null)
 7465                 ? null : eventHandlerProperties.getOnMouseMoved();
 7466     }
 7467 
 7468     /**
 7469      * Defines a function to be called when mouse cursor moves within
 7470      * this {@code Node} but no buttons have been pushed.
 7471      * @return the event handler that is called when a mouse cursor moves
 7472      * within this {@code Node} but no buttons have been pushed
 7473      */
 7474     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7475             onMouseMovedProperty() {
 7476         return getEventHandlerProperties().onMouseMovedProperty();
 7477     }
 7478 
 7479     public final void setOnMousePressed(
 7480             EventHandler&lt;? super MouseEvent&gt; value) {
 7481         onMousePressedProperty().set(value);
 7482     }
 7483 
 7484     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
 7485         return (eventHandlerProperties == null)
 7486                 ? null : eventHandlerProperties.getOnMousePressed();
 7487     }
 7488 
 7489     /**
 7490      * Defines a function to be called when a mouse button
 7491      * has been pressed on this {@code Node}.
 7492      * @return the event handler that is called when a mouse button has been
 7493      * pressed on this {@code Node}
 7494      */
 7495     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7496             onMousePressedProperty() {
 7497         return getEventHandlerProperties().onMousePressedProperty();
 7498     }
 7499 
 7500     public final void setOnMouseReleased(
 7501             EventHandler&lt;? super MouseEvent&gt; value) {
 7502         onMouseReleasedProperty().set(value);
 7503     }
 7504 
 7505     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
 7506         return (eventHandlerProperties == null)
 7507                 ? null : eventHandlerProperties.getOnMouseReleased();
 7508     }
 7509 
 7510     /**
 7511      * Defines a function to be called when a mouse button
 7512      * has been released on this {@code Node}.
 7513      * @return the event handler that is called when a mouse button has been
 7514      * released on this {@code Node}
 7515      */
 7516     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7517             onMouseReleasedProperty() {
 7518         return getEventHandlerProperties().onMouseReleasedProperty();
 7519     }
 7520 
 7521     public final void setOnDragDetected(
 7522             EventHandler&lt;? super MouseEvent&gt; value) {
 7523         onDragDetectedProperty().set(value);
 7524     }
 7525 
 7526     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
 7527         return (eventHandlerProperties == null)
 7528                 ? null : eventHandlerProperties.getOnDragDetected();
 7529     }
 7530 
 7531     /**
 7532      * Defines a function to be called when drag gesture has been
 7533      * detected. This is the right place to start drag and drop operation.
 7534      * @return the event handler that is called when drag gesture has been
 7535      * detected
 7536      */
 7537     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
 7538             onDragDetectedProperty() {
 7539         return getEventHandlerProperties().onDragDetectedProperty();
 7540     }
 7541 
 7542     public final void setOnMouseDragOver(
 7543             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7544         onMouseDragOverProperty().set(value);
 7545     }
 7546 
 7547     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
 7548         return (eventHandlerProperties == null)
 7549                 ? null : eventHandlerProperties.getOnMouseDragOver();
 7550     }
 7551 
 7552     /**
 7553      * Defines a function to be called when a full press-drag-release gesture
 7554      * progresses within this {@code Node}.
 7555      * @return the event handler that is called when a full press-drag-release
 7556      * gesture progresses within this {@code Node}
 7557      * @since JavaFX 2.1
 7558      */
 7559     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7560             onMouseDragOverProperty() {
 7561         return getEventHandlerProperties().onMouseDragOverProperty();
 7562     }
 7563 
 7564     public final void setOnMouseDragReleased(
 7565             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7566         onMouseDragReleasedProperty().set(value);
 7567     }
 7568 
 7569     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
 7570         return (eventHandlerProperties == null)
 7571                 ? null : eventHandlerProperties.getOnMouseDragReleased();
 7572     }
 7573 
 7574     /**
 7575      * Defines a function to be called when a full press-drag-release gesture
 7576      * ends (by releasing mouse button) within this {@code Node}.
 7577      * @return the event handler that is called when a full press-drag-release
 7578      * gesture ends (by releasing mouse button) within this {@code Node}
 7579      * @since JavaFX 2.1
 7580      */
 7581     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7582             onMouseDragReleasedProperty() {
 7583         return getEventHandlerProperties().onMouseDragReleasedProperty();
 7584     }
 7585 
 7586     public final void setOnMouseDragEntered(
 7587             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7588         onMouseDragEnteredProperty().set(value);
 7589     }
 7590 
 7591     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
 7592         return (eventHandlerProperties == null)
 7593                 ? null : eventHandlerProperties.getOnMouseDragEntered();
 7594     }
 7595 
 7596     /**
 7597      * Defines a function to be called when a full press-drag-release gesture
 7598      * enters this {@code Node}.
 7599      * @return the event handler that is called when a full press-drag-release
 7600      * gesture enters this {@code Node}
 7601      * @since JavaFX 2.1
 7602      */
 7603     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7604             onMouseDragEnteredProperty() {
 7605         return getEventHandlerProperties().onMouseDragEnteredProperty();
 7606     }
 7607 
 7608     public final void setOnMouseDragExited(
 7609             EventHandler&lt;? super MouseDragEvent&gt; value) {
 7610         onMouseDragExitedProperty().set(value);
 7611     }
 7612 
 7613     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
 7614         return (eventHandlerProperties == null)
 7615                 ? null : eventHandlerProperties.getOnMouseDragExited();
 7616     }
 7617 
 7618     /**
 7619      * Defines a function to be called when a full press-drag-release gesture
 7620      * leaves this {@code Node}.
 7621      * @return the event handler that is called when a full press-drag-release
 7622      * gesture leaves this {@code Node}
 7623      * @since JavaFX 2.1
 7624      */
 7625     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
 7626             onMouseDragExitedProperty() {
 7627         return getEventHandlerProperties().onMouseDragExitedProperty();
 7628     }
 7629 
 7630 
 7631     /* *************************************************************************
 7632      *                                                                         *
 7633      *                           Gestures Handling                             *
 7634      *                                                                         *
 7635      **************************************************************************/
 7636 
 7637     public final void setOnScrollStarted(
 7638             EventHandler&lt;? super ScrollEvent&gt; value) {
 7639         onScrollStartedProperty().set(value);
 7640     }
 7641 
 7642     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
 7643         return (eventHandlerProperties == null)
 7644                 ? null : eventHandlerProperties.getOnScrollStarted();
 7645     }
 7646 
 7647     /**
 7648      * Defines a function to be called when a scrolling gesture is detected.
 7649      * @return the event handler that is called when a scrolling gesture is
 7650      * detected
 7651      * @since JavaFX 2.2
 7652      */
 7653     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7654             onScrollStartedProperty() {
 7655         return getEventHandlerProperties().onScrollStartedProperty();
 7656     }
 7657 
 7658     public final void setOnScroll(
 7659             EventHandler&lt;? super ScrollEvent&gt; value) {
 7660         onScrollProperty().set(value);
 7661     }
 7662 
 7663     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
 7664         return (eventHandlerProperties == null)
 7665                 ? null : eventHandlerProperties.getOnScroll();
 7666     }
 7667 
 7668     /**
 7669      * Defines a function to be called when user performs a scrolling action.
 7670      * @return the event handler that is called when user performs a scrolling
 7671      * action
 7672      */
 7673     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7674             onScrollProperty() {
 7675         return getEventHandlerProperties().onScrollProperty();
 7676     }
 7677 
 7678     public final void setOnScrollFinished(
 7679             EventHandler&lt;? super ScrollEvent&gt; value) {
 7680         onScrollFinishedProperty().set(value);
 7681     }
 7682 
 7683     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
 7684         return (eventHandlerProperties == null)
 7685                 ? null : eventHandlerProperties.getOnScrollFinished();
 7686     }
 7687 
 7688     /**
 7689      * Defines a function to be called when a scrolling gesture ends.
 7690      * @return the event handler that is called when a scrolling gesture ends
 7691      * @since JavaFX 2.2
 7692      */
 7693     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
 7694             onScrollFinishedProperty() {
 7695         return getEventHandlerProperties().onScrollFinishedProperty();
 7696     }
 7697 
 7698     public final void setOnRotationStarted(
 7699             EventHandler&lt;? super RotateEvent&gt; value) {
 7700         onRotationStartedProperty().set(value);
 7701     }
 7702 
 7703     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
 7704         return (eventHandlerProperties == null)
 7705                 ? null : eventHandlerProperties.getOnRotationStarted();
 7706     }
 7707 
 7708     /**
 7709      * Defines a function to be called when a rotation gesture is detected.
 7710      * @return the event handler that is called when a rotation gesture is
 7711      * detected
 7712      * @since JavaFX 2.2
 7713      */
 7714     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7715             onRotationStartedProperty() {
 7716         return getEventHandlerProperties().onRotationStartedProperty();
 7717     }
 7718 
 7719     public final void setOnRotate(
 7720             EventHandler&lt;? super RotateEvent&gt; value) {
 7721         onRotateProperty().set(value);
 7722     }
 7723 
 7724     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
 7725         return (eventHandlerProperties == null)
 7726                 ? null : eventHandlerProperties.getOnRotate();
 7727     }
 7728 
 7729     /**
 7730      * Defines a function to be called when user performs a rotation action.
 7731      * @return the event handler that is called when user performs a rotation
 7732      * action
 7733      * @since JavaFX 2.2
 7734      */
 7735     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7736             onRotateProperty() {
 7737         return getEventHandlerProperties().onRotateProperty();
 7738     }
 7739 
 7740     public final void setOnRotationFinished(
 7741             EventHandler&lt;? super RotateEvent&gt; value) {
 7742         onRotationFinishedProperty().set(value);
 7743     }
 7744 
 7745     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
 7746         return (eventHandlerProperties == null)
 7747                 ? null : eventHandlerProperties.getOnRotationFinished();
 7748     }
 7749 
 7750     /**
 7751      * Defines a function to be called when a rotation gesture ends.
 7752      * @return the event handler that is called when a rotation gesture ends
 7753      * @since JavaFX 2.2
 7754      */
 7755     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
 7756             onRotationFinishedProperty() {
 7757         return getEventHandlerProperties().onRotationFinishedProperty();
 7758     }
 7759 
 7760     public final void setOnZoomStarted(
 7761             EventHandler&lt;? super ZoomEvent&gt; value) {
 7762         onZoomStartedProperty().set(value);
 7763     }
 7764 
 7765     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
 7766         return (eventHandlerProperties == null)
 7767                 ? null : eventHandlerProperties.getOnZoomStarted();
 7768     }
 7769 
 7770     /**
 7771      * Defines a function to be called when a zooming gesture is detected.
 7772      * @return the event handler that is called when a zooming gesture is
 7773      * detected
 7774      * @since JavaFX 2.2
 7775      */
 7776     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7777             onZoomStartedProperty() {
 7778         return getEventHandlerProperties().onZoomStartedProperty();
 7779     }
 7780 
 7781     public final void setOnZoom(
 7782             EventHandler&lt;? super ZoomEvent&gt; value) {
 7783         onZoomProperty().set(value);
 7784     }
 7785 
 7786     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
 7787         return (eventHandlerProperties == null)
 7788                 ? null : eventHandlerProperties.getOnZoom();
 7789     }
 7790 
 7791     /**
 7792      * Defines a function to be called when user performs a zooming action.
 7793      * @return the event handler that is called when user performs a zooming
 7794      * action
 7795      * @since JavaFX 2.2
 7796      */
 7797     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7798             onZoomProperty() {
 7799         return getEventHandlerProperties().onZoomProperty();
 7800     }
 7801 
 7802     public final void setOnZoomFinished(
 7803             EventHandler&lt;? super ZoomEvent&gt; value) {
 7804         onZoomFinishedProperty().set(value);
 7805     }
 7806 
 7807     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
 7808         return (eventHandlerProperties == null)
 7809                 ? null : eventHandlerProperties.getOnZoomFinished();
 7810     }
 7811 
 7812     /**
 7813      * Defines a function to be called when a zooming gesture ends.
 7814      * @return the event handler that is called when a zooming gesture ends
 7815      * @since JavaFX 2.2
 7816      */
 7817     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
 7818             onZoomFinishedProperty() {
 7819         return getEventHandlerProperties().onZoomFinishedProperty();
 7820     }
 7821 
 7822     public final void setOnSwipeUp(
 7823             EventHandler&lt;? super SwipeEvent&gt; value) {
 7824         onSwipeUpProperty().set(value);
 7825     }
 7826 
 7827     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
 7828         return (eventHandlerProperties == null)
 7829                 ? null : eventHandlerProperties.getOnSwipeUp();
 7830     }
 7831 
 7832     /**
 7833      * Defines a function to be called when an upward swipe gesture
 7834      * centered over this node happens.
 7835      * @return the event handler that is called when an upward swipe gesture
 7836      * centered over this node happens
 7837      * @since JavaFX 2.2
 7838      */
 7839     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7840             onSwipeUpProperty() {
 7841         return getEventHandlerProperties().onSwipeUpProperty();
 7842     }
 7843 
 7844     public final void setOnSwipeDown(
 7845             EventHandler&lt;? super SwipeEvent&gt; value) {
 7846         onSwipeDownProperty().set(value);
 7847     }
 7848 
 7849     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
 7850         return (eventHandlerProperties == null)
 7851                 ? null : eventHandlerProperties.getOnSwipeDown();
 7852     }
 7853 
 7854     /**
 7855      * Defines a function to be called when a downward swipe gesture
 7856      * centered over this node happens.
 7857      * @return the event handler that is called when a downward swipe gesture
 7858      * centered over this node happens
 7859      * @since JavaFX 2.2
 7860      */
 7861     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7862             onSwipeDownProperty() {
 7863         return getEventHandlerProperties().onSwipeDownProperty();
 7864     }
 7865 
 7866     public final void setOnSwipeLeft(
 7867             EventHandler&lt;? super SwipeEvent&gt; value) {
 7868         onSwipeLeftProperty().set(value);
 7869     }
 7870 
 7871     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
 7872         return (eventHandlerProperties == null)
 7873                 ? null : eventHandlerProperties.getOnSwipeLeft();
 7874     }
 7875 
 7876     /**
 7877      * Defines a function to be called when a leftward swipe gesture
 7878      * centered over this node happens.
 7879      * @return the event handler that is called when a leftward swipe gesture
 7880      * centered over this node happens
 7881      * @since JavaFX 2.2
 7882      */
 7883     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7884             onSwipeLeftProperty() {
 7885         return getEventHandlerProperties().onSwipeLeftProperty();
 7886     }
 7887 
 7888     public final void setOnSwipeRight(
 7889             EventHandler&lt;? super SwipeEvent&gt; value) {
 7890         onSwipeRightProperty().set(value);
 7891     }
 7892 
 7893     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
 7894         return (eventHandlerProperties == null)
 7895                 ? null : eventHandlerProperties.getOnSwipeRight();
 7896     }
 7897 
 7898     /**
 7899      * Defines a function to be called when an rightward swipe gesture
 7900      * centered over this node happens.
 7901      * @return the event handler that is called when an rightward swipe gesture
 7902      * centered over this node happens
 7903      * @since JavaFX 2.2
 7904      */
 7905     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
 7906             onSwipeRightProperty() {
 7907         return getEventHandlerProperties().onSwipeRightProperty();
 7908     }
 7909 
 7910 
 7911     /* *************************************************************************
 7912      *                                                                         *
 7913      *                             Touch Handling                              *
 7914      *                                                                         *
 7915      **************************************************************************/
 7916 
 7917     public final void setOnTouchPressed(
 7918             EventHandler&lt;? super TouchEvent&gt; value) {
 7919         onTouchPressedProperty().set(value);
 7920     }
 7921 
 7922     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
 7923         return (eventHandlerProperties == null)
 7924                 ? null : eventHandlerProperties.getOnTouchPressed();
 7925     }
 7926 
 7927     /**
 7928      * Defines a function to be called when a new touch point is pressed.
 7929      * @return the event handler that is called when a new touch point is pressed
 7930      * @since JavaFX 2.2
 7931      */
 7932     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7933             onTouchPressedProperty() {
 7934         return getEventHandlerProperties().onTouchPressedProperty();
 7935     }
 7936 
 7937     public final void setOnTouchMoved(
 7938             EventHandler&lt;? super TouchEvent&gt; value) {
 7939         onTouchMovedProperty().set(value);
 7940     }
 7941 
 7942     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
 7943         return (eventHandlerProperties == null)
 7944                 ? null : eventHandlerProperties.getOnTouchMoved();
 7945     }
 7946 
 7947     /**
 7948      * Defines a function to be called when a touch point is moved.
 7949      * @return the event handler that is called when a touch point is moved
 7950      * @since JavaFX 2.2
 7951      */
 7952     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7953             onTouchMovedProperty() {
 7954         return getEventHandlerProperties().onTouchMovedProperty();
 7955     }
 7956 
 7957     public final void setOnTouchReleased(
 7958             EventHandler&lt;? super TouchEvent&gt; value) {
 7959         onTouchReleasedProperty().set(value);
 7960     }
 7961 
 7962     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
 7963         return (eventHandlerProperties == null)
 7964                 ? null : eventHandlerProperties.getOnTouchReleased();
 7965     }
 7966 
 7967     /**
 7968      * Defines a function to be called when a touch point is released.
 7969      * @return the event handler that is called when a touch point is released
 7970      * @since JavaFX 2.2
 7971      */
 7972     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7973             onTouchReleasedProperty() {
 7974         return getEventHandlerProperties().onTouchReleasedProperty();
 7975     }
 7976 
 7977     public final void setOnTouchStationary(
 7978             EventHandler&lt;? super TouchEvent&gt; value) {
 7979         onTouchStationaryProperty().set(value);
 7980     }
 7981 
 7982     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
 7983         return (eventHandlerProperties == null)
 7984                 ? null : eventHandlerProperties.getOnTouchStationary();
 7985     }
 7986 
 7987     /**
 7988      * Defines a function to be called when a touch point stays pressed and
 7989      * still.
 7990      * @return the event handler that is called when a touch point stays pressed
 7991      * and still
 7992      * @since JavaFX 2.2
 7993      */
 7994     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
 7995             onTouchStationaryProperty() {
 7996         return getEventHandlerProperties().onTouchStationaryProperty();
 7997     }
 7998 
 7999     /* *************************************************************************
 8000      *                                                                         *
 8001      *                           Keyboard Handling                             *
 8002      *                                                                         *
 8003      **************************************************************************/
 8004 
 8005     public final void setOnKeyPressed(
 8006             EventHandler&lt;? super KeyEvent&gt; value) {
 8007         onKeyPressedProperty().set(value);
 8008     }
 8009 
 8010     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
 8011         return (eventHandlerProperties == null)
 8012                 ? null : eventHandlerProperties.getOnKeyPressed();
 8013     }
 8014 
 8015     /**
 8016      * Defines a function to be called when this {@code Node} or its child
 8017      * {@code Node} has input focus and a key has been pressed. The function
 8018      * is called only if the event hasn&#39;t been already consumed during its
 8019      * capturing or bubbling phase.
 8020      * @return the event handler that is called when this {@code Node} or its
 8021      * child {@code Node} has input focus and a key has been pressed
 8022      */
 8023     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8024             onKeyPressedProperty() {
 8025         return getEventHandlerProperties().onKeyPressedProperty();
 8026     }
 8027 
 8028     public final void setOnKeyReleased(
 8029             EventHandler&lt;? super KeyEvent&gt; value) {
 8030         onKeyReleasedProperty().set(value);
 8031     }
 8032 
 8033     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
 8034         return (eventHandlerProperties == null)
 8035                 ? null : eventHandlerProperties.getOnKeyReleased();
 8036     }
 8037 
 8038     /**
 8039      * Defines a function to be called when this {@code Node} or its child
 8040      * {@code Node} has input focus and a key has been released. The function
 8041      * is called only if the event hasn&#39;t been already consumed during its
 8042      * capturing or bubbling phase.
 8043      * @return the event handler that is called when this {@code Node} or its
 8044      * child {@code Node} has input focus and a key has been released
 8045      */
 8046     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8047             onKeyReleasedProperty() {
 8048         return getEventHandlerProperties().onKeyReleasedProperty();
 8049     }
 8050 
 8051     public final void setOnKeyTyped(
 8052             EventHandler&lt;? super KeyEvent&gt; value) {
 8053         onKeyTypedProperty().set(value);
 8054     }
 8055 
 8056     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
 8057         return (eventHandlerProperties == null)
 8058                 ? null : eventHandlerProperties.getOnKeyTyped();
 8059     }
 8060 
 8061     /**
 8062      * Defines a function to be called when this {@code Node} or its child
 8063      * {@code Node} has input focus and a key has been typed. The function
 8064      * is called only if the event hasn&#39;t been already consumed during its
 8065      * capturing or bubbling phase.
 8066      * @return the event handler that is called when this {@code Node} or its
 8067      * child {@code Node} has input focus and a key has been typed
 8068      */
 8069     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
 8070             onKeyTypedProperty() {
 8071         return getEventHandlerProperties().onKeyTypedProperty();
 8072     }
 8073 
 8074     /* *************************************************************************
 8075      *                                                                         *
 8076      *                           Input Method Handling                         *
 8077      *                                                                         *
 8078      **************************************************************************/
 8079 
 8080     public final void setOnInputMethodTextChanged(
 8081             EventHandler&lt;? super InputMethodEvent&gt; value) {
 8082         onInputMethodTextChangedProperty().set(value);
 8083     }
 8084 
 8085     public final EventHandler&lt;? super InputMethodEvent&gt;
 8086             getOnInputMethodTextChanged() {
 8087         return (eventHandlerProperties == null)
 8088                 ? null : eventHandlerProperties.getOnInputMethodTextChanged();
 8089     }
 8090 
 8091     /**
 8092      * Defines a function to be called when this {@code Node}
 8093      * has input focus and the input method text has changed.  If this
 8094      * function is not defined in this {@code Node}, then it
 8095      * receives the result string of the input method composition as a
 8096      * series of {@code onKeyTyped} function calls.
 8097      * &lt;p&gt;
 8098      * When the {@code Node} loses the input focus, the JavaFX runtime
 8099      * automatically commits the existing composed text if any.
 8100      * &lt;/p&gt;
 8101      * @return the event handler that is called when this {@code Node} has input
 8102      * focus and the input method text has changed
 8103      */
 8104     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
 8105             onInputMethodTextChangedProperty() {
 8106         return getEventHandlerProperties().onInputMethodTextChangedProperty();
 8107     }
 8108 
 8109     public final void setInputMethodRequests(InputMethodRequests value) {
 8110         inputMethodRequestsProperty().set(value);
 8111     }
 8112 
 8113     public final InputMethodRequests getInputMethodRequests() {
 8114         return (miscProperties == null)
 8115                        ? DEFAULT_INPUT_METHOD_REQUESTS
 8116                        : miscProperties.getInputMethodRequests();
 8117     }
 8118 
 8119     /**
 8120      * Property holding InputMethodRequests.
 8121      *
 8122      * @return InputMethodRequestsProperty
 8123      */
 8124     public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
 8125         return getMiscProperties().inputMethodRequestsProperty();
 8126     }
 8127 
 8128     /***************************************************************************
 8129      *                                                                         *
 8130      *                             Focus Traversal                             *
 8131      *                                                                         *
 8132      **************************************************************************/
 8133 
 8134     /**
 8135      * Special boolean property which allows for atomic focus change.
 8136      * Focus change means defocusing the old focus owner and focusing a new
 8137      * one. With a usual property, defocusing the old node fires the value
 8138      * changed event and user code can react with something that breaks
 8139      * focusability of the new node, or even remove the new node from the scene.
 8140      * This leads to various error states. This property allows for setting
 8141      * the state without firing the event. The focus change first sets both
 8142      * properties and then fires both events. This makes the focus change look
 8143      * like an atomic operation - when the old node is notified to loose focus,
 8144      * the new node is already focused.
 8145      */
 8146     final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
 8147         private boolean value;
 8148         private boolean valid = true;
 8149         private boolean needsChangeEvent = false;
 8150 
 8151         public void store(final boolean value) {
 8152             if (value != this.value) {
 8153                 this.value = value;
 8154                 markInvalid();
 8155             }
 8156         }
 8157 
 8158         public void notifyListeners() {
 8159             if (needsChangeEvent) {
 8160                 fireValueChangedEvent();
 8161                 needsChangeEvent = false;
 8162             }
 8163         }
 8164 
 8165         private void markInvalid() {
 8166             if (valid) {
 8167                 valid = false;
 8168 
 8169                 pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
 8170                 PlatformLogger logger = Logging.getFocusLogger();
 8171                 if (logger.isLoggable(Level.FINE)) {
 8172                     logger.fine(this + &quot; focused=&quot; + get());
 8173                 }
 8174 
 8175                 needsChangeEvent = true;
 8176 
 8177                 notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
 8178             }
 8179         }
 8180 
 8181         @Override
 8182         public boolean get() {
 8183             valid = true;
 8184             return value;
 8185         }
 8186 
 8187         @Override
 8188         public Object getBean() {
 8189             return Node.this;
 8190         }
 8191 
 8192         @Override
 8193         public String getName() {
 8194             return &quot;focused&quot;;
 8195         }
 8196     }
 8197 
 8198     /**
 8199      * Indicates whether this {@code Node} currently has the input focus.
 8200      * To have the input focus, a node must be the {@code Scene}&#39;s focus
 8201      * owner, and the scene must be in a {@code Stage} that is visible
 8202      * and active. See {@link #requestFocus()} for more information.
 8203      *
 8204      * @see #requestFocus()
 8205      * @defaultValue false
 8206      */
 8207     private FocusedProperty focused;
 8208 
 8209     protected final void setFocused(boolean value) {
 8210         FocusedProperty fp = focusedPropertyImpl();
 8211         if (fp.value != value) {
 8212             fp.store(value);
 8213             fp.notifyListeners();
 8214         }
 8215     }
 8216 
 8217     public final boolean isFocused() {
 8218         return focused == null ? false : focused.get();
 8219     }
 8220 
 8221     public final ReadOnlyBooleanProperty focusedProperty() {
 8222         return focusedPropertyImpl();
 8223     }
 8224 
 8225     private FocusedProperty focusedPropertyImpl() {
 8226         if (focused == null) {
 8227             focused = new FocusedProperty();
 8228         }
 8229         return focused;
 8230     }
 8231 
 8232     /**
 8233      * Specifies whether this {@code Node} should be a part of focus traversal
 8234      * cycle. When this property is {@code true} focus can be moved to this
 8235      * {@code Node} and from this {@code Node} using regular focus traversal
 8236      * keys. On a desktop such keys are usually {@code TAB} for moving focus
 8237      * forward and {@code SHIFT+TAB} for moving focus backward.
 8238      *
 8239      * When a {@code Scene} is created, the system gives focus to a
 8240      * {@code Node} whose {@code focusTraversable} variable is true
 8241      * and that is eligible to receive the focus,
 8242      * unless the focus had been set explicitly via a call
 8243      * to {@link #requestFocus()}.
 8244      *
 8245      * @see #requestFocus()
 8246      * @defaultValue false
 8247      */
 8248     private BooleanProperty focusTraversable;
 8249 
 8250     public final void setFocusTraversable(boolean value) {
 8251         focusTraversableProperty().set(value);
 8252     }
 8253     public final boolean isFocusTraversable() {
 8254         return focusTraversable == null ? false : focusTraversable.get();
 8255     }
 8256 
 8257     public final BooleanProperty focusTraversableProperty() {
 8258         if (focusTraversable == null) {
 8259             focusTraversable = new StyleableBooleanProperty(false) {
 8260 
 8261                 @Override
 8262                 public void invalidated() {
 8263                     Scene _scene = getScene();
 8264                     if (_scene != null) {
 8265                         if (get()) {
 8266                             _scene.initializeInternalEventDispatcher();
 8267                         }
 8268                         focusSetDirty(_scene);
 8269                     }
 8270                 }
 8271 
 8272                 @Override
 8273                 public CssMetaData getCssMetaData() {
 8274                     return StyleableProperties.FOCUS_TRAVERSABLE;
 8275                 }
 8276 
 8277                 @Override
 8278                 public Object getBean() {
 8279                     return Node.this;
 8280                 }
 8281 
 8282                 @Override
 8283                 public String getName() {
 8284                     return &quot;focusTraversable&quot;;
 8285                 }
 8286             };
 8287         }
 8288         return focusTraversable;
 8289     }
 8290 
 8291     /**
 8292      * Called when something has changed on this node that *may* have made the
 8293      * scene&#39;s focus dirty. This covers the cases where this node is the focus
 8294      * owner and it may have lost eligibility, or it&#39;s traversable and it may
 8295      * have gained eligibility. Note that we do not want to use disabled
 8296      * or treeVisible here, as this function is called from their
 8297      * &quot;on invalidate&quot; triggers, and using them will cause them to be
 8298      * revalidated. The pulse will revalidate everything and make the final
 8299      * determination.
 8300      */
 8301     private void focusSetDirty(Scene s) {
 8302         if (s != null &amp;&amp;
 8303             (this == s.getFocusOwner() || isFocusTraversable())) {
 8304                 s.setFocusDirty(true);
 8305         }
 8306     }
 8307 
 8308     /**
 8309      * Requests that this {@code Node} get the input focus, and that this
 8310      * {@code Node}&#39;s top-level ancestor become the focused window. To be
 8311      * eligible to receive the focus, the node must be part of a scene, it and
 8312      * all of its ancestors must be visible, and it must not be disabled.
 8313      * If this node is eligible, this function will cause it to become this
 8314      * {@code Scene}&#39;s &quot;focus owner&quot;. Each scene has at most one focus owner
 8315      * node. The focus owner will not actually have the input focus, however,
 8316      * unless the scene belongs to a {@code Stage} that is both visible
 8317      * and active.
 8318      */
 8319     public void requestFocus() {
 8320         if (getScene() != null) {
 8321             getScene().requestFocus(this);
 8322         }
 8323     }
 8324 
 8325     /**
 8326      * Traverses from this node in the direction indicated. Note that this
 8327      * node need not actually have the focus, nor need it be focusTraversable.
 8328      * However, the node must be part of a scene, otherwise this request
 8329      * is ignored.
 8330      */
 8331     final boolean traverse(Direction dir) {
 8332         if (getScene() == null) {
 8333             return false;
 8334         }
 8335         return getScene().traverse(this, dir);
 8336     }
 8337 
 8338     ////////////////////////////
 8339     //  Private Implementation
 8340     ////////////////////////////
 8341 
 8342      /**
 8343       * Returns a string representation for the object.
 8344       * @return a string representation for the object.
 8345       */
 8346     @Override
 8347     public String toString() {
 8348         String klassName = getClass().getName();
 8349         String simpleName = klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
 8350         StringBuilder sbuf = new StringBuilder(simpleName);
 8351         boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
 8352         boolean hasStyleClass = !getStyleClass().isEmpty();
 8353 
 8354         if (!hasId) {
 8355             sbuf.append(&#39;@&#39;);
 8356             sbuf.append(Integer.toHexString(hashCode()));
 8357         } else {
 8358             sbuf.append(&quot;[id=&quot;);
 8359             sbuf.append(getId());
 8360             if (!hasStyleClass) sbuf.append(&quot;]&quot;);
 8361         }
 8362         if (hasStyleClass) {
 8363             if (!hasId) sbuf.append(&#39;[&#39;);
 8364             else sbuf.append(&quot;, &quot;);
 8365             sbuf.append(&quot;styleClass=&quot;);
 8366             sbuf.append(getStyleClass());
 8367             sbuf.append(&quot;]&quot;);
 8368         }
 8369         return sbuf.toString();
 8370     }
 8371 
 8372     private void preprocessMouseEvent(MouseEvent e) {
 8373         final EventType&lt;?&gt; eventType = e.getEventType();
 8374         if (eventType == MouseEvent.MOUSE_PRESSED) {
 8375             for (Node n = this; n != null; n = n.getParent()) {
 8376                 n.setPressed(e.isPrimaryButtonDown());
 8377             }
 8378             return;
 8379         }
 8380         if (eventType == MouseEvent.MOUSE_RELEASED) {
 8381             for (Node n = this; n != null; n = n.getParent()) {
 8382                 n.setPressed(e.isPrimaryButtonDown());
 8383             }
 8384             return;
 8385         }
 8386 
 8387         if (e.getTarget() == this) {
 8388             // the mouse event types are translated only when the node uses
 8389             // its internal event dispatcher, so both entered / exited variants
 8390             // are possible here
 8391 
 8392             if ((eventType == MouseEvent.MOUSE_ENTERED)
 8393                     || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
 8394                 setHover(true);
 8395                 return;
 8396             }
 8397 
 8398             if ((eventType == MouseEvent.MOUSE_EXITED)
 8399                     || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
 8400                 setHover(false);
 8401                 return;
 8402             }
 8403         }
 8404     }
 8405 
 8406     void markDirtyLayoutBranch() {
 8407         Parent p = getParent();
 8408         while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
 8409             p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
 8410             if (p.isSceneRoot()) {
 8411                 Toolkit.getToolkit().requestNextPulse();
 8412                 if (getSubScene() != null) {
 8413                     getSubScene().setDirtyLayout(p);
 8414                 }
 8415             }
 8416             p = p.getParent();
 8417         }
 8418 
 8419     }
 8420 
 8421     private boolean isWindowShowing() {
 8422         Scene s = getScene();
 8423         if (s == null) return false;
 8424         Window w = s.getWindow();
 8425         return w != null &amp;&amp; w.isShowing();
 8426     }
 8427 
 8428     private void updateTreeShowing() {
 8429         setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
 8430     }
 8431 
 8432     private boolean treeShowing;
 8433     private TreeShowingPropertyReadOnly treeShowingRO;
 8434 
 8435     final void setTreeShowing(boolean value) {
 8436         if (treeShowing != value) {
 8437             treeShowing = value;
 8438             ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
 8439         }
 8440     }
 8441 
 8442     final boolean isTreeShowing() {
 8443         return treeShowingProperty().get();
 8444     }
 8445 
 8446     final BooleanExpression treeShowingProperty() {
 8447         if (treeShowingRO == null) {
 8448             treeShowingRO = new TreeShowingPropertyReadOnly();
 8449         }
 8450         return treeShowingRO;
 8451     }
 8452 
 8453     class TreeShowingPropertyReadOnly extends BooleanExpression {
 8454 
 8455         private ExpressionHelper&lt;Boolean&gt; helper;
 8456         private boolean valid;
 8457 
 8458         @Override
 8459         public void addListener(InvalidationListener listener) {
 8460             helper = ExpressionHelper.addListener(helper, this, listener);
 8461         }
 8462 
 8463         @Override
 8464         public void removeListener(InvalidationListener listener) {
 8465             helper = ExpressionHelper.removeListener(helper, listener);
 8466         }
 8467 
 8468         @Override
 8469         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8470             helper = ExpressionHelper.addListener(helper, this, listener);
 8471         }
 8472 
 8473         @Override
 8474         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8475             helper = ExpressionHelper.removeListener(helper, listener);
 8476         }
 8477 
 8478         protected void invalidate() {
 8479             if (valid) {
 8480                 valid = false;
 8481                 ExpressionHelper.fireValueChangedEvent(helper);
 8482             }
 8483         }
 8484 
 8485         @Override
 8486         public boolean get() {
 8487             valid = true;
 8488             return Node.this.treeShowing;
 8489         }
 8490 
 8491     }
 8492 
 8493     private void updateTreeVisible(boolean parentChanged) {
 8494         boolean isTreeVisible = isVisible();
 8495         final Node parentNode = getParent() != null ? getParent() :
 8496                     clipParent != null ? clipParent :
 8497                     getSubScene() != null ? getSubScene() : null;
 8498         if (isTreeVisible) {
 8499             isTreeVisible = parentNode == null || parentNode.isTreeVisible();
 8500         }
 8501         // When the parent has changed to visible and we have unsynchronized visibility,
 8502         // we have to synchronize, because the rendering will now pass through the newly-visible parent
 8503         // Otherwise an invisible Node might get rendered
 8504         if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
 8505                 &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
 8506             addToSceneDirtyList();
 8507         }
 8508         setTreeVisible(isTreeVisible);
 8509 
 8510         updateTreeShowing();
 8511     }
 8512 
 8513     private boolean treeVisible;
 8514     private TreeVisiblePropertyReadOnly treeVisibleRO;
 8515 
 8516     final void setTreeVisible(boolean value) {
 8517         if (treeVisible != value) {
 8518             treeVisible = value;
 8519             updateCanReceiveFocus();
 8520             focusSetDirty(getScene());
 8521             if (getClip() != null) {
 8522                 getClip().updateTreeVisible(true);
 8523             }
 8524             if (treeVisible &amp;&amp; !isDirtyEmpty()) {
 8525                 addToSceneDirtyList();
 8526             }
 8527             ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
 8528             if (Node.this instanceof SubScene) {
 8529                 Node subSceneRoot = ((SubScene)Node.this).getRoot();
 8530                 if (subSceneRoot != null) {
 8531                     // SubScene.getRoot() is only null if it&#39;s constructor
 8532                     // has not finished.
 8533                     subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
 8534                 }
 8535             }
 8536         }
 8537     }
 8538 
 8539     final boolean isTreeVisible() {
 8540         return treeVisibleProperty().get();
 8541     }
 8542 
 8543     final BooleanExpression treeVisibleProperty() {
 8544         if (treeVisibleRO == null) {
 8545             treeVisibleRO = new TreeVisiblePropertyReadOnly();
 8546         }
 8547         return treeVisibleRO;
 8548     }
 8549 
 8550     class TreeVisiblePropertyReadOnly extends BooleanExpression {
 8551 
 8552         private ExpressionHelper&lt;Boolean&gt; helper;
 8553         private boolean valid;
 8554 
 8555         @Override
 8556         public void addListener(InvalidationListener listener) {
 8557             helper = ExpressionHelper.addListener(helper, this, listener);
 8558         }
 8559 
 8560         @Override
 8561         public void removeListener(InvalidationListener listener) {
 8562             helper = ExpressionHelper.removeListener(helper, listener);
 8563         }
 8564 
 8565         @Override
 8566         public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8567             helper = ExpressionHelper.addListener(helper, this, listener);
 8568         }
 8569 
 8570         @Override
 8571         public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
 8572             helper = ExpressionHelper.removeListener(helper, listener);
 8573         }
 8574 
 8575         protected void invalidate() {
 8576             if (valid) {
 8577                 valid = false;
 8578                 ExpressionHelper.fireValueChangedEvent(helper);
 8579             }
 8580         }
 8581 
 8582         @Override
 8583         public boolean get() {
 8584             valid = true;
 8585             return Node.this.treeVisible;
 8586         }
 8587 
 8588     }
 8589 
 8590     private boolean canReceiveFocus = false;
 8591 
 8592     private void setCanReceiveFocus(boolean value) {
 8593         canReceiveFocus = value;
 8594     }
 8595 
 8596     final boolean isCanReceiveFocus() {
 8597         return canReceiveFocus;
 8598     }
 8599 
 8600     private void updateCanReceiveFocus() {
 8601         setCanReceiveFocus(getScene() != null
 8602           &amp;&amp; !isDisabled()
 8603           &amp;&amp; isTreeVisible());
 8604     }
 8605 
 8606     // for indenting messages based on scene-graph depth
 8607     String indent() {
 8608         String indent = &quot;&quot;;
 8609         Parent p = this.getParent();
 8610         while (p != null) {
 8611             indent += &quot;  &quot;;
 8612             p = p.getParent();
 8613         }
 8614         return indent;
 8615     }
 8616 
 8617     /*
 8618      * Should we underline the mnemonic character?
 8619      */
 8620     private BooleanProperty showMnemonics;
 8621 
 8622     final void setShowMnemonics(boolean value) {
 8623         showMnemonicsProperty().set(value);
 8624     }
 8625 
 8626     final boolean isShowMnemonics() {
 8627         return showMnemonics == null ? false : showMnemonics.get();
 8628     }
 8629 
 8630     final BooleanProperty showMnemonicsProperty() {
 8631         if (showMnemonics == null) {
 8632             showMnemonics = new BooleanPropertyBase(false) {
 8633 
 8634                 @Override
 8635                 protected void invalidated() {
 8636                     pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
 8637                 }
 8638 
 8639                 @Override
 8640                 public Object getBean() {
 8641                     return Node.this;
 8642                 }
 8643 
 8644                 @Override
 8645                 public String getName() {
 8646                     return &quot;showMnemonics&quot;;
 8647                 }
 8648             };
 8649         }
 8650         return showMnemonics;
 8651     }
 8652 
 8653 
 8654     /**
 8655      * References a node that is a labelFor this node.
 8656      * Accessible via a NodeAccessor. See Label.labelFor for details.
 8657      */
 8658     private Node labeledBy = null;
 8659 
 8660 
 8661     /***************************************************************************
 8662      *                                                                         *
 8663      *                         Event Dispatch                                  *
 8664      *                                                                         *
 8665      **************************************************************************/
 8666 
 8667     // PENDING_DOC_REVIEW
 8668     /**
 8669      * Specifies the event dispatcher for this node. The default event
 8670      * dispatcher sends the received events to the registered event handlers and
 8671      * filters. When replacing the value with a new {@code EventDispatcher},
 8672      * the new dispatcher should forward events to the replaced dispatcher
 8673      * to maintain the node&#39;s default event handling behavior.
 8674      */
 8675     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
 8676 
 8677     public final void setEventDispatcher(EventDispatcher value) {
 8678         eventDispatcherProperty().set(value);
 8679     }
 8680 
 8681     public final EventDispatcher getEventDispatcher() {
 8682         return eventDispatcherProperty().get();
 8683     }
 8684 
 8685     public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
 8686         initializeInternalEventDispatcher();
 8687         return eventDispatcher;
 8688     }
 8689 
 8690     private NodeEventDispatcher internalEventDispatcher;
 8691 
 8692     // PENDING_DOC_REVIEW
 8693     /**
 8694      * Registers an event handler to this node. The handler is called when the
 8695      * node receives an {@code Event} of the specified type during the bubbling
 8696      * phase of event delivery.
 8697      *
 8698      * @param &lt;T&gt; the specific event class of the handler
 8699      * @param eventType the type of the events to receive by the handler
 8700      * @param eventHandler the handler to register
 8701      * @throws NullPointerException if the event type or handler is null
 8702      */
 8703     public final &lt;T extends Event&gt; void addEventHandler(
 8704             final EventType&lt;T&gt; eventType,
 8705             final EventHandler&lt;? super T&gt; eventHandler) {
 8706         getInternalEventDispatcher().getEventHandlerManager()
 8707                                     .addEventHandler(eventType, eventHandler);
 8708     }
 8709 
 8710     // PENDING_DOC_REVIEW
 8711     /**
 8712      * Unregisters a previously registered event handler from this node. One
 8713      * handler might have been registered for different event types, so the
 8714      * caller needs to specify the particular event type from which to
 8715      * unregister the handler.
 8716      *
 8717      * @param &lt;T&gt; the specific event class of the handler
 8718      * @param eventType the event type from which to unregister
 8719      * @param eventHandler the handler to unregister
 8720      * @throws NullPointerException if the event type or handler is null
 8721      */
 8722     public final &lt;T extends Event&gt; void removeEventHandler(
 8723             final EventType&lt;T&gt; eventType,
 8724             final EventHandler&lt;? super T&gt; eventHandler) {
 8725         getInternalEventDispatcher()
 8726                 .getEventHandlerManager()
 8727                 .removeEventHandler(eventType, eventHandler);
 8728     }
 8729 
 8730     // PENDING_DOC_REVIEW
 8731     /**
 8732      * Registers an event filter to this node. The filter is called when the
 8733      * node receives an {@code Event} of the specified type during the capturing
 8734      * phase of event delivery.
 8735      *
 8736      * @param &lt;T&gt; the specific event class of the filter
 8737      * @param eventType the type of the events to receive by the filter
 8738      * @param eventFilter the filter to register
 8739      * @throws NullPointerException if the event type or filter is null
 8740      */
 8741     public final &lt;T extends Event&gt; void addEventFilter(
 8742             final EventType&lt;T&gt; eventType,
 8743             final EventHandler&lt;? super T&gt; eventFilter) {
 8744         getInternalEventDispatcher().getEventHandlerManager()
 8745                                     .addEventFilter(eventType, eventFilter);
 8746     }
 8747 
 8748     // PENDING_DOC_REVIEW
 8749     /**
 8750      * Unregisters a previously registered event filter from this node. One
 8751      * filter might have been registered for different event types, so the
 8752      * caller needs to specify the particular event type from which to
 8753      * unregister the filter.
 8754      *
 8755      * @param &lt;T&gt; the specific event class of the filter
 8756      * @param eventType the event type from which to unregister
 8757      * @param eventFilter the filter to unregister
 8758      * @throws NullPointerException if the event type or filter is null
 8759      */
 8760     public final &lt;T extends Event&gt; void removeEventFilter(
 8761             final EventType&lt;T&gt; eventType,
 8762             final EventHandler&lt;? super T&gt; eventFilter) {
 8763         getInternalEventDispatcher().getEventHandlerManager()
 8764                                     .removeEventFilter(eventType, eventFilter);
 8765     }
 8766 
 8767     /**
 8768      * Sets the handler to use for this event type. There can only be one such handler
 8769      * specified at a time. This handler is guaranteed to be called as the last, after
 8770      * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
 8771      * This is used for registering the user-defined onFoo event handlers.
 8772      *
 8773      * @param &lt;T&gt; the specific event class of the handler
 8774      * @param eventType the event type to associate with the given eventHandler
 8775      * @param eventHandler the handler to register, or null to unregister
 8776      * @throws NullPointerException if the event type is null
 8777      */
 8778     protected final &lt;T extends Event&gt; void setEventHandler(
 8779             final EventType&lt;T&gt; eventType,
 8780             final EventHandler&lt;? super T&gt; eventHandler) {
 8781         getInternalEventDispatcher().getEventHandlerManager()
 8782                                     .setEventHandler(eventType, eventHandler);
 8783     }
 8784 
 8785     private NodeEventDispatcher getInternalEventDispatcher() {
 8786         initializeInternalEventDispatcher();
 8787         return internalEventDispatcher;
 8788     }
 8789 
 8790     private void initializeInternalEventDispatcher() {
 8791         if (internalEventDispatcher == null) {
 8792             internalEventDispatcher = createInternalEventDispatcher();
 8793             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
 8794                                           Node.this,
 8795                                           &quot;eventDispatcher&quot;,
 8796                                           internalEventDispatcher);
 8797         }
 8798     }
 8799 
 8800     private NodeEventDispatcher createInternalEventDispatcher() {
 8801         return new NodeEventDispatcher(this);
 8802     }
 8803 
 8804     /**
 8805      * Event dispatcher for invoking preprocessing of mouse events
 8806      */
 8807     private EventDispatcher preprocessMouseEventDispatcher;
 8808 
 8809     // PENDING_DOC_REVIEW
 8810     /**
 8811      * Construct an event dispatch chain for this node. The event dispatch chain
 8812      * contains all event dispatchers from the stage to this node.
 8813      *
 8814      * @param tail the initial chain to build from
 8815      * @return the resulting event dispatch chain for this node
 8816      */
 8817     @Override
 8818     public EventDispatchChain buildEventDispatchChain(
 8819             EventDispatchChain tail) {
 8820 
 8821         if (preprocessMouseEventDispatcher == null) {
 8822             preprocessMouseEventDispatcher = (event, tail1) -&gt; {
 8823                 event = tail1.dispatchEvent(event);
 8824                 if (event instanceof MouseEvent) {
 8825                     preprocessMouseEvent((MouseEvent) event);
 8826                 }
 8827 
 8828                 return event;
 8829             };
 8830         }
 8831 
 8832         tail = tail.prepend(preprocessMouseEventDispatcher);
 8833 
 8834         // prepend all event dispatchers from this node to the root
 8835         Node curNode = this;
 8836         do {
 8837             if (curNode.eventDispatcher != null) {
 8838                 final EventDispatcher eventDispatcherValue =
 8839                         curNode.eventDispatcher.get();
 8840                 if (eventDispatcherValue != null) {
 8841                     tail = tail.prepend(eventDispatcherValue);
 8842                 }
 8843             }
 8844             final Node curParent = curNode.getParent();
 8845             curNode = curParent != null ? curParent : curNode.getSubScene();
 8846         } while (curNode != null);
 8847 
 8848         if (getScene() != null) {
 8849             // prepend scene&#39;s dispatch chain
 8850             tail = getScene().buildEventDispatchChain(tail);
 8851         }
 8852 
 8853         return tail;
 8854     }
 8855 
 8856     // PENDING_DOC_REVIEW
 8857     /**
 8858      * Fires the specified event. By default the event will travel through the
 8859      * hierarchy from the stage to this node. Any event filter encountered will
 8860      * be notified and can consume the event. If not consumed by the filters,
 8861      * the event handlers on this node are notified. If these don&#39;t consume the
 8862      * event either, the event will travel back the same path it arrived to
 8863      * this node. All event handlers encountered are called and can consume the
 8864      * event.
 8865      * &lt;p&gt;
 8866      * This method must be called on the FX user thread.
 8867      *
 8868      * @param event the event to fire
 8869      */
 8870     public final void fireEvent(Event event) {
 8871 
 8872         /* Log input events.  We do a coarse filter for at least the FINE
 8873          * level and then granularize from there.
 8874          */
 8875         if (event instanceof InputEvent) {
 8876             PlatformLogger logger = Logging.getInputLogger();
 8877             if (logger.isLoggable(Level.FINE)) {
 8878                 EventType eventType = event.getEventType();
 8879                 if (eventType == MouseEvent.MOUSE_ENTERED ||
 8880                     eventType == MouseEvent.MOUSE_EXITED) {
 8881                     logger.finer(event.toString());
 8882                 } else if (eventType == MouseEvent.MOUSE_MOVED ||
 8883                            eventType == MouseEvent.MOUSE_DRAGGED) {
 8884                     logger.finest(event.toString());
 8885                 } else {
 8886                     logger.fine(event.toString());
 8887                 }
 8888             }
 8889         }
 8890 
 8891         Event.fireEvent(this, event);
 8892     }
 8893 
 8894     /***************************************************************************
 8895      *                                                                         *
 8896      *                         Stylesheet Handling                             *
 8897      *                                                                         *
 8898      **************************************************************************/
 8899 
 8900 
 8901     /**
 8902      * {@inheritDoc}
 8903      * @return {@code getClass().getName()} without the package name
 8904      * @since JavaFX 8.0
 8905      */
 8906     @Override
 8907     public String getTypeSelector() {
 8908 
 8909         final Class&lt;?&gt; clazz = getClass();
 8910         final Package pkg = clazz.getPackage();
 8911 
 8912         // package could be null. not likely, but could be.
 8913         int plen = 0;
 8914         if (pkg != null) {
 8915             plen = pkg.getName().length();
 8916         }
 8917 
 8918         final int clen = clazz.getName().length();
 8919         final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;
 8920 
 8921         return clazz.getName().substring(pos);
 8922     }
 8923 
 8924     /**
 8925      * {@inheritDoc}
 8926      * @return {@code getParent()}
 8927      * @since JavaFX 8.0
 8928      */
 8929     @Override
 8930     public Styleable getStyleableParent() {
 8931         return getParent();
 8932     }
 8933 
 8934 
 8935     /**
 8936      * Returns the initial focus traversable state of this node, for use
 8937      * by the JavaFX CSS engine to correctly set its initial value. This method
 8938      * can be overridden by subclasses in instances where focus traversable should
 8939      * initially be true (as the default implementation of this method is to return
 8940      * false).
 8941      *
 8942      * @return the initial focus traversable state for this {@code Node}.
 8943      * @since 9
 8944      */
 8945     protected Boolean getInitialFocusTraversable() {
 8946         return Boolean.FALSE;
 8947     }
 8948 
 8949     /**
 8950      * Returns the initial cursor state of this node, for use
 8951      * by the JavaFX CSS engine to correctly set its initial value. This method
 8952      * can be overridden by subclasses in instances where the cursor should
 8953      * initially be non-null (as the default implementation of this method is to return
 8954      * null).
 8955      *
 8956      * @return the initial cursor state for this {@code Node}.
 8957      * @since 9
 8958      */
 8959     protected Cursor getInitialCursor() {
 8960         return null;
 8961     }
 8962 
 8963      /**
 8964       * Super-lazy instantiation pattern from Bill Pugh.
 8965       */
 8966      private static class StyleableProperties {
 8967 
 8968         private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
 8969             new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {
 8970 
 8971                 @Override
 8972                 public boolean isSettable(Node node) {
 8973                     return node.miscProperties == null || node.miscProperties.canSetCursor();
 8974                 }
 8975 
 8976                 @Override
 8977                 public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
 8978                     return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
 8979                 }
 8980 
 8981                 @Override
 8982                 public Cursor getInitialValue(Node node) {
 8983                     // Most controls default focusTraversable to true.
 8984                     // Give a way to have them return the correct default value.
 8985                     return node.getInitialCursor();
 8986                 }
 8987 
 8988             };
 8989         private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
 8990             new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {
 8991 
 8992                 @Override
 8993                 public boolean isSettable(Node node) {
 8994                     return node.miscProperties == null || node.miscProperties.canSetEffect();
 8995                 }
 8996 
 8997                 @Override
 8998                 public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
 8999                     return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
 9000                 }
 9001             };
 9002         private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
 9003             new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
 9004                 BooleanConverter.getInstance(), Boolean.FALSE) {
 9005 
 9006                 @Override
 9007                 public boolean isSettable(Node node) {
 9008                     return node.focusTraversable == null || !node.focusTraversable.isBound();
 9009                 }
 9010 
 9011                 @Override
 9012                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9013                     return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
 9014                 }
 9015 
 9016                 @Override
 9017                 public Boolean getInitialValue(Node node) {
 9018                     // Most controls default focusTraversable to true.
 9019                     // Give a way to have them return the correct default value.
 9020                     return node.getInitialFocusTraversable();
 9021                 }
 9022 
 9023             };
 9024         private static final CssMetaData&lt;Node,Number&gt; OPACITY =
 9025             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
 9026                 SizeConverter.getInstance(), 1.0) {
 9027 
 9028                 @Override
 9029                 public boolean isSettable(Node node) {
 9030                     return node.opacity == null || !node.opacity.isBound();
 9031                 }
 9032 
 9033                 @Override
 9034                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9035                     return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
 9036                 }
 9037             };
 9038         private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
 9039             new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {
 9040 
 9041                 @Override
 9042                 public boolean isSettable(Node node) {
 9043                     return node.blendMode == null || !node.blendMode.isBound();
 9044                 }
 9045 
 9046                 @Override
 9047                 public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
 9048                     return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
 9049                 }
 9050             };
 9051         private static final CssMetaData&lt;Node,Number&gt; ROTATE =
 9052             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
 9053                 SizeConverter.getInstance(), 0.0) {
 9054 
 9055                 @Override
 9056                 public boolean isSettable(Node node) {
 9057                     return node.nodeTransformation == null
 9058                         || node.nodeTransformation.rotate == null
 9059                         || node.nodeTransformation.canSetRotate();
 9060                 }
 9061 
 9062                 @Override
 9063                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9064                     return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
 9065                 }
 9066             };
 9067         private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
 9068             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
 9069                 SizeConverter.getInstance(), 1.0) {
 9070 
 9071                 @Override
 9072                 public boolean isSettable(Node node) {
 9073                     return node.nodeTransformation == null
 9074                         || node.nodeTransformation.scaleX == null
 9075                         || node.nodeTransformation.canSetScaleX();
 9076                 }
 9077 
 9078                 @Override
 9079                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9080                     return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
 9081                 }
 9082             };
 9083         private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
 9084             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
 9085                 SizeConverter.getInstance(), 1.0) {
 9086 
 9087                 @Override
 9088                 public boolean isSettable(Node node) {
 9089                     return node.nodeTransformation == null
 9090                         || node.nodeTransformation.scaleY == null
 9091                         || node.nodeTransformation.canSetScaleY();
 9092                 }
 9093 
 9094                 @Override
 9095                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9096                     return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
 9097                 }
 9098             };
 9099         private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
 9100             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
 9101                 SizeConverter.getInstance(), 1.0) {
 9102 
 9103                 @Override
 9104                 public boolean isSettable(Node node) {
 9105                     return node.nodeTransformation == null
 9106                         || node.nodeTransformation.scaleZ == null
 9107                         || node.nodeTransformation.canSetScaleZ();
 9108                 }
 9109 
 9110                 @Override
 9111                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9112                     return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
 9113                 }
 9114             };
 9115         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
 9116             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
 9117                 SizeConverter.getInstance(), 0.0) {
 9118 
 9119                 @Override
 9120                 public boolean isSettable(Node node) {
 9121                     return node.nodeTransformation == null
 9122                         || node.nodeTransformation.translateX == null
 9123                         || node.nodeTransformation.canSetTranslateX();
 9124                 }
 9125 
 9126                 @Override
 9127                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9128                     return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
 9129                 }
 9130             };
 9131         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
 9132             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
 9133                 SizeConverter.getInstance(), 0.0) {
 9134 
 9135                 @Override
 9136                 public boolean isSettable(Node node) {
 9137                     return node.nodeTransformation == null
 9138                         || node.nodeTransformation.translateY == null
 9139                         || node.nodeTransformation.canSetTranslateY();
 9140                 }
 9141 
 9142                 @Override
 9143                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9144                     return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
 9145                 }
 9146             };
 9147         private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
 9148             new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
 9149                 SizeConverter.getInstance(), 0.0) {
 9150 
 9151                 @Override
 9152                 public boolean isSettable(Node node) {
 9153                     return node.nodeTransformation == null
 9154                         || node.nodeTransformation.translateZ == null
 9155                         || node.nodeTransformation.canSetTranslateZ();
 9156                 }
 9157 
 9158                 @Override
 9159                 public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9160                     return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
 9161                 }
 9162             };
 9163          private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
 9164                  = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
 9165                          SizeConverter.getInstance(), 0.0) {
 9166 
 9167                      @Override
 9168                      public boolean isSettable(Node node) {
 9169                          return node.miscProperties == null
 9170                          || node.miscProperties.viewOrder == null
 9171                          || !node.miscProperties.viewOrder.isBound();
 9172                      }
 9173 
 9174                      @Override
 9175                      public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
 9176                          return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
 9177                      }
 9178                  };
 9179         private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
 9180             new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
 9181                 new StyleConverter&lt;String,Boolean&gt;() {
 9182 
 9183                     @Override
 9184                     // [ visible | hidden | collapse | inherit ]
 9185                     public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
 9186                         final String sval = value != null ? value.getValue() : null;
 9187                         return &quot;visible&quot;.equalsIgnoreCase(sval);
 9188                     }
 9189 
 9190                 },
 9191                 Boolean.TRUE) {
 9192 
 9193                 @Override
 9194                 public boolean isSettable(Node node) {
 9195                     return node.visible == null || !node.visible.isBound();
 9196                 }
 9197 
 9198                 @Override
 9199                 public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
 9200                     return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
 9201                 }
 9202             };
 9203 
 9204          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 9205 
 9206          static {
 9207 
 9208              final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 9209                      new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
 9210              styleables.add(CURSOR);
 9211              styleables.add(EFFECT);
 9212              styleables.add(FOCUS_TRAVERSABLE);
 9213              styleables.add(OPACITY);
 9214              styleables.add(BLEND_MODE);
 9215              styleables.add(ROTATE);
 9216              styleables.add(SCALE_X);
 9217              styleables.add(SCALE_Y);
 9218              styleables.add(SCALE_Z);
 9219              styleables.add(VIEW_ORDER);
 9220              styleables.add(TRANSLATE_X);
 9221              styleables.add(TRANSLATE_Y);
 9222              styleables.add(TRANSLATE_Z);
 9223              styleables.add(VISIBILITY);
 9224              STYLEABLES = Collections.unmodifiableList(styleables);
 9225 
 9226          }
 9227     }
 9228 
 9229     /**
 9230      * @return The CssMetaData associated with this class, which may include the
 9231      * CssMetaData of its superclasses.
 9232      * @since JavaFX 8.0
 9233      */
 9234     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 9235         //
 9236         // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
 9237         // is referenced no earlier (and therefore loaded no earlier by the
 9238         // class loader) than the moment that  getClassCssMetaData() is called.
 9239         // This avoids loading the CssMetaData instances until the point at
 9240         // which CSS needs the data.
 9241         //
 9242         return StyleableProperties.STYLEABLES;
 9243     }
 9244 
 9245     /**
 9246      * This method should delegate to {@link Node#getClassCssMetaData()} so that
 9247      * a Node&#39;s CssMetaData can be accessed without the need for reflection.
 9248      *
 9249      * @return The CssMetaData associated with this node, which may include the
 9250      * CssMetaData of its superclasses.
 9251      * @since JavaFX 8.0
 9252      */
 9253 
 9254     @Override
 9255     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 9256         return getClassCssMetaData();
 9257     }
 9258 
 9259     /*
 9260      * @return  The Styles that match this CSS property for the given Node. The
 9261      * list is sorted by descending specificity.
 9262      */
 9263     // SB-dependency: RT-21096 has been filed to track this
 9264     static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
 9265          return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
 9266     }
 9267 
 9268     final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
 9269          ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
 9270                  (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
 9271          Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
 9272          if (ret != null) {
 9273              if (ret instanceof ObservableMap) return (ObservableMap)ret;
 9274              return FXCollections.observableMap(ret);
 9275          }
 9276          return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
 9277      }
 9278 
 9279      /*
 9280       * RT-17293
 9281       */
 9282      // SB-dependency: RT-21096 has been filed to track this
 9283      final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
 9284          if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
 9285          else getProperties().remove(&quot;STYLEMAP&quot;);
 9286      }
 9287 
 9288     /*
 9289      * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
 9290      * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
 9291      * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
 9292      * styles used to resolve lookup values.
 9293      *
 9294      * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
 9295      * @return The Map populated with matching styles.
 9296      */
 9297     // SB-dependency: RT-21096 has been filed to track this
 9298     Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {
 9299 
 9300         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
 9301         return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
 9302     }
 9303 
 9304     /**
 9305      * Flags used to indicate in which way this node is dirty (or whether it
 9306      * is clean) and what must happen during the next CSS cycle on the
 9307      * scenegraph.
 9308      */
 9309     CssFlags cssFlag = CssFlags.CLEAN;
 9310 
 9311     /**
 9312      * Needed for testing.
 9313      */
 9314     final CssFlags getCSSFlags() { return cssFlag; }
 9315 
 9316     /**
 9317      * Called when a CSS pseudo-class change would cause styles to be reapplied.
 9318      */
 9319     private void requestCssStateTransition() {
 9320         // If there is no scene, then we cannot make it dirty, so we&#39;ll leave
 9321         // the flag alone
 9322         if (getScene() == null) return;
 9323         // Don&#39;t bother doing anything if the cssFlag is not CLEAN.
 9324         // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
 9325         // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
 9326         if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
 9327             cssFlag = CssFlags.UPDATE;
 9328             notifyParentsOfInvalidatedCSS();
 9329         }
 9330     }
 9331 
 9332     /**
 9333      * Used to specify that a pseudo-class of this Node has changed. If the
 9334      * pseudo-class is used in a CSS selector that matches this Node, CSS will
 9335      * be reapplied. Typically, this method is called from the {@code invalidated}
 9336      * method of a property that is used as a pseudo-class. For example:
 9337      * &lt;pre&gt;&lt;code&gt;
 9338      *
 9339      *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
 9340      *
 9341      *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
 9342      *
 9343      *           {@literal @}Override public void invalidated() {
 9344      *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
 9345      *           }
 9346      *
 9347      *           {@literal @}Override public Object getBean() {
 9348      *               return MyControl.this;
 9349      *           }
 9350      *
 9351      *           {@literal @}Override public String getName() {
 9352      *               return &quot;myPseudoClassState&quot;;
 9353      *           }
 9354      *       };
 9355      * &lt;/code&gt;&lt;/pre&gt;
 9356      * @param pseudoClass the pseudo-class that has changed state
 9357      * @param active whether or not the state is active
 9358      * @since JavaFX 8.0
 9359      */
 9360     public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {
 9361 
 9362         final boolean modified = active
 9363                 ? pseudoClassStates.add(pseudoClass)
 9364                 : pseudoClassStates.remove(pseudoClass);
 9365 
 9366         if (modified &amp;&amp; styleHelper != null) {
 9367             final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
 9368             if (isTransition) {
 9369                 requestCssStateTransition();
 9370             }
 9371         }
 9372    }
 9373 
 9374     // package so that StyleHelper can get at it
 9375     final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
 9376     /**
 9377      * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
 9378      * @since JavaFX 8.0
 9379      */
 9380     public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {
 9381 
 9382         return FXCollections.unmodifiableObservableSet(pseudoClassStates);
 9383 
 9384     }
 9385 
 9386     // Walks up the tree telling each parent that the pseudo class state of
 9387     // this node has changed.
 9388     final void notifyParentsOfInvalidatedCSS() {
 9389         SubScene subScene = getSubScene();
 9390         Parent root = (subScene != null) ?
 9391                 subScene.getRoot() : getScene().getRoot();
 9392 
 9393         if (!root.isDirty(DirtyBits.NODE_CSS)) {
 9394             // Ensure that Scene.root is marked as dirty. If the scene isn&#39;t
 9395             // dirty, nothing will get repainted. This bit is cleared from
 9396             // Scene in doCSSPass().
 9397             NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
 9398             if (subScene != null) {
 9399                 // If the node is part of a subscene, then we must ensure that
 9400                 // the we not only mark subScene.root dirty, but continue and
 9401                 // call subScene.notifyParentsOfInvalidatedCSS() until
 9402                 // Scene.root gets marked dirty, via the recursive call:
 9403                 subScene.cssFlag = CssFlags.UPDATE;
 9404                 subScene.notifyParentsOfInvalidatedCSS();
 9405             }
 9406         }
 9407         Parent _parent = getParent();
 9408         while (_parent != null) {
 9409             if (_parent.cssFlag == CssFlags.CLEAN) {
 9410                 _parent.cssFlag = CssFlags.DIRTY_BRANCH;
 9411                 _parent = _parent.getParent();
 9412             } else {
 9413                 _parent = null;
 9414             }
 9415         }
 9416     }
 9417 
 9418     final void reapplyCSS() {
 9419 
 9420         if (getScene() == null) return;
 9421 
 9422         if (cssFlag == CssFlags.REAPPLY) return;
 9423 
 9424         // RT-36838 - don&#39;t reapply CSS in the middle of an update
 9425         if (cssFlag == CssFlags.UPDATE) {
 9426             cssFlag = CssFlags.REAPPLY;
 9427             notifyParentsOfInvalidatedCSS();
 9428             return;
 9429         }
 9430 
 9431         reapplyCss();
 9432 
 9433         //
 9434         // One idiom employed by developers is to, during the layout pass,
 9435         // add or remove nodes from the scene. For example, a ScrollPane
 9436         // might add scroll bars to itself if it determines during layout
 9437         // that it needs them, or a ListView might add cells to itself if
 9438         // it determines that it needs to. In such situations we must
 9439         // apply the CSS immediately and not add it to the scene&#39;s queue
 9440         // for deferred action.
 9441         //
 9442         if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
 9443             NodeHelper.processCSS(this);
 9444         } else {
 9445             notifyParentsOfInvalidatedCSS();
 9446         }
 9447 
 9448     }
 9449 
 9450     //
 9451     // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
 9452     // means that new style maps are calculated for the node. The process of reapplying
 9453     // CSS may reset the CSS properties of a node to their initial state, but the _new_
 9454     // styles are not applied as part of this process.
 9455     //
 9456     // There is no check of the CSS state of a child since reapply takes precedence
 9457     // over other CSS states.
 9458     //
 9459     private void reapplyCss() {
 9460 
 9461         // Hang on to current styleHelper so we can know whether
 9462         // createStyleHelper returned the same styleHelper
 9463         final CssStyleHelper oldStyleHelper = styleHelper;
 9464 
 9465         // CSS state is &quot;REAPPLY&quot;
 9466         cssFlag = CssFlags.REAPPLY;
 9467 
 9468         styleHelper = CssStyleHelper.createStyleHelper(this);
 9469 
 9470         // REAPPLY to my children, too.
 9471         if (this instanceof Parent) {
 9472 
 9473             // minor optimization to avoid calling createStyleHelper on children
 9474             // when we know there will not be any change in the style maps.
 9475             final boolean visitChildren =
 9476                     // If we don&#39;t have a styleHelper, then we should visit the children of this parent
 9477                     // since there might be styles that depend on being a child of this parent.
 9478                     // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
 9479                     styleHelper == null ||
 9480                     // if the styleHelper changed, then we definitely need to visit the children
 9481                     // since the new styles may have an effect on the children&#39;s styles calculated values.
 9482                     (oldStyleHelper != styleHelper) ||
 9483                     // If our parent is null, then we&#39;re the root of a scene or sub-scene, most likely,
 9484                     // and we&#39;ll visit children because elsewhere the code depends on root.reapplyCSS()
 9485                     // to force css to be reapplied (whether it needs to be or not).
 9486                     (getParent() == null) ||
 9487                     // If our parent&#39;s cssFlag is other than clean, then the parent may have just had
 9488                     // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
 9489                     // may affect my children&#39;s styles.
 9490                     (getParent().cssFlag != CssFlags.CLEAN);
 9491 
 9492             if (visitChildren) {
 9493 
 9494                 List&lt;Node&gt; children = ((Parent) this).getChildren();
 9495                 for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
 9496                     Node child = children.get(n);
 9497                     child.reapplyCss();
 9498                 }
 9499             }
 9500 
 9501         } else if (this instanceof SubScene) {
 9502 
 9503             // SubScene root is a Parent, but reapplyCss is a private method in Node
 9504             final Node subSceneRoot = ((SubScene)this).getRoot();
 9505             if (subSceneRoot != null) {
 9506                 subSceneRoot.reapplyCss();
 9507             }
 9508 
 9509         } else if (styleHelper == null) {
 9510             //
 9511             // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
 9512             // since there are no styles to apply or children to update.
 9513             //
 9514             cssFlag = CssFlags.CLEAN;
 9515             return;
 9516         }
 9517 
 9518         cssFlag = CssFlags.UPDATE;
 9519 
 9520     }
 9521 
 9522     void processCSS() {
 9523         switch (cssFlag) {
 9524             case CLEAN:
 9525                 break;
 9526             case DIRTY_BRANCH:
 9527             {
 9528                 Parent me = (Parent)this;
 9529                 // clear the flag first in case the flag is set to something
 9530                 // other than clean by downstream processing.
 9531                 me.cssFlag = CssFlags.CLEAN;
 9532                 List&lt;Node&gt; children = me.getChildren();
 9533                 for (int i=0, max=children.size(); i&lt;max; i++) {
 9534                     children.get(i).processCSS();
 9535                 }
 9536                 break;
 9537             }
 9538             case REAPPLY:
 9539             case UPDATE:
 9540             default:
 9541                 NodeHelper.processCSS(this);
 9542         }
 9543     }
 9544 
 9545     /**
 9546      * If required, apply styles to this Node and its children, if any. This method does not normally need to
 9547      * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
 9548      * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
 9549      * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
 9550      * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
 9551      * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
 9552      * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
 9553      * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
 9554      * following sequence of operations.&lt;/p&gt;
 9555      * &lt;pre&gt;{@code
 9556      *     parentNode.applyCss();
 9557      *     parentNode.layout();
 9558      * }&lt;/pre&gt;
 9559      * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
 9560      * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
 9561      * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
 9562      * will return zero (until some time after the Stage is shown). &lt;/p&gt;
 9563      * &lt;pre&gt;&lt;code&gt;
 9564      * {@literal @}Override
 9565      * public void start(Stage stage) throws Exception {
 9566      *
 9567      *    Group root = new Group();
 9568      *    Scene scene = new Scene(root);
 9569      *
 9570      *    Button button = new Button(&quot;Hello World&quot;);
 9571      *    root.getChildren().add(button);
 9572      *
 9573      *    root.applyCss();
 9574      *    root.layout();
 9575      *
 9576      *    double width = button.getWidth();
 9577      *    double height = button.getHeight();
 9578      *
 9579      *    System.out.println(width + &quot;, &quot; + height);
 9580      *
 9581      *    stage.setScene(scene);
 9582      *    stage.show();
 9583      * }
 9584      * &lt;/code&gt;&lt;/pre&gt;
 9585      * @since JavaFX 8.0
 9586      */
 9587     public final void applyCss() {
 9588 
 9589         if (getScene() == null) {
 9590             return;
 9591         }
 9592 
 9593         // update, unless reapply
 9594         if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;
 9595 
 9596         //
 9597         // RT-28394 - need to see if any ancestor has a flag UPDATE
 9598         // If so, process css from the top-most CssFlags.UPDATE node
 9599         // since my ancestor&#39;s styles may affect mine.
 9600         //
 9601         // If the scene-graph root isn&#39;t NODE_CSS dirty, then all my
 9602         // ancestor flags should be CLEAN and I can skip this lookup.
 9603         //
 9604         Node topMost = this;
 9605 
 9606         final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 9607         if (dirtyRoot) {
 9608 
 9609             Node _parent = getParent();
 9610             while (_parent != null) {
 9611                 if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
 9612                     topMost = _parent;
 9613                 }
 9614                 _parent = _parent.getParent();
 9615             }
 9616 
 9617             // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
 9618             // but that isn&#39;t necessary since UPDATE will apply css to all of
 9619             // a Parent&#39;s children.
 9620 
 9621             // If we&#39;re at the root of the scene-graph, make sure the NODE_CSS
 9622             // dirty bit is cleared (see Scene#doCSSPass())
 9623             if (topMost == getScene().getRoot()) {
 9624                 getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
 9625             }
 9626         }
 9627 
 9628         topMost.processCSS();
 9629 
 9630     }
 9631 
 9632     /*
 9633      * If invoked, will update styles from here on down. This method should not be called directly. If
 9634      * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
 9635      * this Node&#39;s CSS state is properly updated.
 9636      *
 9637      * Note that the difference between this method and {@link #applyCss()} is that this method
 9638      * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
 9639      * CSS update and apply styles from that node on down.
 9640      *
 9641      * Note: This method MUST only be called via its accessor method.
 9642      */
 9643     private void doProcessCSS() {
 9644 
 9645         // Nothing to do...
 9646         if (cssFlag == CssFlags.CLEAN) return;
 9647 
 9648         // if REAPPLY was deferred, process it now...
 9649         if (cssFlag == CssFlags.REAPPLY) {
 9650             reapplyCss();
 9651         }
 9652 
 9653         // Clear the flag first in case the flag is set to something
 9654         // other than clean by downstream processing.
 9655         cssFlag = CssFlags.CLEAN;
 9656 
 9657         // Transition to the new state and apply styles
 9658         if (styleHelper != null &amp;&amp; getScene() != null) {
 9659             styleHelper.transitionToState(this);
 9660         }
 9661     }
 9662 
 9663 
 9664     /**
 9665      * A StyleHelper for this node.
 9666      * A StyleHelper contains all the css styles for this node
 9667      * and knows how to apply them when our state changes.
 9668      */
 9669     CssStyleHelper styleHelper;
 9670 
 9671     private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
 9672     private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
 9673     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
 9674     private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
 9675     private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);
 9676 
 9677     private static abstract class LazyTransformProperty
 9678             extends ReadOnlyObjectProperty&lt;Transform&gt; {
 9679 
 9680         protected static final int VALID = 0;
 9681         protected static final int INVALID = 1;
 9682         protected static final int VALIDITY_UNKNOWN = 2;
 9683         protected int valid = INVALID;
 9684 
 9685         private ExpressionHelper&lt;Transform&gt; helper;
 9686 
 9687         private Transform transform;
 9688         private boolean canReuse = false;
 9689 
 9690         @Override
 9691         public void addListener(InvalidationListener listener) {
 9692             helper = ExpressionHelper.addListener(helper, this, listener);
 9693         }
 9694 
 9695         @Override
 9696         public void removeListener(InvalidationListener listener) {
 9697             helper = ExpressionHelper.removeListener(helper, listener);
 9698         }
 9699 
 9700         @Override
 9701         public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
 9702             helper = ExpressionHelper.addListener(helper, this, listener);
 9703         }
 9704 
 9705         @Override
 9706         public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
 9707             helper = ExpressionHelper.removeListener(helper, listener);
 9708         }
 9709 
 9710         protected Transform getInternalValue() {
 9711             if (valid == INVALID ||
 9712                     (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
 9713                 transform = computeTransform(canReuse ? transform : null);
 9714                 canReuse = true;
 9715                 valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
 9716             }
 9717 
 9718             return transform;
 9719         }
 9720 
 9721         @Override
 9722         public Transform get() {
 9723             transform = getInternalValue();
 9724             canReuse = false;
 9725             return transform;
 9726         }
 9727 
 9728         public void validityUnknown() {
 9729             if (valid == VALID) {
 9730                 valid = VALIDITY_UNKNOWN;
 9731             }
 9732         }
 9733 
 9734         public void invalidate() {
 9735             if (valid != INVALID) {
 9736                 valid = INVALID;
 9737                 ExpressionHelper.fireValueChangedEvent(helper);
 9738             }
 9739         }
 9740 
 9741         protected abstract boolean validityKnown();
 9742         protected abstract int computeValidity();
 9743         protected abstract Transform computeTransform(Transform reuse);
 9744     }
 9745 
 9746     private static abstract class LazyBoundsProperty
 9747             extends ReadOnlyObjectProperty&lt;Bounds&gt; {
 9748         private ExpressionHelper&lt;Bounds&gt; helper;
 9749         private boolean valid;
 9750 
 9751         private Bounds bounds;
 9752 
 9753         @Override
 9754         public void addListener(InvalidationListener listener) {
 9755             helper = ExpressionHelper.addListener(helper, this, listener);
 9756         }
 9757 
 9758         @Override
 9759         public void removeListener(InvalidationListener listener) {
 9760             helper = ExpressionHelper.removeListener(helper, listener);
 9761         }
 9762 
 9763         @Override
 9764         public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9765             helper = ExpressionHelper.addListener(helper, this, listener);
 9766         }
 9767 
 9768         @Override
 9769         public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
 9770             helper = ExpressionHelper.removeListener(helper, listener);
 9771         }
 9772 
 9773         @Override
 9774         public Bounds get() {
 9775             if (!valid) {
 9776                 bounds = computeBounds();
 9777                 valid = true;
 9778             }
 9779 
 9780             return bounds;
 9781         }
 9782 
 9783         public void invalidate() {
 9784             if (valid) {
 9785                 valid = false;
 9786                 ExpressionHelper.fireValueChangedEvent(helper);
 9787             }
 9788         }
 9789 
 9790         protected abstract Bounds computeBounds();
 9791     }
 9792 
 9793     private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);
 9794 
 9795     /**
 9796      * The accessible role for this {@code Node}.
 9797      * &lt;p&gt;
 9798      * The screen reader uses the role of a node to determine the
 9799      * attributes and actions that are supported.
 9800      *
 9801      * @defaultValue {@link AccessibleRole#NODE}
 9802      * @see AccessibleRole
 9803      *
 9804      * @since JavaFX 8u40
 9805      */
 9806     private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;
 9807 
 9808     public final void setAccessibleRole(AccessibleRole value) {
 9809         if (value == null) value = AccessibleRole.NODE;
 9810         accessibleRoleProperty().set(value);
 9811     }
 9812 
 9813     public final AccessibleRole getAccessibleRole() {
 9814         if (accessibleRole == null) return AccessibleRole.NODE;
 9815         return accessibleRoleProperty().get();
 9816     }
 9817 
 9818     public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
 9819         if (accessibleRole == null) {
 9820             accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
 9821         }
 9822         return accessibleRole;
 9823     }
 9824 
 9825     public final void setAccessibleRoleDescription(String value) {
 9826         accessibleRoleDescriptionProperty().set(value);
 9827     }
 9828 
 9829     public final String getAccessibleRoleDescription() {
 9830         if (accessibilityProperties == null) return null;
 9831         if (accessibilityProperties.accessibleRoleDescription == null) return null;
 9832         return accessibleRoleDescriptionProperty().get();
 9833     }
 9834 
 9835     /**
 9836      * The role description of this {@code Node}.
 9837      * &lt;p&gt;
 9838      * Normally, when a role is provided for a node, the screen reader
 9839      * speaks the role as well as the contents of the node.  When this
 9840      * value is set, it is possible to override the default.  This is
 9841      * useful because the set of roles is predefined.  For example,
 9842      * it is possible to set the role of a node to be a button, but
 9843      * have the role description be arbitrary text.
 9844      *
 9845      * @return the role description of this {@code Node}.
 9846      * @defaultValue null
 9847      *
 9848      * @since JavaFX 8u40
 9849      */
 9850     public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
 9851         return getAccessibilityProperties().getAccessibleRoleDescription();
 9852     }
 9853 
 9854     public final void setAccessibleText(String value) {
 9855         accessibleTextProperty().set(value);
 9856     }
 9857 
 9858     public final String getAccessibleText() {
 9859         if (accessibilityProperties == null) return null;
 9860         if (accessibilityProperties.accessibleText == null) return null;
 9861         return accessibleTextProperty().get();
 9862     }
 9863 
 9864     /**
 9865      * The accessible text for this {@code Node}.
 9866      * &lt;p&gt;
 9867      * This property is used to set the text that the screen
 9868      * reader will speak.  If a node normally speaks text,
 9869      * that text is overriden.  For example, a button
 9870      * usually speaks using the text in the control but will
 9871      * no longer do this when this value is set.
 9872      *
 9873      * @return accessible text for this {@code Node}.
 9874      * @defaultValue null
 9875      *
 9876      * @since JavaFX 8u40
 9877      */
 9878     public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
 9879         return getAccessibilityProperties().getAccessibleText();
 9880     }
 9881 
 9882     public final void setAccessibleHelp(String value) {
 9883         accessibleHelpProperty().set(value);
 9884     }
 9885 
 9886     public final String getAccessibleHelp() {
 9887         if (accessibilityProperties == null) return null;
 9888         if (accessibilityProperties.accessibleHelp == null) return null;
 9889         return accessibleHelpProperty().get();
 9890     }
 9891 
 9892     /**
 9893      * The accessible help text for this {@code Node}.
 9894      * &lt;p&gt;
 9895      * The help text provides a more detailed description of the
 9896      * accessible text for a node.  By default, if the node has
 9897      * a tool tip, this text is used.
 9898      *
 9899      * @return the accessible help text for this {@code Node}.
 9900      * @defaultValue null
 9901      *
 9902      * @since JavaFX 8u40
 9903      */
 9904     public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
 9905         return getAccessibilityProperties().getAccessibleHelp();
 9906     }
 9907 
 9908     AccessibilityProperties accessibilityProperties;
 9909     private AccessibilityProperties getAccessibilityProperties() {
 9910         if (accessibilityProperties == null) {
 9911             accessibilityProperties = new AccessibilityProperties();
 9912         }
 9913         return accessibilityProperties;
 9914     }
 9915 
 9916     private class AccessibilityProperties {
 9917         ObjectProperty&lt;String&gt; accessibleRoleDescription;
 9918         ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
 9919             if (accessibleRoleDescription == null) {
 9920                 accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
 9921             }
 9922             return accessibleRoleDescription;
 9923         }
 9924         ObjectProperty&lt;String&gt; accessibleText;
 9925         ObjectProperty&lt;String&gt; getAccessibleText() {
 9926             if (accessibleText == null) {
 9927                 accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
 9928             }
 9929             return accessibleText;
 9930         }
 9931         ObjectProperty&lt;String&gt; accessibleHelp;
 9932         ObjectProperty&lt;String&gt; getAccessibleHelp() {
 9933             if (accessibleHelp == null) {
 9934                 accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
 9935             }
 9936             return accessibleHelp;
 9937         }
 9938     }
 9939 
 9940     /**
 9941      * This method is called by the assistive technology to request
 9942      * the value for an attribute.
 9943      * &lt;p&gt;
 9944      * This method is commonly overridden by subclasses to implement
 9945      * attributes that are required for a specific role.&lt;br&gt;
 9946      * If a particular attribute is not handled, the superclass implementation
 9947      * must be called.
 9948      * &lt;/p&gt;
 9949      *
 9950      * @param attribute the requested attribute
 9951      * @param parameters optional list of parameters
 9952      * @return the value for the requested attribute
 9953      *
 9954      * @see AccessibleAttribute
 9955      *
 9956      * @since JavaFX 8u40
 9957      */
 9958     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 9959         switch (attribute) {
 9960             case ROLE: return getAccessibleRole();
 9961             case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
 9962             case TEXT: return getAccessibleText();
 9963             case HELP: return getAccessibleHelp();
 9964             case PARENT: return getParent();
 9965             case SCENE: return getScene();
 9966             case BOUNDS: return localToScreen(getBoundsInLocal());
 9967             case DISABLED: return isDisabled();
 9968             case FOCUSED: return isFocused();
 9969             case VISIBLE: return isVisible();
 9970             case LABELED_BY: return labeledBy;
 9971             default: return null;
 9972         }
 9973     }
 9974 
 9975     /**
 9976      * This method is called by the assistive technology to request the action
 9977      * indicated by the argument should be executed.
 9978      * &lt;p&gt;
 9979      * This method is commonly overridden by subclasses to implement
 9980      * action that are required for a specific role.&lt;br&gt;
 9981      * If a particular action is not handled, the superclass implementation
 9982      * must be called.
 9983      * &lt;/p&gt;
 9984      *
 9985      * @param action the action to execute
 9986      * @param parameters optional list of parameters
 9987      *
 9988      * @see AccessibleAction
 9989      *
 9990      * @since JavaFX 8u40
 9991      */
 9992     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
 9993         switch (action) {
 9994             case REQUEST_FOCUS:
 9995                 if (isFocusTraversable()) {
 9996                     requestFocus();
 9997                 }
 9998                 break;
 9999             case SHOW_MENU: {
10000                 Bounds b = getBoundsInLocal();
10001                 Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
10002                 ContextMenuEvent event =
10003                     new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
10004                     b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY(),
10005                     false, new PickResult(this, b.getMaxX(), b.getMaxY()));
10006                 Event.fireEvent(this, event);
10007                 break;
10008             }
10009             default:
10010         }
10011     }
10012 
10013     /**
10014      * This method is called by the application to notify the assistive
10015      * technology that the value for an attribute has changed.
10016      *
10017      * @param attributes the attribute whose value has changed
10018      *
10019      * @see AccessibleAttribute
10020      *
10021      * @since JavaFX 8u40
10022      */
10023     public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
10024         if (accessible == null) {
10025             Scene scene = getScene();
10026             if (scene != null) {
10027                 accessible = scene.removeAccessible(this);
10028             }
10029         }
10030         if (accessible != null) {
10031             accessible.sendNotification(attributes);
10032         }
10033     }
10034 
10035     Accessible accessible;
10036     Accessible getAccessible() {
10037         if (accessible == null) {
10038             Scene scene = getScene();
10039             /* It is possible the node was reparented and getAccessible()
10040              * is called before the pulse. Try to recycle the accessible
10041              * before creating a new one.
10042              * Note: this code relies that an accessible can never be on
10043              * more than one Scene#accMap. Thus, the only way
10044              * scene#removeAccessible() returns non-null is if the node
10045              * old scene and new scene are the same object.
10046              */
10047             if (scene != null) {
10048                 accessible = scene.removeAccessible(this);
10049             }
10050         }
10051         if (accessible == null) {
10052             accessible = Application.GetApplication().createAccessible();
10053             accessible.setEventHandler(new Accessible.EventHandler() {
10054                 @SuppressWarnings(&quot;deprecation&quot;)
10055                 @Override public AccessControlContext getAccessControlContext() {
10056                     Scene scene = getScene();
10057                     if (scene == null) {
10058                         /* This can happen during the release process of an accessible object. */
10059                         throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
10060                     }
10061                     if (scene.getPeer() != null) {
10062                         return scene.getPeer().getAccessControlContext();
10063                     } else {
10064                         /* In some rare cases the accessible for a Node is needed
10065                          * before its scene is made visible. For example, the screen reader
10066                          * might ask a Menu for its ContextMenu before the ContextMenu
10067                          * is made visible. That is a problem because the Window for the
10068                          * ContextMenu is only created immediately before the first time
10069                          * it is shown.
10070                          */
10071                         return scene.acc;
10072                     }
10073                 }
10074                 @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
10075                     return queryAccessibleAttribute(attribute, parameters);
10076                 }
10077                 @Override public void executeAction(AccessibleAction action, Object... parameters) {
10078                     executeAccessibleAction(action, parameters);
10079                 }
10080                 @Override public String toString() {
10081                     String klassName = Node.this.getClass().getName();
10082                     return klassName.substring(klassName.lastIndexOf(&#39;.&#39;)+1);
10083                 }
10084             });
10085         }
10086         return accessible;
10087     }
10088 
10089     void releaseAccessible() {
10090         Accessible acc = this.accessible;
10091         if (acc != null) {
10092             accessible = null;
10093             acc.dispose();
10094         }
10095     }
10096 
10097 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>