diff a/modules/javafx.base/src/main/java/javafx/beans/binding/package.html b/modules/javafx.base/src/main/java/javafx/beans/binding/package.html
--- a/modules/javafx.base/src/main/java/javafx/beans/binding/package.html
+++ b/modules/javafx.base/src/main/java/javafx/beans/binding/package.html
@@ -33,11 +33,11 @@
 <title>javafx.beans.binding</title>
 </head>
 <body>
     <p>Provides classes that create and operate on a {@link Binding Binding}
         that calculates a value that depends on one or more sources.</p>
-	<h1>Characteristics of Bindings</h1>
+	<h2>Characteristics of Bindings</h2>
 	<p>Bindings are assembled from one or more sources, usually called
 		their dependencies. A binding observes its dependencies for changes
 		and updates its own value according to changes in the dependencies.</p>
 	<p>Almost all bindings defined in this library require
 		implementations of {@link javafx.beans.Observable} for their
@@ -49,11 +49,11 @@
 		allowing to construct very complex bindings from simple ones.</p>
 	<p>Bindings in our implementation are always calculated lazily.
 		That means, if a dependency changes, the result of a binding is not
 		immediately recalculated, but it is marked as invalid. Next time the
 		value of an invalid binding is requested, it is recalculated.</p>
-	<h1>High Level API and Low Level API</h1>
+	<h2>High Level API and Low Level API</h2>
 	<p>The Binding API is roughly divided in two parts, the High Level
 		Binding API and the Low Level Binding API. The High Level Binding API
 		allows to construct simple bindings in an easy to use fashion.
 		Defining a binding with the High Level API should be straightforward,
 		especially when used in an IDE that provides code completion.
diff a/modules/javafx.base/src/main/java/javafx/beans/property/package.html b/modules/javafx.base/src/main/java/javafx/beans/property/package.html
--- a/modules/javafx.base/src/main/java/javafx/beans/property/package.html
+++ b/modules/javafx.base/src/main/java/javafx/beans/property/package.html
@@ -34,22 +34,22 @@
 </head>
 <body>
 	<p>The package {@code javafx.beans.property} defines read-only
 		properties and writable properties, plus a number of implementations.
 	</p>
-	<h1>Read-only Properties</h1>
+	<h2>Read-only Properties</h2>
 	<p>Read-only properties have two getters, {@code get()} returns the
 		primitive value, {@code getValue()} returns the boxed value.</p>
 	<p>It is possible to observe read-only properties for changes. They
 		define methods to add and remove {@link
 		javafx.beans.InvalidationListener InvalidationListeners} and {@link
 		javafx.beans.value.ChangeListener ChangeListeners}.</p>
 	<p>To get the context of a read-only property, two methods {@code
 		getBean()} and {@code getName()} are defined. They return the
 		containing bean and the name of a property.</p>
 
-	<h1>Writable Properties</h1>
+	<h2>Writable Properties</h2>
 	<p>In addition to the functionality defined for read-only
 		properties, writable properties contain the following methods.</p>
 	<p>A writable property defines two setters in addition to the
 		getters defined for read-only properties. The setter {@code set()}
 		takes a primitive value, the second setter {@code setValue()} takes
@@ -60,6 +60,6 @@
 		the bound {@code ObservableValue}. It is also possible to define a
 		bidirectional binding between two properties, so that both properties
 		always contain the same value. If one of the properties changes, the
 		other one will be updated.</p>
 </body>
-</html>
+</html>
diff a/modules/javafx.base/src/main/java/javafx/beans/value/package.html b/modules/javafx.base/src/main/java/javafx/beans/value/package.html
--- a/modules/javafx.base/src/main/java/javafx/beans/value/package.html
+++ b/modules/javafx.base/src/main/java/javafx/beans/value/package.html
@@ -35,11 +35,11 @@
 <body>
 	<p>The package {@code javafx.beans.value} contains the two
 		fundamental interfaces {@link javafx.beans.value.ObservableValue} and {@link
 		javafx.beans.value.WritableValue} and all of its sub-interfaces.</p>
 
-	<h1>ObservableValue</h1>
+	<h2>ObservableValue</h2>
 	An ObservableValue wraps a value that can be read and observed for
 	invalidations and changes. Listeners have to implement either {@link
 	javafx.beans.InvalidationListener} or {@link javafx.beans.value.ChangeListener}. To allow
 	working with primitive types directly a number of sub-interfaces are
 	defined.
@@ -81,11 +81,11 @@
 			<th scope="row">{@code String}</th>
 			<td>{@link javafx.beans.value.ObservableStringValue}</td>
 		</tr>
 	</table>
 
-	<h1>WritableValue</h1>
+	<h2>WritableValue</h2>
 	A WritableValue wraps a value that can be read and set. As with {@code
 	ObservableValues}, a number of sub-interfaces are defined to work with
 	primitive types directly.
 	<table>
         <caption>WritableValue Table</caption>
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/ButtonBar.java b/modules/javafx.controls/src/main/java/javafx/scene/control/ButtonBar.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/ButtonBar.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/ButtonBar.java
@@ -50,32 +50,32 @@
  * method, placed inside a ButtonBar (via the {@link #getButtons()} list), and will
  * then be positioned relative to all other nodes in the button list based on their
  * annotations, as well as the overarching
  * {@link #buttonOrderProperty() button order} specified for the ButtonBar.
  *
- * <h3>Uniform button sizing</h3>
+ * <h2>Uniform button sizing</h2>
  * <p>By default all buttons are uniformly sized in a ButtonBar, meaning that all
  * buttons take the width of the widest button. It is possible to opt-out of this
  * on a per-button basis, but calling the {@link #setButtonUniformSize(Node, boolean)} method with
  * a boolean value of false.
  *
  * <p>If a button is excluded from uniform sizing, it is both excluded from
  * being resized away from its preferred size, and also excluded from the
  * measuring process, so its size will not influence the maximum size calculated
  * for all buttons in the ButtonBar.
  *
- * <h3>Screenshots</h3>
+ * <h2>Screenshots</h2>
  * <p>Because a ButtonBar comes with built-in support for Windows, Mac OS
  * and Linux, there are three screenshots shown below, with the same buttons
  * laid out on each of the three operating systems.
  *
  * <p>
  * <strong>Windows:</strong><p><img src="doc-files/buttonBar-windows.png" alt=""></p>
  * <strong>Mac OS:</strong><p><img src="doc-files/buttonBar-mac.png" alt=""></p>
  * <strong>Linux:</strong><p><img src="doc-files/buttonBar-linux.png" alt=""></p>
  *
- * <h3>Code Samples</h3>
+ * <h2>Code Samples</h2>
  * <p>Instantiating and using the ButtonBar is simple, simply do the following:
  *
  * <pre>
  * {@code
  * // Create the ButtonBar instance
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java b/modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java
@@ -185,22 +185,22 @@
  *         textProperty().bind(itemProperty());
  *     }
  * }
  * </pre>
  *
- * <h3>Key Design Goals</h3>
+ * <h2>Key Design Goals</h2>
  * <ul>
  *   <li>Both time and memory efficient for large data sets</li>
  *   <li>Easy to build and use libraries for custom cells</li>
  *   <li>Easy to customize cell visuals</li>
  *   <li>Easy to customize display formatting (12.34 as $12.34 or 1234% etc)</li>
  *   <li>Easy to extend for custom visuals</li>
  *   <li>Easy to have "panels" of data for the visuals</li>
  *   <li>Easy to animate the cell size or other properties</li>
  * </ul>
  *
- * <h3>Key Use Cases</h3>
+ * <h2>Key Use Cases</h2>
  * Following are a number of key use cases used to drive the Cell API design,
  * along with code examples showing how those use cases are satisfied by this
  * API. This is by no means to be considered the definitive list of capabilities
  * or features supported, but rather, to provide some guidance as to how to use
  * the Cell API. The examples below are focused on the ListView, but the same
@@ -260,11 +260,11 @@
  *
  * .list-cell .negative {
  *   -fx-text-fill: red;
  * }</pre>
  *
- * <h3>Editing</h3>
+ * <h2>Editing</h2>
  * <p>Most virtualized controls that use the Cell architecture (e.g. {@link ListView},
  * {@link TreeView}, {@link TableView} and {@link TreeTableView}) all support
  * the notion of editing values directly via the cell. You can learn more about
  * the control-specific details by going to the 'editing' section in the class
  * documentation for the controls linked above. The remainder of this section
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/ComboBox.java b/modules/javafx.controls/src/main/java/javafx/scene/control/ComboBox.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/ComboBox.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/ComboBox.java
@@ -121,11 +121,11 @@
  * By default the converter simply returns the String input as the user typed it,
  * which therefore assumes that the type of the editable ComboBox is String. If
  * a different type is specified and the ComboBox is to be editable, it is
  * necessary to specify a custom {@link StringConverter}.
  *
- * <h3>A warning about inserting Nodes into the ComboBox items list</h3>
+ * <h2>A warning about inserting Nodes into the ComboBox items list</h2>
  * ComboBox allows for the items list to contain elements of any type, including
  * {@link Node} instances. Putting nodes into
  * the items list is <strong>strongly not recommended</strong>. This is because
  * the default {@link #cellFactoryProperty() cell factory} simply inserts Node
  * items directly into the cell, including in the ComboBox 'button' area too.
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/Dialog.java b/modules/javafx.controls/src/main/java/javafx/scene/control/Dialog.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/Dialog.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/Dialog.java
@@ -150,11 +150,11 @@
  * <p>There is no better or worse option of the three listed above, so developers
  * are encouraged to work to their own style preferences. The purpose of showing
  * the above is to help introduce developers to the {@link Optional} API, which
  * is new in Java 8 and may be foreign to many developers.
  *
- * <h3>Dialog Validation / Intercepting Button Actions</h3>
+ * <h2>Dialog Validation / Intercepting Button Actions</h2>
  *
  * <p>In some circumstances it is desirable to prevent a dialog from closing
  * until some aspect of the dialog becomes internally consistent (e.g. a form
  * inside the dialog has all fields in a valid state). To do this, users of the
  * dialogs API should become familiar with the
@@ -173,11 +173,11 @@
  *     if (!validateAndStore()) {
  *         event.consume();
  *     }
  * });}</pre>
  *
- * <h3>Dialog Closing Rules</h3>
+ * <h2>Dialog Closing Rules</h2>
  *
  * <p>It is important to understand what happens when a Dialog is closed, and
  * also how a Dialog can be closed, especially in abnormal closing situations
  * (such as when the 'X' button is clicked in a dialogs title bar, or when
  * operating system specific keyboard shortcuts (such as alt-F4 on Windows)
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java b/modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java
@@ -86,11 +86,11 @@
  * as the supporting classes (mentioned below), type-safe. In addition, making
  * use of the generic type supports substantially simplified development of applications
  * making use of ListView, as all modern IDEs are able to auto-complete far
  * more successfully with the additional type information.
  *
- * <h3>Populating a ListView</h3>
+ * <h2>Populating a ListView</h2>
  * <p>A simple example of how to create and populate a ListView of names (Strings)
  * is shown here:
  *
  * <pre> {@code ObservableList<String> names = FXCollections.observableArrayList(
  *          "Julia", "Ian", "Sue", "Matthew", "Hannah", "Stephan", "Denise");
@@ -120,11 +120,11 @@
  *
  * The issue with the approach shown above is that the content list is being
  * copied into the items list - meaning that subsequent changes to the content
  * list are not observed, and will not be reflected visually within the ListView.
  *
- * <h3>ListView Selection / Focus APIs</h3>
+ * <h2>ListView Selection / Focus APIs</h2>
  * <p>To track selection and focus, it is necessary to become familiar with the
  * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
  * one instance of each of these classes, available from
  * {@link #selectionModelProperty() selectionModel} and
  * {@link #focusModelProperty() focusModel} properties respectively.
@@ -140,18 +140,18 @@
  * multiple selection in a default ListView instance, it is therefore necessary
  * to do the following:
  *
  * <pre> {@code listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}</pre>
  *
- * <h3>Customizing ListView Visuals</h3>
+ * <h2>Customizing ListView Visuals</h2>
  * <p>The visuals of the ListView can be entirely customized by replacing the
  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
  * generate {@link ListCell} instances, which are used to represent an item in the
  * ListView. See the {@link Cell} class documentation for a more complete
  * description of how to write custom Cells.
  *
- * <h3>Editing</h3>
+ * <h2>Editing</h2>
  * <p>This control supports inline editing of values, and this section attempts to
  * give an overview of the available APIs and how you should use them.</p>
  *
  * <p>Firstly, cell editing most commonly requires a different user interface
  * than when a cell is not being edited. This is the responsibility of the
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/Pagination.java b/modules/javafx.controls/src/main/java/javafx/scene/control/Pagination.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/Pagination.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/Pagination.java
@@ -49,36 +49,36 @@
  * <p>
  * A Pagination control is used for navigation between pages of a single content,
  * which has been divided into smaller parts.
  * </p>
  *
- * <h3>Styling the page indicators</h3>
+ * <h2>Styling the page indicators</h2>
  * <p>
  * The control can be customized to display numeric page indicators or bullet style indicators by
  * setting the style class {@link #STYLE_CLASS_BULLET}.  The
  * {@link #maxPageIndicatorCountProperty() maxPageIndicatorCountProperty} can be used to change
  * the maximum number of page indicators.  The property value can also be changed
  * via CSS using -fx-max-page-indicator-count.
  *</p>
  *
- * <h3>Page count</h3>
+ * <h2>Page count</h2>
  * <p>
  * The {@link #pageCountProperty() pageCountProperty} controls the number of
  * pages this pagination control has.  If the page count is
  * not known {@link #INDETERMINATE} should be used as the page count.
  * </p>
  *
- * <h3>Page factory</h3>
+ * <h2>Page factory</h2>
  * <p>
  * The {@link #pageFactoryProperty() pageFactoryProperty} is a callback function
  * that is called when a page has been selected by the application or
  * the user.  The function is required for the functionality of the pagination
  * control.  The callback function should load and return the contents of the selected page.
  * Null should be returned if the selected page index does not exist.
  * </p>
  *
- * <h3>Creating a Pagination control:</h3>
+ * <h2>Creating a Pagination control:</h2>
  * <p>
  * A simple example of how to create a pagination control with ten pages and
  * each page containing text.
  * </p>
  *
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java b/modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java
@@ -97,11 +97,11 @@
  * {@link #setShowRoot(boolean) showRoot} property to {@code false}. If the root
  * node is hidden, there is one less level of indentation, and all children
  * nodes of the root node are shown. By default, the root node is shown in the
  * TreeView.
  *
- * <h3>TreeView Selection / Focus APIs</h3>
+ * <h2>TreeView Selection / Focus APIs</h2>
  * <p>To track selection and focus, it is necessary to become familiar with the
  * {@link SelectionModel} and {@link FocusModel} classes. A TreeView has at most
  * one instance of each of these classes, available from
  * {@link #selectionModelProperty() selectionModel} and
  * {@link #focusModelProperty() focusModel} properties respectively.
@@ -117,18 +117,18 @@
  * multiple selection in a default TreeView instance, it is therefore necessary
  * to do the following:
  *
  * <pre> {@code treeView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}</pre>
  *
- * <h3>Customizing TreeView Visuals</h3>
+ * <h2>Customizing TreeView Visuals</h2>
  * <p>The visuals of the TreeView can be entirely customized by replacing the
  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
  * generate {@link TreeCell} instances, which are used to represent an item in the
  * TreeView. See the {@link Cell} class documentation for a more complete
  * description of how to write custom Cells.
  *
- * <h3>Editing</h3>
+ * <h2>Editing</h2>
  * <p>This control supports inline editing of values, and this section attempts to
  * give an overview of the available APIs and how you should use them.</p>
  *
  * <p>Firstly, cell editing most commonly requires a different user interface
  * than when a cell is not being edited. This is the responsibility of the
diff a/modules/javafx.graphics/src/main/java/javafx/scene/Node.java b/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/Node.java
@@ -223,21 +223,21 @@
  * <p>
  * An application should not extend the Node class directly. Doing so may lead to
  * an UnsupportedOperationException being thrown.
  * </p>
  *
- * <h3>String ID</h3>
+ * <h2>String ID</h2>
  * <p>
  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  * much like the "id" attribute of an HTML tag in that it is up to the designer
  * and developer to ensure that the {@code id} is unique within the scene graph.
  * A convenience function called {@link #lookup(String)} can be used to find
  * a node with a unique id within the scene graph, or within a subtree of the
  * scene graph. The id can also be used identify nodes for applying styles; see
  * the CSS section below.
  *
- * <h3>Coordinate System</h3>
+ * <h2>Coordinate System</h2>
  * <p>
  * The {@code Node} class defines a traditional computer graphics "local"
  * coordinate system in which the {@code x} axis increases to the right and the
  * {@code y} axis increases downwards.  The concrete node classes for shapes
  * provide variables for defining the geometry and location of the shape
@@ -266,11 +266,11 @@
  * the transformed coordinates, not the local coordinates of the nodes.
  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  * important context-specific information about coordinate mapping and how
  * it can affect rendering.
  *
- * <h3>Transformations</h3>
+ * <h2>Transformations</h2>
  * <p>
  * Any {@code Node} can have transformations applied to it. These include
  * translation, rotation, scaling, or shearing.
  * <p>
  * A <b>translation</b> transformation is one which shifts the origin of the
@@ -323,11 +323,11 @@
  * <p>
  * Multiple transformations may be applied to a node by specifying an ordered
  * chain of transforms.  The order in which the transforms are applied is
  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  *
- * <h3>Bounding Rectangles</h3>
+ * <h2>Bounding Rectangles</h2>
  * <p>
  * Since every {@code Node} has transformations, every Node's geometric
  * bounding rectangle can be described differently depending on whether
  * transformations are accounted for or not.
  * <p>
@@ -379,11 +379,11 @@
  * {@code boundsInParent} and {@code boundsInLocal} are the same. </p>
  * <p> <img src="doc-files/bounds.png" alt="The rectangles are enclosed by their
  * respective bounds"> </p>
  *
  *
- * <h3>CSS</h3>
+ * <h2>CSS</h2>
  * <p>
  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  * {@code style} variables that are used in styling this node from
  * CSS. The {@code id} and {@code styleClass} variables are used in
  * CSS style sheets to identify nodes to which styles should be
diff a/modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java b/modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java
@@ -49,11 +49,11 @@
  * at this moment.
  * <p>
  * Drag entered/exited events behave similarly to mouse entered/exited
  * events, please see {@code MouseEvent} overview.
  *
- * <h3>Drag sources: initiating a drag and drop gesture</h3>
+ * <h2>Drag sources: initiating a drag and drop gesture</h2>
  *
  * When a drag gesture is detected, an application can decide whether to
  * start a drag and drop gesture or continue with a press-drag-release gesture.
  * <p>
  * The default drag detection mechanism uses mouse movements with a pressed
@@ -93,11 +93,11 @@
         event.consume();
     }
 });
  * </pre>
  *
- * <br><h3>Potential drop targets</h3>
+ * <br><h2>Potential drop targets</h2>
  *
  * <p>
  * After the drag and drop gesture has been started, any object
  * ({@code Node}, {@code Scene}) over which the mouse is dragged is
  * a potential drop target.
@@ -181,11 +181,11 @@
         event.consume();
     }
 });
  * </pre>
  *
- * <h3>Drag sources: finalizing drag and drop gesture</h3>
+ * <h2>Drag sources: finalizing drag and drop gesture</h2>
  *
  * <p>
  * After the gesture has been finished, whether by successful or unsuccessful
  * data transfer or being canceled, the {@code DRAG_DONE} event is sent to
  * the gesture source. The {@code getTransferMode()} method of the event
diff a/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java b/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
@@ -47,11 +47,11 @@
  * MouseEvent's node, sceneX,sceneY - relative to to the
  * origin of the {@code Scene} that contains the node,
  * screenX,screenY - relative to origin of the screen that
  * contains the mouse pointer.
  *
- * <h3>Dragging gestures</h3>
+ * <h2>Dragging gestures</h2>
  * <p>
  * There are three types of dragging gestures. They are all initiated by
  * a mouse press event and terminated as a result of a mouse released
  * event, the source node decides which gesture will take place.
  * <p>
@@ -92,11 +92,11 @@
  * but also scroll gesture events. If it means a conflict in an application
  * (the physical dragging action is handled by two different handlers), the
  * {@code isSynthesized()} method may be used to detect the problem and make the
  * dragging handlers behave accordingly.
  *
- * <h3>Mouse enter/exit handling</h3>
+ * <h2>Mouse enter/exit handling</h2>
  * <p>
  * When mouse enters a node, the node gets {@code MOUSE_ENTERED} event, when
  * it leaves, it gets {@code MOUSE_EXITED} event. These events are delivered
  * only to the entered/exited node and seemingly don't go through the
  * capturing/bubbling phases. This is the most common use-case.
@@ -120,11 +120,11 @@
  * It's still one event just switching types, so if it's filtered or consumed,
  * it affects both event variants. Thanks to the subtype-relationship, a
  * {@code MOUSE_ENTERED_TARGET} event handler will receive the
  * {@code MOUSE_ENTERED} event on target.
  *
- * <h3>Notes</h3>
+ * <h2>Notes</h2>
  * <ul>
  *   <li>For triggering context menus see the {@link ContextMenuEvent}.</li>
  * </ul>
  * @since JavaFX 2.0
  */
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/AnchorPane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/AnchorPane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/AnchorPane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/AnchorPane.java
@@ -40,11 +40,11 @@
  * unmanaged children are ignored for all layout calculations.</p>
  * <p>
  * AnchorPanes may be styled with backgrounds and borders using CSS.  See
  * {@link javafx.scene.layout.Region Region} superclass for details.</p>
  *
- * <h3>Anchor Constraints</h3>
+ * <h2>Anchor Constraints</h2>
  * <p>
  * The application sets anchor constraints on each child to configure the anchors
  * on one or more sides.  If a child is anchored on opposite sides (and is resizable), the
  * anchor pane will resize it to maintain both offsets, otherwise the anchor pane
  * will resize it to its preferred size.  If in the former case (anchored on opposite
@@ -73,11 +73,11 @@
  *     <b>AnchorPane.setTopAnchor(button, 10.0);
  *     AnchorPane.setRightAnchor(button, 10.0);</b>
  *     anchorPane.getChildren().addAll(list, button);
  * </code></pre>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  * <p>
  * An anchor pane's parent will resize the anchor pane within the anchor pane's resizable range
  * during layout.   By default the anchor pane computes this range based on its content
  * as outlined in the table below.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/BorderPane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/BorderPane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/BorderPane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/BorderPane.java
@@ -80,11 +80,11 @@
  *
  * <p>
  * BorderPane lays out each child set in the five positions regardless of the child's
  * visible property value; unmanaged children are ignored.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  * <p>
  * BorderPane is commonly used as the root of a {@link javafx.scene.Scene Scene},
  * in which case its size will track the size of the scene.  If the scene or stage
  * size has not been directly set by the application, the scene size will be
  * initialized to the border pane's preferred size.   However, if a border pane
@@ -120,11 +120,11 @@
  * <p>
  * BorderPane does not clip its content by default, so it is possible that children's
  * bounds may extend outside its own bounds if a child's min size prevents it from
  * being fit within it space.</p>
  *
- * <h4>Optional Layout Constraints</h4>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set constraints on individual children to customize BorderPane's layout.
  * For each constraint, BorderPane provides a static method for setting it on the child.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/FlowPane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/FlowPane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/FlowPane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/FlowPane.java
@@ -96,11 +96,11 @@
  *
  * <p>
  * FlowPane may be styled with backgrounds and borders using CSS.  See
  * {@link javafx.scene.layout.Region Region} superclass for details.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A flowpane's parent will resize the flowpane within the flowpane's resizable range
  * during layout.   By default the flowpane computes this range based on its content
  * as outlined in the tables below.
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/GridPane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/GridPane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/GridPane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/GridPane.java
@@ -79,11 +79,11 @@
  * (0th node in back, last node in front).
  * <p>
  * GridPane may be styled with backgrounds and borders using CSS.  See
  * {@link javafx.scene.layout.Region Region} superclass for details.</p>
  *
- * <h3>Grid Constraints</h3>
+ * <h2>Grid Constraints</h2>
  * <p>
  * A child's placement within the grid is defined by it's layout constraints:
  * </p>
  *
  * <table border="1">
@@ -130,11 +130,11 @@
  *     <b>gridpane.add(new Button(), 1, 0);</b> // column=1 row=0
  *     <b>gridpane.add(new Label(), 2, 0);</b>  // column=2 row=0
  * </code></pre>
  *
  *
- * <h3>Row/Column Sizing</h3>
+ * <h2>Row/Column Sizing</h2>
  *
  * By default, rows and columns will be sized to fit their content;
  * a column will be wide enough to accommodate the widest child, a
  * row tall enough to fit the tallest child. However, if an application needs
  * to explicitly control the size of rows or columns, it may do so by adding
@@ -160,11 +160,11 @@
  * <p>
  * Note: Nodes spanning multiple rows/columns will be also size to the preferred sizes.
  * The affected rows/columns are resized by the following priority: grow priorities, last row.
  * This is with respect to row/column constraints.
  *
- * <h3>Percentage Sizing</h3>
+ * <h2>Percentage Sizing</h2>
  *
  * Alternatively, RowConstraints and ColumnConstraints allow the size to be specified
  * as a percentage of gridpane's available space:
  * <pre><code>
  *     GridPane gridpane = new GridPane();
@@ -179,19 +179,19 @@
  * <p>
  * Note that if the sum of the widthPercent (or heightPercent) values total greater than 100, the values will
  * be treated as weights.  e.g.  if 3 columns are each given a widthPercent of 50,
  * then each will be allocated 1/3 of the gridpane's available width (50/(50+50+50)).
  *
- * <h3>Mixing Size Types</h3>
+ * <h2>Mixing Size Types</h2>
  *
  * An application may freely mix the size-types of rows/columns (computed from content, fixed,
  * or percentage).  The percentage rows/columns will always be allocated space first
  * based on their percentage of the gridpane's available space (size minus insets and gaps).
  * The remaining space will be allocated to rows/columns given their minimum, preferred,
  * and maximum sizes and grow priorities.
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  * <p>
  * A gridpane's parent will resize the gridpane within the gridpane's resizable range
  * during layout.   By default the gridpane computes this range based on its content
  * and row/column constraints as outlined in the table below.
  * </p>
@@ -225,11 +225,11 @@
  * <p>
  * GridPane does not clip its content by default, so it is possible that children's
  * bounds may extend outside its own bounds if a child's min size prevents it from
  * being fit within it space.</p>
  *
- * <h3>Optional Layout Constraints</h3>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set additional constraints on children to customize how the
  * child is sized and positioned within the layout area established by it's row/column
  * indices/spans:
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/HBox.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/HBox.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/HBox.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/HBox.java
@@ -74,11 +74,11 @@
  * Constraints" for details.
  * <p>
  * HBox lays out each managed child regardless of the child's
  * visible property value; unmanaged children are ignored.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * An hbox's parent will resize the hbox within the hbox's resizable range
  * during layout.   By default the hbox computes this range based on its content
  * as outlined in the table below.
@@ -111,11 +111,11 @@
  * <p>
  * HBox does not clip its content by default, so it is possible that children's
  * bounds may extend outside its own bounds if a child's min size prevents it from
  * being fit within the hbox.</p>
  *
- * <h3>Optional Layout Constraints</h3>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set constraints on individual children to customize HBox's layout.
  * For each constraint, HBox provides a static method for setting it on the child.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/Pane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/Pane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/Pane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/Pane.java
@@ -56,11 +56,11 @@
  *
  * <p>
  * Pane resizes each managed child regardless of the child's visible property value;
  * unmanaged children are ignored for all layout calculations.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A pane's parent will resize the pane within the pane's resizable range
  * during layout.   By default the pane computes this range based on its content
  * as outlined in the table below:
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/StackPane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/StackPane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/StackPane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/StackPane.java
@@ -65,11 +65,11 @@
  * visible property value; unmanaged children are ignored.</p>
  * <p>
  * StackPane may be styled with backgrounds and borders using CSS.  See
  * {@link javafx.scene.layout.Region Region} for details.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A stackpane's parent will resize the stackpane within the stackpane's resizable range
  * during layout.   By default the stackpane computes this range based on its content
  * as outlined in the table below.
@@ -104,11 +104,11 @@
  * <p>
  * StackPane does not clip its content by default, so it is possible that children's
  * bounds may extend outside its own bounds if a child's min size prevents it from
  * being fit within the stackpane.</p>
  *
- * <h3>Optional Layout Constraints</h3>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set constraints on individual children to customize StackPane's layout.
  * For each constraint, StackPane provides a static method for setting it on the child.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/TilePane.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/TilePane.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/TilePane.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/TilePane.java
@@ -103,11 +103,11 @@
  * The TilePane will attempt to resize each child to fill its tile.
  * If the child could not be sized to fill the tile (either because it was not
  * resizable or its size limits prevented it) then it will be aligned within the
  * tile using tileAlignment.
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A tilepane's parent will resize the tilepane within the tilepane's resizable range
  * during layout. By default the tilepane computes this range based on its content
  * as outlined in the tables below.
@@ -154,11 +154,11 @@
  * bounds may extend outside the tiles (and possibly the tilepane bounds) if a
  * child's pref size prevents it from being fit within its tile. Also, if the tilepane
  * is resized smaller than its preferred size, it may not be able to fit all the
  * tiles within its bounds and the content will extend outside.
  *
- * <h3>Optional Layout Constraints</h3>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set constraints on individual children to customize TilePane's layout.
  * For each constraint, TilePane provides a static method for setting it on the child.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/VBox.java b/modules/javafx.graphics/src/main/java/javafx/scene/layout/VBox.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/VBox.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/VBox.java
@@ -72,11 +72,11 @@
  * Constraints" for details.
  * <p>
  * VBox lays out each managed child regardless of the child's
  * visible property value; unmanaged children are ignored.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A vbox's parent will resize the vbox within the vbox's resizable range
  * during layout.   By default the vbox computes this range based on its content
  * as outlined in the table below.
@@ -111,11 +111,11 @@
  * <p>
  * VBox does not clip its content by default, so it is possible that children's
  * bounds may extend outside its own bounds if a child's min size prevents it from
  * being fit within the vbox.</p>
  *
- * <h3>Optional Layout Constraints</h3>
+ * <h2>Optional Layout Constraints</h2>
  *
  * <p>
  * An application may set constraints on individual children to customize VBox's layout.
  * For each constraint, VBox provides a static method for setting it on the child.
  * </p>
diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html b/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
@@ -41,11 +41,11 @@
 the pane will automatically manage the layout for the node, so the application
 should not position or resize the node directly; see &quot;Node Resizability&quot;
 for more details.
 </p>
 
-<h3>Scene Graph Layout Mechanism</h3>
+<h2>Scene Graph Layout Mechanism</h2>
 <p>
 The scene graph layout mechanism is driven automatically by the system once
 the application creates and displays a {@link javafx.scene.Scene Scene}.
 The scene graph detects dynamic node changes which affect layout (such as a
 change in size or content) and calls {@code requestLayout()}, which marks that
@@ -57,11 +57,11 @@
 and processed in a single pass rather than executing re-layout on on each minute
 change. Therefore, applications should not invoke layout directly on nodes.
 </p>
 
 
-<h3>Node Resizability</h3>
+<h2>Node Resizability</h2>
 <p>
 The scene graph supports both resizable and non-resizable node classes.  The
 {@code isResizable()} method on {@link javafx.scene.Node Node} returns whether a
 given node is resizable or not.  {@literal A resizable node class is one which supports a range
 of acceptable sizes (minimum <= preferred <= maximum), allowing its parent to resize
@@ -99,11 +99,11 @@
 
 <pre><code>    Circle circle = new Circle();
     circle.setRadius(50);
 </code></pre>
 
-<h3>Resizable Range</h3>
+<h2>Resizable Range</h2>
 
 Each resizable node class computes an appropriate min, pref, and max size based
 on its own content and property settings (it's 'intrinsic' size range).
 Some resizable classes have an unbounded max size (all layout panes) while
 others have a max size that is clamped by default to their preferred size (buttons)
@@ -124,11 +124,11 @@
 </code></pre>
 And finally, if the application needs to restore the intrinsically computed values:
 <pre><code>    listview.setPrefSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);
 </code></pre>
 
-<h3>CSS Styling and Node Sizing</h3>
+<h2>CSS Styling and Node Sizing</h2>
 
 Applications cannot reliably query the bounds of a resizable node until it has been
 added to a scene because the size of that node may be dependent on CSS.  This is
 because CSS is used to style many aspects of a node which affect it's preferred size
 (font, padding, borders, etc) and so the node cannot be laid out (resized) until
@@ -140,11 +140,11 @@
 is initialized, CSS is applied to nodes on each pulse (when needed) just before
 the layout pass.
 
 
 
-<h3>Visual Bounds vs. Layout Bounds</h3>
+<h2>Visual Bounds vs. Layout Bounds</h2>
 
 A graphically rich user interface often has the need to make a distinction between
 a node's visual bounds and the bounds used for layout.  For example, the tight visual
 bounds of a Text node's character glyphs would not work for layout, as the text
 would not be aligned and leading/trailing whitespace would be discounted.  Also,
diff a/modules/javafx.graphics/src/main/java/javafx/scene/package.html b/modules/javafx.graphics/src/main/java/javafx/scene/package.html
--- a/modules/javafx.graphics/src/main/java/javafx/scene/package.html
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/package.html
@@ -77,11 +77,11 @@
 graph. Specifically, a node must appear no more than once in the children
 list of a {@link javafx.scene.Parent Parent} or as the clip of a
 {@link javafx.scene.Node Node}.
 See the {@link javafx.scene.Node Node} class for more details on these restrictions.</p>
 
-<h3>Example</h3>
+<h2>Example</h2>
 
 <p>An example JavaFX scene graph is as follows:</p>
 
 <pre>
 package example;
@@ -125,11 +125,11 @@
 
 <p>The above example will generate the following image:</p>
 
 <p><img src="doc-files/Scene1.png" alt="A visual rendering of the JavaFX Scene example"></p>
 
-<h3>Coordinate System and Transformations</h3>
+<h2>Coordinate System and Transformations</h2>
 
 <p>The {@code Node} class defines a traditional computer graphics "local"
 coordinate system in which the {@code x} axis increases to the right and the
 {@code y} axis increases downwards. The concrete node classes for shapes
 provide variables for defining the geometry and location of the shape
@@ -144,11 +144,11 @@
 will change the position, orientation, or size of the coordinate system as
 viewed from the parent of the node that has been transformed.</p>
 
 <p>See the {@link javafx.scene.Node Node} class for more information on transformations.</p>
 
-<h3>Bounding Rectangle</h3>
+<h2>Bounding Rectangle</h2>
 
 <p>Since every {@code Node} has transformations, every Node's geometric
 bounding rectangle can be described differently depending on whether
 transformations are accounted for or not.</p>
 
@@ -173,11 +173,11 @@
 
 </ul>
 
 <p>See the {@link javafx.scene.Node Node} class for more information on bounding rectangles.</p>
 
-<h3>CSS</h3>
+<h2>CSS</h2>
 <p>
 The JavaFX Scene Graph provides the facility to style nodes using
 CSS (Cascading Style Sheets).
 The {@link javafx.scene.Node Node} class contains {@code id}, {@code styleClass}, and
 {@code style} variables are used by CSS selectors to find nodes
diff a/modules/javafx.graphics/src/main/java/javafx/scene/shape/Shape.java b/modules/javafx.graphics/src/main/java/javafx/scene/shape/Shape.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/shape/Shape.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/shape/Shape.java
@@ -90,11 +90,11 @@
  * <p>
  * An application should not extend the Shape class directly. Doing so may lead to
  * an UnsupportedOperationException being thrown.
  * </p>
  *
- * <h3>Interaction with coordinate systems</h3>
+ * <h2>Interaction with coordinate systems</h2>
  * Most nodes tend to have only integer translations applied to them and
  * quite often they are defined using integer coordinates as well.  For
  * this common case, fills of shapes with straight line edges tend to be
  * crisp since they line up with the cracks between pixels that fall on
  * integer device coordinates and thus tend to naturally cover entire pixels.
diff a/modules/javafx.graphics/src/main/java/javafx/scene/text/TextFlow.java b/modules/javafx.graphics/src/main/java/javafx/scene/text/TextFlow.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/text/TextFlow.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/text/TextFlow.java
@@ -108,11 +108,11 @@
  *
  * <p>
  * TextFlow may be styled with backgrounds and borders using CSS.  See
  * {@link javafx.scene.layout.Region Region} superclass for details.</p>
  *
- * <h3>Resizable Range</h3>
+ * <h2>Resizable Range</h2>
  *
  * <p>
  * A textflow's parent will resize the textflow within the textflow's range
  * during layout. By default the textflow computes this range based on its content
  * as outlined in the tables below.
