<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Dialog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  71 
  72 import javafx.css.PseudoClass;
  73 import javafx.beans.DefaultProperty;
  74 import javafx.css.Styleable;
  75 import javafx.css.StyleableProperty;
  76 import javafx.scene.AccessibleAttribute;
  77 import javafx.scene.AccessibleRole;
  78 import javafx.scene.Node;
  79 import javafx.util.Pair;
  80 
  81 /**
  82  * A ListView displays a horizontal or vertical list of items from which the
  83  * user may select, or with which the user may interact. A ListView is able to
  84  * have its generic type set to represent the type of data in the backing model.
  85  * Doing this has the benefit of making various methods in the ListView, as well
  86  * as the supporting classes (mentioned below), type-safe. In addition, making
  87  * use of the generic type supports substantially simplified development of applications
  88  * making use of ListView, as all modern IDEs are able to auto-complete far
  89  * more successfully with the additional type information.
  90  *
<span class="line-modified">  91  * &lt;h3&gt;Populating a ListView&lt;/h3&gt;</span>
  92  * &lt;p&gt;A simple example of how to create and populate a ListView of names (Strings)
  93  * is shown here:
  94  *
  95  * &lt;pre&gt; {@code ObservableList&lt;String&gt; names = FXCollections.observableArrayList(
  96  *          &quot;Julia&quot;, &quot;Ian&quot;, &quot;Sue&quot;, &quot;Matthew&quot;, &quot;Hannah&quot;, &quot;Stephan&quot;, &quot;Denise&quot;);
  97  * ListView&lt;String&gt; listView = new ListView&lt;String&gt;(names);}&lt;/pre&gt;
  98  *
  99  * &lt;p&gt;The elements of the ListView are contained within the
 100  * {@link #itemsProperty() items} {@link ObservableList}. This
 101  * ObservableList is automatically observed by the ListView, such that any
 102  * changes that occur inside the ObservableList will be automatically shown in
 103  * the ListView itself. If passing the &lt;code&gt;ObservableList&lt;/code&gt; in to the
 104  * ListView constructor is not feasible, the recommended approach for setting
 105  * the items is to simply call:
 106  *
 107  * &lt;pre&gt; {@code ObservableList&lt;T&gt; content = ...
 108  * listView.setItems(content);}&lt;/pre&gt;
 109  *
 110  * &lt;img src=&quot;doc-files/ListView.png&quot; alt=&quot;Image of the ListView control&quot;&gt;
 111  *
 112  * &lt;p&gt;The end result of this is, as noted above, that the ListView will automatically
 113  * refresh the view to represent the items in the list.
 114  *
 115  * &lt;p&gt;Another approach, whilst accepted by the ListView, &lt;b&gt;is not the
 116  * recommended approach&lt;/b&gt;:
 117  *
 118  * &lt;pre&gt; {@code List&lt;T&gt; content = ...
 119  * getItems().setAll(content);}&lt;/pre&gt;
 120  *
 121  * The issue with the approach shown above is that the content list is being
 122  * copied into the items list - meaning that subsequent changes to the content
 123  * list are not observed, and will not be reflected visually within the ListView.
 124  *
<span class="line-modified"> 125  * &lt;h3&gt;ListView Selection / Focus APIs&lt;/h3&gt;</span>
 126  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 127  * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
 128  * one instance of each of these classes, available from
 129  * {@link #selectionModelProperty() selectionModel} and
 130  * {@link #focusModelProperty() focusModel} properties respectively.
 131  * Whilst it is possible to use this API to set a new selection model, in
 132  * most circumstances this is not necessary - the default selection and focus
 133  * models should work in most circumstances.
 134  *
 135  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a ListView is
 136  * an implementation of the {@link MultipleSelectionModel} abstract class.
 137  * However, as noted in the API documentation for
 138  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 139  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 140  * multiple selection in a default ListView instance, it is therefore necessary
 141  * to do the following:
 142  *
 143  * &lt;pre&gt; {@code listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 144  *
<span class="line-modified"> 145  * &lt;h3&gt;Customizing ListView Visuals&lt;/h3&gt;</span>
 146  * &lt;p&gt;The visuals of the ListView can be entirely customized by replacing the
 147  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 148  * generate {@link ListCell} instances, which are used to represent an item in the
 149  * ListView. See the {@link Cell} class documentation for a more complete
 150  * description of how to write custom Cells.
 151  *
<span class="line-modified"> 152  * &lt;h3&gt;Editing&lt;/h3&gt;</span>
 153  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 154  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 155  *
 156  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 157  * than when a cell is not being edited. This is the responsibility of the
 158  * {@link Cell} implementation being used. For ListView, this is the responsibility
 159  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 160  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 161  * or to switch to a different UI when editing begins (e.g. when a double-click
 162  * is received on a cell).&lt;/p&gt;
 163  *
 164  * &lt;p&gt;To know when editing has been requested on a cell,
 165  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 166  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 167  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 168  * appropriate (e.g. set the text to null and set the graphic to be a
 169  * {@link TextField}). Additionally, you should also override
 170  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 171  * when the editing concludes. In both cases it is important that you also
 172  * ensure that you call the super method to have the cell perform all duties it
</pre>
</td>
<td>
<hr />
<pre>
  71 
  72 import javafx.css.PseudoClass;
  73 import javafx.beans.DefaultProperty;
  74 import javafx.css.Styleable;
  75 import javafx.css.StyleableProperty;
  76 import javafx.scene.AccessibleAttribute;
  77 import javafx.scene.AccessibleRole;
  78 import javafx.scene.Node;
  79 import javafx.util.Pair;
  80 
  81 /**
  82  * A ListView displays a horizontal or vertical list of items from which the
  83  * user may select, or with which the user may interact. A ListView is able to
  84  * have its generic type set to represent the type of data in the backing model.
  85  * Doing this has the benefit of making various methods in the ListView, as well
  86  * as the supporting classes (mentioned below), type-safe. In addition, making
  87  * use of the generic type supports substantially simplified development of applications
  88  * making use of ListView, as all modern IDEs are able to auto-complete far
  89  * more successfully with the additional type information.
  90  *
<span class="line-modified">  91  * &lt;h2&gt;Populating a ListView&lt;/h2&gt;</span>
  92  * &lt;p&gt;A simple example of how to create and populate a ListView of names (Strings)
  93  * is shown here:
  94  *
  95  * &lt;pre&gt; {@code ObservableList&lt;String&gt; names = FXCollections.observableArrayList(
  96  *          &quot;Julia&quot;, &quot;Ian&quot;, &quot;Sue&quot;, &quot;Matthew&quot;, &quot;Hannah&quot;, &quot;Stephan&quot;, &quot;Denise&quot;);
  97  * ListView&lt;String&gt; listView = new ListView&lt;String&gt;(names);}&lt;/pre&gt;
  98  *
  99  * &lt;p&gt;The elements of the ListView are contained within the
 100  * {@link #itemsProperty() items} {@link ObservableList}. This
 101  * ObservableList is automatically observed by the ListView, such that any
 102  * changes that occur inside the ObservableList will be automatically shown in
 103  * the ListView itself. If passing the &lt;code&gt;ObservableList&lt;/code&gt; in to the
 104  * ListView constructor is not feasible, the recommended approach for setting
 105  * the items is to simply call:
 106  *
 107  * &lt;pre&gt; {@code ObservableList&lt;T&gt; content = ...
 108  * listView.setItems(content);}&lt;/pre&gt;
 109  *
 110  * &lt;img src=&quot;doc-files/ListView.png&quot; alt=&quot;Image of the ListView control&quot;&gt;
 111  *
 112  * &lt;p&gt;The end result of this is, as noted above, that the ListView will automatically
 113  * refresh the view to represent the items in the list.
 114  *
 115  * &lt;p&gt;Another approach, whilst accepted by the ListView, &lt;b&gt;is not the
 116  * recommended approach&lt;/b&gt;:
 117  *
 118  * &lt;pre&gt; {@code List&lt;T&gt; content = ...
 119  * getItems().setAll(content);}&lt;/pre&gt;
 120  *
 121  * The issue with the approach shown above is that the content list is being
 122  * copied into the items list - meaning that subsequent changes to the content
 123  * list are not observed, and will not be reflected visually within the ListView.
 124  *
<span class="line-modified"> 125  * &lt;h2&gt;ListView Selection / Focus APIs&lt;/h2&gt;</span>
 126  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 127  * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
 128  * one instance of each of these classes, available from
 129  * {@link #selectionModelProperty() selectionModel} and
 130  * {@link #focusModelProperty() focusModel} properties respectively.
 131  * Whilst it is possible to use this API to set a new selection model, in
 132  * most circumstances this is not necessary - the default selection and focus
 133  * models should work in most circumstances.
 134  *
 135  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a ListView is
 136  * an implementation of the {@link MultipleSelectionModel} abstract class.
 137  * However, as noted in the API documentation for
 138  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 139  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 140  * multiple selection in a default ListView instance, it is therefore necessary
 141  * to do the following:
 142  *
 143  * &lt;pre&gt; {@code listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 144  *
<span class="line-modified"> 145  * &lt;h2&gt;Customizing ListView Visuals&lt;/h2&gt;</span>
 146  * &lt;p&gt;The visuals of the ListView can be entirely customized by replacing the
 147  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 148  * generate {@link ListCell} instances, which are used to represent an item in the
 149  * ListView. See the {@link Cell} class documentation for a more complete
 150  * description of how to write custom Cells.
 151  *
<span class="line-modified"> 152  * &lt;h2&gt;Editing&lt;/h2&gt;</span>
 153  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 154  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 155  *
 156  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 157  * than when a cell is not being edited. This is the responsibility of the
 158  * {@link Cell} implementation being used. For ListView, this is the responsibility
 159  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 160  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 161  * or to switch to a different UI when editing begins (e.g. when a double-click
 162  * is received on a cell).&lt;/p&gt;
 163  *
 164  * &lt;p&gt;To know when editing has been requested on a cell,
 165  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 166  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 167  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 168  * appropriate (e.g. set the text to null and set the graphic to be a
 169  * {@link TextField}). Additionally, you should also override
 170  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 171  * when the editing concludes. In both cases it is important that you also
 172  * ensure that you call the super method to have the cell perform all duties it
</pre>
</td>
</tr>
</table>
<center><a href="Dialog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>