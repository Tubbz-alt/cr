<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ButtonBar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComboBox.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/Cell.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
170  * data associated with it), then we just use the empty String.
171  * &lt;p&gt;
172  * Note that there are additional
173  * methods prefixed with &#39;update&#39; that may be of interest, so be
174  * sure to read the API documentation for Cell, and subclasses of Cell, closely.
175  * &lt;p&gt;
176  * Of course, we can also use the binding API rather than overriding the
177  * &#39;update&#39; methods. Shown below is a very trivial example of how this could
178  * be achieved.
179  *
180  *
181  * &lt;pre&gt;
182  * public class BoundLabelCell extends ListCell&amp;lt;String&amp;gt; {
183  *
184  *     public BoundLabelCell() {
185  *         textProperty().bind(itemProperty());
186  *     }
187  * }
188  * &lt;/pre&gt;
189  *
<span class="line-modified">190  * &lt;h3&gt;Key Design Goals&lt;/h3&gt;</span>
191  * &lt;ul&gt;
192  *   &lt;li&gt;Both time and memory efficient for large data sets&lt;/li&gt;
193  *   &lt;li&gt;Easy to build and use libraries for custom cells&lt;/li&gt;
194  *   &lt;li&gt;Easy to customize cell visuals&lt;/li&gt;
195  *   &lt;li&gt;Easy to customize display formatting (12.34 as $12.34 or 1234% etc)&lt;/li&gt;
196  *   &lt;li&gt;Easy to extend for custom visuals&lt;/li&gt;
197  *   &lt;li&gt;Easy to have &quot;panels&quot; of data for the visuals&lt;/li&gt;
198  *   &lt;li&gt;Easy to animate the cell size or other properties&lt;/li&gt;
199  * &lt;/ul&gt;
200  *
<span class="line-modified">201  * &lt;h3&gt;Key Use Cases&lt;/h3&gt;</span>
202  * Following are a number of key use cases used to drive the Cell API design,
203  * along with code examples showing how those use cases are satisfied by this
204  * API. This is by no means to be considered the definitive list of capabilities
205  * or features supported, but rather, to provide some guidance as to how to use
206  * the Cell API. The examples below are focused on the ListView, but the same
207  * philosophy applies to TreeCells or other kinds of cells.
208  * &lt;p&gt;
209  * &lt;b&gt;Changing the Cell&#39;s Colors&lt;/b&gt;
210  * &lt;p&gt;
211  * This should be extraordinarily simple in JavaFX. Each Cell can be styled
212  * directly from CSS. So for example, if you wanted to change the default
213  * background of every cell in a ListView to be WHITE you could do the
214  * following CSS:
215  *
216  * &lt;pre&gt;
217  * .list-cell {
218  *   -fx-padding: 3 3 3 3;
219  *   -fx-background-color: white;
220  * }&lt;/pre&gt;
221  *
</pre>
<hr />
<pre>
245  * be to use style classes. Suppose you had an {@link ObservableList} of Numbers
246  * to display in a ListView and wanted to color all of the negative values red
247  * and all positive or 0 values black.
248  * One way to achieve this is with a custom cellFactory which changes the
249  * styleClass of the Cell based on whether the value is negative or positive. This
250  * is as simple as adding code to test if the number in the cell is negative,
251  * and adding a &quot;negative&quot; styleClass. If the number is not negative, the &quot;negative&quot;
252  * string should be removed. This approach allows for the colors to be defined
253  * from CSS, allowing for simple customization. The CSS file would then include
254  * something like the following:
255  *
256  * &lt;pre&gt;
257  * .list-cell {
258  *   -fx-text-fill: black;
259  * }
260  *
261  * .list-cell .negative {
262  *   -fx-text-fill: red;
263  * }&lt;/pre&gt;
264  *
<span class="line-modified">265  * &lt;h3&gt;Editing&lt;/h3&gt;</span>
266  * &lt;p&gt;Most virtualized controls that use the Cell architecture (e.g. {@link ListView},
267  * {@link TreeView}, {@link TableView} and {@link TreeTableView}) all support
268  * the notion of editing values directly via the cell. You can learn more about
269  * the control-specific details by going to the &#39;editing&#39; section in the class
270  * documentation for the controls linked above. The remainder of this section
271  * will cover some of the finer details of editing with cells.&lt;/p&gt;
272  *
273  * &lt;p&gt;The general flow of editing is as follows (note that in these steps the
274  * {@link ListView} control is used as an example, but similar API exists for
275  * all controls mentioned above, and the process is exactly the same in general):&lt;/p&gt;
276  *
277  * &lt;ol&gt;
278  *     &lt;li&gt;User requests a cell enter editing mode (via keyboard or mouse commands),
279  *     or the developer requests that a cell enter editing mode (by calling a
280  *     method such as the ListView {@link ListView#edit(int) edit} method.
281  *     &lt;strong&gt;Note:&lt;/strong&gt; If the user double-clicks or fires an appropriate
282  *     keyboard command to initiate editing, then they are effectively calling
283  *     the appropriate edit method on the control (i.e. the entry method for
284  *     user-initiated and developer-initiated editing is the same).&lt;/li&gt;
285  *     &lt;li&gt;Each cell in the visible region of the control is notified that the
</pre>
</td>
<td>
<hr />
<pre>
170  * data associated with it), then we just use the empty String.
171  * &lt;p&gt;
172  * Note that there are additional
173  * methods prefixed with &#39;update&#39; that may be of interest, so be
174  * sure to read the API documentation for Cell, and subclasses of Cell, closely.
175  * &lt;p&gt;
176  * Of course, we can also use the binding API rather than overriding the
177  * &#39;update&#39; methods. Shown below is a very trivial example of how this could
178  * be achieved.
179  *
180  *
181  * &lt;pre&gt;
182  * public class BoundLabelCell extends ListCell&amp;lt;String&amp;gt; {
183  *
184  *     public BoundLabelCell() {
185  *         textProperty().bind(itemProperty());
186  *     }
187  * }
188  * &lt;/pre&gt;
189  *
<span class="line-modified">190  * &lt;h2&gt;Key Design Goals&lt;/h2&gt;</span>
191  * &lt;ul&gt;
192  *   &lt;li&gt;Both time and memory efficient for large data sets&lt;/li&gt;
193  *   &lt;li&gt;Easy to build and use libraries for custom cells&lt;/li&gt;
194  *   &lt;li&gt;Easy to customize cell visuals&lt;/li&gt;
195  *   &lt;li&gt;Easy to customize display formatting (12.34 as $12.34 or 1234% etc)&lt;/li&gt;
196  *   &lt;li&gt;Easy to extend for custom visuals&lt;/li&gt;
197  *   &lt;li&gt;Easy to have &quot;panels&quot; of data for the visuals&lt;/li&gt;
198  *   &lt;li&gt;Easy to animate the cell size or other properties&lt;/li&gt;
199  * &lt;/ul&gt;
200  *
<span class="line-modified">201  * &lt;h2&gt;Key Use Cases&lt;/h2&gt;</span>
202  * Following are a number of key use cases used to drive the Cell API design,
203  * along with code examples showing how those use cases are satisfied by this
204  * API. This is by no means to be considered the definitive list of capabilities
205  * or features supported, but rather, to provide some guidance as to how to use
206  * the Cell API. The examples below are focused on the ListView, but the same
207  * philosophy applies to TreeCells or other kinds of cells.
208  * &lt;p&gt;
209  * &lt;b&gt;Changing the Cell&#39;s Colors&lt;/b&gt;
210  * &lt;p&gt;
211  * This should be extraordinarily simple in JavaFX. Each Cell can be styled
212  * directly from CSS. So for example, if you wanted to change the default
213  * background of every cell in a ListView to be WHITE you could do the
214  * following CSS:
215  *
216  * &lt;pre&gt;
217  * .list-cell {
218  *   -fx-padding: 3 3 3 3;
219  *   -fx-background-color: white;
220  * }&lt;/pre&gt;
221  *
</pre>
<hr />
<pre>
245  * be to use style classes. Suppose you had an {@link ObservableList} of Numbers
246  * to display in a ListView and wanted to color all of the negative values red
247  * and all positive or 0 values black.
248  * One way to achieve this is with a custom cellFactory which changes the
249  * styleClass of the Cell based on whether the value is negative or positive. This
250  * is as simple as adding code to test if the number in the cell is negative,
251  * and adding a &quot;negative&quot; styleClass. If the number is not negative, the &quot;negative&quot;
252  * string should be removed. This approach allows for the colors to be defined
253  * from CSS, allowing for simple customization. The CSS file would then include
254  * something like the following:
255  *
256  * &lt;pre&gt;
257  * .list-cell {
258  *   -fx-text-fill: black;
259  * }
260  *
261  * .list-cell .negative {
262  *   -fx-text-fill: red;
263  * }&lt;/pre&gt;
264  *
<span class="line-modified">265  * &lt;h2&gt;Editing&lt;/h2&gt;</span>
266  * &lt;p&gt;Most virtualized controls that use the Cell architecture (e.g. {@link ListView},
267  * {@link TreeView}, {@link TableView} and {@link TreeTableView}) all support
268  * the notion of editing values directly via the cell. You can learn more about
269  * the control-specific details by going to the &#39;editing&#39; section in the class
270  * documentation for the controls linked above. The remainder of this section
271  * will cover some of the finer details of editing with cells.&lt;/p&gt;
272  *
273  * &lt;p&gt;The general flow of editing is as follows (note that in these steps the
274  * {@link ListView} control is used as an example, but similar API exists for
275  * all controls mentioned above, and the process is exactly the same in general):&lt;/p&gt;
276  *
277  * &lt;ol&gt;
278  *     &lt;li&gt;User requests a cell enter editing mode (via keyboard or mouse commands),
279  *     or the developer requests that a cell enter editing mode (by calling a
280  *     method such as the ListView {@link ListView#edit(int) edit} method.
281  *     &lt;strong&gt;Note:&lt;/strong&gt; If the user double-clicks or fires an appropriate
282  *     keyboard command to initiate editing, then they are effectively calling
283  *     the appropriate edit method on the control (i.e. the entry method for
284  *     user-initiated and developer-initiated editing is the same).&lt;/li&gt;
285  *     &lt;li&gt;Each cell in the visible region of the control is notified that the
</pre>
</td>
</tr>
</table>
<center><a href="ButtonBar.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ComboBox.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>