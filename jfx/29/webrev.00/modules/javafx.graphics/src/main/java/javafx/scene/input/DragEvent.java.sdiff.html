<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Node.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MouseEvent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/input/DragEvent.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 import javafx.event.EventType;
 35 import javafx.geometry.Point3D;
 36 
 37 import com.sun.javafx.scene.input.InputEventUtils;
 38 import java.io.IOException;
 39 
 40 // PENDING_DOC_REVIEW
 41 /**
 42  * Drag events replace mouse events during drag-and-drop gesture.
 43  * The difference between press-drag-release and drag-and-drop gestures
 44  * is described at {@link javafx.scene.input.MouseEvent MouseEvent}.
 45  * &lt;p&gt;
 46  * Drag and drop gesture can be started by calling {@code startDragAndDrop()}
 47  * (on a node or scene) inside of a {@link MouseEvent#DRAG_DETECTED DRAG_DETECTED} event handler.
 48  * The data to be transfered to drop target are placed to a {@code dragBoard}
 49  * at this moment.
 50  * &lt;p&gt;
 51  * Drag entered/exited events behave similarly to mouse entered/exited
 52  * events, please see {@code MouseEvent} overview.
 53  *
<span class="line-modified"> 54  * &lt;h3&gt;Drag sources: initiating a drag and drop gesture&lt;/h3&gt;</span>
 55  *
 56  * When a drag gesture is detected, an application can decide whether to
 57  * start a drag and drop gesture or continue with a press-drag-release gesture.
 58  * &lt;p&gt;
 59  * The default drag detection mechanism uses mouse movements with a pressed
 60  * button in combination with hysteresis. This behavior can be
 61  * augmented by the application. Each {@code MOUSE_PRESSED} and
 62  * {@code MOUSE_DRAGGED} event has a {@code dragDetect} flag that determines
 63  * whether a drag gesture has been detected. The default value of this flag
 64  * depends on the default detection mechanism and can be modified by calling
 65  * {@code setDragDetect()} inside of an event handler. When processing of
 66  * one of these events ends with the {@code dragDetect} flag set to true,
 67  * a {@code DRAG_DETECTED} {@code MouseEvent} is sent to the potential gesture
 68  * source (the object on which a mouse button has been pressed). This event
 69  * notifies about the gesture detection.
 70  * &lt;p&gt;
 71  * Inside a {@code DRAG_DETECTED} event handler, if the
 72  * {@code startDragAndDrop()} method is called on a node or scene and a dragged
 73  * data is made available to the returned {@code Dragboard}, the object on which
 74  * {@code startDragAndDrop()} has been called is considred a gesture source
</pre>
<hr />
<pre>
 78  * &lt;p&gt;
 79  * The {@code startDragAndDrop()} method takes a set of {@code TransferMode}s
 80  * supported by the gesture source. For instance passing only
 81  * {@code TransferMode.COPY} indicates that the gesture source allows only
 82  * copying of the data, not moving or referencing.
 83  * &lt;p&gt;
 84  * Following example shows a simple drag and drop source:
 85  * &lt;pre&gt;
 86 Rectangle rect = new Rectangle(100, 100);
 87 rect.setOnDragDetected(new EventHandler&amp;lt;MouseEvent&amp;gt;() {
 88     &amp;#64;Override public void handle(MouseEvent event) {
 89         Dragboard db = startDragAndDrop(TransferMode.ANY);
 90         ClipboardContent content = new ClipboardContent();
 91         content.putString(&quot;Hello!&quot;);
 92         db.setContent(content);
 93         event.consume();
 94     }
 95 });
 96  * &lt;/pre&gt;
 97  *
<span class="line-modified"> 98  * &lt;br&gt;&lt;h3&gt;Potential drop targets&lt;/h3&gt;</span>
 99  *
100  * &lt;p&gt;
101  * After the drag and drop gesture has been started, any object
102  * ({@code Node}, {@code Scene}) over which the mouse is dragged is
103  * a potential drop target.
104  * &lt;p&gt;
105  * When the mouse is dragged into the boundaries of potential drop target,
106  * the potential target gets a {@code DRAG_ENTERED} event. When the mouse is
107  * dragged outside of the potential target&#39;s bounds, it gets a
108  * {@code DRAG_EXITED} event. There are also the bubbling
109  * {@code DRAG_ENTERED_TARGET} and {@code DRAG_EXITED_TARGET} variants. They
110  * behave similarly to mouse entered/exited events, please see
111  * {@code MouseEvent} overview.
112  * &lt;p&gt;
113  * A potential drop target can decide to change its appearance to
114  * let the user know that the dragged data can be dropped on it. This can be
115  * done in a {@code DRAG_OVER} event handler, based on the position of the
116  * mouse. Another option is to change the potential target&#39;s appearance in
117  * a {@code DRAG_ENTERED} and {@code DRAG_EXITED} handlers.
118  * &lt;p&gt;
</pre>
<hr />
<pre>
166             event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
167         }
168         event.consume();
169     }
170 });
171 
172 rect.setOnDragDropped(new EventHandler&amp;lt;DragEvent&amp;gt;() {
173     &amp;#64;Override public void handle(DragEvent event) {
174         Dragboard db = event.getDragboard();
175         boolean success = false;
176         if (db.hasString()) {
177             System.out.println(&quot;Dropped: &quot; + db.getString());
178             success = true;
179         }
180         event.setDropCompleted(success);
181         event.consume();
182     }
183 });
184  * &lt;/pre&gt;
185  *
<span class="line-modified">186  * &lt;h3&gt;Drag sources: finalizing drag and drop gesture&lt;/h3&gt;</span>
187  *
188  * &lt;p&gt;
189  * After the gesture has been finished, whether by successful or unsuccessful
190  * data transfer or being canceled, the {@code DRAG_DONE} event is sent to
191  * the gesture source. The {@code getTransferMode()} method of the event
192  * indicates to the gesture source how the transfer of data was completed.
193  * If the transfer mode has the value {@code MOVE}, then this allows the source
194  * to clear out its data. Clearing the source&#39;s data gives the appropriate
195  * appearance to a user that the data has been moved by the drag and drop
196  * gesture. If it has the value {@code null}, then the drag and drop gesture
197  * ended without any data being transferred.  This could happen as a result of
198  * a mouse release event over a node that is not a drop target, or the user
199  * pressing the ESC key to cancel the drag and drop gesture, or by
200  * the gesture target reporting an unsuccessful data transfer.
201  * &lt;/p&gt;
202  * @since JavaFX 2.0
203  */
204 public final class DragEvent extends InputEvent {
205 
206     private static final long serialVersionUID = 20121107L;
</pre>
</td>
<td>
<hr />
<pre>
 34 import javafx.event.EventType;
 35 import javafx.geometry.Point3D;
 36 
 37 import com.sun.javafx.scene.input.InputEventUtils;
 38 import java.io.IOException;
 39 
 40 // PENDING_DOC_REVIEW
 41 /**
 42  * Drag events replace mouse events during drag-and-drop gesture.
 43  * The difference between press-drag-release and drag-and-drop gestures
 44  * is described at {@link javafx.scene.input.MouseEvent MouseEvent}.
 45  * &lt;p&gt;
 46  * Drag and drop gesture can be started by calling {@code startDragAndDrop()}
 47  * (on a node or scene) inside of a {@link MouseEvent#DRAG_DETECTED DRAG_DETECTED} event handler.
 48  * The data to be transfered to drop target are placed to a {@code dragBoard}
 49  * at this moment.
 50  * &lt;p&gt;
 51  * Drag entered/exited events behave similarly to mouse entered/exited
 52  * events, please see {@code MouseEvent} overview.
 53  *
<span class="line-modified"> 54  * &lt;h2&gt;Drag sources: initiating a drag and drop gesture&lt;/h2&gt;</span>
 55  *
 56  * When a drag gesture is detected, an application can decide whether to
 57  * start a drag and drop gesture or continue with a press-drag-release gesture.
 58  * &lt;p&gt;
 59  * The default drag detection mechanism uses mouse movements with a pressed
 60  * button in combination with hysteresis. This behavior can be
 61  * augmented by the application. Each {@code MOUSE_PRESSED} and
 62  * {@code MOUSE_DRAGGED} event has a {@code dragDetect} flag that determines
 63  * whether a drag gesture has been detected. The default value of this flag
 64  * depends on the default detection mechanism and can be modified by calling
 65  * {@code setDragDetect()} inside of an event handler. When processing of
 66  * one of these events ends with the {@code dragDetect} flag set to true,
 67  * a {@code DRAG_DETECTED} {@code MouseEvent} is sent to the potential gesture
 68  * source (the object on which a mouse button has been pressed). This event
 69  * notifies about the gesture detection.
 70  * &lt;p&gt;
 71  * Inside a {@code DRAG_DETECTED} event handler, if the
 72  * {@code startDragAndDrop()} method is called on a node or scene and a dragged
 73  * data is made available to the returned {@code Dragboard}, the object on which
 74  * {@code startDragAndDrop()} has been called is considred a gesture source
</pre>
<hr />
<pre>
 78  * &lt;p&gt;
 79  * The {@code startDragAndDrop()} method takes a set of {@code TransferMode}s
 80  * supported by the gesture source. For instance passing only
 81  * {@code TransferMode.COPY} indicates that the gesture source allows only
 82  * copying of the data, not moving or referencing.
 83  * &lt;p&gt;
 84  * Following example shows a simple drag and drop source:
 85  * &lt;pre&gt;
 86 Rectangle rect = new Rectangle(100, 100);
 87 rect.setOnDragDetected(new EventHandler&amp;lt;MouseEvent&amp;gt;() {
 88     &amp;#64;Override public void handle(MouseEvent event) {
 89         Dragboard db = startDragAndDrop(TransferMode.ANY);
 90         ClipboardContent content = new ClipboardContent();
 91         content.putString(&quot;Hello!&quot;);
 92         db.setContent(content);
 93         event.consume();
 94     }
 95 });
 96  * &lt;/pre&gt;
 97  *
<span class="line-modified"> 98  * &lt;br&gt;&lt;h2&gt;Potential drop targets&lt;/h2&gt;</span>
 99  *
100  * &lt;p&gt;
101  * After the drag and drop gesture has been started, any object
102  * ({@code Node}, {@code Scene}) over which the mouse is dragged is
103  * a potential drop target.
104  * &lt;p&gt;
105  * When the mouse is dragged into the boundaries of potential drop target,
106  * the potential target gets a {@code DRAG_ENTERED} event. When the mouse is
107  * dragged outside of the potential target&#39;s bounds, it gets a
108  * {@code DRAG_EXITED} event. There are also the bubbling
109  * {@code DRAG_ENTERED_TARGET} and {@code DRAG_EXITED_TARGET} variants. They
110  * behave similarly to mouse entered/exited events, please see
111  * {@code MouseEvent} overview.
112  * &lt;p&gt;
113  * A potential drop target can decide to change its appearance to
114  * let the user know that the dragged data can be dropped on it. This can be
115  * done in a {@code DRAG_OVER} event handler, based on the position of the
116  * mouse. Another option is to change the potential target&#39;s appearance in
117  * a {@code DRAG_ENTERED} and {@code DRAG_EXITED} handlers.
118  * &lt;p&gt;
</pre>
<hr />
<pre>
166             event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
167         }
168         event.consume();
169     }
170 });
171 
172 rect.setOnDragDropped(new EventHandler&amp;lt;DragEvent&amp;gt;() {
173     &amp;#64;Override public void handle(DragEvent event) {
174         Dragboard db = event.getDragboard();
175         boolean success = false;
176         if (db.hasString()) {
177             System.out.println(&quot;Dropped: &quot; + db.getString());
178             success = true;
179         }
180         event.setDropCompleted(success);
181         event.consume();
182     }
183 });
184  * &lt;/pre&gt;
185  *
<span class="line-modified">186  * &lt;h2&gt;Drag sources: finalizing drag and drop gesture&lt;/h2&gt;</span>
187  *
188  * &lt;p&gt;
189  * After the gesture has been finished, whether by successful or unsuccessful
190  * data transfer or being canceled, the {@code DRAG_DONE} event is sent to
191  * the gesture source. The {@code getTransferMode()} method of the event
192  * indicates to the gesture source how the transfer of data was completed.
193  * If the transfer mode has the value {@code MOVE}, then this allows the source
194  * to clear out its data. Clearing the source&#39;s data gives the appropriate
195  * appearance to a user that the data has been moved by the drag and drop
196  * gesture. If it has the value {@code null}, then the drag and drop gesture
197  * ended without any data being transferred.  This could happen as a result of
198  * a mouse release event over a node that is not a drop target, or the user
199  * pressing the ESC key to cancel the drag and drop gesture, or by
200  * the gesture target reporting an unsuccessful data transfer.
201  * &lt;/p&gt;
202  * @since JavaFX 2.0
203  */
204 public final class DragEvent extends InputEvent {
205 
206     private static final long serialVersionUID = 20121107L;
</pre>
</td>
</tr>
</table>
<center><a href="../Node.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MouseEvent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>