diff a/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html b/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
--- a/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/layout/package.html
@@ -41,11 +41,11 @@
 the pane will automatically manage the layout for the node, so the application
 should not position or resize the node directly; see &quot;Node Resizability&quot;
 for more details.
 </p>
 
-<h3>Scene Graph Layout Mechanism</h3>
+<h2>Scene Graph Layout Mechanism</h2>
 <p>
 The scene graph layout mechanism is driven automatically by the system once
 the application creates and displays a {@link javafx.scene.Scene Scene}.
 The scene graph detects dynamic node changes which affect layout (such as a
 change in size or content) and calls {@code requestLayout()}, which marks that
@@ -57,11 +57,11 @@
 and processed in a single pass rather than executing re-layout on on each minute
 change. Therefore, applications should not invoke layout directly on nodes.
 </p>
 
 
-<h3>Node Resizability</h3>
+<h2>Node Resizability</h2>
 <p>
 The scene graph supports both resizable and non-resizable node classes.  The
 {@code isResizable()} method on {@link javafx.scene.Node Node} returns whether a
 given node is resizable or not.  {@literal A resizable node class is one which supports a range
 of acceptable sizes (minimum <= preferred <= maximum), allowing its parent to resize
@@ -99,11 +99,11 @@
 
 <pre><code>    Circle circle = new Circle();
     circle.setRadius(50);
 </code></pre>
 
-<h3>Resizable Range</h3>
+<h2>Resizable Range</h2>
 
 Each resizable node class computes an appropriate min, pref, and max size based
 on its own content and property settings (it's 'intrinsic' size range).
 Some resizable classes have an unbounded max size (all layout panes) while
 others have a max size that is clamped by default to their preferred size (buttons)
@@ -124,11 +124,11 @@
 </code></pre>
 And finally, if the application needs to restore the intrinsically computed values:
 <pre><code>    listview.setPrefSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);
 </code></pre>
 
-<h3>CSS Styling and Node Sizing</h3>
+<h2>CSS Styling and Node Sizing</h2>
 
 Applications cannot reliably query the bounds of a resizable node until it has been
 added to a scene because the size of that node may be dependent on CSS.  This is
 because CSS is used to style many aspects of a node which affect it's preferred size
 (font, padding, borders, etc) and so the node cannot be laid out (resized) until
@@ -140,11 +140,11 @@
 is initialized, CSS is applied to nodes on each pulse (when needed) just before
 the layout pass.
 
 
 
-<h3>Visual Bounds vs. Layout Bounds</h3>
+<h2>Visual Bounds vs. Layout Bounds</h2>
 
 A graphically rich user interface often has the need to make a distinction between
 a node's visual bounds and the bounds used for layout.  For example, the tight visual
 bounds of a Text node's character glyphs would not work for layout, as the text
 would not be aligned and leading/trailing whitespace would be discounted.  Also,
