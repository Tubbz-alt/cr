diff a/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java b/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
--- a/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
+++ b/modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java
@@ -47,11 +47,11 @@
  * MouseEvent's node, sceneX,sceneY - relative to to the
  * origin of the {@code Scene} that contains the node,
  * screenX,screenY - relative to origin of the screen that
  * contains the mouse pointer.
  *
- * <h3>Dragging gestures</h3>
+ * <h2>Dragging gestures</h2>
  * <p>
  * There are three types of dragging gestures. They are all initiated by
  * a mouse press event and terminated as a result of a mouse released
  * event, the source node decides which gesture will take place.
  * <p>
@@ -92,11 +92,11 @@
  * but also scroll gesture events. If it means a conflict in an application
  * (the physical dragging action is handled by two different handlers), the
  * {@code isSynthesized()} method may be used to detect the problem and make the
  * dragging handlers behave accordingly.
  *
- * <h3>Mouse enter/exit handling</h3>
+ * <h2>Mouse enter/exit handling</h2>
  * <p>
  * When mouse enters a node, the node gets {@code MOUSE_ENTERED} event, when
  * it leaves, it gets {@code MOUSE_EXITED} event. These events are delivered
  * only to the entered/exited node and seemingly don't go through the
  * capturing/bubbling phases. This is the most common use-case.
@@ -120,11 +120,11 @@
  * It's still one event just switching types, so if it's filtered or consumed,
  * it affects both event variants. Thanks to the subtype-relationship, a
  * {@code MOUSE_ENTERED_TARGET} event handler will receive the
  * {@code MOUSE_ENTERED} event on target.
  *
- * <h3>Notes</h3>
+ * <h2>Notes</h2>
  * <ul>
  *   <li>For triggering context menus see the {@link ContextMenuEvent}.</li>
  * </ul>
  * @since JavaFX 2.0
  */
