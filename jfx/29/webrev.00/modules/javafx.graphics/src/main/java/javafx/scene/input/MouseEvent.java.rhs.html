<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/javafx/scene/input/MouseEvent.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.input;
  27 
  28 import com.sun.javafx.tk.Toolkit;
  29 import javafx.beans.NamedArg;
  30 import javafx.event.Event;
  31 import javafx.event.EventTarget;
  32 import javafx.event.EventType;
  33 import javafx.geometry.Point3D;
  34 import javafx.scene.Node;
  35 
  36 import com.sun.javafx.scene.input.InputEventUtils;
  37 import java.io.IOException;
  38 
  39 // PENDING_DOC_REVIEW
  40 /**
  41  * When mouse event occurs, the top-most node under cursor is picked and
  42  * the event is delivered to it through capturing and bubbling phases
  43  * described at {@link javafx.event.EventDispatcher EventDispatcher}.
  44  * &lt;p&gt;
  45  * The mouse (pointer&#39;s) location is available relative to several
  46  * coordinate systems: x,y - relative to the origin of the
  47  * MouseEvent&#39;s node, sceneX,sceneY - relative to to the
  48  * origin of the {@code Scene} that contains the node,
  49  * screenX,screenY - relative to origin of the screen that
  50  * contains the mouse pointer.
  51  *
<a name="1" id="anc1"></a><span class="line-modified">  52  * &lt;h2&gt;Dragging gestures&lt;/h2&gt;</span>
  53  * &lt;p&gt;
  54  * There are three types of dragging gestures. They are all initiated by
  55  * a mouse press event and terminated as a result of a mouse released
  56  * event, the source node decides which gesture will take place.
  57  * &lt;p&gt;
  58  * The simple press-drag-release gesture is default. It&#39;s best used to allow
  59  * changing size of a shape, dragging it around and so on. Whole
  60  * press-drag-release gesture is delivered to one node. When mouse
  61  * button is pressed, the top-most node is picked and all subsequent
  62  * mouse events are delivered to the same node until the button is released.
  63  * If a mouse clicked event is generated from these events, it is still
  64  * delivered to the same node.
  65  * &lt;p&gt;
  66  * During simple press-drag-release gesture, the other nodes are not involved
  67  * and don&#39;t get any events. If these nodes need to be involved in the gesture,
  68  * full press-drag-release gesture has to be activated. This gesture is
  69  * best used for connecting nodes by &quot;wires&quot;, dragging nodes to other nodes etc.
  70  * This gesture type is more closely described at
  71  * {@link javafx.scene.input.MouseDragEvent MouseDragEvent} which contains
  72  * the events delivered to the gesture targets.
  73  * &lt;p&gt;
  74  * The third gesture type is platform-supported drag-and-drop gesture. It serves
  75  * best to transfer data and works also between (not necessarily FX)
  76  * applications. This gesture type is more closely described
  77  * at {@link javafx.scene.input.DragEvent DragEvent}.
  78  * &lt;p&gt;
  79  * In a short summary, simple press-drag-release gesture is activated
  80  * automatically when a mouse button is pressed and delivers all
  81  * {@code MouseEvent}s to the gesture source. When you start dragging,
  82  * eventually the {@code DRAG_DETECTED} event arrives. In its handler
  83  * you can either start full press-drag-release gesture by calling
  84  * {@code startFullDrag} method on a node or scene - the {@code MouseDragEvent}s
  85  * start to be delivered to gesture targets, or you can start drag and drop
  86  * gesture by calling {@code startDragAndDrop} method on a node or scene -
  87  * the system switches into the drag and drop mode and {@code DragEvent}s start
  88  * to be delivered instead of {@code MouseEvent}s. If you don&#39;t call any of
  89  * those methods, the simple press-drag-release gesture continues.
  90  * &lt;p&gt;
  91  * Note that dragging a finger over touch screen produces mouse dragging events,
  92  * but also scroll gesture events. If it means a conflict in an application
  93  * (the physical dragging action is handled by two different handlers), the
  94  * {@code isSynthesized()} method may be used to detect the problem and make the
  95  * dragging handlers behave accordingly.
  96  *
<a name="2" id="anc2"></a><span class="line-modified">  97  * &lt;h2&gt;Mouse enter/exit handling&lt;/h2&gt;</span>
  98  * &lt;p&gt;
  99  * When mouse enters a node, the node gets {@code MOUSE_ENTERED} event, when
 100  * it leaves, it gets {@code MOUSE_EXITED} event. These events are delivered
 101  * only to the entered/exited node and seemingly don&#39;t go through the
 102  * capturing/bubbling phases. This is the most common use-case.
 103  * &lt;p&gt;
 104  * When the capturing or bubbling is desired, there are
 105  * {@code MOUSE_ENTERED_TARGET}/{@code MOUSE_EXITED_TARGET} events. These events
 106  * go through capturing/bubbling phases normally. This means that parent may
 107  * receive the {@code MOUSE_ENTERED_TARGET} event when mouse entered
 108  * either the parent itself or some of its children. To distinguish between
 109  * these two cases event target can be tested on equality with the node.
 110  * &lt;p&gt;
 111  * These two types are closely connected:
 112  * {@code MOUSE_ENTERED}/{@code MOUSE_EXITED} are subtypes
 113  * of {@code MOUSE_ENTERED_TARGET}/{@code MOUSE_EXITED_TARGET}.
 114  * During capturing phase,
 115  * {@code MOUSE_ENTERED_TARGET} is delivered to the
 116  * parents. When the event is delivered to the event target (the node that
 117  * has actually been entered), its type is switched to
 118  * {@code MOUSE_ENTERED}. Then the type is switched back to
 119  * {@code MOUSE_ENTERED_TARGET} for the bubbling phase.
 120  * It&#39;s still one event just switching types, so if it&#39;s filtered or consumed,
 121  * it affects both event variants. Thanks to the subtype-relationship, a
 122  * {@code MOUSE_ENTERED_TARGET} event handler will receive the
 123  * {@code MOUSE_ENTERED} event on target.
 124  *
<a name="3" id="anc3"></a><span class="line-modified"> 125  * &lt;h2&gt;Notes&lt;/h2&gt;</span>
 126  * &lt;ul&gt;
 127  *   &lt;li&gt;For triggering context menus see the {@link ContextMenuEvent}.&lt;/li&gt;
 128  * &lt;/ul&gt;
 129  * @since JavaFX 2.0
 130  */
 131 public class MouseEvent extends InputEvent {
 132 
 133     private static final long serialVersionUID = 20121107L;
 134 
 135     /**
 136      * Common supertype for all mouse event types.
 137      */
 138     public static final EventType&lt;MouseEvent&gt; ANY =
 139             new EventType&lt;MouseEvent&gt;(InputEvent.ANY, &quot;MOUSE&quot;);
 140 
 141     /**
 142      * This event occurs when mouse button is pressed. This activates a
 143      * press-drag-release gesture, so all subsequent mouse events until
 144      * the button is released are delivered to the same node.
 145      */
 146     public static final EventType&lt;MouseEvent&gt; MOUSE_PRESSED =
 147             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_PRESSED&quot;);
 148 
 149     /**
 150      * This event occurs when mouse button is released. It is delivered
 151      * to the same node where the button has been pressed which activated
 152      * a press-drag-release gesture.
 153      */
 154     public static final EventType&lt;MouseEvent&gt; MOUSE_RELEASED =
 155             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_RELEASED&quot;);
 156 
 157     /**
 158      * This event occurs when mouse button has been clicked (pressed and
 159      * released on the same node). This event provides a button-like behavior
 160      * to any node. Note that even long drags can generate click event (it
 161      * is delivered to the top-most node on which the mouse was both
 162      * pressed and released).
 163      */
 164     public static final EventType&lt;MouseEvent&gt; MOUSE_CLICKED =
 165             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_CLICKED&quot;);
 166 
 167     /**
 168      * This event occurs when mouse enters a node. It&#39;s the bubbling variant,
 169      * which is delivered also to all parents of the entered node (unless it
 170      * was consumed). When notifications about mouse entering some of node&#39;s
 171      * children are not desired, {@code MOUSE_ENTERED} event handler should
 172      * be used.
 173      *
 174      * @see MouseEvent MouseEvent for more information about mouse entered/exited handling
 175      */
 176     public static final EventType&lt;MouseEvent&gt; MOUSE_ENTERED_TARGET =
 177             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_ENTERED_TARGET&quot;);
 178 
 179     /**
 180      * This event occurs when mouse enters a node. This event type is delivered
 181      * only to the entered node, if parents want to filter it or get the
 182      * bubbling event, they need to use {@code MOUSE_ENTERED_TARGET}.
 183      *
 184      * @see MouseEvent MouseEvent for more information about mouse entered/exited handling
 185      */
 186     public static final EventType&lt;MouseEvent&gt; MOUSE_ENTERED =
 187             new EventType&lt;MouseEvent&gt;(MouseEvent.MOUSE_ENTERED_TARGET, &quot;MOUSE_ENTERED&quot;);
 188 
 189     /**
 190      * This event occurs when mouse exits a node. It&#39;s the bubbling variant,
 191      * which is delivered also to all parents of the exited node (unless it
 192      * was consumed). When notifications about mouse exiting some of node&#39;s
 193      * children are not desired, {@code MOUSE_EXITED} event handler should
 194      * be used.
 195      *
 196      * @see MouseEvent MouseEvent for more information about mouse entered/exited handling
 197      */
 198     public static final EventType&lt;MouseEvent&gt; MOUSE_EXITED_TARGET =
 199             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_EXITED_TARGET&quot;);
 200 
 201     /**
 202      * This event occurs when mouse exits a node. This event type is delivered
 203      * only to the exited node, if parents want to filter it or get the
 204      * bubbling event, they need to use {@code MOUSE_EXITED_TARGET}.
 205      *
 206      * @see MouseEvent MouseEvent for more information about mouse entered/exited handling
 207      */
 208     public static final EventType&lt;MouseEvent&gt; MOUSE_EXITED =
 209             new EventType&lt;MouseEvent&gt;(MouseEvent.MOUSE_EXITED_TARGET, &quot;MOUSE_EXITED&quot;);
 210 
 211     /**
 212      * This event occurs when mouse moves within a node and no buttons
 213      * are pressed. If any mouse button is pressed, MOUSE_DRAGGED event
 214      * occurs instead.
 215      */
 216     public static final EventType&lt;MouseEvent&gt; MOUSE_MOVED =
 217             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_MOVED&quot;);
 218 
 219     /**
 220      * This event occurs when mouse moves with a pressed button.
 221      * It is delivered to the same node where the button has been pressed
 222      * which activated a press-drag-release gesture. It is delivered
 223      * regardless of the mouse being within bounds of the node.
 224      */
 225     public static final EventType&lt;MouseEvent&gt; MOUSE_DRAGGED =
 226             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;MOUSE_DRAGGED&quot;);
 227 
 228     /**
 229      * This event is delivered to a node that is identified as a source of a
 230      * dragging gesture. Handler of this event is the only place where
 231      * full press-drag-release gesture or a drag and drop gesture can be
 232      * started (by calling {@link javafx.scene.Node#startFullDrag startFullDrag()}
 233      * of {@link javafx.scene.Node#startDragAndDrop startDragAndDrop()} method).
 234      * If none of them is called, simple press-drag-release gesture will continue.
 235      * &lt;p&gt;
 236      * Note that his event is generated based on dragging the mouse over a
 237      * platform-specific distance threshold. You can modify this behavior
 238      * by calling {@code setDragDetect} method on any MOUSE_PRESSED or
 239      * MOUSE_DRAGGED event.
 240      *
 241      * @see MouseEvent MouseEvent for more details about simple press-drag-release gestures
 242      * @see MouseDragEvent MouseDragEvent for more details about full press-drag-release gestures
 243      * @see DragEvent DragEvent for more details about drag and drop gestures
 244      */
 245     public static final EventType&lt;MouseEvent&gt; DRAG_DETECTED =
 246             new EventType&lt;MouseEvent&gt;(MouseEvent.ANY, &quot;DRAG_DETECTED&quot;);
 247 
 248     /**
 249      * Fills the given event by this event&#39;s coordinates recomputed to the given
 250      * source object
 251      * @param newEvent Event whose coordinates are to be filled
 252      * @param newSource Source object to compute coordinates for
 253      */
 254     void recomputeCoordinatesToSource(MouseEvent oldEvent, Object newSource) {
 255 
 256         final Point3D newCoordinates = InputEventUtils.recomputeCoordinates(
 257                 pickResult, newSource);
 258 
 259         x = newCoordinates.getX();
 260         y = newCoordinates.getY();
 261         z = newCoordinates.getZ();
 262     }
 263 
 264     @Override
 265     public EventType&lt;? extends MouseEvent&gt; getEventType() {
 266         return (EventType&lt;? extends MouseEvent&gt;) super.getEventType();
 267     }
 268 
 269     /**
 270      * Copies this event for a different source and target.
 271      * In most cases you don&#39;t need to use this method, it&#39;s called
 272      * automatically when you fire the event.
 273      * @param newSource New event source
 274      * @param newTarget New event target
 275      * @return copy of this event for a different source and target
 276      */
 277     @Override
 278     public MouseEvent copyFor(Object newSource, EventTarget newTarget) {
 279         MouseEvent e = (MouseEvent) super.copyFor(newSource, newTarget);
 280         e.recomputeCoordinatesToSource(this, newSource);
 281         return e;
 282     }
 283 
 284     /**
 285      * Creates a copy of the given event with the given fields substituted.
 286      * @param newSource the new source of the copied event
 287      * @param newTarget the new target of the copied event
 288      * @param eventType the new eventType
 289      * @return the event copy with the fields substituted
 290      * @since JavaFX 8.0
 291      */
 292     public MouseEvent copyFor(Object newSource, EventTarget newTarget, EventType&lt;? extends MouseEvent&gt; eventType) {
 293         MouseEvent e = copyFor(newSource, newTarget);
 294         e.eventType = eventType;
 295         return e;
 296     }
 297 
 298     /**
 299      * Constructs new MouseEvent event with null source and target.
 300      *
 301      * Both {@link #isBackButtonDown()}  and {@link #isForwardButtonDown()}
 302      * will return {@literal false} for this event.
 303      *
 304      * @param eventType The type of the event.
 305      * @param x The x with respect to the scene.
 306      * @param y The y with respect to the scene.
 307      * @param screenX The x coordinate relative to screen.
 308      * @param screenY The y coordinate relative to screen.
 309      * @param button the mouse button used
 310      * @param clickCount number of click counts
 311      * @param shiftDown true if shift modifier was pressed.
 312      * @param controlDown true if control modifier was pressed.
 313      * @param altDown true if alt modifier was pressed.
 314      * @param metaDown true if meta modifier was pressed.
 315      * @param primaryButtonDown true if primary button was pressed.
 316      * @param middleButtonDown true if middle button was pressed.
 317      * @param secondaryButtonDown true if secondary button was pressed.
 318      * @param synthesized if this event was synthesized
 319      * @param popupTrigger whether this event denotes a popup trigger for current platform
 320      * @param stillSincePress see {@link #isStillSincePress() }
 321      * @param pickResult pick result. Can be null, in this case a 2D pick result
 322      *                   without any further values is constructed
 323      *                   based on the scene coordinates
 324      * @since JavaFX 8.0
 325      */
 326     public MouseEvent(
 327             @NamedArg(&quot;eventType&quot;) EventType&lt;? extends MouseEvent&gt; eventType,
 328             @NamedArg(&quot;x&quot;) double x, @NamedArg(&quot;y&quot;) double y,
 329             @NamedArg(&quot;screenX&quot;) double screenX, @NamedArg(&quot;screenY&quot;) double screenY,
 330             @NamedArg(&quot;button&quot;) MouseButton button,
 331             @NamedArg(&quot;clickCount&quot;) int clickCount,
 332             @NamedArg(&quot;shiftDown&quot;) boolean shiftDown,
 333             @NamedArg(&quot;controlDown&quot;) boolean controlDown,
 334             @NamedArg(&quot;altDown&quot;) boolean altDown,
 335             @NamedArg(&quot;metaDown&quot;) boolean metaDown,
 336             @NamedArg(&quot;primaryButtonDown&quot;) boolean primaryButtonDown,
 337             @NamedArg(&quot;middleButtonDown&quot;) boolean middleButtonDown,
 338             @NamedArg(&quot;secondaryButtonDown&quot;) boolean secondaryButtonDown,
 339             @NamedArg(&quot;synthesized&quot;) boolean synthesized,
 340             @NamedArg(&quot;popupTrigger&quot;) boolean popupTrigger,
 341             @NamedArg(&quot;stillSincePress&quot;) boolean stillSincePress,
 342             @NamedArg(&quot;pickResult&quot;) PickResult pickResult) {
 343         this(null, null, eventType, x, y, screenX, screenY, button, clickCount,
 344                 shiftDown, controlDown, altDown, metaDown,
 345                 primaryButtonDown, middleButtonDown, secondaryButtonDown,
 346                 synthesized, popupTrigger, stillSincePress, pickResult);
 347     }
 348 
 349     /**
 350      * Constructs new MouseEvent event with null source and target.
 351      * @param eventType The type of the event.
 352      * @param x The x with respect to the scene.
 353      * @param y The y with respect to the scene.
 354      * @param screenX The x coordinate relative to screen.
 355      * @param screenY The y coordinate relative to screen.
 356      * @param button the mouse button used
 357      * @param clickCount number of click counts
 358      * @param shiftDown true if shift modifier was pressed.
 359      * @param controlDown true if control modifier was pressed.
 360      * @param altDown true if alt modifier was pressed.
 361      * @param metaDown true if meta modifier was pressed.
 362      * @param primaryButtonDown true if primary button was pressed.
 363      * @param middleButtonDown true if middle button was pressed.
 364      * @param secondaryButtonDown true if secondary button was pressed.
 365      * @param backButtonDown true if back button was pressed.
 366      * @param forwardButtonDown true if forward button was pressed
 367      * @param synthesized if this event was synthesized
 368      * @param popupTrigger whether this event denotes a popup trigger for current platform
 369      * @param stillSincePress see {@link #isStillSincePress() }
 370      * @param pickResult pick result. Can be null, in this case a 2D pick result
 371      *                   without any further values is constructed
 372      *                   based on the scene coordinates
 373      * @since 12
 374      */
 375     public MouseEvent(
 376             @NamedArg(&quot;eventType&quot;) EventType&lt;? extends MouseEvent&gt; eventType,
 377             @NamedArg(&quot;x&quot;) double x, @NamedArg(&quot;y&quot;) double y,
 378             @NamedArg(&quot;screenX&quot;) double screenX, @NamedArg(&quot;screenY&quot;) double screenY,
 379             @NamedArg(&quot;button&quot;) MouseButton button,
 380             @NamedArg(&quot;clickCount&quot;) int clickCount,
 381             @NamedArg(&quot;shiftDown&quot;) boolean shiftDown,
 382             @NamedArg(&quot;controlDown&quot;) boolean controlDown,
 383             @NamedArg(&quot;altDown&quot;) boolean altDown,
 384             @NamedArg(&quot;metaDown&quot;) boolean metaDown,
 385             @NamedArg(&quot;primaryButtonDown&quot;) boolean primaryButtonDown,
 386             @NamedArg(&quot;middleButtonDown&quot;) boolean middleButtonDown,
 387             @NamedArg(&quot;secondaryButtonDown&quot;) boolean secondaryButtonDown,
 388             @NamedArg(&quot;backButtonDown&quot;) boolean backButtonDown,
 389             @NamedArg(&quot;forwardButtonDown&quot;) boolean forwardButtonDown,
 390             @NamedArg(&quot;synthesized&quot;) boolean synthesized,
 391             @NamedArg(&quot;popupTrigger&quot;) boolean popupTrigger,
 392             @NamedArg(&quot;stillSincePress&quot;) boolean stillSincePress,
 393             @NamedArg(&quot;pickResult&quot;) PickResult pickResult) {
 394         this(null, null, eventType, x, y, screenX, screenY, button, clickCount,
 395                 shiftDown, controlDown, altDown, metaDown,
 396                 primaryButtonDown, middleButtonDown, secondaryButtonDown,
 397                 backButtonDown, forwardButtonDown,
 398                 synthesized, popupTrigger, stillSincePress, pickResult);
 399     }
 400 
 401     /**
 402      * Constructs new MouseEvent event.
 403      *
 404      * Both {@link #isBackButtonDown()}  and {@link #isForwardButtonDown()}
 405      * will return {@literal false} for this event.
 406      *
 407      * @param source the source of the event. Can be null.
 408      * @param target the target of the event. Can be null.
 409      * @param eventType The type of the event.
 410      * @param x The x with respect to the source. Should be in scene coordinates if source == null or source is not a Node.
 411      * @param y The y with respect to the source. Should be in scene coordinates if source == null or source is not a Node.
 412      * @param screenX The x coordinate relative to screen.
 413      * @param screenY The y coordinate relative to screen.
 414      * @param button the mouse button used
 415      * @param clickCount number of click counts
 416      * @param shiftDown true if shift modifier was pressed.
 417      * @param controlDown true if control modifier was pressed.
 418      * @param altDown true if alt modifier was pressed.
 419      * @param metaDown true if meta modifier was pressed.
 420      * @param primaryButtonDown true if primary button was pressed.
 421      * @param middleButtonDown true if middle button was pressed.
 422      * @param secondaryButtonDown true if secondary button was pressed.
 423      * @param synthesized if this event was synthesized
 424      * @param popupTrigger whether this event denotes a popup trigger for current platform
 425      * @param stillSincePress see {@link #isStillSincePress() }
 426      * @param pickResult pick result. Can be null, in this case a 2D pick result
 427      *                   without any further values is constructed
 428      *                   based on the scene coordinates and target
 429      * @since JavaFX 8.0
 430      */
 431     public MouseEvent(@NamedArg(&quot;source&quot;) Object source, @NamedArg(&quot;target&quot;) EventTarget target,
 432             @NamedArg(&quot;eventType&quot;) EventType&lt;? extends MouseEvent&gt; eventType,
 433             @NamedArg(&quot;x&quot;) double x, @NamedArg(&quot;y&quot;) double y,
 434             @NamedArg(&quot;screenX&quot;) double screenX, @NamedArg(&quot;screenY&quot;) double screenY,
 435             @NamedArg(&quot;button&quot;) MouseButton button,
 436             @NamedArg(&quot;clickCount&quot;) int clickCount,
 437             @NamedArg(&quot;shiftDown&quot;) boolean shiftDown,
 438             @NamedArg(&quot;controlDown&quot;) boolean controlDown,
 439             @NamedArg(&quot;altDown&quot;) boolean altDown,
 440             @NamedArg(&quot;metaDown&quot;) boolean metaDown,
 441             @NamedArg(&quot;primaryButtonDown&quot;) boolean primaryButtonDown,
 442             @NamedArg(&quot;middleButtonDown&quot;) boolean middleButtonDown,
 443             @NamedArg(&quot;secondaryButtonDown&quot;) boolean secondaryButtonDown,
 444             @NamedArg(&quot;synthesized&quot;) boolean synthesized,
 445             @NamedArg(&quot;popupTrigger&quot;) boolean popupTrigger,
 446             @NamedArg(&quot;stillSincePress&quot;) boolean stillSincePress,
 447             @NamedArg(&quot;pickResult&quot;) PickResult pickResult) {
 448         this(source, target, eventType, x, y, screenX, screenY, button, clickCount,
 449                 shiftDown, controlDown, altDown, metaDown,
 450                 primaryButtonDown, middleButtonDown, secondaryButtonDown, false, false,
 451                 synthesized, popupTrigger, stillSincePress, pickResult);
 452     }
 453 
 454     /**
 455      * Constructs new MouseEvent event.
 456      * @param source the source of the event. Can be null.
 457      * @param target the target of the event. Can be null.
 458      * @param eventType The type of the event.
 459      * @param x The x with respect to the source. Should be in scene coordinates if source == null or source is not a Node.
 460      * @param y The y with respect to the source. Should be in scene coordinates if source == null or source is not a Node.
 461      * @param screenX The x coordinate relative to screen.
 462      * @param screenY The y coordinate relative to screen.
 463      * @param button the mouse button used
 464      * @param clickCount number of click counts
 465      * @param shiftDown true if shift modifier was pressed.
 466      * @param controlDown true if control modifier was pressed.
 467      * @param altDown true if alt modifier was pressed.
 468      * @param metaDown true if meta modifier was pressed.
 469      * @param primaryButtonDown true if primary button was pressed.
 470      * @param middleButtonDown true if middle button was pressed.
 471      * @param secondaryButtonDown true if secondary button was pressed.
 472      * @param backButtonDown true if the back button was pressed
 473      * @param forwardButtonDown true if the forward button was pressed
 474      * @param synthesized if this event was synthesized
 475      * @param popupTrigger whether this event denotes a popup trigger for current platform
 476      * @param stillSincePress see {@link #isStillSincePress() }
 477      * @param pickResult pick result. Can be null, in this case a 2D pick result
 478      *                   without any further values is constructed
 479      *                   based on the scene coordinates and target
 480      * @since 12
 481      */
 482     public MouseEvent(@NamedArg(&quot;source&quot;) Object source, @NamedArg(&quot;target&quot;) EventTarget target,
 483                       @NamedArg(&quot;eventType&quot;) EventType&lt;? extends MouseEvent&gt; eventType,
 484                       @NamedArg(&quot;x&quot;) double x, @NamedArg(&quot;y&quot;) double y,
 485                       @NamedArg(&quot;screenX&quot;) double screenX, @NamedArg(&quot;screenY&quot;) double screenY,
 486                       @NamedArg(&quot;button&quot;) MouseButton button,
 487                       @NamedArg(&quot;clickCount&quot;) int clickCount,
 488                       @NamedArg(&quot;shiftDown&quot;) boolean shiftDown,
 489                       @NamedArg(&quot;controlDown&quot;) boolean controlDown,
 490                       @NamedArg(&quot;altDown&quot;) boolean altDown,
 491                       @NamedArg(&quot;metaDown&quot;) boolean metaDown,
 492                       @NamedArg(&quot;primaryButtonDown&quot;) boolean primaryButtonDown,
 493                       @NamedArg(&quot;middleButtonDown&quot;) boolean middleButtonDown,
 494                       @NamedArg(&quot;secondaryButtonDown&quot;) boolean secondaryButtonDown,
 495                       @NamedArg(&quot;backButtonDown&quot;) boolean backButtonDown,
 496                       @NamedArg(&quot;forwardButtonDown&quot;) boolean forwardButtonDown,
 497                       @NamedArg(&quot;synthesized&quot;) boolean synthesized,
 498                       @NamedArg(&quot;popupTrigger&quot;) boolean popupTrigger,
 499                       @NamedArg(&quot;stillSincePress&quot;) boolean stillSincePress,
 500                       @NamedArg(&quot;pickResult&quot;) PickResult pickResult) {
 501         super(source, target, eventType);
 502         this.x = x;
 503         this.y = y;
 504         this.screenX = screenX;
 505         this.screenY = screenY;
 506         this.sceneX = x;
 507         this.sceneY = y;
 508         this.button = button;
 509         this.clickCount = clickCount;
 510         this.shiftDown = shiftDown;
 511         this.controlDown = controlDown;
 512         this.altDown = altDown;
 513         this.metaDown = metaDown;
 514         this.primaryButtonDown = primaryButtonDown;
 515         this.middleButtonDown = middleButtonDown;
 516         this.secondaryButtonDown = secondaryButtonDown;
 517         this.backButtonDown = backButtonDown;
 518         this.forwardButtonDown = forwardButtonDown;
 519         this.synthesized = synthesized;
 520         this.stillSincePress = stillSincePress;
 521         this.popupTrigger = popupTrigger;
 522         this.pickResult = pickResult;
 523         this.pickResult = pickResult != null ? pickResult : new PickResult(target, x, y);
 524         final Point3D p = InputEventUtils.recomputeCoordinates(this.pickResult, null);
 525         this.x = p.getX();
 526         this.y = p.getY();
 527         this.z = p.getZ();
 528     }
 529 
 530     /**
 531      * Creates a copy of this mouse event of MouseDragEvent type
 532      * @param e the mouse event to copy
 533      * @param source the new source of the copied event
 534      * @param target the new target of the copied event
 535      * @param type the new MouseDragEvent type
 536      * @param gestureSource the new source of the gesture
 537      * @param pickResult pick result. Can be null, in this case a 2D pick result
 538      *                   without any further values is constructed
 539      *                   based on the scene coordinates
 540      * @return new MouseDragEvent that was created from MouseEvent
 541      * @since JavaFX 8.0
 542      */
 543     public static MouseDragEvent copyForMouseDragEvent(
 544             MouseEvent e,
 545             Object source, EventTarget target,
 546             EventType&lt;MouseDragEvent&gt; type,
 547             Object gestureSource, PickResult pickResult) {
 548         MouseDragEvent ev = new MouseDragEvent(source, target,
 549                 type, e.sceneX, e.sceneY, e.screenX, e.screenY,
 550                 e.button, e.clickCount, e.shiftDown, e.controlDown,
 551                 e.altDown, e.metaDown, e.primaryButtonDown, e.middleButtonDown,
 552                 e.secondaryButtonDown, e.backButtonDown, e.forwardButtonDown, e.synthesized, e.popupTrigger,
 553                 pickResult, gestureSource);
 554         ev.recomputeCoordinatesToSource(e, source);
 555         return ev;
 556     }
 557     private final Flags flags = new Flags();
 558 
 559     /**
 560      * Determines whether this event will be followed by {@code DRAG_DETECTED}
 561      * event. It has effect only with  {@code MOUSE_PRESSED} and
 562      * {@code MOUSE_DRAGGED} events.
 563      *
 564      * @return true if the {@code DRAG_DETECTED} event will follow
 565      */
 566     public boolean isDragDetect() {
 567         return flags.dragDetect;
 568     }
 569 
 570     /**
 571      * Augments drag detection behavior. The value says whether this event
 572      * will be followed by {@code DRAG_DETECTED} event. It has effect only
 573      * with  {@code MOUSE_PRESSED} and  {@code MOUSE_DRAGGED} events.
 574      *
 575      * @param dragDetect Whether {@code DRAG_DETECTED} event will follow
 576      */
 577     public void setDragDetect(boolean dragDetect) {
 578         flags.dragDetect = dragDetect;
 579     }
 580 
 581     /**
 582      * Horizontal x position of the event relative to the
 583      * origin of the MouseEvent&#39;s node.
 584      */
 585     private transient double x;
 586 
 587     /**
 588      * Horizontal position of the event relative to the
 589      * origin of the MouseEvent&#39;s source.
 590      *
 591      * @return horizontal position of the event relative to the
 592      * origin of the MouseEvent&#39;s source.
 593      */
 594     public final double getX() {
 595         return x;
 596     }
 597 
 598     /**
 599      * Vertical y position of the event relative to the
 600      * origin of the MouseEvent&#39;s node.
 601      */
 602     private transient double y;
 603 
 604     /**
 605      * Vertical position of the event relative to the
 606      * origin of the MouseEvent&#39;s source.
 607      *
 608      * @return vertical position of the event relative to the
 609      * origin of the MouseEvent&#39;s source.
 610      */
 611     public final double getY() {
 612         return y;
 613     }
 614 
 615     /**
 616      * Depth z position of the event relative to the
 617      * origin of the MouseEvent&#39;s node.
 618      */
 619     private transient double z;
 620 
 621     /**
 622      * Depth position of the event relative to the
 623      * origin of the MouseEvent&#39;s source.
 624      *
 625      * @return depth position of the event relative to the
 626      * origin of the MouseEvent&#39;s source.
 627      * @since JavaFX 8.0
 628      */
 629     public final double getZ() {
 630         return z;
 631     }
 632 
 633     /**
 634      * Absolute horizontal x position of the event.
 635      */
 636     private final double screenX;
 637 
 638     /**
 639      * Returns absolute horizontal position of the event.
 640      * @return absolute horizontal position of the event
 641      */
 642     public final double getScreenX() {
 643         return screenX;
 644     }
 645 
 646     /**
 647      * Absolute vertical y position of the event.
 648      */
 649     private final double screenY;
 650 
 651     /**
 652      * Returns absolute vertical position of the event.
 653      * @return absolute vertical position of the event
 654      */
 655     public final double getScreenY() {
 656         return screenY;
 657     }
 658 
 659     /**
 660      * Horizontal x position of the event relative to the
 661      * origin of the {@code Scene} that contains the MouseEvent&#39;s node.
 662      * If the node is not in a {@code Scene}, then the value is relative to
 663      * the boundsInParent of the root-most parent of the MouseEvent&#39;s node.
 664      */
 665     private final double sceneX;
 666 
 667     /**
 668      * Returns horizontal position of the event relative to the
 669      * origin of the {@code Scene} that contains the MouseEvent&#39;s source.
 670      * If the node is not in a {@code Scene}, then the value is relative to
 671      * the boundsInParent of the root-most parent of the MouseEvent&#39;s node.
 672      * Note that in 3D scene, this represents the flat coordinates after
 673      * applying the projection transformations.
 674      *
 675      * @return horizontal position of the event relative to the
 676      * origin of the {@code Scene} that contains the MouseEvent&#39;s source
 677      */
 678     public final double getSceneX() {
 679         return sceneX;
 680     }
 681 
 682     /**
 683      * Vertical y position of the event relative to the
 684      * origin of the {@code Scene} that contains the MouseEvent&#39;s node.
 685      * If the node is not in a {@code Scene}, then the value is relative to
 686      * the boundsInParent of the root-most parent of the MouseEvent&#39;s node.
 687      */
 688     private final double sceneY;
 689 
 690     /**
 691      * Returns vertical position of the event relative to the
 692      * origin of the {@code Scene} that contains the MouseEvent&#39;s source.
 693      * If the node is not in a {@code Scene}, then the value is relative to
 694      * the boundsInParent of the root-most parent of the MouseEvent&#39;s node.
 695      * Note that in 3D scene, this represents the flat coordinates after
 696      * applying the projection transformations.
 697      *
 698      * @return vertical position of the event relative to the
 699      * origin of the {@code Scene} that contains the MouseEvent&#39;s source
 700      */
 701     public final double getSceneY() {
 702         return sceneY;
 703     }
 704 
 705     /**
 706      * Which, if any, of the mouse buttons is responsible for this event.
 707      */
 708     private final MouseButton button;
 709 
 710     /**
 711      * Which, if any, of the mouse buttons is responsible for this event.
 712      *
 713      * @return mouse button whose state change caused this event
 714      */
 715     public final MouseButton getButton() {
 716         return button;
 717     }
 718 
 719     /**
 720      * Number of mouse clicks associated with this event.
 721      * All MOUSE_MOVED events have the clickCount value equal to 0. The
 722      * value is increased with MOUSE_PRESSED event and stays like
 723      * that for all subsequent events till MOUSE_RELEASED, including the
 724      * afterwards generated MOUSE_CLICKED event. The value is increased
 725      * to numbers higher than one if all the events between two subsequent
 726      * presses happen on a small region and in a small time (according
 727      * to native operating system configuration).
 728      */
 729     private final int clickCount;
 730 
 731     /**
 732      * Returns number of mouse clicks associated with this event.
 733      * All MOUSE_MOVED events have the clickCount value equal to 0. The
 734      * value is increased with MOUSE_PRESSED event and stays like
 735      * that for all subsequent events till MOUSE_RELEASED, including the
 736      * afterwards generated MOUSE_CLICKED event. The value is increased
 737      * to numbers higher than one if all the events between two subsequent
 738      * presses happen on a small region and in a small time (according
 739      * to native operating system configuration).
 740      *
 741      * @return number of mouse clicks associated with this event
 742      */
 743     public final int getClickCount() {
 744         return clickCount;
 745     }
 746 
 747     /**
 748      * Whether the mouse cursor left the hysteresis region since the previous
 749      * press.
 750      */
 751     private final boolean stillSincePress;
 752 
 753     /**
 754      * Indicates whether the mouse cursor stayed in the system-provided
 755      * hysteresis area since last pressed event that occurred before this event.
 756      * &lt;p&gt;
 757      * Click event is generated for a node if mouse was both pressed and
 758      * released over the node, regardless of mouse movements between the press
 759      * and release. If a node wants to react differently on a simple click and
 760      * on a mouse drag, it should use a system-supplied short distance
 761      * threshold to decide between click and drag (users often perform
 762      * inadvertent tiny movements during a click). It can be easily achieved
 763      * by ignoring all drags with this method returning {@code true} and
 764      * ignoring all clicks with this method returning {@code false}.
 765      *
 766      * @return true if there were no significant mouse movements (out of
 767      * system hysteresis area) since the last pressed event that occurred
 768      * before this event.
 769      */
 770     public final boolean isStillSincePress() {
 771         return stillSincePress;
 772     }
 773 
 774     /**
 775      * Whether or not the Shift modifier is down on this event.
 776      */
 777     private final boolean shiftDown;
 778 
 779     /**
 780      * Whether or not the Shift modifier is down on this event.
 781      * @return true if the Shift modifier is down on this event
 782      */
 783     public final boolean isShiftDown() {
 784         return shiftDown;
 785     }
 786 
 787     /**
 788      * Whether or not the Control modifier is down on this event.
 789      */
 790     private final boolean controlDown;
 791 
 792     /**
 793      * Whether or not the Control modifier is down on this event.
 794      * @return true if the Control modifier is down on this event
 795      */
 796     public final boolean isControlDown() {
 797         return controlDown;
 798     }
 799 
 800     /**
 801      * Whether or not the Alt modifier is down on this event.
 802      */
 803     private final boolean altDown;
 804 
 805     /**
 806      * Whether or not the Alt modifier is down on this event.
 807      * @return true if the Alt modifier is down on this event
 808      */
 809     public final boolean isAltDown() {
 810         return altDown;
 811     }
 812 
 813     /**
 814      * Whether or not the Meta modifier is down on this event.
 815      */
 816     private final boolean metaDown;
 817 
 818     /**
 819      * Whether or not the Meta modifier is down on this event.
 820      * @return true if the Meta modifier is down on this event
 821      */
 822     public final boolean isMetaDown() {
 823         return metaDown;
 824     }
 825 
 826     private final boolean synthesized;
 827 
 828     /**
 829      * Indicates whether this event is synthesized from using a touch screen
 830      * instead of usual mouse event source devices like mouse or track pad.
 831      * When a finger is dragged over a touch screen, both scrolling gesture
 832      * and mouse dragging are produced. If it causes a conflict in an
 833      * application, this flag can be used to tell apart the usual mouse dragging
 834      * from the touch screen dragging already handled as scroll events.
 835      * @return true if this event is synthesized from using a touch screen
 836      * @since JavaFX 2.2
 837      */
 838     public boolean isSynthesized() {
 839         return synthesized;
 840     }
 841 
 842     /**
 843      * Returns whether or not the host platform common shortcut modifier is
 844      * down on this event. This common shortcut modifier is a modifier key which
 845      * is used commonly in shortcuts on the host platform. It is for example
 846      * {@code control} on Windows and {@code meta} (command key) on Mac.
 847      *
 848      * @return {@code true} if the shortcut modifier is down, {@code false}
 849      *      otherwise
 850      */
 851     public final boolean isShortcutDown() {
 852         switch (Toolkit.getToolkit().getPlatformShortcutKey()) {
 853             case SHIFT:
 854                 return shiftDown;
 855 
 856             case CONTROL:
 857                 return controlDown;
 858 
 859             case ALT:
 860                 return altDown;
 861 
 862             case META:
 863                 return metaDown;
 864 
 865             default:
 866                 return false;
 867         }
 868     }
 869 
 870     /**
 871      * Whether or not this mouse event is the popup menu
 872      * trigger event for the platform.
 873      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: Popup menus are triggered differently
 874      * on different systems. Therefore, {@code popupTrigger}
 875      * should be checked in both {@code onMousePressed}
 876      * and {@code mouseReleased} for proper cross-platform functionality.
 877      */
 878     private final boolean popupTrigger;
 879 
 880     /**
 881      * Returns {@code true} if this mouse event is the popup menu
 882      * trigger event for the platform.
 883      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: Popup menus are triggered differently
 884      * on different systems. Therefore, {@code popupTrigger}
 885      * should be checked in both {@code onMousePressed}
 886      * and {@code mouseReleased} for proper cross-platform functionality.
 887      *
 888      * @return {@code true} if this mouse event is the popup menu
 889      * trigger event for the platform
 890      * @since JavaFX 8.0
 891      */
 892     public final boolean isPopupTrigger() {
 893         return popupTrigger;
 894     }
 895 
 896     /**
 897      * {@code true} if primary button (button 1, usually the left) is currently
 898      * pressed. Note that this is different from the {@link #getButton() button}
 899      * variable in that the {@code button} variable indicates which button press was
 900      * responsible for this event while this variable indicates whether the
 901      * primary button is depressed.
 902      */
 903     private final boolean primaryButtonDown;
 904 
 905     /**
 906      * Returns {@code true} if primary button (button 1, usually the left)
 907      * is currently pressed. Note that this is different from the
 908      * {@code getButton()} method that indicates which button press was
 909      * responsible for this event while this method indicates whether the
 910      * primary button is depressed.
 911      *
 912      * @return {@code true} if primary button (button 1, usually the left)
 913      * is currently pressed
 914      */
 915     public final boolean isPrimaryButtonDown() {
 916         return primaryButtonDown;
 917     }
 918 
 919     /**
 920      * {@code true} if secondary button (button 3, usually the right) is currently
 921      * pressed. Note that this is different from the {@link #getButton() button}
 922      * variable in that the {@code button} variable indicates which button press was
 923      * responsible for this event while this variable indicates whether the
 924      * primary button is depressed.
 925      */
 926     private final boolean secondaryButtonDown;
 927 
 928     /**
 929      * Returns {@code true} if secondary button (button 3, usually the right)
 930      * is currently pressed. Note that this is different from the
 931      * {@code getButton()} method that indicates which button press was
 932      * responsible for this event while this method indicates whether the
 933      * secondary button is depressed.
 934      *
 935      * @return {@code true} if secondary button (button 3, usually the right)
 936      * is currently pressed
 937      */
 938     public final boolean isSecondaryButtonDown() {
 939         return secondaryButtonDown;
 940     }
 941 
 942     /**
 943      * {@code true} if middle button (button 2) is currently pressed.
 944      * Note that this is different from the {@link #getButton() button} variable in
 945      * that the {@code button} variable indicates which button press was
 946      * responsible for this event while this variable indicates whether the
 947      * middle button is depressed.
 948      */
 949     private final boolean middleButtonDown;
 950 
 951     /**
 952      * Returns {@code true} if middle button (button 2)
 953      * is currently pressed. Note that this is different from the
 954      * {@code getButton()} method that indicates which button press was
 955      * responsible for this event while this method indicates whether the
 956      * middle button is depressed.
 957      *
 958      * @return {@code true} if middle button (button 2) is currently pressed
 959      */
 960     public final boolean isMiddleButtonDown() {
 961         return middleButtonDown;
 962     }
 963 
 964     /**
 965      * {@code true} if back button (button 4) is currently pressed.
 966      * Note that this is different from the {@link #getButton() button} variable in
 967      * that the {@code button} variable indicates which button press was
 968      * responsible for this event while this variable indicates whether the
 969      * back button is depressed.
 970      */
 971     private final boolean backButtonDown;
 972 
 973     /**
 974      * Returns {@code true} if back button (button 4)
 975      * is currently pressed. Note that this is different from the
 976      * {@code getButton()} method that indicates which button press was
 977      * responsible for this event while this method indicates whether the
 978      * back button is depressed.
 979      *
 980      * @return {@code true} if back button (button 4) is currently pressed
 981      * @since 12
 982      */
 983     public final boolean isBackButtonDown() {
 984         return backButtonDown;
 985     }
 986 
 987     /**
 988      * {@code true} if forward button (button 5) is currently pressed.
 989      * Note that this is different from the {@link #getButton() button} variable in
 990      * that the {@code button} variable indicates which button press was
 991      * responsible for this event while this variable indicates whether the
 992      * forward button is depressed.
 993      */
 994     private final boolean forwardButtonDown;
 995 
 996     /**
 997      * Returns {@code true} if forward button (button 5)
 998      * is currently pressed. Note that this is different from the
 999      * {@code getButton()} method that indicates which button press was
1000      * responsible for this event while this method indicates whether the
1001      * back button is depressed.
1002      *
1003      * @return {@code true} if forward button (button 5) is currently pressed
1004      * @since 12
1005      */
1006     public final boolean isForwardButtonDown() {
1007         return forwardButtonDown;
1008     }
1009 
1010     /**
1011      * Returns a string representation of this {@code MouseEvent} object.
1012      * @return a string representation of this {@code MouseEvent} object.
1013      */
1014     @Override public String toString() {
1015         final StringBuilder sb = new StringBuilder(&quot;MouseEvent [&quot;);
1016 
1017         sb.append(&quot;source = &quot;).append(getSource());
1018         sb.append(&quot;, target = &quot;).append(getTarget());
1019         sb.append(&quot;, eventType = &quot;).append(getEventType());
1020         sb.append(&quot;, consumed = &quot;).append(isConsumed());
1021 
1022         sb.append(&quot;, x = &quot;).append(getX()).append(&quot;, y = &quot;).append(getY())
1023                 .append(&quot;, z = &quot;).append(getZ());
1024 
1025         if (getButton() != null) {
1026             sb.append(&quot;, button = &quot;).append(getButton());
1027         }
1028         if (getClickCount() &gt; 1) {
1029             sb.append(&quot;, clickCount = &quot;).append(getClickCount());
1030         }
1031         if (isPrimaryButtonDown()) {
1032             sb.append(&quot;, primaryButtonDown&quot;);
1033         }
1034         if (isMiddleButtonDown()) {
1035             sb.append(&quot;, middleButtonDown&quot;);
1036         }
1037         if (isSecondaryButtonDown()) {
1038             sb.append(&quot;, secondaryButtonDown&quot;);
1039         }
1040         if (isBackButtonDown()) {
1041             sb.append(&quot;, backButtonDown&quot;);
1042         }
1043         if (isForwardButtonDown()) {
1044             sb.append(&quot;, forwardButtonDown&quot;);
1045         }
1046         if (isShiftDown()) {
1047             sb.append(&quot;, shiftDown&quot;);
1048         }
1049         if (isControlDown()) {
1050             sb.append(&quot;, controlDown&quot;);
1051         }
1052         if (isAltDown()) {
1053             sb.append(&quot;, altDown&quot;);
1054         }
1055         if (isMetaDown()) {
1056             sb.append(&quot;, metaDown&quot;);
1057         }
1058         if (isShortcutDown()) {
1059             sb.append(&quot;, shortcutDown&quot;);
1060         }
1061         if (isSynthesized()) {
1062             sb.append(&quot;, synthesized&quot;);
1063         }
1064         sb.append(&quot;, pickResult = &quot;).append(getPickResult());
1065 
1066         return sb.append(&quot;]&quot;).toString();
1067     }
1068 
1069     /**
1070      * Information about the pick if the picked {@code Node} is a
1071      * {@code Shape3D} node and its pickOnBounds is false.
1072      */
1073     private PickResult pickResult;
1074 
1075     /**
1076      * Returns information about the pick.
1077      *
1078      * @return new PickResult object that contains information about the pick
1079      * @since JavaFX 8.0
1080      */
1081     public final PickResult getPickResult() {
1082         return pickResult;
1083     }
1084 
1085     /**
1086      * These properties need to live in a separate object shared among all the
1087      * copied events to make sure that the values are propagated to the
1088      * original event.
1089      */
1090     private static class Flags implements Cloneable {
1091         /**
1092          * Whether dragDetected event is going to be sent after this event.
1093          * Applies only to MOUSE_PRESSED and MOUSE_MOVED event types.
1094          */
1095         boolean dragDetect = true;
1096 
1097         @Override
1098         public Flags clone() {
1099             try {
1100                 return (Flags) super.clone();
1101             } catch (CloneNotSupportedException e) {
1102                 /* won&#39;t happen */
1103                 return null;
1104             }
1105         }
1106     }
1107 
1108     private void readObject(java.io.ObjectInputStream in)
1109             throws IOException, ClassNotFoundException {
1110         in.defaultReadObject();
1111         x = sceneX;
1112         y = sceneY;
1113     }
1114 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>