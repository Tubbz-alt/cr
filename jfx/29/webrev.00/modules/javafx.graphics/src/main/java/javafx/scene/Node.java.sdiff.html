<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/scene/Node.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../javafx.controls/src/main/java/javafx/scene/control/TreeView.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="input/DragEvent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/javafx/scene/Node.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  208  * subtree will be automatically removed as described above if the application
  209  * doesn&#39;t explicitly remove it.
  210  * &lt;p&gt;
  211  * Node objects may be constructed and modified on any thread as long they are
  212  * not yet attached to a {@link Scene} in a {@link Window} that is
  213  * {@link Window#isShowing showing}.
  214  * An application must attach nodes to such a Scene or modify them on the JavaFX
  215  * Application Thread.
  216  *
  217  * &lt;p&gt;
  218  * The JavaFX Application Thread is created as part of the startup process for
  219  * the JavaFX runtime. See the {@link javafx.application.Application} class and
  220  * the {@link Platform#startup(Runnable)} method for more information.
  221  * &lt;/p&gt;
  222  *
  223  * &lt;p&gt;
  224  * An application should not extend the Node class directly. Doing so may lead to
  225  * an UnsupportedOperationException being thrown.
  226  * &lt;/p&gt;
  227  *
<span class="line-modified">  228  * &lt;h3&gt;String ID&lt;/h3&gt;</span>
  229  * &lt;p&gt;
  230  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  231  * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
  232  * and developer to ensure that the {@code id} is unique within the scene graph.
  233  * A convenience function called {@link #lookup(String)} can be used to find
  234  * a node with a unique id within the scene graph, or within a subtree of the
  235  * scene graph. The id can also be used identify nodes for applying styles; see
  236  * the CSS section below.
  237  *
<span class="line-modified">  238  * &lt;h3&gt;Coordinate System&lt;/h3&gt;</span>
  239  * &lt;p&gt;
  240  * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
  241  * coordinate system in which the {@code x} axis increases to the right and the
  242  * {@code y} axis increases downwards.  The concrete node classes for shapes
  243  * provide variables for defining the geometry and location of the shape
  244  * within this local coordinate space.  For example,
  245  * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
  246  * {@code width}, {@code height} variables while
  247  * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
  248  * and {@code radius}.
  249  * &lt;p&gt;
  250  * At the device pixel level, integer coordinates map onto the corners and
  251  * cracks between the pixels and the centers of the pixels appear at the
  252  * midpoints between integer pixel locations.  Because all coordinate values
  253  * are specified with floating point numbers, coordinates can precisely
  254  * point to these corners (when the floating point values have exact integer
  255  * values) or to any location on the pixel.  For example, a coordinate of
  256  * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
  257  * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
  258  * of {@code 10} by {@code 10} would span from the upper left corner of the
  259  * upper left pixel on the {@code Stage} to the lower right corner of the
  260  * 10th pixel on the 10th scanline.  The pixel center of the last pixel
  261  * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
  262  * &lt;p&gt;
  263  * In practice, most nodes have transformations applied to their coordinate
  264  * system as mentioned below.  As a result, the information above describing
  265  * the alignment of device coordinates to the pixel grid is relative to
  266  * the transformed coordinates, not the local coordinates of the nodes.
  267  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  268  * important context-specific information about coordinate mapping and how
  269  * it can affect rendering.
  270  *
<span class="line-modified">  271  * &lt;h3&gt;Transformations&lt;/h3&gt;</span>
  272  * &lt;p&gt;
  273  * Any {@code Node} can have transformations applied to it. These include
  274  * translation, rotation, scaling, or shearing.
  275  * &lt;p&gt;
  276  * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
  277  * node&#39;s coordinate space along either the x or y axis. For example, if you
  278  * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
  279  * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
  280  * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
  281  * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
  282  * 100 points wide and 50 tall. Note that the origin was shifted, not the
  283  * {@code x} variable of the rectangle.
  284  * &lt;p&gt;
  285  * A common node transform is a translation by an integer distance, most often
  286  * used to lay out nodes on the stage.  Such integer translations maintain the
  287  * device pixel mapping so that local coordinates that are integers still
  288  * map to the cracks between pixels.
  289  * &lt;p&gt;
  290  * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
  291  * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
</pre>
<hr />
<pre>
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
  313  * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
<span class="line-modified">  328  * &lt;h3&gt;Bounding Rectangles&lt;/h3&gt;</span>
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
  334  * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
  335  * variable which specifies the bounding rectangle of the {@code Node} in
  336  * untransformed local coordinates. {@code boundsInLocal} includes the
  337  * Node&#39;s shape geometry, including any space required for a
  338  * non-zero stroke that may fall outside the local position/size variables,
  339  * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
  340  * &lt;p&gt;
  341  * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
  342  * specifies the bounding rectangle of the {@code Node} after all transformations
  343  * have been applied, including those set in {@link #getTransforms transforms},
  344  * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
  345  * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
  346  * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
  347  * parent&#39;s coordinate system.  This is the &#39;visual&#39; bounds of the node.
  348  * &lt;p&gt;
</pre>
<hr />
<pre>
  364  * coordinate space of the Node&#39;s parent. The {@code boundsInLocal} stays the same
  365  * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
  366  * in the coordinate space of the Node.
  367  *
  368  * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
  369  * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
  370  * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
  371  *
  372  * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
  373  * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
  374  * (the stroke is centered by default, so only half of it is outside
  375  * of the original bounds; it is also possible to create inside or outside
  376  * stroke).
  377  *
  378  * Since neither of the rectangles has any transformation applied,
  379  * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
  380  * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
  381  * respective bounds&quot;&gt; &lt;/p&gt;
  382  *
  383  *
<span class="line-modified">  384  * &lt;h3&gt;CSS&lt;/h3&gt;</span>
  385  * &lt;p&gt;
  386  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  387  * {@code style} variables that are used in styling this node from
  388  * CSS. The {@code id} and {@code styleClass} variables are used in
  389  * CSS style sheets to identify nodes to which styles should be
  390  * applied. The {@code style} variable contains style properties and
  391  * values that are applied directly to this node.
  392  * &lt;p&gt;
  393  * For further information about CSS and how to apply CSS styles
  394  * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
  395  * Guide&lt;/a&gt;.
  396  * @since JavaFX 2.0
  397  */
  398 @IDProperty(&quot;id&quot;)
  399 public abstract class Node implements EventTarget, Styleable {
  400 
  401     /*
  402      * Store the singleton instance of the NodeHelper subclass corresponding
  403      * to the subclass of this instance of Node
  404      */
</pre>
</td>
<td>
<hr />
<pre>
  208  * subtree will be automatically removed as described above if the application
  209  * doesn&#39;t explicitly remove it.
  210  * &lt;p&gt;
  211  * Node objects may be constructed and modified on any thread as long they are
  212  * not yet attached to a {@link Scene} in a {@link Window} that is
  213  * {@link Window#isShowing showing}.
  214  * An application must attach nodes to such a Scene or modify them on the JavaFX
  215  * Application Thread.
  216  *
  217  * &lt;p&gt;
  218  * The JavaFX Application Thread is created as part of the startup process for
  219  * the JavaFX runtime. See the {@link javafx.application.Application} class and
  220  * the {@link Platform#startup(Runnable)} method for more information.
  221  * &lt;/p&gt;
  222  *
  223  * &lt;p&gt;
  224  * An application should not extend the Node class directly. Doing so may lead to
  225  * an UnsupportedOperationException being thrown.
  226  * &lt;/p&gt;
  227  *
<span class="line-modified">  228  * &lt;h2&gt;String ID&lt;/h2&gt;</span>
  229  * &lt;p&gt;
  230  * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
  231  * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
  232  * and developer to ensure that the {@code id} is unique within the scene graph.
  233  * A convenience function called {@link #lookup(String)} can be used to find
  234  * a node with a unique id within the scene graph, or within a subtree of the
  235  * scene graph. The id can also be used identify nodes for applying styles; see
  236  * the CSS section below.
  237  *
<span class="line-modified">  238  * &lt;h2&gt;Coordinate System&lt;/h2&gt;</span>
  239  * &lt;p&gt;
  240  * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
  241  * coordinate system in which the {@code x} axis increases to the right and the
  242  * {@code y} axis increases downwards.  The concrete node classes for shapes
  243  * provide variables for defining the geometry and location of the shape
  244  * within this local coordinate space.  For example,
  245  * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
  246  * {@code width}, {@code height} variables while
  247  * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
  248  * and {@code radius}.
  249  * &lt;p&gt;
  250  * At the device pixel level, integer coordinates map onto the corners and
  251  * cracks between the pixels and the centers of the pixels appear at the
  252  * midpoints between integer pixel locations.  Because all coordinate values
  253  * are specified with floating point numbers, coordinates can precisely
  254  * point to these corners (when the floating point values have exact integer
  255  * values) or to any location on the pixel.  For example, a coordinate of
  256  * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
  257  * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
  258  * of {@code 10} by {@code 10} would span from the upper left corner of the
  259  * upper left pixel on the {@code Stage} to the lower right corner of the
  260  * 10th pixel on the 10th scanline.  The pixel center of the last pixel
  261  * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
  262  * &lt;p&gt;
  263  * In practice, most nodes have transformations applied to their coordinate
  264  * system as mentioned below.  As a result, the information above describing
  265  * the alignment of device coordinates to the pixel grid is relative to
  266  * the transformed coordinates, not the local coordinates of the nodes.
  267  * The {@link javafx.scene.shape.Shape Shape} class describes some additional
  268  * important context-specific information about coordinate mapping and how
  269  * it can affect rendering.
  270  *
<span class="line-modified">  271  * &lt;h2&gt;Transformations&lt;/h2&gt;</span>
  272  * &lt;p&gt;
  273  * Any {@code Node} can have transformations applied to it. These include
  274  * translation, rotation, scaling, or shearing.
  275  * &lt;p&gt;
  276  * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
  277  * node&#39;s coordinate space along either the x or y axis. For example, if you
  278  * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
  279  * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
  280  * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
  281  * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
  282  * 100 points wide and 50 tall. Note that the origin was shifted, not the
  283  * {@code x} variable of the rectangle.
  284  * &lt;p&gt;
  285  * A common node transform is a translation by an integer distance, most often
  286  * used to lay out nodes on the stage.  Such integer translations maintain the
  287  * device pixel mapping so that local coordinates that are integers still
  288  * map to the cracks between pixels.
  289  * &lt;p&gt;
  290  * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
  291  * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
</pre>
<hr />
<pre>
  308  * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
  309  * smaller depending on the scaling factor. Scaling alters the coordinate space
  310  * of the node such that each unit of distance along the axis in local
  311  * coordinates is multiplied by the scale factor. As with rotation
  312  * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
  313  * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
  314  * example, if you create a {@link javafx.scene.shape.Rectangle} with a
  315  * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
  316  * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
  317  * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
  318  * (including the stroke) will double in size, growing to the right and
  319  * downwards from the origin.
  320  * &lt;p&gt;
  321  * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
  322  * rotates one axis so that the x and y axes are no longer perpendicular.
  323  * &lt;p&gt;
  324  * Multiple transformations may be applied to a node by specifying an ordered
  325  * chain of transforms.  The order in which the transforms are applied is
  326  * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
  327  *
<span class="line-modified">  328  * &lt;h2&gt;Bounding Rectangles&lt;/h2&gt;</span>
  329  * &lt;p&gt;
  330  * Since every {@code Node} has transformations, every Node&#39;s geometric
  331  * bounding rectangle can be described differently depending on whether
  332  * transformations are accounted for or not.
  333  * &lt;p&gt;
  334  * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
  335  * variable which specifies the bounding rectangle of the {@code Node} in
  336  * untransformed local coordinates. {@code boundsInLocal} includes the
  337  * Node&#39;s shape geometry, including any space required for a
  338  * non-zero stroke that may fall outside the local position/size variables,
  339  * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
  340  * &lt;p&gt;
  341  * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
  342  * specifies the bounding rectangle of the {@code Node} after all transformations
  343  * have been applied, including those set in {@link #getTransforms transforms},
  344  * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
  345  * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
  346  * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
  347  * parent&#39;s coordinate system.  This is the &#39;visual&#39; bounds of the node.
  348  * &lt;p&gt;
</pre>
<hr />
<pre>
  364  * coordinate space of the Node&#39;s parent. The {@code boundsInLocal} stays the same
  365  * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
  366  * in the coordinate space of the Node.
  367  *
  368  * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
  369  * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
  370  * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
  371  *
  372  * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
  373  * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
  374  * (the stroke is centered by default, so only half of it is outside
  375  * of the original bounds; it is also possible to create inside or outside
  376  * stroke).
  377  *
  378  * Since neither of the rectangles has any transformation applied,
  379  * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
  380  * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
  381  * respective bounds&quot;&gt; &lt;/p&gt;
  382  *
  383  *
<span class="line-modified">  384  * &lt;h2&gt;CSS&lt;/h2&gt;</span>
  385  * &lt;p&gt;
  386  * The {@code Node} class contains {@code id}, {@code styleClass}, and
  387  * {@code style} variables that are used in styling this node from
  388  * CSS. The {@code id} and {@code styleClass} variables are used in
  389  * CSS style sheets to identify nodes to which styles should be
  390  * applied. The {@code style} variable contains style properties and
  391  * values that are applied directly to this node.
  392  * &lt;p&gt;
  393  * For further information about CSS and how to apply CSS styles
  394  * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
  395  * Guide&lt;/a&gt;.
  396  * @since JavaFX 2.0
  397  */
  398 @IDProperty(&quot;id&quot;)
  399 public abstract class Node implements EventTarget, Styleable {
  400 
  401     /*
  402      * Store the singleton instance of the NodeHelper subclass corresponding
  403      * to the subclass of this instance of Node
  404      */
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../javafx.controls/src/main/java/javafx/scene/control/TreeView.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="input/DragEvent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>