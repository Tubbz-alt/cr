<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableSkinUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;


  31 import javafx.beans.property.DoubleProperty;
  32 import javafx.beans.property.ReadOnlyObjectProperty;
  33 import javafx.beans.property.ReadOnlyObjectWrapper;
  34 import javafx.beans.value.WritableValue;
  35 import javafx.collections.ListChangeListener;
  36 import javafx.collections.ObservableList;
  37 import javafx.collections.WeakListChangeListener;
<span class="line-modified">  38 import javafx.css.CssMetaData;</span>
<span class="line-modified">  39 import javafx.css.PseudoClass;</span>
<span class="line-removed">  40 import javafx.css.Styleable;</span>
<span class="line-removed">  41 import javafx.css.StyleableDoubleProperty;</span>
<span class="line-removed">  42 import javafx.css.StyleableProperty;</span>
  43 import javafx.event.EventHandler;
  44 import javafx.geometry.HPos;
  45 import javafx.geometry.Insets;
  46 import javafx.geometry.Pos;
  47 import javafx.geometry.VPos;
  48 import javafx.scene.AccessibleAttribute;
  49 import javafx.scene.AccessibleRole;
  50 import javafx.scene.Node;
  51 import javafx.scene.control.ContextMenu;
  52 import javafx.scene.control.Label;

  53 import javafx.scene.control.TableColumn;
  54 import javafx.scene.control.TableColumnBase;





  55 import javafx.scene.input.ContextMenuEvent;
  56 import javafx.scene.input.MouseEvent;
  57 import javafx.scene.layout.GridPane;
  58 import javafx.scene.layout.HBox;
  59 import javafx.scene.layout.Priority;
  60 import javafx.scene.layout.Region;

  61 
  62 import java.util.ArrayList;
  63 import java.util.Collections;
  64 import java.util.List;
  65 import java.util.Locale;
  66 
<span class="line-removed">  67 import javafx.css.converter.SizeConverter;</span>
<span class="line-removed">  68 </span>
  69 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  70 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  71 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  72 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  73 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  74 
  75 
  76 /**
  77  * Region responsible for painting a single column header. A subcomponent used by
  78  * subclasses of {@link TableViewSkinBase}.
  79  *
  80  * @since 9
  81  */
  82 public class TableColumnHeader extends Region {
  83 
  84     /***************************************************************************
  85      *                                                                         *
  86      * Static Fields                                                           *
  87      *                                                                         *
  88      **************************************************************************/
</pre>
<hr />
<pre>
 569 
 570         // --- label
 571         label = new Label();
 572         label.setText(getTableColumn().getText());
 573         label.setGraphic(getTableColumn().getGraphic());
 574         label.setVisible(getTableColumn().isVisible());
 575 
 576         // ---- container for the sort arrow (which is not supported on embedded
 577         // platforms)
 578         if (isSortingEnabled()) {
 579             // put together the grid
 580             updateSortGrid();
 581         }
 582     }
 583 
 584     private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {
 585         double prefWidth = column.getPrefWidth();
 586 
 587         // if the prefWidth has been set, we do _not_ autosize columns
 588         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 589             TableSkinUtils.resizeColumnToFitContent(getTableSkin(), column, cellsToMeasure);</span>
<span class="line-modified"> 590 //            getTableViewSkin().resizeColumnToFitContent(column, cellsToMeasure);</span>






































































































































































 591         }
 592     }
 593 
 594     private void updateSortPosition() {
 595         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 596         updateSortGrid();
 597     }
 598 
 599     private void updateSortGrid() {
 600         // Fix for RT-14488
 601         if (this instanceof NestedTableColumnHeader) return;
 602 
 603         getChildren().clear();
 604         getChildren().add(label);
 605 
 606         // we do not support sorting in embedded devices
 607         if (! isSortingEnabled()) return;
 608 
 609         isSortColumn = sortPos != -1;
 610         if (! isSortColumn) {
</pre>
</td>
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;
<span class="line-added">  31 import com.sun.javafx.scene.control.TreeTableViewBackingList;</span>
<span class="line-added">  32 import com.sun.javafx.scene.control.skin.Utils;</span>
  33 import javafx.beans.property.DoubleProperty;
  34 import javafx.beans.property.ReadOnlyObjectProperty;
  35 import javafx.beans.property.ReadOnlyObjectWrapper;
  36 import javafx.beans.value.WritableValue;
  37 import javafx.collections.ListChangeListener;
  38 import javafx.collections.ObservableList;
  39 import javafx.collections.WeakListChangeListener;
<span class="line-modified">  40 import javafx.css.*;</span>
<span class="line-modified">  41 import javafx.css.converter.SizeConverter;</span>



  42 import javafx.event.EventHandler;
  43 import javafx.geometry.HPos;
  44 import javafx.geometry.Insets;
  45 import javafx.geometry.Pos;
  46 import javafx.geometry.VPos;
  47 import javafx.scene.AccessibleAttribute;
  48 import javafx.scene.AccessibleRole;
  49 import javafx.scene.Node;
  50 import javafx.scene.control.ContextMenu;
  51 import javafx.scene.control.Label;
<span class="line-added">  52 import javafx.scene.control.TableCell;</span>
  53 import javafx.scene.control.TableColumn;
  54 import javafx.scene.control.TableColumnBase;
<span class="line-added">  55 import javafx.scene.control.TableView;</span>
<span class="line-added">  56 import javafx.scene.control.TreeTableCell;</span>
<span class="line-added">  57 import javafx.scene.control.TreeTableColumn;</span>
<span class="line-added">  58 import javafx.scene.control.TreeTableRow;</span>
<span class="line-added">  59 import javafx.scene.control.TreeTableView;</span>
  60 import javafx.scene.input.ContextMenuEvent;
  61 import javafx.scene.input.MouseEvent;
  62 import javafx.scene.layout.GridPane;
  63 import javafx.scene.layout.HBox;
  64 import javafx.scene.layout.Priority;
  65 import javafx.scene.layout.Region;
<span class="line-added">  66 import javafx.util.Callback;</span>
  67 
  68 import java.util.ArrayList;
  69 import java.util.Collections;
  70 import java.util.List;
  71 import java.util.Locale;
  72 


  73 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  74 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  75 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  76 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  77 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  78 
  79 
  80 /**
  81  * Region responsible for painting a single column header. A subcomponent used by
  82  * subclasses of {@link TableViewSkinBase}.
  83  *
  84  * @since 9
  85  */
  86 public class TableColumnHeader extends Region {
  87 
  88     /***************************************************************************
  89      *                                                                         *
  90      * Static Fields                                                           *
  91      *                                                                         *
  92      **************************************************************************/
</pre>
<hr />
<pre>
 573 
 574         // --- label
 575         label = new Label();
 576         label.setText(getTableColumn().getText());
 577         label.setGraphic(getTableColumn().getGraphic());
 578         label.setVisible(getTableColumn().isVisible());
 579 
 580         // ---- container for the sort arrow (which is not supported on embedded
 581         // platforms)
 582         if (isSortingEnabled()) {
 583             // put together the grid
 584             updateSortGrid();
 585         }
 586     }
 587 
 588     private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {
 589         double prefWidth = column.getPrefWidth();
 590 
 591         // if the prefWidth has been set, we do _not_ autosize columns
 592         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 593             resizeColumnToFitContent(column, cellsToMeasure);</span>
<span class="line-modified"> 594         }</span>
<span class="line-added"> 595     }</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597     /**</span>
<span class="line-added"> 598      * Resizes the given column based on the preferred width of all items contained in it. This can be potentially very</span>
<span class="line-added"> 599      * expensive if the number of rows is large. Subclass can either call this method or override it (no need to call</span>
<span class="line-added"> 600      * {@code super()}) to provide their custom algorithm.</span>
<span class="line-added"> 601      *</span>
<span class="line-added"> 602      * @param tc      the column to resize</span>
<span class="line-added"> 603      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.</span>
<span class="line-added"> 604      * @since 12</span>
<span class="line-added"> 605      */</span>
<span class="line-added"> 606     protected void resizeColumnToFitContent(TableColumnBase&lt;?, ?&gt; tc, int maxRows) {</span>
<span class="line-added"> 607         if (!tc.isResizable()) return;</span>
<span class="line-added"> 608 </span>
<span class="line-added"> 609         Object control = this.getTableSkin().getSkinnable();</span>
<span class="line-added"> 610         if (control instanceof TableView) {</span>
<span class="line-added"> 611             resizeColumnToFitContent((TableView)control, (TableColumn)tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 612         } else if (control instanceof TreeTableView) {</span>
<span class="line-added"> 613             resizeColumnToFitContent((TreeTableView)control, (TreeTableColumn)tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 614         }</span>
<span class="line-added"> 615     }</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 618         List&lt;?&gt; items = tv.getItems();</span>
<span class="line-added"> 619         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 620 </span>
<span class="line-added"> 621         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 622         if (cellFactory == null) return;</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);</span>
<span class="line-added"> 625         if (cell == null) return;</span>
<span class="line-added"> 626 </span>
<span class="line-added"> 627         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 628         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 629         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631         // determine cell padding</span>
<span class="line-added"> 632         double padding = 10;</span>
<span class="line-added"> 633         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 634         if (n instanceof Region) {</span>
<span class="line-added"> 635             Region r = (Region) n;</span>
<span class="line-added"> 636             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 637         }</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 640         double maxWidth = 0;</span>
<span class="line-added"> 641         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 642             cell.updateTableColumn(tc);</span>
<span class="line-added"> 643             cell.updateTableView(tv);</span>
<span class="line-added"> 644             cell.updateIndex(row);</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 647                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 648                 cell.applyCss();</span>
<span class="line-added"> 649                 maxWidth = Math.max(maxWidth, cell.prefWidth(-1));</span>
<span class="line-added"> 650                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 651             }</span>
<span class="line-added"> 652         }</span>
<span class="line-added"> 653 </span>
<span class="line-added"> 654         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 655         cell.updateIndex(-1);</span>
<span class="line-added"> 656 </span>
<span class="line-added"> 657         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 658         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 659         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 660         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 661         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 662         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 663         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 664         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 665 </span>
<span class="line-added"> 666         // RT-23486</span>
<span class="line-added"> 667         maxWidth += padding;</span>
<span class="line-added"> 668         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {</span>
<span class="line-added"> 669             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 670                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 671             }</span>
<span class="line-added"> 672 </span>
<span class="line-added"> 673             int size = tc.getColumns().size();</span>
<span class="line-added"> 674             if (size &gt; 0) {</span>
<span class="line-added"> 675                 resizeColumnToFitContent(tc.getColumns().get(size - 1), maxRows);</span>
<span class="line-added"> 676                 return;</span>
<span class="line-added"> 677             }</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 680         } else {</span>
<span class="line-added"> 681             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
<span class="line-added"> 682         }</span>
<span class="line-added"> 683     }</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 686         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);</span>
<span class="line-added"> 687         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 688 </span>
<span class="line-added"> 689         Callback cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 690         if (cellFactory == null) return;</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);</span>
<span class="line-added"> 693         if (cell == null) return;</span>
<span class="line-added"> 694 </span>
<span class="line-added"> 695         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 696         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 697         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 698 </span>
<span class="line-added"> 699         // determine cell padding</span>
<span class="line-added"> 700         double padding = 10;</span>
<span class="line-added"> 701         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 702         if (n instanceof Region) {</span>
<span class="line-added"> 703             Region r = (Region) n;</span>
<span class="line-added"> 704             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 705         }</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         TreeTableRow&lt;T&gt; treeTableRow = new TreeTableRow&lt;&gt;();</span>
<span class="line-added"> 708         treeTableRow.updateTreeTableView(ttv);</span>
<span class="line-added"> 709 </span>
<span class="line-added"> 710         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 711         double maxWidth = 0;</span>
<span class="line-added"> 712         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 713             treeTableRow.updateIndex(row);</span>
<span class="line-added"> 714             treeTableRow.updateTreeItem(ttv.getTreeItem(row));</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716             cell.updateTreeTableColumn(tc);</span>
<span class="line-added"> 717             cell.updateTreeTableView(ttv);</span>
<span class="line-added"> 718             cell.updateTreeTableRow(treeTableRow);</span>
<span class="line-added"> 719             cell.updateIndex(row);</span>
<span class="line-added"> 720 </span>
<span class="line-added"> 721             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 722                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 723                 cell.applyCss();</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725                 double w = cell.prefWidth(-1);</span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727                 maxWidth = Math.max(maxWidth, w);</span>
<span class="line-added"> 728                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 729             }</span>
<span class="line-added"> 730         }</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 733         cell.updateIndex(-1);</span>
<span class="line-added"> 734 </span>
<span class="line-added"> 735         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 736         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 737         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 738         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 739         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 740         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 741         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 742         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744         // RT-23486</span>
<span class="line-added"> 745         maxWidth += padding;</span>
<span class="line-added"> 746         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {</span>
<span class="line-added"> 747 </span>
<span class="line-added"> 748             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 749                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 750             }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752             int size = tc.getColumns().size();</span>
<span class="line-added"> 753             if (size &gt; 0) {</span>
<span class="line-added"> 754                 resizeColumnToFitContent(tc.getColumns().get(size - 1), maxRows);</span>
<span class="line-added"> 755                 return;</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757 </span>
<span class="line-added"> 758             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 759         } else {</span>
<span class="line-added"> 760             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
 761         }
 762     }
 763 
 764     private void updateSortPosition() {
 765         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 766         updateSortGrid();
 767     }
 768 
 769     private void updateSortGrid() {
 770         // Fix for RT-14488
 771         if (this instanceof NestedTableColumnHeader) return;
 772 
 773         getChildren().clear();
 774         getChildren().add(label);
 775 
 776         // we do not support sorting in embedded devices
 777         if (! isSortingEnabled()) return;
 778 
 779         isSortColumn = sortPos != -1;
 780         if (! isSortColumn) {
</pre>
</td>
</tr>
</table>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableSkinUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>