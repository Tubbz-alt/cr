<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;
<a name="1" id="anc1"></a>

  31 import javafx.beans.property.DoubleProperty;
  32 import javafx.beans.property.ReadOnlyObjectProperty;
  33 import javafx.beans.property.ReadOnlyObjectWrapper;
  34 import javafx.beans.value.WritableValue;
  35 import javafx.collections.ListChangeListener;
  36 import javafx.collections.ObservableList;
  37 import javafx.collections.WeakListChangeListener;
<a name="2" id="anc2"></a><span class="line-modified">  38 import javafx.css.CssMetaData;</span>
<span class="line-modified">  39 import javafx.css.PseudoClass;</span>
<span class="line-removed">  40 import javafx.css.Styleable;</span>
<span class="line-removed">  41 import javafx.css.StyleableDoubleProperty;</span>
<span class="line-removed">  42 import javafx.css.StyleableProperty;</span>
  43 import javafx.event.EventHandler;
  44 import javafx.geometry.HPos;
  45 import javafx.geometry.Insets;
  46 import javafx.geometry.Pos;
  47 import javafx.geometry.VPos;
  48 import javafx.scene.AccessibleAttribute;
  49 import javafx.scene.AccessibleRole;
  50 import javafx.scene.Node;
  51 import javafx.scene.control.ContextMenu;
  52 import javafx.scene.control.Label;
<a name="3" id="anc3"></a>
  53 import javafx.scene.control.TableColumn;
  54 import javafx.scene.control.TableColumnBase;
<a name="4" id="anc4"></a>




  55 import javafx.scene.input.ContextMenuEvent;
  56 import javafx.scene.input.MouseEvent;
  57 import javafx.scene.layout.GridPane;
  58 import javafx.scene.layout.HBox;
  59 import javafx.scene.layout.Priority;
  60 import javafx.scene.layout.Region;
<a name="5" id="anc5"></a>
  61 
  62 import java.util.ArrayList;
  63 import java.util.Collections;
  64 import java.util.List;
  65 import java.util.Locale;
  66 
<a name="6" id="anc6"></a><span class="line-removed">  67 import javafx.css.converter.SizeConverter;</span>
<span class="line-removed">  68 </span>
  69 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  70 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  71 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  72 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  73 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  74 
  75 
  76 /**
  77  * Region responsible for painting a single column header. A subcomponent used by
  78  * subclasses of {@link TableViewSkinBase}.
  79  *
  80  * @since 9
  81  */
  82 public class TableColumnHeader extends Region {
  83 
  84     /***************************************************************************
  85      *                                                                         *
  86      * Static Fields                                                           *
  87      *                                                                         *
  88      **************************************************************************/
  89 
  90     static final String DEFAULT_STYLE_CLASS = &quot;column-header&quot;;
  91 
  92     // Copied from TableColumn. The value here should always be in-sync with
  93     // the value in TableColumn
  94     static final double DEFAULT_COLUMN_WIDTH = 80.0F;
  95 
  96 
  97 
  98     /***************************************************************************
  99      *                                                                         *
 100      * Private Fields                                                          *
 101      *                                                                         *
 102      **************************************************************************/
 103 
 104     private boolean autoSizeComplete = false;
 105 
 106     private double dragOffset;
 107     private NestedTableColumnHeader nestedColumnHeader;
 108     private TableHeaderRow tableHeaderRow;
 109     private NestedTableColumnHeader parentHeader;
 110 
 111     // work out where this column currently is within its parent
 112     Label label;
 113 
 114     // sort order
 115     int sortPos = -1;
 116     private Region arrow;
 117     private Label sortOrderLabel;
 118     private HBox sortOrderDots;
 119     private Node sortArrow;
 120     private boolean isSortColumn;
 121 
 122     private boolean isSizeDirty = false;
 123 
 124     boolean isLastVisibleColumn = false;
 125 
 126     // package for testing
 127     int columnIndex = -1;
 128 
 129     private int newColumnPos;
 130 
 131     // the line drawn in the table when a user presses and moves a column header
 132     // to indicate where the column will be dropped. This is provided by the
 133     // table skin, but manipulated by the header
 134     Region columnReorderLine;
 135 
 136 
 137 
 138     /***************************************************************************
 139      *                                                                         *
 140      * Constructor                                                             *
 141      *                                                                         *
 142      **************************************************************************/
 143 
 144     /**
 145      * Creates a new TableColumnHeader instance to visually represent the given
 146      * {@link TableColumnBase} instance.
 147      *
 148      * @param tc The table column to be visually represented by this instance.
 149      */
 150     public TableColumnHeader(final TableColumnBase tc) {
 151         setTableColumn(tc);
 152         setFocusTraversable(false);
 153 
 154         initStyleClasses();
 155         initUI();
 156 
 157         // change listener for multiple properties
 158         changeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();
 159         changeListenerHandler.registerChangeListener(sceneProperty(), e -&gt; updateScene());
 160 
 161         if (getTableColumn() != null) {
 162             changeListenerHandler.registerChangeListener(tc.idProperty(), e -&gt; setId(tc.getId()));
 163             changeListenerHandler.registerChangeListener(tc.styleProperty(), e -&gt; setStyle(tc.getStyle()));
 164             changeListenerHandler.registerChangeListener(tc.widthProperty(), e -&gt; {
 165                 // It is this that ensures that when a column is resized that the header
 166                 // visually adjusts its width as necessary.
 167                 isSizeDirty = true;
 168                 requestLayout();
 169             });
 170             changeListenerHandler.registerChangeListener(tc.visibleProperty(), e -&gt; setVisible(getTableColumn().isVisible()));
 171             changeListenerHandler.registerChangeListener(tc.sortNodeProperty(), e -&gt; updateSortGrid());
 172             changeListenerHandler.registerChangeListener(tc.sortableProperty(), e -&gt; {
 173                 // we need to notify all headers that a sortable state has changed,
 174                 // in case the sort grid in other columns needs to be updated.
 175                 if (TableSkinUtils.getSortOrder(getTableSkin()).contains(getTableColumn())) {
 176                     NestedTableColumnHeader root = getTableHeaderRow().getRootHeader();
 177                     updateAllHeaders(root);
 178                 }
 179             });
 180             changeListenerHandler.registerChangeListener(tc.textProperty(), e -&gt; label.setText(tc.getText()));
 181             changeListenerHandler.registerChangeListener(tc.graphicProperty(), e -&gt; label.setGraphic(tc.getGraphic()));
 182 
 183             setId(tc.getId());
 184             setStyle(tc.getStyle());
 185             /* Having TableColumn role parented by TableColumn causes VoiceOver to be unhappy */
 186             setAccessibleRole(AccessibleRole.TABLE_COLUMN);
 187         }
 188     }
 189 
 190 
 191 
 192     /***************************************************************************
 193      *                                                                         *
 194      * Listeners                                                               *
 195      *                                                                         *
 196      **************************************************************************/
 197 
 198     final LambdaMultiplePropertyChangeListenerHandler changeListenerHandler;
 199 
 200     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderListener = c -&gt; {
 201         updateSortPosition();
 202     };
 203 
 204     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
 205         updateColumnIndex();
 206         updateSortPosition();
 207     };
 208 
 209     private ListChangeListener&lt;String&gt; styleClassListener = c -&gt; {
 210         while (c.next()) {
 211             if (c.wasRemoved()) {
 212                 getStyleClass().removeAll(c.getRemoved());
 213             }
 214             if (c.wasAdded()) {
 215                 getStyleClass().addAll(c.getAddedSubList());
 216             }
 217         }
 218     };
 219 
 220     private WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakSortOrderListener =
 221             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrderListener);
 222     private final WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakVisibleLeafColumnsListener =
 223             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(visibleLeafColumnsListener);
 224     private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
 225             new WeakListChangeListener&lt;String&gt;(styleClassListener);
 226 
 227     private static final EventHandler&lt;MouseEvent&gt; mousePressedHandler = me -&gt; {
 228         TableColumnHeader header = (TableColumnHeader) me.getSource();
 229         TableColumnBase tableColumn = header.getTableColumn();
 230 
 231         ContextMenu menu = tableColumn.getContextMenu();
 232         if (menu != null &amp;&amp; menu.isShowing()) {
 233             menu.hide();
 234         }
 235 
 236         if (me.isConsumed()) return;
 237         me.consume();
 238 
 239         header.getTableHeaderRow().columnDragLock = true;
 240 
 241         // pass focus to the table, so that the user immediately sees
 242         // the focus rectangle around the table control.
 243         header.getTableSkin().getSkinnable().requestFocus();
 244 
 245         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 246             header.columnReorderingStarted(me.getX());
 247         }
 248     };
 249 
 250     private static final EventHandler&lt;MouseEvent&gt; mouseDraggedHandler = me -&gt; {
 251         if (me.isConsumed()) return;
 252         me.consume();
 253 
 254         TableColumnHeader header = (TableColumnHeader) me.getSource();
 255 
 256         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 257             header.columnReordering(me.getSceneX(), me.getSceneY());
 258         }
 259     };
 260 
 261     private static final EventHandler&lt;MouseEvent&gt; mouseReleasedHandler = me -&gt; {
 262         if (me.isPopupTrigger()) return;
 263         if (me.isConsumed()) return;
 264         me.consume();
 265 
 266         TableColumnHeader header = (TableColumnHeader) me.getSource();
 267         header.getTableHeaderRow().columnDragLock = false;
 268 
 269         if (header.getTableHeaderRow().isReordering() &amp;&amp; header.isColumnReorderingEnabled()) {
 270             header.columnReorderingComplete();
 271         } else if (me.isStillSincePress()) {
 272             header.sortColumn(me.isShiftDown());
 273         }
 274     };
 275 
 276     private static final EventHandler&lt;ContextMenuEvent&gt; contextMenuRequestedHandler = me -&gt; {
 277         TableColumnHeader header = (TableColumnHeader) me.getSource();
 278         TableColumnBase tableColumn = header.getTableColumn();
 279 
 280         ContextMenu menu = tableColumn.getContextMenu();
 281         if (menu != null) {
 282             menu.show(header, me.getScreenX(), me.getScreenY());
 283             me.consume();
 284         }
 285     };
 286 
 287 
 288 
 289     /***************************************************************************
 290      *                                                                         *
 291      * Properties                                                              *
 292      *                                                                         *
 293      **************************************************************************/
 294 
 295     // --- size
 296     private DoubleProperty size;
 297     private final double getSize() {
 298         return size == null ? 20.0 : size.doubleValue();
 299     }
 300     private final DoubleProperty sizeProperty() {
 301         if (size == null) {
 302             size = new StyleableDoubleProperty(20) {
 303                 @Override
 304                 protected void invalidated() {
 305                     double value = get();
 306                     if (value &lt;= 0) {
 307                         if (isBound()) {
 308                             unbind();
 309                         }
 310                         set(20);
 311                         throw new IllegalArgumentException(&quot;Size cannot be 0 or negative&quot;);
 312                     }
 313                 }
 314 
 315 
 316 
 317                 @Override public Object getBean() {
 318                     return TableColumnHeader.this;
 319                 }
 320 
 321                 @Override public String getName() {
 322                     return &quot;size&quot;;
 323                 }
 324 
 325                 @Override public CssMetaData&lt;TableColumnHeader,Number&gt; getCssMetaData() {
 326                     return StyleableProperties.SIZE;
 327                 }
 328             };
 329         }
 330         return size;
 331     }
 332 
 333 
 334     /**
 335      * A property that refers to the {@link TableColumnBase} instance that this
 336      * header is visually represents.
 337      */
 338     // --- table column
 339     private ReadOnlyObjectWrapper&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableColumn&quot;);
 340     private final void setTableColumn(TableColumnBase&lt;?,?&gt; column) {
 341         tableColumn.set(column);
 342     }
 343     public final TableColumnBase&lt;?,?&gt; getTableColumn() {
 344         return tableColumn.get();
 345     }
 346     public final ReadOnlyObjectProperty&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumnProperty() {
 347         return tableColumn.getReadOnlyProperty();
 348     }
 349 
 350 
 351 
 352     /***************************************************************************
 353      *                                                                         *
 354      * Public API                                                              *
 355      *                                                                         *
 356      **************************************************************************/
 357 
 358     /** {@inheritDoc} */
 359     @Override protected void layoutChildren() {
 360         if (isSizeDirty) {
 361             resize(getTableColumn().getWidth(), getHeight());
 362             isSizeDirty = false;
 363         }
 364 
 365         double sortWidth = 0;
 366         double w = snapSizeX(getWidth()) - (snappedLeftInset() + snappedRightInset());
 367         double h = getHeight() - (snappedTopInset() + snappedBottomInset());
 368         double x = w;
 369 
 370         // a bit hacky, but we REALLY don&#39;t want the arrow shape to fluctuate
 371         // in size
 372         if (arrow != null) {
 373             arrow.setMaxSize(arrow.prefWidth(-1), arrow.prefHeight(-1));
 374         }
 375 
 376         if (sortArrow != null &amp;&amp; sortArrow.isVisible()) {
 377             sortWidth = sortArrow.prefWidth(-1);
 378             x -= sortWidth;
 379             sortArrow.resize(sortWidth, sortArrow.prefHeight(-1));
 380             positionInArea(sortArrow, x, snappedTopInset(),
 381                     sortWidth, h, 0, HPos.CENTER, VPos.CENTER);
 382         }
 383 
 384         if (label != null) {
 385             double labelWidth = w - sortWidth;
 386             label.resizeRelocate(snappedLeftInset(), 0, labelWidth, getHeight());
 387         }
 388     }
 389 
 390     /** {@inheritDoc} */
 391     @Override protected double computePrefWidth(double height) {
 392         if (getNestedColumnHeader() != null) {
 393             double width = getNestedColumnHeader().prefWidth(height);
 394 
 395             if (getTableColumn() != null) {
 396                 TableColumnBaseHelper.setWidth(getTableColumn(), width);
 397             }
 398 
 399             return width;
 400         } else if (getTableColumn() != null &amp;&amp; getTableColumn().isVisible()) {
 401             return snapSizeX(getTableColumn().getWidth());
 402         }
 403 
 404         return 0;
 405     }
 406 
 407     /** {@inheritDoc} */
 408     @Override protected double computeMinHeight(double width) {
 409         return label == null ? 0 : label.minHeight(width);
 410     }
 411 
 412     /** {@inheritDoc} */
 413     @Override protected double computePrefHeight(double width) {
 414         if (getTableColumn() == null) return 0;
 415         return Math.max(getSize(), label.prefHeight(-1));
 416     }
 417 
 418     /** {@inheritDoc} */
 419     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 420         return getClassCssMetaData();
 421     }
 422 
 423     /** {@inheritDoc} */
 424     @Override  public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 425         switch (attribute) {
 426             case INDEX: return getIndex(getTableColumn());
 427             case TEXT: return getTableColumn() != null ? getTableColumn().getText() : null;
 428             default: return super.queryAccessibleAttribute(attribute, parameters);
 429         }
 430     }
 431 
 432 
 433 
 434     /***************************************************************************
 435      *                                                                         *
 436      * Private Implementation                                                  *
 437      *                                                                         *
 438      **************************************************************************/
 439 
 440     void initStyleClasses() {
 441         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 442         installTableColumnStyleClassListener();
 443     }
 444 
 445     void installTableColumnStyleClassListener() {
 446         TableColumnBase tc = getTableColumn();
 447         if (tc != null) {
 448             // add in all styleclasses from the table column into the header, and also set up a listener
 449             // so that any subsequent changes to the table column are also applied to the header
 450             getStyleClass().addAll(tc.getStyleClass());
 451             tc.getStyleClass().addListener(weakStyleClassListener);
 452         }
 453     }
 454 
 455     NestedTableColumnHeader getNestedColumnHeader() { return nestedColumnHeader; }
 456     void setNestedColumnHeader(NestedTableColumnHeader nch) { nestedColumnHeader = nch; }
 457 
 458     /**
 459      * Returns the {@link TableHeaderRow} associated with this {@code TableColumnHeader}.
 460      *
 461      * @return the {@code TableHeaderRow} associated with this {@code TableColumnHeader}
 462      * @since 12
 463      */
 464     protected TableHeaderRow getTableHeaderRow() {
 465         return tableHeaderRow;
 466     }
 467 
 468     void setTableHeaderRow(TableHeaderRow thr) {
 469         tableHeaderRow = thr;
 470         updateTableSkin();
 471     }
 472 
 473     private void updateTableSkin() {
 474         // when we get the table header row, we are also given the skin,
 475         // so this is the time to hook up listeners, etc.
 476         TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin = getTableSkin();
 477         if (tableSkin == null) return;
 478 
 479         updateColumnIndex();
 480         this.columnReorderLine = tableSkin.getColumnReorderLine();
 481 
 482         if (getTableColumn() != null) {
 483             updateSortPosition();
 484             TableSkinUtils.getSortOrder(tableSkin).addListener(weakSortOrderListener);
 485             TableSkinUtils.getVisibleLeafColumns(tableSkin).addListener(weakVisibleLeafColumnsListener);
 486         }
 487     }
 488 
 489     /**
 490      * Returns the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted. This will return
 491      * {@code null} until the {@code TableHeaderRow} has been set.
 492      *
 493      * @return the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted, or {@code null}
 494      * @since 12
 495      */
 496     protected TableViewSkinBase&lt;?, ?, ?, ?, ?&gt; getTableSkin() {
 497         return tableHeaderRow == null ? null : tableHeaderRow.tableSkin;
 498     }
 499 
 500     NestedTableColumnHeader getParentHeader() { return parentHeader; }
 501     void setParentHeader(NestedTableColumnHeader ph) { parentHeader = ph; }
 502 
 503     // RT-29682: When the sortable property of a TableColumnBase changes this
 504     // may impact other TableColumnHeaders, as they may need to change their
 505     // sort order representation. Rather than install listeners across all
 506     // TableColumn in the sortOrder list for their sortable property, we simply
 507     // update the sortPosition of all headers whenever the sortOrder property
 508     // changes, assuming the column is within the sortOrder list.
 509     private void updateAllHeaders(TableColumnHeader header) {
 510         if (header instanceof NestedTableColumnHeader) {
 511             List&lt;TableColumnHeader&gt; children = ((NestedTableColumnHeader)header).getColumnHeaders();
 512             for (int i = 0; i &lt; children.size(); i++) {
 513                 updateAllHeaders(children.get(i));
 514             }
 515         } else {
 516             header.updateSortPosition();
 517         }
 518     }
 519 
 520     private void updateScene() {
 521         // RT-17684: If the TableColumn widths are all currently the default,
 522         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 523         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 524         // number of rows retrieved from a very slow (e.g. remote) data source.
 525         // Obviously, the bigger the value of n, the more likely the default
 526         // width will be suitable for most values in the column
 527         final int n = 30;
 528         if (! autoSizeComplete) {
 529             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 530                 return;
 531             }
<a name="7" id="anc7"></a><span class="line-modified"> 532             doColumnAutoSize(getTableColumn(), n);</span>
 533             autoSizeComplete = true;
 534         }
 535     }
 536 
 537     void dispose() {
 538         TableViewSkinBase tableSkin = getTableSkin();
 539         if (tableSkin != null) {
 540             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 541             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 542         }
 543 
 544         changeListenerHandler.dispose();
 545     }
 546 
 547     private boolean isSortingEnabled() {
 548         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 549         // to always return true (for now), as we want to support column sorting
 550         // everywhere
 551         return true;
 552     }
 553 
 554     private boolean isColumnReorderingEnabled() {
 555         // we only allow for column reordering if there are more than one column,
 556         return !Properties.IS_TOUCH_SUPPORTED &amp;&amp; TableSkinUtils.getVisibleLeafColumns(getTableSkin()).size() &gt; 1;
 557     }
 558 
 559     private void initUI() {
 560         // TableColumn will be null if we are dealing with the root NestedTableColumnHeader
 561         if (getTableColumn() == null) return;
 562 
 563         // set up mouse events
 564         setOnMousePressed(mousePressedHandler);
 565         setOnMouseDragged(mouseDraggedHandler);
 566         setOnDragDetected(event -&gt; event.consume());
 567         setOnContextMenuRequested(contextMenuRequestedHandler);
 568         setOnMouseReleased(mouseReleasedHandler);
 569 
 570         // --- label
 571         label = new Label();
 572         label.setText(getTableColumn().getText());
 573         label.setGraphic(getTableColumn().getGraphic());
 574         label.setVisible(getTableColumn().isVisible());
 575 
 576         // ---- container for the sort arrow (which is not supported on embedded
 577         // platforms)
 578         if (isSortingEnabled()) {
 579             // put together the grid
 580             updateSortGrid();
 581         }
 582     }
 583 
<a name="8" id="anc8"></a><span class="line-modified"> 584     private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {</span>
<span class="line-modified"> 585         double prefWidth = column.getPrefWidth();</span>
 586 
 587         // if the prefWidth has been set, we do _not_ autosize columns
 588         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<a name="9" id="anc9"></a><span class="line-modified"> 589             TableSkinUtils.resizeColumnToFitContent(getTableSkin(), column, cellsToMeasure);</span>
<span class="line-modified"> 590 //            getTableViewSkin().resizeColumnToFitContent(column, cellsToMeasure);</span>
















































































































































































 591         }
 592     }
 593 
 594     private void updateSortPosition() {
 595         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 596         updateSortGrid();
 597     }
 598 
 599     private void updateSortGrid() {
 600         // Fix for RT-14488
 601         if (this instanceof NestedTableColumnHeader) return;
 602 
 603         getChildren().clear();
 604         getChildren().add(label);
 605 
 606         // we do not support sorting in embedded devices
 607         if (! isSortingEnabled()) return;
 608 
 609         isSortColumn = sortPos != -1;
 610         if (! isSortColumn) {
 611             if (sortArrow != null) {
 612                 sortArrow.setVisible(false);
 613             }
 614             return;
 615         }
 616 
 617         // RT-28016: if the tablecolumn is not a visible leaf column, we should ignore this
 618         int visibleLeafIndex = TableSkinUtils.getVisibleLeafIndex(getTableSkin(), getTableColumn());
 619         if (visibleLeafIndex == -1) return;
 620 
 621         final int sortColumnCount = getVisibleSortOrderColumnCount();
 622         boolean showSortOrderDots = sortPos &lt;= 3 &amp;&amp; sortColumnCount &gt; 1;
 623 
 624         Node _sortArrow = null;
 625         if (getTableColumn().getSortNode() != null) {
 626             _sortArrow = getTableColumn().getSortNode();
 627             getChildren().add(_sortArrow);
 628         } else {
 629             GridPane sortArrowGrid = new GridPane();
 630             _sortArrow = sortArrowGrid;
 631             sortArrowGrid.setPadding(new Insets(0, 3, 0, 0));
 632             getChildren().add(sortArrowGrid);
 633 
 634             // if we are here, and the sort arrow is null, we better create it
 635             if (arrow == null) {
 636                 arrow = new Region();
 637                 arrow.getStyleClass().setAll(&quot;arrow&quot;);
 638                 arrow.setVisible(true);
 639                 arrow.setRotate(isAscending(getTableColumn()) ? 180.0F : 0.0F);
 640                 changeListenerHandler.registerChangeListener(getSortTypeProperty(getTableColumn()), e -&gt; {
 641                     updateSortGrid();
 642                     if (arrow != null) {
 643                         arrow.setRotate(isAscending(getTableColumn()) ? 180 : 0.0);
 644                     }
 645                 });
 646             }
 647 
 648             arrow.setVisible(isSortColumn);
 649 
 650             if (sortPos &gt; 2) {
 651                 if (sortOrderLabel == null) {
 652                     // ---- sort order label (for sort positions greater than 3)
 653                     sortOrderLabel = new Label();
 654                     sortOrderLabel.getStyleClass().add(&quot;sort-order&quot;);
 655                 }
 656 
 657                 // only show the label if the sortPos is greater than 3 (for sortPos
 658                 // values less than three, we show the sortOrderDots instead)
 659                 sortOrderLabel.setText(&quot;&quot; + (sortPos + 1));
 660                 sortOrderLabel.setVisible(sortColumnCount &gt; 1);
 661 
 662                 // update the grid layout
 663                 sortArrowGrid.add(arrow, 1, 1);
 664                 GridPane.setHgrow(arrow, Priority.NEVER);
 665                 GridPane.setVgrow(arrow, Priority.NEVER);
 666                 sortArrowGrid.add(sortOrderLabel, 2, 1);
 667             } else if (showSortOrderDots) {
 668                 if (sortOrderDots == null) {
 669                     sortOrderDots = new HBox(0);
 670                     sortOrderDots.getStyleClass().add(&quot;sort-order-dots-container&quot;);
 671                 }
 672 
 673                 // show the sort order dots
 674                 boolean isAscending = isAscending(getTableColumn());
 675                 int arrowRow = isAscending ? 1 : 2;
 676                 int dotsRow = isAscending ? 2 : 1;
 677 
 678                 sortArrowGrid.add(arrow, 1, arrowRow);
 679                 GridPane.setHalignment(arrow, HPos.CENTER);
 680                 sortArrowGrid.add(sortOrderDots, 1, dotsRow);
 681 
 682                 updateSortOrderDots(sortPos);
 683             } else {
 684                 // only show the arrow
 685                 sortArrowGrid.add(arrow, 1, 1);
 686                 GridPane.setHgrow(arrow, Priority.NEVER);
 687                 GridPane.setVgrow(arrow, Priority.ALWAYS);
 688             }
 689         }
 690 
 691         sortArrow = _sortArrow;
 692         if (sortArrow != null) {
 693             sortArrow.setVisible(isSortColumn);
 694         }
 695 
 696         requestLayout();
 697     }
 698 
 699     private void updateSortOrderDots(int sortPos) {
 700         double arrowWidth = arrow.prefWidth(-1);
 701 
 702         sortOrderDots.getChildren().clear();
 703 
 704         for (int i = 0; i &lt;= sortPos; i++) {
 705             Region r = new Region();
 706             r.getStyleClass().add(&quot;sort-order-dot&quot;);
 707 
 708             String sortTypeName = getSortTypeName(getTableColumn());
 709             if (sortTypeName != null &amp;&amp; ! sortTypeName.isEmpty()) {
 710                 r.getStyleClass().add(sortTypeName.toLowerCase(Locale.ROOT));
 711             }
 712 
 713             sortOrderDots.getChildren().add(r);
 714 
 715             // RT-34914: fine tuning the placement of the sort dots. We could have gone to a custom layout, but for now
 716             // this works fine.
 717             if (i &lt; sortPos) {
 718                 Region spacer = new Region();
 719                 double lp = sortPos == 1 ? 1 : 0;
 720                 spacer.setPadding(new Insets(0, 1, 0, lp));
 721                 sortOrderDots.getChildren().add(spacer);
 722             }
 723         }
 724 
 725         sortOrderDots.setAlignment(Pos.TOP_CENTER);
 726         sortOrderDots.setMaxWidth(arrowWidth);
 727     }
 728 
 729     // Package for testing purposes only.
 730     void moveColumn(TableColumnBase column, final int newColumnPos) {
 731         if (column == null || newColumnPos &lt; 0) return;
 732 
 733         ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 734 
 735         final int columnsCount = columns.size();
 736         final int currentPos = columns.indexOf(column);
 737 
 738         int actualNewColumnPos = newColumnPos;
 739 
 740         // Fix for RT-35141: We need to account for hidden columns.
 741         // We keep iterating until we see &#39;requiredVisibleColumns&#39; number of visible columns
 742         final int requiredVisibleColumns = actualNewColumnPos;
 743         int visibleColumnsSeen = 0;
 744         for (int i = 0; i &lt; columnsCount; i++) {
 745             if (visibleColumnsSeen == (requiredVisibleColumns + 1)) {
 746                 break;
 747             }
 748 
 749             if (columns.get(i).isVisible()) {
 750                 visibleColumnsSeen++;
 751             } else {
 752                 actualNewColumnPos++;
 753             }
 754         }
 755         // --- end of RT-35141 fix
 756 
 757         if (actualNewColumnPos &gt;= columnsCount) {
 758             actualNewColumnPos = columnsCount - 1;
 759         } else if (actualNewColumnPos &lt; 0) {
 760             actualNewColumnPos = 0;
 761         }
 762 
 763         if (actualNewColumnPos == currentPos) return;
 764 
 765         List&lt;TableColumnBase&lt;?,?&gt;&gt; tempList = new ArrayList&lt;&gt;(columns);
 766         tempList.remove(column);
 767         tempList.add(actualNewColumnPos, column);
 768 
 769         columns.setAll(tempList);
 770     }
 771 
 772     private ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; getColumns(TableColumnBase column) {
 773         return column.getParentColumn() == null ?
 774                 TableSkinUtils.getColumns(getTableSkin()) :
 775                 column.getParentColumn().getColumns();
 776     }
 777 
 778     private int getIndex(TableColumnBase&lt;?,?&gt; column) {
 779         if (column == null) return -1;
 780 
 781         ObservableList&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 782 
 783         int index = -1;
 784         for (int i = 0; i &lt; columns.size(); i++) {
 785             TableColumnBase&lt;?,?&gt; _column = columns.get(i);
 786             if (! _column.isVisible()) continue;
 787 
 788             index++;
 789             if (column.equals(_column)) break;
 790         }
 791 
 792         return index;
 793     }
 794 
 795     private void updateColumnIndex() {
 796 //        TableView tv = getTableView();
 797         TableColumnBase tc = getTableColumn();
 798         TableViewSkinBase tableSkin = getTableSkin();
 799         columnIndex = tableSkin == null || tc == null ? -1 :TableSkinUtils.getVisibleLeafIndex(tableSkin,tc);
 800 
 801         // update the pseudo class state regarding whether this is the last
 802         // visible cell (i.e. the right-most).
 803         isLastVisibleColumn = getTableColumn() != null &amp;&amp;
 804                 columnIndex != -1 &amp;&amp;
 805                 columnIndex == TableSkinUtils.getVisibleLeafColumns(tableSkin).size() - 1;
 806         pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
 807     }
 808 
 809     private void sortColumn(final boolean addColumn) {
 810         if (! isSortingEnabled()) return;
 811 
 812         // we only allow sorting on the leaf columns and columns
 813         // that actually have comparators defined, and are sortable
 814         if (getTableColumn() == null || getTableColumn().getColumns().size() != 0 || getTableColumn().getComparator() == null || !getTableColumn().isSortable()) return;
 815 //        final int sortPos = getTable().getSortOrder().indexOf(column);
 816 //        final boolean isSortColumn = sortPos != -1;
 817 
 818         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
 819 
 820         // addColumn is true e.g. when the user is holding down Shift
 821         if (addColumn) {
 822             if (!isSortColumn) {
 823                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
 824                 sortOrder.add(getTableColumn());
 825             } else if (isAscending(getTableColumn())) {
 826                 setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
 827             } else {
 828                 int i = sortOrder.indexOf(getTableColumn());
 829                 if (i != -1) {
 830                     sortOrder.remove(i);
 831                 }
 832             }
 833         } else {
 834             // the user has clicked on a column header - we should add this to
 835             // the TableView sortOrder list if it isn&#39;t already there.
 836             if (isSortColumn &amp;&amp; sortOrder.size() == 1) {
 837                 // the column is already being sorted, and it&#39;s the only column.
 838                 // We therefore move through the 2nd or 3rd states:
 839                 //   1st click: sort ascending
 840                 //   2nd click: sort descending
 841                 //   3rd click: natural sorting (sorting is switched off)
 842                 if (isAscending(getTableColumn())) {
 843                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
 844                 } else {
 845                     // remove from sort
 846                     sortOrder.remove(getTableColumn());
 847                 }
 848             } else if (isSortColumn) {
 849                 // the column is already being used to sort, so we toggle its
 850                 // sortAscending property, and also make the column become the
 851                 // primary sort column
 852                 if (isAscending(getTableColumn())) {
 853                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
 854                 } else if (isDescending(getTableColumn())) {
 855                     setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
 856                 }
 857 
 858                 // to prevent multiple sorts, we make a copy of the sort order
 859                 // list, moving the column value from the current position to
 860                 // its new position at the front of the list
 861                 List&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderCopy = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrder);
 862                 sortOrderCopy.remove(getTableColumn());
 863                 sortOrderCopy.add(0, getTableColumn());
 864                 sortOrder.setAll(getTableColumn());
 865             } else {
 866                 // add to the sort order, in ascending form
 867                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
 868                 sortOrder.setAll(getTableColumn());
 869             }
 870         }
 871     }
 872 
 873     // Because it is possible that some columns are in the sortOrder list but are
 874     // not themselves sortable, we cannot just do sortOrderList.indexOf(column).
 875     // Therefore, this method does the proper work required of iterating through
 876     // and ignoring non-sortable (and null) columns in the sortOrder list.
 877     private int getSortPosition() {
 878         if (getTableColumn() == null) {
 879             return -1;
 880         }
 881 
 882         final List&lt;TableColumnBase&gt; sortOrder = getVisibleSortOrderColumns();
 883         int pos = 0;
 884         for (int i = 0; i &lt; sortOrder.size(); i++) {
 885             TableColumnBase _tc = sortOrder.get(i);
 886 
 887             if (getTableColumn().equals(_tc)) {
 888                 return pos;
 889             }
 890 
 891             pos++;
 892         }
 893 
 894         return -1;
 895     }
 896 
 897     private List&lt;TableColumnBase&gt; getVisibleSortOrderColumns() {
 898         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
 899 
 900         List&lt;TableColumnBase&gt; visibleSortOrderColumns = new ArrayList&lt;&gt;();
 901         for (int i = 0; i &lt; sortOrder.size(); i++) {
 902             TableColumnBase _tc = sortOrder.get(i);
 903             if (_tc == null || ! _tc.isSortable() || ! _tc.isVisible()) {
 904                 continue;
 905             }
 906 
 907             visibleSortOrderColumns.add(_tc);
 908         }
 909 
 910         return visibleSortOrderColumns;
 911     }
 912 
 913     // as with getSortPosition above, this method iterates through the sortOrder
 914     // list ignoring the null and non-sortable columns, so that we get the correct
 915     // number of columns in the sortOrder list.
 916     private int getVisibleSortOrderColumnCount() {
 917         return getVisibleSortOrderColumns().size();
 918     }
 919 
 920 
 921 
 922     /***************************************************************************
 923      *                                                                         *
 924      * Private Implementation: Column Reordering                               *
 925      *                                                                         *
 926      **************************************************************************/
 927 
 928     // package for testing
 929     void columnReorderingStarted(double dragOffset) {
 930         if (! getTableColumn().isReorderable()) return;
 931 
 932         // Used to ensure the column ghost is positioned relative to where the
 933         // user clicked on the column header
 934         this.dragOffset = dragOffset;
 935 
 936         // Note here that we only allow for reordering of &#39;root&#39; columns
 937         getTableHeaderRow().setReorderingColumn(getTableColumn());
 938         getTableHeaderRow().setReorderingRegion(this);
 939     }
 940 
 941     // package for testing
 942     void columnReordering(double sceneX, double sceneY) {
 943         if (! getTableColumn().isReorderable()) return;
 944 
 945         // this is for handling the column drag to reorder columns.
 946         // It shows a line to indicate where the &#39;drop&#39; will be.
 947 
 948         // indicate that we&#39;ve started dragging so that the dragging
 949         // line overlay is shown
 950         getTableHeaderRow().setReordering(true);
 951 
 952         // Firstly we need to determine where to draw the line.
 953         // Find which column we&#39;re over
 954         TableColumnHeader hoverHeader = null;
 955 
 956         // x represents where the mouse is relative to the parent
 957         // NestedTableColumnHeader
 958         final double x = getParentHeader().sceneToLocal(sceneX, sceneY).getX();
 959 
 960         // calculate where the ghost column header should be
 961         double dragX = getTableSkin().getSkinnable().sceneToLocal(sceneX, sceneY).getX() - dragOffset;
 962         getTableHeaderRow().setDragHeaderX(dragX);
 963 
 964         double startX = 0;
 965         double endX = 0;
 966         double headersWidth = 0;
 967         newColumnPos = 0;
 968         for (TableColumnHeader header : getParentHeader().getColumnHeaders()) {
 969             if (! header.isVisible()) continue;
 970 
 971             double headerWidth = header.prefWidth(-1);
 972             headersWidth += headerWidth;
 973 
 974             startX = header.getBoundsInParent().getMinX();
 975             endX = startX + headerWidth;
 976 
 977             if (x &gt;= startX &amp;&amp; x &lt; endX) {
 978                 hoverHeader = header;
 979                 break;
 980             }
 981             newColumnPos++;
 982         }
 983 
 984         // hoverHeader will be null if the drag occurs outside of the
 985         // tableview. In this case we handle the newColumnPos specially
 986         // and then short-circuit. This results in the drop action
 987         // resulting in the correct result (the column will drop at
 988         // the start or end of the table).
 989         if (hoverHeader == null) {
 990             newColumnPos = x &gt; headersWidth ? (getParentHeader().getColumns().size() - 1) : 0;
 991             return;
 992         }
 993 
 994         // This is the x-axis value midway through hoverHeader. It&#39;s
 995         // used to determine whether the drop should be to the left
 996         // or the right of hoverHeader.
 997         double midPoint = startX + (endX - startX) / 2;
 998         boolean beforeMidPoint = x &lt;= midPoint;
 999 
1000         // Based on where the mouse actually is, we have to shuffle
1001         // where we want the column to end up. This code handles that.
1002         int currentPos = getIndex(getTableColumn());
1003         newColumnPos += newColumnPos &gt; currentPos &amp;&amp; beforeMidPoint ?
1004             -1 : (newColumnPos &lt; currentPos &amp;&amp; !beforeMidPoint ? 1 : 0);
1005 
1006         double lineX = getTableHeaderRow().sceneToLocal(hoverHeader.localToScene(hoverHeader.getBoundsInLocal())).getMinX();
1007         lineX = lineX + ((beforeMidPoint) ? (0) : (hoverHeader.getWidth()));
1008 
1009         if (lineX &gt;= -0.5 &amp;&amp; lineX &lt;= getTableSkin().getSkinnable().getWidth()) {
1010             columnReorderLine.setTranslateX(lineX);
1011 
1012             // then if this is the first event, we set the property to true
1013             // so that the line becomes visible until the drop is completed.
1014             // We also set reordering to true so that the various reordering
1015             // effects become visible (ghost, transparent overlay, etc).
1016             columnReorderLine.setVisible(true);
1017         }
1018 
1019         getTableHeaderRow().setReordering(true);
1020     }
1021 
1022     // package for testing
1023     void columnReorderingComplete() {
1024         if (! getTableColumn().isReorderable()) return;
1025 
1026         // Move col from where it is now to the new position.
1027         moveColumn(getTableColumn(), newColumnPos);
1028 
1029         // cleanup
1030         columnReorderLine.setTranslateX(0.0F);
1031         columnReorderLine.setLayoutX(0.0F);
1032         newColumnPos = 0;
1033 
1034         getTableHeaderRow().setReordering(false);
1035         columnReorderLine.setVisible(false);
1036         getTableHeaderRow().setReorderingColumn(null);
1037         getTableHeaderRow().setReorderingRegion(null);
1038         dragOffset = 0.0F;
1039     }
1040 
1041     double getDragRectHeight() {
1042         return getHeight();
1043     }
1044 
1045     // Used to test whether this column header properly represents the given column.
1046     // In particular, whether it has child column headers for all child columns
1047     boolean represents(TableColumnBase&lt;?, ?&gt; column) {
1048         if (!column.getColumns().isEmpty()) {
1049             // this column has children, but we are in a TableColumnHeader instance,
1050             // so the match is bad.
1051             return false;
1052         }
1053         return column == getTableColumn();
1054     }
1055 
1056 
1057 
1058     /***************************************************************************
1059      *                                                                         *
1060      * Stylesheet Handling                                                     *
1061      *                                                                         *
1062      **************************************************************************/
1063 
1064     private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
1065             PseudoClass.getPseudoClass(&quot;last-visible&quot;);
1066 
1067     /*
1068      * Super-lazy instantiation pattern from Bill Pugh.
1069      */
1070      private static class StyleableProperties {
1071          private static final CssMetaData&lt;TableColumnHeader,Number&gt; SIZE =
1072             new CssMetaData&lt;TableColumnHeader,Number&gt;(&quot;-fx-size&quot;,
1073                  SizeConverter.getInstance(), 20.0) {
1074 
1075             @Override
1076             public boolean isSettable(TableColumnHeader n) {
1077                 return n.size == null || !n.size.isBound();
1078             }
1079 
1080             @Override
1081             public StyleableProperty&lt;Number&gt; getStyleableProperty(TableColumnHeader n) {
1082                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.sizeProperty();
1083             }
1084         };
1085 
1086          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1087          static {
1088 
1089             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1090                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
1091             styleables.add(SIZE);
1092             STYLEABLES = Collections.unmodifiableList(styleables);
1093 
1094          }
1095     }
1096 
1097     /**
1098      * Returns the CssMetaData associated with this class, which may include the
1099      * CssMetaData of its superclasses.
1100      *
1101      * @return the CssMetaData associated with this class, which may include the
1102      * CssMetaData of its superclasses
1103      */
1104     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1105         return StyleableProperties.STYLEABLES;
1106     }
1107 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>