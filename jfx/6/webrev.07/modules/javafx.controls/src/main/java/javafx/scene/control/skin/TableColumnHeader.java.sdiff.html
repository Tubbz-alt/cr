<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableSkinUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;


  31 import javafx.beans.property.DoubleProperty;
  32 import javafx.beans.property.ReadOnlyObjectProperty;
  33 import javafx.beans.property.ReadOnlyObjectWrapper;
  34 import javafx.beans.value.WritableValue;
  35 import javafx.collections.ListChangeListener;
  36 import javafx.collections.ObservableList;
  37 import javafx.collections.WeakListChangeListener;
  38 import javafx.css.CssMetaData;
  39 import javafx.css.PseudoClass;
  40 import javafx.css.Styleable;
  41 import javafx.css.StyleableDoubleProperty;
  42 import javafx.css.StyleableProperty;

  43 import javafx.event.EventHandler;
  44 import javafx.geometry.HPos;
  45 import javafx.geometry.Insets;
  46 import javafx.geometry.Pos;
  47 import javafx.geometry.VPos;
  48 import javafx.scene.AccessibleAttribute;
  49 import javafx.scene.AccessibleRole;
  50 import javafx.scene.Node;
  51 import javafx.scene.control.ContextMenu;
  52 import javafx.scene.control.Label;

  53 import javafx.scene.control.TableColumn;
  54 import javafx.scene.control.TableColumnBase;





  55 import javafx.scene.input.ContextMenuEvent;
  56 import javafx.scene.input.MouseEvent;
  57 import javafx.scene.layout.GridPane;
  58 import javafx.scene.layout.HBox;
  59 import javafx.scene.layout.Priority;
  60 import javafx.scene.layout.Region;

  61 
  62 import java.util.ArrayList;
  63 import java.util.Collections;
  64 import java.util.List;
  65 import java.util.Locale;
  66 
<span class="line-removed">  67 import javafx.css.converter.SizeConverter;</span>
<span class="line-removed">  68 </span>
  69 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  70 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  71 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  72 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  73 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  74 
  75 
  76 /**
  77  * Region responsible for painting a single column header. A subcomponent used by
  78  * subclasses of {@link TableViewSkinBase}.
  79  *
  80  * @since 9
  81  */
  82 public class TableColumnHeader extends Region {
  83 
  84     /***************************************************************************
  85      *                                                                         *
  86      * Static Fields                                                           *
  87      *                                                                         *
  88      **************************************************************************/
</pre>
<hr />
<pre>
 512             for (int i = 0; i &lt; children.size(); i++) {
 513                 updateAllHeaders(children.get(i));
 514             }
 515         } else {
 516             header.updateSortPosition();
 517         }
 518     }
 519 
 520     private void updateScene() {
 521         // RT-17684: If the TableColumn widths are all currently the default,
 522         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 523         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 524         // number of rows retrieved from a very slow (e.g. remote) data source.
 525         // Obviously, the bigger the value of n, the more likely the default
 526         // width will be suitable for most values in the column
 527         final int n = 30;
 528         if (! autoSizeComplete) {
 529             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 530                 return;
 531             }
<span class="line-modified"> 532             doColumnAutoSize(getTableColumn(), n);</span>
 533             autoSizeComplete = true;
 534         }
 535     }
 536 
 537     void dispose() {
 538         TableViewSkinBase tableSkin = getTableSkin();
 539         if (tableSkin != null) {
 540             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 541             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 542         }
 543 
 544         changeListenerHandler.dispose();
 545     }
 546 
 547     private boolean isSortingEnabled() {
 548         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 549         // to always return true (for now), as we want to support column sorting
 550         // everywhere
 551         return true;
 552     }
</pre>
<hr />
<pre>
 564         setOnMousePressed(mousePressedHandler);
 565         setOnMouseDragged(mouseDraggedHandler);
 566         setOnDragDetected(event -&gt; event.consume());
 567         setOnContextMenuRequested(contextMenuRequestedHandler);
 568         setOnMouseReleased(mouseReleasedHandler);
 569 
 570         // --- label
 571         label = new Label();
 572         label.setText(getTableColumn().getText());
 573         label.setGraphic(getTableColumn().getGraphic());
 574         label.setVisible(getTableColumn().isVisible());
 575 
 576         // ---- container for the sort arrow (which is not supported on embedded
 577         // platforms)
 578         if (isSortingEnabled()) {
 579             // put together the grid
 580             updateSortGrid();
 581         }
 582     }
 583 
<span class="line-modified"> 584     private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {</span>
<span class="line-modified"> 585         double prefWidth = column.getPrefWidth();</span>
 586 
 587         // if the prefWidth has been set, we do _not_ autosize columns
 588         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 589             TableSkinUtils.resizeColumnToFitContent(getTableSkin(), column, cellsToMeasure);</span>
<span class="line-modified"> 590 //            getTableViewSkin().resizeColumnToFitContent(column, cellsToMeasure);</span>

















































































































































































 591         }
 592     }
 593 
 594     private void updateSortPosition() {
 595         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 596         updateSortGrid();
 597     }
 598 
 599     private void updateSortGrid() {
 600         // Fix for RT-14488
 601         if (this instanceof NestedTableColumnHeader) return;
 602 
 603         getChildren().clear();
 604         getChildren().add(label);
 605 
 606         // we do not support sorting in embedded devices
 607         if (! isSortingEnabled()) return;
 608 
 609         isSortColumn = sortPos != -1;
 610         if (! isSortColumn) {
</pre>
</td>
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;
<span class="line-added">  31 import com.sun.javafx.scene.control.TreeTableViewBackingList;</span>
<span class="line-added">  32 import com.sun.javafx.scene.control.skin.Utils;</span>
  33 import javafx.beans.property.DoubleProperty;
  34 import javafx.beans.property.ReadOnlyObjectProperty;
  35 import javafx.beans.property.ReadOnlyObjectWrapper;
  36 import javafx.beans.value.WritableValue;
  37 import javafx.collections.ListChangeListener;
  38 import javafx.collections.ObservableList;
  39 import javafx.collections.WeakListChangeListener;
  40 import javafx.css.CssMetaData;
  41 import javafx.css.PseudoClass;
  42 import javafx.css.Styleable;
  43 import javafx.css.StyleableDoubleProperty;
  44 import javafx.css.StyleableProperty;
<span class="line-added">  45 import javafx.css.converter.SizeConverter;</span>
  46 import javafx.event.EventHandler;
  47 import javafx.geometry.HPos;
  48 import javafx.geometry.Insets;
  49 import javafx.geometry.Pos;
  50 import javafx.geometry.VPos;
  51 import javafx.scene.AccessibleAttribute;
  52 import javafx.scene.AccessibleRole;
  53 import javafx.scene.Node;
  54 import javafx.scene.control.ContextMenu;
  55 import javafx.scene.control.Label;
<span class="line-added">  56 import javafx.scene.control.TableCell;</span>
  57 import javafx.scene.control.TableColumn;
  58 import javafx.scene.control.TableColumnBase;
<span class="line-added">  59 import javafx.scene.control.TableView;</span>
<span class="line-added">  60 import javafx.scene.control.TreeTableCell;</span>
<span class="line-added">  61 import javafx.scene.control.TreeTableColumn;</span>
<span class="line-added">  62 import javafx.scene.control.TreeTableRow;</span>
<span class="line-added">  63 import javafx.scene.control.TreeTableView;</span>
  64 import javafx.scene.input.ContextMenuEvent;
  65 import javafx.scene.input.MouseEvent;
  66 import javafx.scene.layout.GridPane;
  67 import javafx.scene.layout.HBox;
  68 import javafx.scene.layout.Priority;
  69 import javafx.scene.layout.Region;
<span class="line-added">  70 import javafx.util.Callback;</span>
  71 
  72 import java.util.ArrayList;
  73 import java.util.Collections;
  74 import java.util.List;
  75 import java.util.Locale;
  76 


  77 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  78 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  79 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  80 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  81 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  82 
  83 
  84 /**
  85  * Region responsible for painting a single column header. A subcomponent used by
  86  * subclasses of {@link TableViewSkinBase}.
  87  *
  88  * @since 9
  89  */
  90 public class TableColumnHeader extends Region {
  91 
  92     /***************************************************************************
  93      *                                                                         *
  94      * Static Fields                                                           *
  95      *                                                                         *
  96      **************************************************************************/
</pre>
<hr />
<pre>
 520             for (int i = 0; i &lt; children.size(); i++) {
 521                 updateAllHeaders(children.get(i));
 522             }
 523         } else {
 524             header.updateSortPosition();
 525         }
 526     }
 527 
 528     private void updateScene() {
 529         // RT-17684: If the TableColumn widths are all currently the default,
 530         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 531         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 532         // number of rows retrieved from a very slow (e.g. remote) data source.
 533         // Obviously, the bigger the value of n, the more likely the default
 534         // width will be suitable for most values in the column
 535         final int n = 30;
 536         if (! autoSizeComplete) {
 537             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 538                 return;
 539             }
<span class="line-modified"> 540             doColumnAutoSize(n);</span>
 541             autoSizeComplete = true;
 542         }
 543     }
 544 
 545     void dispose() {
 546         TableViewSkinBase tableSkin = getTableSkin();
 547         if (tableSkin != null) {
 548             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 549             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 550         }
 551 
 552         changeListenerHandler.dispose();
 553     }
 554 
 555     private boolean isSortingEnabled() {
 556         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 557         // to always return true (for now), as we want to support column sorting
 558         // everywhere
 559         return true;
 560     }
</pre>
<hr />
<pre>
 572         setOnMousePressed(mousePressedHandler);
 573         setOnMouseDragged(mouseDraggedHandler);
 574         setOnDragDetected(event -&gt; event.consume());
 575         setOnContextMenuRequested(contextMenuRequestedHandler);
 576         setOnMouseReleased(mouseReleasedHandler);
 577 
 578         // --- label
 579         label = new Label();
 580         label.setText(getTableColumn().getText());
 581         label.setGraphic(getTableColumn().getGraphic());
 582         label.setVisible(getTableColumn().isVisible());
 583 
 584         // ---- container for the sort arrow (which is not supported on embedded
 585         // platforms)
 586         if (isSortingEnabled()) {
 587             // put together the grid
 588             updateSortGrid();
 589         }
 590     }
 591 
<span class="line-modified"> 592     private void doColumnAutoSize(int cellsToMeasure) {</span>
<span class="line-modified"> 593         double prefWidth = getTableColumn().getPrefWidth();</span>
 594 
 595         // if the prefWidth has been set, we do _not_ autosize columns
 596         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 597             resizeColumnToFitContent(cellsToMeasure);</span>
<span class="line-modified"> 598         }</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601     /**</span>
<span class="line-added"> 602      * Resizes this {@code TableColumnHeader}&#39;s column to fit the width of its content.</span>
<span class="line-added"> 603      *</span>
<span class="line-added"> 604      * @implSpec The resulting column width for this implementation is the maximum of the preferred width of the header</span>
<span class="line-added"> 605      * cell and the preferred width of the first {@code maxRow} cells.</span>
<span class="line-added"> 606      * &lt;p&gt;</span>
<span class="line-added"> 607      * Subclasses can either use this method or override it (without the need to call {@code super()}) to provide their</span>
<span class="line-added"> 608      * custom implementation (such as ones that exclude the header, exclude {@code null} content, compute the minimum</span>
<span class="line-added"> 609      * width, etc.).</span>
<span class="line-added"> 610      *</span>
<span class="line-added"> 611      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.</span>
<span class="line-added"> 612      * @since 14</span>
<span class="line-added"> 613      */</span>
<span class="line-added"> 614     protected void resizeColumnToFitContent(int maxRows) {</span>
<span class="line-added"> 615         TableColumnBase&lt;?, ?&gt; tc = getTableColumn();</span>
<span class="line-added"> 616         if (!tc.isResizable()) return;</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618         Object control = this.getTableSkin().getSkinnable();</span>
<span class="line-added"> 619         if (control instanceof TableView) {</span>
<span class="line-added"> 620             resizeColumnToFitContent((TableView) control, (TableColumn) tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 621         } else if (control instanceof TreeTableView) {</span>
<span class="line-added"> 622             resizeColumnToFitContent((TreeTableView) control, (TreeTableColumn) tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 623         }</span>
<span class="line-added"> 624     }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 627         List&lt;?&gt; items = tv.getItems();</span>
<span class="line-added"> 628         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 631         if (cellFactory == null) return;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);</span>
<span class="line-added"> 634         if (cell == null) return;</span>
<span class="line-added"> 635 </span>
<span class="line-added"> 636         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 637         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 638         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640         // determine cell padding</span>
<span class="line-added"> 641         double padding = 10;</span>
<span class="line-added"> 642         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 643         if (n instanceof Region) {</span>
<span class="line-added"> 644             Region r = (Region) n;</span>
<span class="line-added"> 645             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 646         }</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 649         double maxWidth = 0;</span>
<span class="line-added"> 650         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 651             cell.updateTableColumn(tc);</span>
<span class="line-added"> 652             cell.updateTableView(tv);</span>
<span class="line-added"> 653             cell.updateIndex(row);</span>
<span class="line-added"> 654 </span>
<span class="line-added"> 655             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 656                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 657                 cell.applyCss();</span>
<span class="line-added"> 658                 maxWidth = Math.max(maxWidth, cell.prefWidth(-1));</span>
<span class="line-added"> 659                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 660             }</span>
<span class="line-added"> 661         }</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 664         cell.updateIndex(-1);</span>
<span class="line-added"> 665 </span>
<span class="line-added"> 666         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 667         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 668         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 669         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 670         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 671         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 672         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 673         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675         // RT-23486</span>
<span class="line-added"> 676         maxWidth += padding;</span>
<span class="line-added"> 677         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {</span>
<span class="line-added"> 678             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 679                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 680             }</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682             int size = tc.getColumns().size();</span>
<span class="line-added"> 683             if (size &gt; 0) {</span>
<span class="line-added"> 684                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 685                 if (columnHeader != null) {</span>
<span class="line-added"> 686                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 687                 }</span>
<span class="line-added"> 688                 return;</span>
<span class="line-added"> 689             }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 692         } else {</span>
<span class="line-added"> 693             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
<span class="line-added"> 694         }</span>
<span class="line-added"> 695     }</span>
<span class="line-added"> 696 </span>
<span class="line-added"> 697     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 698         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);</span>
<span class="line-added"> 699         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 700 </span>
<span class="line-added"> 701         Callback cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 702         if (cellFactory == null) return;</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);</span>
<span class="line-added"> 705         if (cell == null) return;</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 708         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 709         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711         // determine cell padding</span>
<span class="line-added"> 712         double padding = 10;</span>
<span class="line-added"> 713         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 714         if (n instanceof Region) {</span>
<span class="line-added"> 715             Region r = (Region) n;</span>
<span class="line-added"> 716             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 717         }</span>
<span class="line-added"> 718 </span>
<span class="line-added"> 719         TreeTableRow&lt;T&gt; treeTableRow = new TreeTableRow&lt;&gt;();</span>
<span class="line-added"> 720         treeTableRow.updateTreeTableView(ttv);</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 723         double maxWidth = 0;</span>
<span class="line-added"> 724         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 725             treeTableRow.updateIndex(row);</span>
<span class="line-added"> 726             treeTableRow.updateTreeItem(ttv.getTreeItem(row));</span>
<span class="line-added"> 727 </span>
<span class="line-added"> 728             cell.updateTreeTableColumn(tc);</span>
<span class="line-added"> 729             cell.updateTreeTableView(ttv);</span>
<span class="line-added"> 730             cell.updateTreeTableRow(treeTableRow);</span>
<span class="line-added"> 731             cell.updateIndex(row);</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 734                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 735                 cell.applyCss();</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737                 double w = cell.prefWidth(-1);</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739                 maxWidth = Math.max(maxWidth, w);</span>
<span class="line-added"> 740                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742         }</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 745         cell.updateIndex(-1);</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 748         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 749         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 750         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 751         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 752         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 753         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 754         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756         // RT-23486</span>
<span class="line-added"> 757         maxWidth += padding;</span>
<span class="line-added"> 758         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {</span>
<span class="line-added"> 759 </span>
<span class="line-added"> 760             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 761                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 762             }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764             int size = tc.getColumns().size();</span>
<span class="line-added"> 765             if (size &gt; 0) {</span>
<span class="line-added"> 766                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 767                 if (columnHeader != null) {</span>
<span class="line-added"> 768                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 769                 }</span>
<span class="line-added"> 770                 return;</span>
<span class="line-added"> 771             }</span>
<span class="line-added"> 772 </span>
<span class="line-added"> 773             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 774         } else {</span>
<span class="line-added"> 775             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
 776         }
 777     }
 778 
 779     private void updateSortPosition() {
 780         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 781         updateSortGrid();
 782     }
 783 
 784     private void updateSortGrid() {
 785         // Fix for RT-14488
 786         if (this instanceof NestedTableColumnHeader) return;
 787 
 788         getChildren().clear();
 789         getChildren().add(label);
 790 
 791         // we do not support sorting in embedded devices
 792         if (! isSortingEnabled()) return;
 793 
 794         isSortColumn = sortPos != -1;
 795         if (! isSortColumn) {
</pre>
</td>
</tr>
</table>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableSkinUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>