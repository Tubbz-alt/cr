<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  31 import com.sun.javafx.scene.control.TreeTableViewBackingList;
  32 import com.sun.javafx.scene.control.skin.Utils;
  33 import javafx.beans.property.DoubleProperty;
  34 import javafx.beans.property.ReadOnlyObjectProperty;
  35 import javafx.beans.property.ReadOnlyObjectWrapper;
  36 import javafx.beans.value.WritableValue;
  37 import javafx.collections.ListChangeListener;
  38 import javafx.collections.ObservableList;
  39 import javafx.collections.WeakListChangeListener;
  40 import javafx.css.*;
  41 import javafx.css.converter.SizeConverter;
  42 import javafx.event.EventHandler;
  43 import javafx.geometry.HPos;
  44 import javafx.geometry.Insets;
  45 import javafx.geometry.Pos;
  46 import javafx.geometry.VPos;
  47 import javafx.scene.AccessibleAttribute;
  48 import javafx.scene.AccessibleRole;
  49 import javafx.scene.Node;
  50 import javafx.scene.control.ContextMenu;
  51 import javafx.scene.control.Label;
  52 import javafx.scene.control.TableCell;
  53 import javafx.scene.control.TableColumn;
  54 import javafx.scene.control.TableColumnBase;
  55 import javafx.scene.control.TableView;
  56 import javafx.scene.control.TreeTableCell;
  57 import javafx.scene.control.TreeTableColumn;
  58 import javafx.scene.control.TreeTableRow;
  59 import javafx.scene.control.TreeTableView;
  60 import javafx.scene.input.ContextMenuEvent;
  61 import javafx.scene.input.MouseEvent;
  62 import javafx.scene.layout.GridPane;
  63 import javafx.scene.layout.HBox;
  64 import javafx.scene.layout.Priority;
  65 import javafx.scene.layout.Region;
  66 import javafx.util.Callback;
  67 
  68 import java.util.ArrayList;
  69 import java.util.Collections;
  70 import java.util.List;
  71 import java.util.Locale;
  72 
  73 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  74 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  75 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  76 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  77 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  78 
  79 
  80 /**
  81  * Region responsible for painting a single column header. A subcomponent used by
  82  * subclasses of {@link TableViewSkinBase}.
  83  *
  84  * @since 9
  85  */
  86 public class TableColumnHeader extends Region {
  87 
  88     /***************************************************************************
  89      *                                                                         *
  90      * Static Fields                                                           *
  91      *                                                                         *
  92      **************************************************************************/
  93 
  94     static final String DEFAULT_STYLE_CLASS = &quot;column-header&quot;;
  95 
  96     // Copied from TableColumn. The value here should always be in-sync with
  97     // the value in TableColumn
  98     static final double DEFAULT_COLUMN_WIDTH = 80.0F;
  99 
 100 
 101 
 102     /***************************************************************************
 103      *                                                                         *
 104      * Private Fields                                                          *
 105      *                                                                         *
 106      **************************************************************************/
 107 
 108     private boolean autoSizeComplete = false;
 109 
 110     private double dragOffset;
 111     private NestedTableColumnHeader nestedColumnHeader;
 112     private TableHeaderRow tableHeaderRow;
 113     private NestedTableColumnHeader parentHeader;
 114 
 115     // work out where this column currently is within its parent
 116     Label label;
 117 
 118     // sort order
 119     int sortPos = -1;
 120     private Region arrow;
 121     private Label sortOrderLabel;
 122     private HBox sortOrderDots;
 123     private Node sortArrow;
 124     private boolean isSortColumn;
 125 
 126     private boolean isSizeDirty = false;
 127 
 128     boolean isLastVisibleColumn = false;
 129 
 130     // package for testing
 131     int columnIndex = -1;
 132 
 133     private int newColumnPos;
 134 
 135     // the line drawn in the table when a user presses and moves a column header
 136     // to indicate where the column will be dropped. This is provided by the
 137     // table skin, but manipulated by the header
 138     Region columnReorderLine;
 139 
 140 
 141 
 142     /***************************************************************************
 143      *                                                                         *
 144      * Constructor                                                             *
 145      *                                                                         *
 146      **************************************************************************/
 147 
 148     /**
 149      * Creates a new TableColumnHeader instance to visually represent the given
 150      * {@link TableColumnBase} instance.
 151      *
 152      * @param tc The table column to be visually represented by this instance.
 153      */
 154     public TableColumnHeader(final TableColumnBase tc) {
 155         setTableColumn(tc);
 156         setFocusTraversable(false);
 157 
 158         initStyleClasses();
 159         initUI();
 160 
 161         // change listener for multiple properties
 162         changeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();
 163         changeListenerHandler.registerChangeListener(sceneProperty(), e -&gt; updateScene());
 164 
 165         if (getTableColumn() != null) {
 166             changeListenerHandler.registerChangeListener(tc.idProperty(), e -&gt; setId(tc.getId()));
 167             changeListenerHandler.registerChangeListener(tc.styleProperty(), e -&gt; setStyle(tc.getStyle()));
 168             changeListenerHandler.registerChangeListener(tc.widthProperty(), e -&gt; {
 169                 // It is this that ensures that when a column is resized that the header
 170                 // visually adjusts its width as necessary.
 171                 isSizeDirty = true;
 172                 requestLayout();
 173             });
 174             changeListenerHandler.registerChangeListener(tc.visibleProperty(), e -&gt; setVisible(getTableColumn().isVisible()));
 175             changeListenerHandler.registerChangeListener(tc.sortNodeProperty(), e -&gt; updateSortGrid());
 176             changeListenerHandler.registerChangeListener(tc.sortableProperty(), e -&gt; {
 177                 // we need to notify all headers that a sortable state has changed,
 178                 // in case the sort grid in other columns needs to be updated.
 179                 if (TableSkinUtils.getSortOrder(getTableSkin()).contains(getTableColumn())) {
 180                     NestedTableColumnHeader root = getTableHeaderRow().getRootHeader();
 181                     updateAllHeaders(root);
 182                 }
 183             });
 184             changeListenerHandler.registerChangeListener(tc.textProperty(), e -&gt; label.setText(tc.getText()));
 185             changeListenerHandler.registerChangeListener(tc.graphicProperty(), e -&gt; label.setGraphic(tc.getGraphic()));
 186 
 187             setId(tc.getId());
 188             setStyle(tc.getStyle());
 189             /* Having TableColumn role parented by TableColumn causes VoiceOver to be unhappy */
 190             setAccessibleRole(AccessibleRole.TABLE_COLUMN);
 191         }
 192     }
 193 
 194 
 195 
 196     /***************************************************************************
 197      *                                                                         *
 198      * Listeners                                                               *
 199      *                                                                         *
 200      **************************************************************************/
 201 
 202     final LambdaMultiplePropertyChangeListenerHandler changeListenerHandler;
 203 
 204     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderListener = c -&gt; {
 205         updateSortPosition();
 206     };
 207 
 208     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
 209         updateColumnIndex();
 210         updateSortPosition();
 211     };
 212 
 213     private ListChangeListener&lt;String&gt; styleClassListener = c -&gt; {
 214         while (c.next()) {
 215             if (c.wasRemoved()) {
 216                 getStyleClass().removeAll(c.getRemoved());
 217             }
 218             if (c.wasAdded()) {
 219                 getStyleClass().addAll(c.getAddedSubList());
 220             }
 221         }
 222     };
 223 
 224     private WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakSortOrderListener =
 225             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrderListener);
 226     private final WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakVisibleLeafColumnsListener =
 227             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(visibleLeafColumnsListener);
 228     private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
 229             new WeakListChangeListener&lt;String&gt;(styleClassListener);
 230 
 231     private static final EventHandler&lt;MouseEvent&gt; mousePressedHandler = me -&gt; {
 232         TableColumnHeader header = (TableColumnHeader) me.getSource();
 233         TableColumnBase tableColumn = header.getTableColumn();
 234 
 235         ContextMenu menu = tableColumn.getContextMenu();
 236         if (menu != null &amp;&amp; menu.isShowing()) {
 237             menu.hide();
 238         }
 239 
 240         if (me.isConsumed()) return;
 241         me.consume();
 242 
 243         header.getTableHeaderRow().columnDragLock = true;
 244 
 245         // pass focus to the table, so that the user immediately sees
 246         // the focus rectangle around the table control.
 247         header.getTableSkin().getSkinnable().requestFocus();
 248 
 249         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 250             header.columnReorderingStarted(me.getX());
 251         }
 252     };
 253 
 254     private static final EventHandler&lt;MouseEvent&gt; mouseDraggedHandler = me -&gt; {
 255         if (me.isConsumed()) return;
 256         me.consume();
 257 
 258         TableColumnHeader header = (TableColumnHeader) me.getSource();
 259 
 260         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 261             header.columnReordering(me.getSceneX(), me.getSceneY());
 262         }
 263     };
 264 
 265     private static final EventHandler&lt;MouseEvent&gt; mouseReleasedHandler = me -&gt; {
 266         if (me.isPopupTrigger()) return;
 267         if (me.isConsumed()) return;
 268         me.consume();
 269 
 270         TableColumnHeader header = (TableColumnHeader) me.getSource();
 271         header.getTableHeaderRow().columnDragLock = false;
 272 
 273         if (header.getTableHeaderRow().isReordering() &amp;&amp; header.isColumnReorderingEnabled()) {
 274             header.columnReorderingComplete();
 275         } else if (me.isStillSincePress()) {
 276             header.sortColumn(me.isShiftDown());
 277         }
 278     };
 279 
 280     private static final EventHandler&lt;ContextMenuEvent&gt; contextMenuRequestedHandler = me -&gt; {
 281         TableColumnHeader header = (TableColumnHeader) me.getSource();
 282         TableColumnBase tableColumn = header.getTableColumn();
 283 
 284         ContextMenu menu = tableColumn.getContextMenu();
 285         if (menu != null) {
 286             menu.show(header, me.getScreenX(), me.getScreenY());
 287             me.consume();
 288         }
 289     };
 290 
 291 
 292 
 293     /***************************************************************************
 294      *                                                                         *
 295      * Properties                                                              *
 296      *                                                                         *
 297      **************************************************************************/
 298 
 299     // --- size
 300     private DoubleProperty size;
 301     private final double getSize() {
 302         return size == null ? 20.0 : size.doubleValue();
 303     }
 304     private final DoubleProperty sizeProperty() {
 305         if (size == null) {
 306             size = new StyleableDoubleProperty(20) {
 307                 @Override
 308                 protected void invalidated() {
 309                     double value = get();
 310                     if (value &lt;= 0) {
 311                         if (isBound()) {
 312                             unbind();
 313                         }
 314                         set(20);
 315                         throw new IllegalArgumentException(&quot;Size cannot be 0 or negative&quot;);
 316                     }
 317                 }
 318 
 319 
 320 
 321                 @Override public Object getBean() {
 322                     return TableColumnHeader.this;
 323                 }
 324 
 325                 @Override public String getName() {
 326                     return &quot;size&quot;;
 327                 }
 328 
 329                 @Override public CssMetaData&lt;TableColumnHeader,Number&gt; getCssMetaData() {
 330                     return StyleableProperties.SIZE;
 331                 }
 332             };
 333         }
 334         return size;
 335     }
 336 
 337 
 338     /**
 339      * A property that refers to the {@link TableColumnBase} instance that this
 340      * header is visually represents.
 341      */
 342     // --- table column
 343     private ReadOnlyObjectWrapper&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableColumn&quot;);
 344     private final void setTableColumn(TableColumnBase&lt;?,?&gt; column) {
 345         tableColumn.set(column);
 346     }
 347     public final TableColumnBase&lt;?,?&gt; getTableColumn() {
 348         return tableColumn.get();
 349     }
 350     public final ReadOnlyObjectProperty&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumnProperty() {
 351         return tableColumn.getReadOnlyProperty();
 352     }
 353 
 354 
 355 
 356     /***************************************************************************
 357      *                                                                         *
 358      * Public API                                                              *
 359      *                                                                         *
 360      **************************************************************************/
 361 
 362     /** {@inheritDoc} */
 363     @Override protected void layoutChildren() {
 364         if (isSizeDirty) {
 365             resize(getTableColumn().getWidth(), getHeight());
 366             isSizeDirty = false;
 367         }
 368 
 369         double sortWidth = 0;
 370         double w = snapSizeX(getWidth()) - (snappedLeftInset() + snappedRightInset());
 371         double h = getHeight() - (snappedTopInset() + snappedBottomInset());
 372         double x = w;
 373 
 374         // a bit hacky, but we REALLY don&#39;t want the arrow shape to fluctuate
 375         // in size
 376         if (arrow != null) {
 377             arrow.setMaxSize(arrow.prefWidth(-1), arrow.prefHeight(-1));
 378         }
 379 
 380         if (sortArrow != null &amp;&amp; sortArrow.isVisible()) {
 381             sortWidth = sortArrow.prefWidth(-1);
 382             x -= sortWidth;
 383             sortArrow.resize(sortWidth, sortArrow.prefHeight(-1));
 384             positionInArea(sortArrow, x, snappedTopInset(),
 385                     sortWidth, h, 0, HPos.CENTER, VPos.CENTER);
 386         }
 387 
 388         if (label != null) {
 389             double labelWidth = w - sortWidth;
 390             label.resizeRelocate(snappedLeftInset(), 0, labelWidth, getHeight());
 391         }
 392     }
 393 
 394     /** {@inheritDoc} */
 395     @Override protected double computePrefWidth(double height) {
 396         if (getNestedColumnHeader() != null) {
 397             double width = getNestedColumnHeader().prefWidth(height);
 398 
 399             if (getTableColumn() != null) {
 400                 TableColumnBaseHelper.setWidth(getTableColumn(), width);
 401             }
 402 
 403             return width;
 404         } else if (getTableColumn() != null &amp;&amp; getTableColumn().isVisible()) {
 405             return snapSizeX(getTableColumn().getWidth());
 406         }
 407 
 408         return 0;
 409     }
 410 
 411     /** {@inheritDoc} */
 412     @Override protected double computeMinHeight(double width) {
 413         return label == null ? 0 : label.minHeight(width);
 414     }
 415 
 416     /** {@inheritDoc} */
 417     @Override protected double computePrefHeight(double width) {
 418         if (getTableColumn() == null) return 0;
 419         return Math.max(getSize(), label.prefHeight(-1));
 420     }
 421 
 422     /** {@inheritDoc} */
 423     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 424         return getClassCssMetaData();
 425     }
 426 
 427     /** {@inheritDoc} */
 428     @Override  public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 429         switch (attribute) {
 430             case INDEX: return getIndex(getTableColumn());
 431             case TEXT: return getTableColumn() != null ? getTableColumn().getText() : null;
 432             default: return super.queryAccessibleAttribute(attribute, parameters);
 433         }
 434     }
 435 
 436 
 437 
 438     /***************************************************************************
 439      *                                                                         *
 440      * Private Implementation                                                  *
 441      *                                                                         *
 442      **************************************************************************/
 443 
 444     void initStyleClasses() {
 445         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 446         installTableColumnStyleClassListener();
 447     }
 448 
 449     void installTableColumnStyleClassListener() {
 450         TableColumnBase tc = getTableColumn();
 451         if (tc != null) {
 452             // add in all styleclasses from the table column into the header, and also set up a listener
 453             // so that any subsequent changes to the table column are also applied to the header
 454             getStyleClass().addAll(tc.getStyleClass());
 455             tc.getStyleClass().addListener(weakStyleClassListener);
 456         }
 457     }
 458 
 459     NestedTableColumnHeader getNestedColumnHeader() { return nestedColumnHeader; }
 460     void setNestedColumnHeader(NestedTableColumnHeader nch) { nestedColumnHeader = nch; }
 461 
 462     /**
 463      * Returns the {@link TableHeaderRow} associated with this {@code TableColumnHeader}.
 464      *
 465      * @return the {@code TableHeaderRow} associated with this {@code TableColumnHeader}
 466      * @since 12
 467      */
 468     protected TableHeaderRow getTableHeaderRow() {
 469         return tableHeaderRow;
 470     }
 471 
 472     void setTableHeaderRow(TableHeaderRow thr) {
 473         tableHeaderRow = thr;
 474         updateTableSkin();
 475     }
 476 
 477     private void updateTableSkin() {
 478         // when we get the table header row, we are also given the skin,
 479         // so this is the time to hook up listeners, etc.
 480         TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin = getTableSkin();
 481         if (tableSkin == null) return;
 482 
 483         updateColumnIndex();
 484         this.columnReorderLine = tableSkin.getColumnReorderLine();
 485 
 486         if (getTableColumn() != null) {
 487             updateSortPosition();
 488             TableSkinUtils.getSortOrder(tableSkin).addListener(weakSortOrderListener);
 489             TableSkinUtils.getVisibleLeafColumns(tableSkin).addListener(weakVisibleLeafColumnsListener);
 490         }
 491     }
 492 
 493     /**
 494      * Returns the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted. This will return
 495      * {@code null} until the {@code TableHeaderRow} has been set.
 496      *
 497      * @return the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted, or {@code null}
 498      * @since 12
 499      */
 500     protected TableViewSkinBase&lt;?, ?, ?, ?, ?&gt; getTableSkin() {
 501         return tableHeaderRow == null ? null : tableHeaderRow.tableSkin;
 502     }
 503 
 504     NestedTableColumnHeader getParentHeader() { return parentHeader; }
 505     void setParentHeader(NestedTableColumnHeader ph) { parentHeader = ph; }
 506 
 507     // RT-29682: When the sortable property of a TableColumnBase changes this
 508     // may impact other TableColumnHeaders, as they may need to change their
 509     // sort order representation. Rather than install listeners across all
 510     // TableColumn in the sortOrder list for their sortable property, we simply
 511     // update the sortPosition of all headers whenever the sortOrder property
 512     // changes, assuming the column is within the sortOrder list.
 513     private void updateAllHeaders(TableColumnHeader header) {
 514         if (header instanceof NestedTableColumnHeader) {
 515             List&lt;TableColumnHeader&gt; children = ((NestedTableColumnHeader)header).getColumnHeaders();
 516             for (int i = 0; i &lt; children.size(); i++) {
 517                 updateAllHeaders(children.get(i));
 518             }
 519         } else {
 520             header.updateSortPosition();
 521         }
 522     }
 523 
 524     private void updateScene() {
 525         // RT-17684: If the TableColumn widths are all currently the default,
 526         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 527         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 528         // number of rows retrieved from a very slow (e.g. remote) data source.
 529         // Obviously, the bigger the value of n, the more likely the default
 530         // width will be suitable for most values in the column
 531         final int n = 30;
 532         if (! autoSizeComplete) {
 533             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 534                 return;
 535             }
 536             doColumnAutoSize(n);
 537             autoSizeComplete = true;
 538         }
 539     }
 540 
 541     void dispose() {
 542         TableViewSkinBase tableSkin = getTableSkin();
 543         if (tableSkin != null) {
 544             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 545             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 546         }
 547 
 548         changeListenerHandler.dispose();
 549     }
 550 
 551     private boolean isSortingEnabled() {
 552         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 553         // to always return true (for now), as we want to support column sorting
 554         // everywhere
 555         return true;
 556     }
 557 
 558     private boolean isColumnReorderingEnabled() {
 559         // we only allow for column reordering if there are more than one column,
 560         return !Properties.IS_TOUCH_SUPPORTED &amp;&amp; TableSkinUtils.getVisibleLeafColumns(getTableSkin()).size() &gt; 1;
 561     }
 562 
 563     private void initUI() {
 564         // TableColumn will be null if we are dealing with the root NestedTableColumnHeader
 565         if (getTableColumn() == null) return;
 566 
 567         // set up mouse events
 568         setOnMousePressed(mousePressedHandler);
 569         setOnMouseDragged(mouseDraggedHandler);
 570         setOnDragDetected(event -&gt; event.consume());
 571         setOnContextMenuRequested(contextMenuRequestedHandler);
 572         setOnMouseReleased(mouseReleasedHandler);
 573 
 574         // --- label
 575         label = new Label();
 576         label.setText(getTableColumn().getText());
 577         label.setGraphic(getTableColumn().getGraphic());
 578         label.setVisible(getTableColumn().isVisible());
 579 
 580         // ---- container for the sort arrow (which is not supported on embedded
 581         // platforms)
 582         if (isSortingEnabled()) {
 583             // put together the grid
 584             updateSortGrid();
 585         }
 586     }
 587 
 588     private void doColumnAutoSize(int cellsToMeasure) {
 589         double prefWidth = getTableColumn().getPrefWidth();
 590 
 591         // if the prefWidth has been set, we do _not_ autosize columns
 592         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
 593             resizeColumnToFitContent(cellsToMeasure);
 594         }
 595     }
 596 
 597     /**
<a name="1" id="anc1"></a><span class="line-modified"> 598      * Resizes this {@code TableColumnHeader}&#39;s column to fit the width of its content. The resulting column width for</span>
<span class="line-modified"> 599      * this implementation is the maximum of the preferred width of the header cell and the preferred width of the first</span>
<span class="line-added"> 600      * {@code maxRow} cells.</span>
 601      * &lt;p&gt;
 602      * Subclasses can either use this method or override it (without the need to call {@code super()}) to provide their
 603      * custom implementation (such as ones that exclude the header, exclude {@code null} content, compute the minimum
 604      * width etc.).
 605      *
 606      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.
 607      * @since 14
 608      */
 609     protected void resizeColumnToFitContent(int maxRows) {
 610         TableColumnBase&lt;?, ?&gt; tc = getTableColumn();
 611         if (!tc.isResizable()) return;
 612 
 613         Object control = this.getTableSkin().getSkinnable();
 614         if (control instanceof TableView) {
 615             resizeColumnToFitContent((TableView) control, (TableColumn) tc, this.getTableSkin(), maxRows);
 616         } else if (control instanceof TreeTableView) {
 617             resizeColumnToFitContent((TreeTableView) control, (TreeTableColumn) tc, this.getTableSkin(), maxRows);
 618         }
 619     }
 620 
 621     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 622         List&lt;?&gt; items = tv.getItems();
 623         if (items == null || items.isEmpty()) return;
 624 
 625         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();
 626         if (cellFactory == null) return;
 627 
 628         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);
 629         if (cell == null) return;
 630 
 631         // set this property to tell the TableCell we want to know its actual
 632         // preferred width, not the width of the associated TableColumnBase
 633         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);
 634 
 635         // determine cell padding
 636         double padding = 10;
 637         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();
 638         if (n instanceof Region) {
 639             Region r = (Region) n;
 640             padding = r.snappedLeftInset() + r.snappedRightInset();
 641         }
 642 
 643         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);
 644         double maxWidth = 0;
 645         for (int row = 0; row &lt; rows; row++) {
 646             cell.updateTableColumn(tc);
 647             cell.updateTableView(tv);
 648             cell.updateIndex(row);
 649 
 650             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {
 651                 tableSkin.getChildren().add(cell);
 652                 cell.applyCss();
 653                 maxWidth = Math.max(maxWidth, cell.prefWidth(-1));
 654                 tableSkin.getChildren().remove(cell);
 655             }
 656         }
 657 
 658         // dispose of the cell to prevent it retaining listeners (see RT-31015)
 659         cell.updateIndex(-1);
 660 
 661         // RT-36855 - take into account the column header text / graphic widths.
 662         // Magic 10 is to allow for sort arrow to appear without text truncation.
 663         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 664         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 665         Node graphic = header.label.getGraphic();
 666         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 667         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 668         maxWidth = Math.max(maxWidth, headerWidth);
 669 
 670         // RT-23486
 671         maxWidth += padding;
 672         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {
 673             if (maxWidth &gt; tc.getMaxWidth()) {
 674                 maxWidth = tc.getMaxWidth();
 675             }
 676 
 677             int size = tc.getColumns().size();
 678             if (size &gt; 0) {
 679                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));
 680                 if (columnHeader != null) {
 681                     columnHeader.resizeColumnToFitContent(maxRows);
 682                 }
 683                 return;
 684             }
 685 
 686             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 687         } else {
 688             TableColumnBaseHelper.setWidth(tc, maxWidth);
 689         }
 690     }
 691 
 692     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 693         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);
 694         if (items == null || items.isEmpty()) return;
 695 
 696         Callback cellFactory = tc.getCellFactory();
 697         if (cellFactory == null) return;
 698 
 699         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);
 700         if (cell == null) return;
 701 
 702         // set this property to tell the TableCell we want to know its actual
 703         // preferred width, not the width of the associated TableColumnBase
 704         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);
 705 
 706         // determine cell padding
 707         double padding = 10;
 708         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();
 709         if (n instanceof Region) {
 710             Region r = (Region) n;
 711             padding = r.snappedLeftInset() + r.snappedRightInset();
 712         }
 713 
 714         TreeTableRow&lt;T&gt; treeTableRow = new TreeTableRow&lt;&gt;();
 715         treeTableRow.updateTreeTableView(ttv);
 716 
 717         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);
 718         double maxWidth = 0;
 719         for (int row = 0; row &lt; rows; row++) {
 720             treeTableRow.updateIndex(row);
 721             treeTableRow.updateTreeItem(ttv.getTreeItem(row));
 722 
 723             cell.updateTreeTableColumn(tc);
 724             cell.updateTreeTableView(ttv);
 725             cell.updateTreeTableRow(treeTableRow);
 726             cell.updateIndex(row);
 727 
 728             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {
 729                 tableSkin.getChildren().add(cell);
 730                 cell.applyCss();
 731 
 732                 double w = cell.prefWidth(-1);
 733 
 734                 maxWidth = Math.max(maxWidth, w);
 735                 tableSkin.getChildren().remove(cell);
 736             }
 737         }
 738 
 739         // dispose of the cell to prevent it retaining listeners (see RT-31015)
 740         cell.updateIndex(-1);
 741 
 742         // RT-36855 - take into account the column header text / graphic widths.
 743         // Magic 10 is to allow for sort arrow to appear without text truncation.
 744         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 745         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 746         Node graphic = header.label.getGraphic();
 747         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 748         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 749         maxWidth = Math.max(maxWidth, headerWidth);
 750 
 751         // RT-23486
 752         maxWidth += padding;
 753         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {
 754 
 755             if (maxWidth &gt; tc.getMaxWidth()) {
 756                 maxWidth = tc.getMaxWidth();
 757             }
 758 
 759             int size = tc.getColumns().size();
 760             if (size &gt; 0) {
 761                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));
 762                 if (columnHeader != null) {
 763                     columnHeader.resizeColumnToFitContent(maxRows);
 764                 }
 765                 return;
 766             }
 767 
 768             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 769         } else {
 770             TableColumnBaseHelper.setWidth(tc, maxWidth);
 771         }
 772     }
 773 
 774     private void updateSortPosition() {
 775         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 776         updateSortGrid();
 777     }
 778 
 779     private void updateSortGrid() {
 780         // Fix for RT-14488
 781         if (this instanceof NestedTableColumnHeader) return;
 782 
 783         getChildren().clear();
 784         getChildren().add(label);
 785 
 786         // we do not support sorting in embedded devices
 787         if (! isSortingEnabled()) return;
 788 
 789         isSortColumn = sortPos != -1;
 790         if (! isSortColumn) {
 791             if (sortArrow != null) {
 792                 sortArrow.setVisible(false);
 793             }
 794             return;
 795         }
 796 
 797         // RT-28016: if the tablecolumn is not a visible leaf column, we should ignore this
 798         int visibleLeafIndex = TableSkinUtils.getVisibleLeafIndex(getTableSkin(), getTableColumn());
 799         if (visibleLeafIndex == -1) return;
 800 
 801         final int sortColumnCount = getVisibleSortOrderColumnCount();
 802         boolean showSortOrderDots = sortPos &lt;= 3 &amp;&amp; sortColumnCount &gt; 1;
 803 
 804         Node _sortArrow = null;
 805         if (getTableColumn().getSortNode() != null) {
 806             _sortArrow = getTableColumn().getSortNode();
 807             getChildren().add(_sortArrow);
 808         } else {
 809             GridPane sortArrowGrid = new GridPane();
 810             _sortArrow = sortArrowGrid;
 811             sortArrowGrid.setPadding(new Insets(0, 3, 0, 0));
 812             getChildren().add(sortArrowGrid);
 813 
 814             // if we are here, and the sort arrow is null, we better create it
 815             if (arrow == null) {
 816                 arrow = new Region();
 817                 arrow.getStyleClass().setAll(&quot;arrow&quot;);
 818                 arrow.setVisible(true);
 819                 arrow.setRotate(isAscending(getTableColumn()) ? 180.0F : 0.0F);
 820                 changeListenerHandler.registerChangeListener(getSortTypeProperty(getTableColumn()), e -&gt; {
 821                     updateSortGrid();
 822                     if (arrow != null) {
 823                         arrow.setRotate(isAscending(getTableColumn()) ? 180 : 0.0);
 824                     }
 825                 });
 826             }
 827 
 828             arrow.setVisible(isSortColumn);
 829 
 830             if (sortPos &gt; 2) {
 831                 if (sortOrderLabel == null) {
 832                     // ---- sort order label (for sort positions greater than 3)
 833                     sortOrderLabel = new Label();
 834                     sortOrderLabel.getStyleClass().add(&quot;sort-order&quot;);
 835                 }
 836 
 837                 // only show the label if the sortPos is greater than 3 (for sortPos
 838                 // values less than three, we show the sortOrderDots instead)
 839                 sortOrderLabel.setText(&quot;&quot; + (sortPos + 1));
 840                 sortOrderLabel.setVisible(sortColumnCount &gt; 1);
 841 
 842                 // update the grid layout
 843                 sortArrowGrid.add(arrow, 1, 1);
 844                 GridPane.setHgrow(arrow, Priority.NEVER);
 845                 GridPane.setVgrow(arrow, Priority.NEVER);
 846                 sortArrowGrid.add(sortOrderLabel, 2, 1);
 847             } else if (showSortOrderDots) {
 848                 if (sortOrderDots == null) {
 849                     sortOrderDots = new HBox(0);
 850                     sortOrderDots.getStyleClass().add(&quot;sort-order-dots-container&quot;);
 851                 }
 852 
 853                 // show the sort order dots
 854                 boolean isAscending = isAscending(getTableColumn());
 855                 int arrowRow = isAscending ? 1 : 2;
 856                 int dotsRow = isAscending ? 2 : 1;
 857 
 858                 sortArrowGrid.add(arrow, 1, arrowRow);
 859                 GridPane.setHalignment(arrow, HPos.CENTER);
 860                 sortArrowGrid.add(sortOrderDots, 1, dotsRow);
 861 
 862                 updateSortOrderDots(sortPos);
 863             } else {
 864                 // only show the arrow
 865                 sortArrowGrid.add(arrow, 1, 1);
 866                 GridPane.setHgrow(arrow, Priority.NEVER);
 867                 GridPane.setVgrow(arrow, Priority.ALWAYS);
 868             }
 869         }
 870 
 871         sortArrow = _sortArrow;
 872         if (sortArrow != null) {
 873             sortArrow.setVisible(isSortColumn);
 874         }
 875 
 876         requestLayout();
 877     }
 878 
 879     private void updateSortOrderDots(int sortPos) {
 880         double arrowWidth = arrow.prefWidth(-1);
 881 
 882         sortOrderDots.getChildren().clear();
 883 
 884         for (int i = 0; i &lt;= sortPos; i++) {
 885             Region r = new Region();
 886             r.getStyleClass().add(&quot;sort-order-dot&quot;);
 887 
 888             String sortTypeName = getSortTypeName(getTableColumn());
 889             if (sortTypeName != null &amp;&amp; ! sortTypeName.isEmpty()) {
 890                 r.getStyleClass().add(sortTypeName.toLowerCase(Locale.ROOT));
 891             }
 892 
 893             sortOrderDots.getChildren().add(r);
 894 
 895             // RT-34914: fine tuning the placement of the sort dots. We could have gone to a custom layout, but for now
 896             // this works fine.
 897             if (i &lt; sortPos) {
 898                 Region spacer = new Region();
 899                 double lp = sortPos == 1 ? 1 : 0;
 900                 spacer.setPadding(new Insets(0, 1, 0, lp));
 901                 sortOrderDots.getChildren().add(spacer);
 902             }
 903         }
 904 
 905         sortOrderDots.setAlignment(Pos.TOP_CENTER);
 906         sortOrderDots.setMaxWidth(arrowWidth);
 907     }
 908 
 909     // Package for testing purposes only.
 910     void moveColumn(TableColumnBase column, final int newColumnPos) {
 911         if (column == null || newColumnPos &lt; 0) return;
 912 
 913         ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 914 
 915         final int columnsCount = columns.size();
 916         final int currentPos = columns.indexOf(column);
 917 
 918         int actualNewColumnPos = newColumnPos;
 919 
 920         // Fix for RT-35141: We need to account for hidden columns.
 921         // We keep iterating until we see &#39;requiredVisibleColumns&#39; number of visible columns
 922         final int requiredVisibleColumns = actualNewColumnPos;
 923         int visibleColumnsSeen = 0;
 924         for (int i = 0; i &lt; columnsCount; i++) {
 925             if (visibleColumnsSeen == (requiredVisibleColumns + 1)) {
 926                 break;
 927             }
 928 
 929             if (columns.get(i).isVisible()) {
 930                 visibleColumnsSeen++;
 931             } else {
 932                 actualNewColumnPos++;
 933             }
 934         }
 935         // --- end of RT-35141 fix
 936 
 937         if (actualNewColumnPos &gt;= columnsCount) {
 938             actualNewColumnPos = columnsCount - 1;
 939         } else if (actualNewColumnPos &lt; 0) {
 940             actualNewColumnPos = 0;
 941         }
 942 
 943         if (actualNewColumnPos == currentPos) return;
 944 
 945         List&lt;TableColumnBase&lt;?,?&gt;&gt; tempList = new ArrayList&lt;&gt;(columns);
 946         tempList.remove(column);
 947         tempList.add(actualNewColumnPos, column);
 948 
 949         columns.setAll(tempList);
 950     }
 951 
 952     private ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; getColumns(TableColumnBase column) {
 953         return column.getParentColumn() == null ?
 954                 TableSkinUtils.getColumns(getTableSkin()) :
 955                 column.getParentColumn().getColumns();
 956     }
 957 
 958     private int getIndex(TableColumnBase&lt;?,?&gt; column) {
 959         if (column == null) return -1;
 960 
 961         ObservableList&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 962 
 963         int index = -1;
 964         for (int i = 0; i &lt; columns.size(); i++) {
 965             TableColumnBase&lt;?,?&gt; _column = columns.get(i);
 966             if (! _column.isVisible()) continue;
 967 
 968             index++;
 969             if (column.equals(_column)) break;
 970         }
 971 
 972         return index;
 973     }
 974 
 975     private void updateColumnIndex() {
 976 //        TableView tv = getTableView();
 977         TableColumnBase tc = getTableColumn();
 978         TableViewSkinBase tableSkin = getTableSkin();
 979         columnIndex = tableSkin == null || tc == null ? -1 :TableSkinUtils.getVisibleLeafIndex(tableSkin,tc);
 980 
 981         // update the pseudo class state regarding whether this is the last
 982         // visible cell (i.e. the right-most).
 983         isLastVisibleColumn = getTableColumn() != null &amp;&amp;
 984                 columnIndex != -1 &amp;&amp;
 985                 columnIndex == TableSkinUtils.getVisibleLeafColumns(tableSkin).size() - 1;
 986         pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
 987     }
 988 
 989     private void sortColumn(final boolean addColumn) {
 990         if (! isSortingEnabled()) return;
 991 
 992         // we only allow sorting on the leaf columns and columns
 993         // that actually have comparators defined, and are sortable
 994         if (getTableColumn() == null || getTableColumn().getColumns().size() != 0 || getTableColumn().getComparator() == null || !getTableColumn().isSortable()) return;
 995 //        final int sortPos = getTable().getSortOrder().indexOf(column);
 996 //        final boolean isSortColumn = sortPos != -1;
 997 
 998         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
 999 
1000         // addColumn is true e.g. when the user is holding down Shift
1001         if (addColumn) {
1002             if (!isSortColumn) {
1003                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1004                 sortOrder.add(getTableColumn());
1005             } else if (isAscending(getTableColumn())) {
1006                 setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1007             } else {
1008                 int i = sortOrder.indexOf(getTableColumn());
1009                 if (i != -1) {
1010                     sortOrder.remove(i);
1011                 }
1012             }
1013         } else {
1014             // the user has clicked on a column header - we should add this to
1015             // the TableView sortOrder list if it isn&#39;t already there.
1016             if (isSortColumn &amp;&amp; sortOrder.size() == 1) {
1017                 // the column is already being sorted, and it&#39;s the only column.
1018                 // We therefore move through the 2nd or 3rd states:
1019                 //   1st click: sort ascending
1020                 //   2nd click: sort descending
1021                 //   3rd click: natural sorting (sorting is switched off)
1022                 if (isAscending(getTableColumn())) {
1023                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1024                 } else {
1025                     // remove from sort
1026                     sortOrder.remove(getTableColumn());
1027                 }
1028             } else if (isSortColumn) {
1029                 // the column is already being used to sort, so we toggle its
1030                 // sortAscending property, and also make the column become the
1031                 // primary sort column
1032                 if (isAscending(getTableColumn())) {
1033                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1034                 } else if (isDescending(getTableColumn())) {
1035                     setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1036                 }
1037 
1038                 // to prevent multiple sorts, we make a copy of the sort order
1039                 // list, moving the column value from the current position to
1040                 // its new position at the front of the list
1041                 List&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderCopy = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrder);
1042                 sortOrderCopy.remove(getTableColumn());
1043                 sortOrderCopy.add(0, getTableColumn());
1044                 sortOrder.setAll(getTableColumn());
1045             } else {
1046                 // add to the sort order, in ascending form
1047                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1048                 sortOrder.setAll(getTableColumn());
1049             }
1050         }
1051     }
1052 
1053     // Because it is possible that some columns are in the sortOrder list but are
1054     // not themselves sortable, we cannot just do sortOrderList.indexOf(column).
1055     // Therefore, this method does the proper work required of iterating through
1056     // and ignoring non-sortable (and null) columns in the sortOrder list.
1057     private int getSortPosition() {
1058         if (getTableColumn() == null) {
1059             return -1;
1060         }
1061 
1062         final List&lt;TableColumnBase&gt; sortOrder = getVisibleSortOrderColumns();
1063         int pos = 0;
1064         for (int i = 0; i &lt; sortOrder.size(); i++) {
1065             TableColumnBase _tc = sortOrder.get(i);
1066 
1067             if (getTableColumn().equals(_tc)) {
1068                 return pos;
1069             }
1070 
1071             pos++;
1072         }
1073 
1074         return -1;
1075     }
1076 
1077     private List&lt;TableColumnBase&gt; getVisibleSortOrderColumns() {
1078         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
1079 
1080         List&lt;TableColumnBase&gt; visibleSortOrderColumns = new ArrayList&lt;&gt;();
1081         for (int i = 0; i &lt; sortOrder.size(); i++) {
1082             TableColumnBase _tc = sortOrder.get(i);
1083             if (_tc == null || ! _tc.isSortable() || ! _tc.isVisible()) {
1084                 continue;
1085             }
1086 
1087             visibleSortOrderColumns.add(_tc);
1088         }
1089 
1090         return visibleSortOrderColumns;
1091     }
1092 
1093     // as with getSortPosition above, this method iterates through the sortOrder
1094     // list ignoring the null and non-sortable columns, so that we get the correct
1095     // number of columns in the sortOrder list.
1096     private int getVisibleSortOrderColumnCount() {
1097         return getVisibleSortOrderColumns().size();
1098     }
1099 
1100 
1101 
1102     /***************************************************************************
1103      *                                                                         *
1104      * Private Implementation: Column Reordering                               *
1105      *                                                                         *
1106      **************************************************************************/
1107 
1108     // package for testing
1109     void columnReorderingStarted(double dragOffset) {
1110         if (! getTableColumn().isReorderable()) return;
1111 
1112         // Used to ensure the column ghost is positioned relative to where the
1113         // user clicked on the column header
1114         this.dragOffset = dragOffset;
1115 
1116         // Note here that we only allow for reordering of &#39;root&#39; columns
1117         getTableHeaderRow().setReorderingColumn(getTableColumn());
1118         getTableHeaderRow().setReorderingRegion(this);
1119     }
1120 
1121     // package for testing
1122     void columnReordering(double sceneX, double sceneY) {
1123         if (! getTableColumn().isReorderable()) return;
1124 
1125         // this is for handling the column drag to reorder columns.
1126         // It shows a line to indicate where the &#39;drop&#39; will be.
1127 
1128         // indicate that we&#39;ve started dragging so that the dragging
1129         // line overlay is shown
1130         getTableHeaderRow().setReordering(true);
1131 
1132         // Firstly we need to determine where to draw the line.
1133         // Find which column we&#39;re over
1134         TableColumnHeader hoverHeader = null;
1135 
1136         // x represents where the mouse is relative to the parent
1137         // NestedTableColumnHeader
1138         final double x = getParentHeader().sceneToLocal(sceneX, sceneY).getX();
1139 
1140         // calculate where the ghost column header should be
1141         double dragX = getTableSkin().getSkinnable().sceneToLocal(sceneX, sceneY).getX() - dragOffset;
1142         getTableHeaderRow().setDragHeaderX(dragX);
1143 
1144         double startX = 0;
1145         double endX = 0;
1146         double headersWidth = 0;
1147         newColumnPos = 0;
1148         for (TableColumnHeader header : getParentHeader().getColumnHeaders()) {
1149             if (! header.isVisible()) continue;
1150 
1151             double headerWidth = header.prefWidth(-1);
1152             headersWidth += headerWidth;
1153 
1154             startX = header.getBoundsInParent().getMinX();
1155             endX = startX + headerWidth;
1156 
1157             if (x &gt;= startX &amp;&amp; x &lt; endX) {
1158                 hoverHeader = header;
1159                 break;
1160             }
1161             newColumnPos++;
1162         }
1163 
1164         // hoverHeader will be null if the drag occurs outside of the
1165         // tableview. In this case we handle the newColumnPos specially
1166         // and then short-circuit. This results in the drop action
1167         // resulting in the correct result (the column will drop at
1168         // the start or end of the table).
1169         if (hoverHeader == null) {
1170             newColumnPos = x &gt; headersWidth ? (getParentHeader().getColumns().size() - 1) : 0;
1171             return;
1172         }
1173 
1174         // This is the x-axis value midway through hoverHeader. It&#39;s
1175         // used to determine whether the drop should be to the left
1176         // or the right of hoverHeader.
1177         double midPoint = startX + (endX - startX) / 2;
1178         boolean beforeMidPoint = x &lt;= midPoint;
1179 
1180         // Based on where the mouse actually is, we have to shuffle
1181         // where we want the column to end up. This code handles that.
1182         int currentPos = getIndex(getTableColumn());
1183         newColumnPos += newColumnPos &gt; currentPos &amp;&amp; beforeMidPoint ?
1184             -1 : (newColumnPos &lt; currentPos &amp;&amp; !beforeMidPoint ? 1 : 0);
1185 
1186         double lineX = getTableHeaderRow().sceneToLocal(hoverHeader.localToScene(hoverHeader.getBoundsInLocal())).getMinX();
1187         lineX = lineX + ((beforeMidPoint) ? (0) : (hoverHeader.getWidth()));
1188 
1189         if (lineX &gt;= -0.5 &amp;&amp; lineX &lt;= getTableSkin().getSkinnable().getWidth()) {
1190             columnReorderLine.setTranslateX(lineX);
1191 
1192             // then if this is the first event, we set the property to true
1193             // so that the line becomes visible until the drop is completed.
1194             // We also set reordering to true so that the various reordering
1195             // effects become visible (ghost, transparent overlay, etc).
1196             columnReorderLine.setVisible(true);
1197         }
1198 
1199         getTableHeaderRow().setReordering(true);
1200     }
1201 
1202     // package for testing
1203     void columnReorderingComplete() {
1204         if (! getTableColumn().isReorderable()) return;
1205 
1206         // Move col from where it is now to the new position.
1207         moveColumn(getTableColumn(), newColumnPos);
1208 
1209         // cleanup
1210         columnReorderLine.setTranslateX(0.0F);
1211         columnReorderLine.setLayoutX(0.0F);
1212         newColumnPos = 0;
1213 
1214         getTableHeaderRow().setReordering(false);
1215         columnReorderLine.setVisible(false);
1216         getTableHeaderRow().setReorderingColumn(null);
1217         getTableHeaderRow().setReorderingRegion(null);
1218         dragOffset = 0.0F;
1219     }
1220 
1221     double getDragRectHeight() {
1222         return getHeight();
1223     }
1224 
1225     // Used to test whether this column header properly represents the given column.
1226     // In particular, whether it has child column headers for all child columns
1227     boolean represents(TableColumnBase&lt;?, ?&gt; column) {
1228         if (!column.getColumns().isEmpty()) {
1229             // this column has children, but we are in a TableColumnHeader instance,
1230             // so the match is bad.
1231             return false;
1232         }
1233         return column == getTableColumn();
1234     }
1235 
1236 
1237 
1238     /***************************************************************************
1239      *                                                                         *
1240      * Stylesheet Handling                                                     *
1241      *                                                                         *
1242      **************************************************************************/
1243 
1244     private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
1245             PseudoClass.getPseudoClass(&quot;last-visible&quot;);
1246 
1247     /*
1248      * Super-lazy instantiation pattern from Bill Pugh.
1249      */
1250      private static class StyleableProperties {
1251          private static final CssMetaData&lt;TableColumnHeader,Number&gt; SIZE =
1252             new CssMetaData&lt;TableColumnHeader,Number&gt;(&quot;-fx-size&quot;,
1253                  SizeConverter.getInstance(), 20.0) {
1254 
1255             @Override
1256             public boolean isSettable(TableColumnHeader n) {
1257                 return n.size == null || !n.size.isBound();
1258             }
1259 
1260             @Override
1261             public StyleableProperty&lt;Number&gt; getStyleableProperty(TableColumnHeader n) {
1262                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.sizeProperty();
1263             }
1264         };
1265 
1266          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1267          static {
1268 
1269             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1270                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
1271             styleables.add(SIZE);
1272             STYLEABLES = Collections.unmodifiableList(styleables);
1273 
1274          }
1275     }
1276 
1277     /**
1278      * Returns the CssMetaData associated with this class, which may include the
1279      * CssMetaData of its superclasses.
1280      *
1281      * @return the CssMetaData associated with this class, which may include the
1282      * CssMetaData of its superclasses
1283      */
1284     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1285         return StyleableProperties.STYLEABLES;
1286     }
1287 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>