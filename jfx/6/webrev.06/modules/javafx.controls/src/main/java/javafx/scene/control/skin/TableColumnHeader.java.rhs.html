<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TableColumnBaseHelper;
<a name="1" id="anc1"></a><span class="line-added">  31 import com.sun.javafx.scene.control.TreeTableViewBackingList;</span>
<span class="line-added">  32 import com.sun.javafx.scene.control.skin.Utils;</span>
  33 import javafx.beans.property.DoubleProperty;
  34 import javafx.beans.property.ReadOnlyObjectProperty;
  35 import javafx.beans.property.ReadOnlyObjectWrapper;
  36 import javafx.beans.value.WritableValue;
  37 import javafx.collections.ListChangeListener;
  38 import javafx.collections.ObservableList;
  39 import javafx.collections.WeakListChangeListener;
  40 import javafx.css.CssMetaData;
  41 import javafx.css.PseudoClass;
  42 import javafx.css.Styleable;
  43 import javafx.css.StyleableDoubleProperty;
  44 import javafx.css.StyleableProperty;
<a name="2" id="anc2"></a><span class="line-added">  45 import javafx.css.converter.SizeConverter;</span>
  46 import javafx.event.EventHandler;
  47 import javafx.geometry.HPos;
  48 import javafx.geometry.Insets;
  49 import javafx.geometry.Pos;
  50 import javafx.geometry.VPos;
  51 import javafx.scene.AccessibleAttribute;
  52 import javafx.scene.AccessibleRole;
  53 import javafx.scene.Node;
  54 import javafx.scene.control.ContextMenu;
  55 import javafx.scene.control.Label;
<a name="3" id="anc3"></a><span class="line-added">  56 import javafx.scene.control.TableCell;</span>
  57 import javafx.scene.control.TableColumn;
  58 import javafx.scene.control.TableColumnBase;
<a name="4" id="anc4"></a><span class="line-added">  59 import javafx.scene.control.TableView;</span>
<span class="line-added">  60 import javafx.scene.control.TreeTableCell;</span>
<span class="line-added">  61 import javafx.scene.control.TreeTableColumn;</span>
<span class="line-added">  62 import javafx.scene.control.TreeTableRow;</span>
<span class="line-added">  63 import javafx.scene.control.TreeTableView;</span>
  64 import javafx.scene.input.ContextMenuEvent;
  65 import javafx.scene.input.MouseEvent;
  66 import javafx.scene.layout.GridPane;
  67 import javafx.scene.layout.HBox;
  68 import javafx.scene.layout.Priority;
  69 import javafx.scene.layout.Region;
<a name="5" id="anc5"></a><span class="line-added">  70 import javafx.util.Callback;</span>
  71 
  72 import java.util.ArrayList;
  73 import java.util.Collections;
  74 import java.util.List;
  75 import java.util.Locale;
  76 
<a name="6" id="anc6"></a>

  77 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeName;
  78 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.getSortTypeProperty;
  79 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isAscending;
  80 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.isDescending;
  81 import static com.sun.javafx.scene.control.TableColumnSortTypeWrapper.setSortType;
  82 
  83 
  84 /**
  85  * Region responsible for painting a single column header. A subcomponent used by
  86  * subclasses of {@link TableViewSkinBase}.
  87  *
  88  * @since 9
  89  */
  90 public class TableColumnHeader extends Region {
  91 
  92     /***************************************************************************
  93      *                                                                         *
  94      * Static Fields                                                           *
  95      *                                                                         *
  96      **************************************************************************/
  97 
  98     static final String DEFAULT_STYLE_CLASS = &quot;column-header&quot;;
  99 
 100     // Copied from TableColumn. The value here should always be in-sync with
 101     // the value in TableColumn
 102     static final double DEFAULT_COLUMN_WIDTH = 80.0F;
 103 
 104 
 105 
 106     /***************************************************************************
 107      *                                                                         *
 108      * Private Fields                                                          *
 109      *                                                                         *
 110      **************************************************************************/
 111 
 112     private boolean autoSizeComplete = false;
 113 
 114     private double dragOffset;
 115     private NestedTableColumnHeader nestedColumnHeader;
 116     private TableHeaderRow tableHeaderRow;
 117     private NestedTableColumnHeader parentHeader;
 118 
 119     // work out where this column currently is within its parent
 120     Label label;
 121 
 122     // sort order
 123     int sortPos = -1;
 124     private Region arrow;
 125     private Label sortOrderLabel;
 126     private HBox sortOrderDots;
 127     private Node sortArrow;
 128     private boolean isSortColumn;
 129 
 130     private boolean isSizeDirty = false;
 131 
 132     boolean isLastVisibleColumn = false;
 133 
 134     // package for testing
 135     int columnIndex = -1;
 136 
 137     private int newColumnPos;
 138 
 139     // the line drawn in the table when a user presses and moves a column header
 140     // to indicate where the column will be dropped. This is provided by the
 141     // table skin, but manipulated by the header
 142     Region columnReorderLine;
 143 
 144 
 145 
 146     /***************************************************************************
 147      *                                                                         *
 148      * Constructor                                                             *
 149      *                                                                         *
 150      **************************************************************************/
 151 
 152     /**
 153      * Creates a new TableColumnHeader instance to visually represent the given
 154      * {@link TableColumnBase} instance.
 155      *
 156      * @param tc The table column to be visually represented by this instance.
 157      */
 158     public TableColumnHeader(final TableColumnBase tc) {
 159         setTableColumn(tc);
 160         setFocusTraversable(false);
 161 
 162         initStyleClasses();
 163         initUI();
 164 
 165         // change listener for multiple properties
 166         changeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();
 167         changeListenerHandler.registerChangeListener(sceneProperty(), e -&gt; updateScene());
 168 
 169         if (getTableColumn() != null) {
 170             changeListenerHandler.registerChangeListener(tc.idProperty(), e -&gt; setId(tc.getId()));
 171             changeListenerHandler.registerChangeListener(tc.styleProperty(), e -&gt; setStyle(tc.getStyle()));
 172             changeListenerHandler.registerChangeListener(tc.widthProperty(), e -&gt; {
 173                 // It is this that ensures that when a column is resized that the header
 174                 // visually adjusts its width as necessary.
 175                 isSizeDirty = true;
 176                 requestLayout();
 177             });
 178             changeListenerHandler.registerChangeListener(tc.visibleProperty(), e -&gt; setVisible(getTableColumn().isVisible()));
 179             changeListenerHandler.registerChangeListener(tc.sortNodeProperty(), e -&gt; updateSortGrid());
 180             changeListenerHandler.registerChangeListener(tc.sortableProperty(), e -&gt; {
 181                 // we need to notify all headers that a sortable state has changed,
 182                 // in case the sort grid in other columns needs to be updated.
 183                 if (TableSkinUtils.getSortOrder(getTableSkin()).contains(getTableColumn())) {
 184                     NestedTableColumnHeader root = getTableHeaderRow().getRootHeader();
 185                     updateAllHeaders(root);
 186                 }
 187             });
 188             changeListenerHandler.registerChangeListener(tc.textProperty(), e -&gt; label.setText(tc.getText()));
 189             changeListenerHandler.registerChangeListener(tc.graphicProperty(), e -&gt; label.setGraphic(tc.getGraphic()));
 190 
 191             setId(tc.getId());
 192             setStyle(tc.getStyle());
 193             /* Having TableColumn role parented by TableColumn causes VoiceOver to be unhappy */
 194             setAccessibleRole(AccessibleRole.TABLE_COLUMN);
 195         }
 196     }
 197 
 198 
 199 
 200     /***************************************************************************
 201      *                                                                         *
 202      * Listeners                                                               *
 203      *                                                                         *
 204      **************************************************************************/
 205 
 206     final LambdaMultiplePropertyChangeListenerHandler changeListenerHandler;
 207 
 208     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderListener = c -&gt; {
 209         updateSortPosition();
 210     };
 211 
 212     private ListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumnsListener = c -&gt; {
 213         updateColumnIndex();
 214         updateSortPosition();
 215     };
 216 
 217     private ListChangeListener&lt;String&gt; styleClassListener = c -&gt; {
 218         while (c.next()) {
 219             if (c.wasRemoved()) {
 220                 getStyleClass().removeAll(c.getRemoved());
 221             }
 222             if (c.wasAdded()) {
 223                 getStyleClass().addAll(c.getAddedSubList());
 224             }
 225         }
 226     };
 227 
 228     private WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakSortOrderListener =
 229             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrderListener);
 230     private final WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt; weakVisibleLeafColumnsListener =
 231             new WeakListChangeListener&lt;TableColumnBase&lt;?,?&gt;&gt;(visibleLeafColumnsListener);
 232     private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
 233             new WeakListChangeListener&lt;String&gt;(styleClassListener);
 234 
 235     private static final EventHandler&lt;MouseEvent&gt; mousePressedHandler = me -&gt; {
 236         TableColumnHeader header = (TableColumnHeader) me.getSource();
 237         TableColumnBase tableColumn = header.getTableColumn();
 238 
 239         ContextMenu menu = tableColumn.getContextMenu();
 240         if (menu != null &amp;&amp; menu.isShowing()) {
 241             menu.hide();
 242         }
 243 
 244         if (me.isConsumed()) return;
 245         me.consume();
 246 
 247         header.getTableHeaderRow().columnDragLock = true;
 248 
 249         // pass focus to the table, so that the user immediately sees
 250         // the focus rectangle around the table control.
 251         header.getTableSkin().getSkinnable().requestFocus();
 252 
 253         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 254             header.columnReorderingStarted(me.getX());
 255         }
 256     };
 257 
 258     private static final EventHandler&lt;MouseEvent&gt; mouseDraggedHandler = me -&gt; {
 259         if (me.isConsumed()) return;
 260         me.consume();
 261 
 262         TableColumnHeader header = (TableColumnHeader) me.getSource();
 263 
 264         if (me.isPrimaryButtonDown() &amp;&amp; header.isColumnReorderingEnabled()) {
 265             header.columnReordering(me.getSceneX(), me.getSceneY());
 266         }
 267     };
 268 
 269     private static final EventHandler&lt;MouseEvent&gt; mouseReleasedHandler = me -&gt; {
 270         if (me.isPopupTrigger()) return;
 271         if (me.isConsumed()) return;
 272         me.consume();
 273 
 274         TableColumnHeader header = (TableColumnHeader) me.getSource();
 275         header.getTableHeaderRow().columnDragLock = false;
 276 
 277         if (header.getTableHeaderRow().isReordering() &amp;&amp; header.isColumnReorderingEnabled()) {
 278             header.columnReorderingComplete();
 279         } else if (me.isStillSincePress()) {
 280             header.sortColumn(me.isShiftDown());
 281         }
 282     };
 283 
 284     private static final EventHandler&lt;ContextMenuEvent&gt; contextMenuRequestedHandler = me -&gt; {
 285         TableColumnHeader header = (TableColumnHeader) me.getSource();
 286         TableColumnBase tableColumn = header.getTableColumn();
 287 
 288         ContextMenu menu = tableColumn.getContextMenu();
 289         if (menu != null) {
 290             menu.show(header, me.getScreenX(), me.getScreenY());
 291             me.consume();
 292         }
 293     };
 294 
 295 
 296 
 297     /***************************************************************************
 298      *                                                                         *
 299      * Properties                                                              *
 300      *                                                                         *
 301      **************************************************************************/
 302 
 303     // --- size
 304     private DoubleProperty size;
 305     private final double getSize() {
 306         return size == null ? 20.0 : size.doubleValue();
 307     }
 308     private final DoubleProperty sizeProperty() {
 309         if (size == null) {
 310             size = new StyleableDoubleProperty(20) {
 311                 @Override
 312                 protected void invalidated() {
 313                     double value = get();
 314                     if (value &lt;= 0) {
 315                         if (isBound()) {
 316                             unbind();
 317                         }
 318                         set(20);
 319                         throw new IllegalArgumentException(&quot;Size cannot be 0 or negative&quot;);
 320                     }
 321                 }
 322 
 323 
 324 
 325                 @Override public Object getBean() {
 326                     return TableColumnHeader.this;
 327                 }
 328 
 329                 @Override public String getName() {
 330                     return &quot;size&quot;;
 331                 }
 332 
 333                 @Override public CssMetaData&lt;TableColumnHeader,Number&gt; getCssMetaData() {
 334                     return StyleableProperties.SIZE;
 335                 }
 336             };
 337         }
 338         return size;
 339     }
 340 
 341 
 342     /**
 343      * A property that refers to the {@link TableColumnBase} instance that this
 344      * header is visually represents.
 345      */
 346     // --- table column
 347     private ReadOnlyObjectWrapper&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumn = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;tableColumn&quot;);
 348     private final void setTableColumn(TableColumnBase&lt;?,?&gt; column) {
 349         tableColumn.set(column);
 350     }
 351     public final TableColumnBase&lt;?,?&gt; getTableColumn() {
 352         return tableColumn.get();
 353     }
 354     public final ReadOnlyObjectProperty&lt;TableColumnBase&lt;?,?&gt;&gt; tableColumnProperty() {
 355         return tableColumn.getReadOnlyProperty();
 356     }
 357 
 358 
 359 
 360     /***************************************************************************
 361      *                                                                         *
 362      * Public API                                                              *
 363      *                                                                         *
 364      **************************************************************************/
 365 
 366     /** {@inheritDoc} */
 367     @Override protected void layoutChildren() {
 368         if (isSizeDirty) {
 369             resize(getTableColumn().getWidth(), getHeight());
 370             isSizeDirty = false;
 371         }
 372 
 373         double sortWidth = 0;
 374         double w = snapSizeX(getWidth()) - (snappedLeftInset() + snappedRightInset());
 375         double h = getHeight() - (snappedTopInset() + snappedBottomInset());
 376         double x = w;
 377 
 378         // a bit hacky, but we REALLY don&#39;t want the arrow shape to fluctuate
 379         // in size
 380         if (arrow != null) {
 381             arrow.setMaxSize(arrow.prefWidth(-1), arrow.prefHeight(-1));
 382         }
 383 
 384         if (sortArrow != null &amp;&amp; sortArrow.isVisible()) {
 385             sortWidth = sortArrow.prefWidth(-1);
 386             x -= sortWidth;
 387             sortArrow.resize(sortWidth, sortArrow.prefHeight(-1));
 388             positionInArea(sortArrow, x, snappedTopInset(),
 389                     sortWidth, h, 0, HPos.CENTER, VPos.CENTER);
 390         }
 391 
 392         if (label != null) {
 393             double labelWidth = w - sortWidth;
 394             label.resizeRelocate(snappedLeftInset(), 0, labelWidth, getHeight());
 395         }
 396     }
 397 
 398     /** {@inheritDoc} */
 399     @Override protected double computePrefWidth(double height) {
 400         if (getNestedColumnHeader() != null) {
 401             double width = getNestedColumnHeader().prefWidth(height);
 402 
 403             if (getTableColumn() != null) {
 404                 TableColumnBaseHelper.setWidth(getTableColumn(), width);
 405             }
 406 
 407             return width;
 408         } else if (getTableColumn() != null &amp;&amp; getTableColumn().isVisible()) {
 409             return snapSizeX(getTableColumn().getWidth());
 410         }
 411 
 412         return 0;
 413     }
 414 
 415     /** {@inheritDoc} */
 416     @Override protected double computeMinHeight(double width) {
 417         return label == null ? 0 : label.minHeight(width);
 418     }
 419 
 420     /** {@inheritDoc} */
 421     @Override protected double computePrefHeight(double width) {
 422         if (getTableColumn() == null) return 0;
 423         return Math.max(getSize(), label.prefHeight(-1));
 424     }
 425 
 426     /** {@inheritDoc} */
 427     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 428         return getClassCssMetaData();
 429     }
 430 
 431     /** {@inheritDoc} */
 432     @Override  public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 433         switch (attribute) {
 434             case INDEX: return getIndex(getTableColumn());
 435             case TEXT: return getTableColumn() != null ? getTableColumn().getText() : null;
 436             default: return super.queryAccessibleAttribute(attribute, parameters);
 437         }
 438     }
 439 
 440 
 441 
 442     /***************************************************************************
 443      *                                                                         *
 444      * Private Implementation                                                  *
 445      *                                                                         *
 446      **************************************************************************/
 447 
 448     void initStyleClasses() {
 449         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 450         installTableColumnStyleClassListener();
 451     }
 452 
 453     void installTableColumnStyleClassListener() {
 454         TableColumnBase tc = getTableColumn();
 455         if (tc != null) {
 456             // add in all styleclasses from the table column into the header, and also set up a listener
 457             // so that any subsequent changes to the table column are also applied to the header
 458             getStyleClass().addAll(tc.getStyleClass());
 459             tc.getStyleClass().addListener(weakStyleClassListener);
 460         }
 461     }
 462 
 463     NestedTableColumnHeader getNestedColumnHeader() { return nestedColumnHeader; }
 464     void setNestedColumnHeader(NestedTableColumnHeader nch) { nestedColumnHeader = nch; }
 465 
 466     /**
 467      * Returns the {@link TableHeaderRow} associated with this {@code TableColumnHeader}.
 468      *
 469      * @return the {@code TableHeaderRow} associated with this {@code TableColumnHeader}
 470      * @since 12
 471      */
 472     protected TableHeaderRow getTableHeaderRow() {
 473         return tableHeaderRow;
 474     }
 475 
 476     void setTableHeaderRow(TableHeaderRow thr) {
 477         tableHeaderRow = thr;
 478         updateTableSkin();
 479     }
 480 
 481     private void updateTableSkin() {
 482         // when we get the table header row, we are also given the skin,
 483         // so this is the time to hook up listeners, etc.
 484         TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin = getTableSkin();
 485         if (tableSkin == null) return;
 486 
 487         updateColumnIndex();
 488         this.columnReorderLine = tableSkin.getColumnReorderLine();
 489 
 490         if (getTableColumn() != null) {
 491             updateSortPosition();
 492             TableSkinUtils.getSortOrder(tableSkin).addListener(weakSortOrderListener);
 493             TableSkinUtils.getVisibleLeafColumns(tableSkin).addListener(weakVisibleLeafColumnsListener);
 494         }
 495     }
 496 
 497     /**
 498      * Returns the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted. This will return
 499      * {@code null} until the {@code TableHeaderRow} has been set.
 500      *
 501      * @return the {@code TableViewSkinBase} in which this {@code TableColumnHeader} is inserted, or {@code null}
 502      * @since 12
 503      */
 504     protected TableViewSkinBase&lt;?, ?, ?, ?, ?&gt; getTableSkin() {
 505         return tableHeaderRow == null ? null : tableHeaderRow.tableSkin;
 506     }
 507 
 508     NestedTableColumnHeader getParentHeader() { return parentHeader; }
 509     void setParentHeader(NestedTableColumnHeader ph) { parentHeader = ph; }
 510 
 511     // RT-29682: When the sortable property of a TableColumnBase changes this
 512     // may impact other TableColumnHeaders, as they may need to change their
 513     // sort order representation. Rather than install listeners across all
 514     // TableColumn in the sortOrder list for their sortable property, we simply
 515     // update the sortPosition of all headers whenever the sortOrder property
 516     // changes, assuming the column is within the sortOrder list.
 517     private void updateAllHeaders(TableColumnHeader header) {
 518         if (header instanceof NestedTableColumnHeader) {
 519             List&lt;TableColumnHeader&gt; children = ((NestedTableColumnHeader)header).getColumnHeaders();
 520             for (int i = 0; i &lt; children.size(); i++) {
 521                 updateAllHeaders(children.get(i));
 522             }
 523         } else {
 524             header.updateSortPosition();
 525         }
 526     }
 527 
 528     private void updateScene() {
 529         // RT-17684: If the TableColumn widths are all currently the default,
 530         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 531         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 532         // number of rows retrieved from a very slow (e.g. remote) data source.
 533         // Obviously, the bigger the value of n, the more likely the default
 534         // width will be suitable for most values in the column
 535         final int n = 30;
 536         if (! autoSizeComplete) {
 537             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 538                 return;
 539             }
<a name="7" id="anc7"></a><span class="line-modified"> 540             doColumnAutoSize(n);</span>
 541             autoSizeComplete = true;
 542         }
 543     }
 544 
 545     void dispose() {
 546         TableViewSkinBase tableSkin = getTableSkin();
 547         if (tableSkin != null) {
 548             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 549             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 550         }
 551 
 552         changeListenerHandler.dispose();
 553     }
 554 
 555     private boolean isSortingEnabled() {
 556         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 557         // to always return true (for now), as we want to support column sorting
 558         // everywhere
 559         return true;
 560     }
 561 
 562     private boolean isColumnReorderingEnabled() {
 563         // we only allow for column reordering if there are more than one column,
 564         return !Properties.IS_TOUCH_SUPPORTED &amp;&amp; TableSkinUtils.getVisibleLeafColumns(getTableSkin()).size() &gt; 1;
 565     }
 566 
 567     private void initUI() {
 568         // TableColumn will be null if we are dealing with the root NestedTableColumnHeader
 569         if (getTableColumn() == null) return;
 570 
 571         // set up mouse events
 572         setOnMousePressed(mousePressedHandler);
 573         setOnMouseDragged(mouseDraggedHandler);
 574         setOnDragDetected(event -&gt; event.consume());
 575         setOnContextMenuRequested(contextMenuRequestedHandler);
 576         setOnMouseReleased(mouseReleasedHandler);
 577 
 578         // --- label
 579         label = new Label();
 580         label.setText(getTableColumn().getText());
 581         label.setGraphic(getTableColumn().getGraphic());
 582         label.setVisible(getTableColumn().isVisible());
 583 
 584         // ---- container for the sort arrow (which is not supported on embedded
 585         // platforms)
 586         if (isSortingEnabled()) {
 587             // put together the grid
 588             updateSortGrid();
 589         }
 590     }
 591 
<a name="8" id="anc8"></a><span class="line-modified"> 592     private void doColumnAutoSize(int cellsToMeasure) {</span>
<span class="line-modified"> 593         double prefWidth = getTableColumn().getPrefWidth();</span>
 594 
 595         // if the prefWidth has been set, we do _not_ autosize columns
 596         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<a name="9" id="anc9"></a><span class="line-modified"> 597             resizeColumnToFitContent(cellsToMeasure);</span>
<span class="line-modified"> 598         }</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601     /**</span>
<span class="line-added"> 602      * Resizes this {@code TableColumnHeader}&#39;s column to fit the width of its content.</span>
<span class="line-added"> 603      *</span>
<span class="line-added"> 604      * @implSpec The resulting column width for this implementation is the maximum of the preferred width of the header</span>
<span class="line-added"> 605      * cell and the preferred width of the first {@code maxRow} cells.</span>
<span class="line-added"> 606      * &lt;p&gt;</span>
<span class="line-added"> 607      * Subclasses can either use this method or override it (without the need to call {@code super()}) to provide their</span>
<span class="line-added"> 608      * custom implementation (such as ones that exclude the header, exclude {@code null} content, compute the minimum</span>
<span class="line-added"> 609      * width, etc.).</span>
<span class="line-added"> 610      *</span>
<span class="line-added"> 611      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.</span>
<span class="line-added"> 612      * @since 14</span>
<span class="line-added"> 613      */</span>
<span class="line-added"> 614     protected void resizeColumnToFitContent(int maxRows) {</span>
<span class="line-added"> 615         TableColumnBase&lt;?, ?&gt; tc = getTableColumn();</span>
<span class="line-added"> 616         if (!tc.isResizable()) return;</span>
<span class="line-added"> 617 </span>
<span class="line-added"> 618         Object control = this.getTableSkin().getSkinnable();</span>
<span class="line-added"> 619         if (control instanceof TableView) {</span>
<span class="line-added"> 620             resizeColumnToFitContent((TableView) control, (TableColumn) tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 621         } else if (control instanceof TreeTableView) {</span>
<span class="line-added"> 622             resizeColumnToFitContent((TreeTableView) control, (TreeTableColumn) tc, this.getTableSkin(), maxRows);</span>
<span class="line-added"> 623         }</span>
<span class="line-added"> 624     }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 627         List&lt;?&gt; items = tv.getItems();</span>
<span class="line-added"> 628         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 631         if (cellFactory == null) return;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);</span>
<span class="line-added"> 634         if (cell == null) return;</span>
<span class="line-added"> 635 </span>
<span class="line-added"> 636         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 637         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 638         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640         // determine cell padding</span>
<span class="line-added"> 641         double padding = 10;</span>
<span class="line-added"> 642         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 643         if (n instanceof Region) {</span>
<span class="line-added"> 644             Region r = (Region) n;</span>
<span class="line-added"> 645             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 646         }</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 649         double maxWidth = 0;</span>
<span class="line-added"> 650         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 651             cell.updateTableColumn(tc);</span>
<span class="line-added"> 652             cell.updateTableView(tv);</span>
<span class="line-added"> 653             cell.updateIndex(row);</span>
<span class="line-added"> 654 </span>
<span class="line-added"> 655             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 656                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 657                 cell.applyCss();</span>
<span class="line-added"> 658                 maxWidth = Math.max(maxWidth, cell.prefWidth(-1));</span>
<span class="line-added"> 659                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 660             }</span>
<span class="line-added"> 661         }</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 664         cell.updateIndex(-1);</span>
<span class="line-added"> 665 </span>
<span class="line-added"> 666         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 667         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 668         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 669         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 670         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 671         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 672         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 673         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675         // RT-23486</span>
<span class="line-added"> 676         maxWidth += padding;</span>
<span class="line-added"> 677         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {</span>
<span class="line-added"> 678             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 679                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 680             }</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682             int size = tc.getColumns().size();</span>
<span class="line-added"> 683             if (size &gt; 0) {</span>
<span class="line-added"> 684                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 685                 if (columnHeader != null) {</span>
<span class="line-added"> 686                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 687                 }</span>
<span class="line-added"> 688                 return;</span>
<span class="line-added"> 689             }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 692         } else {</span>
<span class="line-added"> 693             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
<span class="line-added"> 694         }</span>
<span class="line-added"> 695     }</span>
<span class="line-added"> 696 </span>
<span class="line-added"> 697     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {</span>
<span class="line-added"> 698         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);</span>
<span class="line-added"> 699         if (items == null || items.isEmpty()) return;</span>
<span class="line-added"> 700 </span>
<span class="line-added"> 701         Callback cellFactory = tc.getCellFactory();</span>
<span class="line-added"> 702         if (cellFactory == null) return;</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);</span>
<span class="line-added"> 705         if (cell == null) return;</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         // set this property to tell the TableCell we want to know its actual</span>
<span class="line-added"> 708         // preferred width, not the width of the associated TableColumnBase</span>
<span class="line-added"> 709         cell.getProperties().put(Properties.DEFER_TO_PARENT_PREF_WIDTH, Boolean.TRUE);</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711         // determine cell padding</span>
<span class="line-added"> 712         double padding = 10;</span>
<span class="line-added"> 713         Node n = cell.getSkin() == null ? null : cell.getSkin().getNode();</span>
<span class="line-added"> 714         if (n instanceof Region) {</span>
<span class="line-added"> 715             Region r = (Region) n;</span>
<span class="line-added"> 716             padding = r.snappedLeftInset() + r.snappedRightInset();</span>
<span class="line-added"> 717         }</span>
<span class="line-added"> 718 </span>
<span class="line-added"> 719         TreeTableRow&lt;T&gt; treeTableRow = new TreeTableRow&lt;&gt;();</span>
<span class="line-added"> 720         treeTableRow.updateTreeTableView(ttv);</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722         int rows = maxRows == -1 ? items.size() : Math.min(items.size(), maxRows);</span>
<span class="line-added"> 723         double maxWidth = 0;</span>
<span class="line-added"> 724         for (int row = 0; row &lt; rows; row++) {</span>
<span class="line-added"> 725             treeTableRow.updateIndex(row);</span>
<span class="line-added"> 726             treeTableRow.updateTreeItem(ttv.getTreeItem(row));</span>
<span class="line-added"> 727 </span>
<span class="line-added"> 728             cell.updateTreeTableColumn(tc);</span>
<span class="line-added"> 729             cell.updateTreeTableView(ttv);</span>
<span class="line-added"> 730             cell.updateTreeTableRow(treeTableRow);</span>
<span class="line-added"> 731             cell.updateIndex(row);</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733             if ((cell.getText() != null &amp;&amp; !cell.getText().isEmpty()) || cell.getGraphic() != null) {</span>
<span class="line-added"> 734                 tableSkin.getChildren().add(cell);</span>
<span class="line-added"> 735                 cell.applyCss();</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737                 double w = cell.prefWidth(-1);</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739                 maxWidth = Math.max(maxWidth, w);</span>
<span class="line-added"> 740                 tableSkin.getChildren().remove(cell);</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742         }</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744         // dispose of the cell to prevent it retaining listeners (see RT-31015)</span>
<span class="line-added"> 745         cell.updateIndex(-1);</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747         // RT-36855 - take into account the column header text / graphic widths.</span>
<span class="line-added"> 748         // Magic 10 is to allow for sort arrow to appear without text truncation.</span>
<span class="line-added"> 749         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);</span>
<span class="line-added"> 750         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);</span>
<span class="line-added"> 751         Node graphic = header.label.getGraphic();</span>
<span class="line-added"> 752         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();</span>
<span class="line-added"> 753         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();</span>
<span class="line-added"> 754         maxWidth = Math.max(maxWidth, headerWidth);</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756         // RT-23486</span>
<span class="line-added"> 757         maxWidth += padding;</span>
<span class="line-added"> 758         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {</span>
<span class="line-added"> 759 </span>
<span class="line-added"> 760             if (maxWidth &gt; tc.getMaxWidth()) {</span>
<span class="line-added"> 761                 maxWidth = tc.getMaxWidth();</span>
<span class="line-added"> 762             }</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764             int size = tc.getColumns().size();</span>
<span class="line-added"> 765             if (size &gt; 0) {</span>
<span class="line-added"> 766                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 767                 if (columnHeader != null) {</span>
<span class="line-added"> 768                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 769                 }</span>
<span class="line-added"> 770                 return;</span>
<span class="line-added"> 771             }</span>
<span class="line-added"> 772 </span>
<span class="line-added"> 773             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));</span>
<span class="line-added"> 774         } else {</span>
<span class="line-added"> 775             TableColumnBaseHelper.setWidth(tc, maxWidth);</span>
 776         }
 777     }
 778 
 779     private void updateSortPosition() {
 780         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 781         updateSortGrid();
 782     }
 783 
 784     private void updateSortGrid() {
 785         // Fix for RT-14488
 786         if (this instanceof NestedTableColumnHeader) return;
 787 
 788         getChildren().clear();
 789         getChildren().add(label);
 790 
 791         // we do not support sorting in embedded devices
 792         if (! isSortingEnabled()) return;
 793 
 794         isSortColumn = sortPos != -1;
 795         if (! isSortColumn) {
 796             if (sortArrow != null) {
 797                 sortArrow.setVisible(false);
 798             }
 799             return;
 800         }
 801 
 802         // RT-28016: if the tablecolumn is not a visible leaf column, we should ignore this
 803         int visibleLeafIndex = TableSkinUtils.getVisibleLeafIndex(getTableSkin(), getTableColumn());
 804         if (visibleLeafIndex == -1) return;
 805 
 806         final int sortColumnCount = getVisibleSortOrderColumnCount();
 807         boolean showSortOrderDots = sortPos &lt;= 3 &amp;&amp; sortColumnCount &gt; 1;
 808 
 809         Node _sortArrow = null;
 810         if (getTableColumn().getSortNode() != null) {
 811             _sortArrow = getTableColumn().getSortNode();
 812             getChildren().add(_sortArrow);
 813         } else {
 814             GridPane sortArrowGrid = new GridPane();
 815             _sortArrow = sortArrowGrid;
 816             sortArrowGrid.setPadding(new Insets(0, 3, 0, 0));
 817             getChildren().add(sortArrowGrid);
 818 
 819             // if we are here, and the sort arrow is null, we better create it
 820             if (arrow == null) {
 821                 arrow = new Region();
 822                 arrow.getStyleClass().setAll(&quot;arrow&quot;);
 823                 arrow.setVisible(true);
 824                 arrow.setRotate(isAscending(getTableColumn()) ? 180.0F : 0.0F);
 825                 changeListenerHandler.registerChangeListener(getSortTypeProperty(getTableColumn()), e -&gt; {
 826                     updateSortGrid();
 827                     if (arrow != null) {
 828                         arrow.setRotate(isAscending(getTableColumn()) ? 180 : 0.0);
 829                     }
 830                 });
 831             }
 832 
 833             arrow.setVisible(isSortColumn);
 834 
 835             if (sortPos &gt; 2) {
 836                 if (sortOrderLabel == null) {
 837                     // ---- sort order label (for sort positions greater than 3)
 838                     sortOrderLabel = new Label();
 839                     sortOrderLabel.getStyleClass().add(&quot;sort-order&quot;);
 840                 }
 841 
 842                 // only show the label if the sortPos is greater than 3 (for sortPos
 843                 // values less than three, we show the sortOrderDots instead)
 844                 sortOrderLabel.setText(&quot;&quot; + (sortPos + 1));
 845                 sortOrderLabel.setVisible(sortColumnCount &gt; 1);
 846 
 847                 // update the grid layout
 848                 sortArrowGrid.add(arrow, 1, 1);
 849                 GridPane.setHgrow(arrow, Priority.NEVER);
 850                 GridPane.setVgrow(arrow, Priority.NEVER);
 851                 sortArrowGrid.add(sortOrderLabel, 2, 1);
 852             } else if (showSortOrderDots) {
 853                 if (sortOrderDots == null) {
 854                     sortOrderDots = new HBox(0);
 855                     sortOrderDots.getStyleClass().add(&quot;sort-order-dots-container&quot;);
 856                 }
 857 
 858                 // show the sort order dots
 859                 boolean isAscending = isAscending(getTableColumn());
 860                 int arrowRow = isAscending ? 1 : 2;
 861                 int dotsRow = isAscending ? 2 : 1;
 862 
 863                 sortArrowGrid.add(arrow, 1, arrowRow);
 864                 GridPane.setHalignment(arrow, HPos.CENTER);
 865                 sortArrowGrid.add(sortOrderDots, 1, dotsRow);
 866 
 867                 updateSortOrderDots(sortPos);
 868             } else {
 869                 // only show the arrow
 870                 sortArrowGrid.add(arrow, 1, 1);
 871                 GridPane.setHgrow(arrow, Priority.NEVER);
 872                 GridPane.setVgrow(arrow, Priority.ALWAYS);
 873             }
 874         }
 875 
 876         sortArrow = _sortArrow;
 877         if (sortArrow != null) {
 878             sortArrow.setVisible(isSortColumn);
 879         }
 880 
 881         requestLayout();
 882     }
 883 
 884     private void updateSortOrderDots(int sortPos) {
 885         double arrowWidth = arrow.prefWidth(-1);
 886 
 887         sortOrderDots.getChildren().clear();
 888 
 889         for (int i = 0; i &lt;= sortPos; i++) {
 890             Region r = new Region();
 891             r.getStyleClass().add(&quot;sort-order-dot&quot;);
 892 
 893             String sortTypeName = getSortTypeName(getTableColumn());
 894             if (sortTypeName != null &amp;&amp; ! sortTypeName.isEmpty()) {
 895                 r.getStyleClass().add(sortTypeName.toLowerCase(Locale.ROOT));
 896             }
 897 
 898             sortOrderDots.getChildren().add(r);
 899 
 900             // RT-34914: fine tuning the placement of the sort dots. We could have gone to a custom layout, but for now
 901             // this works fine.
 902             if (i &lt; sortPos) {
 903                 Region spacer = new Region();
 904                 double lp = sortPos == 1 ? 1 : 0;
 905                 spacer.setPadding(new Insets(0, 1, 0, lp));
 906                 sortOrderDots.getChildren().add(spacer);
 907             }
 908         }
 909 
 910         sortOrderDots.setAlignment(Pos.TOP_CENTER);
 911         sortOrderDots.setMaxWidth(arrowWidth);
 912     }
 913 
 914     // Package for testing purposes only.
 915     void moveColumn(TableColumnBase column, final int newColumnPos) {
 916         if (column == null || newColumnPos &lt; 0) return;
 917 
 918         ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 919 
 920         final int columnsCount = columns.size();
 921         final int currentPos = columns.indexOf(column);
 922 
 923         int actualNewColumnPos = newColumnPos;
 924 
 925         // Fix for RT-35141: We need to account for hidden columns.
 926         // We keep iterating until we see &#39;requiredVisibleColumns&#39; number of visible columns
 927         final int requiredVisibleColumns = actualNewColumnPos;
 928         int visibleColumnsSeen = 0;
 929         for (int i = 0; i &lt; columnsCount; i++) {
 930             if (visibleColumnsSeen == (requiredVisibleColumns + 1)) {
 931                 break;
 932             }
 933 
 934             if (columns.get(i).isVisible()) {
 935                 visibleColumnsSeen++;
 936             } else {
 937                 actualNewColumnPos++;
 938             }
 939         }
 940         // --- end of RT-35141 fix
 941 
 942         if (actualNewColumnPos &gt;= columnsCount) {
 943             actualNewColumnPos = columnsCount - 1;
 944         } else if (actualNewColumnPos &lt; 0) {
 945             actualNewColumnPos = 0;
 946         }
 947 
 948         if (actualNewColumnPos == currentPos) return;
 949 
 950         List&lt;TableColumnBase&lt;?,?&gt;&gt; tempList = new ArrayList&lt;&gt;(columns);
 951         tempList.remove(column);
 952         tempList.add(actualNewColumnPos, column);
 953 
 954         columns.setAll(tempList);
 955     }
 956 
 957     private ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; getColumns(TableColumnBase column) {
 958         return column.getParentColumn() == null ?
 959                 TableSkinUtils.getColumns(getTableSkin()) :
 960                 column.getParentColumn().getColumns();
 961     }
 962 
 963     private int getIndex(TableColumnBase&lt;?,?&gt; column) {
 964         if (column == null) return -1;
 965 
 966         ObservableList&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns = getColumns(column);
 967 
 968         int index = -1;
 969         for (int i = 0; i &lt; columns.size(); i++) {
 970             TableColumnBase&lt;?,?&gt; _column = columns.get(i);
 971             if (! _column.isVisible()) continue;
 972 
 973             index++;
 974             if (column.equals(_column)) break;
 975         }
 976 
 977         return index;
 978     }
 979 
 980     private void updateColumnIndex() {
 981 //        TableView tv = getTableView();
 982         TableColumnBase tc = getTableColumn();
 983         TableViewSkinBase tableSkin = getTableSkin();
 984         columnIndex = tableSkin == null || tc == null ? -1 :TableSkinUtils.getVisibleLeafIndex(tableSkin,tc);
 985 
 986         // update the pseudo class state regarding whether this is the last
 987         // visible cell (i.e. the right-most).
 988         isLastVisibleColumn = getTableColumn() != null &amp;&amp;
 989                 columnIndex != -1 &amp;&amp;
 990                 columnIndex == TableSkinUtils.getVisibleLeafColumns(tableSkin).size() - 1;
 991         pseudoClassStateChanged(PSEUDO_CLASS_LAST_VISIBLE, isLastVisibleColumn);
 992     }
 993 
 994     private void sortColumn(final boolean addColumn) {
 995         if (! isSortingEnabled()) return;
 996 
 997         // we only allow sorting on the leaf columns and columns
 998         // that actually have comparators defined, and are sortable
 999         if (getTableColumn() == null || getTableColumn().getColumns().size() != 0 || getTableColumn().getComparator() == null || !getTableColumn().isSortable()) return;
1000 //        final int sortPos = getTable().getSortOrder().indexOf(column);
1001 //        final boolean isSortColumn = sortPos != -1;
1002 
1003         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
1004 
1005         // addColumn is true e.g. when the user is holding down Shift
1006         if (addColumn) {
1007             if (!isSortColumn) {
1008                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1009                 sortOrder.add(getTableColumn());
1010             } else if (isAscending(getTableColumn())) {
1011                 setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1012             } else {
1013                 int i = sortOrder.indexOf(getTableColumn());
1014                 if (i != -1) {
1015                     sortOrder.remove(i);
1016                 }
1017             }
1018         } else {
1019             // the user has clicked on a column header - we should add this to
1020             // the TableView sortOrder list if it isn&#39;t already there.
1021             if (isSortColumn &amp;&amp; sortOrder.size() == 1) {
1022                 // the column is already being sorted, and it&#39;s the only column.
1023                 // We therefore move through the 2nd or 3rd states:
1024                 //   1st click: sort ascending
1025                 //   2nd click: sort descending
1026                 //   3rd click: natural sorting (sorting is switched off)
1027                 if (isAscending(getTableColumn())) {
1028                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1029                 } else {
1030                     // remove from sort
1031                     sortOrder.remove(getTableColumn());
1032                 }
1033             } else if (isSortColumn) {
1034                 // the column is already being used to sort, so we toggle its
1035                 // sortAscending property, and also make the column become the
1036                 // primary sort column
1037                 if (isAscending(getTableColumn())) {
1038                     setSortType(getTableColumn(), TableColumn.SortType.DESCENDING);
1039                 } else if (isDescending(getTableColumn())) {
1040                     setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1041                 }
1042 
1043                 // to prevent multiple sorts, we make a copy of the sort order
1044                 // list, moving the column value from the current position to
1045                 // its new position at the front of the list
1046                 List&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrderCopy = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;(sortOrder);
1047                 sortOrderCopy.remove(getTableColumn());
1048                 sortOrderCopy.add(0, getTableColumn());
1049                 sortOrder.setAll(getTableColumn());
1050             } else {
1051                 // add to the sort order, in ascending form
1052                 setSortType(getTableColumn(), TableColumn.SortType.ASCENDING);
1053                 sortOrder.setAll(getTableColumn());
1054             }
1055         }
1056     }
1057 
1058     // Because it is possible that some columns are in the sortOrder list but are
1059     // not themselves sortable, we cannot just do sortOrderList.indexOf(column).
1060     // Therefore, this method does the proper work required of iterating through
1061     // and ignoring non-sortable (and null) columns in the sortOrder list.
1062     private int getSortPosition() {
1063         if (getTableColumn() == null) {
1064             return -1;
1065         }
1066 
1067         final List&lt;TableColumnBase&gt; sortOrder = getVisibleSortOrderColumns();
1068         int pos = 0;
1069         for (int i = 0; i &lt; sortOrder.size(); i++) {
1070             TableColumnBase _tc = sortOrder.get(i);
1071 
1072             if (getTableColumn().equals(_tc)) {
1073                 return pos;
1074             }
1075 
1076             pos++;
1077         }
1078 
1079         return -1;
1080     }
1081 
1082     private List&lt;TableColumnBase&gt; getVisibleSortOrderColumns() {
1083         final ObservableList&lt;TableColumnBase&lt;?,?&gt;&gt; sortOrder = TableSkinUtils.getSortOrder(getTableSkin());
1084 
1085         List&lt;TableColumnBase&gt; visibleSortOrderColumns = new ArrayList&lt;&gt;();
1086         for (int i = 0; i &lt; sortOrder.size(); i++) {
1087             TableColumnBase _tc = sortOrder.get(i);
1088             if (_tc == null || ! _tc.isSortable() || ! _tc.isVisible()) {
1089                 continue;
1090             }
1091 
1092             visibleSortOrderColumns.add(_tc);
1093         }
1094 
1095         return visibleSortOrderColumns;
1096     }
1097 
1098     // as with getSortPosition above, this method iterates through the sortOrder
1099     // list ignoring the null and non-sortable columns, so that we get the correct
1100     // number of columns in the sortOrder list.
1101     private int getVisibleSortOrderColumnCount() {
1102         return getVisibleSortOrderColumns().size();
1103     }
1104 
1105 
1106 
1107     /***************************************************************************
1108      *                                                                         *
1109      * Private Implementation: Column Reordering                               *
1110      *                                                                         *
1111      **************************************************************************/
1112 
1113     // package for testing
1114     void columnReorderingStarted(double dragOffset) {
1115         if (! getTableColumn().isReorderable()) return;
1116 
1117         // Used to ensure the column ghost is positioned relative to where the
1118         // user clicked on the column header
1119         this.dragOffset = dragOffset;
1120 
1121         // Note here that we only allow for reordering of &#39;root&#39; columns
1122         getTableHeaderRow().setReorderingColumn(getTableColumn());
1123         getTableHeaderRow().setReorderingRegion(this);
1124     }
1125 
1126     // package for testing
1127     void columnReordering(double sceneX, double sceneY) {
1128         if (! getTableColumn().isReorderable()) return;
1129 
1130         // this is for handling the column drag to reorder columns.
1131         // It shows a line to indicate where the &#39;drop&#39; will be.
1132 
1133         // indicate that we&#39;ve started dragging so that the dragging
1134         // line overlay is shown
1135         getTableHeaderRow().setReordering(true);
1136 
1137         // Firstly we need to determine where to draw the line.
1138         // Find which column we&#39;re over
1139         TableColumnHeader hoverHeader = null;
1140 
1141         // x represents where the mouse is relative to the parent
1142         // NestedTableColumnHeader
1143         final double x = getParentHeader().sceneToLocal(sceneX, sceneY).getX();
1144 
1145         // calculate where the ghost column header should be
1146         double dragX = getTableSkin().getSkinnable().sceneToLocal(sceneX, sceneY).getX() - dragOffset;
1147         getTableHeaderRow().setDragHeaderX(dragX);
1148 
1149         double startX = 0;
1150         double endX = 0;
1151         double headersWidth = 0;
1152         newColumnPos = 0;
1153         for (TableColumnHeader header : getParentHeader().getColumnHeaders()) {
1154             if (! header.isVisible()) continue;
1155 
1156             double headerWidth = header.prefWidth(-1);
1157             headersWidth += headerWidth;
1158 
1159             startX = header.getBoundsInParent().getMinX();
1160             endX = startX + headerWidth;
1161 
1162             if (x &gt;= startX &amp;&amp; x &lt; endX) {
1163                 hoverHeader = header;
1164                 break;
1165             }
1166             newColumnPos++;
1167         }
1168 
1169         // hoverHeader will be null if the drag occurs outside of the
1170         // tableview. In this case we handle the newColumnPos specially
1171         // and then short-circuit. This results in the drop action
1172         // resulting in the correct result (the column will drop at
1173         // the start or end of the table).
1174         if (hoverHeader == null) {
1175             newColumnPos = x &gt; headersWidth ? (getParentHeader().getColumns().size() - 1) : 0;
1176             return;
1177         }
1178 
1179         // This is the x-axis value midway through hoverHeader. It&#39;s
1180         // used to determine whether the drop should be to the left
1181         // or the right of hoverHeader.
1182         double midPoint = startX + (endX - startX) / 2;
1183         boolean beforeMidPoint = x &lt;= midPoint;
1184 
1185         // Based on where the mouse actually is, we have to shuffle
1186         // where we want the column to end up. This code handles that.
1187         int currentPos = getIndex(getTableColumn());
1188         newColumnPos += newColumnPos &gt; currentPos &amp;&amp; beforeMidPoint ?
1189             -1 : (newColumnPos &lt; currentPos &amp;&amp; !beforeMidPoint ? 1 : 0);
1190 
1191         double lineX = getTableHeaderRow().sceneToLocal(hoverHeader.localToScene(hoverHeader.getBoundsInLocal())).getMinX();
1192         lineX = lineX + ((beforeMidPoint) ? (0) : (hoverHeader.getWidth()));
1193 
1194         if (lineX &gt;= -0.5 &amp;&amp; lineX &lt;= getTableSkin().getSkinnable().getWidth()) {
1195             columnReorderLine.setTranslateX(lineX);
1196 
1197             // then if this is the first event, we set the property to true
1198             // so that the line becomes visible until the drop is completed.
1199             // We also set reordering to true so that the various reordering
1200             // effects become visible (ghost, transparent overlay, etc).
1201             columnReorderLine.setVisible(true);
1202         }
1203 
1204         getTableHeaderRow().setReordering(true);
1205     }
1206 
1207     // package for testing
1208     void columnReorderingComplete() {
1209         if (! getTableColumn().isReorderable()) return;
1210 
1211         // Move col from where it is now to the new position.
1212         moveColumn(getTableColumn(), newColumnPos);
1213 
1214         // cleanup
1215         columnReorderLine.setTranslateX(0.0F);
1216         columnReorderLine.setLayoutX(0.0F);
1217         newColumnPos = 0;
1218 
1219         getTableHeaderRow().setReordering(false);
1220         columnReorderLine.setVisible(false);
1221         getTableHeaderRow().setReorderingColumn(null);
1222         getTableHeaderRow().setReorderingRegion(null);
1223         dragOffset = 0.0F;
1224     }
1225 
1226     double getDragRectHeight() {
1227         return getHeight();
1228     }
1229 
1230     // Used to test whether this column header properly represents the given column.
1231     // In particular, whether it has child column headers for all child columns
1232     boolean represents(TableColumnBase&lt;?, ?&gt; column) {
1233         if (!column.getColumns().isEmpty()) {
1234             // this column has children, but we are in a TableColumnHeader instance,
1235             // so the match is bad.
1236             return false;
1237         }
1238         return column == getTableColumn();
1239     }
1240 
1241 
1242 
1243     /***************************************************************************
1244      *                                                                         *
1245      * Stylesheet Handling                                                     *
1246      *                                                                         *
1247      **************************************************************************/
1248 
1249     private static final PseudoClass PSEUDO_CLASS_LAST_VISIBLE =
1250             PseudoClass.getPseudoClass(&quot;last-visible&quot;);
1251 
1252     /*
1253      * Super-lazy instantiation pattern from Bill Pugh.
1254      */
1255      private static class StyleableProperties {
1256          private static final CssMetaData&lt;TableColumnHeader,Number&gt; SIZE =
1257             new CssMetaData&lt;TableColumnHeader,Number&gt;(&quot;-fx-size&quot;,
1258                  SizeConverter.getInstance(), 20.0) {
1259 
1260             @Override
1261             public boolean isSettable(TableColumnHeader n) {
1262                 return n.size == null || !n.size.isBound();
1263             }
1264 
1265             @Override
1266             public StyleableProperty&lt;Number&gt; getStyleableProperty(TableColumnHeader n) {
1267                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.sizeProperty();
1268             }
1269         };
1270 
1271          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1272          static {
1273 
1274             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1275                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
1276             styleables.add(SIZE);
1277             STYLEABLES = Collections.unmodifiableList(styleables);
1278 
1279          }
1280     }
1281 
1282     /**
1283      * Returns the CssMetaData associated with this class, which may include the
1284      * CssMetaData of its superclasses.
1285      *
1286      * @return the CssMetaData associated with this class, which may include the
1287      * CssMetaData of its superclasses
1288      */
1289     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1290         return StyleableProperties.STYLEABLES;
1291     }
1292 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>