<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/test/javafx/scene/control/skin/TableColumnHeaderTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableColumnHeader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 516             for (int i = 0; i &lt; children.size(); i++) {
 517                 updateAllHeaders(children.get(i));
 518             }
 519         } else {
 520             header.updateSortPosition();
 521         }
 522     }
 523 
 524     private void updateScene() {
 525         // RT-17684: If the TableColumn widths are all currently the default,
 526         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 527         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 528         // number of rows retrieved from a very slow (e.g. remote) data source.
 529         // Obviously, the bigger the value of n, the more likely the default
 530         // width will be suitable for most values in the column
 531         final int n = 30;
 532         if (! autoSizeComplete) {
 533             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 534                 return;
 535             }
<span class="line-modified"> 536             doColumnAutoSize(getTableColumn(), n);</span>
 537             autoSizeComplete = true;
 538         }
 539     }
 540 
 541     void dispose() {
 542         TableViewSkinBase tableSkin = getTableSkin();
 543         if (tableSkin != null) {
 544             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 545             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 546         }
 547 
 548         changeListenerHandler.dispose();
 549     }
 550 
 551     private boolean isSortingEnabled() {
 552         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 553         // to always return true (for now), as we want to support column sorting
 554         // everywhere
 555         return true;
 556     }
</pre>
<hr />
<pre>
 568         setOnMousePressed(mousePressedHandler);
 569         setOnMouseDragged(mouseDraggedHandler);
 570         setOnDragDetected(event -&gt; event.consume());
 571         setOnContextMenuRequested(contextMenuRequestedHandler);
 572         setOnMouseReleased(mouseReleasedHandler);
 573 
 574         // --- label
 575         label = new Label();
 576         label.setText(getTableColumn().getText());
 577         label.setGraphic(getTableColumn().getGraphic());
 578         label.setVisible(getTableColumn().isVisible());
 579 
 580         // ---- container for the sort arrow (which is not supported on embedded
 581         // platforms)
 582         if (isSortingEnabled()) {
 583             // put together the grid
 584             updateSortGrid();
 585         }
 586     }
 587 
<span class="line-modified"> 588     private void doColumnAutoSize(TableColumnBase&lt;?,?&gt; column, int cellsToMeasure) {</span>
<span class="line-modified"> 589         double prefWidth = column.getPrefWidth();</span>
 590 
 591         // if the prefWidth has been set, we do _not_ autosize columns
 592         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 593             resizeColumnToFitContent(column, cellsToMeasure);</span>
 594         }
 595     }
 596 
 597     /**
<span class="line-modified"> 598      * Resizes the given column based on the preferred width of all items contained in it. This can be potentially very</span>
<span class="line-modified"> 599      * expensive if the number of rows is large. Subclass can either call this method or override it (no need to call</span>
<span class="line-modified"> 600      * {@code super()}) to provide their custom algorithm.</span>


 601      *
<span class="line-removed"> 602      * @param tc      the column to resize</span>
 603      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.
<span class="line-modified"> 604      * @since 12</span>
 605      */
<span class="line-modified"> 606     protected void resizeColumnToFitContent(TableColumnBase&lt;?, ?&gt; tc, int maxRows) {</span>

 607         if (!tc.isResizable()) return;
 608 
 609         Object control = this.getTableSkin().getSkinnable();
 610         if (control instanceof TableView) {
 611             resizeColumnToFitContent((TableView)control, (TableColumn)tc, this.getTableSkin(), maxRows);
 612         } else if (control instanceof TreeTableView) {
 613             resizeColumnToFitContent((TreeTableView)control, (TreeTableColumn)tc, this.getTableSkin(), maxRows);
 614         }
 615     }
 616 
 617     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 618         List&lt;?&gt; items = tv.getItems();
 619         if (items == null || items.isEmpty()) return;
 620 
 621         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();
 622         if (cellFactory == null) return;
 623 
 624         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);
 625         if (cell == null) return;
 626 
</pre>
<hr />
<pre>
 655         cell.updateIndex(-1);
 656 
 657         // RT-36855 - take into account the column header text / graphic widths.
 658         // Magic 10 is to allow for sort arrow to appear without text truncation.
 659         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 660         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 661         Node graphic = header.label.getGraphic();
 662         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 663         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 664         maxWidth = Math.max(maxWidth, headerWidth);
 665 
 666         // RT-23486
 667         maxWidth += padding;
 668         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {
 669             if (maxWidth &gt; tc.getMaxWidth()) {
 670                 maxWidth = tc.getMaxWidth();
 671             }
 672 
 673             int size = tc.getColumns().size();
 674             if (size &gt; 0) {
<span class="line-modified"> 675                 resizeColumnToFitContent(tc.getColumns().get(size - 1), maxRows);</span>



 676                 return;
 677             }
 678 
 679             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 680         } else {
 681             TableColumnBaseHelper.setWidth(tc, maxWidth);
 682         }
 683     }
 684 
 685     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 686         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);
 687         if (items == null || items.isEmpty()) return;
 688 
 689         Callback cellFactory = tc.getCellFactory();
 690         if (cellFactory == null) return;
 691 
 692         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);
 693         if (cell == null) return;
 694 
 695         // set this property to tell the TableCell we want to know its actual
</pre>
<hr />
<pre>
 734 
 735         // RT-36855 - take into account the column header text / graphic widths.
 736         // Magic 10 is to allow for sort arrow to appear without text truncation.
 737         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 738         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 739         Node graphic = header.label.getGraphic();
 740         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 741         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 742         maxWidth = Math.max(maxWidth, headerWidth);
 743 
 744         // RT-23486
 745         maxWidth += padding;
 746         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {
 747 
 748             if (maxWidth &gt; tc.getMaxWidth()) {
 749                 maxWidth = tc.getMaxWidth();
 750             }
 751 
 752             int size = tc.getColumns().size();
 753             if (size &gt; 0) {
<span class="line-modified"> 754                 resizeColumnToFitContent(tc.getColumns().get(size - 1), maxRows);</span>



 755                 return;
 756             }
 757 
 758             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 759         } else {
 760             TableColumnBaseHelper.setWidth(tc, maxWidth);
 761         }
 762     }
 763 
 764     private void updateSortPosition() {
 765         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 766         updateSortGrid();
 767     }
 768 
 769     private void updateSortGrid() {
 770         // Fix for RT-14488
 771         if (this instanceof NestedTableColumnHeader) return;
 772 
 773         getChildren().clear();
 774         getChildren().add(label);
</pre>
</td>
<td>
<hr />
<pre>
 516             for (int i = 0; i &lt; children.size(); i++) {
 517                 updateAllHeaders(children.get(i));
 518             }
 519         } else {
 520             header.updateSortPosition();
 521         }
 522     }
 523 
 524     private void updateScene() {
 525         // RT-17684: If the TableColumn widths are all currently the default,
 526         // we attempt to &#39;auto-size&#39; based on the preferred width of the first
 527         // n rows (we can&#39;t do all rows, as that could conceivably be an unlimited
 528         // number of rows retrieved from a very slow (e.g. remote) data source.
 529         // Obviously, the bigger the value of n, the more likely the default
 530         // width will be suitable for most values in the column
 531         final int n = 30;
 532         if (! autoSizeComplete) {
 533             if (getTableColumn() == null || getTableColumn().getWidth() != DEFAULT_COLUMN_WIDTH || getScene() == null) {
 534                 return;
 535             }
<span class="line-modified"> 536             doColumnAutoSize(n);</span>
 537             autoSizeComplete = true;
 538         }
 539     }
 540 
 541     void dispose() {
 542         TableViewSkinBase tableSkin = getTableSkin();
 543         if (tableSkin != null) {
 544             TableSkinUtils.getVisibleLeafColumns(tableSkin).removeListener(weakVisibleLeafColumnsListener);
 545             TableSkinUtils.getSortOrder(tableSkin).removeListener(weakSortOrderListener);
 546         }
 547 
 548         changeListenerHandler.dispose();
 549     }
 550 
 551     private boolean isSortingEnabled() {
 552         // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
 553         // to always return true (for now), as we want to support column sorting
 554         // everywhere
 555         return true;
 556     }
</pre>
<hr />
<pre>
 568         setOnMousePressed(mousePressedHandler);
 569         setOnMouseDragged(mouseDraggedHandler);
 570         setOnDragDetected(event -&gt; event.consume());
 571         setOnContextMenuRequested(contextMenuRequestedHandler);
 572         setOnMouseReleased(mouseReleasedHandler);
 573 
 574         // --- label
 575         label = new Label();
 576         label.setText(getTableColumn().getText());
 577         label.setGraphic(getTableColumn().getGraphic());
 578         label.setVisible(getTableColumn().isVisible());
 579 
 580         // ---- container for the sort arrow (which is not supported on embedded
 581         // platforms)
 582         if (isSortingEnabled()) {
 583             // put together the grid
 584             updateSortGrid();
 585         }
 586     }
 587 
<span class="line-modified"> 588     private void doColumnAutoSize(int cellsToMeasure) {</span>
<span class="line-modified"> 589         double prefWidth = getTableColumn().getPrefWidth();</span>
 590 
 591         // if the prefWidth has been set, we do _not_ autosize columns
 592         if (prefWidth == DEFAULT_COLUMN_WIDTH) {
<span class="line-modified"> 593             resizeColumnToFitContent(cellsToMeasure);</span>
 594         }
 595     }
 596 
 597     /**
<span class="line-modified"> 598      * Resizes this {@code TableColumnHeader}&#39;s column based on content of header and content of cells. This</span>
<span class="line-modified"> 599      * implementation measures the preferred width of the header, the preferred width of the first {@code maxRow} cells</span>
<span class="line-modified"> 600      * and sizes the column to the maximum width of all measured values. Subclass can either call this method or</span>
<span class="line-added"> 601      * override it (no need to call {@code super()}) to provide their custom implementation (exclude headers, exclude</span>
<span class="line-added"> 602      * null content, use min).</span>
 603      *

 604      * @param maxRows the number of rows considered when resizing. If -1 is given, all rows are considered.
<span class="line-modified"> 605      * @since 14</span>
 606      */
<span class="line-modified"> 607     protected void resizeColumnToFitContent(int maxRows) {</span>
<span class="line-added"> 608         TableColumnBase&lt;?, ?&gt; tc = getTableColumn();</span>
 609         if (!tc.isResizable()) return;
 610 
 611         Object control = this.getTableSkin().getSkinnable();
 612         if (control instanceof TableView) {
 613             resizeColumnToFitContent((TableView)control, (TableColumn)tc, this.getTableSkin(), maxRows);
 614         } else if (control instanceof TreeTableView) {
 615             resizeColumnToFitContent((TreeTableView)control, (TreeTableColumn)tc, this.getTableSkin(), maxRows);
 616         }
 617     }
 618 
 619     private &lt;T,S&gt; void resizeColumnToFitContent(TableView&lt;T&gt; tv, TableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 620         List&lt;?&gt; items = tv.getItems();
 621         if (items == null || items.isEmpty()) return;
 622 
 623         Callback/*&lt;TableColumn&lt;T, ?&gt;, TableCell&lt;T,?&gt;&gt;*/ cellFactory = tc.getCellFactory();
 624         if (cellFactory == null) return;
 625 
 626         TableCell&lt;T,?&gt; cell = (TableCell&lt;T, ?&gt;) cellFactory.call(tc);
 627         if (cell == null) return;
 628 
</pre>
<hr />
<pre>
 657         cell.updateIndex(-1);
 658 
 659         // RT-36855 - take into account the column header text / graphic widths.
 660         // Magic 10 is to allow for sort arrow to appear without text truncation.
 661         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 662         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 663         Node graphic = header.label.getGraphic();
 664         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 665         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 666         maxWidth = Math.max(maxWidth, headerWidth);
 667 
 668         // RT-23486
 669         maxWidth += padding;
 670         if (tv.getColumnResizePolicy() == TableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; tv.getWidth() &gt; 0) {
 671             if (maxWidth &gt; tc.getMaxWidth()) {
 672                 maxWidth = tc.getMaxWidth();
 673             }
 674 
 675             int size = tc.getColumns().size();
 676             if (size &gt; 0) {
<span class="line-modified"> 677                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 678                 if (columnHeader != null) {</span>
<span class="line-added"> 679                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 680                 }</span>
 681                 return;
 682             }
 683 
 684             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 685         } else {
 686             TableColumnBaseHelper.setWidth(tc, maxWidth);
 687         }
 688     }
 689 
 690     private &lt;T,S&gt; void resizeColumnToFitContent(TreeTableView&lt;T&gt; ttv, TreeTableColumn&lt;T, S&gt; tc, TableViewSkinBase tableSkin, int maxRows) {
 691         List&lt;?&gt; items = new TreeTableViewBackingList(ttv);
 692         if (items == null || items.isEmpty()) return;
 693 
 694         Callback cellFactory = tc.getCellFactory();
 695         if (cellFactory == null) return;
 696 
 697         TreeTableCell&lt;T,S&gt; cell = (TreeTableCell) cellFactory.call(tc);
 698         if (cell == null) return;
 699 
 700         // set this property to tell the TableCell we want to know its actual
</pre>
<hr />
<pre>
 739 
 740         // RT-36855 - take into account the column header text / graphic widths.
 741         // Magic 10 is to allow for sort arrow to appear without text truncation.
 742         TableColumnHeader header = tableSkin.getTableHeaderRow().getColumnHeaderFor(tc);
 743         double headerTextWidth = Utils.computeTextWidth(header.label.getFont(), tc.getText(), -1);
 744         Node graphic = header.label.getGraphic();
 745         double headerGraphicWidth = graphic == null ? 0 : graphic.prefWidth(-1) + header.label.getGraphicTextGap();
 746         double headerWidth = headerTextWidth + headerGraphicWidth + 10 + header.snappedLeftInset() + header.snappedRightInset();
 747         maxWidth = Math.max(maxWidth, headerWidth);
 748 
 749         // RT-23486
 750         maxWidth += padding;
 751         if (ttv.getColumnResizePolicy() == TreeTableView.CONSTRAINED_RESIZE_POLICY &amp;&amp; ttv.getWidth() &gt; 0) {
 752 
 753             if (maxWidth &gt; tc.getMaxWidth()) {
 754                 maxWidth = tc.getMaxWidth();
 755             }
 756 
 757             int size = tc.getColumns().size();
 758             if (size &gt; 0) {
<span class="line-modified"> 759                 TableColumnHeader columnHeader = getTableHeaderRow().getColumnHeaderFor(tc.getColumns().get(size - 1));</span>
<span class="line-added"> 760                 if (columnHeader != null) {</span>
<span class="line-added"> 761                     columnHeader.resizeColumnToFitContent(maxRows);</span>
<span class="line-added"> 762                 }</span>
 763                 return;
 764             }
 765 
 766             TableSkinUtils.resizeColumn(tableSkin, tc, Math.round(maxWidth - tc.getWidth()));
 767         } else {
 768             TableColumnBaseHelper.setWidth(tc, maxWidth);
 769         }
 770     }
 771 
 772     private void updateSortPosition() {
 773         this.sortPos = ! getTableColumn().isSortable() ? -1 : getSortPosition();
 774         updateSortGrid();
 775     }
 776 
 777     private void updateSortGrid() {
 778         // Fix for RT-14488
 779         if (this instanceof NestedTableColumnHeader) return;
 780 
 781         getChildren().clear();
 782         getChildren().add(label);
</pre>
</td>
</tr>
</table>
<center><a href="NestedTableColumnHeader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/test/javafx/scene/control/skin/TableColumnHeaderTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>