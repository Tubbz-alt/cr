diff a/modules/javafx.base/src/main/java/javafx/collections/FXCollections.java b/modules/javafx.base/src/main/java/javafx/collections/FXCollections.java
--- a/modules/javafx.base/src/main/java/javafx/collections/FXCollections.java
+++ b/modules/javafx.base/src/main/java/javafx/collections/FXCollections.java
@@ -1006,10 +1006,15 @@
         SynchronizedList(List<T> list, Object mutex) {
             this.backingList = list;
             this.mutex = mutex;
         }
 
+        SynchronizedList(List<T> list) {
+            this.backingList = list;
+            this.mutex = this;
+        }
+
         @Override
         public int size() {
             synchronized(mutex) {
                 return backingList.size();
             }
@@ -1195,23 +1200,19 @@
         private ListListenerHelper helper;
 
         private final ObservableList<T> backingList;
         private final ListChangeListener<T> listener;
 
-        SynchronizedObservableList(ObservableList<T> seq, Object mutex) {
-            super(seq, mutex);
+        SynchronizedObservableList(ObservableList<T> seq) {
+            super(seq);
             this.backingList = seq;
             listener = c -> {
                 ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange<T>(SynchronizedObservableList.this, c));
             };
             backingList.addListener(new WeakListChangeListener<T>(listener));
         }
 
-        SynchronizedObservableList(ObservableList<T> seq) {
-            this(seq, new Object());
-        }
-
         @Override
         public boolean addAll(T... elements) {
             synchronized(mutex) {
                 return backingList.addAll(elements);
             }
@@ -1772,11 +1773,12 @@
             this.backingSet = set;
             this.mutex = mutex;
         }
 
         SynchronizedSet(Set<E> set) {
-            this(set, new Object());
+            this.backingSet = set;
+            this.mutex = this;
         }
 
         @Override
         public int size() {
             synchronized(mutex) {
@@ -1888,23 +1890,19 @@
 
         private final ObservableSet<E> backingSet;
         private SetListenerHelper listenerHelper;
         private final SetChangeListener<E> listener;
 
-        SynchronizedObservableSet(ObservableSet<E> set, Object mutex) {
-            super(set, mutex);
+        SynchronizedObservableSet(ObservableSet<E> set) {
+            super(set);
             backingSet = set;
             listener = c -> {
                 SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange<E>(SynchronizedObservableSet.this, c));
             };
             backingSet.addListener(new WeakSetChangeListener<E>(listener));
         }
 
-        SynchronizedObservableSet(ObservableSet<E> set) {
-            this(set, new Object());
-        }
-
         @Override
         public void addListener(InvalidationListener listener) {
             synchronized (mutex) {
                 listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
             }
@@ -2550,17 +2548,13 @@
 
     private static class SynchronizedMap<K, V> implements Map<K, V> {
         final Object mutex;
         private final Map<K, V> backingMap;
 
-        SynchronizedMap(Map<K, V> map, Object mutex) {
-            backingMap = map;
-            this.mutex = mutex;
-        }
-
         SynchronizedMap(Map<K, V> map) {
-            this(map, new Object());
+            backingMap = map;
+            this.mutex = this;
         }
 
         @Override
         public int size() {
             synchronized (mutex) {
@@ -2782,23 +2776,19 @@
 
         private final ObservableMap<K, V> backingMap;
         private MapListenerHelper listenerHelper;
         private final MapChangeListener<K, V> listener;
 
-        SynchronizedObservableMap(ObservableMap<K, V> map, Object mutex) {
-            super(map, mutex);
+        SynchronizedObservableMap(ObservableMap<K, V> map) {
+            super(map);
             backingMap = map;
             listener = c -> {
                 MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange<K, V>(SynchronizedObservableMap.this, c));
             };
             backingMap.addListener(new WeakMapChangeListener<K, V>(listener));
         }
 
-        SynchronizedObservableMap(ObservableMap<K, V> map) {
-            this(map, new Object());
-        }
-
         @Override
         public void addListener(InvalidationListener listener) {
             synchronized (mutex) {
                 listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
             }
diff a/modules/javafx.base/src/test/java/test/javafx/collections/FXCollectionsTest.java b/modules/javafx.base/src/test/java/test/javafx/collections/FXCollectionsTest.java
--- a/modules/javafx.base/src/test/java/test/javafx/collections/FXCollectionsTest.java
+++ b/modules/javafx.base/src/test/java/test/javafx/collections/FXCollectionsTest.java
@@ -27,10 +27,12 @@
 
 import javafx.beans.InvalidationListener;
 import org.junit.Test;
 
 import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
 import javafx.collections.FXCollections;
 import javafx.collections.ListChangeListener;
 import test.javafx.collections.MockSetObserver.Tuple;
 import javafx.collections.ObservableList;
 import javafx.collections.ObservableMap;
@@ -668,10 +670,97 @@
         set.addAll(Arrays.asList("foo6", "foo7"));
         assertTrue(set.containsAll(Arrays.asList("foo", "foo2", "foo3", "foo6", "foo7")));
         assertEquals(5, set.size());
     }
 
+    @Test
+    public void synchronizedMapIterationProtectionTest() {
+        testIterationProtection(FXCollections.synchronizedObservableMap(FXCollections.observableHashMap()), this::putRandomValue, this::copyMap);
+    }
+
+    private void putRandomValue(Map<Integer, Integer> map, Random rnd) {
+        map.put(rnd.nextInt(1000), rnd.nextInt());
+    }
+
+    private void copyMap(Map<Integer, Integer> map) {
+        new HashMap<>(map);
+    }
+
+    @Test
+    public void synchronizedSetIterationProtectionTest() {
+        testIterationProtection(FXCollections.synchronizedObservableSet(FXCollections.observableSet()), this::addRandomValue, this::copySet);
+    }
+
+    private void addRandomValue(Set<Integer> set, Random rnd) {
+        set.add(rnd.nextInt(1000));
+    }
+
+    private void copySet(Set<Integer> set) {
+        new HashSet<>(set);
+    }
+
+    @Test
+    public void synchronizedListIterationProtectionTest() {
+        testIterationProtection(FXCollections.synchronizedObservableList(FXCollections.observableArrayList()), this::modifyList, this::iterateOverList);
+    }
+
+    private void modifyList(List<Integer> list, Random rnd) {
+        if (rnd.nextInt(1000) > list.size()) {
+            list.add(rnd.nextInt(1000));
+        } else {
+            list.remove(rnd.nextInt(list.size()));
+        }
+    }
+
+    private void iterateOverList(List<Integer> list) {
+        Iterator<Integer> it = list.iterator();
+        while (it.hasNext()) {
+            it.next();
+        }
+    }
+
+    public <V> void testIterationProtection(V collection, BiConsumer<V, Random> backgroundChanger, Consumer<V> protectedCode) {
+        CollectionChangeThread<V> thread = new CollectionChangeThread<>(collection, backgroundChanger);
+        thread.start();
+        for (int i = 0; i < 10000; i++) {
+            try {
+                synchronized (collection) {
+                    protectedCode.accept(collection);
+                }
+            } catch (ConcurrentModificationException e) {
+                thread.terminate();
+                fail("ConcurrentModificationException should not be thrown");
+            }
+        }
+        thread.terminate();
+    }
+
+    private static class CollectionChangeThread<V> extends Thread {
+        private boolean shallRun = true;
+        private V collection;
+        private BiConsumer<V, Random> backgroundChanger;
+        private Random rnd = new Random();
+
+        public CollectionChangeThread(V collection, BiConsumer<V, Random> backgroundChanger) {
+            super("FXCollectionsTest.CollectionChangeThread");
+            this.collection = collection;
+            this.backgroundChanger = backgroundChanger;
+        }
+
+        @Override
+        public void run() {
+            while (shallRun) {
+                backgroundChanger.accept(collection, rnd);
+            }
+        }
+
+        public void terminate() {
+            shallRun = false;
+        }
+    }
+
+
     private static class NonSortableObservableList extends AbstractList<String> implements ObservableList<String> {
 
         private List<String> backingList = new ArrayList<String>();
         private Set<ListChangeListener<? super String>> listeners = new HashSet<ListChangeListener<? super String>>();
         private Set<InvalidationListener> invalidationListeners = new HashSet<InvalidationListener>();
