<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/variables.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * variables.c: Implementation of the variable storage and lookup
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  */
  11 
  12 #define IN_LIBXSLT
  13 #include &quot;libxslt.h&quot;
  14 
  15 #include &lt;string.h&gt;
  16 
  17 #include &lt;libxml/xmlmemory.h&gt;
  18 #include &lt;libxml/tree.h&gt;
  19 #include &lt;libxml/valid.h&gt;
  20 #include &lt;libxml/hash.h&gt;
  21 #include &lt;libxml/xmlerror.h&gt;
  22 #include &lt;libxml/xpath.h&gt;
  23 #include &lt;libxml/xpathInternals.h&gt;
  24 #include &lt;libxml/parserInternals.h&gt;
  25 #include &lt;libxml/dict.h&gt;
  26 #include &quot;xslt.h&quot;
  27 #include &quot;xsltInternals.h&quot;
  28 #include &quot;xsltutils.h&quot;
  29 #include &quot;variables.h&quot;
  30 #include &quot;transform.h&quot;
  31 #include &quot;imports.h&quot;
  32 #include &quot;preproc.h&quot;
  33 #include &quot;keys.h&quot;
  34 
  35 #ifdef WITH_XSLT_DEBUG
  36  #define WITH_XSLT_DEBUG_VARIABLE
  37 #endif
  38 
  39 #ifdef XSLT_REFACTORED
  40 const xmlChar *xsltDocFragFake = (const xmlChar *) &quot; fake node libxslt&quot;;
  41 #endif
  42 
  43 static const xmlChar *xsltComputingGlobalVarMarker =
  44  (const xmlChar *) &quot; var/param being computed&quot;;
  45 
  46 #define XSLT_VAR_GLOBAL (1&lt;&lt;0)
  47 #define XSLT_VAR_IN_SELECT (1&lt;&lt;1)
  48 #define XSLT_TCTXT_VARIABLE(c) ((xsltStackElemPtr) (c)-&gt;contextVariable)
  49 
  50 /************************************************************************
  51  *                                  *
  52  *  Result Value Tree (Result Tree Fragment) interfaces         *
  53  *                                  *
  54  ************************************************************************/
  55 /**
  56  * xsltCreateRVT:
  57  * @ctxt:  an XSLT transformation context
  58  *
  59  * Creates a Result Value Tree
  60  * (the XSLT 1.0 term for this is &quot;Result Tree Fragment&quot;)
  61  *
  62  * Returns the result value tree or NULL in case of API or internal errors.
  63  */
  64 xmlDocPtr
  65 xsltCreateRVT(xsltTransformContextPtr ctxt)
  66 {
  67     xmlDocPtr container;
  68 
  69     /*
  70     * Question: Why is this function public?
  71     * Answer: It is called by the EXSLT module.
  72     */
  73     if (ctxt == NULL)
  74     return(NULL);
  75 
  76     /*
  77     * Reuse a RTF from the cache if available.
  78     */
  79     if (ctxt-&gt;cache-&gt;RVT) {
  80     container = ctxt-&gt;cache-&gt;RVT;
  81     ctxt-&gt;cache-&gt;RVT = (xmlDocPtr) container-&gt;next;
  82     /* clear the internal pointers */
  83     container-&gt;next = NULL;
  84     container-&gt;prev = NULL;
  85     if (ctxt-&gt;cache-&gt;nbRVT &gt; 0)
  86         ctxt-&gt;cache-&gt;nbRVT--;
  87 #ifdef XSLT_DEBUG_PROFILE_CACHE
  88     ctxt-&gt;cache-&gt;dbgReusedRVTs++;
  89 #endif
  90     return(container);
  91     }
  92 
  93     container = xmlNewDoc(NULL);
  94     if (container == NULL)
  95     return(NULL);
  96     container-&gt;dict = ctxt-&gt;dict;
  97     xmlDictReference(container-&gt;dict);
  98     XSLT_MARK_RES_TREE_FRAG(container);
  99     container-&gt;doc = container;
 100     container-&gt;parent = NULL;
 101     return(container);
 102 }
 103 
 104 /**
 105  * xsltRegisterTmpRVT:
 106  * @ctxt:  an XSLT transformation context
 107  * @RVT:  a result value tree (Result Tree Fragment)
 108  *
 109  * Registers the result value tree (XSLT 1.0 term: Result Tree Fragment)
 110  * in the garbage collector.
 111  * The fragment will be freed at the exit of the currently
 112  * instantiated xsl:template.
 113  * Obsolete; this function might produce massive memory overhead,
 114  * since the fragment is only freed when the current xsl:template
 115  * exits. Use xsltRegisterLocalRVT() instead.
 116  *
 117  * Returns 0 in case of success and -1 in case of API or internal errors.
 118  */
 119 int
 120 xsltRegisterTmpRVT(xsltTransformContextPtr ctxt, xmlDocPtr RVT)
 121 {
 122     if ((ctxt == NULL) || (RVT == NULL))
 123     return(-1);
 124 
 125     RVT-&gt;prev = NULL;
 126     RVT-&gt;psvi = XSLT_RVT_LOCAL;
 127 
 128     /*
 129     * We&#39;ll restrict the lifetime of user-created fragments
 130     * insinde an xsl:variable and xsl:param to the lifetime of the
 131     * var/param itself.
 132     */
 133     if (ctxt-&gt;contextVariable != NULL) {
 134     RVT-&gt;next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)-&gt;fragment;
 135     XSLT_TCTXT_VARIABLE(ctxt)-&gt;fragment = RVT;
 136     return(0);
 137     }
 138 
 139     RVT-&gt;next = (xmlNodePtr) ctxt-&gt;tmpRVT;
 140     if (ctxt-&gt;tmpRVT != NULL)
 141     ctxt-&gt;tmpRVT-&gt;prev = (xmlNodePtr) RVT;
 142     ctxt-&gt;tmpRVT = RVT;
 143     return(0);
 144 }
 145 
 146 /**
 147  * xsltRegisterLocalRVT:
 148  * @ctxt:  an XSLT transformation context
 149  * @RVT:  a result value tree (Result Tree Fragment; xmlDocPtr)
 150  *
 151  * Registers a result value tree (XSLT 1.0 term: Result Tree Fragment)
 152  * in the RVT garbage collector.
 153  * The fragment will be freed when the instruction which created the
 154  * fragment exits.
 155  *
 156  * Returns 0 in case of success and -1 in case of API or internal errors.
 157  */
 158 int
 159 xsltRegisterLocalRVT(xsltTransformContextPtr ctxt,
 160              xmlDocPtr RVT)
 161 {
 162     if ((ctxt == NULL) || (RVT == NULL))
 163     return(-1);
 164 
 165     RVT-&gt;prev = NULL;
 166     RVT-&gt;psvi = XSLT_RVT_LOCAL;
 167 
 168     /*
 169     * When evaluating &quot;select&quot; expressions of xsl:variable
 170     * and xsl:param, we need to bind newly created tree fragments
 171     * to the variable itself; otherwise the fragment will be
 172     * freed before we leave the scope of a var.
 173     */
 174     if ((ctxt-&gt;contextVariable != NULL) &amp;&amp;
 175     (XSLT_TCTXT_VARIABLE(ctxt)-&gt;flags &amp; XSLT_VAR_IN_SELECT))
 176     {
 177     RVT-&gt;next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)-&gt;fragment;
 178     XSLT_TCTXT_VARIABLE(ctxt)-&gt;fragment = RVT;
 179     return(0);
 180     }
 181     /*
 182     * Store the fragment in the scope of the current instruction.
 183     * If not reference by a returning instruction (like EXSLT&#39;s function),
 184     * then this fragment will be freed, when the instruction exits.
 185     */
 186     RVT-&gt;next = (xmlNodePtr) ctxt-&gt;localRVT;
 187     if (ctxt-&gt;localRVT != NULL)
 188     ctxt-&gt;localRVT-&gt;prev = (xmlNodePtr) RVT;
 189     ctxt-&gt;localRVT = RVT;
 190     return(0);
 191 }
 192 
 193 /**
 194  * xsltExtensionInstructionResultFinalize:
 195  * @ctxt:  an XSLT transformation context
 196  *
 197  * Finalizes the data (e.g. result tree fragments) created
 198  * within a value-returning process (e.g. EXSLT&#39;s function).
 199  * Tree fragments marked as being returned by a function are
 200  * set to normal state, which means that the fragment garbage
 201  * collector will free them after the function-calling process exits.
 202  *
 203  * Returns 0 in case of success and -1 in case of API or internal errors.
 204  *
 205  * This function is unsupported in newer releases of libxslt.
 206  */
 207 int
 208 xsltExtensionInstructionResultFinalize(xsltTransformContextPtr ctxt)
 209 {
 210     xmlGenericError(xmlGenericErrorContext,
 211             &quot;xsltExtensionInstructionResultFinalize is unsupported &quot;
 212             &quot;in this release of libxslt.\n&quot;);
 213     return(-1);
 214 }
 215 
 216 /**
 217  * xsltExtensionInstructionResultRegister:
 218  * @ctxt: an XSLT transformation context
 219  * @obj: an XPath object to be inspected for result tree fragments
 220  *
 221  * Marks the result of a value-returning extension instruction
 222  * in order to avoid it being garbage collected before the
 223  * extension instruction exits.
 224  * Note that one still has to additionally register any newly created
 225  * tree fragments (via xsltCreateRVT()) with xsltRegisterLocalRVT().
 226  *
 227  * Returns 0 in case of success and -1 in case of error.
 228  *
 229  * It isn&#39;t necessary to call this function in newer releases of
 230  * libxslt.
 231  */
 232 int
 233 xsltExtensionInstructionResultRegister(xsltTransformContextPtr ctxt,
 234                        xmlXPathObjectPtr obj)
 235 {
 236     return(0);
 237 }
 238 
 239 /**
 240  * xsltFlagRVTs:
 241  * @ctxt: an XSLT transformation context
 242  * @obj: an XPath object to be inspected for result tree fragments
 243  * @val: the flag value
 244  *
 245  * Updates ownership information of RVTs in @obj according to @val.
 246  *
 247  * @val = XSLT_RVT_FUNC_RESULT for the result of an extension function, so its
 248  *        RVTs won&#39;t be destroyed after leaving the returning scope.
 249  * @val = XSLT_RVT_LOCAL for the result of an extension function to reset
 250  *        the state of its RVTs after it was returned to a new scope.
 251  * @val = XSLT_RVT_GLOBAL for parts of global variables.
 252  *
 253  * Returns 0 in case of success and -1 in case of error.
 254  */
 255 int
 256 xsltFlagRVTs(xsltTransformContextPtr ctxt, xmlXPathObjectPtr obj, void *val) {
 257     int i;
 258     xmlNodePtr cur;
 259     xmlDocPtr doc;
 260 
 261     if ((ctxt == NULL) || (obj == NULL))
 262     return(-1);
 263 
 264     /*
 265     * OPTIMIZE TODO: If no local variables/params and no local tree
 266     * fragments were created, then we don&#39;t need to analyse the XPath
 267     * objects for tree fragments.
 268     */
 269 
 270     if ((obj-&gt;type != XPATH_NODESET) &amp;&amp; (obj-&gt;type != XPATH_XSLT_TREE))
 271     return(0);
 272     if ((obj-&gt;nodesetval == NULL) || (obj-&gt;nodesetval-&gt;nodeNr == 0))
 273     return(0);
 274 
 275     for (i = 0; i &lt; obj-&gt;nodesetval-&gt;nodeNr; i++) {
 276     cur = obj-&gt;nodesetval-&gt;nodeTab[i];
 277     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 278         /*
 279         * The XPath module sets the owner element of a ns-node on
 280         * the ns-&gt;next field.
 281         */
 282         if ((((xmlNsPtr) cur)-&gt;next != NULL) &amp;&amp;
 283         (((xmlNsPtr) cur)-&gt;next-&gt;type == XML_ELEMENT_NODE))
 284         {
 285         cur = (xmlNodePtr) ((xmlNsPtr) cur)-&gt;next;
 286         doc = cur-&gt;doc;
 287         } else {
 288         xsltTransformError(ctxt, NULL, ctxt-&gt;inst,
 289             &quot;Internal error in xsltFlagRVTs(): &quot;
 290             &quot;Cannot retrieve the doc of a namespace node.\n&quot;);
 291         return(-1);
 292         }
 293     } else {
 294         doc = cur-&gt;doc;
 295     }
 296     if (doc == NULL) {
 297         xsltTransformError(ctxt, NULL, ctxt-&gt;inst,
 298         &quot;Internal error in xsltFlagRVTs(): &quot;
 299         &quot;Cannot retrieve the doc of a node.\n&quot;);
 300         return(-1);
 301     }
 302     if (doc-&gt;name &amp;&amp; (doc-&gt;name[0] == &#39; &#39;) &amp;&amp;
 303             doc-&gt;psvi != XSLT_RVT_GLOBAL) {
 304         /*
 305         * This is a result tree fragment.
 306         * We store ownership information in the @psvi field.
 307         * TODO: How do we know if this is a doc acquired via the
 308         *  document() function?
 309         */
 310 #ifdef WITH_XSLT_DEBUG_VARIABLE
 311             XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
 312                 &quot;Flagging RVT %p: %p -&gt; %p\n&quot;, doc, doc-&gt;psvi, val));
 313 #endif
 314 
 315             if (val == XSLT_RVT_LOCAL) {
 316                 if (doc-&gt;psvi == XSLT_RVT_FUNC_RESULT)
 317                     doc-&gt;psvi = XSLT_RVT_LOCAL;
 318             } else if (val == XSLT_RVT_GLOBAL) {
 319                 if (doc-&gt;psvi != XSLT_RVT_LOCAL) {
 320             xmlGenericError(xmlGenericErrorContext,
 321                             &quot;xsltFlagRVTs: Invalid transition %p =&gt; GLOBAL\n&quot;,
 322                             doc-&gt;psvi);
 323                     doc-&gt;psvi = XSLT_RVT_GLOBAL;
 324                     return(-1);
 325                 }
 326 
 327                 /* Will be registered as persistant in xsltReleaseLocalRVTs. */
 328                 doc-&gt;psvi = XSLT_RVT_GLOBAL;
 329             } else if (val == XSLT_RVT_FUNC_RESULT) {
 330             doc-&gt;psvi = val;
 331             }
 332     }
 333     }
 334 
 335     return(0);
 336 }
 337 
 338 /**
 339  * xsltReleaseRVT:
 340  * @ctxt:  an XSLT transformation context
 341  * @RVT:  a result value tree (Result Tree Fragment)
 342  *
 343  * Either frees the RVT (which is an xmlDoc) or stores
 344  * it in the context&#39;s cache for later reuse.
 345  */
 346 void
 347 xsltReleaseRVT(xsltTransformContextPtr ctxt, xmlDocPtr RVT)
 348 {
 349     if (RVT == NULL)
 350     return;
 351 
 352     if (ctxt &amp;&amp; (ctxt-&gt;cache-&gt;nbRVT &lt; 40)) {
 353     /*
 354     * Store the Result Tree Fragment.
 355     * Free the document info.
 356     */
 357     if (RVT-&gt;_private != NULL) {
 358         xsltFreeDocumentKeys((xsltDocumentPtr) RVT-&gt;_private);
 359         xmlFree(RVT-&gt;_private);
 360         RVT-&gt;_private = NULL;
 361     }
 362     /*
 363     * Clear the document tree.
 364     * REVISIT TODO: Do we expect ID/IDREF tables to be existent?
 365     */
 366     if (RVT-&gt;children != NULL) {
 367         xmlFreeNodeList(RVT-&gt;children);
 368         RVT-&gt;children = NULL;
 369         RVT-&gt;last = NULL;
 370     }
 371     if (RVT-&gt;ids != NULL) {
 372         xmlFreeIDTable((xmlIDTablePtr) RVT-&gt;ids);
 373         RVT-&gt;ids = NULL;
 374     }
 375     if (RVT-&gt;refs != NULL) {
 376         xmlFreeRefTable((xmlRefTablePtr) RVT-&gt;refs);
 377         RVT-&gt;refs = NULL;
 378     }
 379 
 380     /*
 381     * Reset the ownership information.
 382     */
 383     RVT-&gt;psvi = NULL;
 384 
 385     RVT-&gt;next = (xmlNodePtr) ctxt-&gt;cache-&gt;RVT;
 386     ctxt-&gt;cache-&gt;RVT = RVT;
 387 
 388     ctxt-&gt;cache-&gt;nbRVT++;
 389 
 390 #ifdef XSLT_DEBUG_PROFILE_CACHE
 391     ctxt-&gt;cache-&gt;dbgCachedRVTs++;
 392 #endif
 393     return;
 394     }
 395     /*
 396     * Free it.
 397     */
 398     if (RVT-&gt;_private != NULL) {
 399     xsltFreeDocumentKeys((xsltDocumentPtr) RVT-&gt;_private);
 400     xmlFree(RVT-&gt;_private);
 401     }
 402     xmlFreeDoc(RVT);
 403 }
 404 
 405 /**
 406  * xsltRegisterPersistRVT:
 407  * @ctxt:  an XSLT transformation context
 408  * @RVT:  a result value tree (Result Tree Fragment)
 409  *
 410  * Register the result value tree (XSLT 1.0 term: Result Tree Fragment)
 411  * in the fragment garbage collector.
 412  * The fragment will be freed when the transformation context is
 413  * freed.
 414  *
 415  * Returns 0 in case of success and -1 in case of error.
 416  */
 417 int
 418 xsltRegisterPersistRVT(xsltTransformContextPtr ctxt, xmlDocPtr RVT)
 419 {
 420     if ((ctxt == NULL) || (RVT == NULL)) return(-1);
 421 
 422     RVT-&gt;psvi = XSLT_RVT_GLOBAL;
 423     RVT-&gt;prev = NULL;
 424     RVT-&gt;next = (xmlNodePtr) ctxt-&gt;persistRVT;
 425     if (ctxt-&gt;persistRVT != NULL)
 426     ctxt-&gt;persistRVT-&gt;prev = (xmlNodePtr) RVT;
 427     ctxt-&gt;persistRVT = RVT;
 428     return(0);
 429 }
 430 
 431 /**
 432  * xsltFreeRVTs:
 433  * @ctxt:  an XSLT transformation context
 434  *
 435  * Frees all registered result value trees (Result Tree Fragments)
 436  * of the transformation. Internal function; should not be called
 437  * by user-code.
 438  */
 439 void
 440 xsltFreeRVTs(xsltTransformContextPtr ctxt)
 441 {
 442     xmlDocPtr cur, next;
 443 
 444     if (ctxt == NULL)
 445     return;
 446     /*
 447     * Local fragments.
 448     */
 449     cur = ctxt-&gt;localRVT;
 450     while (cur != NULL) {
 451         next = (xmlDocPtr) cur-&gt;next;
 452     if (cur-&gt;_private != NULL) {
 453         xsltFreeDocumentKeys(cur-&gt;_private);
 454         xmlFree(cur-&gt;_private);
 455     }
 456     xmlFreeDoc(cur);
 457     cur = next;
 458     }
 459     ctxt-&gt;localRVT = NULL;
 460     /*
 461     * User-created per-template fragments.
 462     */
 463     cur = ctxt-&gt;tmpRVT;
 464     while (cur != NULL) {
 465         next = (xmlDocPtr) cur-&gt;next;
 466     if (cur-&gt;_private != NULL) {
 467         xsltFreeDocumentKeys(cur-&gt;_private);
 468         xmlFree(cur-&gt;_private);
 469     }
 470     xmlFreeDoc(cur);
 471     cur = next;
 472     }
 473     ctxt-&gt;tmpRVT = NULL;
 474     /*
 475     * Global fragments.
 476     */
 477     cur = ctxt-&gt;persistRVT;
 478     while (cur != NULL) {
 479         next = (xmlDocPtr) cur-&gt;next;
 480     if (cur-&gt;_private != NULL) {
 481         xsltFreeDocumentKeys(cur-&gt;_private);
 482         xmlFree(cur-&gt;_private);
 483     }
 484     xmlFreeDoc(cur);
 485     cur = next;
 486     }
 487     ctxt-&gt;persistRVT = NULL;
 488 }
 489 
 490 /************************************************************************
 491  *                                  *
 492  *          Module interfaces               *
 493  *                                  *
 494  ************************************************************************/
 495 
 496 /**
 497  * xsltNewStackElem:
 498  *
 499  * Create a new XSLT ParserContext
 500  *
 501  * Returns the newly allocated xsltParserStackElem or NULL in case of error
 502  */
 503 static xsltStackElemPtr
 504 xsltNewStackElem(xsltTransformContextPtr ctxt)
 505 {
 506     xsltStackElemPtr ret;
 507     /*
 508     * Reuse a stack item from the cache if available.
 509     */
 510     if (ctxt &amp;&amp; ctxt-&gt;cache-&gt;stackItems) {
 511     ret = ctxt-&gt;cache-&gt;stackItems;
 512     ctxt-&gt;cache-&gt;stackItems = ret-&gt;next;
 513     ret-&gt;next = NULL;
 514     ctxt-&gt;cache-&gt;nbStackItems--;
 515 #ifdef XSLT_DEBUG_PROFILE_CACHE
 516     ctxt-&gt;cache-&gt;dbgReusedVars++;
 517 #endif
 518     return(ret);
 519     }
 520     ret = (xsltStackElemPtr) xmlMalloc(sizeof(xsltStackElem));
 521     if (ret == NULL) {
 522     xsltTransformError(NULL, NULL, NULL,
 523         &quot;xsltNewStackElem : malloc failed\n&quot;);
 524     return(NULL);
 525     }
 526     memset(ret, 0, sizeof(xsltStackElem));
 527     ret-&gt;context = ctxt;
 528     return(ret);
 529 }
 530 
 531 /**
 532  * xsltCopyStackElem:
 533  * @elem:  an XSLT stack element
 534  *
 535  * Makes a copy of the stack element
 536  *
 537  * Returns the copy of NULL
 538  */
 539 static xsltStackElemPtr
 540 xsltCopyStackElem(xsltStackElemPtr elem) {
 541     xsltStackElemPtr cur;
 542 
 543     cur = (xsltStackElemPtr) xmlMalloc(sizeof(xsltStackElem));
 544     if (cur == NULL) {
 545     xsltTransformError(NULL, NULL, NULL,
 546         &quot;xsltCopyStackElem : malloc failed\n&quot;);
 547     return(NULL);
 548     }
 549     memset(cur, 0, sizeof(xsltStackElem));
 550     cur-&gt;context = elem-&gt;context;
 551     cur-&gt;name = elem-&gt;name;
 552     cur-&gt;nameURI = elem-&gt;nameURI;
 553     cur-&gt;select = elem-&gt;select;
 554     cur-&gt;tree = elem-&gt;tree;
 555     cur-&gt;comp = elem-&gt;comp;
 556     return(cur);
 557 }
 558 
 559 /**
 560  * xsltFreeStackElem:
 561  * @elem:  an XSLT stack element
 562  *
 563  * Free up the memory allocated by @elem
 564  */
 565 static void
 566 xsltFreeStackElem(xsltStackElemPtr elem) {
 567     if (elem == NULL)
 568     return;
 569     if (elem-&gt;value != NULL)
 570     xmlXPathFreeObject(elem-&gt;value);
 571     /*
 572     * Release the list of temporary Result Tree Fragments.
 573     */
 574     if (elem-&gt;context) {
 575     xmlDocPtr cur;
 576 
 577     while (elem-&gt;fragment != NULL) {
 578         cur = elem-&gt;fragment;
 579         elem-&gt;fragment = (xmlDocPtr) cur-&gt;next;
 580 
 581             if (cur-&gt;psvi == XSLT_RVT_LOCAL) {
 582         xsltReleaseRVT(elem-&gt;context, cur);
 583             } else if (cur-&gt;psvi == XSLT_RVT_FUNC_RESULT) {
 584                 xsltRegisterLocalRVT(elem-&gt;context, cur);
 585                 cur-&gt;psvi = XSLT_RVT_FUNC_RESULT;
 586             } else {
 587                 xmlGenericError(xmlGenericErrorContext,
 588                         &quot;xsltFreeStackElem: Unexpected RVT flag %p\n&quot;,
 589                         cur-&gt;psvi);
 590             }
 591     }
 592     }
 593     /*
 594     * Cache or free the variable structure.
 595     */
 596     if (elem-&gt;context &amp;&amp; (elem-&gt;context-&gt;cache-&gt;nbStackItems &lt; 50)) {
 597     /*
 598     * Store the item in the cache.
 599     */
 600     xsltTransformContextPtr ctxt = elem-&gt;context;
 601     memset(elem, 0, sizeof(xsltStackElem));
 602     elem-&gt;context = ctxt;
 603     elem-&gt;next = ctxt-&gt;cache-&gt;stackItems;
 604     ctxt-&gt;cache-&gt;stackItems = elem;
 605     ctxt-&gt;cache-&gt;nbStackItems++;
 606 #ifdef XSLT_DEBUG_PROFILE_CACHE
 607     ctxt-&gt;cache-&gt;dbgCachedVars++;
 608 #endif
 609     return;
 610     }
 611     xmlFree(elem);
 612 }
 613 
 614 static void
 615 xsltFreeStackElemEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
 616     xsltFreeStackElem((xsltStackElemPtr) payload);
 617 }
 618 
 619 
 620 /**
 621  * xsltFreeStackElemList:
 622  * @elem:  an XSLT stack element
 623  *
 624  * Free up the memory allocated by @elem
 625  */
 626 void
 627 xsltFreeStackElemList(xsltStackElemPtr elem) {
 628     xsltStackElemPtr next;
 629 
 630     while (elem != NULL) {
 631     next = elem-&gt;next;
 632     xsltFreeStackElem(elem);
 633     elem = next;
 634     }
 635 }
 636 
 637 /**
 638  * xsltStackLookup:
 639  * @ctxt:  an XSLT transformation context
 640  * @name:  the local part of the name
 641  * @nameURI:  the URI part of the name
 642  *
 643  * Locate an element in the stack based on its name.
 644  */
 645 #if 0 /* TODO: Those seem to have been used for debugging. */
 646 static int stack_addr = 0;
 647 static int stack_cmp = 0;
 648 #endif
 649 
 650 static xsltStackElemPtr
 651 xsltStackLookup(xsltTransformContextPtr ctxt, const xmlChar *name,
 652             const xmlChar *nameURI) {
 653     int i;
 654     xsltStackElemPtr cur;
 655 
 656     if ((ctxt == NULL) || (name == NULL) || (ctxt-&gt;varsNr == 0))
 657     return(NULL);
 658 
 659     /*
 660      * Do the lookup from the top of the stack, but
 661      * don&#39;t use params being computed in a call-param
 662      * First lookup expects the variable name and URI to
 663      * come from the disctionnary and hence pointer comparison.
 664      */
 665     for (i = ctxt-&gt;varsNr; i &gt; ctxt-&gt;varsBase; i--) {
 666     cur = ctxt-&gt;varsTab[i-1];
 667     while (cur != NULL) {
 668         if ((cur-&gt;name == name) &amp;&amp; (cur-&gt;nameURI == nameURI)) {
 669 #if 0
 670         stack_addr++;
 671 #endif
 672         return(cur);
 673         }
 674         cur = cur-&gt;next;
 675     }
 676     }
 677 
 678     /*
 679      * Redo the lookup with interned string compares
 680      * to avoid string compares.
 681      */
 682     name = xmlDictLookup(ctxt-&gt;dict, name, -1);
 683     if (nameURI != NULL)
 684         nameURI = xmlDictLookup(ctxt-&gt;dict, nameURI, -1);
 685 
 686     for (i = ctxt-&gt;varsNr; i &gt; ctxt-&gt;varsBase; i--) {
 687     cur = ctxt-&gt;varsTab[i-1];
 688     while (cur != NULL) {
 689         if ((cur-&gt;name == name) &amp;&amp; (cur-&gt;nameURI == nameURI)) {
 690 #if 0
 691         stack_cmp++;
 692 #endif
 693         return(cur);
 694         }
 695         cur = cur-&gt;next;
 696     }
 697     }
 698 
 699     return(NULL);
 700 }
 701 
 702 #ifdef XSLT_REFACTORED
 703 #else
 704 
 705 /**
 706  * xsltCheckStackElem:
 707  * @ctxt:  xn XSLT transformation context
 708  * @name:  the variable name
 709  * @nameURI:  the variable namespace URI
 710  *
 711  * Checks whether a variable or param is already defined.
 712  *
 713  * URGENT TODO: Checks for redefinition of vars/params should be
 714  *  done only at compilation time.
 715  *
 716  * Returns 1 if variable is present, 2 if param is present, 3 if this
 717  *         is an inherited param, 0 if not found, -1 in case of failure.
 718  */
 719 static int
 720 xsltCheckStackElem(xsltTransformContextPtr ctxt, const xmlChar *name,
 721                const xmlChar *nameURI) {
 722     xsltStackElemPtr cur;
 723 
 724     if ((ctxt == NULL) || (name == NULL))
 725     return(-1);
 726 
 727     cur = xsltStackLookup(ctxt, name, nameURI);
 728     if (cur == NULL)
 729         return(0);
 730     if (cur-&gt;comp != NULL) {
 731         if (cur-&gt;comp-&gt;type == XSLT_FUNC_WITHPARAM)
 732         return(3);
 733     else if (cur-&gt;comp-&gt;type == XSLT_FUNC_PARAM)
 734         return(2);
 735     }
 736 
 737     return(1);
 738 }
 739 
 740 #endif /* XSLT_REFACTORED */
 741 
 742 /**
 743  * xsltAddStackElem:
 744  * @ctxt:  xn XSLT transformation context
 745  * @elem:  a stack element
 746  *
 747  * Push an element (or list) onto the stack.
 748  * In case of a list, each member will be pushed into
 749  * a seperate slot; i.e. there&#39;s always 1 stack entry for
 750  * 1 stack element.
 751  *
 752  * Returns 0 in case of success, -1 in case of failure.
 753  */
 754 static int
 755 xsltAddStackElem(xsltTransformContextPtr ctxt, xsltStackElemPtr elem)
 756 {
 757     if ((ctxt == NULL) || (elem == NULL))
 758     return(-1);
 759 
 760     do {
 761     if (ctxt-&gt;varsMax == 0) {
 762         ctxt-&gt;varsMax = 10;
 763         ctxt-&gt;varsTab =
 764         (xsltStackElemPtr *) xmlMalloc(ctxt-&gt;varsMax *
 765         sizeof(ctxt-&gt;varsTab[0]));
 766         if (ctxt-&gt;varsTab == NULL) {
 767         xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 768         return (-1);
 769         }
 770     }
 771     if (ctxt-&gt;varsNr &gt;= ctxt-&gt;varsMax) {
 772         ctxt-&gt;varsMax *= 2;
 773         ctxt-&gt;varsTab =
 774         (xsltStackElemPtr *) xmlRealloc(ctxt-&gt;varsTab,
 775         ctxt-&gt;varsMax *
 776         sizeof(ctxt-&gt;varsTab[0]));
 777         if (ctxt-&gt;varsTab == NULL) {
 778         xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 779         return (-1);
 780         }
 781     }
 782     ctxt-&gt;varsTab[ctxt-&gt;varsNr++] = elem;
 783     ctxt-&gt;vars = elem;
 784 
 785     elem = elem-&gt;next;
 786     } while (elem != NULL);
 787 
 788     return(0);
 789 }
 790 
 791 /**
 792  * xsltAddStackElemList:
 793  * @ctxt:  xn XSLT transformation context
 794  * @elems:  a stack element list
 795  *
 796  * Push an element list onto the stack.
 797  *
 798  * Returns 0 in case of success, -1 in case of failure.
 799  */
 800 int
 801 xsltAddStackElemList(xsltTransformContextPtr ctxt, xsltStackElemPtr elems)
 802 {
 803     return(xsltAddStackElem(ctxt, elems));
 804 }
 805 
 806 /************************************************************************
 807  *                                  *
 808  *          Module interfaces               *
 809  *                                  *
 810  ************************************************************************/
 811 
 812 /**
 813  * xsltEvalVariable:
 814  * @ctxt:  the XSLT transformation context
 815  * @variable:  the variable or parameter item
 816  * @comp: the compiled XSLT instruction
 817  *
 818  * Evaluate a variable value.
 819  *
 820  * Returns the XPath Object value or NULL in case of error
 821  */
 822 static xmlXPathObjectPtr
 823 xsltEvalVariable(xsltTransformContextPtr ctxt, xsltStackElemPtr variable,
 824              xsltStylePreCompPtr castedComp)
 825 {
 826 #ifdef XSLT_REFACTORED
 827     xsltStyleItemVariablePtr comp =
 828     (xsltStyleItemVariablePtr) castedComp;
 829 #else
 830     xsltStylePreCompPtr comp = castedComp;
 831 #endif
 832     xmlXPathObjectPtr result = NULL;
 833     xmlNodePtr oldInst;
 834 
 835     if ((ctxt == NULL) || (variable == NULL))
 836     return(NULL);
 837 
 838     /*
 839     * A variable or parameter are evaluated on demand; thus the
 840     * context (of XSLT and XPath) need to be temporarily adjusted and
 841     * restored on exit.
 842     */
 843     oldInst = ctxt-&gt;inst;
 844 
 845 #ifdef WITH_XSLT_DEBUG_VARIABLE
 846     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
 847     &quot;Evaluating variable &#39;%s&#39;\n&quot;, variable-&gt;name));
 848 #endif
 849     if (variable-&gt;select != NULL) {
 850     xmlXPathCompExprPtr xpExpr = NULL;
 851     xmlDocPtr oldXPDoc;
 852     xmlNodePtr oldXPContextNode;
 853     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
 854     xmlNsPtr *oldXPNamespaces;
 855     xmlXPathContextPtr xpctxt = ctxt-&gt;xpathCtxt;
 856     xsltStackElemPtr oldVar = ctxt-&gt;contextVariable;
 857 
 858     if ((comp != NULL) &amp;&amp; (comp-&gt;comp != NULL)) {
 859         xpExpr = comp-&gt;comp;
 860     } else {
 861         xpExpr = xmlXPathCompile(variable-&gt;select);
 862     }
 863     if (xpExpr == NULL)
 864         return(NULL);
 865     /*
 866     * Save context states.
 867     */
 868     oldXPDoc = xpctxt-&gt;doc;
 869     oldXPContextNode = xpctxt-&gt;node;
 870     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
 871     oldXPContextSize = xpctxt-&gt;contextSize;
 872     oldXPNamespaces = xpctxt-&gt;namespaces;
 873     oldXPNsNr = xpctxt-&gt;nsNr;
 874 
 875     xpctxt-&gt;node = ctxt-&gt;node;
 876     /*
 877     * OPTIMIZE TODO: Lame try to set the context doc.
 878     *   Get rid of this somehow in xpath.c.
 879     */
 880     if ((ctxt-&gt;node-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;
 881         ctxt-&gt;node-&gt;doc)
 882         xpctxt-&gt;doc = ctxt-&gt;node-&gt;doc;
 883     /*
 884     * BUG TODO: The proximity position and the context size will
 885     *  potentially be wrong.
 886     *  Example:
 887     *  &lt;xsl:template select=&quot;foo&quot;&gt;
 888     *    &lt;xsl:variable name=&quot;pos&quot; select=&quot;position()&quot;/&gt;
 889     *    &lt;xsl:for-each select=&quot;bar&quot;&gt;
 890     *      &lt;xsl:value-of select=&quot;$pos&quot;/&gt;
 891     *    &lt;/xsl:for-each&gt;
 892     *  &lt;/xsl:template&gt;
 893     *  Here the proximity position and context size are changed
 894     *  to the context of &lt;xsl:for-each select=&quot;bar&quot;&gt;, but
 895     *  the variable needs to be evaluated in the context of
 896     *  &lt;xsl:template select=&quot;foo&quot;&gt;.
 897     */
 898     if (comp != NULL) {
 899 
 900 #ifdef XSLT_REFACTORED
 901         if (comp-&gt;inScopeNs != NULL) {
 902         xpctxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
 903         xpctxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
 904         } else {
 905         xpctxt-&gt;namespaces = NULL;
 906         xpctxt-&gt;nsNr = 0;
 907         }
 908 #else
 909         xpctxt-&gt;namespaces = comp-&gt;nsList;
 910         xpctxt-&gt;nsNr = comp-&gt;nsNr;
 911 #endif
 912     } else {
 913         xpctxt-&gt;namespaces = NULL;
 914         xpctxt-&gt;nsNr = 0;
 915     }
 916 
 917     /*
 918     * We need to mark that we are &quot;selecting&quot; a var&#39;s value;
 919     * if any tree fragments are created inside the expression,
 920     * then those need to be stored inside the variable; otherwise
 921     * we&#39;ll eventually free still referenced fragments, before
 922     * we leave the scope of the variable.
 923     */
 924     ctxt-&gt;contextVariable = variable;
 925     variable-&gt;flags |= XSLT_VAR_IN_SELECT;
 926 
 927     result = xmlXPathCompiledEval(xpExpr, xpctxt);
 928 
 929     variable-&gt;flags ^= XSLT_VAR_IN_SELECT;
 930     /*
 931     * Restore Context states.
 932     */
 933     ctxt-&gt;contextVariable = oldVar;
 934 
 935     xpctxt-&gt;doc = oldXPDoc;
 936     xpctxt-&gt;node = oldXPContextNode;
 937     xpctxt-&gt;contextSize = oldXPContextSize;
 938     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
 939     xpctxt-&gt;namespaces = oldXPNamespaces;
 940     xpctxt-&gt;nsNr = oldXPNsNr;
 941 
 942     if ((comp == NULL) || (comp-&gt;comp == NULL))
 943         xmlXPathFreeCompExpr(xpExpr);
 944     if (result == NULL) {
 945         xsltTransformError(ctxt, NULL,
 946         (comp != NULL) ? comp-&gt;inst : NULL,
 947         &quot;Failed to evaluate the expression of variable &#39;%s&#39;.\n&quot;,
 948         variable-&gt;name);
 949         ctxt-&gt;state = XSLT_STATE_STOPPED;
 950 
 951 #ifdef WITH_XSLT_DEBUG_VARIABLE
 952 #ifdef LIBXML_DEBUG_ENABLED
 953     } else {
 954         if ((xsltGenericDebugContext == stdout) ||
 955         (xsltGenericDebugContext == stderr))
 956         xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,
 957                     result, 0);
 958 #endif
 959 #endif
 960     }
 961     } else {
 962     if (variable-&gt;tree == NULL) {
 963         result = xmlXPathNewCString(&quot;&quot;);
 964     } else {
 965         if (variable-&gt;tree) {
 966         xmlDocPtr container;
 967         xmlNodePtr oldInsert;
 968         xmlDocPtr  oldOutput;
 969         xsltStackElemPtr oldVar = ctxt-&gt;contextVariable;
 970 
 971         /*
 972         * Generate a result tree fragment.
 973         */
 974         container = xsltCreateRVT(ctxt);
 975         if (container == NULL)
 976             goto error;
 977         /*
 978         * NOTE: Local Result Tree Fragments of params/variables
 979         * are not registered globally anymore; the life-time
 980         * is not directly dependant of the param/variable itself.
 981         *
 982         * OLD: xsltRegisterTmpRVT(ctxt, container);
 983         */
 984         /*
 985         * Attach the Result Tree Fragment to the variable;
 986         * when the variable is freed, it will also free
 987         * the Result Tree Fragment.
 988         */
 989         variable-&gt;fragment = container;
 990                 container-&gt;psvi = XSLT_RVT_LOCAL;
 991 
 992         oldOutput = ctxt-&gt;output;
 993         oldInsert = ctxt-&gt;insert;
 994 
 995         ctxt-&gt;output = container;
 996         ctxt-&gt;insert = (xmlNodePtr) container;
 997         ctxt-&gt;contextVariable = variable;
 998         /*
 999         * Process the sequence constructor (variable-&gt;tree).
1000         * The resulting tree will be held by @container.
1001         */
1002         xsltApplyOneTemplate(ctxt, ctxt-&gt;node, variable-&gt;tree,
1003             NULL, NULL);
1004 
1005         ctxt-&gt;contextVariable = oldVar;
1006         ctxt-&gt;insert = oldInsert;
1007         ctxt-&gt;output = oldOutput;
1008 
1009         result = xmlXPathNewValueTree((xmlNodePtr) container);
1010         }
1011         if (result == NULL) {
1012         result = xmlXPathNewCString(&quot;&quot;);
1013         } else {
1014         /*
1015         * Freeing is not handled there anymore.
1016         * QUESTION TODO: What does the above comment mean?
1017         */
1018             result-&gt;boolval = 0;
1019         }
1020 #ifdef WITH_XSLT_DEBUG_VARIABLE
1021 #ifdef LIBXML_DEBUG_ENABLED
1022 
1023         if ((xsltGenericDebugContext == stdout) ||
1024         (xsltGenericDebugContext == stderr))
1025         xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,
1026                     result, 0);
1027 #endif
1028 #endif
1029     }
1030     }
1031 
1032 error:
1033     ctxt-&gt;inst = oldInst;
1034     return(result);
1035 }
1036 
1037 /**
1038  * xsltEvalGlobalVariable:
1039  * @elem:  the variable or parameter
1040  * @ctxt:  the XSLT transformation context
1041  *
1042  * Evaluates a the value of a global xsl:variable or
1043  * xsl:param declaration.
1044  *
1045  * Returns the XPath Object value or NULL in case of error
1046  */
1047 static xmlXPathObjectPtr
1048 xsltEvalGlobalVariable(xsltStackElemPtr elem, xsltTransformContextPtr ctxt)
1049 {
1050     xmlXPathObjectPtr result = NULL;
1051     xmlNodePtr oldInst;
1052     const xmlChar* oldVarName;
1053 
1054 #ifdef XSLT_REFACTORED
1055     xsltStyleBasicItemVariablePtr comp;
1056 #else
1057     xsltStylePreCompPtr comp;
1058 #endif
1059 
1060     if ((ctxt == NULL) || (elem == NULL))
1061     return(NULL);
1062     if (elem-&gt;computed)
1063     return(elem-&gt;value);
1064 
1065 
1066 #ifdef WITH_XSLT_DEBUG_VARIABLE
1067     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1068     &quot;Evaluating global variable %s\n&quot;, elem-&gt;name));
1069 #endif
1070 
1071 #ifdef WITH_DEBUGGER
1072     if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp;
1073         elem-&gt;comp &amp;&amp; elem-&gt;comp-&gt;inst)
1074         xslHandleDebugger(elem-&gt;comp-&gt;inst, NULL, NULL, ctxt);
1075 #endif
1076 
1077     oldInst = ctxt-&gt;inst;
1078 #ifdef XSLT_REFACTORED
1079     comp = (xsltStyleBasicItemVariablePtr) elem-&gt;comp;
1080 #else
1081     comp = elem-&gt;comp;
1082 #endif
1083     oldVarName = elem-&gt;name;
1084     elem-&gt;name = xsltComputingGlobalVarMarker;
1085     /*
1086     * OPTIMIZE TODO: We should consider instantiating global vars/params
1087     *  on-demand. The vars/params don&#39;t need to be evaluated if never
1088     *  called; and in the case of global params, if values for such params
1089     *  are provided by the user.
1090     */
1091     if (elem-&gt;select != NULL) {
1092     xmlXPathCompExprPtr xpExpr = NULL;
1093     xmlDocPtr oldXPDoc;
1094     xmlNodePtr oldXPContextNode;
1095     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
1096     xmlNsPtr *oldXPNamespaces;
1097     xmlXPathContextPtr xpctxt = ctxt-&gt;xpathCtxt;
1098 
1099     if ((comp != NULL) &amp;&amp; (comp-&gt;comp != NULL)) {
1100         xpExpr = comp-&gt;comp;
1101     } else {
1102         xpExpr = xmlXPathCompile(elem-&gt;select);
1103     }
1104     if (xpExpr == NULL)
1105         goto error;
1106 
1107 
1108     if (comp != NULL)
1109         ctxt-&gt;inst = comp-&gt;inst;
1110     else
1111         ctxt-&gt;inst = NULL;
1112     /*
1113     * SPEC XSLT 1.0:
1114     * &quot;At top-level, the expression or template specifying the
1115     *  variable value is evaluated with the same context as that used
1116     *  to process the root node of the source document: the current
1117     *  node is the root node of the source document and the current
1118     *  node list is a list containing just the root node of the source
1119     *  document.&quot;
1120     */
1121     /*
1122     * Save context states.
1123     */
1124     oldXPDoc = xpctxt-&gt;doc;
1125     oldXPContextNode = xpctxt-&gt;node;
1126     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
1127     oldXPContextSize = xpctxt-&gt;contextSize;
1128     oldXPNamespaces = xpctxt-&gt;namespaces;
1129     oldXPNsNr = xpctxt-&gt;nsNr;
1130 
1131     xpctxt-&gt;node = ctxt-&gt;initialContextNode;
1132     xpctxt-&gt;doc = ctxt-&gt;initialContextDoc;
1133     xpctxt-&gt;contextSize = 1;
1134     xpctxt-&gt;proximityPosition = 1;
1135 
1136     if (comp != NULL) {
1137 
1138 #ifdef XSLT_REFACTORED
1139         if (comp-&gt;inScopeNs != NULL) {
1140         xpctxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
1141         xpctxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
1142         } else {
1143         xpctxt-&gt;namespaces = NULL;
1144         xpctxt-&gt;nsNr = 0;
1145         }
1146 #else
1147         xpctxt-&gt;namespaces = comp-&gt;nsList;
1148         xpctxt-&gt;nsNr = comp-&gt;nsNr;
1149 #endif
1150     } else {
1151         xpctxt-&gt;namespaces = NULL;
1152         xpctxt-&gt;nsNr = 0;
1153     }
1154 
1155     result = xmlXPathCompiledEval(xpExpr, xpctxt);
1156 
1157     /*
1158     * Restore Context states.
1159     */
1160     xpctxt-&gt;doc = oldXPDoc;
1161     xpctxt-&gt;node = oldXPContextNode;
1162     xpctxt-&gt;contextSize = oldXPContextSize;
1163     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
1164     xpctxt-&gt;namespaces = oldXPNamespaces;
1165     xpctxt-&gt;nsNr = oldXPNsNr;
1166 
1167     if ((comp == NULL) || (comp-&gt;comp == NULL))
1168         xmlXPathFreeCompExpr(xpExpr);
1169     if (result == NULL) {
1170         if (comp == NULL)
1171         xsltTransformError(ctxt, NULL, NULL,
1172             &quot;Evaluating global variable %s failed\n&quot;, elem-&gt;name);
1173         else
1174         xsltTransformError(ctxt, NULL, comp-&gt;inst,
1175             &quot;Evaluating global variable %s failed\n&quot;, elem-&gt;name);
1176         ctxt-&gt;state = XSLT_STATE_STOPPED;
1177             goto error;
1178         }
1179 
1180         /*
1181          * Mark all RVTs that are referenced from result as part
1182          * of this variable so they won&#39;t be freed too early.
1183          */
1184         xsltFlagRVTs(ctxt, result, XSLT_RVT_GLOBAL);
1185 
1186 #ifdef WITH_XSLT_DEBUG_VARIABLE
1187 #ifdef LIBXML_DEBUG_ENABLED
1188     if ((xsltGenericDebugContext == stdout) ||
1189         (xsltGenericDebugContext == stderr))
1190         xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,
1191                     result, 0);
1192 #endif
1193 #endif
1194     } else {
1195     if (elem-&gt;tree == NULL) {
1196         result = xmlXPathNewCString(&quot;&quot;);
1197     } else {
1198         xmlDocPtr container;
1199         xmlNodePtr oldInsert;
1200         xmlDocPtr  oldOutput, oldXPDoc;
1201         /*
1202         * Generate a result tree fragment.
1203         */
1204         container = xsltCreateRVT(ctxt);
1205         if (container == NULL)
1206         goto error;
1207         /*
1208         * Let the lifetime of the tree fragment be handled by
1209         * the Libxslt&#39;s garbage collector.
1210         */
1211         xsltRegisterPersistRVT(ctxt, container);
1212 
1213         oldOutput = ctxt-&gt;output;
1214         oldInsert = ctxt-&gt;insert;
1215 
1216         oldXPDoc = ctxt-&gt;xpathCtxt-&gt;doc;
1217 
1218         ctxt-&gt;output = container;
1219         ctxt-&gt;insert = (xmlNodePtr) container;
1220 
1221         ctxt-&gt;xpathCtxt-&gt;doc = ctxt-&gt;initialContextDoc;
1222         /*
1223         * Process the sequence constructor.
1224         */
1225         xsltApplyOneTemplate(ctxt, ctxt-&gt;node, elem-&gt;tree, NULL, NULL);
1226 
1227         ctxt-&gt;xpathCtxt-&gt;doc = oldXPDoc;
1228 
1229         ctxt-&gt;insert = oldInsert;
1230         ctxt-&gt;output = oldOutput;
1231 
1232         result = xmlXPathNewValueTree((xmlNodePtr) container);
1233         if (result == NULL) {
1234         result = xmlXPathNewCString(&quot;&quot;);
1235         } else {
1236             result-&gt;boolval = 0; /* Freeing is not handled there anymore */
1237         }
1238 #ifdef WITH_XSLT_DEBUG_VARIABLE
1239 #ifdef LIBXML_DEBUG_ENABLED
1240         if ((xsltGenericDebugContext == stdout) ||
1241         (xsltGenericDebugContext == stderr))
1242         xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,
1243                     result, 0);
1244 #endif
1245 #endif
1246     }
1247     }
1248 
1249 error:
1250     elem-&gt;name = oldVarName;
1251     ctxt-&gt;inst = oldInst;
1252     if (result != NULL) {
1253     elem-&gt;value = result;
1254     elem-&gt;computed = 1;
1255     }
1256     return(result);
1257 }
1258 
1259 static void
1260 xsltEvalGlobalVariableWrapper(void *payload, void *data,
1261                               const xmlChar *name ATTRIBUTE_UNUSED) {
1262     xsltEvalGlobalVariable((xsltStackElemPtr) payload,
1263                            (xsltTransformContextPtr) data);
1264 }
1265 
1266 /**
1267  * xsltEvalGlobalVariables:
1268  * @ctxt:  the XSLT transformation context
1269  *
1270  * Evaluates all global variables and parameters of a stylesheet.
1271  * For internal use only. This is called at start of a transformation.
1272  *
1273  * Returns 0 in case of success, -1 in case of error
1274  */
1275 int
1276 xsltEvalGlobalVariables(xsltTransformContextPtr ctxt) {
1277     xsltStackElemPtr elem;
1278     xsltStylesheetPtr style;
1279 
1280     if ((ctxt == NULL) || (ctxt-&gt;document == NULL))
1281     return(-1);
1282 
1283 #ifdef WITH_XSLT_DEBUG_VARIABLE
1284     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1285     &quot;Registering global variables\n&quot;));
1286 #endif
1287     /*
1288      * Walk the list from the stylesheets and populate the hash table
1289      */
1290     style = ctxt-&gt;style;
1291     while (style != NULL) {
1292     elem = style-&gt;variables;
1293 
1294 #ifdef WITH_XSLT_DEBUG_VARIABLE
1295     if ((style-&gt;doc != NULL) &amp;&amp; (style-&gt;doc-&gt;URL != NULL)) {
1296         XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1297                  &quot;Registering global variables from %s\n&quot;,
1298                      style-&gt;doc-&gt;URL));
1299     }
1300 #endif
1301 
1302     while (elem != NULL) {
1303         xsltStackElemPtr def;
1304 
1305         /*
1306          * Global variables are stored in the variables pool.
1307          */
1308         def = (xsltStackElemPtr)
1309             xmlHashLookup2(ctxt-&gt;globalVars,
1310                          elem-&gt;name, elem-&gt;nameURI);
1311         if (def == NULL) {
1312 
1313         def = xsltCopyStackElem(elem);
1314         xmlHashAddEntry2(ctxt-&gt;globalVars,
1315                  elem-&gt;name, elem-&gt;nameURI, def);
1316         } else if ((elem-&gt;comp != NULL) &amp;&amp;
1317                (elem-&gt;comp-&gt;type == XSLT_FUNC_VARIABLE)) {
1318         /*
1319          * Redefinition of variables from a different stylesheet
1320          * should not generate a message.
1321          */
1322         if ((elem-&gt;comp-&gt;inst != NULL) &amp;&amp;
1323             (def-&gt;comp != NULL) &amp;&amp; (def-&gt;comp-&gt;inst != NULL) &amp;&amp;
1324             (elem-&gt;comp-&gt;inst-&gt;doc == def-&gt;comp-&gt;inst-&gt;doc))
1325         {
1326             xsltTransformError(ctxt, style, elem-&gt;comp-&gt;inst,
1327             &quot;Global variable %s already defined\n&quot;, elem-&gt;name);
1328             if (style != NULL) style-&gt;errors++;
1329         }
1330         }
1331         elem = elem-&gt;next;
1332     }
1333 
1334     style = xsltNextImport(style);
1335     }
1336 
1337     /*
1338      * This part does the actual evaluation
1339      */
1340     xmlHashScan(ctxt-&gt;globalVars, xsltEvalGlobalVariableWrapper, ctxt);
1341 
1342     return(0);
1343 }
1344 
1345 /**
1346  * xsltRegisterGlobalVariable:
1347  * @style:  the XSLT transformation context
1348  * @name:  the variable name
1349  * @ns_uri:  the variable namespace URI
1350  * @sel:  the expression which need to be evaluated to generate a value
1351  * @tree:  the subtree if sel is NULL
1352  * @comp:  the precompiled value
1353  * @value:  the string value if available
1354  *
1355  * Register a new variable value. If @value is NULL it unregisters
1356  * the variable
1357  *
1358  * Returns 0 in case of success, -1 in case of error
1359  */
1360 static int
1361 xsltRegisterGlobalVariable(xsltStylesheetPtr style, const xmlChar *name,
1362              const xmlChar *ns_uri, const xmlChar *sel,
1363              xmlNodePtr tree, xsltStylePreCompPtr comp,
1364              const xmlChar *value) {
1365     xsltStackElemPtr elem, tmp;
1366     if (style == NULL)
1367     return(-1);
1368     if (name == NULL)
1369     return(-1);
1370     if (comp == NULL)
1371     return(-1);
1372 
1373 #ifdef WITH_XSLT_DEBUG_VARIABLE
1374     if (comp-&gt;type == XSLT_FUNC_PARAM)
1375     xsltGenericDebug(xsltGenericDebugContext,
1376              &quot;Defining global param %s\n&quot;, name);
1377     else
1378     xsltGenericDebug(xsltGenericDebugContext,
1379              &quot;Defining global variable %s\n&quot;, name);
1380 #endif
1381 
1382     elem = xsltNewStackElem(NULL);
1383     if (elem == NULL)
1384     return(-1);
1385     elem-&gt;comp = comp;
1386     elem-&gt;name = xmlDictLookup(style-&gt;dict, name, -1);
1387     elem-&gt;select = xmlDictLookup(style-&gt;dict, sel, -1);
1388     if (ns_uri)
1389     elem-&gt;nameURI = xmlDictLookup(style-&gt;dict, ns_uri, -1);
1390     elem-&gt;tree = tree;
1391     tmp = style-&gt;variables;
1392     if (tmp == NULL) {
1393     elem-&gt;next = NULL;
1394     style-&gt;variables = elem;
1395     } else {
1396     while (tmp != NULL) {
1397         if ((elem-&gt;comp-&gt;type == XSLT_FUNC_VARIABLE) &amp;&amp;
1398         (tmp-&gt;comp-&gt;type == XSLT_FUNC_VARIABLE) &amp;&amp;
1399         (xmlStrEqual(elem-&gt;name, tmp-&gt;name)) &amp;&amp;
1400         ((elem-&gt;nameURI == tmp-&gt;nameURI) ||
1401          (xmlStrEqual(elem-&gt;nameURI, tmp-&gt;nameURI))))
1402         {
1403         xsltTransformError(NULL, style, comp-&gt;inst,
1404         &quot;redefinition of global variable %s\n&quot;, elem-&gt;name);
1405         style-&gt;errors++;
1406         }
1407         if (tmp-&gt;next == NULL)
1408             break;
1409         tmp = tmp-&gt;next;
1410     }
1411     elem-&gt;next = NULL;
1412     tmp-&gt;next = elem;
1413     }
1414     if (value != NULL) {
1415     elem-&gt;computed = 1;
1416     elem-&gt;value = xmlXPathNewString(value);
1417     }
1418     return(0);
1419 }
1420 
1421 /**
1422  * xsltProcessUserParamInternal
1423  *
1424  * @ctxt:  the XSLT transformation context
1425  * @name:  a null terminated parameter name
1426  * @value: a null terminated value (may be an XPath expression)
1427  * @eval:  0 to treat the value literally, else evaluate as XPath expression
1428  *
1429  * If @eval is 0 then @value is treated literally and is stored in the global
1430  * parameter/variable table without any change.
1431  *
1432  * Uf @eval is 1 then @value is treated as an XPath expression and is
1433  * evaluated.  In this case, if you want to pass a string which will be
1434  * interpreted literally then it must be enclosed in single or double quotes.
1435  * If the string contains single quotes (double quotes) then it cannot be
1436  * enclosed single quotes (double quotes).  If the string which you want to
1437  * be treated literally contains both single and double quotes (e.g. Meet
1438  * at Joe&#39;s for &quot;Twelfth Night&quot; at 7 o&#39;clock) then there is no suitable
1439  * quoting character.  You cannot use &amp;apos; or &amp;quot; inside the string
1440  * because the replacement of character entities with their equivalents is
1441  * done at a different stage of processing.  The solution is to call
1442  * xsltQuoteUserParams or xsltQuoteOneUserParam.
1443  *
1444  * This needs to be done on parsed stylesheets before starting to apply
1445  * transformations.  Normally this will be called (directly or indirectly)
1446  * only from xsltEvalUserParams, xsltEvalOneUserParam, xsltQuoteUserParams,
1447  * or xsltQuoteOneUserParam.
1448  *
1449  * Returns 0 in case of success, -1 in case of error
1450  */
1451 
1452 static
1453 int
1454 xsltProcessUserParamInternal(xsltTransformContextPtr ctxt,
1455                      const xmlChar * name,
1456                  const xmlChar * value,
1457                  int eval) {
1458 
1459     xsltStylesheetPtr style;
1460     const xmlChar *prefix;
1461     const xmlChar *href;
1462     xmlXPathCompExprPtr xpExpr;
1463     xmlXPathObjectPtr result;
1464 
1465     xsltStackElemPtr elem;
1466     int res;
1467     void *res_ptr;
1468 
1469     if (ctxt == NULL)
1470     return(-1);
1471     if (name == NULL)
1472     return(0);
1473     if (value == NULL)
1474     return(0);
1475 
1476     style = ctxt-&gt;style;
1477 
1478 #ifdef WITH_XSLT_DEBUG_VARIABLE
1479     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1480         &quot;Evaluating user parameter %s=%s\n&quot;, name, value));
1481 #endif
1482 
1483     /*
1484      * Name lookup
1485      */
1486     href = NULL;
1487 
1488     if (name[0] == &#39;{&#39;) {
1489         int len = 0;
1490 
1491         while ((name[len] != 0) &amp;&amp; (name[len] != &#39;}&#39;)) len++;
1492         if (name[len] == 0) {
1493            xsltTransformError(ctxt, style, NULL,
1494            &quot;user param : malformed parameter name : %s\n&quot;, name);
1495         } else {
1496            href = xmlDictLookup(ctxt-&gt;dict, &amp;name[1], len-1);
1497            name = xmlDictLookup(ctxt-&gt;dict, &amp;name[len + 1], -1);
1498        }
1499     }
1500     else {
1501         name = xsltSplitQName(ctxt-&gt;dict, name, &amp;prefix);
1502         if (prefix != NULL) {
1503             xmlNsPtr ns;
1504 
1505             ns = xmlSearchNs(style-&gt;doc, xmlDocGetRootElement(style-&gt;doc),
1506                              prefix);
1507             if (ns == NULL) {
1508                 xsltTransformError(ctxt, style, NULL,
1509                 &quot;user param : no namespace bound to prefix %s\n&quot;, prefix);
1510                 href = NULL;
1511             } else {
1512                 href = ns-&gt;href;
1513             }
1514         }
1515     }
1516 
1517     if (name == NULL)
1518     return (-1);
1519 
1520     res_ptr = xmlHashLookup2(ctxt-&gt;globalVars, name, href);
1521     if (res_ptr != 0) {
1522     xsltTransformError(ctxt, style, NULL,
1523         &quot;Global parameter %s already defined\n&quot;, name);
1524     }
1525     if (ctxt-&gt;globalVars == NULL)
1526     ctxt-&gt;globalVars = xmlHashCreate(20);
1527 
1528     /*
1529      * do not overwrite variables with parameters from the command line
1530      */
1531     while (style != NULL) {
1532         elem = ctxt-&gt;style-&gt;variables;
1533     while (elem != NULL) {
1534         if ((elem-&gt;comp != NULL) &amp;&amp;
1535             (elem-&gt;comp-&gt;type == XSLT_FUNC_VARIABLE) &amp;&amp;
1536         (xmlStrEqual(elem-&gt;name, name)) &amp;&amp;
1537         (xmlStrEqual(elem-&gt;nameURI, href))) {
1538         return(0);
1539         }
1540             elem = elem-&gt;next;
1541     }
1542         style = xsltNextImport(style);
1543     }
1544     style = ctxt-&gt;style;
1545     elem = NULL;
1546 
1547     /*
1548      * Do the evaluation if @eval is non-zero.
1549      */
1550 
1551     result = NULL;
1552     if (eval != 0) {
1553         xpExpr = xmlXPathCompile(value);
1554     if (xpExpr != NULL) {
1555         xmlDocPtr oldXPDoc;
1556         xmlNodePtr oldXPContextNode;
1557         int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
1558         xmlNsPtr *oldXPNamespaces;
1559         xmlXPathContextPtr xpctxt = ctxt-&gt;xpathCtxt;
1560 
1561         /*
1562         * Save context states.
1563         */
1564         oldXPDoc = xpctxt-&gt;doc;
1565         oldXPContextNode = xpctxt-&gt;node;
1566         oldXPProximityPosition = xpctxt-&gt;proximityPosition;
1567         oldXPContextSize = xpctxt-&gt;contextSize;
1568         oldXPNamespaces = xpctxt-&gt;namespaces;
1569         oldXPNsNr = xpctxt-&gt;nsNr;
1570 
1571         /*
1572         * SPEC XSLT 1.0:
1573         * &quot;At top-level, the expression or template specifying the
1574         *  variable value is evaluated with the same context as that used
1575         *  to process the root node of the source document: the current
1576         *  node is the root node of the source document and the current
1577         *  node list is a list containing just the root node of the source
1578         *  document.&quot;
1579         */
1580         xpctxt-&gt;doc = ctxt-&gt;initialContextDoc;
1581         xpctxt-&gt;node = ctxt-&gt;initialContextNode;
1582         xpctxt-&gt;contextSize = 1;
1583         xpctxt-&gt;proximityPosition = 1;
1584         /*
1585         * There is really no in scope namespace for parameters on the
1586         * command line.
1587         */
1588         xpctxt-&gt;namespaces = NULL;
1589         xpctxt-&gt;nsNr = 0;
1590 
1591         result = xmlXPathCompiledEval(xpExpr, xpctxt);
1592 
1593         /*
1594         * Restore Context states.
1595         */
1596         xpctxt-&gt;doc = oldXPDoc;
1597         xpctxt-&gt;node = oldXPContextNode;
1598         xpctxt-&gt;contextSize = oldXPContextSize;
1599         xpctxt-&gt;proximityPosition = oldXPProximityPosition;
1600         xpctxt-&gt;namespaces = oldXPNamespaces;
1601         xpctxt-&gt;nsNr = oldXPNsNr;
1602 
1603         xmlXPathFreeCompExpr(xpExpr);
1604     }
1605     if (result == NULL) {
1606         xsltTransformError(ctxt, style, NULL,
1607         &quot;Evaluating user parameter %s failed\n&quot;, name);
1608         ctxt-&gt;state = XSLT_STATE_STOPPED;
1609         return(-1);
1610     }
1611     }
1612 
1613     /*
1614      * If @eval is 0 then @value is to be taken literally and result is NULL
1615      *
1616      * If @eval is not 0, then @value is an XPath expression and has been
1617      * successfully evaluated and result contains the resulting value and
1618      * is not NULL.
1619      *
1620      * Now create an xsltStackElemPtr for insertion into the context&#39;s
1621      * global variable/parameter hash table.
1622      */
1623 
1624 #ifdef WITH_XSLT_DEBUG_VARIABLE
1625 #ifdef LIBXML_DEBUG_ENABLED
1626     if ((xsltGenericDebugContext == stdout) ||
1627         (xsltGenericDebugContext == stderr))
1628         xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,
1629                     result, 0);
1630 #endif
1631 #endif
1632 
1633     elem = xsltNewStackElem(NULL);
1634     if (elem != NULL) {
1635     elem-&gt;name = name;
1636     elem-&gt;select = xmlDictLookup(ctxt-&gt;dict, value, -1);
1637     if (href != NULL)
1638         elem-&gt;nameURI = xmlDictLookup(ctxt-&gt;dict, href, -1);
1639     elem-&gt;tree = NULL;
1640     elem-&gt;computed = 1;
1641     if (eval == 0) {
1642         elem-&gt;value = xmlXPathNewString(value);
1643     }
1644     else {
1645         elem-&gt;value = result;
1646     }
1647     }
1648 
1649     /*
1650      * Global parameters are stored in the XPath context variables pool.
1651      */
1652 
1653     res = xmlHashAddEntry2(ctxt-&gt;globalVars, name, href, elem);
1654     if (res != 0) {
1655     xsltFreeStackElem(elem);
1656     xsltTransformError(ctxt, style, NULL,
1657         &quot;Global parameter %s already defined\n&quot;, name);
1658     }
1659     return(0);
1660 }
1661 
1662 /**
1663  * xsltEvalUserParams:
1664  *
1665  * @ctxt:  the XSLT transformation context
1666  * @params:  a NULL terminated array of parameters name/value tuples
1667  *
1668  * Evaluate the global variables of a stylesheet. This needs to be
1669  * done on parsed stylesheets before starting to apply transformations.
1670  * Each of the parameters is evaluated as an XPath expression and stored
1671  * in the global variables/parameter hash table.  If you want your
1672  * parameter used literally, use xsltQuoteUserParams.
1673  *
1674  * Returns 0 in case of success, -1 in case of error
1675  */
1676 
1677 int
1678 xsltEvalUserParams(xsltTransformContextPtr ctxt, const char **params) {
1679     int indx = 0;
1680     const xmlChar *name;
1681     const xmlChar *value;
1682 
1683     if (params == NULL)
1684     return(0);
1685     while (params[indx] != NULL) {
1686     name = (const xmlChar *) params[indx++];
1687     value = (const xmlChar *) params[indx++];
1688     if (xsltEvalOneUserParam(ctxt, name, value) != 0)
1689         return(-1);
1690     }
1691     return 0;
1692 }
1693 
1694 /**
1695  * xsltQuoteUserParams:
1696  *
1697  * @ctxt:  the XSLT transformation context
1698  * @params:  a NULL terminated arry of parameters names/values tuples
1699  *
1700  * Similar to xsltEvalUserParams, but the values are treated literally and
1701  * are * *not* evaluated as XPath expressions. This should be done on parsed
1702  * stylesheets before starting to apply transformations.
1703  *
1704  * Returns 0 in case of success, -1 in case of error.
1705  */
1706 
1707 int
1708 xsltQuoteUserParams(xsltTransformContextPtr ctxt, const char **params) {
1709     int indx = 0;
1710     const xmlChar *name;
1711     const xmlChar *value;
1712 
1713     if (params == NULL)
1714     return(0);
1715     while (params[indx] != NULL) {
1716     name = (const xmlChar *) params[indx++];
1717     value = (const xmlChar *) params[indx++];
1718     if (xsltQuoteOneUserParam(ctxt, name, value) != 0)
1719         return(-1);
1720     }
1721     return 0;
1722 }
1723 
1724 /**
1725  * xsltEvalOneUserParam:
1726  * @ctxt:  the XSLT transformation context
1727  * @name:  a null terminated string giving the name of the parameter
1728  * @value:  a null terminated string giving the XPath expression to be evaluated
1729  *
1730  * This is normally called from xsltEvalUserParams to process a single
1731  * parameter from a list of parameters.  The @value is evaluated as an
1732  * XPath expression and the result is stored in the context&#39;s global
1733  * variable/parameter hash table.
1734  *
1735  * To have a parameter treated literally (not as an XPath expression)
1736  * use xsltQuoteUserParams (or xsltQuoteOneUserParam).  For more
1737  * details see description of xsltProcessOneUserParamInternal.
1738  *
1739  * Returns 0 in case of success, -1 in case of error.
1740  */
1741 
1742 int
1743 xsltEvalOneUserParam(xsltTransformContextPtr ctxt,
1744              const xmlChar * name,
1745              const xmlChar * value) {
1746     return xsltProcessUserParamInternal(ctxt, name, value,
1747                                 1 /* xpath eval ? */);
1748 }
1749 
1750 /**
1751  * xsltQuoteOneUserParam:
1752  * @ctxt:  the XSLT transformation context
1753  * @name:  a null terminated string giving the name of the parameter
1754  * @value:  a null terminated string giving the parameter value
1755  *
1756  * This is normally called from xsltQuoteUserParams to process a single
1757  * parameter from a list of parameters.  The @value is stored in the
1758  * context&#39;s global variable/parameter hash table.
1759  *
1760  * Returns 0 in case of success, -1 in case of error.
1761  */
1762 
1763 int
1764 xsltQuoteOneUserParam(xsltTransformContextPtr ctxt,
1765              const xmlChar * name,
1766              const xmlChar * value) {
1767     return xsltProcessUserParamInternal(ctxt, name, value,
1768                     0 /* xpath eval ? */);
1769 }
1770 
1771 /**
1772  * xsltBuildVariable:
1773  * @ctxt:  the XSLT transformation context
1774  * @comp:  the precompiled form
1775  * @tree:  the tree if select is NULL
1776  *
1777  * Computes a new variable value.
1778  *
1779  * Returns the xsltStackElemPtr or NULL in case of error
1780  */
1781 static xsltStackElemPtr
1782 xsltBuildVariable(xsltTransformContextPtr ctxt,
1783           xsltStylePreCompPtr castedComp,
1784           xmlNodePtr tree)
1785 {
1786 #ifdef XSLT_REFACTORED
1787     xsltStyleBasicItemVariablePtr comp =
1788     (xsltStyleBasicItemVariablePtr) castedComp;
1789 #else
1790     xsltStylePreCompPtr comp = castedComp;
1791 #endif
1792     xsltStackElemPtr elem;
1793 
1794 #ifdef WITH_XSLT_DEBUG_VARIABLE
1795     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1796              &quot;Building variable %s&quot;, comp-&gt;name));
1797     if (comp-&gt;select != NULL)
1798     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1799              &quot; select %s&quot;, comp-&gt;select));
1800     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext, &quot;\n&quot;));
1801 #endif
1802 
1803     elem = xsltNewStackElem(ctxt);
1804     if (elem == NULL)
1805     return(NULL);
1806     elem-&gt;comp = (xsltStylePreCompPtr) comp;
1807     elem-&gt;name = comp-&gt;name;
1808     elem-&gt;select = comp-&gt;select;
1809     elem-&gt;nameURI = comp-&gt;ns;
1810     elem-&gt;tree = tree;
1811     elem-&gt;value = xsltEvalVariable(ctxt, elem,
1812     (xsltStylePreCompPtr) comp);
1813     elem-&gt;computed = 1;
1814     return(elem);
1815 }
1816 
1817 /**
1818  * xsltRegisterVariable:
1819  * @ctxt:  the XSLT transformation context
1820  * @comp: the compiled XSLT-variable (or param) instruction
1821  * @tree:  the tree if select is NULL
1822  * @isParam:  indicates if this is a parameter
1823  *
1824  * Computes and registers a new variable.
1825  *
1826  * Returns 0 in case of success, -1 in case of error
1827  */
1828 static int
1829 xsltRegisterVariable(xsltTransformContextPtr ctxt,
1830              xsltStylePreCompPtr castedComp,
1831              xmlNodePtr tree, int isParam)
1832 {
1833 #ifdef XSLT_REFACTORED
1834     xsltStyleBasicItemVariablePtr comp =
1835     (xsltStyleBasicItemVariablePtr) castedComp;
1836 #else
1837     xsltStylePreCompPtr comp = castedComp;
1838     int present;
1839 #endif
1840     xsltStackElemPtr variable;
1841 
1842 #ifdef XSLT_REFACTORED
1843     /*
1844     * REFACTORED NOTE: Redefinitions of vars/params are checked
1845     *  at compilation time in the refactored code.
1846     * xsl:with-param parameters are checked in xsltApplyXSLTTemplate().
1847     */
1848 #else
1849     present = xsltCheckStackElem(ctxt, comp-&gt;name, comp-&gt;ns);
1850     if (isParam == 0) {
1851     if ((present != 0) &amp;&amp; (present != 3)) {
1852         /* TODO: report QName. */
1853         xsltTransformError(ctxt, NULL, comp-&gt;inst,
1854         &quot;XSLT-variable: Redefinition of variable &#39;%s&#39;.\n&quot;, comp-&gt;name);
1855         return(0);
1856     }
1857     } else if (present != 0) {
1858     if ((present == 1) || (present == 2)) {
1859         /* TODO: report QName. */
1860         xsltTransformError(ctxt, NULL, comp-&gt;inst,
1861         &quot;XSLT-param: Redefinition of parameter &#39;%s&#39;.\n&quot;, comp-&gt;name);
1862         return(0);
1863     }
1864 #ifdef WITH_XSLT_DEBUG_VARIABLE
1865     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1866          &quot;param %s defined by caller\n&quot;, comp-&gt;name));
1867 #endif
1868     return(0);
1869     }
1870 #endif /* else of XSLT_REFACTORED */
1871 
1872     variable = xsltBuildVariable(ctxt, (xsltStylePreCompPtr) comp, tree);
1873     xsltAddStackElem(ctxt, variable);
1874     return(0);
1875 }
1876 
1877 /**
1878  * xsltGlobalVariableLookup:
1879  * @ctxt:  the XSLT transformation context
1880  * @name:  the variable name
1881  * @ns_uri:  the variable namespace URI
1882  *
1883  * Search in the Variable array of the context for the given
1884  * variable value.
1885  *
1886  * Returns the value or NULL if not found
1887  */
1888 static xmlXPathObjectPtr
1889 xsltGlobalVariableLookup(xsltTransformContextPtr ctxt, const xmlChar *name,
1890                  const xmlChar *ns_uri) {
1891     xsltStackElemPtr elem;
1892     xmlXPathObjectPtr ret = NULL;
1893 
1894     /*
1895      * Lookup the global variables in XPath global variable hash table
1896      */
1897     if ((ctxt-&gt;xpathCtxt == NULL) || (ctxt-&gt;globalVars == NULL))
1898     return(NULL);
1899     elem = (xsltStackElemPtr)
1900         xmlHashLookup2(ctxt-&gt;globalVars, name, ns_uri);
1901     if (elem == NULL) {
1902 #ifdef WITH_XSLT_DEBUG_VARIABLE
1903     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1904              &quot;global variable not found %s\n&quot;, name));
1905 #endif
1906     return(NULL);
1907     }
1908     /*
1909     * URGENT TODO: Move the detection of recursive definitions
1910     * to compile-time.
1911     */
1912     if (elem-&gt;computed == 0) {
1913     if (elem-&gt;name == xsltComputingGlobalVarMarker) {
1914         xsltTransformError(ctxt, NULL, elem-&gt;comp-&gt;inst,
1915         &quot;Recursive definition of %s\n&quot;, name);
1916         return(NULL);
1917     }
1918     ret = xsltEvalGlobalVariable(elem, ctxt);
1919     } else
1920     ret = elem-&gt;value;
1921     return(xmlXPathObjectCopy(ret));
1922 }
1923 
1924 /**
1925  * xsltVariableLookup:
1926  * @ctxt:  the XSLT transformation context
1927  * @name:  the variable name
1928  * @ns_uri:  the variable namespace URI
1929  *
1930  * Search in the Variable array of the context for the given
1931  * variable value.
1932  *
1933  * Returns the value or NULL if not found
1934  */
1935 xmlXPathObjectPtr
1936 xsltVariableLookup(xsltTransformContextPtr ctxt, const xmlChar *name,
1937            const xmlChar *ns_uri) {
1938     xsltStackElemPtr elem;
1939 
1940     if (ctxt == NULL)
1941     return(NULL);
1942 
1943     elem = xsltStackLookup(ctxt, name, ns_uri);
1944     if (elem == NULL) {
1945     return(xsltGlobalVariableLookup(ctxt, name, ns_uri));
1946     }
1947     if (elem-&gt;computed == 0) {
1948 #ifdef WITH_XSLT_DEBUG_VARIABLE
1949     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1950                  &quot;uncomputed variable %s\n&quot;, name));
1951 #endif
1952         elem-&gt;value = xsltEvalVariable(ctxt, elem, NULL);
1953     elem-&gt;computed = 1;
1954     }
1955     if (elem-&gt;value != NULL)
1956     return(xmlXPathObjectCopy(elem-&gt;value));
1957 #ifdef WITH_XSLT_DEBUG_VARIABLE
1958     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
1959              &quot;variable not found %s\n&quot;, name));
1960 #endif
1961     return(NULL);
1962 }
1963 
1964 /**
1965  * xsltParseStylesheetCallerParam:
1966  * @ctxt:  the XSLT transformation context
1967  * @inst:  the xsl:with-param instruction element
1968  *
1969  * Processes an xsl:with-param instruction at transformation time.
1970  * The value is compute, but not recorded.
1971  * NOTE that this is also called with an *xsl:param* element
1972  * from exsltFuncFunctionFunction().
1973  *
1974  * Returns the new xsltStackElemPtr or NULL
1975  */
1976 
1977 xsltStackElemPtr
1978 xsltParseStylesheetCallerParam(xsltTransformContextPtr ctxt, xmlNodePtr inst)
1979 {
1980 #ifdef XSLT_REFACTORED
1981     xsltStyleBasicItemVariablePtr comp;
1982 #else
1983     xsltStylePreCompPtr comp;
1984 #endif
1985     xmlNodePtr tree = NULL; /* The first child node of the instruction or
1986                                the instruction itself. */
1987     xsltStackElemPtr param = NULL;
1988 
1989     if ((ctxt == NULL) || (inst == NULL) || (inst-&gt;type != XML_ELEMENT_NODE))
1990     return(NULL);
1991 
1992 #ifdef XSLT_REFACTORED
1993     comp = (xsltStyleBasicItemVariablePtr) inst-&gt;psvi;
1994 #else
1995     comp = (xsltStylePreCompPtr) inst-&gt;psvi;
1996 #endif
1997 
1998     if (comp == NULL) {
1999         xsltTransformError(ctxt, NULL, inst,
2000         &quot;Internal error in xsltParseStylesheetCallerParam(): &quot;
2001         &quot;The XSLT &#39;with-param&#39; instruction was not compiled.\n&quot;);
2002         return(NULL);
2003     }
2004     if (comp-&gt;name == NULL) {
2005     xsltTransformError(ctxt, NULL, inst,
2006         &quot;Internal error in xsltParseStylesheetCallerParam(): &quot;
2007         &quot;XSLT &#39;with-param&#39;: The attribute &#39;name&#39; was not compiled.\n&quot;);
2008     return(NULL);
2009     }
2010 
2011 #ifdef WITH_XSLT_DEBUG_VARIABLE
2012     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2013         &quot;Handling xsl:with-param %s\n&quot;, comp-&gt;name));
2014 #endif
2015 
2016     if (comp-&gt;select == NULL) {
2017     tree = inst-&gt;children;
2018     } else {
2019 #ifdef WITH_XSLT_DEBUG_VARIABLE
2020     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2021         &quot;        select %s\n&quot;, comp-&gt;select));
2022 #endif
2023     tree = inst;
2024     }
2025 
2026     param = xsltBuildVariable(ctxt, (xsltStylePreCompPtr) comp, tree);
2027 
2028     return(param);
2029 }
2030 
2031 /**
2032  * xsltParseGlobalVariable:
2033  * @style:  the XSLT stylesheet
2034  * @cur:  the &quot;variable&quot; element
2035  *
2036  * Parses a global XSLT &#39;variable&#39; declaration at compilation time
2037  * and registers it
2038  */
2039 void
2040 xsltParseGlobalVariable(xsltStylesheetPtr style, xmlNodePtr cur)
2041 {
2042 #ifdef XSLT_REFACTORED
2043     xsltStyleItemVariablePtr comp;
2044 #else
2045     xsltStylePreCompPtr comp;
2046 #endif
2047 
2048     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
2049     return;
2050 
2051 #ifdef XSLT_REFACTORED
2052     /*
2053     * Note that xsltStylePreCompute() will be called from
2054     * xslt.c only.
2055     */
2056     comp = (xsltStyleItemVariablePtr) cur-&gt;psvi;
2057 #else
2058     xsltStylePreCompute(style, cur);
2059     comp = (xsltStylePreCompPtr) cur-&gt;psvi;
2060 #endif
2061     if (comp == NULL) {
2062     xsltTransformError(NULL, style, cur,
2063          &quot;xsl:variable : compilation failed\n&quot;);
2064     return;
2065     }
2066 
2067     if (comp-&gt;name == NULL) {
2068     xsltTransformError(NULL, style, cur,
2069         &quot;xsl:variable : missing name attribute\n&quot;);
2070     return;
2071     }
2072 
2073     /*
2074     * Parse the content (a sequence constructor) of xsl:variable.
2075     */
2076     if (cur-&gt;children != NULL) {
2077 #ifdef XSLT_REFACTORED
2078         xsltParseSequenceConstructor(XSLT_CCTXT(style), cur-&gt;children);
2079 #else
2080         xsltParseTemplateContent(style, cur);
2081 #endif
2082     }
2083 #ifdef WITH_XSLT_DEBUG_VARIABLE
2084     xsltGenericDebug(xsltGenericDebugContext,
2085     &quot;Registering global variable %s\n&quot;, comp-&gt;name);
2086 #endif
2087 
2088     xsltRegisterGlobalVariable(style, comp-&gt;name, comp-&gt;ns,
2089     comp-&gt;select, cur-&gt;children, (xsltStylePreCompPtr) comp,
2090     NULL);
2091 }
2092 
2093 /**
2094  * xsltParseGlobalParam:
2095  * @style:  the XSLT stylesheet
2096  * @cur:  the &quot;param&quot; element
2097  *
2098  * parse an XSLT transformation param declaration and record
2099  * its value.
2100  */
2101 
2102 void
2103 xsltParseGlobalParam(xsltStylesheetPtr style, xmlNodePtr cur) {
2104 #ifdef XSLT_REFACTORED
2105     xsltStyleItemParamPtr comp;
2106 #else
2107     xsltStylePreCompPtr comp;
2108 #endif
2109 
2110     if ((cur == NULL) || (style == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
2111     return;
2112 
2113 #ifdef XSLT_REFACTORED
2114     /*
2115     * Note that xsltStylePreCompute() will be called from
2116     * xslt.c only.
2117     */
2118     comp = (xsltStyleItemParamPtr) cur-&gt;psvi;
2119 #else
2120     xsltStylePreCompute(style, cur);
2121     comp = (xsltStylePreCompPtr) cur-&gt;psvi;
2122 #endif
2123     if (comp == NULL) {
2124     xsltTransformError(NULL, style, cur,
2125          &quot;xsl:param : compilation failed\n&quot;);
2126     return;
2127     }
2128 
2129     if (comp-&gt;name == NULL) {
2130     xsltTransformError(NULL, style, cur,
2131         &quot;xsl:param : missing name attribute\n&quot;);
2132     return;
2133     }
2134 
2135     /*
2136     * Parse the content (a sequence constructor) of xsl:param.
2137     */
2138     if (cur-&gt;children != NULL) {
2139 #ifdef XSLT_REFACTORED
2140         xsltParseSequenceConstructor(XSLT_CCTXT(style), cur-&gt;children);
2141 #else
2142         xsltParseTemplateContent(style, cur);
2143 #endif
2144     }
2145 
2146 #ifdef WITH_XSLT_DEBUG_VARIABLE
2147     xsltGenericDebug(xsltGenericDebugContext,
2148     &quot;Registering global param %s\n&quot;, comp-&gt;name);
2149 #endif
2150 
2151     xsltRegisterGlobalVariable(style, comp-&gt;name, comp-&gt;ns,
2152     comp-&gt;select, cur-&gt;children, (xsltStylePreCompPtr) comp,
2153     NULL);
2154 }
2155 
2156 /**
2157  * xsltParseStylesheetVariable:
2158  * @ctxt:  the XSLT transformation context
2159  * @inst:  the xsl:variable instruction element
2160  *
2161  * Registers a local XSLT &#39;variable&#39; instruction at transformation time
2162  * and evaluates its value.
2163  */
2164 void
2165 xsltParseStylesheetVariable(xsltTransformContextPtr ctxt, xmlNodePtr inst)
2166 {
2167 #ifdef XSLT_REFACTORED
2168     xsltStyleItemVariablePtr comp;
2169 #else
2170     xsltStylePreCompPtr comp;
2171 #endif
2172 
2173     if ((inst == NULL) || (ctxt == NULL) || (inst-&gt;type != XML_ELEMENT_NODE))
2174     return;
2175 
2176     comp = inst-&gt;psvi;
2177     if (comp == NULL) {
2178         xsltTransformError(ctxt, NULL, inst,
2179         &quot;Internal error in xsltParseStylesheetVariable(): &quot;
2180         &quot;The XSLT &#39;variable&#39; instruction was not compiled.\n&quot;);
2181         return;
2182     }
2183     if (comp-&gt;name == NULL) {
2184     xsltTransformError(ctxt, NULL, inst,
2185         &quot;Internal error in xsltParseStylesheetVariable(): &quot;
2186         &quot;The attribute &#39;name&#39; was not compiled.\n&quot;);
2187     return;
2188     }
2189 
2190 #ifdef WITH_XSLT_DEBUG_VARIABLE
2191     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2192     &quot;Registering variable &#39;%s&#39;\n&quot;, comp-&gt;name));
2193 #endif
2194 
2195     xsltRegisterVariable(ctxt, (xsltStylePreCompPtr) comp, inst-&gt;children, 0);
2196 }
2197 
2198 /**
2199  * xsltParseStylesheetParam:
2200  * @ctxt:  the XSLT transformation context
2201  * @cur:  the XSLT &#39;param&#39; element
2202  *
2203  * Registers a local XSLT &#39;param&#39; declaration at transformation time and
2204  * evaluates its value.
2205  */
2206 void
2207 xsltParseStylesheetParam(xsltTransformContextPtr ctxt, xmlNodePtr cur)
2208 {
2209 #ifdef XSLT_REFACTORED
2210     xsltStyleItemParamPtr comp;
2211 #else
2212     xsltStylePreCompPtr comp;
2213 #endif
2214 
2215     if ((cur == NULL) || (ctxt == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
2216     return;
2217 
2218     comp = cur-&gt;psvi;
2219     if ((comp == NULL) || (comp-&gt;name == NULL)) {
2220     xsltTransformError(ctxt, NULL, cur,
2221         &quot;Internal error in xsltParseStylesheetParam(): &quot;
2222         &quot;The XSLT &#39;param&#39; declaration was not compiled correctly.\n&quot;);
2223     return;
2224     }
2225 
2226 #ifdef WITH_XSLT_DEBUG_VARIABLE
2227     XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2228     &quot;Registering param %s\n&quot;, comp-&gt;name));
2229 #endif
2230 
2231     xsltRegisterVariable(ctxt, (xsltStylePreCompPtr) comp, cur-&gt;children, 1);
2232 }
2233 
2234 /**
2235  * xsltFreeGlobalVariables:
2236  * @ctxt:  the XSLT transformation context
2237  *
2238  * Free up the data associated to the global variables
2239  * its value.
2240  */
2241 
2242 void
2243 xsltFreeGlobalVariables(xsltTransformContextPtr ctxt) {
2244     xmlHashFree(ctxt-&gt;globalVars, xsltFreeStackElemEntry);
2245 }
2246 
2247 /**
2248  * xsltXPathVariableLookup:
2249  * @ctxt:  a void * but the the XSLT transformation context actually
2250  * @name:  the variable name
2251  * @ns_uri:  the variable namespace URI
2252  *
2253  * This is the entry point when a varibale is needed by the XPath
2254  * interpretor.
2255  *
2256  * Returns the value or NULL if not found
2257  */
2258 xmlXPathObjectPtr
2259 xsltXPathVariableLookup(void *ctxt, const xmlChar *name,
2260                     const xmlChar *ns_uri) {
2261     xsltTransformContextPtr tctxt;
2262     xmlXPathObjectPtr valueObj = NULL;
2263 
2264     if ((ctxt == NULL) || (name == NULL))
2265     return(NULL);
2266 
2267 #ifdef WITH_XSLT_DEBUG_VARIABLE
2268     XSLT_TRACE(((xsltTransformContextPtr)ctxt),XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2269         &quot;Lookup variable &#39;%s&#39;\n&quot;, name));
2270 #endif
2271 
2272     tctxt = (xsltTransformContextPtr) ctxt;
2273     /*
2274     * Local variables/params ---------------------------------------------
2275     *
2276     * Do the lookup from the top of the stack, but
2277     * don&#39;t use params being computed in a call-param
2278     * First lookup expects the variable name and URI to
2279     * come from the disctionnary and hence pointer comparison.
2280     */
2281     if (tctxt-&gt;varsNr != 0) {
2282     int i;
2283     xsltStackElemPtr variable = NULL, cur;
2284 
2285     for (i = tctxt-&gt;varsNr; i &gt; tctxt-&gt;varsBase; i--) {
2286         cur = tctxt-&gt;varsTab[i-1];
2287         if ((cur-&gt;name == name) &amp;&amp; (cur-&gt;nameURI == ns_uri)) {
2288 #if 0
2289         stack_addr++;
2290 #endif
2291         variable = cur;
2292         goto local_variable_found;
2293         }
2294         cur = cur-&gt;next;
2295     }
2296     /*
2297     * Redo the lookup with interned strings to avoid string comparison.
2298     *
2299     * OPTIMIZE TODO: The problem here is, that if we request a
2300     *  global variable, then this will be also executed.
2301     */
2302     {
2303         const xmlChar *tmpName = name, *tmpNsName = ns_uri;
2304 
2305         name = xmlDictLookup(tctxt-&gt;dict, name, -1);
2306         if (ns_uri)
2307         ns_uri = xmlDictLookup(tctxt-&gt;dict, ns_uri, -1);
2308         if ((tmpName != name) || (tmpNsName != ns_uri)) {
2309         for (i = tctxt-&gt;varsNr; i &gt; tctxt-&gt;varsBase; i--) {
2310             cur = tctxt-&gt;varsTab[i-1];
2311             if ((cur-&gt;name == name) &amp;&amp; (cur-&gt;nameURI == ns_uri)) {
2312 #if 0
2313             stack_cmp++;
2314 #endif
2315             variable = cur;
2316             goto local_variable_found;
2317             }
2318         }
2319         }
2320     }
2321 
2322 local_variable_found:
2323 
2324     if (variable) {
2325         if (variable-&gt;computed == 0) {
2326 
2327 #ifdef WITH_XSLT_DEBUG_VARIABLE
2328         XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2329             &quot;uncomputed variable &#39;%s&#39;\n&quot;, name));
2330 #endif
2331         variable-&gt;value = xsltEvalVariable(tctxt, variable, NULL);
2332         variable-&gt;computed = 1;
2333         }
2334         if (variable-&gt;value != NULL) {
2335         valueObj = xmlXPathObjectCopy(variable-&gt;value);
2336         }
2337         return(valueObj);
2338     }
2339     }
2340     /*
2341     * Global variables/params --------------------------------------------
2342     */
2343     if (tctxt-&gt;globalVars) {
2344     valueObj = xsltGlobalVariableLookup(tctxt, name, ns_uri);
2345     }
2346 
2347     if (valueObj == NULL) {
2348 
2349 #ifdef WITH_XSLT_DEBUG_VARIABLE
2350     XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2351              &quot;variable not found &#39;%s&#39;\n&quot;, name));
2352 #endif
2353 
2354     if (ns_uri) {
2355         xsltTransformError(tctxt, NULL, tctxt-&gt;inst,
2356         &quot;Variable &#39;{%s}%s&#39; has not been declared.\n&quot;, ns_uri, name);
2357     } else {
2358         xsltTransformError(tctxt, NULL, tctxt-&gt;inst,
2359         &quot;Variable &#39;%s&#39; has not been declared.\n&quot;, name);
2360     }
2361     } else {
2362 
2363 #ifdef WITH_XSLT_DEBUG_VARIABLE
2364     XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,
2365         &quot;found variable &#39;%s&#39;\n&quot;, name));
2366 #endif
2367     }
2368 
2369     return(valueObj);
2370 }
2371 
2372 
    </pre>
  </body>
</html>