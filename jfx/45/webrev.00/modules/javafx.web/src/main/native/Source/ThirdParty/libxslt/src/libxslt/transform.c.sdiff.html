<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/transform.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="templates.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="variables.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/transform.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 215 xsltTemplateParamsCleanup(xsltTransformContextPtr ctxt)
 216 {
 217     xsltStackElemPtr param;
 218 
 219     for (; ctxt-&gt;varsNr &gt; ctxt-&gt;varsBase; ctxt-&gt;varsNr--) {
 220     param = ctxt-&gt;varsTab[ctxt-&gt;varsNr -1];
 221     /*
 222     * Free xsl:param items.
 223     * xsl:with-param items will have a level of -1 or -2.
 224     */
 225     if (param-&gt;level &gt;= 0) {
 226         xsltFreeStackElemList(param);
 227     }
 228     }
 229     if (ctxt-&gt;varsNr &gt; 0)
 230         ctxt-&gt;vars = ctxt-&gt;varsTab[ctxt-&gt;varsNr - 1];
 231     else
 232         ctxt-&gt;vars = NULL;
 233 }
 234 


 235 /**
 236  * profPush:
 237  * @ctxt: the transformation context
 238  * @value:  the profiling value to push on the stack
 239  *
 240  * Push a profiling value on the stack
 241  *
 242  * Returns the new index in the stack or 0 in case of error
 243  */
 244 static int
 245 profPush(xsltTransformContextPtr ctxt, long value)
 246 {
 247     if (ctxt-&gt;profMax == 0) {
 248         ctxt-&gt;profMax = 4;
 249         ctxt-&gt;profTab =
 250             (long *) xmlMalloc(ctxt-&gt;profMax * sizeof(ctxt-&gt;profTab[0]));
 251         if (ctxt-&gt;profTab == NULL) {
 252             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 253             return (0);
 254         }
</pre>
<hr />
<pre>
 323         if (templ-&gt;templCalledTab == NULL || templ-&gt;templCountTab == NULL) {
 324             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 325             return;
 326         }
 327     }
 328 
 329     for (i = 0; i &lt; templ-&gt;templNr; i++) {
 330         if (templ-&gt;templCalledTab[i] == parent) {
 331             templ-&gt;templCountTab[i]++;
 332             break;
 333         }
 334     }
 335     if (i == templ-&gt;templNr) {
 336         /* not found, add new one */
 337         templ-&gt;templCalledTab[templ-&gt;templNr] = parent;
 338         templ-&gt;templCountTab[templ-&gt;templNr] = 1;
 339         templ-&gt;templNr++;
 340     }
 341 }
 342 


 343 /**
 344  * xsltPreCompEval:
 345  * @ctxt: transform context
 346  * @node: context node
 347  * @comp: precompiled expression
 348  *
 349  * Evaluate a precompiled XPath expression.
 350  */
 351 static xmlXPathObjectPtr
 352 xsltPreCompEval(xsltTransformContextPtr ctxt, xmlNodePtr node,
 353                 xsltStylePreCompPtr comp) {
 354     xmlXPathObjectPtr res;
 355     xmlXPathContextPtr xpctxt;
 356     xmlNodePtr oldXPContextNode;
 357     xmlNsPtr *oldXPNamespaces;
 358     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
 359 
 360     xpctxt = ctxt-&gt;xpathCtxt;
 361     oldXPContextNode = xpctxt-&gt;node;
 362     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
</pre>
<hr />
<pre>
1073     /*
1074     * TODO: DO we want to use this also for &quot;text&quot; output?
1075     */
1076         copy = xmlNewTextLen(NULL, 0);
1077     if (copy == NULL)
1078         goto exit;
1079     if (cur-&gt;name == xmlStringTextNoenc)
1080         copy-&gt;name = xmlStringTextNoenc;
1081 
1082     /*
1083      * Must confirm that content is in dict (bug 302821)
1084      * TODO: This check should be not needed for text coming
1085      * from the stylesheets
1086      */
1087     if (xmlDictOwns(ctxt-&gt;dict, cur-&gt;content))
1088         copy-&gt;content = cur-&gt;content;
1089     else {
1090         if ((copy-&gt;content = xmlStrdup(cur-&gt;content)) == NULL)
1091         return NULL;
1092     }


1093     } else {
1094         /*
1095      * normal processing. keep counters to extend the text node
1096      * in xsltAddTextString if needed.
1097      */
1098         unsigned int len;
1099 
1100     len = xmlStrlen(cur-&gt;content);
1101     copy = xmlNewTextLen(cur-&gt;content, len);
1102     if (copy == NULL)
1103         goto exit;
1104     if (cur-&gt;name == xmlStringTextNoenc)
1105         copy-&gt;name = xmlStringTextNoenc;
1106     ctxt-&gt;lasttext = copy-&gt;content;
1107     ctxt-&gt;lasttsize = len;
1108     ctxt-&gt;lasttuse = len;
1109     }
1110     if (copy != NULL) {
1111     if (target != NULL) {
1112         copy-&gt;doc = target-&gt;doc;
</pre>
<hr />
<pre>
2188     */
2189     ctxt-&gt;currentTemplateRule = templ;
2190 
2191 #ifdef WITH_XSLT_DEBUG_PROCESS
2192     if (contextNode-&gt;type == XML_DOCUMENT_NODE) {
2193         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2194          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for /\n&quot;,
2195                          templ-&gt;match));
2196     } else {
2197         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2198          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for %s\n&quot;,
2199                          templ-&gt;match, contextNode-&gt;name));
2200         }
2201 #endif
2202     xsltApplyXSLTTemplate(ctxt, contextNode, templ-&gt;content, templ, withParams);
2203 
2204     ctxt-&gt;currentTemplateRule = oldCurTempRule;
2205     }
2206 }
2207 

2208 static xmlNodePtr
2209 xsltDebuggerStartSequenceConstructor(xsltTransformContextPtr ctxt,
2210                      xmlNodePtr contextNode,
2211                      xmlNodePtr list,
2212                      xsltTemplatePtr templ,
2213                      int *addCallResult)
2214 {
2215     xmlNodePtr debugedNode = NULL;
2216 
2217     if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) {
2218         if (templ) {
2219             *addCallResult = xslAddCall(templ, templ-&gt;elem);
2220         } else {
2221             *addCallResult = xslAddCall(NULL, list);
2222         }
2223         switch (ctxt-&gt;debugStatus) {
2224             case XSLT_DEBUG_RUN_RESTART:
2225             case XSLT_DEBUG_QUIT:
2226                 if (*addCallResult)
2227                     xslDropCall();
2228                 return(NULL);
2229         }
2230         if (templ) {
2231             xslHandleDebugger(templ-&gt;elem, contextNode, templ, ctxt);
2232             debugedNode = templ-&gt;elem;
2233         } else if (list) {
2234             xslHandleDebugger(list, contextNode, templ, ctxt);
2235             debugedNode = list;
2236         } else if (ctxt-&gt;inst) {
2237             xslHandleDebugger(ctxt-&gt;inst, contextNode, templ, ctxt);
2238             debugedNode = ctxt-&gt;inst;
2239         }
2240     }
2241     return(debugedNode);
2242 }

2243 
2244 /**
2245  * xsltLocalVariablePush:
2246  * @ctxt: the transformation context
2247  * @variable: variable to be pushed to the variable stack
2248  * @level: new value for variable&#39;s level
2249  *
2250  * Places the variable onto the local variable stack
2251  *
2252  * Returns: 0 for success, -1 for any error
2253  * **NOTE:**
2254  * This is an internal routine and should not be called by users!
2255  */
2256 int
2257 xsltLocalVariablePush(xsltTransformContextPtr ctxt,
2258               xsltStackElemPtr variable,
2259               int level)
2260 {
2261     if (ctxt-&gt;varsMax == 0) {
2262     ctxt-&gt;varsMax = 10;
</pre>
<hr />
<pre>
2394         xsltDebug(ctxt, contextNode, list, NULL);
2395     ctxt-&gt;state = XSLT_STATE_STOPPED;
2396         return;
2397     }
2398     ctxt-&gt;depth++;
2399 
2400     oldLocalFragmentTop = ctxt-&gt;localRVT;
2401     oldInsert = insert = ctxt-&gt;insert;
2402     oldInst = oldCurInst = ctxt-&gt;inst;
2403     oldContextNode = ctxt-&gt;node;
2404     /*
2405     * Save current number of variables on the stack; new vars are popped when
2406     * exiting.
2407     */
2408     oldVarsNr = ctxt-&gt;varsNr;
2409     /*
2410     * Process the sequence constructor.
2411     */
2412     cur = list;
2413     while (cur != NULL) {











2414         ctxt-&gt;inst = cur;
2415 
2416 #ifdef WITH_DEBUGGER
2417         switch (ctxt-&gt;debugStatus) {
2418             case XSLT_DEBUG_RUN_RESTART:
2419             case XSLT_DEBUG_QUIT:
2420                 break;
2421 
2422         }
2423 #endif
2424         /*
2425          * Test; we must have a valid insertion point.
2426          */
2427         if (insert == NULL) {
2428 
2429 #ifdef WITH_XSLT_DEBUG_PROCESS
2430             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2431         &quot;xsltApplySequenceConstructor: insert == NULL !\n&quot;));
2432 #endif
2433             goto error;
</pre>
<hr />
<pre>
2850              * Flagged as an extension element
2851              */
2852             if (cur-&gt;psvi == xsltExtMarker)
2853                 function = xsltExtElementLookup(ctxt, cur-&gt;name,
2854                                                 cur-&gt;ns-&gt;href);
2855             else
2856                 function = ((xsltElemPreCompPtr) cur-&gt;psvi)-&gt;func;
2857 
2858             if (function == NULL) {
2859                 xmlNodePtr child;
2860                 int found = 0;
2861 
2862 #ifdef WITH_XSLT_DEBUG_PROCESS
2863                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2864             &quot;xsltApplySequenceConstructor: unknown extension %s\n&quot;,
2865                     cur-&gt;name));
2866 #endif
2867                 /*
2868                  * Search if there are fallbacks
2869                  */

2870                 child = cur-&gt;children;
2871                 while (child != NULL) {
2872                     if ((IS_XSLT_ELEM(child)) &amp;&amp;
2873                         (IS_XSLT_NAME(child, &quot;fallback&quot;)))
2874             {
2875                         found = 1;
2876                         xsltApplySequenceConstructor(ctxt, contextNode,
2877                 child-&gt;children, NULL);
2878                     }
2879                     child = child-&gt;next;
2880                 }

2881 
2882                 if (!found) {
2883                     xsltTransformError(ctxt, NULL, cur,
2884             &quot;xsltApplySequenceConstructor: failed to find extension %s\n&quot;,
2885             cur-&gt;name);
2886                 }
2887             } else {
2888 #ifdef WITH_XSLT_DEBUG_PROCESS
2889                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2890             &quot;xsltApplySequenceConstructor: extension construct %s\n&quot;,
2891                     cur-&gt;name));
2892 #endif
2893 
2894                 /*
2895                  * Disable the xsltCopyTextString optimization for
2896                  * extension elements. Extensions could append text using
2897                  * xmlAddChild which will free the buffer pointed to by
2898                  * &#39;lasttext&#39;. This buffer could later be reallocated with
2899                  * a different size than recorded in &#39;lasttsize&#39;. See bug
2900                  * #777432.
</pre>
<hr />
<pre>
3069 * @list:  the nodes of a sequence constructor;
3070 *         (plus leading xsl:param elements)
3071 * @templ: the compiled xsl:template declaration;
3072 *         NULL if a sequence constructor
3073 * @withParams:  a set of caller-parameters (xsl:with-param) or NULL
3074 *
3075 * Called by:
3076 * - xsltApplyImports()
3077 * - xsltCallTemplate()
3078 * - xsltDefaultProcessOneNode()
3079 * - xsltProcessOneNode()
3080 */
3081 static void
3082 xsltApplyXSLTTemplate(xsltTransformContextPtr ctxt,
3083               xmlNodePtr contextNode,
3084               xmlNodePtr list,
3085               xsltTemplatePtr templ,
3086               xsltStackElemPtr withParams)
3087 {
3088     int oldVarsBase = 0;
<span class="line-removed">3089     long start = 0;</span>
3090     xmlNodePtr cur;
3091     xsltStackElemPtr tmpParam = NULL;
3092     xmlDocPtr oldUserFragmentTop;



3093 
3094 #ifdef XSLT_REFACTORED
3095     xsltStyleItemParamPtr iparam;
3096 #else
3097     xsltStylePreCompPtr iparam;
3098 #endif
3099 
3100 #ifdef WITH_DEBUGGER
3101     int addCallResult = 0;
3102 #endif
3103 
3104     if (ctxt == NULL)
3105     return;
3106     if (templ == NULL) {
3107     xsltTransformError(ctxt, NULL, list,
3108         &quot;xsltApplyXSLTTemplate: Bad arguments; @templ is mandatory.\n&quot;);
3109     return;
3110     }
3111 
3112 #ifdef WITH_DEBUGGER
</pre>
<hr />
<pre>
3127         &quot;xsltApplyXSLTTemplate: A potential infinite template recursion &quot;
3128         &quot;was detected.\n&quot;
3129         &quot;You can adjust maxTemplateVars (--maxvars) in order to &quot;
3130         &quot;raise the maximum number of variables/params (currently set to %d).\n&quot;,
3131         ctxt-&gt;maxTemplateVars);
3132         xsltDebug(ctxt, contextNode, list, NULL);
3133     ctxt-&gt;state = XSLT_STATE_STOPPED;
3134         return;
3135     }
3136 
3137     oldUserFragmentTop = ctxt-&gt;tmpRVT;
3138     ctxt-&gt;tmpRVT = NULL;
3139 
3140     /*
3141     * Initiate a distinct scope of local params/variables.
3142     */
3143     oldVarsBase = ctxt-&gt;varsBase;
3144     ctxt-&gt;varsBase = ctxt-&gt;varsNr;
3145 
3146     ctxt-&gt;node = contextNode;


3147     if (ctxt-&gt;profile) {
3148     templ-&gt;nbCalls++;
3149     start = xsltTimestamp();
3150     profPush(ctxt, 0);
3151     profCallgraphAdd(templ, ctxt-&gt;templ);
3152     }


3153     /*
3154     * Push the xsl:template declaration onto the stack.
3155     */
3156     templPush(ctxt, templ);
3157 
3158 #ifdef WITH_XSLT_DEBUG_PROCESS
3159     if (templ-&gt;name != NULL)
3160     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
3161     &quot;applying xsl:template &#39;%s&#39;\n&quot;, templ-&gt;name));
3162 #endif
3163     /*
3164     * Process xsl:param instructions and skip those elements for
3165     * further processing.
3166     */
3167     cur = list;
3168     do {
3169     if (cur-&gt;type == XML_TEXT_NODE) {
3170         cur = cur-&gt;next;
3171         continue;
3172     }
</pre>
<hr />
<pre>
3240     * Release user-created fragments stored in the scope
3241     * of xsl:template. Note that this mechanism is deprecated:
3242     * user code should now use xsltRegisterLocalRVT() instead
3243     * of the obsolete xsltRegisterTmpRVT().
3244     */
3245     if (ctxt-&gt;tmpRVT) {
3246     xmlDocPtr curdoc = ctxt-&gt;tmpRVT, tmp;
3247 
3248     while (curdoc != NULL) {
3249         tmp = curdoc;
3250         curdoc = (xmlDocPtr) curdoc-&gt;next;
3251         xsltReleaseRVT(ctxt, tmp);
3252     }
3253     }
3254     ctxt-&gt;tmpRVT = oldUserFragmentTop;
3255 
3256     /*
3257     * Pop the xsl:template declaration from the stack.
3258     */
3259     templPop(ctxt);


3260     if (ctxt-&gt;profile) {
3261     long spent, child, total, end;
3262 
3263     end = xsltTimestamp();
3264     child = profPop(ctxt);
3265     total = end - start;
3266     spent = total - child;
3267     if (spent &lt;= 0) {
3268         /*
3269         * Not possible unless the original calibration failed
3270         * we can try to correct it on the fly.
3271         */
3272         xsltCalibrateAdjust(spent);
3273         spent = 0;
3274     }
3275 
3276     templ-&gt;time += spent;
3277     if (ctxt-&gt;profNr &gt; 0)
3278         ctxt-&gt;profTab[ctxt-&gt;profNr - 1] += total;
3279     }

3280 
3281 #ifdef WITH_DEBUGGER
3282     if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp; (addCallResult)) {
3283         xslDropCall();
3284     }
3285 #endif
3286 }
3287 
3288 
3289 /**
3290  * xsltApplyOneTemplate:
3291  * @ctxt:  a XSLT process context
3292  * @contextNode:  the node in the source tree.
3293  * @list:  the nodes of a sequence constructor
3294  * @templ: not used
3295  * @params:  a set of parameters (xsl:param) or NULL
3296  *
3297  * Processes a sequence constructor on the current node in the source tree.
3298  *
3299  * @params are the already computed variable stack items; this function
</pre>
<hr />
<pre>
3417                                                  XSLT_SAXON_NAMESPACE);
3418         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;write&quot;)) {
3419 #ifdef WITH_XSLT_DEBUG_EXTRA
3420             xsltGenericDebug(xsltGenericDebugContext,
3421                              &quot;Found xalan:write extension\n&quot;);
3422 #endif
3423             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3424                                                  (const xmlChar *)
3425                                                  &quot;select&quot;,
3426                                                  XSLT_XALAN_NAMESPACE);
3427         if (URL != NULL) {
3428         xmlXPathCompExprPtr cmp;
3429         xmlChar *val;
3430 
3431         /*
3432          * Trying to handle bug #59212
3433          * The value of the &quot;select&quot; attribute is an
3434          * XPath expression.
3435          * (see http://xml.apache.org/xalan-j/extensionslib.html#redirect)
3436          */
<span class="line-modified">3437         cmp = xmlXPathCompile(URL);</span>
3438                 val = xsltEvalXPathString(ctxt, cmp);
3439         xmlXPathFreeCompExpr(cmp);
3440         xmlFree(URL);
3441         URL = val;
3442         }
3443         if (URL == NULL)
3444         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3445                              (const xmlChar *)
3446                              &quot;file&quot;,
3447                              XSLT_XALAN_NAMESPACE);
3448         if (URL == NULL)
3449         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3450                              (const xmlChar *)
3451                              &quot;href&quot;,
3452                              XSLT_XALAN_NAMESPACE);
3453         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;document&quot;)) {
3454             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3455                                                  (const xmlChar *) &quot;href&quot;,
3456                                                  NULL);
3457         }
</pre>
<hr />
<pre>
4981                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
4982                          cur-&gt;parent-&gt;name,
4983                          cur-&gt;parent-&gt;ns-&gt;href);
4984                 if (val == NULL) {
4985                 val = (const xmlChar *)
4986                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
4987                          BAD_CAST &quot;*&quot;,
4988                          cur-&gt;parent-&gt;ns-&gt;href);
4989                 }
4990             } else {
4991                 val = (const xmlChar *)
4992                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
4993                          cur-&gt;parent-&gt;name, NULL);
4994             }
4995             if ((val != NULL) &amp;&amp;
4996                 (xmlStrEqual(val, (xmlChar *) &quot;strip&quot;))) {
4997                 delNode = cur;
4998                 break;
4999             }
5000             }
<span class="line-modified">5001             /* no break on purpose */</span>
5002         case XML_ELEMENT_NODE:
5003         case XML_DOCUMENT_NODE:
5004         case XML_HTML_DOCUMENT_NODE:
5005         case XML_CDATA_SECTION_NODE:
5006         case XML_PI_NODE:
5007         case XML_COMMENT_NODE:
5008             xmlXPathNodeSetAddUnique(list, cur);
5009             break;
5010         case XML_DTD_NODE:
5011             /* Unlink the DTD, it&#39;s still reachable
5012              * using doc-&gt;intSubset */
5013             if (cur-&gt;next != NULL)
5014             cur-&gt;next-&gt;prev = cur-&gt;prev;
5015             if (cur-&gt;prev != NULL)
5016             cur-&gt;prev-&gt;next = cur-&gt;next;
5017             break;
5018         case XML_NAMESPACE_DECL:
5019             break;
5020         default:
5021 #ifdef WITH_XSLT_DEBUG_PROCESS
</pre>
<hr />
<pre>
5881      * Check for XPath document order availability
5882      */
5883     root = xmlDocGetRootElement(doc);
5884     if (root != NULL) {
5885     if (((ptrdiff_t) root-&gt;content &gt;= 0) &amp;&amp;
5886             (xslDebugStatus == XSLT_DEBUG_NONE))
5887         xmlXPathOrderDocElems(doc);
5888     }
5889 
5890     if (userCtxt != NULL)
5891     ctxt = userCtxt;
5892     else
5893     ctxt = xsltNewTransformContext(style, doc);
5894 
5895     if (ctxt == NULL)
5896         return (NULL);
5897 
5898     ctxt-&gt;initialContextDoc = doc;
5899     ctxt-&gt;initialContextNode = (xmlNodePtr) doc;
5900 
<span class="line-modified">5901     if (profile != NULL)</span>

5902         ctxt-&gt;profile = 1;







5903 
5904     if (output != NULL)
5905         ctxt-&gt;outputFile = output;
5906     else
5907         ctxt-&gt;outputFile = NULL;
5908 
5909     /*
5910      * internalize the modes if needed
5911      */
5912     if (ctxt-&gt;dict != NULL) {
5913         if (ctxt-&gt;mode != NULL)
5914         ctxt-&gt;mode = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;mode, -1);
5915         if (ctxt-&gt;modeURI != NULL)
5916         ctxt-&gt;modeURI = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;modeURI, -1);
5917     }
5918 
5919     XSLT_GET_IMPORT_PTR(method, style, method)
5920     XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
5921     XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
5922     XSLT_GET_IMPORT_PTR(version, style, version)
</pre>
<hr />
<pre>
5995         method);
5996             goto error;
5997         }
5998     } else {
5999         ctxt-&gt;type = XSLT_OUTPUT_XML;
6000         res = xmlNewDoc(style-&gt;version);
6001         if (res == NULL)
6002             goto error;
6003     res-&gt;dict = ctxt-&gt;dict;
6004     xmlDictReference(ctxt-&gt;dict);
6005 #ifdef WITH_XSLT_DEBUG
6006     xsltGenericDebug(xsltGenericDebugContext,
6007              &quot;reusing transformation dict for output\n&quot;);
6008 #endif
6009     }
6010     res-&gt;charset = XML_CHAR_ENCODING_UTF8;
6011     if (encoding != NULL)
6012         res-&gt;encoding = xmlStrdup(encoding);
6013     variables = style-&gt;variables;
6014 







6015     /*
6016      * Start the evaluation, evaluate the params, the stylesheets globals
6017      * and start by processing the top node.
6018      */
6019     if (xsltNeedElemSpaceHandling(ctxt))
6020     xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));
6021     /*
6022     * Evaluate global params and user-provided params.
6023     */
<span class="line-removed">6024     ctxt-&gt;node = (xmlNodePtr) doc;</span>
6025     if (ctxt-&gt;globalVars == NULL)
6026     ctxt-&gt;globalVars = xmlHashCreate(20);
6027     if (params != NULL) {
6028         xsltEvalUserParams(ctxt, params);
6029     }
6030 
6031     /* need to be called before evaluating global variables */
6032     xsltCountKeys(ctxt);
6033 
6034     xsltEvalGlobalVariables(ctxt);
6035 
6036     /* Clean up any unused RVTs. */
6037     xsltReleaseLocalRVTs(ctxt, NULL);
6038 
<span class="line-removed">6039     ctxt-&gt;node = (xmlNodePtr) doc;</span>
<span class="line-removed">6040     ctxt-&gt;output = res;</span>
6041     ctxt-&gt;insert = (xmlNodePtr) res;
6042     ctxt-&gt;varsBase = ctxt-&gt;varsNr - 1;
6043 
<span class="line-removed">6044     ctxt-&gt;xpathCtxt-&gt;contextSize = 1;</span>
<span class="line-removed">6045     ctxt-&gt;xpathCtxt-&gt;proximityPosition = 1;</span>
<span class="line-removed">6046     ctxt-&gt;xpathCtxt-&gt;node = NULL; /* TODO: Set the context node here? */</span>
6047     /*
6048     * Start processing the source tree -----------------------------------
6049     */
6050     xsltProcessOneNode(ctxt, ctxt-&gt;node, NULL);
6051     /*
6052     * Remove all remaining vars from the stack.
6053     */
6054     xsltLocalVariablePop(ctxt, 0, -2);
6055     xsltShutdownCtxtExts(ctxt);
6056 
6057     xsltCleanupTemplates(style); /* TODO: &lt;- style should be read only */
6058 
6059     /*
6060      * Now cleanup our variables so stylesheet can be re-used
6061      *
6062      * TODO: this is not needed anymore global variables are copied
6063      *       and not evaluated directly anymore, keep this as a check
6064      */
6065     if (style-&gt;variables != variables) {
6066         vptr = style-&gt;variables;
</pre>
<hr />
<pre>
6156            possible comment nodes */
6157         node = res-&gt;children;
6158         last = res-&gt;last;
6159         res-&gt;children = NULL;
6160         res-&gt;last = NULL;
6161                 res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
6162                                                     doctypePublic,
6163                                                     doctypeSystem);
6164         if (res-&gt;children != NULL) {
6165             res-&gt;children-&gt;next = node;
6166             node-&gt;prev = res-&gt;children;
6167             res-&gt;last = last;
6168         } else {
6169             res-&gt;children = node;
6170             res-&gt;last = last;
6171         }
6172         }
6173         }
6174     }
6175     xmlXPathFreeNodeSet(ctxt-&gt;nodeList);


6176     if (profile != NULL) {
6177         xsltSaveProfiling(ctxt, profile);
6178     }

6179 
6180     /*
6181      * Be pedantic.
6182      */
6183     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;state != XSLT_STATE_OK)) {
6184     xmlFreeDoc(res);
6185     res = NULL;
6186     }
6187     if ((res != NULL) &amp;&amp; (ctxt != NULL) &amp;&amp; (output != NULL)) {
6188     int ret;
6189 
6190     ret = xsltCheckWrite(ctxt-&gt;sec, ctxt, (const xmlChar *) output);
6191     if (ret == 0) {
6192         xsltTransformError(ctxt, NULL, NULL,
6193              &quot;xsltApplyStylesheet: forbidden to save to %s\n&quot;,
6194                    output);
6195     } else if (ret &lt; 0) {
6196         xsltTransformError(ctxt, NULL, NULL,
6197              &quot;xsltApplyStylesheet: saving to %s may not be possible\n&quot;,
6198                    output);
</pre>
</td>
<td>
<hr />
<pre>
 215 xsltTemplateParamsCleanup(xsltTransformContextPtr ctxt)
 216 {
 217     xsltStackElemPtr param;
 218 
 219     for (; ctxt-&gt;varsNr &gt; ctxt-&gt;varsBase; ctxt-&gt;varsNr--) {
 220     param = ctxt-&gt;varsTab[ctxt-&gt;varsNr -1];
 221     /*
 222     * Free xsl:param items.
 223     * xsl:with-param items will have a level of -1 or -2.
 224     */
 225     if (param-&gt;level &gt;= 0) {
 226         xsltFreeStackElemList(param);
 227     }
 228     }
 229     if (ctxt-&gt;varsNr &gt; 0)
 230         ctxt-&gt;vars = ctxt-&gt;varsTab[ctxt-&gt;varsNr - 1];
 231     else
 232         ctxt-&gt;vars = NULL;
 233 }
 234 
<span class="line-added"> 235 #ifdef WITH_PROFILER</span>
<span class="line-added"> 236 </span>
 237 /**
 238  * profPush:
 239  * @ctxt: the transformation context
 240  * @value:  the profiling value to push on the stack
 241  *
 242  * Push a profiling value on the stack
 243  *
 244  * Returns the new index in the stack or 0 in case of error
 245  */
 246 static int
 247 profPush(xsltTransformContextPtr ctxt, long value)
 248 {
 249     if (ctxt-&gt;profMax == 0) {
 250         ctxt-&gt;profMax = 4;
 251         ctxt-&gt;profTab =
 252             (long *) xmlMalloc(ctxt-&gt;profMax * sizeof(ctxt-&gt;profTab[0]));
 253         if (ctxt-&gt;profTab == NULL) {
 254             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 255             return (0);
 256         }
</pre>
<hr />
<pre>
 325         if (templ-&gt;templCalledTab == NULL || templ-&gt;templCountTab == NULL) {
 326             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 327             return;
 328         }
 329     }
 330 
 331     for (i = 0; i &lt; templ-&gt;templNr; i++) {
 332         if (templ-&gt;templCalledTab[i] == parent) {
 333             templ-&gt;templCountTab[i]++;
 334             break;
 335         }
 336     }
 337     if (i == templ-&gt;templNr) {
 338         /* not found, add new one */
 339         templ-&gt;templCalledTab[templ-&gt;templNr] = parent;
 340         templ-&gt;templCountTab[templ-&gt;templNr] = 1;
 341         templ-&gt;templNr++;
 342     }
 343 }
 344 
<span class="line-added"> 345 #endif /* WITH_PROFILER */</span>
<span class="line-added"> 346 </span>
 347 /**
 348  * xsltPreCompEval:
 349  * @ctxt: transform context
 350  * @node: context node
 351  * @comp: precompiled expression
 352  *
 353  * Evaluate a precompiled XPath expression.
 354  */
 355 static xmlXPathObjectPtr
 356 xsltPreCompEval(xsltTransformContextPtr ctxt, xmlNodePtr node,
 357                 xsltStylePreCompPtr comp) {
 358     xmlXPathObjectPtr res;
 359     xmlXPathContextPtr xpctxt;
 360     xmlNodePtr oldXPContextNode;
 361     xmlNsPtr *oldXPNamespaces;
 362     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
 363 
 364     xpctxt = ctxt-&gt;xpathCtxt;
 365     oldXPContextNode = xpctxt-&gt;node;
 366     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
</pre>
<hr />
<pre>
1077     /*
1078     * TODO: DO we want to use this also for &quot;text&quot; output?
1079     */
1080         copy = xmlNewTextLen(NULL, 0);
1081     if (copy == NULL)
1082         goto exit;
1083     if (cur-&gt;name == xmlStringTextNoenc)
1084         copy-&gt;name = xmlStringTextNoenc;
1085 
1086     /*
1087      * Must confirm that content is in dict (bug 302821)
1088      * TODO: This check should be not needed for text coming
1089      * from the stylesheets
1090      */
1091     if (xmlDictOwns(ctxt-&gt;dict, cur-&gt;content))
1092         copy-&gt;content = cur-&gt;content;
1093     else {
1094         if ((copy-&gt;content = xmlStrdup(cur-&gt;content)) == NULL)
1095         return NULL;
1096     }
<span class="line-added">1097 </span>
<span class="line-added">1098     ctxt-&gt;lasttext = NULL;</span>
1099     } else {
1100         /*
1101      * normal processing. keep counters to extend the text node
1102      * in xsltAddTextString if needed.
1103      */
1104         unsigned int len;
1105 
1106     len = xmlStrlen(cur-&gt;content);
1107     copy = xmlNewTextLen(cur-&gt;content, len);
1108     if (copy == NULL)
1109         goto exit;
1110     if (cur-&gt;name == xmlStringTextNoenc)
1111         copy-&gt;name = xmlStringTextNoenc;
1112     ctxt-&gt;lasttext = copy-&gt;content;
1113     ctxt-&gt;lasttsize = len;
1114     ctxt-&gt;lasttuse = len;
1115     }
1116     if (copy != NULL) {
1117     if (target != NULL) {
1118         copy-&gt;doc = target-&gt;doc;
</pre>
<hr />
<pre>
2194     */
2195     ctxt-&gt;currentTemplateRule = templ;
2196 
2197 #ifdef WITH_XSLT_DEBUG_PROCESS
2198     if (contextNode-&gt;type == XML_DOCUMENT_NODE) {
2199         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2200          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for /\n&quot;,
2201                          templ-&gt;match));
2202     } else {
2203         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2204          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for %s\n&quot;,
2205                          templ-&gt;match, contextNode-&gt;name));
2206         }
2207 #endif
2208     xsltApplyXSLTTemplate(ctxt, contextNode, templ-&gt;content, templ, withParams);
2209 
2210     ctxt-&gt;currentTemplateRule = oldCurTempRule;
2211     }
2212 }
2213 
<span class="line-added">2214 #ifdef WITH_DEBUGGER</span>
2215 static xmlNodePtr
2216 xsltDebuggerStartSequenceConstructor(xsltTransformContextPtr ctxt,
2217                      xmlNodePtr contextNode,
2218                      xmlNodePtr list,
2219                      xsltTemplatePtr templ,
2220                      int *addCallResult)
2221 {
2222     xmlNodePtr debugedNode = NULL;
2223 
2224     if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) {
2225         if (templ) {
2226             *addCallResult = xslAddCall(templ, templ-&gt;elem);
2227         } else {
2228             *addCallResult = xslAddCall(NULL, list);
2229         }
2230         switch (ctxt-&gt;debugStatus) {
2231             case XSLT_DEBUG_RUN_RESTART:
2232             case XSLT_DEBUG_QUIT:
2233                 if (*addCallResult)
2234                     xslDropCall();
2235                 return(NULL);
2236         }
2237         if (templ) {
2238             xslHandleDebugger(templ-&gt;elem, contextNode, templ, ctxt);
2239             debugedNode = templ-&gt;elem;
2240         } else if (list) {
2241             xslHandleDebugger(list, contextNode, templ, ctxt);
2242             debugedNode = list;
2243         } else if (ctxt-&gt;inst) {
2244             xslHandleDebugger(ctxt-&gt;inst, contextNode, templ, ctxt);
2245             debugedNode = ctxt-&gt;inst;
2246         }
2247     }
2248     return(debugedNode);
2249 }
<span class="line-added">2250 #endif /* WITH_DEBUGGER */</span>
2251 
2252 /**
2253  * xsltLocalVariablePush:
2254  * @ctxt: the transformation context
2255  * @variable: variable to be pushed to the variable stack
2256  * @level: new value for variable&#39;s level
2257  *
2258  * Places the variable onto the local variable stack
2259  *
2260  * Returns: 0 for success, -1 for any error
2261  * **NOTE:**
2262  * This is an internal routine and should not be called by users!
2263  */
2264 int
2265 xsltLocalVariablePush(xsltTransformContextPtr ctxt,
2266               xsltStackElemPtr variable,
2267               int level)
2268 {
2269     if (ctxt-&gt;varsMax == 0) {
2270     ctxt-&gt;varsMax = 10;
</pre>
<hr />
<pre>
2402         xsltDebug(ctxt, contextNode, list, NULL);
2403     ctxt-&gt;state = XSLT_STATE_STOPPED;
2404         return;
2405     }
2406     ctxt-&gt;depth++;
2407 
2408     oldLocalFragmentTop = ctxt-&gt;localRVT;
2409     oldInsert = insert = ctxt-&gt;insert;
2410     oldInst = oldCurInst = ctxt-&gt;inst;
2411     oldContextNode = ctxt-&gt;node;
2412     /*
2413     * Save current number of variables on the stack; new vars are popped when
2414     * exiting.
2415     */
2416     oldVarsNr = ctxt-&gt;varsNr;
2417     /*
2418     * Process the sequence constructor.
2419     */
2420     cur = list;
2421     while (cur != NULL) {
<span class="line-added">2422         if (ctxt-&gt;opLimit != 0) {</span>
<span class="line-added">2423             if (ctxt-&gt;opCount &gt;= ctxt-&gt;opLimit) {</span>
<span class="line-added">2424         xsltTransformError(ctxt, NULL, cur,</span>
<span class="line-added">2425             &quot;xsltApplySequenceConstructor: &quot;</span>
<span class="line-added">2426                     &quot;Operation limit exceeded\n&quot;);</span>
<span class="line-added">2427             ctxt-&gt;state = XSLT_STATE_STOPPED;</span>
<span class="line-added">2428                 goto error;</span>
<span class="line-added">2429             }</span>
<span class="line-added">2430             ctxt-&gt;opCount += 1;</span>
<span class="line-added">2431         }</span>
<span class="line-added">2432 </span>
2433         ctxt-&gt;inst = cur;
2434 
2435 #ifdef WITH_DEBUGGER
2436         switch (ctxt-&gt;debugStatus) {
2437             case XSLT_DEBUG_RUN_RESTART:
2438             case XSLT_DEBUG_QUIT:
2439                 break;
2440 
2441         }
2442 #endif
2443         /*
2444          * Test; we must have a valid insertion point.
2445          */
2446         if (insert == NULL) {
2447 
2448 #ifdef WITH_XSLT_DEBUG_PROCESS
2449             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2450         &quot;xsltApplySequenceConstructor: insert == NULL !\n&quot;));
2451 #endif
2452             goto error;
</pre>
<hr />
<pre>
2869              * Flagged as an extension element
2870              */
2871             if (cur-&gt;psvi == xsltExtMarker)
2872                 function = xsltExtElementLookup(ctxt, cur-&gt;name,
2873                                                 cur-&gt;ns-&gt;href);
2874             else
2875                 function = ((xsltElemPreCompPtr) cur-&gt;psvi)-&gt;func;
2876 
2877             if (function == NULL) {
2878                 xmlNodePtr child;
2879                 int found = 0;
2880 
2881 #ifdef WITH_XSLT_DEBUG_PROCESS
2882                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2883             &quot;xsltApplySequenceConstructor: unknown extension %s\n&quot;,
2884                     cur-&gt;name));
2885 #endif
2886                 /*
2887                  * Search if there are fallbacks
2888                  */
<span class="line-added">2889                 ctxt-&gt;insert = insert;</span>
2890                 child = cur-&gt;children;
2891                 while (child != NULL) {
2892                     if ((IS_XSLT_ELEM(child)) &amp;&amp;
2893                         (IS_XSLT_NAME(child, &quot;fallback&quot;)))
2894             {
2895                         found = 1;
2896                         xsltApplySequenceConstructor(ctxt, contextNode,
2897                 child-&gt;children, NULL);
2898                     }
2899                     child = child-&gt;next;
2900                 }
<span class="line-added">2901                 ctxt-&gt;insert = oldInsert;</span>
2902 
2903                 if (!found) {
2904                     xsltTransformError(ctxt, NULL, cur,
2905             &quot;xsltApplySequenceConstructor: failed to find extension %s\n&quot;,
2906             cur-&gt;name);
2907                 }
2908             } else {
2909 #ifdef WITH_XSLT_DEBUG_PROCESS
2910                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2911             &quot;xsltApplySequenceConstructor: extension construct %s\n&quot;,
2912                     cur-&gt;name));
2913 #endif
2914 
2915                 /*
2916                  * Disable the xsltCopyTextString optimization for
2917                  * extension elements. Extensions could append text using
2918                  * xmlAddChild which will free the buffer pointed to by
2919                  * &#39;lasttext&#39;. This buffer could later be reallocated with
2920                  * a different size than recorded in &#39;lasttsize&#39;. See bug
2921                  * #777432.
</pre>
<hr />
<pre>
3090 * @list:  the nodes of a sequence constructor;
3091 *         (plus leading xsl:param elements)
3092 * @templ: the compiled xsl:template declaration;
3093 *         NULL if a sequence constructor
3094 * @withParams:  a set of caller-parameters (xsl:with-param) or NULL
3095 *
3096 * Called by:
3097 * - xsltApplyImports()
3098 * - xsltCallTemplate()
3099 * - xsltDefaultProcessOneNode()
3100 * - xsltProcessOneNode()
3101 */
3102 static void
3103 xsltApplyXSLTTemplate(xsltTransformContextPtr ctxt,
3104               xmlNodePtr contextNode,
3105               xmlNodePtr list,
3106               xsltTemplatePtr templ,
3107               xsltStackElemPtr withParams)
3108 {
3109     int oldVarsBase = 0;

3110     xmlNodePtr cur;
3111     xsltStackElemPtr tmpParam = NULL;
3112     xmlDocPtr oldUserFragmentTop;
<span class="line-added">3113 #ifdef WITH_PROFILER</span>
<span class="line-added">3114     long start = 0;</span>
<span class="line-added">3115 #endif</span>
3116 
3117 #ifdef XSLT_REFACTORED
3118     xsltStyleItemParamPtr iparam;
3119 #else
3120     xsltStylePreCompPtr iparam;
3121 #endif
3122 
3123 #ifdef WITH_DEBUGGER
3124     int addCallResult = 0;
3125 #endif
3126 
3127     if (ctxt == NULL)
3128     return;
3129     if (templ == NULL) {
3130     xsltTransformError(ctxt, NULL, list,
3131         &quot;xsltApplyXSLTTemplate: Bad arguments; @templ is mandatory.\n&quot;);
3132     return;
3133     }
3134 
3135 #ifdef WITH_DEBUGGER
</pre>
<hr />
<pre>
3150         &quot;xsltApplyXSLTTemplate: A potential infinite template recursion &quot;
3151         &quot;was detected.\n&quot;
3152         &quot;You can adjust maxTemplateVars (--maxvars) in order to &quot;
3153         &quot;raise the maximum number of variables/params (currently set to %d).\n&quot;,
3154         ctxt-&gt;maxTemplateVars);
3155         xsltDebug(ctxt, contextNode, list, NULL);
3156     ctxt-&gt;state = XSLT_STATE_STOPPED;
3157         return;
3158     }
3159 
3160     oldUserFragmentTop = ctxt-&gt;tmpRVT;
3161     ctxt-&gt;tmpRVT = NULL;
3162 
3163     /*
3164     * Initiate a distinct scope of local params/variables.
3165     */
3166     oldVarsBase = ctxt-&gt;varsBase;
3167     ctxt-&gt;varsBase = ctxt-&gt;varsNr;
3168 
3169     ctxt-&gt;node = contextNode;
<span class="line-added">3170 </span>
<span class="line-added">3171 #ifdef WITH_PROFILER</span>
3172     if (ctxt-&gt;profile) {
3173     templ-&gt;nbCalls++;
3174     start = xsltTimestamp();
3175     profPush(ctxt, 0);
3176     profCallgraphAdd(templ, ctxt-&gt;templ);
3177     }
<span class="line-added">3178 #endif</span>
<span class="line-added">3179 </span>
3180     /*
3181     * Push the xsl:template declaration onto the stack.
3182     */
3183     templPush(ctxt, templ);
3184 
3185 #ifdef WITH_XSLT_DEBUG_PROCESS
3186     if (templ-&gt;name != NULL)
3187     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
3188     &quot;applying xsl:template &#39;%s&#39;\n&quot;, templ-&gt;name));
3189 #endif
3190     /*
3191     * Process xsl:param instructions and skip those elements for
3192     * further processing.
3193     */
3194     cur = list;
3195     do {
3196     if (cur-&gt;type == XML_TEXT_NODE) {
3197         cur = cur-&gt;next;
3198         continue;
3199     }
</pre>
<hr />
<pre>
3267     * Release user-created fragments stored in the scope
3268     * of xsl:template. Note that this mechanism is deprecated:
3269     * user code should now use xsltRegisterLocalRVT() instead
3270     * of the obsolete xsltRegisterTmpRVT().
3271     */
3272     if (ctxt-&gt;tmpRVT) {
3273     xmlDocPtr curdoc = ctxt-&gt;tmpRVT, tmp;
3274 
3275     while (curdoc != NULL) {
3276         tmp = curdoc;
3277         curdoc = (xmlDocPtr) curdoc-&gt;next;
3278         xsltReleaseRVT(ctxt, tmp);
3279     }
3280     }
3281     ctxt-&gt;tmpRVT = oldUserFragmentTop;
3282 
3283     /*
3284     * Pop the xsl:template declaration from the stack.
3285     */
3286     templPop(ctxt);
<span class="line-added">3287 </span>
<span class="line-added">3288 #ifdef WITH_PROFILER</span>
3289     if (ctxt-&gt;profile) {
3290     long spent, child, total, end;
3291 
3292     end = xsltTimestamp();
3293     child = profPop(ctxt);
3294     total = end - start;
3295     spent = total - child;
3296     if (spent &lt;= 0) {
3297         /*
3298         * Not possible unless the original calibration failed
3299         * we can try to correct it on the fly.
3300         */
3301         xsltCalibrateAdjust(spent);
3302         spent = 0;
3303     }
3304 
3305     templ-&gt;time += spent;
3306     if (ctxt-&gt;profNr &gt; 0)
3307         ctxt-&gt;profTab[ctxt-&gt;profNr - 1] += total;
3308     }
<span class="line-added">3309 #endif</span>
3310 
3311 #ifdef WITH_DEBUGGER
3312     if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp; (addCallResult)) {
3313         xslDropCall();
3314     }
3315 #endif
3316 }
3317 
3318 
3319 /**
3320  * xsltApplyOneTemplate:
3321  * @ctxt:  a XSLT process context
3322  * @contextNode:  the node in the source tree.
3323  * @list:  the nodes of a sequence constructor
3324  * @templ: not used
3325  * @params:  a set of parameters (xsl:param) or NULL
3326  *
3327  * Processes a sequence constructor on the current node in the source tree.
3328  *
3329  * @params are the already computed variable stack items; this function
</pre>
<hr />
<pre>
3447                                                  XSLT_SAXON_NAMESPACE);
3448         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;write&quot;)) {
3449 #ifdef WITH_XSLT_DEBUG_EXTRA
3450             xsltGenericDebug(xsltGenericDebugContext,
3451                              &quot;Found xalan:write extension\n&quot;);
3452 #endif
3453             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3454                                                  (const xmlChar *)
3455                                                  &quot;select&quot;,
3456                                                  XSLT_XALAN_NAMESPACE);
3457         if (URL != NULL) {
3458         xmlXPathCompExprPtr cmp;
3459         xmlChar *val;
3460 
3461         /*
3462          * Trying to handle bug #59212
3463          * The value of the &quot;select&quot; attribute is an
3464          * XPath expression.
3465          * (see http://xml.apache.org/xalan-j/extensionslib.html#redirect)
3466          */
<span class="line-modified">3467         cmp = xmlXPathCtxtCompile(ctxt-&gt;xpathCtxt, URL);</span>
3468                 val = xsltEvalXPathString(ctxt, cmp);
3469         xmlXPathFreeCompExpr(cmp);
3470         xmlFree(URL);
3471         URL = val;
3472         }
3473         if (URL == NULL)
3474         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3475                              (const xmlChar *)
3476                              &quot;file&quot;,
3477                              XSLT_XALAN_NAMESPACE);
3478         if (URL == NULL)
3479         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3480                              (const xmlChar *)
3481                              &quot;href&quot;,
3482                              XSLT_XALAN_NAMESPACE);
3483         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;document&quot;)) {
3484             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3485                                                  (const xmlChar *) &quot;href&quot;,
3486                                                  NULL);
3487         }
</pre>
<hr />
<pre>
5011                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5012                          cur-&gt;parent-&gt;name,
5013                          cur-&gt;parent-&gt;ns-&gt;href);
5014                 if (val == NULL) {
5015                 val = (const xmlChar *)
5016                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5017                          BAD_CAST &quot;*&quot;,
5018                          cur-&gt;parent-&gt;ns-&gt;href);
5019                 }
5020             } else {
5021                 val = (const xmlChar *)
5022                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5023                          cur-&gt;parent-&gt;name, NULL);
5024             }
5025             if ((val != NULL) &amp;&amp;
5026                 (xmlStrEqual(val, (xmlChar *) &quot;strip&quot;))) {
5027                 delNode = cur;
5028                 break;
5029             }
5030             }
<span class="line-modified">5031             /* Intentional fall-through */</span>
5032         case XML_ELEMENT_NODE:
5033         case XML_DOCUMENT_NODE:
5034         case XML_HTML_DOCUMENT_NODE:
5035         case XML_CDATA_SECTION_NODE:
5036         case XML_PI_NODE:
5037         case XML_COMMENT_NODE:
5038             xmlXPathNodeSetAddUnique(list, cur);
5039             break;
5040         case XML_DTD_NODE:
5041             /* Unlink the DTD, it&#39;s still reachable
5042              * using doc-&gt;intSubset */
5043             if (cur-&gt;next != NULL)
5044             cur-&gt;next-&gt;prev = cur-&gt;prev;
5045             if (cur-&gt;prev != NULL)
5046             cur-&gt;prev-&gt;next = cur-&gt;next;
5047             break;
5048         case XML_NAMESPACE_DECL:
5049             break;
5050         default:
5051 #ifdef WITH_XSLT_DEBUG_PROCESS
</pre>
<hr />
<pre>
5911      * Check for XPath document order availability
5912      */
5913     root = xmlDocGetRootElement(doc);
5914     if (root != NULL) {
5915     if (((ptrdiff_t) root-&gt;content &gt;= 0) &amp;&amp;
5916             (xslDebugStatus == XSLT_DEBUG_NONE))
5917         xmlXPathOrderDocElems(doc);
5918     }
5919 
5920     if (userCtxt != NULL)
5921     ctxt = userCtxt;
5922     else
5923     ctxt = xsltNewTransformContext(style, doc);
5924 
5925     if (ctxt == NULL)
5926         return (NULL);
5927 
5928     ctxt-&gt;initialContextDoc = doc;
5929     ctxt-&gt;initialContextNode = (xmlNodePtr) doc;
5930 
<span class="line-modified">5931     if (profile != NULL) {</span>
<span class="line-added">5932 #ifdef WITH_PROFILER</span>
5933         ctxt-&gt;profile = 1;
<span class="line-added">5934 #else</span>
<span class="line-added">5935         xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,</span>
<span class="line-added">5936                 &quot;xsltApplyStylesheetInternal: &quot;</span>
<span class="line-added">5937                 &quot;libxslt compiled without profiler\n&quot;);</span>
<span class="line-added">5938         goto error;</span>
<span class="line-added">5939 #endif</span>
<span class="line-added">5940     }</span>
5941 
5942     if (output != NULL)
5943         ctxt-&gt;outputFile = output;
5944     else
5945         ctxt-&gt;outputFile = NULL;
5946 
5947     /*
5948      * internalize the modes if needed
5949      */
5950     if (ctxt-&gt;dict != NULL) {
5951         if (ctxt-&gt;mode != NULL)
5952         ctxt-&gt;mode = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;mode, -1);
5953         if (ctxt-&gt;modeURI != NULL)
5954         ctxt-&gt;modeURI = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;modeURI, -1);
5955     }
5956 
5957     XSLT_GET_IMPORT_PTR(method, style, method)
5958     XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
5959     XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
5960     XSLT_GET_IMPORT_PTR(version, style, version)
</pre>
<hr />
<pre>
6033         method);
6034             goto error;
6035         }
6036     } else {
6037         ctxt-&gt;type = XSLT_OUTPUT_XML;
6038         res = xmlNewDoc(style-&gt;version);
6039         if (res == NULL)
6040             goto error;
6041     res-&gt;dict = ctxt-&gt;dict;
6042     xmlDictReference(ctxt-&gt;dict);
6043 #ifdef WITH_XSLT_DEBUG
6044     xsltGenericDebug(xsltGenericDebugContext,
6045              &quot;reusing transformation dict for output\n&quot;);
6046 #endif
6047     }
6048     res-&gt;charset = XML_CHAR_ENCODING_UTF8;
6049     if (encoding != NULL)
6050         res-&gt;encoding = xmlStrdup(encoding);
6051     variables = style-&gt;variables;
6052 
<span class="line-added">6053     ctxt-&gt;node = (xmlNodePtr) doc;</span>
<span class="line-added">6054     ctxt-&gt;output = res;</span>
<span class="line-added">6055 </span>
<span class="line-added">6056     ctxt-&gt;xpathCtxt-&gt;contextSize = 1;</span>
<span class="line-added">6057     ctxt-&gt;xpathCtxt-&gt;proximityPosition = 1;</span>
<span class="line-added">6058     ctxt-&gt;xpathCtxt-&gt;node = NULL; /* TODO: Set the context node here? */</span>
<span class="line-added">6059 </span>
6060     /*
6061      * Start the evaluation, evaluate the params, the stylesheets globals
6062      * and start by processing the top node.
6063      */
6064     if (xsltNeedElemSpaceHandling(ctxt))
6065     xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));
6066     /*
6067     * Evaluate global params and user-provided params.
6068     */

6069     if (ctxt-&gt;globalVars == NULL)
6070     ctxt-&gt;globalVars = xmlHashCreate(20);
6071     if (params != NULL) {
6072         xsltEvalUserParams(ctxt, params);
6073     }
6074 
6075     /* need to be called before evaluating global variables */
6076     xsltCountKeys(ctxt);
6077 
6078     xsltEvalGlobalVariables(ctxt);
6079 
6080     /* Clean up any unused RVTs. */
6081     xsltReleaseLocalRVTs(ctxt, NULL);
6082 


6083     ctxt-&gt;insert = (xmlNodePtr) res;
6084     ctxt-&gt;varsBase = ctxt-&gt;varsNr - 1;
6085 



6086     /*
6087     * Start processing the source tree -----------------------------------
6088     */
6089     xsltProcessOneNode(ctxt, ctxt-&gt;node, NULL);
6090     /*
6091     * Remove all remaining vars from the stack.
6092     */
6093     xsltLocalVariablePop(ctxt, 0, -2);
6094     xsltShutdownCtxtExts(ctxt);
6095 
6096     xsltCleanupTemplates(style); /* TODO: &lt;- style should be read only */
6097 
6098     /*
6099      * Now cleanup our variables so stylesheet can be re-used
6100      *
6101      * TODO: this is not needed anymore global variables are copied
6102      *       and not evaluated directly anymore, keep this as a check
6103      */
6104     if (style-&gt;variables != variables) {
6105         vptr = style-&gt;variables;
</pre>
<hr />
<pre>
6195            possible comment nodes */
6196         node = res-&gt;children;
6197         last = res-&gt;last;
6198         res-&gt;children = NULL;
6199         res-&gt;last = NULL;
6200                 res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
6201                                                     doctypePublic,
6202                                                     doctypeSystem);
6203         if (res-&gt;children != NULL) {
6204             res-&gt;children-&gt;next = node;
6205             node-&gt;prev = res-&gt;children;
6206             res-&gt;last = last;
6207         } else {
6208             res-&gt;children = node;
6209             res-&gt;last = last;
6210         }
6211         }
6212         }
6213     }
6214     xmlXPathFreeNodeSet(ctxt-&gt;nodeList);
<span class="line-added">6215 </span>
<span class="line-added">6216 #ifdef WITH_PROFILER</span>
6217     if (profile != NULL) {
6218         xsltSaveProfiling(ctxt, profile);
6219     }
<span class="line-added">6220 #endif</span>
6221 
6222     /*
6223      * Be pedantic.
6224      */
6225     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;state != XSLT_STATE_OK)) {
6226     xmlFreeDoc(res);
6227     res = NULL;
6228     }
6229     if ((res != NULL) &amp;&amp; (ctxt != NULL) &amp;&amp; (output != NULL)) {
6230     int ret;
6231 
6232     ret = xsltCheckWrite(ctxt-&gt;sec, ctxt, (const xmlChar *) output);
6233     if (ret == 0) {
6234         xsltTransformError(ctxt, NULL, NULL,
6235              &quot;xsltApplyStylesheet: forbidden to save to %s\n&quot;,
6236                    output);
6237     } else if (ret &lt; 0) {
6238         xsltTransformError(ctxt, NULL, NULL,
6239              &quot;xsltApplyStylesheet: saving to %s may not be possible\n&quot;,
6240                    output);
</pre>
</td>
</tr>
</table>
<center><a href="templates.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="variables.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>