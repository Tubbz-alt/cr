<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/pattern.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="numbers.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/pattern.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  96     int        indexExtra;
  97     int        lenExtra;
  98 };
  99 
 100 struct _xsltCompMatch {
 101     struct _xsltCompMatch *next; /* siblings in the name hash */
 102     float priority;              /* the priority */
 103     const xmlChar *pattern;       /* the pattern */
 104     const xmlChar *mode;         /* the mode */
 105     const xmlChar *modeURI;      /* the mode URI */
 106     xsltTemplatePtr template;    /* the associated template */
 107     xmlNodePtr node;             /* the containing element */
 108 
 109     int direct;
 110     /* TODO fix the statically allocated size steps[] */
 111     int nbStep;
 112     int maxStep;
 113     xmlNsPtr *nsList;       /* the namespaces in scope */
 114     int nsNr;           /* the number of namespaces in scope */
 115     xsltStepOpPtr steps;        /* ops for computation */
<span class="line-removed"> 116     int novar;                  /* doesn&#39;t contain variables */</span>
 117 };
 118 
 119 typedef struct _xsltParserContext xsltParserContext;
 120 typedef xsltParserContext *xsltParserContextPtr;
 121 struct _xsltParserContext {
 122     xsltStylesheetPtr style;        /* the stylesheet */
 123     xsltTransformContextPtr ctxt;   /* the transformation or NULL */
 124     const xmlChar *cur;         /* the current char being parsed */
 125     const xmlChar *base;        /* the full expression */
 126     xmlDocPtr      doc;         /* the source document */
 127     xmlNodePtr    elem;         /* the source element */
 128     int error;              /* error code */
 129     xsltCompMatchPtr comp;      /* the result */
 130 };
 131 
 132 /************************************************************************
 133  *                                  *
 134  *          Type functions                  *
 135  *                                  *
 136  ************************************************************************/
</pre>
<hr />
<pre>
 325     comp-&gt;steps[comp-&gt;nbStep].value = value;
 326     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 327     comp-&gt;steps[comp-&gt;nbStep].value3 = NULL;
 328     comp-&gt;steps[comp-&gt;nbStep].comp = NULL;
 329     if (ctxt-&gt;ctxt != NULL) {
 330     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 331         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 332     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 333         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 334     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 335         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 336     } else {
 337     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 338         xsltAllocateExtra(ctxt-&gt;style);
 339     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 340         xsltAllocateExtra(ctxt-&gt;style);
 341     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 342         xsltAllocateExtra(ctxt-&gt;style);
 343     }
 344     if (op == XSLT_OP_PREDICATE) {
<span class="line-modified"> 345     xmlXPathContextPtr xctxt;</span>
 346 
<span class="line-removed"> 347     if (ctxt-&gt;style != NULL)</span>
<span class="line-removed"> 348         xctxt = xmlXPathNewContext(ctxt-&gt;style-&gt;doc);</span>
<span class="line-removed"> 349     else</span>
<span class="line-removed"> 350         xctxt = xmlXPathNewContext(NULL);</span>
 351 #ifdef XML_XPATH_NOVAR
 352     if (novar != 0)
<span class="line-modified"> 353         xctxt-&gt;flags = XML_XPATH_NOVAR;</span>
 354 #endif
<span class="line-modified"> 355     if (ctxt-&gt;style != NULL)</span>
<span class="line-modified"> 356         xctxt-&gt;dict = ctxt-&gt;style-&gt;dict;</span>
<span class="line-removed"> 357     comp-&gt;steps[comp-&gt;nbStep].comp = xmlXPathCtxtCompile(xctxt, value);</span>
<span class="line-removed"> 358     xmlXPathFreeContext(xctxt);</span>
 359     if (comp-&gt;steps[comp-&gt;nbStep].comp == NULL) {
 360         xsltTransformError(NULL, ctxt-&gt;style, ctxt-&gt;elem,
 361             &quot;Failed to compile predicate\n&quot;);
 362         if (ctxt-&gt;style != NULL)
 363         ctxt-&gt;style-&gt;errors++;
 364     }
 365     }
 366     comp-&gt;nbStep++;
 367     return (0);
 368 }
 369 
 370 /**
 371  * xsltSwapTopCompMatch:
 372  * @comp:  the compiled match expression
 373  *
 374  * reverse the two top steps.
 375  */
 376 static void
 377 xsltSwapTopCompMatch(xsltCompMatchPtr comp) {
 378     int i;
</pre>
<hr />
<pre>
 578     oldProximityPosition = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
 579     ctxt-&gt;xpathCtxt-&gt;node = node;
 580     ctxt-&gt;xpathCtxt-&gt;doc = doc;
 581     ctxt-&gt;xpathCtxt-&gt;namespaces = nsList;
 582     ctxt-&gt;xpathCtxt-&gt;nsNr = nsNr;
 583     newlist = xmlXPathEval(comp-&gt;pattern, ctxt-&gt;xpathCtxt);
 584     ctxt-&gt;xpathCtxt-&gt;node = oldnode;
 585     ctxt-&gt;xpathCtxt-&gt;doc = olddoc;
 586     ctxt-&gt;xpathCtxt-&gt;namespaces = oldNamespaces;
 587     ctxt-&gt;xpathCtxt-&gt;nsNr = oldNsNr;
 588     ctxt-&gt;xpathCtxt-&gt;contextSize = oldContextSize;
 589     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldProximityPosition;
 590     if (newlist == NULL)
 591         return(-1);
 592     if (newlist-&gt;type != XPATH_NODESET) {
 593         xmlXPathFreeObject(newlist);
 594         return(-1);
 595     }
 596     ix = 0;
 597 
<span class="line-modified"> 598     if ((parent == NULL) || (node-&gt;doc == NULL) || isRVT ||</span>
<span class="line-removed"> 599             (comp-&gt;novar == 0))</span>
 600         nocache = 1;
 601 
 602     if (nocache == 0) {
 603         if (list != NULL)
 604         xmlXPathFreeObject(list);
 605         list = newlist;
 606 
 607         XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra) =
 608         (void *) list;
 609         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) =
 610         (void *) doc;
 611         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) =
 612         0;
 613         XSLT_RUNTIME_EXTRA_FREE(ctxt, sel-&gt;lenExtra) =
 614         xmlXPathFreeObjectWrapper;
 615     } else
 616         list = newlist;
 617     }
 618     if ((list-&gt;nodesetval == NULL) ||
 619     (list-&gt;nodesetval-&gt;nodeNr &lt;= 0)) {
</pre>
<hr />
<pre>
1234  * Test whether the node matches one of the patterns in the list
1235  *
1236  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
1237  */
1238 int
1239 xsltTestCompMatchList(xsltTransformContextPtr ctxt, xmlNodePtr node,
1240                   xsltCompMatchPtr comp) {
1241     int ret;
1242 
1243     if ((ctxt == NULL) || (node == NULL))
1244     return(-1);
1245     while (comp != NULL) {
1246     ret = xsltTestCompMatch(ctxt, comp, node, NULL, NULL);
1247     if (ret == 1)
1248         return(1);
1249     comp = comp-&gt;next;
1250     }
1251     return(0);
1252 }
1253 




























1254 /************************************************************************
1255  *                                  *
1256  *          Dedicated parser for templates          *
1257  *                                  *
1258  ************************************************************************/
1259 
1260 #define CUR (*ctxt-&gt;cur)
1261 #define SKIP(val) ctxt-&gt;cur += (val)
1262 #define NXT(val) ctxt-&gt;cur[(val)]
1263 #define CUR_PTR ctxt-&gt;cur
1264 
1265 #define SKIP_BLANKS                         \
1266     while (IS_BLANK_CH(CUR)) NEXT
1267 
1268 #define CURRENT (*ctxt-&gt;cur)
1269 #define NEXT ((*ctxt-&gt;cur) ?  ctxt-&gt;cur++: ctxt-&gt;cur)
1270 
1271 
1272 #define PUSH(op, val, val2, novar)                      \
1273     if (xsltCompMatchAdd(ctxt, ctxt-&gt;comp, (op), (val), (val2), (novar))) goto error;
</pre>
<hr />
<pre>
1778  *                           | RelativePathPattern &#39;/&#39; StepPattern
1779  *                           | RelativePathPattern &#39;//&#39; StepPattern
1780  */
1781 static void
1782 xsltCompileRelativePathPattern(xsltParserContextPtr ctxt, xmlChar *token, int novar) {
1783     xsltCompileStepPattern(ctxt, token, novar);
1784     if (ctxt-&gt;error)
1785     goto error;
1786     SKIP_BLANKS;
1787     while ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {
1788     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1789         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1790         NEXT;
1791         NEXT;
1792         SKIP_BLANKS;
1793         xsltCompileStepPattern(ctxt, NULL, novar);
1794     } else if (CUR == &#39;/&#39;) {
1795         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1796         NEXT;
1797         SKIP_BLANKS;
<span class="line-modified">1798         if ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {</span>
<span class="line-removed">1799         xsltCompileRelativePathPattern(ctxt, NULL, novar);</span>
<span class="line-removed">1800         }</span>
1801     } else {
1802         ctxt-&gt;error = 1;
1803     }
1804     if (ctxt-&gt;error)
1805         goto error;
1806     SKIP_BLANKS;
1807     }
1808 error:
1809     return;
1810 }
1811 
1812 /**
1813  * xsltCompileLocationPathPattern:
1814  * @ctxt:  the compilation context
1815  * @novar:  flag to prohibit xslt variables
1816  *
1817  * Compile the XSLT LocationPathPattern and generates a precompiled
1818  * form suitable for fast matching.
1819  *
1820  * [2] LocationPathPattern ::= &#39;/&#39; RelativePathPattern?
</pre>
<hr />
<pre>
1845         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1846     }
1847     } else if (CUR == &#39;*&#39;) {
1848     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1849     } else if (CUR == &#39;@&#39;) {
1850     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1851     } else {
1852     xmlChar *name;
1853     name = xsltScanNCName(ctxt);
1854     if (name == NULL) {
1855         xsltTransformError(NULL, NULL, NULL,
1856             &quot;xsltCompileLocationPathPattern : Name expected\n&quot;);
1857         ctxt-&gt;error = 1;
1858         return;
1859     }
1860     SKIP_BLANKS;
1861     if ((CUR == &#39;(&#39;) &amp;&amp; !xmlXPathIsNodeType(name)) {
1862         xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);
1863         xmlFree(name);
1864         name = NULL;


1865         if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1866         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1867         NEXT;
1868         NEXT;
1869         SKIP_BLANKS;
1870         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1871         } else if (CUR == &#39;/&#39;) {
1872         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1873         NEXT;
1874         SKIP_BLANKS;
1875         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1876         }
1877         return;
1878     }
1879     xsltCompileRelativePathPattern(ctxt, name, novar);
1880     }
1881 error:
1882     return;
1883 }
1884 
</pre>
<hr />
<pre>
1955     if (first == NULL)
1956         first = element;
1957     else if (previous != NULL)
1958         previous-&gt;next = element;
1959     previous = element;
1960 
1961     ctxt-&gt;comp = element;
1962     ctxt-&gt;base = xmlStrndup(&amp;pattern[start], end - start);
1963     if (ctxt-&gt;base == NULL)
1964         goto error;
1965     ctxt-&gt;cur = &amp;(ctxt-&gt;base)[current - start];
1966     element-&gt;pattern = ctxt-&gt;base;
1967         element-&gt;node = node;
1968     element-&gt;nsList = xmlGetNsList(doc, node);
1969     j = 0;
1970     if (element-&gt;nsList != NULL) {
1971         while (element-&gt;nsList[j] != NULL)
1972         j++;
1973     }
1974     element-&gt;nsNr = j;
<span class="line-removed">1975         element-&gt;novar = novar;</span>
1976 
1977 
1978 #ifdef WITH_XSLT_DEBUG_PATTERN
1979     xsltGenericDebug(xsltGenericDebugContext,
1980              &quot;xsltCompilePattern : parsing &#39;%s&#39;\n&quot;,
1981              element-&gt;pattern);
1982 #endif
1983     /*
1984      Preset default priority to be zero.
1985      This may be changed by xsltCompileLocationPathPattern.
1986      */
1987     element-&gt;priority = 0;
1988     xsltCompileLocationPathPattern(ctxt, novar);
1989     if (ctxt-&gt;error) {
1990         xsltTransformError(NULL, style, node,
1991                  &quot;xsltCompilePattern : failed to compile &#39;%s&#39;\n&quot;,
1992                  element-&gt;pattern);
1993         if (style != NULL) style-&gt;errors++;
1994         goto error;
1995     }
</pre>
<hr />
<pre>
2120         if (style-&gt;namedTemplates == NULL) {
2121             style-&gt;namedTemplates = xmlHashCreate(10);
2122             if (style-&gt;namedTemplates == NULL)
2123                 return(-1);
2124         }
2125         else {
2126             void *dup = xmlHashLookup2(style-&gt;namedTemplates, cur-&gt;name,
2127                                        cur-&gt;nameURI);
2128             if (dup != NULL) {
2129                 xsltTransformError(NULL, style, cur-&gt;elem,
2130                                    &quot;xsl:template: error duplicate name &#39;%s&#39;\n&quot;,
2131                                    cur-&gt;name);
2132                 style-&gt;errors++;
2133                 return(-1);
2134             }
2135         }
2136 
2137         xmlHashAddEntry2(style-&gt;namedTemplates, cur-&gt;name, cur-&gt;nameURI, cur);
2138     }
2139 
<span class="line-modified">2140     if (cur-&gt;match == NULL)</span>






2141     return(0);

2142 
2143     priority = cur-&gt;priority;
2144     pat = xsltCompilePatternInternal(cur-&gt;match, style-&gt;doc, cur-&gt;elem,
2145             style, NULL, 1);
2146     if (pat == NULL)
2147     return(-1);
2148     while (pat) {
2149     next = pat-&gt;next;
2150     pat-&gt;next = NULL;
2151     name = NULL;
2152 
2153     pat-&gt;template = cur;
2154     if (mode != NULL)
2155         pat-&gt;mode = xmlDictLookup(style-&gt;dict, mode, -1);
2156     if (modeURI != NULL)
2157         pat-&gt;modeURI = xmlDictLookup(style-&gt;dict, modeURI, -1);
2158     if (priority != XSLT_PAT_NO_PRIORITY)
2159         pat-&gt;priority = priority;
2160 
2161     /*
</pre>
<hr />
<pre>
2347     if ((ctxt == NULL) || (node == NULL))
2348     return(NULL);
2349 
2350     if (style == NULL) {
2351     curstyle = ctxt-&gt;style;
2352     } else {
2353     curstyle = xsltNextImport(style);
2354     }
2355 
2356     while ((curstyle != NULL) &amp;&amp; (curstyle != style)) {
2357     priority = XSLT_PAT_NO_PRIORITY;
2358     /* TODO : handle IDs/keys here ! */
2359     if (curstyle-&gt;templatesHash != NULL) {
2360         /*
2361          * Use the top name as selector
2362          */
2363         switch (node-&gt;type) {
2364         case XML_ELEMENT_NODE:
2365             if (node-&gt;name[0] == &#39; &#39;)
2366             break;

2367         case XML_ATTRIBUTE_NODE:
2368         case XML_PI_NODE:
2369             name = node-&gt;name;
2370             break;
2371         case XML_DOCUMENT_NODE:
2372         case XML_HTML_DOCUMENT_NODE:
2373         case XML_TEXT_NODE:
2374         case XML_CDATA_SECTION_NODE:
2375         case XML_COMMENT_NODE:
2376         case XML_ENTITY_REF_NODE:
2377         case XML_ENTITY_NODE:
2378         case XML_DOCUMENT_TYPE_NODE:
2379         case XML_DOCUMENT_FRAG_NODE:
2380         case XML_NOTATION_NODE:
2381         case XML_DTD_NODE:
2382         case XML_ELEMENT_DECL:
2383         case XML_ATTRIBUTE_DECL:
2384         case XML_ENTITY_DECL:
2385         case XML_NAMESPACE_DECL:
2386         case XML_XINCLUDE_START:
2387         case XML_XINCLUDE_END:
2388             break;
2389         default:
2390             return(NULL);
2391 
2392         }
2393     }
2394     if (name != NULL) {
2395         /*
2396          * find the list of applicable expressions based on the name
2397          */
2398         list = (xsltCompMatchPtr) xmlHashLookup3(curstyle-&gt;templatesHash,
2399                          name, ctxt-&gt;mode, ctxt-&gt;modeURI);
2400     } else
2401         list = NULL;
2402     while (list != NULL) {
2403         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2404                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {</span>
2405         ret = list-&gt;template;
2406         priority = list-&gt;priority;
2407         break;
2408         }
2409         list = list-&gt;next;
2410     }
2411     list = NULL;
2412 
2413     /*
2414      * find alternate generic matches
2415      */
2416     switch (node-&gt;type) {
2417         case XML_ELEMENT_NODE:
2418         if (node-&gt;name[0] == &#39; &#39;)
2419             list = curstyle-&gt;rootMatch;
2420         else
2421             list = curstyle-&gt;elemMatch;
2422         if (node-&gt;psvi != NULL) keyed = 1;
2423         break;
2424         case XML_ATTRIBUTE_NODE: {
</pre>
<hr />
<pre>
2453         break;
2454         case XML_ENTITY_REF_NODE:
2455         case XML_ENTITY_NODE:
2456         case XML_DOCUMENT_TYPE_NODE:
2457         case XML_DOCUMENT_FRAG_NODE:
2458         case XML_NOTATION_NODE:
2459         case XML_DTD_NODE:
2460         case XML_ELEMENT_DECL:
2461         case XML_ATTRIBUTE_DECL:
2462         case XML_ENTITY_DECL:
2463         case XML_NAMESPACE_DECL:
2464         case XML_XINCLUDE_START:
2465         case XML_XINCLUDE_END:
2466         break;
2467         default:
2468         break;
2469     }
2470     while ((list != NULL) &amp;&amp;
2471            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2472         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2473                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {</span>
2474         ret = list-&gt;template;
2475         priority = list-&gt;priority;
2476         break;
2477         }
2478         list = list-&gt;next;
2479     }
2480     /*
2481      * Some of the tests for elements can also apply to documents
2482      */
2483     if ((node-&gt;type == XML_DOCUMENT_NODE) ||
2484         (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
2485         (node-&gt;type == XML_TEXT_NODE)) {
2486         list = curstyle-&gt;elemMatch;
2487         while ((list != NULL) &amp;&amp;
2488            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2489         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2490                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {</span>
2491             ret = list-&gt;template;
2492             priority = list-&gt;priority;
2493             break;
2494         }
2495         list = list-&gt;next;
2496         }
2497     } else if ((node-&gt;type == XML_PI_NODE) ||
2498            (node-&gt;type == XML_COMMENT_NODE)) {
2499         list = curstyle-&gt;elemMatch;
2500         while ((list != NULL) &amp;&amp;
2501            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2502         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2503                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {</span>
2504             ret = list-&gt;template;
2505             priority = list-&gt;priority;
2506             break;
2507         }
2508         list = list-&gt;next;
2509         }
2510     }
2511 
2512 keyed_match:
2513     if (keyed) {
2514         list = curstyle-&gt;keyMatch;
2515         while ((list != NULL) &amp;&amp;
2516            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2517         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2518                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {</span>
2519             ret = list-&gt;template;
2520             priority = list-&gt;priority;
2521             break;
2522         }
2523         list = list-&gt;next;
2524         }
2525     }
2526     else if (ctxt-&gt;hasTemplKeyPatterns &amp;&amp;
2527         ((ctxt-&gt;document == NULL) ||
2528          (ctxt-&gt;document-&gt;nbKeysComputed &lt; ctxt-&gt;nbKeys)))
2529     {
2530         /*
2531         * Compute all remaining keys for this document.
2532         *
2533         * REVISIT TODO: I think this could be further optimized.
2534         */
2535         if (xsltComputeAllKeys(ctxt, node) == -1)
2536         goto error;
2537 
2538         switch (node-&gt;type) {
</pre>
</td>
<td>
<hr />
<pre>
  96     int        indexExtra;
  97     int        lenExtra;
  98 };
  99 
 100 struct _xsltCompMatch {
 101     struct _xsltCompMatch *next; /* siblings in the name hash */
 102     float priority;              /* the priority */
 103     const xmlChar *pattern;       /* the pattern */
 104     const xmlChar *mode;         /* the mode */
 105     const xmlChar *modeURI;      /* the mode URI */
 106     xsltTemplatePtr template;    /* the associated template */
 107     xmlNodePtr node;             /* the containing element */
 108 
 109     int direct;
 110     /* TODO fix the statically allocated size steps[] */
 111     int nbStep;
 112     int maxStep;
 113     xmlNsPtr *nsList;       /* the namespaces in scope */
 114     int nsNr;           /* the number of namespaces in scope */
 115     xsltStepOpPtr steps;        /* ops for computation */

 116 };
 117 
 118 typedef struct _xsltParserContext xsltParserContext;
 119 typedef xsltParserContext *xsltParserContextPtr;
 120 struct _xsltParserContext {
 121     xsltStylesheetPtr style;        /* the stylesheet */
 122     xsltTransformContextPtr ctxt;   /* the transformation or NULL */
 123     const xmlChar *cur;         /* the current char being parsed */
 124     const xmlChar *base;        /* the full expression */
 125     xmlDocPtr      doc;         /* the source document */
 126     xmlNodePtr    elem;         /* the source element */
 127     int error;              /* error code */
 128     xsltCompMatchPtr comp;      /* the result */
 129 };
 130 
 131 /************************************************************************
 132  *                                  *
 133  *          Type functions                  *
 134  *                                  *
 135  ************************************************************************/
</pre>
<hr />
<pre>
 324     comp-&gt;steps[comp-&gt;nbStep].value = value;
 325     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 326     comp-&gt;steps[comp-&gt;nbStep].value3 = NULL;
 327     comp-&gt;steps[comp-&gt;nbStep].comp = NULL;
 328     if (ctxt-&gt;ctxt != NULL) {
 329     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 330         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 331     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 332         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 333     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 334         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 335     } else {
 336     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 337         xsltAllocateExtra(ctxt-&gt;style);
 338     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 339         xsltAllocateExtra(ctxt-&gt;style);
 340     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 341         xsltAllocateExtra(ctxt-&gt;style);
 342     }
 343     if (op == XSLT_OP_PREDICATE) {
<span class="line-modified"> 344         int flags = 0;</span>
 345 




 346 #ifdef XML_XPATH_NOVAR
 347     if (novar != 0)
<span class="line-modified"> 348         flags = XML_XPATH_NOVAR;</span>
 349 #endif
<span class="line-modified"> 350     comp-&gt;steps[comp-&gt;nbStep].comp = xsltXPathCompileFlags(ctxt-&gt;style,</span>
<span class="line-modified"> 351                 value, flags);</span>


 352     if (comp-&gt;steps[comp-&gt;nbStep].comp == NULL) {
 353         xsltTransformError(NULL, ctxt-&gt;style, ctxt-&gt;elem,
 354             &quot;Failed to compile predicate\n&quot;);
 355         if (ctxt-&gt;style != NULL)
 356         ctxt-&gt;style-&gt;errors++;
 357     }
 358     }
 359     comp-&gt;nbStep++;
 360     return (0);
 361 }
 362 
 363 /**
 364  * xsltSwapTopCompMatch:
 365  * @comp:  the compiled match expression
 366  *
 367  * reverse the two top steps.
 368  */
 369 static void
 370 xsltSwapTopCompMatch(xsltCompMatchPtr comp) {
 371     int i;
</pre>
<hr />
<pre>
 571     oldProximityPosition = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
 572     ctxt-&gt;xpathCtxt-&gt;node = node;
 573     ctxt-&gt;xpathCtxt-&gt;doc = doc;
 574     ctxt-&gt;xpathCtxt-&gt;namespaces = nsList;
 575     ctxt-&gt;xpathCtxt-&gt;nsNr = nsNr;
 576     newlist = xmlXPathEval(comp-&gt;pattern, ctxt-&gt;xpathCtxt);
 577     ctxt-&gt;xpathCtxt-&gt;node = oldnode;
 578     ctxt-&gt;xpathCtxt-&gt;doc = olddoc;
 579     ctxt-&gt;xpathCtxt-&gt;namespaces = oldNamespaces;
 580     ctxt-&gt;xpathCtxt-&gt;nsNr = oldNsNr;
 581     ctxt-&gt;xpathCtxt-&gt;contextSize = oldContextSize;
 582     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldProximityPosition;
 583     if (newlist == NULL)
 584         return(-1);
 585     if (newlist-&gt;type != XPATH_NODESET) {
 586         xmlXPathFreeObject(newlist);
 587         return(-1);
 588     }
 589     ix = 0;
 590 
<span class="line-modified"> 591     if ((parent == NULL) || (node-&gt;doc == NULL) || isRVT)</span>

 592         nocache = 1;
 593 
 594     if (nocache == 0) {
 595         if (list != NULL)
 596         xmlXPathFreeObject(list);
 597         list = newlist;
 598 
 599         XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra) =
 600         (void *) list;
 601         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) =
 602         (void *) doc;
 603         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) =
 604         0;
 605         XSLT_RUNTIME_EXTRA_FREE(ctxt, sel-&gt;lenExtra) =
 606         xmlXPathFreeObjectWrapper;
 607     } else
 608         list = newlist;
 609     }
 610     if ((list-&gt;nodesetval == NULL) ||
 611     (list-&gt;nodesetval-&gt;nodeNr &lt;= 0)) {
</pre>
<hr />
<pre>
1226  * Test whether the node matches one of the patterns in the list
1227  *
1228  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
1229  */
1230 int
1231 xsltTestCompMatchList(xsltTransformContextPtr ctxt, xmlNodePtr node,
1232                   xsltCompMatchPtr comp) {
1233     int ret;
1234 
1235     if ((ctxt == NULL) || (node == NULL))
1236     return(-1);
1237     while (comp != NULL) {
1238     ret = xsltTestCompMatch(ctxt, comp, node, NULL, NULL);
1239     if (ret == 1)
1240         return(1);
1241     comp = comp-&gt;next;
1242     }
1243     return(0);
1244 }
1245 
<span class="line-added">1246 /**</span>
<span class="line-added">1247  * xsltCompMatchClearCache:</span>
<span class="line-added">1248  * @ctxt:  a XSLT process context</span>
<span class="line-added">1249  * @comp: the precompiled pattern list</span>
<span class="line-added">1250  *</span>
<span class="line-added">1251  * Clear pattern match cache.</span>
<span class="line-added">1252  */</span>
<span class="line-added">1253 void</span>
<span class="line-added">1254 xsltCompMatchClearCache(xsltTransformContextPtr ctxt, xsltCompMatchPtr comp) {</span>
<span class="line-added">1255     xsltStepOpPtr sel;</span>
<span class="line-added">1256     xmlXPathObjectPtr list;</span>
<span class="line-added">1257 </span>
<span class="line-added">1258     if ((ctxt == NULL) || (comp == NULL))</span>
<span class="line-added">1259         return;</span>
<span class="line-added">1260 </span>
<span class="line-added">1261     sel = &amp;comp-&gt;steps[0];</span>
<span class="line-added">1262     list = (xmlXPathObjectPtr) XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra);</span>
<span class="line-added">1263 </span>
<span class="line-added">1264     if (list != NULL) {</span>
<span class="line-added">1265         xmlXPathFreeObject(list);</span>
<span class="line-added">1266 </span>
<span class="line-added">1267         XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra) = NULL;</span>
<span class="line-added">1268         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) = NULL;</span>
<span class="line-added">1269         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) = 0;</span>
<span class="line-added">1270         XSLT_RUNTIME_EXTRA_FREE(ctxt, sel-&gt;lenExtra) = NULL;</span>
<span class="line-added">1271     }</span>
<span class="line-added">1272 }</span>
<span class="line-added">1273 </span>
1274 /************************************************************************
1275  *                                  *
1276  *          Dedicated parser for templates          *
1277  *                                  *
1278  ************************************************************************/
1279 
1280 #define CUR (*ctxt-&gt;cur)
1281 #define SKIP(val) ctxt-&gt;cur += (val)
1282 #define NXT(val) ctxt-&gt;cur[(val)]
1283 #define CUR_PTR ctxt-&gt;cur
1284 
1285 #define SKIP_BLANKS                         \
1286     while (IS_BLANK_CH(CUR)) NEXT
1287 
1288 #define CURRENT (*ctxt-&gt;cur)
1289 #define NEXT ((*ctxt-&gt;cur) ?  ctxt-&gt;cur++: ctxt-&gt;cur)
1290 
1291 
1292 #define PUSH(op, val, val2, novar)                      \
1293     if (xsltCompMatchAdd(ctxt, ctxt-&gt;comp, (op), (val), (val2), (novar))) goto error;
</pre>
<hr />
<pre>
1798  *                           | RelativePathPattern &#39;/&#39; StepPattern
1799  *                           | RelativePathPattern &#39;//&#39; StepPattern
1800  */
1801 static void
1802 xsltCompileRelativePathPattern(xsltParserContextPtr ctxt, xmlChar *token, int novar) {
1803     xsltCompileStepPattern(ctxt, token, novar);
1804     if (ctxt-&gt;error)
1805     goto error;
1806     SKIP_BLANKS;
1807     while ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {
1808     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1809         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1810         NEXT;
1811         NEXT;
1812         SKIP_BLANKS;
1813         xsltCompileStepPattern(ctxt, NULL, novar);
1814     } else if (CUR == &#39;/&#39;) {
1815         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1816         NEXT;
1817         SKIP_BLANKS;
<span class="line-modified">1818         xsltCompileStepPattern(ctxt, NULL, novar);</span>


1819     } else {
1820         ctxt-&gt;error = 1;
1821     }
1822     if (ctxt-&gt;error)
1823         goto error;
1824     SKIP_BLANKS;
1825     }
1826 error:
1827     return;
1828 }
1829 
1830 /**
1831  * xsltCompileLocationPathPattern:
1832  * @ctxt:  the compilation context
1833  * @novar:  flag to prohibit xslt variables
1834  *
1835  * Compile the XSLT LocationPathPattern and generates a precompiled
1836  * form suitable for fast matching.
1837  *
1838  * [2] LocationPathPattern ::= &#39;/&#39; RelativePathPattern?
</pre>
<hr />
<pre>
1863         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1864     }
1865     } else if (CUR == &#39;*&#39;) {
1866     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1867     } else if (CUR == &#39;@&#39;) {
1868     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1869     } else {
1870     xmlChar *name;
1871     name = xsltScanNCName(ctxt);
1872     if (name == NULL) {
1873         xsltTransformError(NULL, NULL, NULL,
1874             &quot;xsltCompileLocationPathPattern : Name expected\n&quot;);
1875         ctxt-&gt;error = 1;
1876         return;
1877     }
1878     SKIP_BLANKS;
1879     if ((CUR == &#39;(&#39;) &amp;&amp; !xmlXPathIsNodeType(name)) {
1880         xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);
1881         xmlFree(name);
1882         name = NULL;
<span class="line-added">1883             if (ctxt-&gt;error)</span>
<span class="line-added">1884                 return;</span>
1885         if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1886         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1887         NEXT;
1888         NEXT;
1889         SKIP_BLANKS;
1890         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1891         } else if (CUR == &#39;/&#39;) {
1892         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1893         NEXT;
1894         SKIP_BLANKS;
1895         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1896         }
1897         return;
1898     }
1899     xsltCompileRelativePathPattern(ctxt, name, novar);
1900     }
1901 error:
1902     return;
1903 }
1904 
</pre>
<hr />
<pre>
1975     if (first == NULL)
1976         first = element;
1977     else if (previous != NULL)
1978         previous-&gt;next = element;
1979     previous = element;
1980 
1981     ctxt-&gt;comp = element;
1982     ctxt-&gt;base = xmlStrndup(&amp;pattern[start], end - start);
1983     if (ctxt-&gt;base == NULL)
1984         goto error;
1985     ctxt-&gt;cur = &amp;(ctxt-&gt;base)[current - start];
1986     element-&gt;pattern = ctxt-&gt;base;
1987         element-&gt;node = node;
1988     element-&gt;nsList = xmlGetNsList(doc, node);
1989     j = 0;
1990     if (element-&gt;nsList != NULL) {
1991         while (element-&gt;nsList[j] != NULL)
1992         j++;
1993     }
1994     element-&gt;nsNr = j;

1995 
1996 
1997 #ifdef WITH_XSLT_DEBUG_PATTERN
1998     xsltGenericDebug(xsltGenericDebugContext,
1999              &quot;xsltCompilePattern : parsing &#39;%s&#39;\n&quot;,
2000              element-&gt;pattern);
2001 #endif
2002     /*
2003      Preset default priority to be zero.
2004      This may be changed by xsltCompileLocationPathPattern.
2005      */
2006     element-&gt;priority = 0;
2007     xsltCompileLocationPathPattern(ctxt, novar);
2008     if (ctxt-&gt;error) {
2009         xsltTransformError(NULL, style, node,
2010                  &quot;xsltCompilePattern : failed to compile &#39;%s&#39;\n&quot;,
2011                  element-&gt;pattern);
2012         if (style != NULL) style-&gt;errors++;
2013         goto error;
2014     }
</pre>
<hr />
<pre>
2139         if (style-&gt;namedTemplates == NULL) {
2140             style-&gt;namedTemplates = xmlHashCreate(10);
2141             if (style-&gt;namedTemplates == NULL)
2142                 return(-1);
2143         }
2144         else {
2145             void *dup = xmlHashLookup2(style-&gt;namedTemplates, cur-&gt;name,
2146                                        cur-&gt;nameURI);
2147             if (dup != NULL) {
2148                 xsltTransformError(NULL, style, cur-&gt;elem,
2149                                    &quot;xsl:template: error duplicate name &#39;%s&#39;\n&quot;,
2150                                    cur-&gt;name);
2151                 style-&gt;errors++;
2152                 return(-1);
2153             }
2154         }
2155 
2156         xmlHashAddEntry2(style-&gt;namedTemplates, cur-&gt;name, cur-&gt;nameURI, cur);
2157     }
2158 
<span class="line-modified">2159     if (cur-&gt;match == NULL) {</span>
<span class="line-added">2160             if (cur-&gt;name == NULL) {</span>
<span class="line-added">2161                 xsltTransformError(NULL, style, cur-&gt;elem,</span>
<span class="line-added">2162                     &quot;xsl:template: need to specify match or name attribute\n&quot;);</span>
<span class="line-added">2163                 style-&gt;errors++;</span>
<span class="line-added">2164                 return(-1);</span>
<span class="line-added">2165             }</span>
2166     return(0);
<span class="line-added">2167     }</span>
2168 
2169     priority = cur-&gt;priority;
2170     pat = xsltCompilePatternInternal(cur-&gt;match, style-&gt;doc, cur-&gt;elem,
2171             style, NULL, 1);
2172     if (pat == NULL)
2173     return(-1);
2174     while (pat) {
2175     next = pat-&gt;next;
2176     pat-&gt;next = NULL;
2177     name = NULL;
2178 
2179     pat-&gt;template = cur;
2180     if (mode != NULL)
2181         pat-&gt;mode = xmlDictLookup(style-&gt;dict, mode, -1);
2182     if (modeURI != NULL)
2183         pat-&gt;modeURI = xmlDictLookup(style-&gt;dict, modeURI, -1);
2184     if (priority != XSLT_PAT_NO_PRIORITY)
2185         pat-&gt;priority = priority;
2186 
2187     /*
</pre>
<hr />
<pre>
2373     if ((ctxt == NULL) || (node == NULL))
2374     return(NULL);
2375 
2376     if (style == NULL) {
2377     curstyle = ctxt-&gt;style;
2378     } else {
2379     curstyle = xsltNextImport(style);
2380     }
2381 
2382     while ((curstyle != NULL) &amp;&amp; (curstyle != style)) {
2383     priority = XSLT_PAT_NO_PRIORITY;
2384     /* TODO : handle IDs/keys here ! */
2385     if (curstyle-&gt;templatesHash != NULL) {
2386         /*
2387          * Use the top name as selector
2388          */
2389         switch (node-&gt;type) {
2390         case XML_ELEMENT_NODE:
2391             if (node-&gt;name[0] == &#39; &#39;)
2392             break;
<span class="line-added">2393                     /* Intentional fall-through */</span>
2394         case XML_ATTRIBUTE_NODE:
2395         case XML_PI_NODE:
2396             name = node-&gt;name;
2397             break;
2398         case XML_DOCUMENT_NODE:
2399         case XML_HTML_DOCUMENT_NODE:
2400         case XML_TEXT_NODE:
2401         case XML_CDATA_SECTION_NODE:
2402         case XML_COMMENT_NODE:
2403         case XML_ENTITY_REF_NODE:
2404         case XML_ENTITY_NODE:
2405         case XML_DOCUMENT_TYPE_NODE:
2406         case XML_DOCUMENT_FRAG_NODE:
2407         case XML_NOTATION_NODE:
2408         case XML_DTD_NODE:
2409         case XML_ELEMENT_DECL:
2410         case XML_ATTRIBUTE_DECL:
2411         case XML_ENTITY_DECL:
2412         case XML_NAMESPACE_DECL:
2413         case XML_XINCLUDE_START:
2414         case XML_XINCLUDE_END:
2415             break;
2416         default:
2417             return(NULL);
2418 
2419         }
2420     }
2421     if (name != NULL) {
2422         /*
2423          * find the list of applicable expressions based on the name
2424          */
2425         list = (xsltCompMatchPtr) xmlHashLookup3(curstyle-&gt;templatesHash,
2426                          name, ctxt-&gt;mode, ctxt-&gt;modeURI);
2427     } else
2428         list = NULL;
2429     while (list != NULL) {
2430         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2431                       ctxt-&gt;mode, ctxt-&gt;modeURI) == 1) {</span>
2432         ret = list-&gt;template;
2433         priority = list-&gt;priority;
2434         break;
2435         }
2436         list = list-&gt;next;
2437     }
2438     list = NULL;
2439 
2440     /*
2441      * find alternate generic matches
2442      */
2443     switch (node-&gt;type) {
2444         case XML_ELEMENT_NODE:
2445         if (node-&gt;name[0] == &#39; &#39;)
2446             list = curstyle-&gt;rootMatch;
2447         else
2448             list = curstyle-&gt;elemMatch;
2449         if (node-&gt;psvi != NULL) keyed = 1;
2450         break;
2451         case XML_ATTRIBUTE_NODE: {
</pre>
<hr />
<pre>
2480         break;
2481         case XML_ENTITY_REF_NODE:
2482         case XML_ENTITY_NODE:
2483         case XML_DOCUMENT_TYPE_NODE:
2484         case XML_DOCUMENT_FRAG_NODE:
2485         case XML_NOTATION_NODE:
2486         case XML_DTD_NODE:
2487         case XML_ELEMENT_DECL:
2488         case XML_ATTRIBUTE_DECL:
2489         case XML_ENTITY_DECL:
2490         case XML_NAMESPACE_DECL:
2491         case XML_XINCLUDE_START:
2492         case XML_XINCLUDE_END:
2493         break;
2494         default:
2495         break;
2496     }
2497     while ((list != NULL) &amp;&amp;
2498            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2499         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2500                       ctxt-&gt;mode, ctxt-&gt;modeURI) == 1) {</span>
2501         ret = list-&gt;template;
2502         priority = list-&gt;priority;
2503         break;
2504         }
2505         list = list-&gt;next;
2506     }
2507     /*
2508      * Some of the tests for elements can also apply to documents
2509      */
2510     if ((node-&gt;type == XML_DOCUMENT_NODE) ||
2511         (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
2512         (node-&gt;type == XML_TEXT_NODE)) {
2513         list = curstyle-&gt;elemMatch;
2514         while ((list != NULL) &amp;&amp;
2515            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2516         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2517                       ctxt-&gt;mode, ctxt-&gt;modeURI) == 1) {</span>
2518             ret = list-&gt;template;
2519             priority = list-&gt;priority;
2520             break;
2521         }
2522         list = list-&gt;next;
2523         }
2524     } else if ((node-&gt;type == XML_PI_NODE) ||
2525            (node-&gt;type == XML_COMMENT_NODE)) {
2526         list = curstyle-&gt;elemMatch;
2527         while ((list != NULL) &amp;&amp;
2528            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2529         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2530                       ctxt-&gt;mode, ctxt-&gt;modeURI) == 1) {</span>
2531             ret = list-&gt;template;
2532             priority = list-&gt;priority;
2533             break;
2534         }
2535         list = list-&gt;next;
2536         }
2537     }
2538 
2539 keyed_match:
2540     if (keyed) {
2541         list = curstyle-&gt;keyMatch;
2542         while ((list != NULL) &amp;&amp;
2543            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2544         if (xsltTestCompMatch(ctxt, list, node,
<span class="line-modified">2545                       ctxt-&gt;mode, ctxt-&gt;modeURI) == 1) {</span>
2546             ret = list-&gt;template;
2547             priority = list-&gt;priority;
2548             break;
2549         }
2550         list = list-&gt;next;
2551         }
2552     }
2553     else if (ctxt-&gt;hasTemplKeyPatterns &amp;&amp;
2554         ((ctxt-&gt;document == NULL) ||
2555          (ctxt-&gt;document-&gt;nbKeysComputed &lt; ctxt-&gt;nbKeys)))
2556     {
2557         /*
2558         * Compute all remaining keys for this document.
2559         *
2560         * REVISIT TODO: I think this could be further optimized.
2561         */
2562         if (xsltComputeAllKeys(ctxt, node) == -1)
2563         goto error;
2564 
2565         switch (node-&gt;type) {
</pre>
</td>
</tr>
</table>
<center><a href="numbers.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>