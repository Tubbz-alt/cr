<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * numbers.c: Implementation of the XSLT number functions
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  * Bjorn Reese &lt;breese@users.sourceforge.net&gt;
  11  */
  12 
  13 #define IN_LIBXSLT
  14 #include &quot;libxslt.h&quot;
  15 
  16 #include &lt;math.h&gt;
  17 #include &lt;limits.h&gt;
  18 #include &lt;float.h&gt;
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parserInternals.h&gt;
  23 #include &lt;libxml/xpath.h&gt;
  24 #include &lt;libxml/xpathInternals.h&gt;
  25 #include &lt;libxml/encoding.h&gt;
  26 #include &quot;xsltutils.h&quot;
  27 #include &quot;pattern.h&quot;
  28 #include &quot;templates.h&quot;
  29 #include &quot;transform.h&quot;
  30 #include &quot;numbersInternals.h&quot;
  31 
  32 #ifndef FALSE
  33 # define FALSE (0 == 1)
  34 # define TRUE (1 == 1)
  35 #endif
  36 
  37 #define SYMBOL_QUOTE        ((xmlChar)&#39;\&#39;&#39;)
  38 
  39 #define DEFAULT_TOKEN       &#39;0&#39;
  40 #define DEFAULT_SEPARATOR   &quot;.&quot;
  41 
  42 #define MAX_TOKENS      1024
  43 
  44 typedef struct _xsltFormatToken xsltFormatToken;
  45 typedef xsltFormatToken *xsltFormatTokenPtr;
  46 struct _xsltFormatToken {
  47     xmlChar *separator;
  48     int      token;
  49     int      width;
  50 };
  51 
  52 typedef struct _xsltFormat xsltFormat;
  53 typedef xsltFormat *xsltFormatPtr;
  54 struct _xsltFormat {
  55     xmlChar     *start;
  56     xsltFormatToken  tokens[MAX_TOKENS];
  57     int          nTokens;
  58     xmlChar     *end;
  59 };
  60 
  61 static char alpha_upper_list[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
  62 static char alpha_lower_list[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
  63 static xsltFormatToken default_token;
  64 
  65 /*
  66  * **** Start temp insert ****
  67  *
  68  * The following routine xsltUTF8Charcmp will be replaced with calls to
  69  * the corresponding libxml routine at a later date (when other
  70  * inter-library dependencies require it).
  71  */
  72 
  73 /**
  74  * xsltUTF8Charcmp
  75  * @utf1: pointer to first UTF8 char
  76  * @utf2: pointer to second UTF8 char
  77  *
  78  * returns result of comparing the two UCS4 values
  79  * as with xmlStrncmp
  80  */
  81 static int
  82 xsltUTF8Charcmp(xmlChar *utf1, xmlChar *utf2) {
  83     int len = xmlUTF8Strsize(utf1, 1);
  84 
  85     if (len &lt; 1)
  86         return -1;
  87     if (utf1 == NULL ) {
  88         if (utf2 == NULL)
  89             return 0;
  90         return -1;
  91     }
  92     return xmlStrncmp(utf1, utf2, len);
  93 }
  94 
  95 /***** Stop temp insert *****/
  96 /************************************************************************
  97  *                                  *
  98  *          Utility functions               *
  99  *                                  *
 100  ************************************************************************/
 101 
 102 #define IS_SPECIAL(self,letter)         \
 103     ((xsltUTF8Charcmp((letter), (self)-&gt;zeroDigit) == 0)        ||  \
 104      (xsltUTF8Charcmp((letter), (self)-&gt;digit) == 0)        ||  \
 105      (xsltUTF8Charcmp((letter), (self)-&gt;decimalPoint) == 0)  || \
 106      (xsltUTF8Charcmp((letter), (self)-&gt;grouping) == 0)     ||  \
 107      (xsltUTF8Charcmp((letter), (self)-&gt;patternSeparator) == 0))
 108 
 109 #define IS_DIGIT_ZERO(x) xsltIsDigitZero(x)
 110 #define IS_DIGIT_ONE(x) xsltIsDigitZero((x)-1)
 111 
 112 static int
 113 xsltIsDigitZero(unsigned int ch)
 114 {
 115     /*
 116      * Reference: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
 117      *
 118      * There a many more digit ranges in newer Unicode versions. These
 119      * are only the zeros that match Digit in XML 1.0 (IS_DIGIT macro).
 120      */
 121     switch (ch) {
 122     case 0x0030: case 0x0660: case 0x06F0: case 0x0966:
 123     case 0x09E6: case 0x0A66: case 0x0AE6: case 0x0B66:
 124     case 0x0C66: case 0x0CE6: case 0x0D66: case 0x0E50:
 125     case 0x0ED0: case 0x0F20:
 126     return TRUE;
 127     default:
 128     return FALSE;
 129     }
 130 }
 131 
 132 static void
 133 xsltNumberFormatDecimal(xmlBufferPtr buffer,
 134             double number,
 135             int digit_zero,
 136             int width,
 137             int digitsPerGroup,
 138             int groupingCharacter,
 139             int groupingCharacterLen)
 140 {
 141     /*
 142      * This used to be
 143      *  xmlChar temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 4];
 144      * which would be length 68 on x86 arch.  It was changed to be a longer,
 145      * fixed length in order to try to cater for (reasonable) UTF8
 146      * separators and numeric characters.  The max UTF8 char size will be
 147      * 6 or less, so the value used [500] should be *much* larger than needed
 148      */
 149     xmlChar temp_string[500];
 150     xmlChar *pointer;
 151     xmlChar temp_char[6];
 152     int i;
 153     int val;
 154     int len;
 155 
 156     /* Build buffer from back */
 157     pointer = &amp;temp_string[sizeof(temp_string)] - 1;    /* last char */
 158     *pointer = 0;
 159     i = 0;
 160     while (pointer &gt; temp_string) {
 161     if ((i &gt;= width) &amp;&amp; (fabs(number) &lt; 1.0))
 162         break; /* for */
 163     if ((i &gt; 0) &amp;&amp; (groupingCharacter != 0) &amp;&amp;
 164         (digitsPerGroup &gt; 0) &amp;&amp;
 165         ((i % digitsPerGroup) == 0)) {
 166         if (pointer - groupingCharacterLen &lt; temp_string) {
 167             i = -1;     /* flag error */
 168         break;
 169         }
 170         pointer -= groupingCharacterLen;
 171         xmlCopyCharMultiByte(pointer, groupingCharacter);
 172     }
 173 
 174     val = digit_zero + (int)fmod(number, 10.0);
 175     if (val &lt; 0x80) {           /* shortcut if ASCII */
 176         if (pointer &lt;= temp_string) {   /* Check enough room */
 177             i = -1;
 178         break;
 179         }
 180         *(--pointer) = val;
 181     }
 182     else {
 183     /*
 184      * Here we have a multibyte character.  It&#39;s a little messy,
 185      * because until we generate the char we don&#39;t know how long
 186      * it is.  So, we generate it into the buffer temp_char, then
 187      * copy from there into temp_string.
 188      */
 189         len = xmlCopyCharMultiByte(temp_char, val);
 190         if ( (pointer - len) &lt; temp_string ) {
 191             i = -1;
 192         break;
 193         }
 194         pointer -= len;
 195         memcpy(pointer, temp_char, len);
 196     }
 197     number /= 10.0;
 198     ++i;
 199     }
 200     if (i &lt; 0)
 201         xsltGenericError(xsltGenericErrorContext,
 202         &quot;xsltNumberFormatDecimal: Internal buffer size exceeded\n&quot;);
 203     xmlBufferCat(buffer, pointer);
 204 }
 205 
 206 static void
 207 xsltNumberFormatAlpha(xsltNumberDataPtr data,
 208               xmlBufferPtr buffer,
 209               double number,
 210               int is_upper)
 211 {
 212     char temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 1];
 213     char *pointer;
 214     int i;
 215     char *alpha_list;
 216     double alpha_size = (double)(sizeof(alpha_upper_list) - 1);
 217 
 218     /*
 219      * XSLT 1.0 isn&#39;t clear on how to handle zero, but XSLT 2.0 says:
 220      *
 221      *     For all format tokens other than the first kind above (one that
 222      *     consists of decimal digits), there may be implementation-defined
 223      *     lower and upper bounds on the range of numbers that can be
 224      *     formatted using this format token; indeed, for some numbering
 225      *     sequences there may be intrinsic limits. [...] Numbers that fall
 226      *     outside this range must be formatted using the format token 1.
 227      *
 228      * The &quot;a&quot; token has an intrinsic lower limit of 1.
 229      */
 230     if (number &lt; 1.0) {
 231         xsltNumberFormatDecimal(buffer, number, &#39;0&#39;, 1,
 232                                 data-&gt;digitsPerGroup,
 233                                 data-&gt;groupingCharacter,
 234                                 data-&gt;groupingCharacterLen);
 235         return;
 236     }
 237 
 238     /* Build buffer from back */
 239     pointer = &amp;temp_string[sizeof(temp_string)];
 240     *(--pointer) = 0;
 241     alpha_list = (is_upper) ? alpha_upper_list : alpha_lower_list;
 242 
 243     for (i = 1; i &lt; (int)sizeof(temp_string); i++) {
 244     number--;
 245     *(--pointer) = alpha_list[((int)fmod(number, alpha_size))];
 246     number /= alpha_size;
 247     if (number &lt; 1.0)
 248         break; /* for */
 249     }
 250     xmlBufferCCat(buffer, pointer);
 251 }
 252 
 253 static void
 254 xsltNumberFormatRoman(xsltNumberDataPtr data,
 255               xmlBufferPtr buffer,
 256               double number,
 257               int is_upper)
 258 {
 259     /*
 260      * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper
 261      * bound to avoid denial of service.
 262      */
 263     if (number &lt; 1.0 || number &gt; 5000.0) {
 264         xsltNumberFormatDecimal(buffer, number, &#39;0&#39;, 1,
 265                                 data-&gt;digitsPerGroup,
 266                                 data-&gt;groupingCharacter,
 267                                 data-&gt;groupingCharacterLen);
 268         return;
 269     }
 270 
 271     /*
 272      * Based on an example by Jim Walsh
 273      */
 274     while (number &gt;= 1000.0) {
 275     xmlBufferCCat(buffer, (is_upper) ? &quot;M&quot; : &quot;m&quot;);
 276     number -= 1000.0;
 277     }
 278     if (number &gt;= 900.0) {
 279     xmlBufferCCat(buffer, (is_upper) ? &quot;CM&quot; : &quot;cm&quot;);
 280     number -= 900.0;
 281     }
 282     while (number &gt;= 500.0) {
 283     xmlBufferCCat(buffer, (is_upper) ? &quot;D&quot; : &quot;d&quot;);
 284     number -= 500.0;
 285     }
 286     if (number &gt;= 400.0) {
 287     xmlBufferCCat(buffer, (is_upper) ? &quot;CD&quot; : &quot;cd&quot;);
 288     number -= 400.0;
 289     }
 290     while (number &gt;= 100.0) {
 291     xmlBufferCCat(buffer, (is_upper) ? &quot;C&quot; : &quot;c&quot;);
 292     number -= 100.0;
 293     }
 294     if (number &gt;= 90.0) {
 295     xmlBufferCCat(buffer, (is_upper) ? &quot;XC&quot; : &quot;xc&quot;);
 296     number -= 90.0;
 297     }
 298     while (number &gt;= 50.0) {
 299     xmlBufferCCat(buffer, (is_upper) ? &quot;L&quot; : &quot;l&quot;);
 300     number -= 50.0;
 301     }
 302     if (number &gt;= 40.0) {
 303     xmlBufferCCat(buffer, (is_upper) ? &quot;XL&quot; : &quot;xl&quot;);
 304     number -= 40.0;
 305     }
 306     while (number &gt;= 10.0) {
 307     xmlBufferCCat(buffer, (is_upper) ? &quot;X&quot; : &quot;x&quot;);
 308     number -= 10.0;
 309     }
 310     if (number &gt;= 9.0) {
 311     xmlBufferCCat(buffer, (is_upper) ? &quot;IX&quot; : &quot;ix&quot;);
 312     number -= 9.0;
 313     }
 314     while (number &gt;= 5.0) {
 315     xmlBufferCCat(buffer, (is_upper) ? &quot;V&quot; : &quot;v&quot;);
 316     number -= 5.0;
 317     }
 318     if (number &gt;= 4.0) {
 319     xmlBufferCCat(buffer, (is_upper) ? &quot;IV&quot; : &quot;iv&quot;);
 320     number -= 4.0;
 321     }
 322     while (number &gt;= 1.0) {
 323     xmlBufferCCat(buffer, (is_upper) ? &quot;I&quot; : &quot;i&quot;);
 324     number--;
 325     }
 326 }
 327 
 328 static void
 329 xsltNumberFormatTokenize(const xmlChar *format,
 330              xsltFormatPtr tokens)
 331 {
 332     int ix = 0;
 333     int j;
 334     int val;
 335     int len;
 336 
 337     default_token.token = DEFAULT_TOKEN;
 338     default_token.width = 1;
 339     default_token.separator = BAD_CAST(DEFAULT_SEPARATOR);
 340 
 341 
 342     tokens-&gt;start = NULL;
 343     tokens-&gt;tokens[0].separator = NULL;
 344     tokens-&gt;end = NULL;
 345 
 346     /*
 347      * Insert initial non-alphanumeric token.
 348      * There is always such a token in the list, even if NULL
 349      */
 350     while (! (IS_LETTER(val=xmlStringCurrentChar(NULL, format+ix, &amp;len)) ||
 351           IS_DIGIT(val)) ) {
 352     if (format[ix] == 0)        /* if end of format string */
 353         break; /* while */
 354     ix += len;
 355     }
 356     if (ix &gt; 0)
 357     tokens-&gt;start = xmlStrndup(format, ix);
 358 
 359 
 360     for (tokens-&gt;nTokens = 0; tokens-&gt;nTokens &lt; MAX_TOKENS;
 361      tokens-&gt;nTokens++) {
 362     if (format[ix] == 0)
 363         break; /* for */
 364 
 365     /*
 366      * separator has already been parsed (except for the first
 367      * number) in tokens-&gt;end, recover it.
 368      */
 369     if (tokens-&gt;nTokens &gt; 0) {
 370         tokens-&gt;tokens[tokens-&gt;nTokens].separator = tokens-&gt;end;
 371         tokens-&gt;end = NULL;
 372     }
 373 
 374     val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 375     if (IS_DIGIT_ONE(val) ||
 376          IS_DIGIT_ZERO(val)) {
 377         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 378         while (IS_DIGIT_ZERO(val)) {
 379         tokens-&gt;tokens[tokens-&gt;nTokens].width++;
 380         ix += len;
 381         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 382         }
 383         if (IS_DIGIT_ONE(val)) {
 384         tokens-&gt;tokens[tokens-&gt;nTokens].token = val - 1;
 385         ix += len;
 386         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 387         } else {
 388                 tokens-&gt;tokens[tokens-&gt;nTokens].token = &#39;0&#39;;
 389                 tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 390             }
 391     } else if ( (val == &#39;A&#39;) ||
 392             (val == &#39;a&#39;) ||
 393             (val == &#39;I&#39;) ||
 394             (val == &#39;i&#39;) ) {
 395         tokens-&gt;tokens[tokens-&gt;nTokens].token = val;
 396         ix += len;
 397         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 398     } else {
 399         /* XSLT section 7.7
 400          * &quot;Any other format token indicates a numbering sequence
 401          *  that starts with that token. If an implementation does
 402          *  not support a numbering sequence that starts with that
 403          *  token, it must use a format token of 1.&quot;
 404          */
 405         tokens-&gt;tokens[tokens-&gt;nTokens].token = &#39;0&#39;;
 406         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 407     }
 408     /*
 409      * Skip over remaining alphanumeric characters from the Nd
 410      * (Number, decimal digit), Nl (Number, letter), No (Number,
 411      * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt
 412      * (Letters, titlecase), Lm (Letters, modifiers), and Lo
 413      * (Letters, other (uncased)) Unicode categories. This happens
 414      * to correspond to the Letter and Digit classes from XML (and
 415      * one wonders why XSLT doesn&#39;t refer to these instead).
 416      */
 417     while (IS_LETTER(val) || IS_DIGIT(val)) {
 418         ix += len;
 419         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 420     }
 421 
 422     /*
 423      * Insert temporary non-alphanumeric final tooken.
 424      */
 425     j = ix;
 426     while (! (IS_LETTER(val) || IS_DIGIT(val))) {
 427         if (val == 0)
 428         break; /* while */
 429         ix += len;
 430         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 431     }
 432     if (ix &gt; j)
 433         tokens-&gt;end = xmlStrndup(&amp;format[j], ix - j);
 434     }
 435 }
 436 
 437 static void
 438 xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,
 439                   double *numbers,
 440                   int numbers_max,
 441                   xsltFormatPtr tokens,
 442                   xmlBufferPtr buffer)
 443 {
 444     int i = 0;
 445     double number;
 446     xsltFormatTokenPtr token;
 447 
 448     /*
 449      * Handle initial non-alphanumeric token
 450      */
 451     if (tokens-&gt;start != NULL)
 452      xmlBufferCat(buffer, tokens-&gt;start);
 453 
 454     for (i = 0; i &lt; numbers_max; i++) {
 455     /* Insert number */
 456     number = numbers[(numbers_max - 1) - i];
 457         /* Round to nearest like XSLT 2.0 */
 458         number = floor(number + 0.5);
 459         /*
 460          * XSLT 1.0 isn&#39;t clear on how to handle negative numbers, but XSLT
 461          * 2.0 says:
 462          *
 463          *     It is a non-recoverable dynamic error if any undiscarded item
 464          *     in the atomized sequence supplied as the value of the value
 465          *     attribute of xsl:number cannot be converted to an integer, or
 466          *     if the resulting integer is less than 0 (zero).
 467          */
 468         if (number &lt; 0.0) {
 469             xsltTransformError(NULL, NULL, NULL,
 470                     &quot;xsl-number : negative value\n&quot;);
 471             /* Recover by treating negative values as zero. */
 472             number = 0.0;
 473         }
 474     if (i &lt; tokens-&gt;nTokens) {
 475       /*
 476        * The &quot;n&quot;th format token will be used to format the &quot;n&quot;th
 477        * number in the list
 478        */
 479       token = &amp;(tokens-&gt;tokens[i]);
 480     } else if (tokens-&gt;nTokens &gt; 0) {
 481       /*
 482        * If there are more numbers than format tokens, then the
 483        * last format token will be used to format the remaining
 484        * numbers.
 485        */
 486       token = &amp;(tokens-&gt;tokens[tokens-&gt;nTokens - 1]);
 487     } else {
 488       /*
 489        * If there are no format tokens, then a format token of
 490        * 1 is used to format all numbers.
 491        */
 492       token = &amp;default_token;
 493     }
 494 
 495     /* Print separator, except for the first number */
 496     if (i &gt; 0) {
 497         if (token-&gt;separator != NULL)
 498         xmlBufferCat(buffer, token-&gt;separator);
 499         else
 500         xmlBufferCCat(buffer, DEFAULT_SEPARATOR);
 501     }
 502 
 503     switch (xmlXPathIsInf(number)) {
 504     case -1:
 505         xmlBufferCCat(buffer, &quot;-Infinity&quot;);
 506         break;
 507     case 1:
 508         xmlBufferCCat(buffer, &quot;Infinity&quot;);
 509         break;
 510     default:
 511         if (xmlXPathIsNaN(number)) {
 512         xmlBufferCCat(buffer, &quot;NaN&quot;);
 513         } else {
 514 
 515         switch (token-&gt;token) {
 516         case &#39;A&#39;:
 517             xsltNumberFormatAlpha(data, buffer, number, TRUE);
 518             break;
 519         case &#39;a&#39;:
 520             xsltNumberFormatAlpha(data, buffer, number, FALSE);
 521             break;
 522         case &#39;I&#39;:
 523             xsltNumberFormatRoman(data, buffer, number, TRUE);
 524             break;
 525         case &#39;i&#39;:
 526             xsltNumberFormatRoman(data, buffer, number, FALSE);
 527             break;
 528         default:
 529             if (IS_DIGIT_ZERO(token-&gt;token)) {
 530             xsltNumberFormatDecimal(buffer,
 531                         number,
 532                         token-&gt;token,
 533                         token-&gt;width,
 534                         data-&gt;digitsPerGroup,
 535                         data-&gt;groupingCharacter,
 536                         data-&gt;groupingCharacterLen);
 537             }
 538             break;
 539         }
 540         }
 541 
 542     }
 543     }
 544 
 545     /*
 546      * Handle final non-alphanumeric token
 547      */
 548     if (tokens-&gt;end != NULL)
 549      xmlBufferCat(buffer, tokens-&gt;end);
 550 
 551 }
 552 
 553 static int
 554 xsltTestCompMatchCount(xsltTransformContextPtr context,
 555                        xmlNodePtr node,
 556                        xsltCompMatchPtr countPat,
 557                        xmlNodePtr cur)
 558 {
 559     if (countPat != NULL) {
 560         return xsltTestCompMatchList(context, node, countPat);
 561     }
 562     else {
 563         /*
 564          * 7.7 Numbering
 565          *
 566          * If count attribute is not specified, then it defaults to the
 567          * pattern that matches any node with the same node type as the
 568          * current node and, if the current node has an expanded-name, with
 569          * the same expanded-name as the current node.
 570          */
 571         if (node-&gt;type != cur-&gt;type)
 572             return 0;
 573         if (node-&gt;type == XML_NAMESPACE_DECL)
 574             /*
 575              * Namespace nodes have no preceding siblings and no parents
 576              * that are namespace nodes. This means that node == cur.
 577              */
 578             return 1;
 579         /* TODO: Skip node types without expanded names like text nodes. */
 580         if (!xmlStrEqual(node-&gt;name, cur-&gt;name))
 581             return 0;
 582         if (node-&gt;ns == cur-&gt;ns)
 583             return 1;
 584         if ((node-&gt;ns == NULL) || (cur-&gt;ns == NULL))
 585             return 0;
 586         return (xmlStrEqual(node-&gt;ns-&gt;href, cur-&gt;ns-&gt;href));
 587     }
 588 }
 589 
 590 static int
 591 xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,
 592                 xmlNodePtr node,
 593                 xsltCompMatchPtr countPat,
 594                 xsltCompMatchPtr fromPat,
 595                 double *array)
 596 {
 597     int amount = 0;
 598     int cnt = 0;
 599     xmlNodePtr cur = node;
 600 
 601     while (cur != NULL) {
 602     /* process current node */
 603     if (xsltTestCompMatchCount(context, cur, countPat, node))
 604         cnt++;
 605     if ((fromPat != NULL) &amp;&amp;
 606         xsltTestCompMatchList(context, cur, fromPat)) {
 607         break; /* while */
 608     }
 609 
 610     /* Skip to next preceding or ancestor */
 611     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 612 #ifdef LIBXML_DOCB_ENABLED
 613             (cur-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 614 #endif
 615             (cur-&gt;type == XML_HTML_DOCUMENT_NODE))
 616         break; /* while */
 617 
 618         if (cur-&gt;type == XML_NAMESPACE_DECL) {
 619             /*
 620             * The XPath module stores the parent of a namespace node in
 621             * the ns-&gt;next field.
 622             */
 623             cur = (xmlNodePtr) ((xmlNsPtr) cur)-&gt;next;
 624         } else if (cur-&gt;type == XML_ATTRIBUTE_NODE) {
 625             cur = cur-&gt;parent;
 626         } else {
 627             while ((cur-&gt;prev != NULL) &amp;&amp; ((cur-&gt;prev-&gt;type == XML_DTD_NODE) ||
 628                    (cur-&gt;prev-&gt;type == XML_XINCLUDE_START) ||
 629                    (cur-&gt;prev-&gt;type == XML_XINCLUDE_END)))
 630                 cur = cur-&gt;prev;
 631             if (cur-&gt;prev != NULL) {
 632                 for (cur = cur-&gt;prev; cur-&gt;last != NULL; cur = cur-&gt;last);
 633             } else {
 634                 cur = cur-&gt;parent;
 635             }
 636         }
 637     }
 638 
 639     array[amount++] = (double) cnt;
 640 
 641     return(amount);
 642 }
 643 
 644 static int
 645 xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 646                  xmlNodePtr node,
 647                  xsltCompMatchPtr countPat,
 648                  xsltCompMatchPtr fromPat,
 649                  double *array,
 650                  int max)
 651 {
 652     int amount = 0;
 653     int cnt;
 654     xmlNodePtr oldCtxtNode;
 655     xmlNodePtr ancestor;
 656     xmlNodePtr preceding;
 657     xmlXPathParserContextPtr parser;
 658 
 659     oldCtxtNode = context-&gt;xpathCtxt-&gt;node;
 660     parser = xmlXPathNewParserContext(NULL, context-&gt;xpathCtxt);
 661     if (parser) {
 662     /* ancestor-or-self::*[count] */
 663     ancestor = node;
 664     while ((ancestor != NULL) &amp;&amp; (ancestor-&gt;type != XML_DOCUMENT_NODE)) {
 665         if ((fromPat != NULL) &amp;&amp;
 666         xsltTestCompMatchList(context, ancestor, fromPat))
 667         break; /* for */
 668 
 669             /*
 670              * The xmlXPathNext* iterators require that the context node is
 671              * set to the start node. Calls to xsltTestCompMatch* may also
 672              * leave the context node in an undefined state, so make sure
 673              * that the context node is reset before each iterator invocation.
 674              */
 675 
 676         if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 677         /* count(preceding-sibling::*) */
 678         cnt = 1;
 679                 context-&gt;xpathCtxt-&gt;node = ancestor;
 680                 preceding = xmlXPathNextPrecedingSibling(parser, ancestor);
 681                 while (preceding != NULL) {
 682                 if (xsltTestCompMatchCount(context, preceding, countPat,
 683                                                node))
 684             cnt++;
 685                     context-&gt;xpathCtxt-&gt;node = ancestor;
 686                     preceding =
 687                         xmlXPathNextPrecedingSibling(parser, preceding);
 688         }
 689         array[amount++] = (double)cnt;
 690         if (amount &gt;= max)
 691             break; /* for */
 692         }
 693             context-&gt;xpathCtxt-&gt;node = node;
 694             ancestor = xmlXPathNextAncestor(parser, ancestor);
 695     }
 696     xmlXPathFreeParserContext(parser);
 697     }
 698     context-&gt;xpathCtxt-&gt;node = oldCtxtNode;
 699     return amount;
 700 }
 701 
 702 static int
 703 xsltNumberFormatGetValue(xmlXPathContextPtr context,
 704              xmlNodePtr node,
 705              const xmlChar *value,
 706              double *number)
 707 {
 708     int amount = 0;
 709     xmlBufferPtr pattern;
 710     xmlXPathObjectPtr obj;
 711 
 712     pattern = xmlBufferCreate();
 713     if (pattern != NULL) {
 714     xmlBufferCCat(pattern, &quot;number(&quot;);
 715     xmlBufferCat(pattern, value);
 716     xmlBufferCCat(pattern, &quot;)&quot;);
 717     context-&gt;node = node;
 718     obj = xmlXPathEvalExpression(xmlBufferContent(pattern),
 719                      context);
 720     if (obj != NULL) {
 721         *number = obj-&gt;floatval;
 722         amount++;
 723         xmlXPathFreeObject(obj);
 724     }
 725     xmlBufferFree(pattern);
 726     }
 727     return amount;
 728 }
 729 
 730 /**
 731  * xsltNumberFormat:
 732  * @ctxt: the XSLT transformation context
 733  * @data: the formatting information
 734  * @node: the data to format
 735  *
 736  * Convert one number.
 737  */
 738 void
 739 xsltNumberFormat(xsltTransformContextPtr ctxt,
 740          xsltNumberDataPtr data,
 741          xmlNodePtr node)
 742 {
 743     xmlBufferPtr output = NULL;
 744     int amount, i;
 745     double number;
 746     xsltFormat tokens;
 747 
 748     if (data-&gt;format != NULL) {
 749         xsltNumberFormatTokenize(data-&gt;format, &amp;tokens);
 750     }
 751     else {
 752         xmlChar *format;
 753 
 754     /* The format needs to be recomputed each time */
 755         if (data-&gt;has_format == 0)
 756             return;
 757     format = xsltEvalAttrValueTemplate(ctxt, data-&gt;node,
 758                          (const xmlChar *) &quot;format&quot;,
 759                          XSLT_NAMESPACE);
 760         if (format == NULL)
 761             return;
 762         xsltNumberFormatTokenize(format, &amp;tokens);
 763     xmlFree(format);
 764     }
 765 
 766     output = xmlBufferCreate();
 767     if (output == NULL)
 768     goto XSLT_NUMBER_FORMAT_END;
 769 
 770     /*
 771      * Evaluate the XPath expression to find the value(s)
 772      */
 773     if (data-&gt;value) {
 774     amount = xsltNumberFormatGetValue(ctxt-&gt;xpathCtxt,
 775                       node,
 776                       data-&gt;value,
 777                       &amp;number);
 778     if (amount == 1) {
 779         xsltNumberFormatInsertNumbers(data,
 780                       &amp;number,
 781                       1,
 782                       &amp;tokens,
 783                       output);
 784     }
 785 
 786     } else if (data-&gt;level) {
 787 
 788     if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;single&quot;)) {
 789         amount = xsltNumberFormatGetMultipleLevel(ctxt,
 790                               node,
 791                               data-&gt;countPat,
 792                               data-&gt;fromPat,
 793                               &amp;number,
 794                               1);
 795         if (amount == 1) {
 796         xsltNumberFormatInsertNumbers(data,
 797                           &amp;number,
 798                           1,
 799                           &amp;tokens,
 800                           output);
 801         }
 802     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;multiple&quot;)) {
 803         double numarray[1024];
 804         int max = sizeof(numarray)/sizeof(numarray[0]);
 805         amount = xsltNumberFormatGetMultipleLevel(ctxt,
 806                               node,
 807                               data-&gt;countPat,
 808                               data-&gt;fromPat,
 809                               numarray,
 810                               max);
 811         if (amount &gt; 0) {
 812         xsltNumberFormatInsertNumbers(data,
 813                           numarray,
 814                           amount,
 815                           &amp;tokens,
 816                           output);
 817         }
 818     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;any&quot;)) {
 819         amount = xsltNumberFormatGetAnyLevel(ctxt,
 820                          node,
 821                          data-&gt;countPat,
 822                          data-&gt;fromPat,
 823                          &amp;number);
 824         if (amount &gt; 0) {
 825         xsltNumberFormatInsertNumbers(data,
 826                           &amp;number,
 827                           1,
 828                           &amp;tokens,
 829                           output);
 830         }
 831     }
 832 
 833         /*
 834          * Unlike `match` patterns, `count` and `from` patterns can contain
 835          * variable references, so we have to clear the pattern match
 836          * cache if the &quot;direct&quot; matching algorithm was used.
 837          */
 838         if (data-&gt;countPat != NULL)
 839             xsltCompMatchClearCache(ctxt, data-&gt;countPat);
 840         if (data-&gt;fromPat != NULL)
 841             xsltCompMatchClearCache(ctxt, data-&gt;fromPat);
 842     }
 843     /* Insert number as text node */
 844     xsltCopyTextString(ctxt, ctxt-&gt;insert, xmlBufferContent(output), 0);
 845 
 846     xmlBufferFree(output);
 847 
 848 XSLT_NUMBER_FORMAT_END:
 849     if (tokens.start != NULL)
 850     xmlFree(tokens.start);
 851     if (tokens.end != NULL)
 852     xmlFree(tokens.end);
 853     for (i = 0;i &lt; tokens.nTokens;i++) {
 854     if (tokens.tokens[i].separator != NULL)
 855         xmlFree(tokens.tokens[i].separator);
 856     }
 857 }
 858 
 859 static int
 860 xsltFormatNumberPreSuffix(xsltDecimalFormatPtr self, xmlChar **format, xsltFormatNumberInfoPtr info)
 861 {
 862     /* will hold total length of prefix/suffix without quote characters */
 863     int count=0;
 864     int len;
 865 
 866     while (1) {
 867     /*
 868      * prefix / suffix ends at end of string or at
 869      * first &#39;special&#39; character
 870      */
 871     if (**format == 0)
 872         return count;
 873     /* if next character &#39;escaped&#39; just count it */
 874     if (**format == SYMBOL_QUOTE) {
 875         if (*++(*format) == 0)
 876         return -1;
 877     }
 878     else if (IS_SPECIAL(self, *format))
 879         return count;
 880     /*
 881      * else treat percent/per-mille as special cases,
 882      * depending on whether +ve or -ve
 883      */
 884     else {
 885         /*
 886          * for +ve prefix/suffix, allow only a
 887          * single occurence of either
 888          */
 889         if (xsltUTF8Charcmp(*format, self-&gt;percent) == 0) {
 890         if (info-&gt;is_multiplier_set)
 891             return -1;
 892         info-&gt;multiplier = 100;
 893         info-&gt;is_multiplier_set = TRUE;
 894         } else if (xsltUTF8Charcmp(*format, self-&gt;permille) == 0) {
 895         if (info-&gt;is_multiplier_set)
 896             return -1;
 897         info-&gt;multiplier = 1000;
 898         info-&gt;is_multiplier_set = TRUE;
 899         }
 900     }
 901 
 902     if ((len=xmlUTF8Strsize(*format, 1)) &lt; 1)
 903         return -1;
 904     count += len;
 905     *format += len;
 906     }
 907 }
 908 
 909 /**
 910  * xsltFormatNumberConversion:
 911  * @self: the decimal format
 912  * @format: the format requested
 913  * @number: the value to format
 914  * @result: the place to output the result
 915  *
 916  * format-number() uses the JDK 1.1 DecimalFormat class:
 917  *
 918  * http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html
 919  *
 920  * Structure:
 921  *
 922  *   pattern    := subpattern{;subpattern}
 923  *   subpattern := {prefix}integer{.fraction}{suffix}
 924  *   prefix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 925  *   suffix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 926  *   integer    := &#39;#&#39;* &#39;0&#39;* &#39;0&#39;
 927  *   fraction   := &#39;0&#39;* &#39;#&#39;*
 928  *
 929  *   Notation:
 930  *    X*       0 or more instances of X
 931  *    (X | Y)  either X or Y.
 932  *    X..Y     any character from X up to Y, inclusive.
 933  *    S - T    characters in S, except those in T
 934  *
 935  * Special Characters:
 936  *
 937  *   Symbol Meaning
 938  *   0      a digit
 939  *   #      a digit, zero shows as absent
 940  *   .      placeholder for decimal separator
 941  *   ,      placeholder for grouping separator.
 942  *   ;      separates formats.
 943  *   -      default negative prefix.
 944  *   %      multiply by 100 and show as percentage
 945  *   ?      multiply by 1000 and show as per mille
 946  *   X      any other characters can be used in the prefix or suffix
 947  *   &#39;      used to quote special characters in a prefix or suffix.
 948  *
 949  * Returns a possible XPath error
 950  */
 951 xmlXPathError
 952 xsltFormatNumberConversion(xsltDecimalFormatPtr self,
 953                xmlChar *format,
 954                double number,
 955                xmlChar **result)
 956 {
 957     xmlXPathError status = XPATH_EXPRESSION_OK;
 958     xmlBufferPtr buffer;
 959     xmlChar *the_format, *prefix = NULL, *suffix = NULL;
 960     xmlChar *nprefix, *nsuffix = NULL;
 961     int     prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
 962     double  scale;
 963     int     j, len;
 964     int     self_grouping_len;
 965     xsltFormatNumberInfo format_info;
 966     /*
 967      * delayed_multiplier allows a &#39;trailing&#39; percent or
 968      * permille to be treated as suffix
 969      */
 970     int     delayed_multiplier = 0;
 971     /* flag to show no -ve format present for -ve number */
 972     char    default_sign = 0;
 973     /* flag to show error found, should use default format */
 974     char    found_error = 0;
 975 
 976     if (xmlStrlen(format) &lt;= 0) {
 977     xsltTransformError(NULL, NULL, NULL,
 978                 &quot;xsltFormatNumberConversion : &quot;
 979         &quot;Invalid format (0-length)\n&quot;);
 980     }
 981     *result = NULL;
 982     switch (xmlXPathIsInf(number)) {
 983     case -1:
 984         if (self-&gt;minusSign == NULL)
 985         *result = xmlStrdup(BAD_CAST &quot;-&quot;);
 986         else
 987         *result = xmlStrdup(self-&gt;minusSign);
 988         /* Intentional fall-through */
 989     case 1:
 990         if ((self == NULL) || (self-&gt;infinity == NULL))
 991         *result = xmlStrcat(*result, BAD_CAST &quot;Infinity&quot;);
 992         else
 993         *result = xmlStrcat(*result, self-&gt;infinity);
 994         return(status);
 995     default:
 996         if (xmlXPathIsNaN(number)) {
 997         if ((self == NULL) || (self-&gt;noNumber == NULL))
 998             *result = xmlStrdup(BAD_CAST &quot;NaN&quot;);
 999         else
1000             *result = xmlStrdup(self-&gt;noNumber);
1001         return(status);
1002         }
1003     }
1004 
1005     buffer = xmlBufferCreate();
1006     if (buffer == NULL) {
1007     return XPATH_MEMORY_ERROR;
1008     }
1009 
1010     format_info.integer_hash = 0;
1011     format_info.integer_digits = 0;
1012     format_info.frac_digits = 0;
1013     format_info.frac_hash = 0;
1014     format_info.group = -1;
1015     format_info.multiplier = 1;
1016     format_info.add_decimal = FALSE;
1017     format_info.is_multiplier_set = FALSE;
1018     format_info.is_negative_pattern = FALSE;
1019 
1020     the_format = format;
1021 
1022     /*
1023      * First we process the +ve pattern to get percent / permille,
1024      * as well as main format
1025      */
1026     prefix = the_format;
1027     prefix_length = xsltFormatNumberPreSuffix(self, &amp;the_format, &amp;format_info);
1028     if (prefix_length &lt; 0) {
1029     found_error = 1;
1030     goto OUTPUT_NUMBER;
1031     }
1032 
1033     /*
1034      * Here we process the &quot;number&quot; part of the format.  It gets
1035      * a little messy because of the percent/per-mille - if that
1036      * appears at the end, it may be part of the suffix instead
1037      * of part of the number, so the variable delayed_multiplier
1038      * is used to handle it
1039      */
1040     self_grouping_len = xmlStrlen(self-&gt;grouping);
1041     while ((*the_format != 0) &amp;&amp;
1042        (xsltUTF8Charcmp(the_format, self-&gt;decimalPoint) != 0) &amp;&amp;
1043        (xsltUTF8Charcmp(the_format, self-&gt;patternSeparator) != 0)) {
1044 
1045     if (delayed_multiplier != 0) {
1046         format_info.multiplier = delayed_multiplier;
1047         format_info.is_multiplier_set = TRUE;
1048         delayed_multiplier = 0;
1049     }
1050     if (xsltUTF8Charcmp(the_format, self-&gt;digit) == 0) {
1051         if (format_info.integer_digits &gt; 0) {
1052         found_error = 1;
1053         goto OUTPUT_NUMBER;
1054         }
1055         format_info.integer_hash++;
1056         if (format_info.group &gt;= 0)
1057         format_info.group++;
1058     } else if (xsltUTF8Charcmp(the_format, self-&gt;zeroDigit) == 0) {
1059         format_info.integer_digits++;
1060         if (format_info.group &gt;= 0)
1061         format_info.group++;
1062     } else if ((self_grouping_len &gt; 0) &amp;&amp;
1063         (!xmlStrncmp(the_format, self-&gt;grouping, self_grouping_len))) {
1064         /* Reset group count */
1065         format_info.group = 0;
1066         the_format += self_grouping_len;
1067         continue;
1068     } else if (xsltUTF8Charcmp(the_format, self-&gt;percent) == 0) {
1069         if (format_info.is_multiplier_set) {
1070         found_error = 1;
1071         goto OUTPUT_NUMBER;
1072         }
1073         delayed_multiplier = 100;
1074     } else  if (xsltUTF8Charcmp(the_format, self-&gt;permille) == 0) {
1075         if (format_info.is_multiplier_set) {
1076         found_error = 1;
1077         goto OUTPUT_NUMBER;
1078         }
1079         delayed_multiplier = 1000;
1080     } else
1081         break; /* while */
1082 
1083     if ((len=xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1084         found_error = 1;
1085         goto OUTPUT_NUMBER;
1086     }
1087     the_format += len;
1088 
1089     }
1090 
1091     /* We have finished the integer part, now work on fraction */
1092     if ( (*the_format != 0) &amp;&amp;
1093          (xsltUTF8Charcmp(the_format, self-&gt;decimalPoint) == 0) ) {
1094         format_info.add_decimal = TRUE;
1095         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1096             found_error = 1;
1097             goto OUTPUT_NUMBER;
1098         }
1099     the_format += len;  /* Skip over the decimal */
1100     }
1101 
1102     while (*the_format != 0) {
1103 
1104     if (xsltUTF8Charcmp(the_format, self-&gt;zeroDigit) == 0) {
1105         if (format_info.frac_hash != 0) {
1106         found_error = 1;
1107         goto OUTPUT_NUMBER;
1108         }
1109         format_info.frac_digits++;
1110     } else if (xsltUTF8Charcmp(the_format, self-&gt;digit) == 0) {
1111         format_info.frac_hash++;
1112     } else if (xsltUTF8Charcmp(the_format, self-&gt;percent) == 0) {
1113         if (format_info.is_multiplier_set) {
1114         found_error = 1;
1115         goto OUTPUT_NUMBER;
1116         }
1117         delayed_multiplier = 100;
1118         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1119             found_error = 1;
1120         goto OUTPUT_NUMBER;
1121         }
1122         the_format += len;
1123         continue; /* while */
1124     } else if (xsltUTF8Charcmp(the_format, self-&gt;permille) == 0) {
1125         if (format_info.is_multiplier_set) {
1126         found_error = 1;
1127         goto OUTPUT_NUMBER;
1128         }
1129         delayed_multiplier = 1000;
1130         if  ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1131             found_error = 1;
1132         goto OUTPUT_NUMBER;
1133         }
1134         the_format += len;
1135         continue; /* while */
1136     } else if (xsltUTF8Charcmp(the_format, self-&gt;grouping) != 0) {
1137         break; /* while */
1138     }
1139     if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1140         found_error = 1;
1141         goto OUTPUT_NUMBER;
1142     }
1143     the_format += len;
1144     if (delayed_multiplier != 0) {
1145         format_info.multiplier = delayed_multiplier;
1146         delayed_multiplier = 0;
1147         format_info.is_multiplier_set = TRUE;
1148     }
1149     }
1150 
1151     /*
1152      * If delayed_multiplier is set after processing the
1153      * &quot;number&quot; part, should be in suffix
1154      */
1155     if (delayed_multiplier != 0) {
1156     the_format -= len;
1157     delayed_multiplier = 0;
1158     }
1159 
1160     suffix = the_format;
1161     suffix_length = xsltFormatNumberPreSuffix(self, &amp;the_format, &amp;format_info);
1162     if ( (suffix_length &lt; 0) ||
1163      ((*the_format != 0) &amp;&amp;
1164       (xsltUTF8Charcmp(the_format, self-&gt;patternSeparator) != 0)) ) {
1165     found_error = 1;
1166     goto OUTPUT_NUMBER;
1167     }
1168 
1169     /*
1170      * We have processed the +ve prefix, number part and +ve suffix.
1171      * If the number is -ve, we must substitute the -ve prefix / suffix
1172      */
1173     if (number &lt; 0) {
1174         /*
1175      * Note that j is the number of UTF8 chars before the separator,
1176      * not the number of bytes! (bug 151975)
1177      */
1178         j =  xmlUTF8Strloc(format, self-&gt;patternSeparator);
1179     if (j &lt; 0) {
1180     /* No -ve pattern present, so use default signing */
1181         default_sign = 1;
1182     }
1183     else {
1184         /* Skip over pattern separator (accounting for UTF8) */
1185         the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);
1186         /*
1187          * Flag changes interpretation of percent/permille
1188          * in -ve pattern
1189          */
1190         format_info.is_negative_pattern = TRUE;
1191         format_info.is_multiplier_set = FALSE;
1192 
1193         /* First do the -ve prefix */
1194         nprefix = the_format;
1195         nprefix_length = xsltFormatNumberPreSuffix(self,
1196                     &amp;the_format, &amp;format_info);
1197         if (nprefix_length&lt;0) {
1198         found_error = 1;
1199         goto OUTPUT_NUMBER;
1200         }
1201 
1202         while (*the_format != 0) {
1203         if ( (xsltUTF8Charcmp(the_format, (self)-&gt;percent) == 0) ||
1204              (xsltUTF8Charcmp(the_format, (self)-&gt;permille)== 0) ) {
1205             if (format_info.is_multiplier_set) {
1206             found_error = 1;
1207             goto OUTPUT_NUMBER;
1208             }
1209             format_info.is_multiplier_set = TRUE;
1210             delayed_multiplier = 1;
1211         }
1212         else if (IS_SPECIAL(self, the_format))
1213             delayed_multiplier = 0;
1214         else
1215             break; /* while */
1216         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1217             found_error = 1;
1218             goto OUTPUT_NUMBER;
1219         }
1220         the_format += len;
1221         }
1222         if (delayed_multiplier != 0) {
1223         format_info.is_multiplier_set = FALSE;
1224         the_format -= len;
1225         }
1226 
1227         /* Finally do the -ve suffix */
1228         if (*the_format != 0) {
1229         nsuffix = the_format;
1230         nsuffix_length = xsltFormatNumberPreSuffix(self,
1231                     &amp;the_format, &amp;format_info);
1232         if (nsuffix_length &lt; 0) {
1233             found_error = 1;
1234             goto OUTPUT_NUMBER;
1235         }
1236         }
1237         else
1238         nsuffix_length = 0;
1239         if (*the_format != 0) {
1240         found_error = 1;
1241         goto OUTPUT_NUMBER;
1242         }
1243         /*
1244          * Here&#39;s another Java peculiarity:
1245          * if -ve prefix/suffix == +ve ones, discard &amp; use default
1246          */
1247         if ((nprefix_length != prefix_length) ||
1248         (nsuffix_length != suffix_length) ||
1249         ((nprefix_length &gt; 0) &amp;&amp;
1250          (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||
1251         ((nsuffix_length &gt; 0) &amp;&amp;
1252          (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {
1253         prefix = nprefix;
1254         prefix_length = nprefix_length;
1255         suffix = nsuffix;
1256         suffix_length = nsuffix_length;
1257         } /* else {
1258         default_sign = 1;
1259         }
1260         */
1261     }
1262     }
1263 
1264 OUTPUT_NUMBER:
1265     if (found_error != 0) {
1266     xsltTransformError(NULL, NULL, NULL,
1267                 &quot;xsltFormatNumberConversion : &quot;
1268         &quot;error in format string &#39;%s&#39;, using default\n&quot;, format);
1269     default_sign = (number &lt; 0.0) ? 1 : 0;
1270     prefix_length = suffix_length = 0;
1271     format_info.integer_hash = 0;
1272     format_info.integer_digits = 1;
1273     format_info.frac_digits = 1;
1274     format_info.frac_hash = 4;
1275     format_info.group = -1;
1276     format_info.multiplier = 1;
1277     format_info.add_decimal = TRUE;
1278     }
1279 
1280     /* Ready to output our number.  First see if &quot;default sign&quot; is required */
1281     if (default_sign != 0)
1282     xmlBufferAdd(buffer, self-&gt;minusSign, xmlUTF8Strsize(self-&gt;minusSign, 1));
1283 
1284     /* Put the prefix into the buffer */
1285     for (j = 0; j &lt; prefix_length; ) {
1286     if (*prefix == SYMBOL_QUOTE)
1287             prefix++;
1288         len = xmlUTF8Strsize(prefix, 1);
1289         xmlBufferAdd(buffer, prefix, len);
1290         prefix += len;
1291         j += len;
1292     }
1293 
1294     /* Next do the integer part of the number */
1295     number = fabs(number) * (double)format_info.multiplier;
1296     scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
1297     number = floor((scale * number + 0.5)) / scale;
1298     if ((self-&gt;grouping != NULL) &amp;&amp;
1299         (self-&gt;grouping[0] != 0)) {
1300         int gchar;
1301 
1302     len = xmlStrlen(self-&gt;grouping);
1303     gchar = xsltGetUTF8Char(self-&gt;grouping, &amp;len);
1304     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1305                 format_info.integer_digits,
1306                 format_info.group,
1307                 gchar, len);
1308     } else
1309     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1310                 format_info.integer_digits,
1311                 format_info.group,
1312                 &#39;,&#39;, 1);
1313 
1314     /* Special case: java treats &#39;.#&#39; like &#39;.0&#39;, &#39;.##&#39; like &#39;.0#&#39;, etc. */
1315     if ((format_info.integer_digits + format_info.integer_hash +
1316      format_info.frac_digits == 0) &amp;&amp; (format_info.frac_hash &gt; 0)) {
1317         ++format_info.frac_digits;
1318     --format_info.frac_hash;
1319     }
1320 
1321     /* Add leading zero, if required */
1322     if ((floor(number) == 0) &amp;&amp;
1323     (format_info.integer_digits + format_info.frac_digits == 0)) {
1324         xmlBufferAdd(buffer, self-&gt;zeroDigit, xmlUTF8Strsize(self-&gt;zeroDigit, 1));
1325     }
1326 
1327     /* Next the fractional part, if required */
1328     if (format_info.frac_digits + format_info.frac_hash == 0) {
1329         if (format_info.add_decimal)
1330         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1331              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1332     }
1333     else {
1334       number -= floor(number);
1335     if ((number != 0) || (format_info.frac_digits != 0)) {
1336         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1337              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1338         number = floor(scale * number + 0.5);
1339         for (j = format_info.frac_hash; j &gt; 0; j--) {
1340         if (fmod(number, 10.0) &gt;= 1.0)
1341             break; /* for */
1342         number /= 10.0;
1343         }
1344         xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1345                 format_info.frac_digits + j,
1346                 0, 0, 0);
1347     }
1348     }
1349     /* Put the suffix into the buffer */
1350     for (j = 0; j &lt; suffix_length; ) {
1351     if (*suffix == SYMBOL_QUOTE)
1352             suffix++;
1353         len = xmlUTF8Strsize(suffix, 1);
1354         xmlBufferAdd(buffer, suffix, len);
1355         suffix += len;
1356         j += len;
1357     }
1358 
1359     *result = xmlStrdup(xmlBufferContent(buffer));
1360     xmlBufferFree(buffer);
1361     return status;
1362 }
1363 
    </pre>
  </body>
</html>