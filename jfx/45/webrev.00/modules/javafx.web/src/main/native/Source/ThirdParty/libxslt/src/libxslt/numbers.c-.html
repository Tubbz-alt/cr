<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * numbers.c: Implementation of the XSLT number functions
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  * Bjorn Reese &lt;breese@users.sourceforge.net&gt;
  11  */
  12 
  13 #define IN_LIBXSLT
  14 #include &quot;libxslt.h&quot;
  15 
  16 #include &lt;math.h&gt;
  17 #include &lt;limits.h&gt;
  18 #include &lt;float.h&gt;
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parserInternals.h&gt;
  23 #include &lt;libxml/xpath.h&gt;
  24 #include &lt;libxml/xpathInternals.h&gt;
  25 #include &lt;libxml/encoding.h&gt;
  26 #include &quot;xsltutils.h&quot;
  27 #include &quot;pattern.h&quot;
  28 #include &quot;templates.h&quot;
  29 #include &quot;transform.h&quot;
  30 #include &quot;numbersInternals.h&quot;
  31 
  32 #ifndef FALSE
  33 # define FALSE (0 == 1)
  34 # define TRUE (1 == 1)
  35 #endif
  36 
  37 #define SYMBOL_QUOTE        ((xmlChar)&#39;\&#39;&#39;)
  38 
  39 #define DEFAULT_TOKEN       (xmlChar)&#39;0&#39;
  40 #define DEFAULT_SEPARATOR   &quot;.&quot;
  41 
  42 #define MAX_TOKENS      1024
  43 
  44 typedef struct _xsltFormatToken xsltFormatToken;
  45 typedef xsltFormatToken *xsltFormatTokenPtr;
  46 struct _xsltFormatToken {
  47     xmlChar *separator;
  48     xmlChar  token;
  49     int      width;
  50 };
  51 
  52 typedef struct _xsltFormat xsltFormat;
  53 typedef xsltFormat *xsltFormatPtr;
  54 struct _xsltFormat {
  55     xmlChar     *start;
  56     xsltFormatToken  tokens[MAX_TOKENS];
  57     int          nTokens;
  58     xmlChar     *end;
  59 };
  60 
  61 static char alpha_upper_list[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
  62 static char alpha_lower_list[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
  63 static xsltFormatToken default_token;
  64 
  65 /*
  66  * **** Start temp insert ****
  67  *
  68  * The following routine xsltUTF8Charcmp will be replaced with calls to
  69  * the corresponding libxml routine at a later date (when other
  70  * inter-library dependencies require it).
  71  */
  72 
  73 /**
  74  * xsltUTF8Charcmp
  75  * @utf1: pointer to first UTF8 char
  76  * @utf2: pointer to second UTF8 char
  77  *
  78  * returns result of comparing the two UCS4 values
  79  * as with xmlStrncmp
  80  */
  81 static int
  82 xsltUTF8Charcmp(xmlChar *utf1, xmlChar *utf2) {
  83     int len = xmlUTF8Strsize(utf1, 1);
  84 
  85     if (len &lt; 1)
  86         return -1;
  87     if (utf1 == NULL ) {
  88         if (utf2 == NULL)
  89             return 0;
  90         return -1;
  91     }
  92     return xmlStrncmp(utf1, utf2, len);
  93 }
  94 
  95 /***** Stop temp insert *****/
  96 /************************************************************************
  97  *                                  *
  98  *          Utility functions               *
  99  *                                  *
 100  ************************************************************************/
 101 
 102 #define IS_SPECIAL(self,letter)         \
 103     ((xsltUTF8Charcmp((letter), (self)-&gt;zeroDigit) == 0)        ||  \
 104      (xsltUTF8Charcmp((letter), (self)-&gt;digit) == 0)        ||  \
 105      (xsltUTF8Charcmp((letter), (self)-&gt;decimalPoint) == 0)  || \
 106      (xsltUTF8Charcmp((letter), (self)-&gt;grouping) == 0)     ||  \
 107      (xsltUTF8Charcmp((letter), (self)-&gt;patternSeparator) == 0))
 108 
 109 #define IS_DIGIT_ZERO(x) xsltIsDigitZero(x)
 110 #define IS_DIGIT_ONE(x) xsltIsDigitZero((xmlChar)(x)-1)
 111 
 112 static int
 113 xsltIsDigitZero(unsigned int ch)
 114 {
 115     /*
 116      * Reference: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
 117      */
 118     switch (ch) {
 119     case 0x0030: case 0x0660: case 0x06F0: case 0x0966:
 120     case 0x09E6: case 0x0A66: case 0x0AE6: case 0x0B66:
 121     case 0x0C66: case 0x0CE6: case 0x0D66: case 0x0E50:
 122     case 0x0E60: case 0x0F20: case 0x1040: case 0x17E0:
 123     case 0x1810: case 0xFF10:
 124     return TRUE;
 125     default:
 126     return FALSE;
 127     }
 128 }
 129 
 130 static void
 131 xsltNumberFormatDecimal(xmlBufferPtr buffer,
 132             double number,
 133             int digit_zero,
 134             int width,
 135             int digitsPerGroup,
 136             int groupingCharacter,
 137             int groupingCharacterLen)
 138 {
 139     /*
 140      * This used to be
 141      *  xmlChar temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 4];
 142      * which would be length 68 on x86 arch.  It was changed to be a longer,
 143      * fixed length in order to try to cater for (reasonable) UTF8
 144      * separators and numeric characters.  The max UTF8 char size will be
 145      * 6 or less, so the value used [500] should be *much* larger than needed
 146      */
 147     xmlChar temp_string[500];
 148     xmlChar *pointer;
 149     xmlChar temp_char[6];
 150     int i;
 151     int val;
 152     int len;
 153 
 154     /* Build buffer from back */
 155     pointer = &amp;temp_string[sizeof(temp_string)] - 1;    /* last char */
 156     *pointer = 0;
 157     i = 0;
 158     while (pointer &gt; temp_string) {
 159     if ((i &gt;= width) &amp;&amp; (fabs(number) &lt; 1.0))
 160         break; /* for */
 161     if ((i &gt; 0) &amp;&amp; (groupingCharacter != 0) &amp;&amp;
 162         (digitsPerGroup &gt; 0) &amp;&amp;
 163         ((i % digitsPerGroup) == 0)) {
 164         if (pointer - groupingCharacterLen &lt; temp_string) {
 165             i = -1;     /* flag error */
 166         break;
 167         }
 168         pointer -= groupingCharacterLen;
 169         xmlCopyCharMultiByte(pointer, groupingCharacter);
 170     }
 171 
 172     val = digit_zero + (int)fmod(number, 10.0);
 173     if (val &lt; 0x80) {           /* shortcut if ASCII */
 174         if (pointer &lt;= temp_string) {   /* Check enough room */
 175             i = -1;
 176         break;
 177         }
 178         *(--pointer) = val;
 179     }
 180     else {
 181     /*
 182      * Here we have a multibyte character.  It&#39;s a little messy,
 183      * because until we generate the char we don&#39;t know how long
 184      * it is.  So, we generate it into the buffer temp_char, then
 185      * copy from there into temp_string.
 186      */
 187         len = xmlCopyCharMultiByte(temp_char, val);
 188         if ( (pointer - len) &lt; temp_string ) {
 189             i = -1;
 190         break;
 191         }
 192         pointer -= len;
 193         memcpy(pointer, temp_char, len);
 194     }
 195     number /= 10.0;
 196     ++i;
 197     }
 198     if (i &lt; 0)
 199         xsltGenericError(xsltGenericErrorContext,
 200         &quot;xsltNumberFormatDecimal: Internal buffer size exceeded\n&quot;);
 201     xmlBufferCat(buffer, pointer);
 202 }
 203 
 204 static void
 205 xsltNumberFormatAlpha(xsltNumberDataPtr data,
 206               xmlBufferPtr buffer,
 207               double number,
 208               int is_upper)
 209 {
 210     char temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 1];
 211     char *pointer;
 212     int i;
 213     char *alpha_list;
 214     double alpha_size = (double)(sizeof(alpha_upper_list) - 1);
 215 
 216     /*
 217      * XSLT 1.0 isn&#39;t clear on how to handle zero, but XSLT 2.0 says:
 218      *
 219      *     For all format tokens other than the first kind above (one that
 220      *     consists of decimal digits), there may be implementation-defined
 221      *     lower and upper bounds on the range of numbers that can be
 222      *     formatted using this format token; indeed, for some numbering
 223      *     sequences there may be intrinsic limits. [...] Numbers that fall
 224      *     outside this range must be formatted using the format token 1.
 225      *
 226      * The &quot;a&quot; token has an intrinsic lower limit of 1.
 227      */
 228     if (number &lt; 1.0) {
 229         xsltNumberFormatDecimal(buffer, number, &#39;0&#39;, 1,
 230                                 data-&gt;digitsPerGroup,
 231                                 data-&gt;groupingCharacter,
 232                                 data-&gt;groupingCharacterLen);
 233         return;
 234     }
 235 
 236     /* Build buffer from back */
 237     pointer = &amp;temp_string[sizeof(temp_string)];
 238     *(--pointer) = 0;
 239     alpha_list = (is_upper) ? alpha_upper_list : alpha_lower_list;
 240 
 241     for (i = 1; i &lt; (int)sizeof(temp_string); i++) {
 242     number--;
 243     *(--pointer) = alpha_list[((int)fmod(number, alpha_size))];
 244     number /= alpha_size;
 245     if (number &lt; 1.0)
 246         break; /* for */
 247     }
 248     xmlBufferCCat(buffer, pointer);
 249 }
 250 
 251 static void
 252 xsltNumberFormatRoman(xsltNumberDataPtr data,
 253               xmlBufferPtr buffer,
 254               double number,
 255               int is_upper)
 256 {
 257     /*
 258      * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper
 259      * bound to avoid denial of service.
 260      */
 261     if (number &lt; 1.0 || number &gt; 5000.0) {
 262         xsltNumberFormatDecimal(buffer, number, &#39;0&#39;, 1,
 263                                 data-&gt;digitsPerGroup,
 264                                 data-&gt;groupingCharacter,
 265                                 data-&gt;groupingCharacterLen);
 266         return;
 267     }
 268 
 269     /*
 270      * Based on an example by Jim Walsh
 271      */
 272     while (number &gt;= 1000.0) {
 273     xmlBufferCCat(buffer, (is_upper) ? &quot;M&quot; : &quot;m&quot;);
 274     number -= 1000.0;
 275     }
 276     if (number &gt;= 900.0) {
 277     xmlBufferCCat(buffer, (is_upper) ? &quot;CM&quot; : &quot;cm&quot;);
 278     number -= 900.0;
 279     }
 280     while (number &gt;= 500.0) {
 281     xmlBufferCCat(buffer, (is_upper) ? &quot;D&quot; : &quot;d&quot;);
 282     number -= 500.0;
 283     }
 284     if (number &gt;= 400.0) {
 285     xmlBufferCCat(buffer, (is_upper) ? &quot;CD&quot; : &quot;cd&quot;);
 286     number -= 400.0;
 287     }
 288     while (number &gt;= 100.0) {
 289     xmlBufferCCat(buffer, (is_upper) ? &quot;C&quot; : &quot;c&quot;);
 290     number -= 100.0;
 291     }
 292     if (number &gt;= 90.0) {
 293     xmlBufferCCat(buffer, (is_upper) ? &quot;XC&quot; : &quot;xc&quot;);
 294     number -= 90.0;
 295     }
 296     while (number &gt;= 50.0) {
 297     xmlBufferCCat(buffer, (is_upper) ? &quot;L&quot; : &quot;l&quot;);
 298     number -= 50.0;
 299     }
 300     if (number &gt;= 40.0) {
 301     xmlBufferCCat(buffer, (is_upper) ? &quot;XL&quot; : &quot;xl&quot;);
 302     number -= 40.0;
 303     }
 304     while (number &gt;= 10.0) {
 305     xmlBufferCCat(buffer, (is_upper) ? &quot;X&quot; : &quot;x&quot;);
 306     number -= 10.0;
 307     }
 308     if (number &gt;= 9.0) {
 309     xmlBufferCCat(buffer, (is_upper) ? &quot;IX&quot; : &quot;ix&quot;);
 310     number -= 9.0;
 311     }
 312     while (number &gt;= 5.0) {
 313     xmlBufferCCat(buffer, (is_upper) ? &quot;V&quot; : &quot;v&quot;);
 314     number -= 5.0;
 315     }
 316     if (number &gt;= 4.0) {
 317     xmlBufferCCat(buffer, (is_upper) ? &quot;IV&quot; : &quot;iv&quot;);
 318     number -= 4.0;
 319     }
 320     while (number &gt;= 1.0) {
 321     xmlBufferCCat(buffer, (is_upper) ? &quot;I&quot; : &quot;i&quot;);
 322     number--;
 323     }
 324 }
 325 
 326 static void
 327 xsltNumberFormatTokenize(const xmlChar *format,
 328              xsltFormatPtr tokens)
 329 {
 330     int ix = 0;
 331     int j;
 332     int val;
 333     int len;
 334 
 335     default_token.token = DEFAULT_TOKEN;
 336     default_token.width = 1;
 337     default_token.separator = BAD_CAST(DEFAULT_SEPARATOR);
 338 
 339 
 340     tokens-&gt;start = NULL;
 341     tokens-&gt;tokens[0].separator = NULL;
 342     tokens-&gt;end = NULL;
 343 
 344     /*
 345      * Insert initial non-alphanumeric token.
 346      * There is always such a token in the list, even if NULL
 347      */
 348     while (! (IS_LETTER(val=xmlStringCurrentChar(NULL, format+ix, &amp;len)) ||
 349           IS_DIGIT(val)) ) {
 350     if (format[ix] == 0)        /* if end of format string */
 351         break; /* while */
 352     ix += len;
 353     }
 354     if (ix &gt; 0)
 355     tokens-&gt;start = xmlStrndup(format, ix);
 356 
 357 
 358     for (tokens-&gt;nTokens = 0; tokens-&gt;nTokens &lt; MAX_TOKENS;
 359      tokens-&gt;nTokens++) {
 360     if (format[ix] == 0)
 361         break; /* for */
 362 
 363     /*
 364      * separator has already been parsed (except for the first
 365      * number) in tokens-&gt;end, recover it.
 366      */
 367     if (tokens-&gt;nTokens &gt; 0) {
 368         tokens-&gt;tokens[tokens-&gt;nTokens].separator = tokens-&gt;end;
 369         tokens-&gt;end = NULL;
 370     }
 371 
 372     val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 373     if (IS_DIGIT_ONE(val) ||
 374          IS_DIGIT_ZERO(val)) {
 375         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 376         while (IS_DIGIT_ZERO(val)) {
 377         tokens-&gt;tokens[tokens-&gt;nTokens].width++;
 378         ix += len;
 379         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 380         }
 381         if (IS_DIGIT_ONE(val)) {
 382         tokens-&gt;tokens[tokens-&gt;nTokens].token = val - 1;
 383         ix += len;
 384         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 385         }
 386     } else if ( (val == (xmlChar)&#39;A&#39;) ||
 387             (val == (xmlChar)&#39;a&#39;) ||
 388             (val == (xmlChar)&#39;I&#39;) ||
 389             (val == (xmlChar)&#39;i&#39;) ) {
 390         tokens-&gt;tokens[tokens-&gt;nTokens].token = val;
 391         ix += len;
 392         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 393     } else {
 394         /* XSLT section 7.7
 395          * &quot;Any other format token indicates a numbering sequence
 396          *  that starts with that token. If an implementation does
 397          *  not support a numbering sequence that starts with that
 398          *  token, it must use a format token of 1.&quot;
 399          */
 400         tokens-&gt;tokens[tokens-&gt;nTokens].token = (xmlChar)&#39;0&#39;;
 401         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 402     }
 403     /*
 404      * Skip over remaining alphanumeric characters from the Nd
 405      * (Number, decimal digit), Nl (Number, letter), No (Number,
 406      * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt
 407      * (Letters, titlecase), Lm (Letters, modifiers), and Lo
 408      * (Letters, other (uncased)) Unicode categories. This happens
 409      * to correspond to the Letter and Digit classes from XML (and
 410      * one wonders why XSLT doesn&#39;t refer to these instead).
 411      */
 412     while (IS_LETTER(val) || IS_DIGIT(val)) {
 413         ix += len;
 414         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 415     }
 416 
 417     /*
 418      * Insert temporary non-alphanumeric final tooken.
 419      */
 420     j = ix;
 421     while (! (IS_LETTER(val) || IS_DIGIT(val))) {
 422         if (val == 0)
 423         break; /* while */
 424         ix += len;
 425         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 426     }
 427     if (ix &gt; j)
 428         tokens-&gt;end = xmlStrndup(&amp;format[j], ix - j);
 429     }
 430 }
 431 
 432 static void
 433 xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,
 434                   double *numbers,
 435                   int numbers_max,
 436                   xsltFormatPtr tokens,
 437                   xmlBufferPtr buffer)
 438 {
 439     int i = 0;
 440     double number;
 441     xsltFormatTokenPtr token;
 442 
 443     /*
 444      * Handle initial non-alphanumeric token
 445      */
 446     if (tokens-&gt;start != NULL)
 447      xmlBufferCat(buffer, tokens-&gt;start);
 448 
 449     for (i = 0; i &lt; numbers_max; i++) {
 450     /* Insert number */
 451     number = numbers[(numbers_max - 1) - i];
 452         /* Round to nearest like XSLT 2.0 */
 453         number = floor(number + 0.5);
 454         /*
 455          * XSLT 1.0 isn&#39;t clear on how to handle negative numbers, but XSLT
 456          * 2.0 says:
 457          *
 458          *     It is a non-recoverable dynamic error if any undiscarded item
 459          *     in the atomized sequence supplied as the value of the value
 460          *     attribute of xsl:number cannot be converted to an integer, or
 461          *     if the resulting integer is less than 0 (zero).
 462          */
 463         if (number &lt; 0.0) {
 464             xsltTransformError(NULL, NULL, NULL,
 465                     &quot;xsl-number : negative value\n&quot;);
 466             /* Recover by treating negative values as zero. */
 467             number = 0.0;
 468         }
 469     if (i &lt; tokens-&gt;nTokens) {
 470       /*
 471        * The &quot;n&quot;th format token will be used to format the &quot;n&quot;th
 472        * number in the list
 473        */
 474       token = &amp;(tokens-&gt;tokens[i]);
 475     } else if (tokens-&gt;nTokens &gt; 0) {
 476       /*
 477        * If there are more numbers than format tokens, then the
 478        * last format token will be used to format the remaining
 479        * numbers.
 480        */
 481       token = &amp;(tokens-&gt;tokens[tokens-&gt;nTokens - 1]);
 482     } else {
 483       /*
 484        * If there are no format tokens, then a format token of
 485        * 1 is used to format all numbers.
 486        */
 487       token = &amp;default_token;
 488     }
 489 
 490     /* Print separator, except for the first number */
 491     if (i &gt; 0) {
 492         if (token-&gt;separator != NULL)
 493         xmlBufferCat(buffer, token-&gt;separator);
 494         else
 495         xmlBufferCCat(buffer, DEFAULT_SEPARATOR);
 496     }
 497 
 498     switch (xmlXPathIsInf(number)) {
 499     case -1:
 500         xmlBufferCCat(buffer, &quot;-Infinity&quot;);
 501         break;
 502     case 1:
 503         xmlBufferCCat(buffer, &quot;Infinity&quot;);
 504         break;
 505     default:
 506         if (xmlXPathIsNaN(number)) {
 507         xmlBufferCCat(buffer, &quot;NaN&quot;);
 508         } else {
 509 
 510         switch (token-&gt;token) {
 511         case &#39;A&#39;:
 512             xsltNumberFormatAlpha(data, buffer, number, TRUE);
 513             break;
 514         case &#39;a&#39;:
 515             xsltNumberFormatAlpha(data, buffer, number, FALSE);
 516             break;
 517         case &#39;I&#39;:
 518             xsltNumberFormatRoman(data, buffer, number, TRUE);
 519             break;
 520         case &#39;i&#39;:
 521             xsltNumberFormatRoman(data, buffer, number, FALSE);
 522             break;
 523         default:
 524             if (IS_DIGIT_ZERO(token-&gt;token)) {
 525             xsltNumberFormatDecimal(buffer,
 526                         number,
 527                         token-&gt;token,
 528                         token-&gt;width,
 529                         data-&gt;digitsPerGroup,
 530                         data-&gt;groupingCharacter,
 531                         data-&gt;groupingCharacterLen);
 532             }
 533             break;
 534         }
 535         }
 536 
 537     }
 538     }
 539 
 540     /*
 541      * Handle final non-alphanumeric token
 542      */
 543     if (tokens-&gt;end != NULL)
 544      xmlBufferCat(buffer, tokens-&gt;end);
 545 
 546 }
 547 
 548 static int
 549 xsltTestCompMatchCount(xsltTransformContextPtr context,
 550                        xmlNodePtr node,
 551                        xsltCompMatchPtr countPat,
 552                        xmlNodePtr cur)
 553 {
 554     if (countPat != NULL) {
 555         return xsltTestCompMatchList(context, node, countPat);
 556     }
 557     else {
 558         /*
 559          * 7.7 Numbering
 560          *
 561          * If count attribute is not specified, then it defaults to the
 562          * pattern that matches any node with the same node type as the
 563          * current node and, if the current node has an expanded-name, with
 564          * the same expanded-name as the current node.
 565          */
 566         if (node-&gt;type != cur-&gt;type)
 567             return 0;
 568         if (node-&gt;type == XML_NAMESPACE_DECL)
 569             /*
 570              * Namespace nodes have no preceding siblings and no parents
 571              * that are namespace nodes. This means that node == cur.
 572              */
 573             return 1;
 574         /* TODO: Skip node types without expanded names like text nodes. */
 575         if (!xmlStrEqual(node-&gt;name, cur-&gt;name))
 576             return 0;
 577         if (node-&gt;ns == cur-&gt;ns)
 578             return 1;
 579         if ((node-&gt;ns == NULL) || (cur-&gt;ns == NULL))
 580             return 0;
 581         return (xmlStrEqual(node-&gt;ns-&gt;href, cur-&gt;ns-&gt;href));
 582     }
 583 }
 584 
 585 static int
 586 xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,
 587                 xmlNodePtr node,
 588                 xsltCompMatchPtr countPat,
 589                 xsltCompMatchPtr fromPat,
 590                 double *array)
 591 {
 592     int amount = 0;
 593     int cnt = 0;
 594     xmlNodePtr cur = node;
 595 
 596     while (cur != NULL) {
 597     /* process current node */
 598     if (xsltTestCompMatchCount(context, cur, countPat, node))
 599         cnt++;
 600     if ((fromPat != NULL) &amp;&amp;
 601         xsltTestCompMatchList(context, cur, fromPat)) {
 602         break; /* while */
 603     }
 604 
 605     /* Skip to next preceding or ancestor */
 606     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 607 #ifdef LIBXML_DOCB_ENABLED
 608             (cur-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 609 #endif
 610             (cur-&gt;type == XML_HTML_DOCUMENT_NODE))
 611         break; /* while */
 612 
 613         if (cur-&gt;type == XML_NAMESPACE_DECL) {
 614             /*
 615             * The XPath module stores the parent of a namespace node in
 616             * the ns-&gt;next field.
 617             */
 618             cur = (xmlNodePtr) ((xmlNsPtr) cur)-&gt;next;
 619         } else if (cur-&gt;type == XML_ATTRIBUTE_NODE) {
 620             cur = cur-&gt;parent;
 621         } else {
 622             while ((cur-&gt;prev != NULL) &amp;&amp; ((cur-&gt;prev-&gt;type == XML_DTD_NODE) ||
 623                    (cur-&gt;prev-&gt;type == XML_XINCLUDE_START) ||
 624                    (cur-&gt;prev-&gt;type == XML_XINCLUDE_END)))
 625                 cur = cur-&gt;prev;
 626             if (cur-&gt;prev != NULL) {
 627                 for (cur = cur-&gt;prev; cur-&gt;last != NULL; cur = cur-&gt;last);
 628             } else {
 629                 cur = cur-&gt;parent;
 630             }
 631         }
 632     }
 633 
 634     array[amount++] = (double) cnt;
 635 
 636     return(amount);
 637 }
 638 
 639 static int
 640 xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 641                  xmlNodePtr node,
 642                  xsltCompMatchPtr countPat,
 643                  xsltCompMatchPtr fromPat,
 644                  double *array,
 645                  int max)
 646 {
 647     int amount = 0;
 648     int cnt;
 649     xmlNodePtr ancestor;
 650     xmlNodePtr preceding;
 651     xmlXPathParserContextPtr parser;
 652 
 653     context-&gt;xpathCtxt-&gt;node = node;
 654     parser = xmlXPathNewParserContext(NULL, context-&gt;xpathCtxt);
 655     if (parser) {
 656     /* ancestor-or-self::*[count] */
 657     for (ancestor = node;
 658          (ancestor != NULL) &amp;&amp; (ancestor-&gt;type != XML_DOCUMENT_NODE);
 659          ancestor = xmlXPathNextAncestor(parser, ancestor)) {
 660 
 661         if ((fromPat != NULL) &amp;&amp;
 662         xsltTestCompMatchList(context, ancestor, fromPat))
 663         break; /* for */
 664 
 665         if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 666         /* count(preceding-sibling::*) */
 667         cnt = 1;
 668         for (preceding =
 669                         xmlXPathNextPrecedingSibling(parser, ancestor);
 670              preceding != NULL;
 671              preceding =
 672                 xmlXPathNextPrecedingSibling(parser, preceding)) {
 673 
 674                 if (xsltTestCompMatchCount(context, preceding, countPat,
 675                                                node))
 676             cnt++;
 677         }
 678         array[amount++] = (double)cnt;
 679         if (amount &gt;= max)
 680             break; /* for */
 681         }
 682     }
 683     xmlXPathFreeParserContext(parser);
 684     }
 685     return amount;
 686 }
 687 
 688 static int
 689 xsltNumberFormatGetValue(xmlXPathContextPtr context,
 690              xmlNodePtr node,
 691              const xmlChar *value,
 692              double *number)
 693 {
 694     int amount = 0;
 695     xmlBufferPtr pattern;
 696     xmlXPathObjectPtr obj;
 697 
 698     pattern = xmlBufferCreate();
 699     if (pattern != NULL) {
 700     xmlBufferCCat(pattern, &quot;number(&quot;);
 701     xmlBufferCat(pattern, value);
 702     xmlBufferCCat(pattern, &quot;)&quot;);
 703     context-&gt;node = node;
 704     obj = xmlXPathEvalExpression(xmlBufferContent(pattern),
 705                      context);
 706     if (obj != NULL) {
 707         *number = obj-&gt;floatval;
 708         amount++;
 709         xmlXPathFreeObject(obj);
 710     }
 711     xmlBufferFree(pattern);
 712     }
 713     return amount;
 714 }
 715 
 716 /**
 717  * xsltNumberFormat:
 718  * @ctxt: the XSLT transformation context
 719  * @data: the formatting information
 720  * @node: the data to format
 721  *
 722  * Convert one number.
 723  */
 724 void
 725 xsltNumberFormat(xsltTransformContextPtr ctxt,
 726          xsltNumberDataPtr data,
 727          xmlNodePtr node)
 728 {
 729     xmlBufferPtr output = NULL;
 730     int amount, i;
 731     double number;
 732     xsltFormat tokens;
 733 
 734     if (data-&gt;format != NULL) {
 735         xsltNumberFormatTokenize(data-&gt;format, &amp;tokens);
 736     }
 737     else {
 738         xmlChar *format;
 739 
 740     /* The format needs to be recomputed each time */
 741         if (data-&gt;has_format == 0)
 742             return;
 743     format = xsltEvalAttrValueTemplate(ctxt, data-&gt;node,
 744                          (const xmlChar *) &quot;format&quot;,
 745                          XSLT_NAMESPACE);
 746         if (format == NULL)
 747             return;
 748         xsltNumberFormatTokenize(format, &amp;tokens);
 749     xmlFree(format);
 750     }
 751 
 752     output = xmlBufferCreate();
 753     if (output == NULL)
 754     goto XSLT_NUMBER_FORMAT_END;
 755 
 756     /*
 757      * Evaluate the XPath expression to find the value(s)
 758      */
 759     if (data-&gt;value) {
 760     amount = xsltNumberFormatGetValue(ctxt-&gt;xpathCtxt,
 761                       node,
 762                       data-&gt;value,
 763                       &amp;number);
 764     if (amount == 1) {
 765         xsltNumberFormatInsertNumbers(data,
 766                       &amp;number,
 767                       1,
 768                       &amp;tokens,
 769                       output);
 770     }
 771 
 772     } else if (data-&gt;level) {
 773 
 774     if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;single&quot;)) {
 775         amount = xsltNumberFormatGetMultipleLevel(ctxt,
 776                               node,
 777                               data-&gt;countPat,
 778                               data-&gt;fromPat,
 779                               &amp;number,
 780                               1);
 781         if (amount == 1) {
 782         xsltNumberFormatInsertNumbers(data,
 783                           &amp;number,
 784                           1,
 785                           &amp;tokens,
 786                           output);
 787         }
 788     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;multiple&quot;)) {
 789         double numarray[1024];
 790         int max = sizeof(numarray)/sizeof(numarray[0]);
 791         amount = xsltNumberFormatGetMultipleLevel(ctxt,
 792                               node,
 793                               data-&gt;countPat,
 794                               data-&gt;fromPat,
 795                               numarray,
 796                               max);
 797         if (amount &gt; 0) {
 798         xsltNumberFormatInsertNumbers(data,
 799                           numarray,
 800                           amount,
 801                           &amp;tokens,
 802                           output);
 803         }
 804     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;any&quot;)) {
 805         amount = xsltNumberFormatGetAnyLevel(ctxt,
 806                          node,
 807                          data-&gt;countPat,
 808                          data-&gt;fromPat,
 809                          &amp;number);
 810         if (amount &gt; 0) {
 811         xsltNumberFormatInsertNumbers(data,
 812                           &amp;number,
 813                           1,
 814                           &amp;tokens,
 815                           output);
 816         }
 817     }
 818     }
 819     /* Insert number as text node */
 820     xsltCopyTextString(ctxt, ctxt-&gt;insert, xmlBufferContent(output), 0);
 821 
 822     xmlBufferFree(output);
 823 
 824 XSLT_NUMBER_FORMAT_END:
 825     if (tokens.start != NULL)
 826     xmlFree(tokens.start);
 827     if (tokens.end != NULL)
 828     xmlFree(tokens.end);
 829     for (i = 0;i &lt; tokens.nTokens;i++) {
 830     if (tokens.tokens[i].separator != NULL)
 831         xmlFree(tokens.tokens[i].separator);
 832     }
 833 }
 834 
 835 static int
 836 xsltFormatNumberPreSuffix(xsltDecimalFormatPtr self, xmlChar **format, xsltFormatNumberInfoPtr info)
 837 {
 838     int count=0;    /* will hold total length of prefix/suffix */
 839     int len;
 840 
 841     while (1) {
 842     /*
 843      * prefix / suffix ends at end of string or at
 844      * first &#39;special&#39; character
 845      */
 846     if (**format == 0)
 847         return count;
 848     /* if next character &#39;escaped&#39; just count it */
 849     if (**format == SYMBOL_QUOTE) {
 850         if (*++(*format) == 0)
 851         return -1;
 852     }
 853     else if (IS_SPECIAL(self, *format))
 854         return count;
 855     /*
 856      * else treat percent/per-mille as special cases,
 857      * depending on whether +ve or -ve
 858      */
 859     else {
 860         /*
 861          * for +ve prefix/suffix, allow only a
 862          * single occurence of either
 863          */
 864         if (xsltUTF8Charcmp(*format, self-&gt;percent) == 0) {
 865         if (info-&gt;is_multiplier_set)
 866             return -1;
 867         info-&gt;multiplier = 100;
 868         info-&gt;is_multiplier_set = TRUE;
 869         } else if (xsltUTF8Charcmp(*format, self-&gt;permille) == 0) {
 870         if (info-&gt;is_multiplier_set)
 871             return -1;
 872         info-&gt;multiplier = 1000;
 873         info-&gt;is_multiplier_set = TRUE;
 874         }
 875     }
 876 
 877     if ((len=xmlUTF8Strsize(*format, 1)) &lt; 1)
 878         return -1;
 879     count += len;
 880     *format += len;
 881     }
 882 }
 883 
 884 /**
 885  * xsltFormatNumberConversion:
 886  * @self: the decimal format
 887  * @format: the format requested
 888  * @number: the value to format
 889  * @result: the place to output the result
 890  *
 891  * format-number() uses the JDK 1.1 DecimalFormat class:
 892  *
 893  * http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html
 894  *
 895  * Structure:
 896  *
 897  *   pattern    := subpattern{;subpattern}
 898  *   subpattern := {prefix}integer{.fraction}{suffix}
 899  *   prefix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 900  *   suffix     := &#39;\\u0000&#39;..&#39;\\uFFFD&#39; - specialCharacters
 901  *   integer    := &#39;#&#39;* &#39;0&#39;* &#39;0&#39;
 902  *   fraction   := &#39;0&#39;* &#39;#&#39;*
 903  *
 904  *   Notation:
 905  *    X*       0 or more instances of X
 906  *    (X | Y)  either X or Y.
 907  *    X..Y     any character from X up to Y, inclusive.
 908  *    S - T    characters in S, except those in T
 909  *
 910  * Special Characters:
 911  *
 912  *   Symbol Meaning
 913  *   0      a digit
 914  *   #      a digit, zero shows as absent
 915  *   .      placeholder for decimal separator
 916  *   ,      placeholder for grouping separator.
 917  *   ;      separates formats.
 918  *   -      default negative prefix.
 919  *   %      multiply by 100 and show as percentage
 920  *   ?      multiply by 1000 and show as per mille
 921  *   X      any other characters can be used in the prefix or suffix
 922  *   &#39;      used to quote special characters in a prefix or suffix.
 923  *
 924  * Returns a possible XPath error
 925  */
 926 xmlXPathError
 927 xsltFormatNumberConversion(xsltDecimalFormatPtr self,
 928                xmlChar *format,
 929                double number,
 930                xmlChar **result)
 931 {
 932     xmlXPathError status = XPATH_EXPRESSION_OK;
 933     xmlBufferPtr buffer;
 934     xmlChar *the_format, *prefix = NULL, *suffix = NULL;
 935     xmlChar *nprefix, *nsuffix = NULL;
 936     xmlChar pchar;
 937     int     prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
 938     double  scale;
 939     int     j, len;
 940     int     self_grouping_len;
 941     xsltFormatNumberInfo format_info;
 942     /*
 943      * delayed_multiplier allows a &#39;trailing&#39; percent or
 944      * permille to be treated as suffix
 945      */
 946     int     delayed_multiplier = 0;
 947     /* flag to show no -ve format present for -ve number */
 948     char    default_sign = 0;
 949     /* flag to show error found, should use default format */
 950     char    found_error = 0;
 951 
 952     if (xmlStrlen(format) &lt;= 0) {
 953     xsltTransformError(NULL, NULL, NULL,
 954                 &quot;xsltFormatNumberConversion : &quot;
 955         &quot;Invalid format (0-length)\n&quot;);
 956     }
 957     *result = NULL;
 958     switch (xmlXPathIsInf(number)) {
 959     case -1:
 960         if (self-&gt;minusSign == NULL)
 961         *result = xmlStrdup(BAD_CAST &quot;-&quot;);
 962         else
 963         *result = xmlStrdup(self-&gt;minusSign);
 964         /* no-break on purpose */
 965     case 1:
 966         if ((self == NULL) || (self-&gt;infinity == NULL))
 967         *result = xmlStrcat(*result, BAD_CAST &quot;Infinity&quot;);
 968         else
 969         *result = xmlStrcat(*result, self-&gt;infinity);
 970         return(status);
 971     default:
 972         if (xmlXPathIsNaN(number)) {
 973         if ((self == NULL) || (self-&gt;noNumber == NULL))
 974             *result = xmlStrdup(BAD_CAST &quot;NaN&quot;);
 975         else
 976             *result = xmlStrdup(self-&gt;noNumber);
 977         return(status);
 978         }
 979     }
 980 
 981     buffer = xmlBufferCreate();
 982     if (buffer == NULL) {
 983     return XPATH_MEMORY_ERROR;
 984     }
 985 
 986     format_info.integer_hash = 0;
 987     format_info.integer_digits = 0;
 988     format_info.frac_digits = 0;
 989     format_info.frac_hash = 0;
 990     format_info.group = -1;
 991     format_info.multiplier = 1;
 992     format_info.add_decimal = FALSE;
 993     format_info.is_multiplier_set = FALSE;
 994     format_info.is_negative_pattern = FALSE;
 995 
 996     the_format = format;
 997 
 998     /*
 999      * First we process the +ve pattern to get percent / permille,
1000      * as well as main format
1001      */
1002     prefix = the_format;
1003     prefix_length = xsltFormatNumberPreSuffix(self, &amp;the_format, &amp;format_info);
1004     if (prefix_length &lt; 0) {
1005     found_error = 1;
1006     goto OUTPUT_NUMBER;
1007     }
1008 
1009     /*
1010      * Here we process the &quot;number&quot; part of the format.  It gets
1011      * a little messy because of the percent/per-mille - if that
1012      * appears at the end, it may be part of the suffix instead
1013      * of part of the number, so the variable delayed_multiplier
1014      * is used to handle it
1015      */
1016     self_grouping_len = xmlStrlen(self-&gt;grouping);
1017     while ((*the_format != 0) &amp;&amp;
1018        (xsltUTF8Charcmp(the_format, self-&gt;decimalPoint) != 0) &amp;&amp;
1019        (xsltUTF8Charcmp(the_format, self-&gt;patternSeparator) != 0)) {
1020 
1021     if (delayed_multiplier != 0) {
1022         format_info.multiplier = delayed_multiplier;
1023         format_info.is_multiplier_set = TRUE;
1024         delayed_multiplier = 0;
1025     }
1026     if (xsltUTF8Charcmp(the_format, self-&gt;digit) == 0) {
1027         if (format_info.integer_digits &gt; 0) {
1028         found_error = 1;
1029         goto OUTPUT_NUMBER;
1030         }
1031         format_info.integer_hash++;
1032         if (format_info.group &gt;= 0)
1033         format_info.group++;
1034     } else if (xsltUTF8Charcmp(the_format, self-&gt;zeroDigit) == 0) {
1035         format_info.integer_digits++;
1036         if (format_info.group &gt;= 0)
1037         format_info.group++;
1038     } else if ((self_grouping_len &gt; 0) &amp;&amp;
1039         (!xmlStrncmp(the_format, self-&gt;grouping, self_grouping_len))) {
1040         /* Reset group count */
1041         format_info.group = 0;
1042         the_format += self_grouping_len;
1043         continue;
1044     } else if (xsltUTF8Charcmp(the_format, self-&gt;percent) == 0) {
1045         if (format_info.is_multiplier_set) {
1046         found_error = 1;
1047         goto OUTPUT_NUMBER;
1048         }
1049         delayed_multiplier = 100;
1050     } else  if (xsltUTF8Charcmp(the_format, self-&gt;permille) == 0) {
1051         if (format_info.is_multiplier_set) {
1052         found_error = 1;
1053         goto OUTPUT_NUMBER;
1054         }
1055         delayed_multiplier = 1000;
1056     } else
1057         break; /* while */
1058 
1059     if ((len=xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1060         found_error = 1;
1061         goto OUTPUT_NUMBER;
1062     }
1063     the_format += len;
1064 
1065     }
1066 
1067     /* We have finished the integer part, now work on fraction */
1068     if ( (*the_format != 0) &amp;&amp;
1069          (xsltUTF8Charcmp(the_format, self-&gt;decimalPoint) == 0) ) {
1070         format_info.add_decimal = TRUE;
1071         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1072             found_error = 1;
1073             goto OUTPUT_NUMBER;
1074         }
1075     the_format += len;  /* Skip over the decimal */
1076     }
1077 
1078     while (*the_format != 0) {
1079 
1080     if (xsltUTF8Charcmp(the_format, self-&gt;zeroDigit) == 0) {
1081         if (format_info.frac_hash != 0) {
1082         found_error = 1;
1083         goto OUTPUT_NUMBER;
1084         }
1085         format_info.frac_digits++;
1086     } else if (xsltUTF8Charcmp(the_format, self-&gt;digit) == 0) {
1087         format_info.frac_hash++;
1088     } else if (xsltUTF8Charcmp(the_format, self-&gt;percent) == 0) {
1089         if (format_info.is_multiplier_set) {
1090         found_error = 1;
1091         goto OUTPUT_NUMBER;
1092         }
1093         delayed_multiplier = 100;
1094         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1095             found_error = 1;
1096         goto OUTPUT_NUMBER;
1097         }
1098         the_format += len;
1099         continue; /* while */
1100     } else if (xsltUTF8Charcmp(the_format, self-&gt;permille) == 0) {
1101         if (format_info.is_multiplier_set) {
1102         found_error = 1;
1103         goto OUTPUT_NUMBER;
1104         }
1105         delayed_multiplier = 1000;
1106         if  ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1107             found_error = 1;
1108         goto OUTPUT_NUMBER;
1109         }
1110         the_format += len;
1111         continue; /* while */
1112     } else if (xsltUTF8Charcmp(the_format, self-&gt;grouping) != 0) {
1113         break; /* while */
1114     }
1115     if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1116         found_error = 1;
1117         goto OUTPUT_NUMBER;
1118     }
1119     the_format += len;
1120     if (delayed_multiplier != 0) {
1121         format_info.multiplier = delayed_multiplier;
1122         delayed_multiplier = 0;
1123         format_info.is_multiplier_set = TRUE;
1124     }
1125     }
1126 
1127     /*
1128      * If delayed_multiplier is set after processing the
1129      * &quot;number&quot; part, should be in suffix
1130      */
1131     if (delayed_multiplier != 0) {
1132     the_format -= len;
1133     delayed_multiplier = 0;
1134     }
1135 
1136     suffix = the_format;
1137     suffix_length = xsltFormatNumberPreSuffix(self, &amp;the_format, &amp;format_info);
1138     if ( (suffix_length &lt; 0) ||
1139      ((*the_format != 0) &amp;&amp;
1140       (xsltUTF8Charcmp(the_format, self-&gt;patternSeparator) != 0)) ) {
1141     found_error = 1;
1142     goto OUTPUT_NUMBER;
1143     }
1144 
1145     /*
1146      * We have processed the +ve prefix, number part and +ve suffix.
1147      * If the number is -ve, we must substitute the -ve prefix / suffix
1148      */
1149     if (number &lt; 0) {
1150         /*
1151      * Note that j is the number of UTF8 chars before the separator,
1152      * not the number of bytes! (bug 151975)
1153      */
1154         j =  xmlUTF8Strloc(format, self-&gt;patternSeparator);
1155     if (j &lt; 0) {
1156     /* No -ve pattern present, so use default signing */
1157         default_sign = 1;
1158     }
1159     else {
1160         /* Skip over pattern separator (accounting for UTF8) */
1161         the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);
1162         /*
1163          * Flag changes interpretation of percent/permille
1164          * in -ve pattern
1165          */
1166         format_info.is_negative_pattern = TRUE;
1167         format_info.is_multiplier_set = FALSE;
1168 
1169         /* First do the -ve prefix */
1170         nprefix = the_format;
1171         nprefix_length = xsltFormatNumberPreSuffix(self,
1172                     &amp;the_format, &amp;format_info);
1173         if (nprefix_length&lt;0) {
1174         found_error = 1;
1175         goto OUTPUT_NUMBER;
1176         }
1177 
1178         while (*the_format != 0) {
1179         if ( (xsltUTF8Charcmp(the_format, (self)-&gt;percent) == 0) ||
1180              (xsltUTF8Charcmp(the_format, (self)-&gt;permille)== 0) ) {
1181             if (format_info.is_multiplier_set) {
1182             found_error = 1;
1183             goto OUTPUT_NUMBER;
1184             }
1185             format_info.is_multiplier_set = TRUE;
1186             delayed_multiplier = 1;
1187         }
1188         else if (IS_SPECIAL(self, the_format))
1189             delayed_multiplier = 0;
1190         else
1191             break; /* while */
1192         if ((len = xmlUTF8Strsize(the_format, 1)) &lt; 1) {
1193             found_error = 1;
1194             goto OUTPUT_NUMBER;
1195         }
1196         the_format += len;
1197         }
1198         if (delayed_multiplier != 0) {
1199         format_info.is_multiplier_set = FALSE;
1200         the_format -= len;
1201         }
1202 
1203         /* Finally do the -ve suffix */
1204         if (*the_format != 0) {
1205         nsuffix = the_format;
1206         nsuffix_length = xsltFormatNumberPreSuffix(self,
1207                     &amp;the_format, &amp;format_info);
1208         if (nsuffix_length &lt; 0) {
1209             found_error = 1;
1210             goto OUTPUT_NUMBER;
1211         }
1212         }
1213         else
1214         nsuffix_length = 0;
1215         if (*the_format != 0) {
1216         found_error = 1;
1217         goto OUTPUT_NUMBER;
1218         }
1219         /*
1220          * Here&#39;s another Java peculiarity:
1221          * if -ve prefix/suffix == +ve ones, discard &amp; use default
1222          */
1223         if ((nprefix_length != prefix_length) ||
1224         (nsuffix_length != suffix_length) ||
1225         ((nprefix_length &gt; 0) &amp;&amp;
1226          (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||
1227         ((nsuffix_length &gt; 0) &amp;&amp;
1228          (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {
1229         prefix = nprefix;
1230         prefix_length = nprefix_length;
1231         suffix = nsuffix;
1232         suffix_length = nsuffix_length;
1233         } /* else {
1234         default_sign = 1;
1235         }
1236         */
1237     }
1238     }
1239 
1240 OUTPUT_NUMBER:
1241     if (found_error != 0) {
1242     xsltTransformError(NULL, NULL, NULL,
1243                 &quot;xsltFormatNumberConversion : &quot;
1244         &quot;error in format string &#39;%s&#39;, using default\n&quot;, format);
1245     default_sign = (number &lt; 0.0) ? 1 : 0;
1246     prefix_length = suffix_length = 0;
1247     format_info.integer_hash = 0;
1248     format_info.integer_digits = 1;
1249     format_info.frac_digits = 1;
1250     format_info.frac_hash = 4;
1251     format_info.group = -1;
1252     format_info.multiplier = 1;
1253     format_info.add_decimal = TRUE;
1254     }
1255 
1256     /* Ready to output our number.  First see if &quot;default sign&quot; is required */
1257     if (default_sign != 0)
1258     xmlBufferAdd(buffer, self-&gt;minusSign, xmlUTF8Strsize(self-&gt;minusSign, 1));
1259 
1260     /* Put the prefix into the buffer */
1261     for (j = 0; j &lt; prefix_length; j++) {
1262     if ((pchar = *prefix++) == SYMBOL_QUOTE) {
1263         len = xmlUTF8Strsize(prefix, 1);
1264         xmlBufferAdd(buffer, prefix, len);
1265         prefix += len;
1266         j += len - 1;   /* length of symbol less length of quote */
1267     } else
1268         xmlBufferAdd(buffer, &amp;pchar, 1);
1269     }
1270 
1271     /* Next do the integer part of the number */
1272     number = fabs(number) * (double)format_info.multiplier;
1273     scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
1274     number = floor((scale * number + 0.5)) / scale;
1275     if ((self-&gt;grouping != NULL) &amp;&amp;
1276         (self-&gt;grouping[0] != 0)) {
1277 
1278     len = xmlStrlen(self-&gt;grouping);
1279     pchar = xsltGetUTF8Char(self-&gt;grouping, &amp;len);
1280     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1281                 format_info.integer_digits,
1282                 format_info.group,
1283                 pchar, len);
1284     } else
1285     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1286                 format_info.integer_digits,
1287                 format_info.group,
1288                 &#39;,&#39;, 1);
1289 
1290     /* Special case: java treats &#39;.#&#39; like &#39;.0&#39;, &#39;.##&#39; like &#39;.0#&#39;, etc. */
1291     if ((format_info.integer_digits + format_info.integer_hash +
1292      format_info.frac_digits == 0) &amp;&amp; (format_info.frac_hash &gt; 0)) {
1293         ++format_info.frac_digits;
1294     --format_info.frac_hash;
1295     }
1296 
1297     /* Add leading zero, if required */
1298     if ((floor(number) == 0) &amp;&amp;
1299     (format_info.integer_digits + format_info.frac_digits == 0)) {
1300         xmlBufferAdd(buffer, self-&gt;zeroDigit, xmlUTF8Strsize(self-&gt;zeroDigit, 1));
1301     }
1302 
1303     /* Next the fractional part, if required */
1304     if (format_info.frac_digits + format_info.frac_hash == 0) {
1305         if (format_info.add_decimal)
1306         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1307              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1308     }
1309     else {
1310       number -= floor(number);
1311     if ((number != 0) || (format_info.frac_digits != 0)) {
1312         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1313              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1314         number = floor(scale * number + 0.5);
1315         for (j = format_info.frac_hash; j &gt; 0; j--) {
1316         if (fmod(number, 10.0) &gt;= 1.0)
1317             break; /* for */
1318         number /= 10.0;
1319         }
1320         xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1321                 format_info.frac_digits + j,
1322                 0, 0, 0);
1323     }
1324     }
1325     /* Put the suffix into the buffer */
1326     for (j = 0; j &lt; suffix_length; j++) {
1327     if ((pchar = *suffix++) == SYMBOL_QUOTE) {
1328             len = xmlUTF8Strsize(suffix, 1);
1329         xmlBufferAdd(buffer, suffix, len);
1330         suffix += len;
1331         j += len - 1;   /* length of symbol less length of escape */
1332     } else
1333         xmlBufferAdd(buffer, &amp;pchar, 1);
1334     }
1335 
1336     *result = xmlStrdup(xmlBufferContent(buffer));
1337     xmlBufferFree(buffer);
1338     return status;
1339 }
1340 
    </pre>
  </body>
</html>