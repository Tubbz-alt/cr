<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xslt.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="variables.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="xsltInternals.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xslt.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 575     xsltGenericDebug(xsltGenericDebugContext,
 576     &quot;Freeing compilation context\n&quot;);
 577     xsltGenericDebug(xsltGenericDebugContext,
 578     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
 579     xsltGenericDebug(xsltGenericDebugContext,
 580     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
 581 #endif
 582     /*
 583     * Free node-infos.
 584     */
 585     if (cctxt-&gt;inodeList != NULL) {
 586     xsltCompilerNodeInfoPtr tmp, cur = cctxt-&gt;inodeList;
 587     while (cur != NULL) {
 588         tmp = cur;
 589         cur = cur-&gt;next;
 590         xmlFree(tmp);
 591     }
 592     }
 593     if (cctxt-&gt;tmpList != NULL)
 594     xsltPointerListFree(cctxt-&gt;tmpList);
<span class="line-removed"> 595 #ifdef XSLT_REFACTORED_XPATHCOMP</span>
<span class="line-removed"> 596     if (cctxt-&gt;xpathCtxt != NULL)</span>
<span class="line-removed"> 597     xmlXPathFreeContext(cctxt-&gt;xpathCtxt);</span>
<span class="line-removed"> 598 #endif</span>
 599     if (cctxt-&gt;nsAliases != NULL)
 600     xsltFreeNsAliasList(cctxt-&gt;nsAliases);
 601 
 602     if (cctxt-&gt;ivars)
 603     xsltCompilerVarInfoFree(cctxt);
 604 
 605     xmlFree(cctxt);
 606 }
 607 
 608 /**
 609  * xsltCompilerCreate:
 610  *
 611  * Creates an XSLT compiler context.
 612  *
 613  * Returns the pointer to the created xsltCompilerCtxt or
 614  *         NULL in case of an internal error.
 615  */
 616 static xsltCompilerCtxtPtr
 617 xsltCompilationCtxtCreate(xsltStylesheetPtr style) {
 618     xsltCompilerCtxtPtr ret;
 619 
 620     ret = (xsltCompilerCtxtPtr) xmlMalloc(sizeof(xsltCompilerCtxt));
 621     if (ret == NULL) {
 622     xsltTransformError(NULL, style, NULL,
 623         &quot;xsltCompilerCreate: allocation of compiler &quot;
 624         &quot;context failed.\n&quot;);
 625     return(NULL);
 626     }
 627     memset(ret, 0, sizeof(xsltCompilerCtxt));
 628 
 629     ret-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
 630     ret-&gt;tmpList = xsltPointerListCreate(20);
 631     if (ret-&gt;tmpList == NULL) {
 632     goto internal_err;
 633     }
<span class="line-removed"> 634 #ifdef XSLT_REFACTORED_XPATHCOMP</span>
<span class="line-removed"> 635     /*</span>
<span class="line-removed"> 636     * Create the XPath compilation context in order</span>
<span class="line-removed"> 637     * to speed up precompilation of XPath expressions.</span>
<span class="line-removed"> 638     */</span>
<span class="line-removed"> 639     ret-&gt;xpathCtxt = xmlXPathNewContext(NULL);</span>
<span class="line-removed"> 640     if (ret-&gt;xpathCtxt == NULL)</span>
<span class="line-removed"> 641     goto internal_err;</span>
<span class="line-removed"> 642 #endif</span>
 643 
 644     return(ret);
 645 
 646 internal_err:
 647     xsltCompilationCtxtFree(ret);
 648     return(NULL);
 649 }
 650 
 651 static void
 652 xsltLREEffectiveNsNodesFree(xsltEffectiveNsPtr first)
 653 {
 654     xsltEffectiveNsPtr tmp;
 655 
 656     while (first != NULL) {
 657     tmp = first;
 658     first = first-&gt;nextInStore;
 659     xmlFree(tmp);
 660     }
 661 }
 662 
</pre>
<hr />
<pre>
 744     ret-&gt;exclResultNamespaces = xsltPointerListCreate(-1);
 745     if (ret-&gt;exclResultNamespaces == NULL)
 746     goto internal_err;
 747     /*
 748     * Global list of extension instruction namespace names.
 749     */
 750     ret-&gt;extElemNamespaces = xsltPointerListCreate(-1);
 751     if (ret-&gt;extElemNamespaces == NULL)
 752     goto internal_err;
 753 
 754     return(ret);
 755 
 756 internal_err:
 757 
 758     return(NULL);
 759 }
 760 
 761 #endif
 762 
 763 /**
<span class="line-modified"> 764  * xsltNewStylesheet:</span>

 765  *
 766  * Create a new XSLT Stylesheet
 767  *
 768  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error
 769  */
<span class="line-modified"> 770 xsltStylesheetPtr</span>
<span class="line-modified"> 771 xsltNewStylesheet(void) {</span>
 772     xsltStylesheetPtr ret = NULL;
 773 
 774     ret = (xsltStylesheetPtr) xmlMalloc(sizeof(xsltStylesheet));
 775     if (ret == NULL) {
 776     xsltTransformError(NULL, NULL, NULL,
 777         &quot;xsltNewStylesheet : malloc failed\n&quot;);
 778     goto internal_err;
 779     }
 780     memset(ret, 0, sizeof(xsltStylesheet));
 781 

 782     ret-&gt;omitXmlDeclaration = -1;
 783     ret-&gt;standalone = -1;
 784     ret-&gt;decimalFormat = xsltNewDecimalFormat(NULL, NULL);
 785     ret-&gt;indent = -1;
 786     ret-&gt;errors = 0;
 787     ret-&gt;warnings = 0;
 788     ret-&gt;exclPrefixNr = 0;
 789     ret-&gt;exclPrefixMax = 0;
 790     ret-&gt;exclPrefixTab = NULL;
 791     ret-&gt;extInfos = NULL;
 792     ret-&gt;extrasNr = 0;
 793     ret-&gt;internalized = 1;
 794     ret-&gt;literal_result = 0;
 795     ret-&gt;forwards_compatible = 0;
 796     ret-&gt;dict = xmlDictCreate();
 797 #ifdef WITH_XSLT_DEBUG
 798     xsltGenericDebug(xsltGenericDebugContext,
 799     &quot;creating dictionary for stylesheet\n&quot;);
 800 #endif
 801 















 802     xsltInit();
 803 
 804     return(ret);
 805 
 806 internal_err:
 807     if (ret != NULL)
 808     xsltFreeStylesheet(ret);
 809     return(NULL);
 810 }
 811 












 812 /**
 813  * xsltAllocateExtra:
 814  * @style:  an XSLT stylesheet
 815  *
 816  * Allocate an extra runtime information slot statically while compiling
 817  * the stylesheet and return its number
 818  *
 819  * Returns the number of the slot
 820  */
 821 int
 822 xsltAllocateExtra(xsltStylesheetPtr style)
 823 {
 824     return(style-&gt;extrasNr++);
 825 }
 826 
 827 /**
 828  * xsltAllocateExtraCtxt:
 829  * @ctxt:  an XSLT transformation context
 830  *
 831  * Allocate an extra runtime information slot at run-time
</pre>
<hr />
<pre>
1048     if (style-&gt;principalData) {
1049         xsltFreePrincipalStylesheetData(style-&gt;principalData);
1050         style-&gt;principalData = NULL;
1051     }
1052     }
1053 #endif
1054     /*
1055     * Better to free the main document of this stylesheet level
1056     * at the end - so here.
1057     */
1058     if (style-&gt;doc != NULL) {
1059         xmlFreeDoc(style-&gt;doc);
1060     }
1061 
1062 #ifdef WITH_XSLT_DEBUG
1063     xsltGenericDebug(xsltGenericDebugContext,
1064                      &quot;freeing dictionary from stylesheet\n&quot;);
1065 #endif
1066     xmlDictFree(style-&gt;dict);
1067 



1068     memset(style, -1, sizeof(xsltStylesheet));
1069     xmlFree(style);
1070 }
1071 
1072 /************************************************************************
1073  *                                  *
1074  *      Parsing of an XSLT Stylesheet               *
1075  *                                  *
1076  ************************************************************************/
1077 
1078 #ifdef XSLT_REFACTORED
1079     /*
1080     * This is now performed in an optimized way in xsltParseXSLTTemplate.
1081     */
1082 #else
1083 /**
1084  * xsltGetInheritedNsList:
1085  * @style:  the stylesheet
1086  * @template: the template
1087  * @node:  the current node
</pre>
<hr />
<pre>
1332 #endif
1333         if (xmlValidateQName(BAD_CAST element, 0) != 0) {
1334             xsltTransformError(NULL, style, cur,
1335             &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;
1336             &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);
1337             xmlFree(element);
1338             style-&gt;errors++;
1339         } else {
1340             const xmlChar *URI;
1341 
1342             /*
1343             * TODO: Don&#39;t use xsltGetQNameURI().
1344             */
1345             URI = xsltGetQNameURI(cur, &amp;element);
1346             if (element == NULL) {
1347             /*
1348             * TODO: We&#39;ll report additionally an error
1349             *  via the stylesheet&#39;s error handling.
1350             */
1351             xsltTransformError(NULL, style, cur,
<span class="line-modified">1352                 &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;</span>
<span class="line-modified">1353                 &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);</span>
1354             style-&gt;errors++;
1355             } else {
1356             xmlNsPtr ns;
1357 
1358             /*
1359             * XSLT-1.0 &quot;Each QName is expanded into an
1360             *  expanded-name using the namespace declarations in
1361             *  effect on the xsl:output element in which the QName
1362             *  occurs; if there is a default namespace, it is used
1363             *  for QNames that do not have a prefix&quot;
1364             * NOTE: Fix of bug #339570.
1365             */
1366             if (URI == NULL) {
1367                 ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1368                 if (ns != NULL)
1369                 URI = ns-&gt;href;
1370             }
1371             xmlHashAddEntry2(style-&gt;cdataSection, element, URI,
1372                 (void *) &quot;cdata&quot;);
1373             xmlFree(element);
</pre>
<hr />
<pre>
5462     }
5463 
5464     /*
5465      * parse the content and register the pattern
5466      */
5467     xsltParseTemplateContent(style, template);
5468     ret-&gt;elem = template;
5469     ret-&gt;content = template-&gt;children;
5470     xsltAddTemplate(style, ret, ret-&gt;mode, ret-&gt;modeURI);
5471 
5472 error:
5473     return;
5474 }
5475 
5476 #endif /* else XSLT_REFACTORED */
5477 
5478 #ifdef XSLT_REFACTORED
5479 
5480 /**
5481  * xsltIncludeComp:
<span class="line-modified">5482  * @cctxt: the compilation contenxt</span>
5483  * @node:  the xsl:include node
5484  *
5485  * Process the xslt include node on the source node
5486  */
5487 static xsltStyleItemIncludePtr
5488 xsltCompileXSLTIncludeElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node) {
5489     xsltStyleItemIncludePtr item;
5490 
5491     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
5492     return(NULL);
5493 
5494     node-&gt;psvi = NULL;
5495     item = (xsltStyleItemIncludePtr) xmlMalloc(sizeof(xsltStyleItemInclude));
5496     if (item == NULL) {
5497     xsltTransformError(NULL, cctxt-&gt;style, node,
5498         &quot;xsltIncludeComp : malloc failed\n&quot;);
5499     cctxt-&gt;style-&gt;errors++;
5500     return(NULL);
5501     }
5502     memset(item, 0, sizeof(xsltStyleItemInclude));
</pre>
<hr />
<pre>
6515 
6516 /**
6517  * xsltParseStylesheetImportedDoc:
6518  * @doc:  an xmlDoc parsed XML
6519  * @parentStyle: pointer to the parent stylesheet (if it exists)
6520  *
6521  * parse an XSLT stylesheet building the associated structures
6522  * except the processing not needed for imported documents.
6523  *
6524  * Returns a new XSLT stylesheet structure.
6525  */
6526 
6527 xsltStylesheetPtr
6528 xsltParseStylesheetImportedDoc(xmlDocPtr doc,
6529                    xsltStylesheetPtr parentStyle) {
6530     xsltStylesheetPtr retStyle;
6531 
6532     if (doc == NULL)
6533     return(NULL);
6534 
<span class="line-modified">6535     retStyle = xsltNewStylesheet();</span>
6536     if (retStyle == NULL)
6537     return(NULL);
<span class="line-modified">6538     /*</span>
<span class="line-modified">6539     * Set the importing stylesheet module; also used to detect recursion.</span>
<span class="line-modified">6540     */</span>
<span class="line-modified">6541     retStyle-&gt;parent = parentStyle;</span>



















6542     /*
6543     * Adjust the string dict.
6544     */
6545     if (doc-&gt;dict != NULL) {
<span class="line-modified">6546         xmlDictFree(retStyle-&gt;dict);</span>
<span class="line-modified">6547     retStyle-&gt;dict = doc-&gt;dict;</span>
6548 #ifdef WITH_XSLT_DEBUG
6549         xsltGenericDebug(xsltGenericDebugContext,
6550         &quot;reusing dictionary from %s for stylesheet\n&quot;,
6551         doc-&gt;URL);
6552 #endif
<span class="line-modified">6553     xmlDictReference(retStyle-&gt;dict);</span>
6554     }
6555 
6556     /*
6557     * TODO: Eliminate xsltGatherNamespaces(); we must not restrict
6558     *  the stylesheet to containt distinct namespace prefixes.
6559     */
<span class="line-modified">6560     xsltGatherNamespaces(retStyle);</span>
6561 
6562 #ifdef XSLT_REFACTORED
6563     {
6564     xsltCompilerCtxtPtr cctxt;
6565     xsltStylesheetPtr oldCurSheet;
6566 
<span class="line-modified">6567     if (parentStyle == NULL) {</span>
6568         xsltPrincipalStylesheetDataPtr principalData;
6569         /*
<span class="line-removed">6570         * Principal stylesheet</span>
<span class="line-removed">6571         * --------------------</span>
<span class="line-removed">6572         */</span>
<span class="line-removed">6573         retStyle-&gt;principal = retStyle;</span>
<span class="line-removed">6574         /*</span>
6575         * Create extra data for the principal stylesheet.
6576         */
6577         principalData = xsltNewPrincipalStylesheetData();
6578         if (principalData == NULL) {
<span class="line-modified">6579         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6580         return(NULL);</span>
6581         }
<span class="line-modified">6582         retStyle-&gt;principalData = principalData;</span>
6583         /*
6584         * Create the compilation context
6585         * ------------------------------
6586         * (only once; for the principal stylesheet).
6587         * This is currently the only function where the
6588         * compilation context is created.
6589         */
<span class="line-modified">6590         cctxt = xsltCompilationCtxtCreate(retStyle);</span>
6591         if (cctxt == NULL) {
<span class="line-modified">6592         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6593         return(NULL);</span>
6594         }
<span class="line-modified">6595         retStyle-&gt;compCtxt = (void *) cctxt;</span>
<span class="line-modified">6596         cctxt-&gt;style = retStyle;</span>
<span class="line-modified">6597         cctxt-&gt;dict = retStyle-&gt;dict;</span>
6598         cctxt-&gt;psData = principalData;
6599         /*
6600         * Push initial dummy node info.
6601         */
6602         cctxt-&gt;depth = -1;
6603         xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6604     } else {
6605         /*
6606         * Imported stylesheet.
6607         */
<span class="line-modified">6608         retStyle-&gt;principal = parentStyle-&gt;principal;</span>
<span class="line-modified">6609         cctxt = parentStyle-&gt;compCtxt;</span>
<span class="line-removed">6610         retStyle-&gt;compCtxt = cctxt;</span>
6611     }
6612     /*
6613     * Save the old and set the current stylesheet structure in the
6614     * compilation context.
6615     */
6616     oldCurSheet = cctxt-&gt;style;
<span class="line-modified">6617     cctxt-&gt;style = retStyle;</span>
6618 
<span class="line-modified">6619     retStyle-&gt;doc = doc;</span>
<span class="line-modified">6620     xsltParseStylesheetProcess(retStyle, doc);</span>
6621 
6622     cctxt-&gt;style = oldCurSheet;
<span class="line-modified">6623     if (parentStyle == NULL) {</span>
6624         /*
6625         * Pop the initial dummy node info.
6626         */
6627         xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6628     } else {
6629         /*
6630         * Clear the compilation context of imported
6631         * stylesheets.
6632         * TODO: really?
6633         */
<span class="line-modified">6634         /* retStyle-&gt;compCtxt = NULL; */</span>
6635     }
<span class="line-modified">6636     /*</span>
<span class="line-removed">6637     * Free the stylesheet if there were errors.</span>
<span class="line-removed">6638     */</span>
<span class="line-removed">6639     if (retStyle != NULL) {</span>
<span class="line-removed">6640         if (retStyle-&gt;errors != 0) {</span>
6641 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
<span class="line-modified">6642         /*</span>
<span class="line-modified">6643         * Restore all changes made to namespace URIs of ns-decls.</span>
<span class="line-modified">6644         */</span>
<span class="line-modified">6645         if (cctxt-&gt;psData-&gt;nsMap)</span>
<span class="line-modified">6646             xsltRestoreDocumentNamespaces(cctxt-&gt;psData-&gt;nsMap, doc);</span>
<span class="line-modified">6647 #endif</span>
<span class="line-removed">6648         /*</span>
<span class="line-removed">6649         * Detach the doc from the stylesheet; otherwise the doc</span>
<span class="line-removed">6650         * will be freed in xsltFreeStylesheet().</span>
<span class="line-removed">6651         */</span>
<span class="line-removed">6652         retStyle-&gt;doc = NULL;</span>
<span class="line-removed">6653         /*</span>
<span class="line-removed">6654         * Cleanup the doc if its the main stylesheet.</span>
<span class="line-removed">6655         */</span>
<span class="line-removed">6656         if (parentStyle == NULL) {</span>
<span class="line-removed">6657             xsltCleanupStylesheetTree(doc, xmlDocGetRootElement(doc));</span>
<span class="line-removed">6658             if (retStyle-&gt;compCtxt != NULL) {</span>
<span class="line-removed">6659             xsltCompilationCtxtFree(retStyle-&gt;compCtxt);</span>
<span class="line-removed">6660             retStyle-&gt;compCtxt = NULL;</span>
<span class="line-removed">6661             }</span>
6662         }

6663 
<span class="line-modified">6664         xsltFreeStylesheet(retStyle);</span>
<span class="line-modified">6665         retStyle = NULL;</span>

6666         }
6667     }
<span class="line-removed">6668     }</span>
6669 
6670 #else /* XSLT_REFACTORED */
6671     /*
6672     * Old behaviour.
6673     */
<span class="line-modified">6674     retStyle-&gt;doc = doc;</span>
<span class="line-modified">6675     if (xsltParseStylesheetProcess(retStyle, doc) == NULL) {</span>
<span class="line-modified">6676         retStyle-&gt;doc = NULL;</span>
<span class="line-modified">6677         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6678         retStyle = NULL;</span>
<span class="line-removed">6679     }</span>
<span class="line-removed">6680     if (retStyle != NULL) {</span>
<span class="line-removed">6681     if (retStyle-&gt;errors != 0) {</span>
<span class="line-removed">6682         retStyle-&gt;doc = NULL;</span>
<span class="line-removed">6683         if (parentStyle == NULL)</span>
<span class="line-removed">6684         xsltCleanupStylesheetTree(doc,</span>
<span class="line-removed">6685             xmlDocGetRootElement(doc));</span>
<span class="line-removed">6686         xsltFreeStylesheet(retStyle);</span>
<span class="line-removed">6687         retStyle = NULL;</span>
<span class="line-removed">6688     }</span>
6689     }
6690 #endif /* else of XSLT_REFACTORED */
6691 
<span class="line-modified">6692     return(retStyle);</span>

















6693 }
6694 
6695 /**
6696  * xsltParseStylesheetDoc:
6697  * @doc:  and xmlDoc parsed XML
6698  *
6699  * parse an XSLT stylesheet, building the associated structures.  doc
6700  * is kept as a reference within the returned stylesheet, so changes
6701  * to doc after the parsing will be reflected when the stylesheet
6702  * is applied, and the doc is automatically freed when the
6703  * stylesheet is closed.
6704  *
6705  * Returns a new XSLT stylesheet structure.
6706  */
6707 
6708 xsltStylesheetPtr
6709 xsltParseStylesheetDoc(xmlDocPtr doc) {
<span class="line-removed">6710     xsltStylesheetPtr ret;</span>
<span class="line-removed">6711 </span>
6712     xsltInitGlobals();
6713 
<span class="line-modified">6714     ret = xsltParseStylesheetImportedDoc(doc, NULL);</span>
<span class="line-removed">6715     if (ret == NULL)</span>
<span class="line-removed">6716     return(NULL);</span>
<span class="line-removed">6717 </span>
<span class="line-removed">6718     xsltResolveStylesheetAttributeSet(ret);</span>
<span class="line-removed">6719 #ifdef XSLT_REFACTORED</span>
<span class="line-removed">6720     /*</span>
<span class="line-removed">6721     * Free the compilation context.</span>
<span class="line-removed">6722     * TODO: Check if it&#39;s better to move this cleanup to</span>
<span class="line-removed">6723     *   xsltParseStylesheetImportedDoc().</span>
<span class="line-removed">6724     */</span>
<span class="line-removed">6725     if (ret-&gt;compCtxt != NULL) {</span>
<span class="line-removed">6726     xsltCompilationCtxtFree(XSLT_CCTXT(ret));</span>
<span class="line-removed">6727     ret-&gt;compCtxt = NULL;</span>
<span class="line-removed">6728     }</span>
<span class="line-removed">6729 #endif</span>
<span class="line-removed">6730     return(ret);</span>
6731 }
6732 
6733 /**
6734  * xsltParseStylesheetFile:
6735  * @filename:  the filename/URL to the stylesheet
6736  *
6737  * Load and parse an XSLT stylesheet
6738  *
6739  * Returns a new XSLT stylesheet structure.
6740  */
6741 
6742 xsltStylesheetPtr
6743 xsltParseStylesheetFile(const xmlChar* filename) {
6744     xsltSecurityPrefsPtr sec;
6745     xsltStylesheetPtr ret;
6746     xmlDocPtr doc;
6747 
6748     xsltInitGlobals();
6749 
6750     if (filename == NULL)
</pre>
</td>
<td>
<hr />
<pre>
 575     xsltGenericDebug(xsltGenericDebugContext,
 576     &quot;Freeing compilation context\n&quot;);
 577     xsltGenericDebug(xsltGenericDebugContext,
 578     &quot;### Max inodes: %d\n&quot;, cctxt-&gt;maxNodeInfos);
 579     xsltGenericDebug(xsltGenericDebugContext,
 580     &quot;### Max LREs  : %d\n&quot;, cctxt-&gt;maxLREs);
 581 #endif
 582     /*
 583     * Free node-infos.
 584     */
 585     if (cctxt-&gt;inodeList != NULL) {
 586     xsltCompilerNodeInfoPtr tmp, cur = cctxt-&gt;inodeList;
 587     while (cur != NULL) {
 588         tmp = cur;
 589         cur = cur-&gt;next;
 590         xmlFree(tmp);
 591     }
 592     }
 593     if (cctxt-&gt;tmpList != NULL)
 594     xsltPointerListFree(cctxt-&gt;tmpList);




 595     if (cctxt-&gt;nsAliases != NULL)
 596     xsltFreeNsAliasList(cctxt-&gt;nsAliases);
 597 
 598     if (cctxt-&gt;ivars)
 599     xsltCompilerVarInfoFree(cctxt);
 600 
 601     xmlFree(cctxt);
 602 }
 603 
 604 /**
 605  * xsltCompilerCreate:
 606  *
 607  * Creates an XSLT compiler context.
 608  *
 609  * Returns the pointer to the created xsltCompilerCtxt or
 610  *         NULL in case of an internal error.
 611  */
 612 static xsltCompilerCtxtPtr
 613 xsltCompilationCtxtCreate(xsltStylesheetPtr style) {
 614     xsltCompilerCtxtPtr ret;
 615 
 616     ret = (xsltCompilerCtxtPtr) xmlMalloc(sizeof(xsltCompilerCtxt));
 617     if (ret == NULL) {
 618     xsltTransformError(NULL, style, NULL,
 619         &quot;xsltCompilerCreate: allocation of compiler &quot;
 620         &quot;context failed.\n&quot;);
 621     return(NULL);
 622     }
 623     memset(ret, 0, sizeof(xsltCompilerCtxt));
 624 
 625     ret-&gt;errSeverity = XSLT_ERROR_SEVERITY_ERROR;
 626     ret-&gt;tmpList = xsltPointerListCreate(20);
 627     if (ret-&gt;tmpList == NULL) {
 628     goto internal_err;
 629     }









 630 
 631     return(ret);
 632 
 633 internal_err:
 634     xsltCompilationCtxtFree(ret);
 635     return(NULL);
 636 }
 637 
 638 static void
 639 xsltLREEffectiveNsNodesFree(xsltEffectiveNsPtr first)
 640 {
 641     xsltEffectiveNsPtr tmp;
 642 
 643     while (first != NULL) {
 644     tmp = first;
 645     first = first-&gt;nextInStore;
 646     xmlFree(tmp);
 647     }
 648 }
 649 
</pre>
<hr />
<pre>
 731     ret-&gt;exclResultNamespaces = xsltPointerListCreate(-1);
 732     if (ret-&gt;exclResultNamespaces == NULL)
 733     goto internal_err;
 734     /*
 735     * Global list of extension instruction namespace names.
 736     */
 737     ret-&gt;extElemNamespaces = xsltPointerListCreate(-1);
 738     if (ret-&gt;extElemNamespaces == NULL)
 739     goto internal_err;
 740 
 741     return(ret);
 742 
 743 internal_err:
 744 
 745     return(NULL);
 746 }
 747 
 748 #endif
 749 
 750 /**
<span class="line-modified"> 751  * xsltNewStylesheetInternal:</span>
<span class="line-added"> 752  * @parent:  the parent stylesheet or NULL</span>
 753  *
 754  * Create a new XSLT Stylesheet
 755  *
 756  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error
 757  */
<span class="line-modified"> 758 static xsltStylesheetPtr</span>
<span class="line-modified"> 759 xsltNewStylesheetInternal(xsltStylesheetPtr parent) {</span>
 760     xsltStylesheetPtr ret = NULL;
 761 
 762     ret = (xsltStylesheetPtr) xmlMalloc(sizeof(xsltStylesheet));
 763     if (ret == NULL) {
 764     xsltTransformError(NULL, NULL, NULL,
 765         &quot;xsltNewStylesheet : malloc failed\n&quot;);
 766     goto internal_err;
 767     }
 768     memset(ret, 0, sizeof(xsltStylesheet));
 769 
<span class="line-added"> 770     ret-&gt;parent = parent;</span>
 771     ret-&gt;omitXmlDeclaration = -1;
 772     ret-&gt;standalone = -1;
 773     ret-&gt;decimalFormat = xsltNewDecimalFormat(NULL, NULL);
 774     ret-&gt;indent = -1;
 775     ret-&gt;errors = 0;
 776     ret-&gt;warnings = 0;
 777     ret-&gt;exclPrefixNr = 0;
 778     ret-&gt;exclPrefixMax = 0;
 779     ret-&gt;exclPrefixTab = NULL;
 780     ret-&gt;extInfos = NULL;
 781     ret-&gt;extrasNr = 0;
 782     ret-&gt;internalized = 1;
 783     ret-&gt;literal_result = 0;
 784     ret-&gt;forwards_compatible = 0;
 785     ret-&gt;dict = xmlDictCreate();
 786 #ifdef WITH_XSLT_DEBUG
 787     xsltGenericDebug(xsltGenericDebugContext,
 788     &quot;creating dictionary for stylesheet\n&quot;);
 789 #endif
 790 
<span class="line-added"> 791     if (parent == NULL) {</span>
<span class="line-added"> 792         ret-&gt;principal = ret;</span>
<span class="line-added"> 793 </span>
<span class="line-added"> 794         ret-&gt;xpathCtxt = xmlXPathNewContext(NULL);</span>
<span class="line-added"> 795         if (ret-&gt;xpathCtxt == NULL) {</span>
<span class="line-added"> 796             xsltTransformError(NULL, NULL, NULL,</span>
<span class="line-added"> 797                     &quot;xsltNewStylesheet: xmlXPathNewContext failed\n&quot;);</span>
<span class="line-added"> 798             goto internal_err;</span>
<span class="line-added"> 799         }</span>
<span class="line-added"> 800         if (xmlXPathContextSetCache(ret-&gt;xpathCtxt, 1, -1, 0) == -1)</span>
<span class="line-added"> 801             goto internal_err;</span>
<span class="line-added"> 802     } else {</span>
<span class="line-added"> 803         ret-&gt;principal = parent-&gt;principal;</span>
<span class="line-added"> 804     }</span>
<span class="line-added"> 805 </span>
 806     xsltInit();
 807 
 808     return(ret);
 809 
 810 internal_err:
 811     if (ret != NULL)
 812     xsltFreeStylesheet(ret);
 813     return(NULL);
 814 }
 815 
<span class="line-added"> 816 /**</span>
<span class="line-added"> 817  * xsltNewStylesheet:</span>
<span class="line-added"> 818  *</span>
<span class="line-added"> 819  * Create a new XSLT Stylesheet</span>
<span class="line-added"> 820  *</span>
<span class="line-added"> 821  * Returns the newly allocated xsltStylesheetPtr or NULL in case of error</span>
<span class="line-added"> 822  */</span>
<span class="line-added"> 823 xsltStylesheetPtr</span>
<span class="line-added"> 824 xsltNewStylesheet(void) {</span>
<span class="line-added"> 825     return xsltNewStylesheetInternal(NULL);</span>
<span class="line-added"> 826 }</span>
<span class="line-added"> 827 </span>
 828 /**
 829  * xsltAllocateExtra:
 830  * @style:  an XSLT stylesheet
 831  *
 832  * Allocate an extra runtime information slot statically while compiling
 833  * the stylesheet and return its number
 834  *
 835  * Returns the number of the slot
 836  */
 837 int
 838 xsltAllocateExtra(xsltStylesheetPtr style)
 839 {
 840     return(style-&gt;extrasNr++);
 841 }
 842 
 843 /**
 844  * xsltAllocateExtraCtxt:
 845  * @ctxt:  an XSLT transformation context
 846  *
 847  * Allocate an extra runtime information slot at run-time
</pre>
<hr />
<pre>
1064     if (style-&gt;principalData) {
1065         xsltFreePrincipalStylesheetData(style-&gt;principalData);
1066         style-&gt;principalData = NULL;
1067     }
1068     }
1069 #endif
1070     /*
1071     * Better to free the main document of this stylesheet level
1072     * at the end - so here.
1073     */
1074     if (style-&gt;doc != NULL) {
1075         xmlFreeDoc(style-&gt;doc);
1076     }
1077 
1078 #ifdef WITH_XSLT_DEBUG
1079     xsltGenericDebug(xsltGenericDebugContext,
1080                      &quot;freeing dictionary from stylesheet\n&quot;);
1081 #endif
1082     xmlDictFree(style-&gt;dict);
1083 
<span class="line-added">1084     if (style-&gt;xpathCtxt != NULL)</span>
<span class="line-added">1085     xmlXPathFreeContext(style-&gt;xpathCtxt);</span>
<span class="line-added">1086 </span>
1087     memset(style, -1, sizeof(xsltStylesheet));
1088     xmlFree(style);
1089 }
1090 
1091 /************************************************************************
1092  *                                  *
1093  *      Parsing of an XSLT Stylesheet               *
1094  *                                  *
1095  ************************************************************************/
1096 
1097 #ifdef XSLT_REFACTORED
1098     /*
1099     * This is now performed in an optimized way in xsltParseXSLTTemplate.
1100     */
1101 #else
1102 /**
1103  * xsltGetInheritedNsList:
1104  * @style:  the stylesheet
1105  * @template: the template
1106  * @node:  the current node
</pre>
<hr />
<pre>
1351 #endif
1352         if (xmlValidateQName(BAD_CAST element, 0) != 0) {
1353             xsltTransformError(NULL, style, cur,
1354             &quot;Attribute &#39;cdata-section-elements&#39;: The value &quot;
1355             &quot;&#39;%s&#39; is not a valid QName.\n&quot;, element);
1356             xmlFree(element);
1357             style-&gt;errors++;
1358         } else {
1359             const xmlChar *URI;
1360 
1361             /*
1362             * TODO: Don&#39;t use xsltGetQNameURI().
1363             */
1364             URI = xsltGetQNameURI(cur, &amp;element);
1365             if (element == NULL) {
1366             /*
1367             * TODO: We&#39;ll report additionally an error
1368             *  via the stylesheet&#39;s error handling.
1369             */
1370             xsltTransformError(NULL, style, cur,
<span class="line-modified">1371                 &quot;Attribute &#39;cdata-section-elements&#39;: &quot;</span>
<span class="line-modified">1372                 &quot;Not a valid QName.\n&quot;);</span>
1373             style-&gt;errors++;
1374             } else {
1375             xmlNsPtr ns;
1376 
1377             /*
1378             * XSLT-1.0 &quot;Each QName is expanded into an
1379             *  expanded-name using the namespace declarations in
1380             *  effect on the xsl:output element in which the QName
1381             *  occurs; if there is a default namespace, it is used
1382             *  for QNames that do not have a prefix&quot;
1383             * NOTE: Fix of bug #339570.
1384             */
1385             if (URI == NULL) {
1386                 ns = xmlSearchNs(style-&gt;doc, cur, NULL);
1387                 if (ns != NULL)
1388                 URI = ns-&gt;href;
1389             }
1390             xmlHashAddEntry2(style-&gt;cdataSection, element, URI,
1391                 (void *) &quot;cdata&quot;);
1392             xmlFree(element);
</pre>
<hr />
<pre>
5481     }
5482 
5483     /*
5484      * parse the content and register the pattern
5485      */
5486     xsltParseTemplateContent(style, template);
5487     ret-&gt;elem = template;
5488     ret-&gt;content = template-&gt;children;
5489     xsltAddTemplate(style, ret, ret-&gt;mode, ret-&gt;modeURI);
5490 
5491 error:
5492     return;
5493 }
5494 
5495 #endif /* else XSLT_REFACTORED */
5496 
5497 #ifdef XSLT_REFACTORED
5498 
5499 /**
5500  * xsltIncludeComp:
<span class="line-modified">5501  * @cctxt: the compilation context</span>
5502  * @node:  the xsl:include node
5503  *
5504  * Process the xslt include node on the source node
5505  */
5506 static xsltStyleItemIncludePtr
5507 xsltCompileXSLTIncludeElem(xsltCompilerCtxtPtr cctxt, xmlNodePtr node) {
5508     xsltStyleItemIncludePtr item;
5509 
5510     if ((cctxt == NULL) || (node == NULL) || (node-&gt;type != XML_ELEMENT_NODE))
5511     return(NULL);
5512 
5513     node-&gt;psvi = NULL;
5514     item = (xsltStyleItemIncludePtr) xmlMalloc(sizeof(xsltStyleItemInclude));
5515     if (item == NULL) {
5516     xsltTransformError(NULL, cctxt-&gt;style, node,
5517         &quot;xsltIncludeComp : malloc failed\n&quot;);
5518     cctxt-&gt;style-&gt;errors++;
5519     return(NULL);
5520     }
5521     memset(item, 0, sizeof(xsltStyleItemInclude));
</pre>
<hr />
<pre>
6534 
6535 /**
6536  * xsltParseStylesheetImportedDoc:
6537  * @doc:  an xmlDoc parsed XML
6538  * @parentStyle: pointer to the parent stylesheet (if it exists)
6539  *
6540  * parse an XSLT stylesheet building the associated structures
6541  * except the processing not needed for imported documents.
6542  *
6543  * Returns a new XSLT stylesheet structure.
6544  */
6545 
6546 xsltStylesheetPtr
6547 xsltParseStylesheetImportedDoc(xmlDocPtr doc,
6548                    xsltStylesheetPtr parentStyle) {
6549     xsltStylesheetPtr retStyle;
6550 
6551     if (doc == NULL)
6552     return(NULL);
6553 
<span class="line-modified">6554     retStyle = xsltNewStylesheetInternal(parentStyle);</span>
6555     if (retStyle == NULL)
6556     return(NULL);
<span class="line-modified">6557 </span>
<span class="line-modified">6558     if (xsltParseStylesheetUser(retStyle, doc) != 0) {</span>
<span class="line-modified">6559         xsltFreeStylesheet(retStyle);</span>
<span class="line-modified">6560         return(NULL);</span>
<span class="line-added">6561     }</span>
<span class="line-added">6562 </span>
<span class="line-added">6563     return(retStyle);</span>
<span class="line-added">6564 }</span>
<span class="line-added">6565 </span>
<span class="line-added">6566 /**</span>
<span class="line-added">6567  * xsltParseStylesheetUser:</span>
<span class="line-added">6568  * @style: pointer to the stylesheet</span>
<span class="line-added">6569  * @doc:  an xmlDoc parsed XML</span>
<span class="line-added">6570  *</span>
<span class="line-added">6571  * Parse an XSLT stylesheet with a user-provided stylesheet struct.</span>
<span class="line-added">6572  *</span>
<span class="line-added">6573  * Returns 0 if successful, -1 in case of error.</span>
<span class="line-added">6574  */</span>
<span class="line-added">6575 int</span>
<span class="line-added">6576 xsltParseStylesheetUser(xsltStylesheetPtr style, xmlDocPtr doc) {</span>
<span class="line-added">6577     if ((style == NULL) || (doc == NULL))</span>
<span class="line-added">6578     return(-1);</span>
<span class="line-added">6579 </span>
6580     /*
6581     * Adjust the string dict.
6582     */
6583     if (doc-&gt;dict != NULL) {
<span class="line-modified">6584         xmlDictFree(style-&gt;dict);</span>
<span class="line-modified">6585     style-&gt;dict = doc-&gt;dict;</span>
6586 #ifdef WITH_XSLT_DEBUG
6587         xsltGenericDebug(xsltGenericDebugContext,
6588         &quot;reusing dictionary from %s for stylesheet\n&quot;,
6589         doc-&gt;URL);
6590 #endif
<span class="line-modified">6591     xmlDictReference(style-&gt;dict);</span>
6592     }
6593 
6594     /*
6595     * TODO: Eliminate xsltGatherNamespaces(); we must not restrict
6596     *  the stylesheet to containt distinct namespace prefixes.
6597     */
<span class="line-modified">6598     xsltGatherNamespaces(style);</span>
6599 
6600 #ifdef XSLT_REFACTORED
6601     {
6602     xsltCompilerCtxtPtr cctxt;
6603     xsltStylesheetPtr oldCurSheet;
6604 
<span class="line-modified">6605     if (style-&gt;parent == NULL) {</span>
6606         xsltPrincipalStylesheetDataPtr principalData;
6607         /*





6608         * Create extra data for the principal stylesheet.
6609         */
6610         principalData = xsltNewPrincipalStylesheetData();
6611         if (principalData == NULL) {
<span class="line-modified">6612         return(-1);</span>

6613         }
<span class="line-modified">6614         style-&gt;principalData = principalData;</span>
6615         /*
6616         * Create the compilation context
6617         * ------------------------------
6618         * (only once; for the principal stylesheet).
6619         * This is currently the only function where the
6620         * compilation context is created.
6621         */
<span class="line-modified">6622         cctxt = xsltCompilationCtxtCreate(style);</span>
6623         if (cctxt == NULL) {
<span class="line-modified">6624         return(-1);</span>

6625         }
<span class="line-modified">6626         style-&gt;compCtxt = (void *) cctxt;</span>
<span class="line-modified">6627         cctxt-&gt;style = style;</span>
<span class="line-modified">6628         cctxt-&gt;dict = style-&gt;dict;</span>
6629         cctxt-&gt;psData = principalData;
6630         /*
6631         * Push initial dummy node info.
6632         */
6633         cctxt-&gt;depth = -1;
6634         xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);
6635     } else {
6636         /*
6637         * Imported stylesheet.
6638         */
<span class="line-modified">6639         cctxt = style-&gt;parent-&gt;compCtxt;</span>
<span class="line-modified">6640         style-&gt;compCtxt = cctxt;</span>

6641     }
6642     /*
6643     * Save the old and set the current stylesheet structure in the
6644     * compilation context.
6645     */
6646     oldCurSheet = cctxt-&gt;style;
<span class="line-modified">6647     cctxt-&gt;style = style;</span>
6648 
<span class="line-modified">6649     style-&gt;doc = doc;</span>
<span class="line-modified">6650     xsltParseStylesheetProcess(style, doc);</span>
6651 
6652     cctxt-&gt;style = oldCurSheet;
<span class="line-modified">6653     if (style-&gt;parent == NULL) {</span>
6654         /*
6655         * Pop the initial dummy node info.
6656         */
6657         xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);
6658     } else {
6659         /*
6660         * Clear the compilation context of imported
6661         * stylesheets.
6662         * TODO: really?
6663         */
<span class="line-modified">6664         /* style-&gt;compCtxt = NULL; */</span>
6665     }
<span class="line-modified">6666 </span>




6667 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
<span class="line-modified">6668         if (style-&gt;errors != 0) {</span>
<span class="line-modified">6669             /*</span>
<span class="line-modified">6670             * Restore all changes made to namespace URIs of ns-decls.</span>
<span class="line-modified">6671             */</span>
<span class="line-modified">6672             if (cctxt-&gt;psData-&gt;nsMap)</span>
<span class="line-modified">6673                 xsltRestoreDocumentNamespaces(cctxt-&gt;psData-&gt;nsMap, doc);</span>














6674         }
<span class="line-added">6675 #endif</span>
6676 
<span class="line-modified">6677         if (style-&gt;parent == NULL) {</span>
<span class="line-modified">6678             xsltCompilationCtxtFree(style-&gt;compCtxt);</span>
<span class="line-added">6679             style-&gt;compCtxt = NULL;</span>
6680         }
6681     }

6682 
6683 #else /* XSLT_REFACTORED */
6684     /*
6685     * Old behaviour.
6686     */
<span class="line-modified">6687     style-&gt;doc = doc;</span>
<span class="line-modified">6688     if (xsltParseStylesheetProcess(style, doc) == NULL) {</span>
<span class="line-modified">6689         style-&gt;doc = NULL;</span>
<span class="line-modified">6690         return(-1);</span>











6691     }
6692 #endif /* else of XSLT_REFACTORED */
6693 
<span class="line-modified">6694     if (style-&gt;errors != 0) {</span>
<span class="line-added">6695         /*</span>
<span class="line-added">6696         * Detach the doc from the stylesheet; otherwise the doc</span>
<span class="line-added">6697         * will be freed in xsltFreeStylesheet().</span>
<span class="line-added">6698         */</span>
<span class="line-added">6699         style-&gt;doc = NULL;</span>
<span class="line-added">6700         /*</span>
<span class="line-added">6701         * Cleanup the doc if its the main stylesheet.</span>
<span class="line-added">6702         */</span>
<span class="line-added">6703         if (style-&gt;parent == NULL)</span>
<span class="line-added">6704             xsltCleanupStylesheetTree(doc, xmlDocGetRootElement(doc));</span>
<span class="line-added">6705         return(-1);</span>
<span class="line-added">6706     }</span>
<span class="line-added">6707 </span>
<span class="line-added">6708     if (style-&gt;parent == NULL)</span>
<span class="line-added">6709         xsltResolveStylesheetAttributeSet(style);</span>
<span class="line-added">6710 </span>
<span class="line-added">6711     return(0);</span>
6712 }
6713 
6714 /**
6715  * xsltParseStylesheetDoc:
6716  * @doc:  and xmlDoc parsed XML
6717  *
6718  * parse an XSLT stylesheet, building the associated structures.  doc
6719  * is kept as a reference within the returned stylesheet, so changes
6720  * to doc after the parsing will be reflected when the stylesheet
6721  * is applied, and the doc is automatically freed when the
6722  * stylesheet is closed.
6723  *
6724  * Returns a new XSLT stylesheet structure.
6725  */
6726 
6727 xsltStylesheetPtr
6728 xsltParseStylesheetDoc(xmlDocPtr doc) {


6729     xsltInitGlobals();
6730 
<span class="line-modified">6731     return(xsltParseStylesheetImportedDoc(doc, NULL));</span>
















6732 }
6733 
6734 /**
6735  * xsltParseStylesheetFile:
6736  * @filename:  the filename/URL to the stylesheet
6737  *
6738  * Load and parse an XSLT stylesheet
6739  *
6740  * Returns a new XSLT stylesheet structure.
6741  */
6742 
6743 xsltStylesheetPtr
6744 xsltParseStylesheetFile(const xmlChar* filename) {
6745     xsltSecurityPrefsPtr sec;
6746     xsltStylesheetPtr ret;
6747     xmlDocPtr doc;
6748 
6749     xsltInitGlobals();
6750 
6751     if (filename == NULL)
</pre>
</td>
</tr>
</table>
<center><a href="variables.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="xsltInternals.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>