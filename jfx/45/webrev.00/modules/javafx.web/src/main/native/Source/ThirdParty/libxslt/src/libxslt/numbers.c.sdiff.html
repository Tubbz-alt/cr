<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="libxslt.syms.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parserInternals.h&gt;
  23 #include &lt;libxml/xpath.h&gt;
  24 #include &lt;libxml/xpathInternals.h&gt;
  25 #include &lt;libxml/encoding.h&gt;
  26 #include &quot;xsltutils.h&quot;
  27 #include &quot;pattern.h&quot;
  28 #include &quot;templates.h&quot;
  29 #include &quot;transform.h&quot;
  30 #include &quot;numbersInternals.h&quot;
  31 
  32 #ifndef FALSE
  33 # define FALSE (0 == 1)
  34 # define TRUE (1 == 1)
  35 #endif
  36 
  37 #define SYMBOL_QUOTE        ((xmlChar)&#39;\&#39;&#39;)
  38 
<span class="line-modified">  39 #define DEFAULT_TOKEN       (xmlChar)&#39;0&#39;</span>
  40 #define DEFAULT_SEPARATOR   &quot;.&quot;
  41 
  42 #define MAX_TOKENS      1024
  43 
  44 typedef struct _xsltFormatToken xsltFormatToken;
  45 typedef xsltFormatToken *xsltFormatTokenPtr;
  46 struct _xsltFormatToken {
  47     xmlChar *separator;
<span class="line-modified">  48     xmlChar  token;</span>
  49     int      width;
  50 };
  51 
  52 typedef struct _xsltFormat xsltFormat;
  53 typedef xsltFormat *xsltFormatPtr;
  54 struct _xsltFormat {
  55     xmlChar     *start;
  56     xsltFormatToken  tokens[MAX_TOKENS];
  57     int          nTokens;
  58     xmlChar     *end;
  59 };
  60 
  61 static char alpha_upper_list[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
  62 static char alpha_lower_list[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
  63 static xsltFormatToken default_token;
  64 
  65 /*
  66  * **** Start temp insert ****
  67  *
  68  * The following routine xsltUTF8Charcmp will be replaced with calls to
</pre>
<hr />
<pre>
  90         return -1;
  91     }
  92     return xmlStrncmp(utf1, utf2, len);
  93 }
  94 
  95 /***** Stop temp insert *****/
  96 /************************************************************************
  97  *                                  *
  98  *          Utility functions               *
  99  *                                  *
 100  ************************************************************************/
 101 
 102 #define IS_SPECIAL(self,letter)         \
 103     ((xsltUTF8Charcmp((letter), (self)-&gt;zeroDigit) == 0)        ||  \
 104      (xsltUTF8Charcmp((letter), (self)-&gt;digit) == 0)        ||  \
 105      (xsltUTF8Charcmp((letter), (self)-&gt;decimalPoint) == 0)  || \
 106      (xsltUTF8Charcmp((letter), (self)-&gt;grouping) == 0)     ||  \
 107      (xsltUTF8Charcmp((letter), (self)-&gt;patternSeparator) == 0))
 108 
 109 #define IS_DIGIT_ZERO(x) xsltIsDigitZero(x)
<span class="line-modified"> 110 #define IS_DIGIT_ONE(x) xsltIsDigitZero((xmlChar)(x)-1)</span>
 111 
 112 static int
 113 xsltIsDigitZero(unsigned int ch)
 114 {
 115     /*
 116      * Reference: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt



 117      */
 118     switch (ch) {
 119     case 0x0030: case 0x0660: case 0x06F0: case 0x0966:
 120     case 0x09E6: case 0x0A66: case 0x0AE6: case 0x0B66:
 121     case 0x0C66: case 0x0CE6: case 0x0D66: case 0x0E50:
<span class="line-modified"> 122     case 0x0E60: case 0x0F20: case 0x1040: case 0x17E0:</span>
<span class="line-removed"> 123     case 0x1810: case 0xFF10:</span>
 124     return TRUE;
 125     default:
 126     return FALSE;
 127     }
 128 }
 129 
 130 static void
 131 xsltNumberFormatDecimal(xmlBufferPtr buffer,
 132             double number,
 133             int digit_zero,
 134             int width,
 135             int digitsPerGroup,
 136             int groupingCharacter,
 137             int groupingCharacterLen)
 138 {
 139     /*
 140      * This used to be
 141      *  xmlChar temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 4];
 142      * which would be length 68 on x86 arch.  It was changed to be a longer,
 143      * fixed length in order to try to cater for (reasonable) UTF8
</pre>
<hr />
<pre>
 365      * number) in tokens-&gt;end, recover it.
 366      */
 367     if (tokens-&gt;nTokens &gt; 0) {
 368         tokens-&gt;tokens[tokens-&gt;nTokens].separator = tokens-&gt;end;
 369         tokens-&gt;end = NULL;
 370     }
 371 
 372     val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 373     if (IS_DIGIT_ONE(val) ||
 374          IS_DIGIT_ZERO(val)) {
 375         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 376         while (IS_DIGIT_ZERO(val)) {
 377         tokens-&gt;tokens[tokens-&gt;nTokens].width++;
 378         ix += len;
 379         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 380         }
 381         if (IS_DIGIT_ONE(val)) {
 382         tokens-&gt;tokens[tokens-&gt;nTokens].token = val - 1;
 383         ix += len;
 384         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
<span class="line-modified"> 385         }</span>
<span class="line-modified"> 386     } else if ( (val == (xmlChar)&#39;A&#39;) ||</span>
<span class="line-modified"> 387             (val == (xmlChar)&#39;a&#39;) ||</span>
<span class="line-modified"> 388             (val == (xmlChar)&#39;I&#39;) ||</span>
<span class="line-modified"> 389             (val == (xmlChar)&#39;i&#39;) ) {</span>



 390         tokens-&gt;tokens[tokens-&gt;nTokens].token = val;
 391         ix += len;
 392         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 393     } else {
 394         /* XSLT section 7.7
 395          * &quot;Any other format token indicates a numbering sequence
 396          *  that starts with that token. If an implementation does
 397          *  not support a numbering sequence that starts with that
 398          *  token, it must use a format token of 1.&quot;
 399          */
<span class="line-modified"> 400         tokens-&gt;tokens[tokens-&gt;nTokens].token = (xmlChar)&#39;0&#39;;</span>
 401         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 402     }
 403     /*
 404      * Skip over remaining alphanumeric characters from the Nd
 405      * (Number, decimal digit), Nl (Number, letter), No (Number,
 406      * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt
 407      * (Letters, titlecase), Lm (Letters, modifiers), and Lo
 408      * (Letters, other (uncased)) Unicode categories. This happens
 409      * to correspond to the Letter and Digit classes from XML (and
 410      * one wonders why XSLT doesn&#39;t refer to these instead).
 411      */
 412     while (IS_LETTER(val) || IS_DIGIT(val)) {
 413         ix += len;
 414         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 415     }
 416 
 417     /*
 418      * Insert temporary non-alphanumeric final tooken.
 419      */
 420     j = ix;
</pre>
<hr />
<pre>
 629                 cur = cur-&gt;parent;
 630             }
 631         }
 632     }
 633 
 634     array[amount++] = (double) cnt;
 635 
 636     return(amount);
 637 }
 638 
 639 static int
 640 xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 641                  xmlNodePtr node,
 642                  xsltCompMatchPtr countPat,
 643                  xsltCompMatchPtr fromPat,
 644                  double *array,
 645                  int max)
 646 {
 647     int amount = 0;
 648     int cnt;

 649     xmlNodePtr ancestor;
 650     xmlNodePtr preceding;
 651     xmlXPathParserContextPtr parser;
 652 
<span class="line-modified"> 653     context-&gt;xpathCtxt-&gt;node = node;</span>
 654     parser = xmlXPathNewParserContext(NULL, context-&gt;xpathCtxt);
 655     if (parser) {
 656     /* ancestor-or-self::*[count] */
<span class="line-modified"> 657     for (ancestor = node;</span>
<span class="line-modified"> 658          (ancestor != NULL) &amp;&amp; (ancestor-&gt;type != XML_DOCUMENT_NODE);</span>
<span class="line-removed"> 659          ancestor = xmlXPathNextAncestor(parser, ancestor)) {</span>
<span class="line-removed"> 660 </span>
 661         if ((fromPat != NULL) &amp;&amp;
 662         xsltTestCompMatchList(context, ancestor, fromPat))
 663         break; /* for */
 664 







 665         if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 666         /* count(preceding-sibling::*) */
 667         cnt = 1;
<span class="line-modified"> 668         for (preceding =</span>
<span class="line-modified"> 669                         xmlXPathNextPrecedingSibling(parser, ancestor);</span>
<span class="line-modified"> 670              preceding != NULL;</span>
<span class="line-removed"> 671              preceding =</span>
<span class="line-removed"> 672                 xmlXPathNextPrecedingSibling(parser, preceding)) {</span>
<span class="line-removed"> 673 </span>
 674                 if (xsltTestCompMatchCount(context, preceding, countPat,
 675                                                node))
 676             cnt++;



 677         }
 678         array[amount++] = (double)cnt;
 679         if (amount &gt;= max)
 680             break; /* for */
 681         }


 682     }
 683     xmlXPathFreeParserContext(parser);
 684     }

 685     return amount;
 686 }
 687 
 688 static int
 689 xsltNumberFormatGetValue(xmlXPathContextPtr context,
 690              xmlNodePtr node,
 691              const xmlChar *value,
 692              double *number)
 693 {
 694     int amount = 0;
 695     xmlBufferPtr pattern;
 696     xmlXPathObjectPtr obj;
 697 
 698     pattern = xmlBufferCreate();
 699     if (pattern != NULL) {
 700     xmlBufferCCat(pattern, &quot;number(&quot;);
 701     xmlBufferCat(pattern, value);
 702     xmlBufferCCat(pattern, &quot;)&quot;);
 703     context-&gt;node = node;
 704     obj = xmlXPathEvalExpression(xmlBufferContent(pattern),
</pre>
<hr />
<pre>
 798         xsltNumberFormatInsertNumbers(data,
 799                           numarray,
 800                           amount,
 801                           &amp;tokens,
 802                           output);
 803         }
 804     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;any&quot;)) {
 805         amount = xsltNumberFormatGetAnyLevel(ctxt,
 806                          node,
 807                          data-&gt;countPat,
 808                          data-&gt;fromPat,
 809                          &amp;number);
 810         if (amount &gt; 0) {
 811         xsltNumberFormatInsertNumbers(data,
 812                           &amp;number,
 813                           1,
 814                           &amp;tokens,
 815                           output);
 816         }
 817     }










 818     }
 819     /* Insert number as text node */
 820     xsltCopyTextString(ctxt, ctxt-&gt;insert, xmlBufferContent(output), 0);
 821 
 822     xmlBufferFree(output);
 823 
 824 XSLT_NUMBER_FORMAT_END:
 825     if (tokens.start != NULL)
 826     xmlFree(tokens.start);
 827     if (tokens.end != NULL)
 828     xmlFree(tokens.end);
 829     for (i = 0;i &lt; tokens.nTokens;i++) {
 830     if (tokens.tokens[i].separator != NULL)
 831         xmlFree(tokens.tokens[i].separator);
 832     }
 833 }
 834 
 835 static int
 836 xsltFormatNumberPreSuffix(xsltDecimalFormatPtr self, xmlChar **format, xsltFormatNumberInfoPtr info)
 837 {
<span class="line-modified"> 838     int count=0;    /* will hold total length of prefix/suffix */</span>

 839     int len;
 840 
 841     while (1) {
 842     /*
 843      * prefix / suffix ends at end of string or at
 844      * first &#39;special&#39; character
 845      */
 846     if (**format == 0)
 847         return count;
 848     /* if next character &#39;escaped&#39; just count it */
 849     if (**format == SYMBOL_QUOTE) {
 850         if (*++(*format) == 0)
 851         return -1;
 852     }
 853     else if (IS_SPECIAL(self, *format))
 854         return count;
 855     /*
 856      * else treat percent/per-mille as special cases,
 857      * depending on whether +ve or -ve
 858      */
</pre>
<hr />
<pre>
 916  *   ,      placeholder for grouping separator.
 917  *   ;      separates formats.
 918  *   -      default negative prefix.
 919  *   %      multiply by 100 and show as percentage
 920  *   ?      multiply by 1000 and show as per mille
 921  *   X      any other characters can be used in the prefix or suffix
 922  *   &#39;      used to quote special characters in a prefix or suffix.
 923  *
 924  * Returns a possible XPath error
 925  */
 926 xmlXPathError
 927 xsltFormatNumberConversion(xsltDecimalFormatPtr self,
 928                xmlChar *format,
 929                double number,
 930                xmlChar **result)
 931 {
 932     xmlXPathError status = XPATH_EXPRESSION_OK;
 933     xmlBufferPtr buffer;
 934     xmlChar *the_format, *prefix = NULL, *suffix = NULL;
 935     xmlChar *nprefix, *nsuffix = NULL;
<span class="line-removed"> 936     xmlChar pchar;</span>
 937     int     prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
 938     double  scale;
 939     int     j, len;
 940     int     self_grouping_len;
 941     xsltFormatNumberInfo format_info;
 942     /*
 943      * delayed_multiplier allows a &#39;trailing&#39; percent or
 944      * permille to be treated as suffix
 945      */
 946     int     delayed_multiplier = 0;
 947     /* flag to show no -ve format present for -ve number */
 948     char    default_sign = 0;
 949     /* flag to show error found, should use default format */
 950     char    found_error = 0;
 951 
 952     if (xmlStrlen(format) &lt;= 0) {
 953     xsltTransformError(NULL, NULL, NULL,
 954                 &quot;xsltFormatNumberConversion : &quot;
 955         &quot;Invalid format (0-length)\n&quot;);
 956     }
 957     *result = NULL;
 958     switch (xmlXPathIsInf(number)) {
 959     case -1:
 960         if (self-&gt;minusSign == NULL)
 961         *result = xmlStrdup(BAD_CAST &quot;-&quot;);
 962         else
 963         *result = xmlStrdup(self-&gt;minusSign);
<span class="line-modified"> 964         /* no-break on purpose */</span>
 965     case 1:
 966         if ((self == NULL) || (self-&gt;infinity == NULL))
 967         *result = xmlStrcat(*result, BAD_CAST &quot;Infinity&quot;);
 968         else
 969         *result = xmlStrcat(*result, self-&gt;infinity);
 970         return(status);
 971     default:
 972         if (xmlXPathIsNaN(number)) {
 973         if ((self == NULL) || (self-&gt;noNumber == NULL))
 974             *result = xmlStrdup(BAD_CAST &quot;NaN&quot;);
 975         else
 976             *result = xmlStrdup(self-&gt;noNumber);
 977         return(status);
 978         }
 979     }
 980 
 981     buffer = xmlBufferCreate();
 982     if (buffer == NULL) {
 983     return XPATH_MEMORY_ERROR;
 984     }
</pre>
<hr />
<pre>
1241     if (found_error != 0) {
1242     xsltTransformError(NULL, NULL, NULL,
1243                 &quot;xsltFormatNumberConversion : &quot;
1244         &quot;error in format string &#39;%s&#39;, using default\n&quot;, format);
1245     default_sign = (number &lt; 0.0) ? 1 : 0;
1246     prefix_length = suffix_length = 0;
1247     format_info.integer_hash = 0;
1248     format_info.integer_digits = 1;
1249     format_info.frac_digits = 1;
1250     format_info.frac_hash = 4;
1251     format_info.group = -1;
1252     format_info.multiplier = 1;
1253     format_info.add_decimal = TRUE;
1254     }
1255 
1256     /* Ready to output our number.  First see if &quot;default sign&quot; is required */
1257     if (default_sign != 0)
1258     xmlBufferAdd(buffer, self-&gt;minusSign, xmlUTF8Strsize(self-&gt;minusSign, 1));
1259 
1260     /* Put the prefix into the buffer */
<span class="line-modified">1261     for (j = 0; j &lt; prefix_length; j++) {</span>
<span class="line-modified">1262     if ((pchar = *prefix++) == SYMBOL_QUOTE) {</span>

1263         len = xmlUTF8Strsize(prefix, 1);
1264         xmlBufferAdd(buffer, prefix, len);
1265         prefix += len;
<span class="line-modified">1266         j += len - 1;   /* length of symbol less length of quote */</span>
<span class="line-removed">1267     } else</span>
<span class="line-removed">1268         xmlBufferAdd(buffer, &amp;pchar, 1);</span>
1269     }
1270 
1271     /* Next do the integer part of the number */
1272     number = fabs(number) * (double)format_info.multiplier;
1273     scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
1274     number = floor((scale * number + 0.5)) / scale;
1275     if ((self-&gt;grouping != NULL) &amp;&amp;
1276         (self-&gt;grouping[0] != 0)) {

1277 
1278     len = xmlStrlen(self-&gt;grouping);
<span class="line-modified">1279     pchar = xsltGetUTF8Char(self-&gt;grouping, &amp;len);</span>
1280     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1281                 format_info.integer_digits,
1282                 format_info.group,
<span class="line-modified">1283                 pchar, len);</span>
1284     } else
1285     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1286                 format_info.integer_digits,
1287                 format_info.group,
1288                 &#39;,&#39;, 1);
1289 
1290     /* Special case: java treats &#39;.#&#39; like &#39;.0&#39;, &#39;.##&#39; like &#39;.0#&#39;, etc. */
1291     if ((format_info.integer_digits + format_info.integer_hash +
1292      format_info.frac_digits == 0) &amp;&amp; (format_info.frac_hash &gt; 0)) {
1293         ++format_info.frac_digits;
1294     --format_info.frac_hash;
1295     }
1296 
1297     /* Add leading zero, if required */
1298     if ((floor(number) == 0) &amp;&amp;
1299     (format_info.integer_digits + format_info.frac_digits == 0)) {
1300         xmlBufferAdd(buffer, self-&gt;zeroDigit, xmlUTF8Strsize(self-&gt;zeroDigit, 1));
1301     }
1302 
1303     /* Next the fractional part, if required */
</pre>
<hr />
<pre>
1306         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1307              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1308     }
1309     else {
1310       number -= floor(number);
1311     if ((number != 0) || (format_info.frac_digits != 0)) {
1312         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1313              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1314         number = floor(scale * number + 0.5);
1315         for (j = format_info.frac_hash; j &gt; 0; j--) {
1316         if (fmod(number, 10.0) &gt;= 1.0)
1317             break; /* for */
1318         number /= 10.0;
1319         }
1320         xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1321                 format_info.frac_digits + j,
1322                 0, 0, 0);
1323     }
1324     }
1325     /* Put the suffix into the buffer */
<span class="line-modified">1326     for (j = 0; j &lt; suffix_length; j++) {</span>
<span class="line-modified">1327     if ((pchar = *suffix++) == SYMBOL_QUOTE) {</span>
<span class="line-modified">1328             len = xmlUTF8Strsize(suffix, 1);</span>

1329         xmlBufferAdd(buffer, suffix, len);
1330         suffix += len;
<span class="line-modified">1331         j += len - 1;   /* length of symbol less length of escape */</span>
<span class="line-removed">1332     } else</span>
<span class="line-removed">1333         xmlBufferAdd(buffer, &amp;pchar, 1);</span>
1334     }
1335 
1336     *result = xmlStrdup(xmlBufferContent(buffer));
1337     xmlBufferFree(buffer);
1338     return status;
1339 }
1340 
</pre>
</td>
<td>
<hr />
<pre>
  19 #include &lt;string.h&gt;
  20 
  21 #include &lt;libxml/xmlmemory.h&gt;
  22 #include &lt;libxml/parserInternals.h&gt;
  23 #include &lt;libxml/xpath.h&gt;
  24 #include &lt;libxml/xpathInternals.h&gt;
  25 #include &lt;libxml/encoding.h&gt;
  26 #include &quot;xsltutils.h&quot;
  27 #include &quot;pattern.h&quot;
  28 #include &quot;templates.h&quot;
  29 #include &quot;transform.h&quot;
  30 #include &quot;numbersInternals.h&quot;
  31 
  32 #ifndef FALSE
  33 # define FALSE (0 == 1)
  34 # define TRUE (1 == 1)
  35 #endif
  36 
  37 #define SYMBOL_QUOTE        ((xmlChar)&#39;\&#39;&#39;)
  38 
<span class="line-modified">  39 #define DEFAULT_TOKEN       &#39;0&#39;</span>
  40 #define DEFAULT_SEPARATOR   &quot;.&quot;
  41 
  42 #define MAX_TOKENS      1024
  43 
  44 typedef struct _xsltFormatToken xsltFormatToken;
  45 typedef xsltFormatToken *xsltFormatTokenPtr;
  46 struct _xsltFormatToken {
  47     xmlChar *separator;
<span class="line-modified">  48     int      token;</span>
  49     int      width;
  50 };
  51 
  52 typedef struct _xsltFormat xsltFormat;
  53 typedef xsltFormat *xsltFormatPtr;
  54 struct _xsltFormat {
  55     xmlChar     *start;
  56     xsltFormatToken  tokens[MAX_TOKENS];
  57     int          nTokens;
  58     xmlChar     *end;
  59 };
  60 
  61 static char alpha_upper_list[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
  62 static char alpha_lower_list[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
  63 static xsltFormatToken default_token;
  64 
  65 /*
  66  * **** Start temp insert ****
  67  *
  68  * The following routine xsltUTF8Charcmp will be replaced with calls to
</pre>
<hr />
<pre>
  90         return -1;
  91     }
  92     return xmlStrncmp(utf1, utf2, len);
  93 }
  94 
  95 /***** Stop temp insert *****/
  96 /************************************************************************
  97  *                                  *
  98  *          Utility functions               *
  99  *                                  *
 100  ************************************************************************/
 101 
 102 #define IS_SPECIAL(self,letter)         \
 103     ((xsltUTF8Charcmp((letter), (self)-&gt;zeroDigit) == 0)        ||  \
 104      (xsltUTF8Charcmp((letter), (self)-&gt;digit) == 0)        ||  \
 105      (xsltUTF8Charcmp((letter), (self)-&gt;decimalPoint) == 0)  || \
 106      (xsltUTF8Charcmp((letter), (self)-&gt;grouping) == 0)     ||  \
 107      (xsltUTF8Charcmp((letter), (self)-&gt;patternSeparator) == 0))
 108 
 109 #define IS_DIGIT_ZERO(x) xsltIsDigitZero(x)
<span class="line-modified"> 110 #define IS_DIGIT_ONE(x) xsltIsDigitZero((x)-1)</span>
 111 
 112 static int
 113 xsltIsDigitZero(unsigned int ch)
 114 {
 115     /*
 116      * Reference: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
<span class="line-added"> 117      *</span>
<span class="line-added"> 118      * There a many more digit ranges in newer Unicode versions. These</span>
<span class="line-added"> 119      * are only the zeros that match Digit in XML 1.0 (IS_DIGIT macro).</span>
 120      */
 121     switch (ch) {
 122     case 0x0030: case 0x0660: case 0x06F0: case 0x0966:
 123     case 0x09E6: case 0x0A66: case 0x0AE6: case 0x0B66:
 124     case 0x0C66: case 0x0CE6: case 0x0D66: case 0x0E50:
<span class="line-modified"> 125     case 0x0ED0: case 0x0F20:</span>

 126     return TRUE;
 127     default:
 128     return FALSE;
 129     }
 130 }
 131 
 132 static void
 133 xsltNumberFormatDecimal(xmlBufferPtr buffer,
 134             double number,
 135             int digit_zero,
 136             int width,
 137             int digitsPerGroup,
 138             int groupingCharacter,
 139             int groupingCharacterLen)
 140 {
 141     /*
 142      * This used to be
 143      *  xmlChar temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 4];
 144      * which would be length 68 on x86 arch.  It was changed to be a longer,
 145      * fixed length in order to try to cater for (reasonable) UTF8
</pre>
<hr />
<pre>
 367      * number) in tokens-&gt;end, recover it.
 368      */
 369     if (tokens-&gt;nTokens &gt; 0) {
 370         tokens-&gt;tokens[tokens-&gt;nTokens].separator = tokens-&gt;end;
 371         tokens-&gt;end = NULL;
 372     }
 373 
 374     val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 375     if (IS_DIGIT_ONE(val) ||
 376          IS_DIGIT_ZERO(val)) {
 377         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 378         while (IS_DIGIT_ZERO(val)) {
 379         tokens-&gt;tokens[tokens-&gt;nTokens].width++;
 380         ix += len;
 381         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 382         }
 383         if (IS_DIGIT_ONE(val)) {
 384         tokens-&gt;tokens[tokens-&gt;nTokens].token = val - 1;
 385         ix += len;
 386         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
<span class="line-modified"> 387         } else {</span>
<span class="line-modified"> 388                 tokens-&gt;tokens[tokens-&gt;nTokens].token = &#39;0&#39;;</span>
<span class="line-modified"> 389                 tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;</span>
<span class="line-modified"> 390             }</span>
<span class="line-modified"> 391     } else if ( (val == &#39;A&#39;) ||</span>
<span class="line-added"> 392             (val == &#39;a&#39;) ||</span>
<span class="line-added"> 393             (val == &#39;I&#39;) ||</span>
<span class="line-added"> 394             (val == &#39;i&#39;) ) {</span>
 395         tokens-&gt;tokens[tokens-&gt;nTokens].token = val;
 396         ix += len;
 397         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 398     } else {
 399         /* XSLT section 7.7
 400          * &quot;Any other format token indicates a numbering sequence
 401          *  that starts with that token. If an implementation does
 402          *  not support a numbering sequence that starts with that
 403          *  token, it must use a format token of 1.&quot;
 404          */
<span class="line-modified"> 405         tokens-&gt;tokens[tokens-&gt;nTokens].token = &#39;0&#39;;</span>
 406         tokens-&gt;tokens[tokens-&gt;nTokens].width = 1;
 407     }
 408     /*
 409      * Skip over remaining alphanumeric characters from the Nd
 410      * (Number, decimal digit), Nl (Number, letter), No (Number,
 411      * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt
 412      * (Letters, titlecase), Lm (Letters, modifiers), and Lo
 413      * (Letters, other (uncased)) Unicode categories. This happens
 414      * to correspond to the Letter and Digit classes from XML (and
 415      * one wonders why XSLT doesn&#39;t refer to these instead).
 416      */
 417     while (IS_LETTER(val) || IS_DIGIT(val)) {
 418         ix += len;
 419         val = xmlStringCurrentChar(NULL, format+ix, &amp;len);
 420     }
 421 
 422     /*
 423      * Insert temporary non-alphanumeric final tooken.
 424      */
 425     j = ix;
</pre>
<hr />
<pre>
 634                 cur = cur-&gt;parent;
 635             }
 636         }
 637     }
 638 
 639     array[amount++] = (double) cnt;
 640 
 641     return(amount);
 642 }
 643 
 644 static int
 645 xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
 646                  xmlNodePtr node,
 647                  xsltCompMatchPtr countPat,
 648                  xsltCompMatchPtr fromPat,
 649                  double *array,
 650                  int max)
 651 {
 652     int amount = 0;
 653     int cnt;
<span class="line-added"> 654     xmlNodePtr oldCtxtNode;</span>
 655     xmlNodePtr ancestor;
 656     xmlNodePtr preceding;
 657     xmlXPathParserContextPtr parser;
 658 
<span class="line-modified"> 659     oldCtxtNode = context-&gt;xpathCtxt-&gt;node;</span>
 660     parser = xmlXPathNewParserContext(NULL, context-&gt;xpathCtxt);
 661     if (parser) {
 662     /* ancestor-or-self::*[count] */
<span class="line-modified"> 663     ancestor = node;</span>
<span class="line-modified"> 664     while ((ancestor != NULL) &amp;&amp; (ancestor-&gt;type != XML_DOCUMENT_NODE)) {</span>


 665         if ((fromPat != NULL) &amp;&amp;
 666         xsltTestCompMatchList(context, ancestor, fromPat))
 667         break; /* for */
 668 
<span class="line-added"> 669             /*</span>
<span class="line-added"> 670              * The xmlXPathNext* iterators require that the context node is</span>
<span class="line-added"> 671              * set to the start node. Calls to xsltTestCompMatch* may also</span>
<span class="line-added"> 672              * leave the context node in an undefined state, so make sure</span>
<span class="line-added"> 673              * that the context node is reset before each iterator invocation.</span>
<span class="line-added"> 674              */</span>
<span class="line-added"> 675 </span>
 676         if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 677         /* count(preceding-sibling::*) */
 678         cnt = 1;
<span class="line-modified"> 679                 context-&gt;xpathCtxt-&gt;node = ancestor;</span>
<span class="line-modified"> 680                 preceding = xmlXPathNextPrecedingSibling(parser, ancestor);</span>
<span class="line-modified"> 681                 while (preceding != NULL) {</span>



 682                 if (xsltTestCompMatchCount(context, preceding, countPat,
 683                                                node))
 684             cnt++;
<span class="line-added"> 685                     context-&gt;xpathCtxt-&gt;node = ancestor;</span>
<span class="line-added"> 686                     preceding =</span>
<span class="line-added"> 687                         xmlXPathNextPrecedingSibling(parser, preceding);</span>
 688         }
 689         array[amount++] = (double)cnt;
 690         if (amount &gt;= max)
 691             break; /* for */
 692         }
<span class="line-added"> 693             context-&gt;xpathCtxt-&gt;node = node;</span>
<span class="line-added"> 694             ancestor = xmlXPathNextAncestor(parser, ancestor);</span>
 695     }
 696     xmlXPathFreeParserContext(parser);
 697     }
<span class="line-added"> 698     context-&gt;xpathCtxt-&gt;node = oldCtxtNode;</span>
 699     return amount;
 700 }
 701 
 702 static int
 703 xsltNumberFormatGetValue(xmlXPathContextPtr context,
 704              xmlNodePtr node,
 705              const xmlChar *value,
 706              double *number)
 707 {
 708     int amount = 0;
 709     xmlBufferPtr pattern;
 710     xmlXPathObjectPtr obj;
 711 
 712     pattern = xmlBufferCreate();
 713     if (pattern != NULL) {
 714     xmlBufferCCat(pattern, &quot;number(&quot;);
 715     xmlBufferCat(pattern, value);
 716     xmlBufferCCat(pattern, &quot;)&quot;);
 717     context-&gt;node = node;
 718     obj = xmlXPathEvalExpression(xmlBufferContent(pattern),
</pre>
<hr />
<pre>
 812         xsltNumberFormatInsertNumbers(data,
 813                           numarray,
 814                           amount,
 815                           &amp;tokens,
 816                           output);
 817         }
 818     } else if (xmlStrEqual(data-&gt;level, (const xmlChar *) &quot;any&quot;)) {
 819         amount = xsltNumberFormatGetAnyLevel(ctxt,
 820                          node,
 821                          data-&gt;countPat,
 822                          data-&gt;fromPat,
 823                          &amp;number);
 824         if (amount &gt; 0) {
 825         xsltNumberFormatInsertNumbers(data,
 826                           &amp;number,
 827                           1,
 828                           &amp;tokens,
 829                           output);
 830         }
 831     }
<span class="line-added"> 832 </span>
<span class="line-added"> 833         /*</span>
<span class="line-added"> 834          * Unlike `match` patterns, `count` and `from` patterns can contain</span>
<span class="line-added"> 835          * variable references, so we have to clear the pattern match</span>
<span class="line-added"> 836          * cache if the &quot;direct&quot; matching algorithm was used.</span>
<span class="line-added"> 837          */</span>
<span class="line-added"> 838         if (data-&gt;countPat != NULL)</span>
<span class="line-added"> 839             xsltCompMatchClearCache(ctxt, data-&gt;countPat);</span>
<span class="line-added"> 840         if (data-&gt;fromPat != NULL)</span>
<span class="line-added"> 841             xsltCompMatchClearCache(ctxt, data-&gt;fromPat);</span>
 842     }
 843     /* Insert number as text node */
 844     xsltCopyTextString(ctxt, ctxt-&gt;insert, xmlBufferContent(output), 0);
 845 
 846     xmlBufferFree(output);
 847 
 848 XSLT_NUMBER_FORMAT_END:
 849     if (tokens.start != NULL)
 850     xmlFree(tokens.start);
 851     if (tokens.end != NULL)
 852     xmlFree(tokens.end);
 853     for (i = 0;i &lt; tokens.nTokens;i++) {
 854     if (tokens.tokens[i].separator != NULL)
 855         xmlFree(tokens.tokens[i].separator);
 856     }
 857 }
 858 
 859 static int
 860 xsltFormatNumberPreSuffix(xsltDecimalFormatPtr self, xmlChar **format, xsltFormatNumberInfoPtr info)
 861 {
<span class="line-modified"> 862     /* will hold total length of prefix/suffix without quote characters */</span>
<span class="line-added"> 863     int count=0;</span>
 864     int len;
 865 
 866     while (1) {
 867     /*
 868      * prefix / suffix ends at end of string or at
 869      * first &#39;special&#39; character
 870      */
 871     if (**format == 0)
 872         return count;
 873     /* if next character &#39;escaped&#39; just count it */
 874     if (**format == SYMBOL_QUOTE) {
 875         if (*++(*format) == 0)
 876         return -1;
 877     }
 878     else if (IS_SPECIAL(self, *format))
 879         return count;
 880     /*
 881      * else treat percent/per-mille as special cases,
 882      * depending on whether +ve or -ve
 883      */
</pre>
<hr />
<pre>
 941  *   ,      placeholder for grouping separator.
 942  *   ;      separates formats.
 943  *   -      default negative prefix.
 944  *   %      multiply by 100 and show as percentage
 945  *   ?      multiply by 1000 and show as per mille
 946  *   X      any other characters can be used in the prefix or suffix
 947  *   &#39;      used to quote special characters in a prefix or suffix.
 948  *
 949  * Returns a possible XPath error
 950  */
 951 xmlXPathError
 952 xsltFormatNumberConversion(xsltDecimalFormatPtr self,
 953                xmlChar *format,
 954                double number,
 955                xmlChar **result)
 956 {
 957     xmlXPathError status = XPATH_EXPRESSION_OK;
 958     xmlBufferPtr buffer;
 959     xmlChar *the_format, *prefix = NULL, *suffix = NULL;
 960     xmlChar *nprefix, *nsuffix = NULL;

 961     int     prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
 962     double  scale;
 963     int     j, len;
 964     int     self_grouping_len;
 965     xsltFormatNumberInfo format_info;
 966     /*
 967      * delayed_multiplier allows a &#39;trailing&#39; percent or
 968      * permille to be treated as suffix
 969      */
 970     int     delayed_multiplier = 0;
 971     /* flag to show no -ve format present for -ve number */
 972     char    default_sign = 0;
 973     /* flag to show error found, should use default format */
 974     char    found_error = 0;
 975 
 976     if (xmlStrlen(format) &lt;= 0) {
 977     xsltTransformError(NULL, NULL, NULL,
 978                 &quot;xsltFormatNumberConversion : &quot;
 979         &quot;Invalid format (0-length)\n&quot;);
 980     }
 981     *result = NULL;
 982     switch (xmlXPathIsInf(number)) {
 983     case -1:
 984         if (self-&gt;minusSign == NULL)
 985         *result = xmlStrdup(BAD_CAST &quot;-&quot;);
 986         else
 987         *result = xmlStrdup(self-&gt;minusSign);
<span class="line-modified"> 988         /* Intentional fall-through */</span>
 989     case 1:
 990         if ((self == NULL) || (self-&gt;infinity == NULL))
 991         *result = xmlStrcat(*result, BAD_CAST &quot;Infinity&quot;);
 992         else
 993         *result = xmlStrcat(*result, self-&gt;infinity);
 994         return(status);
 995     default:
 996         if (xmlXPathIsNaN(number)) {
 997         if ((self == NULL) || (self-&gt;noNumber == NULL))
 998             *result = xmlStrdup(BAD_CAST &quot;NaN&quot;);
 999         else
1000             *result = xmlStrdup(self-&gt;noNumber);
1001         return(status);
1002         }
1003     }
1004 
1005     buffer = xmlBufferCreate();
1006     if (buffer == NULL) {
1007     return XPATH_MEMORY_ERROR;
1008     }
</pre>
<hr />
<pre>
1265     if (found_error != 0) {
1266     xsltTransformError(NULL, NULL, NULL,
1267                 &quot;xsltFormatNumberConversion : &quot;
1268         &quot;error in format string &#39;%s&#39;, using default\n&quot;, format);
1269     default_sign = (number &lt; 0.0) ? 1 : 0;
1270     prefix_length = suffix_length = 0;
1271     format_info.integer_hash = 0;
1272     format_info.integer_digits = 1;
1273     format_info.frac_digits = 1;
1274     format_info.frac_hash = 4;
1275     format_info.group = -1;
1276     format_info.multiplier = 1;
1277     format_info.add_decimal = TRUE;
1278     }
1279 
1280     /* Ready to output our number.  First see if &quot;default sign&quot; is required */
1281     if (default_sign != 0)
1282     xmlBufferAdd(buffer, self-&gt;minusSign, xmlUTF8Strsize(self-&gt;minusSign, 1));
1283 
1284     /* Put the prefix into the buffer */
<span class="line-modified">1285     for (j = 0; j &lt; prefix_length; ) {</span>
<span class="line-modified">1286     if (*prefix == SYMBOL_QUOTE)</span>
<span class="line-added">1287             prefix++;</span>
1288         len = xmlUTF8Strsize(prefix, 1);
1289         xmlBufferAdd(buffer, prefix, len);
1290         prefix += len;
<span class="line-modified">1291         j += len;</span>


1292     }
1293 
1294     /* Next do the integer part of the number */
1295     number = fabs(number) * (double)format_info.multiplier;
1296     scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
1297     number = floor((scale * number + 0.5)) / scale;
1298     if ((self-&gt;grouping != NULL) &amp;&amp;
1299         (self-&gt;grouping[0] != 0)) {
<span class="line-added">1300         int gchar;</span>
1301 
1302     len = xmlStrlen(self-&gt;grouping);
<span class="line-modified">1303     gchar = xsltGetUTF8Char(self-&gt;grouping, &amp;len);</span>
1304     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1305                 format_info.integer_digits,
1306                 format_info.group,
<span class="line-modified">1307                 gchar, len);</span>
1308     } else
1309     xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1310                 format_info.integer_digits,
1311                 format_info.group,
1312                 &#39;,&#39;, 1);
1313 
1314     /* Special case: java treats &#39;.#&#39; like &#39;.0&#39;, &#39;.##&#39; like &#39;.0#&#39;, etc. */
1315     if ((format_info.integer_digits + format_info.integer_hash +
1316      format_info.frac_digits == 0) &amp;&amp; (format_info.frac_hash &gt; 0)) {
1317         ++format_info.frac_digits;
1318     --format_info.frac_hash;
1319     }
1320 
1321     /* Add leading zero, if required */
1322     if ((floor(number) == 0) &amp;&amp;
1323     (format_info.integer_digits + format_info.frac_digits == 0)) {
1324         xmlBufferAdd(buffer, self-&gt;zeroDigit, xmlUTF8Strsize(self-&gt;zeroDigit, 1));
1325     }
1326 
1327     /* Next the fractional part, if required */
</pre>
<hr />
<pre>
1330         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1331              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1332     }
1333     else {
1334       number -= floor(number);
1335     if ((number != 0) || (format_info.frac_digits != 0)) {
1336         xmlBufferAdd(buffer, self-&gt;decimalPoint,
1337              xmlUTF8Strsize(self-&gt;decimalPoint, 1));
1338         number = floor(scale * number + 0.5);
1339         for (j = format_info.frac_hash; j &gt; 0; j--) {
1340         if (fmod(number, 10.0) &gt;= 1.0)
1341             break; /* for */
1342         number /= 10.0;
1343         }
1344         xsltNumberFormatDecimal(buffer, floor(number), self-&gt;zeroDigit[0],
1345                 format_info.frac_digits + j,
1346                 0, 0, 0);
1347     }
1348     }
1349     /* Put the suffix into the buffer */
<span class="line-modified">1350     for (j = 0; j &lt; suffix_length; ) {</span>
<span class="line-modified">1351     if (*suffix == SYMBOL_QUOTE)</span>
<span class="line-modified">1352             suffix++;</span>
<span class="line-added">1353         len = xmlUTF8Strsize(suffix, 1);</span>
1354         xmlBufferAdd(buffer, suffix, len);
1355         suffix += len;
<span class="line-modified">1356         j += len;</span>


1357     }
1358 
1359     *result = xmlStrdup(xmlBufferContent(buffer));
1360     xmlBufferFree(buffer);
1361     return status;
1362 }
1363 
</pre>
</td>
</tr>
</table>
<center><a href="libxslt.syms.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>