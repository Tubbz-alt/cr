<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/pattern.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * pattern.c: Implemetation of the template match compilation and lookup
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  */
  11 
  12 /*
  13  * TODO: handle pathological cases like *[*[@a=&quot;b&quot;]]
  14  * TODO: detect [number] at compilation, optimize accordingly
  15  */
  16 
  17 #define IN_LIBXSLT
  18 #include &quot;libxslt.h&quot;
  19 
  20 #include &lt;string.h&gt;
  21 
  22 #include &lt;libxml/xmlmemory.h&gt;
  23 #include &lt;libxml/tree.h&gt;
  24 #include &lt;libxml/valid.h&gt;
  25 #include &lt;libxml/hash.h&gt;
  26 #include &lt;libxml/xmlerror.h&gt;
  27 #include &lt;libxml/parserInternals.h&gt;
  28 #include &lt;libxml/xpath.h&gt;
  29 #include &quot;xslt.h&quot;
  30 #include &quot;xsltInternals.h&quot;
  31 #include &quot;xsltutils.h&quot;
  32 #include &quot;imports.h&quot;
  33 #include &quot;templates.h&quot;
  34 #include &quot;keys.h&quot;
  35 #include &quot;pattern.h&quot;
  36 #include &quot;documents.h&quot;
  37 
  38 #ifdef WITH_XSLT_DEBUG
  39 #define WITH_XSLT_DEBUG_PATTERN
  40 #endif
  41 
  42 /*
  43  * Types are private:
  44  */
  45 
  46 typedef enum {
  47     XSLT_OP_END=0,
  48     XSLT_OP_ROOT,
  49     XSLT_OP_ELEM,
  50     XSLT_OP_ATTR,
  51     XSLT_OP_PARENT,
  52     XSLT_OP_ANCESTOR,
  53     XSLT_OP_ID,
  54     XSLT_OP_KEY,
  55     XSLT_OP_NS,
  56     XSLT_OP_ALL,
  57     XSLT_OP_PI,
  58     XSLT_OP_COMMENT,
  59     XSLT_OP_TEXT,
  60     XSLT_OP_NODE,
  61     XSLT_OP_PREDICATE
  62 } xsltOp;
  63 
  64 typedef enum {
  65     AXIS_CHILD=1,
  66     AXIS_ATTRIBUTE
  67 } xsltAxis;
  68 
  69 typedef struct _xsltStepState xsltStepState;
  70 typedef xsltStepState *xsltStepStatePtr;
  71 struct _xsltStepState {
  72     int step;
  73     xmlNodePtr node;
  74 };
  75 
  76 typedef struct _xsltStepStates xsltStepStates;
  77 typedef xsltStepStates *xsltStepStatesPtr;
  78 struct _xsltStepStates {
  79     int nbstates;
  80     int maxstates;
  81     xsltStepStatePtr states;
  82 };
  83 
  84 typedef struct _xsltStepOp xsltStepOp;
  85 typedef xsltStepOp *xsltStepOpPtr;
  86 struct _xsltStepOp {
  87     xsltOp op;
  88     xmlChar *value;
  89     xmlChar *value2;
  90     xmlChar *value3;
  91     xmlXPathCompExprPtr comp;
  92     /*
  93      * Optimisations for count
  94      */
  95     int        previousExtra;
  96     int        indexExtra;
  97     int        lenExtra;
  98 };
  99 
 100 struct _xsltCompMatch {
 101     struct _xsltCompMatch *next; /* siblings in the name hash */
 102     float priority;              /* the priority */
 103     const xmlChar *pattern;       /* the pattern */
 104     const xmlChar *mode;         /* the mode */
 105     const xmlChar *modeURI;      /* the mode URI */
 106     xsltTemplatePtr template;    /* the associated template */
 107     xmlNodePtr node;             /* the containing element */
 108 
 109     int direct;
 110     /* TODO fix the statically allocated size steps[] */
 111     int nbStep;
 112     int maxStep;
 113     xmlNsPtr *nsList;       /* the namespaces in scope */
 114     int nsNr;           /* the number of namespaces in scope */
 115     xsltStepOpPtr steps;        /* ops for computation */
 116     int novar;                  /* doesn&#39;t contain variables */
 117 };
 118 
 119 typedef struct _xsltParserContext xsltParserContext;
 120 typedef xsltParserContext *xsltParserContextPtr;
 121 struct _xsltParserContext {
 122     xsltStylesheetPtr style;        /* the stylesheet */
 123     xsltTransformContextPtr ctxt;   /* the transformation or NULL */
 124     const xmlChar *cur;         /* the current char being parsed */
 125     const xmlChar *base;        /* the full expression */
 126     xmlDocPtr      doc;         /* the source document */
 127     xmlNodePtr    elem;         /* the source element */
 128     int error;              /* error code */
 129     xsltCompMatchPtr comp;      /* the result */
 130 };
 131 
 132 /************************************************************************
 133  *                                  *
 134  *          Type functions                  *
 135  *                                  *
 136  ************************************************************************/
 137 
 138 /**
 139  * xsltNewCompMatch:
 140  *
 141  * Create a new XSLT CompMatch
 142  *
 143  * Returns the newly allocated xsltCompMatchPtr or NULL in case of error
 144  */
 145 static xsltCompMatchPtr
 146 xsltNewCompMatch(void) {
 147     xsltCompMatchPtr cur;
 148 
 149     cur = (xsltCompMatchPtr) xmlMalloc(sizeof(xsltCompMatch));
 150     if (cur == NULL) {
 151     xsltTransformError(NULL, NULL, NULL,
 152         &quot;xsltNewCompMatch : out of memory error\n&quot;);
 153     return(NULL);
 154     }
 155     memset(cur, 0, sizeof(xsltCompMatch));
 156     cur-&gt;maxStep = 10;
 157     cur-&gt;nbStep = 0;
 158     cur-&gt; steps = (xsltStepOpPtr) xmlMalloc(sizeof(xsltStepOp) *
 159                                             cur-&gt;maxStep);
 160     if (cur-&gt;steps == NULL) {
 161     xsltTransformError(NULL, NULL, NULL,
 162         &quot;xsltNewCompMatch : out of memory error\n&quot;);
 163     xmlFree(cur);
 164     return(NULL);
 165     }
 166     cur-&gt;nsNr = 0;
 167     cur-&gt;nsList = NULL;
 168     cur-&gt;direct = 0;
 169     return(cur);
 170 }
 171 
 172 /**
 173  * xsltFreeCompMatch:
 174  * @comp:  an XSLT comp
 175  *
 176  * Free up the memory allocated by @comp
 177  */
 178 static void
 179 xsltFreeCompMatch(xsltCompMatchPtr comp) {
 180     xsltStepOpPtr op;
 181     int i;
 182 
 183     if (comp == NULL)
 184     return;
 185     if (comp-&gt;pattern != NULL)
 186     xmlFree((xmlChar *)comp-&gt;pattern);
 187     if (comp-&gt;nsList != NULL)
 188     xmlFree(comp-&gt;nsList);
 189     for (i = 0;i &lt; comp-&gt;nbStep;i++) {
 190     op = &amp;comp-&gt;steps[i];
 191     if (op-&gt;value != NULL)
 192         xmlFree(op-&gt;value);
 193     if (op-&gt;value2 != NULL)
 194         xmlFree(op-&gt;value2);
 195     if (op-&gt;value3 != NULL)
 196         xmlFree(op-&gt;value3);
 197     if (op-&gt;comp != NULL)
 198         xmlXPathFreeCompExpr(op-&gt;comp);
 199     }
 200     xmlFree(comp-&gt;steps);
 201     memset(comp, -1, sizeof(xsltCompMatch));
 202     xmlFree(comp);
 203 }
 204 
 205 /**
 206  * xsltFreeCompMatchList:
 207  * @comp:  an XSLT comp list
 208  *
 209  * Free up the memory allocated by all the elements of @comp
 210  */
 211 void
 212 xsltFreeCompMatchList(xsltCompMatchPtr comp) {
 213     xsltCompMatchPtr cur;
 214 
 215     while (comp != NULL) {
 216     cur = comp;
 217     comp = comp-&gt;next;
 218     xsltFreeCompMatch(cur);
 219     }
 220 }
 221 
 222 static void
 223 xsltFreeCompMatchListEntry(void *payload,
 224                            const xmlChar *name ATTRIBUTE_UNUSED) {
 225     xsltFreeCompMatchList((xsltCompMatchPtr) payload);
 226 }
 227 
 228 /**
 229  * xsltNormalizeCompSteps:
 230  * @payload: pointer to template hash table entry
 231  * @data: pointer to the stylesheet
 232  * @name: template match name
 233  *
 234  * This is a hashtable scanner function to normalize the compiled
 235  * steps of an imported stylesheet.
 236  */
 237 void xsltNormalizeCompSteps(void *payload,
 238         void *data, const xmlChar *name ATTRIBUTE_UNUSED) {
 239     xsltCompMatchPtr comp = payload;
 240     xsltStylesheetPtr style = data;
 241     int ix;
 242 
 243     for (ix = 0; ix &lt; comp-&gt;nbStep; ix++) {
 244         comp-&gt;steps[ix].previousExtra += style-&gt;extrasNr;
 245         comp-&gt;steps[ix].indexExtra += style-&gt;extrasNr;
 246         comp-&gt;steps[ix].lenExtra += style-&gt;extrasNr;
 247     }
 248 }
 249 
 250 /**
 251  * xsltNewParserContext:
 252  * @style:  the stylesheet
 253  * @ctxt:  the transformation context, if done at run-time
 254  *
 255  * Create a new XSLT ParserContext
 256  *
 257  * Returns the newly allocated xsltParserContextPtr or NULL in case of error
 258  */
 259 static xsltParserContextPtr
 260 xsltNewParserContext(xsltStylesheetPtr style, xsltTransformContextPtr ctxt) {
 261     xsltParserContextPtr cur;
 262 
 263     cur = (xsltParserContextPtr) xmlMalloc(sizeof(xsltParserContext));
 264     if (cur == NULL) {
 265     xsltTransformError(NULL, NULL, NULL,
 266         &quot;xsltNewParserContext : malloc failed\n&quot;);
 267     return(NULL);
 268     }
 269     memset(cur, 0, sizeof(xsltParserContext));
 270     cur-&gt;style = style;
 271     cur-&gt;ctxt = ctxt;
 272     return(cur);
 273 }
 274 
 275 /**
 276  * xsltFreeParserContext:
 277  * @ctxt:  an XSLT parser context
 278  *
 279  * Free up the memory allocated by @ctxt
 280  */
 281 static void
 282 xsltFreeParserContext(xsltParserContextPtr ctxt) {
 283     if (ctxt == NULL)
 284     return;
 285     memset(ctxt, -1, sizeof(xsltParserContext));
 286     xmlFree(ctxt);
 287 }
 288 
 289 /**
 290  * xsltCompMatchAdd:
 291  * @comp:  the compiled match expression
 292  * @op:  an op
 293  * @value:  the first value
 294  * @value2:  the second value
 295  * @novar:  flag to set XML_XPATH_NOVAR
 296  *
 297  * Add an step to an XSLT Compiled Match
 298  *
 299  * Returns -1 in case of failure, 0 otherwise.
 300  */
 301 static int
 302 xsltCompMatchAdd(xsltParserContextPtr ctxt, xsltCompMatchPtr comp,
 303                  xsltOp op, xmlChar * value, xmlChar * value2, int novar)
 304 {
 305     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
 306         xsltStepOpPtr tmp;
 307 
 308     tmp = (xsltStepOpPtr) xmlRealloc(comp-&gt;steps, comp-&gt;maxStep * 2 *
 309                                      sizeof(xsltStepOp));
 310     if (tmp == NULL) {
 311         xsltGenericError(xsltGenericErrorContext,
 312          &quot;xsltCompMatchAdd: memory re-allocation failure.\n&quot;);
 313         if (ctxt-&gt;style != NULL)
 314         ctxt-&gt;style-&gt;errors++;
 315         if (value)
 316             xmlFree(value);
 317         if (value2)
 318             xmlFree(value2);
 319         return (-1);
 320     }
 321         comp-&gt;maxStep *= 2;
 322     comp-&gt;steps = tmp;
 323     }
 324     comp-&gt;steps[comp-&gt;nbStep].op = op;
 325     comp-&gt;steps[comp-&gt;nbStep].value = value;
 326     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 327     comp-&gt;steps[comp-&gt;nbStep].value3 = NULL;
 328     comp-&gt;steps[comp-&gt;nbStep].comp = NULL;
 329     if (ctxt-&gt;ctxt != NULL) {
 330     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 331         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 332     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 333         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 334     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 335         xsltAllocateExtraCtxt(ctxt-&gt;ctxt);
 336     } else {
 337     comp-&gt;steps[comp-&gt;nbStep].previousExtra =
 338         xsltAllocateExtra(ctxt-&gt;style);
 339     comp-&gt;steps[comp-&gt;nbStep].indexExtra =
 340         xsltAllocateExtra(ctxt-&gt;style);
 341     comp-&gt;steps[comp-&gt;nbStep].lenExtra =
 342         xsltAllocateExtra(ctxt-&gt;style);
 343     }
 344     if (op == XSLT_OP_PREDICATE) {
 345     xmlXPathContextPtr xctxt;
 346 
 347     if (ctxt-&gt;style != NULL)
 348         xctxt = xmlXPathNewContext(ctxt-&gt;style-&gt;doc);
 349     else
 350         xctxt = xmlXPathNewContext(NULL);
 351 #ifdef XML_XPATH_NOVAR
 352     if (novar != 0)
 353         xctxt-&gt;flags = XML_XPATH_NOVAR;
 354 #endif
 355     if (ctxt-&gt;style != NULL)
 356         xctxt-&gt;dict = ctxt-&gt;style-&gt;dict;
 357     comp-&gt;steps[comp-&gt;nbStep].comp = xmlXPathCtxtCompile(xctxt, value);
 358     xmlXPathFreeContext(xctxt);
 359     if (comp-&gt;steps[comp-&gt;nbStep].comp == NULL) {
 360         xsltTransformError(NULL, ctxt-&gt;style, ctxt-&gt;elem,
 361             &quot;Failed to compile predicate\n&quot;);
 362         if (ctxt-&gt;style != NULL)
 363         ctxt-&gt;style-&gt;errors++;
 364     }
 365     }
 366     comp-&gt;nbStep++;
 367     return (0);
 368 }
 369 
 370 /**
 371  * xsltSwapTopCompMatch:
 372  * @comp:  the compiled match expression
 373  *
 374  * reverse the two top steps.
 375  */
 376 static void
 377 xsltSwapTopCompMatch(xsltCompMatchPtr comp) {
 378     int i;
 379     int j = comp-&gt;nbStep - 1;
 380 
 381     if (j &gt; 0) {
 382     register xmlChar *tmp;
 383     register xsltOp op;
 384     register xmlXPathCompExprPtr expr;
 385     register int t;
 386     i = j - 1;
 387     tmp = comp-&gt;steps[i].value;
 388     comp-&gt;steps[i].value = comp-&gt;steps[j].value;
 389     comp-&gt;steps[j].value = tmp;
 390     tmp = comp-&gt;steps[i].value2;
 391     comp-&gt;steps[i].value2 = comp-&gt;steps[j].value2;
 392     comp-&gt;steps[j].value2 = tmp;
 393     tmp = comp-&gt;steps[i].value3;
 394     comp-&gt;steps[i].value3 = comp-&gt;steps[j].value3;
 395     comp-&gt;steps[j].value3 = tmp;
 396     op = comp-&gt;steps[i].op;
 397     comp-&gt;steps[i].op = comp-&gt;steps[j].op;
 398     comp-&gt;steps[j].op = op;
 399     expr = comp-&gt;steps[i].comp;
 400     comp-&gt;steps[i].comp = comp-&gt;steps[j].comp;
 401     comp-&gt;steps[j].comp = expr;
 402     t = comp-&gt;steps[i].previousExtra;
 403     comp-&gt;steps[i].previousExtra = comp-&gt;steps[j].previousExtra;
 404     comp-&gt;steps[j].previousExtra = t;
 405     t = comp-&gt;steps[i].indexExtra;
 406     comp-&gt;steps[i].indexExtra = comp-&gt;steps[j].indexExtra;
 407     comp-&gt;steps[j].indexExtra = t;
 408     t = comp-&gt;steps[i].lenExtra;
 409     comp-&gt;steps[i].lenExtra = comp-&gt;steps[j].lenExtra;
 410     comp-&gt;steps[j].lenExtra = t;
 411     }
 412 }
 413 
 414 /**
 415  * xsltReverseCompMatch:
 416  * @ctxt: the parser context
 417  * @comp:  the compiled match expression
 418  *
 419  * reverse all the stack of expressions
 420  */
 421 static void
 422 xsltReverseCompMatch(xsltParserContextPtr ctxt, xsltCompMatchPtr comp) {
 423     int i = 0;
 424     int j = comp-&gt;nbStep - 1;
 425 
 426     while (j &gt; i) {
 427     register xmlChar *tmp;
 428     register xsltOp op;
 429     register xmlXPathCompExprPtr expr;
 430     register int t;
 431 
 432     tmp = comp-&gt;steps[i].value;
 433     comp-&gt;steps[i].value = comp-&gt;steps[j].value;
 434     comp-&gt;steps[j].value = tmp;
 435     tmp = comp-&gt;steps[i].value2;
 436     comp-&gt;steps[i].value2 = comp-&gt;steps[j].value2;
 437     comp-&gt;steps[j].value2 = tmp;
 438     tmp = comp-&gt;steps[i].value3;
 439     comp-&gt;steps[i].value3 = comp-&gt;steps[j].value3;
 440     comp-&gt;steps[j].value3 = tmp;
 441     op = comp-&gt;steps[i].op;
 442     comp-&gt;steps[i].op = comp-&gt;steps[j].op;
 443     comp-&gt;steps[j].op = op;
 444     expr = comp-&gt;steps[i].comp;
 445     comp-&gt;steps[i].comp = comp-&gt;steps[j].comp;
 446     comp-&gt;steps[j].comp = expr;
 447     t = comp-&gt;steps[i].previousExtra;
 448     comp-&gt;steps[i].previousExtra = comp-&gt;steps[j].previousExtra;
 449     comp-&gt;steps[j].previousExtra = t;
 450     t = comp-&gt;steps[i].indexExtra;
 451     comp-&gt;steps[i].indexExtra = comp-&gt;steps[j].indexExtra;
 452     comp-&gt;steps[j].indexExtra = t;
 453     t = comp-&gt;steps[i].lenExtra;
 454     comp-&gt;steps[i].lenExtra = comp-&gt;steps[j].lenExtra;
 455     comp-&gt;steps[j].lenExtra = t;
 456     j--;
 457     i++;
 458     }
 459     xsltCompMatchAdd(ctxt, comp, XSLT_OP_END, NULL, NULL, 0);
 460 
 461     /*
 462      * Detect consecutive XSLT_OP_PREDICATE and predicates on ops which
 463      * haven&#39;t been optimized yet indicating a direct matching should be done.
 464      */
 465     for (i = 0;i &lt; comp-&gt;nbStep - 1;i++) {
 466         xsltOp op = comp-&gt;steps[i].op;
 467 
 468         if ((op != XSLT_OP_ELEM) &amp;&amp;
 469             (op != XSLT_OP_ALL) &amp;&amp;
 470         (comp-&gt;steps[i + 1].op == XSLT_OP_PREDICATE)) {
 471 
 472         comp-&gt;direct = 1;
 473         if (comp-&gt;pattern[0] != &#39;/&#39;) {
 474         xmlChar *query;
 475 
 476         query = xmlStrdup((const xmlChar *)&quot;//&quot;);
 477         query = xmlStrcat(query, comp-&gt;pattern);
 478 
 479         xmlFree((xmlChar *) comp-&gt;pattern);
 480         comp-&gt;pattern = query;
 481         }
 482         break;
 483     }
 484     }
 485 }
 486 
 487 /************************************************************************
 488  *                                  *
 489  *      The interpreter for the precompiled patterns        *
 490  *                                  *
 491  ************************************************************************/
 492 
 493 static int
 494 xsltPatPushState(xsltTransformContextPtr ctxt, xsltStepStates *states,
 495                  int step, xmlNodePtr node) {
 496     if ((states-&gt;states == NULL) || (states-&gt;maxstates &lt;= 0)) {
 497         states-&gt;maxstates = 4;
 498     states-&gt;nbstates = 0;
 499     states-&gt;states = xmlMalloc(4 * sizeof(xsltStepState));
 500     }
 501     else if (states-&gt;maxstates &lt;= states-&gt;nbstates) {
 502         xsltStepState *tmp;
 503 
 504     tmp = (xsltStepStatePtr) xmlRealloc(states-&gt;states,
 505                    2 * states-&gt;maxstates * sizeof(xsltStepState));
 506     if (tmp == NULL) {
 507         xsltGenericError(xsltGenericErrorContext,
 508          &quot;xsltPatPushState: memory re-allocation failure.\n&quot;);
 509         ctxt-&gt;state = XSLT_STATE_STOPPED;
 510         return(-1);
 511     }
 512     states-&gt;states = tmp;
 513     states-&gt;maxstates *= 2;
 514     }
 515     states-&gt;states[states-&gt;nbstates].step = step;
 516     states-&gt;states[states-&gt;nbstates++].node = node;
 517 #if 0
 518     fprintf(stderr, &quot;Push: %d, %s\n&quot;, step, node-&gt;name);
 519 #endif
 520     return(0);
 521 }
 522 
 523 static void
 524 xmlXPathFreeObjectWrapper(void *obj) {
 525     xmlXPathFreeObject((xmlXPathObjectPtr) obj);
 526 }
 527 
 528 /**
 529  * xsltTestCompMatchDirect:
 530  * @ctxt:  a XSLT process context
 531  * @comp: the precompiled pattern
 532  * @node: a node
 533  * @nsList: the namespaces in scope
 534  * @nsNr: the number of namespaces in scope
 535  *
 536  * Test whether the node matches the pattern, do a direct evalutation
 537  * and not a step by step evaluation.
 538  *
 539  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
 540  */
 541 static int
 542 xsltTestCompMatchDirect(xsltTransformContextPtr ctxt, xsltCompMatchPtr comp,
 543                     xmlNodePtr node, xmlNsPtr *nsList, int nsNr) {
 544     xsltStepOpPtr sel = NULL;
 545     xmlDocPtr prevdoc;
 546     xmlDocPtr doc;
 547     xmlXPathObjectPtr list;
 548     int ix, j;
 549     int nocache = 0;
 550     int isRVT;
 551 
 552     doc = node-&gt;doc;
 553     if (XSLT_IS_RES_TREE_FRAG(doc))
 554     isRVT = 1;
 555     else
 556     isRVT = 0;
 557     sel = &amp;comp-&gt;steps[0]; /* store extra in first step arbitrarily */
 558 
 559     prevdoc = (xmlDocPtr)
 560     XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr);
 561     ix = XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival);
 562     list = (xmlXPathObjectPtr)
 563     XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra);
 564 
 565     if ((list == NULL) || (prevdoc != doc)) {
 566     xmlXPathObjectPtr newlist;
 567     xmlNodePtr parent = node-&gt;parent;
 568     xmlDocPtr olddoc;
 569     xmlNodePtr oldnode;
 570     int oldNsNr, oldContextSize, oldProximityPosition;
 571     xmlNsPtr *oldNamespaces;
 572 
 573     oldnode = ctxt-&gt;xpathCtxt-&gt;node;
 574     olddoc = ctxt-&gt;xpathCtxt-&gt;doc;
 575     oldNsNr = ctxt-&gt;xpathCtxt-&gt;nsNr;
 576     oldNamespaces = ctxt-&gt;xpathCtxt-&gt;namespaces;
 577     oldContextSize = ctxt-&gt;xpathCtxt-&gt;contextSize;
 578     oldProximityPosition = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
 579     ctxt-&gt;xpathCtxt-&gt;node = node;
 580     ctxt-&gt;xpathCtxt-&gt;doc = doc;
 581     ctxt-&gt;xpathCtxt-&gt;namespaces = nsList;
 582     ctxt-&gt;xpathCtxt-&gt;nsNr = nsNr;
 583     newlist = xmlXPathEval(comp-&gt;pattern, ctxt-&gt;xpathCtxt);
 584     ctxt-&gt;xpathCtxt-&gt;node = oldnode;
 585     ctxt-&gt;xpathCtxt-&gt;doc = olddoc;
 586     ctxt-&gt;xpathCtxt-&gt;namespaces = oldNamespaces;
 587     ctxt-&gt;xpathCtxt-&gt;nsNr = oldNsNr;
 588     ctxt-&gt;xpathCtxt-&gt;contextSize = oldContextSize;
 589     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldProximityPosition;
 590     if (newlist == NULL)
 591         return(-1);
 592     if (newlist-&gt;type != XPATH_NODESET) {
 593         xmlXPathFreeObject(newlist);
 594         return(-1);
 595     }
 596     ix = 0;
 597 
 598     if ((parent == NULL) || (node-&gt;doc == NULL) || isRVT ||
 599             (comp-&gt;novar == 0))
 600         nocache = 1;
 601 
 602     if (nocache == 0) {
 603         if (list != NULL)
 604         xmlXPathFreeObject(list);
 605         list = newlist;
 606 
 607         XSLT_RUNTIME_EXTRA_LST(ctxt, sel-&gt;lenExtra) =
 608         (void *) list;
 609         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) =
 610         (void *) doc;
 611         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) =
 612         0;
 613         XSLT_RUNTIME_EXTRA_FREE(ctxt, sel-&gt;lenExtra) =
 614         xmlXPathFreeObjectWrapper;
 615     } else
 616         list = newlist;
 617     }
 618     if ((list-&gt;nodesetval == NULL) ||
 619     (list-&gt;nodesetval-&gt;nodeNr &lt;= 0)) {
 620     if (nocache == 1)
 621         xmlXPathFreeObject(list);
 622     return(0);
 623     }
 624     /* TODO: store the index and use it for the scan */
 625     if (ix == 0) {
 626     for (j = 0;j &lt; list-&gt;nodesetval-&gt;nodeNr;j++) {
 627         if (list-&gt;nodesetval-&gt;nodeTab[j] == node) {
 628         if (nocache == 1)
 629             xmlXPathFreeObject(list);
 630         return(1);
 631         }
 632     }
 633     } else {
 634     }
 635     if (nocache == 1)
 636     xmlXPathFreeObject(list);
 637     return(0);
 638 }
 639 
 640 /**
 641  * xsltTestPredicateMatch:
 642  * @ctxt: a XSLT process context
 643  * @comp: the precompiled pattern
 644  * @node: a node
 645  * @step: the predicate step
 646  * @sel:  the previous step
 647  *
 648  * Test whether the node matches the predicate
 649  *
 650  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
 651  */
 652 static int
 653 xsltTestPredicateMatch(xsltTransformContextPtr ctxt, xsltCompMatchPtr comp,
 654                        xmlNodePtr node, xsltStepOpPtr step,
 655                        xsltStepOpPtr sel) {
 656     xmlNodePtr oldNode;
 657     xmlDocPtr doc;
 658     int oldCS, oldCP;
 659     int pos = 0, len = 0;
 660     int isRVT;
 661     int match;
 662 
 663     if (step-&gt;value == NULL)
 664         return(0);
 665     if (step-&gt;comp == NULL)
 666         return(0);
 667 
 668     doc = node-&gt;doc;
 669     if (XSLT_IS_RES_TREE_FRAG(doc))
 670         isRVT = 1;
 671     else
 672         isRVT = 0;
 673 
 674     /*
 675      * Recompute contextSize and proximityPosition.
 676      *
 677      * TODO: Make this work for additional ops. Currently, only XSLT_OP_ELEM
 678      * and XSLT_OP_ALL are supported.
 679      */
 680     oldCS = ctxt-&gt;xpathCtxt-&gt;contextSize;
 681     oldCP = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
 682     if ((sel != NULL) &amp;&amp;
 683         (sel-&gt;op == XSLT_OP_ELEM) &amp;&amp;
 684         (sel-&gt;value != NULL) &amp;&amp;
 685         (node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 686         (node-&gt;parent != NULL)) {
 687         xmlNodePtr previous;
 688         int nocache = 0;
 689 
 690         previous = (xmlNodePtr)
 691             XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr);
 692         if ((previous != NULL) &amp;&amp;
 693             (previous-&gt;parent == node-&gt;parent)) {
 694             /*
 695              * just walk back to adjust the index
 696              */
 697             int indx = 0;
 698             xmlNodePtr sibling = node;
 699 
 700             while (sibling != NULL) {
 701                 if (sibling == previous)
 702                     break;
 703                 if ((sibling-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 704                     (previous-&gt;name != NULL) &amp;&amp;
 705                     (sibling-&gt;name != NULL) &amp;&amp;
 706                     (previous-&gt;name[0] == sibling-&gt;name[0]) &amp;&amp;
 707                     (xmlStrEqual(previous-&gt;name, sibling-&gt;name)))
 708                 {
 709                     if ((sel-&gt;value2 == NULL) ||
 710                         ((sibling-&gt;ns != NULL) &amp;&amp;
 711                          (xmlStrEqual(sel-&gt;value2, sibling-&gt;ns-&gt;href))))
 712                         indx++;
 713                 }
 714                 sibling = sibling-&gt;prev;
 715             }
 716             if (sibling == NULL) {
 717                 /* hum going backward in document order ... */
 718                 indx = 0;
 719                 sibling = node;
 720                 while (sibling != NULL) {
 721                     if (sibling == previous)
 722                         break;
 723                     if ((sibling-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 724                         (previous-&gt;name != NULL) &amp;&amp;
 725                         (sibling-&gt;name != NULL) &amp;&amp;
 726                         (previous-&gt;name[0] == sibling-&gt;name[0]) &amp;&amp;
 727                         (xmlStrEqual(previous-&gt;name, sibling-&gt;name)))
 728                     {
 729                         if ((sel-&gt;value2 == NULL) ||
 730                             ((sibling-&gt;ns != NULL) &amp;&amp;
 731                             (xmlStrEqual(sel-&gt;value2,
 732                             sibling-&gt;ns-&gt;href))))
 733                         {
 734                             indx--;
 735                         }
 736                     }
 737                     sibling = sibling-&gt;next;
 738                 }
 739             }
 740             if (sibling != NULL) {
 741                 pos = XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) + indx;
 742                 /*
 743                  * If the node is in a Value Tree we need to
 744                  * save len, but cannot cache the node!
 745                  * (bugs 153137 and 158840)
 746                  */
 747                 if (node-&gt;doc != NULL) {
 748                     len = XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;lenExtra, ival);
 749                     if (!isRVT) {
 750                         XSLT_RUNTIME_EXTRA(ctxt,
 751                             sel-&gt;previousExtra, ptr) = node;
 752                         XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) = pos;
 753                     }
 754                 }
 755             } else
 756                 pos = 0;
 757         } else {
 758             /*
 759              * recompute the index
 760              */
 761             xmlNodePtr parent = node-&gt;parent;
 762             xmlNodePtr siblings = NULL;
 763 
 764             if (parent) siblings = parent-&gt;children;
 765 
 766             while (siblings != NULL) {
 767                 if (siblings-&gt;type == XML_ELEMENT_NODE) {
 768                     if (siblings == node) {
 769                         len++;
 770                         pos = len;
 771                     } else if ((node-&gt;name != NULL) &amp;&amp;
 772                                (siblings-&gt;name != NULL) &amp;&amp;
 773                         (node-&gt;name[0] == siblings-&gt;name[0]) &amp;&amp;
 774                         (xmlStrEqual(node-&gt;name, siblings-&gt;name))) {
 775                         if ((sel-&gt;value2 == NULL) ||
 776                             ((siblings-&gt;ns != NULL) &amp;&amp;
 777                              (xmlStrEqual(sel-&gt;value2, siblings-&gt;ns-&gt;href))))
 778                             len++;
 779                     }
 780                 }
 781                 siblings = siblings-&gt;next;
 782             }
 783             if ((parent == NULL) || (node-&gt;doc == NULL))
 784                 nocache = 1;
 785             else {
 786                 while (parent-&gt;parent != NULL)
 787                     parent = parent-&gt;parent;
 788                 if (((parent-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
 789                      (parent-&gt;type != XML_HTML_DOCUMENT_NODE)) ||
 790                      (parent != (xmlNodePtr) node-&gt;doc))
 791                     nocache = 1;
 792             }
 793         }
 794         if (pos != 0) {
 795             ctxt-&gt;xpathCtxt-&gt;contextSize = len;
 796             ctxt-&gt;xpathCtxt-&gt;proximityPosition = pos;
 797             /*
 798              * If the node is in a Value Tree we cannot
 799              * cache it !
 800              */
 801             if ((!isRVT) &amp;&amp; (node-&gt;doc != NULL) &amp;&amp;
 802                 (nocache == 0)) {
 803                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) = node;
 804                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) = pos;
 805                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;lenExtra, ival) = len;
 806             }
 807         }
 808     } else if ((sel != NULL) &amp;&amp; (sel-&gt;op == XSLT_OP_ALL) &amp;&amp;
 809                (node-&gt;type == XML_ELEMENT_NODE)) {
 810         xmlNodePtr previous;
 811         int nocache = 0;
 812 
 813         previous = (xmlNodePtr)
 814             XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr);
 815         if ((previous != NULL) &amp;&amp;
 816             (previous-&gt;parent == node-&gt;parent)) {
 817             /*
 818              * just walk back to adjust the index
 819              */
 820             int indx = 0;
 821             xmlNodePtr sibling = node;
 822 
 823             while (sibling != NULL) {
 824                 if (sibling == previous)
 825                     break;
 826                 if (sibling-&gt;type == XML_ELEMENT_NODE)
 827                     indx++;
 828                 sibling = sibling-&gt;prev;
 829             }
 830             if (sibling == NULL) {
 831                 /* hum going backward in document order ... */
 832                 indx = 0;
 833                 sibling = node;
 834                 while (sibling != NULL) {
 835                     if (sibling == previous)
 836                         break;
 837                     if (sibling-&gt;type == XML_ELEMENT_NODE)
 838                         indx--;
 839                     sibling = sibling-&gt;next;
 840                 }
 841             }
 842             if (sibling != NULL) {
 843                 pos = XSLT_RUNTIME_EXTRA(ctxt,
 844                     sel-&gt;indexExtra, ival) + indx;
 845                 /*
 846                  * If the node is in a Value Tree we cannot
 847                  * cache it !
 848                  */
 849                 if ((node-&gt;doc != NULL) &amp;&amp; !isRVT) {
 850                     len = XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;lenExtra, ival);
 851                     XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) = node;
 852                     XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) = pos;
 853                 }
 854             } else
 855                 pos = 0;
 856         } else {
 857             /*
 858              * recompute the index
 859              */
 860             xmlNodePtr parent = node-&gt;parent;
 861             xmlNodePtr siblings = NULL;
 862 
 863             if (parent) siblings = parent-&gt;children;
 864 
 865             while (siblings != NULL) {
 866                 if (siblings-&gt;type == XML_ELEMENT_NODE) {
 867                     len++;
 868                     if (siblings == node) {
 869                         pos = len;
 870                     }
 871                 }
 872                 siblings = siblings-&gt;next;
 873             }
 874             if ((parent == NULL) || (node-&gt;doc == NULL))
 875                 nocache = 1;
 876             else {
 877                 while (parent-&gt;parent != NULL)
 878                     parent = parent-&gt;parent;
 879                 if (((parent-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
 880                      (parent-&gt;type != XML_HTML_DOCUMENT_NODE)) ||
 881                      (parent != (xmlNodePtr) node-&gt;doc))
 882                     nocache = 1;
 883             }
 884         }
 885         if (pos != 0) {
 886             ctxt-&gt;xpathCtxt-&gt;contextSize = len;
 887             ctxt-&gt;xpathCtxt-&gt;proximityPosition = pos;
 888             /*
 889              * If the node is in a Value Tree we cannot
 890              * cache it !
 891              */
 892             if ((node-&gt;doc != NULL) &amp;&amp; (nocache == 0) &amp;&amp; !isRVT) {
 893                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;previousExtra, ptr) = node;
 894                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;indexExtra, ival) = pos;
 895                 XSLT_RUNTIME_EXTRA(ctxt, sel-&gt;lenExtra, ival) = len;
 896             }
 897         }
 898     }
 899 
 900     oldNode = ctxt-&gt;node;
 901     ctxt-&gt;node = node;
 902 
 903     match = xsltEvalXPathPredicate(ctxt, step-&gt;comp, comp-&gt;nsList, comp-&gt;nsNr);
 904 
 905     if (pos != 0) {
 906         ctxt-&gt;xpathCtxt-&gt;contextSize = oldCS;
 907         ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldCP;
 908     }
 909     ctxt-&gt;node = oldNode;
 910 
 911     return match;
 912 }
 913 
 914 /**
 915  * xsltTestCompMatch:
 916  * @ctxt:  a XSLT process context
 917  * @comp: the precompiled pattern
 918  * @node: a node
 919  * @mode:  the mode name or NULL
 920  * @modeURI:  the mode URI or NULL
 921  *
 922  * Test whether the node matches the pattern
 923  *
 924  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
 925  */
 926 static int
 927 xsltTestCompMatch(xsltTransformContextPtr ctxt, xsltCompMatchPtr comp,
 928               xmlNodePtr matchNode, const xmlChar *mode,
 929           const xmlChar *modeURI) {
 930     int i;
 931     int found = 0;
 932     xmlNodePtr node = matchNode;
 933     xmlNodePtr oldInst;
 934     xsltStepOpPtr step, sel = NULL;
 935     xsltStepStates states = {0, 0, NULL}; /* // may require backtrack */
 936 
 937     if ((comp == NULL) || (node == NULL) || (ctxt == NULL)) {
 938     xsltTransformError(ctxt, NULL, node,
 939         &quot;xsltTestCompMatch: null arg\n&quot;);
 940         return(-1);
 941     }
 942     if (mode != NULL) {
 943     if (comp-&gt;mode == NULL)
 944         return(0);
 945     /*
 946      * both mode strings must be interned on the stylesheet dictionary
 947      */
 948     if (comp-&gt;mode != mode)
 949         return(0);
 950     } else {
 951     if (comp-&gt;mode != NULL)
 952         return(0);
 953     }
 954     if (modeURI != NULL) {
 955     if (comp-&gt;modeURI == NULL)
 956         return(0);
 957     /*
 958      * both modeURI strings must be interned on the stylesheet dictionary
 959      */
 960     if (comp-&gt;modeURI != modeURI)
 961         return(0);
 962     } else {
 963     if (comp-&gt;modeURI != NULL)
 964         return(0);
 965     }
 966 
 967     /* Some XPath functions rely on inst being set correctly. */
 968     oldInst = ctxt-&gt;inst;
 969     ctxt-&gt;inst = comp-&gt;node;
 970 
 971     i = 0;
 972 restart:
 973     for (;i &lt; comp-&gt;nbStep;i++) {
 974     step = &amp;comp-&gt;steps[i];
 975     if (step-&gt;op != XSLT_OP_PREDICATE)
 976         sel = step;
 977     switch (step-&gt;op) {
 978             case XSLT_OP_END:
 979         goto found;
 980             case XSLT_OP_ROOT:
 981         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 982 #ifdef LIBXML_DOCB_ENABLED
 983             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 984 #endif
 985             (node-&gt;type == XML_HTML_DOCUMENT_NODE))
 986             continue;
 987         if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp; (node-&gt;name[0] == &#39; &#39;))
 988             continue;
 989         goto rollback;
 990             case XSLT_OP_ELEM:
 991         if (node-&gt;type != XML_ELEMENT_NODE)
 992             goto rollback;
 993         if (step-&gt;value == NULL)
 994             continue;
 995         if (step-&gt;value[0] != node-&gt;name[0])
 996             goto rollback;
 997         if (!xmlStrEqual(step-&gt;value, node-&gt;name))
 998             goto rollback;
 999 
1000         /* Namespace test */
1001         if (node-&gt;ns == NULL) {
1002             if (step-&gt;value2 != NULL)
1003             goto rollback;
1004         } else if (node-&gt;ns-&gt;href != NULL) {
1005             if (step-&gt;value2 == NULL)
1006             goto rollback;
1007             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
1008             goto rollback;
1009         }
1010         continue;
1011             case XSLT_OP_ATTR:
1012         if (node-&gt;type != XML_ATTRIBUTE_NODE)
1013             goto rollback;
1014         if (step-&gt;value != NULL) {
1015             if (step-&gt;value[0] != node-&gt;name[0])
1016             goto rollback;
1017             if (!xmlStrEqual(step-&gt;value, node-&gt;name))
1018             goto rollback;
1019         }
1020         /* Namespace test */
1021         if (node-&gt;ns == NULL) {
1022             if (step-&gt;value2 != NULL)
1023             goto rollback;
1024         } else if (step-&gt;value2 != NULL) {
1025             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
1026             goto rollback;
1027         }
1028         continue;
1029             case XSLT_OP_PARENT:
1030         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
1031             (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
1032 #ifdef LIBXML_DOCB_ENABLED
1033             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
1034 #endif
1035             (node-&gt;type == XML_NAMESPACE_DECL))
1036             goto rollback;
1037         node = node-&gt;parent;
1038         if (node == NULL)
1039             goto rollback;
1040         if (step-&gt;value == NULL)
1041             continue;
1042         if (step-&gt;value[0] != node-&gt;name[0])
1043             goto rollback;
1044         if (!xmlStrEqual(step-&gt;value, node-&gt;name))
1045             goto rollback;
1046         /* Namespace test */
1047         if (node-&gt;ns == NULL) {
1048             if (step-&gt;value2 != NULL)
1049             goto rollback;
1050         } else if (node-&gt;ns-&gt;href != NULL) {
1051             if (step-&gt;value2 == NULL)
1052             goto rollback;
1053             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
1054             goto rollback;
1055         }
1056         continue;
1057             case XSLT_OP_ANCESTOR:
1058         /* TODO: implement coalescing of ANCESTOR/NODE ops */
1059         if (step-&gt;value == NULL) {
1060             step = &amp;comp-&gt;steps[i+1];
1061             if (step-&gt;op == XSLT_OP_ROOT)
1062             goto found;
1063             /* added NS, ID and KEY as a result of bug 168208 */
1064             if ((step-&gt;op != XSLT_OP_ELEM) &amp;&amp;
1065             (step-&gt;op != XSLT_OP_ALL) &amp;&amp;
1066             (step-&gt;op != XSLT_OP_NS) &amp;&amp;
1067             (step-&gt;op != XSLT_OP_ID) &amp;&amp;
1068             (step-&gt;op != XSLT_OP_KEY))
1069             goto rollback;
1070         }
1071         if (node == NULL)
1072             goto rollback;
1073         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
1074             (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
1075 #ifdef LIBXML_DOCB_ENABLED
1076             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
1077 #endif
1078             (node-&gt;type == XML_NAMESPACE_DECL))
1079             goto rollback;
1080         node = node-&gt;parent;
1081         if ((step-&gt;op != XSLT_OP_ELEM) &amp;&amp; step-&gt;op != XSLT_OP_ALL) {
1082             xsltPatPushState(ctxt, &amp;states, i, node);
1083             continue;
1084         }
1085         i++;
1086         if (step-&gt;value == NULL) {
1087             xsltPatPushState(ctxt, &amp;states, i - 1, node);
1088             continue;
1089         }
1090         while (node != NULL) {
1091             if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1092             (step-&gt;value[0] == node-&gt;name[0]) &amp;&amp;
1093             (xmlStrEqual(step-&gt;value, node-&gt;name))) {
1094             /* Namespace test */
1095             if (node-&gt;ns == NULL) {
1096                 if (step-&gt;value2 == NULL)
1097                 break;
1098             } else if (node-&gt;ns-&gt;href != NULL) {
1099                 if ((step-&gt;value2 != NULL) &amp;&amp;
1100                     (xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href)))
1101                 break;
1102             }
1103             }
1104             node = node-&gt;parent;
1105         }
1106         if (node == NULL)
1107             goto rollback;
1108         xsltPatPushState(ctxt, &amp;states, i - 1, node);
1109         continue;
1110             case XSLT_OP_ID: {
1111         /* TODO Handle IDs decently, must be done differently */
1112         xmlAttrPtr id;
1113 
1114         if (node-&gt;type != XML_ELEMENT_NODE)
1115             goto rollback;
1116 
1117         id = xmlGetID(node-&gt;doc, step-&gt;value);
1118         if ((id == NULL) || (id-&gt;parent != node))
1119             goto rollback;
1120         break;
1121         }
1122             case XSLT_OP_KEY: {
1123         xmlNodeSetPtr list;
1124         int indx;
1125 
1126         list = xsltGetKey(ctxt, step-&gt;value,
1127                       step-&gt;value3, step-&gt;value2);
1128         if (list == NULL)
1129             goto rollback;
1130         for (indx = 0;indx &lt; list-&gt;nodeNr;indx++)
1131             if (list-&gt;nodeTab[indx] == node)
1132             break;
1133         if (indx &gt;= list-&gt;nodeNr)
1134             goto rollback;
1135         break;
1136         }
1137             case XSLT_OP_NS:
1138         if (node-&gt;type != XML_ELEMENT_NODE)
1139             goto rollback;
1140         if (node-&gt;ns == NULL) {
1141             if (step-&gt;value != NULL)
1142             goto rollback;
1143         } else if (node-&gt;ns-&gt;href != NULL) {
1144             if (step-&gt;value == NULL)
1145             goto rollback;
1146             if (!xmlStrEqual(step-&gt;value, node-&gt;ns-&gt;href))
1147             goto rollback;
1148         }
1149         break;
1150             case XSLT_OP_ALL:
1151         if (node-&gt;type != XML_ELEMENT_NODE)
1152             goto rollback;
1153         break;
1154         case XSLT_OP_PREDICATE: {
1155         /*
1156          * When there is cascading XSLT_OP_PREDICATE or a predicate
1157          * after an op which hasn&#39;t been optimized yet, then use a
1158          * direct computation approach. It&#39;s not done directly
1159          * at the beginning of the routine to filter out as much
1160          * as possible this costly computation.
1161          */
1162         if (comp-&gt;direct) {
1163             found = xsltTestCompMatchDirect(ctxt, comp, matchNode,
1164                             comp-&gt;nsList, comp-&gt;nsNr);
1165                     goto exit;
1166         }
1167 
1168         if (!xsltTestPredicateMatch(ctxt, comp, node, step, sel))
1169             goto rollback;
1170 
1171         break;
1172         }
1173             case XSLT_OP_PI:
1174         if (node-&gt;type != XML_PI_NODE)
1175             goto rollback;
1176         if (step-&gt;value != NULL) {
1177             if (!xmlStrEqual(step-&gt;value, node-&gt;name))
1178             goto rollback;
1179         }
1180         break;
1181             case XSLT_OP_COMMENT:
1182         if (node-&gt;type != XML_COMMENT_NODE)
1183             goto rollback;
1184         break;
1185             case XSLT_OP_TEXT:
1186         if ((node-&gt;type != XML_TEXT_NODE) &amp;&amp;
1187             (node-&gt;type != XML_CDATA_SECTION_NODE))
1188             goto rollback;
1189         break;
1190             case XSLT_OP_NODE:
1191         switch (node-&gt;type) {
1192             case XML_ELEMENT_NODE:
1193             case XML_CDATA_SECTION_NODE:
1194             case XML_PI_NODE:
1195             case XML_COMMENT_NODE:
1196             case XML_TEXT_NODE:
1197             break;
1198             default:
1199             goto rollback;
1200         }
1201         break;
1202     }
1203     }
1204 found:
1205     found = 1;
1206 exit:
1207     ctxt-&gt;inst = oldInst;
1208     if (states.states != NULL) {
1209         /* Free the rollback states */
1210     xmlFree(states.states);
1211     }
1212     return found;
1213 rollback:
1214     /* got an error try to rollback */
1215     if (states.states == NULL || states.nbstates &lt;= 0) {
1216         found = 0;
1217     goto exit;
1218     }
1219     states.nbstates--;
1220     i = states.states[states.nbstates].step;
1221     node = states.states[states.nbstates].node;
1222 #if 0
1223     fprintf(stderr, &quot;Pop: %d, %s\n&quot;, i, node-&gt;name);
1224 #endif
1225     goto restart;
1226 }
1227 
1228 /**
1229  * xsltTestCompMatchList:
1230  * @ctxt:  a XSLT process context
1231  * @node: a node
1232  * @comp: the precompiled pattern list
1233  *
1234  * Test whether the node matches one of the patterns in the list
1235  *
1236  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
1237  */
1238 int
1239 xsltTestCompMatchList(xsltTransformContextPtr ctxt, xmlNodePtr node,
1240                   xsltCompMatchPtr comp) {
1241     int ret;
1242 
1243     if ((ctxt == NULL) || (node == NULL))
1244     return(-1);
1245     while (comp != NULL) {
1246     ret = xsltTestCompMatch(ctxt, comp, node, NULL, NULL);
1247     if (ret == 1)
1248         return(1);
1249     comp = comp-&gt;next;
1250     }
1251     return(0);
1252 }
1253 
1254 /************************************************************************
1255  *                                  *
1256  *          Dedicated parser for templates          *
1257  *                                  *
1258  ************************************************************************/
1259 
1260 #define CUR (*ctxt-&gt;cur)
1261 #define SKIP(val) ctxt-&gt;cur += (val)
1262 #define NXT(val) ctxt-&gt;cur[(val)]
1263 #define CUR_PTR ctxt-&gt;cur
1264 
1265 #define SKIP_BLANKS                         \
1266     while (IS_BLANK_CH(CUR)) NEXT
1267 
1268 #define CURRENT (*ctxt-&gt;cur)
1269 #define NEXT ((*ctxt-&gt;cur) ?  ctxt-&gt;cur++: ctxt-&gt;cur)
1270 
1271 
1272 #define PUSH(op, val, val2, novar)                      \
1273     if (xsltCompMatchAdd(ctxt, ctxt-&gt;comp, (op), (val), (val2), (novar))) goto error;
1274 
1275 #define SWAP()                      \
1276     xsltSwapTopCompMatch(ctxt-&gt;comp);
1277 
1278 #define XSLT_ERROR(X)                           \
1279     { xsltError(ctxt, __FILE__, __LINE__, X);           \
1280       ctxt-&gt;error = (X); return; }
1281 
1282 #define XSLT_ERROR0(X)                          \
1283     { xsltError(ctxt, __FILE__, __LINE__, X);           \
1284       ctxt-&gt;error = (X); return(0); }
1285 
1286 /**
1287  * xsltScanLiteral:
1288  * @ctxt:  the XPath Parser context
1289  *
1290  * Parse an XPath Litteral:
1291  *
1292  * [29] Literal ::= &#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;
1293  *                | &quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;
1294  *
1295  * Returns the Literal parsed or NULL
1296  */
1297 
1298 static xmlChar *
1299 xsltScanLiteral(xsltParserContextPtr ctxt) {
1300     const xmlChar *q, *cur;
1301     xmlChar *ret = NULL;
1302     int val, len;
1303 
1304     SKIP_BLANKS;
1305     if (CUR == &#39;&quot;&#39;) {
1306         NEXT;
1307     cur = q = CUR_PTR;
1308     val = xmlStringCurrentChar(NULL, cur, &amp;len);
1309     while ((IS_CHAR(val)) &amp;&amp; (val != &#39;&quot;&#39;)) {
1310         cur += len;
1311         val = xmlStringCurrentChar(NULL, cur, &amp;len);
1312     }
1313     if (!IS_CHAR(val)) {
1314         ctxt-&gt;error = 1;
1315         return(NULL);
1316     } else {
1317         ret = xmlStrndup(q, cur - q);
1318         }
1319     cur += len;
1320     CUR_PTR = cur;
1321     } else if (CUR == &#39;\&#39;&#39;) {
1322         NEXT;
1323     cur = q = CUR_PTR;
1324     val = xmlStringCurrentChar(NULL, cur, &amp;len);
1325     while ((IS_CHAR(val)) &amp;&amp; (val != &#39;\&#39;&#39;)) {
1326         cur += len;
1327         val = xmlStringCurrentChar(NULL, cur, &amp;len);
1328     }
1329     if (!IS_CHAR(val)) {
1330         ctxt-&gt;error = 1;
1331         return(NULL);
1332     } else {
1333         ret = xmlStrndup(q, cur - q);
1334         }
1335     cur += len;
1336     CUR_PTR = cur;
1337     } else {
1338     /* XP_ERROR(XPATH_START_LITERAL_ERROR); */
1339     ctxt-&gt;error = 1;
1340     return(NULL);
1341     }
1342     return(ret);
1343 }
1344 
1345 /**
1346  * xsltScanNCName:
1347  * @ctxt:  the XPath Parser context
1348  *
1349  * Parses a non qualified name
1350  *
1351  * Returns the Name parsed or NULL
1352  */
1353 
1354 static xmlChar *
1355 xsltScanNCName(xsltParserContextPtr ctxt) {
1356     const xmlChar *q, *cur;
1357     xmlChar *ret = NULL;
1358     int val, len;
1359 
1360     SKIP_BLANKS;
1361 
1362     cur = q = CUR_PTR;
1363     val = xmlStringCurrentChar(NULL, cur, &amp;len);
1364     if (!IS_LETTER(val) &amp;&amp; (val != &#39;_&#39;))
1365     return(NULL);
1366 
1367     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
1368            (val == &#39;.&#39;) || (val == &#39;-&#39;) ||
1369        (val == &#39;_&#39;) ||
1370        (IS_COMBINING(val)) ||
1371        (IS_EXTENDER(val))) {
1372     cur += len;
1373     val = xmlStringCurrentChar(NULL, cur, &amp;len);
1374     }
1375     ret = xmlStrndup(q, cur - q);
1376     CUR_PTR = cur;
1377     return(ret);
1378 }
1379 
1380 /*
1381  * xsltCompileIdKeyPattern:
1382  * @ctxt:  the compilation context
1383  * @name:  a preparsed name
1384  * @aid:  whether id/key are allowed there
1385  * @novar:  flag to prohibit xslt var
1386  *
1387  * Compile the XSLT LocationIdKeyPattern
1388  * [3] IdKeyPattern ::= &#39;id&#39; &#39;(&#39; Literal &#39;)&#39;
1389  *                    | &#39;key&#39; &#39;(&#39; Literal &#39;,&#39; Literal &#39;)&#39;
1390  *
1391  * also handle NodeType and PI from:
1392  *
1393  * [7]  NodeTest ::= NameTest
1394  *                 | NodeType &#39;(&#39; &#39;)&#39;
1395  *                 | &#39;processing-instruction&#39; &#39;(&#39; Literal &#39;)&#39;
1396  */
1397 static void
1398 xsltCompileIdKeyPattern(xsltParserContextPtr ctxt, xmlChar *name,
1399         int aid, int novar, xsltAxis axis) {
1400     xmlChar *lit = NULL;
1401     xmlChar *lit2 = NULL;
1402 
1403     if (CUR != &#39;(&#39;) {
1404     xsltTransformError(NULL, NULL, NULL,
1405         &quot;xsltCompileIdKeyPattern : ( expected\n&quot;);
1406     ctxt-&gt;error = 1;
1407     return;
1408     }
1409     if ((aid) &amp;&amp; (xmlStrEqual(name, (const xmlChar *)&quot;id&quot;))) {
1410     if (axis != 0) {
1411         xsltTransformError(NULL, NULL, NULL,
1412             &quot;xsltCompileIdKeyPattern : NodeTest expected\n&quot;);
1413         ctxt-&gt;error = 1;
1414         return;
1415     }
1416     NEXT;
1417     SKIP_BLANKS;
1418         lit = xsltScanLiteral(ctxt);
1419     if (ctxt-&gt;error) {
1420         xsltTransformError(NULL, NULL, NULL,
1421             &quot;xsltCompileIdKeyPattern : Literal expected\n&quot;);
1422         return;
1423     }
1424     SKIP_BLANKS;
1425     if (CUR != &#39;)&#39;) {
1426         xsltTransformError(NULL, NULL, NULL,
1427             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1428         xmlFree(lit);
1429         ctxt-&gt;error = 1;
1430         return;
1431     }
1432     NEXT;
1433     PUSH(XSLT_OP_ID, lit, NULL, novar);
1434     lit = NULL;
1435     } else if ((aid) &amp;&amp; (xmlStrEqual(name, (const xmlChar *)&quot;key&quot;))) {
1436     if (axis != 0) {
1437         xsltTransformError(NULL, NULL, NULL,
1438             &quot;xsltCompileIdKeyPattern : NodeTest expected\n&quot;);
1439         ctxt-&gt;error = 1;
1440         return;
1441     }
1442     NEXT;
1443     SKIP_BLANKS;
1444         lit = xsltScanLiteral(ctxt);
1445     if (ctxt-&gt;error) {
1446         xsltTransformError(NULL, NULL, NULL,
1447             &quot;xsltCompileIdKeyPattern : Literal expected\n&quot;);
1448         return;
1449     }
1450     SKIP_BLANKS;
1451     if (CUR != &#39;,&#39;) {
1452         xsltTransformError(NULL, NULL, NULL,
1453             &quot;xsltCompileIdKeyPattern : , expected\n&quot;);
1454         xmlFree(lit);
1455         ctxt-&gt;error = 1;
1456         return;
1457     }
1458     NEXT;
1459     SKIP_BLANKS;
1460         lit2 = xsltScanLiteral(ctxt);
1461     if (ctxt-&gt;error) {
1462         xsltTransformError(NULL, NULL, NULL,
1463             &quot;xsltCompileIdKeyPattern : Literal expected\n&quot;);
1464         xmlFree(lit);
1465         return;
1466     }
1467     SKIP_BLANKS;
1468     if (CUR != &#39;)&#39;) {
1469         xsltTransformError(NULL, NULL, NULL,
1470             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1471         xmlFree(lit);
1472         xmlFree(lit2);
1473         ctxt-&gt;error = 1;
1474         return;
1475     }
1476     NEXT;
1477     /* URGENT TODO: support namespace in keys */
1478     PUSH(XSLT_OP_KEY, lit, lit2, novar);
1479     lit = NULL;
1480     lit2 = NULL;
1481     } else if (xmlStrEqual(name, (const xmlChar *)&quot;processing-instruction&quot;)) {
1482     NEXT;
1483     SKIP_BLANKS;
1484     if (CUR != &#39;)&#39;) {
1485         lit = xsltScanLiteral(ctxt);
1486         if (ctxt-&gt;error) {
1487         xsltTransformError(NULL, NULL, NULL,
1488             &quot;xsltCompileIdKeyPattern : Literal expected\n&quot;);
1489         return;
1490         }
1491         SKIP_BLANKS;
1492         if (CUR != &#39;)&#39;) {
1493         xsltTransformError(NULL, NULL, NULL,
1494             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1495         ctxt-&gt;error = 1;
1496                 xmlFree(lit);
1497         return;
1498         }
1499     }
1500     NEXT;
1501     PUSH(XSLT_OP_PI, lit, NULL, novar);
1502     lit = NULL;
1503     } else if (xmlStrEqual(name, (const xmlChar *)&quot;text&quot;)) {
1504     NEXT;
1505     SKIP_BLANKS;
1506     if (CUR != &#39;)&#39;) {
1507         xsltTransformError(NULL, NULL, NULL,
1508             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1509         ctxt-&gt;error = 1;
1510         return;
1511     }
1512     NEXT;
1513     PUSH(XSLT_OP_TEXT, NULL, NULL, novar);
1514     } else if (xmlStrEqual(name, (const xmlChar *)&quot;comment&quot;)) {
1515     NEXT;
1516     SKIP_BLANKS;
1517     if (CUR != &#39;)&#39;) {
1518         xsltTransformError(NULL, NULL, NULL,
1519             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1520         ctxt-&gt;error = 1;
1521         return;
1522     }
1523     NEXT;
1524     PUSH(XSLT_OP_COMMENT, NULL, NULL, novar);
1525     } else if (xmlStrEqual(name, (const xmlChar *)&quot;node&quot;)) {
1526     NEXT;
1527     SKIP_BLANKS;
1528     if (CUR != &#39;)&#39;) {
1529         xsltTransformError(NULL, NULL, NULL,
1530             &quot;xsltCompileIdKeyPattern : ) expected\n&quot;);
1531         ctxt-&gt;error = 1;
1532         return;
1533     }
1534     NEXT;
1535     if (axis == AXIS_ATTRIBUTE) {
1536         PUSH(XSLT_OP_ATTR, NULL, NULL, novar);
1537     }
1538     else {
1539         PUSH(XSLT_OP_NODE, NULL, NULL, novar);
1540     }
1541     } else if (aid) {
1542     xsltTransformError(NULL, NULL, NULL,
1543         &quot;xsltCompileIdKeyPattern : expecting &#39;key&#39; or &#39;id&#39; or node type\n&quot;);
1544     ctxt-&gt;error = 1;
1545     return;
1546     } else {
1547     xsltTransformError(NULL, NULL, NULL,
1548         &quot;xsltCompileIdKeyPattern : node type\n&quot;);
1549     ctxt-&gt;error = 1;
1550     return;
1551     }
1552 error:
1553     return;
1554 }
1555 
1556 /**
1557  * xsltCompileStepPattern:
1558  * @ctxt:  the compilation context
1559  * @token:  a posible precompiled name
1560  * @novar: flag to prohibit xslt variables from pattern
1561  *
1562  * Compile the XSLT StepPattern and generates a precompiled
1563  * form suitable for fast matching.
1564  *
1565  * [5] StepPattern ::= ChildOrAttributeAxisSpecifier NodeTest Predicate*
1566  * [6] ChildOrAttributeAxisSpecifier ::= AbbreviatedAxisSpecifier
1567  *                                     | (&#39;child&#39; | &#39;attribute&#39;) &#39;::&#39;
1568  * from XPath
1569  * [7]  NodeTest ::= NameTest
1570  *                 | NodeType &#39;(&#39; &#39;)&#39;
1571  *                 | &#39;processing-instruction&#39; &#39;(&#39; Literal &#39;)&#39;
1572  * [8] Predicate ::= &#39;[&#39; PredicateExpr &#39;]&#39;
1573  * [9] PredicateExpr ::= Expr
1574  * [13] AbbreviatedAxisSpecifier ::= &#39;@&#39;?
1575  * [37] NameTest ::= &#39;*&#39; | NCName &#39;:&#39; &#39;*&#39; | QName
1576  */
1577 
1578 static void
1579 xsltCompileStepPattern(xsltParserContextPtr ctxt, xmlChar *token, int novar) {
1580     xmlChar *name = NULL;
1581     const xmlChar *URI = NULL;
1582     xmlChar *URL = NULL;
1583     int level;
1584     xsltAxis axis = 0;
1585 
1586     SKIP_BLANKS;
1587     if ((token == NULL) &amp;&amp; (CUR == &#39;@&#39;)) {
1588     NEXT;
1589         axis = AXIS_ATTRIBUTE;
1590     }
1591 parse_node_test:
1592     if (token == NULL)
1593     token = xsltScanNCName(ctxt);
1594     if (token == NULL) {
1595     if (CUR == &#39;*&#39;) {
1596         NEXT;
1597         if (axis == AXIS_ATTRIBUTE) {
1598                 PUSH(XSLT_OP_ATTR, NULL, NULL, novar);
1599             }
1600             else {
1601                 PUSH(XSLT_OP_ALL, NULL, NULL, novar);
1602             }
1603         goto parse_predicate;
1604     } else {
1605         xsltTransformError(NULL, NULL, NULL,
1606             &quot;xsltCompileStepPattern : Name expected\n&quot;);
1607         ctxt-&gt;error = 1;
1608         goto error;
1609     }
1610     }
1611 
1612 
1613     SKIP_BLANKS;
1614     if (CUR == &#39;(&#39;) {
1615     xsltCompileIdKeyPattern(ctxt, token, 0, novar, axis);
1616     xmlFree(token);
1617     token = NULL;
1618     if (ctxt-&gt;error)
1619         goto error;
1620     } else if (CUR == &#39;:&#39;) {
1621     NEXT;
1622     if (CUR != &#39;:&#39;) {
1623         xmlChar *prefix = token;
1624         xmlNsPtr ns;
1625 
1626         /*
1627          * This is a namespace match
1628          */
1629         token = xsltScanNCName(ctxt);
1630         ns = xmlSearchNs(ctxt-&gt;doc, ctxt-&gt;elem, prefix);
1631         if (ns == NULL) {
1632         xsltTransformError(NULL, NULL, NULL,
1633         &quot;xsltCompileStepPattern : no namespace bound to prefix %s\n&quot;,
1634                  prefix);
1635         xmlFree(prefix);
1636         prefix=NULL;
1637         ctxt-&gt;error = 1;
1638         goto error;
1639         } else {
1640         URL = xmlStrdup(ns-&gt;href);
1641         }
1642         xmlFree(prefix);
1643         prefix=NULL;
1644         if (token == NULL) {
1645         if (CUR == &#39;*&#39;) {
1646             NEXT;
1647                     if (axis == AXIS_ATTRIBUTE) {
1648                         PUSH(XSLT_OP_ATTR, NULL, URL, novar);
1649             URL = NULL;
1650                     }
1651                     else {
1652                         PUSH(XSLT_OP_NS, URL, NULL, novar);
1653             URL = NULL;
1654                     }
1655         } else {
1656             xsltTransformError(NULL, NULL, NULL,
1657                 &quot;xsltCompileStepPattern : Name expected\n&quot;);
1658             ctxt-&gt;error = 1;
1659                     xmlFree(URL);
1660             goto error;
1661         }
1662         } else {
1663                 if (axis == AXIS_ATTRIBUTE) {
1664                     PUSH(XSLT_OP_ATTR, token, URL, novar);
1665             token = NULL;
1666             URL = NULL;
1667                 }
1668                 else {
1669                     PUSH(XSLT_OP_ELEM, token, URL, novar);
1670             token = NULL;
1671             URL = NULL;
1672                 }
1673         }
1674     } else {
1675         if (axis != 0) {
1676         xsltTransformError(NULL, NULL, NULL,
1677             &quot;xsltCompileStepPattern : NodeTest expected\n&quot;);
1678         ctxt-&gt;error = 1;
1679         goto error;
1680         }
1681         NEXT;
1682         if (xmlStrEqual(token, (const xmlChar *) &quot;child&quot;)) {
1683             axis = AXIS_CHILD;
1684         } else if (xmlStrEqual(token, (const xmlChar *) &quot;attribute&quot;)) {
1685             axis = AXIS_ATTRIBUTE;
1686         } else {
1687         xsltTransformError(NULL, NULL, NULL,
1688             &quot;xsltCompileStepPattern : &#39;child&#39; or &#39;attribute&#39; expected\n&quot;);
1689         ctxt-&gt;error = 1;
1690         goto error;
1691         }
1692         xmlFree(token);
1693         token = NULL;
1694             SKIP_BLANKS;
1695             token = xsltScanNCName(ctxt);
1696         goto parse_node_test;
1697     }
1698     } else {
1699     URI = xsltGetQNameURI(ctxt-&gt;elem, &amp;token);
1700     if (token == NULL) {
1701         ctxt-&gt;error = 1;
1702         goto error;
1703     }
1704     if (URI != NULL)
1705         URL = xmlStrdup(URI);
1706         if (axis == AXIS_ATTRIBUTE) {
1707             PUSH(XSLT_OP_ATTR, token, URL, novar);
1708         token = NULL;
1709         URL = NULL;
1710         }
1711         else {
1712             PUSH(XSLT_OP_ELEM, token, URL, novar);
1713         token = NULL;
1714         URL = NULL;
1715         }
1716     }
1717 parse_predicate:
1718     SKIP_BLANKS;
1719     level = 0;
1720     while (CUR == &#39;[&#39;) {
1721     const xmlChar *q;
1722     xmlChar *ret = NULL;
1723 
1724     level++;
1725     NEXT;
1726     q = CUR_PTR;
1727     while (CUR != 0) {
1728         /* Skip over nested predicates */
1729         if (CUR == &#39;[&#39;)
1730         level++;
1731         else if (CUR == &#39;]&#39;) {
1732         level--;
1733         if (level == 0)
1734             break;
1735         } else if (CUR == &#39;&quot;&#39;) {
1736         NEXT;
1737         while ((CUR != 0) &amp;&amp; (CUR != &#39;&quot;&#39;))
1738             NEXT;
1739         } else if (CUR == &#39;\&#39;&#39;) {
1740         NEXT;
1741         while ((CUR != 0) &amp;&amp; (CUR != &#39;\&#39;&#39;))
1742             NEXT;
1743         }
1744         NEXT;
1745     }
1746     if (CUR == 0) {
1747         xsltTransformError(NULL, NULL, NULL,
1748             &quot;xsltCompileStepPattern : &#39;]&#39; expected\n&quot;);
1749         ctxt-&gt;error = 1;
1750         return;
1751         }
1752     ret = xmlStrndup(q, CUR_PTR - q);
1753     PUSH(XSLT_OP_PREDICATE, ret, NULL, novar);
1754     ret = NULL;
1755     /* push the predicate lower than local test */
1756     SWAP();
1757     NEXT;
1758     SKIP_BLANKS;
1759     }
1760     return;
1761 error:
1762     if (token != NULL)
1763     xmlFree(token);
1764     if (name != NULL)
1765     xmlFree(name);
1766 }
1767 
1768 /**
1769  * xsltCompileRelativePathPattern:
1770  * @comp:  the compilation context
1771  * @token:  a posible precompiled name
1772  * @novar:  flag to prohibit xslt variables
1773  *
1774  * Compile the XSLT RelativePathPattern and generates a precompiled
1775  * form suitable for fast matching.
1776  *
1777  * [4] RelativePathPattern ::= StepPattern
1778  *                           | RelativePathPattern &#39;/&#39; StepPattern
1779  *                           | RelativePathPattern &#39;//&#39; StepPattern
1780  */
1781 static void
1782 xsltCompileRelativePathPattern(xsltParserContextPtr ctxt, xmlChar *token, int novar) {
1783     xsltCompileStepPattern(ctxt, token, novar);
1784     if (ctxt-&gt;error)
1785     goto error;
1786     SKIP_BLANKS;
1787     while ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {
1788     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1789         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1790         NEXT;
1791         NEXT;
1792         SKIP_BLANKS;
1793         xsltCompileStepPattern(ctxt, NULL, novar);
1794     } else if (CUR == &#39;/&#39;) {
1795         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1796         NEXT;
1797         SKIP_BLANKS;
1798         if ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {
1799         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1800         }
1801     } else {
1802         ctxt-&gt;error = 1;
1803     }
1804     if (ctxt-&gt;error)
1805         goto error;
1806     SKIP_BLANKS;
1807     }
1808 error:
1809     return;
1810 }
1811 
1812 /**
1813  * xsltCompileLocationPathPattern:
1814  * @ctxt:  the compilation context
1815  * @novar:  flag to prohibit xslt variables
1816  *
1817  * Compile the XSLT LocationPathPattern and generates a precompiled
1818  * form suitable for fast matching.
1819  *
1820  * [2] LocationPathPattern ::= &#39;/&#39; RelativePathPattern?
1821  *                           | IdKeyPattern ((&#39;/&#39; | &#39;//&#39;) RelativePathPattern)?
1822  *                           | &#39;//&#39;? RelativePathPattern
1823  */
1824 static void
1825 xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {
1826     SKIP_BLANKS;
1827     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1828     /*
1829      * since we reverse the query
1830      * a leading // can be safely ignored
1831      */
1832     NEXT;
1833     NEXT;
1834     ctxt-&gt;comp-&gt;priority = 0.5; /* &#39;//&#39; means not 0 priority */
1835     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1836     } else if (CUR == &#39;/&#39;) {
1837     /*
1838      * We need to find root as the parent
1839      */
1840     NEXT;
1841     SKIP_BLANKS;
1842     PUSH(XSLT_OP_ROOT, NULL, NULL, novar);
1843     if ((CUR != 0) &amp;&amp; (CUR != &#39;|&#39;)) {
1844         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1845         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1846     }
1847     } else if (CUR == &#39;*&#39;) {
1848     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1849     } else if (CUR == &#39;@&#39;) {
1850     xsltCompileRelativePathPattern(ctxt, NULL, novar);
1851     } else {
1852     xmlChar *name;
1853     name = xsltScanNCName(ctxt);
1854     if (name == NULL) {
1855         xsltTransformError(NULL, NULL, NULL,
1856             &quot;xsltCompileLocationPathPattern : Name expected\n&quot;);
1857         ctxt-&gt;error = 1;
1858         return;
1859     }
1860     SKIP_BLANKS;
1861     if ((CUR == &#39;(&#39;) &amp;&amp; !xmlXPathIsNodeType(name)) {
1862         xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);
1863         xmlFree(name);
1864         name = NULL;
1865         if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1866         PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
1867         NEXT;
1868         NEXT;
1869         SKIP_BLANKS;
1870         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1871         } else if (CUR == &#39;/&#39;) {
1872         PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
1873         NEXT;
1874         SKIP_BLANKS;
1875         xsltCompileRelativePathPattern(ctxt, NULL, novar);
1876         }
1877         return;
1878     }
1879     xsltCompileRelativePathPattern(ctxt, name, novar);
1880     }
1881 error:
1882     return;
1883 }
1884 
1885 /**
1886  * xsltCompilePatternInternal:
1887  * @pattern: an XSLT pattern
1888  * @doc:  the containing document
1889  * @node:  the containing element
1890  * @style:  the stylesheet
1891  * @runtime:  the transformation context, if done at run-time
1892  * @novar:  flag to prohibit xslt variables
1893  *
1894  * Compile the XSLT pattern and generates a list of precompiled form suitable
1895  * for fast matching.
1896  *
1897  * [1] Pattern ::= LocationPathPattern | Pattern &#39;|&#39; LocationPathPattern
1898  *
1899  * Returns the generated pattern list or NULL in case of failure
1900  */
1901 
1902 static xsltCompMatchPtr
1903 xsltCompilePatternInternal(const xmlChar *pattern, xmlDocPtr doc,
1904                xmlNodePtr node, xsltStylesheetPtr style,
1905            xsltTransformContextPtr runtime, int novar) {
1906     xsltParserContextPtr ctxt = NULL;
1907     xsltCompMatchPtr element, first = NULL, previous = NULL;
1908     int current, start, end, level, j;
1909 
1910     if (pattern == NULL) {
1911     xsltTransformError(NULL, NULL, node,
1912              &quot;xsltCompilePattern : NULL pattern\n&quot;);
1913     return(NULL);
1914     }
1915 
1916     ctxt = xsltNewParserContext(style, runtime);
1917     if (ctxt == NULL)
1918     return(NULL);
1919     ctxt-&gt;doc = doc;
1920     ctxt-&gt;elem = node;
1921     current = end = 0;
1922     while (pattern[current] != 0) {
1923     start = current;
1924     while (IS_BLANK_CH(pattern[current]))
1925         current++;
1926     end = current;
1927     level = 0;
1928     while ((pattern[end] != 0) &amp;&amp; ((pattern[end] != &#39;|&#39;) || (level != 0))) {
1929         if (pattern[end] == &#39;[&#39;)
1930         level++;
1931         else if (pattern[end] == &#39;]&#39;)
1932         level--;
1933         else if (pattern[end] == &#39;\&#39;&#39;) {
1934         end++;
1935         while ((pattern[end] != 0) &amp;&amp; (pattern[end] != &#39;\&#39;&#39;))
1936             end++;
1937         } else if (pattern[end] == &#39;&quot;&#39;) {
1938         end++;
1939         while ((pattern[end] != 0) &amp;&amp; (pattern[end] != &#39;&quot;&#39;))
1940             end++;
1941         }
1942         if (pattern[end] == 0)
1943             break;
1944         end++;
1945     }
1946     if (current == end) {
1947         xsltTransformError(NULL, NULL, node,
1948                  &quot;xsltCompilePattern : NULL pattern\n&quot;);
1949         goto error;
1950     }
1951     element = xsltNewCompMatch();
1952     if (element == NULL) {
1953         goto error;
1954     }
1955     if (first == NULL)
1956         first = element;
1957     else if (previous != NULL)
1958         previous-&gt;next = element;
1959     previous = element;
1960 
1961     ctxt-&gt;comp = element;
1962     ctxt-&gt;base = xmlStrndup(&amp;pattern[start], end - start);
1963     if (ctxt-&gt;base == NULL)
1964         goto error;
1965     ctxt-&gt;cur = &amp;(ctxt-&gt;base)[current - start];
1966     element-&gt;pattern = ctxt-&gt;base;
1967         element-&gt;node = node;
1968     element-&gt;nsList = xmlGetNsList(doc, node);
1969     j = 0;
1970     if (element-&gt;nsList != NULL) {
1971         while (element-&gt;nsList[j] != NULL)
1972         j++;
1973     }
1974     element-&gt;nsNr = j;
1975         element-&gt;novar = novar;
1976 
1977 
1978 #ifdef WITH_XSLT_DEBUG_PATTERN
1979     xsltGenericDebug(xsltGenericDebugContext,
1980              &quot;xsltCompilePattern : parsing &#39;%s&#39;\n&quot;,
1981              element-&gt;pattern);
1982 #endif
1983     /*
1984      Preset default priority to be zero.
1985      This may be changed by xsltCompileLocationPathPattern.
1986      */
1987     element-&gt;priority = 0;
1988     xsltCompileLocationPathPattern(ctxt, novar);
1989     if (ctxt-&gt;error) {
1990         xsltTransformError(NULL, style, node,
1991                  &quot;xsltCompilePattern : failed to compile &#39;%s&#39;\n&quot;,
1992                  element-&gt;pattern);
1993         if (style != NULL) style-&gt;errors++;
1994         goto error;
1995     }
1996 
1997     /*
1998      * Reverse for faster interpretation.
1999      */
2000     xsltReverseCompMatch(ctxt, element);
2001 
2002     /*
2003      * Set-up the priority
2004      */
2005     if (element-&gt;priority == 0) {   /* if not yet determined */
2006         if (((element-&gt;steps[0].op == XSLT_OP_ELEM) ||
2007          (element-&gt;steps[0].op == XSLT_OP_ATTR) ||
2008          (element-&gt;steps[0].op == XSLT_OP_PI)) &amp;&amp;
2009         (element-&gt;steps[0].value != NULL) &amp;&amp;
2010         (element-&gt;steps[1].op == XSLT_OP_END)) {
2011         ;   /* previously preset */
2012         } else if ((element-&gt;steps[0].op == XSLT_OP_ATTR) &amp;&amp;
2013                (element-&gt;steps[0].value2 != NULL) &amp;&amp;
2014                (element-&gt;steps[1].op == XSLT_OP_END)) {
2015             element-&gt;priority = -0.25;
2016         } else if ((element-&gt;steps[0].op == XSLT_OP_NS) &amp;&amp;
2017                (element-&gt;steps[0].value != NULL) &amp;&amp;
2018                (element-&gt;steps[1].op == XSLT_OP_END)) {
2019             element-&gt;priority = -0.25;
2020         } else if ((element-&gt;steps[0].op == XSLT_OP_ATTR) &amp;&amp;
2021                (element-&gt;steps[0].value == NULL) &amp;&amp;
2022                (element-&gt;steps[0].value2 == NULL) &amp;&amp;
2023                (element-&gt;steps[1].op == XSLT_OP_END)) {
2024             element-&gt;priority = -0.5;
2025         } else if (((element-&gt;steps[0].op == XSLT_OP_PI) ||
2026                (element-&gt;steps[0].op == XSLT_OP_TEXT) ||
2027                (element-&gt;steps[0].op == XSLT_OP_ALL) ||
2028                (element-&gt;steps[0].op == XSLT_OP_NODE) ||
2029                (element-&gt;steps[0].op == XSLT_OP_COMMENT)) &amp;&amp;
2030                (element-&gt;steps[1].op == XSLT_OP_END)) {
2031             element-&gt;priority = -0.5;
2032         } else {
2033         element-&gt;priority = 0.5;
2034         }
2035     }
2036 #ifdef WITH_XSLT_DEBUG_PATTERN
2037     xsltGenericDebug(xsltGenericDebugContext,
2038              &quot;xsltCompilePattern : parsed %s, default priority %f\n&quot;,
2039              element-&gt;pattern, element-&gt;priority);
2040 #endif
2041     if (pattern[end] == &#39;|&#39;)
2042         end++;
2043     current = end;
2044     }
2045     if (end == 0) {
2046     xsltTransformError(NULL, style, node,
2047              &quot;xsltCompilePattern : NULL pattern\n&quot;);
2048     if (style != NULL) style-&gt;errors++;
2049     goto error;
2050     }
2051 
2052     xsltFreeParserContext(ctxt);
2053     return(first);
2054 
2055 error:
2056     if (ctxt != NULL)
2057     xsltFreeParserContext(ctxt);
2058     if (first != NULL)
2059     xsltFreeCompMatchList(first);
2060     return(NULL);
2061 }
2062 
2063 /**
2064  * xsltCompilePattern:
2065  * @pattern: an XSLT pattern
2066  * @doc:  the containing document
2067  * @node:  the containing element
2068  * @style:  the stylesheet
2069  * @runtime:  the transformation context, if done at run-time
2070  *
2071  * Compile the XSLT pattern and generates a list of precompiled form suitable
2072  * for fast matching.
2073  *
2074  * [1] Pattern ::= LocationPathPattern | Pattern &#39;|&#39; LocationPathPattern
2075  *
2076  * Returns the generated pattern list or NULL in case of failure
2077  */
2078 
2079 xsltCompMatchPtr
2080 xsltCompilePattern(const xmlChar *pattern, xmlDocPtr doc,
2081                xmlNodePtr node, xsltStylesheetPtr style,
2082            xsltTransformContextPtr runtime) {
2083     return (xsltCompilePatternInternal(pattern, doc, node, style, runtime, 0));
2084 }
2085 
2086 /************************************************************************
2087  *                                  *
2088  *          Module interfaces               *
2089  *                                  *
2090  ************************************************************************/
2091 
2092 /**
2093  * xsltAddTemplate:
2094  * @style: an XSLT stylesheet
2095  * @cur: an XSLT template
2096  * @mode:  the mode name or NULL
2097  * @modeURI:  the mode URI or NULL
2098  *
2099  * Register the XSLT pattern associated to @cur
2100  *
2101  * Returns -1 in case of error, 0 otherwise
2102  */
2103 int
2104 xsltAddTemplate(xsltStylesheetPtr style, xsltTemplatePtr cur,
2105             const xmlChar *mode, const xmlChar *modeURI) {
2106     xsltCompMatchPtr pat, list, next;
2107     /*
2108      * &#39;top&#39; will point to style-&gt;xxxMatch ptr - declaring as &#39;void&#39;
2109      *  avoids gcc &#39;type-punned pointer&#39; warning.
2110      */
2111     void **top = NULL;
2112     const xmlChar *name = NULL;
2113     float priority;              /* the priority */
2114 
2115     if ((style == NULL) || (cur == NULL))
2116     return(-1);
2117 
2118     /* Register named template */
2119     if (cur-&gt;name != NULL) {
2120         if (style-&gt;namedTemplates == NULL) {
2121             style-&gt;namedTemplates = xmlHashCreate(10);
2122             if (style-&gt;namedTemplates == NULL)
2123                 return(-1);
2124         }
2125         else {
2126             void *dup = xmlHashLookup2(style-&gt;namedTemplates, cur-&gt;name,
2127                                        cur-&gt;nameURI);
2128             if (dup != NULL) {
2129                 xsltTransformError(NULL, style, cur-&gt;elem,
2130                                    &quot;xsl:template: error duplicate name &#39;%s&#39;\n&quot;,
2131                                    cur-&gt;name);
2132                 style-&gt;errors++;
2133                 return(-1);
2134             }
2135         }
2136 
2137         xmlHashAddEntry2(style-&gt;namedTemplates, cur-&gt;name, cur-&gt;nameURI, cur);
2138     }
2139 
2140     if (cur-&gt;match == NULL)
2141     return(0);
2142 
2143     priority = cur-&gt;priority;
2144     pat = xsltCompilePatternInternal(cur-&gt;match, style-&gt;doc, cur-&gt;elem,
2145             style, NULL, 1);
2146     if (pat == NULL)
2147     return(-1);
2148     while (pat) {
2149     next = pat-&gt;next;
2150     pat-&gt;next = NULL;
2151     name = NULL;
2152 
2153     pat-&gt;template = cur;
2154     if (mode != NULL)
2155         pat-&gt;mode = xmlDictLookup(style-&gt;dict, mode, -1);
2156     if (modeURI != NULL)
2157         pat-&gt;modeURI = xmlDictLookup(style-&gt;dict, modeURI, -1);
2158     if (priority != XSLT_PAT_NO_PRIORITY)
2159         pat-&gt;priority = priority;
2160 
2161     /*
2162      * insert it in the hash table list corresponding to its lookup name
2163      */
2164     switch (pat-&gt;steps[0].op) {
2165         case XSLT_OP_ATTR:
2166         if (pat-&gt;steps[0].value != NULL)
2167         name = pat-&gt;steps[0].value;
2168         else
2169         top = &amp;(style-&gt;attrMatch);
2170         break;
2171         case XSLT_OP_PARENT:
2172         case XSLT_OP_ANCESTOR:
2173         top = &amp;(style-&gt;elemMatch);
2174         break;
2175         case XSLT_OP_ROOT:
2176         top = &amp;(style-&gt;rootMatch);
2177         break;
2178         case XSLT_OP_KEY:
2179         top = &amp;(style-&gt;keyMatch);
2180         break;
2181         case XSLT_OP_ID:
2182         /* TODO optimize ID !!! */
2183         case XSLT_OP_NS:
2184         case XSLT_OP_ALL:
2185         top = &amp;(style-&gt;elemMatch);
2186         break;
2187         case XSLT_OP_END:
2188     case XSLT_OP_PREDICATE:
2189         xsltTransformError(NULL, style, NULL,
2190                  &quot;xsltAddTemplate: invalid compiled pattern\n&quot;);
2191         xsltFreeCompMatch(pat);
2192         return(-1);
2193         /*
2194          * TODO: some flags at the top level about type based patterns
2195          *       would be faster than inclusion in the hash table.
2196          */
2197     case XSLT_OP_PI:
2198         if (pat-&gt;steps[0].value != NULL)
2199         name = pat-&gt;steps[0].value;
2200         else
2201         top = &amp;(style-&gt;piMatch);
2202         break;
2203     case XSLT_OP_COMMENT:
2204         top = &amp;(style-&gt;commentMatch);
2205         break;
2206     case XSLT_OP_TEXT:
2207         top = &amp;(style-&gt;textMatch);
2208         break;
2209         case XSLT_OP_ELEM:
2210     case XSLT_OP_NODE:
2211         if (pat-&gt;steps[0].value != NULL)
2212         name = pat-&gt;steps[0].value;
2213         else
2214         top = &amp;(style-&gt;elemMatch);
2215         break;
2216     }
2217     if (name != NULL) {
2218         if (style-&gt;templatesHash == NULL) {
2219         style-&gt;templatesHash = xmlHashCreate(1024);
2220         if (style-&gt;templatesHash == NULL) {
2221             xsltFreeCompMatch(pat);
2222             return(-1);
2223         }
2224         xmlHashAddEntry3(style-&gt;templatesHash, name, mode, modeURI, pat);
2225         } else {
2226         list = (xsltCompMatchPtr) xmlHashLookup3(style-&gt;templatesHash,
2227                              name, mode, modeURI);
2228         if (list == NULL) {
2229             xmlHashAddEntry3(style-&gt;templatesHash, name,
2230                      mode, modeURI, pat);
2231         } else {
2232             /*
2233              * Note &#39;&lt;=&#39; since one must choose among the matching
2234              * template rules that are left, the one that occurs
2235              * last in the stylesheet
2236              */
2237             if (list-&gt;priority &lt;= pat-&gt;priority) {
2238             pat-&gt;next = list;
2239             xmlHashUpdateEntry3(style-&gt;templatesHash, name,
2240                         mode, modeURI, pat, NULL);
2241             } else {
2242             while (list-&gt;next != NULL) {
2243                 if (list-&gt;next-&gt;priority &lt;= pat-&gt;priority)
2244                 break;
2245                 list = list-&gt;next;
2246             }
2247             pat-&gt;next = list-&gt;next;
2248             list-&gt;next = pat;
2249             }
2250         }
2251         }
2252     } else if (top != NULL) {
2253         list = *top;
2254         if (list == NULL) {
2255         *top = pat;
2256         pat-&gt;next = NULL;
2257         } else if (list-&gt;priority &lt;= pat-&gt;priority) {
2258         pat-&gt;next = list;
2259         *top = pat;
2260         } else {
2261         while (list-&gt;next != NULL) {
2262             if (list-&gt;next-&gt;priority &lt;= pat-&gt;priority)
2263             break;
2264             list = list-&gt;next;
2265         }
2266         pat-&gt;next = list-&gt;next;
2267         list-&gt;next = pat;
2268         }
2269     } else {
2270         xsltTransformError(NULL, style, NULL,
2271                  &quot;xsltAddTemplate: invalid compiled pattern\n&quot;);
2272         xsltFreeCompMatch(pat);
2273         return(-1);
2274     }
2275 #ifdef WITH_XSLT_DEBUG_PATTERN
2276     if (mode)
2277         xsltGenericDebug(xsltGenericDebugContext,
2278              &quot;added pattern : &#39;%s&#39; mode &#39;%s&#39; priority %f\n&quot;,
2279                  pat-&gt;pattern, pat-&gt;mode, pat-&gt;priority);
2280     else
2281         xsltGenericDebug(xsltGenericDebugContext,
2282              &quot;added pattern : &#39;%s&#39; priority %f\n&quot;,
2283                  pat-&gt;pattern, pat-&gt;priority);
2284 #endif
2285 
2286     pat = next;
2287     }
2288     return(0);
2289 }
2290 
2291 static int
2292 xsltComputeAllKeys(xsltTransformContextPtr ctxt, xmlNodePtr contextNode)
2293 {
2294     if ((ctxt == NULL) || (contextNode == NULL)) {
2295     xsltTransformError(ctxt, NULL, ctxt-&gt;inst,
2296         &quot;Internal error in xsltComputeAllKeys(): &quot;
2297         &quot;Bad arguments.\n&quot;);
2298     return(-1);
2299     }
2300 
2301     if (ctxt-&gt;document == NULL) {
2302     /*
2303     * The document info will only be NULL if we have a RTF.
2304     */
2305     if (contextNode-&gt;doc-&gt;_private != NULL)
2306         goto doc_info_mismatch;
2307     /*
2308     * On-demand creation of the document info (needed for keys).
2309     */
2310     ctxt-&gt;document = xsltNewDocument(ctxt, contextNode-&gt;doc);
2311     if (ctxt-&gt;document == NULL)
2312         return(-1);
2313     }
2314     return xsltInitAllDocKeys(ctxt);
2315 
2316 doc_info_mismatch:
2317     xsltTransformError(ctxt, NULL, ctxt-&gt;inst,
2318     &quot;Internal error in xsltComputeAllKeys(): &quot;
2319     &quot;The context&#39;s document info doesn&#39;t match the &quot;
2320     &quot;document info of the current result tree.\n&quot;);
2321     ctxt-&gt;state = XSLT_STATE_STOPPED;
2322     return(-1);
2323 }
2324 
2325 /**
2326  * xsltGetTemplate:
2327  * @ctxt:  a XSLT process context
2328  * @node:  the node being processed
2329  * @style:  the current style
2330  *
2331  * Finds the template applying to this node, if @style is non-NULL
2332  * it means one needs to look for the next imported template in scope.
2333  *
2334  * Returns the xsltTemplatePtr or NULL if not found
2335  */
2336 xsltTemplatePtr
2337 xsltGetTemplate(xsltTransformContextPtr ctxt, xmlNodePtr node,
2338             xsltStylesheetPtr style)
2339 {
2340     xsltStylesheetPtr curstyle;
2341     xsltTemplatePtr ret = NULL;
2342     const xmlChar *name = NULL;
2343     xsltCompMatchPtr list = NULL;
2344     float priority;
2345     int keyed = 0;
2346 
2347     if ((ctxt == NULL) || (node == NULL))
2348     return(NULL);
2349 
2350     if (style == NULL) {
2351     curstyle = ctxt-&gt;style;
2352     } else {
2353     curstyle = xsltNextImport(style);
2354     }
2355 
2356     while ((curstyle != NULL) &amp;&amp; (curstyle != style)) {
2357     priority = XSLT_PAT_NO_PRIORITY;
2358     /* TODO : handle IDs/keys here ! */
2359     if (curstyle-&gt;templatesHash != NULL) {
2360         /*
2361          * Use the top name as selector
2362          */
2363         switch (node-&gt;type) {
2364         case XML_ELEMENT_NODE:
2365             if (node-&gt;name[0] == &#39; &#39;)
2366             break;
2367         case XML_ATTRIBUTE_NODE:
2368         case XML_PI_NODE:
2369             name = node-&gt;name;
2370             break;
2371         case XML_DOCUMENT_NODE:
2372         case XML_HTML_DOCUMENT_NODE:
2373         case XML_TEXT_NODE:
2374         case XML_CDATA_SECTION_NODE:
2375         case XML_COMMENT_NODE:
2376         case XML_ENTITY_REF_NODE:
2377         case XML_ENTITY_NODE:
2378         case XML_DOCUMENT_TYPE_NODE:
2379         case XML_DOCUMENT_FRAG_NODE:
2380         case XML_NOTATION_NODE:
2381         case XML_DTD_NODE:
2382         case XML_ELEMENT_DECL:
2383         case XML_ATTRIBUTE_DECL:
2384         case XML_ENTITY_DECL:
2385         case XML_NAMESPACE_DECL:
2386         case XML_XINCLUDE_START:
2387         case XML_XINCLUDE_END:
2388             break;
2389         default:
2390             return(NULL);
2391 
2392         }
2393     }
2394     if (name != NULL) {
2395         /*
2396          * find the list of applicable expressions based on the name
2397          */
2398         list = (xsltCompMatchPtr) xmlHashLookup3(curstyle-&gt;templatesHash,
2399                          name, ctxt-&gt;mode, ctxt-&gt;modeURI);
2400     } else
2401         list = NULL;
2402     while (list != NULL) {
2403         if (xsltTestCompMatch(ctxt, list, node,
2404                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {
2405         ret = list-&gt;template;
2406         priority = list-&gt;priority;
2407         break;
2408         }
2409         list = list-&gt;next;
2410     }
2411     list = NULL;
2412 
2413     /*
2414      * find alternate generic matches
2415      */
2416     switch (node-&gt;type) {
2417         case XML_ELEMENT_NODE:
2418         if (node-&gt;name[0] == &#39; &#39;)
2419             list = curstyle-&gt;rootMatch;
2420         else
2421             list = curstyle-&gt;elemMatch;
2422         if (node-&gt;psvi != NULL) keyed = 1;
2423         break;
2424         case XML_ATTRIBUTE_NODE: {
2425             xmlAttrPtr attr;
2426 
2427         list = curstyle-&gt;attrMatch;
2428         attr = (xmlAttrPtr) node;
2429         if (attr-&gt;psvi != NULL) keyed = 1;
2430         break;
2431         }
2432         case XML_PI_NODE:
2433         list = curstyle-&gt;piMatch;
2434         if (node-&gt;psvi != NULL) keyed = 1;
2435         break;
2436         case XML_DOCUMENT_NODE:
2437         case XML_HTML_DOCUMENT_NODE: {
2438             xmlDocPtr doc;
2439 
2440         list = curstyle-&gt;rootMatch;
2441         doc = (xmlDocPtr) node;
2442         if (doc-&gt;psvi != NULL) keyed = 1;
2443         break;
2444         }
2445         case XML_TEXT_NODE:
2446         case XML_CDATA_SECTION_NODE:
2447         list = curstyle-&gt;textMatch;
2448         if (node-&gt;psvi != NULL) keyed = 1;
2449         break;
2450         case XML_COMMENT_NODE:
2451         list = curstyle-&gt;commentMatch;
2452         if (node-&gt;psvi != NULL) keyed = 1;
2453         break;
2454         case XML_ENTITY_REF_NODE:
2455         case XML_ENTITY_NODE:
2456         case XML_DOCUMENT_TYPE_NODE:
2457         case XML_DOCUMENT_FRAG_NODE:
2458         case XML_NOTATION_NODE:
2459         case XML_DTD_NODE:
2460         case XML_ELEMENT_DECL:
2461         case XML_ATTRIBUTE_DECL:
2462         case XML_ENTITY_DECL:
2463         case XML_NAMESPACE_DECL:
2464         case XML_XINCLUDE_START:
2465         case XML_XINCLUDE_END:
2466         break;
2467         default:
2468         break;
2469     }
2470     while ((list != NULL) &amp;&amp;
2471            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2472         if (xsltTestCompMatch(ctxt, list, node,
2473                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {
2474         ret = list-&gt;template;
2475         priority = list-&gt;priority;
2476         break;
2477         }
2478         list = list-&gt;next;
2479     }
2480     /*
2481      * Some of the tests for elements can also apply to documents
2482      */
2483     if ((node-&gt;type == XML_DOCUMENT_NODE) ||
2484         (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
2485         (node-&gt;type == XML_TEXT_NODE)) {
2486         list = curstyle-&gt;elemMatch;
2487         while ((list != NULL) &amp;&amp;
2488            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2489         if (xsltTestCompMatch(ctxt, list, node,
2490                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {
2491             ret = list-&gt;template;
2492             priority = list-&gt;priority;
2493             break;
2494         }
2495         list = list-&gt;next;
2496         }
2497     } else if ((node-&gt;type == XML_PI_NODE) ||
2498            (node-&gt;type == XML_COMMENT_NODE)) {
2499         list = curstyle-&gt;elemMatch;
2500         while ((list != NULL) &amp;&amp;
2501            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2502         if (xsltTestCompMatch(ctxt, list, node,
2503                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {
2504             ret = list-&gt;template;
2505             priority = list-&gt;priority;
2506             break;
2507         }
2508         list = list-&gt;next;
2509         }
2510     }
2511 
2512 keyed_match:
2513     if (keyed) {
2514         list = curstyle-&gt;keyMatch;
2515         while ((list != NULL) &amp;&amp;
2516            ((ret == NULL)  || (list-&gt;priority &gt; priority))) {
2517         if (xsltTestCompMatch(ctxt, list, node,
2518                       ctxt-&gt;mode, ctxt-&gt;modeURI)) {
2519             ret = list-&gt;template;
2520             priority = list-&gt;priority;
2521             break;
2522         }
2523         list = list-&gt;next;
2524         }
2525     }
2526     else if (ctxt-&gt;hasTemplKeyPatterns &amp;&amp;
2527         ((ctxt-&gt;document == NULL) ||
2528          (ctxt-&gt;document-&gt;nbKeysComputed &lt; ctxt-&gt;nbKeys)))
2529     {
2530         /*
2531         * Compute all remaining keys for this document.
2532         *
2533         * REVISIT TODO: I think this could be further optimized.
2534         */
2535         if (xsltComputeAllKeys(ctxt, node) == -1)
2536         goto error;
2537 
2538         switch (node-&gt;type) {
2539         case XML_ELEMENT_NODE:
2540             if (node-&gt;psvi != NULL) keyed = 1;
2541             break;
2542         case XML_ATTRIBUTE_NODE:
2543             if (((xmlAttrPtr) node)-&gt;psvi != NULL) keyed = 1;
2544             break;
2545         case XML_TEXT_NODE:
2546         case XML_CDATA_SECTION_NODE:
2547         case XML_COMMENT_NODE:
2548         case XML_PI_NODE:
2549             if (node-&gt;psvi != NULL) keyed = 1;
2550             break;
2551         case XML_DOCUMENT_NODE:
2552         case XML_HTML_DOCUMENT_NODE:
2553             if (((xmlDocPtr) node)-&gt;psvi != NULL) keyed = 1;
2554             break;
2555         default:
2556             break;
2557         }
2558         if (keyed)
2559         goto keyed_match;
2560     }
2561     if (ret != NULL)
2562         return(ret);
2563 
2564     /*
2565      * Cycle on next curstylesheet import.
2566      */
2567     curstyle = xsltNextImport(curstyle);
2568     }
2569 
2570 error:
2571     return(NULL);
2572 }
2573 
2574 /**
2575  * xsltCleanupTemplates:
2576  * @style: an XSLT stylesheet
2577  *
2578  * Cleanup the state of the templates used by the stylesheet and
2579  * the ones it imports.
2580  */
2581 void
2582 xsltCleanupTemplates(xsltStylesheetPtr style ATTRIBUTE_UNUSED) {
2583 }
2584 
2585 /**
2586  * xsltFreeTemplateHashes:
2587  * @style: an XSLT stylesheet
2588  *
2589  * Free up the memory used by xsltAddTemplate/xsltGetTemplate mechanism
2590  */
2591 void
2592 xsltFreeTemplateHashes(xsltStylesheetPtr style) {
2593     if (style-&gt;templatesHash != NULL)
2594     xmlHashFree((xmlHashTablePtr) style-&gt;templatesHash,
2595             xsltFreeCompMatchListEntry);
2596     if (style-&gt;rootMatch != NULL)
2597         xsltFreeCompMatchList(style-&gt;rootMatch);
2598     if (style-&gt;keyMatch != NULL)
2599         xsltFreeCompMatchList(style-&gt;keyMatch);
2600     if (style-&gt;elemMatch != NULL)
2601         xsltFreeCompMatchList(style-&gt;elemMatch);
2602     if (style-&gt;attrMatch != NULL)
2603         xsltFreeCompMatchList(style-&gt;attrMatch);
2604     if (style-&gt;parentMatch != NULL)
2605         xsltFreeCompMatchList(style-&gt;parentMatch);
2606     if (style-&gt;textMatch != NULL)
2607         xsltFreeCompMatchList(style-&gt;textMatch);
2608     if (style-&gt;piMatch != NULL)
2609         xsltFreeCompMatchList(style-&gt;piMatch);
2610     if (style-&gt;commentMatch != NULL)
2611         xsltFreeCompMatchList(style-&gt;commentMatch);
2612     if (style-&gt;namedTemplates != NULL)
2613         xmlHashFree(style-&gt;namedTemplates, NULL);
2614 }
2615 
    </pre>
  </body>
</html>