<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/transform.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * transform.c: Implementation of the XSL Transformation 1.0 engine
   3  *              transform part, i.e. applying a Stylesheet to a document
   4  *
   5  * References:
   6  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   7  *
   8  *   Michael Kay &quot;XSLT Programmer&#39;s Reference&quot; pp 637-643
   9  *   Writing Multiple Output Files
  10  *
  11  *   XSLT-1.1 Working Draft
  12  *   http://www.w3.org/TR/xslt11#multiple-output
  13  *
  14  * See Copyright for the status of this software.
  15  *
  16  * daniel@veillard.com
  17  */
  18 
  19 #define IN_LIBXSLT
  20 #include &quot;libxslt.h&quot;
  21 
  22 #include &lt;limits.h&gt;
  23 #include &lt;string.h&gt;
  24 #include &lt;stdio.h&gt;
  25 #include &lt;stddef.h&gt;
  26 
  27 #include &lt;libxml/xmlmemory.h&gt;
  28 #include &lt;libxml/parser.h&gt;
  29 #include &lt;libxml/tree.h&gt;
  30 #include &lt;libxml/valid.h&gt;
  31 #include &lt;libxml/hash.h&gt;
  32 #include &lt;libxml/encoding.h&gt;
  33 #include &lt;libxml/xmlerror.h&gt;
  34 #include &lt;libxml/xpath.h&gt;
  35 #include &lt;libxml/parserInternals.h&gt;
  36 #include &lt;libxml/xpathInternals.h&gt;
  37 #include &lt;libxml/HTMLtree.h&gt;
  38 #include &lt;libxml/debugXML.h&gt;
  39 #include &lt;libxml/uri.h&gt;
  40 #include &quot;xslt.h&quot;
  41 #include &quot;xsltInternals.h&quot;
  42 #include &quot;xsltutils.h&quot;
  43 #include &quot;pattern.h&quot;
  44 #include &quot;transform.h&quot;
  45 #include &quot;variables.h&quot;
  46 #include &quot;numbersInternals.h&quot;
  47 #include &quot;namespaces.h&quot;
  48 #include &quot;attributes.h&quot;
  49 #include &quot;templates.h&quot;
  50 #include &quot;imports.h&quot;
  51 #include &quot;keys.h&quot;
  52 #include &quot;documents.h&quot;
  53 #include &quot;extensions.h&quot;
  54 #include &quot;extra.h&quot;
  55 #include &quot;preproc.h&quot;
  56 #include &quot;security.h&quot;
  57 
  58 #ifdef WITH_XSLT_DEBUG
  59 #define WITH_XSLT_DEBUG_EXTRA
  60 #define WITH_XSLT_DEBUG_PROCESS
  61 #define WITH_XSLT_DEBUG_VARIABLE
  62 #endif
  63 
  64 #define XSLT_GENERATE_HTML_DOCTYPE
  65 #ifdef XSLT_GENERATE_HTML_DOCTYPE
  66 static int xsltGetHTMLIDs(const xmlChar *version, const xmlChar **publicID,
  67               const xmlChar **systemID);
  68 #endif
  69 
  70 int xsltMaxDepth = 3000;
  71 int xsltMaxVars = 15000;
  72 
  73 /*
  74  * Useful macros
  75  */
  76 
  77 #ifndef FALSE
  78 # define FALSE (0 == 1)
  79 # define TRUE (!FALSE)
  80 #endif
  81 
  82 #define IS_BLANK_NODE(n)                        \
  83     (((n)-&gt;type == XML_TEXT_NODE) &amp;&amp; (xsltIsBlank((n)-&gt;content)))
  84 
  85 
  86 /*
  87 * Forward declarations
  88 */
  89 
  90 static xmlNsPtr
  91 xsltCopyNamespaceListInternal(xmlNodePtr node, xmlNsPtr cur);
  92 
  93 static xmlNodePtr
  94 xsltCopyTree(xsltTransformContextPtr ctxt, xmlNodePtr invocNode,
  95          xmlNodePtr node, xmlNodePtr insert, int isLRE,
  96          int topElemVisited);
  97 
  98 static void
  99 xsltApplySequenceConstructor(xsltTransformContextPtr ctxt,
 100                  xmlNodePtr contextNode, xmlNodePtr list,
 101                  xsltTemplatePtr templ);
 102 
 103 static void
 104 xsltApplyXSLTTemplate(xsltTransformContextPtr ctxt,
 105               xmlNodePtr contextNode,
 106               xmlNodePtr list,
 107               xsltTemplatePtr templ,
 108               xsltStackElemPtr withParams);
 109 
 110 /**
 111  * templPush:
 112  * @ctxt: the transformation context
 113  * @value:  the template to push on the stack
 114  *
 115  * Push a template on the stack
 116  *
 117  * Returns the new index in the stack or 0 in case of error
 118  */
 119 static int
 120 templPush(xsltTransformContextPtr ctxt, xsltTemplatePtr value)
 121 {
 122     if (ctxt-&gt;templMax == 0) {
 123         ctxt-&gt;templMax = 4;
 124         ctxt-&gt;templTab =
 125             (xsltTemplatePtr *) xmlMalloc(ctxt-&gt;templMax *
 126                                           sizeof(ctxt-&gt;templTab[0]));
 127         if (ctxt-&gt;templTab == NULL) {
 128             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 129             return (0);
 130         }
 131     }
 132     else if (ctxt-&gt;templNr &gt;= ctxt-&gt;templMax) {
 133         ctxt-&gt;templMax *= 2;
 134         ctxt-&gt;templTab =
 135             (xsltTemplatePtr *) xmlRealloc(ctxt-&gt;templTab,
 136                                            ctxt-&gt;templMax *
 137                                            sizeof(ctxt-&gt;templTab[0]));
 138         if (ctxt-&gt;templTab == NULL) {
 139             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 140             return (0);
 141         }
 142     }
 143     ctxt-&gt;templTab[ctxt-&gt;templNr] = value;
 144     ctxt-&gt;templ = value;
 145     return (ctxt-&gt;templNr++);
 146 }
 147 /**
 148  * templPop:
 149  * @ctxt: the transformation context
 150  *
 151  * Pop a template value from the stack
 152  *
 153  * Returns the stored template value
 154  */
 155 static xsltTemplatePtr
 156 templPop(xsltTransformContextPtr ctxt)
 157 {
 158     xsltTemplatePtr ret;
 159 
 160     if (ctxt-&gt;templNr &lt;= 0)
 161         return (0);
 162     ctxt-&gt;templNr--;
 163     if (ctxt-&gt;templNr &gt; 0)
 164         ctxt-&gt;templ = ctxt-&gt;templTab[ctxt-&gt;templNr - 1];
 165     else
 166         ctxt-&gt;templ = (xsltTemplatePtr) 0;
 167     ret = ctxt-&gt;templTab[ctxt-&gt;templNr];
 168     ctxt-&gt;templTab[ctxt-&gt;templNr] = 0;
 169     return (ret);
 170 }
 171 
 172 /**
 173  * xsltLocalVariablePop:
 174  * @ctxt: the transformation context
 175  * @limitNr: number of variables which should remain
 176  * @level: the depth in the xsl:template&#39;s tree
 177  *
 178  * Pops all variable values at the given @depth from the stack.
 179  *
 180  * Returns the stored variable value
 181  * **NOTE:**
 182  * This is an internal routine and should not be called by users!
 183  */
 184 void
 185 xsltLocalVariablePop(xsltTransformContextPtr ctxt, int limitNr, int level)
 186 {
 187     xsltStackElemPtr variable;
 188 
 189     if (ctxt-&gt;varsNr &lt;= 0)
 190         return;
 191 
 192     do {
 193     if (ctxt-&gt;varsNr &lt;= limitNr)
 194         break;
 195     variable = ctxt-&gt;varsTab[ctxt-&gt;varsNr - 1];
 196     if (variable-&gt;level &lt;= level)
 197         break;
 198     if (variable-&gt;level &gt;= 0)
 199         xsltFreeStackElemList(variable);
 200     ctxt-&gt;varsNr--;
 201     } while (ctxt-&gt;varsNr != 0);
 202     if (ctxt-&gt;varsNr &gt; 0)
 203         ctxt-&gt;vars = ctxt-&gt;varsTab[ctxt-&gt;varsNr - 1];
 204     else
 205         ctxt-&gt;vars = NULL;
 206 }
 207 
 208 /**
 209  * xsltTemplateParamsCleanup:
 210  *
 211  * Removes xsl:param and xsl:with-param items from the
 212  * variable-stack. Only xsl:with-param items are not freed.
 213  */
 214 static void
 215 xsltTemplateParamsCleanup(xsltTransformContextPtr ctxt)
 216 {
 217     xsltStackElemPtr param;
 218 
 219     for (; ctxt-&gt;varsNr &gt; ctxt-&gt;varsBase; ctxt-&gt;varsNr--) {
 220     param = ctxt-&gt;varsTab[ctxt-&gt;varsNr -1];
 221     /*
 222     * Free xsl:param items.
 223     * xsl:with-param items will have a level of -1 or -2.
 224     */
 225     if (param-&gt;level &gt;= 0) {
 226         xsltFreeStackElemList(param);
 227     }
 228     }
 229     if (ctxt-&gt;varsNr &gt; 0)
 230         ctxt-&gt;vars = ctxt-&gt;varsTab[ctxt-&gt;varsNr - 1];
 231     else
 232         ctxt-&gt;vars = NULL;
 233 }
 234 
 235 #ifdef WITH_PROFILER
 236 
 237 /**
 238  * profPush:
 239  * @ctxt: the transformation context
 240  * @value:  the profiling value to push on the stack
 241  *
 242  * Push a profiling value on the stack
 243  *
 244  * Returns the new index in the stack or 0 in case of error
 245  */
 246 static int
 247 profPush(xsltTransformContextPtr ctxt, long value)
 248 {
 249     if (ctxt-&gt;profMax == 0) {
 250         ctxt-&gt;profMax = 4;
 251         ctxt-&gt;profTab =
 252             (long *) xmlMalloc(ctxt-&gt;profMax * sizeof(ctxt-&gt;profTab[0]));
 253         if (ctxt-&gt;profTab == NULL) {
 254             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 255             return (0);
 256         }
 257     }
 258     else if (ctxt-&gt;profNr &gt;= ctxt-&gt;profMax) {
 259         ctxt-&gt;profMax *= 2;
 260         ctxt-&gt;profTab =
 261             (long *) xmlRealloc(ctxt-&gt;profTab,
 262                                 ctxt-&gt;profMax * sizeof(ctxt-&gt;profTab[0]));
 263         if (ctxt-&gt;profTab == NULL) {
 264             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 265             return (0);
 266         }
 267     }
 268     ctxt-&gt;profTab[ctxt-&gt;profNr] = value;
 269     ctxt-&gt;prof = value;
 270     return (ctxt-&gt;profNr++);
 271 }
 272 /**
 273  * profPop:
 274  * @ctxt: the transformation context
 275  *
 276  * Pop a profiling value from the stack
 277  *
 278  * Returns the stored profiling value
 279  */
 280 static long
 281 profPop(xsltTransformContextPtr ctxt)
 282 {
 283     long ret;
 284 
 285     if (ctxt-&gt;profNr &lt;= 0)
 286         return (0);
 287     ctxt-&gt;profNr--;
 288     if (ctxt-&gt;profNr &gt; 0)
 289         ctxt-&gt;prof = ctxt-&gt;profTab[ctxt-&gt;profNr - 1];
 290     else
 291         ctxt-&gt;prof = (long) 0;
 292     ret = ctxt-&gt;profTab[ctxt-&gt;profNr];
 293     ctxt-&gt;profTab[ctxt-&gt;profNr] = 0;
 294     return (ret);
 295 }
 296 
 297 static void
 298 profCallgraphAdd(xsltTemplatePtr templ, xsltTemplatePtr parent)
 299 {
 300     int i;
 301 
 302     if (templ-&gt;templMax == 0) {
 303         templ-&gt;templMax = 4;
 304         templ-&gt;templCalledTab =
 305             (xsltTemplatePtr *) xmlMalloc(templ-&gt;templMax *
 306                                           sizeof(templ-&gt;templCalledTab[0]));
 307         templ-&gt;templCountTab =
 308             (int *) xmlMalloc(templ-&gt;templMax *
 309                                           sizeof(templ-&gt;templCountTab[0]));
 310         if (templ-&gt;templCalledTab == NULL || templ-&gt;templCountTab == NULL) {
 311             xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
 312             return;
 313         }
 314     }
 315     else if (templ-&gt;templNr &gt;= templ-&gt;templMax) {
 316         templ-&gt;templMax *= 2;
 317         templ-&gt;templCalledTab =
 318             (xsltTemplatePtr *) xmlRealloc(templ-&gt;templCalledTab,
 319                                            templ-&gt;templMax *
 320                                            sizeof(templ-&gt;templCalledTab[0]));
 321         templ-&gt;templCountTab =
 322             (int *) xmlRealloc(templ-&gt;templCountTab,
 323                                            templ-&gt;templMax *
 324                                            sizeof(templ-&gt;templCountTab[0]));
 325         if (templ-&gt;templCalledTab == NULL || templ-&gt;templCountTab == NULL) {
 326             xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
 327             return;
 328         }
 329     }
 330 
 331     for (i = 0; i &lt; templ-&gt;templNr; i++) {
 332         if (templ-&gt;templCalledTab[i] == parent) {
 333             templ-&gt;templCountTab[i]++;
 334             break;
 335         }
 336     }
 337     if (i == templ-&gt;templNr) {
 338         /* not found, add new one */
 339         templ-&gt;templCalledTab[templ-&gt;templNr] = parent;
 340         templ-&gt;templCountTab[templ-&gt;templNr] = 1;
 341         templ-&gt;templNr++;
 342     }
 343 }
 344 
 345 #endif /* WITH_PROFILER */
 346 
 347 /**
 348  * xsltPreCompEval:
 349  * @ctxt: transform context
 350  * @node: context node
 351  * @comp: precompiled expression
 352  *
 353  * Evaluate a precompiled XPath expression.
 354  */
 355 static xmlXPathObjectPtr
 356 xsltPreCompEval(xsltTransformContextPtr ctxt, xmlNodePtr node,
 357                 xsltStylePreCompPtr comp) {
 358     xmlXPathObjectPtr res;
 359     xmlXPathContextPtr xpctxt;
 360     xmlNodePtr oldXPContextNode;
 361     xmlNsPtr *oldXPNamespaces;
 362     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
 363 
 364     xpctxt = ctxt-&gt;xpathCtxt;
 365     oldXPContextNode = xpctxt-&gt;node;
 366     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
 367     oldXPContextSize = xpctxt-&gt;contextSize;
 368     oldXPNsNr = xpctxt-&gt;nsNr;
 369     oldXPNamespaces = xpctxt-&gt;namespaces;
 370 
 371     xpctxt-&gt;node = node;
 372 #ifdef XSLT_REFACTORED
 373     if (comp-&gt;inScopeNs != NULL) {
 374         xpctxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
 375         xpctxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
 376     } else {
 377         xpctxt-&gt;namespaces = NULL;
 378         xpctxt-&gt;nsNr = 0;
 379     }
 380 #else
 381     xpctxt-&gt;namespaces = comp-&gt;nsList;
 382     xpctxt-&gt;nsNr = comp-&gt;nsNr;
 383 #endif
 384 
 385     res = xmlXPathCompiledEval(comp-&gt;comp, xpctxt);
 386 
 387     xpctxt-&gt;node = oldXPContextNode;
 388     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
 389     xpctxt-&gt;contextSize = oldXPContextSize;
 390     xpctxt-&gt;nsNr = oldXPNsNr;
 391     xpctxt-&gt;namespaces = oldXPNamespaces;
 392 
 393     return(res);
 394 }
 395 
 396 /**
 397  * xsltPreCompEvalToBoolean:
 398  * @ctxt: transform context
 399  * @node: context node
 400  * @comp: precompiled expression
 401  *
 402  * Evaluate a precompiled XPath expression as boolean.
 403  */
 404 static int
 405 xsltPreCompEvalToBoolean(xsltTransformContextPtr ctxt, xmlNodePtr node,
 406                          xsltStylePreCompPtr comp) {
 407     int res;
 408     xmlXPathContextPtr xpctxt;
 409     xmlNodePtr oldXPContextNode;
 410     xmlNsPtr *oldXPNamespaces;
 411     int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
 412 
 413     xpctxt = ctxt-&gt;xpathCtxt;
 414     oldXPContextNode = xpctxt-&gt;node;
 415     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
 416     oldXPContextSize = xpctxt-&gt;contextSize;
 417     oldXPNsNr = xpctxt-&gt;nsNr;
 418     oldXPNamespaces = xpctxt-&gt;namespaces;
 419 
 420     xpctxt-&gt;node = node;
 421 #ifdef XSLT_REFACTORED
 422     if (comp-&gt;inScopeNs != NULL) {
 423         xpctxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
 424         xpctxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
 425     } else {
 426         xpctxt-&gt;namespaces = NULL;
 427         xpctxt-&gt;nsNr = 0;
 428     }
 429 #else
 430     xpctxt-&gt;namespaces = comp-&gt;nsList;
 431     xpctxt-&gt;nsNr = comp-&gt;nsNr;
 432 #endif
 433 
 434     res = xmlXPathCompiledEvalToBoolean(comp-&gt;comp, xpctxt);
 435 
 436     xpctxt-&gt;node = oldXPContextNode;
 437     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
 438     xpctxt-&gt;contextSize = oldXPContextSize;
 439     xpctxt-&gt;nsNr = oldXPNsNr;
 440     xpctxt-&gt;namespaces = oldXPNamespaces;
 441 
 442     return(res);
 443 }
 444 
 445 /************************************************************************
 446  *                                  *
 447  *          XInclude default settings           *
 448  *                                  *
 449  ************************************************************************/
 450 
 451 static int xsltDoXIncludeDefault = 0;
 452 
 453 /**
 454  * xsltSetXIncludeDefault:
 455  * @xinclude: whether to do XInclude processing
 456  *
 457  * Set whether XInclude should be processed on document being loaded by default
 458  */
 459 void
 460 xsltSetXIncludeDefault(int xinclude) {
 461     xsltDoXIncludeDefault = (xinclude != 0);
 462 }
 463 
 464 /**
 465  * xsltGetXIncludeDefault:
 466  *
 467  * Provides the default state for XInclude processing
 468  *
 469  * Returns 0 if there is no processing 1 otherwise
 470  */
 471 int
 472 xsltGetXIncludeDefault(void) {
 473     return(xsltDoXIncludeDefault);
 474 }
 475 
 476 static unsigned long xsltDefaultTrace = (unsigned long) XSLT_TRACE_ALL;
 477 
 478 /**
 479  * xsltDebugSetDefaultTrace:
 480  * @val: tracing level mask
 481  *
 482  * Set the default debug tracing level mask
 483  */
 484 void xsltDebugSetDefaultTrace(xsltDebugTraceCodes val) {
 485     xsltDefaultTrace = val;
 486 }
 487 
 488 /**
 489  * xsltDebugGetDefaultTrace:
 490  *
 491  * Get the current default debug tracing level mask
 492  *
 493  * Returns the current default debug tracing level mask
 494  */
 495 xsltDebugTraceCodes xsltDebugGetDefaultTrace() {
 496     return xsltDefaultTrace;
 497 }
 498 
 499 /************************************************************************
 500  *                                  *
 501  *          Handling of Transformation Contexts     *
 502  *                                  *
 503  ************************************************************************/
 504 
 505 static xsltTransformCachePtr
 506 xsltTransformCacheCreate(void)
 507 {
 508     xsltTransformCachePtr ret;
 509 
 510     ret = (xsltTransformCachePtr) xmlMalloc(sizeof(xsltTransformCache));
 511     if (ret == NULL) {
 512     xsltTransformError(NULL, NULL, NULL,
 513         &quot;xsltTransformCacheCreate : malloc failed\n&quot;);
 514     return(NULL);
 515     }
 516     memset(ret, 0, sizeof(xsltTransformCache));
 517     return(ret);
 518 }
 519 
 520 static void
 521 xsltTransformCacheFree(xsltTransformCachePtr cache)
 522 {
 523     if (cache == NULL)
 524     return;
 525     /*
 526     * Free tree fragments.
 527     */
 528     if (cache-&gt;RVT) {
 529     xmlDocPtr tmp, cur = cache-&gt;RVT;
 530     while (cur) {
 531         tmp = cur;
 532         cur = (xmlDocPtr) cur-&gt;next;
 533         if (tmp-&gt;_private != NULL) {
 534         /*
 535         * Tree the document info.
 536         */
 537         xsltFreeDocumentKeys((xsltDocumentPtr) tmp-&gt;_private);
 538         xmlFree(tmp-&gt;_private);
 539         }
 540         xmlFreeDoc(tmp);
 541     }
 542     }
 543     /*
 544     * Free vars/params.
 545     */
 546     if (cache-&gt;stackItems) {
 547     xsltStackElemPtr tmp, cur = cache-&gt;stackItems;
 548     while (cur) {
 549         tmp = cur;
 550         cur = cur-&gt;next;
 551         /*
 552         * REVISIT TODO: Should be call a destruction-function
 553         * instead?
 554         */
 555         xmlFree(tmp);
 556     }
 557     }
 558     xmlFree(cache);
 559 }
 560 
 561 /**
 562  * xsltNewTransformContext:
 563  * @style:  a parsed XSLT stylesheet
 564  * @doc:  the input document
 565  *
 566  * Create a new XSLT TransformContext
 567  *
 568  * Returns the newly allocated xsltTransformContextPtr or NULL in case of error
 569  */
 570 xsltTransformContextPtr
 571 xsltNewTransformContext(xsltStylesheetPtr style, xmlDocPtr doc) {
 572     xsltTransformContextPtr cur;
 573     xsltDocumentPtr docu;
 574     int i;
 575 
 576     xsltInitGlobals();
 577 
 578     cur = (xsltTransformContextPtr) xmlMalloc(sizeof(xsltTransformContext));
 579     if (cur == NULL) {
 580     xsltTransformError(NULL, NULL, (xmlNodePtr)doc,
 581         &quot;xsltNewTransformContext : malloc failed\n&quot;);
 582     return(NULL);
 583     }
 584     memset(cur, 0, sizeof(xsltTransformContext));
 585 
 586     cur-&gt;cache = xsltTransformCacheCreate();
 587     if (cur-&gt;cache == NULL)
 588     goto internal_err;
 589     /*
 590      * setup of the dictionary must be done early as some of the
 591      * processing later like key handling may need it.
 592      */
 593     cur-&gt;dict = xmlDictCreateSub(style-&gt;dict);
 594     cur-&gt;internalized = ((style-&gt;internalized) &amp;&amp; (cur-&gt;dict != NULL));
 595 #ifdef WITH_XSLT_DEBUG
 596     xsltGenericDebug(xsltGenericDebugContext,
 597          &quot;Creating sub-dictionary from stylesheet for transformation\n&quot;);
 598 #endif
 599 
 600     /*
 601      * initialize the template stack
 602      */
 603     cur-&gt;templTab = (xsltTemplatePtr *)
 604             xmlMalloc(10 * sizeof(xsltTemplatePtr));
 605     if (cur-&gt;templTab == NULL) {
 606     xsltTransformError(NULL, NULL, (xmlNodePtr) doc,
 607         &quot;xsltNewTransformContext: out of memory\n&quot;);
 608     goto internal_err;
 609     }
 610     cur-&gt;templNr = 0;
 611     cur-&gt;templMax = 5;
 612     cur-&gt;templ = NULL;
 613     cur-&gt;maxTemplateDepth = xsltMaxDepth;
 614 
 615     /*
 616      * initialize the variables stack
 617      */
 618     cur-&gt;varsTab = (xsltStackElemPtr *)
 619             xmlMalloc(10 * sizeof(xsltStackElemPtr));
 620     if (cur-&gt;varsTab == NULL) {
 621         xmlGenericError(xmlGenericErrorContext,
 622         &quot;xsltNewTransformContext: out of memory\n&quot;);
 623     goto internal_err;
 624     }
 625     cur-&gt;varsNr = 0;
 626     cur-&gt;varsMax = 10;
 627     cur-&gt;vars = NULL;
 628     cur-&gt;varsBase = 0;
 629     cur-&gt;maxTemplateVars = xsltMaxVars;
 630 
 631     /*
 632      * the profiling stack is not initialized by default
 633      */
 634     cur-&gt;profTab = NULL;
 635     cur-&gt;profNr = 0;
 636     cur-&gt;profMax = 0;
 637     cur-&gt;prof = 0;
 638 
 639     cur-&gt;style = style;
 640     xmlXPathInit();
 641     cur-&gt;xpathCtxt = xmlXPathNewContext(doc);
 642     if (cur-&gt;xpathCtxt == NULL) {
 643     xsltTransformError(NULL, NULL, (xmlNodePtr) doc,
 644         &quot;xsltNewTransformContext : xmlXPathNewContext failed\n&quot;);
 645     goto internal_err;
 646     }
 647     /*
 648     * Create an XPath cache.
 649     */
 650     if (xmlXPathContextSetCache(cur-&gt;xpathCtxt, 1, -1, 0) == -1)
 651     goto internal_err;
 652     /*
 653      * Initialize the extras array
 654      */
 655     if (style-&gt;extrasNr != 0) {
 656     cur-&gt;extrasMax = style-&gt;extrasNr + 20;
 657     cur-&gt;extras = (xsltRuntimeExtraPtr)
 658         xmlMalloc(cur-&gt;extrasMax * sizeof(xsltRuntimeExtra));
 659     if (cur-&gt;extras == NULL) {
 660         xmlGenericError(xmlGenericErrorContext,
 661             &quot;xsltNewTransformContext: out of memory\n&quot;);
 662         goto internal_err;
 663     }
 664     cur-&gt;extrasNr = style-&gt;extrasNr;
 665     for (i = 0;i &lt; cur-&gt;extrasMax;i++) {
 666         cur-&gt;extras[i].info = NULL;
 667         cur-&gt;extras[i].deallocate = NULL;
 668         cur-&gt;extras[i].val.ptr = NULL;
 669     }
 670     } else {
 671     cur-&gt;extras = NULL;
 672     cur-&gt;extrasNr = 0;
 673     cur-&gt;extrasMax = 0;
 674     }
 675 
 676     XSLT_REGISTER_VARIABLE_LOOKUP(cur);
 677     XSLT_REGISTER_FUNCTION_LOOKUP(cur);
 678     cur-&gt;xpathCtxt-&gt;nsHash = style-&gt;nsHash;
 679     /*
 680      * Initialize the registered external modules
 681      */
 682     xsltInitCtxtExts(cur);
 683     /*
 684      * Setup document element ordering for later efficiencies
 685      * (bug 133289)
 686      */
 687     if (xslDebugStatus == XSLT_DEBUG_NONE)
 688         xmlXPathOrderDocElems(doc);
 689     /*
 690      * Must set parserOptions before calling xsltNewDocument
 691      * (bug 164530)
 692      */
 693     cur-&gt;parserOptions = XSLT_PARSE_OPTIONS;
 694     docu = xsltNewDocument(cur, doc);
 695     if (docu == NULL) {
 696     xsltTransformError(cur, NULL, (xmlNodePtr)doc,
 697         &quot;xsltNewTransformContext : xsltNewDocument failed\n&quot;);
 698     goto internal_err;
 699     }
 700     docu-&gt;main = 1;
 701     cur-&gt;document = docu;
 702     cur-&gt;inst = NULL;
 703     cur-&gt;outputFile = NULL;
 704     cur-&gt;sec = xsltGetDefaultSecurityPrefs();
 705     cur-&gt;debugStatus = xslDebugStatus;
 706     cur-&gt;traceCode = (unsigned long*) &amp;xsltDefaultTrace;
 707     cur-&gt;xinclude = xsltGetXIncludeDefault();
 708     cur-&gt;keyInitLevel = 0;
 709 
 710     return(cur);
 711 
 712 internal_err:
 713     if (cur != NULL)
 714     xsltFreeTransformContext(cur);
 715     return(NULL);
 716 }
 717 
 718 /**
 719  * xsltFreeTransformContext:
 720  * @ctxt:  an XSLT parser context
 721  *
 722  * Free up the memory allocated by @ctxt
 723  */
 724 void
 725 xsltFreeTransformContext(xsltTransformContextPtr ctxt) {
 726     if (ctxt == NULL)
 727     return;
 728 
 729     /*
 730      * Shutdown the extension modules associated to the stylesheet
 731      * used if needed.
 732      */
 733     xsltShutdownCtxtExts(ctxt);
 734 
 735     if (ctxt-&gt;xpathCtxt != NULL) {
 736     ctxt-&gt;xpathCtxt-&gt;nsHash = NULL;
 737     xmlXPathFreeContext(ctxt-&gt;xpathCtxt);
 738     }
 739     if (ctxt-&gt;templTab != NULL)
 740     xmlFree(ctxt-&gt;templTab);
 741     if (ctxt-&gt;varsTab != NULL)
 742     xmlFree(ctxt-&gt;varsTab);
 743     if (ctxt-&gt;profTab != NULL)
 744     xmlFree(ctxt-&gt;profTab);
 745     if ((ctxt-&gt;extrasNr &gt; 0) &amp;&amp; (ctxt-&gt;extras != NULL)) {
 746     int i;
 747 
 748     for (i = 0;i &lt; ctxt-&gt;extrasNr;i++) {
 749         if ((ctxt-&gt;extras[i].deallocate != NULL) &amp;&amp;
 750         (ctxt-&gt;extras[i].info != NULL))
 751         ctxt-&gt;extras[i].deallocate(ctxt-&gt;extras[i].info);
 752     }
 753     xmlFree(ctxt-&gt;extras);
 754     }
 755     xsltFreeGlobalVariables(ctxt);
 756     xsltFreeDocuments(ctxt);
 757     xsltFreeCtxtExts(ctxt);
 758     xsltFreeRVTs(ctxt);
 759     xsltTransformCacheFree(ctxt-&gt;cache);
 760     xmlDictFree(ctxt-&gt;dict);
 761 #ifdef WITH_XSLT_DEBUG
 762     xsltGenericDebug(xsltGenericDebugContext,
 763                      &quot;freeing transformation dictionary\n&quot;);
 764 #endif
 765     memset(ctxt, -1, sizeof(xsltTransformContext));
 766     xmlFree(ctxt);
 767 }
 768 
 769 /************************************************************************
 770  *                                  *
 771  *          Copy of Nodes in an XSLT fashion        *
 772  *                                  *
 773  ************************************************************************/
 774 
 775 /**
 776  * xsltAddChild:
 777  * @parent:  the parent node
 778  * @cur:  the child node
 779  *
 780  * Wrapper version of xmlAddChild with a more consistent behaviour on
 781  * error. One expect the use to be child = xsltAddChild(parent, child);
 782  * and the routine will take care of not leaking on errors or node merge
 783  *
 784  * Returns the child is successfully attached or NULL if merged or freed
 785  */
 786 static xmlNodePtr
 787 xsltAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 788    xmlNodePtr ret;
 789 
 790    if (cur == NULL)
 791        return(NULL);
 792    if (parent == NULL) {
 793        xmlFreeNode(cur);
 794        return(NULL);
 795    }
 796    ret = xmlAddChild(parent, cur);
 797 
 798    return(ret);
 799 }
 800 
 801 /**
 802  * xsltAddTextString:
 803  * @ctxt:  a XSLT process context
 804  * @target:  the text node where the text will be attached
 805  * @string:  the text string
 806  * @len:  the string length in byte
 807  *
 808  * Extend the current text node with the new string, it handles coalescing
 809  *
 810  * Returns: the text node
 811  */
 812 static xmlNodePtr
 813 xsltAddTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,
 814           const xmlChar *string, int len) {
 815     /*
 816      * optimization
 817      */
 818     if ((len &lt;= 0) || (string == NULL) || (target == NULL))
 819         return(target);
 820 
 821     if (ctxt-&gt;lasttext == target-&gt;content) {
 822         int minSize;
 823 
 824         /* Check for integer overflow accounting for NUL terminator. */
 825         if (len &gt;= INT_MAX - ctxt-&gt;lasttuse) {
 826             xsltTransformError(ctxt, NULL, target,
 827                 &quot;xsltCopyText: text allocation failed\n&quot;);
 828             return(NULL);
 829         }
 830         minSize = ctxt-&gt;lasttuse + len + 1;
 831 
 832         if (ctxt-&gt;lasttsize &lt; minSize) {
 833         xmlChar *newbuf;
 834         int size;
 835             int extra;
 836 
 837             /* Double buffer size but increase by at least 100 bytes. */
 838             extra = minSize &lt; 100 ? 100 : minSize;
 839 
 840             /* Check for integer overflow. */
 841             if (extra &gt; INT_MAX - ctxt-&gt;lasttsize) {
 842                 size = INT_MAX;
 843             }
 844             else {
 845                 size = ctxt-&gt;lasttsize + extra;
 846             }
 847 
 848         newbuf = (xmlChar *) xmlRealloc(target-&gt;content,size);
 849         if (newbuf == NULL) {
 850         xsltTransformError(ctxt, NULL, target,
 851          &quot;xsltCopyText: text allocation failed\n&quot;);
 852         return(NULL);
 853         }
 854         ctxt-&gt;lasttsize = size;
 855         ctxt-&gt;lasttext = newbuf;
 856         target-&gt;content = newbuf;
 857     }
 858     memcpy(&amp;(target-&gt;content[ctxt-&gt;lasttuse]), string, len);
 859     ctxt-&gt;lasttuse += len;
 860     target-&gt;content[ctxt-&gt;lasttuse] = 0;
 861     } else {
 862     xmlNodeAddContent(target, string);
 863     ctxt-&gt;lasttext = target-&gt;content;
 864     len = xmlStrlen(target-&gt;content);
 865     ctxt-&gt;lasttsize = len;
 866     ctxt-&gt;lasttuse = len;
 867     }
 868     return(target);
 869 }
 870 
 871 /**
 872  * xsltCopyTextString:
 873  * @ctxt:  a XSLT process context
 874  * @target:  the element where the text will be attached
 875  * @string:  the text string
 876  * @noescape:  should disable-escaping be activated for this text node.
 877  *
 878  * Adds @string to a newly created or an existent text node child of
 879  * @target.
 880  *
 881  * Returns: the text node, where the text content of @cur is copied to.
 882  *          NULL in case of API or internal errors.
 883  */
 884 xmlNodePtr
 885 xsltCopyTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,
 886                const xmlChar *string, int noescape)
 887 {
 888     xmlNodePtr copy;
 889     int len;
 890 
 891     if (string == NULL)
 892     return(NULL);
 893 
 894 #ifdef WITH_XSLT_DEBUG_PROCESS
 895     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,
 896              &quot;xsltCopyTextString: copy text %s\n&quot;,
 897              string));
 898 #endif
 899 
 900     /*
 901     * Play safe and reset the merging mechanism for every new
 902     * target node.
 903     */
 904     if ((target == NULL) || (target-&gt;children == NULL)) {
 905     ctxt-&gt;lasttext = NULL;
 906     }
 907 
 908     /* handle coalescing of text nodes here */
 909     len = xmlStrlen(string);
 910     if ((ctxt-&gt;type == XSLT_OUTPUT_XML) &amp;&amp;
 911     (ctxt-&gt;style-&gt;cdataSection != NULL) &amp;&amp;
 912     (target != NULL) &amp;&amp;
 913     (target-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 914     (((target-&gt;ns == NULL) &amp;&amp;
 915       (xmlHashLookup2(ctxt-&gt;style-&gt;cdataSection,
 916                   target-&gt;name, NULL) != NULL)) ||
 917      ((target-&gt;ns != NULL) &amp;&amp;
 918       (xmlHashLookup2(ctxt-&gt;style-&gt;cdataSection,
 919                       target-&gt;name, target-&gt;ns-&gt;href) != NULL))))
 920     {
 921     /*
 922     * Process &quot;cdata-section-elements&quot;.
 923     */
 924     if ((target-&gt;last != NULL) &amp;&amp;
 925         (target-&gt;last-&gt;type == XML_CDATA_SECTION_NODE))
 926     {
 927         return(xsltAddTextString(ctxt, target-&gt;last, string, len));
 928     }
 929     copy = xmlNewCDataBlock(ctxt-&gt;output, string, len);
 930     } else if (noescape) {
 931     /*
 932     * Process &quot;disable-output-escaping&quot;.
 933     */
 934     if ((target != NULL) &amp;&amp; (target-&gt;last != NULL) &amp;&amp;
 935         (target-&gt;last-&gt;type == XML_TEXT_NODE) &amp;&amp;
 936         (target-&gt;last-&gt;name == xmlStringTextNoenc))
 937     {
 938         return(xsltAddTextString(ctxt, target-&gt;last, string, len));
 939     }
 940     copy = xmlNewTextLen(string, len);
 941     if (copy != NULL)
 942         copy-&gt;name = xmlStringTextNoenc;
 943     } else {
 944     /*
 945     * Default processing.
 946     */
 947     if ((target != NULL) &amp;&amp; (target-&gt;last != NULL) &amp;&amp;
 948         (target-&gt;last-&gt;type == XML_TEXT_NODE) &amp;&amp;
 949         (target-&gt;last-&gt;name == xmlStringText)) {
 950         return(xsltAddTextString(ctxt, target-&gt;last, string, len));
 951     }
 952     copy = xmlNewTextLen(string, len);
 953     }
 954     if (copy != NULL &amp;&amp; target != NULL)
 955     copy = xsltAddChild(target, copy);
 956     if (copy != NULL) {
 957     ctxt-&gt;lasttext = copy-&gt;content;
 958     ctxt-&gt;lasttsize = len;
 959     ctxt-&gt;lasttuse = len;
 960     } else {
 961     xsltTransformError(ctxt, NULL, target,
 962              &quot;xsltCopyTextString: text copy failed\n&quot;);
 963     ctxt-&gt;lasttext = NULL;
 964     }
 965     return(copy);
 966 }
 967 
 968 /**
 969  * xsltCopyText:
 970  * @ctxt:  a XSLT process context
 971  * @target:  the element where the text will be attached
 972  * @cur:  the text or CDATA node
 973  * @interned:  the string is in the target doc dictionary
 974  *
 975  * Copy the text content of @cur and append it to @target&#39;s children.
 976  *
 977  * Returns: the text node, where the text content of @cur is copied to.
 978  *          NULL in case of API or internal errors.
 979  */
 980 static xmlNodePtr
 981 xsltCopyText(xsltTransformContextPtr ctxt, xmlNodePtr target,
 982          xmlNodePtr cur, int interned)
 983 {
 984     xmlNodePtr copy;
 985 
 986     if ((cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 987     (cur-&gt;type != XML_CDATA_SECTION_NODE))
 988     return(NULL);
 989     if (cur-&gt;content == NULL)
 990     return(NULL);
 991 
 992 #ifdef WITH_XSLT_DEBUG_PROCESS
 993     if (cur-&gt;type == XML_CDATA_SECTION_NODE) {
 994     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,
 995              &quot;xsltCopyText: copy CDATA text %s\n&quot;,
 996              cur-&gt;content));
 997     } else if (cur-&gt;name == xmlStringTextNoenc) {
 998     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,
 999              &quot;xsltCopyText: copy unescaped text %s\n&quot;,
1000              cur-&gt;content));
1001     } else {
1002     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,
1003              &quot;xsltCopyText: copy text %s\n&quot;,
1004              cur-&gt;content));
1005     }
1006 #endif
1007 
1008     /*
1009     * Play save and reset the merging mechanism for every new
1010     * target node.
1011     */
1012     if ((target == NULL) || (target-&gt;children == NULL)) {
1013     ctxt-&gt;lasttext = NULL;
1014     }
1015 
1016     if ((ctxt-&gt;style-&gt;cdataSection != NULL) &amp;&amp;
1017     (ctxt-&gt;type == XSLT_OUTPUT_XML) &amp;&amp;
1018     (target != NULL) &amp;&amp;
1019     (target-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1020     (((target-&gt;ns == NULL) &amp;&amp;
1021       (xmlHashLookup2(ctxt-&gt;style-&gt;cdataSection,
1022                   target-&gt;name, NULL) != NULL)) ||
1023      ((target-&gt;ns != NULL) &amp;&amp;
1024       (xmlHashLookup2(ctxt-&gt;style-&gt;cdataSection,
1025                       target-&gt;name, target-&gt;ns-&gt;href) != NULL))))
1026     {
1027     /*
1028     * Process &quot;cdata-section-elements&quot;.
1029     */
1030     /*
1031     * OPTIMIZE TODO: xsltCopyText() is also used for attribute content.
1032     */
1033     /*
1034     * TODO: Since this doesn&#39;t merge adjacent CDATA-section nodes,
1035     * we&#39;ll get: &lt;![CDATA[x]]&gt;&lt;!CDATA[y]]&gt;.
1036     * TODO: Reported in #321505.
1037     */
1038     if ((target-&gt;last != NULL) &amp;&amp;
1039          (target-&gt;last-&gt;type == XML_CDATA_SECTION_NODE))
1040     {
1041         /*
1042         * Append to existing CDATA-section node.
1043         */
1044         copy = xsltAddTextString(ctxt, target-&gt;last, cur-&gt;content,
1045         xmlStrlen(cur-&gt;content));
1046         goto exit;
1047     } else {
1048         unsigned int len;
1049 
1050         len = xmlStrlen(cur-&gt;content);
1051         copy = xmlNewCDataBlock(ctxt-&gt;output, cur-&gt;content, len);
1052         if (copy == NULL)
1053         goto exit;
1054         ctxt-&gt;lasttext = copy-&gt;content;
1055         ctxt-&gt;lasttsize = len;
1056         ctxt-&gt;lasttuse = len;
1057     }
1058     } else if ((target != NULL) &amp;&amp;
1059     (target-&gt;last != NULL) &amp;&amp;
1060     /* both escaped or both non-escaped text-nodes */
1061     (((target-&gt;last-&gt;type == XML_TEXT_NODE) &amp;&amp;
1062     (target-&gt;last-&gt;name == cur-&gt;name)) ||
1063         /* non-escaped text nodes and CDATA-section nodes */
1064     (((target-&gt;last-&gt;type == XML_CDATA_SECTION_NODE) &amp;&amp;
1065     (cur-&gt;name == xmlStringTextNoenc)))))
1066     {
1067     /*
1068      * we are appending to an existing text node
1069      */
1070     copy = xsltAddTextString(ctxt, target-&gt;last, cur-&gt;content,
1071         xmlStrlen(cur-&gt;content));
1072     goto exit;
1073     } else if ((interned) &amp;&amp; (target != NULL) &amp;&amp;
1074     (target-&gt;doc != NULL) &amp;&amp;
1075     (target-&gt;doc-&gt;dict == ctxt-&gt;dict))
1076     {
1077     /*
1078     * TODO: DO we want to use this also for &quot;text&quot; output?
1079     */
1080         copy = xmlNewTextLen(NULL, 0);
1081     if (copy == NULL)
1082         goto exit;
1083     if (cur-&gt;name == xmlStringTextNoenc)
1084         copy-&gt;name = xmlStringTextNoenc;
1085 
1086     /*
1087      * Must confirm that content is in dict (bug 302821)
1088      * TODO: This check should be not needed for text coming
1089      * from the stylesheets
1090      */
1091     if (xmlDictOwns(ctxt-&gt;dict, cur-&gt;content))
1092         copy-&gt;content = cur-&gt;content;
1093     else {
1094         if ((copy-&gt;content = xmlStrdup(cur-&gt;content)) == NULL)
1095         return NULL;
1096     }
1097 
1098     ctxt-&gt;lasttext = NULL;
1099     } else {
1100         /*
1101      * normal processing. keep counters to extend the text node
1102      * in xsltAddTextString if needed.
1103      */
1104         unsigned int len;
1105 
1106     len = xmlStrlen(cur-&gt;content);
1107     copy = xmlNewTextLen(cur-&gt;content, len);
1108     if (copy == NULL)
1109         goto exit;
1110     if (cur-&gt;name == xmlStringTextNoenc)
1111         copy-&gt;name = xmlStringTextNoenc;
1112     ctxt-&gt;lasttext = copy-&gt;content;
1113     ctxt-&gt;lasttsize = len;
1114     ctxt-&gt;lasttuse = len;
1115     }
1116     if (copy != NULL) {
1117     if (target != NULL) {
1118         copy-&gt;doc = target-&gt;doc;
1119         /*
1120         * MAYBE TODO: Maybe we should reset the ctxt-&gt;lasttext here
1121         *  to ensure that the optimized text-merging mechanism
1122         *  won&#39;t interfere with normal node-merging in any case.
1123         */
1124         copy = xsltAddChild(target, copy);
1125     }
1126     } else {
1127     xsltTransformError(ctxt, NULL, target,
1128              &quot;xsltCopyText: text copy failed\n&quot;);
1129     }
1130 
1131 exit:
1132     if ((copy == NULL) || (copy-&gt;content == NULL)) {
1133     xsltTransformError(ctxt, NULL, target,
1134         &quot;Internal error in xsltCopyText(): &quot;
1135         &quot;Failed to copy the string.\n&quot;);
1136     ctxt-&gt;state = XSLT_STATE_STOPPED;
1137     }
1138     return(copy);
1139 }
1140 
1141 /**
1142  * xsltShallowCopyAttr:
1143  * @ctxt:  a XSLT process context
1144  * @invocNode: responsible node in the stylesheet; used for error reports
1145  * @target:  the element where the attribute will be grafted
1146  * @attr: the attribute to be copied
1147  *
1148  * Do a copy of an attribute.
1149  * Called by:
1150  *  - xsltCopyTree()
1151  *  - xsltCopyOf()
1152  *  - xsltCopy()
1153  *
1154  * Returns: a new xmlAttrPtr, or NULL in case of error.
1155  */
1156 static xmlAttrPtr
1157 xsltShallowCopyAttr(xsltTransformContextPtr ctxt, xmlNodePtr invocNode,
1158          xmlNodePtr target, xmlAttrPtr attr)
1159 {
1160     xmlAttrPtr copy;
1161     xmlChar *value;
1162 
1163     if (attr == NULL)
1164     return(NULL);
1165 
1166     if (target-&gt;type != XML_ELEMENT_NODE) {
1167     xsltTransformError(ctxt, NULL, invocNode,
1168         &quot;Cannot add an attribute node to a non-element node.\n&quot;);
1169     return(NULL);
1170     }
1171 
1172     if (target-&gt;children != NULL) {
1173     xsltTransformError(ctxt, NULL, invocNode,
1174         &quot;Attribute nodes must be added before &quot;
1175         &quot;any child nodes to an element.\n&quot;);
1176     return(NULL);
1177     }
1178 
1179     value = xmlNodeListGetString(attr-&gt;doc, attr-&gt;children, 1);
1180     if (attr-&gt;ns != NULL) {
1181     xmlNsPtr ns;
1182 
1183     ns = xsltGetSpecialNamespace(ctxt, invocNode,
1184         attr-&gt;ns-&gt;href, attr-&gt;ns-&gt;prefix, target);
1185     if (ns == NULL) {
1186         xsltTransformError(ctxt, NULL, invocNode,
1187         &quot;Namespace fixup error: Failed to acquire an in-scope &quot;
1188         &quot;namespace binding of the copied attribute &#39;{%s}%s&#39;.\n&quot;,
1189         attr-&gt;ns-&gt;href, attr-&gt;name);
1190         /*
1191         * TODO: Should we just stop here?
1192         */
1193     }
1194     /*
1195     * Note that xmlSetNsProp() will take care of duplicates
1196     * and assigns the new namespace even to a duplicate.
1197     */
1198     copy = xmlSetNsProp(target, ns, attr-&gt;name, value);
1199     } else {
1200     copy = xmlSetNsProp(target, NULL, attr-&gt;name, value);
1201     }
1202     if (value != NULL)
1203     xmlFree(value);
1204 
1205     if (copy == NULL)
1206     return(NULL);
1207 
1208 #if 0
1209     /*
1210     * NOTE: This was optimized according to bug #342695.
1211     * TODO: Can this further be optimized, if source and target
1212     *  share the same dict and attr-&gt;children is just 1 text node
1213     *  which is in the dict? How probable is such a case?
1214     */
1215     /*
1216     * TODO: Do we need to create an empty text node if the value
1217     *  is the empty string?
1218     */
1219     value = xmlNodeListGetString(attr-&gt;doc, attr-&gt;children, 1);
1220     if (value != NULL) {
1221     txtNode = xmlNewDocText(target-&gt;doc, NULL);
1222     if (txtNode == NULL)
1223         return(NULL);
1224     if ((target-&gt;doc != NULL) &amp;&amp;
1225         (target-&gt;doc-&gt;dict != NULL))
1226     {
1227         txtNode-&gt;content =
1228         (xmlChar *) xmlDictLookup(target-&gt;doc-&gt;dict,
1229             BAD_CAST value, -1);
1230         xmlFree(value);
1231     } else
1232         txtNode-&gt;content = value;
1233     copy-&gt;children = txtNode;
1234     }
1235 #endif
1236 
1237     return(copy);
1238 }
1239 
1240 /**
1241  * xsltCopyAttrListNoOverwrite:
1242  * @ctxt:  a XSLT process context
1243  * @invocNode: responsible node in the stylesheet; used for error reports
1244  * @target:  the element where the new attributes will be grafted
1245  * @attr:  the first attribute in the list to be copied
1246  *
1247  * Copies a list of attribute nodes, starting with @attr, over to the
1248  * @target element node.
1249  *
1250  * Called by:
1251  *  - xsltCopyTree()
1252  *
1253  * Returns 0 on success and -1 on errors and internal errors.
1254  */
1255 static int
1256 xsltCopyAttrListNoOverwrite(xsltTransformContextPtr ctxt,
1257                 xmlNodePtr invocNode,
1258                 xmlNodePtr target, xmlAttrPtr attr)
1259 {
1260     xmlAttrPtr copy;
1261     xmlNsPtr origNs = NULL, copyNs = NULL;
1262     xmlChar *value;
1263 
1264     /*
1265     * Don&#39;t use xmlCopyProp() here, since it will try to
1266     * reconciliate namespaces.
1267     */
1268     while (attr != NULL) {
1269     /*
1270     * Find a namespace node in the tree of @target.
1271     * Avoid searching for the same ns.
1272     */
1273     if (attr-&gt;ns != origNs) {
1274         origNs = attr-&gt;ns;
1275         if (attr-&gt;ns != NULL) {
1276         copyNs = xsltGetSpecialNamespace(ctxt, invocNode,
1277             attr-&gt;ns-&gt;href, attr-&gt;ns-&gt;prefix, target);
1278         if (copyNs == NULL)
1279             return(-1);
1280         } else
1281         copyNs = NULL;
1282     }
1283     /*
1284      * If attribute has a value, we need to copy it (watching out
1285      * for possible entities)
1286      */
1287     if ((attr-&gt;children) &amp;&amp; (attr-&gt;children-&gt;type == XML_TEXT_NODE) &amp;&amp;
1288             (attr-&gt;children-&gt;next == NULL)) {
1289             copy = xmlNewNsProp(target, copyNs, attr-&gt;name,
1290                                 attr-&gt;children-&gt;content);
1291         } else if (attr-&gt;children != NULL) {
1292         value = xmlNodeListGetString(attr-&gt;doc, attr-&gt;children, 1);
1293             copy = xmlNewNsProp(target, copyNs, attr-&gt;name, BAD_CAST value);
1294         xmlFree(value);
1295         } else {
1296             copy = xmlNewNsProp(target, copyNs, attr-&gt;name, NULL);
1297         }
1298 
1299     if (copy == NULL)
1300         return(-1);
1301 
1302     attr = attr-&gt;next;
1303     }
1304     return(0);
1305 }
1306 
1307 /**
1308  * xsltShallowCopyElem:
1309  * @ctxt:  the XSLT process context
1310  * @node:  the element node in the source tree
1311  *         or the Literal Result Element
1312  * @insert:  the parent in the result tree
1313  * @isLRE: if @node is a Literal Result Element
1314  *
1315  * Make a copy of the element node @node
1316  * and insert it as last child of @insert.
1317  *
1318  * URGENT TODO: The problem with this one (for the non-refactored code)
1319  * is that it is used for both, Literal Result Elements *and*
1320  * copying input nodes.
1321  *
1322  * BIG NOTE: This is only called for XML_ELEMENT_NODEs.
1323  *
1324  * Called from:
1325  *   xsltApplySequenceConstructor()
1326  *    (for Literal Result Elements - which is a problem)
1327  *   xsltCopy() (for shallow-copying elements via xsl:copy)
1328  *
1329  * Returns a pointer to the new node, or NULL in case of error
1330  */
1331 static xmlNodePtr
1332 xsltShallowCopyElem(xsltTransformContextPtr ctxt, xmlNodePtr node,
1333             xmlNodePtr insert, int isLRE)
1334 {
1335     xmlNodePtr copy;
1336 
1337     if ((node-&gt;type == XML_DTD_NODE) || (insert == NULL))
1338     return(NULL);
1339     if ((node-&gt;type == XML_TEXT_NODE) ||
1340     (node-&gt;type == XML_CDATA_SECTION_NODE))
1341     return(xsltCopyText(ctxt, insert, node, 0));
1342 
1343     copy = xmlDocCopyNode(node, insert-&gt;doc, 0);
1344     if (copy != NULL) {
1345     copy-&gt;doc = ctxt-&gt;output;
1346     copy = xsltAddChild(insert, copy);
1347         if (copy == NULL) {
1348              xsltTransformError(ctxt, NULL, node,
1349                 &quot;xsltShallowCopyElem: copy failed\n&quot;);
1350              return (copy);
1351         }
1352 
1353     if (node-&gt;type == XML_ELEMENT_NODE) {
1354         /*
1355          * Add namespaces as they are needed
1356          */
1357         if (node-&gt;nsDef != NULL) {
1358         /*
1359         * TODO: Remove the LRE case in the refactored code
1360         * gets enabled.
1361         */
1362         if (isLRE)
1363             xsltCopyNamespaceList(ctxt, copy, node-&gt;nsDef);
1364         else
1365             xsltCopyNamespaceListInternal(copy, node-&gt;nsDef);
1366         }
1367 
1368         /*
1369         * URGENT TODO: The problem with this is that it does not
1370         *  copy over all namespace nodes in scope.
1371         *  The damn thing about this is, that we would need to
1372         *  use the xmlGetNsList(), for every single node; this is
1373         *  also done in xsltCopyTree(), but only for the top node.
1374         */
1375         if (node-&gt;ns != NULL) {
1376         if (isLRE) {
1377             /*
1378             * REVISIT TODO: Since the non-refactored code still does
1379             *  ns-aliasing, we need to call xsltGetNamespace() here.
1380             *  Remove this when ready.
1381             */
1382             copy-&gt;ns = xsltGetNamespace(ctxt, node, node-&gt;ns, copy);
1383         } else {
1384             copy-&gt;ns = xsltGetSpecialNamespace(ctxt,
1385             node, node-&gt;ns-&gt;href, node-&gt;ns-&gt;prefix, copy);
1386 
1387         }
1388         } else if ((insert-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1389                (insert-&gt;ns != NULL))
1390         {
1391         /*
1392         * &quot;Undeclare&quot; the default namespace.
1393         */
1394         xsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);
1395         }
1396     }
1397     } else {
1398     xsltTransformError(ctxt, NULL, node,
1399         &quot;xsltShallowCopyElem: copy %s failed\n&quot;, node-&gt;name);
1400     }
1401     return(copy);
1402 }
1403 
1404 /**
1405  * xsltCopyTreeList:
1406  * @ctxt:  a XSLT process context
1407  * @invocNode: responsible node in the stylesheet; used for error reports
1408  * @list:  the list of element nodes in the source tree.
1409  * @insert:  the parent in the result tree.
1410  * @isLRE:  is this a literal result element list
1411  * @topElemVisited: indicates if a top-most element was already processed
1412  *
1413  * Make a copy of the full list of tree @list
1414  * and insert it as last children of @insert
1415  *
1416  * NOTE: Not to be used for Literal Result Elements.
1417  *
1418  * Used by:
1419  *  - xsltCopyOf()
1420  *
1421  * Returns a pointer to the new list, or NULL in case of error
1422  */
1423 static xmlNodePtr
1424 xsltCopyTreeList(xsltTransformContextPtr ctxt, xmlNodePtr invocNode,
1425          xmlNodePtr list,
1426          xmlNodePtr insert, int isLRE, int topElemVisited)
1427 {
1428     xmlNodePtr copy, ret = NULL;
1429 
1430     while (list != NULL) {
1431     copy = xsltCopyTree(ctxt, invocNode,
1432         list, insert, isLRE, topElemVisited);
1433     if (copy != NULL) {
1434         if (ret == NULL) {
1435         ret = copy;
1436         }
1437     }
1438     list = list-&gt;next;
1439     }
1440     return(ret);
1441 }
1442 
1443 /**
1444  * xsltCopyNamespaceListInternal:
1445  * @node:  the target node
1446  * @cur:  the first namespace
1447  *
1448  * Do a copy of a namespace list. If @node is non-NULL the
1449  * new namespaces are added automatically.
1450  * Called by:
1451  *   xsltCopyTree()
1452  *
1453  * QUESTION: What is the exact difference between this function
1454  *  and xsltCopyNamespaceList() in &quot;namespaces.c&quot;?
1455  * ANSWER: xsltCopyNamespaceList() tries to apply ns-aliases.
1456  *
1457  * Returns: a new xmlNsPtr, or NULL in case of error.
1458  */
1459 static xmlNsPtr
1460 xsltCopyNamespaceListInternal(xmlNodePtr elem, xmlNsPtr ns) {
1461     xmlNsPtr ret = NULL;
1462     xmlNsPtr p = NULL, q, luNs;
1463 
1464     if (ns == NULL)
1465     return(NULL);
1466     /*
1467      * One can add namespaces only on element nodes
1468      */
1469     if ((elem != NULL) &amp;&amp; (elem-&gt;type != XML_ELEMENT_NODE))
1470     elem = NULL;
1471 
1472     do {
1473     if (ns-&gt;type != XML_NAMESPACE_DECL)
1474         break;
1475     /*
1476      * Avoid duplicating namespace declarations on the tree.
1477      */
1478     if (elem != NULL) {
1479         if ((elem-&gt;ns != NULL) &amp;&amp;
1480         xmlStrEqual(elem-&gt;ns-&gt;prefix, ns-&gt;prefix) &amp;&amp;
1481         xmlStrEqual(elem-&gt;ns-&gt;href, ns-&gt;href))
1482         {
1483         ns = ns-&gt;next;
1484         continue;
1485         }
1486         luNs = xmlSearchNs(elem-&gt;doc, elem, ns-&gt;prefix);
1487         if ((luNs != NULL) &amp;&amp; (xmlStrEqual(luNs-&gt;href, ns-&gt;href)))
1488         {
1489         ns = ns-&gt;next;
1490         continue;
1491         }
1492     }
1493     q = xmlNewNs(elem, ns-&gt;href, ns-&gt;prefix);
1494     if (p == NULL) {
1495         ret = p = q;
1496     } else if (q != NULL) {
1497         p-&gt;next = q;
1498         p = q;
1499     }
1500     ns = ns-&gt;next;
1501     } while (ns != NULL);
1502     return(ret);
1503 }
1504 
1505 /**
1506  * xsltShallowCopyNsNode:
1507  * @ctxt:  the XSLT transformation context
1508  * @invocNode: responsible node in the stylesheet; used for error reports
1509  * @insert:  the target element node in the result tree
1510  * @ns: the namespace node
1511  *
1512  * This is used for copying ns-nodes with xsl:copy-of and xsl:copy.
1513  *
1514  * Returns a new/existing ns-node, or NULL.
1515  */
1516 static xmlNsPtr
1517 xsltShallowCopyNsNode(xsltTransformContextPtr ctxt,
1518               xmlNodePtr invocNode,
1519               xmlNodePtr insert,
1520               xmlNsPtr ns)
1521 {
1522     /*
1523      * TODO: Contrary to header comments, this is declared as int.
1524      * be modified to return a node pointer, or NULL if any error
1525      */
1526     xmlNsPtr tmpns;
1527 
1528     if ((insert == NULL) || (insert-&gt;type != XML_ELEMENT_NODE))
1529     return(NULL);
1530 
1531     if (insert-&gt;children != NULL) {
1532     xsltTransformError(ctxt, NULL, invocNode,
1533         &quot;Namespace nodes must be added before &quot;
1534         &quot;any child nodes are added to an element.\n&quot;);
1535     return(NULL);
1536     }
1537     /*
1538      * BIG NOTE: Xalan-J simply overwrites any ns-decls with
1539      * an equal prefix. We definitively won&#39;t do that.
1540      *
1541      * MSXML 4.0 and the .NET ignores ns-decls for which an
1542      * equal prefix is already in use.
1543      *
1544      * Saxon raises an error like:
1545      * &quot;net.sf.saxon.xpath.DynamicError: Cannot create two namespace
1546      * nodes with the same name&quot;.
1547      *
1548      * NOTE: We&#39;ll currently follow MSXML here.
1549      * REVISIT TODO: Check if it&#39;s better to follow Saxon here.
1550      */
1551     if (ns-&gt;prefix == NULL) {
1552     /*
1553     * If we are adding ns-nodes to an element using e.g.
1554     * &lt;xsl:copy-of select=&quot;/foo/namespace::*&quot;&gt;, then we need
1555     * to ensure that we don&#39;t incorrectly declare a default
1556     * namespace on an element in no namespace, which otherwise
1557     * would move the element incorrectly into a namespace, if
1558     * the node tree is serialized.
1559     */
1560     if (insert-&gt;ns == NULL)
1561         goto occupied;
1562     } else if ((ns-&gt;prefix[0] == &#39;x&#39;) &amp;&amp;
1563     xmlStrEqual(ns-&gt;prefix, BAD_CAST &quot;xml&quot;))
1564     {
1565     /*
1566     * The XML namespace is built in.
1567     */
1568     return(NULL);
1569     }
1570 
1571     if (insert-&gt;nsDef != NULL) {
1572     tmpns = insert-&gt;nsDef;
1573     do {
1574         if ((tmpns-&gt;prefix == NULL) == (ns-&gt;prefix == NULL)) {
1575         if ((tmpns-&gt;prefix == ns-&gt;prefix) ||
1576             xmlStrEqual(tmpns-&gt;prefix, ns-&gt;prefix))
1577         {
1578             /*
1579             * Same prefix.
1580             */
1581             if (xmlStrEqual(tmpns-&gt;href, ns-&gt;href))
1582             return(NULL);
1583             goto occupied;
1584         }
1585         }
1586         tmpns = tmpns-&gt;next;
1587     } while (tmpns != NULL);
1588     }
1589     tmpns = xmlSearchNs(insert-&gt;doc, insert, ns-&gt;prefix);
1590     if ((tmpns != NULL) &amp;&amp; xmlStrEqual(tmpns-&gt;href, ns-&gt;href))
1591     return(NULL);
1592     /*
1593     * Declare a new namespace.
1594     * TODO: The problem (wrt efficiency) with this xmlNewNs() is
1595     * that it will again search the already declared namespaces
1596     * for a duplicate :-/
1597     */
1598     return(xmlNewNs(insert, ns-&gt;href, ns-&gt;prefix));
1599 
1600 occupied:
1601     /*
1602     * TODO: We could as well raise an error here (like Saxon does),
1603     * or at least generate a warning.
1604     */
1605     return(NULL);
1606 }
1607 
1608 /**
1609  * xsltCopyTree:
1610  * @ctxt:  the XSLT transformation context
1611  * @invocNode: responsible node in the stylesheet; used for error reports
1612  * @node:  the element node in the source tree
1613  * @insert:  the parent in the result tree
1614  * @isLRE:  indicates if @node is a Literal Result Element
1615  * @topElemVisited: indicates if a top-most element was already processed
1616  *
1617  * Make a copy of the full tree under the element node @node
1618  * and insert it as last child of @insert
1619  *
1620  * NOTE: Not to be used for Literal Result Elements.
1621  *
1622  * Used by:
1623  *  - xsltCopyOf()
1624  *
1625  * Returns a pointer to the new tree, or NULL in case of error
1626  */
1627 static xmlNodePtr
1628 xsltCopyTree(xsltTransformContextPtr ctxt, xmlNodePtr invocNode,
1629          xmlNodePtr node, xmlNodePtr insert, int isLRE,
1630          int topElemVisited)
1631 {
1632     xmlNodePtr copy;
1633 
1634     if (node == NULL)
1635     return(NULL);
1636     switch (node-&gt;type) {
1637         case XML_ELEMENT_NODE:
1638         case XML_ENTITY_REF_NODE:
1639         case XML_ENTITY_NODE:
1640         case XML_PI_NODE:
1641         case XML_COMMENT_NODE:
1642         case XML_DOCUMENT_NODE:
1643         case XML_HTML_DOCUMENT_NODE:
1644 #ifdef LIBXML_DOCB_ENABLED
1645         case XML_DOCB_DOCUMENT_NODE:
1646 #endif
1647         break;
1648         case XML_TEXT_NODE: {
1649         int noenc = (node-&gt;name == xmlStringTextNoenc);
1650         return(xsltCopyTextString(ctxt, insert, node-&gt;content, noenc));
1651         }
1652         case XML_CDATA_SECTION_NODE:
1653         return(xsltCopyTextString(ctxt, insert, node-&gt;content, 0));
1654         case XML_ATTRIBUTE_NODE:
1655         return((xmlNodePtr)
1656         xsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));
1657         case XML_NAMESPACE_DECL:
1658         return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,
1659         insert, (xmlNsPtr) node));
1660 
1661         case XML_DOCUMENT_TYPE_NODE:
1662         case XML_DOCUMENT_FRAG_NODE:
1663         case XML_NOTATION_NODE:
1664         case XML_DTD_NODE:
1665         case XML_ELEMENT_DECL:
1666         case XML_ATTRIBUTE_DECL:
1667         case XML_ENTITY_DECL:
1668         case XML_XINCLUDE_START:
1669         case XML_XINCLUDE_END:
1670             return(NULL);
1671     }
1672     if (XSLT_IS_RES_TREE_FRAG(node)) {
1673     if (node-&gt;children != NULL)
1674         copy = xsltCopyTreeList(ctxt, invocNode,
1675         node-&gt;children, insert, 0, 0);
1676     else
1677         copy = NULL;
1678     return(copy);
1679     }
1680     copy = xmlDocCopyNode(node, insert-&gt;doc, 0);
1681     if (copy != NULL) {
1682     copy-&gt;doc = ctxt-&gt;output;
1683     copy = xsltAddChild(insert, copy);
1684         if (copy == NULL) {
1685             xsltTransformError(ctxt, NULL, invocNode,
1686             &quot;xsltCopyTree: Copying of &#39;%s&#39; failed.\n&quot;, node-&gt;name);
1687             return (copy);
1688         }
1689     /*
1690      * The node may have been coalesced into another text node.
1691      */
1692     if (insert-&gt;last != copy)
1693         return(insert-&gt;last);
1694     copy-&gt;next = NULL;
1695 
1696     if (node-&gt;type == XML_ELEMENT_NODE) {
1697         /*
1698         * Copy in-scope namespace nodes.
1699         *
1700         * REVISIT: Since we try to reuse existing in-scope ns-decls by
1701         *  using xmlSearchNsByHref(), this will eventually change
1702         *  the prefix of an original ns-binding; thus it might
1703         *  break QNames in element/attribute content.
1704         * OPTIMIZE TODO: If we had a xmlNsPtr * on the transformation
1705         *  context, plus a ns-lookup function, which writes directly
1706         *  to a given list, then we wouldn&#39;t need to create/free the
1707         *  nsList every time.
1708         */
1709         if ((topElemVisited == 0) &amp;&amp;
1710         (node-&gt;parent != NULL) &amp;&amp;
1711         (node-&gt;parent-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
1712         (node-&gt;parent-&gt;type != XML_HTML_DOCUMENT_NODE))
1713         {
1714         xmlNsPtr *nsList, *curns, ns;
1715 
1716         /*
1717         * If this is a top-most element in a tree to be
1718         * copied, then we need to ensure that all in-scope
1719         * namespaces are copied over. For nodes deeper in the
1720         * tree, it is sufficient to reconcile only the ns-decls
1721         * (node-&gt;nsDef entries).
1722         */
1723 
1724         nsList = xmlGetNsList(node-&gt;doc, node);
1725         if (nsList != NULL) {
1726             curns = nsList;
1727             do {
1728             /*
1729             * Search by prefix first in order to break as less
1730             * QNames in element/attribute content as possible.
1731             */
1732             ns = xmlSearchNs(insert-&gt;doc, insert,
1733                 (*curns)-&gt;prefix);
1734 
1735             if ((ns == NULL) ||
1736                 (! xmlStrEqual(ns-&gt;href, (*curns)-&gt;href)))
1737             {
1738                 ns = NULL;
1739                 /*
1740                 * Search by namespace name.
1741                 * REVISIT TODO: Currently disabled.
1742                 */
1743 #if 0
1744                 ns = xmlSearchNsByHref(insert-&gt;doc,
1745                 insert, (*curns)-&gt;href);
1746 #endif
1747             }
1748             if (ns == NULL) {
1749                 /*
1750                 * Declare a new namespace on the copied element.
1751                 */
1752                 ns = xmlNewNs(copy, (*curns)-&gt;href,
1753                 (*curns)-&gt;prefix);
1754                 /* TODO: Handle errors */
1755             }
1756             if (node-&gt;ns == *curns) {
1757                 /*
1758                 * If this was the original&#39;s namespace then set
1759                 * the generated counterpart on the copy.
1760                 */
1761                 copy-&gt;ns = ns;
1762             }
1763             curns++;
1764             } while (*curns != NULL);
1765             xmlFree(nsList);
1766         }
1767         } else if (node-&gt;nsDef != NULL) {
1768         /*
1769         * Copy over all namespace declaration attributes.
1770         */
1771         if (node-&gt;nsDef != NULL) {
1772             if (isLRE)
1773             xsltCopyNamespaceList(ctxt, copy, node-&gt;nsDef);
1774             else
1775             xsltCopyNamespaceListInternal(copy, node-&gt;nsDef);
1776         }
1777         }
1778         /*
1779         * Set the namespace.
1780         */
1781         if (node-&gt;ns != NULL) {
1782         if (copy-&gt;ns == NULL) {
1783             /*
1784             * This will map copy-&gt;ns to one of the newly created
1785             * in-scope ns-decls, OR create a new ns-decl on @copy.
1786             */
1787             copy-&gt;ns = xsltGetSpecialNamespace(ctxt, invocNode,
1788             node-&gt;ns-&gt;href, node-&gt;ns-&gt;prefix, copy);
1789         }
1790         } else if ((insert-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1791         (insert-&gt;ns != NULL))
1792         {
1793         /*
1794         * &quot;Undeclare&quot; the default namespace on @copy with xmlns=&quot;&quot;.
1795         */
1796         xsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);
1797         }
1798         /*
1799         * Copy attribute nodes.
1800         */
1801         if (node-&gt;properties != NULL) {
1802         xsltCopyAttrListNoOverwrite(ctxt, invocNode,
1803             copy, node-&gt;properties);
1804         }
1805         if (topElemVisited == 0)
1806         topElemVisited = 1;
1807     }
1808     /*
1809     * Copy the subtree.
1810     */
1811     if (node-&gt;children != NULL) {
1812         xsltCopyTreeList(ctxt, invocNode,
1813         node-&gt;children, copy, isLRE, topElemVisited);
1814     }
1815     } else {
1816     xsltTransformError(ctxt, NULL, invocNode,
1817         &quot;xsltCopyTree: Copying of &#39;%s&#39; failed.\n&quot;, node-&gt;name);
1818     }
1819     return(copy);
1820 }
1821 
1822 /************************************************************************
1823  *                                  *
1824  *      Error/fallback processing               *
1825  *                                  *
1826  ************************************************************************/
1827 
1828 /**
1829  * xsltApplyFallbacks:
1830  * @ctxt:  a XSLT process context
1831  * @node:  the node in the source tree.
1832  * @inst:  the node generating the error
1833  *
1834  * Process possible xsl:fallback nodes present under @inst
1835  *
1836  * Returns the number of xsl:fallback element found and processed
1837  */
1838 static int
1839 xsltApplyFallbacks(xsltTransformContextPtr ctxt, xmlNodePtr node,
1840                xmlNodePtr inst) {
1841 
1842     xmlNodePtr child;
1843     int ret = 0;
1844 
1845     if ((ctxt == NULL) || (node == NULL) || (inst == NULL) ||
1846     (inst-&gt;children == NULL))
1847     return(0);
1848 
1849     child = inst-&gt;children;
1850     while (child != NULL) {
1851         if ((IS_XSLT_ELEM(child)) &amp;&amp;
1852             (xmlStrEqual(child-&gt;name, BAD_CAST &quot;fallback&quot;))) {
1853 #ifdef WITH_XSLT_DEBUG_PARSING
1854         xsltGenericDebug(xsltGenericDebugContext,
1855                  &quot;applying xsl:fallback\n&quot;);
1856 #endif
1857         ret++;
1858         xsltApplySequenceConstructor(ctxt, node, child-&gt;children,
1859         NULL);
1860     }
1861     child = child-&gt;next;
1862     }
1863     return(ret);
1864 }
1865 
1866 /************************************************************************
1867  *                                  *
1868  *          Default processing              *
1869  *                                  *
1870  ************************************************************************/
1871 
1872 /**
1873  * xsltDefaultProcessOneNode:
1874  * @ctxt:  a XSLT process context
1875  * @node:  the node in the source tree.
1876  * @params: extra parameters passed to the template if any
1877  *
1878  * Process the source node with the default built-in template rule:
1879  * &lt;xsl:template match=&quot;*|/&quot;&gt;
1880  *   &lt;xsl:apply-templates/&gt;
1881  * &lt;/xsl:template&gt;
1882  *
1883  * and
1884  *
1885  * &lt;xsl:template match=&quot;text()|@*&quot;&gt;
1886  *   &lt;xsl:value-of select=&quot;.&quot;/&gt;
1887  * &lt;/xsl:template&gt;
1888  *
1889  * Note also that namespace declarations are copied directly:
1890  *
1891  * the built-in template rule is the only template rule that is applied
1892  * for namespace nodes.
1893  */
1894 static void
1895 xsltDefaultProcessOneNode(xsltTransformContextPtr ctxt, xmlNodePtr node,
1896               xsltStackElemPtr params) {
1897     xmlNodePtr copy;
1898     xmlNodePtr delete = NULL, cur;
1899     int nbchild = 0, oldSize;
1900     int childno = 0, oldPos;
1901     xsltTemplatePtr template;
1902 
1903     CHECK_STOPPED;
1904     /*
1905      * Handling of leaves
1906      */
1907     switch (node-&gt;type) {
1908     case XML_DOCUMENT_NODE:
1909     case XML_HTML_DOCUMENT_NODE:
1910     case XML_ELEMENT_NODE:
1911         break;
1912     case XML_CDATA_SECTION_NODE:
1913 #ifdef WITH_XSLT_DEBUG_PROCESS
1914         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1915          &quot;xsltDefaultProcessOneNode: copy CDATA %s\n&quot;,
1916         node-&gt;content));
1917 #endif
1918         copy = xsltCopyText(ctxt, ctxt-&gt;insert, node, 0);
1919         if (copy == NULL) {
1920         xsltTransformError(ctxt, NULL, node,
1921          &quot;xsltDefaultProcessOneNode: cdata copy failed\n&quot;);
1922         }
1923         return;
1924     case XML_TEXT_NODE:
1925 #ifdef WITH_XSLT_DEBUG_PROCESS
1926         if (node-&gt;content == NULL) {
1927         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1928          &quot;xsltDefaultProcessOneNode: copy empty text\n&quot;));
1929         return;
1930         } else {
1931         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1932          &quot;xsltDefaultProcessOneNode: copy text %s\n&quot;,
1933             node-&gt;content));
1934             }
1935 #endif
1936         copy = xsltCopyText(ctxt, ctxt-&gt;insert, node, 0);
1937         if (copy == NULL) {
1938         xsltTransformError(ctxt, NULL, node,
1939          &quot;xsltDefaultProcessOneNode: text copy failed\n&quot;);
1940         }
1941         return;
1942     case XML_ATTRIBUTE_NODE:
1943         cur = node-&gt;children;
1944         while ((cur != NULL) &amp;&amp; (cur-&gt;type != XML_TEXT_NODE))
1945         cur = cur-&gt;next;
1946         if (cur == NULL) {
1947         xsltTransformError(ctxt, NULL, node,
1948          &quot;xsltDefaultProcessOneNode: no text for attribute\n&quot;);
1949         } else {
1950 #ifdef WITH_XSLT_DEBUG_PROCESS
1951         if (cur-&gt;content == NULL) {
1952             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1953              &quot;xsltDefaultProcessOneNode: copy empty text\n&quot;));
1954         } else {
1955             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1956              &quot;xsltDefaultProcessOneNode: copy text %s\n&quot;,
1957             cur-&gt;content));
1958                 }
1959 #endif
1960         copy = xsltCopyText(ctxt, ctxt-&gt;insert, cur, 0);
1961         if (copy == NULL) {
1962             xsltTransformError(ctxt, NULL, node,
1963              &quot;xsltDefaultProcessOneNode: text copy failed\n&quot;);
1964         }
1965         }
1966         return;
1967     default:
1968         return;
1969     }
1970     /*
1971      * Handling of Elements: first pass, cleanup and counting
1972      */
1973     cur = node-&gt;children;
1974     while (cur != NULL) {
1975     switch (cur-&gt;type) {
1976         case XML_TEXT_NODE:
1977         case XML_CDATA_SECTION_NODE:
1978         case XML_DOCUMENT_NODE:
1979         case XML_HTML_DOCUMENT_NODE:
1980         case XML_ELEMENT_NODE:
1981         case XML_PI_NODE:
1982         case XML_COMMENT_NODE:
1983         nbchild++;
1984         break;
1985             case XML_DTD_NODE:
1986         /* Unlink the DTD, it&#39;s still reachable using doc-&gt;intSubset */
1987         if (cur-&gt;next != NULL)
1988             cur-&gt;next-&gt;prev = cur-&gt;prev;
1989         if (cur-&gt;prev != NULL)
1990             cur-&gt;prev-&gt;next = cur-&gt;next;
1991         break;
1992         default:
1993 #ifdef WITH_XSLT_DEBUG_PROCESS
1994         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
1995          &quot;xsltDefaultProcessOneNode: skipping node type %d\n&quot;,
1996                          cur-&gt;type));
1997 #endif
1998         delete = cur;
1999     }
2000     cur = cur-&gt;next;
2001     if (delete != NULL) {
2002 #ifdef WITH_XSLT_DEBUG_PROCESS
2003         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2004          &quot;xsltDefaultProcessOneNode: removing ignorable blank node\n&quot;));
2005 #endif
2006         xmlUnlinkNode(delete);
2007         xmlFreeNode(delete);
2008         delete = NULL;
2009     }
2010     }
2011     if (delete != NULL) {
2012 #ifdef WITH_XSLT_DEBUG_PROCESS
2013     XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2014          &quot;xsltDefaultProcessOneNode: removing ignorable blank node\n&quot;));
2015 #endif
2016     xmlUnlinkNode(delete);
2017     xmlFreeNode(delete);
2018     delete = NULL;
2019     }
2020 
2021     /*
2022      * Handling of Elements: second pass, actual processing
2023      *
2024      * Note that params are passed to the next template. This matches
2025      * XSLT 2.0 behavior but doesn&#39;t conform to XSLT 1.0.
2026      */
2027     oldSize = ctxt-&gt;xpathCtxt-&gt;contextSize;
2028     oldPos = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
2029     cur = node-&gt;children;
2030     while (cur != NULL) {
2031     childno++;
2032     switch (cur-&gt;type) {
2033         case XML_DOCUMENT_NODE:
2034         case XML_HTML_DOCUMENT_NODE:
2035         case XML_ELEMENT_NODE:
2036         ctxt-&gt;xpathCtxt-&gt;contextSize = nbchild;
2037         ctxt-&gt;xpathCtxt-&gt;proximityPosition = childno;
2038         xsltProcessOneNode(ctxt, cur, params);
2039         break;
2040         case XML_CDATA_SECTION_NODE:
2041         template = xsltGetTemplate(ctxt, cur, NULL);
2042         if (template) {
2043 #ifdef WITH_XSLT_DEBUG_PROCESS
2044             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2045          &quot;xsltDefaultProcessOneNode: applying template for CDATA %s\n&quot;,
2046                      cur-&gt;content));
2047 #endif
2048             /*
2049             * Instantiate the xsl:template.
2050             */
2051             xsltApplyXSLTTemplate(ctxt, cur, template-&gt;content,
2052             template, params);
2053         } else /* if (ctxt-&gt;mode == NULL) */ {
2054 #ifdef WITH_XSLT_DEBUG_PROCESS
2055             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2056              &quot;xsltDefaultProcessOneNode: copy CDATA %s\n&quot;,
2057                      cur-&gt;content));
2058 #endif
2059             copy = xsltCopyText(ctxt, ctxt-&gt;insert, cur, 0);
2060             if (copy == NULL) {
2061             xsltTransformError(ctxt, NULL, cur,
2062                 &quot;xsltDefaultProcessOneNode: cdata copy failed\n&quot;);
2063             }
2064         }
2065         break;
2066         case XML_TEXT_NODE:
2067         template = xsltGetTemplate(ctxt, cur, NULL);
2068         if (template) {
2069 #ifdef WITH_XSLT_DEBUG_PROCESS
2070             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2071          &quot;xsltDefaultProcessOneNode: applying template for text %s\n&quot;,
2072                      cur-&gt;content));
2073 #endif
2074             ctxt-&gt;xpathCtxt-&gt;contextSize = nbchild;
2075             ctxt-&gt;xpathCtxt-&gt;proximityPosition = childno;
2076             /*
2077             * Instantiate the xsl:template.
2078             */
2079             xsltApplyXSLTTemplate(ctxt, cur, template-&gt;content,
2080             template, params);
2081         } else /* if (ctxt-&gt;mode == NULL) */ {
2082 #ifdef WITH_XSLT_DEBUG_PROCESS
2083             if (cur-&gt;content == NULL) {
2084             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2085              &quot;xsltDefaultProcessOneNode: copy empty text\n&quot;));
2086             } else {
2087             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2088              &quot;xsltDefaultProcessOneNode: copy text %s\n&quot;,
2089                      cur-&gt;content));
2090                     }
2091 #endif
2092             copy = xsltCopyText(ctxt, ctxt-&gt;insert, cur, 0);
2093             if (copy == NULL) {
2094             xsltTransformError(ctxt, NULL, cur,
2095                 &quot;xsltDefaultProcessOneNode: text copy failed\n&quot;);
2096             }
2097         }
2098         break;
2099         case XML_PI_NODE:
2100         case XML_COMMENT_NODE:
2101         template = xsltGetTemplate(ctxt, cur, NULL);
2102         if (template) {
2103 #ifdef WITH_XSLT_DEBUG_PROCESS
2104             if (cur-&gt;type == XML_PI_NODE) {
2105             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2106              &quot;xsltDefaultProcessOneNode: template found for PI %s\n&quot;,
2107                              cur-&gt;name));
2108             } else if (cur-&gt;type == XML_COMMENT_NODE) {
2109             XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2110              &quot;xsltDefaultProcessOneNode: template found for comment\n&quot;));
2111                     }
2112 #endif
2113             ctxt-&gt;xpathCtxt-&gt;contextSize = nbchild;
2114             ctxt-&gt;xpathCtxt-&gt;proximityPosition = childno;
2115             /*
2116             * Instantiate the xsl:template.
2117             */
2118             xsltApplyXSLTTemplate(ctxt, cur, template-&gt;content,
2119             template, params);
2120         }
2121         break;
2122         default:
2123         break;
2124     }
2125     cur = cur-&gt;next;
2126     }
2127     ctxt-&gt;xpathCtxt-&gt;contextSize = oldSize;
2128     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldPos;
2129 }
2130 
2131 /**
2132  * xsltProcessOneNode:
2133  * @ctxt:  a XSLT process context
2134  * @contextNode:  the &quot;current node&quot; in the source tree
2135  * @withParams:  extra parameters (e.g. xsl:with-param) passed to the
2136  *               template if any
2137  *
2138  * Process the source node.
2139  */
2140 void
2141 xsltProcessOneNode(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
2142                xsltStackElemPtr withParams)
2143 {
2144     xsltTemplatePtr templ;
2145     xmlNodePtr oldNode;
2146 
2147     templ = xsltGetTemplate(ctxt, contextNode, NULL);
2148     /*
2149      * If no template is found, apply the default rule.
2150      */
2151     if (templ == NULL) {
2152 #ifdef WITH_XSLT_DEBUG_PROCESS
2153     if (contextNode-&gt;type == XML_DOCUMENT_NODE) {
2154         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2155          &quot;xsltProcessOneNode: no template found for /\n&quot;));
2156     } else if (contextNode-&gt;type == XML_CDATA_SECTION_NODE) {
2157         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2158          &quot;xsltProcessOneNode: no template found for CDATA\n&quot;));
2159     } else if (contextNode-&gt;type == XML_ATTRIBUTE_NODE) {
2160         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2161          &quot;xsltProcessOneNode: no template found for attribute %s\n&quot;,
2162                          ((xmlAttrPtr) contextNode)-&gt;name));
2163     } else  {
2164         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2165          &quot;xsltProcessOneNode: no template found for %s\n&quot;, contextNode-&gt;name));
2166         }
2167 #endif
2168     oldNode = ctxt-&gt;node;
2169     ctxt-&gt;node = contextNode;
2170     xsltDefaultProcessOneNode(ctxt, contextNode, withParams);
2171     ctxt-&gt;node = oldNode;
2172     return;
2173     }
2174 
2175     if (contextNode-&gt;type == XML_ATTRIBUTE_NODE) {
2176     xsltTemplatePtr oldCurTempRule = ctxt-&gt;currentTemplateRule;
2177     /*
2178     * Set the &quot;current template rule&quot;.
2179     */
2180     ctxt-&gt;currentTemplateRule = templ;
2181 
2182 #ifdef WITH_XSLT_DEBUG_PROCESS
2183     XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2184          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for attribute %s\n&quot;,
2185                      templ-&gt;match, contextNode-&gt;name));
2186 #endif
2187     xsltApplyXSLTTemplate(ctxt, contextNode, templ-&gt;content, templ, withParams);
2188 
2189     ctxt-&gt;currentTemplateRule = oldCurTempRule;
2190     } else {
2191     xsltTemplatePtr oldCurTempRule = ctxt-&gt;currentTemplateRule;
2192     /*
2193     * Set the &quot;current template rule&quot;.
2194     */
2195     ctxt-&gt;currentTemplateRule = templ;
2196 
2197 #ifdef WITH_XSLT_DEBUG_PROCESS
2198     if (contextNode-&gt;type == XML_DOCUMENT_NODE) {
2199         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2200          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for /\n&quot;,
2201                          templ-&gt;match));
2202     } else {
2203         XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,
2204          &quot;xsltProcessOneNode: applying template &#39;%s&#39; for %s\n&quot;,
2205                          templ-&gt;match, contextNode-&gt;name));
2206         }
2207 #endif
2208     xsltApplyXSLTTemplate(ctxt, contextNode, templ-&gt;content, templ, withParams);
2209 
2210     ctxt-&gt;currentTemplateRule = oldCurTempRule;
2211     }
2212 }
2213 
2214 #ifdef WITH_DEBUGGER
2215 static xmlNodePtr
2216 xsltDebuggerStartSequenceConstructor(xsltTransformContextPtr ctxt,
2217                      xmlNodePtr contextNode,
2218                      xmlNodePtr list,
2219                      xsltTemplatePtr templ,
2220                      int *addCallResult)
2221 {
2222     xmlNodePtr debugedNode = NULL;
2223 
2224     if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) {
2225         if (templ) {
2226             *addCallResult = xslAddCall(templ, templ-&gt;elem);
2227         } else {
2228             *addCallResult = xslAddCall(NULL, list);
2229         }
2230         switch (ctxt-&gt;debugStatus) {
2231             case XSLT_DEBUG_RUN_RESTART:
2232             case XSLT_DEBUG_QUIT:
2233                 if (*addCallResult)
2234                     xslDropCall();
2235                 return(NULL);
2236         }
2237         if (templ) {
2238             xslHandleDebugger(templ-&gt;elem, contextNode, templ, ctxt);
2239             debugedNode = templ-&gt;elem;
2240         } else if (list) {
2241             xslHandleDebugger(list, contextNode, templ, ctxt);
2242             debugedNode = list;
2243         } else if (ctxt-&gt;inst) {
2244             xslHandleDebugger(ctxt-&gt;inst, contextNode, templ, ctxt);
2245             debugedNode = ctxt-&gt;inst;
2246         }
2247     }
2248     return(debugedNode);
2249 }
2250 #endif /* WITH_DEBUGGER */
2251 
2252 /**
2253  * xsltLocalVariablePush:
2254  * @ctxt: the transformation context
2255  * @variable: variable to be pushed to the variable stack
2256  * @level: new value for variable&#39;s level
2257  *
2258  * Places the variable onto the local variable stack
2259  *
2260  * Returns: 0 for success, -1 for any error
2261  * **NOTE:**
2262  * This is an internal routine and should not be called by users!
2263  */
2264 int
2265 xsltLocalVariablePush(xsltTransformContextPtr ctxt,
2266               xsltStackElemPtr variable,
2267               int level)
2268 {
2269     if (ctxt-&gt;varsMax == 0) {
2270     ctxt-&gt;varsMax = 10;
2271     ctxt-&gt;varsTab =
2272         (xsltStackElemPtr *) xmlMalloc(ctxt-&gt;varsMax *
2273         sizeof(ctxt-&gt;varsTab[0]));
2274     if (ctxt-&gt;varsTab == NULL) {
2275         xmlGenericError(xmlGenericErrorContext, &quot;malloc failed !\n&quot;);
2276         return (-1);
2277     }
2278     }
2279     if (ctxt-&gt;varsNr &gt;= ctxt-&gt;varsMax) {
2280     ctxt-&gt;varsMax *= 2;
2281     ctxt-&gt;varsTab =
2282         (xsltStackElemPtr *) xmlRealloc(ctxt-&gt;varsTab,
2283         ctxt-&gt;varsMax *
2284         sizeof(ctxt-&gt;varsTab[0]));
2285     if (ctxt-&gt;varsTab == NULL) {
2286         xmlGenericError(xmlGenericErrorContext, &quot;realloc failed !\n&quot;);
2287         return (-1);
2288     }
2289     }
2290     ctxt-&gt;varsTab[ctxt-&gt;varsNr++] = variable;
2291     ctxt-&gt;vars = variable;
2292     variable-&gt;level = level;
2293     return(0);
2294 }
2295 
2296 /**
2297  * xsltReleaseLocalRVTs:
2298  *
2299  * Fragments which are results of extension instructions
2300  * are preserved; all other fragments are freed/cached.
2301  */
2302 static void
2303 xsltReleaseLocalRVTs(xsltTransformContextPtr ctxt, xmlDocPtr base)
2304 {
2305     xmlDocPtr cur = ctxt-&gt;localRVT, tmp;
2306 
2307     if (cur == base)
2308         return;
2309     if (cur-&gt;prev != NULL)
2310         xsltTransformError(ctxt, NULL, NULL, &quot;localRVT not head of list\n&quot;);
2311 
2312     /* Reset localRVT early because some RVTs might be registered again. */
2313     ctxt-&gt;localRVT = base;
2314     if (base != NULL)
2315         base-&gt;prev = NULL;
2316 
2317     do {
2318         tmp = cur;
2319         cur = (xmlDocPtr) cur-&gt;next;
2320         if (tmp-&gt;psvi == XSLT_RVT_LOCAL) {
2321             xsltReleaseRVT(ctxt, tmp);
2322         } else if (tmp-&gt;psvi == XSLT_RVT_GLOBAL) {
2323             xsltRegisterPersistRVT(ctxt, tmp);
2324         } else if (tmp-&gt;psvi == XSLT_RVT_FUNC_RESULT) {
2325             /*
2326              * This will either register the RVT again or move it to the
2327              * context variable.
2328              */
2329             xsltRegisterLocalRVT(ctxt, tmp);
2330             tmp-&gt;psvi = XSLT_RVT_FUNC_RESULT;
2331         } else {
2332             xmlGenericError(xmlGenericErrorContext,
2333                     &quot;xsltReleaseLocalRVTs: Unexpected RVT flag %p\n&quot;,
2334                     tmp-&gt;psvi);
2335         }
2336     } while (cur != base);
2337 }
2338 
2339 /**
2340  * xsltApplySequenceConstructor:
2341  * @ctxt:  a XSLT process context
2342  * @contextNode:  the &quot;current node&quot; in the source tree
2343  * @list:  the nodes of a sequence constructor;
2344  *         (plus leading xsl:param elements)
2345  * @templ: the compiled xsl:template (optional)
2346  *
2347  * Processes a sequence constructor.
2348  *
2349  * NOTE: ctxt-&gt;currentTemplateRule was introduced to reflect the
2350  * semantics of &quot;current template rule&quot;. I.e. the field ctxt-&gt;templ
2351  * is not intended to reflect this, thus always pushed onto the
2352  * template stack.
2353  */
2354 static void
2355 xsltApplySequenceConstructor(xsltTransformContextPtr ctxt,
2356                  xmlNodePtr contextNode, xmlNodePtr list,
2357                  xsltTemplatePtr templ)
2358 {
2359     xmlNodePtr oldInsert, oldInst, oldCurInst, oldContextNode;
2360     xmlNodePtr cur, insert, copy = NULL;
2361     int level = 0, oldVarsNr;
2362     xmlDocPtr oldLocalFragmentTop;
2363 
2364 #ifdef XSLT_REFACTORED
2365     xsltStylePreCompPtr info;
2366 #endif
2367 
2368 #ifdef WITH_DEBUGGER
2369     int addCallResult = 0;
2370     xmlNodePtr debuggedNode = NULL;
2371 #endif
2372 
2373     if (ctxt == NULL)
2374     return;
2375 
2376 #ifdef WITH_DEBUGGER
2377     if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) {
2378     debuggedNode =
2379         xsltDebuggerStartSequenceConstructor(ctxt, contextNode,
2380         list, templ, &amp;addCallResult);
2381     if (debuggedNode == NULL)
2382         return;
2383     }
2384 #endif
2385 
2386     if (list == NULL)
2387         return;
2388     CHECK_STOPPED;
2389 
2390     /*
2391     * Check for infinite recursion: stop if the maximum of nested templates
2392     * is excceeded. Adjust xsltMaxDepth if you need more.
2393     */
2394     if (ctxt-&gt;depth &gt;= ctxt-&gt;maxTemplateDepth) {
2395         xsltTransformError(ctxt, NULL, list,
2396         &quot;xsltApplySequenceConstructor: A potential infinite template &quot;
2397             &quot;recursion was detected.\n&quot;
2398         &quot;You can adjust xsltMaxDepth (--maxdepth) in order to &quot;
2399         &quot;raise the maximum number of nested template calls and &quot;
2400         &quot;variables/params (currently set to %d).\n&quot;,
2401         ctxt-&gt;maxTemplateDepth);
2402         xsltDebug(ctxt, contextNode, list, NULL);
2403     ctxt-&gt;state = XSLT_STATE_STOPPED;
2404         return;
2405     }
2406     ctxt-&gt;depth++;
2407 
2408     oldLocalFragmentTop = ctxt-&gt;localRVT;
2409     oldInsert = insert = ctxt-&gt;insert;
2410     oldInst = oldCurInst = ctxt-&gt;inst;
2411     oldContextNode = ctxt-&gt;node;
2412     /*
2413     * Save current number of variables on the stack; new vars are popped when
2414     * exiting.
2415     */
2416     oldVarsNr = ctxt-&gt;varsNr;
2417     /*
2418     * Process the sequence constructor.
2419     */
2420     cur = list;
2421     while (cur != NULL) {
2422         if (ctxt-&gt;opLimit != 0) {
2423             if (ctxt-&gt;opCount &gt;= ctxt-&gt;opLimit) {
2424         xsltTransformError(ctxt, NULL, cur,
2425             &quot;xsltApplySequenceConstructor: &quot;
2426                     &quot;Operation limit exceeded\n&quot;);
2427             ctxt-&gt;state = XSLT_STATE_STOPPED;
2428                 goto error;
2429             }
2430             ctxt-&gt;opCount += 1;
2431         }
2432 
2433         ctxt-&gt;inst = cur;
2434 
2435 #ifdef WITH_DEBUGGER
2436         switch (ctxt-&gt;debugStatus) {
2437             case XSLT_DEBUG_RUN_RESTART:
2438             case XSLT_DEBUG_QUIT:
2439                 break;
2440 
2441         }
2442 #endif
2443         /*
2444          * Test; we must have a valid insertion point.
2445          */
2446         if (insert == NULL) {
2447 
2448 #ifdef WITH_XSLT_DEBUG_PROCESS
2449             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2450         &quot;xsltApplySequenceConstructor: insert == NULL !\n&quot;));
2451 #endif
2452             goto error;
2453         }
2454 
2455 #ifdef WITH_DEBUGGER
2456         if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp; (debuggedNode != cur))
2457             xslHandleDebugger(cur, contextNode, templ, ctxt);
2458 #endif
2459 
2460 #ifdef XSLT_REFACTORED
2461     if (cur-&gt;type == XML_ELEMENT_NODE) {
2462         info = (xsltStylePreCompPtr) cur-&gt;psvi;
2463         /*
2464         * We expect a compiled representation on:
2465         * 1) XSLT instructions of this XSLT version (1.0)
2466         *    (with a few exceptions)
2467         * 2) Literal result elements
2468         * 3) Extension instructions
2469         * 4) XSLT instructions of future XSLT versions
2470         *    (forwards-compatible mode).
2471         */
2472         if (info == NULL) {
2473         /*
2474         * Handle the rare cases where we don&#39;t expect a compiled
2475         * representation on an XSLT element.
2476         */
2477         if (IS_XSLT_ELEM_FAST(cur) &amp;&amp; IS_XSLT_NAME(cur, &quot;message&quot;)) {
2478             xsltMessage(ctxt, contextNode, cur);
2479             goto skip_children;
2480         }
2481         /*
2482         * Something really went wrong:
2483         */
2484         xsltTransformError(ctxt, NULL, cur,
2485             &quot;Internal error in xsltApplySequenceConstructor(): &quot;
2486             &quot;The element &#39;%s&#39; in the stylesheet has no compiled &quot;
2487             &quot;representation.\n&quot;,
2488             cur-&gt;name);
2489                 goto skip_children;
2490             }
2491 
2492         if (info-&gt;type == XSLT_FUNC_LITERAL_RESULT_ELEMENT) {
2493         xsltStyleItemLRElementInfoPtr lrInfo =
2494             (xsltStyleItemLRElementInfoPtr) info;
2495         /*
2496         * Literal result elements
2497         * --------------------------------------------------------
2498         */
2499 #ifdef WITH_XSLT_DEBUG_PROCESS
2500         XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,
2501             xsltGenericDebug(xsltGenericDebugContext,
2502             &quot;xsltApplySequenceConstructor: copy literal result &quot;
2503             &quot;element &#39;%s&#39;\n&quot;, cur-&gt;name));
2504 #endif
2505         /*
2506         * Copy the raw element-node.
2507         * OLD: if ((copy = xsltShallowCopyElem(ctxt, cur, insert))
2508         *     == NULL)
2509         *   goto error;
2510         */
2511         copy = xmlDocCopyNode(cur, insert-&gt;doc, 0);
2512         if (copy == NULL) {
2513             xsltTransformError(ctxt, NULL, cur,
2514             &quot;Internal error in xsltApplySequenceConstructor(): &quot;
2515             &quot;Failed to copy literal result element &#39;%s&#39;.\n&quot;,
2516             cur-&gt;name);
2517             goto error;
2518         } else {
2519             /*
2520             * Add the element-node to the result tree.
2521             */
2522             copy-&gt;doc = ctxt-&gt;output;
2523             copy = xsltAddChild(insert, copy);
2524             /*
2525             * Create effective namespaces declarations.
2526             * OLD: xsltCopyNamespaceList(ctxt, copy, cur-&gt;nsDef);
2527             */
2528             if (lrInfo-&gt;effectiveNs != NULL) {
2529             xsltEffectiveNsPtr effNs = lrInfo-&gt;effectiveNs;
2530             xmlNsPtr ns, lastns = NULL;
2531 
2532             while (effNs != NULL) {
2533                 /*
2534                 * Avoid generating redundant namespace
2535                 * declarations; thus lookup if there is already
2536                 * such a ns-decl in the result.
2537                 */
2538                 ns = xmlSearchNs(copy-&gt;doc, copy, effNs-&gt;prefix);
2539                 if ((ns != NULL) &amp;&amp;
2540                 (xmlStrEqual(ns-&gt;href, effNs-&gt;nsName)))
2541                 {
2542                 effNs = effNs-&gt;next;
2543                 continue;
2544                 }
2545                 ns = xmlNewNs(copy, effNs-&gt;nsName, effNs-&gt;prefix);
2546                 if (ns == NULL) {
2547                 xsltTransformError(ctxt, NULL, cur,
2548                     &quot;Internal error in &quot;
2549                     &quot;xsltApplySequenceConstructor(): &quot;
2550                     &quot;Failed to copy a namespace &quot;
2551                     &quot;declaration.\n&quot;);
2552                 goto error;
2553                 }
2554 
2555                 if (lastns == NULL)
2556                 copy-&gt;nsDef = ns;
2557                 else
2558                 lastns-&gt;next =ns;
2559                 lastns = ns;
2560 
2561                 effNs = effNs-&gt;next;
2562             }
2563 
2564             }
2565             /*
2566             * NOTE that we don&#39;t need to apply ns-alising: this was
2567             *  already done at compile-time.
2568             */
2569             if (cur-&gt;ns != NULL) {
2570             /*
2571             * If there&#39;s no such ns-decl in the result tree,
2572             * then xsltGetSpecialNamespace() will
2573             * create a ns-decl on the copied node.
2574             */
2575             copy-&gt;ns = xsltGetSpecialNamespace(ctxt, cur,
2576                 cur-&gt;ns-&gt;href, cur-&gt;ns-&gt;prefix, copy);
2577             } else {
2578             /*
2579             * Undeclare the default namespace if needed.
2580             * This can be skipped, if the result element has
2581             *  no ns-decls, in which case the result element
2582             *  obviously does not declare a default namespace;
2583             *  AND there&#39;s either no parent, or the parent
2584             *  element is in no namespace; this means there&#39;s no
2585             *  default namespace is scope to care about.
2586             *
2587             * REVISIT: This might result in massive
2588             *  generation of ns-decls if nodes in a default
2589             *  namespaces are mixed with nodes in no namespace.
2590             *
2591             */
2592             if (copy-&gt;nsDef ||
2593                 ((insert != NULL) &amp;&amp;
2594                  (insert-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
2595                  (insert-&gt;ns != NULL)))
2596             {
2597                 xsltGetSpecialNamespace(ctxt, cur,
2598                 NULL, NULL, copy);
2599             }
2600             }
2601         }
2602         /*
2603         * SPEC XSLT 2.0 &quot;Each attribute of the literal result
2604         *  element, other than an attribute in the XSLT namespace,
2605         *  is processed to produce an attribute for the element in
2606         *  the result tree.&quot;
2607         * NOTE: See bug #341325.
2608         */
2609         if (cur-&gt;properties != NULL) {
2610             xsltAttrListTemplateProcess(ctxt, copy, cur-&gt;properties);
2611         }
2612         } else if (IS_XSLT_ELEM_FAST(cur)) {
2613         /*
2614         * XSLT instructions
2615         * --------------------------------------------------------
2616         */
2617         if (info-&gt;type == XSLT_FUNC_UNKOWN_FORWARDS_COMPAT) {
2618             /*
2619             * We hit an unknown XSLT element.
2620             * Try to apply one of the fallback cases.
2621             */
2622             ctxt-&gt;insert = insert;
2623             if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {
2624             xsltTransformError(ctxt, NULL, cur,
2625                 &quot;The is no fallback behaviour defined for &quot;
2626                 &quot;the unknown XSLT element &#39;%s&#39;.\n&quot;,
2627                 cur-&gt;name);
2628             }
2629             ctxt-&gt;insert = oldInsert;
2630         } else if (info-&gt;func != NULL) {
2631             /*
2632             * Execute the XSLT instruction.
2633             */
2634             ctxt-&gt;insert = insert;
2635 
2636             info-&gt;func(ctxt, contextNode, cur,
2637             (xsltElemPreCompPtr) info);
2638 
2639             /*
2640             * Cleanup temporary tree fragments.
2641             */
2642             if (oldLocalFragmentTop != ctxt-&gt;localRVT)
2643             xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
2644 
2645             ctxt-&gt;insert = oldInsert;
2646         } else if (info-&gt;type == XSLT_FUNC_VARIABLE) {
2647             xsltStackElemPtr tmpvar = ctxt-&gt;vars;
2648 
2649             xsltParseStylesheetVariable(ctxt, cur);
2650 
2651             if (tmpvar != ctxt-&gt;vars) {
2652             /*
2653             * TODO: Using a @tmpvar is an annoying workaround, but
2654             *  the current mechanisms do not provide any other way
2655             *  of knowing if the var was really pushed onto the
2656             *  stack.
2657             */
2658             ctxt-&gt;vars-&gt;level = level;
2659             }
2660         } else if (info-&gt;type == XSLT_FUNC_MESSAGE) {
2661             /*
2662             * TODO: Won&#39;t be hit, since we don&#39;t compile xsl:message.
2663             */
2664             xsltMessage(ctxt, contextNode, cur);
2665         } else {
2666             xsltTransformError(ctxt, NULL, cur,
2667             &quot;Unexpected XSLT element &#39;%s&#39;.\n&quot;, cur-&gt;name);
2668         }
2669         goto skip_children;
2670 
2671         } else {
2672         xsltTransformFunction func;
2673         /*
2674         * Extension intructions (elements)
2675         * --------------------------------------------------------
2676         */
2677         if (cur-&gt;psvi == xsltExtMarker) {
2678             /*
2679             * The xsltExtMarker was set during the compilation
2680             * of extension instructions if there was no registered
2681             * handler for this specific extension function at
2682             * compile-time.
2683             * Libxslt will now lookup if a handler is
2684             * registered in the context of this transformation.
2685             */
2686             func = xsltExtElementLookup(ctxt, cur-&gt;name,
2687                                                 cur-&gt;ns-&gt;href);
2688         } else
2689             func = ((xsltElemPreCompPtr) cur-&gt;psvi)-&gt;func;
2690 
2691         if (func == NULL) {
2692             /*
2693             * No handler available.
2694             * Try to execute fallback behaviour via xsl:fallback.
2695             */
2696 #ifdef WITH_XSLT_DEBUG_PROCESS
2697             XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,
2698             xsltGenericDebug(xsltGenericDebugContext,
2699                 &quot;xsltApplySequenceConstructor: unknown extension %s\n&quot;,
2700                 cur-&gt;name));
2701 #endif
2702             ctxt-&gt;insert = insert;
2703             if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {
2704             xsltTransformError(ctxt, NULL, cur,
2705                 &quot;Unknown extension instruction &#39;{%s}%s&#39;.\n&quot;,
2706                 cur-&gt;ns-&gt;href, cur-&gt;name);
2707             }
2708             ctxt-&gt;insert = oldInsert;
2709         } else {
2710             /*
2711             * Execute the handler-callback.
2712             */
2713 #ifdef WITH_XSLT_DEBUG_PROCESS
2714             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2715             &quot;xsltApplySequenceConstructor: extension construct %s\n&quot;,
2716             cur-&gt;name));
2717 #endif
2718                     /*
2719                      * Disable the xsltCopyTextString optimization for
2720                      * extension elements. Extensions could append text using
2721                      * xmlAddChild which will free the buffer pointed to by
2722                      * &#39;lasttext&#39;. This buffer could later be reallocated with
2723                      * a different size than recorded in &#39;lasttsize&#39;. See bug
2724                      * #777432.
2725                      */
2726                     if (cur-&gt;psvi == xsltExtMarker) {
2727                         ctxt-&gt;lasttext = NULL;
2728                     }
2729 
2730             ctxt-&gt;insert = insert;
2731 
2732             func(ctxt, contextNode, cur, cur-&gt;psvi);
2733 
2734             /*
2735             * Cleanup temporary tree fragments.
2736             */
2737             if (oldLocalFragmentTop != ctxt-&gt;localRVT)
2738             xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
2739 
2740             ctxt-&gt;insert = oldInsert;
2741         }
2742         goto skip_children;
2743         }
2744 
2745     } else if (XSLT_IS_TEXT_NODE(cur)) {
2746         /*
2747         * Text
2748         * ------------------------------------------------------------
2749         */
2750 #ifdef WITH_XSLT_DEBUG_PROCESS
2751             if (cur-&gt;name == xmlStringTextNoenc) {
2752                 XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,
2753             xsltGenericDebug(xsltGenericDebugContext,
2754             &quot;xsltApplySequenceConstructor: copy unescaped text &#39;%s&#39;\n&quot;,
2755             cur-&gt;content));
2756             } else {
2757                 XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,
2758             xsltGenericDebug(xsltGenericDebugContext,
2759             &quot;xsltApplySequenceConstructor: copy text &#39;%s&#39;\n&quot;,
2760             cur-&gt;content));
2761             }
2762 #endif
2763             if (xsltCopyText(ctxt, insert, cur, ctxt-&gt;internalized) == NULL)
2764         goto error;
2765     }
2766 
2767 #else /* XSLT_REFACTORED */
2768 
2769         if (IS_XSLT_ELEM(cur)) {
2770             /*
2771              * This is an XSLT node
2772              */
2773             xsltStylePreCompPtr info = (xsltStylePreCompPtr) cur-&gt;psvi;
2774 
2775             if (info == NULL) {
2776                 if (IS_XSLT_NAME(cur, &quot;message&quot;)) {
2777                     xsltMessage(ctxt, contextNode, cur);
2778                 } else {
2779                     /*
2780                      * That&#39;s an error try to apply one of the fallback cases
2781                      */
2782                     ctxt-&gt;insert = insert;
2783                     if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {
2784                         xsltGenericError(xsltGenericErrorContext,
2785                 &quot;xsltApplySequenceConstructor: %s was not compiled\n&quot;,
2786                 cur-&gt;name);
2787                     }
2788                     ctxt-&gt;insert = oldInsert;
2789                 }
2790                 goto skip_children;
2791             }
2792 
2793             if (info-&gt;func != NULL) {
2794         oldCurInst = ctxt-&gt;inst;
2795         ctxt-&gt;inst = cur;
2796                 ctxt-&gt;insert = insert;
2797 
2798                 info-&gt;func(ctxt, contextNode, cur, (xsltElemPreCompPtr) info);
2799 
2800         /*
2801         * Cleanup temporary tree fragments.
2802         */
2803         if (oldLocalFragmentTop != ctxt-&gt;localRVT)
2804             xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
2805 
2806                 ctxt-&gt;insert = oldInsert;
2807         ctxt-&gt;inst = oldCurInst;
2808                 goto skip_children;
2809             }
2810 
2811             if (IS_XSLT_NAME(cur, &quot;variable&quot;)) {
2812         xsltStackElemPtr tmpvar = ctxt-&gt;vars;
2813 
2814         oldCurInst = ctxt-&gt;inst;
2815         ctxt-&gt;inst = cur;
2816 
2817         xsltParseStylesheetVariable(ctxt, cur);
2818 
2819         ctxt-&gt;inst = oldCurInst;
2820 
2821         if (tmpvar != ctxt-&gt;vars) {
2822             /*
2823             * TODO: Using a @tmpvar is an annoying workaround, but
2824             *  the current mechanisms do not provide any other way
2825             *  of knowing if the var was really pushed onto the
2826             *  stack.
2827             */
2828             ctxt-&gt;vars-&gt;level = level;
2829         }
2830             } else if (IS_XSLT_NAME(cur, &quot;message&quot;)) {
2831                 xsltMessage(ctxt, contextNode, cur);
2832             } else {
2833         xsltTransformError(ctxt, NULL, cur,
2834             &quot;Unexpected XSLT element &#39;%s&#39;.\n&quot;, cur-&gt;name);
2835             }
2836             goto skip_children;
2837         } else if ((cur-&gt;type == XML_TEXT_NODE) ||
2838                    (cur-&gt;type == XML_CDATA_SECTION_NODE)) {
2839 
2840             /*
2841              * This text comes from the stylesheet
2842              * For stylesheets, the set of whitespace-preserving
2843              * element names consists of just xsl:text.
2844              */
2845 #ifdef WITH_XSLT_DEBUG_PROCESS
2846             if (cur-&gt;type == XML_CDATA_SECTION_NODE) {
2847                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2848                                  &quot;xsltApplySequenceConstructor: copy CDATA text %s\n&quot;,
2849                                  cur-&gt;content));
2850             } else if (cur-&gt;name == xmlStringTextNoenc) {
2851                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2852                                  &quot;xsltApplySequenceConstructor: copy unescaped text %s\n&quot;,
2853                                  cur-&gt;content));
2854             } else {
2855                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2856                                  &quot;xsltApplySequenceConstructor: copy text %s\n&quot;,
2857                                  cur-&gt;content));
2858             }
2859 #endif
2860             if (xsltCopyText(ctxt, insert, cur, ctxt-&gt;internalized) == NULL)
2861         goto error;
2862         } else if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
2863                    (cur-&gt;ns != NULL) &amp;&amp; (cur-&gt;psvi != NULL)) {
2864             xsltTransformFunction function;
2865 
2866         oldCurInst = ctxt-&gt;inst;
2867         ctxt-&gt;inst = cur;
2868             /*
2869              * Flagged as an extension element
2870              */
2871             if (cur-&gt;psvi == xsltExtMarker)
2872                 function = xsltExtElementLookup(ctxt, cur-&gt;name,
2873                                                 cur-&gt;ns-&gt;href);
2874             else
2875                 function = ((xsltElemPreCompPtr) cur-&gt;psvi)-&gt;func;
2876 
2877             if (function == NULL) {
2878                 xmlNodePtr child;
2879                 int found = 0;
2880 
2881 #ifdef WITH_XSLT_DEBUG_PROCESS
2882                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2883             &quot;xsltApplySequenceConstructor: unknown extension %s\n&quot;,
2884                     cur-&gt;name));
2885 #endif
2886                 /*
2887                  * Search if there are fallbacks
2888                  */
2889                 ctxt-&gt;insert = insert;
2890                 child = cur-&gt;children;
2891                 while (child != NULL) {
2892                     if ((IS_XSLT_ELEM(child)) &amp;&amp;
2893                         (IS_XSLT_NAME(child, &quot;fallback&quot;)))
2894             {
2895                         found = 1;
2896                         xsltApplySequenceConstructor(ctxt, contextNode,
2897                 child-&gt;children, NULL);
2898                     }
2899                     child = child-&gt;next;
2900                 }
2901                 ctxt-&gt;insert = oldInsert;
2902 
2903                 if (!found) {
2904                     xsltTransformError(ctxt, NULL, cur,
2905             &quot;xsltApplySequenceConstructor: failed to find extension %s\n&quot;,
2906             cur-&gt;name);
2907                 }
2908             } else {
2909 #ifdef WITH_XSLT_DEBUG_PROCESS
2910                 XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2911             &quot;xsltApplySequenceConstructor: extension construct %s\n&quot;,
2912                     cur-&gt;name));
2913 #endif
2914 
2915                 /*
2916                  * Disable the xsltCopyTextString optimization for
2917                  * extension elements. Extensions could append text using
2918                  * xmlAddChild which will free the buffer pointed to by
2919                  * &#39;lasttext&#39;. This buffer could later be reallocated with
2920                  * a different size than recorded in &#39;lasttsize&#39;. See bug
2921                  * #777432.
2922                  */
2923                 if (cur-&gt;psvi == xsltExtMarker) {
2924                 ctxt-&gt;lasttext = NULL;
2925                 }
2926 
2927                 ctxt-&gt;insert = insert;
2928 
2929                 function(ctxt, contextNode, cur, cur-&gt;psvi);
2930         /*
2931         * Cleanup temporary tree fragments.
2932         */
2933         if (oldLocalFragmentTop != ctxt-&gt;localRVT)
2934             xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
2935 
2936                 ctxt-&gt;insert = oldInsert;
2937 
2938             }
2939         ctxt-&gt;inst = oldCurInst;
2940             goto skip_children;
2941         } else if (cur-&gt;type == XML_ELEMENT_NODE) {
2942 #ifdef WITH_XSLT_DEBUG_PROCESS
2943             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
2944         &quot;xsltApplySequenceConstructor: copy node %s\n&quot;,
2945                 cur-&gt;name));
2946 #endif
2947         oldCurInst = ctxt-&gt;inst;
2948         ctxt-&gt;inst = cur;
2949 
2950             if ((copy = xsltShallowCopyElem(ctxt, cur, insert, 1)) == NULL)
2951         goto error;
2952             /*
2953              * Add extra namespaces inherited from the current template
2954              * if we are in the first level children and this is a
2955          * &quot;real&quot; template.
2956              */
2957             if ((templ != NULL) &amp;&amp; (oldInsert == insert) &amp;&amp;
2958                 (ctxt-&gt;templ != NULL) &amp;&amp; (ctxt-&gt;templ-&gt;inheritedNs != NULL)) {
2959                 int i;
2960                 xmlNsPtr ns, ret;
2961 
2962                 for (i = 0; i &lt; ctxt-&gt;templ-&gt;inheritedNsNr; i++) {
2963             const xmlChar *URI = NULL;
2964             xsltStylesheetPtr style;
2965                     ns = ctxt-&gt;templ-&gt;inheritedNs[i];
2966 
2967             /* Note that the XSLT namespace was already excluded
2968             * in xsltGetInheritedNsList().
2969             */
2970 #if 0
2971             if (xmlStrEqual(ns-&gt;href, XSLT_NAMESPACE))
2972             continue;
2973 #endif
2974             style = ctxt-&gt;style;
2975             while (style != NULL) {
2976             if (style-&gt;nsAliases != NULL)
2977                 URI = (const xmlChar *)
2978                 xmlHashLookup(style-&gt;nsAliases, ns-&gt;href);
2979             if (URI != NULL)
2980                 break;
2981 
2982             style = xsltNextImport(style);
2983             }
2984             if (URI == UNDEFINED_DEFAULT_NS)
2985             continue;
2986             if (URI == NULL)
2987             URI = ns-&gt;href;
2988             /*
2989             * TODO: The following will still be buggy for the
2990             * non-refactored code.
2991             */
2992             ret = xmlSearchNs(copy-&gt;doc, copy, ns-&gt;prefix);
2993             if ((ret == NULL) || (!xmlStrEqual(ret-&gt;href, URI)))
2994             {
2995             xmlNewNs(copy, URI, ns-&gt;prefix);
2996             }
2997                 }
2998         if (copy-&gt;ns != NULL) {
2999             /*
3000              * Fix the node namespace if needed
3001              */
3002             copy-&gt;ns = xsltGetNamespace(ctxt, cur, copy-&gt;ns, copy);
3003         }
3004             }
3005         /*
3006              * all the attributes are directly inherited
3007              */
3008             if (cur-&gt;properties != NULL) {
3009                 xsltAttrListTemplateProcess(ctxt, copy, cur-&gt;properties);
3010             }
3011         ctxt-&gt;inst = oldCurInst;
3012         }
3013 #endif /* else of XSLT_REFACTORED */
3014 
3015         /*
3016          * Descend into content in document order.
3017          */
3018         if (cur-&gt;children != NULL) {
3019             if (cur-&gt;children-&gt;type != XML_ENTITY_DECL) {
3020                 cur = cur-&gt;children;
3021         level++;
3022                 if (copy != NULL)
3023                     insert = copy;
3024                 continue;
3025             }
3026         }
3027 
3028 skip_children:
3029     /*
3030     * If xslt:message was just processed, we might have hit a
3031     * terminate=&#39;yes&#39;; if so, then break the loop and clean up.
3032     * TODO: Do we need to check this also before trying to descend
3033     *  into the content?
3034     */
3035     if (ctxt-&gt;state == XSLT_STATE_STOPPED)
3036         break;
3037         if (cur-&gt;next != NULL) {
3038             cur = cur-&gt;next;
3039             continue;
3040         }
3041 
3042         do {
3043             cur = cur-&gt;parent;
3044         level--;
3045         /*
3046         * Pop variables/params (xsl:variable and xsl:param).
3047         */
3048         if ((ctxt-&gt;varsNr &gt; oldVarsNr) &amp;&amp; (ctxt-&gt;vars-&gt;level &gt; level)) {
3049         xsltLocalVariablePop(ctxt, oldVarsNr, level);
3050         }
3051 
3052             insert = insert-&gt;parent;
3053             if (cur == NULL)
3054                 break;
3055             if (cur == list-&gt;parent) {
3056                 cur = NULL;
3057                 break;
3058             }
3059             if (cur-&gt;next != NULL) {
3060                 cur = cur-&gt;next;
3061                 break;
3062             }
3063         } while (cur != NULL);
3064     }
3065 
3066 error:
3067     /*
3068     * In case of errors: pop remaining variables.
3069     */
3070     if (ctxt-&gt;varsNr &gt; oldVarsNr)
3071     xsltLocalVariablePop(ctxt, oldVarsNr, -1);
3072 
3073     ctxt-&gt;node = oldContextNode;
3074     ctxt-&gt;inst = oldInst;
3075     ctxt-&gt;insert = oldInsert;
3076 
3077     ctxt-&gt;depth--;
3078 
3079 #ifdef WITH_DEBUGGER
3080     if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp; (addCallResult)) {
3081         xslDropCall();
3082     }
3083 #endif
3084 }
3085 
3086 /*
3087 * xsltApplyXSLTTemplate:
3088 * @ctxt:  a XSLT transformation context
3089 * @contextNode:  the node in the source tree.
3090 * @list:  the nodes of a sequence constructor;
3091 *         (plus leading xsl:param elements)
3092 * @templ: the compiled xsl:template declaration;
3093 *         NULL if a sequence constructor
3094 * @withParams:  a set of caller-parameters (xsl:with-param) or NULL
3095 *
3096 * Called by:
3097 * - xsltApplyImports()
3098 * - xsltCallTemplate()
3099 * - xsltDefaultProcessOneNode()
3100 * - xsltProcessOneNode()
3101 */
3102 static void
3103 xsltApplyXSLTTemplate(xsltTransformContextPtr ctxt,
3104               xmlNodePtr contextNode,
3105               xmlNodePtr list,
3106               xsltTemplatePtr templ,
3107               xsltStackElemPtr withParams)
3108 {
3109     int oldVarsBase = 0;
3110     xmlNodePtr cur;
3111     xsltStackElemPtr tmpParam = NULL;
3112     xmlDocPtr oldUserFragmentTop;
3113 #ifdef WITH_PROFILER
3114     long start = 0;
3115 #endif
3116 
3117 #ifdef XSLT_REFACTORED
3118     xsltStyleItemParamPtr iparam;
3119 #else
3120     xsltStylePreCompPtr iparam;
3121 #endif
3122 
3123 #ifdef WITH_DEBUGGER
3124     int addCallResult = 0;
3125 #endif
3126 
3127     if (ctxt == NULL)
3128     return;
3129     if (templ == NULL) {
3130     xsltTransformError(ctxt, NULL, list,
3131         &quot;xsltApplyXSLTTemplate: Bad arguments; @templ is mandatory.\n&quot;);
3132     return;
3133     }
3134 
3135 #ifdef WITH_DEBUGGER
3136     if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) {
3137     if (xsltDebuggerStartSequenceConstructor(ctxt, contextNode,
3138         list, templ, &amp;addCallResult) == NULL)
3139         return;
3140     }
3141 #endif
3142 
3143     if (list == NULL)
3144         return;
3145     CHECK_STOPPED;
3146 
3147     if (ctxt-&gt;varsNr &gt;= ctxt-&gt;maxTemplateVars)
3148     {
3149         xsltTransformError(ctxt, NULL, list,
3150         &quot;xsltApplyXSLTTemplate: A potential infinite template recursion &quot;
3151         &quot;was detected.\n&quot;
3152         &quot;You can adjust maxTemplateVars (--maxvars) in order to &quot;
3153         &quot;raise the maximum number of variables/params (currently set to %d).\n&quot;,
3154         ctxt-&gt;maxTemplateVars);
3155         xsltDebug(ctxt, contextNode, list, NULL);
3156     ctxt-&gt;state = XSLT_STATE_STOPPED;
3157         return;
3158     }
3159 
3160     oldUserFragmentTop = ctxt-&gt;tmpRVT;
3161     ctxt-&gt;tmpRVT = NULL;
3162 
3163     /*
3164     * Initiate a distinct scope of local params/variables.
3165     */
3166     oldVarsBase = ctxt-&gt;varsBase;
3167     ctxt-&gt;varsBase = ctxt-&gt;varsNr;
3168 
3169     ctxt-&gt;node = contextNode;
3170 
3171 #ifdef WITH_PROFILER
3172     if (ctxt-&gt;profile) {
3173     templ-&gt;nbCalls++;
3174     start = xsltTimestamp();
3175     profPush(ctxt, 0);
3176     profCallgraphAdd(templ, ctxt-&gt;templ);
3177     }
3178 #endif
3179 
3180     /*
3181     * Push the xsl:template declaration onto the stack.
3182     */
3183     templPush(ctxt, templ);
3184 
3185 #ifdef WITH_XSLT_DEBUG_PROCESS
3186     if (templ-&gt;name != NULL)
3187     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
3188     &quot;applying xsl:template &#39;%s&#39;\n&quot;, templ-&gt;name));
3189 #endif
3190     /*
3191     * Process xsl:param instructions and skip those elements for
3192     * further processing.
3193     */
3194     cur = list;
3195     do {
3196     if (cur-&gt;type == XML_TEXT_NODE) {
3197         cur = cur-&gt;next;
3198         continue;
3199     }
3200     if ((cur-&gt;type != XML_ELEMENT_NODE) ||
3201         (cur-&gt;name[0] != &#39;p&#39;) ||
3202         (cur-&gt;psvi == NULL) ||
3203         (! xmlStrEqual(cur-&gt;name, BAD_CAST &quot;param&quot;)) ||
3204         (! IS_XSLT_ELEM(cur)))
3205     {
3206         break;
3207     }
3208 
3209     list = cur-&gt;next;
3210 
3211 #ifdef XSLT_REFACTORED
3212     iparam = (xsltStyleItemParamPtr) cur-&gt;psvi;
3213 #else
3214     iparam = (xsltStylePreCompPtr) cur-&gt;psvi;
3215 #endif
3216 
3217     /*
3218     * Substitute xsl:param for a given xsl:with-param.
3219     * Since the XPath expression will reference the params/vars
3220     * by index, we need to slot the xsl:with-params in the
3221     * order of encountered xsl:params to keep the sequence of
3222     * params/variables in the stack exactly as it was at
3223     * compile time,
3224     */
3225     tmpParam = NULL;
3226     if (withParams) {
3227         tmpParam = withParams;
3228         do {
3229         if ((tmpParam-&gt;name == (iparam-&gt;name)) &amp;&amp;
3230             (tmpParam-&gt;nameURI == (iparam-&gt;ns)))
3231         {
3232             /*
3233             * Push the caller-parameter.
3234             */
3235             xsltLocalVariablePush(ctxt, tmpParam, -1);
3236             break;
3237         }
3238         tmpParam = tmpParam-&gt;next;
3239         } while (tmpParam != NULL);
3240     }
3241     /*
3242     * Push the xsl:param.
3243     */
3244     if (tmpParam == NULL) {
3245         /*
3246         * Note that we must assume that the added parameter
3247         * has a @depth of 0.
3248         */
3249         xsltParseStylesheetParam(ctxt, cur);
3250     }
3251     cur = cur-&gt;next;
3252     } while (cur != NULL);
3253     /*
3254     * Process the sequence constructor.
3255     */
3256     xsltApplySequenceConstructor(ctxt, contextNode, list, templ);
3257 
3258     /*
3259     * Remove remaining xsl:param and xsl:with-param items from
3260     * the stack. Don&#39;t free xsl:with-param items.
3261     */
3262     if (ctxt-&gt;varsNr &gt; ctxt-&gt;varsBase)
3263     xsltTemplateParamsCleanup(ctxt);
3264     ctxt-&gt;varsBase = oldVarsBase;
3265 
3266     /*
3267     * Release user-created fragments stored in the scope
3268     * of xsl:template. Note that this mechanism is deprecated:
3269     * user code should now use xsltRegisterLocalRVT() instead
3270     * of the obsolete xsltRegisterTmpRVT().
3271     */
3272     if (ctxt-&gt;tmpRVT) {
3273     xmlDocPtr curdoc = ctxt-&gt;tmpRVT, tmp;
3274 
3275     while (curdoc != NULL) {
3276         tmp = curdoc;
3277         curdoc = (xmlDocPtr) curdoc-&gt;next;
3278         xsltReleaseRVT(ctxt, tmp);
3279     }
3280     }
3281     ctxt-&gt;tmpRVT = oldUserFragmentTop;
3282 
3283     /*
3284     * Pop the xsl:template declaration from the stack.
3285     */
3286     templPop(ctxt);
3287 
3288 #ifdef WITH_PROFILER
3289     if (ctxt-&gt;profile) {
3290     long spent, child, total, end;
3291 
3292     end = xsltTimestamp();
3293     child = profPop(ctxt);
3294     total = end - start;
3295     spent = total - child;
3296     if (spent &lt;= 0) {
3297         /*
3298         * Not possible unless the original calibration failed
3299         * we can try to correct it on the fly.
3300         */
3301         xsltCalibrateAdjust(spent);
3302         spent = 0;
3303     }
3304 
3305     templ-&gt;time += spent;
3306     if (ctxt-&gt;profNr &gt; 0)
3307         ctxt-&gt;profTab[ctxt-&gt;profNr - 1] += total;
3308     }
3309 #endif
3310 
3311 #ifdef WITH_DEBUGGER
3312     if ((ctxt-&gt;debugStatus != XSLT_DEBUG_NONE) &amp;&amp; (addCallResult)) {
3313         xslDropCall();
3314     }
3315 #endif
3316 }
3317 
3318 
3319 /**
3320  * xsltApplyOneTemplate:
3321  * @ctxt:  a XSLT process context
3322  * @contextNode:  the node in the source tree.
3323  * @list:  the nodes of a sequence constructor
3324  * @templ: not used
3325  * @params:  a set of parameters (xsl:param) or NULL
3326  *
3327  * Processes a sequence constructor on the current node in the source tree.
3328  *
3329  * @params are the already computed variable stack items; this function
3330  * pushes them on the variable stack, and pops them before exiting; it&#39;s
3331  * left to the caller to free or reuse @params afterwards. The initial
3332  * states of the variable stack will always be restored before this
3333  * function exits.
3334  * NOTE that this does *not* initiate a new distinct variable scope; i.e.
3335  * variables already on the stack are visible to the process. The caller&#39;s
3336  * side needs to start a new variable scope if needed (e.g. in exsl:function).
3337  *
3338  * @templ is obsolete and not used anymore (e.g. &lt;exslt:function&gt; does not
3339  * provide a @templ); a non-NULL @templ might raise an error in the future.
3340  *
3341  * BIG NOTE: This function is not intended to process the content of an
3342  * xsl:template; it does not expect xsl:param instructions in @list and
3343  * will report errors if found.
3344  *
3345  * Called by:
3346  *  - xsltEvalVariable() (variables.c)
3347  *  - exsltFuncFunctionFunction() (libexsl/functions.c)
3348  */
3349 void
3350 xsltApplyOneTemplate(xsltTransformContextPtr ctxt,
3351              xmlNodePtr contextNode,
3352                      xmlNodePtr list,
3353              xsltTemplatePtr templ ATTRIBUTE_UNUSED,
3354                      xsltStackElemPtr params)
3355 {
3356     if ((ctxt == NULL) || (list == NULL))
3357     return;
3358     CHECK_STOPPED;
3359 
3360     if (params) {
3361     /*
3362      * This code should be obsolete - was previously used
3363      * by libexslt/functions.c, but due to bug 381319 the
3364      * logic there was changed.
3365      */
3366     int oldVarsNr = ctxt-&gt;varsNr;
3367 
3368     /*
3369     * Push the given xsl:param(s) onto the variable stack.
3370     */
3371     while (params != NULL) {
3372         xsltLocalVariablePush(ctxt, params, -1);
3373         params = params-&gt;next;
3374     }
3375     xsltApplySequenceConstructor(ctxt, contextNode, list, templ);
3376     /*
3377     * Pop the given xsl:param(s) from the stack but don&#39;t free them.
3378     */
3379     xsltLocalVariablePop(ctxt, oldVarsNr, -2);
3380     } else
3381     xsltApplySequenceConstructor(ctxt, contextNode, list, templ);
3382 }
3383 
3384 /************************************************************************
3385  *                                  *
3386  *          XSLT-1.1 extensions                 *
3387  *                                  *
3388  ************************************************************************/
3389 
3390 /**
3391  * xsltDocumentElem:
3392  * @ctxt:  an XSLT processing context
3393  * @node:  The current node
3394  * @inst:  the instruction in the stylesheet
3395  * @castedComp:  precomputed information
3396  *
3397  * Process an EXSLT/XSLT-1.1 document element
3398  */
3399 void
3400 xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,
3401                  xmlNodePtr inst, xsltElemPreCompPtr castedComp)
3402 {
3403 #ifdef XSLT_REFACTORED
3404     xsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;
3405 #else
3406     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
3407 #endif
3408     xsltStylesheetPtr style = NULL;
3409     int ret;
3410     xmlChar *filename = NULL, *prop, *elements;
3411     xmlChar *element, *end;
3412     xmlDocPtr res = NULL;
3413     xmlDocPtr oldOutput;
3414     xmlNodePtr oldInsert, root;
3415     const char *oldOutputFile;
3416     xsltOutputType oldType;
3417     xmlChar *URL = NULL;
3418     const xmlChar *method;
3419     const xmlChar *doctypePublic;
3420     const xmlChar *doctypeSystem;
3421     const xmlChar *version;
3422     const xmlChar *encoding;
3423     int redirect_write_append = 0;
3424 
3425     if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))
3426         return;
3427 
3428     if (comp-&gt;filename == NULL) {
3429 
3430         if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;output&quot;)) {
3431         /*
3432         * The element &quot;output&quot; is in the namespace XSLT_SAXON_NAMESPACE
3433         *   (http://icl.com/saxon)
3434         * The @file is in no namespace.
3435         */
3436 #ifdef WITH_XSLT_DEBUG_EXTRA
3437             xsltGenericDebug(xsltGenericDebugContext,
3438                              &quot;Found saxon:output extension\n&quot;);
3439 #endif
3440             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3441                                                  (const xmlChar *) &quot;file&quot;,
3442                                                  XSLT_SAXON_NAMESPACE);
3443 
3444         if (URL == NULL)
3445         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3446                                                  (const xmlChar *) &quot;href&quot;,
3447                                                  XSLT_SAXON_NAMESPACE);
3448         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;write&quot;)) {
3449 #ifdef WITH_XSLT_DEBUG_EXTRA
3450             xsltGenericDebug(xsltGenericDebugContext,
3451                              &quot;Found xalan:write extension\n&quot;);
3452 #endif
3453             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3454                                                  (const xmlChar *)
3455                                                  &quot;select&quot;,
3456                                                  XSLT_XALAN_NAMESPACE);
3457         if (URL != NULL) {
3458         xmlXPathCompExprPtr cmp;
3459         xmlChar *val;
3460 
3461         /*
3462          * Trying to handle bug #59212
3463          * The value of the &quot;select&quot; attribute is an
3464          * XPath expression.
3465          * (see http://xml.apache.org/xalan-j/extensionslib.html#redirect)
3466          */
3467         cmp = xmlXPathCtxtCompile(ctxt-&gt;xpathCtxt, URL);
3468                 val = xsltEvalXPathString(ctxt, cmp);
3469         xmlXPathFreeCompExpr(cmp);
3470         xmlFree(URL);
3471         URL = val;
3472         }
3473         if (URL == NULL)
3474         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3475                              (const xmlChar *)
3476                              &quot;file&quot;,
3477                              XSLT_XALAN_NAMESPACE);
3478         if (URL == NULL)
3479         URL = xsltEvalAttrValueTemplate(ctxt, inst,
3480                              (const xmlChar *)
3481                              &quot;href&quot;,
3482                              XSLT_XALAN_NAMESPACE);
3483         } else if (xmlStrEqual(inst-&gt;name, (const xmlChar *) &quot;document&quot;)) {
3484             URL = xsltEvalAttrValueTemplate(ctxt, inst,
3485                                                  (const xmlChar *) &quot;href&quot;,
3486                                                  NULL);
3487         }
3488 
3489     } else {
3490         URL = xmlStrdup(comp-&gt;filename);
3491     }
3492 
3493     if (URL == NULL) {
3494     xsltTransformError(ctxt, NULL, inst,
3495                  &quot;xsltDocumentElem: href/URI-Reference not found\n&quot;);
3496     return;
3497     }
3498 
3499     /*
3500      * If the computation failed, it&#39;s likely that the URL wasn&#39;t escaped
3501      */
3502     filename = xmlBuildURI(URL, (const xmlChar *) ctxt-&gt;outputFile);
3503     if (filename == NULL) {
3504     xmlChar *escURL;
3505 
3506     escURL=xmlURIEscapeStr(URL, BAD_CAST &quot;:/.?,&quot;);
3507     if (escURL != NULL) {
3508         filename = xmlBuildURI(escURL, (const xmlChar *) ctxt-&gt;outputFile);
3509         xmlFree(escURL);
3510     }
3511     }
3512 
3513     if (filename == NULL) {
3514     xsltTransformError(ctxt, NULL, inst,
3515                  &quot;xsltDocumentElem: URL computation failed for %s\n&quot;,
3516              URL);
3517     xmlFree(URL);
3518     return;
3519     }
3520 
3521     /*
3522      * Security checking: can we write to this resource
3523      */
3524     if (ctxt-&gt;sec != NULL) {
3525     ret = xsltCheckWrite(ctxt-&gt;sec, ctxt, filename);
3526     if (ret &lt;= 0) {
3527             if (ret == 0)
3528                 xsltTransformError(ctxt, NULL, inst,
3529                      &quot;xsltDocumentElem: write rights for %s denied\n&quot;,
3530                                  filename);
3531         xmlFree(URL);
3532         xmlFree(filename);
3533         return;
3534     }
3535     }
3536 
3537     oldOutputFile = ctxt-&gt;outputFile;
3538     oldOutput = ctxt-&gt;output;
3539     oldInsert = ctxt-&gt;insert;
3540     oldType = ctxt-&gt;type;
3541     ctxt-&gt;outputFile = (const char *) filename;
3542 
3543     style = xsltNewStylesheet();
3544     if (style == NULL) {
3545     xsltTransformError(ctxt, NULL, inst,
3546                          &quot;xsltDocumentElem: out of memory\n&quot;);
3547         goto error;
3548     }
3549 
3550     /*
3551      * Version described in 1.1 draft allows full parameterization
3552      * of the output.
3553      */
3554     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3555                      (const xmlChar *) &quot;version&quot;,
3556                      NULL);
3557     if (prop != NULL) {
3558     if (style-&gt;version != NULL)
3559         xmlFree(style-&gt;version);
3560     style-&gt;version = prop;
3561     }
3562     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3563                      (const xmlChar *) &quot;encoding&quot;,
3564                      NULL);
3565     if (prop != NULL) {
3566     if (style-&gt;encoding != NULL)
3567         xmlFree(style-&gt;encoding);
3568     style-&gt;encoding = prop;
3569     }
3570     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3571                      (const xmlChar *) &quot;method&quot;,
3572                      NULL);
3573     if (prop != NULL) {
3574     const xmlChar *URI;
3575 
3576     if (style-&gt;method != NULL)
3577         xmlFree(style-&gt;method);
3578     style-&gt;method = NULL;
3579     if (style-&gt;methodURI != NULL)
3580         xmlFree(style-&gt;methodURI);
3581     style-&gt;methodURI = NULL;
3582 
3583     URI = xsltGetQNameURI(inst, &amp;prop);
3584     if (prop == NULL) {
3585         if (style != NULL) style-&gt;errors++;
3586     } else if (URI == NULL) {
3587         if ((xmlStrEqual(prop, (const xmlChar *) &quot;xml&quot;)) ||
3588         (xmlStrEqual(prop, (const xmlChar *) &quot;html&quot;)) ||
3589         (xmlStrEqual(prop, (const xmlChar *) &quot;text&quot;))) {
3590         style-&gt;method = prop;
3591         } else {
3592         xsltTransformError(ctxt, NULL, inst,
3593                  &quot;invalid value for method: %s\n&quot;, prop);
3594         if (style != NULL) style-&gt;warnings++;
3595         }
3596     } else {
3597         style-&gt;method = prop;
3598         style-&gt;methodURI = xmlStrdup(URI);
3599     }
3600     }
3601     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3602                      (const xmlChar *)
3603                      &quot;doctype-system&quot;, NULL);
3604     if (prop != NULL) {
3605     if (style-&gt;doctypeSystem != NULL)
3606         xmlFree(style-&gt;doctypeSystem);
3607     style-&gt;doctypeSystem = prop;
3608     }
3609     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3610                      (const xmlChar *)
3611                      &quot;doctype-public&quot;, NULL);
3612     if (prop != NULL) {
3613     if (style-&gt;doctypePublic != NULL)
3614         xmlFree(style-&gt;doctypePublic);
3615     style-&gt;doctypePublic = prop;
3616     }
3617     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3618                      (const xmlChar *) &quot;standalone&quot;,
3619                      NULL);
3620     if (prop != NULL) {
3621     if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
3622         style-&gt;standalone = 1;
3623     } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
3624         style-&gt;standalone = 0;
3625     } else {
3626         xsltTransformError(ctxt, NULL, inst,
3627                  &quot;invalid value for standalone: %s\n&quot;,
3628                  prop);
3629         if (style != NULL) style-&gt;warnings++;
3630     }
3631     xmlFree(prop);
3632     }
3633 
3634     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3635                      (const xmlChar *) &quot;indent&quot;,
3636                      NULL);
3637     if (prop != NULL) {
3638     if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
3639         style-&gt;indent = 1;
3640     } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
3641         style-&gt;indent = 0;
3642     } else {
3643         xsltTransformError(ctxt, NULL, inst,
3644                  &quot;invalid value for indent: %s\n&quot;, prop);
3645         if (style != NULL) style-&gt;warnings++;
3646     }
3647     xmlFree(prop);
3648     }
3649 
3650     prop = xsltEvalAttrValueTemplate(ctxt, inst,
3651                      (const xmlChar *)
3652                      &quot;omit-xml-declaration&quot;,
3653                      NULL);
3654     if (prop != NULL) {
3655     if (xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
3656         style-&gt;omitXmlDeclaration = 1;
3657     } else if (xmlStrEqual(prop, (const xmlChar *) &quot;no&quot;)) {
3658         style-&gt;omitXmlDeclaration = 0;
3659     } else {
3660         xsltTransformError(ctxt, NULL, inst,
3661                  &quot;invalid value for omit-xml-declaration: %s\n&quot;,
3662                  prop);
3663         if (style != NULL) style-&gt;warnings++;
3664     }
3665     xmlFree(prop);
3666     }
3667 
3668     elements = xsltEvalAttrValueTemplate(ctxt, inst,
3669                      (const xmlChar *)
3670                      &quot;cdata-section-elements&quot;,
3671                      NULL);
3672     if (elements != NULL) {
3673     if (style-&gt;stripSpaces == NULL)
3674         style-&gt;stripSpaces = xmlHashCreate(10);
3675     if (style-&gt;stripSpaces == NULL)
3676         return;
3677 
3678     element = elements;
3679     while (*element != 0) {
3680         while (IS_BLANK_CH(*element))
3681         element++;
3682         if (*element == 0)
3683         break;
3684         end = element;
3685         while ((*end != 0) &amp;&amp; (!IS_BLANK_CH(*end)))
3686         end++;
3687         element = xmlStrndup(element, end - element);
3688         if (element) {
3689         const xmlChar *URI;
3690 
3691 #ifdef WITH_XSLT_DEBUG_PARSING
3692         xsltGenericDebug(xsltGenericDebugContext,
3693                  &quot;add cdata section output element %s\n&quot;,
3694                  element);
3695 #endif
3696                 URI = xsltGetQNameURI(inst, &amp;element);
3697 
3698         xmlHashAddEntry2(style-&gt;stripSpaces, element, URI,
3699                     (xmlChar *) &quot;cdata&quot;);
3700         xmlFree(element);
3701         }
3702         element = end;
3703     }
3704     xmlFree(elements);
3705     }
3706 
3707     /*
3708      * Create a new document tree and process the element template
3709      */
3710     XSLT_GET_IMPORT_PTR(method, style, method)
3711     XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
3712     XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
3713     XSLT_GET_IMPORT_PTR(version, style, version)
3714     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
3715 
3716     if ((method != NULL) &amp;&amp;
3717     (!xmlStrEqual(method, (const xmlChar *) &quot;xml&quot;))) {
3718     if (xmlStrEqual(method, (const xmlChar *) &quot;html&quot;)) {
3719         ctxt-&gt;type = XSLT_OUTPUT_HTML;
3720         if (((doctypePublic != NULL) || (doctypeSystem != NULL)))
3721         res = htmlNewDoc(doctypeSystem, doctypePublic);
3722         else {
3723         if (version != NULL) {
3724 #ifdef XSLT_GENERATE_HTML_DOCTYPE
3725             xsltGetHTMLIDs(version, &amp;doctypePublic, &amp;doctypeSystem);
3726 #endif
3727                 }
3728         res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);
3729         }
3730         if (res == NULL)
3731         goto error;
3732         res-&gt;dict = ctxt-&gt;dict;
3733         xmlDictReference(res-&gt;dict);
3734     } else if (xmlStrEqual(method, (const xmlChar *) &quot;xhtml&quot;)) {
3735         xsltTransformError(ctxt, NULL, inst,
3736          &quot;xsltDocumentElem: unsupported method xhtml\n&quot;);
3737         ctxt-&gt;type = XSLT_OUTPUT_HTML;
3738         res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);
3739         if (res == NULL)
3740         goto error;
3741         res-&gt;dict = ctxt-&gt;dict;
3742         xmlDictReference(res-&gt;dict);
3743     } else if (xmlStrEqual(method, (const xmlChar *) &quot;text&quot;)) {
3744         ctxt-&gt;type = XSLT_OUTPUT_TEXT;
3745         res = xmlNewDoc(style-&gt;version);
3746         if (res == NULL)
3747         goto error;
3748         res-&gt;dict = ctxt-&gt;dict;
3749         xmlDictReference(res-&gt;dict);
3750 #ifdef WITH_XSLT_DEBUG
3751         xsltGenericDebug(xsltGenericDebugContext,
3752                      &quot;reusing transformation dict for output\n&quot;);
3753 #endif
3754     } else {
3755         xsltTransformError(ctxt, NULL, inst,
3756                  &quot;xsltDocumentElem: unsupported method (%s)\n&quot;,
3757                      method);
3758         goto error;
3759     }
3760     } else {
3761     ctxt-&gt;type = XSLT_OUTPUT_XML;
3762     res = xmlNewDoc(style-&gt;version);
3763     if (res == NULL)
3764         goto error;
3765     res-&gt;dict = ctxt-&gt;dict;
3766     xmlDictReference(res-&gt;dict);
3767 #ifdef WITH_XSLT_DEBUG
3768     xsltGenericDebug(xsltGenericDebugContext,
3769                      &quot;reusing transformation dict for output\n&quot;);
3770 #endif
3771     }
3772     res-&gt;charset = XML_CHAR_ENCODING_UTF8;
3773     if (encoding != NULL)
3774     res-&gt;encoding = xmlStrdup(encoding);
3775     ctxt-&gt;output = res;
3776     ctxt-&gt;insert = (xmlNodePtr) res;
3777     xsltApplySequenceConstructor(ctxt, node, inst-&gt;children, NULL);
3778 
3779     /*
3780      * Do some post processing work depending on the generated output
3781      */
3782     root = xmlDocGetRootElement(res);
3783     if (root != NULL) {
3784         const xmlChar *doctype = NULL;
3785 
3786         if ((root-&gt;ns != NULL) &amp;&amp; (root-&gt;ns-&gt;prefix != NULL))
3787         doctype = xmlDictQLookup(ctxt-&gt;dict, root-&gt;ns-&gt;prefix, root-&gt;name);
3788     if (doctype == NULL)
3789         doctype = root-&gt;name;
3790 
3791         /*
3792          * Apply the default selection of the method
3793          */
3794         if ((method == NULL) &amp;&amp;
3795             (root-&gt;ns == NULL) &amp;&amp;
3796             (!xmlStrcasecmp(root-&gt;name, (const xmlChar *) &quot;html&quot;))) {
3797             xmlNodePtr tmp;
3798 
3799             tmp = res-&gt;children;
3800             while ((tmp != NULL) &amp;&amp; (tmp != root)) {
3801                 if (tmp-&gt;type == XML_ELEMENT_NODE)
3802                     break;
3803                 if ((tmp-&gt;type == XML_TEXT_NODE) &amp;&amp; (!xmlIsBlankNode(tmp)))
3804                     break;
3805         tmp = tmp-&gt;next;
3806             }
3807             if (tmp == root) {
3808                 ctxt-&gt;type = XSLT_OUTPUT_HTML;
3809                 res-&gt;type = XML_HTML_DOCUMENT_NODE;
3810                 if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {
3811                     res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
3812                                                         doctypePublic,
3813                                                         doctypeSystem);
3814 #ifdef XSLT_GENERATE_HTML_DOCTYPE
3815         } else if (version != NULL) {
3816                     xsltGetHTMLIDs(version, &amp;doctypePublic,
3817                                    &amp;doctypeSystem);
3818                     if (((doctypePublic != NULL) || (doctypeSystem != NULL)))
3819                         res-&gt;intSubset =
3820                             xmlCreateIntSubset(res, doctype,
3821                                                doctypePublic,
3822                                                doctypeSystem);
3823 #endif
3824                 }
3825             }
3826 
3827         }
3828         if (ctxt-&gt;type == XSLT_OUTPUT_XML) {
3829             XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
3830                 XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
3831                 if (((doctypePublic != NULL) || (doctypeSystem != NULL)))
3832                 res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
3833                                                     doctypePublic,
3834                                                     doctypeSystem);
3835         }
3836     }
3837 
3838     /*
3839      * Calls to redirect:write also take an optional attribute append.
3840      * Attribute append=&quot;true|yes&quot; which will attempt to simply append
3841      * to an existing file instead of always opening a new file. The
3842      * default behavior of always overwriting the file still happens
3843      * if we do not specify append.
3844      * Note that append use will forbid use of remote URI target.
3845      */
3846     prop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)&quot;append&quot;,
3847                      NULL);
3848     if (prop != NULL) {
3849     if (xmlStrEqual(prop, (const xmlChar *) &quot;true&quot;) ||
3850         xmlStrEqual(prop, (const xmlChar *) &quot;yes&quot;)) {
3851         style-&gt;omitXmlDeclaration = 1;
3852         redirect_write_append = 1;
3853     } else
3854         style-&gt;omitXmlDeclaration = 0;
3855     xmlFree(prop);
3856     }
3857 
3858     if (redirect_write_append) {
3859         FILE *f;
3860 
3861     f = fopen((const char *) filename, &quot;ab&quot;);
3862     if (f == NULL) {
3863         ret = -1;
3864     } else {
3865         ret = xsltSaveResultToFile(f, res, style);
3866         fclose(f);
3867     }
3868     } else {
3869     ret = xsltSaveResultToFilename((const char *) filename, res, style, 0);
3870     }
3871     if (ret &lt; 0) {
3872     xsltTransformError(ctxt, NULL, inst,
3873                          &quot;xsltDocumentElem: unable to save to %s\n&quot;,
3874                          filename);
3875 #ifdef WITH_XSLT_DEBUG_EXTRA
3876     } else {
3877         xsltGenericDebug(xsltGenericDebugContext,
3878                          &quot;Wrote %d bytes to %s\n&quot;, ret, filename);
3879 #endif
3880     }
3881 
3882   error:
3883     ctxt-&gt;output = oldOutput;
3884     ctxt-&gt;insert = oldInsert;
3885     ctxt-&gt;type = oldType;
3886     ctxt-&gt;outputFile = oldOutputFile;
3887     if (URL != NULL)
3888         xmlFree(URL);
3889     if (filename != NULL)
3890         xmlFree(filename);
3891     if (style != NULL)
3892         xsltFreeStylesheet(style);
3893     if (res != NULL)
3894         xmlFreeDoc(res);
3895 }
3896 
3897 /************************************************************************
3898  *                                  *
3899  *      Most of the XSLT-1.0 transformations            *
3900  *                                  *
3901  ************************************************************************/
3902 
3903 /**
3904  * xsltSort:
3905  * @ctxt:  a XSLT process context
3906  * @node:  the node in the source tree.
3907  * @inst:  the xslt sort node
3908  * @comp:  precomputed information
3909  *
3910  * function attached to xsl:sort nodes, but this should not be
3911  * called directly
3912  */
3913 void
3914 xsltSort(xsltTransformContextPtr ctxt,
3915     xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,
3916     xsltElemPreCompPtr comp) {
3917     if (comp == NULL) {
3918     xsltTransformError(ctxt, NULL, inst,
3919          &quot;xsl:sort : compilation failed\n&quot;);
3920     return;
3921     }
3922     xsltTransformError(ctxt, NULL, inst,
3923      &quot;xsl:sort : improper use this should not be reached\n&quot;);
3924 }
3925 
3926 /**
3927  * xsltCopy:
3928  * @ctxt:  an XSLT process context
3929  * @node:  the node in the source tree
3930  * @inst:  the element node of the XSLT-copy instruction
3931  * @castedComp:  computed information of the XSLT-copy instruction
3932  *
3933  * Execute the XSLT-copy instruction on the source node.
3934  */
3935 void
3936 xsltCopy(xsltTransformContextPtr ctxt, xmlNodePtr node,
3937      xmlNodePtr inst, xsltElemPreCompPtr castedComp)
3938 {
3939 #ifdef XSLT_REFACTORED
3940     xsltStyleItemCopyPtr comp = (xsltStyleItemCopyPtr) castedComp;
3941 #else
3942     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
3943 #endif
3944     xmlNodePtr copy, oldInsert;
3945 
3946     oldInsert = ctxt-&gt;insert;
3947     if (ctxt-&gt;insert != NULL) {
3948     switch (node-&gt;type) {
3949         case XML_TEXT_NODE:
3950         case XML_CDATA_SECTION_NODE:
3951         /*
3952          * This text comes from the stylesheet
3953          * For stylesheets, the set of whitespace-preserving
3954          * element names consists of just xsl:text.
3955          */
3956 #ifdef WITH_XSLT_DEBUG_PROCESS
3957         if (node-&gt;type == XML_CDATA_SECTION_NODE) {
3958             XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
3959              &quot;xsltCopy: CDATA text %s\n&quot;, node-&gt;content));
3960         } else {
3961             XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
3962              &quot;xsltCopy: text %s\n&quot;, node-&gt;content));
3963                 }
3964 #endif
3965         xsltCopyText(ctxt, ctxt-&gt;insert, node, 0);
3966         break;
3967         case XML_DOCUMENT_NODE:
3968         case XML_HTML_DOCUMENT_NODE:
3969         break;
3970         case XML_ELEMENT_NODE:
3971         /*
3972         * REVISIT NOTE: The &quot;fake&quot; is a doc-node, not an element node.
3973         * REMOVED:
3974         *   if (xmlStrEqual(node-&gt;name, BAD_CAST &quot; fake node libxslt&quot;))
3975         *    return;
3976         */
3977 
3978 #ifdef WITH_XSLT_DEBUG_PROCESS
3979         XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
3980                  &quot;xsltCopy: node %s\n&quot;, node-&gt;name));
3981 #endif
3982         copy = xsltShallowCopyElem(ctxt, node, ctxt-&gt;insert, 0);
3983         ctxt-&gt;insert = copy;
3984         if (comp-&gt;use != NULL) {
3985             xsltApplyAttributeSet(ctxt, node, inst, comp-&gt;use);
3986         }
3987         break;
3988         case XML_ATTRIBUTE_NODE: {
3989 #ifdef WITH_XSLT_DEBUG_PROCESS
3990         XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
3991                  &quot;xsltCopy: attribute %s\n&quot;, node-&gt;name));
3992 #endif
3993         /*
3994         * REVISIT: We could also raise an error if the parent is not
3995         * an element node.
3996         * OPTIMIZE TODO: Can we set the value/children of the
3997         * attribute without an intermediate copy of the string value?
3998         */
3999         xsltShallowCopyAttr(ctxt, inst, ctxt-&gt;insert, (xmlAttrPtr) node);
4000         break;
4001         }
4002         case XML_PI_NODE:
4003 #ifdef WITH_XSLT_DEBUG_PROCESS
4004         XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
4005                  &quot;xsltCopy: PI %s\n&quot;, node-&gt;name));
4006 #endif
4007         copy = xmlNewDocPI(ctxt-&gt;insert-&gt;doc, node-&gt;name,
4008                            node-&gt;content);
4009         copy = xsltAddChild(ctxt-&gt;insert, copy);
4010         break;
4011         case XML_COMMENT_NODE:
4012 #ifdef WITH_XSLT_DEBUG_PROCESS
4013         XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
4014                  &quot;xsltCopy: comment\n&quot;));
4015 #endif
4016         copy = xmlNewComment(node-&gt;content);
4017         copy = xsltAddChild(ctxt-&gt;insert, copy);
4018         break;
4019         case XML_NAMESPACE_DECL:
4020 #ifdef WITH_XSLT_DEBUG_PROCESS
4021         XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,
4022                  &quot;xsltCopy: namespace declaration\n&quot;));
4023 #endif
4024         xsltShallowCopyNsNode(ctxt, inst, ctxt-&gt;insert, (xmlNsPtr)node);
4025         break;
4026         default:
4027         break;
4028 
4029     }
4030     }
4031 
4032     switch (node-&gt;type) {
4033     case XML_DOCUMENT_NODE:
4034     case XML_HTML_DOCUMENT_NODE:
4035     case XML_ELEMENT_NODE:
4036         xsltApplySequenceConstructor(ctxt, ctxt-&gt;node, inst-&gt;children,
4037         NULL);
4038         break;
4039     default:
4040         break;
4041     }
4042     ctxt-&gt;insert = oldInsert;
4043 }
4044 
4045 /**
4046  * xsltText:
4047  * @ctxt:  a XSLT process context
4048  * @node:  the node in the source tree.
4049  * @inst:  the xslt text node
4050  * @comp:  precomputed information
4051  *
4052  * Process the xslt text node on the source node
4053  */
4054 void
4055 xsltText(xsltTransformContextPtr ctxt, xmlNodePtr node ATTRIBUTE_UNUSED,
4056         xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {
4057     if ((inst-&gt;children != NULL) &amp;&amp; (comp != NULL)) {
4058     xmlNodePtr text = inst-&gt;children;
4059     xmlNodePtr copy;
4060 
4061     while (text != NULL) {
4062         if ((text-&gt;type != XML_TEXT_NODE) &amp;&amp;
4063              (text-&gt;type != XML_CDATA_SECTION_NODE)) {
4064         xsltTransformError(ctxt, NULL, inst,
4065                  &quot;xsl:text content problem\n&quot;);
4066         break;
4067         }
4068         copy = xmlNewDocText(ctxt-&gt;output, text-&gt;content);
4069         if (text-&gt;type != XML_CDATA_SECTION_NODE) {
4070 #ifdef WITH_XSLT_DEBUG_PARSING
4071         xsltGenericDebug(xsltGenericDebugContext,
4072              &quot;Disable escaping: %s\n&quot;, text-&gt;content);
4073 #endif
4074         copy-&gt;name = xmlStringTextNoenc;
4075         }
4076         copy = xsltAddChild(ctxt-&gt;insert, copy);
4077         text = text-&gt;next;
4078     }
4079     }
4080 }
4081 
4082 /**
4083  * xsltElement:
4084  * @ctxt:  a XSLT process context
4085  * @node:  the node in the source tree.
4086  * @inst:  the xslt element node
4087  * @castedComp:  precomputed information
4088  *
4089  * Process the xslt element node on the source node
4090  */
4091 void
4092 xsltElement(xsltTransformContextPtr ctxt, xmlNodePtr node,
4093         xmlNodePtr inst, xsltElemPreCompPtr castedComp) {
4094 #ifdef XSLT_REFACTORED
4095     xsltStyleItemElementPtr comp = (xsltStyleItemElementPtr) castedComp;
4096 #else
4097     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4098 #endif
4099     xmlChar *prop = NULL;
4100     const xmlChar *name, *prefix = NULL, *nsName = NULL;
4101     xmlNodePtr copy;
4102     xmlNodePtr oldInsert;
4103 
4104     if (ctxt-&gt;insert == NULL)
4105     return;
4106 
4107     /*
4108     * A comp-&gt;has_name == 0 indicates that we need to skip this instruction,
4109     * since it was evaluated to be invalid already during compilation.
4110     */
4111     if (!comp-&gt;has_name)
4112         return;
4113 
4114     /*
4115      * stack and saves
4116      */
4117     oldInsert = ctxt-&gt;insert;
4118 
4119     if (comp-&gt;name == NULL) {
4120     /* TODO: fix attr acquisition wrt to the XSLT namespace */
4121         prop = xsltEvalAttrValueTemplate(ctxt, inst,
4122         (const xmlChar *) &quot;name&quot;, XSLT_NAMESPACE);
4123         if (prop == NULL) {
4124             xsltTransformError(ctxt, NULL, inst,
4125         &quot;xsl:element: The attribute &#39;name&#39; is missing.\n&quot;);
4126             goto error;
4127         }
4128     if (xmlValidateQName(prop, 0)) {
4129         xsltTransformError(ctxt, NULL, inst,
4130         &quot;xsl:element: The effective name &#39;%s&#39; is not a &quot;
4131         &quot;valid QName.\n&quot;, prop);
4132         /* we fall through to catch any further errors, if possible */
4133     }
4134     name = xsltSplitQName(ctxt-&gt;dict, prop, &amp;prefix);
4135     xmlFree(prop);
4136     } else {
4137     /*
4138     * The &quot;name&quot; value was static.
4139     */
4140 #ifdef XSLT_REFACTORED
4141     prefix = comp-&gt;nsPrefix;
4142     name = comp-&gt;name;
4143 #else
4144     name = xsltSplitQName(ctxt-&gt;dict, comp-&gt;name, &amp;prefix);
4145 #endif
4146     }
4147 
4148     /*
4149      * Create the new element
4150      */
4151     if (ctxt-&gt;output-&gt;dict == ctxt-&gt;dict) {
4152     copy = xmlNewDocNodeEatName(ctxt-&gt;output, NULL, (xmlChar *)name, NULL);
4153     } else {
4154     copy = xmlNewDocNode(ctxt-&gt;output, NULL, (xmlChar *)name, NULL);
4155     }
4156     if (copy == NULL) {
4157     xsltTransformError(ctxt, NULL, inst,
4158         &quot;xsl:element : creation of %s failed\n&quot;, name);
4159     return;
4160     }
4161     copy = xsltAddChild(ctxt-&gt;insert, copy);
4162     if (copy == NULL) {
4163         xsltTransformError(ctxt, NULL, inst,
4164             &quot;xsl:element : xsltAddChild failed\n&quot;);
4165         return;
4166     }
4167 
4168     /*
4169     * Namespace
4170     * ---------
4171     */
4172     if (comp-&gt;has_ns) {
4173     if (comp-&gt;ns != NULL) {
4174         /*
4175         * No AVT; just plain text for the namespace name.
4176         */
4177         if (comp-&gt;ns[0] != 0)
4178         nsName = comp-&gt;ns;
4179     } else {
4180         xmlChar *tmpNsName;
4181         /*
4182         * Eval the AVT.
4183         */
4184         /* TODO: check attr acquisition wrt to the XSLT namespace */
4185         tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,
4186         (const xmlChar *) &quot;namespace&quot;, XSLT_NAMESPACE);
4187         /*
4188         * SPEC XSLT 1.0:
4189         *  &quot;If the string is empty, then the expanded-name of the
4190         *  attribute has a null namespace URI.&quot;
4191         */
4192         if ((tmpNsName != NULL) &amp;&amp; (tmpNsName[0] != 0))
4193         nsName = xmlDictLookup(ctxt-&gt;dict, BAD_CAST tmpNsName, -1);
4194         xmlFree(tmpNsName);
4195     }
4196 
4197         if (xmlStrEqual(nsName, BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;)) {
4198             xsltTransformError(ctxt, NULL, inst,
4199                 &quot;xsl:attribute: Namespace http://www.w3.org/2000/xmlns/ &quot;
4200                 &quot;forbidden.\n&quot;);
4201             goto error;
4202         }
4203         if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {
4204             prefix = BAD_CAST &quot;xml&quot;;
4205         } else if (xmlStrEqual(prefix, BAD_CAST &quot;xml&quot;)) {
4206             prefix = NULL;
4207         }
4208     } else {
4209     xmlNsPtr ns;
4210     /*
4211     * SPEC XSLT 1.0:
4212     *  &quot;If the namespace attribute is not present, then the QName is
4213     *  expanded into an expanded-name using the namespace declarations
4214     *  in effect for the xsl:element element, including any default
4215     *  namespace declaration.
4216     */
4217     ns = xmlSearchNs(inst-&gt;doc, inst, prefix);
4218     if (ns == NULL) {
4219         /*
4220         * TODO: Check this in the compilation layer in case it&#39;s a
4221         * static value.
4222         */
4223             if (prefix != NULL) {
4224                 xsltTransformError(ctxt, NULL, inst,
4225                     &quot;xsl:element: The QName &#39;%s:%s&#39; has no &quot;
4226                     &quot;namespace binding in scope in the stylesheet; &quot;
4227                     &quot;this is an error, since the namespace was not &quot;
4228                     &quot;specified by the instruction itself.\n&quot;, prefix, name);
4229             }
4230     } else
4231         nsName = ns-&gt;href;
4232     }
4233     /*
4234     * Find/create a matching ns-decl in the result tree.
4235     */
4236     if (nsName != NULL) {
4237     if (xmlStrEqual(prefix, BAD_CAST &quot;xmlns&quot;)) {
4238             /* Don&#39;t use a prefix of &quot;xmlns&quot; */
4239         xmlChar *pref = xmlStrdup(BAD_CAST &quot;ns_1&quot;);
4240 
4241         copy-&gt;ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);
4242 
4243         xmlFree(pref);
4244     } else {
4245         copy-&gt;ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,
4246         copy);
4247     }
4248     } else if ((copy-&gt;parent != NULL) &amp;&amp;
4249     (copy-&gt;parent-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
4250     (copy-&gt;parent-&gt;ns != NULL))
4251     {
4252     /*
4253     * &quot;Undeclare&quot; the default namespace.
4254     */
4255     xsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);
4256     }
4257 
4258     ctxt-&gt;insert = copy;
4259 
4260     if (comp-&gt;has_use) {
4261     if (comp-&gt;use != NULL) {
4262         xsltApplyAttributeSet(ctxt, node, inst, comp-&gt;use);
4263     } else {
4264         xmlChar *attrSets = NULL;
4265         /*
4266         * BUG TODO: use-attribute-sets is not a value template.
4267         *  use-attribute-sets = qnames
4268         */
4269         attrSets = xsltEvalAttrValueTemplate(ctxt, inst,
4270         (const xmlChar *)&quot;use-attribute-sets&quot;, NULL);
4271         if (attrSets != NULL) {
4272         xsltApplyAttributeSet(ctxt, node, inst, attrSets);
4273         xmlFree(attrSets);
4274         }
4275     }
4276     }
4277     /*
4278     * Instantiate the sequence constructor.
4279     */
4280     if (inst-&gt;children != NULL)
4281     xsltApplySequenceConstructor(ctxt, ctxt-&gt;node, inst-&gt;children,
4282         NULL);
4283 
4284 error:
4285     ctxt-&gt;insert = oldInsert;
4286     return;
4287 }
4288 
4289 
4290 /**
4291  * xsltComment:
4292  * @ctxt:  a XSLT process context
4293  * @node:  the node in the source tree.
4294  * @inst:  the xslt comment node
4295  * @comp:  precomputed information
4296  *
4297  * Process the xslt comment node on the source node
4298  */
4299 void
4300 xsltComment(xsltTransformContextPtr ctxt, xmlNodePtr node,
4301                xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {
4302     xmlChar *value = NULL;
4303     xmlNodePtr commentNode;
4304     int len;
4305 
4306     value = xsltEvalTemplateString(ctxt, node, inst);
4307     /* TODO: use or generate the compiled form */
4308     len = xmlStrlen(value);
4309     if (len &gt; 0) {
4310         if ((value[len-1] == &#39;-&#39;) ||
4311         (xmlStrstr(value, BAD_CAST &quot;--&quot;))) {
4312         xsltTransformError(ctxt, NULL, inst,
4313             &quot;xsl:comment : &#39;--&#39; or ending &#39;-&#39; not allowed in comment\n&quot;);
4314         /* fall through to try to catch further errors */
4315     }
4316     }
4317 #ifdef WITH_XSLT_DEBUG_PROCESS
4318     if (value == NULL) {
4319     XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,
4320          &quot;xsltComment: empty\n&quot;));
4321     } else {
4322     XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,
4323          &quot;xsltComment: content %s\n&quot;, value));
4324     }
4325 #endif
4326 
4327     commentNode = xmlNewComment(value);
4328     commentNode = xsltAddChild(ctxt-&gt;insert, commentNode);
4329 
4330     if (value != NULL)
4331     xmlFree(value);
4332 }
4333 
4334 /**
4335  * xsltProcessingInstruction:
4336  * @ctxt:  a XSLT process context
4337  * @node:  the node in the source tree.
4338  * @inst:  the xslt processing-instruction node
4339  * @castedComp:  precomputed information
4340  *
4341  * Process the xslt processing-instruction node on the source node
4342  */
4343 void
4344 xsltProcessingInstruction(xsltTransformContextPtr ctxt, xmlNodePtr node,
4345                xmlNodePtr inst, xsltElemPreCompPtr castedComp) {
4346 #ifdef XSLT_REFACTORED
4347     xsltStyleItemPIPtr comp = (xsltStyleItemPIPtr) castedComp;
4348 #else
4349     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4350 #endif
4351     const xmlChar *name;
4352     xmlChar *value = NULL;
4353     xmlNodePtr pi;
4354 
4355 
4356     if (ctxt-&gt;insert == NULL)
4357     return;
4358     if (comp-&gt;has_name == 0)
4359     return;
4360     if (comp-&gt;name == NULL) {
4361     name = xsltEvalAttrValueTemplate(ctxt, inst,
4362                 (const xmlChar *)&quot;name&quot;, NULL);
4363     if (name == NULL) {
4364         xsltTransformError(ctxt, NULL, inst,
4365          &quot;xsl:processing-instruction : name is missing\n&quot;);
4366         goto error;
4367     }
4368     } else {
4369     name = comp-&gt;name;
4370     }
4371     /* TODO: check that it&#39;s both an an NCName and a PITarget. */
4372 
4373 
4374     value = xsltEvalTemplateString(ctxt, node, inst);
4375     if (xmlStrstr(value, BAD_CAST &quot;?&gt;&quot;) != NULL) {
4376     xsltTransformError(ctxt, NULL, inst,
4377          &quot;xsl:processing-instruction: &#39;?&gt;&#39; not allowed within PI content\n&quot;);
4378     goto error;
4379     }
4380 #ifdef WITH_XSLT_DEBUG_PROCESS
4381     if (value == NULL) {
4382     XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,
4383          &quot;xsltProcessingInstruction: %s empty\n&quot;, name));
4384     } else {
4385     XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,
4386          &quot;xsltProcessingInstruction: %s content %s\n&quot;, name, value));
4387     }
4388 #endif
4389 
4390     pi = xmlNewDocPI(ctxt-&gt;insert-&gt;doc, name, value);
4391     pi = xsltAddChild(ctxt-&gt;insert, pi);
4392 
4393 error:
4394     if ((name != NULL) &amp;&amp; (name != comp-&gt;name))
4395         xmlFree((xmlChar *) name);
4396     if (value != NULL)
4397     xmlFree(value);
4398 }
4399 
4400 /**
4401  * xsltCopyOf:
4402  * @ctxt:  an XSLT transformation context
4403  * @node:  the current node in the source tree
4404  * @inst:  the element node of the XSLT copy-of instruction
4405  * @castedComp:  precomputed information of the XSLT copy-of instruction
4406  *
4407  * Process the XSLT copy-of instruction.
4408  */
4409 void
4410 xsltCopyOf(xsltTransformContextPtr ctxt, xmlNodePtr node,
4411                xmlNodePtr inst, xsltElemPreCompPtr castedComp) {
4412 #ifdef XSLT_REFACTORED
4413     xsltStyleItemCopyOfPtr comp = (xsltStyleItemCopyOfPtr) castedComp;
4414 #else
4415     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4416 #endif
4417     xmlXPathObjectPtr res = NULL;
4418     xmlNodeSetPtr list = NULL;
4419     int i;
4420 
4421     if ((ctxt == NULL) || (node == NULL) || (inst == NULL))
4422     return;
4423     if ((comp == NULL) || (comp-&gt;select == NULL) || (comp-&gt;comp == NULL)) {
4424     xsltTransformError(ctxt, NULL, inst,
4425          &quot;xsl:copy-of : compilation failed\n&quot;);
4426     return;
4427     }
4428 
4429      /*
4430     * SPEC XSLT 1.0:
4431     *  &quot;The xsl:copy-of element can be used to insert a result tree
4432     *  fragment into the result tree, without first converting it to
4433     *  a string as xsl:value-of does (see [7.6.1 Generating Text with
4434     *  xsl:value-of]). The required select attribute contains an
4435     *  expression. When the result of evaluating the expression is a
4436     *  result tree fragment, the complete fragment is copied into the
4437     *  result tree. When the result is a node-set, all the nodes in the
4438     *  set are copied in document order into the result tree; copying
4439     *  an element node copies the attribute nodes, namespace nodes and
4440     *  children of the element node as well as the element node itself;
4441     *  a root node is copied by copying its children. When the result
4442     *  is neither a node-set nor a result tree fragment, the result is
4443     *  converted to a string and then inserted into the result tree,
4444     *  as with xsl:value-of.
4445     */
4446 
4447 #ifdef WITH_XSLT_DEBUG_PROCESS
4448     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
4449      &quot;xsltCopyOf: select %s\n&quot;, comp-&gt;select));
4450 #endif
4451 
4452     /*
4453     * Evaluate the &quot;select&quot; expression.
4454     */
4455     res = xsltPreCompEval(ctxt, node, comp);
4456 
4457     if (res != NULL) {
4458     if (res-&gt;type == XPATH_NODESET) {
4459         /*
4460         * Node-set
4461         * --------
4462         */
4463 #ifdef WITH_XSLT_DEBUG_PROCESS
4464         XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
4465          &quot;xsltCopyOf: result is a node set\n&quot;));
4466 #endif
4467         list = res-&gt;nodesetval;
4468         if (list != NULL) {
4469         xmlNodePtr cur;
4470         /*
4471         * The list is already sorted in document order by XPath.
4472         * Append everything in this order under ctxt-&gt;insert.
4473         */
4474         for (i = 0;i &lt; list-&gt;nodeNr;i++) {
4475             cur = list-&gt;nodeTab[i];
4476             if (cur == NULL)
4477             continue;
4478             if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
4479             (cur-&gt;type == XML_HTML_DOCUMENT_NODE))
4480             {
4481             xsltCopyTreeList(ctxt, inst,
4482                 cur-&gt;children, ctxt-&gt;insert, 0, 0);
4483             } else if (cur-&gt;type == XML_ATTRIBUTE_NODE) {
4484             xsltShallowCopyAttr(ctxt, inst,
4485                 ctxt-&gt;insert, (xmlAttrPtr) cur);
4486             } else {
4487             xsltCopyTree(ctxt, inst, cur, ctxt-&gt;insert, 0, 0);
4488             }
4489         }
4490         }
4491     } else if (res-&gt;type == XPATH_XSLT_TREE) {
4492         /*
4493         * Result tree fragment
4494         * --------------------
4495         * E.g. via &lt;xsl:variable ...&gt;&lt;foo/&gt;&lt;/xsl:variable&gt;
4496         * Note that the root node of such trees is an xmlDocPtr in Libxslt.
4497         */
4498 #ifdef WITH_XSLT_DEBUG_PROCESS
4499         XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
4500          &quot;xsltCopyOf: result is a result tree fragment\n&quot;));
4501 #endif
4502         list = res-&gt;nodesetval;
4503         if ((list != NULL) &amp;&amp; (list-&gt;nodeTab != NULL) &amp;&amp;
4504         (list-&gt;nodeTab[0] != NULL) &amp;&amp;
4505         (IS_XSLT_REAL_NODE(list-&gt;nodeTab[0])))
4506         {
4507         xsltCopyTreeList(ctxt, inst,
4508             list-&gt;nodeTab[0]-&gt;children, ctxt-&gt;insert, 0, 0);
4509         }
4510     } else {
4511         xmlChar *value = NULL;
4512         /*
4513         * Convert to a string.
4514         */
4515         value = xmlXPathCastToString(res);
4516         if (value == NULL) {
4517         xsltTransformError(ctxt, NULL, inst,
4518             &quot;Internal error in xsltCopyOf(): &quot;
4519             &quot;failed to cast an XPath object to string.\n&quot;);
4520         ctxt-&gt;state = XSLT_STATE_STOPPED;
4521         } else {
4522         if (value[0] != 0) {
4523             /*
4524             * Append content as text node.
4525             */
4526             xsltCopyTextString(ctxt, ctxt-&gt;insert, value, 0);
4527         }
4528         xmlFree(value);
4529 
4530 #ifdef WITH_XSLT_DEBUG_PROCESS
4531         XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
4532             &quot;xsltCopyOf: result %s\n&quot;, res-&gt;stringval));
4533 #endif
4534         }
4535     }
4536     } else {
4537     ctxt-&gt;state = XSLT_STATE_STOPPED;
4538     }
4539 
4540     if (res != NULL)
4541     xmlXPathFreeObject(res);
4542 }
4543 
4544 /**
4545  * xsltValueOf:
4546  * @ctxt:  a XSLT process context
4547  * @node:  the node in the source tree.
4548  * @inst:  the xslt value-of node
4549  * @castedComp:  precomputed information
4550  *
4551  * Process the xslt value-of node on the source node
4552  */
4553 void
4554 xsltValueOf(xsltTransformContextPtr ctxt, xmlNodePtr node,
4555                xmlNodePtr inst, xsltElemPreCompPtr castedComp)
4556 {
4557 #ifdef XSLT_REFACTORED
4558     xsltStyleItemValueOfPtr comp = (xsltStyleItemValueOfPtr) castedComp;
4559 #else
4560     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4561 #endif
4562     xmlXPathObjectPtr res = NULL;
4563     xmlChar *value = NULL;
4564 
4565     if ((ctxt == NULL) || (node == NULL) || (inst == NULL))
4566     return;
4567 
4568     if ((comp == NULL) || (comp-&gt;select == NULL) || (comp-&gt;comp == NULL)) {
4569     xsltTransformError(ctxt, NULL, inst,
4570         &quot;Internal error in xsltValueOf(): &quot;
4571         &quot;The XSLT &#39;value-of&#39; instruction was not compiled.\n&quot;);
4572     return;
4573     }
4574 
4575 #ifdef WITH_XSLT_DEBUG_PROCESS
4576     XSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,
4577      &quot;xsltValueOf: select %s\n&quot;, comp-&gt;select));
4578 #endif
4579 
4580     res = xsltPreCompEval(ctxt, node, comp);
4581 
4582     /*
4583     * Cast the XPath object to string.
4584     */
4585     if (res != NULL) {
4586     value = xmlXPathCastToString(res);
4587     if (value == NULL) {
4588         xsltTransformError(ctxt, NULL, inst,
4589         &quot;Internal error in xsltValueOf(): &quot;
4590         &quot;failed to cast an XPath object to string.\n&quot;);
4591         ctxt-&gt;state = XSLT_STATE_STOPPED;
4592         goto error;
4593     }
4594     if (value[0] != 0) {
4595         xsltCopyTextString(ctxt, ctxt-&gt;insert, value, comp-&gt;noescape);
4596     }
4597     } else {
4598     xsltTransformError(ctxt, NULL, inst,
4599         &quot;XPath evaluation returned no result.\n&quot;);
4600     ctxt-&gt;state = XSLT_STATE_STOPPED;
4601     goto error;
4602     }
4603 
4604 #ifdef WITH_XSLT_DEBUG_PROCESS
4605     if (value) {
4606     XSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,
4607          &quot;xsltValueOf: result &#39;%s&#39;\n&quot;, value));
4608     }
4609 #endif
4610 
4611 error:
4612     if (value != NULL)
4613     xmlFree(value);
4614     if (res != NULL)
4615     xmlXPathFreeObject(res);
4616 }
4617 
4618 /**
4619  * xsltNumber:
4620  * @ctxt:  a XSLT process context
4621  * @node:  the node in the source tree.
4622  * @inst:  the xslt number node
4623  * @castedComp:  precomputed information
4624  *
4625  * Process the xslt number node on the source node
4626  */
4627 void
4628 xsltNumber(xsltTransformContextPtr ctxt, xmlNodePtr node,
4629        xmlNodePtr inst, xsltElemPreCompPtr castedComp)
4630 {
4631 #ifdef XSLT_REFACTORED
4632     xsltStyleItemNumberPtr comp = (xsltStyleItemNumberPtr) castedComp;
4633 #else
4634     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4635 #endif
4636     xmlXPathContextPtr xpctxt;
4637     xmlNsPtr *oldXPNamespaces;
4638     int oldXPNsNr;
4639 
4640     if (comp == NULL) {
4641     xsltTransformError(ctxt, NULL, inst,
4642          &quot;xsl:number : compilation failed\n&quot;);
4643     return;
4644     }
4645 
4646     if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))
4647     return;
4648 
4649     comp-&gt;numdata.doc = inst-&gt;doc;
4650     comp-&gt;numdata.node = inst;
4651 
4652     xpctxt = ctxt-&gt;xpathCtxt;
4653     oldXPNsNr = xpctxt-&gt;nsNr;
4654     oldXPNamespaces = xpctxt-&gt;namespaces;
4655 
4656 #ifdef XSLT_REFACTORED
4657     if (comp-&gt;inScopeNs != NULL) {
4658         xpctxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
4659         xpctxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
4660     } else {
4661         xpctxt-&gt;namespaces = NULL;
4662         xpctxt-&gt;nsNr = 0;
4663     }
4664 #else
4665     xpctxt-&gt;namespaces = comp-&gt;nsList;
4666     xpctxt-&gt;nsNr = comp-&gt;nsNr;
4667 #endif
4668 
4669     xsltNumberFormat(ctxt, &amp;comp-&gt;numdata, node);
4670 
4671     xpctxt-&gt;nsNr = oldXPNsNr;
4672     xpctxt-&gt;namespaces = oldXPNamespaces;
4673 }
4674 
4675 /**
4676  * xsltApplyImports:
4677  * @ctxt:  an XSLT transformation context
4678  * @contextNode:  the current node in the source tree.
4679  * @inst:  the element node of the XSLT &#39;apply-imports&#39; instruction
4680  * @comp:  the compiled instruction
4681  *
4682  * Process the XSLT apply-imports element.
4683  */
4684 void
4685 xsltApplyImports(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
4686              xmlNodePtr inst,
4687          xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)
4688 {
4689     xsltTemplatePtr templ;
4690 
4691     if ((ctxt == NULL) || (inst == NULL))
4692     return;
4693 
4694     if (comp == NULL) {
4695     xsltTransformError(ctxt, NULL, inst,
4696         &quot;Internal error in xsltApplyImports(): &quot;
4697         &quot;The XSLT &#39;apply-imports&#39; instruction was not compiled.\n&quot;);
4698     return;
4699     }
4700     /*
4701     * NOTE that ctxt-&gt;currentTemplateRule and ctxt-&gt;templ is not the
4702     * same; the former is the &quot;Current Template Rule&quot; as defined by the
4703     * XSLT spec, the latter is simply the template struct being
4704     * currently processed.
4705     */
4706     if (ctxt-&gt;currentTemplateRule == NULL) {
4707     /*
4708     * SPEC XSLT 2.0:
4709     * &quot;[ERR XTDE0560] It is a non-recoverable dynamic error if
4710     *  xsl:apply-imports or xsl:next-match is evaluated when the
4711     *  current template rule is null.&quot;
4712     */
4713     xsltTransformError(ctxt, NULL, inst,
4714          &quot;It is an error to call &#39;apply-imports&#39; &quot;
4715          &quot;when there&#39;s no current template rule.\n&quot;);
4716     return;
4717     }
4718     /*
4719     * TODO: Check if this is correct.
4720     */
4721     templ = xsltGetTemplate(ctxt, contextNode,
4722     ctxt-&gt;currentTemplateRule-&gt;style);
4723 
4724     if (templ != NULL) {
4725     xsltTemplatePtr oldCurTemplRule = ctxt-&gt;currentTemplateRule;
4726     /*
4727     * Set the current template rule.
4728     */
4729     ctxt-&gt;currentTemplateRule = templ;
4730     /*
4731     * URGENT TODO: Need xsl:with-param be handled somehow here?
4732     */
4733     xsltApplyXSLTTemplate(ctxt, contextNode, templ-&gt;content,
4734         templ, NULL);
4735 
4736     ctxt-&gt;currentTemplateRule = oldCurTemplRule;
4737     }
4738     else {
4739         /* Use built-in templates. */
4740         xsltDefaultProcessOneNode(ctxt, contextNode, NULL);
4741     }
4742 }
4743 
4744 /**
4745  * xsltCallTemplate:
4746  * @ctxt:  a XSLT transformation context
4747  * @node:  the &quot;current node&quot; in the source tree
4748  * @inst:  the XSLT &#39;call-template&#39; instruction
4749  * @castedComp:  the compiled information of the instruction
4750  *
4751  * Processes the XSLT call-template instruction on the source node.
4752  */
4753 void
4754 xsltCallTemplate(xsltTransformContextPtr ctxt, xmlNodePtr node,
4755                xmlNodePtr inst, xsltElemPreCompPtr castedComp)
4756 {
4757 #ifdef XSLT_REFACTORED
4758     xsltStyleItemCallTemplatePtr comp =
4759     (xsltStyleItemCallTemplatePtr) castedComp;
4760 #else
4761     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4762 #endif
4763     xsltStackElemPtr withParams = NULL;
4764 
4765     if (ctxt-&gt;insert == NULL)
4766     return;
4767     if (comp == NULL) {
4768     xsltTransformError(ctxt, NULL, inst,
4769          &quot;The XSLT &#39;call-template&#39; instruction was not compiled.\n&quot;);
4770     return;
4771     }
4772 
4773     /*
4774      * The template must have been precomputed
4775      */
4776     if (comp-&gt;templ == NULL) {
4777     comp-&gt;templ = xsltFindTemplate(ctxt, comp-&gt;name, comp-&gt;ns);
4778     if (comp-&gt;templ == NULL) {
4779         if (comp-&gt;ns != NULL) {
4780             xsltTransformError(ctxt, NULL, inst,
4781             &quot;The called template &#39;{%s}%s&#39; was not found.\n&quot;,
4782             comp-&gt;ns, comp-&gt;name);
4783         } else {
4784             xsltTransformError(ctxt, NULL, inst,
4785             &quot;The called template &#39;%s&#39; was not found.\n&quot;,
4786             comp-&gt;name);
4787         }
4788         return;
4789     }
4790     }
4791 
4792 #ifdef WITH_XSLT_DEBUG_PROCESS
4793     if ((comp != NULL) &amp;&amp; (comp-&gt;name != NULL))
4794     XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
4795              &quot;call-template: name %s\n&quot;, comp-&gt;name));
4796 #endif
4797 
4798     if (inst-&gt;children) {
4799     xmlNodePtr cur;
4800     xsltStackElemPtr param;
4801 
4802     cur = inst-&gt;children;
4803     while (cur != NULL) {
4804 #ifdef WITH_DEBUGGER
4805         if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE)
4806         xslHandleDebugger(cur, node, comp-&gt;templ, ctxt);
4807 #endif
4808         if (ctxt-&gt;state == XSLT_STATE_STOPPED) break;
4809         /*
4810         * TODO: The &quot;with-param&quot;s could be part of the &quot;call-template&quot;
4811         *   structure. Avoid to &quot;search&quot; for params dynamically
4812         *   in the XML tree every time.
4813         */
4814         if (IS_XSLT_ELEM(cur)) {
4815         if (IS_XSLT_NAME(cur, &quot;with-param&quot;)) {
4816             param = xsltParseStylesheetCallerParam(ctxt, cur);
4817             if (param != NULL) {
4818             param-&gt;next = withParams;
4819             withParams = param;
4820             }
4821         } else {
4822             xsltGenericError(xsltGenericErrorContext,
4823             &quot;xsl:call-template: misplaced xsl:%s\n&quot;, cur-&gt;name);
4824         }
4825         } else {
4826         xsltGenericError(xsltGenericErrorContext,
4827             &quot;xsl:call-template: misplaced %s element\n&quot;, cur-&gt;name);
4828         }
4829         cur = cur-&gt;next;
4830     }
4831     }
4832     /*
4833      * Create a new frame using the params first
4834      */
4835     xsltApplyXSLTTemplate(ctxt, node, comp-&gt;templ-&gt;content, comp-&gt;templ,
4836     withParams);
4837     if (withParams != NULL)
4838     xsltFreeStackElemList(withParams);
4839 
4840 #ifdef WITH_XSLT_DEBUG_PROCESS
4841     if ((comp != NULL) &amp;&amp; (comp-&gt;name != NULL))
4842     XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,
4843              &quot;call-template returned: name %s\n&quot;, comp-&gt;name));
4844 #endif
4845 }
4846 
4847 /**
4848  * xsltApplyTemplates:
4849  * @ctxt:  a XSLT transformation context
4850  * @node:  the &#39;current node&#39; in the source tree
4851  * @inst:  the element node of an XSLT &#39;apply-templates&#39; instruction
4852  * @castedComp:  the compiled instruction
4853  *
4854  * Processes the XSLT &#39;apply-templates&#39; instruction on the current node.
4855  */
4856 void
4857 xsltApplyTemplates(xsltTransformContextPtr ctxt, xmlNodePtr node,
4858                xmlNodePtr inst, xsltElemPreCompPtr castedComp)
4859 {
4860 #ifdef XSLT_REFACTORED
4861     xsltStyleItemApplyTemplatesPtr comp =
4862     (xsltStyleItemApplyTemplatesPtr) castedComp;
4863 #else
4864     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
4865 #endif
4866     int i;
4867     xmlNodePtr cur, delNode = NULL, oldContextNode;
4868     xmlNodeSetPtr list = NULL, oldList;
4869     xsltStackElemPtr withParams = NULL;
4870     int oldXPProximityPosition, oldXPContextSize;
4871     const xmlChar *oldMode, *oldModeURI;
4872     xmlDocPtr oldXPDoc;
4873     xsltDocumentPtr oldDocInfo;
4874     xmlXPathContextPtr xpctxt;
4875 
4876     if (comp == NULL) {
4877     xsltTransformError(ctxt, NULL, inst,
4878          &quot;xsl:apply-templates : compilation failed\n&quot;);
4879     return;
4880     }
4881     if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))
4882     return;
4883 
4884 #ifdef WITH_XSLT_DEBUG_PROCESS
4885     if ((node != NULL) &amp;&amp; (node-&gt;name != NULL))
4886     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
4887          &quot;xsltApplyTemplates: node: &#39;%s&#39;\n&quot;, node-&gt;name));
4888 #endif
4889 
4890     xpctxt = ctxt-&gt;xpathCtxt;
4891     /*
4892     * Save context states.
4893     */
4894     oldContextNode = ctxt-&gt;node;
4895     oldMode = ctxt-&gt;mode;
4896     oldModeURI = ctxt-&gt;modeURI;
4897     oldDocInfo = ctxt-&gt;document;
4898     oldList = ctxt-&gt;nodeList;
4899 
4900     /*
4901      * The xpath context size and proximity position, as
4902      * well as the xpath and context documents, may be changed
4903      * so we save their initial state and will restore on exit
4904      */
4905     oldXPContextSize = xpctxt-&gt;contextSize;
4906     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
4907     oldXPDoc = xpctxt-&gt;doc;
4908 
4909     /*
4910     * Set up contexts.
4911     */
4912     ctxt-&gt;mode = comp-&gt;mode;
4913     ctxt-&gt;modeURI = comp-&gt;modeURI;
4914 
4915     if (comp-&gt;select != NULL) {
4916     xmlXPathObjectPtr res = NULL;
4917 
4918     if (comp-&gt;comp == NULL) {
4919         xsltTransformError(ctxt, NULL, inst,
4920          &quot;xsl:apply-templates : compilation failed\n&quot;);
4921         goto error;
4922     }
4923 #ifdef WITH_XSLT_DEBUG_PROCESS
4924     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
4925          &quot;xsltApplyTemplates: select %s\n&quot;, comp-&gt;select));
4926 #endif
4927 
4928     res = xsltPreCompEval(ctxt, node, comp);
4929 
4930     if (res != NULL) {
4931         if (res-&gt;type == XPATH_NODESET) {
4932         list = res-&gt;nodesetval; /* consume the node set */
4933         res-&gt;nodesetval = NULL;
4934         } else {
4935         xsltTransformError(ctxt, NULL, inst,
4936             &quot;The &#39;select&#39; expression did not evaluate to a &quot;
4937             &quot;node set.\n&quot;);
4938         ctxt-&gt;state = XSLT_STATE_STOPPED;
4939         xmlXPathFreeObject(res);
4940         goto error;
4941         }
4942         xmlXPathFreeObject(res);
4943         /*
4944         * Note: An xsl:apply-templates with a &#39;select&#39; attribute,
4945         * can change the current source doc.
4946         */
4947     } else {
4948         xsltTransformError(ctxt, NULL, inst,
4949         &quot;Failed to evaluate the &#39;select&#39; expression.\n&quot;);
4950         ctxt-&gt;state = XSLT_STATE_STOPPED;
4951         goto error;
4952     }
4953     if (list == NULL) {
4954 #ifdef WITH_XSLT_DEBUG_PROCESS
4955         XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
4956         &quot;xsltApplyTemplates: select didn&#39;t evaluate to a node list\n&quot;));
4957 #endif
4958         goto exit;
4959     }
4960     /*
4961     *
4962     * NOTE: Previously a document info (xsltDocument) was
4963     * created and attached to the Result Tree Fragment.
4964     * But such a document info is created on demand in
4965     * xsltKeyFunction() (functions.c), so we need to create
4966     * it here beforehand.
4967     * In order to take care of potential keys we need to
4968     * do some extra work for the case when a Result Tree Fragment
4969     * is converted into a nodeset (e.g. exslt:node-set()) :
4970     * We attach a &quot;pseudo-doc&quot; (xsltDocument) to _private.
4971     * This xsltDocument, together with the keyset, will be freed
4972     * when the Result Tree Fragment is freed.
4973     *
4974     */
4975 #if 0
4976     if ((ctxt-&gt;nbKeys &gt; 0) &amp;&amp;
4977         (list-&gt;nodeNr != 0) &amp;&amp;
4978         (list-&gt;nodeTab[0]-&gt;doc != NULL) &amp;&amp;
4979         XSLT_IS_RES_TREE_FRAG(list-&gt;nodeTab[0]-&gt;doc))
4980     {
4981         /*
4982         * NOTE that it&#39;s also OK if @effectiveDocInfo will be
4983         * set to NULL.
4984         */
4985         isRTF = 1;
4986         effectiveDocInfo = list-&gt;nodeTab[0]-&gt;doc-&gt;_private;
4987     }
4988 #endif
4989     } else {
4990     /*
4991      * Build an XPath node set with the children
4992      */
4993     list = xmlXPathNodeSetCreate(NULL);
4994     if (list == NULL)
4995         goto error;
4996     if (node-&gt;type != XML_NAMESPACE_DECL)
4997         cur = node-&gt;children;
4998     else
4999         cur = NULL;
5000     while (cur != NULL) {
5001         switch (cur-&gt;type) {
5002         case XML_TEXT_NODE:
5003             if ((IS_BLANK_NODE(cur)) &amp;&amp;
5004             (cur-&gt;parent != NULL) &amp;&amp;
5005             (cur-&gt;parent-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
5006             (ctxt-&gt;style-&gt;stripSpaces != NULL)) {
5007             const xmlChar *val;
5008 
5009             if (cur-&gt;parent-&gt;ns != NULL) {
5010                 val = (const xmlChar *)
5011                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5012                          cur-&gt;parent-&gt;name,
5013                          cur-&gt;parent-&gt;ns-&gt;href);
5014                 if (val == NULL) {
5015                 val = (const xmlChar *)
5016                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5017                          BAD_CAST &quot;*&quot;,
5018                          cur-&gt;parent-&gt;ns-&gt;href);
5019                 }
5020             } else {
5021                 val = (const xmlChar *)
5022                   xmlHashLookup2(ctxt-&gt;style-&gt;stripSpaces,
5023                          cur-&gt;parent-&gt;name, NULL);
5024             }
5025             if ((val != NULL) &amp;&amp;
5026                 (xmlStrEqual(val, (xmlChar *) &quot;strip&quot;))) {
5027                 delNode = cur;
5028                 break;
5029             }
5030             }
5031             /* Intentional fall-through */
5032         case XML_ELEMENT_NODE:
5033         case XML_DOCUMENT_NODE:
5034         case XML_HTML_DOCUMENT_NODE:
5035         case XML_CDATA_SECTION_NODE:
5036         case XML_PI_NODE:
5037         case XML_COMMENT_NODE:
5038             xmlXPathNodeSetAddUnique(list, cur);
5039             break;
5040         case XML_DTD_NODE:
5041             /* Unlink the DTD, it&#39;s still reachable
5042              * using doc-&gt;intSubset */
5043             if (cur-&gt;next != NULL)
5044             cur-&gt;next-&gt;prev = cur-&gt;prev;
5045             if (cur-&gt;prev != NULL)
5046             cur-&gt;prev-&gt;next = cur-&gt;next;
5047             break;
5048         case XML_NAMESPACE_DECL:
5049             break;
5050         default:
5051 #ifdef WITH_XSLT_DEBUG_PROCESS
5052             XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
5053              &quot;xsltApplyTemplates: skipping cur type %d\n&quot;,
5054                      cur-&gt;type));
5055 #endif
5056             delNode = cur;
5057         }
5058         cur = cur-&gt;next;
5059         if (delNode != NULL) {
5060 #ifdef WITH_XSLT_DEBUG_PROCESS
5061         XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
5062              &quot;xsltApplyTemplates: removing ignorable blank cur\n&quot;));
5063 #endif
5064         xmlUnlinkNode(delNode);
5065         xmlFreeNode(delNode);
5066         delNode = NULL;
5067         }
5068     }
5069     }
5070 
5071 #ifdef WITH_XSLT_DEBUG_PROCESS
5072     if (list != NULL)
5073     XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,
5074     &quot;xsltApplyTemplates: list of %d nodes\n&quot;, list-&gt;nodeNr));
5075 #endif
5076 
5077     if ((list == NULL) || (list-&gt;nodeNr == 0))
5078     goto exit;
5079 
5080     /*
5081     * Set the context&#39;s node set and size; this is also needed for
5082     * for xsltDoSortFunction().
5083     */
5084     ctxt-&gt;nodeList = list;
5085     /*
5086     * Process xsl:with-param and xsl:sort instructions.
5087     * (The code became so verbose just to avoid the
5088     *  xmlNodePtr sorts[XSLT_MAX_SORT] if there&#39;s no xsl:sort)
5089     * BUG TODO: We are not using namespaced potentially defined on the
5090     * xsl:sort or xsl:with-param elements; XPath expression might fail.
5091     */
5092     if (inst-&gt;children) {
5093     xsltStackElemPtr param;
5094 
5095     cur = inst-&gt;children;
5096     while (cur) {
5097 
5098 #ifdef WITH_DEBUGGER
5099         if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE)
5100         xslHandleDebugger(cur, node, NULL, ctxt);
5101 #endif
5102         if (ctxt-&gt;state == XSLT_STATE_STOPPED)
5103         break;
5104         if (cur-&gt;type == XML_TEXT_NODE) {
5105         cur = cur-&gt;next;
5106         continue;
5107         }
5108         if (! IS_XSLT_ELEM(cur))
5109         break;
5110         if (IS_XSLT_NAME(cur, &quot;with-param&quot;)) {
5111         param = xsltParseStylesheetCallerParam(ctxt, cur);
5112         if (param != NULL) {
5113             param-&gt;next = withParams;
5114             withParams = param;
5115         }
5116         }
5117         if (IS_XSLT_NAME(cur, &quot;sort&quot;)) {
5118         xsltTemplatePtr oldCurTempRule =
5119             ctxt-&gt;currentTemplateRule;
5120         int nbsorts = 0;
5121         xmlNodePtr sorts[XSLT_MAX_SORT];
5122 
5123         sorts[nbsorts++] = cur;
5124 
5125         while (cur) {
5126 
5127 #ifdef WITH_DEBUGGER
5128             if (ctxt-&gt;debugStatus != XSLT_DEBUG_NONE)
5129             xslHandleDebugger(cur, node, NULL, ctxt);
5130 #endif
5131             if (ctxt-&gt;state == XSLT_STATE_STOPPED)
5132             break;
5133 
5134             if (cur-&gt;type == XML_TEXT_NODE) {
5135             cur = cur-&gt;next;
5136             continue;
5137             }
5138 
5139             if (! IS_XSLT_ELEM(cur))
5140             break;
5141             if (IS_XSLT_NAME(cur, &quot;with-param&quot;)) {
5142             param = xsltParseStylesheetCallerParam(ctxt, cur);
5143             if (param != NULL) {
5144                 param-&gt;next = withParams;
5145                 withParams = param;
5146             }
5147             }
5148             if (IS_XSLT_NAME(cur, &quot;sort&quot;)) {
5149             if (nbsorts &gt;= XSLT_MAX_SORT) {
5150                 xsltTransformError(ctxt, NULL, cur,
5151                 &quot;The number (%d) of xsl:sort instructions exceeds the &quot;
5152                 &quot;maximum allowed by this processor&#39;s settings.\n&quot;,
5153                 nbsorts);
5154                 ctxt-&gt;state = XSLT_STATE_STOPPED;
5155                 break;
5156             } else {
5157                 sorts[nbsorts++] = cur;
5158             }
5159             }
5160             cur = cur-&gt;next;
5161         }
5162         /*
5163         * The &quot;current template rule&quot; is cleared for xsl:sort.
5164         */
5165         ctxt-&gt;currentTemplateRule = NULL;
5166         /*
5167         * Sort.
5168         */
5169         xsltDoSortFunction(ctxt, sorts, nbsorts);
5170         ctxt-&gt;currentTemplateRule = oldCurTempRule;
5171         break;
5172         }
5173         cur = cur-&gt;next;
5174     }
5175     }
5176     xpctxt-&gt;contextSize = list-&gt;nodeNr;
5177     /*
5178     * Apply templates for all selected source nodes.
5179     */
5180     for (i = 0; i &lt; list-&gt;nodeNr; i++) {
5181     cur = list-&gt;nodeTab[i];
5182     /*
5183     * The node becomes the &quot;current node&quot;.
5184     */
5185     ctxt-&gt;node = cur;
5186     /*
5187     * An xsl:apply-templates can change the current context doc.
5188     * OPTIMIZE TODO: Get rid of the need to set the context doc.
5189     */
5190     if ((cur-&gt;type != XML_NAMESPACE_DECL) &amp;&amp; (cur-&gt;doc != NULL))
5191         xpctxt-&gt;doc = cur-&gt;doc;
5192 
5193     xpctxt-&gt;proximityPosition = i + 1;
5194     /*
5195     * Find and apply a template for this node.
5196     */
5197     xsltProcessOneNode(ctxt, cur, withParams);
5198     }
5199 
5200 exit:
5201 error:
5202     /*
5203     * Free the parameter list.
5204     */
5205     if (withParams != NULL)
5206     xsltFreeStackElemList(withParams);
5207     if (list != NULL)
5208     xmlXPathFreeNodeSet(list);
5209     /*
5210     * Restore context states.
5211     */
5212     xpctxt-&gt;doc = oldXPDoc;
5213     xpctxt-&gt;contextSize = oldXPContextSize;
5214     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
5215 
5216     ctxt-&gt;document = oldDocInfo;
5217     ctxt-&gt;nodeList = oldList;
5218     ctxt-&gt;node = oldContextNode;
5219     ctxt-&gt;mode = oldMode;
5220     ctxt-&gt;modeURI = oldModeURI;
5221 }
5222 
5223 
5224 /**
5225  * xsltChoose:
5226  * @ctxt:  a XSLT process context
5227  * @contextNode:  the current node in the source tree
5228  * @inst:  the xsl:choose instruction
5229  * @comp:  compiled information of the instruction
5230  *
5231  * Processes the xsl:choose instruction on the source node.
5232  */
5233 void
5234 xsltChoose(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
5235        xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)
5236 {
5237     xmlNodePtr cur;
5238 
5239     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))
5240     return;
5241 
5242     /*
5243     * TODO: Content model checks should be done only at compilation
5244     * time.
5245     */
5246     cur = inst-&gt;children;
5247     if (cur == NULL) {
5248     xsltTransformError(ctxt, NULL, inst,
5249         &quot;xsl:choose: The instruction has no content.\n&quot;);
5250     return;
5251     }
5252 
5253 #ifdef XSLT_REFACTORED
5254     /*
5255     * We don&#39;t check the content model during transformation.
5256     */
5257 #else
5258     if ((! IS_XSLT_ELEM(cur)) || (! IS_XSLT_NAME(cur, &quot;when&quot;))) {
5259     xsltTransformError(ctxt, NULL, inst,
5260          &quot;xsl:choose: xsl:when expected first\n&quot;);
5261     return;
5262     }
5263 #endif
5264 
5265     {
5266     int testRes = 0, res = 0;
5267 
5268 #ifdef XSLT_REFACTORED
5269     xsltStyleItemWhenPtr wcomp = NULL;
5270 #else
5271     xsltStylePreCompPtr wcomp = NULL;
5272 #endif
5273 
5274     /*
5275     * Process xsl:when ---------------------------------------------------
5276     */
5277     while (IS_XSLT_ELEM(cur) &amp;&amp; IS_XSLT_NAME(cur, &quot;when&quot;)) {
5278         wcomp = cur-&gt;psvi;
5279 
5280         if ((wcomp == NULL) || (wcomp-&gt;test == NULL) ||
5281         (wcomp-&gt;comp == NULL))
5282         {
5283         xsltTransformError(ctxt, NULL, cur,
5284             &quot;Internal error in xsltChoose(): &quot;
5285             &quot;The XSLT &#39;when&#39; instruction was not compiled.\n&quot;);
5286         goto error;
5287         }
5288 
5289 
5290 #ifdef WITH_DEBUGGER
5291         if (xslDebugStatus != XSLT_DEBUG_NONE) {
5292         /*
5293         * TODO: Isn&#39;t comp-&gt;templ always NULL for xsl:choose?
5294         */
5295         xslHandleDebugger(cur, contextNode, NULL, ctxt);
5296         }
5297 #endif
5298 #ifdef WITH_XSLT_DEBUG_PROCESS
5299         XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
5300         &quot;xsltChoose: test %s\n&quot;, wcomp-&gt;test));
5301 #endif
5302 
5303 #ifdef XSLT_FAST_IF
5304         res = xsltPreCompEvalToBoolean(ctxt, contextNode, wcomp);
5305 
5306         if (res == -1) {
5307         ctxt-&gt;state = XSLT_STATE_STOPPED;
5308         goto error;
5309         }
5310         testRes = (res == 1) ? 1 : 0;
5311 
5312 #else /* XSLT_FAST_IF */
5313 
5314         res = xsltPreCompEval(ctxt, cotextNode, wcomp);
5315 
5316         if (res != NULL) {
5317         if (res-&gt;type != XPATH_BOOLEAN)
5318             res = xmlXPathConvertBoolean(res);
5319         if (res-&gt;type == XPATH_BOOLEAN)
5320             testRes = res-&gt;boolval;
5321         else {
5322 #ifdef WITH_XSLT_DEBUG_PROCESS
5323             XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
5324             &quot;xsltChoose: test didn&#39;t evaluate to a boolean\n&quot;));
5325 #endif
5326             goto error;
5327         }
5328         xmlXPathFreeObject(res);
5329         res = NULL;
5330         } else {
5331         ctxt-&gt;state = XSLT_STATE_STOPPED;
5332         goto error;
5333         }
5334 
5335 #endif /* else of XSLT_FAST_IF */
5336 
5337 #ifdef WITH_XSLT_DEBUG_PROCESS
5338         XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
5339         &quot;xsltChoose: test evaluate to %d\n&quot;, testRes));
5340 #endif
5341         if (testRes)
5342         goto test_is_true;
5343 
5344         cur = cur-&gt;next;
5345     }
5346 
5347     /*
5348     * Process xsl:otherwise ----------------------------------------------
5349     */
5350     if (IS_XSLT_ELEM(cur) &amp;&amp; IS_XSLT_NAME(cur, &quot;otherwise&quot;)) {
5351 
5352 #ifdef WITH_DEBUGGER
5353         if (xslDebugStatus != XSLT_DEBUG_NONE)
5354         xslHandleDebugger(cur, contextNode, NULL, ctxt);
5355 #endif
5356 
5357 #ifdef WITH_XSLT_DEBUG_PROCESS
5358         XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
5359         &quot;evaluating xsl:otherwise\n&quot;));
5360 #endif
5361         goto test_is_true;
5362     }
5363     goto exit;
5364 
5365 test_is_true:
5366 
5367     goto process_sequence;
5368     }
5369 
5370 process_sequence:
5371 
5372     /*
5373     * Instantiate the sequence constructor.
5374     */
5375     xsltApplySequenceConstructor(ctxt, ctxt-&gt;node, cur-&gt;children,
5376     NULL);
5377 
5378 exit:
5379 error:
5380     return;
5381 }
5382 
5383 /**
5384  * xsltIf:
5385  * @ctxt:  a XSLT process context
5386  * @contextNode:  the current node in the source tree
5387  * @inst:  the xsl:if instruction
5388  * @castedComp:  compiled information of the instruction
5389  *
5390  * Processes the xsl:if instruction on the source node.
5391  */
5392 void
5393 xsltIf(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
5394                xmlNodePtr inst, xsltElemPreCompPtr castedComp)
5395 {
5396     int res = 0;
5397 
5398 #ifdef XSLT_REFACTORED
5399     xsltStyleItemIfPtr comp = (xsltStyleItemIfPtr) castedComp;
5400 #else
5401     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
5402 #endif
5403 
5404     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))
5405     return;
5406     if ((comp == NULL) || (comp-&gt;test == NULL) || (comp-&gt;comp == NULL)) {
5407     xsltTransformError(ctxt, NULL, inst,
5408         &quot;Internal error in xsltIf(): &quot;
5409         &quot;The XSLT &#39;if&#39; instruction was not compiled.\n&quot;);
5410     return;
5411     }
5412 
5413 #ifdef WITH_XSLT_DEBUG_PROCESS
5414     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
5415      &quot;xsltIf: test %s\n&quot;, comp-&gt;test));
5416 #endif
5417 
5418 #ifdef XSLT_FAST_IF
5419     {
5420     xmlDocPtr oldLocalFragmentTop = ctxt-&gt;localRVT;
5421 
5422     res = xsltPreCompEvalToBoolean(ctxt, contextNode, comp);
5423 
5424     /*
5425     * Cleanup fragments created during evaluation of the
5426     * &quot;select&quot; expression.
5427     */
5428     if (oldLocalFragmentTop != ctxt-&gt;localRVT)
5429         xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);
5430     }
5431 
5432 #ifdef WITH_XSLT_DEBUG_PROCESS
5433     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
5434     &quot;xsltIf: test evaluate to %d\n&quot;, res));
5435 #endif
5436 
5437     if (res == -1) {
5438     ctxt-&gt;state = XSLT_STATE_STOPPED;
5439     goto error;
5440     }
5441     if (res == 1) {
5442     /*
5443     * Instantiate the sequence constructor of xsl:if.
5444     */
5445     xsltApplySequenceConstructor(ctxt,
5446         contextNode, inst-&gt;children, NULL);
5447     }
5448 
5449 #else /* XSLT_FAST_IF */
5450     {
5451     /*
5452     * OLD CODE:
5453     */
5454     xmlXPathObjectPtr xpobj = xsltPreCompEval(ctxt, contextNode, comp);
5455     if (xpobj != NULL) {
5456         if (xpobj-&gt;type != XPATH_BOOLEAN)
5457         xpobj = xmlXPathConvertBoolean(xpobj);
5458         if (xpobj-&gt;type == XPATH_BOOLEAN) {
5459         res = xpobj-&gt;boolval;
5460 
5461 #ifdef WITH_XSLT_DEBUG_PROCESS
5462         XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,
5463             &quot;xsltIf: test evaluate to %d\n&quot;, res));
5464 #endif
5465         if (res) {
5466             xsltApplySequenceConstructor(ctxt,
5467             contextNode, inst-&gt;children, NULL);
5468         }
5469         } else {
5470 
5471 #ifdef WITH_XSLT_DEBUG_PROCESS
5472         XSLT_TRACE(ctxt, XSLT_TRACE_IF,
5473             xsltGenericDebug(xsltGenericDebugContext,
5474             &quot;xsltIf: test didn&#39;t evaluate to a boolean\n&quot;));
5475 #endif
5476         ctxt-&gt;state = XSLT_STATE_STOPPED;
5477         }
5478         xmlXPathFreeObject(xpobj);
5479     } else {
5480         ctxt-&gt;state = XSLT_STATE_STOPPED;
5481     }
5482     }
5483 #endif /* else of XSLT_FAST_IF */
5484 
5485 error:
5486     return;
5487 }
5488 
5489 /**
5490  * xsltForEach:
5491  * @ctxt:  an XSLT transformation context
5492  * @contextNode:  the &quot;current node&quot; in the source tree
5493  * @inst:  the element node of the xsl:for-each instruction
5494  * @castedComp:  the compiled information of the instruction
5495  *
5496  * Process the xslt for-each node on the source node
5497  */
5498 void
5499 xsltForEach(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
5500         xmlNodePtr inst, xsltElemPreCompPtr castedComp)
5501 {
5502 #ifdef XSLT_REFACTORED
5503     xsltStyleItemForEachPtr comp = (xsltStyleItemForEachPtr) castedComp;
5504 #else
5505     xsltStylePreCompPtr comp = (xsltStylePreCompPtr) castedComp;
5506 #endif
5507     int i;
5508     xmlXPathObjectPtr res = NULL;
5509     xmlNodePtr cur, curInst;
5510     xmlNodeSetPtr list = NULL;
5511     xmlNodeSetPtr oldList;
5512     int oldXPProximityPosition, oldXPContextSize;
5513     xmlNodePtr oldContextNode;
5514     xsltTemplatePtr oldCurTemplRule;
5515     xmlDocPtr oldXPDoc;
5516     xsltDocumentPtr oldDocInfo;
5517     xmlXPathContextPtr xpctxt;
5518 
5519     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL)) {
5520     xsltGenericError(xsltGenericErrorContext,
5521         &quot;xsltForEach(): Bad arguments.\n&quot;);
5522     return;
5523     }
5524 
5525     if (comp == NULL) {
5526         xsltTransformError(ctxt, NULL, inst,
5527         &quot;Internal error in xsltForEach(): &quot;
5528         &quot;The XSLT &#39;for-each&#39; instruction was not compiled.\n&quot;);
5529         return;
5530     }
5531     if ((comp-&gt;select == NULL) || (comp-&gt;comp == NULL)) {
5532     xsltTransformError(ctxt, NULL, inst,
5533         &quot;Internal error in xsltForEach(): &quot;
5534         &quot;The selecting expression of the XSLT &#39;for-each&#39; &quot;
5535         &quot;instruction was not compiled correctly.\n&quot;);
5536     return;
5537     }
5538     xpctxt = ctxt-&gt;xpathCtxt;
5539 
5540 #ifdef WITH_XSLT_DEBUG_PROCESS
5541     XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
5542      &quot;xsltForEach: select %s\n&quot;, comp-&gt;select));
5543 #endif
5544 
5545     /*
5546     * Save context states.
5547     */
5548     oldDocInfo = ctxt-&gt;document;
5549     oldList = ctxt-&gt;nodeList;
5550     oldContextNode = ctxt-&gt;node;
5551     /*
5552     * The &quot;current template rule&quot; is cleared for the instantiation of
5553     * xsl:for-each.
5554     */
5555     oldCurTemplRule = ctxt-&gt;currentTemplateRule;
5556     ctxt-&gt;currentTemplateRule = NULL;
5557 
5558     oldXPDoc = xpctxt-&gt;doc;
5559     oldXPProximityPosition = xpctxt-&gt;proximityPosition;
5560     oldXPContextSize = xpctxt-&gt;contextSize;
5561 
5562     /*
5563     * Evaluate the &#39;select&#39; expression.
5564     */
5565     res = xsltPreCompEval(ctxt, contextNode, comp);
5566 
5567     if (res != NULL) {
5568     if (res-&gt;type == XPATH_NODESET)
5569         list = res-&gt;nodesetval;
5570     else {
5571         xsltTransformError(ctxt, NULL, inst,
5572         &quot;The &#39;select&#39; expression does not evaluate to a node set.\n&quot;);
5573 
5574 #ifdef WITH_XSLT_DEBUG_PROCESS
5575         XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
5576         &quot;xsltForEach: select didn&#39;t evaluate to a node list\n&quot;));
5577 #endif
5578         goto error;
5579     }
5580     } else {
5581     xsltTransformError(ctxt, NULL, inst,
5582         &quot;Failed to evaluate the &#39;select&#39; expression.\n&quot;);
5583     ctxt-&gt;state = XSLT_STATE_STOPPED;
5584     goto error;
5585     }
5586 
5587     if ((list == NULL) || (list-&gt;nodeNr &lt;= 0))
5588     goto exit;
5589 
5590 #ifdef WITH_XSLT_DEBUG_PROCESS
5591     XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
5592     &quot;xsltForEach: select evaluates to %d nodes\n&quot;, list-&gt;nodeNr));
5593 #endif
5594 
5595     /*
5596     * Set the list; this has to be done already here for xsltDoSortFunction().
5597     */
5598     ctxt-&gt;nodeList = list;
5599     /*
5600     * Handle xsl:sort instructions and skip them for further processing.
5601     * BUG TODO: We are not using namespaced potentially defined on the
5602     * xsl:sort element; XPath expression might fail.
5603     */
5604     curInst = inst-&gt;children;
5605     if (IS_XSLT_ELEM(curInst) &amp;&amp; IS_XSLT_NAME(curInst, &quot;sort&quot;)) {
5606     int nbsorts = 0;
5607     xmlNodePtr sorts[XSLT_MAX_SORT];
5608 
5609     sorts[nbsorts++] = curInst;
5610 
5611 #ifdef WITH_DEBUGGER
5612     if (xslDebugStatus != XSLT_DEBUG_NONE)
5613         xslHandleDebugger(curInst, contextNode, NULL, ctxt);
5614 #endif
5615 
5616     curInst = curInst-&gt;next;
5617     while (IS_XSLT_ELEM(curInst) &amp;&amp; IS_XSLT_NAME(curInst, &quot;sort&quot;)) {
5618         if (nbsorts &gt;= XSLT_MAX_SORT) {
5619         xsltTransformError(ctxt, NULL, curInst,
5620             &quot;The number of xsl:sort instructions exceeds the &quot;
5621             &quot;maximum (%d) allowed by this processor.\n&quot;,
5622             XSLT_MAX_SORT);
5623         goto error;
5624         } else {
5625         sorts[nbsorts++] = curInst;
5626         }
5627 
5628 #ifdef WITH_DEBUGGER
5629         if (xslDebugStatus != XSLT_DEBUG_NONE)
5630         xslHandleDebugger(curInst, contextNode, NULL, ctxt);
5631 #endif
5632         curInst = curInst-&gt;next;
5633     }
5634     xsltDoSortFunction(ctxt, sorts, nbsorts);
5635     }
5636     xpctxt-&gt;contextSize = list-&gt;nodeNr;
5637     /*
5638     * Instantiate the sequence constructor for each selected node.
5639     */
5640     for (i = 0; i &lt; list-&gt;nodeNr; i++) {
5641     cur = list-&gt;nodeTab[i];
5642     /*
5643     * The selected node becomes the &quot;current node&quot;.
5644     */
5645     ctxt-&gt;node = cur;
5646     /*
5647     * An xsl:for-each can change the current context doc.
5648     * OPTIMIZE TODO: Get rid of the need to set the context doc.
5649     */
5650     if ((cur-&gt;type != XML_NAMESPACE_DECL) &amp;&amp; (cur-&gt;doc != NULL))
5651         xpctxt-&gt;doc = cur-&gt;doc;
5652 
5653     xpctxt-&gt;proximityPosition = i + 1;
5654 
5655     xsltApplySequenceConstructor(ctxt, cur, curInst, NULL);
5656     }
5657 
5658 exit:
5659 error:
5660     if (res != NULL)
5661     xmlXPathFreeObject(res);
5662     /*
5663     * Restore old states.
5664     */
5665     ctxt-&gt;document = oldDocInfo;
5666     ctxt-&gt;nodeList = oldList;
5667     ctxt-&gt;node = oldContextNode;
5668     ctxt-&gt;currentTemplateRule = oldCurTemplRule;
5669 
5670     xpctxt-&gt;doc = oldXPDoc;
5671     xpctxt-&gt;contextSize = oldXPContextSize;
5672     xpctxt-&gt;proximityPosition = oldXPProximityPosition;
5673 }
5674 
5675 /************************************************************************
5676  *                                  *
5677  *          Generic interface               *
5678  *                                  *
5679  ************************************************************************/
5680 
5681 #ifdef XSLT_GENERATE_HTML_DOCTYPE
5682 typedef struct xsltHTMLVersion {
5683     const char *version;
5684     const char *public;
5685     const char *system;
5686 } xsltHTMLVersion;
5687 
5688 static xsltHTMLVersion xsltHTMLVersions[] = {
5689     { &quot;5&quot;, NULL, &quot;about:legacy-compat&quot; },
5690     { &quot;4.01frame&quot;, &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;,
5691       &quot;http://www.w3.org/TR/1999/REC-html401-19991224/frameset.dtd&quot;},
5692     { &quot;4.01strict&quot;, &quot;-//W3C//DTD HTML 4.01//EN&quot;,
5693       &quot;http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd&quot;},
5694     { &quot;4.01trans&quot;, &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;,
5695       &quot;http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd&quot;},
5696     { &quot;4.01&quot;, &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;,
5697       &quot;http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd&quot;},
5698     { &quot;4.0strict&quot;, &quot;-//W3C//DTD HTML 4.01//EN&quot;,
5699       &quot;http://www.w3.org/TR/html4/strict.dtd&quot;},
5700     { &quot;4.0trans&quot;, &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;,
5701       &quot;http://www.w3.org/TR/html4/loose.dtd&quot;},
5702     { &quot;4.0frame&quot;, &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;,
5703       &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;},
5704     { &quot;4.0&quot;, &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;,
5705       &quot;http://www.w3.org/TR/html4/loose.dtd&quot;},
5706     { &quot;3.2&quot;, &quot;-//W3C//DTD HTML 3.2//EN&quot;, NULL }
5707 };
5708 
5709 /**
5710  * xsltGetHTMLIDs:
5711  * @version:  the version string
5712  * @publicID:  used to return the public ID
5713  * @systemID:  used to return the system ID
5714  *
5715  * Returns -1 if not found, 0 otherwise and the system and public
5716  *         Identifier for this given verion of HTML
5717  */
5718 static int
5719 xsltGetHTMLIDs(const xmlChar *version, const xmlChar **publicID,
5720                 const xmlChar **systemID) {
5721     unsigned int i;
5722     if (version == NULL)
5723     return(-1);
5724     for (i = 0;i &lt; (sizeof(xsltHTMLVersions)/sizeof(xsltHTMLVersions[1]));
5725      i++) {
5726     if (!xmlStrcasecmp(version,
5727                    (const xmlChar *) xsltHTMLVersions[i].version)) {
5728         if (publicID != NULL)
5729         *publicID = (const xmlChar *) xsltHTMLVersions[i].public;
5730         if (systemID != NULL)
5731         *systemID = (const xmlChar *) xsltHTMLVersions[i].system;
5732         return(0);
5733     }
5734     }
5735     return(-1);
5736 }
5737 #endif
5738 
5739 /**
5740  * xsltApplyStripSpaces:
5741  * @ctxt:  a XSLT process context
5742  * @node:  the root of the XML tree
5743  *
5744  * Strip the unwanted ignorable spaces from the input tree
5745  */
5746 void
5747 xsltApplyStripSpaces(xsltTransformContextPtr ctxt, xmlNodePtr node) {
5748     xmlNodePtr current;
5749 #ifdef WITH_XSLT_DEBUG_PROCESS
5750     int nb = 0;
5751 #endif
5752 
5753 
5754     current = node;
5755     while (current != NULL) {
5756     /*
5757      * Cleanup children empty nodes if asked for
5758      */
5759     if ((IS_XSLT_REAL_NODE(current)) &amp;&amp;
5760         (current-&gt;children != NULL) &amp;&amp;
5761         (xsltFindElemSpaceHandling(ctxt, current))) {
5762         xmlNodePtr delete = NULL, cur = current-&gt;children;
5763 
5764         while (cur != NULL) {
5765         if (IS_BLANK_NODE(cur))
5766             delete = cur;
5767 
5768         cur = cur-&gt;next;
5769         if (delete != NULL) {
5770             xmlUnlinkNode(delete);
5771             xmlFreeNode(delete);
5772             delete = NULL;
5773 #ifdef WITH_XSLT_DEBUG_PROCESS
5774             nb++;
5775 #endif
5776         }
5777         }
5778     }
5779 
5780     /*
5781      * Skip to next node in document order.
5782      */
5783     if (node-&gt;type == XML_ENTITY_REF_NODE) {
5784         /* process deep in entities */
5785         xsltApplyStripSpaces(ctxt, node-&gt;children);
5786     }
5787     if ((current-&gt;children != NULL) &amp;&amp;
5788             (current-&gt;type != XML_ENTITY_REF_NODE)) {
5789         current = current-&gt;children;
5790     } else if (current-&gt;next != NULL) {
5791         current = current-&gt;next;
5792     } else {
5793         do {
5794         current = current-&gt;parent;
5795         if (current == NULL)
5796             break;
5797         if (current == node)
5798             goto done;
5799         if (current-&gt;next != NULL) {
5800             current = current-&gt;next;
5801             break;
5802         }
5803         } while (current != NULL);
5804     }
5805     }
5806 
5807 done:
5808 #ifdef WITH_XSLT_DEBUG_PROCESS
5809     XSLT_TRACE(ctxt,XSLT_TRACE_STRIP_SPACES,xsltGenericDebug(xsltGenericDebugContext,
5810          &quot;xsltApplyStripSpaces: removed %d ignorable blank node\n&quot;, nb));
5811 #endif
5812     return;
5813 }
5814 
5815 static int
5816 xsltCountKeys(xsltTransformContextPtr ctxt)
5817 {
5818     xsltStylesheetPtr style;
5819     xsltKeyDefPtr keyd;
5820 
5821     if (ctxt == NULL)
5822     return(-1);
5823 
5824     /*
5825     * Do we have those nastly templates with a key() in the match pattern?
5826     */
5827     ctxt-&gt;hasTemplKeyPatterns = 0;
5828     style = ctxt-&gt;style;
5829     while (style != NULL) {
5830     if (style-&gt;keyMatch != NULL) {
5831         ctxt-&gt;hasTemplKeyPatterns = 1;
5832         break;
5833     }
5834     style = xsltNextImport(style);
5835     }
5836     /*
5837     * Count number of key declarations.
5838     */
5839     ctxt-&gt;nbKeys = 0;
5840     style = ctxt-&gt;style;
5841     while (style != NULL) {
5842     keyd = style-&gt;keys;
5843     while (keyd) {
5844         ctxt-&gt;nbKeys++;
5845         keyd = keyd-&gt;next;
5846     }
5847     style = xsltNextImport(style);
5848     }
5849     return(ctxt-&gt;nbKeys);
5850 }
5851 
5852 /**
5853  * xsltApplyStylesheetInternal:
5854  * @style:  a parsed XSLT stylesheet
5855  * @doc:  a parsed XML document
5856  * @params:  a NULL terminated array of parameters names/values tuples
5857  * @output:  the targetted output
5858  * @profile:  profile FILE * output or NULL
5859  * @user:  user provided parameter
5860  *
5861  * Apply the stylesheet to the document
5862  * NOTE: This may lead to a non-wellformed output XML wise !
5863  *
5864  * Returns the result document or NULL in case of error
5865  */
5866 static xmlDocPtr
5867 xsltApplyStylesheetInternal(xsltStylesheetPtr style, xmlDocPtr doc,
5868                             const char **params, const char *output,
5869                             FILE * profile, xsltTransformContextPtr userCtxt)
5870 {
5871     xmlDocPtr res = NULL;
5872     xsltTransformContextPtr ctxt = NULL;
5873     xmlNodePtr root, node;
5874     const xmlChar *method;
5875     const xmlChar *doctypePublic;
5876     const xmlChar *doctypeSystem;
5877     const xmlChar *version;
5878     const xmlChar *encoding;
5879     xsltStackElemPtr variables;
5880     xsltStackElemPtr vptr;
5881 
5882     xsltInitGlobals();
5883 
5884     if ((style == NULL) || (doc == NULL))
5885         return (NULL);
5886 
5887     if (style-&gt;internalized == 0) {
5888 #ifdef WITH_XSLT_DEBUG
5889     xsltGenericDebug(xsltGenericDebugContext,
5890              &quot;Stylesheet was not fully internalized !\n&quot;);
5891 #endif
5892     }
5893     if (doc-&gt;intSubset != NULL) {
5894     /*
5895      * Avoid hitting the DTD when scanning nodes
5896      * but keep it linked as doc-&gt;intSubset
5897      */
5898     xmlNodePtr cur = (xmlNodePtr) doc-&gt;intSubset;
5899     if (cur-&gt;next != NULL)
5900         cur-&gt;next-&gt;prev = cur-&gt;prev;
5901     if (cur-&gt;prev != NULL)
5902         cur-&gt;prev-&gt;next = cur-&gt;next;
5903     if (doc-&gt;children == cur)
5904         doc-&gt;children = cur-&gt;next;
5905     if (doc-&gt;last == cur)
5906         doc-&gt;last = cur-&gt;prev;
5907     cur-&gt;prev = cur-&gt;next = NULL;
5908     }
5909 
5910     /*
5911      * Check for XPath document order availability
5912      */
5913     root = xmlDocGetRootElement(doc);
5914     if (root != NULL) {
5915     if (((ptrdiff_t) root-&gt;content &gt;= 0) &amp;&amp;
5916             (xslDebugStatus == XSLT_DEBUG_NONE))
5917         xmlXPathOrderDocElems(doc);
5918     }
5919 
5920     if (userCtxt != NULL)
5921     ctxt = userCtxt;
5922     else
5923     ctxt = xsltNewTransformContext(style, doc);
5924 
5925     if (ctxt == NULL)
5926         return (NULL);
5927 
5928     ctxt-&gt;initialContextDoc = doc;
5929     ctxt-&gt;initialContextNode = (xmlNodePtr) doc;
5930 
5931     if (profile != NULL) {
5932 #ifdef WITH_PROFILER
5933         ctxt-&gt;profile = 1;
5934 #else
5935         xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,
5936                 &quot;xsltApplyStylesheetInternal: &quot;
5937                 &quot;libxslt compiled without profiler\n&quot;);
5938         goto error;
5939 #endif
5940     }
5941 
5942     if (output != NULL)
5943         ctxt-&gt;outputFile = output;
5944     else
5945         ctxt-&gt;outputFile = NULL;
5946 
5947     /*
5948      * internalize the modes if needed
5949      */
5950     if (ctxt-&gt;dict != NULL) {
5951         if (ctxt-&gt;mode != NULL)
5952         ctxt-&gt;mode = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;mode, -1);
5953         if (ctxt-&gt;modeURI != NULL)
5954         ctxt-&gt;modeURI = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;modeURI, -1);
5955     }
5956 
5957     XSLT_GET_IMPORT_PTR(method, style, method)
5958     XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
5959     XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
5960     XSLT_GET_IMPORT_PTR(version, style, version)
5961     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
5962 
5963     if ((method != NULL) &amp;&amp;
5964     (!xmlStrEqual(method, (const xmlChar *) &quot;xml&quot;)))
5965     {
5966         if (xmlStrEqual(method, (const xmlChar *) &quot;html&quot;)) {
5967             ctxt-&gt;type = XSLT_OUTPUT_HTML;
5968             if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {
5969                 res = htmlNewDoc(doctypeSystem, doctypePublic);
5970         } else {
5971                 if (version == NULL) {
5972             xmlDtdPtr dtd;
5973 
5974             res = htmlNewDoc(NULL, NULL);
5975             /*
5976             * Make sure no DTD node is generated in this case
5977             */
5978             if (res != NULL) {
5979             dtd = xmlGetIntSubset(res);
5980             if (dtd != NULL) {
5981                 xmlUnlinkNode((xmlNodePtr) dtd);
5982                 xmlFreeDtd(dtd);
5983             }
5984             res-&gt;intSubset = NULL;
5985             res-&gt;extSubset = NULL;
5986             }
5987         } else {
5988 
5989 #ifdef XSLT_GENERATE_HTML_DOCTYPE
5990             xsltGetHTMLIDs(version, &amp;doctypePublic, &amp;doctypeSystem);
5991 #endif
5992             res = htmlNewDoc(doctypeSystem, doctypePublic);
5993         }
5994             }
5995             if (res == NULL)
5996                 goto error;
5997         res-&gt;dict = ctxt-&gt;dict;
5998         xmlDictReference(res-&gt;dict);
5999 
6000 #ifdef WITH_XSLT_DEBUG
6001         xsltGenericDebug(xsltGenericDebugContext,
6002         &quot;reusing transformation dict for output\n&quot;);
6003 #endif
6004         } else if (xmlStrEqual(method, (const xmlChar *) &quot;xhtml&quot;)) {
6005         xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,
6006         &quot;xsltApplyStylesheetInternal: unsupported method xhtml, using html\n&quot;);
6007             ctxt-&gt;type = XSLT_OUTPUT_HTML;
6008             res = htmlNewDoc(doctypeSystem, doctypePublic);
6009             if (res == NULL)
6010                 goto error;
6011         res-&gt;dict = ctxt-&gt;dict;
6012         xmlDictReference(res-&gt;dict);
6013 
6014 #ifdef WITH_XSLT_DEBUG
6015         xsltGenericDebug(xsltGenericDebugContext,
6016         &quot;reusing transformation dict for output\n&quot;);
6017 #endif
6018         } else if (xmlStrEqual(method, (const xmlChar *) &quot;text&quot;)) {
6019             ctxt-&gt;type = XSLT_OUTPUT_TEXT;
6020             res = xmlNewDoc(style-&gt;version);
6021             if (res == NULL)
6022                 goto error;
6023         res-&gt;dict = ctxt-&gt;dict;
6024         xmlDictReference(res-&gt;dict);
6025 
6026 #ifdef WITH_XSLT_DEBUG
6027         xsltGenericDebug(xsltGenericDebugContext,
6028         &quot;reusing transformation dict for output\n&quot;);
6029 #endif
6030         } else {
6031         xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,
6032         &quot;xsltApplyStylesheetInternal: unsupported method (%s)\n&quot;,
6033         method);
6034             goto error;
6035         }
6036     } else {
6037         ctxt-&gt;type = XSLT_OUTPUT_XML;
6038         res = xmlNewDoc(style-&gt;version);
6039         if (res == NULL)
6040             goto error;
6041     res-&gt;dict = ctxt-&gt;dict;
6042     xmlDictReference(ctxt-&gt;dict);
6043 #ifdef WITH_XSLT_DEBUG
6044     xsltGenericDebug(xsltGenericDebugContext,
6045              &quot;reusing transformation dict for output\n&quot;);
6046 #endif
6047     }
6048     res-&gt;charset = XML_CHAR_ENCODING_UTF8;
6049     if (encoding != NULL)
6050         res-&gt;encoding = xmlStrdup(encoding);
6051     variables = style-&gt;variables;
6052 
6053     ctxt-&gt;node = (xmlNodePtr) doc;
6054     ctxt-&gt;output = res;
6055 
6056     ctxt-&gt;xpathCtxt-&gt;contextSize = 1;
6057     ctxt-&gt;xpathCtxt-&gt;proximityPosition = 1;
6058     ctxt-&gt;xpathCtxt-&gt;node = NULL; /* TODO: Set the context node here? */
6059 
6060     /*
6061      * Start the evaluation, evaluate the params, the stylesheets globals
6062      * and start by processing the top node.
6063      */
6064     if (xsltNeedElemSpaceHandling(ctxt))
6065     xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));
6066     /*
6067     * Evaluate global params and user-provided params.
6068     */
6069     if (ctxt-&gt;globalVars == NULL)
6070     ctxt-&gt;globalVars = xmlHashCreate(20);
6071     if (params != NULL) {
6072         xsltEvalUserParams(ctxt, params);
6073     }
6074 
6075     /* need to be called before evaluating global variables */
6076     xsltCountKeys(ctxt);
6077 
6078     xsltEvalGlobalVariables(ctxt);
6079 
6080     /* Clean up any unused RVTs. */
6081     xsltReleaseLocalRVTs(ctxt, NULL);
6082 
6083     ctxt-&gt;insert = (xmlNodePtr) res;
6084     ctxt-&gt;varsBase = ctxt-&gt;varsNr - 1;
6085 
6086     /*
6087     * Start processing the source tree -----------------------------------
6088     */
6089     xsltProcessOneNode(ctxt, ctxt-&gt;node, NULL);
6090     /*
6091     * Remove all remaining vars from the stack.
6092     */
6093     xsltLocalVariablePop(ctxt, 0, -2);
6094     xsltShutdownCtxtExts(ctxt);
6095 
6096     xsltCleanupTemplates(style); /* TODO: &lt;- style should be read only */
6097 
6098     /*
6099      * Now cleanup our variables so stylesheet can be re-used
6100      *
6101      * TODO: this is not needed anymore global variables are copied
6102      *       and not evaluated directly anymore, keep this as a check
6103      */
6104     if (style-&gt;variables != variables) {
6105         vptr = style-&gt;variables;
6106         while (vptr-&gt;next != variables)
6107             vptr = vptr-&gt;next;
6108         vptr-&gt;next = NULL;
6109         xsltFreeStackElemList(style-&gt;variables);
6110         style-&gt;variables = variables;
6111     }
6112     vptr = style-&gt;variables;
6113     while (vptr != NULL) {
6114         if (vptr-&gt;computed) {
6115             if (vptr-&gt;value != NULL) {
6116                 xmlXPathFreeObject(vptr-&gt;value);
6117                 vptr-&gt;value = NULL;
6118                 vptr-&gt;computed = 0;
6119             }
6120         }
6121         vptr = vptr-&gt;next;
6122     }
6123 #if 0
6124     /*
6125      * code disabled by wmb; awaiting kb&#39;s review
6126      * problem is that global variable(s) may contain xpath objects
6127      * from doc associated with RVT, so can&#39;t be freed at this point.
6128      * xsltFreeTransformContext includes a call to xsltFreeRVTs, so
6129      * I assume this shouldn&#39;t be required at this point.
6130      */
6131     /*
6132     * Free all remaining tree fragments.
6133     */
6134     xsltFreeRVTs(ctxt);
6135 #endif
6136     /*
6137      * Do some post processing work depending on the generated output
6138      */
6139     root = xmlDocGetRootElement(res);
6140     if (root != NULL) {
6141         const xmlChar *doctype = NULL;
6142 
6143         if ((root-&gt;ns != NULL) &amp;&amp; (root-&gt;ns-&gt;prefix != NULL))
6144         doctype = xmlDictQLookup(ctxt-&gt;dict, root-&gt;ns-&gt;prefix, root-&gt;name);
6145     if (doctype == NULL)
6146         doctype = root-&gt;name;
6147 
6148         /*
6149          * Apply the default selection of the method
6150          */
6151         if ((method == NULL) &amp;&amp;
6152             (root-&gt;ns == NULL) &amp;&amp;
6153             (!xmlStrcasecmp(root-&gt;name, (const xmlChar *) &quot;html&quot;))) {
6154             xmlNodePtr tmp;
6155 
6156             tmp = res-&gt;children;
6157             while ((tmp != NULL) &amp;&amp; (tmp != root)) {
6158                 if (tmp-&gt;type == XML_ELEMENT_NODE)
6159                     break;
6160                 if ((tmp-&gt;type == XML_TEXT_NODE) &amp;&amp; (!xmlIsBlankNode(tmp)))
6161                     break;
6162         tmp = tmp-&gt;next;
6163             }
6164             if (tmp == root) {
6165                 ctxt-&gt;type = XSLT_OUTPUT_HTML;
6166         /*
6167         * REVISIT TODO: XML_HTML_DOCUMENT_NODE is set after the
6168         *  transformation on the doc, but functions like
6169         */
6170                 res-&gt;type = XML_HTML_DOCUMENT_NODE;
6171                 if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {
6172                     res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
6173                                                         doctypePublic,
6174                                                         doctypeSystem);
6175 #ifdef XSLT_GENERATE_HTML_DOCTYPE
6176         } else if (version != NULL) {
6177                     xsltGetHTMLIDs(version, &amp;doctypePublic,
6178                                    &amp;doctypeSystem);
6179                     if (((doctypePublic != NULL) || (doctypeSystem != NULL)))
6180                         res-&gt;intSubset =
6181                             xmlCreateIntSubset(res, doctype,
6182                                                doctypePublic,
6183                                                doctypeSystem);
6184 #endif
6185                 }
6186             }
6187 
6188         }
6189         if (ctxt-&gt;type == XSLT_OUTPUT_XML) {
6190             XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)
6191             XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)
6192             if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {
6193             xmlNodePtr last;
6194         /* Need a small &quot;hack&quot; here to assure DTD comes before
6195            possible comment nodes */
6196         node = res-&gt;children;
6197         last = res-&gt;last;
6198         res-&gt;children = NULL;
6199         res-&gt;last = NULL;
6200                 res-&gt;intSubset = xmlCreateIntSubset(res, doctype,
6201                                                     doctypePublic,
6202                                                     doctypeSystem);
6203         if (res-&gt;children != NULL) {
6204             res-&gt;children-&gt;next = node;
6205             node-&gt;prev = res-&gt;children;
6206             res-&gt;last = last;
6207         } else {
6208             res-&gt;children = node;
6209             res-&gt;last = last;
6210         }
6211         }
6212         }
6213     }
6214     xmlXPathFreeNodeSet(ctxt-&gt;nodeList);
6215 
6216 #ifdef WITH_PROFILER
6217     if (profile != NULL) {
6218         xsltSaveProfiling(ctxt, profile);
6219     }
6220 #endif
6221 
6222     /*
6223      * Be pedantic.
6224      */
6225     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;state != XSLT_STATE_OK)) {
6226     xmlFreeDoc(res);
6227     res = NULL;
6228     }
6229     if ((res != NULL) &amp;&amp; (ctxt != NULL) &amp;&amp; (output != NULL)) {
6230     int ret;
6231 
6232     ret = xsltCheckWrite(ctxt-&gt;sec, ctxt, (const xmlChar *) output);
6233     if (ret == 0) {
6234         xsltTransformError(ctxt, NULL, NULL,
6235              &quot;xsltApplyStylesheet: forbidden to save to %s\n&quot;,
6236                    output);
6237     } else if (ret &lt; 0) {
6238         xsltTransformError(ctxt, NULL, NULL,
6239              &quot;xsltApplyStylesheet: saving to %s may not be possible\n&quot;,
6240                    output);
6241     }
6242     }
6243 
6244 #ifdef XSLT_DEBUG_PROFILE_CACHE
6245     printf(&quot;# Cache:\n&quot;);
6246     printf(&quot;# Reused tree fragments: %d\n&quot;, ctxt-&gt;cache-&gt;dbgReusedRVTs);
6247     printf(&quot;# Reused variables     : %d\n&quot;, ctxt-&gt;cache-&gt;dbgReusedVars);
6248 #endif
6249 
6250     if ((ctxt != NULL) &amp;&amp; (userCtxt == NULL))
6251     xsltFreeTransformContext(ctxt);
6252 
6253     return (res);
6254 
6255 error:
6256     if (res != NULL)
6257         xmlFreeDoc(res);
6258 
6259 #ifdef XSLT_DEBUG_PROFILE_CACHE
6260     printf(&quot;# Cache:\n&quot;);
6261     printf(&quot;# Reused tree fragments: %d\n&quot;, ctxt-&gt;cache-&gt;dbgReusedRVTs);
6262     printf(&quot;# Reused variables     : %d\n&quot;, ctxt-&gt;cache-&gt;dbgReusedVars);
6263 #endif
6264 
6265     if ((ctxt != NULL) &amp;&amp; (userCtxt == NULL))
6266         xsltFreeTransformContext(ctxt);
6267     return (NULL);
6268 }
6269 
6270 /**
6271  * xsltApplyStylesheet:
6272  * @style:  a parsed XSLT stylesheet
6273  * @doc:  a parsed XML document
6274  * @params:  a NULL terminated arry of parameters names/values tuples
6275  *
6276  * Apply the stylesheet to the document
6277  * NOTE: This may lead to a non-wellformed output XML wise !
6278  *
6279  * Returns the result document or NULL in case of error
6280  */
6281 xmlDocPtr
6282 xsltApplyStylesheet(xsltStylesheetPtr style, xmlDocPtr doc,
6283                     const char **params)
6284 {
6285     return (xsltApplyStylesheetInternal(style, doc, params, NULL, NULL, NULL));
6286 }
6287 
6288 /**
6289  * xsltProfileStylesheet:
6290  * @style:  a parsed XSLT stylesheet
6291  * @doc:  a parsed XML document
6292  * @params:  a NULL terminated arry of parameters names/values tuples
6293  * @output:  a FILE * for the profiling output
6294  *
6295  * Apply the stylesheet to the document and dump the profiling to
6296  * the given output.
6297  *
6298  * Returns the result document or NULL in case of error
6299  */
6300 xmlDocPtr
6301 xsltProfileStylesheet(xsltStylesheetPtr style, xmlDocPtr doc,
6302                       const char **params, FILE * output)
6303 {
6304     xmlDocPtr res;
6305 
6306     res = xsltApplyStylesheetInternal(style, doc, params, NULL, output, NULL);
6307     return (res);
6308 }
6309 
6310 /**
6311  * xsltApplyStylesheetUser:
6312  * @style:  a parsed XSLT stylesheet
6313  * @doc:  a parsed XML document
6314  * @params:  a NULL terminated array of parameters names/values tuples
6315  * @output:  the targetted output
6316  * @profile:  profile FILE * output or NULL
6317  * @userCtxt:  user provided transform context
6318  *
6319  * Apply the stylesheet to the document and allow the user to provide
6320  * its own transformation context.
6321  *
6322  * Returns the result document or NULL in case of error
6323  */
6324 xmlDocPtr
6325 xsltApplyStylesheetUser(xsltStylesheetPtr style, xmlDocPtr doc,
6326                             const char **params, const char *output,
6327                             FILE * profile, xsltTransformContextPtr userCtxt)
6328 {
6329     xmlDocPtr res;
6330 
6331     res = xsltApplyStylesheetInternal(style, doc, params, output,
6332                                   profile, userCtxt);
6333     return (res);
6334 }
6335 
6336 /**
6337  * xsltRunStylesheetUser:
6338  * @style:  a parsed XSLT stylesheet
6339  * @doc:  a parsed XML document
6340  * @params:  a NULL terminated array of parameters names/values tuples
6341  * @output:  the URL/filename ot the generated resource if available
6342  * @SAX:  a SAX handler for progressive callback output (not implemented yet)
6343  * @IObuf:  an output buffer for progressive output (not implemented yet)
6344  * @profile:  profile FILE * output or NULL
6345  * @userCtxt:  user provided transform context
6346  *
6347  * Apply the stylesheet to the document and generate the output according
6348  * to @output @SAX and @IObuf. It&#39;s an error to specify both @SAX and @IObuf.
6349  *
6350  * NOTE: This may lead to a non-wellformed output XML wise !
6351  * NOTE: This may also result in multiple files being generated
6352  * NOTE: using IObuf, the result encoding used will be the one used for
6353  *       creating the output buffer, use the following macro to read it
6354  *       from the stylesheet
6355  *       XSLT_GET_IMPORT_PTR(encoding, style, encoding)
6356  * NOTE: using SAX, any encoding specified in the stylesheet will be lost
6357  *       since the interface uses only UTF8
6358  *
6359  * Returns the number of by written to the main resource or -1 in case of
6360  *         error.
6361  */
6362 int
6363 xsltRunStylesheetUser(xsltStylesheetPtr style, xmlDocPtr doc,
6364                   const char **params, const char *output,
6365                   xmlSAXHandlerPtr SAX, xmlOutputBufferPtr IObuf,
6366           FILE * profile, xsltTransformContextPtr userCtxt)
6367 {
6368     xmlDocPtr tmp;
6369     int ret;
6370 
6371     if ((output == NULL) &amp;&amp; (SAX == NULL) &amp;&amp; (IObuf == NULL))
6372         return (-1);
6373     if ((SAX != NULL) &amp;&amp; (IObuf != NULL))
6374         return (-1);
6375 
6376     /* unsupported yet */
6377     if (SAX != NULL) {
6378         XSLT_TODO   /* xsltRunStylesheet xmlSAXHandlerPtr SAX */
6379     return (-1);
6380     }
6381 
6382     tmp = xsltApplyStylesheetInternal(style, doc, params, output, profile,
6383                                   userCtxt);
6384     if (tmp == NULL) {
6385     xsltTransformError(NULL, NULL, (xmlNodePtr) doc,
6386                          &quot;xsltRunStylesheet : run failed\n&quot;);
6387         return (-1);
6388     }
6389     if (IObuf != NULL) {
6390         /* TODO: incomplete, IObuf output not progressive */
6391         ret = xsltSaveResultTo(IObuf, tmp, style);
6392     } else {
6393         ret = xsltSaveResultToFilename(output, tmp, style, 0);
6394     }
6395     xmlFreeDoc(tmp);
6396     return (ret);
6397 }
6398 
6399 /**
6400  * xsltRunStylesheet:
6401  * @style:  a parsed XSLT stylesheet
6402  * @doc:  a parsed XML document
6403  * @params:  a NULL terminated array of parameters names/values tuples
6404  * @output:  the URL/filename ot the generated resource if available
6405  * @SAX:  a SAX handler for progressive callback output (not implemented yet)
6406  * @IObuf:  an output buffer for progressive output (not implemented yet)
6407  *
6408  * Apply the stylesheet to the document and generate the output according
6409  * to @output @SAX and @IObuf. It&#39;s an error to specify both @SAX and @IObuf.
6410  *
6411  * NOTE: This may lead to a non-wellformed output XML wise !
6412  * NOTE: This may also result in multiple files being generated
6413  * NOTE: using IObuf, the result encoding used will be the one used for
6414  *       creating the output buffer, use the following macro to read it
6415  *       from the stylesheet
6416  *       XSLT_GET_IMPORT_PTR(encoding, style, encoding)
6417  * NOTE: using SAX, any encoding specified in the stylesheet will be lost
6418  *       since the interface uses only UTF8
6419  *
6420  * Returns the number of bytes written to the main resource or -1 in case of
6421  *         error.
6422  */
6423 int
6424 xsltRunStylesheet(xsltStylesheetPtr style, xmlDocPtr doc,
6425                   const char **params, const char *output,
6426                   xmlSAXHandlerPtr SAX, xmlOutputBufferPtr IObuf)
6427 {
6428     return(xsltRunStylesheetUser(style, doc, params, output, SAX, IObuf,
6429                          NULL, NULL));
6430 }
6431 
6432 static void
6433 xsltMessageWrapper(xsltTransformContextPtr ctxt, xmlNodePtr node,
6434                    xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {
6435     xsltMessage(ctxt, node, inst);
6436 }
6437 
6438 /**
6439  * xsltRegisterAllElement:
6440  * @ctxt:  the XPath context
6441  *
6442  * Registers all default XSLT elements in this context
6443  */
6444 void
6445 xsltRegisterAllElement(xsltTransformContextPtr ctxt)
6446 {
6447     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;apply-templates&quot;,
6448                            XSLT_NAMESPACE,
6449                xsltApplyTemplates);
6450     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;apply-imports&quot;,
6451                            XSLT_NAMESPACE,
6452                xsltApplyImports);
6453     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;call-template&quot;,
6454                            XSLT_NAMESPACE,
6455                xsltCallTemplate);
6456     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;element&quot;,
6457                            XSLT_NAMESPACE,
6458                xsltElement);
6459     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;attribute&quot;,
6460                            XSLT_NAMESPACE,
6461                xsltAttribute);
6462     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;text&quot;,
6463                            XSLT_NAMESPACE,
6464                xsltText);
6465     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;processing-instruction&quot;,
6466                            XSLT_NAMESPACE,
6467                xsltProcessingInstruction);
6468     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;comment&quot;,
6469                            XSLT_NAMESPACE,
6470                xsltComment);
6471     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;copy&quot;,
6472                            XSLT_NAMESPACE,
6473                xsltCopy);
6474     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;value-of&quot;,
6475                            XSLT_NAMESPACE,
6476                xsltValueOf);
6477     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;number&quot;,
6478                            XSLT_NAMESPACE,
6479                xsltNumber);
6480     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;for-each&quot;,
6481                            XSLT_NAMESPACE,
6482                xsltForEach);
6483     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;if&quot;,
6484                            XSLT_NAMESPACE,
6485                xsltIf);
6486     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;choose&quot;,
6487                            XSLT_NAMESPACE,
6488                xsltChoose);
6489     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;sort&quot;,
6490                            XSLT_NAMESPACE,
6491                xsltSort);
6492     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;copy-of&quot;,
6493                            XSLT_NAMESPACE,
6494                xsltCopyOf);
6495     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;message&quot;,
6496                            XSLT_NAMESPACE,
6497                xsltMessageWrapper);
6498 
6499     /*
6500      * Those don&#39;t have callable entry points but are registered anyway
6501      */
6502     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;variable&quot;,
6503                            XSLT_NAMESPACE,
6504                xsltDebug);
6505     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;param&quot;,
6506                            XSLT_NAMESPACE,
6507                xsltDebug);
6508     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;with-param&quot;,
6509                            XSLT_NAMESPACE,
6510                xsltDebug);
6511     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;decimal-format&quot;,
6512                            XSLT_NAMESPACE,
6513                xsltDebug);
6514     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;when&quot;,
6515                            XSLT_NAMESPACE,
6516                xsltDebug);
6517     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;otherwise&quot;,
6518                            XSLT_NAMESPACE,
6519                xsltDebug);
6520     xsltRegisterExtElement(ctxt, (const xmlChar *) &quot;fallback&quot;,
6521                            XSLT_NAMESPACE,
6522                xsltDebug);
6523 
6524 }
    </pre>
  </body>
</html>