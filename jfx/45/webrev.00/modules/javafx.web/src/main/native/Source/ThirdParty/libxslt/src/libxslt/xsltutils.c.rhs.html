<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xsltutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * xsltutils.c: Utilities for the XSL Transformation 1.0 engine
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  */
  11 
  12 #define IN_LIBXSLT
  13 #include &quot;libxslt.h&quot;
  14 
  15 #ifndef XSLT_NEED_TRIO
  16 #include &lt;stdio.h&gt;
  17 #else
  18 #include &lt;trio.h&gt;
  19 #endif
  20 
  21 #include &lt;string.h&gt;
  22 #include &lt;time.h&gt;
  23 #ifdef HAVE_SYS_TIME_H
  24 #include &lt;sys/time.h&gt;
  25 #endif
  26 #ifdef HAVE_UNISTD_H
  27 #include &lt;unistd.h&gt;
  28 #endif
  29 #ifdef HAVE_STDLIB_H
  30 #include &lt;stdlib.h&gt;
  31 #endif
  32 #include &lt;stdarg.h&gt;
  33 
  34 #include &lt;libxml/xmlmemory.h&gt;
  35 #include &lt;libxml/tree.h&gt;
  36 #include &lt;libxml/HTMLtree.h&gt;
  37 #include &lt;libxml/xmlerror.h&gt;
  38 #include &lt;libxml/xmlIO.h&gt;
  39 #include &quot;xsltutils.h&quot;
  40 #include &quot;templates.h&quot;
  41 #include &quot;xsltInternals.h&quot;
  42 #include &quot;imports.h&quot;
  43 #include &quot;transform.h&quot;
  44 
  45 #if defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
  46 #define XSLT_WIN32_PERFORMANCE_COUNTER
  47 #endif
  48 
  49 /************************************************************************
  50  *                                  *
  51  *          Convenience function                *
  52  *                                  *
  53  ************************************************************************/
  54 
  55 /**
  56  * xsltGetCNsProp:
  57  * @style: the stylesheet
  58  * @node:  the node
  59  * @name:  the attribute name
  60  * @nameSpace:  the URI of the namespace
  61  *
  62  * Similar to xmlGetNsProp() but with a slightly different semantic
  63  *
  64  * Search and get the value of an attribute associated to a node
  65  * This attribute has to be anchored in the namespace specified,
  66  * or has no namespace and the element is in that namespace.
  67  *
  68  * This does the entity substitution.
  69  * This function looks in DTD attribute declaration for #FIXED or
  70  * default declaration values unless DTD use has been turned off.
  71  *
  72  * Returns the attribute value or NULL if not found. The string is allocated
  73  *         in the stylesheet dictionary.
  74  */
  75 const xmlChar *
  76 xsltGetCNsProp(xsltStylesheetPtr style, xmlNodePtr node,
  77               const xmlChar *name, const xmlChar *nameSpace) {
  78     xmlAttrPtr prop;
  79     xmlDocPtr doc;
  80     xmlNsPtr ns;
  81     xmlChar *tmp;
  82     const xmlChar *ret;
  83 
  84     if ((node == NULL) || (style == NULL) || (style-&gt;dict == NULL))
  85     return(NULL);
  86 
  87     if (nameSpace == NULL)
  88         return xmlGetProp(node, name);
  89 
  90     if (node-&gt;type == XML_NAMESPACE_DECL)
  91         return(NULL);
  92     if (node-&gt;type == XML_ELEMENT_NODE)
  93     prop = node-&gt;properties;
  94     else
  95     prop = NULL;
  96     while (prop != NULL) {
  97     /*
  98      * One need to have
  99      *   - same attribute names
 100      *   - and the attribute carrying that namespace
 101      */
 102         if ((xmlStrEqual(prop-&gt;name, name)) &amp;&amp;
 103         (((prop-&gt;ns == NULL) &amp;&amp; (node-&gt;ns != NULL) &amp;&amp;
 104           (xmlStrEqual(node-&gt;ns-&gt;href, nameSpace))) ||
 105          ((prop-&gt;ns != NULL) &amp;&amp;
 106           (xmlStrEqual(prop-&gt;ns-&gt;href, nameSpace))))) {
 107 
 108         tmp = xmlNodeListGetString(node-&gt;doc, prop-&gt;children, 1);
 109         if (tmp == NULL)
 110             ret = xmlDictLookup(style-&gt;dict, BAD_CAST &quot;&quot;, 0);
 111         else {
 112             ret = xmlDictLookup(style-&gt;dict, tmp, -1);
 113         xmlFree(tmp);
 114         }
 115         return ret;
 116         }
 117     prop = prop-&gt;next;
 118     }
 119     tmp = NULL;
 120     /*
 121      * Check if there is a default declaration in the internal
 122      * or external subsets
 123      */
 124     doc =  node-&gt;doc;
 125     if (doc != NULL) {
 126         if (doc-&gt;intSubset != NULL) {
 127         xmlAttributePtr attrDecl;
 128 
 129         attrDecl = xmlGetDtdAttrDesc(doc-&gt;intSubset, node-&gt;name, name);
 130         if ((attrDecl == NULL) &amp;&amp; (doc-&gt;extSubset != NULL))
 131         attrDecl = xmlGetDtdAttrDesc(doc-&gt;extSubset, node-&gt;name, name);
 132 
 133         if ((attrDecl != NULL) &amp;&amp; (attrDecl-&gt;prefix != NULL)) {
 134             /*
 135          * The DTD declaration only allows a prefix search
 136          */
 137         ns = xmlSearchNs(doc, node, attrDecl-&gt;prefix);
 138         if ((ns != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;href, nameSpace)))
 139             return(xmlDictLookup(style-&gt;dict,
 140                                  attrDecl-&gt;defaultValue, -1));
 141         }
 142     }
 143     }
 144     return(NULL);
 145 }
 146 /**
 147  * xsltGetNsProp:
 148  * @node:  the node
 149  * @name:  the attribute name
 150  * @nameSpace:  the URI of the namespace
 151  *
 152  * Similar to xmlGetNsProp() but with a slightly different semantic
 153  *
 154  * Search and get the value of an attribute associated to a node
 155  * This attribute has to be anchored in the namespace specified,
 156  * or has no namespace and the element is in that namespace.
 157  *
 158  * This does the entity substitution.
 159  * This function looks in DTD attribute declaration for #FIXED or
 160  * default declaration values unless DTD use has been turned off.
 161  *
 162  * Returns the attribute value or NULL if not found.
 163  *     It&#39;s up to the caller to free the memory.
 164  */
 165 xmlChar *
 166 xsltGetNsProp(xmlNodePtr node, const xmlChar *name, const xmlChar *nameSpace) {
 167     xmlAttrPtr prop;
 168     xmlDocPtr doc;
 169     xmlNsPtr ns;
 170 
 171     if (node == NULL)
 172     return(NULL);
 173 
 174     if (nameSpace == NULL)
 175         return xmlGetProp(node, name);
 176 
 177     if (node-&gt;type == XML_NAMESPACE_DECL)
 178         return(NULL);
 179     if (node-&gt;type == XML_ELEMENT_NODE)
 180     prop = node-&gt;properties;
 181     else
 182     prop = NULL;
 183     /*
 184     * TODO: Substitute xmlGetProp() for xmlGetNsProp(), since the former
 185     * is not namespace-aware and will return an attribute with equal
 186     * name regardless of its namespace.
 187     * Example:
 188     *   &lt;xsl:element foo:name=&quot;myName&quot;/&gt;
 189     *   So this would return &quot;myName&quot; even if an attribute @name
 190     *   in the XSLT was requested.
 191     */
 192     while (prop != NULL) {
 193     /*
 194      * One need to have
 195      *   - same attribute names
 196      *   - and the attribute carrying that namespace
 197      */
 198         if ((xmlStrEqual(prop-&gt;name, name)) &amp;&amp;
 199         (((prop-&gt;ns == NULL) &amp;&amp; (node-&gt;ns != NULL) &amp;&amp;
 200           (xmlStrEqual(node-&gt;ns-&gt;href, nameSpace))) ||
 201          ((prop-&gt;ns != NULL) &amp;&amp;
 202           (xmlStrEqual(prop-&gt;ns-&gt;href, nameSpace))))) {
 203         xmlChar *ret;
 204 
 205         ret = xmlNodeListGetString(node-&gt;doc, prop-&gt;children, 1);
 206         if (ret == NULL) return(xmlStrdup((xmlChar *)&quot;&quot;));
 207         return(ret);
 208         }
 209     prop = prop-&gt;next;
 210     }
 211 
 212     /*
 213      * Check if there is a default declaration in the internal
 214      * or external subsets
 215      */
 216     doc =  node-&gt;doc;
 217     if (doc != NULL) {
 218         if (doc-&gt;intSubset != NULL) {
 219         xmlAttributePtr attrDecl;
 220 
 221         attrDecl = xmlGetDtdAttrDesc(doc-&gt;intSubset, node-&gt;name, name);
 222         if ((attrDecl == NULL) &amp;&amp; (doc-&gt;extSubset != NULL))
 223         attrDecl = xmlGetDtdAttrDesc(doc-&gt;extSubset, node-&gt;name, name);
 224 
 225         if ((attrDecl != NULL) &amp;&amp; (attrDecl-&gt;prefix != NULL)) {
 226             /*
 227          * The DTD declaration only allows a prefix search
 228          */
 229         ns = xmlSearchNs(doc, node, attrDecl-&gt;prefix);
 230         if ((ns != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;href, nameSpace)))
 231             return(xmlStrdup(attrDecl-&gt;defaultValue));
 232         }
 233     }
 234     }
 235     return(NULL);
 236 }
 237 
 238 /**
 239  * xsltGetUTF8Char:
 240  * @utf:  a sequence of UTF-8 encoded bytes
 241  * @len:  a pointer to @bytes len
 242  *
 243  * Read one UTF8 Char from @utf
 244  * Function copied from libxml2 xmlGetUTF8Char() ... to discard ultimately
 245  * and use the original API
 246  *
 247  * Returns the char value or -1 in case of error and update @len with the
 248  *        number of bytes used
 249  */
 250 int
 251 xsltGetUTF8Char(const unsigned char *utf, int *len) {
 252     unsigned int c;
 253 
 254     if (utf == NULL)
 255     goto error;
 256     if (len == NULL)
 257     goto error;
 258     if (*len &lt; 1)
 259     goto error;
 260 
 261     c = utf[0];
 262     if (c &amp; 0x80) {
 263     if (*len &lt; 2)
 264         goto error;
 265     if ((utf[1] &amp; 0xc0) != 0x80)
 266         goto error;
 267     if ((c &amp; 0xe0) == 0xe0) {
 268         if (*len &lt; 3)
 269         goto error;
 270         if ((utf[2] &amp; 0xc0) != 0x80)
 271         goto error;
 272         if ((c &amp; 0xf0) == 0xf0) {
 273         if (*len &lt; 4)
 274             goto error;
 275         if ((c &amp; 0xf8) != 0xf0 || (utf[3] &amp; 0xc0) != 0x80)
 276             goto error;
 277         *len = 4;
 278         /* 4-byte code */
 279         c = (utf[0] &amp; 0x7) &lt;&lt; 18;
 280         c |= (utf[1] &amp; 0x3f) &lt;&lt; 12;
 281         c |= (utf[2] &amp; 0x3f) &lt;&lt; 6;
 282         c |= utf[3] &amp; 0x3f;
 283         } else {
 284           /* 3-byte code */
 285         *len = 3;
 286         c = (utf[0] &amp; 0xf) &lt;&lt; 12;
 287         c |= (utf[1] &amp; 0x3f) &lt;&lt; 6;
 288         c |= utf[2] &amp; 0x3f;
 289         }
 290     } else {
 291       /* 2-byte code */
 292         *len = 2;
 293         c = (utf[0] &amp; 0x1f) &lt;&lt; 6;
 294         c |= utf[1] &amp; 0x3f;
 295     }
 296     } else {
 297     /* 1-byte code */
 298     *len = 1;
 299     }
 300     return(c);
 301 
 302 error:
 303     if (len != NULL)
 304     *len = 0;
 305     return(-1);
 306 }
 307 
 308 #ifdef XSLT_REFACTORED
 309 
 310 /**
 311  * xsltPointerListAddSize:
 312  * @list: the pointer list structure
 313  * @item: the item to be stored
 314  * @initialSize: the initial size of the list
 315  *
 316  * Adds an item to the list.
 317  *
 318  * Returns the position of the added item in the list or
 319  *         -1 in case of an error.
 320  */
 321 int
 322 xsltPointerListAddSize(xsltPointerListPtr list,
 323                void *item,
 324                int initialSize)
 325 {
 326     if (list-&gt;items == NULL) {
 327     if (initialSize &lt;= 0)
 328         initialSize = 1;
 329     list-&gt;items = (void **) xmlMalloc(
 330         initialSize * sizeof(void *));
 331     if (list-&gt;items == NULL) {
 332         xsltGenericError(xsltGenericErrorContext,
 333          &quot;xsltPointerListAddSize: memory allocation failure.\n&quot;);
 334         return(-1);
 335     }
 336     list-&gt;number = 0;
 337     list-&gt;size = initialSize;
 338     } else if (list-&gt;size &lt;= list-&gt;number) {
 339     list-&gt;size *= 2;
 340     list-&gt;items = (void **) xmlRealloc(list-&gt;items,
 341         list-&gt;size * sizeof(void *));
 342     if (list-&gt;items == NULL) {
 343         xsltGenericError(xsltGenericErrorContext,
 344          &quot;xsltPointerListAddSize: memory re-allocation failure.\n&quot;);
 345         list-&gt;size = 0;
 346         return(-1);
 347     }
 348     }
 349     list-&gt;items[list-&gt;number++] = item;
 350     return(0);
 351 }
 352 
 353 /**
 354  * xsltPointerListCreate:
 355  * @initialSize: the initial size for the list
 356  *
 357  * Creates an xsltPointerList structure.
 358  *
 359  * Returns a xsltPointerList structure or NULL in case of an error.
 360  */
 361 xsltPointerListPtr
 362 xsltPointerListCreate(int initialSize)
 363 {
 364     xsltPointerListPtr ret;
 365 
 366     ret = xmlMalloc(sizeof(xsltPointerList));
 367     if (ret == NULL) {
 368     xsltGenericError(xsltGenericErrorContext,
 369          &quot;xsltPointerListCreate: memory allocation failure.\n&quot;);
 370     return (NULL);
 371     }
 372     memset(ret, 0, sizeof(xsltPointerList));
 373     if (initialSize &gt; 0) {
 374     xsltPointerListAddSize(ret, NULL, initialSize);
 375     ret-&gt;number = 0;
 376     }
 377     return (ret);
 378 }
 379 
 380 /**
 381  * xsltPointerListFree:
 382  * @list: pointer to the list to be freed
 383  *
 384  * Frees the xsltPointerList structure. This does not free
 385  * the content of the list.
 386  */
 387 void
 388 xsltPointerListFree(xsltPointerListPtr list)
 389 {
 390     if (list == NULL)
 391     return;
 392     if (list-&gt;items != NULL)
 393     xmlFree(list-&gt;items);
 394     xmlFree(list);
 395 }
 396 
 397 /**
 398  * xsltPointerListClear:
 399  * @list: pointer to the list to be cleared
 400  *
 401  * Resets the list, but does not free the allocated array
 402  * and does not free the content of the list.
 403  */
 404 void
 405 xsltPointerListClear(xsltPointerListPtr list)
 406 {
 407     if (list-&gt;items != NULL) {
 408     xmlFree(list-&gt;items);
 409     list-&gt;items = NULL;
 410     }
 411     list-&gt;number = 0;
 412     list-&gt;size = 0;
 413 }
 414 
 415 #endif /* XSLT_REFACTORED */
 416 
 417 /************************************************************************
 418  *                                  *
 419  *      Handling of XSLT stylesheets messages           *
 420  *                                  *
 421  ************************************************************************/
 422 
 423 /**
 424  * xsltMessage:
 425  * @ctxt:  an XSLT processing context
 426  * @node:  The current node
 427  * @inst:  The node containing the message instruction
 428  *
 429  * Process and xsl:message construct
 430  */
 431 void
 432 xsltMessage(xsltTransformContextPtr ctxt, xmlNodePtr node, xmlNodePtr inst) {
 433     xmlGenericErrorFunc error = xsltGenericError;
 434     void *errctx = xsltGenericErrorContext;
 435     xmlChar *prop, *message;
 436     int terminate = 0;
 437 
 438     if ((ctxt == NULL) || (inst == NULL))
 439     return;
 440 
 441     if (ctxt-&gt;error != NULL) {
 442     error = ctxt-&gt;error;
 443     errctx = ctxt-&gt;errctx;
 444     }
 445 
 446     prop = xmlGetNsProp(inst, (const xmlChar *)&quot;terminate&quot;, NULL);
 447     if (prop != NULL) {
 448     if (xmlStrEqual(prop, (const xmlChar *)&quot;yes&quot;)) {
 449         terminate = 1;
 450     } else if (xmlStrEqual(prop, (const xmlChar *)&quot;no&quot;)) {
 451         terminate = 0;
 452     } else {
 453         xsltTransformError(ctxt, NULL, inst,
 454         &quot;xsl:message : terminate expecting &#39;yes&#39; or &#39;no&#39;\n&quot;);
 455     }
 456     xmlFree(prop);
 457     }
 458     message = xsltEvalTemplateString(ctxt, node, inst);
 459     if (message != NULL) {
 460     int len = xmlStrlen(message);
 461 
 462     error(errctx, &quot;%s&quot;, (const char *)message);
 463     if ((len &gt; 0) &amp;&amp; (message[len - 1] != &#39;\n&#39;))
 464         error(errctx, &quot;\n&quot;);
 465     xmlFree(message);
 466     }
 467     if (terminate)
 468     ctxt-&gt;state = XSLT_STATE_STOPPED;
 469 }
 470 
 471 /************************************************************************
 472  *                                  *
 473  *      Handling of out of context errors           *
 474  *                                  *
 475  ************************************************************************/
 476 
 477 #define XSLT_GET_VAR_STR(msg, str) {                \
 478     int       size;                     \
 479     int       chars;                        \
 480     char      *larger;                      \
 481     va_list   ap;                       \
 482                                 \
 483     str = (char *) xmlMalloc(150);              \
 484     if (str == NULL)                        \
 485     return;                         \
 486                                 \
 487     size = 150;                         \
 488                                 \
 489     while (size &lt; 64000) {                  \
 490     va_start(ap, msg);                  \
 491     chars = vsnprintf(str, size, msg, ap);          \
 492     va_end(ap);                     \
 493     if ((chars &gt; -1) &amp;&amp; (chars &lt; size))         \
 494         break;                      \
 495     if (chars &gt; -1)                     \
 496         size += chars + 1;                  \
 497     else                            \
 498         size += 100;                    \
 499     if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
 500         xmlFree(str);                   \
 501         return;                     \
 502     }                           \
 503     str = larger;                       \
 504     }                               \
 505 }
 506 /**
 507  * xsltGenericErrorDefaultFunc:
 508  * @ctx:  an error context
 509  * @msg:  the message to display/transmit
 510  * @...:  extra parameters for the message display
 511  *
 512  * Default handler for out of context error messages.
 513  */
 514 static void LIBXSLT_ATTR_FORMAT(2,3)
 515 xsltGenericErrorDefaultFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) {
 516     va_list args;
 517 
 518     if (xsltGenericErrorContext == NULL)
 519     xsltGenericErrorContext = (void *) stderr;
 520 
 521     va_start(args, msg);
 522     vfprintf((FILE *)xsltGenericErrorContext, msg, args);
 523     va_end(args);
 524 }
 525 
 526 xmlGenericErrorFunc xsltGenericError = xsltGenericErrorDefaultFunc;
 527 void *xsltGenericErrorContext = NULL;
 528 
 529 
 530 /**
 531  * xsltSetGenericErrorFunc:
 532  * @ctx:  the new error handling context
 533  * @handler:  the new handler function
 534  *
 535  * Function to reset the handler and the error context for out of
 536  * context error messages.
 537  * This simply means that @handler will be called for subsequent
 538  * error messages while not parsing nor validating. And @ctx will
 539  * be passed as first argument to @handler
 540  * One can simply force messages to be emitted to another FILE * than
 541  * stderr by setting @ctx to this file handle and @handler to NULL.
 542  */
 543 void
 544 xsltSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
 545     xsltGenericErrorContext = ctx;
 546     if (handler != NULL)
 547     xsltGenericError = handler;
 548     else
 549     xsltGenericError = xsltGenericErrorDefaultFunc;
 550 }
 551 
 552 /**
 553  * xsltGenericDebugDefaultFunc:
 554  * @ctx:  an error context
 555  * @msg:  the message to display/transmit
 556  * @...:  extra parameters for the message display
 557  *
 558  * Default handler for out of context error messages.
 559  */
 560 static void LIBXSLT_ATTR_FORMAT(2,3)
 561 xsltGenericDebugDefaultFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) {
 562     va_list args;
 563 
 564     if (xsltGenericDebugContext == NULL)
 565     return;
 566 
 567     va_start(args, msg);
 568     vfprintf((FILE *)xsltGenericDebugContext, msg, args);
 569     va_end(args);
 570 }
 571 
 572 xmlGenericErrorFunc xsltGenericDebug = xsltGenericDebugDefaultFunc;
 573 void *xsltGenericDebugContext = NULL;
 574 
 575 
 576 /**
 577  * xsltSetGenericDebugFunc:
 578  * @ctx:  the new error handling context
 579  * @handler:  the new handler function
 580  *
 581  * Function to reset the handler and the error context for out of
 582  * context error messages.
 583  * This simply means that @handler will be called for subsequent
 584  * error messages while not parsing or validating. And @ctx will
 585  * be passed as first argument to @handler
 586  * One can simply force messages to be emitted to another FILE * than
 587  * stderr by setting @ctx to this file handle and @handler to NULL.
 588  */
 589 void
 590 xsltSetGenericDebugFunc(void *ctx, xmlGenericErrorFunc handler) {
 591     xsltGenericDebugContext = ctx;
 592     if (handler != NULL)
 593     xsltGenericDebug = handler;
 594     else
 595     xsltGenericDebug = xsltGenericDebugDefaultFunc;
 596 }
 597 
 598 /**
 599  * xsltPrintErrorContext:
 600  * @ctxt:  the transformation context
 601  * @style:  the stylesheet
 602  * @node:  the current node being processed
 603  *
 604  * Display the context of an error.
 605  */
 606 void
 607 xsltPrintErrorContext(xsltTransformContextPtr ctxt,
 608                   xsltStylesheetPtr style, xmlNodePtr node) {
 609     int line = 0;
 610     const xmlChar *file = NULL;
 611     const xmlChar *name = NULL;
 612     const char *type = &quot;error&quot;;
 613     xmlGenericErrorFunc error = xsltGenericError;
 614     void *errctx = xsltGenericErrorContext;
 615 
 616     if (ctxt != NULL) {
 617         if (ctxt-&gt;state == XSLT_STATE_OK)
 618         ctxt-&gt;state = XSLT_STATE_ERROR;
 619     if (ctxt-&gt;error != NULL) {
 620         error = ctxt-&gt;error;
 621         errctx = ctxt-&gt;errctx;
 622     }
 623     }
 624     if ((node == NULL) &amp;&amp; (ctxt != NULL))
 625     node = ctxt-&gt;inst;
 626 
 627     if (node != NULL)  {
 628     if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 629         (node-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 630         xmlDocPtr doc = (xmlDocPtr) node;
 631 
 632         file = doc-&gt;URL;
 633     } else {
 634         line = xmlGetLineNo(node);
 635         if ((node-&gt;doc != NULL) &amp;&amp; (node-&gt;doc-&gt;URL != NULL))
 636         file = node-&gt;doc-&gt;URL;
 637         if (node-&gt;name != NULL)
 638         name = node-&gt;name;
 639     }
 640     }
 641 
 642     if (ctxt != NULL)
 643     type = &quot;runtime error&quot;;
 644     else if (style != NULL) {
 645 #ifdef XSLT_REFACTORED
 646     if (XSLT_CCTXT(style)-&gt;errSeverity == XSLT_ERROR_SEVERITY_WARNING)
 647         type = &quot;compilation warning&quot;;
 648     else
 649         type = &quot;compilation error&quot;;
 650 #else
 651     type = &quot;compilation error&quot;;
 652 #endif
 653     }
 654 
 655     if ((file != NULL) &amp;&amp; (line != 0) &amp;&amp; (name != NULL))
 656     error(errctx, &quot;%s: file %s line %d element %s\n&quot;,
 657           type, file, line, name);
 658     else if ((file != NULL) &amp;&amp; (name != NULL))
 659     error(errctx, &quot;%s: file %s element %s\n&quot;, type, file, name);
 660     else if ((file != NULL) &amp;&amp; (line != 0))
 661     error(errctx, &quot;%s: file %s line %d\n&quot;, type, file, line);
 662     else if (file != NULL)
 663     error(errctx, &quot;%s: file %s\n&quot;, type, file);
 664     else if (name != NULL)
 665     error(errctx, &quot;%s: element %s\n&quot;, type, name);
 666     else
 667     error(errctx, &quot;%s\n&quot;, type);
 668 }
 669 
 670 /**
 671  * xsltSetTransformErrorFunc:
 672  * @ctxt:  the XSLT transformation context
 673  * @ctx:  the new error handling context
 674  * @handler:  the new handler function
 675  *
 676  * Function to reset the handler and the error context for out of
 677  * context error messages specific to a given XSLT transromation.
 678  *
 679  * This simply means that @handler will be called for subsequent
 680  * error messages while running the transformation.
 681  */
 682 void
 683 xsltSetTransformErrorFunc(xsltTransformContextPtr ctxt,
 684                           void *ctx, xmlGenericErrorFunc handler)
 685 {
 686     ctxt-&gt;error = handler;
 687     ctxt-&gt;errctx = ctx;
 688 }
 689 
 690 /**
 691  * xsltTransformError:
 692  * @ctxt:  an XSLT transformation context
 693  * @style:  the XSLT stylesheet used
 694  * @node:  the current node in the stylesheet
 695  * @msg:  the message to display/transmit
 696  * @...:  extra parameters for the message display
 697  *
 698  * Display and format an error messages, gives file, line, position and
 699  * extra parameters, will use the specific transformation context if available
 700  */
 701 void
 702 xsltTransformError(xsltTransformContextPtr ctxt,
 703            xsltStylesheetPtr style,
 704            xmlNodePtr node,
 705            const char *msg, ...) {
 706     xmlGenericErrorFunc error = xsltGenericError;
 707     void *errctx = xsltGenericErrorContext;
 708     char * str;
 709 
 710     if (ctxt != NULL) {
 711         if (ctxt-&gt;state == XSLT_STATE_OK)
 712         ctxt-&gt;state = XSLT_STATE_ERROR;
 713     if (ctxt-&gt;error != NULL) {
 714         error = ctxt-&gt;error;
 715         errctx = ctxt-&gt;errctx;
 716     }
 717     }
 718     if ((node == NULL) &amp;&amp; (ctxt != NULL))
 719     node = ctxt-&gt;inst;
 720     xsltPrintErrorContext(ctxt, style, node);
 721     XSLT_GET_VAR_STR(msg, str);
 722     error(errctx, &quot;%s&quot;, str);
 723     if (str != NULL)
 724     xmlFree(str);
 725 }
 726 
 727 /************************************************************************
 728  *                                  *
 729  *              QNames                  *
 730  *                                  *
 731  ************************************************************************/
 732 
 733 /**
 734  * xsltSplitQName:
 735  * @dict: a dictionary
 736  * @name:  the full QName
 737  * @prefix: the return value
 738  *
 739  * Split QNames into prefix and local names, both allocated from a dictionary.
 740  *
 741  * Returns: the localname or NULL in case of error.
 742  */
 743 const xmlChar *
 744 xsltSplitQName(xmlDictPtr dict, const xmlChar *name, const xmlChar **prefix) {
 745     int len = 0;
 746     const xmlChar *ret = NULL;
 747 
 748     *prefix = NULL;
 749     if ((name == NULL) || (dict == NULL)) return(NULL);
 750     if (name[0] == &#39;:&#39;)
 751         return(xmlDictLookup(dict, name, -1));
 752     while ((name[len] != 0) &amp;&amp; (name[len] != &#39;:&#39;)) len++;
 753     if (name[len] == 0) return(xmlDictLookup(dict, name, -1));
 754     *prefix = xmlDictLookup(dict, name, len);
 755     ret = xmlDictLookup(dict, &amp;name[len + 1], -1);
 756     return(ret);
 757 }
 758 
 759 /**
 760  * xsltGetQNameURI:
 761  * @node:  the node holding the QName
 762  * @name:  pointer to the initial QName value
 763  *
 764  * This function analyzes @name, if the name contains a prefix,
 765  * the function seaches the associated namespace in scope for it.
 766  * It will also replace @name value with the NCName, the old value being
 767  * freed.
 768  * Errors in the prefix lookup are signalled by setting @name to NULL.
 769  *
 770  * NOTE: the namespace returned is a pointer to the place where it is
 771  *       defined and hence has the same lifespan as the document holding it.
 772  *
 773  * Returns the namespace URI if there is a prefix, or NULL if @name is
 774  *         not prefixed.
 775  */
 776 const xmlChar *
 777 xsltGetQNameURI(xmlNodePtr node, xmlChar ** name)
 778 {
 779     int len = 0;
 780     xmlChar *qname;
 781     xmlNsPtr ns;
 782 
 783     if (name == NULL)
 784     return(NULL);
 785     qname = *name;
 786     if ((qname == NULL) || (*qname == 0))
 787     return(NULL);
 788     if (node == NULL) {
 789     xsltGenericError(xsltGenericErrorContext,
 790                  &quot;QName: no element for namespace lookup %s\n&quot;,
 791              qname);
 792     xmlFree(qname);
 793     *name = NULL;
 794     return(NULL);
 795     }
 796 
 797     /* nasty but valid */
 798     if (qname[0] == &#39;:&#39;)
 799     return(NULL);
 800 
 801     /*
 802      * we are not trying to validate but just to cut, and yes it will
 803      * work even if this is a set of UTF-8 encoded chars
 804      */
 805     while ((qname[len] != 0) &amp;&amp; (qname[len] != &#39;:&#39;))
 806     len++;
 807 
 808     if (qname[len] == 0)
 809     return(NULL);
 810 
 811     /*
 812      * handle xml: separately, this one is magical
 813      */
 814     if ((qname[0] == &#39;x&#39;) &amp;&amp; (qname[1] == &#39;m&#39;) &amp;&amp;
 815         (qname[2] == &#39;l&#39;) &amp;&amp; (qname[3] == &#39;:&#39;)) {
 816     if (qname[4] == 0)
 817         return(NULL);
 818         *name = xmlStrdup(&amp;qname[4]);
 819     xmlFree(qname);
 820     return(XML_XML_NAMESPACE);
 821     }
 822 
 823     qname[len] = 0;
 824     ns = xmlSearchNs(node-&gt;doc, node, qname);
 825     if (ns == NULL) {
 826     xsltGenericError(xsltGenericErrorContext,
 827         &quot;%s:%s : no namespace bound to prefix %s\n&quot;,
 828                  qname, &amp;qname[len + 1], qname);
 829     *name = NULL;
 830     xmlFree(qname);
 831     return(NULL);
 832     }
 833     *name = xmlStrdup(&amp;qname[len + 1]);
 834     xmlFree(qname);
 835     return(ns-&gt;href);
 836 }
 837 
 838 /**
 839  * xsltGetQNameURI2:
 840  * @style:  stylesheet pointer
 841  * @node:   the node holding the QName
 842  * @name:   pointer to the initial QName value
 843  *
 844  * This function is similar to xsltGetQNameURI, but is used when
 845  * @name is a dictionary entry.
 846  *
 847  * Returns the namespace URI if there is a prefix, or NULL if @name is
 848  * not prefixed.
 849  */
 850 const xmlChar *
 851 xsltGetQNameURI2(xsltStylesheetPtr style, xmlNodePtr node,
 852          const xmlChar **name) {
 853     int len = 0;
 854     xmlChar *qname;
 855     xmlNsPtr ns;
 856 
 857     if (name == NULL)
 858         return(NULL);
 859     qname = (xmlChar *)*name;
 860     if ((qname == NULL) || (*qname == 0))
 861         return(NULL);
 862     if (node == NULL) {
 863         xsltGenericError(xsltGenericErrorContext,
 864                          &quot;QName: no element for namespace lookup %s\n&quot;,
 865                           qname);
 866     *name = NULL;
 867     return(NULL);
 868     }
 869 
 870     /*
 871      * we are not trying to validate but just to cut, and yes it will
 872      * work even if this is a set of UTF-8 encoded chars
 873      */
 874     while ((qname[len] != 0) &amp;&amp; (qname[len] != &#39;:&#39;))
 875         len++;
 876 
 877     if (qname[len] == 0)
 878         return(NULL);
 879 
 880     /*
 881      * handle xml: separately, this one is magical
 882      */
 883     if ((qname[0] == &#39;x&#39;) &amp;&amp; (qname[1] == &#39;m&#39;) &amp;&amp;
 884         (qname[2] == &#39;l&#39;) &amp;&amp; (qname[3] == &#39;:&#39;)) {
 885         if (qname[4] == 0)
 886             return(NULL);
 887         *name = xmlDictLookup(style-&gt;dict, &amp;qname[4], -1);
 888         return(XML_XML_NAMESPACE);
 889     }
 890 
 891     qname = xmlStrndup(*name, len);
 892     ns = xmlSearchNs(node-&gt;doc, node, qname);
 893     if (ns == NULL) {
 894     if (style) {
 895         xsltTransformError(NULL, style, node,
 896         &quot;No namespace bound to prefix &#39;%s&#39;.\n&quot;,
 897         qname);
 898         style-&gt;errors++;
 899     } else {
 900         xsltGenericError(xsltGenericErrorContext,
 901                 &quot;%s : no namespace bound to prefix %s\n&quot;,
 902         *name, qname);
 903     }
 904         *name = NULL;
 905         xmlFree(qname);
 906         return(NULL);
 907     }
 908     *name = xmlDictLookup(style-&gt;dict, (*name)+len+1, -1);
 909     xmlFree(qname);
 910     return(ns-&gt;href);
 911 }
 912 
 913 /************************************************************************
 914  *                                  *
 915  *              Sorting                 *
 916  *                                  *
 917  ************************************************************************/
 918 
 919 /**
 920  * xsltDocumentSortFunction:
 921  * @list:  the node set
 922  *
 923  * reorder the current node list @list accordingly to the document order
 924  * This function is slow, obsolete and should not be used anymore.
 925  */
 926 void
 927 xsltDocumentSortFunction(xmlNodeSetPtr list) {
 928     int i, j;
 929     int len, tst;
 930     xmlNodePtr node;
 931 
 932     if (list == NULL)
 933     return;
 934     len = list-&gt;nodeNr;
 935     if (len &lt;= 1)
 936     return;
 937     /* TODO: sort is really not optimized, does it needs to ? */
 938     for (i = 0;i &lt; len -1;i++) {
 939     for (j = i + 1; j &lt; len; j++) {
 940         tst = xmlXPathCmpNodes(list-&gt;nodeTab[i], list-&gt;nodeTab[j]);
 941         if (tst == -1) {
 942         node = list-&gt;nodeTab[i];
 943         list-&gt;nodeTab[i] = list-&gt;nodeTab[j];
 944         list-&gt;nodeTab[j] = node;
 945         }
 946     }
 947     }
 948 }
 949 
 950 /**
 951  * xsltComputeSortResult:
 952  * @ctxt:  a XSLT process context
 953  * @sort:  node list
 954  *
 955  * reorder the current node list accordingly to the set of sorting
 956  * requirement provided by the array of nodes.
 957  *
 958  * Returns a ordered XPath nodeset or NULL in case of error.
 959  */
 960 xmlXPathObjectPtr *
 961 xsltComputeSortResult(xsltTransformContextPtr ctxt, xmlNodePtr sort) {
 962 #ifdef XSLT_REFACTORED
 963     xsltStyleItemSortPtr comp;
 964 #else
 965     xsltStylePreCompPtr comp;
 966 #endif
 967     xmlXPathObjectPtr *results = NULL;
 968     xmlNodeSetPtr list = NULL;
 969     xmlXPathObjectPtr res;
 970     int len = 0;
 971     int i;
 972     xmlNodePtr oldNode;
 973     xmlNodePtr oldInst;
 974     int oldPos, oldSize ;
 975     int oldNsNr;
 976     xmlNsPtr *oldNamespaces;
 977 
 978     comp = sort-&gt;psvi;
 979     if (comp == NULL) {
 980     xsltGenericError(xsltGenericErrorContext,
 981          &quot;xsl:sort : compilation failed\n&quot;);
 982     return(NULL);
 983     }
 984 
 985     if ((comp-&gt;select == NULL) || (comp-&gt;comp == NULL))
 986     return(NULL);
 987 
 988     list = ctxt-&gt;nodeList;
 989     if ((list == NULL) || (list-&gt;nodeNr &lt;= 1))
 990     return(NULL);
 991 
 992     len = list-&gt;nodeNr;
 993 
 994     /* TODO: xsl:sort lang attribute */
 995     /* TODO: xsl:sort case-order attribute */
 996 
 997 
 998     results = xmlMalloc(len * sizeof(xmlXPathObjectPtr));
 999     if (results == NULL) {
1000     xsltGenericError(xsltGenericErrorContext,
1001          &quot;xsltComputeSortResult: memory allocation failure\n&quot;);
1002     return(NULL);
1003     }
1004 
1005     oldNode = ctxt-&gt;node;
1006     oldInst = ctxt-&gt;inst;
1007     oldPos = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
1008     oldSize = ctxt-&gt;xpathCtxt-&gt;contextSize;
1009     oldNsNr = ctxt-&gt;xpathCtxt-&gt;nsNr;
1010     oldNamespaces = ctxt-&gt;xpathCtxt-&gt;namespaces;
1011     for (i = 0;i &lt; len;i++) {
1012     ctxt-&gt;inst = sort;
1013     ctxt-&gt;xpathCtxt-&gt;contextSize = len;
1014     ctxt-&gt;xpathCtxt-&gt;proximityPosition = i + 1;
1015     ctxt-&gt;node = list-&gt;nodeTab[i];
1016     ctxt-&gt;xpathCtxt-&gt;node = ctxt-&gt;node;
1017 #ifdef XSLT_REFACTORED
1018     if (comp-&gt;inScopeNs != NULL) {
1019         ctxt-&gt;xpathCtxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
1020         ctxt-&gt;xpathCtxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
1021     } else {
1022         ctxt-&gt;xpathCtxt-&gt;namespaces = NULL;
1023         ctxt-&gt;xpathCtxt-&gt;nsNr = 0;
1024     }
1025 #else
1026     ctxt-&gt;xpathCtxt-&gt;namespaces = comp-&gt;nsList;
1027     ctxt-&gt;xpathCtxt-&gt;nsNr = comp-&gt;nsNr;
1028 #endif
1029     res = xmlXPathCompiledEval(comp-&gt;comp, ctxt-&gt;xpathCtxt);
1030     if (res != NULL) {
1031         if (res-&gt;type != XPATH_STRING)
1032         res = xmlXPathConvertString(res);
1033         if (comp-&gt;number)
1034         res = xmlXPathConvertNumber(res);
1035         res-&gt;index = i; /* Save original pos for dupl resolv */
1036         if (comp-&gt;number) {
1037         if (res-&gt;type == XPATH_NUMBER) {
1038             results[i] = res;
1039         } else {
1040 #ifdef WITH_XSLT_DEBUG_PROCESS
1041             xsltGenericDebug(xsltGenericDebugContext,
1042             &quot;xsltComputeSortResult: select didn&#39;t evaluate to a number\n&quot;);
1043 #endif
1044             results[i] = NULL;
1045         }
1046         } else {
1047         if (res-&gt;type == XPATH_STRING) {
1048             if (comp-&gt;locale != (xsltLocale)0) {
1049             xmlChar *str = res-&gt;stringval;
1050             res-&gt;stringval = (xmlChar *) xsltStrxfrm(comp-&gt;locale, str);
1051             xmlFree(str);
1052             }
1053 
1054             results[i] = res;
1055         } else {
1056 #ifdef WITH_XSLT_DEBUG_PROCESS
1057             xsltGenericDebug(xsltGenericDebugContext,
1058             &quot;xsltComputeSortResult: select didn&#39;t evaluate to a string\n&quot;);
1059 #endif
1060             results[i] = NULL;
1061         }
1062         }
1063     } else {
1064         ctxt-&gt;state = XSLT_STATE_STOPPED;
1065         results[i] = NULL;
1066     }
1067     }
1068     ctxt-&gt;node = oldNode;
1069     ctxt-&gt;inst = oldInst;
1070     ctxt-&gt;xpathCtxt-&gt;contextSize = oldSize;
1071     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldPos;
1072     ctxt-&gt;xpathCtxt-&gt;nsNr = oldNsNr;
1073     ctxt-&gt;xpathCtxt-&gt;namespaces = oldNamespaces;
1074 
1075     return(results);
1076 }
1077 
1078 /**
1079  * xsltDefaultSortFunction:
1080  * @ctxt:  a XSLT process context
1081  * @sorts:  array of sort nodes
1082  * @nbsorts:  the number of sorts in the array
1083  *
1084  * reorder the current node list accordingly to the set of sorting
1085  * requirement provided by the arry of nodes.
1086  */
1087 void
1088 xsltDefaultSortFunction(xsltTransformContextPtr ctxt, xmlNodePtr *sorts,
1089                int nbsorts) {
1090 #ifdef XSLT_REFACTORED
1091     xsltStyleItemSortPtr comp;
1092 #else
1093     xsltStylePreCompPtr comp;
1094 #endif
1095     xmlXPathObjectPtr *resultsTab[XSLT_MAX_SORT];
1096     xmlXPathObjectPtr *results = NULL, *res;
1097     xmlNodeSetPtr list = NULL;
1098     int descending, number, desc, numb;
1099     int len = 0;
1100     int i, j, incr;
1101     int tst;
1102     int depth;
1103     xmlNodePtr node;
1104     xmlXPathObjectPtr tmp;
1105     int tempstype[XSLT_MAX_SORT], temporder[XSLT_MAX_SORT];
1106 
1107     if ((ctxt == NULL) || (sorts == NULL) || (nbsorts &lt;= 0) ||
1108     (nbsorts &gt;= XSLT_MAX_SORT))
1109     return;
1110     if (sorts[0] == NULL)
1111     return;
1112     comp = sorts[0]-&gt;psvi;
1113     if (comp == NULL)
1114     return;
1115 
1116     list = ctxt-&gt;nodeList;
1117     if ((list == NULL) || (list-&gt;nodeNr &lt;= 1))
1118     return; /* nothing to do */
1119 
1120     for (j = 0; j &lt; nbsorts; j++) {
1121     comp = sorts[j]-&gt;psvi;
1122     tempstype[j] = 0;
1123     if ((comp-&gt;stype == NULL) &amp;&amp; (comp-&gt;has_stype != 0)) {
1124         comp-&gt;stype =
1125         xsltEvalAttrValueTemplate(ctxt, sorts[j],
1126                       (const xmlChar *) &quot;data-type&quot;,
1127                       XSLT_NAMESPACE);
1128         if (comp-&gt;stype != NULL) {
1129         tempstype[j] = 1;
1130         if (xmlStrEqual(comp-&gt;stype, (const xmlChar *) &quot;text&quot;))
1131             comp-&gt;number = 0;
1132         else if (xmlStrEqual(comp-&gt;stype, (const xmlChar *) &quot;number&quot;))
1133             comp-&gt;number = 1;
1134         else {
1135             xsltTransformError(ctxt, NULL, sorts[j],
1136               &quot;xsltDoSortFunction: no support for data-type = %s\n&quot;,
1137                      comp-&gt;stype);
1138             comp-&gt;number = 0; /* use default */
1139         }
1140         }
1141     }
1142     temporder[j] = 0;
1143     if ((comp-&gt;order == NULL) &amp;&amp; (comp-&gt;has_order != 0)) {
1144         comp-&gt;order = xsltEvalAttrValueTemplate(ctxt, sorts[j],
1145                             (const xmlChar *) &quot;order&quot;,
1146                             XSLT_NAMESPACE);
1147         if (comp-&gt;order != NULL) {
1148         temporder[j] = 1;
1149         if (xmlStrEqual(comp-&gt;order, (const xmlChar *) &quot;ascending&quot;))
1150             comp-&gt;descending = 0;
1151         else if (xmlStrEqual(comp-&gt;order,
1152                      (const xmlChar *) &quot;descending&quot;))
1153             comp-&gt;descending = 1;
1154         else {
1155             xsltTransformError(ctxt, NULL, sorts[j],
1156                  &quot;xsltDoSortFunction: invalid value %s for order\n&quot;,
1157                      comp-&gt;order);
1158             comp-&gt;descending = 0; /* use default */
1159         }
1160         }
1161     }
1162     }
1163 
1164     len = list-&gt;nodeNr;
1165 
1166     resultsTab[0] = xsltComputeSortResult(ctxt, sorts[0]);
1167     for (i = 1;i &lt; XSLT_MAX_SORT;i++)
1168     resultsTab[i] = NULL;
1169 
1170     results = resultsTab[0];
1171 
1172     comp = sorts[0]-&gt;psvi;
1173     descending = comp-&gt;descending;
1174     number = comp-&gt;number;
1175     if (results == NULL)
1176     return;
1177 
1178     /* Shell&#39;s sort of node-set */
1179     for (incr = len / 2; incr &gt; 0; incr /= 2) {
1180     for (i = incr; i &lt; len; i++) {
1181         j = i - incr;
1182         if (results[i] == NULL)
1183         continue;
1184 
1185         while (j &gt;= 0) {
1186         if (results[j] == NULL)
1187             tst = 1;
1188         else {
1189             if (number) {
1190             /* We make NaN smaller than number in accordance
1191                with XSLT spec */
1192             if (xmlXPathIsNaN(results[j]-&gt;floatval)) {
1193                 if (xmlXPathIsNaN(results[j + incr]-&gt;floatval))
1194                 tst = 0;
1195                 else
1196                 tst = -1;
1197             } else if (xmlXPathIsNaN(results[j + incr]-&gt;floatval))
1198                 tst = 1;
1199             else if (results[j]-&gt;floatval ==
1200                 results[j + incr]-&gt;floatval)
1201                 tst = 0;
1202             else if (results[j]-&gt;floatval &gt;
1203                 results[j + incr]-&gt;floatval)
1204                 tst = 1;
1205             else tst = -1;
1206             } else if(comp-&gt;locale != (xsltLocale)0) {
1207             tst = xsltLocaleStrcmp(
1208                 comp-&gt;locale,
1209                 (xsltLocaleChar *) results[j]-&gt;stringval,
1210                 (xsltLocaleChar *) results[j + incr]-&gt;stringval);
1211             } else {
1212             tst = xmlStrcmp(results[j]-&gt;stringval,
1213                      results[j + incr]-&gt;stringval);
1214             }
1215             if (descending)
1216             tst = -tst;
1217         }
1218         if (tst == 0) {
1219             /*
1220              * Okay we need to use multi level sorts
1221              */
1222             depth = 1;
1223             while (depth &lt; nbsorts) {
1224             if (sorts[depth] == NULL)
1225                 break;
1226             comp = sorts[depth]-&gt;psvi;
1227             if (comp == NULL)
1228                 break;
1229             desc = comp-&gt;descending;
1230             numb = comp-&gt;number;
1231 
1232             /*
1233              * Compute the result of the next level for the
1234              * full set, this might be optimized ... or not
1235              */
1236             if (resultsTab[depth] == NULL)
1237                 resultsTab[depth] = xsltComputeSortResult(ctxt,
1238                                         sorts[depth]);
1239             res = resultsTab[depth];
1240             if (res == NULL)
1241                 break;
1242             if (res[j] == NULL) {
1243                 if (res[j+incr] != NULL)
1244                 tst = 1;
1245             } else if (res[j+incr] == NULL) {
1246                 tst = -1;
1247             } else {
1248                 if (numb) {
1249                 /* We make NaN smaller than number in
1250                    accordance with XSLT spec */
1251                 if (xmlXPathIsNaN(res[j]-&gt;floatval)) {
1252                     if (xmlXPathIsNaN(res[j +
1253                         incr]-&gt;floatval))
1254                     tst = 0;
1255                     else
1256                         tst = -1;
1257                 } else if (xmlXPathIsNaN(res[j + incr]-&gt;
1258                         floatval))
1259                     tst = 1;
1260                 else if (res[j]-&gt;floatval == res[j + incr]-&gt;
1261                         floatval)
1262                     tst = 0;
1263                 else if (res[j]-&gt;floatval &gt;
1264                     res[j + incr]-&gt;floatval)
1265                     tst = 1;
1266                 else tst = -1;
1267                 } else if(comp-&gt;locale != (xsltLocale)0) {
1268                 tst = xsltLocaleStrcmp(
1269                     comp-&gt;locale,
1270                     (xsltLocaleChar *) res[j]-&gt;stringval,
1271                     (xsltLocaleChar *) res[j + incr]-&gt;stringval);
1272                 } else {
1273                 tst = xmlStrcmp(res[j]-&gt;stringval,
1274                          res[j + incr]-&gt;stringval);
1275                 }
1276                 if (desc)
1277                 tst = -tst;
1278             }
1279 
1280             /*
1281              * if we still can&#39;t differenciate at this level
1282              * try one level deeper.
1283              */
1284             if (tst != 0)
1285                 break;
1286             depth++;
1287             }
1288         }
1289         if (tst == 0) {
1290             tst = results[j]-&gt;index &gt; results[j + incr]-&gt;index;
1291         }
1292         if (tst &gt; 0) {
1293             tmp = results[j];
1294             results[j] = results[j + incr];
1295             results[j + incr] = tmp;
1296             node = list-&gt;nodeTab[j];
1297             list-&gt;nodeTab[j] = list-&gt;nodeTab[j + incr];
1298             list-&gt;nodeTab[j + incr] = node;
1299             depth = 1;
1300             while (depth &lt; nbsorts) {
1301             if (sorts[depth] == NULL)
1302                 break;
1303             if (resultsTab[depth] == NULL)
1304                 break;
1305             res = resultsTab[depth];
1306             tmp = res[j];
1307             res[j] = res[j + incr];
1308             res[j + incr] = tmp;
1309             depth++;
1310             }
1311             j -= incr;
1312         } else
1313             break;
1314         }
1315     }
1316     }
1317 
1318     for (j = 0; j &lt; nbsorts; j++) {
1319     comp = sorts[j]-&gt;psvi;
1320     if (tempstype[j] == 1) {
1321         /* The data-type needs to be recomputed each time */
1322         xmlFree((void *)(comp-&gt;stype));
1323         comp-&gt;stype = NULL;
1324     }
1325     if (temporder[j] == 1) {
1326         /* The order needs to be recomputed each time */
1327         xmlFree((void *)(comp-&gt;order));
1328         comp-&gt;order = NULL;
1329     }
1330     if (resultsTab[j] != NULL) {
1331         for (i = 0;i &lt; len;i++)
1332         xmlXPathFreeObject(resultsTab[j][i]);
1333         xmlFree(resultsTab[j]);
1334     }
1335     }
1336 }
1337 
1338 
1339 static xsltSortFunc xsltSortFunction = xsltDefaultSortFunction;
1340 
1341 /**
1342  * xsltDoSortFunction:
1343  * @ctxt:  a XSLT process context
1344  * @sorts:  array of sort nodes
1345  * @nbsorts:  the number of sorts in the array
1346  *
1347  * reorder the current node list accordingly to the set of sorting
1348  * requirement provided by the arry of nodes.
1349  * This is a wrapper function, the actual function used is specified
1350  * using xsltSetCtxtSortFunc() to set the context specific sort function,
1351  * or xsltSetSortFunc() to set the global sort function.
1352  * If a sort function is set on the context, this will get called.
1353  * Otherwise the global sort function is called.
1354  */
1355 void
1356 xsltDoSortFunction(xsltTransformContextPtr ctxt, xmlNodePtr * sorts,
1357                    int nbsorts)
1358 {
1359     if (ctxt-&gt;sortfunc != NULL)
1360     (ctxt-&gt;sortfunc)(ctxt, sorts, nbsorts);
1361     else if (xsltSortFunction != NULL)
1362         xsltSortFunction(ctxt, sorts, nbsorts);
1363 }
1364 
1365 /**
1366  * xsltSetSortFunc:
1367  * @handler:  the new handler function
1368  *
1369  * Function to reset the global handler for XSLT sorting.
1370  * If the handler is NULL, the default sort function will be used.
1371  */
1372 void
1373 xsltSetSortFunc(xsltSortFunc handler) {
1374     if (handler != NULL)
1375     xsltSortFunction = handler;
1376     else
1377     xsltSortFunction = xsltDefaultSortFunction;
1378 }
1379 
1380 /**
1381  * xsltSetCtxtSortFunc:
1382  * @ctxt:  a XSLT process context
1383  * @handler:  the new handler function
1384  *
1385  * Function to set the handler for XSLT sorting
1386  * for the specified context.
1387  * If the handler is NULL, then the global
1388  * sort function will be called
1389  */
1390 void
1391 xsltSetCtxtSortFunc(xsltTransformContextPtr ctxt, xsltSortFunc handler) {
1392     ctxt-&gt;sortfunc = handler;
1393 }
1394 
1395 /************************************************************************
1396  *                                  *
1397  *              Parsing options             *
1398  *                                  *
1399  ************************************************************************/
1400 
1401 /**
1402  * xsltSetCtxtParseOptions:
1403  * @ctxt:  a XSLT process context
1404  * @options:  a combination of libxml2 xmlParserOption
1405  *
1406  * Change the default parser option passed by the XSLT engine to the
1407  * parser when using document() loading.
1408  *
1409  * Returns the previous options or -1 in case of error
1410  */
1411 int
1412 xsltSetCtxtParseOptions(xsltTransformContextPtr ctxt, int options)
1413 {
1414     int oldopts;
1415 
1416     if (ctxt == NULL)
1417         return(-1);
1418     oldopts = ctxt-&gt;parserOptions;
1419     if (ctxt-&gt;xinclude)
1420         oldopts |= XML_PARSE_XINCLUDE;
1421     ctxt-&gt;parserOptions = options;
1422     if (options &amp; XML_PARSE_XINCLUDE)
1423         ctxt-&gt;xinclude = 1;
1424     else
1425         ctxt-&gt;xinclude = 0;
1426     return(oldopts);
1427 }
1428 
1429 /************************************************************************
1430  *                                  *
1431  *              Output                  *
1432  *                                  *
1433  ************************************************************************/
1434 
1435 /**
1436  * xsltSaveResultTo:
1437  * @buf:  an output buffer
1438  * @result:  the result xmlDocPtr
1439  * @style:  the stylesheet
1440  *
1441  * Save the result @result obtained by applying the @style stylesheet
1442  * to an I/O output channel @buf
1443  *
1444  * Returns the number of byte written or -1 in case of failure.
1445  */
1446 int
1447 xsltSaveResultTo(xmlOutputBufferPtr buf, xmlDocPtr result,
1448            xsltStylesheetPtr style) {
1449     const xmlChar *encoding;
1450     int base;
1451     const xmlChar *method;
1452     int indent;
1453 
1454     if ((buf == NULL) || (result == NULL) || (style == NULL))
1455     return(-1);
1456     if ((result-&gt;children == NULL) ||
1457     ((result-&gt;children-&gt;type == XML_DTD_NODE) &amp;&amp;
1458      (result-&gt;children-&gt;next == NULL)))
1459     return(0);
1460 
1461     if ((style-&gt;methodURI != NULL) &amp;&amp;
1462     ((style-&gt;method == NULL) ||
1463      (!xmlStrEqual(style-&gt;method, (const xmlChar *) &quot;xhtml&quot;)))) {
1464         xsltGenericError(xsltGenericErrorContext,
1465         &quot;xsltSaveResultTo : unknown output method\n&quot;);
1466         return(-1);
1467     }
1468 
1469     base = buf-&gt;written;
1470 
1471     XSLT_GET_IMPORT_PTR(method, style, method)
1472     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1473     XSLT_GET_IMPORT_INT(indent, style, indent);
1474 
1475     if ((method == NULL) &amp;&amp; (result-&gt;type == XML_HTML_DOCUMENT_NODE))
1476     method = (const xmlChar *) &quot;html&quot;;
1477 
1478     if ((method != NULL) &amp;&amp;
1479     (xmlStrEqual(method, (const xmlChar *) &quot;html&quot;))) {
1480     if (encoding != NULL) {
1481         htmlSetMetaEncoding(result, (const xmlChar *) encoding);
1482     } else {
1483         htmlSetMetaEncoding(result, (const xmlChar *) &quot;UTF-8&quot;);
1484     }
1485     if (indent == -1)
1486         indent = 1;
1487     htmlDocContentDumpFormatOutput(buf, result, (const char *) encoding,
1488                                indent);
1489     xmlOutputBufferFlush(buf);
1490     } else if ((method != NULL) &amp;&amp;
1491     (xmlStrEqual(method, (const xmlChar *) &quot;xhtml&quot;))) {
1492     if (encoding != NULL) {
1493         htmlSetMetaEncoding(result, (const xmlChar *) encoding);
1494     } else {
1495         htmlSetMetaEncoding(result, (const xmlChar *) &quot;UTF-8&quot;);
1496     }
1497     htmlDocContentDumpOutput(buf, result, (const char *) encoding);
1498     xmlOutputBufferFlush(buf);
1499     } else if ((method != NULL) &amp;&amp;
1500            (xmlStrEqual(method, (const xmlChar *) &quot;text&quot;))) {
1501     xmlNodePtr cur;
1502 
1503     cur = result-&gt;children;
1504     while (cur != NULL) {
1505         if (cur-&gt;type == XML_TEXT_NODE)
1506         xmlOutputBufferWriteString(buf, (const char *) cur-&gt;content);
1507 
1508         /*
1509          * Skip to next node
1510          */
1511         if (cur-&gt;children != NULL) {
1512         if ((cur-&gt;children-&gt;type != XML_ENTITY_DECL) &amp;&amp;
1513             (cur-&gt;children-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
1514             (cur-&gt;children-&gt;type != XML_ENTITY_NODE)) {
1515             cur = cur-&gt;children;
1516             continue;
1517         }
1518         }
1519         if (cur-&gt;next != NULL) {
1520         cur = cur-&gt;next;
1521         continue;
1522         }
1523 
1524         do {
1525         cur = cur-&gt;parent;
1526         if (cur == NULL)
1527             break;
1528         if (cur == (xmlNodePtr) style-&gt;doc) {
1529             cur = NULL;
1530             break;
1531         }
1532         if (cur-&gt;next != NULL) {
1533             cur = cur-&gt;next;
1534             break;
1535         }
1536         } while (cur != NULL);
1537     }
1538     xmlOutputBufferFlush(buf);
1539     } else {
1540     int omitXmlDecl;
1541     int standalone;
1542 
1543     XSLT_GET_IMPORT_INT(omitXmlDecl, style, omitXmlDeclaration);
1544     XSLT_GET_IMPORT_INT(standalone, style, standalone);
1545 
1546     if (omitXmlDecl != 1) {
1547         xmlOutputBufferWriteString(buf, &quot;&lt;?xml version=&quot;);
1548         if (result-&gt;version != NULL) {
1549         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1550         xmlOutputBufferWriteString(buf, (const char *)result-&gt;version);
1551         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1552         } else
1553         xmlOutputBufferWriteString(buf, &quot;\&quot;1.0\&quot;&quot;);
1554         if (encoding == NULL) {
1555         if (result-&gt;encoding != NULL)
1556             encoding = result-&gt;encoding;
1557         else if (result-&gt;charset != XML_CHAR_ENCODING_UTF8)
1558             encoding = (const xmlChar *)
1559                    xmlGetCharEncodingName((xmlCharEncoding)
1560                                           result-&gt;charset);
1561         }
1562         if (encoding != NULL) {
1563         xmlOutputBufferWriteString(buf, &quot; encoding=&quot;);
1564         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1565         xmlOutputBufferWriteString(buf, (const char *) encoding);
1566         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1567         }
1568         switch (standalone) {
1569         case 0:
1570             xmlOutputBufferWriteString(buf, &quot; standalone=\&quot;no\&quot;&quot;);
1571             break;
1572         case 1:
1573             xmlOutputBufferWriteString(buf, &quot; standalone=\&quot;yes\&quot;&quot;);
1574             break;
1575         default:
1576             break;
1577         }
1578         xmlOutputBufferWriteString(buf, &quot;?&gt;\n&quot;);
1579     }
1580     if (result-&gt;children != NULL) {
<a name="1" id="anc1"></a><span class="line-modified">1581             xmlNodePtr children = result-&gt;children;</span>
<span class="line-added">1582         xmlNodePtr child = children;</span>
<span class="line-added">1583 </span>
<span class="line-added">1584             /*</span>
<span class="line-added">1585              * Hack to avoid quadratic behavior when scanning</span>
<span class="line-added">1586              * result-&gt;children in xmlGetIntSubset called by</span>
<span class="line-added">1587              * xmlNodeDumpOutput.</span>
<span class="line-added">1588              */</span>
<span class="line-added">1589             result-&gt;children = NULL;</span>
1590 
1591         while (child != NULL) {
1592         xmlNodeDumpOutput(buf, result, child, 0, (indent == 1),
1593                       (const char *) encoding);
1594         if (indent &amp;&amp; ((child-&gt;type == XML_DTD_NODE) ||
1595             ((child-&gt;type == XML_COMMENT_NODE) &amp;&amp;
1596              (child-&gt;next != NULL))))
1597             xmlOutputBufferWriteString(buf, &quot;\n&quot;);
1598         child = child-&gt;next;
1599         }
1600         if (indent)
1601             xmlOutputBufferWriteString(buf, &quot;\n&quot;);
<a name="2" id="anc2"></a><span class="line-added">1602 </span>
<span class="line-added">1603             result-&gt;children = children;</span>
1604     }
1605     xmlOutputBufferFlush(buf);
1606     }
1607     return(buf-&gt;written - base);
1608 }
1609 
1610 /**
1611  * xsltSaveResultToFilename:
1612  * @URL:  a filename or URL
1613  * @result:  the result xmlDocPtr
1614  * @style:  the stylesheet
1615  * @compression:  the compression factor (0 - 9 included)
1616  *
1617  * Save the result @result obtained by applying the @style stylesheet
1618  * to a file or @URL
1619  *
1620  * Returns the number of byte written or -1 in case of failure.
1621  */
1622 int
1623 xsltSaveResultToFilename(const char *URL, xmlDocPtr result,
1624              xsltStylesheetPtr style, int compression) {
1625     xmlOutputBufferPtr buf;
1626     const xmlChar *encoding;
1627     int ret;
1628 
1629     if ((URL == NULL) || (result == NULL) || (style == NULL))
1630     return(-1);
1631     if (result-&gt;children == NULL)
1632     return(0);
1633 
1634     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1635     if (encoding != NULL) {
1636     xmlCharEncodingHandlerPtr encoder;
1637 
1638     encoder = xmlFindCharEncodingHandler((char *)encoding);
1639     if ((encoder != NULL) &amp;&amp;
1640         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1641              (const xmlChar *) &quot;UTF-8&quot;)))
1642         encoder = NULL;
1643     buf = xmlOutputBufferCreateFilename(URL, encoder, compression);
1644     } else {
1645     buf = xmlOutputBufferCreateFilename(URL, NULL, compression);
1646     }
1647     if (buf == NULL)
1648     return(-1);
1649     xsltSaveResultTo(buf, result, style);
1650     ret = xmlOutputBufferClose(buf);
1651     return(ret);
1652 }
1653 
1654 /**
1655  * xsltSaveResultToFile:
1656  * @file:  a FILE * I/O
1657  * @result:  the result xmlDocPtr
1658  * @style:  the stylesheet
1659  *
1660  * Save the result @result obtained by applying the @style stylesheet
1661  * to an open FILE * I/O.
1662  * This does not close the FILE @file
1663  *
1664  * Returns the number of bytes written or -1 in case of failure.
1665  */
1666 int
1667 xsltSaveResultToFile(FILE *file, xmlDocPtr result, xsltStylesheetPtr style) {
1668     xmlOutputBufferPtr buf;
1669     const xmlChar *encoding;
1670     int ret;
1671 
1672     if ((file == NULL) || (result == NULL) || (style == NULL))
1673     return(-1);
1674     if (result-&gt;children == NULL)
1675     return(0);
1676 
1677     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1678     if (encoding != NULL) {
1679     xmlCharEncodingHandlerPtr encoder;
1680 
1681     encoder = xmlFindCharEncodingHandler((char *)encoding);
1682     if ((encoder != NULL) &amp;&amp;
1683         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1684              (const xmlChar *) &quot;UTF-8&quot;)))
1685         encoder = NULL;
1686     buf = xmlOutputBufferCreateFile(file, encoder);
1687     } else {
1688     buf = xmlOutputBufferCreateFile(file, NULL);
1689     }
1690 
1691     if (buf == NULL)
1692     return(-1);
1693     xsltSaveResultTo(buf, result, style);
1694     ret = xmlOutputBufferClose(buf);
1695     return(ret);
1696 }
1697 
1698 /**
1699  * xsltSaveResultToFd:
1700  * @fd:  a file descriptor
1701  * @result:  the result xmlDocPtr
1702  * @style:  the stylesheet
1703  *
1704  * Save the result @result obtained by applying the @style stylesheet
1705  * to an open file descriptor
1706  * This does not close the descriptor.
1707  *
1708  * Returns the number of bytes written or -1 in case of failure.
1709  */
1710 int
1711 xsltSaveResultToFd(int fd, xmlDocPtr result, xsltStylesheetPtr style) {
1712     xmlOutputBufferPtr buf;
1713     const xmlChar *encoding;
1714     int ret;
1715 
1716     if ((fd &lt; 0) || (result == NULL) || (style == NULL))
1717     return(-1);
1718     if (result-&gt;children == NULL)
1719     return(0);
1720 
1721     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1722     if (encoding != NULL) {
1723     xmlCharEncodingHandlerPtr encoder;
1724 
1725     encoder = xmlFindCharEncodingHandler((char *)encoding);
1726     if ((encoder != NULL) &amp;&amp;
1727         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1728              (const xmlChar *) &quot;UTF-8&quot;)))
1729         encoder = NULL;
1730     buf = xmlOutputBufferCreateFd(fd, encoder);
1731     } else {
1732     buf = xmlOutputBufferCreateFd(fd, NULL);
1733     }
1734     if (buf == NULL)
1735     return(-1);
1736     xsltSaveResultTo(buf, result, style);
1737     ret = xmlOutputBufferClose(buf);
1738     return(ret);
1739 }
1740 
1741 /**
1742  * xsltSaveResultToString:
1743  * @doc_txt_ptr:  Memory pointer for allocated XML text
1744  * @doc_txt_len:  Length of the generated XML text
1745  * @result:  the result xmlDocPtr
1746  * @style:  the stylesheet
1747  *
1748  * Save the result @result obtained by applying the @style stylesheet
1749  * to a new allocated string.
1750  *
1751  * Returns 0 in case of success and -1 in case of error
1752  */
1753 int
1754 xsltSaveResultToString(xmlChar **doc_txt_ptr, int * doc_txt_len,
1755                xmlDocPtr result, xsltStylesheetPtr style) {
1756     xmlOutputBufferPtr buf;
1757     const xmlChar *encoding;
1758 
1759     *doc_txt_ptr = NULL;
1760     *doc_txt_len = 0;
1761     if (result-&gt;children == NULL)
1762     return(0);
1763 
1764     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1765     if (encoding != NULL) {
1766     xmlCharEncodingHandlerPtr encoder;
1767 
1768     encoder = xmlFindCharEncodingHandler((char *)encoding);
1769     if ((encoder != NULL) &amp;&amp;
1770         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1771              (const xmlChar *) &quot;UTF-8&quot;)))
1772         encoder = NULL;
1773     buf = xmlAllocOutputBuffer(encoder);
1774     } else {
1775     buf = xmlAllocOutputBuffer(NULL);
1776     }
1777     if (buf == NULL)
1778     return(-1);
1779     xsltSaveResultTo(buf, result, style);
1780 #ifdef LIBXML2_NEW_BUFFER
1781     if (buf-&gt;conv != NULL) {
1782     *doc_txt_len = xmlBufUse(buf-&gt;conv);
1783     *doc_txt_ptr = xmlStrndup(xmlBufContent(buf-&gt;conv), *doc_txt_len);
1784     } else {
1785     *doc_txt_len = xmlBufUse(buf-&gt;buffer);
1786     *doc_txt_ptr = xmlStrndup(xmlBufContent(buf-&gt;buffer), *doc_txt_len);
1787     }
1788 #else
1789     if (buf-&gt;conv != NULL) {
1790     *doc_txt_len = buf-&gt;conv-&gt;use;
1791     *doc_txt_ptr = xmlStrndup(buf-&gt;conv-&gt;content, *doc_txt_len);
1792     } else {
1793     *doc_txt_len = buf-&gt;buffer-&gt;use;
1794     *doc_txt_ptr = xmlStrndup(buf-&gt;buffer-&gt;content, *doc_txt_len);
1795     }
1796 #endif
1797     (void)xmlOutputBufferClose(buf);
1798     return 0;
1799 }
1800 
<a name="3" id="anc3"></a><span class="line-added">1801 #ifdef WITH_PROFILER</span>
<span class="line-added">1802 </span>
1803 /************************************************************************
1804  *                                  *
1805  *      Generating profiling information            *
1806  *                                  *
1807  ************************************************************************/
1808 
1809 static long calibration = -1;
1810 
1811 /**
1812  * xsltCalibrateTimestamps:
1813  *
1814  * Used for to calibrate the xsltTimestamp() function
1815  * Should work if launched at startup and we don&#39;t loose our quantum :-)
1816  *
1817  * Returns the number of milliseconds used by xsltTimestamp()
1818  */
1819 #if !defined(XSLT_WIN32_PERFORMANCE_COUNTER) &amp;&amp; \
1820     (defined(HAVE_CLOCK_GETTIME) || defined(HAVE_GETTIMEOFDAY))
1821 static long
1822 xsltCalibrateTimestamps(void) {
1823     register int i;
1824 
1825     for (i = 0;i &lt; 999;i++)
1826     xsltTimestamp();
1827     return(xsltTimestamp() / 1000);
1828 }
1829 #endif
1830 
1831 /**
1832  * xsltCalibrateAdjust:
1833  * @delta:  a negative dealy value found
1834  *
1835  * Used for to correct the calibration for xsltTimestamp()
1836  */
1837 void
1838 xsltCalibrateAdjust(long delta) {
1839     calibration += delta;
1840 }
1841 
1842 /**
1843  * xsltTimestamp:
1844  *
1845  * Used for gathering profiling data
1846  *
1847  * Returns the number of tenth of milliseconds since the beginning of the
1848  * profiling
1849  */
1850 long
1851 xsltTimestamp(void)
1852 {
1853 #ifdef XSLT_WIN32_PERFORMANCE_COUNTER
1854     BOOL ok;
1855     LARGE_INTEGER performanceCount;
1856     LARGE_INTEGER performanceFrequency;
1857     LONGLONG quadCount;
1858     double seconds;
1859     static LONGLONG startupQuadCount = 0;
1860     static LONGLONG startupQuadFreq = 0;
1861 
1862     ok = QueryPerformanceCounter(&amp;performanceCount);
1863     if (!ok)
1864         return 0;
1865     quadCount = performanceCount.QuadPart;
1866     if (calibration &lt; 0) {
1867         calibration = 0;
1868         ok = QueryPerformanceFrequency(&amp;performanceFrequency);
1869         if (!ok)
1870             return 0;
1871         startupQuadFreq = performanceFrequency.QuadPart;
1872         startupQuadCount = quadCount;
1873         return (0);
1874     }
1875     if (startupQuadFreq == 0)
1876         return 0;
1877     seconds = (quadCount - startupQuadCount) / (double) startupQuadFreq;
1878     return (long) (seconds * XSLT_TIMESTAMP_TICS_PER_SEC);
1879 
1880 #else /* XSLT_WIN32_PERFORMANCE_COUNTER */
1881 #ifdef HAVE_CLOCK_GETTIME
1882 #  if defined(CLOCK_MONOTONIC)
1883 #    define XSLT_CLOCK CLOCK_MONOTONIC
1884 #  elif defined(CLOCK_HIGHRES)
1885 #    define XSLT_CLOCK CLOCK_HIGHRES
1886 #  else
1887 #    define XSLT_CLOCK CLOCK_REALTIME
1888 #  endif
1889     static struct timespec startup;
1890     struct timespec cur;
1891     long tics;
1892 
1893     if (calibration &lt; 0) {
1894         clock_gettime(XSLT_CLOCK, &amp;startup);
1895         calibration = 0;
1896         calibration = xsltCalibrateTimestamps();
1897         clock_gettime(XSLT_CLOCK, &amp;startup);
1898         return (0);
1899     }
1900 
1901     clock_gettime(XSLT_CLOCK, &amp;cur);
1902     tics = (cur.tv_sec - startup.tv_sec) * XSLT_TIMESTAMP_TICS_PER_SEC;
1903     tics += (cur.tv_nsec - startup.tv_nsec) /
1904                           (1000000000l / XSLT_TIMESTAMP_TICS_PER_SEC);
1905 
1906     tics -= calibration;
1907     return(tics);
1908 
1909 #elif HAVE_GETTIMEOFDAY
1910     static struct timeval startup;
1911     struct timeval cur;
1912     long tics;
1913 
1914     if (calibration &lt; 0) {
1915         gettimeofday(&amp;startup, NULL);
1916         calibration = 0;
1917         calibration = xsltCalibrateTimestamps();
1918         gettimeofday(&amp;startup, NULL);
1919         return (0);
1920     }
1921 
1922     gettimeofday(&amp;cur, NULL);
1923     tics = (cur.tv_sec - startup.tv_sec) * XSLT_TIMESTAMP_TICS_PER_SEC;
1924     tics += (cur.tv_usec - startup.tv_usec) /
1925                           (1000000l / XSLT_TIMESTAMP_TICS_PER_SEC);
1926 
1927     tics -= calibration;
1928     return(tics);
1929 #else
1930 
1931     /* Neither gettimeofday() nor Win32 performance counter available */
1932 
1933     return (0);
1934 
1935 #endif /* HAVE_GETTIMEOFDAY */
1936 #endif /* XSLT_WIN32_PERFORMANCE_COUNTER */
1937 }
1938 
1939 static char *
1940 pretty_templ_match(xsltTemplatePtr templ) {
1941   static char dst[1001];
1942   char *src = (char *)templ-&gt;match;
1943   int i=0,j;
1944 
1945   /* strip white spaces */
1946   for (j=0; i&lt;1000 &amp;&amp; src[j]; i++,j++) {
1947       for(;src[j]==&#39; &#39;;j++);
1948       dst[i]=src[j];
1949   }
1950   if(i&lt;998 &amp;&amp; templ-&gt;mode) {
1951     /* append [mode] */
1952     dst[i++]=&#39;[&#39;;
1953     src=(char *)templ-&gt;mode;
1954     for (j=0; i&lt;999 &amp;&amp; src[j]; i++,j++) {
1955       dst[i]=src[j];
1956     }
1957     dst[i++]=&#39;]&#39;;
1958   }
1959   dst[i]=&#39;\0&#39;;
1960   return dst;
1961 }
1962 
1963 #define MAX_TEMPLATES 10000
1964 
1965 /**
1966  * xsltSaveProfiling:
1967  * @ctxt:  an XSLT context
1968  * @output:  a FILE * for saving the information
1969  *
1970  * Save the profiling information on @output
1971  */
1972 void
1973 xsltSaveProfiling(xsltTransformContextPtr ctxt, FILE *output) {
1974     int nb, i,j,k,l;
1975     int max;
1976     int total;
1977     unsigned long totalt;
1978     xsltTemplatePtr *templates;
1979     xsltStylesheetPtr style;
1980     xsltTemplatePtr templ1,templ2;
1981     int *childt;
1982 
1983     if ((output == NULL) || (ctxt == NULL))
1984     return;
1985     if (ctxt-&gt;profile == 0)
1986     return;
1987 
1988     nb = 0;
1989     max = MAX_TEMPLATES;
1990     templates = xmlMalloc(max * sizeof(xsltTemplatePtr));
1991     if (templates == NULL)
1992     return;
1993 
1994     style = ctxt-&gt;style;
1995     while (style != NULL) {
1996     templ1 = style-&gt;templates;
1997     while (templ1 != NULL) {
1998         if (nb &gt;= max)
1999         break;
2000 
2001         if (templ1-&gt;nbCalls &gt; 0)
2002         templates[nb++] = templ1;
2003         templ1 = templ1-&gt;next;
2004     }
2005 
2006     style = xsltNextImport(style);
2007     }
2008 
2009     for (i = 0;i &lt; nb -1;i++) {
2010     for (j = i + 1; j &lt; nb; j++) {
2011         if ((templates[i]-&gt;time &lt;= templates[j]-&gt;time) ||
2012         ((templates[i]-&gt;time == templates[j]-&gt;time) &amp;&amp;
2013              (templates[i]-&gt;nbCalls &lt;= templates[j]-&gt;nbCalls))) {
2014         templ1 = templates[j];
2015         templates[j] = templates[i];
2016         templates[i] = templ1;
2017         }
2018     }
2019     }
2020 
2021 
2022     /* print flat profile */
2023 
2024     fprintf(output, &quot;%6s%20s%20s%10s  Calls Tot 100us Avg\n\n&quot;,
2025         &quot;number&quot;, &quot;match&quot;, &quot;name&quot;, &quot;mode&quot;);
2026     total = 0;
2027     totalt = 0;
2028     for (i = 0;i &lt; nb;i++) {
2029          templ1 = templates[i];
2030     fprintf(output, &quot;%5d &quot;, i);
2031     if (templ1-&gt;match != NULL) {
2032         if (xmlStrlen(templ1-&gt;match) &gt; 20)
2033         fprintf(output, &quot;%s\n%26s&quot;, templ1-&gt;match, &quot;&quot;);
2034         else
2035         fprintf(output, &quot;%20s&quot;, templ1-&gt;match);
2036     } else {
2037         fprintf(output, &quot;%20s&quot;, &quot;&quot;);
2038     }
2039     if (templ1-&gt;name != NULL) {
2040         if (xmlStrlen(templ1-&gt;name) &gt; 20)
2041         fprintf(output, &quot;%s\n%46s&quot;, templ1-&gt;name, &quot;&quot;);
2042         else
2043         fprintf(output, &quot;%20s&quot;, templ1-&gt;name);
2044     } else {
2045         fprintf(output, &quot;%20s&quot;, &quot;&quot;);
2046     }
2047     if (templ1-&gt;mode != NULL) {
2048         if (xmlStrlen(templ1-&gt;mode) &gt; 10)
2049         fprintf(output, &quot;%s\n%56s&quot;, templ1-&gt;mode, &quot;&quot;);
2050         else
2051         fprintf(output, &quot;%10s&quot;, templ1-&gt;mode);
2052     } else {
2053         fprintf(output, &quot;%10s&quot;, &quot;&quot;);
2054     }
2055     fprintf(output, &quot; %6d&quot;, templ1-&gt;nbCalls);
2056     fprintf(output, &quot; %6ld %6ld\n&quot;, templ1-&gt;time,
2057         templ1-&gt;time / templ1-&gt;nbCalls);
2058     total += templ1-&gt;nbCalls;
2059     totalt += templ1-&gt;time;
2060     }
2061     fprintf(output, &quot;\n%30s%26s %6d %6ld\n&quot;, &quot;Total&quot;, &quot;&quot;, total, totalt);
2062 
2063 
2064     /* print call graph */
2065 
2066     childt = xmlMalloc((nb + 1) * sizeof(int));
2067     if (childt == NULL)
2068     return;
2069 
2070     /* precalculate children times */
2071     for (i = 0; i &lt; nb; i++) {
2072         templ1 = templates[i];
2073 
2074         childt[i] = 0;
2075         for (k = 0; k &lt; nb; k++) {
2076             templ2 = templates[k];
2077             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2078                 if (templ2-&gt;templCalledTab[l] == templ1) {
2079                     childt[i] +=templ2-&gt;time;
2080                 }
2081             }
2082         }
2083     }
2084     childt[i] = 0;
2085 
2086     fprintf(output, &quot;\nindex %% time    self  children    called     name\n&quot;);
2087 
2088     for (i = 0; i &lt; nb; i++) {
2089         char ix_str[20], timep_str[20], times_str[20], timec_str[20], called_str[20];
2090         unsigned long t;
2091 
2092         templ1 = templates[i];
2093         /* callers */
2094         for (j = 0; j &lt; templ1-&gt;templNr; j++) {
2095             templ2 = templ1-&gt;templCalledTab[j];
2096             for (k = 0; k &lt; nb; k++) {
2097               if (templates[k] == templ2)
2098                 break;
2099             }
2100             t=templ2?templ2-&gt;time:totalt;
2101             snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
2102             snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
2103             snprintf(called_str,sizeof(called_str),&quot;%6d/%d&quot;,
2104                 templ1-&gt;templCountTab[j], /* number of times caller calls &#39;this&#39; */
2105                 templ1-&gt;nbCalls);         /* total number of calls to &#39;this&#39; */
2106 
2107             fprintf(output, &quot;             %-8s %-8s %-12s     %s [%d]\n&quot;,
2108                 times_str,timec_str,called_str,
2109                 (templ2?(templ2-&gt;name?(char *)templ2-&gt;name:pretty_templ_match(templ2)):&quot;-&quot;),k);
2110         }
2111         /* this */
2112         snprintf(ix_str,sizeof(ix_str),&quot;[%d]&quot;,i);
2113         snprintf(timep_str,sizeof(timep_str),&quot;%6.2f&quot;,(float)templ1-&gt;time*100.0/totalt);
2114         snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)templ1-&gt;time/XSLT_TIMESTAMP_TICS_PER_SEC);
2115         snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[i]/XSLT_TIMESTAMP_TICS_PER_SEC);
2116         fprintf(output, &quot;%-5s %-6s %-8s %-8s %6d     %s [%d]\n&quot;,
2117             ix_str, timep_str,times_str,timec_str,
2118             templ1-&gt;nbCalls,
2119             templ1-&gt;name?(char *)templ1-&gt;name:pretty_templ_match(templ1),i);
2120         /* callees
2121          * - go over templates[0..nb] and their templCalledTab[]
2122          * - print those where we in the the call-stack
2123          */
2124         total = 0;
2125         for (k = 0; k &lt; nb; k++) {
2126             templ2 = templates[k];
2127             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2128                 if (templ2-&gt;templCalledTab[l] == templ1) {
2129                     total+=templ2-&gt;templCountTab[l];
2130                 }
2131             }
2132         }
2133         for (k = 0; k &lt; nb; k++) {
2134             templ2 = templates[k];
2135             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2136                 if (templ2-&gt;templCalledTab[l] == templ1) {
2137                     snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)templ2-&gt;time/XSLT_TIMESTAMP_TICS_PER_SEC);
2138                     snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
2139                     snprintf(called_str,sizeof(called_str),&quot;%6d/%d&quot;,
2140                         templ2-&gt;templCountTab[l], /* number of times &#39;this&#39; calls callee */
2141                         total);                   /* total number of calls from &#39;this&#39; */
2142                     fprintf(output, &quot;             %-8s %-8s %-12s     %s [%d]\n&quot;,
2143                         times_str,timec_str,called_str,
2144                         templ2-&gt;name?(char *)templ2-&gt;name:pretty_templ_match(templ2),k);
2145                 }
2146             }
2147         }
2148         fprintf(output, &quot;-----------------------------------------------\n&quot;);
2149     }
2150 
2151     fprintf(output, &quot;\f\nIndex by function name\n&quot;);
2152     for (i = 0; i &lt; nb; i++) {
2153         templ1 = templates[i];
2154         fprintf(output, &quot;[%d] %s (%s:%d)\n&quot;,
2155             i, templ1-&gt;name?(char *)templ1-&gt;name:pretty_templ_match(templ1),
2156             templ1-&gt;style-&gt;doc-&gt;URL,templ1-&gt;elem-&gt;line);
2157     }
2158 
2159     fprintf(output, &quot;\f\n&quot;);
2160     xmlFree(childt);
2161 
2162     xmlFree(templates);
2163 }
2164 
2165 /************************************************************************
2166  *                                  *
2167  *      Fetching profiling information              *
2168  *                                  *
2169  ************************************************************************/
2170 
2171 /**
2172  * xsltGetProfileInformation:
2173  * @ctxt:  a transformation context
2174  *
2175  * This function should be called after the transformation completed
2176  * to extract template processing profiling information if available.
2177  * The information is returned as an XML document tree like
2178  * &lt;?xml version=&quot;1.0&quot;?&gt;
2179  * &lt;profile&gt;
2180  * &lt;template rank=&quot;1&quot; match=&quot;*&quot; name=&quot;&quot;
2181  *         mode=&quot;&quot; calls=&quot;6&quot; time=&quot;48&quot; average=&quot;8&quot;/&gt;
2182  * &lt;template rank=&quot;2&quot; match=&quot;item2|item3&quot; name=&quot;&quot;
2183  *         mode=&quot;&quot; calls=&quot;10&quot; time=&quot;30&quot; average=&quot;3&quot;/&gt;
2184  * &lt;template rank=&quot;3&quot; match=&quot;item1&quot; name=&quot;&quot;
2185  *         mode=&quot;&quot; calls=&quot;5&quot; time=&quot;17&quot; average=&quot;3&quot;/&gt;
2186  * &lt;/profile&gt;
2187  * The caller will need to free up the returned tree with xmlFreeDoc()
2188  *
2189  * Returns the xmlDocPtr corresponding to the result or NULL if not available.
2190  */
2191 
2192 xmlDocPtr
2193 xsltGetProfileInformation(xsltTransformContextPtr ctxt)
2194 {
2195     xmlDocPtr ret = NULL;
2196     xmlNodePtr root, child;
2197     char buf[100];
2198 
2199     xsltStylesheetPtr style;
2200     xsltTemplatePtr *templates;
2201     xsltTemplatePtr templ;
2202     int nb = 0, max = 0, i, j;
2203 
2204     if (!ctxt)
2205         return NULL;
2206 
2207     if (!ctxt-&gt;profile)
2208         return NULL;
2209 
2210     nb = 0;
2211     max = 10000;
2212     templates =
2213         (xsltTemplatePtr *) xmlMalloc(max * sizeof(xsltTemplatePtr));
2214     if (templates == NULL)
2215         return NULL;
2216 
2217     /*
2218      * collect all the templates in an array
2219      */
2220     style = ctxt-&gt;style;
2221     while (style != NULL) {
2222         templ = style-&gt;templates;
2223         while (templ != NULL) {
2224             if (nb &gt;= max)
2225                 break;
2226 
2227             if (templ-&gt;nbCalls &gt; 0)
2228                 templates[nb++] = templ;
2229             templ = templ-&gt;next;
2230         }
2231 
2232         style = (xsltStylesheetPtr) xsltNextImport(style);
2233     }
2234 
2235     /*
2236      * Sort the array by time spent
2237      */
2238     for (i = 0; i &lt; nb - 1; i++) {
2239         for (j = i + 1; j &lt; nb; j++) {
2240             if ((templates[i]-&gt;time &lt;= templates[j]-&gt;time) ||
2241                 ((templates[i]-&gt;time == templates[j]-&gt;time) &amp;&amp;
2242                  (templates[i]-&gt;nbCalls &lt;= templates[j]-&gt;nbCalls))) {
2243                 templ = templates[j];
2244                 templates[j] = templates[i];
2245                 templates[i] = templ;
2246             }
2247         }
2248     }
2249 
2250     /*
2251      * Generate a document corresponding to the results.
2252      */
2253     ret = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
2254     root = xmlNewDocNode(ret, NULL, BAD_CAST &quot;profile&quot;, NULL);
2255     xmlDocSetRootElement(ret, root);
2256 
2257     for (i = 0; i &lt; nb; i++) {
2258         child = xmlNewChild(root, NULL, BAD_CAST &quot;template&quot;, NULL);
2259         snprintf(buf, sizeof(buf), &quot;%d&quot;, i + 1);
2260         xmlSetProp(child, BAD_CAST &quot;rank&quot;, BAD_CAST buf);
2261         xmlSetProp(child, BAD_CAST &quot;match&quot;, BAD_CAST templates[i]-&gt;match);
2262         xmlSetProp(child, BAD_CAST &quot;name&quot;, BAD_CAST templates[i]-&gt;name);
2263         xmlSetProp(child, BAD_CAST &quot;mode&quot;, BAD_CAST templates[i]-&gt;mode);
2264 
2265         snprintf(buf, sizeof(buf), &quot;%d&quot;, templates[i]-&gt;nbCalls);
2266         xmlSetProp(child, BAD_CAST &quot;calls&quot;, BAD_CAST buf);
2267 
2268         snprintf(buf, sizeof(buf), &quot;%ld&quot;, templates[i]-&gt;time);
2269         xmlSetProp(child, BAD_CAST &quot;time&quot;, BAD_CAST buf);
2270 
2271         snprintf(buf, sizeof(buf), &quot;%ld&quot;, templates[i]-&gt;time / templates[i]-&gt;nbCalls);
2272         xmlSetProp(child, BAD_CAST &quot;average&quot;, BAD_CAST buf);
2273     };
2274 
2275     xmlFree(templates);
2276 
2277     return ret;
2278 }
2279 
<a name="4" id="anc4"></a><span class="line-added">2280 #endif /* WITH_PROFILER */</span>
<span class="line-added">2281 </span>
2282 /************************************************************************
2283  *                                  *
2284  *      Hooks for libxml2 XPath                 *
2285  *                                  *
2286  ************************************************************************/
2287 
2288 /**
2289  * xsltXPathCompileFlags:
2290  * @style: the stylesheet
2291  * @str:  the XPath expression
2292  * @flags: extra compilation flags to pass down to libxml2 XPath
2293  *
2294  * Compile an XPath expression
2295  *
2296  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
2297  *         the caller has to free the object.
2298  */
2299 xmlXPathCompExprPtr
2300 xsltXPathCompileFlags(xsltStylesheetPtr style, const xmlChar *str, int flags) {
2301     xmlXPathContextPtr xpathCtxt;
2302     xmlXPathCompExprPtr ret;
2303 
2304     if (style != NULL) {
<a name="5" id="anc5"></a><span class="line-modified">2305         xpathCtxt = style-&gt;principal-&gt;xpathCtxt;</span>


















2306     if (xpathCtxt == NULL)
2307         return NULL;
2308     xpathCtxt-&gt;dict = style-&gt;dict;
2309     } else {
2310     xpathCtxt = xmlXPathNewContext(NULL);
2311     if (xpathCtxt == NULL)
2312         return NULL;
2313     }
2314     xpathCtxt-&gt;flags = flags;
2315 
2316     /*
2317     * Compile the expression.
2318     */
2319     ret = xmlXPathCtxtCompile(xpathCtxt, str);
2320 
<a name="6" id="anc6"></a><span class="line-modified">2321     if (style == NULL) {</span>

2322     xmlXPathFreeContext(xpathCtxt);
2323     }
<a name="7" id="anc7"></a>


2324     /*
2325      * TODO: there is a lot of optimizations which should be possible
2326      *       like variable slot precomputations, function precomputations, etc.
2327      */
2328 
2329     return(ret);
2330 }
2331 
2332 /**
2333  * xsltXPathCompile:
2334  * @style: the stylesheet
2335  * @str:  the XPath expression
2336  *
2337  * Compile an XPath expression
2338  *
2339  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
2340  *         the caller has to free the object.
2341  */
2342 xmlXPathCompExprPtr
2343 xsltXPathCompile(xsltStylesheetPtr style, const xmlChar *str) {
2344     return(xsltXPathCompileFlags(style, str, 0));
2345 }
2346 
2347 /************************************************************************
2348  *                                  *
2349  *      Hooks for the debugger                  *
2350  *                                  *
2351  ************************************************************************/
2352 
<a name="8" id="anc8"></a><span class="line-added">2353 int xslDebugStatus;</span>
<span class="line-added">2354 </span>
<span class="line-added">2355 /**</span>
<span class="line-added">2356  * xsltGetDebuggerStatus:</span>
<span class="line-added">2357  *</span>
<span class="line-added">2358  * Get xslDebugStatus.</span>
<span class="line-added">2359  *</span>
<span class="line-added">2360  * Returns the value of xslDebugStatus.</span>
<span class="line-added">2361  */</span>
<span class="line-added">2362 int</span>
<span class="line-added">2363 xsltGetDebuggerStatus(void)</span>
<span class="line-added">2364 {</span>
<span class="line-added">2365     return(xslDebugStatus);</span>
<span class="line-added">2366 }</span>
<span class="line-added">2367 </span>
<span class="line-added">2368 #ifdef WITH_DEBUGGER</span>
<span class="line-added">2369 </span>
2370 /*
2371  * There is currently only 3 debugging callback defined
2372  * Debugger callbacks are disabled by default
2373  */
2374 #define XSLT_CALLBACK_NUMBER 3
2375 
2376 typedef struct _xsltDebuggerCallbacks xsltDebuggerCallbacks;
2377 typedef xsltDebuggerCallbacks *xsltDebuggerCallbacksPtr;
2378 struct _xsltDebuggerCallbacks {
2379     xsltHandleDebuggerCallback handler;
2380     xsltAddCallCallback add;
2381     xsltDropCallCallback drop;
2382 };
2383 
2384 static xsltDebuggerCallbacks xsltDebuggerCurrentCallbacks = {
2385     NULL, /* handler */
2386     NULL, /* add */
2387     NULL  /* drop */
2388 };
2389 
<a name="9" id="anc9"></a>

2390 /**
2391  * xsltSetDebuggerStatus:
2392  * @value : the value to be set
2393  *
2394  * This function sets the value of xslDebugStatus.
2395  */
2396 void
2397 xsltSetDebuggerStatus(int value)
2398 {
2399     xslDebugStatus = value;
2400 }
2401 
<a name="10" id="anc10"></a>












2402 /**
2403  * xsltSetDebuggerCallbacks:
2404  * @no : number of callbacks
2405  * @block : the block of callbacks
2406  *
2407  * This function allow to plug a debugger into the XSLT library
2408  * @block points to a block of memory containing the address of @no
2409  * callback routines.
2410  *
2411  * Returns 0 in case of success and -1 in case of error
2412  */
2413 int
2414 xsltSetDebuggerCallbacks(int no, void *block)
2415 {
2416     xsltDebuggerCallbacksPtr callbacks;
2417 
2418     if ((block == NULL) || (no != XSLT_CALLBACK_NUMBER))
2419     return(-1);
2420 
2421     callbacks = (xsltDebuggerCallbacksPtr) block;
2422     xsltDebuggerCurrentCallbacks.handler = callbacks-&gt;handler;
2423     xsltDebuggerCurrentCallbacks.add  = callbacks-&gt;add;
2424     xsltDebuggerCurrentCallbacks.drop  = callbacks-&gt;drop;
2425     return(0);
2426 }
2427 
2428 /**
2429  * xslHandleDebugger:
2430  * @cur : source node being executed
2431  * @node : data node being processed
2432  * @templ : temlate that applies to node
2433  * @ctxt : the xslt transform context
2434  *
2435  * If either cur or node are a breakpoint, or xslDebugStatus in state
2436  *   where debugging must occcur at this time then transfer control
2437  *   to the xslDebugBreak function
2438  */
2439 void
2440 xslHandleDebugger(xmlNodePtr cur, xmlNodePtr node, xsltTemplatePtr templ,
2441               xsltTransformContextPtr ctxt)
2442 {
2443     if (xsltDebuggerCurrentCallbacks.handler != NULL)
2444     xsltDebuggerCurrentCallbacks.handler(cur, node, templ, ctxt);
2445 }
2446 
2447 /**
2448  * xslAddCall:
2449  * @templ : current template being applied
2450  * @source : the source node being processed
2451  *
2452  * Add template &quot;call&quot; to call stack
2453  * Returns : 1 on sucess 0 otherwise an error may be printed if
2454  *            WITH_XSLT_DEBUG_BREAKPOINTS is defined
2455  */
2456 int
2457 xslAddCall(xsltTemplatePtr templ, xmlNodePtr source)
2458 {
2459     if (xsltDebuggerCurrentCallbacks.add != NULL)
2460     return(xsltDebuggerCurrentCallbacks.add(templ, source));
2461     return(0);
2462 }
2463 
2464 /**
2465  * xslDropCall:
2466  *
2467  * Drop the topmost item off the call stack
2468  */
2469 void
2470 xslDropCall(void)
2471 {
2472     if (xsltDebuggerCurrentCallbacks.drop != NULL)
2473     xsltDebuggerCurrentCallbacks.drop();
2474 }
2475 
<a name="11" id="anc11"></a><span class="line-added">2476 #endif /* WITH_DEBUGGER */</span>
<span class="line-added">2477 </span>
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>