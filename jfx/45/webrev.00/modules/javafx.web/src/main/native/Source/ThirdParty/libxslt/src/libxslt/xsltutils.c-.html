<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xsltutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * xsltutils.c: Utilities for the XSL Transformation 1.0 engine
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/1999/REC-xslt-19991116
   6  *
   7  * See Copyright for the status of this software.
   8  *
   9  * daniel@veillard.com
  10  */
  11 
  12 #define IN_LIBXSLT
  13 #include &quot;libxslt.h&quot;
  14 
  15 #ifndef XSLT_NEED_TRIO
  16 #include &lt;stdio.h&gt;
  17 #else
  18 #include &lt;trio.h&gt;
  19 #endif
  20 
  21 #include &lt;string.h&gt;
  22 #include &lt;time.h&gt;
  23 #ifdef HAVE_SYS_TIME_H
  24 #include &lt;sys/time.h&gt;
  25 #endif
  26 #ifdef HAVE_UNISTD_H
  27 #include &lt;unistd.h&gt;
  28 #endif
  29 #ifdef HAVE_STDLIB_H
  30 #include &lt;stdlib.h&gt;
  31 #endif
  32 #include &lt;stdarg.h&gt;
  33 
  34 #include &lt;libxml/xmlmemory.h&gt;
  35 #include &lt;libxml/tree.h&gt;
  36 #include &lt;libxml/HTMLtree.h&gt;
  37 #include &lt;libxml/xmlerror.h&gt;
  38 #include &lt;libxml/xmlIO.h&gt;
  39 #include &quot;xsltutils.h&quot;
  40 #include &quot;templates.h&quot;
  41 #include &quot;xsltInternals.h&quot;
  42 #include &quot;imports.h&quot;
  43 #include &quot;transform.h&quot;
  44 
  45 #if defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
  46 #define XSLT_WIN32_PERFORMANCE_COUNTER
  47 #endif
  48 
  49 /************************************************************************
  50  *                                  *
  51  *          Convenience function                *
  52  *                                  *
  53  ************************************************************************/
  54 
  55 /**
  56  * xsltGetCNsProp:
  57  * @style: the stylesheet
  58  * @node:  the node
  59  * @name:  the attribute name
  60  * @nameSpace:  the URI of the namespace
  61  *
  62  * Similar to xmlGetNsProp() but with a slightly different semantic
  63  *
  64  * Search and get the value of an attribute associated to a node
  65  * This attribute has to be anchored in the namespace specified,
  66  * or has no namespace and the element is in that namespace.
  67  *
  68  * This does the entity substitution.
  69  * This function looks in DTD attribute declaration for #FIXED or
  70  * default declaration values unless DTD use has been turned off.
  71  *
  72  * Returns the attribute value or NULL if not found. The string is allocated
  73  *         in the stylesheet dictionary.
  74  */
  75 const xmlChar *
  76 xsltGetCNsProp(xsltStylesheetPtr style, xmlNodePtr node,
  77               const xmlChar *name, const xmlChar *nameSpace) {
  78     xmlAttrPtr prop;
  79     xmlDocPtr doc;
  80     xmlNsPtr ns;
  81     xmlChar *tmp;
  82     const xmlChar *ret;
  83 
  84     if ((node == NULL) || (style == NULL) || (style-&gt;dict == NULL))
  85     return(NULL);
  86 
  87     if (nameSpace == NULL)
  88         return xmlGetProp(node, name);
  89 
  90     if (node-&gt;type == XML_NAMESPACE_DECL)
  91         return(NULL);
  92     if (node-&gt;type == XML_ELEMENT_NODE)
  93     prop = node-&gt;properties;
  94     else
  95     prop = NULL;
  96     while (prop != NULL) {
  97     /*
  98      * One need to have
  99      *   - same attribute names
 100      *   - and the attribute carrying that namespace
 101      */
 102         if ((xmlStrEqual(prop-&gt;name, name)) &amp;&amp;
 103         (((prop-&gt;ns == NULL) &amp;&amp; (node-&gt;ns != NULL) &amp;&amp;
 104           (xmlStrEqual(node-&gt;ns-&gt;href, nameSpace))) ||
 105          ((prop-&gt;ns != NULL) &amp;&amp;
 106           (xmlStrEqual(prop-&gt;ns-&gt;href, nameSpace))))) {
 107 
 108         tmp = xmlNodeListGetString(node-&gt;doc, prop-&gt;children, 1);
 109         if (tmp == NULL)
 110             ret = xmlDictLookup(style-&gt;dict, BAD_CAST &quot;&quot;, 0);
 111         else {
 112             ret = xmlDictLookup(style-&gt;dict, tmp, -1);
 113         xmlFree(tmp);
 114         }
 115         return ret;
 116         }
 117     prop = prop-&gt;next;
 118     }
 119     tmp = NULL;
 120     /*
 121      * Check if there is a default declaration in the internal
 122      * or external subsets
 123      */
 124     doc =  node-&gt;doc;
 125     if (doc != NULL) {
 126         if (doc-&gt;intSubset != NULL) {
 127         xmlAttributePtr attrDecl;
 128 
 129         attrDecl = xmlGetDtdAttrDesc(doc-&gt;intSubset, node-&gt;name, name);
 130         if ((attrDecl == NULL) &amp;&amp; (doc-&gt;extSubset != NULL))
 131         attrDecl = xmlGetDtdAttrDesc(doc-&gt;extSubset, node-&gt;name, name);
 132 
 133         if ((attrDecl != NULL) &amp;&amp; (attrDecl-&gt;prefix != NULL)) {
 134             /*
 135          * The DTD declaration only allows a prefix search
 136          */
 137         ns = xmlSearchNs(doc, node, attrDecl-&gt;prefix);
 138         if ((ns != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;href, nameSpace)))
 139             return(xmlDictLookup(style-&gt;dict,
 140                                  attrDecl-&gt;defaultValue, -1));
 141         }
 142     }
 143     }
 144     return(NULL);
 145 }
 146 /**
 147  * xsltGetNsProp:
 148  * @node:  the node
 149  * @name:  the attribute name
 150  * @nameSpace:  the URI of the namespace
 151  *
 152  * Similar to xmlGetNsProp() but with a slightly different semantic
 153  *
 154  * Search and get the value of an attribute associated to a node
 155  * This attribute has to be anchored in the namespace specified,
 156  * or has no namespace and the element is in that namespace.
 157  *
 158  * This does the entity substitution.
 159  * This function looks in DTD attribute declaration for #FIXED or
 160  * default declaration values unless DTD use has been turned off.
 161  *
 162  * Returns the attribute value or NULL if not found.
 163  *     It&#39;s up to the caller to free the memory.
 164  */
 165 xmlChar *
 166 xsltGetNsProp(xmlNodePtr node, const xmlChar *name, const xmlChar *nameSpace) {
 167     xmlAttrPtr prop;
 168     xmlDocPtr doc;
 169     xmlNsPtr ns;
 170 
 171     if (node == NULL)
 172     return(NULL);
 173 
 174     if (nameSpace == NULL)
 175         return xmlGetProp(node, name);
 176 
 177     if (node-&gt;type == XML_NAMESPACE_DECL)
 178         return(NULL);
 179     if (node-&gt;type == XML_ELEMENT_NODE)
 180     prop = node-&gt;properties;
 181     else
 182     prop = NULL;
 183     /*
 184     * TODO: Substitute xmlGetProp() for xmlGetNsProp(), since the former
 185     * is not namespace-aware and will return an attribute with equal
 186     * name regardless of its namespace.
 187     * Example:
 188     *   &lt;xsl:element foo:name=&quot;myName&quot;/&gt;
 189     *   So this would return &quot;myName&quot; even if an attribute @name
 190     *   in the XSLT was requested.
 191     */
 192     while (prop != NULL) {
 193     /*
 194      * One need to have
 195      *   - same attribute names
 196      *   - and the attribute carrying that namespace
 197      */
 198         if ((xmlStrEqual(prop-&gt;name, name)) &amp;&amp;
 199         (((prop-&gt;ns == NULL) &amp;&amp; (node-&gt;ns != NULL) &amp;&amp;
 200           (xmlStrEqual(node-&gt;ns-&gt;href, nameSpace))) ||
 201          ((prop-&gt;ns != NULL) &amp;&amp;
 202           (xmlStrEqual(prop-&gt;ns-&gt;href, nameSpace))))) {
 203         xmlChar *ret;
 204 
 205         ret = xmlNodeListGetString(node-&gt;doc, prop-&gt;children, 1);
 206         if (ret == NULL) return(xmlStrdup((xmlChar *)&quot;&quot;));
 207         return(ret);
 208         }
 209     prop = prop-&gt;next;
 210     }
 211 
 212     /*
 213      * Check if there is a default declaration in the internal
 214      * or external subsets
 215      */
 216     doc =  node-&gt;doc;
 217     if (doc != NULL) {
 218         if (doc-&gt;intSubset != NULL) {
 219         xmlAttributePtr attrDecl;
 220 
 221         attrDecl = xmlGetDtdAttrDesc(doc-&gt;intSubset, node-&gt;name, name);
 222         if ((attrDecl == NULL) &amp;&amp; (doc-&gt;extSubset != NULL))
 223         attrDecl = xmlGetDtdAttrDesc(doc-&gt;extSubset, node-&gt;name, name);
 224 
 225         if ((attrDecl != NULL) &amp;&amp; (attrDecl-&gt;prefix != NULL)) {
 226             /*
 227          * The DTD declaration only allows a prefix search
 228          */
 229         ns = xmlSearchNs(doc, node, attrDecl-&gt;prefix);
 230         if ((ns != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;href, nameSpace)))
 231             return(xmlStrdup(attrDecl-&gt;defaultValue));
 232         }
 233     }
 234     }
 235     return(NULL);
 236 }
 237 
 238 /**
 239  * xsltGetUTF8Char:
 240  * @utf:  a sequence of UTF-8 encoded bytes
 241  * @len:  a pointer to @bytes len
 242  *
 243  * Read one UTF8 Char from @utf
 244  * Function copied from libxml2 xmlGetUTF8Char() ... to discard ultimately
 245  * and use the original API
 246  *
 247  * Returns the char value or -1 in case of error and update @len with the
 248  *        number of bytes used
 249  */
 250 int
 251 xsltGetUTF8Char(const unsigned char *utf, int *len) {
 252     unsigned int c;
 253 
 254     if (utf == NULL)
 255     goto error;
 256     if (len == NULL)
 257     goto error;
 258     if (*len &lt; 1)
 259     goto error;
 260 
 261     c = utf[0];
 262     if (c &amp; 0x80) {
 263     if (*len &lt; 2)
 264         goto error;
 265     if ((utf[1] &amp; 0xc0) != 0x80)
 266         goto error;
 267     if ((c &amp; 0xe0) == 0xe0) {
 268         if (*len &lt; 3)
 269         goto error;
 270         if ((utf[2] &amp; 0xc0) != 0x80)
 271         goto error;
 272         if ((c &amp; 0xf0) == 0xf0) {
 273         if (*len &lt; 4)
 274             goto error;
 275         if ((c &amp; 0xf8) != 0xf0 || (utf[3] &amp; 0xc0) != 0x80)
 276             goto error;
 277         *len = 4;
 278         /* 4-byte code */
 279         c = (utf[0] &amp; 0x7) &lt;&lt; 18;
 280         c |= (utf[1] &amp; 0x3f) &lt;&lt; 12;
 281         c |= (utf[2] &amp; 0x3f) &lt;&lt; 6;
 282         c |= utf[3] &amp; 0x3f;
 283         } else {
 284           /* 3-byte code */
 285         *len = 3;
 286         c = (utf[0] &amp; 0xf) &lt;&lt; 12;
 287         c |= (utf[1] &amp; 0x3f) &lt;&lt; 6;
 288         c |= utf[2] &amp; 0x3f;
 289         }
 290     } else {
 291       /* 2-byte code */
 292         *len = 2;
 293         c = (utf[0] &amp; 0x1f) &lt;&lt; 6;
 294         c |= utf[1] &amp; 0x3f;
 295     }
 296     } else {
 297     /* 1-byte code */
 298     *len = 1;
 299     }
 300     return(c);
 301 
 302 error:
 303     if (len != NULL)
 304     *len = 0;
 305     return(-1);
 306 }
 307 
 308 #ifdef XSLT_REFACTORED
 309 
 310 /**
 311  * xsltPointerListAddSize:
 312  * @list: the pointer list structure
 313  * @item: the item to be stored
 314  * @initialSize: the initial size of the list
 315  *
 316  * Adds an item to the list.
 317  *
 318  * Returns the position of the added item in the list or
 319  *         -1 in case of an error.
 320  */
 321 int
 322 xsltPointerListAddSize(xsltPointerListPtr list,
 323                void *item,
 324                int initialSize)
 325 {
 326     if (list-&gt;items == NULL) {
 327     if (initialSize &lt;= 0)
 328         initialSize = 1;
 329     list-&gt;items = (void **) xmlMalloc(
 330         initialSize * sizeof(void *));
 331     if (list-&gt;items == NULL) {
 332         xsltGenericError(xsltGenericErrorContext,
 333          &quot;xsltPointerListAddSize: memory allocation failure.\n&quot;);
 334         return(-1);
 335     }
 336     list-&gt;number = 0;
 337     list-&gt;size = initialSize;
 338     } else if (list-&gt;size &lt;= list-&gt;number) {
 339     list-&gt;size *= 2;
 340     list-&gt;items = (void **) xmlRealloc(list-&gt;items,
 341         list-&gt;size * sizeof(void *));
 342     if (list-&gt;items == NULL) {
 343         xsltGenericError(xsltGenericErrorContext,
 344          &quot;xsltPointerListAddSize: memory re-allocation failure.\n&quot;);
 345         list-&gt;size = 0;
 346         return(-1);
 347     }
 348     }
 349     list-&gt;items[list-&gt;number++] = item;
 350     return(0);
 351 }
 352 
 353 /**
 354  * xsltPointerListCreate:
 355  * @initialSize: the initial size for the list
 356  *
 357  * Creates an xsltPointerList structure.
 358  *
 359  * Returns a xsltPointerList structure or NULL in case of an error.
 360  */
 361 xsltPointerListPtr
 362 xsltPointerListCreate(int initialSize)
 363 {
 364     xsltPointerListPtr ret;
 365 
 366     ret = xmlMalloc(sizeof(xsltPointerList));
 367     if (ret == NULL) {
 368     xsltGenericError(xsltGenericErrorContext,
 369          &quot;xsltPointerListCreate: memory allocation failure.\n&quot;);
 370     return (NULL);
 371     }
 372     memset(ret, 0, sizeof(xsltPointerList));
 373     if (initialSize &gt; 0) {
 374     xsltPointerListAddSize(ret, NULL, initialSize);
 375     ret-&gt;number = 0;
 376     }
 377     return (ret);
 378 }
 379 
 380 /**
 381  * xsltPointerListFree:
 382  * @list: pointer to the list to be freed
 383  *
 384  * Frees the xsltPointerList structure. This does not free
 385  * the content of the list.
 386  */
 387 void
 388 xsltPointerListFree(xsltPointerListPtr list)
 389 {
 390     if (list == NULL)
 391     return;
 392     if (list-&gt;items != NULL)
 393     xmlFree(list-&gt;items);
 394     xmlFree(list);
 395 }
 396 
 397 /**
 398  * xsltPointerListClear:
 399  * @list: pointer to the list to be cleared
 400  *
 401  * Resets the list, but does not free the allocated array
 402  * and does not free the content of the list.
 403  */
 404 void
 405 xsltPointerListClear(xsltPointerListPtr list)
 406 {
 407     if (list-&gt;items != NULL) {
 408     xmlFree(list-&gt;items);
 409     list-&gt;items = NULL;
 410     }
 411     list-&gt;number = 0;
 412     list-&gt;size = 0;
 413 }
 414 
 415 #endif /* XSLT_REFACTORED */
 416 
 417 /************************************************************************
 418  *                                  *
 419  *      Handling of XSLT stylesheets messages           *
 420  *                                  *
 421  ************************************************************************/
 422 
 423 /**
 424  * xsltMessage:
 425  * @ctxt:  an XSLT processing context
 426  * @node:  The current node
 427  * @inst:  The node containing the message instruction
 428  *
 429  * Process and xsl:message construct
 430  */
 431 void
 432 xsltMessage(xsltTransformContextPtr ctxt, xmlNodePtr node, xmlNodePtr inst) {
 433     xmlGenericErrorFunc error = xsltGenericError;
 434     void *errctx = xsltGenericErrorContext;
 435     xmlChar *prop, *message;
 436     int terminate = 0;
 437 
 438     if ((ctxt == NULL) || (inst == NULL))
 439     return;
 440 
 441     if (ctxt-&gt;error != NULL) {
 442     error = ctxt-&gt;error;
 443     errctx = ctxt-&gt;errctx;
 444     }
 445 
 446     prop = xmlGetNsProp(inst, (const xmlChar *)&quot;terminate&quot;, NULL);
 447     if (prop != NULL) {
 448     if (xmlStrEqual(prop, (const xmlChar *)&quot;yes&quot;)) {
 449         terminate = 1;
 450     } else if (xmlStrEqual(prop, (const xmlChar *)&quot;no&quot;)) {
 451         terminate = 0;
 452     } else {
 453         xsltTransformError(ctxt, NULL, inst,
 454         &quot;xsl:message : terminate expecting &#39;yes&#39; or &#39;no&#39;\n&quot;);
 455     }
 456     xmlFree(prop);
 457     }
 458     message = xsltEvalTemplateString(ctxt, node, inst);
 459     if (message != NULL) {
 460     int len = xmlStrlen(message);
 461 
 462     error(errctx, &quot;%s&quot;, (const char *)message);
 463     if ((len &gt; 0) &amp;&amp; (message[len - 1] != &#39;\n&#39;))
 464         error(errctx, &quot;\n&quot;);
 465     xmlFree(message);
 466     }
 467     if (terminate)
 468     ctxt-&gt;state = XSLT_STATE_STOPPED;
 469 }
 470 
 471 /************************************************************************
 472  *                                  *
 473  *      Handling of out of context errors           *
 474  *                                  *
 475  ************************************************************************/
 476 
 477 #define XSLT_GET_VAR_STR(msg, str) {                \
 478     int       size;                     \
 479     int       chars;                        \
 480     char      *larger;                      \
 481     va_list   ap;                       \
 482                                 \
 483     str = (char *) xmlMalloc(150);              \
 484     if (str == NULL)                        \
 485     return;                         \
 486                                 \
 487     size = 150;                         \
 488                                 \
 489     while (size &lt; 64000) {                  \
 490     va_start(ap, msg);                  \
 491     chars = vsnprintf(str, size, msg, ap);          \
 492     va_end(ap);                     \
 493     if ((chars &gt; -1) &amp;&amp; (chars &lt; size))         \
 494         break;                      \
 495     if (chars &gt; -1)                     \
 496         size += chars + 1;                  \
 497     else                            \
 498         size += 100;                    \
 499     if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
 500         xmlFree(str);                   \
 501         return;                     \
 502     }                           \
 503     str = larger;                       \
 504     }                               \
 505 }
 506 /**
 507  * xsltGenericErrorDefaultFunc:
 508  * @ctx:  an error context
 509  * @msg:  the message to display/transmit
 510  * @...:  extra parameters for the message display
 511  *
 512  * Default handler for out of context error messages.
 513  */
 514 static void LIBXSLT_ATTR_FORMAT(2,3)
 515 xsltGenericErrorDefaultFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) {
 516     va_list args;
 517 
 518     if (xsltGenericErrorContext == NULL)
 519     xsltGenericErrorContext = (void *) stderr;
 520 
 521     va_start(args, msg);
 522     vfprintf((FILE *)xsltGenericErrorContext, msg, args);
 523     va_end(args);
 524 }
 525 
 526 xmlGenericErrorFunc xsltGenericError = xsltGenericErrorDefaultFunc;
 527 void *xsltGenericErrorContext = NULL;
 528 
 529 
 530 /**
 531  * xsltSetGenericErrorFunc:
 532  * @ctx:  the new error handling context
 533  * @handler:  the new handler function
 534  *
 535  * Function to reset the handler and the error context for out of
 536  * context error messages.
 537  * This simply means that @handler will be called for subsequent
 538  * error messages while not parsing nor validating. And @ctx will
 539  * be passed as first argument to @handler
 540  * One can simply force messages to be emitted to another FILE * than
 541  * stderr by setting @ctx to this file handle and @handler to NULL.
 542  */
 543 void
 544 xsltSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
 545     xsltGenericErrorContext = ctx;
 546     if (handler != NULL)
 547     xsltGenericError = handler;
 548     else
 549     xsltGenericError = xsltGenericErrorDefaultFunc;
 550 }
 551 
 552 /**
 553  * xsltGenericDebugDefaultFunc:
 554  * @ctx:  an error context
 555  * @msg:  the message to display/transmit
 556  * @...:  extra parameters for the message display
 557  *
 558  * Default handler for out of context error messages.
 559  */
 560 static void LIBXSLT_ATTR_FORMAT(2,3)
 561 xsltGenericDebugDefaultFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...) {
 562     va_list args;
 563 
 564     if (xsltGenericDebugContext == NULL)
 565     return;
 566 
 567     va_start(args, msg);
 568     vfprintf((FILE *)xsltGenericDebugContext, msg, args);
 569     va_end(args);
 570 }
 571 
 572 xmlGenericErrorFunc xsltGenericDebug = xsltGenericDebugDefaultFunc;
 573 void *xsltGenericDebugContext = NULL;
 574 
 575 
 576 /**
 577  * xsltSetGenericDebugFunc:
 578  * @ctx:  the new error handling context
 579  * @handler:  the new handler function
 580  *
 581  * Function to reset the handler and the error context for out of
 582  * context error messages.
 583  * This simply means that @handler will be called for subsequent
 584  * error messages while not parsing or validating. And @ctx will
 585  * be passed as first argument to @handler
 586  * One can simply force messages to be emitted to another FILE * than
 587  * stderr by setting @ctx to this file handle and @handler to NULL.
 588  */
 589 void
 590 xsltSetGenericDebugFunc(void *ctx, xmlGenericErrorFunc handler) {
 591     xsltGenericDebugContext = ctx;
 592     if (handler != NULL)
 593     xsltGenericDebug = handler;
 594     else
 595     xsltGenericDebug = xsltGenericDebugDefaultFunc;
 596 }
 597 
 598 /**
 599  * xsltPrintErrorContext:
 600  * @ctxt:  the transformation context
 601  * @style:  the stylesheet
 602  * @node:  the current node being processed
 603  *
 604  * Display the context of an error.
 605  */
 606 void
 607 xsltPrintErrorContext(xsltTransformContextPtr ctxt,
 608                   xsltStylesheetPtr style, xmlNodePtr node) {
 609     int line = 0;
 610     const xmlChar *file = NULL;
 611     const xmlChar *name = NULL;
 612     const char *type = &quot;error&quot;;
 613     xmlGenericErrorFunc error = xsltGenericError;
 614     void *errctx = xsltGenericErrorContext;
 615 
 616     if (ctxt != NULL) {
 617         if (ctxt-&gt;state == XSLT_STATE_OK)
 618         ctxt-&gt;state = XSLT_STATE_ERROR;
 619     if (ctxt-&gt;error != NULL) {
 620         error = ctxt-&gt;error;
 621         errctx = ctxt-&gt;errctx;
 622     }
 623     }
 624     if ((node == NULL) &amp;&amp; (ctxt != NULL))
 625     node = ctxt-&gt;inst;
 626 
 627     if (node != NULL)  {
 628     if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 629         (node-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 630         xmlDocPtr doc = (xmlDocPtr) node;
 631 
 632         file = doc-&gt;URL;
 633     } else {
 634         line = xmlGetLineNo(node);
 635         if ((node-&gt;doc != NULL) &amp;&amp; (node-&gt;doc-&gt;URL != NULL))
 636         file = node-&gt;doc-&gt;URL;
 637         if (node-&gt;name != NULL)
 638         name = node-&gt;name;
 639     }
 640     }
 641 
 642     if (ctxt != NULL)
 643     type = &quot;runtime error&quot;;
 644     else if (style != NULL) {
 645 #ifdef XSLT_REFACTORED
 646     if (XSLT_CCTXT(style)-&gt;errSeverity == XSLT_ERROR_SEVERITY_WARNING)
 647         type = &quot;compilation warning&quot;;
 648     else
 649         type = &quot;compilation error&quot;;
 650 #else
 651     type = &quot;compilation error&quot;;
 652 #endif
 653     }
 654 
 655     if ((file != NULL) &amp;&amp; (line != 0) &amp;&amp; (name != NULL))
 656     error(errctx, &quot;%s: file %s line %d element %s\n&quot;,
 657           type, file, line, name);
 658     else if ((file != NULL) &amp;&amp; (name != NULL))
 659     error(errctx, &quot;%s: file %s element %s\n&quot;, type, file, name);
 660     else if ((file != NULL) &amp;&amp; (line != 0))
 661     error(errctx, &quot;%s: file %s line %d\n&quot;, type, file, line);
 662     else if (file != NULL)
 663     error(errctx, &quot;%s: file %s\n&quot;, type, file);
 664     else if (name != NULL)
 665     error(errctx, &quot;%s: element %s\n&quot;, type, name);
 666     else
 667     error(errctx, &quot;%s\n&quot;, type);
 668 }
 669 
 670 /**
 671  * xsltSetTransformErrorFunc:
 672  * @ctxt:  the XSLT transformation context
 673  * @ctx:  the new error handling context
 674  * @handler:  the new handler function
 675  *
 676  * Function to reset the handler and the error context for out of
 677  * context error messages specific to a given XSLT transromation.
 678  *
 679  * This simply means that @handler will be called for subsequent
 680  * error messages while running the transformation.
 681  */
 682 void
 683 xsltSetTransformErrorFunc(xsltTransformContextPtr ctxt,
 684                           void *ctx, xmlGenericErrorFunc handler)
 685 {
 686     ctxt-&gt;error = handler;
 687     ctxt-&gt;errctx = ctx;
 688 }
 689 
 690 /**
 691  * xsltTransformError:
 692  * @ctxt:  an XSLT transformation context
 693  * @style:  the XSLT stylesheet used
 694  * @node:  the current node in the stylesheet
 695  * @msg:  the message to display/transmit
 696  * @...:  extra parameters for the message display
 697  *
 698  * Display and format an error messages, gives file, line, position and
 699  * extra parameters, will use the specific transformation context if available
 700  */
 701 void
 702 xsltTransformError(xsltTransformContextPtr ctxt,
 703            xsltStylesheetPtr style,
 704            xmlNodePtr node,
 705            const char *msg, ...) {
 706     xmlGenericErrorFunc error = xsltGenericError;
 707     void *errctx = xsltGenericErrorContext;
 708     char * str;
 709 
 710     if (ctxt != NULL) {
 711         if (ctxt-&gt;state == XSLT_STATE_OK)
 712         ctxt-&gt;state = XSLT_STATE_ERROR;
 713     if (ctxt-&gt;error != NULL) {
 714         error = ctxt-&gt;error;
 715         errctx = ctxt-&gt;errctx;
 716     }
 717     }
 718     if ((node == NULL) &amp;&amp; (ctxt != NULL))
 719     node = ctxt-&gt;inst;
 720     xsltPrintErrorContext(ctxt, style, node);
 721     XSLT_GET_VAR_STR(msg, str);
 722     error(errctx, &quot;%s&quot;, str);
 723     if (str != NULL)
 724     xmlFree(str);
 725 }
 726 
 727 /************************************************************************
 728  *                                  *
 729  *              QNames                  *
 730  *                                  *
 731  ************************************************************************/
 732 
 733 /**
 734  * xsltSplitQName:
 735  * @dict: a dictionary
 736  * @name:  the full QName
 737  * @prefix: the return value
 738  *
 739  * Split QNames into prefix and local names, both allocated from a dictionary.
 740  *
 741  * Returns: the localname or NULL in case of error.
 742  */
 743 const xmlChar *
 744 xsltSplitQName(xmlDictPtr dict, const xmlChar *name, const xmlChar **prefix) {
 745     int len = 0;
 746     const xmlChar *ret = NULL;
 747 
 748     *prefix = NULL;
 749     if ((name == NULL) || (dict == NULL)) return(NULL);
 750     if (name[0] == &#39;:&#39;)
 751         return(xmlDictLookup(dict, name, -1));
 752     while ((name[len] != 0) &amp;&amp; (name[len] != &#39;:&#39;)) len++;
 753     if (name[len] == 0) return(xmlDictLookup(dict, name, -1));
 754     *prefix = xmlDictLookup(dict, name, len);
 755     ret = xmlDictLookup(dict, &amp;name[len + 1], -1);
 756     return(ret);
 757 }
 758 
 759 /**
 760  * xsltGetQNameURI:
 761  * @node:  the node holding the QName
 762  * @name:  pointer to the initial QName value
 763  *
 764  * This function analyzes @name, if the name contains a prefix,
 765  * the function seaches the associated namespace in scope for it.
 766  * It will also replace @name value with the NCName, the old value being
 767  * freed.
 768  * Errors in the prefix lookup are signalled by setting @name to NULL.
 769  *
 770  * NOTE: the namespace returned is a pointer to the place where it is
 771  *       defined and hence has the same lifespan as the document holding it.
 772  *
 773  * Returns the namespace URI if there is a prefix, or NULL if @name is
 774  *         not prefixed.
 775  */
 776 const xmlChar *
 777 xsltGetQNameURI(xmlNodePtr node, xmlChar ** name)
 778 {
 779     int len = 0;
 780     xmlChar *qname;
 781     xmlNsPtr ns;
 782 
 783     if (name == NULL)
 784     return(NULL);
 785     qname = *name;
 786     if ((qname == NULL) || (*qname == 0))
 787     return(NULL);
 788     if (node == NULL) {
 789     xsltGenericError(xsltGenericErrorContext,
 790                  &quot;QName: no element for namespace lookup %s\n&quot;,
 791              qname);
 792     xmlFree(qname);
 793     *name = NULL;
 794     return(NULL);
 795     }
 796 
 797     /* nasty but valid */
 798     if (qname[0] == &#39;:&#39;)
 799     return(NULL);
 800 
 801     /*
 802      * we are not trying to validate but just to cut, and yes it will
 803      * work even if this is a set of UTF-8 encoded chars
 804      */
 805     while ((qname[len] != 0) &amp;&amp; (qname[len] != &#39;:&#39;))
 806     len++;
 807 
 808     if (qname[len] == 0)
 809     return(NULL);
 810 
 811     /*
 812      * handle xml: separately, this one is magical
 813      */
 814     if ((qname[0] == &#39;x&#39;) &amp;&amp; (qname[1] == &#39;m&#39;) &amp;&amp;
 815         (qname[2] == &#39;l&#39;) &amp;&amp; (qname[3] == &#39;:&#39;)) {
 816     if (qname[4] == 0)
 817         return(NULL);
 818         *name = xmlStrdup(&amp;qname[4]);
 819     xmlFree(qname);
 820     return(XML_XML_NAMESPACE);
 821     }
 822 
 823     qname[len] = 0;
 824     ns = xmlSearchNs(node-&gt;doc, node, qname);
 825     if (ns == NULL) {
 826     xsltGenericError(xsltGenericErrorContext,
 827         &quot;%s:%s : no namespace bound to prefix %s\n&quot;,
 828                  qname, &amp;qname[len + 1], qname);
 829     *name = NULL;
 830     xmlFree(qname);
 831     return(NULL);
 832     }
 833     *name = xmlStrdup(&amp;qname[len + 1]);
 834     xmlFree(qname);
 835     return(ns-&gt;href);
 836 }
 837 
 838 /**
 839  * xsltGetQNameURI2:
 840  * @style:  stylesheet pointer
 841  * @node:   the node holding the QName
 842  * @name:   pointer to the initial QName value
 843  *
 844  * This function is similar to xsltGetQNameURI, but is used when
 845  * @name is a dictionary entry.
 846  *
 847  * Returns the namespace URI if there is a prefix, or NULL if @name is
 848  * not prefixed.
 849  */
 850 const xmlChar *
 851 xsltGetQNameURI2(xsltStylesheetPtr style, xmlNodePtr node,
 852          const xmlChar **name) {
 853     int len = 0;
 854     xmlChar *qname;
 855     xmlNsPtr ns;
 856 
 857     if (name == NULL)
 858         return(NULL);
 859     qname = (xmlChar *)*name;
 860     if ((qname == NULL) || (*qname == 0))
 861         return(NULL);
 862     if (node == NULL) {
 863         xsltGenericError(xsltGenericErrorContext,
 864                          &quot;QName: no element for namespace lookup %s\n&quot;,
 865                           qname);
 866     *name = NULL;
 867     return(NULL);
 868     }
 869 
 870     /*
 871      * we are not trying to validate but just to cut, and yes it will
 872      * work even if this is a set of UTF-8 encoded chars
 873      */
 874     while ((qname[len] != 0) &amp;&amp; (qname[len] != &#39;:&#39;))
 875         len++;
 876 
 877     if (qname[len] == 0)
 878         return(NULL);
 879 
 880     /*
 881      * handle xml: separately, this one is magical
 882      */
 883     if ((qname[0] == &#39;x&#39;) &amp;&amp; (qname[1] == &#39;m&#39;) &amp;&amp;
 884         (qname[2] == &#39;l&#39;) &amp;&amp; (qname[3] == &#39;:&#39;)) {
 885         if (qname[4] == 0)
 886             return(NULL);
 887         *name = xmlDictLookup(style-&gt;dict, &amp;qname[4], -1);
 888         return(XML_XML_NAMESPACE);
 889     }
 890 
 891     qname = xmlStrndup(*name, len);
 892     ns = xmlSearchNs(node-&gt;doc, node, qname);
 893     if (ns == NULL) {
 894     if (style) {
 895         xsltTransformError(NULL, style, node,
 896         &quot;No namespace bound to prefix &#39;%s&#39;.\n&quot;,
 897         qname);
 898         style-&gt;errors++;
 899     } else {
 900         xsltGenericError(xsltGenericErrorContext,
 901                 &quot;%s : no namespace bound to prefix %s\n&quot;,
 902         *name, qname);
 903     }
 904         *name = NULL;
 905         xmlFree(qname);
 906         return(NULL);
 907     }
 908     *name = xmlDictLookup(style-&gt;dict, (*name)+len+1, -1);
 909     xmlFree(qname);
 910     return(ns-&gt;href);
 911 }
 912 
 913 /************************************************************************
 914  *                                  *
 915  *              Sorting                 *
 916  *                                  *
 917  ************************************************************************/
 918 
 919 /**
 920  * xsltDocumentSortFunction:
 921  * @list:  the node set
 922  *
 923  * reorder the current node list @list accordingly to the document order
 924  * This function is slow, obsolete and should not be used anymore.
 925  */
 926 void
 927 xsltDocumentSortFunction(xmlNodeSetPtr list) {
 928     int i, j;
 929     int len, tst;
 930     xmlNodePtr node;
 931 
 932     if (list == NULL)
 933     return;
 934     len = list-&gt;nodeNr;
 935     if (len &lt;= 1)
 936     return;
 937     /* TODO: sort is really not optimized, does it needs to ? */
 938     for (i = 0;i &lt; len -1;i++) {
 939     for (j = i + 1; j &lt; len; j++) {
 940         tst = xmlXPathCmpNodes(list-&gt;nodeTab[i], list-&gt;nodeTab[j]);
 941         if (tst == -1) {
 942         node = list-&gt;nodeTab[i];
 943         list-&gt;nodeTab[i] = list-&gt;nodeTab[j];
 944         list-&gt;nodeTab[j] = node;
 945         }
 946     }
 947     }
 948 }
 949 
 950 /**
 951  * xsltComputeSortResult:
 952  * @ctxt:  a XSLT process context
 953  * @sort:  node list
 954  *
 955  * reorder the current node list accordingly to the set of sorting
 956  * requirement provided by the array of nodes.
 957  *
 958  * Returns a ordered XPath nodeset or NULL in case of error.
 959  */
 960 xmlXPathObjectPtr *
 961 xsltComputeSortResult(xsltTransformContextPtr ctxt, xmlNodePtr sort) {
 962 #ifdef XSLT_REFACTORED
 963     xsltStyleItemSortPtr comp;
 964 #else
 965     xsltStylePreCompPtr comp;
 966 #endif
 967     xmlXPathObjectPtr *results = NULL;
 968     xmlNodeSetPtr list = NULL;
 969     xmlXPathObjectPtr res;
 970     int len = 0;
 971     int i;
 972     xmlNodePtr oldNode;
 973     xmlNodePtr oldInst;
 974     int oldPos, oldSize ;
 975     int oldNsNr;
 976     xmlNsPtr *oldNamespaces;
 977 
 978     comp = sort-&gt;psvi;
 979     if (comp == NULL) {
 980     xsltGenericError(xsltGenericErrorContext,
 981          &quot;xsl:sort : compilation failed\n&quot;);
 982     return(NULL);
 983     }
 984 
 985     if ((comp-&gt;select == NULL) || (comp-&gt;comp == NULL))
 986     return(NULL);
 987 
 988     list = ctxt-&gt;nodeList;
 989     if ((list == NULL) || (list-&gt;nodeNr &lt;= 1))
 990     return(NULL);
 991 
 992     len = list-&gt;nodeNr;
 993 
 994     /* TODO: xsl:sort lang attribute */
 995     /* TODO: xsl:sort case-order attribute */
 996 
 997 
 998     results = xmlMalloc(len * sizeof(xmlXPathObjectPtr));
 999     if (results == NULL) {
1000     xsltGenericError(xsltGenericErrorContext,
1001          &quot;xsltComputeSortResult: memory allocation failure\n&quot;);
1002     return(NULL);
1003     }
1004 
1005     oldNode = ctxt-&gt;node;
1006     oldInst = ctxt-&gt;inst;
1007     oldPos = ctxt-&gt;xpathCtxt-&gt;proximityPosition;
1008     oldSize = ctxt-&gt;xpathCtxt-&gt;contextSize;
1009     oldNsNr = ctxt-&gt;xpathCtxt-&gt;nsNr;
1010     oldNamespaces = ctxt-&gt;xpathCtxt-&gt;namespaces;
1011     for (i = 0;i &lt; len;i++) {
1012     ctxt-&gt;inst = sort;
1013     ctxt-&gt;xpathCtxt-&gt;contextSize = len;
1014     ctxt-&gt;xpathCtxt-&gt;proximityPosition = i + 1;
1015     ctxt-&gt;node = list-&gt;nodeTab[i];
1016     ctxt-&gt;xpathCtxt-&gt;node = ctxt-&gt;node;
1017 #ifdef XSLT_REFACTORED
1018     if (comp-&gt;inScopeNs != NULL) {
1019         ctxt-&gt;xpathCtxt-&gt;namespaces = comp-&gt;inScopeNs-&gt;list;
1020         ctxt-&gt;xpathCtxt-&gt;nsNr = comp-&gt;inScopeNs-&gt;xpathNumber;
1021     } else {
1022         ctxt-&gt;xpathCtxt-&gt;namespaces = NULL;
1023         ctxt-&gt;xpathCtxt-&gt;nsNr = 0;
1024     }
1025 #else
1026     ctxt-&gt;xpathCtxt-&gt;namespaces = comp-&gt;nsList;
1027     ctxt-&gt;xpathCtxt-&gt;nsNr = comp-&gt;nsNr;
1028 #endif
1029     res = xmlXPathCompiledEval(comp-&gt;comp, ctxt-&gt;xpathCtxt);
1030     if (res != NULL) {
1031         if (res-&gt;type != XPATH_STRING)
1032         res = xmlXPathConvertString(res);
1033         if (comp-&gt;number)
1034         res = xmlXPathConvertNumber(res);
1035         res-&gt;index = i; /* Save original pos for dupl resolv */
1036         if (comp-&gt;number) {
1037         if (res-&gt;type == XPATH_NUMBER) {
1038             results[i] = res;
1039         } else {
1040 #ifdef WITH_XSLT_DEBUG_PROCESS
1041             xsltGenericDebug(xsltGenericDebugContext,
1042             &quot;xsltComputeSortResult: select didn&#39;t evaluate to a number\n&quot;);
1043 #endif
1044             results[i] = NULL;
1045         }
1046         } else {
1047         if (res-&gt;type == XPATH_STRING) {
1048             if (comp-&gt;locale != (xsltLocale)0) {
1049             xmlChar *str = res-&gt;stringval;
1050             res-&gt;stringval = (xmlChar *) xsltStrxfrm(comp-&gt;locale, str);
1051             xmlFree(str);
1052             }
1053 
1054             results[i] = res;
1055         } else {
1056 #ifdef WITH_XSLT_DEBUG_PROCESS
1057             xsltGenericDebug(xsltGenericDebugContext,
1058             &quot;xsltComputeSortResult: select didn&#39;t evaluate to a string\n&quot;);
1059 #endif
1060             results[i] = NULL;
1061         }
1062         }
1063     } else {
1064         ctxt-&gt;state = XSLT_STATE_STOPPED;
1065         results[i] = NULL;
1066     }
1067     }
1068     ctxt-&gt;node = oldNode;
1069     ctxt-&gt;inst = oldInst;
1070     ctxt-&gt;xpathCtxt-&gt;contextSize = oldSize;
1071     ctxt-&gt;xpathCtxt-&gt;proximityPosition = oldPos;
1072     ctxt-&gt;xpathCtxt-&gt;nsNr = oldNsNr;
1073     ctxt-&gt;xpathCtxt-&gt;namespaces = oldNamespaces;
1074 
1075     return(results);
1076 }
1077 
1078 /**
1079  * xsltDefaultSortFunction:
1080  * @ctxt:  a XSLT process context
1081  * @sorts:  array of sort nodes
1082  * @nbsorts:  the number of sorts in the array
1083  *
1084  * reorder the current node list accordingly to the set of sorting
1085  * requirement provided by the arry of nodes.
1086  */
1087 void
1088 xsltDefaultSortFunction(xsltTransformContextPtr ctxt, xmlNodePtr *sorts,
1089                int nbsorts) {
1090 #ifdef XSLT_REFACTORED
1091     xsltStyleItemSortPtr comp;
1092 #else
1093     xsltStylePreCompPtr comp;
1094 #endif
1095     xmlXPathObjectPtr *resultsTab[XSLT_MAX_SORT];
1096     xmlXPathObjectPtr *results = NULL, *res;
1097     xmlNodeSetPtr list = NULL;
1098     int descending, number, desc, numb;
1099     int len = 0;
1100     int i, j, incr;
1101     int tst;
1102     int depth;
1103     xmlNodePtr node;
1104     xmlXPathObjectPtr tmp;
1105     int tempstype[XSLT_MAX_SORT], temporder[XSLT_MAX_SORT];
1106 
1107     if ((ctxt == NULL) || (sorts == NULL) || (nbsorts &lt;= 0) ||
1108     (nbsorts &gt;= XSLT_MAX_SORT))
1109     return;
1110     if (sorts[0] == NULL)
1111     return;
1112     comp = sorts[0]-&gt;psvi;
1113     if (comp == NULL)
1114     return;
1115 
1116     list = ctxt-&gt;nodeList;
1117     if ((list == NULL) || (list-&gt;nodeNr &lt;= 1))
1118     return; /* nothing to do */
1119 
1120     for (j = 0; j &lt; nbsorts; j++) {
1121     comp = sorts[j]-&gt;psvi;
1122     tempstype[j] = 0;
1123     if ((comp-&gt;stype == NULL) &amp;&amp; (comp-&gt;has_stype != 0)) {
1124         comp-&gt;stype =
1125         xsltEvalAttrValueTemplate(ctxt, sorts[j],
1126                       (const xmlChar *) &quot;data-type&quot;,
1127                       XSLT_NAMESPACE);
1128         if (comp-&gt;stype != NULL) {
1129         tempstype[j] = 1;
1130         if (xmlStrEqual(comp-&gt;stype, (const xmlChar *) &quot;text&quot;))
1131             comp-&gt;number = 0;
1132         else if (xmlStrEqual(comp-&gt;stype, (const xmlChar *) &quot;number&quot;))
1133             comp-&gt;number = 1;
1134         else {
1135             xsltTransformError(ctxt, NULL, sorts[j],
1136               &quot;xsltDoSortFunction: no support for data-type = %s\n&quot;,
1137                      comp-&gt;stype);
1138             comp-&gt;number = 0; /* use default */
1139         }
1140         }
1141     }
1142     temporder[j] = 0;
1143     if ((comp-&gt;order == NULL) &amp;&amp; (comp-&gt;has_order != 0)) {
1144         comp-&gt;order = xsltEvalAttrValueTemplate(ctxt, sorts[j],
1145                             (const xmlChar *) &quot;order&quot;,
1146                             XSLT_NAMESPACE);
1147         if (comp-&gt;order != NULL) {
1148         temporder[j] = 1;
1149         if (xmlStrEqual(comp-&gt;order, (const xmlChar *) &quot;ascending&quot;))
1150             comp-&gt;descending = 0;
1151         else if (xmlStrEqual(comp-&gt;order,
1152                      (const xmlChar *) &quot;descending&quot;))
1153             comp-&gt;descending = 1;
1154         else {
1155             xsltTransformError(ctxt, NULL, sorts[j],
1156                  &quot;xsltDoSortFunction: invalid value %s for order\n&quot;,
1157                      comp-&gt;order);
1158             comp-&gt;descending = 0; /* use default */
1159         }
1160         }
1161     }
1162     }
1163 
1164     len = list-&gt;nodeNr;
1165 
1166     resultsTab[0] = xsltComputeSortResult(ctxt, sorts[0]);
1167     for (i = 1;i &lt; XSLT_MAX_SORT;i++)
1168     resultsTab[i] = NULL;
1169 
1170     results = resultsTab[0];
1171 
1172     comp = sorts[0]-&gt;psvi;
1173     descending = comp-&gt;descending;
1174     number = comp-&gt;number;
1175     if (results == NULL)
1176     return;
1177 
1178     /* Shell&#39;s sort of node-set */
1179     for (incr = len / 2; incr &gt; 0; incr /= 2) {
1180     for (i = incr; i &lt; len; i++) {
1181         j = i - incr;
1182         if (results[i] == NULL)
1183         continue;
1184 
1185         while (j &gt;= 0) {
1186         if (results[j] == NULL)
1187             tst = 1;
1188         else {
1189             if (number) {
1190             /* We make NaN smaller than number in accordance
1191                with XSLT spec */
1192             if (xmlXPathIsNaN(results[j]-&gt;floatval)) {
1193                 if (xmlXPathIsNaN(results[j + incr]-&gt;floatval))
1194                 tst = 0;
1195                 else
1196                 tst = -1;
1197             } else if (xmlXPathIsNaN(results[j + incr]-&gt;floatval))
1198                 tst = 1;
1199             else if (results[j]-&gt;floatval ==
1200                 results[j + incr]-&gt;floatval)
1201                 tst = 0;
1202             else if (results[j]-&gt;floatval &gt;
1203                 results[j + incr]-&gt;floatval)
1204                 tst = 1;
1205             else tst = -1;
1206             } else if(comp-&gt;locale != (xsltLocale)0) {
1207             tst = xsltLocaleStrcmp(
1208                 comp-&gt;locale,
1209                 (xsltLocaleChar *) results[j]-&gt;stringval,
1210                 (xsltLocaleChar *) results[j + incr]-&gt;stringval);
1211             } else {
1212             tst = xmlStrcmp(results[j]-&gt;stringval,
1213                      results[j + incr]-&gt;stringval);
1214             }
1215             if (descending)
1216             tst = -tst;
1217         }
1218         if (tst == 0) {
1219             /*
1220              * Okay we need to use multi level sorts
1221              */
1222             depth = 1;
1223             while (depth &lt; nbsorts) {
1224             if (sorts[depth] == NULL)
1225                 break;
1226             comp = sorts[depth]-&gt;psvi;
1227             if (comp == NULL)
1228                 break;
1229             desc = comp-&gt;descending;
1230             numb = comp-&gt;number;
1231 
1232             /*
1233              * Compute the result of the next level for the
1234              * full set, this might be optimized ... or not
1235              */
1236             if (resultsTab[depth] == NULL)
1237                 resultsTab[depth] = xsltComputeSortResult(ctxt,
1238                                         sorts[depth]);
1239             res = resultsTab[depth];
1240             if (res == NULL)
1241                 break;
1242             if (res[j] == NULL) {
1243                 if (res[j+incr] != NULL)
1244                 tst = 1;
1245             } else if (res[j+incr] == NULL) {
1246                 tst = -1;
1247             } else {
1248                 if (numb) {
1249                 /* We make NaN smaller than number in
1250                    accordance with XSLT spec */
1251                 if (xmlXPathIsNaN(res[j]-&gt;floatval)) {
1252                     if (xmlXPathIsNaN(res[j +
1253                         incr]-&gt;floatval))
1254                     tst = 0;
1255                     else
1256                         tst = -1;
1257                 } else if (xmlXPathIsNaN(res[j + incr]-&gt;
1258                         floatval))
1259                     tst = 1;
1260                 else if (res[j]-&gt;floatval == res[j + incr]-&gt;
1261                         floatval)
1262                     tst = 0;
1263                 else if (res[j]-&gt;floatval &gt;
1264                     res[j + incr]-&gt;floatval)
1265                     tst = 1;
1266                 else tst = -1;
1267                 } else if(comp-&gt;locale != (xsltLocale)0) {
1268                 tst = xsltLocaleStrcmp(
1269                     comp-&gt;locale,
1270                     (xsltLocaleChar *) res[j]-&gt;stringval,
1271                     (xsltLocaleChar *) res[j + incr]-&gt;stringval);
1272                 } else {
1273                 tst = xmlStrcmp(res[j]-&gt;stringval,
1274                          res[j + incr]-&gt;stringval);
1275                 }
1276                 if (desc)
1277                 tst = -tst;
1278             }
1279 
1280             /*
1281              * if we still can&#39;t differenciate at this level
1282              * try one level deeper.
1283              */
1284             if (tst != 0)
1285                 break;
1286             depth++;
1287             }
1288         }
1289         if (tst == 0) {
1290             tst = results[j]-&gt;index &gt; results[j + incr]-&gt;index;
1291         }
1292         if (tst &gt; 0) {
1293             tmp = results[j];
1294             results[j] = results[j + incr];
1295             results[j + incr] = tmp;
1296             node = list-&gt;nodeTab[j];
1297             list-&gt;nodeTab[j] = list-&gt;nodeTab[j + incr];
1298             list-&gt;nodeTab[j + incr] = node;
1299             depth = 1;
1300             while (depth &lt; nbsorts) {
1301             if (sorts[depth] == NULL)
1302                 break;
1303             if (resultsTab[depth] == NULL)
1304                 break;
1305             res = resultsTab[depth];
1306             tmp = res[j];
1307             res[j] = res[j + incr];
1308             res[j + incr] = tmp;
1309             depth++;
1310             }
1311             j -= incr;
1312         } else
1313             break;
1314         }
1315     }
1316     }
1317 
1318     for (j = 0; j &lt; nbsorts; j++) {
1319     comp = sorts[j]-&gt;psvi;
1320     if (tempstype[j] == 1) {
1321         /* The data-type needs to be recomputed each time */
1322         xmlFree((void *)(comp-&gt;stype));
1323         comp-&gt;stype = NULL;
1324     }
1325     if (temporder[j] == 1) {
1326         /* The order needs to be recomputed each time */
1327         xmlFree((void *)(comp-&gt;order));
1328         comp-&gt;order = NULL;
1329     }
1330     if (resultsTab[j] != NULL) {
1331         for (i = 0;i &lt; len;i++)
1332         xmlXPathFreeObject(resultsTab[j][i]);
1333         xmlFree(resultsTab[j]);
1334     }
1335     }
1336 }
1337 
1338 
1339 static xsltSortFunc xsltSortFunction = xsltDefaultSortFunction;
1340 
1341 /**
1342  * xsltDoSortFunction:
1343  * @ctxt:  a XSLT process context
1344  * @sorts:  array of sort nodes
1345  * @nbsorts:  the number of sorts in the array
1346  *
1347  * reorder the current node list accordingly to the set of sorting
1348  * requirement provided by the arry of nodes.
1349  * This is a wrapper function, the actual function used is specified
1350  * using xsltSetCtxtSortFunc() to set the context specific sort function,
1351  * or xsltSetSortFunc() to set the global sort function.
1352  * If a sort function is set on the context, this will get called.
1353  * Otherwise the global sort function is called.
1354  */
1355 void
1356 xsltDoSortFunction(xsltTransformContextPtr ctxt, xmlNodePtr * sorts,
1357                    int nbsorts)
1358 {
1359     if (ctxt-&gt;sortfunc != NULL)
1360     (ctxt-&gt;sortfunc)(ctxt, sorts, nbsorts);
1361     else if (xsltSortFunction != NULL)
1362         xsltSortFunction(ctxt, sorts, nbsorts);
1363 }
1364 
1365 /**
1366  * xsltSetSortFunc:
1367  * @handler:  the new handler function
1368  *
1369  * Function to reset the global handler for XSLT sorting.
1370  * If the handler is NULL, the default sort function will be used.
1371  */
1372 void
1373 xsltSetSortFunc(xsltSortFunc handler) {
1374     if (handler != NULL)
1375     xsltSortFunction = handler;
1376     else
1377     xsltSortFunction = xsltDefaultSortFunction;
1378 }
1379 
1380 /**
1381  * xsltSetCtxtSortFunc:
1382  * @ctxt:  a XSLT process context
1383  * @handler:  the new handler function
1384  *
1385  * Function to set the handler for XSLT sorting
1386  * for the specified context.
1387  * If the handler is NULL, then the global
1388  * sort function will be called
1389  */
1390 void
1391 xsltSetCtxtSortFunc(xsltTransformContextPtr ctxt, xsltSortFunc handler) {
1392     ctxt-&gt;sortfunc = handler;
1393 }
1394 
1395 /************************************************************************
1396  *                                  *
1397  *              Parsing options             *
1398  *                                  *
1399  ************************************************************************/
1400 
1401 /**
1402  * xsltSetCtxtParseOptions:
1403  * @ctxt:  a XSLT process context
1404  * @options:  a combination of libxml2 xmlParserOption
1405  *
1406  * Change the default parser option passed by the XSLT engine to the
1407  * parser when using document() loading.
1408  *
1409  * Returns the previous options or -1 in case of error
1410  */
1411 int
1412 xsltSetCtxtParseOptions(xsltTransformContextPtr ctxt, int options)
1413 {
1414     int oldopts;
1415 
1416     if (ctxt == NULL)
1417         return(-1);
1418     oldopts = ctxt-&gt;parserOptions;
1419     if (ctxt-&gt;xinclude)
1420         oldopts |= XML_PARSE_XINCLUDE;
1421     ctxt-&gt;parserOptions = options;
1422     if (options &amp; XML_PARSE_XINCLUDE)
1423         ctxt-&gt;xinclude = 1;
1424     else
1425         ctxt-&gt;xinclude = 0;
1426     return(oldopts);
1427 }
1428 
1429 /************************************************************************
1430  *                                  *
1431  *              Output                  *
1432  *                                  *
1433  ************************************************************************/
1434 
1435 /**
1436  * xsltSaveResultTo:
1437  * @buf:  an output buffer
1438  * @result:  the result xmlDocPtr
1439  * @style:  the stylesheet
1440  *
1441  * Save the result @result obtained by applying the @style stylesheet
1442  * to an I/O output channel @buf
1443  *
1444  * Returns the number of byte written or -1 in case of failure.
1445  */
1446 int
1447 xsltSaveResultTo(xmlOutputBufferPtr buf, xmlDocPtr result,
1448            xsltStylesheetPtr style) {
1449     const xmlChar *encoding;
1450     int base;
1451     const xmlChar *method;
1452     int indent;
1453 
1454     if ((buf == NULL) || (result == NULL) || (style == NULL))
1455     return(-1);
1456     if ((result-&gt;children == NULL) ||
1457     ((result-&gt;children-&gt;type == XML_DTD_NODE) &amp;&amp;
1458      (result-&gt;children-&gt;next == NULL)))
1459     return(0);
1460 
1461     if ((style-&gt;methodURI != NULL) &amp;&amp;
1462     ((style-&gt;method == NULL) ||
1463      (!xmlStrEqual(style-&gt;method, (const xmlChar *) &quot;xhtml&quot;)))) {
1464         xsltGenericError(xsltGenericErrorContext,
1465         &quot;xsltSaveResultTo : unknown output method\n&quot;);
1466         return(-1);
1467     }
1468 
1469     base = buf-&gt;written;
1470 
1471     XSLT_GET_IMPORT_PTR(method, style, method)
1472     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1473     XSLT_GET_IMPORT_INT(indent, style, indent);
1474 
1475     if ((method == NULL) &amp;&amp; (result-&gt;type == XML_HTML_DOCUMENT_NODE))
1476     method = (const xmlChar *) &quot;html&quot;;
1477 
1478     if ((method != NULL) &amp;&amp;
1479     (xmlStrEqual(method, (const xmlChar *) &quot;html&quot;))) {
1480     if (encoding != NULL) {
1481         htmlSetMetaEncoding(result, (const xmlChar *) encoding);
1482     } else {
1483         htmlSetMetaEncoding(result, (const xmlChar *) &quot;UTF-8&quot;);
1484     }
1485     if (indent == -1)
1486         indent = 1;
1487     htmlDocContentDumpFormatOutput(buf, result, (const char *) encoding,
1488                                indent);
1489     xmlOutputBufferFlush(buf);
1490     } else if ((method != NULL) &amp;&amp;
1491     (xmlStrEqual(method, (const xmlChar *) &quot;xhtml&quot;))) {
1492     if (encoding != NULL) {
1493         htmlSetMetaEncoding(result, (const xmlChar *) encoding);
1494     } else {
1495         htmlSetMetaEncoding(result, (const xmlChar *) &quot;UTF-8&quot;);
1496     }
1497     htmlDocContentDumpOutput(buf, result, (const char *) encoding);
1498     xmlOutputBufferFlush(buf);
1499     } else if ((method != NULL) &amp;&amp;
1500            (xmlStrEqual(method, (const xmlChar *) &quot;text&quot;))) {
1501     xmlNodePtr cur;
1502 
1503     cur = result-&gt;children;
1504     while (cur != NULL) {
1505         if (cur-&gt;type == XML_TEXT_NODE)
1506         xmlOutputBufferWriteString(buf, (const char *) cur-&gt;content);
1507 
1508         /*
1509          * Skip to next node
1510          */
1511         if (cur-&gt;children != NULL) {
1512         if ((cur-&gt;children-&gt;type != XML_ENTITY_DECL) &amp;&amp;
1513             (cur-&gt;children-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
1514             (cur-&gt;children-&gt;type != XML_ENTITY_NODE)) {
1515             cur = cur-&gt;children;
1516             continue;
1517         }
1518         }
1519         if (cur-&gt;next != NULL) {
1520         cur = cur-&gt;next;
1521         continue;
1522         }
1523 
1524         do {
1525         cur = cur-&gt;parent;
1526         if (cur == NULL)
1527             break;
1528         if (cur == (xmlNodePtr) style-&gt;doc) {
1529             cur = NULL;
1530             break;
1531         }
1532         if (cur-&gt;next != NULL) {
1533             cur = cur-&gt;next;
1534             break;
1535         }
1536         } while (cur != NULL);
1537     }
1538     xmlOutputBufferFlush(buf);
1539     } else {
1540     int omitXmlDecl;
1541     int standalone;
1542 
1543     XSLT_GET_IMPORT_INT(omitXmlDecl, style, omitXmlDeclaration);
1544     XSLT_GET_IMPORT_INT(standalone, style, standalone);
1545 
1546     if (omitXmlDecl != 1) {
1547         xmlOutputBufferWriteString(buf, &quot;&lt;?xml version=&quot;);
1548         if (result-&gt;version != NULL) {
1549         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1550         xmlOutputBufferWriteString(buf, (const char *)result-&gt;version);
1551         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1552         } else
1553         xmlOutputBufferWriteString(buf, &quot;\&quot;1.0\&quot;&quot;);
1554         if (encoding == NULL) {
1555         if (result-&gt;encoding != NULL)
1556             encoding = result-&gt;encoding;
1557         else if (result-&gt;charset != XML_CHAR_ENCODING_UTF8)
1558             encoding = (const xmlChar *)
1559                    xmlGetCharEncodingName((xmlCharEncoding)
1560                                           result-&gt;charset);
1561         }
1562         if (encoding != NULL) {
1563         xmlOutputBufferWriteString(buf, &quot; encoding=&quot;);
1564         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1565         xmlOutputBufferWriteString(buf, (const char *) encoding);
1566         xmlOutputBufferWriteString(buf, &quot;\&quot;&quot;);
1567         }
1568         switch (standalone) {
1569         case 0:
1570             xmlOutputBufferWriteString(buf, &quot; standalone=\&quot;no\&quot;&quot;);
1571             break;
1572         case 1:
1573             xmlOutputBufferWriteString(buf, &quot; standalone=\&quot;yes\&quot;&quot;);
1574             break;
1575         default:
1576             break;
1577         }
1578         xmlOutputBufferWriteString(buf, &quot;?&gt;\n&quot;);
1579     }
1580     if (result-&gt;children != NULL) {
1581         xmlNodePtr child = result-&gt;children;
1582 
1583         while (child != NULL) {
1584         xmlNodeDumpOutput(buf, result, child, 0, (indent == 1),
1585                       (const char *) encoding);
1586         if (indent &amp;&amp; ((child-&gt;type == XML_DTD_NODE) ||
1587             ((child-&gt;type == XML_COMMENT_NODE) &amp;&amp;
1588              (child-&gt;next != NULL))))
1589             xmlOutputBufferWriteString(buf, &quot;\n&quot;);
1590         child = child-&gt;next;
1591         }
1592         if (indent)
1593             xmlOutputBufferWriteString(buf, &quot;\n&quot;);
1594     }
1595     xmlOutputBufferFlush(buf);
1596     }
1597     return(buf-&gt;written - base);
1598 }
1599 
1600 /**
1601  * xsltSaveResultToFilename:
1602  * @URL:  a filename or URL
1603  * @result:  the result xmlDocPtr
1604  * @style:  the stylesheet
1605  * @compression:  the compression factor (0 - 9 included)
1606  *
1607  * Save the result @result obtained by applying the @style stylesheet
1608  * to a file or @URL
1609  *
1610  * Returns the number of byte written or -1 in case of failure.
1611  */
1612 int
1613 xsltSaveResultToFilename(const char *URL, xmlDocPtr result,
1614              xsltStylesheetPtr style, int compression) {
1615     xmlOutputBufferPtr buf;
1616     const xmlChar *encoding;
1617     int ret;
1618 
1619     if ((URL == NULL) || (result == NULL) || (style == NULL))
1620     return(-1);
1621     if (result-&gt;children == NULL)
1622     return(0);
1623 
1624     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1625     if (encoding != NULL) {
1626     xmlCharEncodingHandlerPtr encoder;
1627 
1628     encoder = xmlFindCharEncodingHandler((char *)encoding);
1629     if ((encoder != NULL) &amp;&amp;
1630         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1631              (const xmlChar *) &quot;UTF-8&quot;)))
1632         encoder = NULL;
1633     buf = xmlOutputBufferCreateFilename(URL, encoder, compression);
1634     } else {
1635     buf = xmlOutputBufferCreateFilename(URL, NULL, compression);
1636     }
1637     if (buf == NULL)
1638     return(-1);
1639     xsltSaveResultTo(buf, result, style);
1640     ret = xmlOutputBufferClose(buf);
1641     return(ret);
1642 }
1643 
1644 /**
1645  * xsltSaveResultToFile:
1646  * @file:  a FILE * I/O
1647  * @result:  the result xmlDocPtr
1648  * @style:  the stylesheet
1649  *
1650  * Save the result @result obtained by applying the @style stylesheet
1651  * to an open FILE * I/O.
1652  * This does not close the FILE @file
1653  *
1654  * Returns the number of bytes written or -1 in case of failure.
1655  */
1656 int
1657 xsltSaveResultToFile(FILE *file, xmlDocPtr result, xsltStylesheetPtr style) {
1658     xmlOutputBufferPtr buf;
1659     const xmlChar *encoding;
1660     int ret;
1661 
1662     if ((file == NULL) || (result == NULL) || (style == NULL))
1663     return(-1);
1664     if (result-&gt;children == NULL)
1665     return(0);
1666 
1667     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1668     if (encoding != NULL) {
1669     xmlCharEncodingHandlerPtr encoder;
1670 
1671     encoder = xmlFindCharEncodingHandler((char *)encoding);
1672     if ((encoder != NULL) &amp;&amp;
1673         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1674              (const xmlChar *) &quot;UTF-8&quot;)))
1675         encoder = NULL;
1676     buf = xmlOutputBufferCreateFile(file, encoder);
1677     } else {
1678     buf = xmlOutputBufferCreateFile(file, NULL);
1679     }
1680 
1681     if (buf == NULL)
1682     return(-1);
1683     xsltSaveResultTo(buf, result, style);
1684     ret = xmlOutputBufferClose(buf);
1685     return(ret);
1686 }
1687 
1688 /**
1689  * xsltSaveResultToFd:
1690  * @fd:  a file descriptor
1691  * @result:  the result xmlDocPtr
1692  * @style:  the stylesheet
1693  *
1694  * Save the result @result obtained by applying the @style stylesheet
1695  * to an open file descriptor
1696  * This does not close the descriptor.
1697  *
1698  * Returns the number of bytes written or -1 in case of failure.
1699  */
1700 int
1701 xsltSaveResultToFd(int fd, xmlDocPtr result, xsltStylesheetPtr style) {
1702     xmlOutputBufferPtr buf;
1703     const xmlChar *encoding;
1704     int ret;
1705 
1706     if ((fd &lt; 0) || (result == NULL) || (style == NULL))
1707     return(-1);
1708     if (result-&gt;children == NULL)
1709     return(0);
1710 
1711     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1712     if (encoding != NULL) {
1713     xmlCharEncodingHandlerPtr encoder;
1714 
1715     encoder = xmlFindCharEncodingHandler((char *)encoding);
1716     if ((encoder != NULL) &amp;&amp;
1717         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1718              (const xmlChar *) &quot;UTF-8&quot;)))
1719         encoder = NULL;
1720     buf = xmlOutputBufferCreateFd(fd, encoder);
1721     } else {
1722     buf = xmlOutputBufferCreateFd(fd, NULL);
1723     }
1724     if (buf == NULL)
1725     return(-1);
1726     xsltSaveResultTo(buf, result, style);
1727     ret = xmlOutputBufferClose(buf);
1728     return(ret);
1729 }
1730 
1731 /**
1732  * xsltSaveResultToString:
1733  * @doc_txt_ptr:  Memory pointer for allocated XML text
1734  * @doc_txt_len:  Length of the generated XML text
1735  * @result:  the result xmlDocPtr
1736  * @style:  the stylesheet
1737  *
1738  * Save the result @result obtained by applying the @style stylesheet
1739  * to a new allocated string.
1740  *
1741  * Returns 0 in case of success and -1 in case of error
1742  */
1743 int
1744 xsltSaveResultToString(xmlChar **doc_txt_ptr, int * doc_txt_len,
1745                xmlDocPtr result, xsltStylesheetPtr style) {
1746     xmlOutputBufferPtr buf;
1747     const xmlChar *encoding;
1748 
1749     *doc_txt_ptr = NULL;
1750     *doc_txt_len = 0;
1751     if (result-&gt;children == NULL)
1752     return(0);
1753 
1754     XSLT_GET_IMPORT_PTR(encoding, style, encoding)
1755     if (encoding != NULL) {
1756     xmlCharEncodingHandlerPtr encoder;
1757 
1758     encoder = xmlFindCharEncodingHandler((char *)encoding);
1759     if ((encoder != NULL) &amp;&amp;
1760         (xmlStrEqual((const xmlChar *)encoder-&gt;name,
1761              (const xmlChar *) &quot;UTF-8&quot;)))
1762         encoder = NULL;
1763     buf = xmlAllocOutputBuffer(encoder);
1764     } else {
1765     buf = xmlAllocOutputBuffer(NULL);
1766     }
1767     if (buf == NULL)
1768     return(-1);
1769     xsltSaveResultTo(buf, result, style);
1770 #ifdef LIBXML2_NEW_BUFFER
1771     if (buf-&gt;conv != NULL) {
1772     *doc_txt_len = xmlBufUse(buf-&gt;conv);
1773     *doc_txt_ptr = xmlStrndup(xmlBufContent(buf-&gt;conv), *doc_txt_len);
1774     } else {
1775     *doc_txt_len = xmlBufUse(buf-&gt;buffer);
1776     *doc_txt_ptr = xmlStrndup(xmlBufContent(buf-&gt;buffer), *doc_txt_len);
1777     }
1778 #else
1779     if (buf-&gt;conv != NULL) {
1780     *doc_txt_len = buf-&gt;conv-&gt;use;
1781     *doc_txt_ptr = xmlStrndup(buf-&gt;conv-&gt;content, *doc_txt_len);
1782     } else {
1783     *doc_txt_len = buf-&gt;buffer-&gt;use;
1784     *doc_txt_ptr = xmlStrndup(buf-&gt;buffer-&gt;content, *doc_txt_len);
1785     }
1786 #endif
1787     (void)xmlOutputBufferClose(buf);
1788     return 0;
1789 }
1790 
1791 /************************************************************************
1792  *                                  *
1793  *      Generating profiling information            *
1794  *                                  *
1795  ************************************************************************/
1796 
1797 static long calibration = -1;
1798 
1799 /**
1800  * xsltCalibrateTimestamps:
1801  *
1802  * Used for to calibrate the xsltTimestamp() function
1803  * Should work if launched at startup and we don&#39;t loose our quantum :-)
1804  *
1805  * Returns the number of milliseconds used by xsltTimestamp()
1806  */
1807 #if !defined(XSLT_WIN32_PERFORMANCE_COUNTER) &amp;&amp; \
1808     (defined(HAVE_CLOCK_GETTIME) || defined(HAVE_GETTIMEOFDAY))
1809 static long
1810 xsltCalibrateTimestamps(void) {
1811     register int i;
1812 
1813     for (i = 0;i &lt; 999;i++)
1814     xsltTimestamp();
1815     return(xsltTimestamp() / 1000);
1816 }
1817 #endif
1818 
1819 /**
1820  * xsltCalibrateAdjust:
1821  * @delta:  a negative dealy value found
1822  *
1823  * Used for to correct the calibration for xsltTimestamp()
1824  */
1825 void
1826 xsltCalibrateAdjust(long delta) {
1827     calibration += delta;
1828 }
1829 
1830 /**
1831  * xsltTimestamp:
1832  *
1833  * Used for gathering profiling data
1834  *
1835  * Returns the number of tenth of milliseconds since the beginning of the
1836  * profiling
1837  */
1838 long
1839 xsltTimestamp(void)
1840 {
1841 #ifdef XSLT_WIN32_PERFORMANCE_COUNTER
1842     BOOL ok;
1843     LARGE_INTEGER performanceCount;
1844     LARGE_INTEGER performanceFrequency;
1845     LONGLONG quadCount;
1846     double seconds;
1847     static LONGLONG startupQuadCount = 0;
1848     static LONGLONG startupQuadFreq = 0;
1849 
1850     ok = QueryPerformanceCounter(&amp;performanceCount);
1851     if (!ok)
1852         return 0;
1853     quadCount = performanceCount.QuadPart;
1854     if (calibration &lt; 0) {
1855         calibration = 0;
1856         ok = QueryPerformanceFrequency(&amp;performanceFrequency);
1857         if (!ok)
1858             return 0;
1859         startupQuadFreq = performanceFrequency.QuadPart;
1860         startupQuadCount = quadCount;
1861         return (0);
1862     }
1863     if (startupQuadFreq == 0)
1864         return 0;
1865     seconds = (quadCount - startupQuadCount) / (double) startupQuadFreq;
1866     return (long) (seconds * XSLT_TIMESTAMP_TICS_PER_SEC);
1867 
1868 #else /* XSLT_WIN32_PERFORMANCE_COUNTER */
1869 #ifdef HAVE_CLOCK_GETTIME
1870 #  if defined(CLOCK_MONOTONIC)
1871 #    define XSLT_CLOCK CLOCK_MONOTONIC
1872 #  elif defined(CLOCK_HIGHRES)
1873 #    define XSLT_CLOCK CLOCK_HIGHRES
1874 #  else
1875 #    define XSLT_CLOCK CLOCK_REALTIME
1876 #  endif
1877     static struct timespec startup;
1878     struct timespec cur;
1879     long tics;
1880 
1881     if (calibration &lt; 0) {
1882         clock_gettime(XSLT_CLOCK, &amp;startup);
1883         calibration = 0;
1884         calibration = xsltCalibrateTimestamps();
1885         clock_gettime(XSLT_CLOCK, &amp;startup);
1886         return (0);
1887     }
1888 
1889     clock_gettime(XSLT_CLOCK, &amp;cur);
1890     tics = (cur.tv_sec - startup.tv_sec) * XSLT_TIMESTAMP_TICS_PER_SEC;
1891     tics += (cur.tv_nsec - startup.tv_nsec) /
1892                           (1000000000l / XSLT_TIMESTAMP_TICS_PER_SEC);
1893 
1894     tics -= calibration;
1895     return(tics);
1896 
1897 #elif HAVE_GETTIMEOFDAY
1898     static struct timeval startup;
1899     struct timeval cur;
1900     long tics;
1901 
1902     if (calibration &lt; 0) {
1903         gettimeofday(&amp;startup, NULL);
1904         calibration = 0;
1905         calibration = xsltCalibrateTimestamps();
1906         gettimeofday(&amp;startup, NULL);
1907         return (0);
1908     }
1909 
1910     gettimeofday(&amp;cur, NULL);
1911     tics = (cur.tv_sec - startup.tv_sec) * XSLT_TIMESTAMP_TICS_PER_SEC;
1912     tics += (cur.tv_usec - startup.tv_usec) /
1913                           (1000000l / XSLT_TIMESTAMP_TICS_PER_SEC);
1914 
1915     tics -= calibration;
1916     return(tics);
1917 #else
1918 
1919     /* Neither gettimeofday() nor Win32 performance counter available */
1920 
1921     return (0);
1922 
1923 #endif /* HAVE_GETTIMEOFDAY */
1924 #endif /* XSLT_WIN32_PERFORMANCE_COUNTER */
1925 }
1926 
1927 static char *
1928 pretty_templ_match(xsltTemplatePtr templ) {
1929   static char dst[1001];
1930   char *src = (char *)templ-&gt;match;
1931   int i=0,j;
1932 
1933   /* strip white spaces */
1934   for (j=0; i&lt;1000 &amp;&amp; src[j]; i++,j++) {
1935       for(;src[j]==&#39; &#39;;j++);
1936       dst[i]=src[j];
1937   }
1938   if(i&lt;998 &amp;&amp; templ-&gt;mode) {
1939     /* append [mode] */
1940     dst[i++]=&#39;[&#39;;
1941     src=(char *)templ-&gt;mode;
1942     for (j=0; i&lt;999 &amp;&amp; src[j]; i++,j++) {
1943       dst[i]=src[j];
1944     }
1945     dst[i++]=&#39;]&#39;;
1946   }
1947   dst[i]=&#39;\0&#39;;
1948   return dst;
1949 }
1950 
1951 #define MAX_TEMPLATES 10000
1952 
1953 /**
1954  * xsltSaveProfiling:
1955  * @ctxt:  an XSLT context
1956  * @output:  a FILE * for saving the information
1957  *
1958  * Save the profiling information on @output
1959  */
1960 void
1961 xsltSaveProfiling(xsltTransformContextPtr ctxt, FILE *output) {
1962     int nb, i,j,k,l;
1963     int max;
1964     int total;
1965     unsigned long totalt;
1966     xsltTemplatePtr *templates;
1967     xsltStylesheetPtr style;
1968     xsltTemplatePtr templ1,templ2;
1969     int *childt;
1970 
1971     if ((output == NULL) || (ctxt == NULL))
1972     return;
1973     if (ctxt-&gt;profile == 0)
1974     return;
1975 
1976     nb = 0;
1977     max = MAX_TEMPLATES;
1978     templates = xmlMalloc(max * sizeof(xsltTemplatePtr));
1979     if (templates == NULL)
1980     return;
1981 
1982     style = ctxt-&gt;style;
1983     while (style != NULL) {
1984     templ1 = style-&gt;templates;
1985     while (templ1 != NULL) {
1986         if (nb &gt;= max)
1987         break;
1988 
1989         if (templ1-&gt;nbCalls &gt; 0)
1990         templates[nb++] = templ1;
1991         templ1 = templ1-&gt;next;
1992     }
1993 
1994     style = xsltNextImport(style);
1995     }
1996 
1997     for (i = 0;i &lt; nb -1;i++) {
1998     for (j = i + 1; j &lt; nb; j++) {
1999         if ((templates[i]-&gt;time &lt;= templates[j]-&gt;time) ||
2000         ((templates[i]-&gt;time == templates[j]-&gt;time) &amp;&amp;
2001              (templates[i]-&gt;nbCalls &lt;= templates[j]-&gt;nbCalls))) {
2002         templ1 = templates[j];
2003         templates[j] = templates[i];
2004         templates[i] = templ1;
2005         }
2006     }
2007     }
2008 
2009 
2010     /* print flat profile */
2011 
2012     fprintf(output, &quot;%6s%20s%20s%10s  Calls Tot 100us Avg\n\n&quot;,
2013         &quot;number&quot;, &quot;match&quot;, &quot;name&quot;, &quot;mode&quot;);
2014     total = 0;
2015     totalt = 0;
2016     for (i = 0;i &lt; nb;i++) {
2017          templ1 = templates[i];
2018     fprintf(output, &quot;%5d &quot;, i);
2019     if (templ1-&gt;match != NULL) {
2020         if (xmlStrlen(templ1-&gt;match) &gt; 20)
2021         fprintf(output, &quot;%s\n%26s&quot;, templ1-&gt;match, &quot;&quot;);
2022         else
2023         fprintf(output, &quot;%20s&quot;, templ1-&gt;match);
2024     } else {
2025         fprintf(output, &quot;%20s&quot;, &quot;&quot;);
2026     }
2027     if (templ1-&gt;name != NULL) {
2028         if (xmlStrlen(templ1-&gt;name) &gt; 20)
2029         fprintf(output, &quot;%s\n%46s&quot;, templ1-&gt;name, &quot;&quot;);
2030         else
2031         fprintf(output, &quot;%20s&quot;, templ1-&gt;name);
2032     } else {
2033         fprintf(output, &quot;%20s&quot;, &quot;&quot;);
2034     }
2035     if (templ1-&gt;mode != NULL) {
2036         if (xmlStrlen(templ1-&gt;mode) &gt; 10)
2037         fprintf(output, &quot;%s\n%56s&quot;, templ1-&gt;mode, &quot;&quot;);
2038         else
2039         fprintf(output, &quot;%10s&quot;, templ1-&gt;mode);
2040     } else {
2041         fprintf(output, &quot;%10s&quot;, &quot;&quot;);
2042     }
2043     fprintf(output, &quot; %6d&quot;, templ1-&gt;nbCalls);
2044     fprintf(output, &quot; %6ld %6ld\n&quot;, templ1-&gt;time,
2045         templ1-&gt;time / templ1-&gt;nbCalls);
2046     total += templ1-&gt;nbCalls;
2047     totalt += templ1-&gt;time;
2048     }
2049     fprintf(output, &quot;\n%30s%26s %6d %6ld\n&quot;, &quot;Total&quot;, &quot;&quot;, total, totalt);
2050 
2051 
2052     /* print call graph */
2053 
2054     childt = xmlMalloc((nb + 1) * sizeof(int));
2055     if (childt == NULL)
2056     return;
2057 
2058     /* precalculate children times */
2059     for (i = 0; i &lt; nb; i++) {
2060         templ1 = templates[i];
2061 
2062         childt[i] = 0;
2063         for (k = 0; k &lt; nb; k++) {
2064             templ2 = templates[k];
2065             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2066                 if (templ2-&gt;templCalledTab[l] == templ1) {
2067                     childt[i] +=templ2-&gt;time;
2068                 }
2069             }
2070         }
2071     }
2072     childt[i] = 0;
2073 
2074     fprintf(output, &quot;\nindex %% time    self  children    called     name\n&quot;);
2075 
2076     for (i = 0; i &lt; nb; i++) {
2077         char ix_str[20], timep_str[20], times_str[20], timec_str[20], called_str[20];
2078         unsigned long t;
2079 
2080         templ1 = templates[i];
2081         /* callers */
2082         for (j = 0; j &lt; templ1-&gt;templNr; j++) {
2083             templ2 = templ1-&gt;templCalledTab[j];
2084             for (k = 0; k &lt; nb; k++) {
2085               if (templates[k] == templ2)
2086                 break;
2087             }
2088             t=templ2?templ2-&gt;time:totalt;
2089             snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
2090             snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
2091             snprintf(called_str,sizeof(called_str),&quot;%6d/%d&quot;,
2092                 templ1-&gt;templCountTab[j], /* number of times caller calls &#39;this&#39; */
2093                 templ1-&gt;nbCalls);         /* total number of calls to &#39;this&#39; */
2094 
2095             fprintf(output, &quot;             %-8s %-8s %-12s     %s [%d]\n&quot;,
2096                 times_str,timec_str,called_str,
2097                 (templ2?(templ2-&gt;name?(char *)templ2-&gt;name:pretty_templ_match(templ2)):&quot;-&quot;),k);
2098         }
2099         /* this */
2100         snprintf(ix_str,sizeof(ix_str),&quot;[%d]&quot;,i);
2101         snprintf(timep_str,sizeof(timep_str),&quot;%6.2f&quot;,(float)templ1-&gt;time*100.0/totalt);
2102         snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)templ1-&gt;time/XSLT_TIMESTAMP_TICS_PER_SEC);
2103         snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[i]/XSLT_TIMESTAMP_TICS_PER_SEC);
2104         fprintf(output, &quot;%-5s %-6s %-8s %-8s %6d     %s [%d]\n&quot;,
2105             ix_str, timep_str,times_str,timec_str,
2106             templ1-&gt;nbCalls,
2107             templ1-&gt;name?(char *)templ1-&gt;name:pretty_templ_match(templ1),i);
2108         /* callees
2109          * - go over templates[0..nb] and their templCalledTab[]
2110          * - print those where we in the the call-stack
2111          */
2112         total = 0;
2113         for (k = 0; k &lt; nb; k++) {
2114             templ2 = templates[k];
2115             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2116                 if (templ2-&gt;templCalledTab[l] == templ1) {
2117                     total+=templ2-&gt;templCountTab[l];
2118                 }
2119             }
2120         }
2121         for (k = 0; k &lt; nb; k++) {
2122             templ2 = templates[k];
2123             for (l = 0; l &lt; templ2-&gt;templNr; l++) {
2124                 if (templ2-&gt;templCalledTab[l] == templ1) {
2125                     snprintf(times_str,sizeof(times_str),&quot;%8.3f&quot;,(float)templ2-&gt;time/XSLT_TIMESTAMP_TICS_PER_SEC);
2126                     snprintf(timec_str,sizeof(timec_str),&quot;%8.3f&quot;,(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
2127                     snprintf(called_str,sizeof(called_str),&quot;%6d/%d&quot;,
2128                         templ2-&gt;templCountTab[l], /* number of times &#39;this&#39; calls callee */
2129                         total);                   /* total number of calls from &#39;this&#39; */
2130                     fprintf(output, &quot;             %-8s %-8s %-12s     %s [%d]\n&quot;,
2131                         times_str,timec_str,called_str,
2132                         templ2-&gt;name?(char *)templ2-&gt;name:pretty_templ_match(templ2),k);
2133                 }
2134             }
2135         }
2136         fprintf(output, &quot;-----------------------------------------------\n&quot;);
2137     }
2138 
2139     fprintf(output, &quot;\f\nIndex by function name\n&quot;);
2140     for (i = 0; i &lt; nb; i++) {
2141         templ1 = templates[i];
2142         fprintf(output, &quot;[%d] %s (%s:%d)\n&quot;,
2143             i, templ1-&gt;name?(char *)templ1-&gt;name:pretty_templ_match(templ1),
2144             templ1-&gt;style-&gt;doc-&gt;URL,templ1-&gt;elem-&gt;line);
2145     }
2146 
2147     fprintf(output, &quot;\f\n&quot;);
2148     xmlFree(childt);
2149 
2150     xmlFree(templates);
2151 }
2152 
2153 /************************************************************************
2154  *                                  *
2155  *      Fetching profiling information              *
2156  *                                  *
2157  ************************************************************************/
2158 
2159 /**
2160  * xsltGetProfileInformation:
2161  * @ctxt:  a transformation context
2162  *
2163  * This function should be called after the transformation completed
2164  * to extract template processing profiling information if available.
2165  * The information is returned as an XML document tree like
2166  * &lt;?xml version=&quot;1.0&quot;?&gt;
2167  * &lt;profile&gt;
2168  * &lt;template rank=&quot;1&quot; match=&quot;*&quot; name=&quot;&quot;
2169  *         mode=&quot;&quot; calls=&quot;6&quot; time=&quot;48&quot; average=&quot;8&quot;/&gt;
2170  * &lt;template rank=&quot;2&quot; match=&quot;item2|item3&quot; name=&quot;&quot;
2171  *         mode=&quot;&quot; calls=&quot;10&quot; time=&quot;30&quot; average=&quot;3&quot;/&gt;
2172  * &lt;template rank=&quot;3&quot; match=&quot;item1&quot; name=&quot;&quot;
2173  *         mode=&quot;&quot; calls=&quot;5&quot; time=&quot;17&quot; average=&quot;3&quot;/&gt;
2174  * &lt;/profile&gt;
2175  * The caller will need to free up the returned tree with xmlFreeDoc()
2176  *
2177  * Returns the xmlDocPtr corresponding to the result or NULL if not available.
2178  */
2179 
2180 xmlDocPtr
2181 xsltGetProfileInformation(xsltTransformContextPtr ctxt)
2182 {
2183     xmlDocPtr ret = NULL;
2184     xmlNodePtr root, child;
2185     char buf[100];
2186 
2187     xsltStylesheetPtr style;
2188     xsltTemplatePtr *templates;
2189     xsltTemplatePtr templ;
2190     int nb = 0, max = 0, i, j;
2191 
2192     if (!ctxt)
2193         return NULL;
2194 
2195     if (!ctxt-&gt;profile)
2196         return NULL;
2197 
2198     nb = 0;
2199     max = 10000;
2200     templates =
2201         (xsltTemplatePtr *) xmlMalloc(max * sizeof(xsltTemplatePtr));
2202     if (templates == NULL)
2203         return NULL;
2204 
2205     /*
2206      * collect all the templates in an array
2207      */
2208     style = ctxt-&gt;style;
2209     while (style != NULL) {
2210         templ = style-&gt;templates;
2211         while (templ != NULL) {
2212             if (nb &gt;= max)
2213                 break;
2214 
2215             if (templ-&gt;nbCalls &gt; 0)
2216                 templates[nb++] = templ;
2217             templ = templ-&gt;next;
2218         }
2219 
2220         style = (xsltStylesheetPtr) xsltNextImport(style);
2221     }
2222 
2223     /*
2224      * Sort the array by time spent
2225      */
2226     for (i = 0; i &lt; nb - 1; i++) {
2227         for (j = i + 1; j &lt; nb; j++) {
2228             if ((templates[i]-&gt;time &lt;= templates[j]-&gt;time) ||
2229                 ((templates[i]-&gt;time == templates[j]-&gt;time) &amp;&amp;
2230                  (templates[i]-&gt;nbCalls &lt;= templates[j]-&gt;nbCalls))) {
2231                 templ = templates[j];
2232                 templates[j] = templates[i];
2233                 templates[i] = templ;
2234             }
2235         }
2236     }
2237 
2238     /*
2239      * Generate a document corresponding to the results.
2240      */
2241     ret = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
2242     root = xmlNewDocNode(ret, NULL, BAD_CAST &quot;profile&quot;, NULL);
2243     xmlDocSetRootElement(ret, root);
2244 
2245     for (i = 0; i &lt; nb; i++) {
2246         child = xmlNewChild(root, NULL, BAD_CAST &quot;template&quot;, NULL);
2247         snprintf(buf, sizeof(buf), &quot;%d&quot;, i + 1);
2248         xmlSetProp(child, BAD_CAST &quot;rank&quot;, BAD_CAST buf);
2249         xmlSetProp(child, BAD_CAST &quot;match&quot;, BAD_CAST templates[i]-&gt;match);
2250         xmlSetProp(child, BAD_CAST &quot;name&quot;, BAD_CAST templates[i]-&gt;name);
2251         xmlSetProp(child, BAD_CAST &quot;mode&quot;, BAD_CAST templates[i]-&gt;mode);
2252 
2253         snprintf(buf, sizeof(buf), &quot;%d&quot;, templates[i]-&gt;nbCalls);
2254         xmlSetProp(child, BAD_CAST &quot;calls&quot;, BAD_CAST buf);
2255 
2256         snprintf(buf, sizeof(buf), &quot;%ld&quot;, templates[i]-&gt;time);
2257         xmlSetProp(child, BAD_CAST &quot;time&quot;, BAD_CAST buf);
2258 
2259         snprintf(buf, sizeof(buf), &quot;%ld&quot;, templates[i]-&gt;time / templates[i]-&gt;nbCalls);
2260         xmlSetProp(child, BAD_CAST &quot;average&quot;, BAD_CAST buf);
2261     };
2262 
2263     xmlFree(templates);
2264 
2265     return ret;
2266 }
2267 
2268 /************************************************************************
2269  *                                  *
2270  *      Hooks for libxml2 XPath                 *
2271  *                                  *
2272  ************************************************************************/
2273 
2274 /**
2275  * xsltXPathCompileFlags:
2276  * @style: the stylesheet
2277  * @str:  the XPath expression
2278  * @flags: extra compilation flags to pass down to libxml2 XPath
2279  *
2280  * Compile an XPath expression
2281  *
2282  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
2283  *         the caller has to free the object.
2284  */
2285 xmlXPathCompExprPtr
2286 xsltXPathCompileFlags(xsltStylesheetPtr style, const xmlChar *str, int flags) {
2287     xmlXPathContextPtr xpathCtxt;
2288     xmlXPathCompExprPtr ret;
2289 
2290     if (style != NULL) {
2291 #ifdef XSLT_REFACTORED_XPATHCOMP
2292     if (XSLT_CCTXT(style)) {
2293         /*
2294         * Proposed by Jerome Pesenti
2295         * --------------------------
2296         * For better efficiency we&#39;ll reuse the compilation
2297         * context&#39;s XPath context. For the common stylesheet using
2298         * XPath expressions this will reduce compilation time to
2299         * about 50%.
2300         *
2301         * See http://mail.gnome.org/archives/xslt/2006-April/msg00037.html
2302         */
2303         xpathCtxt = XSLT_CCTXT(style)-&gt;xpathCtxt;
2304         xpathCtxt-&gt;doc = style-&gt;doc;
2305     } else
2306         xpathCtxt = xmlXPathNewContext(style-&gt;doc);
2307 #else
2308     xpathCtxt = xmlXPathNewContext(style-&gt;doc);
2309 #endif
2310     if (xpathCtxt == NULL)
2311         return NULL;
2312     xpathCtxt-&gt;dict = style-&gt;dict;
2313     } else {
2314     xpathCtxt = xmlXPathNewContext(NULL);
2315     if (xpathCtxt == NULL)
2316         return NULL;
2317     }
2318     xpathCtxt-&gt;flags = flags;
2319 
2320     /*
2321     * Compile the expression.
2322     */
2323     ret = xmlXPathCtxtCompile(xpathCtxt, str);
2324 
2325 #ifdef XSLT_REFACTORED_XPATHCOMP
2326     if ((style == NULL) || (! XSLT_CCTXT(style))) {
2327     xmlXPathFreeContext(xpathCtxt);
2328     }
2329 #else
2330     xmlXPathFreeContext(xpathCtxt);
2331 #endif
2332     /*
2333      * TODO: there is a lot of optimizations which should be possible
2334      *       like variable slot precomputations, function precomputations, etc.
2335      */
2336 
2337     return(ret);
2338 }
2339 
2340 /**
2341  * xsltXPathCompile:
2342  * @style: the stylesheet
2343  * @str:  the XPath expression
2344  *
2345  * Compile an XPath expression
2346  *
2347  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
2348  *         the caller has to free the object.
2349  */
2350 xmlXPathCompExprPtr
2351 xsltXPathCompile(xsltStylesheetPtr style, const xmlChar *str) {
2352     return(xsltXPathCompileFlags(style, str, 0));
2353 }
2354 
2355 /************************************************************************
2356  *                                  *
2357  *      Hooks for the debugger                  *
2358  *                                  *
2359  ************************************************************************/
2360 
2361 /*
2362  * There is currently only 3 debugging callback defined
2363  * Debugger callbacks are disabled by default
2364  */
2365 #define XSLT_CALLBACK_NUMBER 3
2366 
2367 typedef struct _xsltDebuggerCallbacks xsltDebuggerCallbacks;
2368 typedef xsltDebuggerCallbacks *xsltDebuggerCallbacksPtr;
2369 struct _xsltDebuggerCallbacks {
2370     xsltHandleDebuggerCallback handler;
2371     xsltAddCallCallback add;
2372     xsltDropCallCallback drop;
2373 };
2374 
2375 static xsltDebuggerCallbacks xsltDebuggerCurrentCallbacks = {
2376     NULL, /* handler */
2377     NULL, /* add */
2378     NULL  /* drop */
2379 };
2380 
2381 int xslDebugStatus;
2382 
2383 /**
2384  * xsltSetDebuggerStatus:
2385  * @value : the value to be set
2386  *
2387  * This function sets the value of xslDebugStatus.
2388  */
2389 void
2390 xsltSetDebuggerStatus(int value)
2391 {
2392     xslDebugStatus = value;
2393 }
2394 
2395 /**
2396  * xsltGetDebuggerStatus:
2397  *
2398  * Get xslDebugStatus.
2399  *
2400  * Returns the value of xslDebugStatus.
2401  */
2402 int
2403 xsltGetDebuggerStatus(void)
2404 {
2405     return(xslDebugStatus);
2406 }
2407 
2408 /**
2409  * xsltSetDebuggerCallbacks:
2410  * @no : number of callbacks
2411  * @block : the block of callbacks
2412  *
2413  * This function allow to plug a debugger into the XSLT library
2414  * @block points to a block of memory containing the address of @no
2415  * callback routines.
2416  *
2417  * Returns 0 in case of success and -1 in case of error
2418  */
2419 int
2420 xsltSetDebuggerCallbacks(int no, void *block)
2421 {
2422     xsltDebuggerCallbacksPtr callbacks;
2423 
2424     if ((block == NULL) || (no != XSLT_CALLBACK_NUMBER))
2425     return(-1);
2426 
2427     callbacks = (xsltDebuggerCallbacksPtr) block;
2428     xsltDebuggerCurrentCallbacks.handler = callbacks-&gt;handler;
2429     xsltDebuggerCurrentCallbacks.add  = callbacks-&gt;add;
2430     xsltDebuggerCurrentCallbacks.drop  = callbacks-&gt;drop;
2431     return(0);
2432 }
2433 
2434 /**
2435  * xslHandleDebugger:
2436  * @cur : source node being executed
2437  * @node : data node being processed
2438  * @templ : temlate that applies to node
2439  * @ctxt : the xslt transform context
2440  *
2441  * If either cur or node are a breakpoint, or xslDebugStatus in state
2442  *   where debugging must occcur at this time then transfer control
2443  *   to the xslDebugBreak function
2444  */
2445 void
2446 xslHandleDebugger(xmlNodePtr cur, xmlNodePtr node, xsltTemplatePtr templ,
2447               xsltTransformContextPtr ctxt)
2448 {
2449     if (xsltDebuggerCurrentCallbacks.handler != NULL)
2450     xsltDebuggerCurrentCallbacks.handler(cur, node, templ, ctxt);
2451 }
2452 
2453 /**
2454  * xslAddCall:
2455  * @templ : current template being applied
2456  * @source : the source node being processed
2457  *
2458  * Add template &quot;call&quot; to call stack
2459  * Returns : 1 on sucess 0 otherwise an error may be printed if
2460  *            WITH_XSLT_DEBUG_BREAKPOINTS is defined
2461  */
2462 int
2463 xslAddCall(xsltTemplatePtr templ, xmlNodePtr source)
2464 {
2465     if (xsltDebuggerCurrentCallbacks.add != NULL)
2466     return(xsltDebuggerCurrentCallbacks.add(templ, source));
2467     return(0);
2468 }
2469 
2470 /**
2471  * xslDropCall:
2472  *
2473  * Drop the topmost item off the call stack
2474  */
2475 void
2476 xslDropCall(void)
2477 {
2478     if (xsltDebuggerCurrentCallbacks.drop != NULL)
2479     xsltDebuggerCurrentCallbacks.drop();
2480 }
2481 
    </pre>
  </body>
</html>