<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/attrvt.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * attrvt.c: Implementation of the XSL Transformation 1.0 engine
  3  *           attribute value template handling part.
  4  *
  5  * References:
  6  *   http://www.w3.org/TR/1999/REC-xslt-19991116
  7  *
  8  *   Michael Kay &quot;XSLT Programmer&#39;s Reference&quot; pp 637-643
  9  *   Writing Multiple Output Files
 10  *
 11  * See Copyright for the status of this software.
 12  *
 13  * daniel@veillard.com
 14  */
 15 
 16 #define IN_LIBXSLT
 17 #include &quot;libxslt.h&quot;
 18 
 19 #include &lt;string.h&gt;
 20 
 21 #include &lt;libxml/xmlmemory.h&gt;
 22 #include &lt;libxml/tree.h&gt;
 23 #include &lt;libxml/xpath.h&gt;
 24 #include &lt;libxml/xpathInternals.h&gt;
 25 #include &quot;xslt.h&quot;
 26 #include &quot;xsltutils.h&quot;
 27 #include &quot;xsltInternals.h&quot;
 28 #include &quot;templates.h&quot;
 29 
 30 #ifdef WITH_XSLT_DEBUG
 31 #define WITH_XSLT_DEBUG_AVT
 32 #endif
 33 
 34 #define MAX_AVT_SEG 10
 35 
 36 typedef struct _xsltAttrVT xsltAttrVT;
 37 typedef xsltAttrVT *xsltAttrVTPtr;
 38 struct _xsltAttrVT {
 39     struct _xsltAttrVT *next; /* next xsltAttrVT */
 40     int nb_seg;     /* Number of segments */
 41     int max_seg;    /* max capacity before re-alloc needed */
 42     int strstart;   /* is the start a string */
 43     /*
 44      * the namespaces in scope
 45      */
 46     xmlNsPtr *nsList;
 47     int nsNr;
 48     /*
 49      * the content is an alternate of string and xmlXPathCompExprPtr
 50      */
<a name="1" id="anc1"></a><span class="line-modified"> 51 #if __STDC_VERSION__ &gt;= 199901L</span>
<span class="line-added"> 52     /* Using a C99 flexible array member avoids false positives under UBSan */</span>
<span class="line-added"> 53     void *segments[];</span>
<span class="line-added"> 54 #else</span>
<span class="line-added"> 55     void *segments[1];</span>
<span class="line-added"> 56 #endif</span>
 57 };
 58 
 59 /**
 60  * xsltNewAttrVT:
 61  * @style:  a XSLT process context
 62  *
 63  * Build a new xsltAttrVT structure
 64  *
 65  * Returns the structure or NULL in case of error
 66  */
 67 static xsltAttrVTPtr
 68 xsltNewAttrVT(xsltStylesheetPtr style) {
 69     xsltAttrVTPtr cur;
<a name="2" id="anc2"></a><span class="line-added"> 70     size_t size = sizeof(xsltAttrVT) + MAX_AVT_SEG * sizeof(void*);</span>
 71 
<a name="3" id="anc3"></a><span class="line-modified"> 72     cur = (xsltAttrVTPtr) xmlMalloc(size);</span>
 73     if (cur == NULL) {
 74     xsltTransformError(NULL, style, NULL,
 75         &quot;xsltNewAttrVTPtr : malloc failed\n&quot;);
 76     if (style != NULL) style-&gt;errors++;
 77     return(NULL);
 78     }
<a name="4" id="anc4"></a><span class="line-modified"> 79     memset(cur, 0, size);</span>
 80 
 81     cur-&gt;nb_seg = 0;
 82     cur-&gt;max_seg = MAX_AVT_SEG;
 83     cur-&gt;strstart = 0;
 84     cur-&gt;next = style-&gt;attVTs;
 85     /*
 86      * Note: this pointer may be changed by a re-alloc within xsltCompileAttr,
 87      * so that code may change the stylesheet pointer also!
 88      */
 89     style-&gt;attVTs = (xsltAttrVTPtr) cur;
 90 
 91     return(cur);
 92 }
 93 
 94 /**
 95  * xsltFreeAttrVT:
 96  * @avt: pointer to an xsltAttrVT structure
 97  *
 98  * Free up the memory associated to the attribute value template
 99  */
100 static void
101 xsltFreeAttrVT(xsltAttrVTPtr avt) {
102     int i;
103 
104     if (avt == NULL) return;
105 
106     if (avt-&gt;strstart == 1) {
107     for (i = 0;i &lt; avt-&gt;nb_seg; i += 2)
108         if (avt-&gt;segments[i] != NULL)
109         xmlFree((xmlChar *) avt-&gt;segments[i]);
110     for (i = 1;i &lt; avt-&gt;nb_seg; i += 2)
111         xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt-&gt;segments[i]);
112     } else {
113     for (i = 0;i &lt; avt-&gt;nb_seg; i += 2)
114         xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt-&gt;segments[i]);
115     for (i = 1;i &lt; avt-&gt;nb_seg; i += 2)
116         if (avt-&gt;segments[i] != NULL)
117         xmlFree((xmlChar *) avt-&gt;segments[i]);
118     }
119     if (avt-&gt;nsList != NULL)
120         xmlFree(avt-&gt;nsList);
121     xmlFree(avt);
122 }
123 
124 /**
125  * xsltFreeAVTList:
126  * @avt: pointer to an list of AVT structures
127  *
128  * Free up the memory associated to the attribute value templates
129  */
130 void
131 xsltFreeAVTList(void *avt) {
132     xsltAttrVTPtr cur = (xsltAttrVTPtr) avt, next;
133 
134     while (cur != NULL) {
135         next = cur-&gt;next;
136     xsltFreeAttrVT(cur);
137     cur = next;
138     }
139 }
140 /**
141  * xsltSetAttrVTsegment:
142  * @ avt: pointer to an xsltAttrVT structure
143  * @ val: the value to be set to the next available segment
144  *
145  * Within xsltCompileAttr there are several places where a value
146  * needs to be added to the &#39;segments&#39; array within the xsltAttrVT
147  * structure, and at each place the allocated size may have to be
148  * re-allocated.  This routine takes care of that situation.
149  *
150  * Returns the avt pointer, which may have been changed by a re-alloc
151  */
152 static xsltAttrVTPtr
153 xsltSetAttrVTsegment(xsltAttrVTPtr avt, void *val) {
154     if (avt-&gt;nb_seg &gt;= avt-&gt;max_seg) {
<a name="5" id="anc5"></a><span class="line-modified">155         size_t size = sizeof(xsltAttrVT) +</span>
<span class="line-modified">156                       (avt-&gt;max_seg + MAX_AVT_SEG) * sizeof(void *);</span>
<span class="line-modified">157     xsltAttrVTPtr tmp = (xsltAttrVTPtr) xmlRealloc(avt, size);</span>
<span class="line-added">158     if (tmp == NULL) {</span>
<span class="line-added">159             xsltFreeAttrVT(avt);</span>
160         return NULL;
161     }
<a name="6" id="anc6"></a><span class="line-added">162         avt = tmp;</span>
163     memset(&amp;avt-&gt;segments[avt-&gt;nb_seg], 0, MAX_AVT_SEG*sizeof(void *));
164     avt-&gt;max_seg += MAX_AVT_SEG;
165     }
166     avt-&gt;segments[avt-&gt;nb_seg++] = val;
167     return avt;
168 }
169 
170 /**
171  * xsltCompileAttr:
172  * @style:  a XSLT process context
173  * @attr: the attribute coming from the stylesheet.
174  *
175  * Precompile an attribute in a stylesheet, basically it checks if it is
<a name="7" id="anc7"></a><span class="line-modified">176  * an attribute value template, and if yes, establish some structures needed</span>
177  * to process it at transformation time.
178  */
179 void
180 xsltCompileAttr(xsltStylesheetPtr style, xmlAttrPtr attr) {
181     const xmlChar *str;
182     const xmlChar *cur;
183     xmlChar *ret = NULL;
184     xmlChar *expr = NULL;
185     xsltAttrVTPtr avt;
186     int i = 0, lastavt = 0;
187 
188     if ((style == NULL) || (attr == NULL) || (attr-&gt;children == NULL))
189         return;
190     if ((attr-&gt;children-&gt;type != XML_TEXT_NODE) ||
191         (attr-&gt;children-&gt;next != NULL)) {
192         xsltTransformError(NULL, style, attr-&gt;parent,
193         &quot;Attribute &#39;%s&#39;: The content is expected to be a single text &quot;
194         &quot;node when compiling an AVT.\n&quot;, attr-&gt;name);
195     style-&gt;errors++;
196     return;
197     }
198     str = attr-&gt;children-&gt;content;
199     if ((xmlStrchr(str, &#39;{&#39;) == NULL) &amp;&amp;
200         (xmlStrchr(str, &#39;}&#39;) == NULL)) return;
201 
202 #ifdef WITH_XSLT_DEBUG_AVT
203     xsltGenericDebug(xsltGenericDebugContext,
204             &quot;Found AVT %s: %s\n&quot;, attr-&gt;name, str);
205 #endif
206     if (attr-&gt;psvi != NULL) {
207 #ifdef WITH_XSLT_DEBUG_AVT
208     xsltGenericDebug(xsltGenericDebugContext,
209             &quot;AVT %s: already compiled\n&quot;, attr-&gt;name);
210 #endif
211         return;
212     }
213     /*
214     * Create a new AVT object.
215     */
216     avt = xsltNewAttrVT(style);
217     if (avt == NULL)
218     return;
219     attr-&gt;psvi = avt;
220 
221     avt-&gt;nsList = xmlGetNsList(attr-&gt;doc, attr-&gt;parent);
222     if (avt-&gt;nsList != NULL) {
223     while (avt-&gt;nsList[i] != NULL)
224         i++;
225     }
226     avt-&gt;nsNr = i;
227 
228     cur = str;
229     while (*cur != 0) {
230     if (*cur == &#39;{&#39;) {
231         if (*(cur+1) == &#39;{&#39;) {  /* escaped &#39;{&#39; */
232             cur++;
233         ret = xmlStrncat(ret, str, cur - str);
234         cur++;
235         str = cur;
236         continue;
237         }
238         if (*(cur+1) == &#39;}&#39;) {  /* skip empty AVT */
239         ret = xmlStrncat(ret, str, cur - str);
240             cur += 2;
241         str = cur;
242         continue;
243         }
244         if ((ret != NULL) || (cur - str &gt; 0)) {
245         ret = xmlStrncat(ret, str, cur - str);
246         str = cur;
247         if (avt-&gt;nb_seg == 0)
248             avt-&gt;strstart = 1;
249         if ((avt = xsltSetAttrVTsegment(avt, (void *) ret)) == NULL)
250             goto error;
251         ret = NULL;
252         lastavt = 0;
253         }
254 
255         cur++;
256         while ((*cur != 0) &amp;&amp; (*cur != &#39;}&#39;)) {
257         /* Need to check for literal (bug539741) */
258         if ((*cur == &#39;\&#39;&#39;) || (*cur == &#39;&quot;&#39;)) {
259             char delim = *(cur++);
260             while ((*cur != 0) &amp;&amp; (*cur != delim))
261             cur++;
262             if (*cur != 0)
263             cur++;  /* skip the ending delimiter */
264         } else
265             cur++;
266         }
267         if (*cur == 0) {
268             xsltTransformError(NULL, style, attr-&gt;parent,
269              &quot;Attribute &#39;%s&#39;: The AVT has an unmatched &#39;{&#39;.\n&quot;,
270              attr-&gt;name);
271         style-&gt;errors++;
272         goto error;
273         }
274         str++;
275         expr = xmlStrndup(str, cur - str);
276         if (expr == NULL) {
277         /*
278         * TODO: What needs to be done here?
279         */
280             XSLT_TODO
281         goto error;
282         } else {
283         xmlXPathCompExprPtr comp;
284 
285         comp = xsltXPathCompile(style, expr);
286         if (comp == NULL) {
287             xsltTransformError(NULL, style, attr-&gt;parent,
288              &quot;Attribute &#39;%s&#39;: Failed to compile the expression &quot;
289              &quot;&#39;%s&#39; in the AVT.\n&quot;, attr-&gt;name, expr);
290             style-&gt;errors++;
291             goto error;
292         }
293         if (avt-&gt;nb_seg == 0)
294             avt-&gt;strstart = 0;
295         if (lastavt == 1) {
296             if ((avt = xsltSetAttrVTsegment(avt, NULL)) == NULL)
297                 goto error;
298         }
299         if ((avt = xsltSetAttrVTsegment(avt, (void *) comp)) == NULL)
300             goto error;
301         lastavt = 1;
302         xmlFree(expr);
303         expr = NULL;
304         }
305         cur++;
306         str = cur;
307     } else if (*cur == &#39;}&#39;) {
308         cur++;
309         if (*cur == &#39;}&#39;) {  /* escaped &#39;}&#39; */
310         ret = xmlStrncat(ret, str, cur - str);
311         cur++;
312         str = cur;
313         continue;
314         } else {
315             xsltTransformError(NULL, style, attr-&gt;parent,
316              &quot;Attribute &#39;%s&#39;: The AVT has an unmatched &#39;}&#39;.\n&quot;,
317              attr-&gt;name);
318         goto error;
319         }
320     } else
321         cur++;
322     }
323     if ((ret != NULL) || (cur - str &gt; 0)) {
324     ret = xmlStrncat(ret, str, cur - str);
325     str = cur;
326     if (avt-&gt;nb_seg == 0)
327         avt-&gt;strstart = 1;
328     if ((avt = xsltSetAttrVTsegment(avt, (void *) ret)) == NULL)
329         goto error;
330     ret = NULL;
331     }
332 
333 error:
334     if (avt == NULL) {
335         xsltTransformError(NULL, style, attr-&gt;parent,
336         &quot;xsltCompileAttr: malloc problem\n&quot;);
337     } else {
338         if (attr-&gt;psvi != avt) {  /* may have changed from realloc */
339             attr-&gt;psvi = avt;
340         /*
341          * This is a &quot;hack&quot;, but I can&#39;t see any clean method of
342          * doing it.  If a re-alloc has taken place, then the pointer
343          * for this AVT may have changed.  style-&gt;attVTs was set by
344          * xsltNewAttrVT, so it needs to be re-set to the new value!
345          */
346         style-&gt;attVTs = avt;
347     }
348     }
349     if (ret != NULL)
350     xmlFree(ret);
351     if (expr != NULL)
352     xmlFree(expr);
353 }
354 
355 
356 /**
357  * xsltEvalAVT:
358  * @ctxt: the XSLT transformation context
359  * @avt: the prevompiled attribute value template info
360  * @node: the node hosting the attribute
361  *
362  * Process the given AVT, and return the new string value.
363  *
364  * Returns the computed string value or NULL, must be deallocated by the
365  *         caller.
366  */
367 xmlChar *
368 xsltEvalAVT(xsltTransformContextPtr ctxt, void *avt, xmlNodePtr node) {
369     xmlChar *ret = NULL, *tmp;
370     xmlXPathCompExprPtr comp;
371     xsltAttrVTPtr cur = (xsltAttrVTPtr) avt;
372     int i;
373     int str;
374 
375     if ((ctxt == NULL) || (avt == NULL) || (node == NULL))
376         return(NULL);
377     str = cur-&gt;strstart;
378     for (i = 0;i &lt; cur-&gt;nb_seg;i++) {
379         if (str) {
380         ret = xmlStrcat(ret, (const xmlChar *) cur-&gt;segments[i]);
381     } else {
382         comp = (xmlXPathCompExprPtr) cur-&gt;segments[i];
383         tmp = xsltEvalXPathStringNs(ctxt, comp, cur-&gt;nsNr, cur-&gt;nsList);
384         if (tmp != NULL) {
385             if (ret != NULL) {
386             ret = xmlStrcat(ret, tmp);
387             xmlFree(tmp);
388         } else {
389             ret = tmp;
390         }
391         }
392     }
393     str = !str;
394     }
395     return(ret);
396 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>