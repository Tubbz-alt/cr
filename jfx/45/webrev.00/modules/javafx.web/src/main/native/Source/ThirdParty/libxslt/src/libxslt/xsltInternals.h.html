<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xsltInternals.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Summary: internal data structures, constants and functions
   3  * Description: Internal data structures, constants and functions used
   4  *              by the XSLT engine.
   5  *              They are not part of the API or ABI, i.e. they can change
   6  *              without prior notice, use carefully.
   7  *
   8  * Copy: See Copyright for the status of this software.
   9  *
  10  * Author: Daniel Veillard
  11  */
  12 
  13 #ifndef __XML_XSLT_INTERNALS_H__
  14 #define __XML_XSLT_INTERNALS_H__
  15 
  16 #include &lt;libxml/tree.h&gt;
  17 #include &lt;libxml/hash.h&gt;
  18 #include &lt;libxml/xpath.h&gt;
  19 #include &lt;libxml/xmlerror.h&gt;
  20 #include &lt;libxml/dict.h&gt;
  21 #include &lt;libxml/xmlstring.h&gt;
  22 #include &lt;libxslt/xslt.h&gt;
  23 #include &quot;xsltexports.h&quot;
  24 #include &quot;xsltlocale.h&quot;
  25 #include &quot;numbersInternals.h&quot;
  26 
  27 #ifdef __cplusplus
  28 extern &quot;C&quot; {
  29 #endif
  30 
  31 /* #define XSLT_DEBUG_PROFILE_CACHE */
  32 
  33 /**
  34  * XSLT_IS_TEXT_NODE:
  35  *
  36  * check if the argument is a text node
  37  */
  38 #define XSLT_IS_TEXT_NODE(n) ((n != NULL) &amp;&amp; \
  39     (((n)-&gt;type == XML_TEXT_NODE) || \
  40      ((n)-&gt;type == XML_CDATA_SECTION_NODE)))
  41 
  42 
  43 /**
  44  * XSLT_MARK_RES_TREE_FRAG:
  45  *
  46  * internal macro to set up tree fragments
  47  */
  48 #define XSLT_MARK_RES_TREE_FRAG(n) \
  49     (n)-&gt;name = (char *) xmlStrdup(BAD_CAST &quot; fake node libxslt&quot;);
  50 
  51 /**
  52  * XSLT_IS_RES_TREE_FRAG:
  53  *
  54  * internal macro to test tree fragments
  55  */
  56 #define XSLT_IS_RES_TREE_FRAG(n) \
  57     ((n != NULL) &amp;&amp; ((n)-&gt;type == XML_DOCUMENT_NODE) &amp;&amp; \
  58      ((n)-&gt;name != NULL) &amp;&amp; ((n)-&gt;name[0] == &#39; &#39;))
  59 
  60 /**
  61  * XSLT_REFACTORED_KEYCOMP:
  62  *
  63  * Internal define to enable on-demand xsl:key computation.
  64  * That&#39;s the only mode now but the define is kept for compatibility
  65  */
  66 #define XSLT_REFACTORED_KEYCOMP
  67 
  68 /**
  69  * XSLT_FAST_IF:
  70  *
  71  * Internal define to enable usage of xmlXPathCompiledEvalToBoolean()
  72  * for XSLT &quot;tests&quot;; e.g. in &lt;xsl:if test=&quot;/foo/bar&quot;&gt;
  73  */
  74 #define XSLT_FAST_IF
  75 
  76 /**
  77  * XSLT_REFACTORED:
  78  *
  79  * Internal define to enable the refactored parts of Libxslt.
  80  */
  81 /* #define XSLT_REFACTORED */
  82 /* ==================================================================== */
  83 
  84 /**
  85  * XSLT_REFACTORED_VARS:
  86  *
  87  * Internal define to enable the refactored variable part of libxslt
  88  */
  89 #define XSLT_REFACTORED_VARS
  90 
  91 #ifdef XSLT_REFACTORED
  92 
  93 extern const xmlChar *xsltXSLTAttrMarker;
  94 
  95 
  96 /* TODO: REMOVE: #define XSLT_REFACTORED_EXCLRESNS */
  97 
  98 /* TODO: REMOVE: #define XSLT_REFACTORED_NSALIAS */
  99 
 100 /**
 101  * XSLT_REFACTORED_XSLT_NSCOMP
 102  *
 103  * Internal define to enable the pointer-comparison of
 104  * namespaces of XSLT elements.
 105  */
 106 /* #define XSLT_REFACTORED_XSLT_NSCOMP */
 107 
 108 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 109 
 110 extern const xmlChar *xsltConstNamespaceNameXSLT;
 111 
 112 /**
 113  * IS_XSLT_ELEM_FAST:
 114  *
 115  * quick test to detect XSLT elements
 116  */
 117 #define IS_XSLT_ELEM_FAST(n) \
 118     (((n) != NULL) &amp;&amp; ((n)-&gt;ns != NULL) &amp;&amp; \
 119     ((n)-&gt;ns-&gt;href == xsltConstNamespaceNameXSLT))
 120 
 121 /**
 122  * IS_XSLT_ATTR_FAST:
 123  *
 124  * quick test to detect XSLT attributes
 125  */
 126 #define IS_XSLT_ATTR_FAST(a) \
 127     (((a) != NULL) &amp;&amp; ((a)-&gt;ns != NULL) &amp;&amp; \
 128     ((a)-&gt;ns-&gt;href == xsltConstNamespaceNameXSLT))
 129 
 130 /**
 131  * XSLT_HAS_INTERNAL_NSMAP:
 132  *
 133  * check for namespace mapping
 134  */
 135 #define XSLT_HAS_INTERNAL_NSMAP(s) \
 136     (((s) != NULL) &amp;&amp; ((s)-&gt;principal) &amp;&amp; \
 137      ((s)-&gt;principal-&gt;principalData) &amp;&amp; \
 138      ((s)-&gt;principal-&gt;principalData-&gt;nsMap))
 139 
 140 /**
 141  * XSLT_GET_INTERNAL_NSMAP:
 142  *
 143  * get pointer to namespace map
 144  */
 145 #define XSLT_GET_INTERNAL_NSMAP(s) ((s)-&gt;principal-&gt;principalData-&gt;nsMap)
 146 
 147 #else /* XSLT_REFACTORED_XSLT_NSCOMP */
 148 
 149 /**
 150  * IS_XSLT_ELEM_FAST:
 151  *
 152  * quick check whether this is an xslt element
 153  */
 154 #define IS_XSLT_ELEM_FAST(n) \
 155     (((n) != NULL) &amp;&amp; ((n)-&gt;ns != NULL) &amp;&amp; \
 156      (xmlStrEqual((n)-&gt;ns-&gt;href, XSLT_NAMESPACE)))
 157 
 158 /**
 159  * IS_XSLT_ATTR_FAST:
 160  *
 161  * quick check for xslt namespace attribute
 162  */
 163 #define IS_XSLT_ATTR_FAST(a) \
 164     (((a) != NULL) &amp;&amp; ((a)-&gt;ns != NULL) &amp;&amp; \
 165      (xmlStrEqual((a)-&gt;ns-&gt;href, XSLT_NAMESPACE)))
 166 
 167 
 168 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
 169 
 170 
 171 /**
 172  * XSLT_REFACTORED_MANDATORY_VERSION:
 173  *
 174  * TODO: Currently disabled to surpress regression test failures, since
 175  *  the old behaviour was that a missing version attribute
 176  *  produced a only a warning and not an error, which was incerrect.
 177  *  So the regression tests need to be fixed if this is enabled.
 178  */
 179 /* #define XSLT_REFACTORED_MANDATORY_VERSION */
 180 
 181 /**
 182  * xsltPointerList:
 183  *
 184  * Pointer-list for various purposes.
 185  */
 186 typedef struct _xsltPointerList xsltPointerList;
 187 typedef xsltPointerList *xsltPointerListPtr;
 188 struct _xsltPointerList {
 189     void **items;
 190     int number;
 191     int size;
 192 };
 193 
 194 #endif
 195 
 196 /**
 197  * XSLT_REFACTORED_PARSING:
 198  *
 199  * Internal define to enable the refactored parts of Libxslt
 200  * related to parsing.
 201  */
 202 /* #define XSLT_REFACTORED_PARSING */
 203 
 204 /**
 205  * XSLT_MAX_SORT:
 206  *
 207  * Max number of specified xsl:sort on an element.
 208  */
 209 #define XSLT_MAX_SORT 15
 210 
 211 /**
 212  * XSLT_PAT_NO_PRIORITY:
 213  *
 214  * Specific value for pattern without priority expressed.
 215  */
 216 #define XSLT_PAT_NO_PRIORITY -12345789
 217 
 218 /**
 219  * xsltRuntimeExtra:
 220  *
 221  * Extra information added to the transformation context.
 222  */
 223 typedef struct _xsltRuntimeExtra xsltRuntimeExtra;
 224 typedef xsltRuntimeExtra *xsltRuntimeExtraPtr;
 225 struct _xsltRuntimeExtra {
 226     void       *info;       /* pointer to the extra data */
 227     xmlFreeFunc deallocate; /* pointer to the deallocation routine */
 228     union {         /* dual-purpose field */
 229         void   *ptr;        /* data not needing deallocation */
 230     int    ival;        /* integer value storage */
 231     } val;
 232 };
 233 
 234 /**
 235  * XSLT_RUNTIME_EXTRA_LST:
 236  * @ctxt: the transformation context
 237  * @nr: the index
 238  *
 239  * Macro used to access extra information stored in the context
 240  */
 241 #define XSLT_RUNTIME_EXTRA_LST(ctxt, nr) (ctxt)-&gt;extras[(nr)].info
 242 /**
 243  * XSLT_RUNTIME_EXTRA_FREE:
 244  * @ctxt: the transformation context
 245  * @nr: the index
 246  *
 247  * Macro used to free extra information stored in the context
 248  */
 249 #define XSLT_RUNTIME_EXTRA_FREE(ctxt, nr) (ctxt)-&gt;extras[(nr)].deallocate
 250 /**
 251  * XSLT_RUNTIME_EXTRA:
 252  * @ctxt: the transformation context
 253  * @nr: the index
 254  *
 255  * Macro used to define extra information stored in the context
 256  */
 257 #define XSLT_RUNTIME_EXTRA(ctxt, nr, typ) (ctxt)-&gt;extras[(nr)].val.typ
 258 
 259 /**
 260  * xsltTemplate:
 261  *
 262  * The in-memory structure corresponding to an XSLT Template.
 263  */
 264 typedef struct _xsltTemplate xsltTemplate;
 265 typedef xsltTemplate *xsltTemplatePtr;
 266 struct _xsltTemplate {
 267     struct _xsltTemplate *next;/* chained list sorted by priority */
 268     struct _xsltStylesheet *style;/* the containing stylesheet */
 269     xmlChar *match; /* the matching string */
 270     float priority; /* as given from the stylesheet, not computed */
 271     const xmlChar *name; /* the local part of the name QName */
 272     const xmlChar *nameURI; /* the URI part of the name QName */
 273     const xmlChar *mode;/* the local part of the mode QName */
 274     const xmlChar *modeURI;/* the URI part of the mode QName */
 275     xmlNodePtr content; /* the template replacement value */
 276     xmlNodePtr elem;    /* the source element */
 277 
 278     /*
 279     * TODO: @inheritedNsNr and @inheritedNs won&#39;t be used in the
 280     *  refactored code.
 281     */
 282     int inheritedNsNr;  /* number of inherited namespaces */
 283     xmlNsPtr *inheritedNs;/* inherited non-excluded namespaces */
 284 
 285     /* Profiling information */
 286     int nbCalls;        /* the number of time the template was called */
 287     unsigned long time; /* the time spent in this template */
 288     void *params;       /* xsl:param instructions */
 289 
 290     int              templNr;       /* Nb of templates in the stack */
 291     int              templMax;      /* Size of the templtes stack */
 292     xsltTemplatePtr *templCalledTab;    /* templates called */
 293     int             *templCountTab;  /* .. and how often */
 294 };
 295 
 296 /**
 297  * xsltDecimalFormat:
 298  *
 299  * Data structure of decimal-format.
 300  */
 301 typedef struct _xsltDecimalFormat xsltDecimalFormat;
 302 typedef xsltDecimalFormat *xsltDecimalFormatPtr;
 303 struct _xsltDecimalFormat {
 304     struct _xsltDecimalFormat *next; /* chained list */
 305     xmlChar *name;
 306     /* Used for interpretation of pattern */
 307     xmlChar *digit;
 308     xmlChar *patternSeparator;
 309     /* May appear in result */
 310     xmlChar *minusSign;
 311     xmlChar *infinity;
 312     xmlChar *noNumber; /* Not-a-number */
 313     /* Used for interpretation of pattern and may appear in result */
 314     xmlChar *decimalPoint;
 315     xmlChar *grouping;
 316     xmlChar *percent;
 317     xmlChar *permille;
 318     xmlChar *zeroDigit;
 319     const xmlChar *nsUri;
 320 };
 321 
 322 /**
 323  * xsltDocument:
 324  *
 325  * Data structure associated to a parsed document.
 326  */
 327 typedef struct _xsltDocument xsltDocument;
 328 typedef xsltDocument *xsltDocumentPtr;
 329 struct _xsltDocument {
 330     struct _xsltDocument *next; /* documents are kept in a chained list */
 331     int main;           /* is this the main document */
 332     xmlDocPtr doc;      /* the parsed document */
 333     void *keys;         /* key tables storage */
 334     struct _xsltDocument *includes; /* subsidiary includes */
 335     int preproc;        /* pre-processing already done */
 336     int nbKeysComputed;
 337 };
 338 
 339 /**
 340  * xsltKeyDef:
 341  *
 342  * Representation of an xsl:key.
 343  */
 344 typedef struct _xsltKeyDef xsltKeyDef;
 345 typedef xsltKeyDef *xsltKeyDefPtr;
 346 struct _xsltKeyDef {
 347     struct _xsltKeyDef *next;
 348     xmlNodePtr inst;
 349     xmlChar *name;
 350     xmlChar *nameURI;
 351     xmlChar *match;
 352     xmlChar *use;
 353     xmlXPathCompExprPtr comp;
 354     xmlXPathCompExprPtr usecomp;
 355     xmlNsPtr *nsList;           /* the namespaces in scope */
 356     int nsNr;                   /* the number of namespaces in scope */
 357 };
 358 
 359 /**
 360  * xsltKeyTable:
 361  *
 362  * Holds the computed keys for key definitions of the same QName.
 363  * Is owned by an xsltDocument.
 364  */
 365 typedef struct _xsltKeyTable xsltKeyTable;
 366 typedef xsltKeyTable *xsltKeyTablePtr;
 367 struct _xsltKeyTable {
 368     struct _xsltKeyTable *next;
 369     xmlChar *name;
 370     xmlChar *nameURI;
 371     xmlHashTablePtr keys;
 372 };
 373 
 374 /*
 375  * The in-memory structure corresponding to an XSLT Stylesheet.
 376  * NOTE: most of the content is simply linked from the doc tree
 377  *       structure, no specific allocation is made.
 378  */
 379 typedef struct _xsltStylesheet xsltStylesheet;
 380 typedef xsltStylesheet *xsltStylesheetPtr;
 381 
 382 typedef struct _xsltTransformContext xsltTransformContext;
 383 typedef xsltTransformContext *xsltTransformContextPtr;
 384 
 385 /**
 386  * xsltElemPreComp:
 387  *
 388  * The in-memory structure corresponding to element precomputed data,
 389  * designed to be extended by extension implementors.
 390  */
 391 typedef struct _xsltElemPreComp xsltElemPreComp;
 392 typedef xsltElemPreComp *xsltElemPreCompPtr;
 393 
 394 /**
 395  * xsltTransformFunction:
 396  * @ctxt: the XSLT transformation context
 397  * @node: the input node
 398  * @inst: the stylesheet node
 399  * @comp: the compiled information from the stylesheet
 400  *
 401  * Signature of the function associated to elements part of the
 402  * stylesheet language like xsl:if or xsl:apply-templates.
 403  */
 404 typedef void (*xsltTransformFunction) (xsltTransformContextPtr ctxt,
 405                                    xmlNodePtr node,
 406                        xmlNodePtr inst,
 407                            xsltElemPreCompPtr comp);
 408 
 409 /**
 410  * xsltSortFunc:
 411  * @ctxt:    a transformation context
 412  * @sorts:   the node-set to sort
 413  * @nbsorts: the number of sorts
 414  *
 415  * Signature of the function to use during sorting
 416  */
 417 typedef void (*xsltSortFunc) (xsltTransformContextPtr ctxt, xmlNodePtr *sorts,
 418                   int nbsorts);
 419 
 420 typedef enum {
 421     XSLT_FUNC_COPY=1,
 422     XSLT_FUNC_SORT,
 423     XSLT_FUNC_TEXT,
 424     XSLT_FUNC_ELEMENT,
 425     XSLT_FUNC_ATTRIBUTE,
 426     XSLT_FUNC_COMMENT,
 427     XSLT_FUNC_PI,
 428     XSLT_FUNC_COPYOF,
 429     XSLT_FUNC_VALUEOF,
 430     XSLT_FUNC_NUMBER,
 431     XSLT_FUNC_APPLYIMPORTS,
 432     XSLT_FUNC_CALLTEMPLATE,
 433     XSLT_FUNC_APPLYTEMPLATES,
 434     XSLT_FUNC_CHOOSE,
 435     XSLT_FUNC_IF,
 436     XSLT_FUNC_FOREACH,
 437     XSLT_FUNC_DOCUMENT,
 438     XSLT_FUNC_WITHPARAM,
 439     XSLT_FUNC_PARAM,
 440     XSLT_FUNC_VARIABLE,
 441     XSLT_FUNC_WHEN,
 442     XSLT_FUNC_EXTENSION
 443 #ifdef XSLT_REFACTORED
 444     ,
 445     XSLT_FUNC_OTHERWISE,
 446     XSLT_FUNC_FALLBACK,
 447     XSLT_FUNC_MESSAGE,
 448     XSLT_FUNC_INCLUDE,
 449     XSLT_FUNC_ATTRSET,
 450     XSLT_FUNC_LITERAL_RESULT_ELEMENT,
 451     XSLT_FUNC_UNKOWN_FORWARDS_COMPAT
 452 #endif
 453 } xsltStyleType;
 454 
 455 /**
 456  * xsltElemPreCompDeallocator:
 457  * @comp:  the #xsltElemPreComp to free up
 458  *
 459  * Deallocates an #xsltElemPreComp structure.
 460  */
 461 typedef void (*xsltElemPreCompDeallocator) (xsltElemPreCompPtr comp);
 462 
 463 /**
 464  * xsltElemPreComp:
 465  *
 466  * The basic structure for compiled items of the AST of the XSLT processor.
 467  * This structure is also intended to be extended by extension implementors.
 468  * TODO: This is somehow not nice, since it has a &quot;free&quot; field, which
 469  *   derived stylesheet-structs do not have.
 470  */
 471 struct _xsltElemPreComp {
 472     xsltElemPreCompPtr next;        /* next item in the global chained
 473                        list held by xsltStylesheet. */
 474     xsltStyleType type;     /* type of the element */
 475     xsltTransformFunction func; /* handling function */
 476     xmlNodePtr inst;            /* the node in the stylesheet&#39;s tree
 477                        corresponding to this item */
 478 
 479     /* end of common part */
 480     xsltElemPreCompDeallocator free;    /* the deallocator */
 481 };
 482 
 483 /**
 484  * xsltStylePreComp:
 485  *
 486  * The abstract basic structure for items of the XSLT processor.
 487  * This includes:
 488  * 1) compiled forms of XSLT instructions (xsl:if, xsl:attribute, etc.)
 489  * 2) compiled forms of literal result elements
 490  * 3) compiled forms of extension elements
 491  */
 492 typedef struct _xsltStylePreComp xsltStylePreComp;
 493 typedef xsltStylePreComp *xsltStylePreCompPtr;
 494 
 495 #ifdef XSLT_REFACTORED
 496 
 497 /*
 498 * Some pointer-list utility functions.
 499 */
 500 XSLTPUBFUN xsltPointerListPtr XSLTCALL
 501         xsltPointerListCreate       (int initialSize);
 502 XSLTPUBFUN void XSLTCALL
 503         xsltPointerListFree     (xsltPointerListPtr list);
 504 XSLTPUBFUN void XSLTCALL
 505         xsltPointerListClear        (xsltPointerListPtr list);
 506 XSLTPUBFUN int XSLTCALL
 507         xsltPointerListAddSize      (xsltPointerListPtr list,
 508                          void *item,
 509                          int initialSize);
 510 
 511 /************************************************************************
 512  *                                  *
 513  * Refactored structures                                                *
 514  *                                  *
 515  ************************************************************************/
 516 
 517 typedef struct _xsltNsListContainer xsltNsListContainer;
 518 typedef xsltNsListContainer *xsltNsListContainerPtr;
 519 struct _xsltNsListContainer {
 520     xmlNsPtr *list;
 521     int totalNumber;
 522     int xpathNumber;
 523 };
 524 
 525 /**
 526  * XSLT_ITEM_COMPATIBILITY_FIELDS:
 527  *
 528  * Fields for API compatibility to the structure
 529  * _xsltElemPreComp which is used for extension functions.
 530  * Note that @next is used for storage; it does not reflect a next
 531  * sibling in the tree.
 532  * TODO: Evaluate if we really need such a compatibility.
 533  */
 534 #define XSLT_ITEM_COMPATIBILITY_FIELDS \
 535     xsltElemPreCompPtr next;\
 536     xsltStyleType type;\
 537     xsltTransformFunction func;\
 538     xmlNodePtr inst;
 539 
 540 /**
 541  * XSLT_ITEM_NAVIGATION_FIELDS:
 542  *
 543  * Currently empty.
 544  * TODO: It is intended to hold navigational fields in the future.
 545  */
 546 #define XSLT_ITEM_NAVIGATION_FIELDS
 547 /*
 548     xsltStylePreCompPtr parent;\
 549     xsltStylePreCompPtr children;\
 550     xsltStylePreCompPtr nextItem;
 551 */
 552 
 553 /**
 554  * XSLT_ITEM_NSINSCOPE_FIELDS:
 555  *
 556  * The in-scope namespaces.
 557  */
 558 #define XSLT_ITEM_NSINSCOPE_FIELDS xsltNsListContainerPtr inScopeNs;
 559 
 560 /**
 561  * XSLT_ITEM_COMMON_FIELDS:
 562  *
 563  * Common fields used for all items.
 564  */
 565 #define XSLT_ITEM_COMMON_FIELDS \
 566     XSLT_ITEM_COMPATIBILITY_FIELDS \
 567     XSLT_ITEM_NAVIGATION_FIELDS \
 568     XSLT_ITEM_NSINSCOPE_FIELDS
 569 
 570 /**
 571  * _xsltStylePreComp:
 572  *
 573  * The abstract basic structure for items of the XSLT processor.
 574  * This includes:
 575  * 1) compiled forms of XSLT instructions (e.g. xsl:if, xsl:attribute, etc.)
 576  * 2) compiled forms of literal result elements
 577  * 3) various properties for XSLT instructions (e.g. xsl:when,
 578  *    xsl:with-param)
 579  *
 580  * REVISIT TODO: Keep this structure equal to the fields
 581  *   defined by XSLT_ITEM_COMMON_FIELDS
 582  */
 583 struct _xsltStylePreComp {
 584     xsltElemPreCompPtr next;    /* next item in the global chained
 585                    list held by xsltStylesheet */
 586     xsltStyleType type;         /* type of the item */
 587     xsltTransformFunction func; /* handling function */
 588     xmlNodePtr inst;        /* the node in the stylesheet&#39;s tree
 589                    corresponding to this item. */
 590     /* Currently no navigational fields. */
 591     xsltNsListContainerPtr inScopeNs;
 592 };
 593 
 594 /**
 595  * xsltStyleBasicEmptyItem:
 596  *
 597  * Abstract structure only used as a short-cut for
 598  * XSLT items with no extra fields.
 599  * NOTE that it is intended that this structure looks the same as
 600  *  _xsltStylePreComp.
 601  */
 602 typedef struct _xsltStyleBasicEmptyItem xsltStyleBasicEmptyItem;
 603 typedef xsltStyleBasicEmptyItem *xsltStyleBasicEmptyItemPtr;
 604 
 605 struct _xsltStyleBasicEmptyItem {
 606     XSLT_ITEM_COMMON_FIELDS
 607 };
 608 
 609 /**
 610  * xsltStyleBasicExpressionItem:
 611  *
 612  * Abstract structure only used as a short-cut for
 613  * XSLT items with just an expression.
 614  */
 615 typedef struct _xsltStyleBasicExpressionItem xsltStyleBasicExpressionItem;
 616 typedef xsltStyleBasicExpressionItem *xsltStyleBasicExpressionItemPtr;
 617 
 618 struct _xsltStyleBasicExpressionItem {
 619     XSLT_ITEM_COMMON_FIELDS
 620 
 621     const xmlChar *select; /* TODO: Change this to &quot;expression&quot;. */
 622     xmlXPathCompExprPtr comp; /* TODO: Change this to compExpr. */
 623 };
 624 
 625 /************************************************************************
 626  *                                  *
 627  * XSLT-instructions/declarations                                       *
 628  *                                  *
 629  ************************************************************************/
 630 
 631 /**
 632  * xsltStyleItemElement:
 633  *
 634  * &lt;!-- Category: instruction --&gt;
 635  * &lt;xsl:element
 636  *  name = { qname }
 637  *  namespace = { uri-reference }
 638  *  use-attribute-sets = qnames&gt;
 639  *  &lt;!-- Content: template --&gt;
 640  * &lt;/xsl:element&gt;
 641  */
 642 typedef struct _xsltStyleItemElement xsltStyleItemElement;
 643 typedef xsltStyleItemElement *xsltStyleItemElementPtr;
 644 
 645 struct _xsltStyleItemElement {
 646     XSLT_ITEM_COMMON_FIELDS
 647 
 648     const xmlChar *use;
 649     int      has_use;
 650     const xmlChar *name;
 651     int      has_name;
 652     const xmlChar *ns;
 653     const xmlChar *nsPrefix;
 654     int      has_ns;
 655 };
 656 
 657 /**
 658  * xsltStyleItemAttribute:
 659  *
 660  * &lt;!-- Category: instruction --&gt;
 661  * &lt;xsl:attribute
 662  *  name = { qname }
 663  *  namespace = { uri-reference }&gt;
 664  *  &lt;!-- Content: template --&gt;
 665  * &lt;/xsl:attribute&gt;
 666  */
 667 typedef struct _xsltStyleItemAttribute xsltStyleItemAttribute;
 668 typedef xsltStyleItemAttribute *xsltStyleItemAttributePtr;
 669 
 670 struct _xsltStyleItemAttribute {
 671     XSLT_ITEM_COMMON_FIELDS
 672     const xmlChar *name;
 673     int      has_name;
 674     const xmlChar *ns;
 675     const xmlChar *nsPrefix;
 676     int      has_ns;
 677 };
 678 
 679 /**
 680  * xsltStyleItemText:
 681  *
 682  * &lt;!-- Category: instruction --&gt;
 683  * &lt;xsl:text
 684  *  disable-output-escaping = &quot;yes&quot; | &quot;no&quot;&gt;
 685  *  &lt;!-- Content: #PCDATA --&gt;
 686  * &lt;/xsl:text&gt;
 687  */
 688 typedef struct _xsltStyleItemText xsltStyleItemText;
 689 typedef xsltStyleItemText *xsltStyleItemTextPtr;
 690 
 691 struct _xsltStyleItemText {
 692     XSLT_ITEM_COMMON_FIELDS
 693     int      noescape;      /* text */
 694 };
 695 
 696 /**
 697  * xsltStyleItemComment:
 698  *
 699  * &lt;!-- Category: instruction --&gt;
 700  *  &lt;xsl:comment&gt;
 701  *  &lt;!-- Content: template --&gt;
 702  * &lt;/xsl:comment&gt;
 703  */
 704 typedef xsltStyleBasicEmptyItem xsltStyleItemComment;
 705 typedef xsltStyleItemComment *xsltStyleItemCommentPtr;
 706 
 707 /**
 708  * xsltStyleItemPI:
 709  *
 710  * &lt;!-- Category: instruction --&gt;
 711  *  &lt;xsl:processing-instruction
 712  *  name = { ncname }&gt;
 713  *  &lt;!-- Content: template --&gt;
 714  * &lt;/xsl:processing-instruction&gt;
 715  */
 716 typedef struct _xsltStyleItemPI xsltStyleItemPI;
 717 typedef xsltStyleItemPI *xsltStyleItemPIPtr;
 718 
 719 struct _xsltStyleItemPI {
 720     XSLT_ITEM_COMMON_FIELDS
 721     const xmlChar *name;
 722     int      has_name;
 723 };
 724 
 725 /**
 726  * xsltStyleItemApplyImports:
 727  *
 728  * &lt;!-- Category: instruction --&gt;
 729  * &lt;xsl:apply-imports /&gt;
 730  */
 731 typedef xsltStyleBasicEmptyItem xsltStyleItemApplyImports;
 732 typedef xsltStyleItemApplyImports *xsltStyleItemApplyImportsPtr;
 733 
 734 /**
 735  * xsltStyleItemApplyTemplates:
 736  *
 737  * &lt;!-- Category: instruction --&gt;
 738  *  &lt;xsl:apply-templates
 739  *  select = node-set-expression
 740  *  mode = qname&gt;
 741  *  &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt;
 742  * &lt;/xsl:apply-templates&gt;
 743  */
 744 typedef struct _xsltStyleItemApplyTemplates xsltStyleItemApplyTemplates;
 745 typedef xsltStyleItemApplyTemplates *xsltStyleItemApplyTemplatesPtr;
 746 
 747 struct _xsltStyleItemApplyTemplates {
 748     XSLT_ITEM_COMMON_FIELDS
 749 
 750     const xmlChar *mode;    /* apply-templates */
 751     const xmlChar *modeURI; /* apply-templates */
 752     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
 753     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 754     /* TODO: with-params */
 755 };
 756 
 757 /**
 758  * xsltStyleItemCallTemplate:
 759  *
 760  * &lt;!-- Category: instruction --&gt;
 761  *  &lt;xsl:call-template
 762  *  name = qname&gt;
 763  *  &lt;!-- Content: xsl:with-param* --&gt;
 764  * &lt;/xsl:call-template&gt;
 765  */
 766 typedef struct _xsltStyleItemCallTemplate xsltStyleItemCallTemplate;
 767 typedef xsltStyleItemCallTemplate *xsltStyleItemCallTemplatePtr;
 768 
 769 struct _xsltStyleItemCallTemplate {
 770     XSLT_ITEM_COMMON_FIELDS
 771 
 772     xsltTemplatePtr templ;  /* call-template */
 773     const xmlChar *name;    /* element, attribute, pi */
 774     int      has_name;      /* element, attribute, pi */
 775     const xmlChar *ns;      /* element */
 776     int      has_ns;        /* element */
 777     /* TODO: with-params */
 778 };
 779 
 780 /**
 781  * xsltStyleItemCopy:
 782  *
 783  * &lt;!-- Category: instruction --&gt;
 784  * &lt;xsl:copy
 785  *  use-attribute-sets = qnames&gt;
 786  *  &lt;!-- Content: template --&gt;
 787  * &lt;/xsl:copy&gt;
 788  */
 789 typedef struct _xsltStyleItemCopy xsltStyleItemCopy;
 790 typedef xsltStyleItemCopy *xsltStyleItemCopyPtr;
 791 
 792 struct _xsltStyleItemCopy {
 793    XSLT_ITEM_COMMON_FIELDS
 794     const xmlChar *use;     /* copy, element */
 795     int      has_use;       /* copy, element */
 796 };
 797 
 798 /**
 799  * xsltStyleItemIf:
 800  *
 801  * &lt;!-- Category: instruction --&gt;
 802  *  &lt;xsl:if
 803  *  test = boolean-expression&gt;
 804  *  &lt;!-- Content: template --&gt;
 805  * &lt;/xsl:if&gt;
 806  */
 807 typedef struct _xsltStyleItemIf xsltStyleItemIf;
 808 typedef xsltStyleItemIf *xsltStyleItemIfPtr;
 809 
 810 struct _xsltStyleItemIf {
 811     XSLT_ITEM_COMMON_FIELDS
 812 
 813     const xmlChar *test;    /* if */
 814     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 815 };
 816 
 817 
 818 /**
 819  * xsltStyleItemCopyOf:
 820  *
 821  * &lt;!-- Category: instruction --&gt;
 822  * &lt;xsl:copy-of
 823  *  select = expression /&gt;
 824  */
 825 typedef xsltStyleBasicExpressionItem xsltStyleItemCopyOf;
 826 typedef xsltStyleItemCopyOf *xsltStyleItemCopyOfPtr;
 827 
 828 /**
 829  * xsltStyleItemValueOf:
 830  *
 831  * &lt;!-- Category: instruction --&gt;
 832  * &lt;xsl:value-of
 833  *  select = string-expression
 834  *  disable-output-escaping = &quot;yes&quot; | &quot;no&quot; /&gt;
 835  */
 836 typedef struct _xsltStyleItemValueOf xsltStyleItemValueOf;
 837 typedef xsltStyleItemValueOf *xsltStyleItemValueOfPtr;
 838 
 839 struct _xsltStyleItemValueOf {
 840     XSLT_ITEM_COMMON_FIELDS
 841 
 842     const xmlChar *select;
 843     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 844     int      noescape;
 845 };
 846 
 847 /**
 848  * xsltStyleItemNumber:
 849  *
 850  * &lt;!-- Category: instruction --&gt;
 851  *  &lt;xsl:number
 852  *  level = &quot;single&quot; | &quot;multiple&quot; | &quot;any&quot;
 853  *  count = pattern
 854  *  from = pattern
 855  *  value = number-expression
 856  *  format = { string }
 857  *  lang = { nmtoken }
 858  *  letter-value = { &quot;alphabetic&quot; | &quot;traditional&quot; }
 859  *  grouping-separator = { char }
 860  *  grouping-size = { number } /&gt;
 861  */
 862 typedef struct _xsltStyleItemNumber xsltStyleItemNumber;
 863 typedef xsltStyleItemNumber *xsltStyleItemNumberPtr;
 864 
 865 struct _xsltStyleItemNumber {
 866     XSLT_ITEM_COMMON_FIELDS
 867     xsltNumberData numdata; /* number */
 868 };
 869 
 870 /**
 871  * xsltStyleItemChoose:
 872  *
 873  * &lt;!-- Category: instruction --&gt;
 874  *  &lt;xsl:choose&gt;
 875  *  &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt;
 876  * &lt;/xsl:choose&gt;
 877  */
 878 typedef xsltStyleBasicEmptyItem xsltStyleItemChoose;
 879 typedef xsltStyleItemChoose *xsltStyleItemChoosePtr;
 880 
 881 /**
 882  * xsltStyleItemFallback:
 883  *
 884  * &lt;!-- Category: instruction --&gt;
 885  *  &lt;xsl:fallback&gt;
 886  *  &lt;!-- Content: template --&gt;
 887  * &lt;/xsl:fallback&gt;
 888  */
 889 typedef xsltStyleBasicEmptyItem xsltStyleItemFallback;
 890 typedef xsltStyleItemFallback *xsltStyleItemFallbackPtr;
 891 
 892 /**
 893  * xsltStyleItemForEach:
 894  *
 895  * &lt;!-- Category: instruction --&gt;
 896  * &lt;xsl:for-each
 897  *   select = node-set-expression&gt;
 898  *   &lt;!-- Content: (xsl:sort*, template) --&gt;
 899  * &lt;/xsl:for-each&gt;
 900  */
 901 typedef xsltStyleBasicExpressionItem xsltStyleItemForEach;
 902 typedef xsltStyleItemForEach *xsltStyleItemForEachPtr;
 903 
 904 /**
 905  * xsltStyleItemMessage:
 906  *
 907  * &lt;!-- Category: instruction --&gt;
 908  * &lt;xsl:message
 909  *   terminate = &quot;yes&quot; | &quot;no&quot;&gt;
 910  *   &lt;!-- Content: template --&gt;
 911  * &lt;/xsl:message&gt;
 912  */
 913 typedef struct _xsltStyleItemMessage xsltStyleItemMessage;
 914 typedef xsltStyleItemMessage *xsltStyleItemMessagePtr;
 915 
 916 struct _xsltStyleItemMessage {
 917     XSLT_ITEM_COMMON_FIELDS
 918     int terminate;
 919 };
 920 
 921 /**
 922  * xsltStyleItemDocument:
 923  *
 924  * NOTE: This is not an instruction of XSLT 1.0.
 925  */
 926 typedef struct _xsltStyleItemDocument xsltStyleItemDocument;
 927 typedef xsltStyleItemDocument *xsltStyleItemDocumentPtr;
 928 
 929 struct _xsltStyleItemDocument {
 930     XSLT_ITEM_COMMON_FIELDS
 931     int      ver11;     /* assigned: in xsltDocumentComp;
 932                                   read: nowhere;
 933                                   TODO: Check if we need. */
 934     const xmlChar *filename;    /* document URL */
 935     int has_filename;
 936 };
 937 
 938 /************************************************************************
 939  *                                  *
 940  * Non-instructions (actually properties of instructions/declarations)  *
 941  *                                  *
 942  ************************************************************************/
 943 
 944 /**
 945  * xsltStyleBasicItemVariable:
 946  *
 947  * Basic struct for xsl:variable, xsl:param and xsl:with-param.
 948  * It&#39;s currently important to have equal fields, since
 949  * xsltParseStylesheetCallerParam() is used with xsl:with-param from
 950  * the xslt side and with xsl:param from the exslt side (in
 951  * exsltFuncFunctionFunction()).
 952  *
 953  * FUTURE NOTE: In XSLT 2.0 xsl:param, xsl:variable and xsl:with-param
 954  *   have additional different fields.
 955  */
 956 typedef struct _xsltStyleBasicItemVariable xsltStyleBasicItemVariable;
 957 typedef xsltStyleBasicItemVariable *xsltStyleBasicItemVariablePtr;
 958 
 959 struct _xsltStyleBasicItemVariable {
 960     XSLT_ITEM_COMMON_FIELDS
 961 
 962     const xmlChar *select;
 963     xmlXPathCompExprPtr comp;
 964 
 965     const xmlChar *name;
 966     int      has_name;
 967     const xmlChar *ns;
 968     int      has_ns;
 969 };
 970 
 971 /**
 972  * xsltStyleItemVariable:
 973  *
 974  * &lt;!-- Category: top-level-element --&gt;
 975  * &lt;xsl:param
 976  *   name = qname
 977  *   select = expression&gt;
 978  *   &lt;!-- Content: template --&gt;
 979  * &lt;/xsl:param&gt;
 980  */
 981 typedef xsltStyleBasicItemVariable xsltStyleItemVariable;
 982 typedef xsltStyleItemVariable *xsltStyleItemVariablePtr;
 983 
 984 /**
 985  * xsltStyleItemParam:
 986  *
 987  * &lt;!-- Category: top-level-element --&gt;
 988  * &lt;xsl:param
 989  *   name = qname
 990  *   select = expression&gt;
 991  *   &lt;!-- Content: template --&gt;
 992  * &lt;/xsl:param&gt;
 993  */
 994 typedef struct _xsltStyleItemParam xsltStyleItemParam;
 995 typedef xsltStyleItemParam *xsltStyleItemParamPtr;
 996 
 997 struct _xsltStyleItemParam {
 998     XSLT_ITEM_COMMON_FIELDS
 999 
1000     const xmlChar *select;
1001     xmlXPathCompExprPtr comp;
1002 
1003     const xmlChar *name;
1004     int      has_name;
1005     const xmlChar *ns;
1006     int      has_ns;
1007 };
1008 
1009 /**
1010  * xsltStyleItemWithParam:
1011  *
1012  * &lt;xsl:with-param
1013  *  name = qname
1014  *  select = expression&gt;
1015  *  &lt;!-- Content: template --&gt;
1016  * &lt;/xsl:with-param&gt;
1017  */
1018 typedef xsltStyleBasicItemVariable xsltStyleItemWithParam;
1019 typedef xsltStyleItemWithParam *xsltStyleItemWithParamPtr;
1020 
1021 /**
1022  * xsltStyleItemSort:
1023  *
1024  * Reflects the XSLT xsl:sort item.
1025  * Allowed parents: xsl:apply-templates, xsl:for-each
1026  * &lt;xsl:sort
1027  *   select = string-expression
1028  *   lang = { nmtoken }
1029  *   data-type = { &quot;text&quot; | &quot;number&quot; | qname-but-not-ncname }
1030  *   order = { &quot;ascending&quot; | &quot;descending&quot; }
1031  *   case-order = { &quot;upper-first&quot; | &quot;lower-first&quot; } /&gt;
1032  */
1033 typedef struct _xsltStyleItemSort xsltStyleItemSort;
1034 typedef xsltStyleItemSort *xsltStyleItemSortPtr;
1035 
1036 struct _xsltStyleItemSort {
1037     XSLT_ITEM_COMMON_FIELDS
1038 
1039     const xmlChar *stype;       /* sort */
1040     int      has_stype;     /* sort */
1041     int      number;        /* sort */
1042     const xmlChar *order;   /* sort */
1043     int      has_order;     /* sort */
1044     int      descending;    /* sort */
1045     const xmlChar *lang;    /* sort */
1046     int      has_lang;      /* sort */
1047     xsltLocale locale;      /* sort */
1048     const xmlChar *case_order;  /* sort */
1049     int      lower_first;   /* sort */
1050 
1051     const xmlChar *use;
1052     int      has_use;
1053 
1054     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
1055 
1056     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
1057 };
1058 
1059 
1060 /**
1061  * xsltStyleItemWhen:
1062  *
1063  * &lt;xsl:when
1064  *   test = boolean-expression&gt;
1065  *   &lt;!-- Content: template --&gt;
1066  * &lt;/xsl:when&gt;
1067  * Allowed parent: xsl:choose
1068  */
1069 typedef struct _xsltStyleItemWhen xsltStyleItemWhen;
1070 typedef xsltStyleItemWhen *xsltStyleItemWhenPtr;
1071 
1072 struct _xsltStyleItemWhen {
1073     XSLT_ITEM_COMMON_FIELDS
1074 
1075     const xmlChar *test;
1076     xmlXPathCompExprPtr comp;
1077 };
1078 
1079 /**
1080  * xsltStyleItemOtherwise:
1081  *
1082  * Allowed parent: xsl:choose
1083  * &lt;xsl:otherwise&gt;
1084  *   &lt;!-- Content: template --&gt;
1085  * &lt;/xsl:otherwise&gt;
1086  */
1087 typedef struct _xsltStyleItemOtherwise xsltStyleItemOtherwise;
1088 typedef xsltStyleItemOtherwise *xsltStyleItemOtherwisePtr;
1089 
1090 struct _xsltStyleItemOtherwise {
1091     XSLT_ITEM_COMMON_FIELDS
1092 };
1093 
1094 typedef struct _xsltStyleItemInclude xsltStyleItemInclude;
1095 typedef xsltStyleItemInclude *xsltStyleItemIncludePtr;
1096 
1097 struct _xsltStyleItemInclude {
1098     XSLT_ITEM_COMMON_FIELDS
1099     xsltDocumentPtr include;
1100 };
1101 
1102 /************************************************************************
1103  *                                  *
1104  *  XSLT elements in forwards-compatible mode                           *
1105  *                                  *
1106  ************************************************************************/
1107 
1108 typedef struct _xsltStyleItemUknown xsltStyleItemUknown;
1109 typedef xsltStyleItemUknown *xsltStyleItemUknownPtr;
1110 struct _xsltStyleItemUknown {
1111     XSLT_ITEM_COMMON_FIELDS
1112 };
1113 
1114 
1115 /************************************************************************
1116  *                                  *
1117  *  Extension elements                                                  *
1118  *                                  *
1119  ************************************************************************/
1120 
1121 /*
1122  * xsltStyleItemExtElement:
1123  *
1124  * Reflects extension elements.
1125  *
1126  * NOTE: Due to the fact that the structure xsltElemPreComp is most
1127  * probably already heavily in use out there by users, so we cannot
1128  * easily change it, we&#39;ll create an intermediate structure which will
1129  * hold an xsltElemPreCompPtr.
1130  * BIG NOTE: The only problem I see here is that the user processes the
1131  *  content of the stylesheet tree, possibly he&#39;ll lookup the node-&gt;psvi
1132  *  fields in order to find subsequent extension functions.
1133  *  In this case, the user&#39;s code will break, since the node-&gt;psvi
1134  *  field will hold now the xsltStyleItemExtElementPtr and not
1135  *  the xsltElemPreCompPtr.
1136  *  However the place where the structure is anchored in the node-tree,
1137  *  namely node-&gt;psvi, has beed already once been moved from node-&gt;_private
1138  *  to node-&gt;psvi, so we have a precedent here, which, I think, should allow
1139  *  us to change such semantics without headaches.
1140  */
1141 typedef struct _xsltStyleItemExtElement xsltStyleItemExtElement;
1142 typedef xsltStyleItemExtElement *xsltStyleItemExtElementPtr;
1143 struct _xsltStyleItemExtElement {
1144     XSLT_ITEM_COMMON_FIELDS
1145     xsltElemPreCompPtr item;
1146 };
1147 
1148 /************************************************************************
1149  *                                  *
1150  *  Literal result elements                                             *
1151  *                                  *
1152  ************************************************************************/
1153 
1154 typedef struct _xsltEffectiveNs xsltEffectiveNs;
1155 typedef xsltEffectiveNs *xsltEffectiveNsPtr;
1156 struct _xsltEffectiveNs {
1157     xsltEffectiveNsPtr nextInStore; /* storage next */
1158     xsltEffectiveNsPtr next; /* next item in the list */
1159     const xmlChar *prefix;
1160     const xmlChar *nsName;
1161     /*
1162     * Indicates if eclared on the literal result element; dunno if really
1163     * needed.
1164     */
1165     int holdByElem;
1166 };
1167 
1168 /*
1169  * Info for literal result elements.
1170  * This will be set on the elem-&gt;psvi field and will be
1171  * shared by literal result elements, which have the same
1172  * excluded result namespaces; i.e., this *won&#39;t* be created uniquely
1173  * for every literal result element.
1174  */
1175 typedef struct _xsltStyleItemLRElementInfo xsltStyleItemLRElementInfo;
1176 typedef xsltStyleItemLRElementInfo *xsltStyleItemLRElementInfoPtr;
1177 struct _xsltStyleItemLRElementInfo {
1178     XSLT_ITEM_COMMON_FIELDS
1179     /*
1180     * @effectiveNs is the set of effective ns-nodes
1181     *  on the literal result element, which will be added to the result
1182     *  element if not already existing in the result tree.
1183     *  This means that excluded namespaces (via exclude-result-prefixes,
1184     *  extension-element-prefixes and the XSLT namespace) not added
1185     *  to the set.
1186     *  Namespace-aliasing was applied on the @effectiveNs.
1187     */
1188     xsltEffectiveNsPtr effectiveNs;
1189 
1190 };
1191 
1192 #ifdef XSLT_REFACTORED
1193 
1194 typedef struct _xsltNsAlias xsltNsAlias;
1195 typedef xsltNsAlias *xsltNsAliasPtr;
1196 struct _xsltNsAlias {
1197     xsltNsAliasPtr next; /* next in the list */
1198     xmlNsPtr literalNs;
1199     xmlNsPtr targetNs;
1200     xmlDocPtr docOfTargetNs;
1201 };
1202 #endif
1203 
1204 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1205 
1206 typedef struct _xsltNsMap xsltNsMap;
1207 typedef xsltNsMap *xsltNsMapPtr;
1208 struct _xsltNsMap {
1209     xsltNsMapPtr next; /* next in the list */
1210     xmlDocPtr doc;
1211     xmlNodePtr elem; /* the element holding the ns-decl */
1212     xmlNsPtr ns; /* the xmlNs structure holding the XML namespace name */
1213     const xmlChar *origNsName; /* the original XML namespace name */
1214     const xmlChar *newNsName; /* the mapped XML namespace name */
1215 };
1216 #endif
1217 
1218 /************************************************************************
1219  *                                  *
1220  *  Compile-time structures for *internal* use only                     *
1221  *                                  *
1222  ************************************************************************/
1223 
1224 typedef struct _xsltPrincipalStylesheetData xsltPrincipalStylesheetData;
1225 typedef xsltPrincipalStylesheetData *xsltPrincipalStylesheetDataPtr;
1226 
1227 typedef struct _xsltNsList xsltNsList;
1228 typedef xsltNsList *xsltNsListPtr;
1229 struct _xsltNsList {
1230     xsltNsListPtr next; /* next in the list */
1231     xmlNsPtr ns;
1232 };
1233 
1234 /*
1235 * xsltVarInfo:
1236 *
1237 * Used at compilation time for parameters and variables.
1238 */
1239 typedef struct _xsltVarInfo xsltVarInfo;
1240 typedef xsltVarInfo *xsltVarInfoPtr;
1241 struct _xsltVarInfo {
1242     xsltVarInfoPtr next; /* next in the list */
1243     xsltVarInfoPtr prev;
1244     int depth; /* the depth in the tree */
1245     const xmlChar *name;
1246     const xmlChar *nsName;
1247 };
1248 
1249 /**
1250  * xsltCompilerNodeInfo:
1251  *
1252  * Per-node information during compile-time.
1253  */
1254 typedef struct _xsltCompilerNodeInfo xsltCompilerNodeInfo;
1255 typedef xsltCompilerNodeInfo *xsltCompilerNodeInfoPtr;
1256 struct _xsltCompilerNodeInfo {
1257     xsltCompilerNodeInfoPtr next;
1258     xsltCompilerNodeInfoPtr prev;
1259     xmlNodePtr node;
1260     int depth;
1261     xsltTemplatePtr templ;   /* The owning template */
1262     int category;        /* XSLT element, LR-element or
1263                                 extension element */
1264     xsltStyleType type;
1265     xsltElemPreCompPtr item; /* The compiled information */
1266     /* The current in-scope namespaces */
1267     xsltNsListContainerPtr inScopeNs;
1268     /* The current excluded result namespaces */
1269     xsltPointerListPtr exclResultNs;
1270     /* The current extension instruction namespaces */
1271     xsltPointerListPtr extElemNs;
1272 
1273     /* The current info for literal result elements. */
1274     xsltStyleItemLRElementInfoPtr litResElemInfo;
1275     /*
1276     * Set to 1 if in-scope namespaces changed,
1277     *  or excluded result namespaces changed,
1278     *  or extension element namespaces changed.
1279     * This will trigger creation of new infos
1280     *  for literal result elements.
1281     */
1282     int nsChanged;
1283     int preserveWhitespace;
1284     int stripWhitespace;
1285     int isRoot; /* whether this is the stylesheet&#39;s root node */
1286     int forwardsCompat; /* whether forwards-compatible mode is enabled */
1287     /* whether the content of an extension element was processed */
1288     int extContentHandled;
1289     /* the type of the current child */
1290     xsltStyleType curChildType;
1291 };
1292 
1293 /**
1294  * XSLT_CCTXT:
1295  *
1296  * get pointer to compiler context
1297  */
1298 #define XSLT_CCTXT(style) ((xsltCompilerCtxtPtr) style-&gt;compCtxt)
1299 
1300 typedef enum {
1301     XSLT_ERROR_SEVERITY_ERROR = 0,
1302     XSLT_ERROR_SEVERITY_WARNING
1303 } xsltErrorSeverityType;
1304 
1305 typedef struct _xsltCompilerCtxt xsltCompilerCtxt;
1306 typedef xsltCompilerCtxt *xsltCompilerCtxtPtr;
1307 struct _xsltCompilerCtxt {
1308     void *errorCtxt;            /* user specific error context */
1309     /*
1310     * used for error/warning reports; e.g. XSLT_ERROR_SEVERITY_WARNING */
1311     xsltErrorSeverityType errSeverity;
1312     int warnings;       /* TODO: number of warnings found at
1313                                    compilation */
1314     int errors;         /* TODO: number of errors found at
1315                                    compilation */
1316     xmlDictPtr dict;
1317     xsltStylesheetPtr style;
1318     int simplified; /* whether this is a simplified stylesheet */
1319     /* TODO: structured/unstructured error contexts. */
1320     int depth; /* Current depth of processing */
1321 
1322     xsltCompilerNodeInfoPtr inode;
1323     xsltCompilerNodeInfoPtr inodeList;
1324     xsltCompilerNodeInfoPtr inodeLast;
1325     xsltPointerListPtr tmpList; /* Used for various purposes */
1326     /*
1327     * The XSLT version as specified by the stylesheet&#39;s root element.
1328     */
1329     int isInclude;
1330     int hasForwardsCompat; /* whether forwards-compatible mode was used
1331                  in a parsing episode */
1332     int maxNodeInfos; /* TEMP TODO: just for the interest */
1333     int maxLREs;  /* TEMP TODO: just for the interest */
1334     /*
1335     * In order to keep the old behaviour, applying strict rules of
1336     * the spec can be turned off. This has effect only on special
1337     * mechanisms like whitespace-stripping in the stylesheet.
1338     */
1339     int strict;
1340     xsltPrincipalStylesheetDataPtr psData;
1341     xsltStyleItemUknownPtr unknownItem;
1342     int hasNsAliases; /* Indicator if there was an xsl:namespace-alias. */
1343     xsltNsAliasPtr nsAliases;
1344     xsltVarInfoPtr ivars; /* Storage of local in-scope variables/params. */
1345     xsltVarInfoPtr ivar; /* topmost local variable/param. */
1346 };
1347 
1348 #else /* XSLT_REFACTORED */
1349 /*
1350 * The old structures before refactoring.
1351 */
1352 
1353 /**
1354  * _xsltStylePreComp:
1355  *
1356  * The in-memory structure corresponding to XSLT stylesheet constructs
1357  * precomputed data.
1358  */
1359 struct _xsltStylePreComp {
1360     xsltElemPreCompPtr next;    /* chained list */
1361     xsltStyleType type;     /* type of the element */
1362     xsltTransformFunction func; /* handling function */
1363     xmlNodePtr inst;        /* the instruction */
1364 
1365     /*
1366      * Pre computed values.
1367      */
1368 
1369     const xmlChar *stype;       /* sort */
1370     int      has_stype;     /* sort */
1371     int      number;        /* sort */
1372     const xmlChar *order;   /* sort */
1373     int      has_order;     /* sort */
1374     int      descending;    /* sort */
1375     const xmlChar *lang;    /* sort */
1376     int      has_lang;      /* sort */
1377     xsltLocale locale;      /* sort */
1378     const xmlChar *case_order;  /* sort */
1379     int      lower_first;   /* sort */
1380 
1381     const xmlChar *use;     /* copy, element */
1382     int      has_use;       /* copy, element */
1383 
1384     int      noescape;      /* text */
1385 
1386     const xmlChar *name;    /* element, attribute, pi */
1387     int      has_name;      /* element, attribute, pi */
1388     const xmlChar *ns;      /* element */
1389     int      has_ns;        /* element */
1390 
1391     const xmlChar *mode;    /* apply-templates */
1392     const xmlChar *modeURI; /* apply-templates */
1393 
1394     const xmlChar *test;    /* if */
1395 
1396     xsltTemplatePtr templ;  /* call-template */
1397 
1398     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
1399 
1400     int      ver11;     /* document */
1401     const xmlChar *filename;    /* document URL */
1402     int      has_filename;  /* document */
1403 
1404     xsltNumberData numdata; /* number */
1405 
1406     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
1407     xmlNsPtr *nsList;       /* the namespaces in scope */
1408     int nsNr;           /* the number of namespaces in scope */
1409 };
1410 
1411 #endif /* XSLT_REFACTORED */
1412 
1413 
1414 /*
1415  * The in-memory structure corresponding to an XSLT Variable
1416  * or Param.
1417  */
1418 typedef struct _xsltStackElem xsltStackElem;
1419 typedef xsltStackElem *xsltStackElemPtr;
1420 struct _xsltStackElem {
1421     struct _xsltStackElem *next;/* chained list */
1422     xsltStylePreCompPtr comp;   /* the compiled form */
1423     int computed;       /* was the evaluation done */
1424     const xmlChar *name;    /* the local part of the name QName */
1425     const xmlChar *nameURI; /* the URI part of the name QName */
1426     const xmlChar *select;  /* the eval string */
1427     xmlNodePtr tree;        /* the sequence constructor if no eval
1428                     string or the location */
1429     xmlXPathObjectPtr value;    /* The value if computed */
1430     xmlDocPtr fragment;     /* The Result Tree Fragments (needed for XSLT 1.0)
1431                    which are bound to the variable&#39;s lifetime. */
1432     int level;                  /* the depth in the tree;
1433                                    -1 if persistent (e.g. a given xsl:with-param) */
1434     xsltTransformContextPtr context; /* The transformation context; needed to cache
1435                                         the variables */
1436     int flags;
1437 };
1438 
1439 #ifdef XSLT_REFACTORED
1440 
1441 struct _xsltPrincipalStylesheetData {
1442     /*
1443     * Namespace dictionary for ns-prefixes and ns-names:
1444     * TODO: Shared between stylesheets, and XPath mechanisms.
1445     *   Not used yet.
1446     */
1447     xmlDictPtr namespaceDict;
1448     /*
1449     * Global list of in-scope namespaces.
1450     */
1451     xsltPointerListPtr inScopeNamespaces;
1452     /*
1453     * Global list of information for [xsl:]excluded-result-prefixes.
1454     */
1455     xsltPointerListPtr exclResultNamespaces;
1456     /*
1457     * Global list of information for [xsl:]extension-element-prefixes.
1458     */
1459     xsltPointerListPtr extElemNamespaces;
1460     xsltEffectiveNsPtr effectiveNs;
1461 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1462     /*
1463     * Namespace name map to get rid of string comparison of namespace names.
1464     */
1465     xsltNsMapPtr nsMap;
1466 #endif
1467 };
1468 
1469 
1470 #endif
1471 /*
1472  * Note that we added a @compCtxt field to anchor an stylesheet compilation
1473  * context, since, due to historical reasons, various compile-time function
1474  * take only the stylesheet as argument and not a compilation context.
1475  */
1476 struct _xsltStylesheet {
1477     /*
1478      * The stylesheet import relation is kept as a tree.
1479      */
1480     struct _xsltStylesheet *parent;
1481     struct _xsltStylesheet *next;
1482     struct _xsltStylesheet *imports;
1483 
1484     xsltDocumentPtr docList;        /* the include document list */
1485 
1486     /*
1487      * General data on the style sheet document.
1488      */
1489     xmlDocPtr doc;      /* the parsed XML stylesheet */
1490     xmlHashTablePtr stripSpaces;/* the hash table of the strip-space and
1491                    preserve space elements */
1492     int             stripAll;   /* strip-space * (1) preserve-space * (-1) */
1493     xmlHashTablePtr cdataSection;/* the hash table of the cdata-section */
1494 
1495     /*
1496      * Global variable or parameters.
1497      */
1498     xsltStackElemPtr variables; /* linked list of param and variables */
1499 
1500     /*
1501      * Template descriptions.
1502      */
1503     xsltTemplatePtr templates;  /* the ordered list of templates */
1504     void *templatesHash;    /* hash table or wherever compiled templates
1505                    information is stored */
1506     void *rootMatch;        /* template based on / */
1507     void *keyMatch;     /* template based on key() */
1508     void *elemMatch;        /* template based on * */
1509     void *attrMatch;        /* template based on @* */
1510     void *parentMatch;      /* template based on .. */
1511     void *textMatch;        /* template based on text() */
1512     void *piMatch;      /* template based on processing-instruction() */
1513     void *commentMatch;     /* template based on comment() */
1514 
1515     /*
1516      * Namespace aliases.
1517      * NOTE: Not used in the refactored code.
1518      */
1519     xmlHashTablePtr nsAliases;  /* the namespace alias hash tables */
1520 
1521     /*
1522      * Attribute sets.
1523      */
1524     xmlHashTablePtr attributeSets;/* the attribute sets hash tables */
1525 
1526     /*
1527      * Namespaces.
1528      * TODO: Eliminate this.
1529      */
1530     xmlHashTablePtr nsHash;     /* the set of namespaces in use:
1531                                    ATTENTION: This is used for
1532                                    execution of XPath expressions; unfortunately
1533                                    it restricts the stylesheet to have distinct
1534                                    prefixes.
1535                    TODO: We need to get rid of this.
1536                  */
1537     void           *nsDefs;     /* ATTENTION TODO: This is currently used to store
1538                    xsltExtDefPtr (in extensions.c) and
1539                                    *not* xmlNsPtr.
1540                  */
1541 
1542     /*
1543      * Key definitions.
1544      */
1545     void *keys;         /* key definitions */
1546 
1547     /*
1548      * Output related stuff.
1549      */
1550     xmlChar *method;        /* the output method */
1551     xmlChar *methodURI;     /* associated namespace if any */
1552     xmlChar *version;       /* version string */
1553     xmlChar *encoding;      /* encoding string */
1554     int omitXmlDeclaration;     /* omit-xml-declaration = &quot;yes&quot; | &quot;no&quot; */
1555 
1556     /*
1557      * Number formatting.
1558      */
1559     xsltDecimalFormatPtr decimalFormat;
1560     int standalone;             /* standalone = &quot;yes&quot; | &quot;no&quot; */
1561     xmlChar *doctypePublic;     /* doctype-public string */
1562     xmlChar *doctypeSystem;     /* doctype-system string */
1563     int indent;         /* should output being indented */
1564     xmlChar *mediaType;     /* media-type string */
1565 
1566     /*
1567      * Precomputed blocks.
1568      */
1569     xsltElemPreCompPtr preComps;/* list of precomputed blocks */
1570     int warnings;       /* number of warnings found at compilation */
1571     int errors;         /* number of errors found at compilation */
1572 
1573     xmlChar  *exclPrefix;   /* last excluded prefixes */
1574     xmlChar **exclPrefixTab;    /* array of excluded prefixes */
1575     int       exclPrefixNr; /* number of excluded prefixes in scope */
1576     int       exclPrefixMax;    /* size of the array */
1577 
1578     void     *_private;     /* user defined data */
1579 
1580     /*
1581      * Extensions.
1582      */
1583     xmlHashTablePtr extInfos;   /* the extension data */
1584     int         extrasNr;   /* the number of extras required */
1585 
1586     /*
1587      * For keeping track of nested includes
1588      */
1589     xsltDocumentPtr includes;   /* points to last nested include */
1590 
1591     /*
1592      * dictionary: shared between stylesheet, context and documents.
1593      */
1594     xmlDictPtr dict;
1595     /*
1596      * precompiled attribute value templates.
1597      */
1598     void *attVTs;
1599     /*
1600      * if namespace-alias has an alias for the default stylesheet prefix
1601      * NOTE: Not used in the refactored code.
1602      */
1603     const xmlChar *defaultAlias;
1604     /*
1605      * bypass pre-processing (already done) (used in imports)
1606      */
1607     int nopreproc;
1608     /*
1609      * all document text strings were internalized
1610      */
1611     int internalized;
1612     /*
1613      * Literal Result Element as Stylesheet c.f. section 2.3
1614      */
1615     int literal_result;
1616     /*
1617     * The principal stylesheet
1618     */
1619     xsltStylesheetPtr principal;
1620 #ifdef XSLT_REFACTORED
1621     /*
1622     * Compilation context used during compile-time.
1623     */
1624     xsltCompilerCtxtPtr compCtxt; /* TODO: Change this to (void *). */
1625 
1626     xsltPrincipalStylesheetDataPtr principalData;
1627 #endif
1628     /*
1629      * Forwards-compatible processing
1630      */
1631     int forwards_compatible;
1632 
1633     xmlHashTablePtr namedTemplates; /* hash table of named templates */
1634 
1635     xmlXPathContextPtr xpathCtxt;
1636 };
1637 
1638 typedef struct _xsltTransformCache xsltTransformCache;
1639 typedef xsltTransformCache *xsltTransformCachePtr;
1640 struct _xsltTransformCache {
1641     xmlDocPtr RVT;
1642     int nbRVT;
1643     xsltStackElemPtr stackItems;
1644     int nbStackItems;
1645 #ifdef XSLT_DEBUG_PROFILE_CACHE
1646     int dbgCachedRVTs;
1647     int dbgReusedRVTs;
1648     int dbgCachedVars;
1649     int dbgReusedVars;
1650 #endif
1651 };
1652 
1653 /*
1654  * The in-memory structure corresponding to an XSLT Transformation.
1655  */
1656 typedef enum {
1657     XSLT_OUTPUT_XML = 0,
1658     XSLT_OUTPUT_HTML,
1659     XSLT_OUTPUT_TEXT
1660 } xsltOutputType;
1661 
1662 typedef enum {
1663     XSLT_STATE_OK = 0,
1664     XSLT_STATE_ERROR,
1665     XSLT_STATE_STOPPED
1666 } xsltTransformState;
1667 
1668 struct _xsltTransformContext {
1669     xsltStylesheetPtr style;        /* the stylesheet used */
1670     xsltOutputType type;        /* the type of output */
1671 
1672     xsltTemplatePtr  templ;     /* the current template */
1673     int              templNr;       /* Nb of templates in the stack */
1674     int              templMax;      /* Size of the templtes stack */
1675     xsltTemplatePtr *templTab;      /* the template stack */
1676 
1677     xsltStackElemPtr  vars;     /* the current variable list */
1678     int               varsNr;       /* Nb of variable list in the stack */
1679     int               varsMax;      /* Size of the variable list stack */
1680     xsltStackElemPtr *varsTab;      /* the variable list stack */
1681     int               varsBase;     /* the var base for current templ */
1682 
1683     /*
1684      * Extensions
1685      */
1686     xmlHashTablePtr   extFunctions; /* the extension functions */
1687     xmlHashTablePtr   extElements;  /* the extension elements */
1688     xmlHashTablePtr   extInfos;     /* the extension data */
1689 
1690     const xmlChar *mode;        /* the current mode */
1691     const xmlChar *modeURI;     /* the current mode URI */
1692 
1693     xsltDocumentPtr docList;        /* the document list */
1694 
1695     xsltDocumentPtr document;       /* the current source document; can be NULL if an RTF */
1696     xmlNodePtr node;            /* the current node being processed */
1697     xmlNodeSetPtr nodeList;     /* the current node list */
1698     /* xmlNodePtr current;          the node */
1699 
1700     xmlDocPtr output;           /* the resulting document */
1701     xmlNodePtr insert;          /* the insertion node */
1702 
1703     xmlXPathContextPtr xpathCtxt;   /* the XPath context */
1704     xsltTransformState state;       /* the current state */
1705 
1706     /*
1707      * Global variables
1708      */
1709     xmlHashTablePtr   globalVars;   /* the global variables and params */
1710 
1711     xmlNodePtr inst;            /* the instruction in the stylesheet */
1712 
1713     int xinclude;           /* should XInclude be processed */
1714 
1715     const char *      outputFile;   /* the output URI if known */
1716 
1717     int profile;                        /* is this run profiled */
1718     long             prof;      /* the current profiled value */
1719     int              profNr;        /* Nb of templates in the stack */
1720     int              profMax;       /* Size of the templtaes stack */
1721     long            *profTab;       /* the profile template stack */
1722 
1723     void            *_private;      /* user defined data */
1724 
1725     int              extrasNr;      /* the number of extras used */
1726     int              extrasMax;     /* the number of extras allocated */
1727     xsltRuntimeExtraPtr extras;     /* extra per runtime information */
1728 
1729     xsltDocumentPtr  styleList;     /* the stylesheet docs list */
1730     void                 * sec;     /* the security preferences if any */
1731 
1732     xmlGenericErrorFunc  error;     /* a specific error handler */
1733     void              * errctx;     /* context for the error handler */
1734 
1735     xsltSortFunc      sortfunc;     /* a ctxt specific sort routine */
1736 
1737     /*
1738      * handling of temporary Result Value Tree
1739      * (XSLT 1.0 term: &quot;Result Tree Fragment&quot;)
1740      */
1741     xmlDocPtr       tmpRVT;     /* list of RVT without persistance */
1742     xmlDocPtr       persistRVT;     /* list of persistant RVTs */
1743     int             ctxtflags;          /* context processing flags */
1744 
1745     /*
1746      * Speed optimization when coalescing text nodes
1747      */
1748     const xmlChar  *lasttext;       /* last text node content */
1749     int             lasttsize;      /* last text node size */
1750     int             lasttuse;       /* last text node use */
1751     /*
1752      * Per Context Debugging
1753      */
1754     int debugStatus;            /* the context level debug status */
1755     unsigned long* traceCode;       /* pointer to the variable holding the mask */
1756 
1757     int parserOptions;          /* parser options xmlParserOption */
1758 
1759     /*
1760      * dictionary: shared between stylesheet, context and documents.
1761      */
1762     xmlDictPtr dict;
1763     xmlDocPtr       tmpDoc; /* Obsolete; not used in the library. */
1764     /*
1765      * all document text strings are internalized
1766      */
1767     int internalized;
1768     int nbKeys;
1769     int hasTemplKeyPatterns;
1770     xsltTemplatePtr currentTemplateRule; /* the Current Template Rule */
1771     xmlNodePtr initialContextNode;
1772     xmlDocPtr initialContextDoc;
1773     xsltTransformCachePtr cache;
1774     void *contextVariable; /* the current variable item */
1775     xmlDocPtr localRVT; /* list of local tree fragments; will be freed when
1776                the instruction which created the fragment
1777                            exits */
1778     xmlDocPtr localRVTBase; /* Obsolete */
1779     int keyInitLevel;   /* Needed to catch recursive keys issues */
1780     int depth;          /* Needed to catch recursions */
1781     int maxTemplateDepth;
1782     int maxTemplateVars;
1783     unsigned long opLimit;
1784     unsigned long opCount;
1785 };
1786 
1787 /**
1788  * CHECK_STOPPED:
1789  *
1790  * Macro to check if the XSLT processing should be stopped.
1791  * Will return from the function.
1792  */
1793 #define CHECK_STOPPED if (ctxt-&gt;state == XSLT_STATE_STOPPED) return;
1794 
1795 /**
1796  * CHECK_STOPPEDE:
1797  *
1798  * Macro to check if the XSLT processing should be stopped.
1799  * Will goto the error: label.
1800  */
1801 #define CHECK_STOPPEDE if (ctxt-&gt;state == XSLT_STATE_STOPPED) goto error;
1802 
1803 /**
1804  * CHECK_STOPPED0:
1805  *
1806  * Macro to check if the XSLT processing should be stopped.
1807  * Will return from the function with a 0 value.
1808  */
1809 #define CHECK_STOPPED0 if (ctxt-&gt;state == XSLT_STATE_STOPPED) return(0);
1810 
1811 /*
1812  * The macro XML_CAST_FPTR is a hack to avoid a gcc warning about
1813  * possible incompatibilities between function pointers and object
1814  * pointers.  It is defined in libxml/hash.h within recent versions
1815  * of libxml2, but is put here for compatibility.
1816  */
1817 #ifndef XML_CAST_FPTR
1818 /**
1819  * XML_CAST_FPTR:
1820  * @fptr:  pointer to a function
1821  *
1822  * Macro to do a casting from an object pointer to a
1823  * function pointer without encountering a warning from
1824  * gcc
1825  *
1826  * #define XML_CAST_FPTR(fptr) (*(void **)(&amp;fptr))
1827  * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
1828  * so it is disabled now
1829  */
1830 
1831 #define XML_CAST_FPTR(fptr) fptr
1832 #endif
1833 /*
1834  * Functions associated to the internal types
1835 xsltDecimalFormatPtr    xsltDecimalFormatGetByName(xsltStylesheetPtr sheet,
1836                            xmlChar *name);
1837  */
1838 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1839             xsltNewStylesheet   (void);
1840 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1841             xsltParseStylesheetFile (const xmlChar* filename);
1842 XSLTPUBFUN void XSLTCALL
1843             xsltFreeStylesheet  (xsltStylesheetPtr style);
1844 XSLTPUBFUN int XSLTCALL
1845             xsltIsBlank     (xmlChar *str);
1846 XSLTPUBFUN void XSLTCALL
1847             xsltFreeStackElemList   (xsltStackElemPtr elem);
1848 XSLTPUBFUN xsltDecimalFormatPtr XSLTCALL
1849             xsltDecimalFormatGetByName(xsltStylesheetPtr style,
1850                          xmlChar *name);
1851 XSLTPUBFUN xsltDecimalFormatPtr XSLTCALL
1852             xsltDecimalFormatGetByQName(xsltStylesheetPtr style,
1853                          const xmlChar *nsUri,
1854                                                  const xmlChar *name);
1855 
1856 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1857             xsltParseStylesheetProcess(xsltStylesheetPtr ret,
1858                          xmlDocPtr doc);
1859 XSLTPUBFUN void XSLTCALL
1860             xsltParseStylesheetOutput(xsltStylesheetPtr style,
1861                          xmlNodePtr cur);
1862 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1863             xsltParseStylesheetDoc  (xmlDocPtr doc);
1864 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1865             xsltParseStylesheetImportedDoc(xmlDocPtr doc,
1866                         xsltStylesheetPtr style);
1867 XSLTPUBFUN int XSLTCALL
1868             xsltParseStylesheetUser(xsltStylesheetPtr style,
1869                         xmlDocPtr doc);
1870 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1871             xsltLoadStylesheetPI    (xmlDocPtr doc);
1872 XSLTPUBFUN void XSLTCALL
1873             xsltNumberFormat    (xsltTransformContextPtr ctxt,
1874                          xsltNumberDataPtr data,
1875                          xmlNodePtr node);
1876 XSLTPUBFUN xmlXPathError XSLTCALL
1877             xsltFormatNumberConversion(xsltDecimalFormatPtr self,
1878                          xmlChar *format,
1879                          double number,
1880                          xmlChar **result);
1881 
1882 XSLTPUBFUN void XSLTCALL
1883             xsltParseTemplateContent(xsltStylesheetPtr style,
1884                          xmlNodePtr templ);
1885 XSLTPUBFUN int XSLTCALL
1886             xsltAllocateExtra   (xsltStylesheetPtr style);
1887 XSLTPUBFUN int XSLTCALL
1888             xsltAllocateExtraCtxt   (xsltTransformContextPtr ctxt);
1889 /*
1890  * Extra functions for Result Value Trees
1891  */
1892 XSLTPUBFUN xmlDocPtr XSLTCALL
1893             xsltCreateRVT       (xsltTransformContextPtr ctxt);
1894 XSLTPUBFUN int XSLTCALL
1895             xsltRegisterTmpRVT  (xsltTransformContextPtr ctxt,
1896                          xmlDocPtr RVT);
1897 XSLTPUBFUN int XSLTCALL
1898             xsltRegisterLocalRVT    (xsltTransformContextPtr ctxt,
1899                          xmlDocPtr RVT);
1900 XSLTPUBFUN int XSLTCALL
1901             xsltRegisterPersistRVT  (xsltTransformContextPtr ctxt,
1902                          xmlDocPtr RVT);
1903 XSLTPUBFUN int XSLTCALL
1904             xsltExtensionInstructionResultRegister(
1905                          xsltTransformContextPtr ctxt,
1906                          xmlXPathObjectPtr obj);
1907 XSLTPUBFUN int XSLTCALL
1908             xsltExtensionInstructionResultFinalize(
1909                          xsltTransformContextPtr ctxt);
1910 XSLTPUBFUN int XSLTCALL
1911             xsltFlagRVTs(
1912                          xsltTransformContextPtr ctxt,
1913                          xmlXPathObjectPtr obj,
1914                          void *val);
1915 XSLTPUBFUN void XSLTCALL
1916             xsltFreeRVTs        (xsltTransformContextPtr ctxt);
1917 XSLTPUBFUN void XSLTCALL
1918             xsltReleaseRVT      (xsltTransformContextPtr ctxt,
1919                          xmlDocPtr RVT);
1920 /*
1921  * Extra functions for Attribute Value Templates
1922  */
1923 XSLTPUBFUN void XSLTCALL
1924             xsltCompileAttr     (xsltStylesheetPtr style,
1925                          xmlAttrPtr attr);
1926 XSLTPUBFUN xmlChar * XSLTCALL
1927             xsltEvalAVT     (xsltTransformContextPtr ctxt,
1928                          void *avt,
1929                          xmlNodePtr node);
1930 XSLTPUBFUN void XSLTCALL
1931             xsltFreeAVTList     (void *avt);
1932 
1933 /*
1934  * Extra function for successful xsltCleanupGlobals / xsltInit sequence.
1935  */
1936 
1937 XSLTPUBFUN void XSLTCALL
1938             xsltUninit      (void);
1939 
1940 /************************************************************************
1941  *                                  *
1942  *  Compile-time functions for *internal* use only                      *
1943  *                                  *
1944  ************************************************************************/
1945 
1946 #ifdef XSLT_REFACTORED
1947 XSLTPUBFUN void XSLTCALL
1948             xsltParseSequenceConstructor(
1949                          xsltCompilerCtxtPtr cctxt,
1950                          xmlNodePtr start);
1951 XSLTPUBFUN int XSLTCALL
1952             xsltParseAnyXSLTElem    (xsltCompilerCtxtPtr cctxt,
1953                          xmlNodePtr elem);
1954 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1955 XSLTPUBFUN int XSLTCALL
1956             xsltRestoreDocumentNamespaces(
1957                          xsltNsMapPtr ns,
1958                          xmlDocPtr doc);
1959 #endif
1960 #endif /* XSLT_REFACTORED */
1961 
1962 /************************************************************************
1963  *                                  *
1964  *  Transformation-time functions for *internal* use only               *
1965  *                                  *
1966  ************************************************************************/
1967 XSLTPUBFUN int XSLTCALL
1968             xsltInitCtxtKey     (xsltTransformContextPtr ctxt,
1969                          xsltDocumentPtr doc,
1970                          xsltKeyDefPtr keyd);
1971 XSLTPUBFUN int XSLTCALL
1972             xsltInitAllDocKeys  (xsltTransformContextPtr ctxt);
1973 #ifdef __cplusplus
1974 }
1975 #endif
1976 
1977 #endif /* __XML_XSLT_H__ */
1978 
    </pre>
  </body>
</html>