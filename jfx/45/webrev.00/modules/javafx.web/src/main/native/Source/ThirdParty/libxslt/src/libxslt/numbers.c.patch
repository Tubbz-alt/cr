diff a/modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c b/modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/numbers.c
@@ -34,20 +34,20 @@
 # define TRUE (1 == 1)
 #endif
 
 #define SYMBOL_QUOTE        ((xmlChar)'\'')
 
-#define DEFAULT_TOKEN       (xmlChar)'0'
+#define DEFAULT_TOKEN       '0'
 #define DEFAULT_SEPARATOR   "."
 
 #define MAX_TOKENS      1024
 
 typedef struct _xsltFormatToken xsltFormatToken;
 typedef xsltFormatToken *xsltFormatTokenPtr;
 struct _xsltFormatToken {
     xmlChar *separator;
-    xmlChar  token;
+    int      token;
     int      width;
 };
 
 typedef struct _xsltFormat xsltFormat;
 typedef xsltFormat *xsltFormatPtr;
@@ -105,24 +105,26 @@
      (xsltUTF8Charcmp((letter), (self)->decimalPoint) == 0)  || \
      (xsltUTF8Charcmp((letter), (self)->grouping) == 0)     ||  \
      (xsltUTF8Charcmp((letter), (self)->patternSeparator) == 0))
 
 #define IS_DIGIT_ZERO(x) xsltIsDigitZero(x)
-#define IS_DIGIT_ONE(x) xsltIsDigitZero((xmlChar)(x)-1)
+#define IS_DIGIT_ONE(x) xsltIsDigitZero((x)-1)
 
 static int
 xsltIsDigitZero(unsigned int ch)
 {
     /*
      * Reference: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
+     *
+     * There a many more digit ranges in newer Unicode versions. These
+     * are only the zeros that match Digit in XML 1.0 (IS_DIGIT macro).
      */
     switch (ch) {
     case 0x0030: case 0x0660: case 0x06F0: case 0x0966:
     case 0x09E6: case 0x0A66: case 0x0AE6: case 0x0B66:
     case 0x0C66: case 0x0CE6: case 0x0D66: case 0x0E50:
-    case 0x0E60: case 0x0F20: case 0x1040: case 0x17E0:
-    case 0x1810: case 0xFF10:
+    case 0x0ED0: case 0x0F20:
     return TRUE;
     default:
     return FALSE;
     }
 }
@@ -380,26 +382,29 @@
         }
         if (IS_DIGIT_ONE(val)) {
         tokens->tokens[tokens->nTokens].token = val - 1;
         ix += len;
         val = xmlStringCurrentChar(NULL, format+ix, &len);
-        }
-    } else if ( (val == (xmlChar)'A') ||
-            (val == (xmlChar)'a') ||
-            (val == (xmlChar)'I') ||
-            (val == (xmlChar)'i') ) {
+        } else {
+                tokens->tokens[tokens->nTokens].token = '0';
+                tokens->tokens[tokens->nTokens].width = 1;
+            }
+    } else if ( (val == 'A') ||
+            (val == 'a') ||
+            (val == 'I') ||
+            (val == 'i') ) {
         tokens->tokens[tokens->nTokens].token = val;
         ix += len;
         val = xmlStringCurrentChar(NULL, format+ix, &len);
     } else {
         /* XSLT section 7.7
          * "Any other format token indicates a numbering sequence
          *  that starts with that token. If an implementation does
          *  not support a numbering sequence that starts with that
          *  token, it must use a format token of 1."
          */
-        tokens->tokens[tokens->nTokens].token = (xmlChar)'0';
+        tokens->tokens[tokens->nTokens].token = '0';
         tokens->tokens[tokens->nTokens].width = 1;
     }
     /*
      * Skip over remaining alphanumeric characters from the Nd
      * (Number, decimal digit), Nl (Number, letter), No (Number,
@@ -644,46 +649,55 @@
                  double *array,
                  int max)
 {
     int amount = 0;
     int cnt;
+    xmlNodePtr oldCtxtNode;
     xmlNodePtr ancestor;
     xmlNodePtr preceding;
     xmlXPathParserContextPtr parser;
 
-    context->xpathCtxt->node = node;
+    oldCtxtNode = context->xpathCtxt->node;
     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
     if (parser) {
     /* ancestor-or-self::*[count] */
-    for (ancestor = node;
-         (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
-         ancestor = xmlXPathNextAncestor(parser, ancestor)) {
-
+    ancestor = node;
+    while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {
         if ((fromPat != NULL) &&
         xsltTestCompMatchList(context, ancestor, fromPat))
         break; /* for */
 
+            /*
+             * The xmlXPathNext* iterators require that the context node is
+             * set to the start node. Calls to xsltTestCompMatch* may also
+             * leave the context node in an undefined state, so make sure
+             * that the context node is reset before each iterator invocation.
+             */
+
         if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
         /* count(preceding-sibling::*) */
         cnt = 1;
-        for (preceding =
-                        xmlXPathNextPrecedingSibling(parser, ancestor);
-             preceding != NULL;
-             preceding =
-                xmlXPathNextPrecedingSibling(parser, preceding)) {
-
+                context->xpathCtxt->node = ancestor;
+                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);
+                while (preceding != NULL) {
                 if (xsltTestCompMatchCount(context, preceding, countPat,
                                                node))
             cnt++;
+                    context->xpathCtxt->node = ancestor;
+                    preceding =
+                        xmlXPathNextPrecedingSibling(parser, preceding);
         }
         array[amount++] = (double)cnt;
         if (amount >= max)
             break; /* for */
         }
+            context->xpathCtxt->node = node;
+            ancestor = xmlXPathNextAncestor(parser, ancestor);
     }
     xmlXPathFreeParserContext(parser);
     }
+    context->xpathCtxt->node = oldCtxtNode;
     return amount;
 }
 
 static int
 xsltNumberFormatGetValue(xmlXPathContextPtr context,
@@ -813,10 +827,20 @@
                           1,
                           &tokens,
                           output);
         }
     }
+
+        /*
+         * Unlike `match` patterns, `count` and `from` patterns can contain
+         * variable references, so we have to clear the pattern match
+         * cache if the "direct" matching algorithm was used.
+         */
+        if (data->countPat != NULL)
+            xsltCompMatchClearCache(ctxt, data->countPat);
+        if (data->fromPat != NULL)
+            xsltCompMatchClearCache(ctxt, data->fromPat);
     }
     /* Insert number as text node */
     xsltCopyTextString(ctxt, ctxt->insert, xmlBufferContent(output), 0);
 
     xmlBufferFree(output);
@@ -833,11 +857,12 @@
 }
 
 static int
 xsltFormatNumberPreSuffix(xsltDecimalFormatPtr self, xmlChar **format, xsltFormatNumberInfoPtr info)
 {
-    int count=0;    /* will hold total length of prefix/suffix */
+    /* will hold total length of prefix/suffix without quote characters */
+    int count=0;
     int len;
 
     while (1) {
     /*
      * prefix / suffix ends at end of string or at
@@ -931,11 +956,10 @@
 {
     xmlXPathError status = XPATH_EXPRESSION_OK;
     xmlBufferPtr buffer;
     xmlChar *the_format, *prefix = NULL, *suffix = NULL;
     xmlChar *nprefix, *nsuffix = NULL;
-    xmlChar pchar;
     int     prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
     double  scale;
     int     j, len;
     int     self_grouping_len;
     xsltFormatNumberInfo format_info;
@@ -959,11 +983,11 @@
     case -1:
         if (self->minusSign == NULL)
         *result = xmlStrdup(BAD_CAST "-");
         else
         *result = xmlStrdup(self->minusSign);
-        /* no-break on purpose */
+        /* Intentional fall-through */
     case 1:
         if ((self == NULL) || (self->infinity == NULL))
         *result = xmlStrcat(*result, BAD_CAST "Infinity");
         else
         *result = xmlStrcat(*result, self->infinity);
@@ -1256,33 +1280,33 @@
     /* Ready to output our number.  First see if "default sign" is required */
     if (default_sign != 0)
     xmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));
 
     /* Put the prefix into the buffer */
-    for (j = 0; j < prefix_length; j++) {
-    if ((pchar = *prefix++) == SYMBOL_QUOTE) {
+    for (j = 0; j < prefix_length; ) {
+    if (*prefix == SYMBOL_QUOTE)
+            prefix++;
         len = xmlUTF8Strsize(prefix, 1);
         xmlBufferAdd(buffer, prefix, len);
         prefix += len;
-        j += len - 1;   /* length of symbol less length of quote */
-    } else
-        xmlBufferAdd(buffer, &pchar, 1);
+        j += len;
     }
 
     /* Next do the integer part of the number */
     number = fabs(number) * (double)format_info.multiplier;
     scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
     number = floor((scale * number + 0.5)) / scale;
     if ((self->grouping != NULL) &&
         (self->grouping[0] != 0)) {
+        int gchar;
 
     len = xmlStrlen(self->grouping);
-    pchar = xsltGetUTF8Char(self->grouping, &len);
+    gchar = xsltGetUTF8Char(self->grouping, &len);
     xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
                 format_info.integer_digits,
                 format_info.group,
-                pchar, len);
+                gchar, len);
     } else
     xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
                 format_info.integer_digits,
                 format_info.group,
                 ',', 1);
@@ -1321,18 +1345,17 @@
                 format_info.frac_digits + j,
                 0, 0, 0);
     }
     }
     /* Put the suffix into the buffer */
-    for (j = 0; j < suffix_length; j++) {
-    if ((pchar = *suffix++) == SYMBOL_QUOTE) {
-            len = xmlUTF8Strsize(suffix, 1);
+    for (j = 0; j < suffix_length; ) {
+    if (*suffix == SYMBOL_QUOTE)
+            suffix++;
+        len = xmlUTF8Strsize(suffix, 1);
         xmlBufferAdd(buffer, suffix, len);
         suffix += len;
-        j += len - 1;   /* length of symbol less length of escape */
-    } else
-        xmlBufferAdd(buffer, &pchar, 1);
+        j += len;
     }
 
     *result = xmlStrdup(xmlBufferContent(buffer));
     xmlBufferFree(buffer);
     return status;
