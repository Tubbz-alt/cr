<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxslt/src/libxslt/xsltInternals.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Summary: internal data structures, constants and functions
   3  * Description: Internal data structures, constants and functions used
   4  *              by the XSLT engine.
   5  *              They are not part of the API or ABI, i.e. they can change
   6  *              without prior notice, use carefully.
   7  *
   8  * Copy: See Copyright for the status of this software.
   9  *
  10  * Author: Daniel Veillard
  11  */
  12 
  13 #ifndef __XML_XSLT_INTERNALS_H__
  14 #define __XML_XSLT_INTERNALS_H__
  15 
  16 #include &lt;libxml/tree.h&gt;
  17 #include &lt;libxml/hash.h&gt;
  18 #include &lt;libxml/xpath.h&gt;
  19 #include &lt;libxml/xmlerror.h&gt;
  20 #include &lt;libxml/dict.h&gt;
  21 #include &lt;libxml/xmlstring.h&gt;
  22 #include &lt;libxslt/xslt.h&gt;
  23 #include &quot;xsltexports.h&quot;
  24 #include &quot;xsltlocale.h&quot;
  25 #include &quot;numbersInternals.h&quot;
  26 
  27 #ifdef __cplusplus
  28 extern &quot;C&quot; {
  29 #endif
  30 
  31 /* #define XSLT_DEBUG_PROFILE_CACHE */
  32 
  33 /**
  34  * XSLT_IS_TEXT_NODE:
  35  *
  36  * check if the argument is a text node
  37  */
  38 #define XSLT_IS_TEXT_NODE(n) ((n != NULL) &amp;&amp; \
  39     (((n)-&gt;type == XML_TEXT_NODE) || \
  40      ((n)-&gt;type == XML_CDATA_SECTION_NODE)))
  41 
  42 
  43 /**
  44  * XSLT_MARK_RES_TREE_FRAG:
  45  *
  46  * internal macro to set up tree fragments
  47  */
  48 #define XSLT_MARK_RES_TREE_FRAG(n) \
  49     (n)-&gt;name = (char *) xmlStrdup(BAD_CAST &quot; fake node libxslt&quot;);
  50 
  51 /**
  52  * XSLT_IS_RES_TREE_FRAG:
  53  *
  54  * internal macro to test tree fragments
  55  */
  56 #define XSLT_IS_RES_TREE_FRAG(n) \
  57     ((n != NULL) &amp;&amp; ((n)-&gt;type == XML_DOCUMENT_NODE) &amp;&amp; \
  58      ((n)-&gt;name != NULL) &amp;&amp; ((n)-&gt;name[0] == &#39; &#39;))
  59 
  60 /**
  61  * XSLT_REFACTORED_KEYCOMP:
  62  *
  63  * Internal define to enable on-demand xsl:key computation.
  64  * That&#39;s the only mode now but the define is kept for compatibility
  65  */
  66 #define XSLT_REFACTORED_KEYCOMP
  67 
  68 /**
  69  * XSLT_FAST_IF:
  70  *
  71  * Internal define to enable usage of xmlXPathCompiledEvalToBoolean()
  72  * for XSLT &quot;tests&quot;; e.g. in &lt;xsl:if test=&quot;/foo/bar&quot;&gt;
  73  */
  74 #define XSLT_FAST_IF
  75 
  76 /**
  77  * XSLT_REFACTORED:
  78  *
  79  * Internal define to enable the refactored parts of Libxslt.
  80  */
  81 /* #define XSLT_REFACTORED */
  82 /* ==================================================================== */
  83 
  84 /**
  85  * XSLT_REFACTORED_VARS:
  86  *
  87  * Internal define to enable the refactored variable part of libxslt
  88  */
  89 #define XSLT_REFACTORED_VARS
  90 
  91 #ifdef XSLT_REFACTORED
  92 
  93 extern const xmlChar *xsltXSLTAttrMarker;
  94 
  95 
  96 /* TODO: REMOVE: #define XSLT_REFACTORED_EXCLRESNS */
  97 
  98 /* TODO: REMOVE: #define XSLT_REFACTORED_NSALIAS */
  99 
 100 /**
 101  * XSLT_REFACTORED_XSLT_NSCOMP
 102  *
 103  * Internal define to enable the pointer-comparison of
 104  * namespaces of XSLT elements.
 105  */
 106 /* #define XSLT_REFACTORED_XSLT_NSCOMP */
 107 
 108 /**
 109  * XSLT_REFACTORED_XPATHCOMP:
 110  *
 111  * Internal define to enable the optimization of the
 112  * compilation of XPath expressions.
 113  */
 114 #define XSLT_REFACTORED_XPATHCOMP
 115 
 116 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
 117 
 118 extern const xmlChar *xsltConstNamespaceNameXSLT;
 119 
 120 /**
 121  * IS_XSLT_ELEM_FAST:
 122  *
 123  * quick test to detect XSLT elements
 124  */
 125 #define IS_XSLT_ELEM_FAST(n) \
 126     (((n) != NULL) &amp;&amp; ((n)-&gt;ns != NULL) &amp;&amp; \
 127     ((n)-&gt;ns-&gt;href == xsltConstNamespaceNameXSLT))
 128 
 129 /**
 130  * IS_XSLT_ATTR_FAST:
 131  *
 132  * quick test to detect XSLT attributes
 133  */
 134 #define IS_XSLT_ATTR_FAST(a) \
 135     (((a) != NULL) &amp;&amp; ((a)-&gt;ns != NULL) &amp;&amp; \
 136     ((a)-&gt;ns-&gt;href == xsltConstNamespaceNameXSLT))
 137 
 138 /**
 139  * XSLT_HAS_INTERNAL_NSMAP:
 140  *
 141  * check for namespace mapping
 142  */
 143 #define XSLT_HAS_INTERNAL_NSMAP(s) \
 144     (((s) != NULL) &amp;&amp; ((s)-&gt;principal) &amp;&amp; \
 145      ((s)-&gt;principal-&gt;principalData) &amp;&amp; \
 146      ((s)-&gt;principal-&gt;principalData-&gt;nsMap))
 147 
 148 /**
 149  * XSLT_GET_INTERNAL_NSMAP:
 150  *
 151  * get pointer to namespace map
 152  */
 153 #define XSLT_GET_INTERNAL_NSMAP(s) ((s)-&gt;principal-&gt;principalData-&gt;nsMap)
 154 
 155 #else /* XSLT_REFACTORED_XSLT_NSCOMP */
 156 
 157 /**
 158  * IS_XSLT_ELEM_FAST:
 159  *
 160  * quick check whether this is an xslt element
 161  */
 162 #define IS_XSLT_ELEM_FAST(n) \
 163     (((n) != NULL) &amp;&amp; ((n)-&gt;ns != NULL) &amp;&amp; \
 164      (xmlStrEqual((n)-&gt;ns-&gt;href, XSLT_NAMESPACE)))
 165 
 166 /**
 167  * IS_XSLT_ATTR_FAST:
 168  *
 169  * quick check for xslt namespace attribute
 170  */
 171 #define IS_XSLT_ATTR_FAST(a) \
 172     (((a) != NULL) &amp;&amp; ((a)-&gt;ns != NULL) &amp;&amp; \
 173      (xmlStrEqual((a)-&gt;ns-&gt;href, XSLT_NAMESPACE)))
 174 
 175 
 176 #endif /* XSLT_REFACTORED_XSLT_NSCOMP */
 177 
 178 
 179 /**
 180  * XSLT_REFACTORED_MANDATORY_VERSION:
 181  *
 182  * TODO: Currently disabled to surpress regression test failures, since
 183  *  the old behaviour was that a missing version attribute
 184  *  produced a only a warning and not an error, which was incerrect.
 185  *  So the regression tests need to be fixed if this is enabled.
 186  */
 187 /* #define XSLT_REFACTORED_MANDATORY_VERSION */
 188 
 189 /**
 190  * xsltPointerList:
 191  *
 192  * Pointer-list for various purposes.
 193  */
 194 typedef struct _xsltPointerList xsltPointerList;
 195 typedef xsltPointerList *xsltPointerListPtr;
 196 struct _xsltPointerList {
 197     void **items;
 198     int number;
 199     int size;
 200 };
 201 
 202 #endif
 203 
 204 /**
 205  * XSLT_REFACTORED_PARSING:
 206  *
 207  * Internal define to enable the refactored parts of Libxslt
 208  * related to parsing.
 209  */
 210 /* #define XSLT_REFACTORED_PARSING */
 211 
 212 /**
 213  * XSLT_MAX_SORT:
 214  *
 215  * Max number of specified xsl:sort on an element.
 216  */
 217 #define XSLT_MAX_SORT 15
 218 
 219 /**
 220  * XSLT_PAT_NO_PRIORITY:
 221  *
 222  * Specific value for pattern without priority expressed.
 223  */
 224 #define XSLT_PAT_NO_PRIORITY -12345789
 225 
 226 /**
 227  * xsltRuntimeExtra:
 228  *
 229  * Extra information added to the transformation context.
 230  */
 231 typedef struct _xsltRuntimeExtra xsltRuntimeExtra;
 232 typedef xsltRuntimeExtra *xsltRuntimeExtraPtr;
 233 struct _xsltRuntimeExtra {
 234     void       *info;       /* pointer to the extra data */
 235     xmlFreeFunc deallocate; /* pointer to the deallocation routine */
 236     union {         /* dual-purpose field */
 237         void   *ptr;        /* data not needing deallocation */
 238     int    ival;        /* integer value storage */
 239     } val;
 240 };
 241 
 242 /**
 243  * XSLT_RUNTIME_EXTRA_LST:
 244  * @ctxt: the transformation context
 245  * @nr: the index
 246  *
 247  * Macro used to access extra information stored in the context
 248  */
 249 #define XSLT_RUNTIME_EXTRA_LST(ctxt, nr) (ctxt)-&gt;extras[(nr)].info
 250 /**
 251  * XSLT_RUNTIME_EXTRA_FREE:
 252  * @ctxt: the transformation context
 253  * @nr: the index
 254  *
 255  * Macro used to free extra information stored in the context
 256  */
 257 #define XSLT_RUNTIME_EXTRA_FREE(ctxt, nr) (ctxt)-&gt;extras[(nr)].deallocate
 258 /**
 259  * XSLT_RUNTIME_EXTRA:
 260  * @ctxt: the transformation context
 261  * @nr: the index
 262  *
 263  * Macro used to define extra information stored in the context
 264  */
 265 #define XSLT_RUNTIME_EXTRA(ctxt, nr, typ) (ctxt)-&gt;extras[(nr)].val.typ
 266 
 267 /**
 268  * xsltTemplate:
 269  *
 270  * The in-memory structure corresponding to an XSLT Template.
 271  */
 272 typedef struct _xsltTemplate xsltTemplate;
 273 typedef xsltTemplate *xsltTemplatePtr;
 274 struct _xsltTemplate {
 275     struct _xsltTemplate *next;/* chained list sorted by priority */
 276     struct _xsltStylesheet *style;/* the containing stylesheet */
 277     xmlChar *match; /* the matching string */
 278     float priority; /* as given from the stylesheet, not computed */
 279     const xmlChar *name; /* the local part of the name QName */
 280     const xmlChar *nameURI; /* the URI part of the name QName */
 281     const xmlChar *mode;/* the local part of the mode QName */
 282     const xmlChar *modeURI;/* the URI part of the mode QName */
 283     xmlNodePtr content; /* the template replacement value */
 284     xmlNodePtr elem;    /* the source element */
 285 
 286     /*
 287     * TODO: @inheritedNsNr and @inheritedNs won&#39;t be used in the
 288     *  refactored code.
 289     */
 290     int inheritedNsNr;  /* number of inherited namespaces */
 291     xmlNsPtr *inheritedNs;/* inherited non-excluded namespaces */
 292 
 293     /* Profiling information */
 294     int nbCalls;        /* the number of time the template was called */
 295     unsigned long time; /* the time spent in this template */
 296     void *params;       /* xsl:param instructions */
 297 
 298     int              templNr;       /* Nb of templates in the stack */
 299     int              templMax;      /* Size of the templtes stack */
 300     xsltTemplatePtr *templCalledTab;    /* templates called */
 301     int             *templCountTab;  /* .. and how often */
 302 };
 303 
 304 /**
 305  * xsltDecimalFormat:
 306  *
 307  * Data structure of decimal-format.
 308  */
 309 typedef struct _xsltDecimalFormat xsltDecimalFormat;
 310 typedef xsltDecimalFormat *xsltDecimalFormatPtr;
 311 struct _xsltDecimalFormat {
 312     struct _xsltDecimalFormat *next; /* chained list */
 313     xmlChar *name;
 314     /* Used for interpretation of pattern */
 315     xmlChar *digit;
 316     xmlChar *patternSeparator;
 317     /* May appear in result */
 318     xmlChar *minusSign;
 319     xmlChar *infinity;
 320     xmlChar *noNumber; /* Not-a-number */
 321     /* Used for interpretation of pattern and may appear in result */
 322     xmlChar *decimalPoint;
 323     xmlChar *grouping;
 324     xmlChar *percent;
 325     xmlChar *permille;
 326     xmlChar *zeroDigit;
 327     const xmlChar *nsUri;
 328 };
 329 
 330 /**
 331  * xsltDocument:
 332  *
 333  * Data structure associated to a parsed document.
 334  */
 335 typedef struct _xsltDocument xsltDocument;
 336 typedef xsltDocument *xsltDocumentPtr;
 337 struct _xsltDocument {
 338     struct _xsltDocument *next; /* documents are kept in a chained list */
 339     int main;           /* is this the main document */
 340     xmlDocPtr doc;      /* the parsed document */
 341     void *keys;         /* key tables storage */
 342     struct _xsltDocument *includes; /* subsidiary includes */
 343     int preproc;        /* pre-processing already done */
 344     int nbKeysComputed;
 345 };
 346 
 347 /**
 348  * xsltKeyDef:
 349  *
 350  * Representation of an xsl:key.
 351  */
 352 typedef struct _xsltKeyDef xsltKeyDef;
 353 typedef xsltKeyDef *xsltKeyDefPtr;
 354 struct _xsltKeyDef {
 355     struct _xsltKeyDef *next;
 356     xmlNodePtr inst;
 357     xmlChar *name;
 358     xmlChar *nameURI;
 359     xmlChar *match;
 360     xmlChar *use;
 361     xmlXPathCompExprPtr comp;
 362     xmlXPathCompExprPtr usecomp;
 363     xmlNsPtr *nsList;           /* the namespaces in scope */
 364     int nsNr;                   /* the number of namespaces in scope */
 365 };
 366 
 367 /**
 368  * xsltKeyTable:
 369  *
 370  * Holds the computed keys for key definitions of the same QName.
 371  * Is owned by an xsltDocument.
 372  */
 373 typedef struct _xsltKeyTable xsltKeyTable;
 374 typedef xsltKeyTable *xsltKeyTablePtr;
 375 struct _xsltKeyTable {
 376     struct _xsltKeyTable *next;
 377     xmlChar *name;
 378     xmlChar *nameURI;
 379     xmlHashTablePtr keys;
 380 };
 381 
 382 /*
 383  * The in-memory structure corresponding to an XSLT Stylesheet.
 384  * NOTE: most of the content is simply linked from the doc tree
 385  *       structure, no specific allocation is made.
 386  */
 387 typedef struct _xsltStylesheet xsltStylesheet;
 388 typedef xsltStylesheet *xsltStylesheetPtr;
 389 
 390 typedef struct _xsltTransformContext xsltTransformContext;
 391 typedef xsltTransformContext *xsltTransformContextPtr;
 392 
 393 /**
 394  * xsltElemPreComp:
 395  *
 396  * The in-memory structure corresponding to element precomputed data,
 397  * designed to be extended by extension implementors.
 398  */
 399 typedef struct _xsltElemPreComp xsltElemPreComp;
 400 typedef xsltElemPreComp *xsltElemPreCompPtr;
 401 
 402 /**
 403  * xsltTransformFunction:
 404  * @ctxt: the XSLT transformation context
 405  * @node: the input node
 406  * @inst: the stylesheet node
 407  * @comp: the compiled information from the stylesheet
 408  *
 409  * Signature of the function associated to elements part of the
 410  * stylesheet language like xsl:if or xsl:apply-templates.
 411  */
 412 typedef void (*xsltTransformFunction) (xsltTransformContextPtr ctxt,
 413                                    xmlNodePtr node,
 414                        xmlNodePtr inst,
 415                            xsltElemPreCompPtr comp);
 416 
 417 /**
 418  * xsltSortFunc:
 419  * @ctxt:    a transformation context
 420  * @sorts:   the node-set to sort
 421  * @nbsorts: the number of sorts
 422  *
 423  * Signature of the function to use during sorting
 424  */
 425 typedef void (*xsltSortFunc) (xsltTransformContextPtr ctxt, xmlNodePtr *sorts,
 426                   int nbsorts);
 427 
 428 typedef enum {
 429     XSLT_FUNC_COPY=1,
 430     XSLT_FUNC_SORT,
 431     XSLT_FUNC_TEXT,
 432     XSLT_FUNC_ELEMENT,
 433     XSLT_FUNC_ATTRIBUTE,
 434     XSLT_FUNC_COMMENT,
 435     XSLT_FUNC_PI,
 436     XSLT_FUNC_COPYOF,
 437     XSLT_FUNC_VALUEOF,
 438     XSLT_FUNC_NUMBER,
 439     XSLT_FUNC_APPLYIMPORTS,
 440     XSLT_FUNC_CALLTEMPLATE,
 441     XSLT_FUNC_APPLYTEMPLATES,
 442     XSLT_FUNC_CHOOSE,
 443     XSLT_FUNC_IF,
 444     XSLT_FUNC_FOREACH,
 445     XSLT_FUNC_DOCUMENT,
 446     XSLT_FUNC_WITHPARAM,
 447     XSLT_FUNC_PARAM,
 448     XSLT_FUNC_VARIABLE,
 449     XSLT_FUNC_WHEN,
 450     XSLT_FUNC_EXTENSION
 451 #ifdef XSLT_REFACTORED
 452     ,
 453     XSLT_FUNC_OTHERWISE,
 454     XSLT_FUNC_FALLBACK,
 455     XSLT_FUNC_MESSAGE,
 456     XSLT_FUNC_INCLUDE,
 457     XSLT_FUNC_ATTRSET,
 458     XSLT_FUNC_LITERAL_RESULT_ELEMENT,
 459     XSLT_FUNC_UNKOWN_FORWARDS_COMPAT
 460 #endif
 461 } xsltStyleType;
 462 
 463 /**
 464  * xsltElemPreCompDeallocator:
 465  * @comp:  the #xsltElemPreComp to free up
 466  *
 467  * Deallocates an #xsltElemPreComp structure.
 468  */
 469 typedef void (*xsltElemPreCompDeallocator) (xsltElemPreCompPtr comp);
 470 
 471 /**
 472  * xsltElemPreComp:
 473  *
 474  * The basic structure for compiled items of the AST of the XSLT processor.
 475  * This structure is also intended to be extended by extension implementors.
 476  * TODO: This is somehow not nice, since it has a &quot;free&quot; field, which
 477  *   derived stylesheet-structs do not have.
 478  */
 479 struct _xsltElemPreComp {
 480     xsltElemPreCompPtr next;        /* next item in the global chained
 481                        list hold by xsltStylesheet. */
 482     xsltStyleType type;     /* type of the element */
 483     xsltTransformFunction func; /* handling function */
 484     xmlNodePtr inst;            /* the node in the stylesheet&#39;s tree
 485                        corresponding to this item */
 486 
 487     /* end of common part */
 488     xsltElemPreCompDeallocator free;    /* the deallocator */
 489 };
 490 
 491 /**
 492  * xsltStylePreComp:
 493  *
 494  * The abstract basic structure for items of the XSLT processor.
 495  * This includes:
 496  * 1) compiled forms of XSLT instructions (xsl:if, xsl:attribute, etc.)
 497  * 2) compiled forms of literal result elements
 498  * 3) compiled forms of extension elements
 499  */
 500 typedef struct _xsltStylePreComp xsltStylePreComp;
 501 typedef xsltStylePreComp *xsltStylePreCompPtr;
 502 
 503 #ifdef XSLT_REFACTORED
 504 
 505 /*
 506 * Some pointer-list utility functions.
 507 */
 508 XSLTPUBFUN xsltPointerListPtr XSLTCALL
 509         xsltPointerListCreate       (int initialSize);
 510 XSLTPUBFUN void XSLTCALL
 511         xsltPointerListFree     (xsltPointerListPtr list);
 512 XSLTPUBFUN void XSLTCALL
 513         xsltPointerListClear        (xsltPointerListPtr list);
 514 XSLTPUBFUN int XSLTCALL
 515         xsltPointerListAddSize      (xsltPointerListPtr list,
 516                          void *item,
 517                          int initialSize);
 518 
 519 /************************************************************************
 520  *                                  *
 521  * Refactored structures                                                *
 522  *                                  *
 523  ************************************************************************/
 524 
 525 typedef struct _xsltNsListContainer xsltNsListContainer;
 526 typedef xsltNsListContainer *xsltNsListContainerPtr;
 527 struct _xsltNsListContainer {
 528     xmlNsPtr *list;
 529     int totalNumber;
 530     int xpathNumber;
 531 };
 532 
 533 /**
 534  * XSLT_ITEM_COMPATIBILITY_FIELDS:
 535  *
 536  * Fields for API compatibility to the structure
 537  * _xsltElemPreComp which is used for extension functions.
 538  * Note that @next is used for storage; it does not reflect a next
 539  * sibling in the tree.
 540  * TODO: Evaluate if we really need such a compatibility.
 541  */
 542 #define XSLT_ITEM_COMPATIBILITY_FIELDS \
 543     xsltElemPreCompPtr next;\
 544     xsltStyleType type;\
 545     xsltTransformFunction func;\
 546     xmlNodePtr inst;
 547 
 548 /**
 549  * XSLT_ITEM_NAVIGATION_FIELDS:
 550  *
 551  * Currently empty.
 552  * TODO: It is intended to hold navigational fields in the future.
 553  */
 554 #define XSLT_ITEM_NAVIGATION_FIELDS
 555 /*
 556     xsltStylePreCompPtr parent;\
 557     xsltStylePreCompPtr children;\
 558     xsltStylePreCompPtr nextItem;
 559 */
 560 
 561 /**
 562  * XSLT_ITEM_NSINSCOPE_FIELDS:
 563  *
 564  * The in-scope namespaces.
 565  */
 566 #define XSLT_ITEM_NSINSCOPE_FIELDS xsltNsListContainerPtr inScopeNs;
 567 
 568 /**
 569  * XSLT_ITEM_COMMON_FIELDS:
 570  *
 571  * Common fields used for all items.
 572  */
 573 #define XSLT_ITEM_COMMON_FIELDS \
 574     XSLT_ITEM_COMPATIBILITY_FIELDS \
 575     XSLT_ITEM_NAVIGATION_FIELDS \
 576     XSLT_ITEM_NSINSCOPE_FIELDS
 577 
 578 /**
 579  * _xsltStylePreComp:
 580  *
 581  * The abstract basic structure for items of the XSLT processor.
 582  * This includes:
 583  * 1) compiled forms of XSLT instructions (e.g. xsl:if, xsl:attribute, etc.)
 584  * 2) compiled forms of literal result elements
 585  * 3) various properties for XSLT instructions (e.g. xsl:when,
 586  *    xsl:with-param)
 587  *
 588  * REVISIT TODO: Keep this structure equal to the fields
 589  *   defined by XSLT_ITEM_COMMON_FIELDS
 590  */
 591 struct _xsltStylePreComp {
 592     xsltElemPreCompPtr next;    /* next item in the global chained
 593                    list hold by xsltStylesheet */
 594     xsltStyleType type;         /* type of the item */
 595     xsltTransformFunction func; /* handling function */
 596     xmlNodePtr inst;        /* the node in the stylesheet&#39;s tree
 597                    corresponding to this item. */
 598     /* Currently no navigational fields. */
 599     xsltNsListContainerPtr inScopeNs;
 600 };
 601 
 602 /**
 603  * xsltStyleBasicEmptyItem:
 604  *
 605  * Abstract structure only used as a short-cut for
 606  * XSLT items with no extra fields.
 607  * NOTE that it is intended that this structure looks the same as
 608  *  _xsltStylePreComp.
 609  */
 610 typedef struct _xsltStyleBasicEmptyItem xsltStyleBasicEmptyItem;
 611 typedef xsltStyleBasicEmptyItem *xsltStyleBasicEmptyItemPtr;
 612 
 613 struct _xsltStyleBasicEmptyItem {
 614     XSLT_ITEM_COMMON_FIELDS
 615 };
 616 
 617 /**
 618  * xsltStyleBasicExpressionItem:
 619  *
 620  * Abstract structure only used as a short-cut for
 621  * XSLT items with just an expression.
 622  */
 623 typedef struct _xsltStyleBasicExpressionItem xsltStyleBasicExpressionItem;
 624 typedef xsltStyleBasicExpressionItem *xsltStyleBasicExpressionItemPtr;
 625 
 626 struct _xsltStyleBasicExpressionItem {
 627     XSLT_ITEM_COMMON_FIELDS
 628 
 629     const xmlChar *select; /* TODO: Change this to &quot;expression&quot;. */
 630     xmlXPathCompExprPtr comp; /* TODO: Change this to compExpr. */
 631 };
 632 
 633 /************************************************************************
 634  *                                  *
 635  * XSLT-instructions/declarations                                       *
 636  *                                  *
 637  ************************************************************************/
 638 
 639 /**
 640  * xsltStyleItemElement:
 641  *
 642  * &lt;!-- Category: instruction --&gt;
 643  * &lt;xsl:element
 644  *  name = { qname }
 645  *  namespace = { uri-reference }
 646  *  use-attribute-sets = qnames&gt;
 647  *  &lt;!-- Content: template --&gt;
 648  * &lt;/xsl:element&gt;
 649  */
 650 typedef struct _xsltStyleItemElement xsltStyleItemElement;
 651 typedef xsltStyleItemElement *xsltStyleItemElementPtr;
 652 
 653 struct _xsltStyleItemElement {
 654     XSLT_ITEM_COMMON_FIELDS
 655 
 656     const xmlChar *use;
 657     int      has_use;
 658     const xmlChar *name;
 659     int      has_name;
 660     const xmlChar *ns;
 661     const xmlChar *nsPrefix;
 662     int      has_ns;
 663 };
 664 
 665 /**
 666  * xsltStyleItemAttribute:
 667  *
 668  * &lt;!-- Category: instruction --&gt;
 669  * &lt;xsl:attribute
 670  *  name = { qname }
 671  *  namespace = { uri-reference }&gt;
 672  *  &lt;!-- Content: template --&gt;
 673  * &lt;/xsl:attribute&gt;
 674  */
 675 typedef struct _xsltStyleItemAttribute xsltStyleItemAttribute;
 676 typedef xsltStyleItemAttribute *xsltStyleItemAttributePtr;
 677 
 678 struct _xsltStyleItemAttribute {
 679     XSLT_ITEM_COMMON_FIELDS
 680     const xmlChar *name;
 681     int      has_name;
 682     const xmlChar *ns;
 683     const xmlChar *nsPrefix;
 684     int      has_ns;
 685 };
 686 
 687 /**
 688  * xsltStyleItemText:
 689  *
 690  * &lt;!-- Category: instruction --&gt;
 691  * &lt;xsl:text
 692  *  disable-output-escaping = &quot;yes&quot; | &quot;no&quot;&gt;
 693  *  &lt;!-- Content: #PCDATA --&gt;
 694  * &lt;/xsl:text&gt;
 695  */
 696 typedef struct _xsltStyleItemText xsltStyleItemText;
 697 typedef xsltStyleItemText *xsltStyleItemTextPtr;
 698 
 699 struct _xsltStyleItemText {
 700     XSLT_ITEM_COMMON_FIELDS
 701     int      noescape;      /* text */
 702 };
 703 
 704 /**
 705  * xsltStyleItemComment:
 706  *
 707  * &lt;!-- Category: instruction --&gt;
 708  *  &lt;xsl:comment&gt;
 709  *  &lt;!-- Content: template --&gt;
 710  * &lt;/xsl:comment&gt;
 711  */
 712 typedef xsltStyleBasicEmptyItem xsltStyleItemComment;
 713 typedef xsltStyleItemComment *xsltStyleItemCommentPtr;
 714 
 715 /**
 716  * xsltStyleItemPI:
 717  *
 718  * &lt;!-- Category: instruction --&gt;
 719  *  &lt;xsl:processing-instruction
 720  *  name = { ncname }&gt;
 721  *  &lt;!-- Content: template --&gt;
 722  * &lt;/xsl:processing-instruction&gt;
 723  */
 724 typedef struct _xsltStyleItemPI xsltStyleItemPI;
 725 typedef xsltStyleItemPI *xsltStyleItemPIPtr;
 726 
 727 struct _xsltStyleItemPI {
 728     XSLT_ITEM_COMMON_FIELDS
 729     const xmlChar *name;
 730     int      has_name;
 731 };
 732 
 733 /**
 734  * xsltStyleItemApplyImports:
 735  *
 736  * &lt;!-- Category: instruction --&gt;
 737  * &lt;xsl:apply-imports /&gt;
 738  */
 739 typedef xsltStyleBasicEmptyItem xsltStyleItemApplyImports;
 740 typedef xsltStyleItemApplyImports *xsltStyleItemApplyImportsPtr;
 741 
 742 /**
 743  * xsltStyleItemApplyTemplates:
 744  *
 745  * &lt;!-- Category: instruction --&gt;
 746  *  &lt;xsl:apply-templates
 747  *  select = node-set-expression
 748  *  mode = qname&gt;
 749  *  &lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt;
 750  * &lt;/xsl:apply-templates&gt;
 751  */
 752 typedef struct _xsltStyleItemApplyTemplates xsltStyleItemApplyTemplates;
 753 typedef xsltStyleItemApplyTemplates *xsltStyleItemApplyTemplatesPtr;
 754 
 755 struct _xsltStyleItemApplyTemplates {
 756     XSLT_ITEM_COMMON_FIELDS
 757 
 758     const xmlChar *mode;    /* apply-templates */
 759     const xmlChar *modeURI; /* apply-templates */
 760     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
 761     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 762     /* TODO: with-params */
 763 };
 764 
 765 /**
 766  * xsltStyleItemCallTemplate:
 767  *
 768  * &lt;!-- Category: instruction --&gt;
 769  *  &lt;xsl:call-template
 770  *  name = qname&gt;
 771  *  &lt;!-- Content: xsl:with-param* --&gt;
 772  * &lt;/xsl:call-template&gt;
 773  */
 774 typedef struct _xsltStyleItemCallTemplate xsltStyleItemCallTemplate;
 775 typedef xsltStyleItemCallTemplate *xsltStyleItemCallTemplatePtr;
 776 
 777 struct _xsltStyleItemCallTemplate {
 778     XSLT_ITEM_COMMON_FIELDS
 779 
 780     xsltTemplatePtr templ;  /* call-template */
 781     const xmlChar *name;    /* element, attribute, pi */
 782     int      has_name;      /* element, attribute, pi */
 783     const xmlChar *ns;      /* element */
 784     int      has_ns;        /* element */
 785     /* TODO: with-params */
 786 };
 787 
 788 /**
 789  * xsltStyleItemCopy:
 790  *
 791  * &lt;!-- Category: instruction --&gt;
 792  * &lt;xsl:copy
 793  *  use-attribute-sets = qnames&gt;
 794  *  &lt;!-- Content: template --&gt;
 795  * &lt;/xsl:copy&gt;
 796  */
 797 typedef struct _xsltStyleItemCopy xsltStyleItemCopy;
 798 typedef xsltStyleItemCopy *xsltStyleItemCopyPtr;
 799 
 800 struct _xsltStyleItemCopy {
 801    XSLT_ITEM_COMMON_FIELDS
 802     const xmlChar *use;     /* copy, element */
 803     int      has_use;       /* copy, element */
 804 };
 805 
 806 /**
 807  * xsltStyleItemIf:
 808  *
 809  * &lt;!-- Category: instruction --&gt;
 810  *  &lt;xsl:if
 811  *  test = boolean-expression&gt;
 812  *  &lt;!-- Content: template --&gt;
 813  * &lt;/xsl:if&gt;
 814  */
 815 typedef struct _xsltStyleItemIf xsltStyleItemIf;
 816 typedef xsltStyleItemIf *xsltStyleItemIfPtr;
 817 
 818 struct _xsltStyleItemIf {
 819     XSLT_ITEM_COMMON_FIELDS
 820 
 821     const xmlChar *test;    /* if */
 822     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 823 };
 824 
 825 
 826 /**
 827  * xsltStyleItemCopyOf:
 828  *
 829  * &lt;!-- Category: instruction --&gt;
 830  * &lt;xsl:copy-of
 831  *  select = expression /&gt;
 832  */
 833 typedef xsltStyleBasicExpressionItem xsltStyleItemCopyOf;
 834 typedef xsltStyleItemCopyOf *xsltStyleItemCopyOfPtr;
 835 
 836 /**
 837  * xsltStyleItemValueOf:
 838  *
 839  * &lt;!-- Category: instruction --&gt;
 840  * &lt;xsl:value-of
 841  *  select = string-expression
 842  *  disable-output-escaping = &quot;yes&quot; | &quot;no&quot; /&gt;
 843  */
 844 typedef struct _xsltStyleItemValueOf xsltStyleItemValueOf;
 845 typedef xsltStyleItemValueOf *xsltStyleItemValueOfPtr;
 846 
 847 struct _xsltStyleItemValueOf {
 848     XSLT_ITEM_COMMON_FIELDS
 849 
 850     const xmlChar *select;
 851     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
 852     int      noescape;
 853 };
 854 
 855 /**
 856  * xsltStyleItemNumber:
 857  *
 858  * &lt;!-- Category: instruction --&gt;
 859  *  &lt;xsl:number
 860  *  level = &quot;single&quot; | &quot;multiple&quot; | &quot;any&quot;
 861  *  count = pattern
 862  *  from = pattern
 863  *  value = number-expression
 864  *  format = { string }
 865  *  lang = { nmtoken }
 866  *  letter-value = { &quot;alphabetic&quot; | &quot;traditional&quot; }
 867  *  grouping-separator = { char }
 868  *  grouping-size = { number } /&gt;
 869  */
 870 typedef struct _xsltStyleItemNumber xsltStyleItemNumber;
 871 typedef xsltStyleItemNumber *xsltStyleItemNumberPtr;
 872 
 873 struct _xsltStyleItemNumber {
 874     XSLT_ITEM_COMMON_FIELDS
 875     xsltNumberData numdata; /* number */
 876 };
 877 
 878 /**
 879  * xsltStyleItemChoose:
 880  *
 881  * &lt;!-- Category: instruction --&gt;
 882  *  &lt;xsl:choose&gt;
 883  *  &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt;
 884  * &lt;/xsl:choose&gt;
 885  */
 886 typedef xsltStyleBasicEmptyItem xsltStyleItemChoose;
 887 typedef xsltStyleItemChoose *xsltStyleItemChoosePtr;
 888 
 889 /**
 890  * xsltStyleItemFallback:
 891  *
 892  * &lt;!-- Category: instruction --&gt;
 893  *  &lt;xsl:fallback&gt;
 894  *  &lt;!-- Content: template --&gt;
 895  * &lt;/xsl:fallback&gt;
 896  */
 897 typedef xsltStyleBasicEmptyItem xsltStyleItemFallback;
 898 typedef xsltStyleItemFallback *xsltStyleItemFallbackPtr;
 899 
 900 /**
 901  * xsltStyleItemForEach:
 902  *
 903  * &lt;!-- Category: instruction --&gt;
 904  * &lt;xsl:for-each
 905  *   select = node-set-expression&gt;
 906  *   &lt;!-- Content: (xsl:sort*, template) --&gt;
 907  * &lt;/xsl:for-each&gt;
 908  */
 909 typedef xsltStyleBasicExpressionItem xsltStyleItemForEach;
 910 typedef xsltStyleItemForEach *xsltStyleItemForEachPtr;
 911 
 912 /**
 913  * xsltStyleItemMessage:
 914  *
 915  * &lt;!-- Category: instruction --&gt;
 916  * &lt;xsl:message
 917  *   terminate = &quot;yes&quot; | &quot;no&quot;&gt;
 918  *   &lt;!-- Content: template --&gt;
 919  * &lt;/xsl:message&gt;
 920  */
 921 typedef struct _xsltStyleItemMessage xsltStyleItemMessage;
 922 typedef xsltStyleItemMessage *xsltStyleItemMessagePtr;
 923 
 924 struct _xsltStyleItemMessage {
 925     XSLT_ITEM_COMMON_FIELDS
 926     int terminate;
 927 };
 928 
 929 /**
 930  * xsltStyleItemDocument:
 931  *
 932  * NOTE: This is not an instruction of XSLT 1.0.
 933  */
 934 typedef struct _xsltStyleItemDocument xsltStyleItemDocument;
 935 typedef xsltStyleItemDocument *xsltStyleItemDocumentPtr;
 936 
 937 struct _xsltStyleItemDocument {
 938     XSLT_ITEM_COMMON_FIELDS
 939     int      ver11;     /* assigned: in xsltDocumentComp;
 940                                   read: nowhere;
 941                                   TODO: Check if we need. */
 942     const xmlChar *filename;    /* document URL */
 943     int has_filename;
 944 };
 945 
 946 /************************************************************************
 947  *                                  *
 948  * Non-instructions (actually properties of instructions/declarations)  *
 949  *                                  *
 950  ************************************************************************/
 951 
 952 /**
 953  * xsltStyleBasicItemVariable:
 954  *
 955  * Basic struct for xsl:variable, xsl:param and xsl:with-param.
 956  * It&#39;s currently important to have equal fields, since
 957  * xsltParseStylesheetCallerParam() is used with xsl:with-param from
 958  * the xslt side and with xsl:param from the exslt side (in
 959  * exsltFuncFunctionFunction()).
 960  *
 961  * FUTURE NOTE: In XSLT 2.0 xsl:param, xsl:variable and xsl:with-param
 962  *   have additional different fields.
 963  */
 964 typedef struct _xsltStyleBasicItemVariable xsltStyleBasicItemVariable;
 965 typedef xsltStyleBasicItemVariable *xsltStyleBasicItemVariablePtr;
 966 
 967 struct _xsltStyleBasicItemVariable {
 968     XSLT_ITEM_COMMON_FIELDS
 969 
 970     const xmlChar *select;
 971     xmlXPathCompExprPtr comp;
 972 
 973     const xmlChar *name;
 974     int      has_name;
 975     const xmlChar *ns;
 976     int      has_ns;
 977 };
 978 
 979 /**
 980  * xsltStyleItemVariable:
 981  *
 982  * &lt;!-- Category: top-level-element --&gt;
 983  * &lt;xsl:param
 984  *   name = qname
 985  *   select = expression&gt;
 986  *   &lt;!-- Content: template --&gt;
 987  * &lt;/xsl:param&gt;
 988  */
 989 typedef xsltStyleBasicItemVariable xsltStyleItemVariable;
 990 typedef xsltStyleItemVariable *xsltStyleItemVariablePtr;
 991 
 992 /**
 993  * xsltStyleItemParam:
 994  *
 995  * &lt;!-- Category: top-level-element --&gt;
 996  * &lt;xsl:param
 997  *   name = qname
 998  *   select = expression&gt;
 999  *   &lt;!-- Content: template --&gt;
1000  * &lt;/xsl:param&gt;
1001  */
1002 typedef struct _xsltStyleItemParam xsltStyleItemParam;
1003 typedef xsltStyleItemParam *xsltStyleItemParamPtr;
1004 
1005 struct _xsltStyleItemParam {
1006     XSLT_ITEM_COMMON_FIELDS
1007 
1008     const xmlChar *select;
1009     xmlXPathCompExprPtr comp;
1010 
1011     const xmlChar *name;
1012     int      has_name;
1013     const xmlChar *ns;
1014     int      has_ns;
1015 };
1016 
1017 /**
1018  * xsltStyleItemWithParam:
1019  *
1020  * &lt;xsl:with-param
1021  *  name = qname
1022  *  select = expression&gt;
1023  *  &lt;!-- Content: template --&gt;
1024  * &lt;/xsl:with-param&gt;
1025  */
1026 typedef xsltStyleBasicItemVariable xsltStyleItemWithParam;
1027 typedef xsltStyleItemWithParam *xsltStyleItemWithParamPtr;
1028 
1029 /**
1030  * xsltStyleItemSort:
1031  *
1032  * Reflects the XSLT xsl:sort item.
1033  * Allowed parents: xsl:apply-templates, xsl:for-each
1034  * &lt;xsl:sort
1035  *   select = string-expression
1036  *   lang = { nmtoken }
1037  *   data-type = { &quot;text&quot; | &quot;number&quot; | qname-but-not-ncname }
1038  *   order = { &quot;ascending&quot; | &quot;descending&quot; }
1039  *   case-order = { &quot;upper-first&quot; | &quot;lower-first&quot; } /&gt;
1040  */
1041 typedef struct _xsltStyleItemSort xsltStyleItemSort;
1042 typedef xsltStyleItemSort *xsltStyleItemSortPtr;
1043 
1044 struct _xsltStyleItemSort {
1045     XSLT_ITEM_COMMON_FIELDS
1046 
1047     const xmlChar *stype;       /* sort */
1048     int      has_stype;     /* sort */
1049     int      number;        /* sort */
1050     const xmlChar *order;   /* sort */
1051     int      has_order;     /* sort */
1052     int      descending;    /* sort */
1053     const xmlChar *lang;    /* sort */
1054     int      has_lang;      /* sort */
1055     xsltLocale locale;      /* sort */
1056     const xmlChar *case_order;  /* sort */
1057     int      lower_first;   /* sort */
1058 
1059     const xmlChar *use;
1060     int      has_use;
1061 
1062     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
1063 
1064     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
1065 };
1066 
1067 
1068 /**
1069  * xsltStyleItemWhen:
1070  *
1071  * &lt;xsl:when
1072  *   test = boolean-expression&gt;
1073  *   &lt;!-- Content: template --&gt;
1074  * &lt;/xsl:when&gt;
1075  * Allowed parent: xsl:choose
1076  */
1077 typedef struct _xsltStyleItemWhen xsltStyleItemWhen;
1078 typedef xsltStyleItemWhen *xsltStyleItemWhenPtr;
1079 
1080 struct _xsltStyleItemWhen {
1081     XSLT_ITEM_COMMON_FIELDS
1082 
1083     const xmlChar *test;
1084     xmlXPathCompExprPtr comp;
1085 };
1086 
1087 /**
1088  * xsltStyleItemOtherwise:
1089  *
1090  * Allowed parent: xsl:choose
1091  * &lt;xsl:otherwise&gt;
1092  *   &lt;!-- Content: template --&gt;
1093  * &lt;/xsl:otherwise&gt;
1094  */
1095 typedef struct _xsltStyleItemOtherwise xsltStyleItemOtherwise;
1096 typedef xsltStyleItemOtherwise *xsltStyleItemOtherwisePtr;
1097 
1098 struct _xsltStyleItemOtherwise {
1099     XSLT_ITEM_COMMON_FIELDS
1100 };
1101 
1102 typedef struct _xsltStyleItemInclude xsltStyleItemInclude;
1103 typedef xsltStyleItemInclude *xsltStyleItemIncludePtr;
1104 
1105 struct _xsltStyleItemInclude {
1106     XSLT_ITEM_COMMON_FIELDS
1107     xsltDocumentPtr include;
1108 };
1109 
1110 /************************************************************************
1111  *                                  *
1112  *  XSLT elements in forwards-compatible mode                           *
1113  *                                  *
1114  ************************************************************************/
1115 
1116 typedef struct _xsltStyleItemUknown xsltStyleItemUknown;
1117 typedef xsltStyleItemUknown *xsltStyleItemUknownPtr;
1118 struct _xsltStyleItemUknown {
1119     XSLT_ITEM_COMMON_FIELDS
1120 };
1121 
1122 
1123 /************************************************************************
1124  *                                  *
1125  *  Extension elements                                                  *
1126  *                                  *
1127  ************************************************************************/
1128 
1129 /*
1130  * xsltStyleItemExtElement:
1131  *
1132  * Reflects extension elements.
1133  *
1134  * NOTE: Due to the fact that the structure xsltElemPreComp is most
1135  * probably already heavily in use out there by users, so we cannot
1136  * easily change it, we&#39;ll create an intermediate structure which will
1137  * hold an xsltElemPreCompPtr.
1138  * BIG NOTE: The only problem I see here is that the user processes the
1139  *  content of the stylesheet tree, possibly he&#39;ll lookup the node-&gt;psvi
1140  *  fields in order to find subsequent extension functions.
1141  *  In this case, the user&#39;s code will break, since the node-&gt;psvi
1142  *  field will hold now the xsltStyleItemExtElementPtr and not
1143  *  the xsltElemPreCompPtr.
1144  *  However the place where the structure is anchored in the node-tree,
1145  *  namely node-&gt;psvi, has beed already once been moved from node-&gt;_private
1146  *  to node-&gt;psvi, so we have a precedent here, which, I think, should allow
1147  *  us to change such semantics without headaches.
1148  */
1149 typedef struct _xsltStyleItemExtElement xsltStyleItemExtElement;
1150 typedef xsltStyleItemExtElement *xsltStyleItemExtElementPtr;
1151 struct _xsltStyleItemExtElement {
1152     XSLT_ITEM_COMMON_FIELDS
1153     xsltElemPreCompPtr item;
1154 };
1155 
1156 /************************************************************************
1157  *                                  *
1158  *  Literal result elements                                             *
1159  *                                  *
1160  ************************************************************************/
1161 
1162 typedef struct _xsltEffectiveNs xsltEffectiveNs;
1163 typedef xsltEffectiveNs *xsltEffectiveNsPtr;
1164 struct _xsltEffectiveNs {
1165     xsltEffectiveNsPtr nextInStore; /* storage next */
1166     xsltEffectiveNsPtr next; /* next item in the list */
1167     const xmlChar *prefix;
1168     const xmlChar *nsName;
1169     /*
1170     * Indicates if eclared on the literal result element; dunno if really
1171     * needed.
1172     */
1173     int holdByElem;
1174 };
1175 
1176 /*
1177  * Info for literal result elements.
1178  * This will be set on the elem-&gt;psvi field and will be
1179  * shared by literal result elements, which have the same
1180  * excluded result namespaces; i.e., this *won&#39;t* be created uniquely
1181  * for every literal result element.
1182  */
1183 typedef struct _xsltStyleItemLRElementInfo xsltStyleItemLRElementInfo;
1184 typedef xsltStyleItemLRElementInfo *xsltStyleItemLRElementInfoPtr;
1185 struct _xsltStyleItemLRElementInfo {
1186     XSLT_ITEM_COMMON_FIELDS
1187     /*
1188     * @effectiveNs is the set of effective ns-nodes
1189     *  on the literal result element, which will be added to the result
1190     *  element if not already existing in the result tree.
1191     *  This means that excluded namespaces (via exclude-result-prefixes,
1192     *  extension-element-prefixes and the XSLT namespace) not added
1193     *  to the set.
1194     *  Namespace-aliasing was applied on the @effectiveNs.
1195     */
1196     xsltEffectiveNsPtr effectiveNs;
1197 
1198 };
1199 
1200 #ifdef XSLT_REFACTORED
1201 
1202 typedef struct _xsltNsAlias xsltNsAlias;
1203 typedef xsltNsAlias *xsltNsAliasPtr;
1204 struct _xsltNsAlias {
1205     xsltNsAliasPtr next; /* next in the list */
1206     xmlNsPtr literalNs;
1207     xmlNsPtr targetNs;
1208     xmlDocPtr docOfTargetNs;
1209 };
1210 #endif
1211 
1212 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1213 
1214 typedef struct _xsltNsMap xsltNsMap;
1215 typedef xsltNsMap *xsltNsMapPtr;
1216 struct _xsltNsMap {
1217     xsltNsMapPtr next; /* next in the list */
1218     xmlDocPtr doc;
1219     xmlNodePtr elem; /* the element holding the ns-decl */
1220     xmlNsPtr ns; /* the xmlNs structure holding the XML namespace name */
1221     const xmlChar *origNsName; /* the original XML namespace name */
1222     const xmlChar *newNsName; /* the mapped XML namespace name */
1223 };
1224 #endif
1225 
1226 /************************************************************************
1227  *                                  *
1228  *  Compile-time structures for *internal* use only                     *
1229  *                                  *
1230  ************************************************************************/
1231 
1232 typedef struct _xsltPrincipalStylesheetData xsltPrincipalStylesheetData;
1233 typedef xsltPrincipalStylesheetData *xsltPrincipalStylesheetDataPtr;
1234 
1235 typedef struct _xsltNsList xsltNsList;
1236 typedef xsltNsList *xsltNsListPtr;
1237 struct _xsltNsList {
1238     xsltNsListPtr next; /* next in the list */
1239     xmlNsPtr ns;
1240 };
1241 
1242 /*
1243 * xsltVarInfo:
1244 *
1245 * Used at compilation time for parameters and variables.
1246 */
1247 typedef struct _xsltVarInfo xsltVarInfo;
1248 typedef xsltVarInfo *xsltVarInfoPtr;
1249 struct _xsltVarInfo {
1250     xsltVarInfoPtr next; /* next in the list */
1251     xsltVarInfoPtr prev;
1252     int depth; /* the depth in the tree */
1253     const xmlChar *name;
1254     const xmlChar *nsName;
1255 };
1256 
1257 /**
1258  * xsltCompilerNodeInfo:
1259  *
1260  * Per-node information during compile-time.
1261  */
1262 typedef struct _xsltCompilerNodeInfo xsltCompilerNodeInfo;
1263 typedef xsltCompilerNodeInfo *xsltCompilerNodeInfoPtr;
1264 struct _xsltCompilerNodeInfo {
1265     xsltCompilerNodeInfoPtr next;
1266     xsltCompilerNodeInfoPtr prev;
1267     xmlNodePtr node;
1268     int depth;
1269     xsltTemplatePtr templ;   /* The owning template */
1270     int category;        /* XSLT element, LR-element or
1271                                 extension element */
1272     xsltStyleType type;
1273     xsltElemPreCompPtr item; /* The compiled information */
1274     /* The current in-scope namespaces */
1275     xsltNsListContainerPtr inScopeNs;
1276     /* The current excluded result namespaces */
1277     xsltPointerListPtr exclResultNs;
1278     /* The current extension instruction namespaces */
1279     xsltPointerListPtr extElemNs;
1280 
1281     /* The current info for literal result elements. */
1282     xsltStyleItemLRElementInfoPtr litResElemInfo;
1283     /*
1284     * Set to 1 if in-scope namespaces changed,
1285     *  or excluded result namespaces changed,
1286     *  or extension element namespaces changed.
1287     * This will trigger creation of new infos
1288     *  for literal result elements.
1289     */
1290     int nsChanged;
1291     int preserveWhitespace;
1292     int stripWhitespace;
1293     int isRoot; /* whether this is the stylesheet&#39;s root node */
1294     int forwardsCompat; /* whether forwards-compatible mode is enabled */
1295     /* whether the content of an extension element was processed */
1296     int extContentHandled;
1297     /* the type of the current child */
1298     xsltStyleType curChildType;
1299 };
1300 
1301 /**
1302  * XSLT_CCTXT:
1303  *
1304  * get pointer to compiler context
1305  */
1306 #define XSLT_CCTXT(style) ((xsltCompilerCtxtPtr) style-&gt;compCtxt)
1307 
1308 typedef enum {
1309     XSLT_ERROR_SEVERITY_ERROR = 0,
1310     XSLT_ERROR_SEVERITY_WARNING
1311 } xsltErrorSeverityType;
1312 
1313 typedef struct _xsltCompilerCtxt xsltCompilerCtxt;
1314 typedef xsltCompilerCtxt *xsltCompilerCtxtPtr;
1315 struct _xsltCompilerCtxt {
1316     void *errorCtxt;            /* user specific error context */
1317     /*
1318     * used for error/warning reports; e.g. XSLT_ERROR_SEVERITY_WARNING */
1319     xsltErrorSeverityType errSeverity;
1320     int warnings;       /* TODO: number of warnings found at
1321                                    compilation */
1322     int errors;         /* TODO: number of errors found at
1323                                    compilation */
1324     xmlDictPtr dict;
1325     xsltStylesheetPtr style;
1326     int simplified; /* whether this is a simplified stylesheet */
1327     /* TODO: structured/unstructured error contexts. */
1328     int depth; /* Current depth of processing */
1329 
1330     xsltCompilerNodeInfoPtr inode;
1331     xsltCompilerNodeInfoPtr inodeList;
1332     xsltCompilerNodeInfoPtr inodeLast;
1333     xsltPointerListPtr tmpList; /* Used for various purposes */
1334     /*
1335     * The XSLT version as specified by the stylesheet&#39;s root element.
1336     */
1337     int isInclude;
1338     int hasForwardsCompat; /* whether forwards-compatible mode was used
1339                  in a parsing episode */
1340     int maxNodeInfos; /* TEMP TODO: just for the interest */
1341     int maxLREs;  /* TEMP TODO: just for the interest */
1342     /*
1343     * In order to keep the old behaviour, applying strict rules of
1344     * the spec can be turned off. This has effect only on special
1345     * mechanisms like whitespace-stripping in the stylesheet.
1346     */
1347     int strict;
1348     xsltPrincipalStylesheetDataPtr psData;
1349 #ifdef XSLT_REFACTORED_XPATHCOMP
1350     xmlXPathContextPtr xpathCtxt;
1351 #endif
1352     xsltStyleItemUknownPtr unknownItem;
1353     int hasNsAliases; /* Indicator if there was an xsl:namespace-alias. */
1354     xsltNsAliasPtr nsAliases;
1355     xsltVarInfoPtr ivars; /* Storage of local in-scope variables/params. */
1356     xsltVarInfoPtr ivar; /* topmost local variable/param. */
1357 };
1358 
1359 #else /* XSLT_REFACTORED */
1360 /*
1361 * The old structures before refactoring.
1362 */
1363 
1364 /**
1365  * _xsltStylePreComp:
1366  *
1367  * The in-memory structure corresponding to XSLT stylesheet constructs
1368  * precomputed data.
1369  */
1370 struct _xsltStylePreComp {
1371     xsltElemPreCompPtr next;    /* chained list */
1372     xsltStyleType type;     /* type of the element */
1373     xsltTransformFunction func; /* handling function */
1374     xmlNodePtr inst;        /* the instruction */
1375 
1376     /*
1377      * Pre computed values.
1378      */
1379 
1380     const xmlChar *stype;       /* sort */
1381     int      has_stype;     /* sort */
1382     int      number;        /* sort */
1383     const xmlChar *order;   /* sort */
1384     int      has_order;     /* sort */
1385     int      descending;    /* sort */
1386     const xmlChar *lang;    /* sort */
1387     int      has_lang;      /* sort */
1388     xsltLocale locale;      /* sort */
1389     const xmlChar *case_order;  /* sort */
1390     int      lower_first;   /* sort */
1391 
1392     const xmlChar *use;     /* copy, element */
1393     int      has_use;       /* copy, element */
1394 
1395     int      noescape;      /* text */
1396 
1397     const xmlChar *name;    /* element, attribute, pi */
1398     int      has_name;      /* element, attribute, pi */
1399     const xmlChar *ns;      /* element */
1400     int      has_ns;        /* element */
1401 
1402     const xmlChar *mode;    /* apply-templates */
1403     const xmlChar *modeURI; /* apply-templates */
1404 
1405     const xmlChar *test;    /* if */
1406 
1407     xsltTemplatePtr templ;  /* call-template */
1408 
1409     const xmlChar *select;  /* sort, copy-of, value-of, apply-templates */
1410 
1411     int      ver11;     /* document */
1412     const xmlChar *filename;    /* document URL */
1413     int      has_filename;  /* document */
1414 
1415     xsltNumberData numdata; /* number */
1416 
1417     xmlXPathCompExprPtr comp;   /* a precompiled XPath expression */
1418     xmlNsPtr *nsList;       /* the namespaces in scope */
1419     int nsNr;           /* the number of namespaces in scope */
1420 };
1421 
1422 #endif /* XSLT_REFACTORED */
1423 
1424 
1425 /*
1426  * The in-memory structure corresponding to an XSLT Variable
1427  * or Param.
1428  */
1429 typedef struct _xsltStackElem xsltStackElem;
1430 typedef xsltStackElem *xsltStackElemPtr;
1431 struct _xsltStackElem {
1432     struct _xsltStackElem *next;/* chained list */
1433     xsltStylePreCompPtr comp;   /* the compiled form */
1434     int computed;       /* was the evaluation done */
1435     const xmlChar *name;    /* the local part of the name QName */
1436     const xmlChar *nameURI; /* the URI part of the name QName */
1437     const xmlChar *select;  /* the eval string */
1438     xmlNodePtr tree;        /* the sequence constructor if no eval
1439                     string or the location */
1440     xmlXPathObjectPtr value;    /* The value if computed */
1441     xmlDocPtr fragment;     /* The Result Tree Fragments (needed for XSLT 1.0)
1442                    which are bound to the variable&#39;s lifetime. */
1443     int level;                  /* the depth in the tree;
1444                                    -1 if persistent (e.g. a given xsl:with-param) */
1445     xsltTransformContextPtr context; /* The transformation context; needed to cache
1446                                         the variables */
1447     int flags;
1448 };
1449 
1450 #ifdef XSLT_REFACTORED
1451 
1452 struct _xsltPrincipalStylesheetData {
1453     /*
1454     * Namespace dictionary for ns-prefixes and ns-names:
1455     * TODO: Shared between stylesheets, and XPath mechanisms.
1456     *   Not used yet.
1457     */
1458     xmlDictPtr namespaceDict;
1459     /*
1460     * Global list of in-scope namespaces.
1461     */
1462     xsltPointerListPtr inScopeNamespaces;
1463     /*
1464     * Global list of information for [xsl:]excluded-result-prefixes.
1465     */
1466     xsltPointerListPtr exclResultNamespaces;
1467     /*
1468     * Global list of information for [xsl:]extension-element-prefixes.
1469     */
1470     xsltPointerListPtr extElemNamespaces;
1471     xsltEffectiveNsPtr effectiveNs;
1472 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1473     /*
1474     * Namespace name map to get rid of string comparison of namespace names.
1475     */
1476     xsltNsMapPtr nsMap;
1477 #endif
1478 };
1479 
1480 
1481 #endif
1482 /*
1483  * Note that we added a @compCtxt field to anchor an stylesheet compilation
1484  * context, since, due to historical reasons, various compile-time function
1485  * take only the stylesheet as argument and not a compilation context.
1486  */
1487 struct _xsltStylesheet {
1488     /*
1489      * The stylesheet import relation is kept as a tree.
1490      */
1491     struct _xsltStylesheet *parent;
1492     struct _xsltStylesheet *next;
1493     struct _xsltStylesheet *imports;
1494 
1495     xsltDocumentPtr docList;        /* the include document list */
1496 
1497     /*
1498      * General data on the style sheet document.
1499      */
1500     xmlDocPtr doc;      /* the parsed XML stylesheet */
1501     xmlHashTablePtr stripSpaces;/* the hash table of the strip-space and
1502                    preserve space elements */
1503     int             stripAll;   /* strip-space * (1) preserve-space * (-1) */
1504     xmlHashTablePtr cdataSection;/* the hash table of the cdata-section */
1505 
1506     /*
1507      * Global variable or parameters.
1508      */
1509     xsltStackElemPtr variables; /* linked list of param and variables */
1510 
1511     /*
1512      * Template descriptions.
1513      */
1514     xsltTemplatePtr templates;  /* the ordered list of templates */
1515     void *templatesHash;    /* hash table or wherever compiled templates
1516                    information is stored */
1517     void *rootMatch;        /* template based on / */
1518     void *keyMatch;     /* template based on key() */
1519     void *elemMatch;        /* template based on * */
1520     void *attrMatch;        /* template based on @* */
1521     void *parentMatch;      /* template based on .. */
1522     void *textMatch;        /* template based on text() */
1523     void *piMatch;      /* template based on processing-instruction() */
1524     void *commentMatch;     /* template based on comment() */
1525 
1526     /*
1527      * Namespace aliases.
1528      * NOTE: Not used in the refactored code.
1529      */
1530     xmlHashTablePtr nsAliases;  /* the namespace alias hash tables */
1531 
1532     /*
1533      * Attribute sets.
1534      */
1535     xmlHashTablePtr attributeSets;/* the attribute sets hash tables */
1536 
1537     /*
1538      * Namespaces.
1539      * TODO: Eliminate this.
1540      */
1541     xmlHashTablePtr nsHash;     /* the set of namespaces in use:
1542                                    ATTENTION: This is used for
1543                                    execution of XPath expressions; unfortunately
1544                                    it restricts the stylesheet to have distinct
1545                                    prefixes.
1546                    TODO: We need to get rid of this.
1547                  */
1548     void           *nsDefs;     /* ATTENTION TODO: This is currently used to store
1549                    xsltExtDefPtr (in extensions.c) and
1550                                    *not* xmlNsPtr.
1551                  */
1552 
1553     /*
1554      * Key definitions.
1555      */
1556     void *keys;         /* key definitions */
1557 
1558     /*
1559      * Output related stuff.
1560      */
1561     xmlChar *method;        /* the output method */
1562     xmlChar *methodURI;     /* associated namespace if any */
1563     xmlChar *version;       /* version string */
1564     xmlChar *encoding;      /* encoding string */
1565     int omitXmlDeclaration;     /* omit-xml-declaration = &quot;yes&quot; | &quot;no&quot; */
1566 
1567     /*
1568      * Number formatting.
1569      */
1570     xsltDecimalFormatPtr decimalFormat;
1571     int standalone;             /* standalone = &quot;yes&quot; | &quot;no&quot; */
1572     xmlChar *doctypePublic;     /* doctype-public string */
1573     xmlChar *doctypeSystem;     /* doctype-system string */
1574     int indent;         /* should output being indented */
1575     xmlChar *mediaType;     /* media-type string */
1576 
1577     /*
1578      * Precomputed blocks.
1579      */
1580     xsltElemPreCompPtr preComps;/* list of precomputed blocks */
1581     int warnings;       /* number of warnings found at compilation */
1582     int errors;         /* number of errors found at compilation */
1583 
1584     xmlChar  *exclPrefix;   /* last excluded prefixes */
1585     xmlChar **exclPrefixTab;    /* array of excluded prefixes */
1586     int       exclPrefixNr; /* number of excluded prefixes in scope */
1587     int       exclPrefixMax;    /* size of the array */
1588 
1589     void     *_private;     /* user defined data */
1590 
1591     /*
1592      * Extensions.
1593      */
1594     xmlHashTablePtr extInfos;   /* the extension data */
1595     int         extrasNr;   /* the number of extras required */
1596 
1597     /*
1598      * For keeping track of nested includes
1599      */
1600     xsltDocumentPtr includes;   /* points to last nested include */
1601 
1602     /*
1603      * dictionary: shared between stylesheet, context and documents.
1604      */
1605     xmlDictPtr dict;
1606     /*
1607      * precompiled attribute value templates.
1608      */
1609     void *attVTs;
1610     /*
1611      * if namespace-alias has an alias for the default stylesheet prefix
1612      * NOTE: Not used in the refactored code.
1613      */
1614     const xmlChar *defaultAlias;
1615     /*
1616      * bypass pre-processing (already done) (used in imports)
1617      */
1618     int nopreproc;
1619     /*
1620      * all document text strings were internalized
1621      */
1622     int internalized;
1623     /*
1624      * Literal Result Element as Stylesheet c.f. section 2.3
1625      */
1626     int literal_result;
1627     /*
1628     * The principal stylesheet
1629     */
1630     xsltStylesheetPtr principal;
1631 #ifdef XSLT_REFACTORED
1632     /*
1633     * Compilation context used during compile-time.
1634     */
1635     xsltCompilerCtxtPtr compCtxt; /* TODO: Change this to (void *). */
1636 
1637     xsltPrincipalStylesheetDataPtr principalData;
1638 #endif
1639     /*
1640      * Forwards-compatible processing
1641      */
1642     int forwards_compatible;
1643 
1644     xmlHashTablePtr namedTemplates; /* hash table of named templates */
1645 };
1646 
1647 typedef struct _xsltTransformCache xsltTransformCache;
1648 typedef xsltTransformCache *xsltTransformCachePtr;
1649 struct _xsltTransformCache {
1650     xmlDocPtr RVT;
1651     int nbRVT;
1652     xsltStackElemPtr stackItems;
1653     int nbStackItems;
1654 #ifdef XSLT_DEBUG_PROFILE_CACHE
1655     int dbgCachedRVTs;
1656     int dbgReusedRVTs;
1657     int dbgCachedVars;
1658     int dbgReusedVars;
1659 #endif
1660 };
1661 
1662 /*
1663  * The in-memory structure corresponding to an XSLT Transformation.
1664  */
1665 typedef enum {
1666     XSLT_OUTPUT_XML = 0,
1667     XSLT_OUTPUT_HTML,
1668     XSLT_OUTPUT_TEXT
1669 } xsltOutputType;
1670 
1671 typedef enum {
1672     XSLT_STATE_OK = 0,
1673     XSLT_STATE_ERROR,
1674     XSLT_STATE_STOPPED
1675 } xsltTransformState;
1676 
1677 struct _xsltTransformContext {
1678     xsltStylesheetPtr style;        /* the stylesheet used */
1679     xsltOutputType type;        /* the type of output */
1680 
1681     xsltTemplatePtr  templ;     /* the current template */
1682     int              templNr;       /* Nb of templates in the stack */
1683     int              templMax;      /* Size of the templtes stack */
1684     xsltTemplatePtr *templTab;      /* the template stack */
1685 
1686     xsltStackElemPtr  vars;     /* the current variable list */
1687     int               varsNr;       /* Nb of variable list in the stack */
1688     int               varsMax;      /* Size of the variable list stack */
1689     xsltStackElemPtr *varsTab;      /* the variable list stack */
1690     int               varsBase;     /* the var base for current templ */
1691 
1692     /*
1693      * Extensions
1694      */
1695     xmlHashTablePtr   extFunctions; /* the extension functions */
1696     xmlHashTablePtr   extElements;  /* the extension elements */
1697     xmlHashTablePtr   extInfos;     /* the extension data */
1698 
1699     const xmlChar *mode;        /* the current mode */
1700     const xmlChar *modeURI;     /* the current mode URI */
1701 
1702     xsltDocumentPtr docList;        /* the document list */
1703 
1704     xsltDocumentPtr document;       /* the current source document; can be NULL if an RTF */
1705     xmlNodePtr node;            /* the current node being processed */
1706     xmlNodeSetPtr nodeList;     /* the current node list */
1707     /* xmlNodePtr current;          the node */
1708 
1709     xmlDocPtr output;           /* the resulting document */
1710     xmlNodePtr insert;          /* the insertion node */
1711 
1712     xmlXPathContextPtr xpathCtxt;   /* the XPath context */
1713     xsltTransformState state;       /* the current state */
1714 
1715     /*
1716      * Global variables
1717      */
1718     xmlHashTablePtr   globalVars;   /* the global variables and params */
1719 
1720     xmlNodePtr inst;            /* the instruction in the stylesheet */
1721 
1722     int xinclude;           /* should XInclude be processed */
1723 
1724     const char *      outputFile;   /* the output URI if known */
1725 
1726     int profile;                        /* is this run profiled */
1727     long             prof;      /* the current profiled value */
1728     int              profNr;        /* Nb of templates in the stack */
1729     int              profMax;       /* Size of the templtaes stack */
1730     long            *profTab;       /* the profile template stack */
1731 
1732     void            *_private;      /* user defined data */
1733 
1734     int              extrasNr;      /* the number of extras used */
1735     int              extrasMax;     /* the number of extras allocated */
1736     xsltRuntimeExtraPtr extras;     /* extra per runtime information */
1737 
1738     xsltDocumentPtr  styleList;     /* the stylesheet docs list */
1739     void                 * sec;     /* the security preferences if any */
1740 
1741     xmlGenericErrorFunc  error;     /* a specific error handler */
1742     void              * errctx;     /* context for the error handler */
1743 
1744     xsltSortFunc      sortfunc;     /* a ctxt specific sort routine */
1745 
1746     /*
1747      * handling of temporary Result Value Tree
1748      * (XSLT 1.0 term: &quot;Result Tree Fragment&quot;)
1749      */
1750     xmlDocPtr       tmpRVT;     /* list of RVT without persistance */
1751     xmlDocPtr       persistRVT;     /* list of persistant RVTs */
1752     int             ctxtflags;          /* context processing flags */
1753 
1754     /*
1755      * Speed optimization when coalescing text nodes
1756      */
1757     const xmlChar  *lasttext;       /* last text node content */
1758     int             lasttsize;      /* last text node size */
1759     int             lasttuse;       /* last text node use */
1760     /*
1761      * Per Context Debugging
1762      */
1763     int debugStatus;            /* the context level debug status */
1764     unsigned long* traceCode;       /* pointer to the variable holding the mask */
1765 
1766     int parserOptions;          /* parser options xmlParserOption */
1767 
1768     /*
1769      * dictionary: shared between stylesheet, context and documents.
1770      */
1771     xmlDictPtr dict;
1772     xmlDocPtr       tmpDoc; /* Obsolete; not used in the library. */
1773     /*
1774      * all document text strings are internalized
1775      */
1776     int internalized;
1777     int nbKeys;
1778     int hasTemplKeyPatterns;
1779     xsltTemplatePtr currentTemplateRule; /* the Current Template Rule */
1780     xmlNodePtr initialContextNode;
1781     xmlDocPtr initialContextDoc;
1782     xsltTransformCachePtr cache;
1783     void *contextVariable; /* the current variable item */
1784     xmlDocPtr localRVT; /* list of local tree fragments; will be freed when
1785                the instruction which created the fragment
1786                            exits */
1787     xmlDocPtr localRVTBase; /* Obsolete */
1788     int keyInitLevel;   /* Needed to catch recursive keys issues */
1789     int depth;          /* Needed to catch recursions */
1790     int maxTemplateDepth;
1791     int maxTemplateVars;
1792 };
1793 
1794 /**
1795  * CHECK_STOPPED:
1796  *
1797  * Macro to check if the XSLT processing should be stopped.
1798  * Will return from the function.
1799  */
1800 #define CHECK_STOPPED if (ctxt-&gt;state == XSLT_STATE_STOPPED) return;
1801 
1802 /**
1803  * CHECK_STOPPEDE:
1804  *
1805  * Macro to check if the XSLT processing should be stopped.
1806  * Will goto the error: label.
1807  */
1808 #define CHECK_STOPPEDE if (ctxt-&gt;state == XSLT_STATE_STOPPED) goto error;
1809 
1810 /**
1811  * CHECK_STOPPED0:
1812  *
1813  * Macro to check if the XSLT processing should be stopped.
1814  * Will return from the function with a 0 value.
1815  */
1816 #define CHECK_STOPPED0 if (ctxt-&gt;state == XSLT_STATE_STOPPED) return(0);
1817 
1818 /*
1819  * The macro XML_CAST_FPTR is a hack to avoid a gcc warning about
1820  * possible incompatibilities between function pointers and object
1821  * pointers.  It is defined in libxml/hash.h within recent versions
1822  * of libxml2, but is put here for compatibility.
1823  */
1824 #ifndef XML_CAST_FPTR
1825 /**
1826  * XML_CAST_FPTR:
1827  * @fptr:  pointer to a function
1828  *
1829  * Macro to do a casting from an object pointer to a
1830  * function pointer without encountering a warning from
1831  * gcc
1832  *
1833  * #define XML_CAST_FPTR(fptr) (*(void **)(&amp;fptr))
1834  * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
1835  * so it is disabled now
1836  */
1837 
1838 #define XML_CAST_FPTR(fptr) fptr
1839 #endif
1840 /*
1841  * Functions associated to the internal types
1842 xsltDecimalFormatPtr    xsltDecimalFormatGetByName(xsltStylesheetPtr sheet,
1843                            xmlChar *name);
1844  */
1845 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1846             xsltNewStylesheet   (void);
1847 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1848             xsltParseStylesheetFile (const xmlChar* filename);
1849 XSLTPUBFUN void XSLTCALL
1850             xsltFreeStylesheet  (xsltStylesheetPtr style);
1851 XSLTPUBFUN int XSLTCALL
1852             xsltIsBlank     (xmlChar *str);
1853 XSLTPUBFUN void XSLTCALL
1854             xsltFreeStackElemList   (xsltStackElemPtr elem);
1855 XSLTPUBFUN xsltDecimalFormatPtr XSLTCALL
1856             xsltDecimalFormatGetByName(xsltStylesheetPtr style,
1857                          xmlChar *name);
1858 XSLTPUBFUN xsltDecimalFormatPtr XSLTCALL
1859             xsltDecimalFormatGetByQName(xsltStylesheetPtr style,
1860                          const xmlChar *nsUri,
1861                                                  const xmlChar *name);
1862 
1863 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1864             xsltParseStylesheetProcess(xsltStylesheetPtr ret,
1865                          xmlDocPtr doc);
1866 XSLTPUBFUN void XSLTCALL
1867             xsltParseStylesheetOutput(xsltStylesheetPtr style,
1868                          xmlNodePtr cur);
1869 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1870             xsltParseStylesheetDoc  (xmlDocPtr doc);
1871 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1872             xsltParseStylesheetImportedDoc(xmlDocPtr doc,
1873                         xsltStylesheetPtr style);
1874 XSLTPUBFUN xsltStylesheetPtr XSLTCALL
1875             xsltLoadStylesheetPI    (xmlDocPtr doc);
1876 XSLTPUBFUN void XSLTCALL
1877             xsltNumberFormat    (xsltTransformContextPtr ctxt,
1878                          xsltNumberDataPtr data,
1879                          xmlNodePtr node);
1880 XSLTPUBFUN xmlXPathError XSLTCALL
1881             xsltFormatNumberConversion(xsltDecimalFormatPtr self,
1882                          xmlChar *format,
1883                          double number,
1884                          xmlChar **result);
1885 
1886 XSLTPUBFUN void XSLTCALL
1887             xsltParseTemplateContent(xsltStylesheetPtr style,
1888                          xmlNodePtr templ);
1889 XSLTPUBFUN int XSLTCALL
1890             xsltAllocateExtra   (xsltStylesheetPtr style);
1891 XSLTPUBFUN int XSLTCALL
1892             xsltAllocateExtraCtxt   (xsltTransformContextPtr ctxt);
1893 /*
1894  * Extra functions for Result Value Trees
1895  */
1896 XSLTPUBFUN xmlDocPtr XSLTCALL
1897             xsltCreateRVT       (xsltTransformContextPtr ctxt);
1898 XSLTPUBFUN int XSLTCALL
1899             xsltRegisterTmpRVT  (xsltTransformContextPtr ctxt,
1900                          xmlDocPtr RVT);
1901 XSLTPUBFUN int XSLTCALL
1902             xsltRegisterLocalRVT    (xsltTransformContextPtr ctxt,
1903                          xmlDocPtr RVT);
1904 XSLTPUBFUN int XSLTCALL
1905             xsltRegisterPersistRVT  (xsltTransformContextPtr ctxt,
1906                          xmlDocPtr RVT);
1907 XSLTPUBFUN int XSLTCALL
1908             xsltExtensionInstructionResultRegister(
1909                          xsltTransformContextPtr ctxt,
1910                          xmlXPathObjectPtr obj);
1911 XSLTPUBFUN int XSLTCALL
1912             xsltExtensionInstructionResultFinalize(
1913                          xsltTransformContextPtr ctxt);
1914 XSLTPUBFUN int XSLTCALL
1915             xsltFlagRVTs(
1916                          xsltTransformContextPtr ctxt,
1917                          xmlXPathObjectPtr obj,
1918                          void *val);
1919 XSLTPUBFUN void XSLTCALL
1920             xsltFreeRVTs        (xsltTransformContextPtr ctxt);
1921 XSLTPUBFUN void XSLTCALL
1922             xsltReleaseRVT      (xsltTransformContextPtr ctxt,
1923                          xmlDocPtr RVT);
1924 /*
1925  * Extra functions for Attribute Value Templates
1926  */
1927 XSLTPUBFUN void XSLTCALL
1928             xsltCompileAttr     (xsltStylesheetPtr style,
1929                          xmlAttrPtr attr);
1930 XSLTPUBFUN xmlChar * XSLTCALL
1931             xsltEvalAVT     (xsltTransformContextPtr ctxt,
1932                          void *avt,
1933                          xmlNodePtr node);
1934 XSLTPUBFUN void XSLTCALL
1935             xsltFreeAVTList     (void *avt);
1936 
1937 /*
1938  * Extra function for successful xsltCleanupGlobals / xsltInit sequence.
1939  */
1940 
1941 XSLTPUBFUN void XSLTCALL
1942             xsltUninit      (void);
1943 
1944 /************************************************************************
1945  *                                  *
1946  *  Compile-time functions for *internal* use only                      *
1947  *                                  *
1948  ************************************************************************/
1949 
1950 #ifdef XSLT_REFACTORED
1951 XSLTPUBFUN void XSLTCALL
1952             xsltParseSequenceConstructor(
1953                          xsltCompilerCtxtPtr cctxt,
1954                          xmlNodePtr start);
1955 XSLTPUBFUN int XSLTCALL
1956             xsltParseAnyXSLTElem    (xsltCompilerCtxtPtr cctxt,
1957                          xmlNodePtr elem);
1958 #ifdef XSLT_REFACTORED_XSLT_NSCOMP
1959 XSLTPUBFUN int XSLTCALL
1960             xsltRestoreDocumentNamespaces(
1961                          xsltNsMapPtr ns,
1962                          xmlDocPtr doc);
1963 #endif
1964 #endif /* XSLT_REFACTORED */
1965 
1966 /************************************************************************
1967  *                                  *
1968  *  Transformation-time functions for *internal* use only               *
1969  *                                  *
1970  ************************************************************************/
1971 XSLTPUBFUN int XSLTCALL
1972             xsltInitCtxtKey     (xsltTransformContextPtr ctxt,
1973                          xsltDocumentPtr doc,
1974                          xsltKeyDefPtr keyd);
1975 XSLTPUBFUN int XSLTCALL
1976             xsltInitAllDocKeys  (xsltTransformContextPtr ctxt);
1977 #ifdef __cplusplus
1978 }
1979 #endif
1980 
1981 #endif /* __XML_XSLT_H__ */
1982 
    </pre>
  </body>
</html>