<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/LabeledTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package test.javafx.scene.control;
 27 
 28 import javafx.css.CssMetaData;
 29 import static org.junit.Assert.assertEquals;
 30 import static org.junit.Assert.assertFalse;
 31 import static org.junit.Assert.assertNotNull;
 32 import static org.junit.Assert.assertNull;
 33 import static org.junit.Assert.assertSame;
 34 import static org.junit.Assert.assertTrue;
 35 import javafx.beans.property.BooleanProperty;
 36 import javafx.beans.property.DoubleProperty;
 37 import javafx.beans.property.ObjectProperty;
 38 import javafx.beans.property.SimpleBooleanProperty;
 39 import javafx.beans.property.SimpleDoubleProperty;
 40 import javafx.beans.property.SimpleObjectProperty;
 41 import javafx.beans.property.SimpleStringProperty;
 42 import javafx.beans.property.StringProperty;
 43 import javafx.css.StyleableProperty;
 44 import javafx.geometry.Insets;
 45 import javafx.geometry.Orientation;
 46 import javafx.geometry.Pos;
 47 import javafx.scene.Node;
 48 import javafx.scene.control.ContentDisplay;
 49 import javafx.scene.control.Labeled;
 50 import javafx.scene.control.OverrunStyle;
 51 import javafx.scene.paint.Color;
 52 import javafx.scene.paint.Paint;
 53 import javafx.scene.shape.Rectangle;
 54 import javafx.scene.text.Font;
 55 import javafx.scene.text.TextAlignment;
 56 
 57 import org.junit.Before;
 58 import org.junit.Ignore;
 59 import org.junit.Test;
 60 
 61 /**
 62  *
 63  * Then we need to write some tests for LabelSkin, such that we test the layout
 64  * of all these cases. Be sure to test when each of these properties has illegal
 65  * values, such as negative for graphicTextGap and null for contentDisplay and
 66  * so forth.
 67  */
 68 public class LabeledTest {
 69     private Labeled labeled;
 70 
 71     @Before public void setup() {
 72         labeled = new LabeledMock();
 73     }
 74 
 75     /********************************************************************************
 76      *                                                                              *
 77      *                           Tests for text property                            *
 78      *                                                                              *
 79      *  - default constructor has text initialized to empty string, graphic is null *
 80      *  - null passed to one-arg constructor results in empty string text           *
 81      *  - string passed to on-arg constructor is set as text                        *
 82      *  - null passed to two-arg constructor for text results in empty string text  *
 83      *  - string passed to two-arg constructor for text is set as text              *
 84      *  - any value passed as graphic to two-arg constructor is set as graphic      *
 85      *                                                                              *
 86      *******************************************************************************/
 87 
 88     @Test public void defaultConstructorShouldHaveNoGraphicAndEmptyString() {
 89         assertNull(labeled.getGraphic());
 90         assertEquals(&quot;&quot;, labeled.getText());
 91     }
 92 
 93     @Test public void oneArgConstructorShouldHaveNoGraphicAndSpecifiedString() {
 94         Labeled l2 = new LabeledMock(null);
 95         assertNull(l2.getGraphic());
 96         assertNull(l2.getText());
 97 
 98         l2 = new LabeledMock(&quot;&quot;);
 99         assertNull(l2.getGraphic());
100         assertEquals(&quot;&quot;, l2.getText());
101 
102         l2 = new LabeledMock(&quot;Hello&quot;);
103         assertNull(l2.getGraphic());
104         assertEquals(&quot;Hello&quot;, l2.getText());
105     }
106 
107     @Test public void twoArgConstructorShouldHaveSpecifiedGraphicAndSpecifiedString() {
108         Labeled l2 = new LabeledMock(null, null);
109         assertNull(l2.getGraphic());
110         assertNull(l2.getText());
111 
112         Rectangle rect = new Rectangle();
113         l2 = new LabeledMock(&quot;Hello&quot;, rect);
114         assertSame(rect, l2.getGraphic());
115         assertEquals(&quot;Hello&quot;, l2.getText());
116     }
117 
118     /********************************************************************************
119      *                                                                              *
120      *                           Tests for text property                            *
121      *                                                                              *
122      *  - can be null                                                               *
123      *  - set is honored                                                            *
124      *  - can be bound                                                              *
125      *  - if bound, impl_cssSettable returns false                                  *
126      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
127      *                                                                              *
128      *******************************************************************************/
129 
130     @Test public void textDefaultValueIsEmptyString() {
131         assertEquals(&quot;&quot;, labeled.getText());
132         assertEquals(&quot;&quot;, labeled.textProperty().get());
133     }
134 
135     @Test public void textCanBeNull() {
136         labeled.setText(null);
137         assertNull(labeled.getText());
138     }
139 
140     @Test public void settingTextValueShouldWork() {
141         labeled.setText(&quot;Hello World&quot;);
142         assertEquals(&quot;Hello World&quot;, labeled.getText());
143     }
144 
145     @Test public void settingTextAndThenCreatingAModelAndReadingTheValueStillWorks() {
146         labeled.setText(&quot;Hello World&quot;);
147         assertEquals(&quot;Hello World&quot;, labeled.textProperty().get());
148     }
149 
150     @Test public void textCanBeBound() {
151         StringProperty other = new SimpleStringProperty(&quot;Apples&quot;);
152         labeled.textProperty().bind(other);
153         assertEquals(&quot;Apples&quot;, labeled.getText());
154     }
155 
156     @Test public void cannotSpecifyTextViaCSS() {
157         try {
158             CssMetaData styleable = ((StyleableProperty)labeled.textProperty()).getCssMetaData();
159             assertNull(styleable);
160         } catch (ClassCastException ignored) {
161             // pass!
162         } catch (Exception e) {
163             org.junit.Assert.fail(e.toString());
164         }
165     }
166 
167     /********************************************************************************
168      *                                                                              *
169      *                         Tests for textFill property                          *
170      *                                                                              *
171      *  - can be null                                                               *
172      *  - set is honored                                                            *
173      *  - can be bound                                                              *
174      *  - is BLACK by default                                                       *
175      *  - if bound, impl_cssSettable returns false                                  *
176      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
177      *                                                                              *
178      *******************************************************************************/
179 
180     @Test public void textFillDefaultValueIsBLACK() {
181         assertSame(Color.BLACK, labeled.getTextFill());
182         assertSame(Color.BLACK, labeled.textFillProperty().get());
183     }
184 
185     @Test public void textFillCanBeNull() {
186         labeled.setTextFill(null);
187         assertNull(labeled.getTextFill());
188     }
189 
190     @Test public void settingTextFillValueShouldWork() {
191         labeled.setTextFill(Color.RED);
192         assertSame(Color.RED, labeled.getTextFill());
193     }
194 
195     @Test public void settingTextFillAndThenCreatingAModelAndReadingTheValueStillWorks() {
196         labeled.setTextFill(Color.RED);
197         assertSame(Color.RED, labeled.textFillProperty().get());
198     }
199 
200     @Test public void textFillCanBeBound() {
201         ObjectProperty&lt;Paint&gt; other = new SimpleObjectProperty&lt;Paint&gt;(Color.RED);
202         labeled.textFillProperty().bind(other);
203         assertSame(Color.RED, labeled.getTextFill());
204     }
205 
206     @Test public void whenTextFillIsBound_impl_cssSettable_ReturnsFalse() {
207         CssMetaData styleable = ((StyleableProperty)labeled.textFillProperty()).getCssMetaData();
208         assertTrue(styleable.isSettable(labeled));
209         ObjectProperty&lt;Paint&gt; other = new SimpleObjectProperty&lt;Paint&gt;(Color.RED);
210         labeled.textFillProperty().bind(other);
211         assertFalse(styleable.isSettable(labeled));
212 
213     }
214 
215     @Test public void whenTextFillIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
216         CssMetaData styleable = ((StyleableProperty)labeled.textFillProperty()).getCssMetaData();
217         assertTrue(styleable.isSettable(labeled));
218     }
219 
220     @Test public void canSpecifyTextFillViaCSS() {
221         ((StyleableProperty)labeled.textFillProperty()).applyStyle(null, Color.YELLOW);
222         assertSame(Color.YELLOW, labeled.getTextFill());
223     }
224 
225     @Test public void textFillBeanIsCorrect() {
226         assertSame(labeled, labeled.textFillProperty().getBean());
227     }
228 
229     @Test public void textFillNameIsCorrect() {
230         assertEquals(&quot;textFill&quot;, labeled.textFillProperty().getName());
231     }
232 
233     /********************************************************************************
234      *                                                                              *
235      *                         Tests for alignment property                         *
236      *                                                                              *
237      *  - can be null                                                               *
238      *  - set is honored                                                            *
239      *  - can be bound                                                              *
240      *  - default is &quot;CENTER_LEFT&quot;                                                  *
241      *  - if bound, impl_cssSettable returns false                                  *
242      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
243      *                                                                              *
244      *******************************************************************************/
245 
<a name="2" id="anc2"></a><span class="line-removed">246     @Ignore(&quot;This is not the default whilst we await a fix for RT-12212&quot;)</span>
247     @Test public void alignmentDefaultValueIsCENTER_LEFT() {
248         assertEquals(Pos.CENTER_LEFT, labeled.getAlignment());
249     }
250 
251     @Test public void alignmentCanBeNull() {
252         labeled.setAlignment(null);
253         assertNull(labeled.getAlignment());
254     }
255 
256     @Test public void settingAlignmentValueShouldWork() {
257         labeled.setAlignment(Pos.CENTER);
258         assertEquals(Pos.CENTER, labeled.getAlignment());
259     }
260 
261     @Test public void settingAlignmentAndThenCreatingAModelAndReadingTheValueStillWorks() {
262         labeled.setAlignment(Pos.CENTER);
263         assertEquals(Pos.CENTER, labeled.alignmentProperty().get());
264     }
265 
266     @Test public void alignmentCanBeBound() {
267         ObjectProperty&lt;Pos&gt; other = new SimpleObjectProperty&lt;Pos&gt;(Pos.BASELINE_RIGHT);
268         labeled.alignmentProperty().bind(other);
269         assertEquals(Pos.BASELINE_RIGHT, labeled.getAlignment());
270     }
271 
272     @Test public void whenAlignmentIsBound_impl_cssSettable_ReturnsFalse() {
273         CssMetaData styleable = ((StyleableProperty)labeled.alignmentProperty()).getCssMetaData();
274         ObjectProperty&lt;Pos&gt; other = new SimpleObjectProperty&lt;Pos&gt;(Pos.BASELINE_RIGHT);
275         labeled.alignmentProperty().bind(other);
276         assertFalse(styleable.isSettable(labeled));
277     }
278 
279     @Test public void whenAlignmentIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
280         CssMetaData styleable = ((StyleableProperty)labeled.alignmentProperty()).getCssMetaData();
281         assertTrue(styleable.isSettable(labeled));
282     }
283 
284     @Test public void canSpecifyAlignmentViaCSS() {
285         ((StyleableProperty)labeled.alignmentProperty()).applyStyle(null, Pos.CENTER_RIGHT);
286         assertEquals(Pos.CENTER_RIGHT, labeled.getAlignment());
287     }
288 
289     /********************************************************************************
290      *                                                                              *
291      *                           Tests for textAlignment                            *
292      *                                                                              *
293      *  - can be null                                                               *
294      *  - set is honored                                                            *
295      *  - can be bound                                                              *
296      *  - default is &quot;LEFT&quot;                                                         *
297      *  - if bound, impl_cssSettable returns false                                  *
298      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
299      *                                                                              *
300      *******************************************************************************/
301 
302     @Test public void textAlignmentDefaultValueIsLEFT() {
303         assertEquals(TextAlignment.LEFT, labeled.getTextAlignment());
304         assertEquals(TextAlignment.LEFT, labeled.textAlignmentProperty().get());
305     }
306 
307     @Test public void textAlignmentCanBeNull() {
308         labeled.setTextAlignment(null);
309         assertNull(labeled.getTextAlignment());
310     }
311 
312     @Test public void settingTextAlignmentValueShouldWork() {
313         labeled.setTextAlignment(TextAlignment.CENTER);
314         assertEquals(TextAlignment.CENTER, labeled.getTextAlignment());
315     }
316 
317     @Test public void settingTextAlignmentAndThenCreatingAModelAndReadingTheValueStillWorks() {
318         labeled.setTextAlignment(TextAlignment.CENTER);
319         assertEquals(TextAlignment.CENTER, labeled.textAlignmentProperty().get());
320     }
321 
322     @Test public void textAlignmentCanBeBound() {
323         ObjectProperty&lt;TextAlignment&gt; other = new SimpleObjectProperty&lt;TextAlignment&gt;(TextAlignment.RIGHT);
324         labeled.textAlignmentProperty().bind(other);
325         assertEquals(TextAlignment.RIGHT, labeled.getTextAlignment());
326     }
327 
328     @Test public void whenTextAlignmentIsBound_impl_cssSettable_ReturnsFalse() {
329         CssMetaData styleable = ((StyleableProperty)labeled.textAlignmentProperty()).getCssMetaData();
330         assertTrue(styleable.isSettable(labeled));
331         ObjectProperty&lt;TextAlignment&gt; other = new SimpleObjectProperty&lt;TextAlignment&gt;(TextAlignment.RIGHT);
332         labeled.textAlignmentProperty().bind(other);
333         assertFalse(styleable.isSettable(labeled));
334     }
335 
336     @Test public void whenTextAlignmentIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
337         CssMetaData styleable = ((StyleableProperty)labeled.textAlignmentProperty()).getCssMetaData();
338         assertTrue(styleable.isSettable(labeled));
339     }
340 
341     @Test public void canSpecifyTextAlignmentViaCSS() {
342         ((StyleableProperty)labeled.textAlignmentProperty()).applyStyle(null, TextAlignment.JUSTIFY);
343         assertEquals(TextAlignment.JUSTIFY, labeled.getTextAlignment());
344     }
345 
346     /********************************************************************************
347      *                                                                              *
348      *                            Tests for textOverrun                             *
349      *                                                                              *
350      *  - can be null                                                               *
351      *  - set is honored                                                            *
352      *  - can be bound                                                              *
353      *  - default is &quot;ELLIPSIS&quot;                                                     *
354      *  - if bound, impl_cssSettable returns false                                  *
355      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
356      *                                                                              *
357      *******************************************************************************/
358 
359     @Test public void textOverrunDefaultValueIsELLIPSIS() {
360         assertEquals(OverrunStyle.ELLIPSIS, labeled.getTextOverrun());
361         assertEquals(OverrunStyle.ELLIPSIS, labeled.textOverrunProperty().get());
362     }
363 
364     @Test public void textOverrunCanBeNull() {
365         labeled.setTextOverrun(null);
366         assertNull(labeled.getTextOverrun());
367     }
368 
369     @Test public void settingTextOverrunValueShouldWork() {
370         labeled.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);
371         assertEquals(OverrunStyle.CENTER_ELLIPSIS, labeled.getTextOverrun());
372     }
373 
374     @Test public void settingTextOverrunAndThenCreatingAModelAndReadingTheValueStillWorks() {
375         labeled.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);
376         assertEquals(OverrunStyle.CENTER_ELLIPSIS, labeled.textOverrunProperty().get());
377     }
378 
379     @Test public void textOverrunCanBeBound() {
380         ObjectProperty&lt;OverrunStyle&gt; other = new SimpleObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.LEADING_WORD_ELLIPSIS);
381         labeled.textOverrunProperty().bind(other);
382         assertEquals(OverrunStyle.LEADING_WORD_ELLIPSIS, labeled.getTextOverrun());
383     }
384 
385     @Test public void whenTextOverrunIsBound_impl_cssSettable_ReturnsFalse() {
386         CssMetaData styleable = ((StyleableProperty)labeled.textOverrunProperty()).getCssMetaData();
387         assertTrue(styleable.isSettable(labeled));
388         ObjectProperty&lt;OverrunStyle&gt; other = new SimpleObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.LEADING_WORD_ELLIPSIS);
389         labeled.textOverrunProperty().bind(other);
390         assertFalse(styleable.isSettable(labeled));
391     }
392 
393     @Test public void whenTextOverrunIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
394         CssMetaData styleable = ((StyleableProperty)labeled.textOverrunProperty()).getCssMetaData();
395         assertTrue(styleable.isSettable(labeled));
396     }
397 
398     @Test public void canSpecifyTextOverrunViaCSS() {
399         ((StyleableProperty)labeled.textOverrunProperty()).applyStyle(null, OverrunStyle.CENTER_WORD_ELLIPSIS);
400         assertEquals(OverrunStyle.CENTER_WORD_ELLIPSIS, labeled.getTextOverrun());
401     }
402 
403     /********************************************************************************
404      *                                                                              *
405      *                         Tests for wrapText property                          *
406      *                                                                              *
407      *  - set is honored                                                            *
408      *  - can be bound                                                              *
409      *  - default is false                                                          *
410      *  - contentBias changes based on wrapText                                     *
411      *  - if bound, impl_cssSettable returns false                                  *
412      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
413      *                                                                              *
414      *******************************************************************************/
415 
416     @Test public void wrapTextDefaultValueIsFalse() {
417         assertFalse(labeled.isWrapText());
418         assertFalse(labeled.wrapTextProperty().get());
419     }
420 
421     @Test public void settingWrapTextValueShouldWork() {
422         labeled.setWrapText(true);
423         assertTrue(labeled.isWrapText());
424     }
425 
426     @Test public void settingWrapTextAndThenCreatingAModelAndReadingTheValueStillWorks() {
427         labeled.setWrapText(true);
428         assertTrue(labeled.wrapTextProperty().get());
429     }
430 
431     @Test public void wrapTextCanBeBound() {
432         BooleanProperty other = new SimpleBooleanProperty(true);
433         labeled.wrapTextProperty().bind(other);
434         assertTrue(labeled.isWrapText());
435     }
436 
437     @Test public void whenWrapTextIsBound_impl_cssSettable_ReturnsFalse() {
438         CssMetaData styleable = ((StyleableProperty)labeled.wrapTextProperty()).getCssMetaData();
439         assertTrue(styleable.isSettable(labeled));
440         BooleanProperty other = new SimpleBooleanProperty(true);
441         labeled.wrapTextProperty().bind(other);
442         assertFalse(styleable.isSettable(labeled));
443     }
444 
445     @Test public void whenWrapTextIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
446         CssMetaData styleable = ((StyleableProperty)labeled.wrapTextProperty()).getCssMetaData();
447         assertTrue(styleable.isSettable(labeled));
448     }
449 
450     @Test public void whenWrapTextIsTrueContentBiasIsHorizontal() {
451         labeled.setWrapText(true);
452         assertEquals(Orientation.HORIZONTAL, labeled.getContentBias());
453     }
454 
455     @Test public void whenWrapTextIsFalseContentBiasIsNull() {
456         assertNull(labeled.getContentBias());
457     }
458 
459     @Test public void canSpecifyWrapTextViaCSS() {
460         ((StyleableProperty)labeled.wrapTextProperty()).applyStyle(null, Boolean.TRUE);
461         assertTrue(labeled.isWrapText());
462     }
463 
464     /********************************************************************************
465      *                                                                              *
466      *                           Tests for font property                            *
467      *                                                                              *
468      *  - can be null                                                               *
469      *  - set is honored                                                            *
470      *  - can be bound                                                              *
471      *  - default is Font.getDefault()                                              *
472      *  - if bound, impl_cssSettable returns false                                  *
473      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
474      *                                                                              *
475      *******************************************************************************/
476 
477     @Test public void fontDefaultValueIsFont_getDefault() {
478         final Font def = Font.getDefault();
479         assertEquals(def, labeled.getFont());
480         assertEquals(def, labeled.fontProperty().get());
481     }
482 
483     @Test public void fontCanBeNull() {
484         labeled.setFont(null);
485         assertNull(labeled.getFont());
486     }
487 
488     @Test public void settingFontValueShouldWork() {
489         final Font f = Font.font(&quot;Arial&quot;, 25);
490         labeled.setFont(f);
491         assertEquals(f, labeled.getFont());
492     }
493 
494     @Test public void settingFontAndThenCreatingAModelAndReadingTheValueStillWorks() {
495         final Font f = Font.font(&quot;Arial&quot;, 25);
496         labeled.setFont(f);
497         assertEquals(f, labeled.fontProperty().get());
498     }
499 
500     @Test public void fontCanBeBound() {
501         final Font f = Font.font(&quot;Arial&quot;, 25);
502         ObjectProperty&lt;Font&gt; other = new SimpleObjectProperty&lt;Font&gt;(f);
503         labeled.fontProperty().bind(other);
504         assertEquals(f, labeled.getFont());
505     }
506 
507     @Test public void whenFontIsBound_impl_cssSettable_ReturnsFalse() {
508         final Font f = Font.font(&quot;Arial&quot;, 25);
509         CssMetaData styleable = ((StyleableProperty)labeled.fontProperty()).getCssMetaData();
510         assertTrue(styleable.isSettable(labeled));
511         ObjectProperty&lt;Font&gt; other = new SimpleObjectProperty&lt;Font&gt;(f);
512         labeled.fontProperty().bind(other);
513         assertFalse(styleable.isSettable(labeled));
514     }
515 
516     @Test public void whenFontIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
517         final Font f = Font.font(&quot;Arial&quot;, 25);
518         CssMetaData styleable = ((StyleableProperty)labeled.fontProperty()).getCssMetaData();
519         assertTrue(styleable.isSettable(labeled));
520     }
521 
522     @Test public void canSpecifyFontViaCSS() {
523         final Font f = Font.font(&quot;Arial&quot;, 25);
524         ((StyleableProperty)labeled.fontProperty()).applyStyle(null, f);
525         assertEquals(f, labeled.getFont());
526     }
527 
528     /********************************************************************************
529      *                                                                              *
530      *                         Tests for graphic property                           *
531      *                                                                              *
532      *  - can be null                                                               *
533      *  - set is honored                                                            *
534      *  - can be bound                                                              *
535      *  - default is null                                                           *
536      *  - if bound, impl_cssSettable returns false                                  *
537      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
538      *                                                                              *
539      *******************************************************************************/
540 
541     @Test public void graphicDefaultValueIsNull() {
542         assertEquals(null, labeled.getGraphic());
543         assertEquals(null, labeled.graphicProperty().get());
544     }
545 
546     @Test public void graphicCanBeNull() {
547         labeled.setGraphic(new Rectangle());
548         labeled.setGraphic(null);
549         assertNull(labeled.getGraphic());
550     }
551 
552     @Test public void settingGraphicValueShouldWork() {
553         Rectangle r = new Rectangle();
554         labeled.setGraphic(r);
555         assertEquals(r, labeled.getGraphic());
556     }
557 
558     @Test public void settingGraphicAndThenCreatingAModelAndReadingTheValueStillWorks() {
559         Rectangle r = new Rectangle();
560         labeled.setGraphic(r);
561         assertEquals(r, labeled.graphicProperty().get());
562     }
563 
564     @Test public void graphicCanBeBound() {
565         Rectangle r = new Rectangle();
566         ObjectProperty&lt;Node&gt; other = new SimpleObjectProperty&lt;Node&gt;(r);
567         labeled.graphicProperty().bind(other);
568         assertEquals(r, labeled.getGraphic());
569     }
570 
571     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
572     @Test public void whenGraphicIsBound_impl_cssSettable_ReturnsFalse() {
573         CssMetaData styleable = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
574         assertTrue(styleable.isSettable(labeled));
575         Rectangle r = new Rectangle();
576         ObjectProperty&lt;Node&gt; other = new SimpleObjectProperty&lt;Node&gt;(r);
577         labeled.graphicProperty().bind(other);
578         assertFalse(styleable.isSettable(labeled));
579     }
580 
581     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
582     @Test public void whenGraphicIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
583         CssMetaData styleable = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
584         assertTrue(styleable.isSettable(labeled));
585     }
586 
587     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
588     @Test public void canSpecifyGraphicViaCSS() {
589         ((StyleableProperty)labeled.graphicProperty()).applyStyle(null, &quot;/some/url&quot;);
590         assertNotNull(labeled.getGraphic());
591     }
592 
593     /********************************************************************************
594      *                                                                              *
595      *                         Tests for underline property                         *
596      *                                                                              *
597      *  - set is honored                                                            *
598      *  - can be bound                                                              *
599      *  - default is false                                                          *
600      *  - if bound, impl_cssSettable returns false                                  *
601      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
602      *                                                                              *
603      *******************************************************************************/
604 
605     @Test public void underlineDefaultValueIsFalse() {
606         assertFalse(labeled.isUnderline());
607         assertFalse(labeled.underlineProperty().get());
608     }
609 
610     @Test public void settingUnderlineValueShouldWork() {
611         labeled.setUnderline(true);
612         assertTrue(labeled.isUnderline());
613     }
614 
615     @Test public void settingUnderlineAndThenCreatingAModelAndReadingTheValueStillWorks() {
616         labeled.setUnderline(true);
617         assertTrue(labeled.underlineProperty().get());
618     }
619 
620     @Test public void underlineCanBeBound() {
621         BooleanProperty other = new SimpleBooleanProperty(true);
622         labeled.underlineProperty().bind(other);
623         assertTrue(labeled.isUnderline());
624     }
625 
626     @Test public void whenUnderlineIsBound_impl_cssSettable_ReturnsFalse() {
627         CssMetaData styleable = ((StyleableProperty)labeled.underlineProperty()).getCssMetaData();
628         assertTrue(styleable.isSettable(labeled));
629         BooleanProperty other = new SimpleBooleanProperty(true);
630         labeled.underlineProperty().bind(other);
631         assertFalse(styleable.isSettable(labeled));
632     }
633 
634     @Test public void whenUnderlineIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
635         CssMetaData styleable = ((StyleableProperty)labeled.underlineProperty()).getCssMetaData();
636         assertTrue(styleable.isSettable(labeled));
637     }
638 
639     @Test public void canSpecifyUnderlineViaCSS() {
640         ((StyleableProperty)labeled.underlineProperty()).applyStyle(null, Boolean.TRUE);
641         assertTrue(labeled.isUnderline());
642     }
643 
644     /********************************************************************************
645      *                                                                              *
646      *                           Tests for contentDisplay                           *
647      *                                                                              *
648      *  - can be null                                                               *
649      *  - set is honored                                                            *
650      *  - can be bound                                                              *
651      *  - default is &quot;LEFT&quot;                                                         *
652      *  - if bound, impl_cssSettable returns false                                  *
653      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
654      *                                                                              *
655      *******************************************************************************/
656 
657     @Test public void contentDisplayDefaultValueIsLEFT() {
658         assertEquals(ContentDisplay.LEFT, labeled.getContentDisplay());
659         assertEquals(ContentDisplay.LEFT, labeled.contentDisplayProperty().get());
660     }
661 
662     @Test public void contentDisplayCanBeNull() {
663         labeled.setContentDisplay(null);
664         assertNull(labeled.getContentDisplay());
665     }
666 
667     @Test public void settingContentDisplayValueShouldWork() {
668         labeled.setContentDisplay(ContentDisplay.CENTER);
669         assertEquals(ContentDisplay.CENTER, labeled.getContentDisplay());
670     }
671 
672     @Test public void settingContentDisplayAndThenCreatingAModelAndReadingTheValueStillWorks() {
673         labeled.setContentDisplay(ContentDisplay.CENTER);
674         assertEquals(ContentDisplay.CENTER, labeled.contentDisplayProperty().get());
675     }
676 
677     @Test public void contentDisplayCanBeBound() {
678         ObjectProperty&lt;ContentDisplay&gt; other = new SimpleObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.RIGHT);
679         labeled.contentDisplayProperty().bind(other);
680         assertEquals(ContentDisplay.RIGHT, labeled.getContentDisplay());
681     }
682 
683     @Test public void whenContentDisplayIsBound_impl_cssSettable_ReturnsFalse() {
684         CssMetaData styleable = ((StyleableProperty)labeled.contentDisplayProperty()).getCssMetaData();
685         assertTrue(styleable.isSettable(labeled));
686         ObjectProperty&lt;ContentDisplay&gt; other = new SimpleObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.RIGHT);
687         labeled.contentDisplayProperty().bind(other);
688         assertFalse(styleable.isSettable(labeled));
689     }
690 
691     @Test public void whenContentDisplayIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
692         CssMetaData styleable = ((StyleableProperty)labeled.contentDisplayProperty()).getCssMetaData();
693         assertTrue(styleable.isSettable(labeled));
694     }
695 
696     @Test public void canSpecifyContentDisplayViaCSS() {
697         ((StyleableProperty)labeled.contentDisplayProperty()).applyStyle(null, ContentDisplay.GRAPHIC_ONLY);
698         assertSame(ContentDisplay.GRAPHIC_ONLY, labeled.getContentDisplay());
699     }
700 
701     /********************************************************************************
702      *                                                                              *
703      *                          Tests for graphicTextGap                            *
704      *                                                                              *
705      *  - set is honored                                                            *
706      *  - can be bound                                                              *
707      *  - default is 4                                                              *
708      *  - if bound, impl_cssSettable returns false                                  *
709      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
710      *                                                                              *
711      *******************************************************************************/
712 
713     @Test public void graphicTextGapDefaultValueIsFour() {
714         assertEquals(4, labeled.getGraphicTextGap(), 0);
715         assertEquals(4, labeled.graphicTextGapProperty().get(), 0);
716     }
717 
718     @Test public void settingGraphicTextGapValueShouldWork() {
719         labeled.setGraphicTextGap(8);
720         assertEquals(8, labeled.getGraphicTextGap(), 0);
721     }
722 
723     @Test public void settingGraphicTextGapNegativeShouldWork() {
724         labeled.setGraphicTextGap(-5.5);
725         assertEquals(-5.5, labeled.getGraphicTextGap(), 0);
726     }
727 
728     @Test public void settingGraphicTextGapAndThenCreatingAModelAndReadingTheValueStillWorks() {
729         labeled.setGraphicTextGap(8);
730         assertEquals(8, labeled.graphicTextGapProperty().get(), 0);
731     }
732 
733     @Test public void graphicTextGapCanBeBound() {
734         DoubleProperty other = new SimpleDoubleProperty(25);
735         labeled.graphicTextGapProperty().bind(other);
736         assertEquals(25, labeled.getGraphicTextGap(), 0);
737     }
738 
739     @Test public void whenGraphicTextGapIsBound_impl_cssSettable_ReturnsFalse() {
740         CssMetaData styleable = ((StyleableProperty)labeled.graphicTextGapProperty()).getCssMetaData();
741         assertTrue(styleable.isSettable(labeled));
742         DoubleProperty other = new SimpleDoubleProperty(25);
743         labeled.graphicTextGapProperty().bind(other);
744         assertFalse(styleable.isSettable(labeled));
745     }
746 
747     @Test public void whenGraphicTextGapIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
748         CssMetaData styleable = ((StyleableProperty)labeled.graphicTextGapProperty()).getCssMetaData();
749         assertTrue(styleable.isSettable(labeled));
750     }
751 
752     @Test public void canSpecifyGraphicTextGapViaCSS() {
753         ((StyleableProperty)labeled.graphicTextGapProperty()).applyStyle(null,  8.0);
754         assertEquals(8, labeled.getGraphicTextGap(), 0);
755     }
756 
757     /********************************************************************************
758      *                                                                              *
759      *                          Tests for labelPadding                              *
760      *                                                                              *
761      *******************************************************************************/
762 
763     @Test public void labelPaddingDefaultValueIsEmptyInsets() {
764         assertEquals(Insets.EMPTY, labeled.getLabelPadding());
765         assertEquals(Insets.EMPTY, labeled.labelPaddingProperty().get());
766     }
767 
<a name="3" id="anc3"></a><span class="line-removed">768     @Ignore (&quot;labelPaddingProperty returns read-only property&quot;)</span>
769     @Test public void canSpecifyLabelPaddingFromCSS() {
770         Insets insets = new Insets(5, 4, 3, 2);
<a name="4" id="anc4"></a><span class="line-modified">771 //        CssMetaData styleable = ((StyleableProperty)labeled.labelPaddingProperty()).getCssMetaData();</span>
<span class="line-modified">772 //        styleable.set(labeled,insets, null);</span>
773         assertEquals(insets, labeled.getLabelPadding());
774         assertEquals(insets, labeled.labelPaddingProperty().get());
775     }
776 
777     /********************************************************************************
778      *                                                                              *
779      *                             Helper classes and such                          *
780      *                                                                              *
781      *******************************************************************************/
782 
783     public static final class LabeledMock extends Labeled {
784         public LabeledMock() { super(); }
785         public LabeledMock(String text) { super(text); }
786         public LabeledMock(String text, Node graphic) { super(text, graphic); }
787     }
788 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>