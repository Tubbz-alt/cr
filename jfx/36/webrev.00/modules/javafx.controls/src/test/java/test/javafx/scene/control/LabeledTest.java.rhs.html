<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/LabeledTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package test.javafx.scene.control;
 27 
 28 import javafx.css.CssMetaData;
 29 import static org.junit.Assert.assertEquals;
 30 import static org.junit.Assert.assertFalse;
 31 import static org.junit.Assert.assertNotNull;
 32 import static org.junit.Assert.assertNull;
 33 import static org.junit.Assert.assertSame;
 34 import static org.junit.Assert.assertTrue;
 35 import javafx.beans.property.BooleanProperty;
 36 import javafx.beans.property.DoubleProperty;
 37 import javafx.beans.property.ObjectProperty;
 38 import javafx.beans.property.SimpleBooleanProperty;
 39 import javafx.beans.property.SimpleDoubleProperty;
 40 import javafx.beans.property.SimpleObjectProperty;
 41 import javafx.beans.property.SimpleStringProperty;
 42 import javafx.beans.property.StringProperty;
 43 import javafx.css.StyleableProperty;
 44 import javafx.geometry.Insets;
 45 import javafx.geometry.Orientation;
 46 import javafx.geometry.Pos;
 47 import javafx.scene.Node;
 48 import javafx.scene.control.ContentDisplay;
 49 import javafx.scene.control.Labeled;
 50 import javafx.scene.control.OverrunStyle;
 51 import javafx.scene.paint.Color;
 52 import javafx.scene.paint.Paint;
 53 import javafx.scene.shape.Rectangle;
 54 import javafx.scene.text.Font;
 55 import javafx.scene.text.TextAlignment;
 56 
 57 import org.junit.Before;
 58 import org.junit.Ignore;
 59 import org.junit.Test;
 60 
 61 /**
 62  *
 63  * Then we need to write some tests for LabelSkin, such that we test the layout
 64  * of all these cases. Be sure to test when each of these properties has illegal
 65  * values, such as negative for graphicTextGap and null for contentDisplay and
 66  * so forth.
 67  */
 68 public class LabeledTest {
 69     private Labeled labeled;
 70 
 71     @Before public void setup() {
 72         labeled = new LabeledMock();
 73     }
 74 
 75     /********************************************************************************
 76      *                                                                              *
 77      *                           Tests for text property                            *
 78      *                                                                              *
 79      *  - default constructor has text initialized to empty string, graphic is null *
 80      *  - null passed to one-arg constructor results in empty string text           *
 81      *  - string passed to on-arg constructor is set as text                        *
 82      *  - null passed to two-arg constructor for text results in empty string text  *
 83      *  - string passed to two-arg constructor for text is set as text              *
 84      *  - any value passed as graphic to two-arg constructor is set as graphic      *
 85      *                                                                              *
 86      *******************************************************************************/
 87 
 88     @Test public void defaultConstructorShouldHaveNoGraphicAndEmptyString() {
 89         assertNull(labeled.getGraphic());
 90         assertEquals(&quot;&quot;, labeled.getText());
 91     }
 92 
 93     @Test public void oneArgConstructorShouldHaveNoGraphicAndSpecifiedString() {
 94         Labeled l2 = new LabeledMock(null);
 95         assertNull(l2.getGraphic());
 96         assertNull(l2.getText());
 97 
 98         l2 = new LabeledMock(&quot;&quot;);
 99         assertNull(l2.getGraphic());
100         assertEquals(&quot;&quot;, l2.getText());
101 
102         l2 = new LabeledMock(&quot;Hello&quot;);
103         assertNull(l2.getGraphic());
104         assertEquals(&quot;Hello&quot;, l2.getText());
105     }
106 
107     @Test public void twoArgConstructorShouldHaveSpecifiedGraphicAndSpecifiedString() {
108         Labeled l2 = new LabeledMock(null, null);
109         assertNull(l2.getGraphic());
110         assertNull(l2.getText());
111 
112         Rectangle rect = new Rectangle();
113         l2 = new LabeledMock(&quot;Hello&quot;, rect);
114         assertSame(rect, l2.getGraphic());
115         assertEquals(&quot;Hello&quot;, l2.getText());
116     }
117 
118     /********************************************************************************
119      *                                                                              *
120      *                           Tests for text property                            *
121      *                                                                              *
122      *  - can be null                                                               *
123      *  - set is honored                                                            *
124      *  - can be bound                                                              *
125      *  - if bound, impl_cssSettable returns false                                  *
126      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
127      *                                                                              *
128      *******************************************************************************/
129 
130     @Test public void textDefaultValueIsEmptyString() {
131         assertEquals(&quot;&quot;, labeled.getText());
132         assertEquals(&quot;&quot;, labeled.textProperty().get());
133     }
134 
135     @Test public void textCanBeNull() {
136         labeled.setText(null);
137         assertNull(labeled.getText());
138     }
139 
140     @Test public void settingTextValueShouldWork() {
141         labeled.setText(&quot;Hello World&quot;);
142         assertEquals(&quot;Hello World&quot;, labeled.getText());
143     }
144 
145     @Test public void settingTextAndThenCreatingAModelAndReadingTheValueStillWorks() {
146         labeled.setText(&quot;Hello World&quot;);
147         assertEquals(&quot;Hello World&quot;, labeled.textProperty().get());
148     }
149 
150     @Test public void textCanBeBound() {
151         StringProperty other = new SimpleStringProperty(&quot;Apples&quot;);
152         labeled.textProperty().bind(other);
153         assertEquals(&quot;Apples&quot;, labeled.getText());
154     }
155 
156     @Test public void cannotSpecifyTextViaCSS() {
157         try {
158             CssMetaData styleable = ((StyleableProperty)labeled.textProperty()).getCssMetaData();
159             assertNull(styleable);
160         } catch (ClassCastException ignored) {
161             // pass!
162         } catch (Exception e) {
163             org.junit.Assert.fail(e.toString());
164         }
165     }
166 
167     /********************************************************************************
168      *                                                                              *
169      *                         Tests for textFill property                          *
170      *                                                                              *
171      *  - can be null                                                               *
172      *  - set is honored                                                            *
173      *  - can be bound                                                              *
174      *  - is BLACK by default                                                       *
175      *  - if bound, impl_cssSettable returns false                                  *
176      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
177      *                                                                              *
178      *******************************************************************************/
179 
180     @Test public void textFillDefaultValueIsBLACK() {
181         assertSame(Color.BLACK, labeled.getTextFill());
182         assertSame(Color.BLACK, labeled.textFillProperty().get());
183     }
184 
185     @Test public void textFillCanBeNull() {
186         labeled.setTextFill(null);
187         assertNull(labeled.getTextFill());
188     }
189 
190     @Test public void settingTextFillValueShouldWork() {
191         labeled.setTextFill(Color.RED);
192         assertSame(Color.RED, labeled.getTextFill());
193     }
194 
195     @Test public void settingTextFillAndThenCreatingAModelAndReadingTheValueStillWorks() {
196         labeled.setTextFill(Color.RED);
197         assertSame(Color.RED, labeled.textFillProperty().get());
198     }
199 
200     @Test public void textFillCanBeBound() {
201         ObjectProperty&lt;Paint&gt; other = new SimpleObjectProperty&lt;Paint&gt;(Color.RED);
202         labeled.textFillProperty().bind(other);
203         assertSame(Color.RED, labeled.getTextFill());
204     }
205 
206     @Test public void whenTextFillIsBound_impl_cssSettable_ReturnsFalse() {
207         CssMetaData styleable = ((StyleableProperty)labeled.textFillProperty()).getCssMetaData();
208         assertTrue(styleable.isSettable(labeled));
209         ObjectProperty&lt;Paint&gt; other = new SimpleObjectProperty&lt;Paint&gt;(Color.RED);
210         labeled.textFillProperty().bind(other);
211         assertFalse(styleable.isSettable(labeled));
212 
213     }
214 
215     @Test public void whenTextFillIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
216         CssMetaData styleable = ((StyleableProperty)labeled.textFillProperty()).getCssMetaData();
217         assertTrue(styleable.isSettable(labeled));
218     }
219 
220     @Test public void canSpecifyTextFillViaCSS() {
221         ((StyleableProperty)labeled.textFillProperty()).applyStyle(null, Color.YELLOW);
222         assertSame(Color.YELLOW, labeled.getTextFill());
223     }
224 
225     @Test public void textFillBeanIsCorrect() {
226         assertSame(labeled, labeled.textFillProperty().getBean());
227     }
228 
229     @Test public void textFillNameIsCorrect() {
230         assertEquals(&quot;textFill&quot;, labeled.textFillProperty().getName());
231     }
232 
233     /********************************************************************************
234      *                                                                              *
235      *                         Tests for alignment property                         *
236      *                                                                              *
237      *  - can be null                                                               *
238      *  - set is honored                                                            *
239      *  - can be bound                                                              *
240      *  - default is &quot;CENTER_LEFT&quot;                                                  *
241      *  - if bound, impl_cssSettable returns false                                  *
242      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
243      *                                                                              *
244      *******************************************************************************/
245 
<a name="2" id="anc2"></a>
246     @Test public void alignmentDefaultValueIsCENTER_LEFT() {
247         assertEquals(Pos.CENTER_LEFT, labeled.getAlignment());
248     }
249 
250     @Test public void alignmentCanBeNull() {
251         labeled.setAlignment(null);
252         assertNull(labeled.getAlignment());
253     }
254 
255     @Test public void settingAlignmentValueShouldWork() {
256         labeled.setAlignment(Pos.CENTER);
257         assertEquals(Pos.CENTER, labeled.getAlignment());
258     }
259 
260     @Test public void settingAlignmentAndThenCreatingAModelAndReadingTheValueStillWorks() {
261         labeled.setAlignment(Pos.CENTER);
262         assertEquals(Pos.CENTER, labeled.alignmentProperty().get());
263     }
264 
265     @Test public void alignmentCanBeBound() {
266         ObjectProperty&lt;Pos&gt; other = new SimpleObjectProperty&lt;Pos&gt;(Pos.BASELINE_RIGHT);
267         labeled.alignmentProperty().bind(other);
268         assertEquals(Pos.BASELINE_RIGHT, labeled.getAlignment());
269     }
270 
271     @Test public void whenAlignmentIsBound_impl_cssSettable_ReturnsFalse() {
272         CssMetaData styleable = ((StyleableProperty)labeled.alignmentProperty()).getCssMetaData();
273         ObjectProperty&lt;Pos&gt; other = new SimpleObjectProperty&lt;Pos&gt;(Pos.BASELINE_RIGHT);
274         labeled.alignmentProperty().bind(other);
275         assertFalse(styleable.isSettable(labeled));
276     }
277 
278     @Test public void whenAlignmentIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
279         CssMetaData styleable = ((StyleableProperty)labeled.alignmentProperty()).getCssMetaData();
280         assertTrue(styleable.isSettable(labeled));
281     }
282 
283     @Test public void canSpecifyAlignmentViaCSS() {
284         ((StyleableProperty)labeled.alignmentProperty()).applyStyle(null, Pos.CENTER_RIGHT);
285         assertEquals(Pos.CENTER_RIGHT, labeled.getAlignment());
286     }
287 
288     /********************************************************************************
289      *                                                                              *
290      *                           Tests for textAlignment                            *
291      *                                                                              *
292      *  - can be null                                                               *
293      *  - set is honored                                                            *
294      *  - can be bound                                                              *
295      *  - default is &quot;LEFT&quot;                                                         *
296      *  - if bound, impl_cssSettable returns false                                  *
297      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
298      *                                                                              *
299      *******************************************************************************/
300 
301     @Test public void textAlignmentDefaultValueIsLEFT() {
302         assertEquals(TextAlignment.LEFT, labeled.getTextAlignment());
303         assertEquals(TextAlignment.LEFT, labeled.textAlignmentProperty().get());
304     }
305 
306     @Test public void textAlignmentCanBeNull() {
307         labeled.setTextAlignment(null);
308         assertNull(labeled.getTextAlignment());
309     }
310 
311     @Test public void settingTextAlignmentValueShouldWork() {
312         labeled.setTextAlignment(TextAlignment.CENTER);
313         assertEquals(TextAlignment.CENTER, labeled.getTextAlignment());
314     }
315 
316     @Test public void settingTextAlignmentAndThenCreatingAModelAndReadingTheValueStillWorks() {
317         labeled.setTextAlignment(TextAlignment.CENTER);
318         assertEquals(TextAlignment.CENTER, labeled.textAlignmentProperty().get());
319     }
320 
321     @Test public void textAlignmentCanBeBound() {
322         ObjectProperty&lt;TextAlignment&gt; other = new SimpleObjectProperty&lt;TextAlignment&gt;(TextAlignment.RIGHT);
323         labeled.textAlignmentProperty().bind(other);
324         assertEquals(TextAlignment.RIGHT, labeled.getTextAlignment());
325     }
326 
327     @Test public void whenTextAlignmentIsBound_impl_cssSettable_ReturnsFalse() {
328         CssMetaData styleable = ((StyleableProperty)labeled.textAlignmentProperty()).getCssMetaData();
329         assertTrue(styleable.isSettable(labeled));
330         ObjectProperty&lt;TextAlignment&gt; other = new SimpleObjectProperty&lt;TextAlignment&gt;(TextAlignment.RIGHT);
331         labeled.textAlignmentProperty().bind(other);
332         assertFalse(styleable.isSettable(labeled));
333     }
334 
335     @Test public void whenTextAlignmentIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
336         CssMetaData styleable = ((StyleableProperty)labeled.textAlignmentProperty()).getCssMetaData();
337         assertTrue(styleable.isSettable(labeled));
338     }
339 
340     @Test public void canSpecifyTextAlignmentViaCSS() {
341         ((StyleableProperty)labeled.textAlignmentProperty()).applyStyle(null, TextAlignment.JUSTIFY);
342         assertEquals(TextAlignment.JUSTIFY, labeled.getTextAlignment());
343     }
344 
345     /********************************************************************************
346      *                                                                              *
347      *                            Tests for textOverrun                             *
348      *                                                                              *
349      *  - can be null                                                               *
350      *  - set is honored                                                            *
351      *  - can be bound                                                              *
352      *  - default is &quot;ELLIPSIS&quot;                                                     *
353      *  - if bound, impl_cssSettable returns false                                  *
354      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
355      *                                                                              *
356      *******************************************************************************/
357 
358     @Test public void textOverrunDefaultValueIsELLIPSIS() {
359         assertEquals(OverrunStyle.ELLIPSIS, labeled.getTextOverrun());
360         assertEquals(OverrunStyle.ELLIPSIS, labeled.textOverrunProperty().get());
361     }
362 
363     @Test public void textOverrunCanBeNull() {
364         labeled.setTextOverrun(null);
365         assertNull(labeled.getTextOverrun());
366     }
367 
368     @Test public void settingTextOverrunValueShouldWork() {
369         labeled.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);
370         assertEquals(OverrunStyle.CENTER_ELLIPSIS, labeled.getTextOverrun());
371     }
372 
373     @Test public void settingTextOverrunAndThenCreatingAModelAndReadingTheValueStillWorks() {
374         labeled.setTextOverrun(OverrunStyle.CENTER_ELLIPSIS);
375         assertEquals(OverrunStyle.CENTER_ELLIPSIS, labeled.textOverrunProperty().get());
376     }
377 
378     @Test public void textOverrunCanBeBound() {
379         ObjectProperty&lt;OverrunStyle&gt; other = new SimpleObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.LEADING_WORD_ELLIPSIS);
380         labeled.textOverrunProperty().bind(other);
381         assertEquals(OverrunStyle.LEADING_WORD_ELLIPSIS, labeled.getTextOverrun());
382     }
383 
384     @Test public void whenTextOverrunIsBound_impl_cssSettable_ReturnsFalse() {
385         CssMetaData styleable = ((StyleableProperty)labeled.textOverrunProperty()).getCssMetaData();
386         assertTrue(styleable.isSettable(labeled));
387         ObjectProperty&lt;OverrunStyle&gt; other = new SimpleObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.LEADING_WORD_ELLIPSIS);
388         labeled.textOverrunProperty().bind(other);
389         assertFalse(styleable.isSettable(labeled));
390     }
391 
392     @Test public void whenTextOverrunIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
393         CssMetaData styleable = ((StyleableProperty)labeled.textOverrunProperty()).getCssMetaData();
394         assertTrue(styleable.isSettable(labeled));
395     }
396 
397     @Test public void canSpecifyTextOverrunViaCSS() {
398         ((StyleableProperty)labeled.textOverrunProperty()).applyStyle(null, OverrunStyle.CENTER_WORD_ELLIPSIS);
399         assertEquals(OverrunStyle.CENTER_WORD_ELLIPSIS, labeled.getTextOverrun());
400     }
401 
402     /********************************************************************************
403      *                                                                              *
404      *                         Tests for wrapText property                          *
405      *                                                                              *
406      *  - set is honored                                                            *
407      *  - can be bound                                                              *
408      *  - default is false                                                          *
409      *  - contentBias changes based on wrapText                                     *
410      *  - if bound, impl_cssSettable returns false                                  *
411      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
412      *                                                                              *
413      *******************************************************************************/
414 
415     @Test public void wrapTextDefaultValueIsFalse() {
416         assertFalse(labeled.isWrapText());
417         assertFalse(labeled.wrapTextProperty().get());
418     }
419 
420     @Test public void settingWrapTextValueShouldWork() {
421         labeled.setWrapText(true);
422         assertTrue(labeled.isWrapText());
423     }
424 
425     @Test public void settingWrapTextAndThenCreatingAModelAndReadingTheValueStillWorks() {
426         labeled.setWrapText(true);
427         assertTrue(labeled.wrapTextProperty().get());
428     }
429 
430     @Test public void wrapTextCanBeBound() {
431         BooleanProperty other = new SimpleBooleanProperty(true);
432         labeled.wrapTextProperty().bind(other);
433         assertTrue(labeled.isWrapText());
434     }
435 
436     @Test public void whenWrapTextIsBound_impl_cssSettable_ReturnsFalse() {
437         CssMetaData styleable = ((StyleableProperty)labeled.wrapTextProperty()).getCssMetaData();
438         assertTrue(styleable.isSettable(labeled));
439         BooleanProperty other = new SimpleBooleanProperty(true);
440         labeled.wrapTextProperty().bind(other);
441         assertFalse(styleable.isSettable(labeled));
442     }
443 
444     @Test public void whenWrapTextIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
445         CssMetaData styleable = ((StyleableProperty)labeled.wrapTextProperty()).getCssMetaData();
446         assertTrue(styleable.isSettable(labeled));
447     }
448 
449     @Test public void whenWrapTextIsTrueContentBiasIsHorizontal() {
450         labeled.setWrapText(true);
451         assertEquals(Orientation.HORIZONTAL, labeled.getContentBias());
452     }
453 
454     @Test public void whenWrapTextIsFalseContentBiasIsNull() {
455         assertNull(labeled.getContentBias());
456     }
457 
458     @Test public void canSpecifyWrapTextViaCSS() {
459         ((StyleableProperty)labeled.wrapTextProperty()).applyStyle(null, Boolean.TRUE);
460         assertTrue(labeled.isWrapText());
461     }
462 
463     /********************************************************************************
464      *                                                                              *
465      *                           Tests for font property                            *
466      *                                                                              *
467      *  - can be null                                                               *
468      *  - set is honored                                                            *
469      *  - can be bound                                                              *
470      *  - default is Font.getDefault()                                              *
471      *  - if bound, impl_cssSettable returns false                                  *
472      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
473      *                                                                              *
474      *******************************************************************************/
475 
476     @Test public void fontDefaultValueIsFont_getDefault() {
477         final Font def = Font.getDefault();
478         assertEquals(def, labeled.getFont());
479         assertEquals(def, labeled.fontProperty().get());
480     }
481 
482     @Test public void fontCanBeNull() {
483         labeled.setFont(null);
484         assertNull(labeled.getFont());
485     }
486 
487     @Test public void settingFontValueShouldWork() {
488         final Font f = Font.font(&quot;Arial&quot;, 25);
489         labeled.setFont(f);
490         assertEquals(f, labeled.getFont());
491     }
492 
493     @Test public void settingFontAndThenCreatingAModelAndReadingTheValueStillWorks() {
494         final Font f = Font.font(&quot;Arial&quot;, 25);
495         labeled.setFont(f);
496         assertEquals(f, labeled.fontProperty().get());
497     }
498 
499     @Test public void fontCanBeBound() {
500         final Font f = Font.font(&quot;Arial&quot;, 25);
501         ObjectProperty&lt;Font&gt; other = new SimpleObjectProperty&lt;Font&gt;(f);
502         labeled.fontProperty().bind(other);
503         assertEquals(f, labeled.getFont());
504     }
505 
506     @Test public void whenFontIsBound_impl_cssSettable_ReturnsFalse() {
507         final Font f = Font.font(&quot;Arial&quot;, 25);
508         CssMetaData styleable = ((StyleableProperty)labeled.fontProperty()).getCssMetaData();
509         assertTrue(styleable.isSettable(labeled));
510         ObjectProperty&lt;Font&gt; other = new SimpleObjectProperty&lt;Font&gt;(f);
511         labeled.fontProperty().bind(other);
512         assertFalse(styleable.isSettable(labeled));
513     }
514 
515     @Test public void whenFontIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
516         final Font f = Font.font(&quot;Arial&quot;, 25);
517         CssMetaData styleable = ((StyleableProperty)labeled.fontProperty()).getCssMetaData();
518         assertTrue(styleable.isSettable(labeled));
519     }
520 
521     @Test public void canSpecifyFontViaCSS() {
522         final Font f = Font.font(&quot;Arial&quot;, 25);
523         ((StyleableProperty)labeled.fontProperty()).applyStyle(null, f);
524         assertEquals(f, labeled.getFont());
525     }
526 
527     /********************************************************************************
528      *                                                                              *
529      *                         Tests for graphic property                           *
530      *                                                                              *
531      *  - can be null                                                               *
532      *  - set is honored                                                            *
533      *  - can be bound                                                              *
534      *  - default is null                                                           *
535      *  - if bound, impl_cssSettable returns false                                  *
536      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
537      *                                                                              *
538      *******************************************************************************/
539 
540     @Test public void graphicDefaultValueIsNull() {
541         assertEquals(null, labeled.getGraphic());
542         assertEquals(null, labeled.graphicProperty().get());
543     }
544 
545     @Test public void graphicCanBeNull() {
546         labeled.setGraphic(new Rectangle());
547         labeled.setGraphic(null);
548         assertNull(labeled.getGraphic());
549     }
550 
551     @Test public void settingGraphicValueShouldWork() {
552         Rectangle r = new Rectangle();
553         labeled.setGraphic(r);
554         assertEquals(r, labeled.getGraphic());
555     }
556 
557     @Test public void settingGraphicAndThenCreatingAModelAndReadingTheValueStillWorks() {
558         Rectangle r = new Rectangle();
559         labeled.setGraphic(r);
560         assertEquals(r, labeled.graphicProperty().get());
561     }
562 
563     @Test public void graphicCanBeBound() {
564         Rectangle r = new Rectangle();
565         ObjectProperty&lt;Node&gt; other = new SimpleObjectProperty&lt;Node&gt;(r);
566         labeled.graphicProperty().bind(other);
567         assertEquals(r, labeled.getGraphic());
568     }
569 
570     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
571     @Test public void whenGraphicIsBound_impl_cssSettable_ReturnsFalse() {
572         CssMetaData styleable = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
573         assertTrue(styleable.isSettable(labeled));
574         Rectangle r = new Rectangle();
575         ObjectProperty&lt;Node&gt; other = new SimpleObjectProperty&lt;Node&gt;(r);
576         labeled.graphicProperty().bind(other);
577         assertFalse(styleable.isSettable(labeled));
578     }
579 
580     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
581     @Test public void whenGraphicIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
582         CssMetaData styleable = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
583         assertTrue(styleable.isSettable(labeled));
584     }
585 
586     @Ignore (&quot;CSS Graphic must be a URL, and then it will try to load the image. Not sure how to test.&quot;)
587     @Test public void canSpecifyGraphicViaCSS() {
588         ((StyleableProperty)labeled.graphicProperty()).applyStyle(null, &quot;/some/url&quot;);
589         assertNotNull(labeled.getGraphic());
590     }
591 
592     /********************************************************************************
593      *                                                                              *
594      *                         Tests for underline property                         *
595      *                                                                              *
596      *  - set is honored                                                            *
597      *  - can be bound                                                              *
598      *  - default is false                                                          *
599      *  - if bound, impl_cssSettable returns false                                  *
600      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
601      *                                                                              *
602      *******************************************************************************/
603 
604     @Test public void underlineDefaultValueIsFalse() {
605         assertFalse(labeled.isUnderline());
606         assertFalse(labeled.underlineProperty().get());
607     }
608 
609     @Test public void settingUnderlineValueShouldWork() {
610         labeled.setUnderline(true);
611         assertTrue(labeled.isUnderline());
612     }
613 
614     @Test public void settingUnderlineAndThenCreatingAModelAndReadingTheValueStillWorks() {
615         labeled.setUnderline(true);
616         assertTrue(labeled.underlineProperty().get());
617     }
618 
619     @Test public void underlineCanBeBound() {
620         BooleanProperty other = new SimpleBooleanProperty(true);
621         labeled.underlineProperty().bind(other);
622         assertTrue(labeled.isUnderline());
623     }
624 
625     @Test public void whenUnderlineIsBound_impl_cssSettable_ReturnsFalse() {
626         CssMetaData styleable = ((StyleableProperty)labeled.underlineProperty()).getCssMetaData();
627         assertTrue(styleable.isSettable(labeled));
628         BooleanProperty other = new SimpleBooleanProperty(true);
629         labeled.underlineProperty().bind(other);
630         assertFalse(styleable.isSettable(labeled));
631     }
632 
633     @Test public void whenUnderlineIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
634         CssMetaData styleable = ((StyleableProperty)labeled.underlineProperty()).getCssMetaData();
635         assertTrue(styleable.isSettable(labeled));
636     }
637 
638     @Test public void canSpecifyUnderlineViaCSS() {
639         ((StyleableProperty)labeled.underlineProperty()).applyStyle(null, Boolean.TRUE);
640         assertTrue(labeled.isUnderline());
641     }
642 
643     /********************************************************************************
644      *                                                                              *
645      *                           Tests for contentDisplay                           *
646      *                                                                              *
647      *  - can be null                                                               *
648      *  - set is honored                                                            *
649      *  - can be bound                                                              *
650      *  - default is &quot;LEFT&quot;                                                         *
651      *  - if bound, impl_cssSettable returns false                                  *
652      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
653      *                                                                              *
654      *******************************************************************************/
655 
656     @Test public void contentDisplayDefaultValueIsLEFT() {
657         assertEquals(ContentDisplay.LEFT, labeled.getContentDisplay());
658         assertEquals(ContentDisplay.LEFT, labeled.contentDisplayProperty().get());
659     }
660 
661     @Test public void contentDisplayCanBeNull() {
662         labeled.setContentDisplay(null);
663         assertNull(labeled.getContentDisplay());
664     }
665 
666     @Test public void settingContentDisplayValueShouldWork() {
667         labeled.setContentDisplay(ContentDisplay.CENTER);
668         assertEquals(ContentDisplay.CENTER, labeled.getContentDisplay());
669     }
670 
671     @Test public void settingContentDisplayAndThenCreatingAModelAndReadingTheValueStillWorks() {
672         labeled.setContentDisplay(ContentDisplay.CENTER);
673         assertEquals(ContentDisplay.CENTER, labeled.contentDisplayProperty().get());
674     }
675 
676     @Test public void contentDisplayCanBeBound() {
677         ObjectProperty&lt;ContentDisplay&gt; other = new SimpleObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.RIGHT);
678         labeled.contentDisplayProperty().bind(other);
679         assertEquals(ContentDisplay.RIGHT, labeled.getContentDisplay());
680     }
681 
682     @Test public void whenContentDisplayIsBound_impl_cssSettable_ReturnsFalse() {
683         CssMetaData styleable = ((StyleableProperty)labeled.contentDisplayProperty()).getCssMetaData();
684         assertTrue(styleable.isSettable(labeled));
685         ObjectProperty&lt;ContentDisplay&gt; other = new SimpleObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.RIGHT);
686         labeled.contentDisplayProperty().bind(other);
687         assertFalse(styleable.isSettable(labeled));
688     }
689 
690     @Test public void whenContentDisplayIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
691         CssMetaData styleable = ((StyleableProperty)labeled.contentDisplayProperty()).getCssMetaData();
692         assertTrue(styleable.isSettable(labeled));
693     }
694 
695     @Test public void canSpecifyContentDisplayViaCSS() {
696         ((StyleableProperty)labeled.contentDisplayProperty()).applyStyle(null, ContentDisplay.GRAPHIC_ONLY);
697         assertSame(ContentDisplay.GRAPHIC_ONLY, labeled.getContentDisplay());
698     }
699 
700     /********************************************************************************
701      *                                                                              *
702      *                          Tests for graphicTextGap                            *
703      *                                                                              *
704      *  - set is honored                                                            *
705      *  - can be bound                                                              *
706      *  - default is 4                                                              *
707      *  - if bound, impl_cssSettable returns false                                  *
708      *  - if specified via CSS and not bound, impl_cssSettable returns true         *
709      *                                                                              *
710      *******************************************************************************/
711 
712     @Test public void graphicTextGapDefaultValueIsFour() {
713         assertEquals(4, labeled.getGraphicTextGap(), 0);
714         assertEquals(4, labeled.graphicTextGapProperty().get(), 0);
715     }
716 
717     @Test public void settingGraphicTextGapValueShouldWork() {
718         labeled.setGraphicTextGap(8);
719         assertEquals(8, labeled.getGraphicTextGap(), 0);
720     }
721 
722     @Test public void settingGraphicTextGapNegativeShouldWork() {
723         labeled.setGraphicTextGap(-5.5);
724         assertEquals(-5.5, labeled.getGraphicTextGap(), 0);
725     }
726 
727     @Test public void settingGraphicTextGapAndThenCreatingAModelAndReadingTheValueStillWorks() {
728         labeled.setGraphicTextGap(8);
729         assertEquals(8, labeled.graphicTextGapProperty().get(), 0);
730     }
731 
732     @Test public void graphicTextGapCanBeBound() {
733         DoubleProperty other = new SimpleDoubleProperty(25);
734         labeled.graphicTextGapProperty().bind(other);
735         assertEquals(25, labeled.getGraphicTextGap(), 0);
736     }
737 
738     @Test public void whenGraphicTextGapIsBound_impl_cssSettable_ReturnsFalse() {
739         CssMetaData styleable = ((StyleableProperty)labeled.graphicTextGapProperty()).getCssMetaData();
740         assertTrue(styleable.isSettable(labeled));
741         DoubleProperty other = new SimpleDoubleProperty(25);
742         labeled.graphicTextGapProperty().bind(other);
743         assertFalse(styleable.isSettable(labeled));
744     }
745 
746     @Test public void whenGraphicTextGapIsSpecifiedViaCSSAndIsNotBound_impl_cssSettable_ReturnsTrue() {
747         CssMetaData styleable = ((StyleableProperty)labeled.graphicTextGapProperty()).getCssMetaData();
748         assertTrue(styleable.isSettable(labeled));
749     }
750 
751     @Test public void canSpecifyGraphicTextGapViaCSS() {
752         ((StyleableProperty)labeled.graphicTextGapProperty()).applyStyle(null,  8.0);
753         assertEquals(8, labeled.getGraphicTextGap(), 0);
754     }
755 
756     /********************************************************************************
757      *                                                                              *
758      *                          Tests for labelPadding                              *
759      *                                                                              *
760      *******************************************************************************/
761 
762     @Test public void labelPaddingDefaultValueIsEmptyInsets() {
763         assertEquals(Insets.EMPTY, labeled.getLabelPadding());
764         assertEquals(Insets.EMPTY, labeled.labelPaddingProperty().get());
765     }
766 
<a name="3" id="anc3"></a>
767     @Test public void canSpecifyLabelPaddingFromCSS() {
768         Insets insets = new Insets(5, 4, 3, 2);
<a name="4" id="anc4"></a><span class="line-modified">769         CssMetaData styleable = ((StyleableProperty)labeled.labelPaddingProperty()).getCssMetaData();</span>
<span class="line-modified">770         styleable.set(labeled, insets, null);</span>
771         assertEquals(insets, labeled.getLabelPadding());
772         assertEquals(insets, labeled.labelPaddingProperty().get());
773     }
774 
775     /********************************************************************************
776      *                                                                              *
777      *                             Helper classes and such                          *
778      *                                                                              *
779      *******************************************************************************/
780 
781     public static final class LabeledMock extends Labeled {
782         public LabeledMock() { super(); }
783         public LabeledMock(String text) { super(text); }
784         public LabeledMock(String text, Node graphic) { super(text, graphic); }
785     }
786 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>