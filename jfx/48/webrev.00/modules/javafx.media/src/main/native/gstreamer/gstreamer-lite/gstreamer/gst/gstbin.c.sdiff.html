<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbin.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstallocator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbin.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbin.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 127  *
 128  */
 129 
 130 #include &quot;gst_private.h&quot;
 131 
 132 #include &quot;gstevent.h&quot;
 133 #include &quot;gstbin.h&quot;
 134 #include &quot;gstinfo.h&quot;
 135 #include &quot;gsterror.h&quot;
 136 
 137 #include &quot;gstutils.h&quot;
 138 #include &quot;gstchildproxy.h&quot;
 139 
 140 GST_DEBUG_CATEGORY_STATIC (bin_debug);
 141 #define GST_CAT_DEFAULT bin_debug
 142 
 143 /* a bin is toplevel if it has no parent or when it is configured to behave like
 144  * a toplevel bin */
 145 #define BIN_IS_TOPLEVEL(bin) ((GST_OBJECT_PARENT (bin) == NULL) || bin-&gt;priv-&gt;asynchandling)
 146 
<span class="line-removed"> 147 #define GST_BIN_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 148    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BIN, GstBinPrivate))</span>
<span class="line-removed"> 149 </span>
 150 struct _GstBinPrivate
 151 {
 152   gboolean asynchandling;
 153   /* if we get an ASYNC_DONE message from ourselves, this means that the
 154    * subclass will simulate ASYNC behaviour without having ASYNC children. When
 155    * such an ASYNC_DONE message is posted while we are doing a state change, we
 156    * have to process the message after finishing the state change even when no
 157    * child returned GST_STATE_CHANGE_ASYNC. */
 158   gboolean pending_async_done;
 159 
 160   guint32 structure_cookie;
 161 
 162 #if 0
 163   /* cached index */
 164   GstIndex *index;
 165 #endif
 166 
 167   /* forward messages from our children */
 168   gboolean message_forward;
 169 
</pre>
<hr />
<pre>
 255 
 256 static void gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data);
 257 
 258 static guint gst_bin_signals[LAST_SIGNAL] = { 0 };
 259 
 260 #define _do_init \
 261 { \
 262   static const GInterfaceInfo iface_info = { \
 263     gst_bin_child_proxy_init, \
 264     NULL, \
 265     NULL}; \
 266   \
 267   g_type_add_interface_static (g_define_type_id, GST_TYPE_CHILD_PROXY, &amp;iface_info); \
 268   \
 269   GST_DEBUG_CATEGORY_INIT (bin_debug, &quot;bin&quot;, GST_DEBUG_BOLD, \
 270       &quot;debugging info for the &#39;bin&#39; container element&quot;); \
 271   \
 272 }
 273 
 274 #define gst_bin_parent_class parent_class
<span class="line-modified"> 275 G_DEFINE_TYPE_WITH_CODE (GstBin, gst_bin, GST_TYPE_ELEMENT, _do_init);</span>


 276 
 277 static GObject *
 278 gst_bin_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
 279     guint index)
 280 {
 281   GstObject *res;
 282   GstBin *bin;
 283 
 284   bin = GST_BIN_CAST (child_proxy);
 285 
 286   GST_OBJECT_LOCK (bin);
 287   if ((res = g_list_nth_data (bin-&gt;children, index)))
 288     gst_object_ref (res);
 289   GST_OBJECT_UNLOCK (bin);
 290 
 291   return (GObject *) res;
 292 }
 293 
 294 static guint
 295 gst_bin_child_proxy_get_children_count (GstChildProxy * child_proxy)
</pre>
<hr />
<pre>
 323 
 324   myboolean = g_value_get_boolean (handler_return);
 325   if (!(ihint-&gt;run_type &amp; G_SIGNAL_RUN_CLEANUP))
 326     g_value_set_boolean (return_accu, myboolean);
 327 
 328   GST_DEBUG (&quot;invocation %d, %d&quot;, ihint-&gt;run_type, myboolean);
 329 
 330   /* stop emission */
 331   return FALSE;
 332 }
 333 
 334 static void
 335 gst_bin_class_init (GstBinClass * klass)
 336 {
 337   GObjectClass *gobject_class;
 338   GstElementClass *gstelement_class;
 339 
 340   gobject_class = (GObjectClass *) klass;
 341   gstelement_class = (GstElementClass *) klass;
 342 
<span class="line-removed"> 343   g_type_class_add_private (klass, sizeof (GstBinPrivate));</span>
<span class="line-removed"> 344 </span>
 345   gobject_class-&gt;set_property = gst_bin_set_property;
 346   gobject_class-&gt;get_property = gst_bin_get_property;
 347 
 348   /**
 349    * GstBin:async-handling:
 350    *
 351    * If set to %TRUE, the bin will handle asynchronous state changes.
 352    * This should be used only if the bin subclass is modifying the state
 353    * of its children on its own.
 354    */
 355   g_object_class_install_property (gobject_class, PROP_ASYNC_HANDLING,
 356       g_param_spec_boolean (&quot;async-handling&quot;, &quot;Async Handling&quot;,
 357           &quot;The bin will handle Asynchronous state changes&quot;,
 358           DEFAULT_ASYNC_HANDLING, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 359 
 360   /**
 361    * GstBin::element-added:
 362    * @bin: the #GstBin
 363    * @element: the #GstElement that was added to the bin
 364    *
</pre>
<hr />
<pre>
 463 #if 0
 464   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_bin_get_index_func);
 465   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_bin_set_index_func);
 466 #endif
 467   gstelement_class-&gt;provide_clock =
 468       GST_DEBUG_FUNCPTR (gst_bin_provide_clock_func);
 469   gstelement_class-&gt;set_clock = GST_DEBUG_FUNCPTR (gst_bin_set_clock_func);
 470 
 471   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_bin_send_event);
 472   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_bin_query);
 473   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_bin_set_context);
 474 
 475   klass-&gt;add_element = GST_DEBUG_FUNCPTR (gst_bin_add_func);
 476   klass-&gt;remove_element = GST_DEBUG_FUNCPTR (gst_bin_remove_func);
 477   klass-&gt;handle_message = GST_DEBUG_FUNCPTR (gst_bin_handle_message_func);
 478 
 479   klass-&gt;deep_element_added = gst_bin_deep_element_added_func;
 480   klass-&gt;deep_element_removed = gst_bin_deep_element_removed_func;
 481 
 482   klass-&gt;do_latency = GST_DEBUG_FUNCPTR (gst_bin_do_latency_func);
<span class="line-modified"> 483   }</span>
 484 
 485 static void
 486 gst_bin_init (GstBin * bin)
 487 {
 488   GstBus *bus;
 489 
 490   bin-&gt;numchildren = 0;
 491   bin-&gt;children = NULL;
 492   bin-&gt;children_cookie = 0;
 493   bin-&gt;messages = NULL;
 494   bin-&gt;provided_clock = NULL;
 495   bin-&gt;clock_dirty = FALSE;
 496 
 497   /* Set up a bus for listening to child elements */
 498   bus = g_object_new (GST_TYPE_BUS, &quot;enable-async&quot;, FALSE, NULL);
 499   gst_object_ref_sink (bus);
 500   bin-&gt;child_bus = bus;
 501   GST_DEBUG_OBJECT (bin, &quot;using bus %&quot; GST_PTR_FORMAT &quot; to listen to children&quot;,
 502       bus);
 503   gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bin_bus_handler, bin,
 504       NULL);
 505 
<span class="line-modified"> 506   bin-&gt;priv = GST_BIN_GET_PRIVATE (bin);</span>
 507   bin-&gt;priv-&gt;asynchandling = DEFAULT_ASYNC_HANDLING;
 508   bin-&gt;priv-&gt;structure_cookie = 0;
 509   bin-&gt;priv-&gt;message_forward = DEFAULT_MESSAGE_FORWARD;
 510 }
 511 
 512 static void
 513 gst_bin_dispose (GObject * object)
 514 {
 515   GstBin *bin = GST_BIN_CAST (object);
 516   GstBus **child_bus_p = &amp;bin-&gt;child_bus;
 517   GstClock **provided_clock_p = &amp;bin-&gt;provided_clock;
 518   GstElement **clock_provider_p = &amp;bin-&gt;clock_provider;
 519 
 520   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p dispose&quot;, object);
 521 
 522   GST_OBJECT_LOCK (object);
 523   gst_object_replace ((GstObject **) child_bus_p, NULL);
 524   gst_object_replace ((GstObject **) provided_clock_p, NULL);
 525   gst_object_replace ((GstObject **) clock_provider_p, NULL);
 526   bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
</pre>
<hr />
<pre>
1108     GQueue elements = G_QUEUE_INIT;
1109 
1110     GST_LOG_OBJECT (bin, &quot;Recursing into bin %&quot; GST_PTR_FORMAT &quot; for %s&quot;,
1111         element, sig_name);
1112     it = gst_bin_iterate_recurse (GST_BIN_CAST (element));
1113     do {
1114       ires = gst_iterator_foreach (it, bin_deep_iterator_foreach, &amp;elements);
1115       if (ires != GST_ITERATOR_DONE) {
1116         g_queue_foreach (&amp;elements, (GFunc) g_object_unref, NULL);
1117         g_queue_clear (&amp;elements);
1118       }
1119       if (ires == GST_ITERATOR_RESYNC)
1120         gst_iterator_resync (it);
1121     } while (ires == GST_ITERATOR_RESYNC);
1122     if (ires != GST_ITERATOR_ERROR) {
1123       GstElement *e;
1124 
1125       while ((e = g_queue_pop_head (&amp;elements))) {
1126         GstObject *parent = gst_object_get_parent (GST_OBJECT_CAST (e));
1127 
<span class="line-modified">1128         GST_LOG_OBJECT (bin, &quot;calling %s for element %&quot; GST_PTR_FORMAT</span>
<span class="line-modified">1129             &quot; in bin %&quot; GST_PTR_FORMAT, sig_name, e, parent);</span>
<span class="line-modified">1130         g_signal_emit (bin, sig_id, 0, parent, e);</span>
<span class="line-modified">1131         gst_object_unref (parent);</span>
<span class="line-modified">1132         g_object_unref (e);</span>




1133       }
1134     }
1135     gst_iterator_free (it);
1136   }
1137 }
1138 
1139 /* vmethod that adds an element to a bin
1140  *
1141  * MT safe
1142  */
1143 static gboolean
1144 gst_bin_add_func (GstBin * bin, GstElement * element)
1145 {
1146   gchar *elem_name;
1147   GstIterator *it;
1148   gboolean is_sink, is_source, provides_clock, requires_clock;
1149   GstMessage *clock_message = NULL, *async_message = NULL;
1150   GstStateChangeReturn ret;
1151   GList *l, *elem_contexts, *need_context_messages;
1152 
</pre>
<hr />
<pre>
2563       if (child_current &lt;= next) {
2564         /* .. and is already past the requested state, assume it got there
2565          * without error */
2566         ret = GST_STATE_CHANGE_SUCCESS;
2567         goto unneeded;
2568       }
2569     } else {
2570       /* .. and the child is busy going upwards */
2571       if (child_current &lt; next) {
2572         /* .. and is already past the requested state, assume it got there
2573          * without error */
2574         ret = GST_STATE_CHANGE_SUCCESS;
2575         goto unneeded;
2576       }
2577     }
2578   }
2579 
2580 do_state:
2581   GST_OBJECT_LOCK (bin);
2582   /* the element was busy with an upwards async state change, we must wait for
<span class="line-modified">2583    * an ASYNC_DONE message before we attemp to change the state. */</span>
2584   if ((found =
2585           find_message (bin, GST_OBJECT_CAST (element),
2586               GST_MESSAGE_ASYNC_START))) {
2587 #ifndef GST_DISABLE_GST_DEBUG
2588     GstMessage *message = GST_MESSAGE_CAST (found-&gt;data);
2589 
2590     GST_DEBUG_OBJECT (element, &quot;element message %p, %s async busy&quot;,
2591         message, GST_ELEMENT_NAME (GST_MESSAGE_SRC (message)));
2592 #endif
2593     /* only wait for upward state changes */
2594     if (next &gt; current) {
2595       /* We found an async element check if we can force its state to change or
2596        * if we have to wait for it to preroll. */
2597       goto was_busy;
2598     }
2599   }
2600   GST_OBJECT_UNLOCK (bin);
2601 
2602 no_preroll:
2603   GST_DEBUG_OBJECT (bin,
</pre>
<hr />
<pre>
2633   {
2634     GST_DEBUG_OBJECT (element, &quot;element was busy, delaying state change&quot;);
2635     GST_OBJECT_UNLOCK (bin);
2636     GST_STATE_UNLOCK (element);
2637     return GST_STATE_CHANGE_ASYNC;
2638   }
2639 }
2640 
2641 /* gst_iterator_fold functions for pads_activate
2642  * Stop the iterator if activating one pad failed, but only if that pad
2643  * has not been removed from the element. */
2644 static gboolean
2645 activate_pads (const GValue * vpad, GValue * ret, gboolean * active)
2646 {
2647   GstPad *pad = g_value_get_object (vpad);
2648   gboolean cont = TRUE;
2649 
2650   if (!gst_pad_set_active (pad, *active)) {
2651     if (GST_PAD_PARENT (pad) != NULL) {
2652       cont = FALSE;
<span class="line-modified">2653     g_value_set_boolean (ret, FALSE);</span>
2654     }
2655   }
2656 
2657   return cont;
2658 }
2659 
2660 /* returns false on error or early cutout of the fold, true if all
2661  * pads in @iter were (de)activated successfully. */
2662 static gboolean
2663 iterator_activate_fold_with_resync (GstIterator * iter, gpointer user_data)
2664 {
2665   GstIteratorResult ires;
2666   GValue ret = { 0 };
2667 
2668   /* no need to unset this later, it&#39;s just a boolean */
2669   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
2670   g_value_set_boolean (&amp;ret, TRUE);
2671 
2672   while (1) {
2673     ires = gst_iterator_fold (iter, (GstIteratorFoldFunction) activate_pads,
</pre>
<hr />
<pre>
2893     case GST_STATE_READY:
2894       /* Clear message list on next READY */
2895       GST_OBJECT_LOCK (bin);
2896       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2897       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2898       GST_OBJECT_UNLOCK (bin);
2899       /* We might not have reached PAUSED yet due to async errors,
2900        * make sure to always deactivate the pads nonetheless */
2901       if (!(gst_bin_src_pads_activate (bin, FALSE)))
2902         goto activate_failure;
2903       break;
2904     case GST_STATE_NULL:
2905       /* Clear message list on next NULL */
2906       GST_OBJECT_LOCK (bin);
2907       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2908       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2909       GST_OBJECT_UNLOCK (bin);
2910       if (current == GST_STATE_READY) {
2911         if (!(gst_bin_src_pads_activate (bin, FALSE)))
2912           goto activate_failure;
<span class="line-modified">2913           }</span>
2914       break;
2915     default:
2916       break;
2917   }
2918 
2919   /* this flag is used to make the async state changes return immediately. We
2920    * don&#39;t want them to interfere with this state change */
2921   GST_OBJECT_LOCK (bin);
2922   bin-&gt;polling = TRUE;
2923   GST_OBJECT_UNLOCK (bin);
2924 
2925   /* iterate in state change order */
2926   it = gst_bin_iterate_sorted (bin);
2927 
2928   /* mark if we&#39;ve seen an ASYNC element in the bin when we did a state change.
2929    * Note how we don&#39;t reset this value when a resync happens, the reason being
2930    * that the async element posted ASYNC_START and we want to post ASYNC_DONE
2931    * even after a resync when the async element is gone */
2932   have_async = FALSE;
2933 
</pre>
<hr />
<pre>
3048    * itself as the source. In that case we still want to check if the state
3049    * change completed. */
3050   if (ret != GST_STATE_CHANGE_ASYNC &amp;&amp; !bin-&gt;priv-&gt;pending_async_done) {
3051     /* no element returned ASYNC and there are no pending async_done messages,
3052      * we can just complete. */
3053     GST_DEBUG_OBJECT (bin, &quot;no async elements&quot;);
3054     goto state_end;
3055   }
3056   /* when we get here an ASYNC element was found */
3057   if (GST_STATE_TARGET (bin) &lt;= GST_STATE_READY) {
3058     /* we ignore ASYNC state changes when we go to READY or NULL */
3059     GST_DEBUG_OBJECT (bin, &quot;target state %s &lt;= READY&quot;,
3060         gst_element_state_get_name (GST_STATE_TARGET (bin)));
3061     goto state_end;
3062   }
3063 
3064   GST_DEBUG_OBJECT (bin, &quot;check async elements&quot;);
3065   /* check if all elements managed to commit their state already */
3066   if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3067     /* nothing found, remove all old ASYNC_DONE messages. This can happen when
<span class="line-modified">3068      * all the elements commited their state while we were doing the state</span>
3069      * change. We will still return ASYNC for consistency but we commit the
3070      * state already so that a _get_state() will return immediately. */
3071     bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3072 
<span class="line-modified">3073     GST_DEBUG_OBJECT (bin, &quot;async elements commited&quot;);</span>
3074     bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, FALSE,
3075         GST_CLOCK_TIME_NONE);
3076   }
3077 
3078 state_end:
3079   bin-&gt;priv-&gt;pending_async_done = FALSE;
3080   GST_OBJECT_UNLOCK (bin);
3081 
3082   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
3083       &quot;done changing bin&#39;s state from %s to %s, now in %s, ret %s&quot;,
3084       gst_element_state_get_name (current),
3085       gst_element_state_get_name (next),
3086       gst_element_state_get_name (GST_STATE (element)),
3087       gst_element_state_change_return_get_name (ret));
3088 
3089   return ret;
3090 
3091   /* ERRORS */
3092 activate_failure:
3093   {
3094     GST_CAT_WARNING_OBJECT (GST_CAT_STATES, element,
3095         &quot;failure (de)activating src pads&quot;);
3096     return GST_STATE_CHANGE_FAILURE;
3097   }
3098 
3099 undo:
3100   {
3101     if (current &lt; next) {
3102       GstIterator *it = gst_bin_iterate_sorted (GST_BIN (element));
3103       GstIteratorResult ret;
3104 
3105       GST_DEBUG_OBJECT (element,
3106           &quot;Bin failed to change state, switching children back to %s&quot;,
3107           gst_element_state_get_name (current));
3108       while (TRUE) {
3109         ret =
3110             gst_iterator_foreach (it, &amp;reset_state, GINT_TO_POINTER (current));
3111         if (ret != GST_ITERATOR_RESYNC)
3112           break;
3113         gst_iterator_resync (it);
<span class="line-modified">3114 }</span>
3115       gst_iterator_free (it);
3116     }
3117     goto done;
3118   }
3119 }
3120 
3121 /*
3122  * This function is a utility event handler. It will send the event to all sinks
3123  * or sources and appropriate ghost pads depending on the event-direction.
3124  *
3125  * Applications are free to override this behaviour and implement their own
3126  * handler, but this will work for pretty much all cases in practice.
3127  */
3128 static gboolean
3129 gst_bin_send_event (GstElement * element, GstEvent * event)
3130 {
3131   GstBin *bin = GST_BIN_CAST (element);
3132   GstIterator *iter;
3133   gboolean res = TRUE;
3134   gboolean done = FALSE;
</pre>
<hr />
<pre>
3503   }
3504 was_busy:
3505   {
3506     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3507     /* if we were busy with a state change and we are requested to flag a
3508      * pending async done, we do so here */
3509     if (flag_pending)
3510       bin-&gt;priv-&gt;pending_async_done = TRUE;
3511     return;
3512   }
3513 nothing_pending:
3514   {
3515     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin, &quot;nothing pending&quot;);
3516     return;
3517   }
3518 }
3519 
3520 static void
3521 bin_do_eos (GstBin * bin)
3522 {
<span class="line-modified">3523   guint32 seqnum = 0;</span>
3524   gboolean eos;
3525 
3526   GST_OBJECT_LOCK (bin);
3527   /* If all sinks are EOS, we&#39;re in PLAYING and no state change is pending
<span class="line-modified">3528    * (or we&#39;re doing playing to playing and noone else will trigger posting</span>
3529    * EOS for us) we forward the EOS message to the parent bin or application
3530    */
3531   eos = GST_STATE (bin) == GST_STATE_PLAYING
3532       &amp;&amp; (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING ||
3533       GST_STATE_PENDING (bin) == GST_STATE_PLAYING)
3534       &amp;&amp; bin-&gt;priv-&gt;posted_playing &amp;&amp; is_eos (bin, &amp;seqnum);
3535   GST_OBJECT_UNLOCK (bin);
3536 
3537   if (eos
3538       &amp;&amp; g_atomic_int_compare_and_exchange (&amp;bin-&gt;priv-&gt;posted_eos, FALSE,
3539           TRUE)) {
3540     GstMessage *tmessage;
3541 
3542     /* Clear out any further messages, and reset posted_eos so we can
3543        detect any new EOS that happens (eg, after a seek). Since all
3544        sinks have now posted an EOS, there will be no further EOS events
3545        seen unless there is a new logical EOS */
3546     GST_OBJECT_LOCK (bin);
3547     bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
3548     bin-&gt;priv-&gt;posted_eos = FALSE;
3549     GST_OBJECT_UNLOCK (bin);
3550 
3551     tmessage = gst_message_new_eos (GST_OBJECT_CAST (bin));
<span class="line-modified">3552     gst_message_set_seqnum (tmessage, seqnum);</span>

3553     GST_DEBUG_OBJECT (bin,
3554         &quot;all sinks posted EOS, posting seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3555     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3556   } else {
3557     GST_LOG_OBJECT (bin, &quot;Not forwarding EOS due to in progress state change, &quot;
3558         &quot; or already posted, or waiting for more EOS&quot;);
3559   }
3560 }
3561 
3562 static void
3563 bin_do_stream_start (GstBin * bin)
3564 {
<span class="line-modified">3565   guint32 seqnum = 0;</span>
3566   gboolean stream_start;
3567   gboolean have_group_id = FALSE;
3568   guint group_id = 0;
3569 
3570   GST_OBJECT_LOCK (bin);
3571   /* If all sinks are STREAM_START we forward the STREAM_START message
3572    * to the parent bin or application
3573    */
3574   stream_start = is_stream_start (bin, &amp;seqnum, &amp;have_group_id, &amp;group_id);
3575   GST_OBJECT_UNLOCK (bin);
3576 
3577   if (stream_start) {
3578     GstMessage *tmessage;
3579 
3580     GST_OBJECT_LOCK (bin);
3581     bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
3582     GST_OBJECT_UNLOCK (bin);
3583 
3584     tmessage = gst_message_new_stream_start (GST_OBJECT_CAST (bin));
<span class="line-modified">3585     gst_message_set_seqnum (tmessage, seqnum);</span>

3586     if (have_group_id)
3587       gst_message_set_group_id (tmessage, group_id);
3588 
3589     GST_DEBUG_OBJECT (bin,
3590         &quot;all sinks posted STREAM_START, posting seqnum #%&quot; G_GUINT32_FORMAT,
3591         seqnum);
3592     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3593   }
3594 }
3595 
3596 /* must be called without the object lock as it posts messages */
3597 static void
3598 bin_do_message_forward (GstBin * bin, GstMessage * message)
3599 {
3600   if (bin-&gt;priv-&gt;message_forward) {
3601     GstMessage *forwarded;
3602 
3603     GST_DEBUG_OBJECT (bin, &quot;pass %s message upward&quot;,
3604         GST_MESSAGE_TYPE_NAME (message));
3605 
</pre>
<hr />
<pre>
3632   context_type = gst_context_get_context_type (context);
3633 
3634   GST_DEBUG_OBJECT (bin, &quot;set context %p %&quot; GST_PTR_FORMAT, context,
3635       gst_context_get_structure (context));
3636   for (l = *contexts; l; l = l-&gt;next) {
3637     GstContext *tmp = l-&gt;data;
3638     const gchar *tmp_type = gst_context_get_context_type (tmp);
3639 
3640     /* Always store newest context but never replace
3641      * a persistent one by a non-persistent one */
3642     if (strcmp (context_type, tmp_type) == 0 &amp;&amp;
3643         (gst_context_is_persistent (context) ||
3644             !gst_context_is_persistent (tmp))) {
3645       gst_context_replace ((GstContext **) &amp; l-&gt;data, context);
3646       break;
3647     }
3648   }
3649   /* Not found? Add */
3650   if (l == NULL) {
3651     *contexts = g_list_prepend (*contexts, gst_context_ref (context));
<span class="line-modified">3652 }</span>
3653 }
3654 
3655 /* handle child messages:
3656  *
3657  * This method is called synchronously when a child posts a message on
3658  * the internal bus.
3659  *
3660  * GST_MESSAGE_EOS: This message is only posted by sinks
3661  *     in the PLAYING state. If all sinks posted the EOS message, post
3662  *     one upwards.
3663  *
3664  * GST_MESSAGE_STATE_DIRTY: Deprecated
3665  *
3666  * GST_MESSAGE_SEGMENT_START: just collect, never forward upwards. If an
3667  *     element posts segment_start twice, only the last message is kept.
3668  *
3669  * GST_MESSAGE_SEGMENT_DONE: replace SEGMENT_START message from same poster
3670  *     with the segment_done message. If there are no more segment_start
3671  *     messages, post segment_done message upwards.
3672  *
</pre>
<hr />
<pre>
3942       GST_DEBUG_OBJECT (bin, &quot;ASYNC_DONE message %p, %s&quot;, message,
3943           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3944 
3945       gst_message_parse_async_done (message, &amp;running_time);
3946 
3947       bin_do_message_forward (bin, message);
3948 
3949       GST_OBJECT_LOCK (bin);
3950       /* ignore messages if we are shutting down */
3951       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3952         goto ignore_done_message;
3953 
3954       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3955       /* if there are no more ASYNC_START messages, everybody posted
3956        * a ASYNC_DONE and we can post one on the bus. When checking, we
3957        * don&#39;t care who still has a pending ASYNC_START */
3958       if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3959         /* nothing found, remove all old ASYNC_DONE messages */
3960         bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3961 
<span class="line-modified">3962         GST_DEBUG_OBJECT (bin, &quot;async elements commited&quot;);</span>
3963         /* when we get an async done message when a state change was busy, we
3964          * need to set the pending_done flag so that at the end of the state
3965          * change we can see if we need to verify pending async elements, hence
3966          * the TRUE argument here. */
3967         bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, TRUE,
3968             running_time);
3969       } else {
3970         GST_DEBUG_OBJECT (bin, &quot;there are more async elements pending&quot;);
3971       }
3972       GST_OBJECT_UNLOCK (bin);
3973       break;
3974 
3975     ignore_done_message:
3976       {
3977         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3978             gst_element_state_get_name (target));
3979         GST_OBJECT_UNLOCK (bin);
3980         gst_message_unref (message);
3981         break;
3982       }
</pre>
<hr />
<pre>
4323 
4324           /* if cached same format, copy duration in query result */
4325           if (format == qformat) {
4326             GST_DEBUG_OBJECT (bin, &quot;return cached duration %&quot; G_GINT64_FORMAT,
4327                 duration);
4328             GST_OBJECT_UNLOCK (bin);
4329 
4330             gst_query_set_duration (query, qformat, duration);
4331             res = TRUE;
4332             goto exit;
4333           }
4334         }
4335       }
4336       GST_OBJECT_UNLOCK (bin);
4337 #else
4338 #ifndef GST_DISABLE_GST_DEBUG
4339       G_STMT_START {
4340         /* Quieten this particularly annoying FIXME a bit: */
4341         static gboolean printed_fixme = FALSE;
4342         if (!printed_fixme) {
<span class="line-modified">4343       GST_FIXME (&quot;implement duration caching in GstBin again&quot;);</span>
4344           printed_fixme = TRUE;
4345         }
4346       }
4347       G_STMT_END;
4348 #endif
4349 #endif
4350       /* no cached value found, iterate and collect durations */
4351       fold_func = (GstIteratorFoldFunction) bin_query_duration_fold;
4352       fold_init = bin_query_min_max_init;
4353       fold_done = bin_query_duration_done;
4354       break;
4355     }
4356     case GST_QUERY_POSITION:
4357     {
4358       fold_func = (GstIteratorFoldFunction) bin_query_position_fold;
4359       fold_init = bin_query_min_max_init;
4360       fold_done = bin_query_position_done;
4361       break;
4362     }
4363     case GST_QUERY_LATENCY:
</pre>
</td>
<td>
<hr />
<pre>
 127  *
 128  */
 129 
 130 #include &quot;gst_private.h&quot;
 131 
 132 #include &quot;gstevent.h&quot;
 133 #include &quot;gstbin.h&quot;
 134 #include &quot;gstinfo.h&quot;
 135 #include &quot;gsterror.h&quot;
 136 
 137 #include &quot;gstutils.h&quot;
 138 #include &quot;gstchildproxy.h&quot;
 139 
 140 GST_DEBUG_CATEGORY_STATIC (bin_debug);
 141 #define GST_CAT_DEFAULT bin_debug
 142 
 143 /* a bin is toplevel if it has no parent or when it is configured to behave like
 144  * a toplevel bin */
 145 #define BIN_IS_TOPLEVEL(bin) ((GST_OBJECT_PARENT (bin) == NULL) || bin-&gt;priv-&gt;asynchandling)
 146 



 147 struct _GstBinPrivate
 148 {
 149   gboolean asynchandling;
 150   /* if we get an ASYNC_DONE message from ourselves, this means that the
 151    * subclass will simulate ASYNC behaviour without having ASYNC children. When
 152    * such an ASYNC_DONE message is posted while we are doing a state change, we
 153    * have to process the message after finishing the state change even when no
 154    * child returned GST_STATE_CHANGE_ASYNC. */
 155   gboolean pending_async_done;
 156 
 157   guint32 structure_cookie;
 158 
 159 #if 0
 160   /* cached index */
 161   GstIndex *index;
 162 #endif
 163 
 164   /* forward messages from our children */
 165   gboolean message_forward;
 166 
</pre>
<hr />
<pre>
 252 
 253 static void gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data);
 254 
 255 static guint gst_bin_signals[LAST_SIGNAL] = { 0 };
 256 
 257 #define _do_init \
 258 { \
 259   static const GInterfaceInfo iface_info = { \
 260     gst_bin_child_proxy_init, \
 261     NULL, \
 262     NULL}; \
 263   \
 264   g_type_add_interface_static (g_define_type_id, GST_TYPE_CHILD_PROXY, &amp;iface_info); \
 265   \
 266   GST_DEBUG_CATEGORY_INIT (bin_debug, &quot;bin&quot;, GST_DEBUG_BOLD, \
 267       &quot;debugging info for the &#39;bin&#39; container element&quot;); \
 268   \
 269 }
 270 
 271 #define gst_bin_parent_class parent_class
<span class="line-modified"> 272 G_DEFINE_TYPE_WITH_CODE (GstBin, gst_bin, GST_TYPE_ELEMENT,</span>
<span class="line-added"> 273     G_ADD_PRIVATE (GstBin)</span>
<span class="line-added"> 274     _do_init);</span>
 275 
 276 static GObject *
 277 gst_bin_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
 278     guint index)
 279 {
 280   GstObject *res;
 281   GstBin *bin;
 282 
 283   bin = GST_BIN_CAST (child_proxy);
 284 
 285   GST_OBJECT_LOCK (bin);
 286   if ((res = g_list_nth_data (bin-&gt;children, index)))
 287     gst_object_ref (res);
 288   GST_OBJECT_UNLOCK (bin);
 289 
 290   return (GObject *) res;
 291 }
 292 
 293 static guint
 294 gst_bin_child_proxy_get_children_count (GstChildProxy * child_proxy)
</pre>
<hr />
<pre>
 322 
 323   myboolean = g_value_get_boolean (handler_return);
 324   if (!(ihint-&gt;run_type &amp; G_SIGNAL_RUN_CLEANUP))
 325     g_value_set_boolean (return_accu, myboolean);
 326 
 327   GST_DEBUG (&quot;invocation %d, %d&quot;, ihint-&gt;run_type, myboolean);
 328 
 329   /* stop emission */
 330   return FALSE;
 331 }
 332 
 333 static void
 334 gst_bin_class_init (GstBinClass * klass)
 335 {
 336   GObjectClass *gobject_class;
 337   GstElementClass *gstelement_class;
 338 
 339   gobject_class = (GObjectClass *) klass;
 340   gstelement_class = (GstElementClass *) klass;
 341 


 342   gobject_class-&gt;set_property = gst_bin_set_property;
 343   gobject_class-&gt;get_property = gst_bin_get_property;
 344 
 345   /**
 346    * GstBin:async-handling:
 347    *
 348    * If set to %TRUE, the bin will handle asynchronous state changes.
 349    * This should be used only if the bin subclass is modifying the state
 350    * of its children on its own.
 351    */
 352   g_object_class_install_property (gobject_class, PROP_ASYNC_HANDLING,
 353       g_param_spec_boolean (&quot;async-handling&quot;, &quot;Async Handling&quot;,
 354           &quot;The bin will handle Asynchronous state changes&quot;,
 355           DEFAULT_ASYNC_HANDLING, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 356 
 357   /**
 358    * GstBin::element-added:
 359    * @bin: the #GstBin
 360    * @element: the #GstElement that was added to the bin
 361    *
</pre>
<hr />
<pre>
 460 #if 0
 461   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_bin_get_index_func);
 462   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_bin_set_index_func);
 463 #endif
 464   gstelement_class-&gt;provide_clock =
 465       GST_DEBUG_FUNCPTR (gst_bin_provide_clock_func);
 466   gstelement_class-&gt;set_clock = GST_DEBUG_FUNCPTR (gst_bin_set_clock_func);
 467 
 468   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_bin_send_event);
 469   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_bin_query);
 470   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_bin_set_context);
 471 
 472   klass-&gt;add_element = GST_DEBUG_FUNCPTR (gst_bin_add_func);
 473   klass-&gt;remove_element = GST_DEBUG_FUNCPTR (gst_bin_remove_func);
 474   klass-&gt;handle_message = GST_DEBUG_FUNCPTR (gst_bin_handle_message_func);
 475 
 476   klass-&gt;deep_element_added = gst_bin_deep_element_added_func;
 477   klass-&gt;deep_element_removed = gst_bin_deep_element_removed_func;
 478 
 479   klass-&gt;do_latency = GST_DEBUG_FUNCPTR (gst_bin_do_latency_func);
<span class="line-modified"> 480 }</span>
 481 
 482 static void
 483 gst_bin_init (GstBin * bin)
 484 {
 485   GstBus *bus;
 486 
 487   bin-&gt;numchildren = 0;
 488   bin-&gt;children = NULL;
 489   bin-&gt;children_cookie = 0;
 490   bin-&gt;messages = NULL;
 491   bin-&gt;provided_clock = NULL;
 492   bin-&gt;clock_dirty = FALSE;
 493 
 494   /* Set up a bus for listening to child elements */
 495   bus = g_object_new (GST_TYPE_BUS, &quot;enable-async&quot;, FALSE, NULL);
 496   gst_object_ref_sink (bus);
 497   bin-&gt;child_bus = bus;
 498   GST_DEBUG_OBJECT (bin, &quot;using bus %&quot; GST_PTR_FORMAT &quot; to listen to children&quot;,
 499       bus);
 500   gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bin_bus_handler, bin,
 501       NULL);
 502 
<span class="line-modified"> 503   bin-&gt;priv = gst_bin_get_instance_private (bin);</span>
 504   bin-&gt;priv-&gt;asynchandling = DEFAULT_ASYNC_HANDLING;
 505   bin-&gt;priv-&gt;structure_cookie = 0;
 506   bin-&gt;priv-&gt;message_forward = DEFAULT_MESSAGE_FORWARD;
 507 }
 508 
 509 static void
 510 gst_bin_dispose (GObject * object)
 511 {
 512   GstBin *bin = GST_BIN_CAST (object);
 513   GstBus **child_bus_p = &amp;bin-&gt;child_bus;
 514   GstClock **provided_clock_p = &amp;bin-&gt;provided_clock;
 515   GstElement **clock_provider_p = &amp;bin-&gt;clock_provider;
 516 
 517   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p dispose&quot;, object);
 518 
 519   GST_OBJECT_LOCK (object);
 520   gst_object_replace ((GstObject **) child_bus_p, NULL);
 521   gst_object_replace ((GstObject **) provided_clock_p, NULL);
 522   gst_object_replace ((GstObject **) clock_provider_p, NULL);
 523   bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
</pre>
<hr />
<pre>
1105     GQueue elements = G_QUEUE_INIT;
1106 
1107     GST_LOG_OBJECT (bin, &quot;Recursing into bin %&quot; GST_PTR_FORMAT &quot; for %s&quot;,
1108         element, sig_name);
1109     it = gst_bin_iterate_recurse (GST_BIN_CAST (element));
1110     do {
1111       ires = gst_iterator_foreach (it, bin_deep_iterator_foreach, &amp;elements);
1112       if (ires != GST_ITERATOR_DONE) {
1113         g_queue_foreach (&amp;elements, (GFunc) g_object_unref, NULL);
1114         g_queue_clear (&amp;elements);
1115       }
1116       if (ires == GST_ITERATOR_RESYNC)
1117         gst_iterator_resync (it);
1118     } while (ires == GST_ITERATOR_RESYNC);
1119     if (ires != GST_ITERATOR_ERROR) {
1120       GstElement *e;
1121 
1122       while ((e = g_queue_pop_head (&amp;elements))) {
1123         GstObject *parent = gst_object_get_parent (GST_OBJECT_CAST (e));
1124 
<span class="line-modified">1125         /* an element could have removed some of its internal elements</span>
<span class="line-modified">1126          * meanwhile, so protect against that */</span>
<span class="line-modified">1127         if (parent) {</span>
<span class="line-modified">1128           GST_LOG_OBJECT (bin, &quot;calling %s for element %&quot; GST_PTR_FORMAT</span>
<span class="line-modified">1129               &quot; in bin %&quot; GST_PTR_FORMAT, sig_name, e, parent);</span>
<span class="line-added">1130           g_signal_emit (bin, sig_id, 0, parent, e);</span>
<span class="line-added">1131           gst_object_unref (parent);</span>
<span class="line-added">1132           g_object_unref (e);</span>
<span class="line-added">1133         }</span>
1134       }
1135     }
1136     gst_iterator_free (it);
1137   }
1138 }
1139 
1140 /* vmethod that adds an element to a bin
1141  *
1142  * MT safe
1143  */
1144 static gboolean
1145 gst_bin_add_func (GstBin * bin, GstElement * element)
1146 {
1147   gchar *elem_name;
1148   GstIterator *it;
1149   gboolean is_sink, is_source, provides_clock, requires_clock;
1150   GstMessage *clock_message = NULL, *async_message = NULL;
1151   GstStateChangeReturn ret;
1152   GList *l, *elem_contexts, *need_context_messages;
1153 
</pre>
<hr />
<pre>
2564       if (child_current &lt;= next) {
2565         /* .. and is already past the requested state, assume it got there
2566          * without error */
2567         ret = GST_STATE_CHANGE_SUCCESS;
2568         goto unneeded;
2569       }
2570     } else {
2571       /* .. and the child is busy going upwards */
2572       if (child_current &lt; next) {
2573         /* .. and is already past the requested state, assume it got there
2574          * without error */
2575         ret = GST_STATE_CHANGE_SUCCESS;
2576         goto unneeded;
2577       }
2578     }
2579   }
2580 
2581 do_state:
2582   GST_OBJECT_LOCK (bin);
2583   /* the element was busy with an upwards async state change, we must wait for
<span class="line-modified">2584    * an ASYNC_DONE message before we attempt to change the state. */</span>
2585   if ((found =
2586           find_message (bin, GST_OBJECT_CAST (element),
2587               GST_MESSAGE_ASYNC_START))) {
2588 #ifndef GST_DISABLE_GST_DEBUG
2589     GstMessage *message = GST_MESSAGE_CAST (found-&gt;data);
2590 
2591     GST_DEBUG_OBJECT (element, &quot;element message %p, %s async busy&quot;,
2592         message, GST_ELEMENT_NAME (GST_MESSAGE_SRC (message)));
2593 #endif
2594     /* only wait for upward state changes */
2595     if (next &gt; current) {
2596       /* We found an async element check if we can force its state to change or
2597        * if we have to wait for it to preroll. */
2598       goto was_busy;
2599     }
2600   }
2601   GST_OBJECT_UNLOCK (bin);
2602 
2603 no_preroll:
2604   GST_DEBUG_OBJECT (bin,
</pre>
<hr />
<pre>
2634   {
2635     GST_DEBUG_OBJECT (element, &quot;element was busy, delaying state change&quot;);
2636     GST_OBJECT_UNLOCK (bin);
2637     GST_STATE_UNLOCK (element);
2638     return GST_STATE_CHANGE_ASYNC;
2639   }
2640 }
2641 
2642 /* gst_iterator_fold functions for pads_activate
2643  * Stop the iterator if activating one pad failed, but only if that pad
2644  * has not been removed from the element. */
2645 static gboolean
2646 activate_pads (const GValue * vpad, GValue * ret, gboolean * active)
2647 {
2648   GstPad *pad = g_value_get_object (vpad);
2649   gboolean cont = TRUE;
2650 
2651   if (!gst_pad_set_active (pad, *active)) {
2652     if (GST_PAD_PARENT (pad) != NULL) {
2653       cont = FALSE;
<span class="line-modified">2654       g_value_set_boolean (ret, FALSE);</span>
2655     }
2656   }
2657 
2658   return cont;
2659 }
2660 
2661 /* returns false on error or early cutout of the fold, true if all
2662  * pads in @iter were (de)activated successfully. */
2663 static gboolean
2664 iterator_activate_fold_with_resync (GstIterator * iter, gpointer user_data)
2665 {
2666   GstIteratorResult ires;
2667   GValue ret = { 0 };
2668 
2669   /* no need to unset this later, it&#39;s just a boolean */
2670   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
2671   g_value_set_boolean (&amp;ret, TRUE);
2672 
2673   while (1) {
2674     ires = gst_iterator_fold (iter, (GstIteratorFoldFunction) activate_pads,
</pre>
<hr />
<pre>
2894     case GST_STATE_READY:
2895       /* Clear message list on next READY */
2896       GST_OBJECT_LOCK (bin);
2897       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2898       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2899       GST_OBJECT_UNLOCK (bin);
2900       /* We might not have reached PAUSED yet due to async errors,
2901        * make sure to always deactivate the pads nonetheless */
2902       if (!(gst_bin_src_pads_activate (bin, FALSE)))
2903         goto activate_failure;
2904       break;
2905     case GST_STATE_NULL:
2906       /* Clear message list on next NULL */
2907       GST_OBJECT_LOCK (bin);
2908       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2909       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2910       GST_OBJECT_UNLOCK (bin);
2911       if (current == GST_STATE_READY) {
2912         if (!(gst_bin_src_pads_activate (bin, FALSE)))
2913           goto activate_failure;
<span class="line-modified">2914       }</span>
2915       break;
2916     default:
2917       break;
2918   }
2919 
2920   /* this flag is used to make the async state changes return immediately. We
2921    * don&#39;t want them to interfere with this state change */
2922   GST_OBJECT_LOCK (bin);
2923   bin-&gt;polling = TRUE;
2924   GST_OBJECT_UNLOCK (bin);
2925 
2926   /* iterate in state change order */
2927   it = gst_bin_iterate_sorted (bin);
2928 
2929   /* mark if we&#39;ve seen an ASYNC element in the bin when we did a state change.
2930    * Note how we don&#39;t reset this value when a resync happens, the reason being
2931    * that the async element posted ASYNC_START and we want to post ASYNC_DONE
2932    * even after a resync when the async element is gone */
2933   have_async = FALSE;
2934 
</pre>
<hr />
<pre>
3049    * itself as the source. In that case we still want to check if the state
3050    * change completed. */
3051   if (ret != GST_STATE_CHANGE_ASYNC &amp;&amp; !bin-&gt;priv-&gt;pending_async_done) {
3052     /* no element returned ASYNC and there are no pending async_done messages,
3053      * we can just complete. */
3054     GST_DEBUG_OBJECT (bin, &quot;no async elements&quot;);
3055     goto state_end;
3056   }
3057   /* when we get here an ASYNC element was found */
3058   if (GST_STATE_TARGET (bin) &lt;= GST_STATE_READY) {
3059     /* we ignore ASYNC state changes when we go to READY or NULL */
3060     GST_DEBUG_OBJECT (bin, &quot;target state %s &lt;= READY&quot;,
3061         gst_element_state_get_name (GST_STATE_TARGET (bin)));
3062     goto state_end;
3063   }
3064 
3065   GST_DEBUG_OBJECT (bin, &quot;check async elements&quot;);
3066   /* check if all elements managed to commit their state already */
3067   if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3068     /* nothing found, remove all old ASYNC_DONE messages. This can happen when
<span class="line-modified">3069      * all the elements committed their state while we were doing the state</span>
3070      * change. We will still return ASYNC for consistency but we commit the
3071      * state already so that a _get_state() will return immediately. */
3072     bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3073 
<span class="line-modified">3074     GST_DEBUG_OBJECT (bin, &quot;async elements committed&quot;);</span>
3075     bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, FALSE,
3076         GST_CLOCK_TIME_NONE);
3077   }
3078 
3079 state_end:
3080   bin-&gt;priv-&gt;pending_async_done = FALSE;
3081   GST_OBJECT_UNLOCK (bin);
3082 
3083   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
3084       &quot;done changing bin&#39;s state from %s to %s, now in %s, ret %s&quot;,
3085       gst_element_state_get_name (current),
3086       gst_element_state_get_name (next),
3087       gst_element_state_get_name (GST_STATE (element)),
3088       gst_element_state_change_return_get_name (ret));
3089 
3090   return ret;
3091 
3092   /* ERRORS */
3093 activate_failure:
3094   {
3095     GST_CAT_WARNING_OBJECT (GST_CAT_STATES, element,
3096         &quot;failure (de)activating src pads&quot;);
3097     return GST_STATE_CHANGE_FAILURE;
3098   }
3099 
3100 undo:
3101   {
3102     if (current &lt; next) {
3103       GstIterator *it = gst_bin_iterate_sorted (GST_BIN (element));
3104       GstIteratorResult ret;
3105 
3106       GST_DEBUG_OBJECT (element,
3107           &quot;Bin failed to change state, switching children back to %s&quot;,
3108           gst_element_state_get_name (current));
3109       while (TRUE) {
3110         ret =
3111             gst_iterator_foreach (it, &amp;reset_state, GINT_TO_POINTER (current));
3112         if (ret != GST_ITERATOR_RESYNC)
3113           break;
3114         gst_iterator_resync (it);
<span class="line-modified">3115       }</span>
3116       gst_iterator_free (it);
3117     }
3118     goto done;
3119   }
3120 }
3121 
3122 /*
3123  * This function is a utility event handler. It will send the event to all sinks
3124  * or sources and appropriate ghost pads depending on the event-direction.
3125  *
3126  * Applications are free to override this behaviour and implement their own
3127  * handler, but this will work for pretty much all cases in practice.
3128  */
3129 static gboolean
3130 gst_bin_send_event (GstElement * element, GstEvent * event)
3131 {
3132   GstBin *bin = GST_BIN_CAST (element);
3133   GstIterator *iter;
3134   gboolean res = TRUE;
3135   gboolean done = FALSE;
</pre>
<hr />
<pre>
3504   }
3505 was_busy:
3506   {
3507     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3508     /* if we were busy with a state change and we are requested to flag a
3509      * pending async done, we do so here */
3510     if (flag_pending)
3511       bin-&gt;priv-&gt;pending_async_done = TRUE;
3512     return;
3513   }
3514 nothing_pending:
3515   {
3516     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin, &quot;nothing pending&quot;);
3517     return;
3518   }
3519 }
3520 
3521 static void
3522 bin_do_eos (GstBin * bin)
3523 {
<span class="line-modified">3524   guint32 seqnum = GST_SEQNUM_INVALID;</span>
3525   gboolean eos;
3526 
3527   GST_OBJECT_LOCK (bin);
3528   /* If all sinks are EOS, we&#39;re in PLAYING and no state change is pending
<span class="line-modified">3529    * (or we&#39;re doing playing to playing and no one else will trigger posting</span>
3530    * EOS for us) we forward the EOS message to the parent bin or application
3531    */
3532   eos = GST_STATE (bin) == GST_STATE_PLAYING
3533       &amp;&amp; (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING ||
3534       GST_STATE_PENDING (bin) == GST_STATE_PLAYING)
3535       &amp;&amp; bin-&gt;priv-&gt;posted_playing &amp;&amp; is_eos (bin, &amp;seqnum);
3536   GST_OBJECT_UNLOCK (bin);
3537 
3538   if (eos
3539       &amp;&amp; g_atomic_int_compare_and_exchange (&amp;bin-&gt;priv-&gt;posted_eos, FALSE,
3540           TRUE)) {
3541     GstMessage *tmessage;
3542 
3543     /* Clear out any further messages, and reset posted_eos so we can
3544        detect any new EOS that happens (eg, after a seek). Since all
3545        sinks have now posted an EOS, there will be no further EOS events
3546        seen unless there is a new logical EOS */
3547     GST_OBJECT_LOCK (bin);
3548     bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
3549     bin-&gt;priv-&gt;posted_eos = FALSE;
3550     GST_OBJECT_UNLOCK (bin);
3551 
3552     tmessage = gst_message_new_eos (GST_OBJECT_CAST (bin));
<span class="line-modified">3553     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">3554       gst_message_set_seqnum (tmessage, seqnum);</span>
3555     GST_DEBUG_OBJECT (bin,
3556         &quot;all sinks posted EOS, posting seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3557     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3558   } else {
3559     GST_LOG_OBJECT (bin, &quot;Not forwarding EOS due to in progress state change, &quot;
3560         &quot; or already posted, or waiting for more EOS&quot;);
3561   }
3562 }
3563 
3564 static void
3565 bin_do_stream_start (GstBin * bin)
3566 {
<span class="line-modified">3567   guint32 seqnum = GST_SEQNUM_INVALID;</span>
3568   gboolean stream_start;
3569   gboolean have_group_id = FALSE;
3570   guint group_id = 0;
3571 
3572   GST_OBJECT_LOCK (bin);
3573   /* If all sinks are STREAM_START we forward the STREAM_START message
3574    * to the parent bin or application
3575    */
3576   stream_start = is_stream_start (bin, &amp;seqnum, &amp;have_group_id, &amp;group_id);
3577   GST_OBJECT_UNLOCK (bin);
3578 
3579   if (stream_start) {
3580     GstMessage *tmessage;
3581 
3582     GST_OBJECT_LOCK (bin);
3583     bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
3584     GST_OBJECT_UNLOCK (bin);
3585 
3586     tmessage = gst_message_new_stream_start (GST_OBJECT_CAST (bin));
<span class="line-modified">3587     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">3588       gst_message_set_seqnum (tmessage, seqnum);</span>
3589     if (have_group_id)
3590       gst_message_set_group_id (tmessage, group_id);
3591 
3592     GST_DEBUG_OBJECT (bin,
3593         &quot;all sinks posted STREAM_START, posting seqnum #%&quot; G_GUINT32_FORMAT,
3594         seqnum);
3595     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3596   }
3597 }
3598 
3599 /* must be called without the object lock as it posts messages */
3600 static void
3601 bin_do_message_forward (GstBin * bin, GstMessage * message)
3602 {
3603   if (bin-&gt;priv-&gt;message_forward) {
3604     GstMessage *forwarded;
3605 
3606     GST_DEBUG_OBJECT (bin, &quot;pass %s message upward&quot;,
3607         GST_MESSAGE_TYPE_NAME (message));
3608 
</pre>
<hr />
<pre>
3635   context_type = gst_context_get_context_type (context);
3636 
3637   GST_DEBUG_OBJECT (bin, &quot;set context %p %&quot; GST_PTR_FORMAT, context,
3638       gst_context_get_structure (context));
3639   for (l = *contexts; l; l = l-&gt;next) {
3640     GstContext *tmp = l-&gt;data;
3641     const gchar *tmp_type = gst_context_get_context_type (tmp);
3642 
3643     /* Always store newest context but never replace
3644      * a persistent one by a non-persistent one */
3645     if (strcmp (context_type, tmp_type) == 0 &amp;&amp;
3646         (gst_context_is_persistent (context) ||
3647             !gst_context_is_persistent (tmp))) {
3648       gst_context_replace ((GstContext **) &amp; l-&gt;data, context);
3649       break;
3650     }
3651   }
3652   /* Not found? Add */
3653   if (l == NULL) {
3654     *contexts = g_list_prepend (*contexts, gst_context_ref (context));
<span class="line-modified">3655   }</span>
3656 }
3657 
3658 /* handle child messages:
3659  *
3660  * This method is called synchronously when a child posts a message on
3661  * the internal bus.
3662  *
3663  * GST_MESSAGE_EOS: This message is only posted by sinks
3664  *     in the PLAYING state. If all sinks posted the EOS message, post
3665  *     one upwards.
3666  *
3667  * GST_MESSAGE_STATE_DIRTY: Deprecated
3668  *
3669  * GST_MESSAGE_SEGMENT_START: just collect, never forward upwards. If an
3670  *     element posts segment_start twice, only the last message is kept.
3671  *
3672  * GST_MESSAGE_SEGMENT_DONE: replace SEGMENT_START message from same poster
3673  *     with the segment_done message. If there are no more segment_start
3674  *     messages, post segment_done message upwards.
3675  *
</pre>
<hr />
<pre>
3945       GST_DEBUG_OBJECT (bin, &quot;ASYNC_DONE message %p, %s&quot;, message,
3946           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3947 
3948       gst_message_parse_async_done (message, &amp;running_time);
3949 
3950       bin_do_message_forward (bin, message);
3951 
3952       GST_OBJECT_LOCK (bin);
3953       /* ignore messages if we are shutting down */
3954       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3955         goto ignore_done_message;
3956 
3957       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3958       /* if there are no more ASYNC_START messages, everybody posted
3959        * a ASYNC_DONE and we can post one on the bus. When checking, we
3960        * don&#39;t care who still has a pending ASYNC_START */
3961       if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3962         /* nothing found, remove all old ASYNC_DONE messages */
3963         bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3964 
<span class="line-modified">3965         GST_DEBUG_OBJECT (bin, &quot;async elements committed&quot;);</span>
3966         /* when we get an async done message when a state change was busy, we
3967          * need to set the pending_done flag so that at the end of the state
3968          * change we can see if we need to verify pending async elements, hence
3969          * the TRUE argument here. */
3970         bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, TRUE,
3971             running_time);
3972       } else {
3973         GST_DEBUG_OBJECT (bin, &quot;there are more async elements pending&quot;);
3974       }
3975       GST_OBJECT_UNLOCK (bin);
3976       break;
3977 
3978     ignore_done_message:
3979       {
3980         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3981             gst_element_state_get_name (target));
3982         GST_OBJECT_UNLOCK (bin);
3983         gst_message_unref (message);
3984         break;
3985       }
</pre>
<hr />
<pre>
4326 
4327           /* if cached same format, copy duration in query result */
4328           if (format == qformat) {
4329             GST_DEBUG_OBJECT (bin, &quot;return cached duration %&quot; G_GINT64_FORMAT,
4330                 duration);
4331             GST_OBJECT_UNLOCK (bin);
4332 
4333             gst_query_set_duration (query, qformat, duration);
4334             res = TRUE;
4335             goto exit;
4336           }
4337         }
4338       }
4339       GST_OBJECT_UNLOCK (bin);
4340 #else
4341 #ifndef GST_DISABLE_GST_DEBUG
4342       G_STMT_START {
4343         /* Quieten this particularly annoying FIXME a bit: */
4344         static gboolean printed_fixme = FALSE;
4345         if (!printed_fixme) {
<span class="line-modified">4346           GST_FIXME (&quot;implement duration caching in GstBin again&quot;);</span>
4347           printed_fixme = TRUE;
4348         }
4349       }
4350       G_STMT_END;
4351 #endif
4352 #endif
4353       /* no cached value found, iterate and collect durations */
4354       fold_func = (GstIteratorFoldFunction) bin_query_duration_fold;
4355       fold_init = bin_query_min_max_init;
4356       fold_done = bin_query_duration_done;
4357       break;
4358     }
4359     case GST_QUERY_POSITION:
4360     {
4361       fold_func = (GstIteratorFoldFunction) bin_query_position_fold;
4362       fold_init = bin_query_min_max_init;
4363       fold_done = bin_query_position_done;
4364       break;
4365     }
4366     case GST_QUERY_LATENCY:
</pre>
</td>
</tr>
</table>
<center><a href="gstallocator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbin.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>