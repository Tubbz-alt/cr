<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/glist.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;glist.h&quot;
  32 #include &quot;gslice.h&quot;
  33 #include &quot;gmessages.h&quot;
  34 
  35 #include &quot;gtestutils.h&quot;
  36 
  37 /**
  38  * SECTION:linked_lists_double
  39  * @title: Doubly-Linked Lists
  40  * @short_description: linked lists that can be iterated over in both directions
  41  *
  42  * The #GList structure and its associated functions provide a standard
  43  * doubly-linked list data structure.
  44  *
  45  * Each element in the list contains a piece of data, together with
  46  * pointers which link to the previous and next elements in the list.
  47  * Using these pointers it is possible to move through the list in both
  48  * directions (unlike the singly-linked [GSList][glib-Singly-Linked-Lists],
  49  * which only allows movement through the list in the forward direction).
  50  *
  51  * The double linked list does not keep track of the number of items
  52  * and does not keep track of both the start and end of the list. If
  53  * you want fast access to both the start and the end of the list,
  54  * and/or the number of items in the list, use a
  55  * [GQueue][glib-Double-ended-Queues] instead.
  56  *
  57  * The data contained in each element can be either integer values, by
  58  * using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],
  59  * or simply pointers to any type of data.
  60  *
  61  * List elements are allocated from the [slice allocator][glib-Memory-Slices],
  62  * which is more efficient than allocating elements individually.
  63  *
  64  * Note that most of the #GList functions expect to be passed a pointer
  65  * to the first element in the list. The functions which insert
  66  * elements return the new start of the list, which may have changed.
  67  *
  68  * There is no function to create a #GList. %NULL is considered to be
  69  * a valid, empty list so you simply set a #GList* to %NULL to initialize
  70  * it.
  71  *
  72  * To add elements, use g_list_append(), g_list_prepend(),
  73  * g_list_insert() and g_list_insert_sorted().
  74  *
  75  * To visit all elements in the list, use a loop over the list:
  76  * |[&lt;!-- language=&quot;C&quot; --&gt;
  77  * GList *l;
  78  * for (l = list; l != NULL; l = l-&gt;next)
  79  *   {
  80  *     // do something with l-&gt;data
  81  *   }
  82  * ]|
  83  *
  84  * To call a function for each element in the list, use g_list_foreach().
  85  *
  86  * To loop over the list and modify it (e.g. remove a certain element)
  87  * a while loop is more appropriate, for example:
  88  * |[&lt;!-- language=&quot;C&quot; --&gt;
  89  * GList *l = list;
  90  * while (l != NULL)
  91  *   {
  92  *     GList *next = l-&gt;next;
  93  *     if (should_be_removed (l))
  94  *       {
  95  *         // possibly free l-&gt;data
  96  *         list = g_list_delete_link (list, l);
  97  *       }
  98  *     l = next;
  99  *   }
 100  * ]|
 101  *
 102  * To remove elements, use g_list_remove().
 103  *
 104  * To navigate in a list, use g_list_first(), g_list_last(),
 105  * g_list_next(), g_list_previous().
 106  *
 107  * To find elements in the list use g_list_nth(), g_list_nth_data(),
 108  * g_list_find() and g_list_find_custom().
 109  *
 110  * To find the index of an element use g_list_position() and
 111  * g_list_index().
 112  *
 113  * To free the entire list, use g_list_free() or g_list_free_full().
 114  */
 115 
 116 /**
 117  * GList:
 118  * @data: holds the element&#39;s data, which can be a pointer to any kind
 119  *        of data, or any integer value using the
 120  *        [Type Conversion Macros][glib-Type-Conversion-Macros]
 121  * @next: contains the link to the next element in the list
 122  * @prev: contains the link to the previous element in the list
 123  *
 124  * The #GList struct is used for each element in a doubly-linked list.
 125  **/
 126 
 127 /**
 128  * g_list_previous:
 129  * @list: an element in a #GList
 130  *
 131  * A convenience macro to get the previous element in a #GList.
 132  * Note that it is considered perfectly acceptable to access
 133  * @list-&gt;prev directly.
 134  *
 135  * Returns: the previous element, or %NULL if there are no previous
 136  *          elements
 137  **/
 138 
 139 /**
 140  * g_list_next:
 141  * @list: an element in a #GList
 142  *
 143  * A convenience macro to get the next element in a #GList.
 144  * Note that it is considered perfectly acceptable to access
 145  * @list-&gt;next directly.
 146  *
 147  * Returns: the next element, or %NULL if there are no more elements
 148  **/
 149 
 150 #define _g_list_alloc()         g_slice_new (GList)
 151 #define _g_list_alloc0()        g_slice_new0 (GList)
 152 #define _g_list_free1(list)     g_slice_free (GList, list)
 153 
 154 /**
 155  * g_list_alloc:
 156  *
 157  * Allocates space for one #GList element. It is called by
 158  * g_list_append(), g_list_prepend(), g_list_insert() and
 159  * g_list_insert_sorted() and so is rarely used on its own.
 160  *
 161  * Returns: a pointer to the newly-allocated #GList element
 162  **/
 163 GList *
 164 g_list_alloc (void)
 165 {
 166   return _g_list_alloc0 ();
 167 }
 168 
 169 /**
 170  * g_list_free:
 171  * @list: a #GList
 172  *
 173  * Frees all of the memory used by a #GList.
 174  * The freed elements are returned to the slice allocator.
 175  *
 176  * If list elements contain dynamically-allocated memory, you should
 177  * either use g_list_free_full() or free them manually first.
 178  */
 179 void
 180 g_list_free (GList *list)
 181 {
 182   g_slice_free_chain (GList, list, next);
 183 }
 184 
 185 /**
 186  * g_list_free_1:
 187  * @list: a #GList element
 188  *
 189  * Frees one #GList element, but does not update links from the next and
 190  * previous elements in the list, so you should not call this function on an
 191  * element that is currently part of a list.
 192  *
 193  * It is usually used after g_list_remove_link().
 194  */
 195 /**
 196  * g_list_free1:
 197  *
 198  * Another name for g_list_free_1().
 199  **/
 200 void
 201 g_list_free_1 (GList *list)
 202 {
 203   _g_list_free1 (list);
 204 }
 205 
 206 /**
 207  * g_list_free_full:
 208  * @list: a pointer to a #GList
 209  * @free_func: the function to be called to free each element&#39;s data
 210  *
 211  * Convenience method, which frees all the memory used by a #GList,
 212  * and calls @free_func on every element&#39;s data.
 213  *
 214  * @free_func must not modify the list (eg, by removing the freed
 215  * element from it).
 216  *
 217  * Since: 2.28
 218  */
 219 void
 220 g_list_free_full (GList          *list,
 221                   GDestroyNotify  free_func)
 222 {
 223   g_list_foreach (list, (GFunc) free_func, NULL);
 224   g_list_free (list);
 225 }
 226 
 227 /**
 228  * g_list_append:
 229  * @list: a pointer to a #GList
 230  * @data: the data for the new element
 231  *
 232  * Adds a new element on to the end of the list.
 233  *
 234  * Note that the return value is the new start of the list,
 235  * if @list was empty; make sure you store the new value.
 236  *
 237  * g_list_append() has to traverse the entire list to find the end,
 238  * which is inefficient when adding multiple elements. A common idiom
 239  * to avoid the inefficiency is to use g_list_prepend() and reverse
 240  * the list with g_list_reverse() when all elements have been added.
 241  *
 242  * |[&lt;!-- language=&quot;C&quot; --&gt;
 243  * // Notice that these are initialized to the empty list.
 244  * GList *string_list = NULL, *number_list = NULL;
 245  *
 246  * // This is a list of strings.
 247  * string_list = g_list_append (string_list, &quot;first&quot;);
 248  * string_list = g_list_append (string_list, &quot;second&quot;);
 249  *
 250  * // This is a list of integers.
 251  * number_list = g_list_append (number_list, GINT_TO_POINTER (27));
 252  * number_list = g_list_append (number_list, GINT_TO_POINTER (14));
 253  * ]|
 254  *
 255  * Returns: either @list or the new start of the #GList if @list was %NULL
 256  */
 257 GList *
 258 g_list_append (GList    *list,
 259                gpointer  data)
 260 {
 261   GList *new_list;
 262   GList *last;
 263 
 264   new_list = _g_list_alloc ();
 265 #ifdef GSTREAMER_LITE
 266   if (new_list == NULL) {
 267     return NULL;
 268   }
 269 #endif // GSTREAMER_LITE
 270   new_list-&gt;data = data;
 271   new_list-&gt;next = NULL;
 272 
 273   if (list)
 274     {
 275       last = g_list_last (list);
 276       /* g_assert (last != NULL); */
 277       last-&gt;next = new_list;
 278       new_list-&gt;prev = last;
 279 
 280       return list;
 281     }
 282   else
 283     {
 284       new_list-&gt;prev = NULL;
 285       return new_list;
 286     }
 287 }
 288 
 289 /**
 290  * g_list_prepend:
 291  * @list: a pointer to a #GList, this must point to the top of the list
 292  * @data: the data for the new element
 293  *
 294  * Prepends a new element on to the start of the list.
 295  *
 296  * Note that the return value is the new start of the list,
 297  * which will have changed, so make sure you store the new value.
 298  *
 299  * |[&lt;!-- language=&quot;C&quot; --&gt;
 300  * // Notice that it is initialized to the empty list.
 301  * GList *list = NULL;
 302  *
 303  * list = g_list_prepend (list, &quot;last&quot;);
 304  * list = g_list_prepend (list, &quot;first&quot;);
 305  * ]|
 306  *
 307  * Do not use this function to prepend a new element to a different
 308  * element than the start of the list. Use g_list_insert_before() instead.
 309  *
 310  * Returns: a pointer to the newly prepended element, which is the new
 311  *     start of the #GList
 312  */
 313 GList *
 314 g_list_prepend (GList    *list,
 315                 gpointer  data)
 316 {
 317   GList *new_list;
 318 
 319   new_list = _g_list_alloc ();
 320 #ifdef GSTREAMER_LITE
 321   if (new_list == NULL) {
 322     return NULL;
 323   }
 324 #endif // GSTREAMER_LITE
 325   new_list-&gt;data = data;
 326   new_list-&gt;next = list;
 327 
 328   if (list)
 329     {
 330       new_list-&gt;prev = list-&gt;prev;
 331       if (list-&gt;prev)
 332         list-&gt;prev-&gt;next = new_list;
 333       list-&gt;prev = new_list;
 334     }
 335   else
 336     new_list-&gt;prev = NULL;
 337 
 338   return new_list;
 339 }
 340 
 341 /**
 342  * g_list_insert:
 343  * @list: a pointer to a #GList, this must point to the top of the list
 344  * @data: the data for the new element
 345  * @position: the position to insert the element. If this is
 346  *     negative, or is larger than the number of elements in the
 347  *     list, the new element is added on to the end of the list.
 348  *
 349  * Inserts a new element into the list at the given position.
 350  *
 351  * Returns: the (possibly changed) start of the #GList
 352  */
 353 GList *
 354 g_list_insert (GList    *list,
 355                gpointer  data,
 356                gint      position)
 357 {
 358   GList *new_list;
 359   GList *tmp_list;
 360 
 361   if (position &lt; 0)
 362     return g_list_append (list, data);
 363   else if (position == 0)
 364     return g_list_prepend (list, data);
 365 
 366   tmp_list = g_list_nth (list, position);
 367   if (!tmp_list)
 368     return g_list_append (list, data);
 369 
 370   new_list = _g_list_alloc ();
 371 #ifdef GSTREAMER_LITE
 372   if (new_list == NULL) {
 373     return NULL;
 374   }
 375 #endif // GSTREAMER_LITE
 376   new_list-&gt;data = data;
 377   new_list-&gt;prev = tmp_list-&gt;prev;
 378   tmp_list-&gt;prev-&gt;next = new_list;
 379   new_list-&gt;next = tmp_list;
 380   tmp_list-&gt;prev = new_list;
 381 
 382   return list;
 383 }
 384 
 385 /**
 386  * g_list_insert_before_link:
 387  * @list: a pointer to a #GList, this must point to the top of the list
 388  * @sibling: (nullable): the list element before which the new element
 389  *     is inserted or %NULL to insert at the end of the list
 390  * @link_: the list element to be added, which must not be part of
 391  *     any other list
 392  *
 393  * Inserts @link_ into the list before the given position.
 394  *
 395  * Returns: the (possibly changed) start of the #GList
 396  *
 397  * Since: 2.62
 398  */
 399 GList *
 400 g_list_insert_before_link (GList *list,
 401                            GList *sibling,
 402                            GList *link_)
 403 {
 404   g_return_val_if_fail (link_ != NULL, list);
 405   g_return_val_if_fail (link_-&gt;prev == NULL, list);
 406   g_return_val_if_fail (link_-&gt;next == NULL, list);
 407 
 408   if (list == NULL)
 409     {
 410       g_return_val_if_fail (sibling == NULL, list);
 411       return link_;
 412     }
 413   else if (sibling != NULL)
 414     {
 415       link_-&gt;prev = sibling-&gt;prev;
 416       link_-&gt;next = sibling;
 417       sibling-&gt;prev = link_;
 418       if (link_-&gt;prev != NULL)
 419         {
 420           link_-&gt;prev-&gt;next = link_;
 421           return list;
 422         }
 423       else
 424         {
 425           g_return_val_if_fail (sibling == list, link_);
 426           return link_;
 427         }
 428     }
 429   else
 430     {
 431       GList *last;
 432 
 433       for (last = list; last-&gt;next != NULL; last = last-&gt;next) {}
 434 
 435       last-&gt;next = link_;
 436       last-&gt;next-&gt;prev = last;
 437       last-&gt;next-&gt;next = NULL;
 438 
 439       return list;
 440     }
 441 }
 442 
 443 /**
 444  * g_list_insert_before:
 445  * @list: a pointer to a #GList, this must point to the top of the list
 446  * @sibling: the list element before which the new element
 447  *     is inserted or %NULL to insert at the end of the list
 448  * @data: the data for the new element
 449  *
 450  * Inserts a new element into the list before the given position.
 451  *
 452  * Returns: the (possibly changed) start of the #GList
 453  */
 454 GList *
 455 g_list_insert_before (GList    *list,
 456                       GList    *sibling,
 457                       gpointer  data)
 458 {
 459   if (list == NULL)
 460     {
 461       list = g_list_alloc ();
 462       list-&gt;data = data;
 463       g_return_val_if_fail (sibling == NULL, list);
 464       return list;
 465     }
 466   else if (sibling != NULL)
 467     {
 468       GList *node;
 469 
 470       node = _g_list_alloc ();
 471 #ifdef GSTREAMER_LITE
 472       if (node == NULL) {
 473         return NULL;
 474       }
 475 #endif // GSTREAMER_LITE
 476       node-&gt;data = data;
 477       node-&gt;prev = sibling-&gt;prev;
 478       node-&gt;next = sibling;
 479       sibling-&gt;prev = node;
 480       if (node-&gt;prev != NULL)
 481         {
 482           node-&gt;prev-&gt;next = node;
 483           return list;
 484         }
 485       else
 486         {
 487           g_return_val_if_fail (sibling == list, node);
 488           return node;
 489         }
 490     }
 491   else
 492     {
 493       GList *last;
 494 
 495       for (last = list; last-&gt;next != NULL; last = last-&gt;next) {}
 496 
 497       last-&gt;next = _g_list_alloc ();
 498 #ifdef GSTREAMER_LITE
 499       if (last-&gt;next == NULL) {
 500         return NULL;
 501       }
 502 #endif // GSTREAMER_LITE
 503       last-&gt;next-&gt;data = data;
 504       last-&gt;next-&gt;prev = last;
 505       last-&gt;next-&gt;next = NULL;
 506 
 507       return list;
 508     }
 509 }
 510 
 511 /**
 512  * g_list_concat:
 513  * @list1: a #GList, this must point to the top of the list
 514  * @list2: the #GList to add to the end of the first #GList,
 515  *     this must point  to the top of the list
 516  *
 517  * Adds the second #GList onto the end of the first #GList.
 518  * Note that the elements of the second #GList are not copied.
 519  * They are used directly.
 520  *
 521  * This function is for example used to move an element in the list.
 522  * The following example moves an element to the top of the list:
 523  * |[&lt;!-- language=&quot;C&quot; --&gt;
 524  * list = g_list_remove_link (list, llink);
 525  * list = g_list_concat (llink, list);
 526  * ]|
 527  *
 528  * Returns: the start of the new #GList, which equals @list1 if not %NULL
 529  */
 530 GList *
 531 g_list_concat (GList *list1,
 532                GList *list2)
 533 {
 534   GList *tmp_list;
 535 
 536   if (list2)
 537     {
 538       tmp_list = g_list_last (list1);
 539       if (tmp_list)
 540         tmp_list-&gt;next = list2;
 541       else
 542         list1 = list2;
 543       list2-&gt;prev = tmp_list;
 544     }
 545 
 546   return list1;
 547 }
 548 
 549 static inline GList *
 550 _g_list_remove_link (GList *list,
 551                      GList *link)
 552 {
 553   if (link == NULL)
 554     return list;
 555 
 556   if (link-&gt;prev)
 557     {
 558       if (link-&gt;prev-&gt;next == link)
 559         link-&gt;prev-&gt;next = link-&gt;next;
 560       else
 561         g_warning (&quot;corrupted double-linked list detected&quot;);
 562     }
 563   if (link-&gt;next)
 564     {
 565       if (link-&gt;next-&gt;prev == link)
 566         link-&gt;next-&gt;prev = link-&gt;prev;
 567       else
 568         g_warning (&quot;corrupted double-linked list detected&quot;);
 569     }
 570 
 571   if (link == list)
 572     list = list-&gt;next;
 573 
 574   link-&gt;next = NULL;
 575   link-&gt;prev = NULL;
 576 
 577   return list;
 578 }
 579 
 580 /**
 581  * g_list_remove:
 582  * @list: a #GList, this must point to the top of the list
 583  * @data: the data of the element to remove
 584  *
 585  * Removes an element from a #GList.
 586  * If two elements contain the same data, only the first is removed.
 587  * If none of the elements contain the data, the #GList is unchanged.
 588  *
 589  * Returns: the (possibly changed) start of the #GList
 590  */
 591 GList *
 592 g_list_remove (GList         *list,
 593                gconstpointer  data)
 594 {
 595   GList *tmp;
 596 
 597   tmp = list;
 598   while (tmp)
 599     {
 600       if (tmp-&gt;data != data)
 601         tmp = tmp-&gt;next;
 602       else
 603         {
 604           list = _g_list_remove_link (list, tmp);
 605           _g_list_free1 (tmp);
 606 
 607           break;
 608         }
 609     }
 610   return list;
 611 }
 612 
 613 /**
 614  * g_list_remove_all:
 615  * @list: a #GList, this must point to the top of the list
 616  * @data: data to remove
 617  *
 618  * Removes all list nodes with data equal to @data.
 619  * Returns the new head of the list. Contrast with
 620  * g_list_remove() which removes only the first node
 621  * matching the given data.
 622  *
 623  * Returns: the (possibly changed) start of the #GList
 624  */
 625 GList *
 626 g_list_remove_all (GList         *list,
 627                    gconstpointer  data)
 628 {
 629   GList *tmp = list;
 630 
 631   while (tmp)
 632     {
 633       if (tmp-&gt;data != data)
 634         tmp = tmp-&gt;next;
 635       else
 636         {
 637           GList *next = tmp-&gt;next;
 638 
 639           if (tmp-&gt;prev)
 640             tmp-&gt;prev-&gt;next = next;
 641           else
 642             list = next;
 643           if (next)
 644             next-&gt;prev = tmp-&gt;prev;
 645 
 646           _g_list_free1 (tmp);
 647           tmp = next;
 648         }
 649     }
 650   return list;
 651 }
 652 
 653 /**
 654  * g_list_remove_link:
 655  * @list: a #GList, this must point to the top of the list
 656  * @llink: an element in the #GList
 657  *
 658  * Removes an element from a #GList, without freeing the element.
 659  * The removed element&#39;s prev and next links are set to %NULL, so
 660  * that it becomes a self-contained list with one element.
 661  *
 662  * This function is for example used to move an element in the list
 663  * (see the example for g_list_concat()) or to remove an element in
 664  * the list before freeing its data:
 665  * |[&lt;!-- language=&quot;C&quot; --&gt;
 666  * list = g_list_remove_link (list, llink);
 667  * free_some_data_that_may_access_the_list_again (llink-&gt;data);
 668  * g_list_free (llink);
 669  * ]|
 670  *
 671  * Returns: the (possibly changed) start of the #GList
 672  */
 673 GList *
 674 g_list_remove_link (GList *list,
 675                     GList *llink)
 676 {
 677   return _g_list_remove_link (list, llink);
 678 }
 679 
 680 /**
 681  * g_list_delete_link:
 682  * @list: a #GList, this must point to the top of the list
 683  * @link_: node to delete from @list
 684  *
 685  * Removes the node link_ from the list and frees it.
 686  * Compare this to g_list_remove_link() which removes the node
 687  * without freeing it.
 688  *
 689  * Returns: the (possibly changed) start of the #GList
 690  */
 691 GList *
 692 g_list_delete_link (GList *list,
 693                     GList *link_)
 694 {
 695   list = _g_list_remove_link (list, link_);
 696   _g_list_free1 (link_);
 697 
 698   return list;
 699 }
 700 
 701 /**
 702  * g_list_copy:
 703  * @list: a #GList, this must point to the top of the list
 704  *
 705  * Copies a #GList.
 706  *
 707  * Note that this is a &quot;shallow&quot; copy. If the list elements
 708  * consist of pointers to data, the pointers are copied but
 709  * the actual data is not. See g_list_copy_deep() if you need
 710  * to copy the data as well.
 711  *
 712  * Returns: the start of the new list that holds the same data as @list
 713  */
 714 GList *
 715 g_list_copy (GList *list)
 716 {
 717   return g_list_copy_deep (list, NULL, NULL);
 718 }
 719 
 720 /**
 721  * g_list_copy_deep:
 722  * @list: a #GList, this must point to the top of the list
 723  * @func: a copy function used to copy every element in the list
 724  * @user_data: user data passed to the copy function @func, or %NULL
 725  *
 726  * Makes a full (deep) copy of a #GList.
 727  *
 728  * In contrast with g_list_copy(), this function uses @func to make
 729  * a copy of each list element, in addition to copying the list
 730  * container itself.
 731  *
 732  * @func, as a #GCopyFunc, takes two arguments, the data to be copied
 733  * and a @user_data pointer. On common processor architectures, it&#39;s safe to
 734  * pass %NULL as @user_data if the copy function takes only one argument. You
 735  * may get compiler warnings from this though if compiling with GCC&#39;s
 736  * `-Wcast-function-type` warning.
 737  *
 738  * For instance, if @list holds a list of GObjects, you can do:
 739  * |[&lt;!-- language=&quot;C&quot; --&gt;
 740  * another_list = g_list_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
 741  * ]|
 742  *
 743  * And, to entirely free the new list, you could do:
 744  * |[&lt;!-- language=&quot;C&quot; --&gt;
 745  * g_list_free_full (another_list, g_object_unref);
 746  * ]|
 747  *
 748  * Returns: the start of the new list that holds a full copy of @list,
 749  *     use g_list_free_full() to free it
 750  *
 751  * Since: 2.34
 752  */
 753 GList *
 754 g_list_copy_deep (GList     *list,
 755                   GCopyFunc  func,
 756                   gpointer   user_data)
 757 {
 758   GList *new_list = NULL;
 759 
 760   if (list)
 761     {
 762       GList *last;
 763 
 764       new_list = _g_list_alloc ();
 765 #ifdef GSTREAMER_LITE
 766       if (new_list == NULL) {
 767         return NULL;
 768       }
 769 #endif // GSTREAMER_LITE
 770       if (func)
 771         new_list-&gt;data = func (list-&gt;data, user_data);
 772       else
 773         new_list-&gt;data = list-&gt;data;
 774       new_list-&gt;prev = NULL;
 775       last = new_list;
 776       list = list-&gt;next;
 777       while (list)
 778         {
 779           last-&gt;next = _g_list_alloc ();
 780 #ifdef GSTREAMER_LITE
 781           if (last-&gt;next == NULL) {
 782             return NULL;
 783           }
 784 #endif // GSTREAMER_LITE
 785           last-&gt;next-&gt;prev = last;
 786           last = last-&gt;next;
 787           if (func)
 788             last-&gt;data = func (list-&gt;data, user_data);
 789           else
 790             last-&gt;data = list-&gt;data;
 791           list = list-&gt;next;
 792         }
 793       last-&gt;next = NULL;
 794     }
 795 
 796   return new_list;
 797 }
 798 
 799 /**
 800  * g_list_reverse:
 801  * @list: a #GList, this must point to the top of the list
 802  *
 803  * Reverses a #GList.
 804  * It simply switches the next and prev pointers of each element.
 805  *
 806  * Returns: the start of the reversed #GList
 807  */
 808 GList *
 809 g_list_reverse (GList *list)
 810 {
 811   GList *last;
 812 
 813   last = NULL;
 814   while (list)
 815     {
 816       last = list;
 817       list = last-&gt;next;
 818       last-&gt;next = last-&gt;prev;
 819       last-&gt;prev = list;
 820     }
 821 
 822   return last;
 823 }
 824 
 825 /**
 826  * g_list_nth:
 827  * @list: a #GList, this must point to the top of the list
 828  * @n: the position of the element, counting from 0
 829  *
 830  * Gets the element at the given position in a #GList.
 831  *
 832  * This iterates over the list until it reaches the @n-th position. If you
 833  * intend to iterate over every element, it is better to use a for-loop as
 834  * described in the #GList introduction.
 835  *
 836  * Returns: the element, or %NULL if the position is off
 837  *     the end of the #GList
 838  */
 839 GList *
 840 g_list_nth (GList *list,
 841             guint  n)
 842 {
 843   while ((n-- &gt; 0) &amp;&amp; list)
 844     list = list-&gt;next;
 845 
 846   return list;
 847 }
 848 
 849 /**
 850  * g_list_nth_prev:
 851  * @list: a #GList
 852  * @n: the position of the element, counting from 0
 853  *
 854  * Gets the element @n places before @list.
 855  *
 856  * Returns: the element, or %NULL if the position is
 857  *     off the end of the #GList
 858  */
 859 GList *
 860 g_list_nth_prev (GList *list,
 861                  guint  n)
 862 {
 863   while ((n-- &gt; 0) &amp;&amp; list)
 864     list = list-&gt;prev;
 865 
 866   return list;
 867 }
 868 
 869 /**
 870  * g_list_nth_data:
 871  * @list: a #GList, this must point to the top of the list
 872  * @n: the position of the element
 873  *
 874  * Gets the data of the element at the given position.
 875  *
 876  * This iterates over the list until it reaches the @n-th position. If you
 877  * intend to iterate over every element, it is better to use a for-loop as
 878  * described in the #GList introduction.
 879  *
 880  * Returns: the element&#39;s data, or %NULL if the position
 881  *     is off the end of the #GList
 882  */
 883 gpointer
 884 g_list_nth_data (GList *list,
 885                  guint  n)
 886 {
 887   while ((n-- &gt; 0) &amp;&amp; list)
 888     list = list-&gt;next;
 889 
 890   return list ? list-&gt;data : NULL;
 891 }
 892 
 893 /**
 894  * g_list_find:
 895  * @list: a #GList, this must point to the top of the list
 896  * @data: the element data to find
 897  *
 898  * Finds the element in a #GList which contains the given data.
 899  *
 900  * Returns: the found #GList element, or %NULL if it is not found
 901  */
 902 GList *
 903 g_list_find (GList         *list,
 904              gconstpointer  data)
 905 {
 906   while (list)
 907     {
 908       if (list-&gt;data == data)
 909         break;
 910       list = list-&gt;next;
 911     }
 912 
 913   return list;
 914 }
 915 
 916 /**
 917  * g_list_find_custom:
 918  * @list: a #GList, this must point to the top of the list
 919  * @data: user data passed to the function
 920  * @func: the function to call for each element.
 921  *     It should return 0 when the desired element is found
 922  *
 923  * Finds an element in a #GList, using a supplied function to
 924  * find the desired element. It iterates over the list, calling
 925  * the given function which should return 0 when the desired
 926  * element is found. The function takes two #gconstpointer arguments,
 927  * the #GList element&#39;s data as the first argument and the
 928  * given user data.
 929  *
 930  * Returns: the found #GList element, or %NULL if it is not found
 931  */
 932 GList *
 933 g_list_find_custom (GList         *list,
 934                     gconstpointer  data,
 935                     GCompareFunc   func)
 936 {
 937   g_return_val_if_fail (func != NULL, list);
 938 
 939   while (list)
 940     {
 941       if (! func (list-&gt;data, data))
 942         return list;
 943       list = list-&gt;next;
 944     }
 945 
 946   return NULL;
 947 }
 948 
 949 /**
 950  * g_list_position:
 951  * @list: a #GList, this must point to the top of the list
 952  * @llink: an element in the #GList
 953  *
 954  * Gets the position of the given element
 955  * in the #GList (starting from 0).
 956  *
 957  * Returns: the position of the element in the #GList,
 958  *     or -1 if the element is not found
 959  */
 960 gint
 961 g_list_position (GList *list,
 962                  GList *llink)
 963 {
 964   gint i;
 965 
 966   i = 0;
 967   while (list)
 968     {
 969       if (list == llink)
 970         return i;
 971       i++;
 972       list = list-&gt;next;
 973     }
 974 
 975   return -1;
 976 }
 977 
 978 /**
 979  * g_list_index:
 980  * @list: a #GList, this must point to the top of the list
 981  * @data: the data to find
 982  *
 983  * Gets the position of the element containing
 984  * the given data (starting from 0).
 985  *
 986  * Returns: the index of the element containing the data,
 987  *     or -1 if the data is not found
 988  */
 989 gint
 990 g_list_index (GList         *list,
 991               gconstpointer  data)
 992 {
 993   gint i;
 994 
 995   i = 0;
 996   while (list)
 997     {
 998       if (list-&gt;data == data)
 999         return i;
1000       i++;
1001       list = list-&gt;next;
1002     }
1003 
1004   return -1;
1005 }
1006 
1007 /**
1008  * g_list_last:
1009  * @list: any #GList element
1010  *
1011  * Gets the last element in a #GList.
1012  *
1013  * Returns: the last element in the #GList,
1014  *     or %NULL if the #GList has no elements
1015  */
1016 GList *
1017 g_list_last (GList *list)
1018 {
1019   if (list)
1020     {
1021       while (list-&gt;next)
1022         list = list-&gt;next;
1023     }
1024 
1025   return list;
1026 }
1027 
1028 /**
1029  * g_list_first:
1030  * @list: any #GList element
1031  *
1032  * Gets the first element in a #GList.
1033  *
1034  * Returns: the first element in the #GList,
1035  *     or %NULL if the #GList has no elements
1036  */
1037 GList *
1038 g_list_first (GList *list)
1039 {
1040   if (list)
1041     {
1042       while (list-&gt;prev)
1043         list = list-&gt;prev;
1044     }
1045 
1046   return list;
1047 }
1048 
1049 /**
1050  * g_list_length:
1051  * @list: a #GList, this must point to the top of the list
1052  *
1053  * Gets the number of elements in a #GList.
1054  *
1055  * This function iterates over the whole list to count its elements.
1056  * Use a #GQueue instead of a GList if you regularly need the number
1057  * of items. To check whether the list is non-empty, it is faster to check
1058  * @list against %NULL.
1059  *
1060  * Returns: the number of elements in the #GList
1061  */
1062 guint
1063 g_list_length (GList *list)
1064 {
1065   guint length;
1066 
1067   length = 0;
1068   while (list)
1069     {
1070       length++;
1071       list = list-&gt;next;
1072     }
1073 
1074   return length;
1075 }
1076 
1077 /**
1078  * g_list_foreach:
1079  * @list: a #GList, this must point to the top of the list
1080  * @func: the function to call with each element&#39;s data
1081  * @user_data: user data to pass to the function
1082  *
1083  * Calls a function for each element of a #GList.
1084  *
1085  * It is safe for @func to remove the element from @list, but it must
1086  * not modify any part of the list after that element.
1087  */
1088 /**
1089  * GFunc:
1090  * @data: the element&#39;s data
1091  * @user_data: user data passed to g_list_foreach() or g_slist_foreach()
1092  *
1093  * Specifies the type of functions passed to g_list_foreach() and
1094  * g_slist_foreach().
1095  */
1096 void
1097 g_list_foreach (GList    *list,
1098                 GFunc     func,
1099                 gpointer  user_data)
1100 {
1101   while (list)
1102     {
1103       GList *next = list-&gt;next;
1104       (*func) (list-&gt;data, user_data);
1105       list = next;
1106     }
1107 }
1108 
1109 static GList*
1110 g_list_insert_sorted_real (GList    *list,
1111                            gpointer  data,
1112                            GFunc     func,
1113                            gpointer  user_data)
1114 {
1115   GList *tmp_list = list;
1116   GList *new_list;
1117   gint cmp;
1118 
1119   g_return_val_if_fail (func != NULL, list);
1120 
1121   if (!list)
1122     {
1123       new_list = _g_list_alloc0 ();
1124       new_list-&gt;data = data;
1125       return new_list;
1126     }
1127 
1128   cmp = ((GCompareDataFunc) func) (data, tmp_list-&gt;data, user_data);
1129 
1130   while ((tmp_list-&gt;next) &amp;&amp; (cmp &gt; 0))
1131     {
1132       tmp_list = tmp_list-&gt;next;
1133 
1134       cmp = ((GCompareDataFunc) func) (data, tmp_list-&gt;data, user_data);
1135     }
1136 
1137   new_list = _g_list_alloc0 ();
1138   new_list-&gt;data = data;
1139 
1140   if ((!tmp_list-&gt;next) &amp;&amp; (cmp &gt; 0))
1141     {
1142       tmp_list-&gt;next = new_list;
1143       new_list-&gt;prev = tmp_list;
1144       return list;
1145     }
1146 
1147   if (tmp_list-&gt;prev)
1148     {
1149       tmp_list-&gt;prev-&gt;next = new_list;
1150       new_list-&gt;prev = tmp_list-&gt;prev;
1151     }
1152   new_list-&gt;next = tmp_list;
1153   tmp_list-&gt;prev = new_list;
1154 
1155   if (tmp_list == list)
1156     return new_list;
1157   else
1158     return list;
1159 }
1160 
1161 /**
1162  * g_list_insert_sorted:
1163  * @list: a pointer to a #GList, this must point to the top of the
1164  *     already sorted list
1165  * @data: the data for the new element
1166  * @func: the function to compare elements in the list. It should
1167  *     return a number &gt; 0 if the first parameter comes after the
1168  *     second parameter in the sort order.
1169  *
1170  * Inserts a new element into the list, using the given comparison
1171  * function to determine its position.
1172  *
1173  * If you are adding many new elements to a list, and the number of
1174  * new elements is much larger than the length of the list, use
1175  * g_list_prepend() to add the new items and sort the list afterwards
1176  * with g_list_sort().
1177  *
1178  * Returns: the (possibly changed) start of the #GList
1179  */
1180 GList *
1181 g_list_insert_sorted (GList        *list,
1182                       gpointer      data,
1183                       GCompareFunc  func)
1184 {
1185   return g_list_insert_sorted_real (list, data, (GFunc) func, NULL);
1186 }
1187 
1188 /**
1189  * g_list_insert_sorted_with_data:
1190  * @list: a pointer to a #GList, this must point to the top of the
1191  *     already sorted list
1192  * @data: the data for the new element
1193  * @func: the function to compare elements in the list. It should
1194  *     return a number &gt; 0 if the first parameter  comes after the
1195  *     second parameter in the sort order.
1196  * @user_data: user data to pass to comparison function
1197  *
1198  * Inserts a new element into the list, using the given comparison
1199  * function to determine its position.
1200  *
1201  * If you are adding many new elements to a list, and the number of
1202  * new elements is much larger than the length of the list, use
1203  * g_list_prepend() to add the new items and sort the list afterwards
1204  * with g_list_sort().
1205  *
1206  * Returns: the (possibly changed) start of the #GList
1207  *
1208  * Since: 2.10
1209  */
1210 GList *
1211 g_list_insert_sorted_with_data (GList            *list,
1212                                 gpointer          data,
1213                                 GCompareDataFunc  func,
1214                                 gpointer          user_data)
1215 {
1216   return g_list_insert_sorted_real (list, data, (GFunc) func, user_data);
1217 }
1218 
1219 static GList *
1220 g_list_sort_merge (GList     *l1,
1221                    GList     *l2,
1222                    GFunc     compare_func,
1223                    gpointer  user_data)
1224 {
1225   GList list, *l, *lprev;
1226   gint cmp;
1227 
1228   l = &amp;list;
1229   lprev = NULL;
1230 
1231   while (l1 &amp;&amp; l2)
1232     {
1233       cmp = ((GCompareDataFunc) compare_func) (l1-&gt;data, l2-&gt;data, user_data);
1234 
1235       if (cmp &lt;= 0)
1236         {
1237           l-&gt;next = l1;
1238           l1 = l1-&gt;next;
1239         }
1240       else
1241         {
1242           l-&gt;next = l2;
1243           l2 = l2-&gt;next;
1244         }
1245       l = l-&gt;next;
1246       l-&gt;prev = lprev;
1247       lprev = l;
1248     }
1249   l-&gt;next = l1 ? l1 : l2;
1250   l-&gt;next-&gt;prev = l;
1251 
1252   return list.next;
1253 }
1254 
1255 static GList *
1256 g_list_sort_real (GList    *list,
1257                   GFunc     compare_func,
1258                   gpointer  user_data)
1259 {
1260   GList *l1, *l2;
1261 
1262   if (!list)
1263     return NULL;
1264   if (!list-&gt;next)
1265     return list;
1266 
1267   l1 = list;
1268   l2 = list-&gt;next;
1269 
1270   while ((l2 = l2-&gt;next) != NULL)
1271     {
1272       if ((l2 = l2-&gt;next) == NULL)
1273         break;
1274       l1 = l1-&gt;next;
1275     }
1276   l2 = l1-&gt;next;
1277   l1-&gt;next = NULL;
1278 
1279   return g_list_sort_merge (g_list_sort_real (list, compare_func, user_data),
1280                             g_list_sort_real (l2, compare_func, user_data),
1281                             compare_func,
1282                             user_data);
1283 }
1284 
1285 /**
1286  * g_list_sort:
1287  * @list: a #GList, this must point to the top of the list
1288  * @compare_func: the comparison function used to sort the #GList.
1289  *     This function is passed the data from 2 elements of the #GList
1290  *     and should return 0 if they are equal, a negative value if the
1291  *     first element comes before the second, or a positive value if
1292  *     the first element comes after the second.
1293  *
1294  * Sorts a #GList using the given comparison function. The algorithm
1295  * used is a stable sort.
1296  *
1297  * Returns: the (possibly changed) start of the #GList
1298  */
1299 /**
1300  * GCompareFunc:
1301  * @a: a value
1302  * @b: a value to compare with
1303  *
1304  * Specifies the type of a comparison function used to compare two
1305  * values.  The function should return a negative integer if the first
1306  * value comes before the second, 0 if they are equal, or a positive
1307  * integer if the first value comes after the second.
1308  *
1309  * Returns: negative value if @a &lt; @b; zero if @a = @b; positive
1310  *          value if @a &gt; @b
1311  */
1312 GList *
1313 g_list_sort (GList        *list,
1314              GCompareFunc  compare_func)
1315 {
1316   return g_list_sort_real (list, (GFunc) compare_func, NULL);
1317 }
1318 
1319 /**
1320  * g_list_sort_with_data:
1321  * @list: a #GList, this must point to the top of the list
1322  * @compare_func: comparison function
1323  * @user_data: user data to pass to comparison function
1324  *
1325  * Like g_list_sort(), but the comparison function accepts
1326  * a user data argument.
1327  *
1328  * Returns: the (possibly changed) start of the #GList
1329  */
1330 /**
1331  * GCompareDataFunc:
1332  * @a: a value
1333  * @b: a value to compare with
1334  * @user_data: user data
1335  *
1336  * Specifies the type of a comparison function used to compare two
1337  * values.  The function should return a negative integer if the first
1338  * value comes before the second, 0 if they are equal, or a positive
1339  * integer if the first value comes after the second.
1340  *
1341  * Returns: negative value if @a &lt; @b; zero if @a = @b; positive
1342  *          value if @a &gt; @b
1343  */
1344 GList *
1345 g_list_sort_with_data (GList            *list,
1346                        GCompareDataFunc  compare_func,
1347                        gpointer          user_data)
1348 {
1349   return g_list_sort_real (list, (GFunc) compare_func, user_data);
1350 }
    </pre>
  </body>
</html>