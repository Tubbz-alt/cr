diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c
@@ -45,81 +45,86 @@
  *
  * # Description of the parsing mechanism:
  *
  * ## Set-up phase
  *
- *  * #GstBaseParse calls @start to inform subclass that data processing is
- *    about to start now.
+ *  * #GstBaseParse calls #GstBaseParseClass.start() to inform subclass
+ *    that data processing is about to start now.
  *
- *  * #GstBaseParse class calls @set_sink_caps to inform the subclass about
- *    incoming sinkpad caps. Subclass could already set the srcpad caps
- *    accordingly, but this might be delayed until calling
- *    gst_base_parse_finish_frame() with a non-queued frame.
+ *  * #GstBaseParse class calls #GstBaseParseClass.set_sink_caps() to
+ *    inform the subclass about incoming sinkpad caps. Subclass could
+ *    already set the srcpad caps accordingly, but this might be delayed
+ *    until calling gst_base_parse_finish_frame() with a non-queued frame.
  *
  *  * At least at this point subclass needs to tell the #GstBaseParse class
- *    how big data chunks it wants to receive (min_frame_size). It can do
- *    this with gst_base_parse_set_min_frame_size().
+ *    how big data chunks it wants to receive (minimum frame size ). It can
+ *    do this with gst_base_parse_set_min_frame_size().
  *
  *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
  *    and starts to process the data.
  *
  * ## Parsing phase
  *
  *  * #GstBaseParse gathers at least min_frame_size bytes of data either
  *    by pulling it from upstream or collecting buffers in an internal
  *    #GstAdapter.
  *
- *  * A buffer of (at least) min_frame_size bytes is passed to subclass with
- *    @handle_frame. Subclass checks the contents and can optionally
- *    return GST_FLOW_OK along with an amount of data to be skipped to find
- *    a valid frame (which will result in a subsequent DISCONT).
- *    If, otherwise, the buffer does not hold a complete frame,
- *    @handle_frame can merely return and will be called again when additional
- *    data is available.  In push mode this amounts to an
- *    additional input buffer (thus minimal additional latency), in pull mode
- *    this amounts to some arbitrary reasonable buffer size increase.
- *    Of course, gst_base_parse_set_min_frame_size() could also be used if a
- *    very specific known amount of additional data is required.
- *    If, however, the buffer holds a complete valid frame, it can pass
- *    the size of this frame to gst_base_parse_finish_frame().
- *    If acting as a converter, it can also merely indicate consumed input data
- *    while simultaneously providing custom output data.
- *    Note that baseclass performs some processing (such as tracking
- *    overall consumed data rate versus duration) for each finished frame,
- *    but other state is only updated upon each call to @handle_frame
+ *  * A buffer of (at least) min_frame_size bytes is passed to subclass
+ *    with #GstBaseParseClass.handle_frame(). Subclass checks the contents
+ *    and can optionally return #GST_FLOW_OK along with an amount of data
+ *    to be skipped to find a valid frame (which will result in a
+ *    subsequent DISCONT).  If, otherwise, the buffer does not hold a
+ *    complete frame, #GstBaseParseClass.handle_frame() can merely return
+ *    and will be called again when additional data is available.  In push
+ *    mode this amounts to an additional input buffer (thus minimal
+ *    additional latency), in pull mode this amounts to some arbitrary
+ *    reasonable buffer size increase.
+ *
+ *    Of course, gst_base_parse_set_min_frame_size() could also be used if
+ *    a very specific known amount of additional data is required.  If,
+ *    however, the buffer holds a complete valid frame, it can pass the
+ *    size of this frame to gst_base_parse_finish_frame().
+ *
+ *    If acting as a converter, it can also merely indicate consumed input
+ *    data while simultaneously providing custom output data.  Note that
+ *    baseclass performs some processing (such as tracking overall consumed
+ *    data rate versus duration) for each finished frame, but other state
+ *    is only updated upon each call to #GstBaseParseClass.handle_frame()
  *    (such as tracking upstream input timestamp).
  *
  *    Subclass is also responsible for setting the buffer metadata
  *    (e.g. buffer timestamp and duration, or keyframe if applicable).
  *    (although the latter can also be done by #GstBaseParse if it is
  *    appropriately configured, see below).  Frame is provided with
  *    timestamp derived from upstream (as much as generally possible),
  *    duration obtained from configuration (see below), and offset
  *    if meaningful (in pull mode).
  *
- *    Note that @check_valid_frame might receive any small
- *    amount of input data when leftover data is being drained (e.g. at EOS).
+ *    Note that #GstBaseParseClass.handle_frame() might receive any small
+ *    amount of input data when leftover data is being drained (e.g. at
+ *    EOS).
  *
- *  * As part of finish frame processing,
- *    just prior to actually pushing the buffer in question,
- *    it is passed to @pre_push_frame which gives subclass yet one
- *    last chance to examine buffer metadata, or to send some custom (tag)
+ *  * As part of finish frame processing, just prior to actually pushing
+ *    the buffer in question, it is passed to
+ *    #GstBaseParseClass.pre_push_frame() which gives subclass yet one last
+ *    chance to examine buffer metadata, or to send some custom (tag)
  *    events, or to perform custom (segment) filtering.
  *
  *  * During the parsing process #GstBaseParseClass will handle both srcpad
- *    and sinkpad events. They will be passed to subclass if @event or
- *    @src_event callbacks have been provided.
+ *    and sinkpad events. They will be passed to subclass if
+ *    #GstBaseParseClass.event() or #GstBaseParseClass.src_event()
+ *    implementations have been provided.
  *
  * ## Shutdown phase
  *
- * * #GstBaseParse class calls @stop to inform the subclass that data
- *   parsing will be stopped.
+ * * #GstBaseParse class calls #GstBaseParseClass.stop() to inform the
+ *   subclass that data parsing will be stopped.
  *
- * Subclass is responsible for providing pad template caps for
- * source and sink pads. The pads need to be named "sink" and "src". It also
- * needs to set the fixed caps on srcpad, when the format is ensured (e.g.
- * when base class calls subclass' @set_sink_caps function).
+ * Subclass is responsible for providing pad template caps for source and
+ * sink pads. The pads need to be named "sink" and "src". It also needs to
+ * set the fixed caps on srcpad, when the format is ensured (e.g.  when
+ * base class calls subclass' #GstBaseParseClass.set_sink_caps() function).
  *
  * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
  * subclass conversion routine needs to know that conversion from
  * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
  * frame number that can be found from the given byte position.
@@ -134,29 +139,31 @@
  *
  * * Provide pad templates
  * * Fixate the source pad caps when appropriate
  * * Inform base class how big data chunks should be retrieved. This is
  *   done with gst_base_parse_set_min_frame_size() function.
- * * Examine data chunks passed to subclass with @handle_frame and pass
- *   proper frame(s) to gst_base_parse_finish_frame(), and setting src pad
- *   caps and timestamps on frame.
+ * * Examine data chunks passed to subclass with
+ *   #GstBaseParseClass.handle_frame() and pass proper frame(s) to
+ *   gst_base_parse_finish_frame(), and setting src pad caps and timestamps
+ *   on frame.
  * * Provide conversion functions
  * * Update the duration information with gst_base_parse_set_duration()
  * * Optionally passthrough using gst_base_parse_set_passthrough()
  * * Configure various baseparse parameters using
  *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
  *   and gst_base_parse_set_frame_rate().
  *
  * * In particular, if subclass is unable to determine a duration, but
  *   parsing (or specs) yields a frames per seconds rate, then this can be
- *   provided to #GstBaseParse to enable it to cater for
- *   buffer time metadata (which will be taken from upstream as much as
+ *   provided to #GstBaseParse to enable it to cater for buffer time
+ *   metadata (which will be taken from upstream as much as
  *   possible). Internally keeping track of frame durations and respective
  *   sizes that have been pushed provides #GstBaseParse with an estimated
- *   bitrate. A default @convert (used if not overridden) will then use these
- *   rates to perform obvious conversions.  These rates are also used to
- *   update (estimated) duration at regular frame intervals.
+ *   bitrate. A default #GstBaseParseClass.convert() (used if not
+ *   overridden) will then use these rates to perform obvious conversions.
+ *   These rates are also used to update (estimated) duration at regular
+ *   frame intervals.
  *
  */
 
 /* TODO:
  *  - In push mode provide a queue of adapter-"queued" buffers for upstream
@@ -203,13 +210,10 @@
   GST_FORMAT_BYTES,
   GST_FORMAT_TIME,
   GST_FORMAT_UNDEFINED
 };
 
-#define GST_BASE_PARSE_GET_PRIVATE(obj)  \
-    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_PARSE, GstBaseParsePrivate))
-
 struct _GstBaseParsePrivate
 {
   GstPadMode pad_mode;
 
   GstAdapter *adapter;
@@ -339,10 +343,13 @@
   /* Tag handling (stream tags only, global tags are passed through as-is) */
   GstTagList *upstream_tags;
   GstTagList *parser_tags;
   GstTagMergeMode parser_tags_merge_mode;
   gboolean tags_changed;
+
+  /* Current segment seqnum */
+  guint32 segment_seqnum;
 };
 
 typedef struct _GstBaseParseSeek
 {
   GstSegment segment;
@@ -364,10 +371,11 @@
   g_mutex_lock (&parse->priv->index_lock);
 #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
   g_mutex_unlock (&parse->priv->index_lock);
 
 static GstElementClass *parent_class = NULL;
+static gint base_parse_private_offset = 0;
 
 static void gst_base_parse_class_init (GstBaseParseClass * klass);
 static void gst_base_parse_init (GstBaseParse * parse,
     GstBaseParseClass * klass);
 
@@ -390,15 +398,25 @@
     };
     GType _type;
 
     _type = g_type_register_static (GST_TYPE_ELEMENT,
         "GstBaseParse", &base_parse_info, G_TYPE_FLAG_ABSTRACT);
+
+    base_parse_private_offset =
+        g_type_add_instance_private (_type, sizeof (GstBaseParsePrivate));
+
     g_once_init_leave (&base_parse_type, _type);
   }
   return (GType) base_parse_type;
 }
 
+static inline GstBaseParsePrivate *
+gst_base_parse_get_instance_private (GstBaseParse * self)
+{
+  return (G_STRUCT_MEMBER_P (self, base_parse_private_offset));
+}
+
 static void gst_base_parse_finalize (GObject * object);
 
 static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
     GstStateChange transition);
 static void gst_base_parse_reset (GstBaseParse * parse);
@@ -524,11 +542,14 @@
 {
   GObjectClass *gobject_class;
   GstElementClass *gstelement_class;
 
   gobject_class = G_OBJECT_CLASS (klass);
-  g_type_class_add_private (klass, sizeof (GstBaseParsePrivate));
+
+  if (base_parse_private_offset != 0)
+    g_type_class_adjust_private_offset (klass, &base_parse_private_offset);
+
   parent_class = g_type_class_peek_parent (klass);
 
   gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
   gobject_class->set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
   gobject_class->get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
@@ -574,11 +595,11 @@
 {
   GstPadTemplate *pad_template;
 
   GST_DEBUG_OBJECT (parse, "gst_base_parse_init");
 
-  parse->priv = GST_BASE_PARSE_GET_PRIVATE (parse);
+  parse->priv = gst_base_parse_get_instance_private (parse);
 
   pad_template =
       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), "sink");
   g_return_if_fail (pad_template != NULL);
   parse->sinkpad = gst_pad_new_from_template (pad_template, "sink");
@@ -624,10 +645,11 @@
   GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
 
   parse->priv->upstream_tags = NULL;
   parse->priv->parser_tags = NULL;
   parse->priv->parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
+  parse->priv->disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;
 }
 
 static void
 gst_base_parse_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -658,10 +680,19 @@
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
 }
 
+/**
+ * gst_base_parse_frame_copy:
+ * @frame: a #GstBaseParseFrame
+ *
+ * Copies a #GstBaseParseFrame.
+ *
+ * Returns: A copy of @frame
+ */
+
 GstBaseParseFrame *
 gst_base_parse_frame_copy (GstBaseParseFrame * frame)
 {
   GstBaseParseFrame *copy;
 
@@ -672,10 +703,16 @@
   GST_TRACE ("copied frame %p -> %p", frame, copy);
 
   return copy;
 }
 
+/**
+ * gst_base_parse_frame_free:
+ * @frame: A #GstBaseParseFrame
+ *
+ * Frees the provided @frame.
+ */
 void
 gst_base_parse_frame_free (GstBaseParseFrame * frame)
 {
   GST_TRACE ("freeing frame %p", frame);
 
@@ -690,12 +727,12 @@
     memset (frame, 0, sizeof (*frame));
   }
 }
 
 G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
-        (GBoxedCopyFunc) gst_base_parse_frame_copy,
-        (GBoxedFreeFunc) gst_base_parse_frame_free);
+    (GBoxedCopyFunc) gst_base_parse_frame_copy,
+    (GBoxedFreeFunc) gst_base_parse_frame_free);
 
 /**
  * gst_base_parse_frame_init:
  * @frame: #GstBaseParseFrame.
  *
@@ -800,11 +837,10 @@
   parse->priv->estimated_duration = -1;
   parse->priv->estimated_drift = 0;
   parse->priv->next_pts = GST_CLOCK_TIME_NONE;
   parse->priv->next_dts = 0;
   parse->priv->syncable = TRUE;
-  parse->priv->disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;
   parse->priv->passthrough = FALSE;
   parse->priv->pts_interpolate = TRUE;
   parse->priv->infer_ts = TRUE;
   parse->priv->has_timing_info = FALSE;
   parse->priv->min_bitrate = G_MAXUINT;
@@ -862,10 +898,12 @@
 
   g_list_foreach (parse->priv->detect_buffers, (GFunc) gst_buffer_unref, NULL);
   g_list_free (parse->priv->detect_buffers);
   parse->priv->detect_buffers = NULL;
   parse->priv->detect_buffers_size = 0;
+
+  parse->priv->segment_seqnum = GST_SEQNUM_INVALID;
   GST_OBJECT_UNLOCK (parse);
 }
 
 static gboolean
 gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
@@ -1167,18 +1205,20 @@
     case GST_EVENT_SEGMENT:
     {
       const GstSegment *in_segment;
       GstSegment out_segment;
       gint64 offset = 0, next_dts;
-      guint32 seqnum = gst_event_get_seqnum (event);
 
+      parse->priv->segment_seqnum = gst_event_get_seqnum (event);
       gst_event_parse_segment (event, &in_segment);
       gst_segment_init (&out_segment, GST_FORMAT_TIME);
       out_segment.rate = in_segment->rate;
       out_segment.applied_rate = in_segment->applied_rate;
 
-      GST_DEBUG_OBJECT (parse, "segment %" GST_SEGMENT_FORMAT, in_segment);
+      GST_DEBUG_OBJECT (parse, "New segment %" GST_SEGMENT_FORMAT, in_segment);
+      GST_DEBUG_OBJECT (parse, "Current segment %" GST_SEGMENT_FORMAT,
+          &parse->segment);
 
       parse->priv->upstream_format = in_segment->format;
       if (in_segment->format == GST_FORMAT_BYTES) {
         GstBaseParseSeek *seek = NULL;
         GSList *node;
@@ -1226,11 +1266,11 @@
         }
 
         gst_event_unref (event);
 
         event = gst_event_new_segment (&out_segment);
-        gst_event_set_seqnum (event, seqnum);
+        gst_event_set_seqnum (event, parse->priv->segment_seqnum);
 
         GST_DEBUG_OBJECT (parse, "Converted incoming segment to TIME. %"
             GST_SEGMENT_FORMAT, in_segment);
 
       } else if (in_segment->format != GST_FORMAT_TIME) {
@@ -1241,26 +1281,28 @@
         out_segment.start = 0;
         out_segment.stop = GST_CLOCK_TIME_NONE;
         out_segment.time = 0;
 
         event = gst_event_new_segment (&out_segment);
-        gst_event_set_seqnum (event, seqnum);
+        gst_event_set_seqnum (event, parse->priv->segment_seqnum);
 
         next_dts = 0;
       } else {
         /* not considered BYTE seekable if it is talking to us in TIME,
          * whatever else it might claim */
         parse->priv->upstream_seekable = FALSE;
         next_dts = in_segment->start;
         gst_event_copy_segment (event, &out_segment);
       }
 
+      GST_DEBUG_OBJECT (parse, "OUT segment %" GST_SEGMENT_FORMAT,
+          &out_segment);
       memcpy (&parse->segment, &out_segment, sizeof (GstSegment));
 
       /*
          gst_segment_set_newsegment (&parse->segment, update, rate,
-          applied_rate, format, start, stop, start);
+         applied_rate, format, start, stop, start);
        */
 
       ret = TRUE;
 
       /* save the segment for later, right before we push a new buffer so that
@@ -1430,11 +1472,11 @@
 
       gst_event_parse_tag (event, &tags);
 
       /* We only care about stream tags here, global tags we just forward */
       if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
-      break;
+        break;
 
       gst_base_parse_set_upstream_tags (parse, tags);
       gst_base_parse_queue_tag_event_update (parse);
       parse->priv->tags_changed = FALSE;
       gst_event_unref (event);
@@ -1654,11 +1696,11 @@
  * @src_format: #GstFormat describing the source format.
  * @src_value: Source value to be converted.
  * @dest_format: #GstFormat defining the converted format.
  * @dest_value: (out): Pointer where the conversion result will be put.
  *
- * Default implementation of "convert" vmethod in #GstBaseParse class.
+ * Default implementation of #GstBaseParseClass.convert().
  *
  * Returns: %TRUE if conversion was successful.
  */
 gboolean
 gst_base_parse_convert_default (GstBaseParse * parse,
@@ -1757,11 +1799,11 @@
 no_slaved_conversions:
   {
     GST_DEBUG_OBJECT (parse,
         "Can't do format conversions when upstream format is not BYTES");
     return FALSE;
-}
+  }
 }
 
 static void
 gst_base_parse_update_duration (GstBaseParse * parse)
 {
@@ -1780,17 +1822,17 @@
   parse->priv->estimated_duration = dest_value;
   GST_LOG_OBJECT (parse,
       "updated estimated duration to %" GST_TIME_FORMAT,
       GST_TIME_ARGS (dest_value));
 
-        if (parse->priv->estimated_drift > GST_SECOND ||
-            parse->priv->estimated_drift < -GST_SECOND) {
-          gst_element_post_message (GST_ELEMENT (parse),
-              gst_message_new_duration_changed (GST_OBJECT (parse)));
-          parse->priv->estimated_drift = 0;
-        }
-      }
+  if (parse->priv->estimated_drift > GST_SECOND ||
+      parse->priv->estimated_drift < -GST_SECOND) {
+    gst_element_post_message (GST_ELEMENT (parse),
+        gst_message_new_duration_changed (GST_OBJECT (parse)));
+    parse->priv->estimated_drift = 0;
+  }
+}
 
 /* gst_base_parse_update_bitrates:
  * @parse: #GstBaseParse.
  * @buffer: Current frame as a #GstBuffer
  *
@@ -1880,13 +1922,13 @@
       guint64 diffprev = gst_util_uint64_scale (100,
           ABSDIFF (parse->priv->avg_bitrate, parse->priv->posted_avg_bitrate),
           parse->priv->avg_bitrate);
       if (diffprev >= UPDATE_THRESHOLD)
         parse->priv->tags_changed = TRUE;
+    }
   }
 }
-}
 
 /**
  * gst_base_parse_add_index_entry:
  * @parse: #GstBaseParse.
  * @offset: offset of entry
@@ -2121,11 +2163,11 @@
   gst_buffer_unref (buffer);
   gst_base_parse_update_frame (parse, frame);
 
   /* clear flags for next frame */
   parse->priv->discont = FALSE;
-    parse->priv->new_frame = FALSE;
+  parse->priv->new_frame = FALSE;
 
   /* use default handler to provide initial (upstream) metadata */
   gst_base_parse_parse_frame (parse, frame);
 
   return frame;
@@ -2201,19 +2243,19 @@
       /* If we're asked to skip more than is available in the adapter,
          we need to remember what we need to skip for next iteration */
       gsize av = gst_adapter_available (parse->priv->adapter);
       GST_DEBUG ("Asked to skip %u (%" G_GSIZE_FORMAT " available)", *skip, av);
       if (av >= *skip) {
-      gst_adapter_flush (parse->priv->adapter, *skip);
+        gst_adapter_flush (parse->priv->adapter, *skip);
       } else {
         GST_DEBUG
             ("This is more than available, flushing %" G_GSIZE_FORMAT
             ", storing %u to skip", av, (guint) (*skip - av));
         parse->priv->skip = *skip - av;
         gst_adapter_flush (parse->priv->adapter, av);
         *skip = av;
-    }
+      }
     }
     if (!parse->priv->discont)
       parse->priv->sync_offset = parse->priv->offset;
     parse->priv->offset += *skip;
     parse->priv->discont = TRUE;
@@ -2454,26 +2496,29 @@
       diff = GST_CLOCK_DIFF (parse->segment.position, last_start);
       if (G_UNLIKELY (diff > 2 * GST_SECOND
               && last_start > parse->segment.start
               && (!GST_CLOCK_TIME_IS_VALID (parse->segment.stop)
                   || last_start < parse->segment.stop))) {
+        GstEvent *topush;
 
         GST_DEBUG_OBJECT (parse,
             "Gap of %" G_GINT64_FORMAT " ns detected in stream " "(%"
             GST_TIME_FORMAT " -> %" GST_TIME_FORMAT "). "
             "Sending updated SEGMENT events", diff,
             GST_TIME_ARGS (parse->segment.position),
             GST_TIME_ARGS (last_start));
 
         /* skip gap FIXME */
-          gst_pad_push_event (parse->srcpad,
-            gst_event_new_segment (&parse->segment));
+        topush = gst_event_new_segment (&parse->segment);
+        if (parse->priv->segment_seqnum != GST_SEQNUM_INVALID)
+          gst_event_set_seqnum (topush, parse->priv->segment_seqnum);
+        gst_pad_push_event (parse->srcpad, topush);
 
         parse->segment.position = last_start;
-        }
       }
     }
+  }
 
   /* update bitrates and optionally post corresponding tags
    * (following newsegment) */
   gst_base_parse_update_bitrates (parse, frame);
 
@@ -2495,12 +2540,12 @@
   if (frame->out_buffer) {
     buffer = frame->out_buffer;
     frame->out_buffer = NULL;
     gst_buffer_replace (&frame->buffer, NULL);
   } else {
-  buffer = frame->buffer;
-  frame->buffer = NULL;
+    buffer = frame->buffer;
+    frame->buffer = NULL;
   }
 
   /* subclass must play nice */
   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
 
@@ -2564,11 +2609,11 @@
         GST_LOG_OBJECT (parse,
             "pushing frame (%" G_GSIZE_FORMAT " bytes) now..", size);
         ret = gst_pad_push (parse->srcpad, buffer);
         GST_LOG_OBJECT (parse, "frame pushed, flow %s",
             gst_flow_get_name (ret));
-    } else {
+      } else {
         GST_LOG_OBJECT (parse,
             "frame (%" G_GSIZE_FORMAT " bytes) not pushed: %s", size,
             gst_flow_get_name (ret));
         gst_buffer_unref (buffer);
       }
@@ -2854,11 +2899,11 @@
   while (parse->priv->buffers_pending) {
     buf = GST_BUFFER_CAST (parse->priv->buffers_pending->data);
     if (prev_head) {
       GST_LOG_OBJECT (parse, "adding pending buffer (size %" G_GSIZE_FORMAT ")",
           gst_buffer_get_size (buf));
-    gst_adapter_push (parse->priv->adapter, buf);
+      gst_adapter_push (parse->priv->adapter, buf);
     } else {
       GST_LOG_OBJECT (parse, "discarding head buffer");
       gst_buffer_unref (buf);
     }
     parse->priv->buffers_pending =
@@ -2887,14 +2932,14 @@
           GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
     } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
       if (GST_CLOCK_TIME_IS_VALID (parse->priv->last_pts)) {
         if (G_LIKELY (GST_BUFFER_DURATION (buf) <= parse->priv->last_pts))
           parse->priv->last_pts -= GST_BUFFER_DURATION (buf);
-      else
+        else
           parse->priv->last_pts = 0;
         GST_BUFFER_PTS (buf) = parse->priv->last_pts;
-      GST_LOG_OBJECT (parse, "applied time %" GST_TIME_FORMAT,
+        GST_LOG_OBJECT (parse, "applied time %" GST_TIME_FORMAT,
             GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
       }
       if (GST_CLOCK_TIME_IS_VALID (parse->priv->last_dts)) {
         if (G_LIKELY (GST_BUFFER_DURATION (buf) <= parse->priv->last_dts))
           parse->priv->last_dts -= GST_BUFFER_DURATION (buf);
@@ -3168,13 +3213,13 @@
       ret = gst_base_parse_push_frame (parse, &frame);
       gst_base_parse_frame_free (&frame);
       return ret;
     }
     if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
-    /* upstream feeding us in reverse playback;
-     * finish previous fragment and start new upon DISCONT */
-    if (parse->segment.rate < 0.0) {
+      /* upstream feeding us in reverse playback;
+       * finish previous fragment and start new upon DISCONT */
+      if (parse->segment.rate < 0.0) {
         GST_DEBUG_OBJECT (parse, "buffer starts new reverse playback fragment");
         ret = gst_base_parse_finish_fragment (parse, TRUE);
         gst_base_parse_start_fragment (parse);
       } else {
         /* discont in the stream, drain and mark discont for next output */
@@ -3191,26 +3236,26 @@
     gint flush = 0;
     gboolean updated_prev_pts = FALSE;
 
     /* note: if subclass indicates MAX fsize,
      * this will not likely be available anyway ... */
-      min_size = MAX (parse->priv->min_frame_size, fsize);
-      av = gst_adapter_available (parse->priv->adapter);
-
-      if (G_UNLIKELY (parse->priv->drain)) {
-        min_size = av;
-        GST_DEBUG_OBJECT (parse, "draining, data left: %d", min_size);
-        if (G_UNLIKELY (!min_size)) {
-          goto done;
-        }
-      }
+    min_size = MAX (parse->priv->min_frame_size, fsize);
+    av = gst_adapter_available (parse->priv->adapter);
 
-      /* Collect at least min_frame_size bytes */
-      if (av < min_size) {
-      GST_DEBUG_OBJECT (parse, "not enough data available (only %d bytes)", av);
+    if (G_UNLIKELY (parse->priv->drain)) {
+      min_size = av;
+      GST_DEBUG_OBJECT (parse, "draining, data left: %d", min_size);
+      if (G_UNLIKELY (!min_size)) {
         goto done;
       }
+    }
+
+    /* Collect at least min_frame_size bytes */
+    if (av < min_size) {
+      GST_DEBUG_OBJECT (parse, "not enough data available (only %d bytes)", av);
+      goto done;
+    }
 
     /* move along with upstream timestamp (if any),
      * but interpolate in between */
     pts = gst_adapter_prev_pts (parse->priv->adapter, NULL);
     dts = gst_adapter_prev_dts (parse->priv->adapter, NULL);
@@ -3235,39 +3280,39 @@
         && GST_CLOCK_TIME_IS_VALID (pts)) {
       parse->priv->prev_dts = parse->priv->next_dts = pts;
       parse->priv->prev_dts_from_pts = TRUE;
     }
 
-      /* always pass all available data */
+    /* always pass all available data */
     tmpbuf = gst_adapter_get_buffer (parse->priv->adapter, av);
 
     /* already inform subclass what timestamps we have planned,
      * at least if provided by time-based upstream */
     if (parse->priv->upstream_format == GST_FORMAT_TIME) {
       tmpbuf = gst_buffer_make_writable (tmpbuf);
       GST_BUFFER_PTS (tmpbuf) = parse->priv->next_pts;
       GST_BUFFER_DTS (tmpbuf) = parse->priv->next_dts;
       GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
-      }
+    }
 
     /* keep the adapter mapped, so keep track of what has to be flushed */
     ret = gst_base_parse_handle_buffer (parse, tmpbuf, &skip, &flush);
     tmpbuf = NULL;
 
     if (ret != GST_FLOW_OK && ret != GST_FLOW_NOT_LINKED) {
-          goto done;
-        }
+      goto done;
+    }
     if (skip == 0 && flush == 0) {
       GST_LOG_OBJECT (parse, "nothing skipped and no frames finished, "
           "breaking to get more data");
       /* ignore this return as it produced no data */
       ret = old_ret;
-        goto done;
-      }
-    if (old_ret == GST_FLOW_OK)
-    old_ret = ret;
+      goto done;
     }
+    if (old_ret == GST_FLOW_OK)
+      old_ret = ret;
+  }
 
 done:
   GST_LOG_OBJECT (parse, "chain leaving");
   return ret;
 }
@@ -3311,36 +3356,10 @@
   if (ret != GST_FLOW_OK) {
     parse->priv->cache = NULL;
     return ret;
   }
 
-  if (gst_buffer_get_size (parse->priv->cache) >= size) {
-    *buffer =
-        gst_buffer_copy_region (parse->priv->cache, GST_BUFFER_COPY_ALL, 0,
-        size);
-#ifdef GSTREAMER_LITE
-    if (buffer == NULL)
-      return GST_FLOW_ERROR;
-#endif // GSTREAMER_LITE
-    GST_BUFFER_OFFSET (*buffer) = parse->priv->offset;
-    return GST_FLOW_OK;
-  }
-
-  /* Not possible to get enough data, try a last time with
-   * requesting exactly the size we need */
-  gst_buffer_unref (parse->priv->cache);
-  parse->priv->cache = NULL;
-
-  ret = gst_pad_pull_range (parse->sinkpad, parse->priv->offset, size,
-      &parse->priv->cache);
-
-  if (ret != GST_FLOW_OK) {
-    GST_DEBUG_OBJECT (parse, "pull_range returned %d", ret);
-    *buffer = NULL;
-    return ret;
-  }
-
   if (gst_buffer_get_size (parse->priv->cache) < size) {
     GST_DEBUG_OBJECT (parse, "Returning short buffer at offset %"
         G_GUINT64_FORMAT ": wanted %u bytes, got %" G_GSIZE_FORMAT " bytes",
         parse->priv->offset, size, gst_buffer_get_size (parse->priv->cache));
 
@@ -3471,20 +3490,20 @@
           return GST_FLOW_ERROR;
         } else {
           fsize += 64 * 1024;
           gst_buffer_unref (buffer);
           continue;
-    }
+        }
       } else if (ret != GST_FLOW_OK) {
-    gst_buffer_unref (buffer);
+        gst_buffer_unref (buffer);
         GST_ERROR_OBJECT (parse, "detect() returned %s",
             gst_flow_get_name (ret));
         return ret;
-    }
+      }
 
       /* Else handle this buffer normally */
-  }
+    }
 
     ret = gst_base_parse_handle_buffer (parse, buffer, &skip, &flushed);
     if (ret != GST_FLOW_OK)
       break;
 
@@ -3511,11 +3530,11 @@
     /* otherwise, get some more data
      * note that is checked this does not happen indefinitely */
     if (!skip) {
       GST_LOG_OBJECT (parse, "getting some more data");
       fsize += 64 * 1024;
-  }
+    }
     parse->priv->drain = FALSE;
   }
 
 done:
   return ret;
@@ -3633,17 +3652,23 @@
        * that we should stop now. */
       GST_ELEMENT_FLOW_ERROR (parse, ret);
       push_eos = TRUE;
     }
     if (push_eos) {
+      GstEvent *topush;
       if (parse->priv->estimated_duration <= 0) {
         gst_base_parse_update_duration (parse);
       }
       /* Push pending events, including SEGMENT events */
       gst_base_parse_push_pending_events (parse);
 
-      gst_pad_push_event (parse->srcpad, gst_event_new_eos ());
+      topush = gst_event_new_eos ();
+      GST_DEBUG_OBJECT (parse, "segment_seqnum:%" G_GUINT32_FORMAT,
+          parse->priv->segment_seqnum);
+      if (parse->priv->segment_seqnum != GST_SEQNUM_INVALID)
+        gst_event_set_seqnum (topush, parse->priv->segment_seqnum);
+      gst_pad_push_event (parse->srcpad, topush);
     }
     gst_object_unref (parse);
   }
 }
 
@@ -3673,11 +3698,11 @@
   gst_query_unref (query);
 
   if (!pull_mode)
     goto baseparse_push;
 
-    GST_DEBUG_OBJECT (parse, "trying to activate in pull mode");
+  GST_DEBUG_OBJECT (parse, "trying to activate in pull mode");
   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
     goto baseparse_push;
 
   parse->priv->push_stream_start = TRUE;
   /* In pull mode, upstream is BYTES */
@@ -3741,18 +3766,19 @@
   if (!gst_base_parse_activate (parse, active))
     goto activate_failed;
 
   switch (mode) {
     case GST_PAD_MODE_PULL:
-    if (active) {
+      if (active) {
+        GstEvent *ev = gst_event_new_segment (&parse->segment);
+        parse->priv->segment_seqnum = gst_event_get_seqnum (ev);
         parse->priv->pending_events =
-            g_list_prepend (parse->priv->pending_events,
-            gst_event_new_segment (&parse->segment));
+            g_list_prepend (parse->priv->pending_events, ev);
         result = TRUE;
-    } else {
+      } else {
         result = gst_pad_stop_task (pad);
-    }
+      }
       break;
     default:
       result = TRUE;
       break;
   }
@@ -3839,15 +3865,15 @@
 }
 
 /**
  * gst_base_parse_set_min_frame_size:
  * @parse: #GstBaseParse.
- * @min_size: Minimum size of the data that this base class should give to
- *            subclass.
+ * @min_size: Minimum size in bytes of the data that this base class should
+ *       give to subclass.
  *
  * Subclass can use this function to tell the base class that it needs to
- * give at least #min_size buffers.
+ * be given buffers of at least @min_size bytes.
  */
 void
 gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
 {
   g_return_if_fail (parse != NULL);
@@ -3951,14 +3977,14 @@
  * @passthrough: %TRUE if parser should run in passthrough mode
  *
  * Set if the nature of the format or configuration does not allow (much)
  * parsing, and the parser should operate in passthrough mode (which only
  * applies when operating in push mode). That is, incoming buffers are
- * pushed through unmodified, i.e. no @check_valid_frame or @parse_frame
- * callbacks will be invoked, but @pre_push_frame will still be invoked,
- * so subclass can perform as much or as little is appropriate for
- * passthrough semantics in @pre_push_frame.
+ * pushed through unmodified, i.e. no #GstBaseParseClass.handle_frame()
+ * will be invoked, but #GstBaseParseClass.pre_push_frame() will still be
+ * invoked, so subclass can perform as much or as little is appropriate for
+ * passthrough semantics in #GstBaseParseClass.pre_push_frame().
  */
 void
 gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
 {
   parse->priv->passthrough = passthrough;
@@ -4076,24 +4102,24 @@
 
       /* try upstream first */
       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
       if (!res) {
         /* Fall back on interpreting segment */
-      GST_OBJECT_LOCK (parse);
+        GST_OBJECT_LOCK (parse);
         /* Only reply BYTES if upstream is in BYTES already, otherwise
          * we're not in charge */
         if (format == GST_FORMAT_BYTES
             && parse->priv->upstream_format == GST_FORMAT_BYTES) {
-        dest_value = parse->priv->offset;
-        res = TRUE;
-      } else if (format == parse->segment.format &&
+          dest_value = parse->priv->offset;
+          res = TRUE;
+        } else if (format == parse->segment.format &&
             GST_CLOCK_TIME_IS_VALID (parse->segment.position)) {
           dest_value = gst_segment_to_stream_time (&parse->segment,
               parse->segment.format, parse->segment.position);
-        res = TRUE;
-      }
-      GST_OBJECT_UNLOCK (parse);
+          res = TRUE;
+        }
+        GST_OBJECT_UNLOCK (parse);
         if (!res && parse->priv->upstream_format == GST_FORMAT_BYTES) {
           /* no precise result, upstream no idea either, then best estimate */
           /* priv->offset is updated in both PUSH/PULL modes, *iff* we're
            * in charge of things */
           res = gst_base_parse_convert (parse,
@@ -4189,11 +4215,11 @@
             GST_TIME_FORMAT " max %" GST_TIME_FORMAT, live,
             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
 
         GST_OBJECT_LOCK (parse);
         /* add our latency */
-          min_latency += parse->priv->min_latency;
+        min_latency += parse->priv->min_latency;
         if (max_latency == -1 || parse->priv->max_latency == -1)
           max_latency = -1;
         else
           max_latency += parse->priv->max_latency;
         GST_OBJECT_UNLOCK (parse);
@@ -4590,11 +4616,11 @@
     seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &start_ts);
     seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
         NULL);
   } else {
     if (rate >= 0)
-    start_ts = seeksegment.position;
+      start_ts = seeksegment.position;
     else
       start_ts = start;
 
     if (seeksegment.stop == -1 && seeksegment.duration != -1)
       seeksegment.stop = seeksegment.start + seeksegment.duration;
@@ -4753,11 +4779,11 @@
       g_free (seek);
     }
   }
 
 done:
-    gst_event_unref (event);
+  gst_event_unref (event);
   return res;
 
   /* ERRORS */
 negative_rate:
   {
@@ -4801,11 +4827,11 @@
 
   if (taglist != NULL)
     parse->priv->upstream_tags = gst_tag_list_ref (taglist);
 
   gst_base_parse_check_bitrate_tags (parse);
-  }
+}
 
 #if 0
 static void
 gst_base_parse_set_index (GstElement * element, GstIndex * index)
 {
@@ -4922,11 +4948,11 @@
     parse->priv->prev_pts = parse->priv->next_pts = pts;
 
   if (GST_CLOCK_TIME_IS_VALID (dts) && (parse->priv->prev_dts != dts)) {
     parse->priv->prev_dts = parse->priv->next_dts = dts;
     parse->priv->prev_dts_from_pts = FALSE;
-}
+  }
 }
 
 /**
  * gst_base_parse_merge_tags:
  * @parse: a #GstBaseParse
