<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpoll.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  * Copyright (C) 2004 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   4  * Copyright (C) 2007 Peter Kjellerstedt &lt;pkj@axis.com&gt;
   5  * Copyright (C) 2008 Ole André Vadla Ravnås &lt;ole.andre.ravnas@tandberg.com&gt;
   6  *
   7  * gstpoll.c: File descriptor set
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 /**
  25  * SECTION:gstpoll
  26  * @title: GstPoll
  27  * @short_description: Keep track of file descriptors and make it possible
  28  *                     to wait on them in a cancellable way
  29  *
  30  * A #GstPoll keeps track of file descriptors much like fd_set (used with
  31  * select()) or a struct pollfd array (used with poll()). Once created with
  32  * gst_poll_new(), the set can be used to wait for file descriptors to be
  33  * readable and/or writable. It is possible to make this wait be controlled
  34  * by specifying %TRUE for the @controllable flag when creating the set (or
  35  * later calling gst_poll_set_controllable()).
  36  *
  37  * New file descriptors are added to the set using gst_poll_add_fd(), and
  38  * removed using gst_poll_remove_fd(). Controlling which file descriptors
  39  * should be waited for to become readable and/or writable are done using
<a name="1" id="anc1"></a><span class="line-modified">  40  * gst_poll_fd_ctl_read() and gst_poll_fd_ctl_write().</span>
  41  *
  42  * Use gst_poll_wait() to wait for the file descriptors to actually become
  43  * readable and/or writable, or to timeout if no file descriptor is available
  44  * in time. The wait can be controlled by calling gst_poll_restart() and
  45  * gst_poll_set_flushing().
  46  *
  47  * Once the file descriptor set has been waited for, one can use
  48  * gst_poll_fd_has_closed() to see if the file descriptor has been closed,
  49  * gst_poll_fd_has_error() to see if it has generated an error,
  50  * gst_poll_fd_can_read() to see if it is possible to read from the file
  51  * descriptor, and gst_poll_fd_can_write() to see if it is possible to
  52  * write to it.
  53  *
  54  */
  55 
  56 #ifdef HAVE_CONFIG_H
  57 #include &quot;config.h&quot;
  58 #endif
  59 
  60 #include &quot;gst_private.h&quot;
  61 #include &quot;glib-compat-private.h&quot;
  62 
  63 #include &lt;sys/types.h&gt;
  64 
  65 #ifdef HAVE_UNISTD_H
  66 #include &lt;unistd.h&gt;
  67 #endif
  68 
  69 #include &lt;errno.h&gt;
  70 #include &lt;fcntl.h&gt;
  71 
  72 #include &lt;glib.h&gt;
  73 
  74 #ifdef G_OS_WIN32
  75 #include &lt;winsock2.h&gt;
  76 #else
  77 #define _GNU_SOURCE 1
  78 #ifdef HAVE_SYS_POLL_H
  79 #include &lt;sys/poll.h&gt;
  80 #endif
  81 #ifdef HAVE_POLL_H
  82 #include &lt;poll.h&gt;
  83 #endif
  84 #include &lt;sys/time.h&gt;
  85 #include &lt;sys/socket.h&gt;
  86 #endif
  87 
  88 #ifdef G_OS_WIN32
  89 #  ifndef EWOULDBLOCK
  90 #  define EWOULDBLOCK EAGAIN    /* This is just to placate gcc */
  91 #  endif
  92 #endif /* G_OS_WIN32 */
  93 
  94 /* OS/X needs this because of bad headers */
  95 #include &lt;string.h&gt;
  96 
  97 /* The poll() emulation on OS/X doesn&#39;t handle fds=NULL, nfds=0,
  98  * so we prefer our own poll emulation.
  99  */
 100 #if defined(BROKEN_POLL)
 101 #undef HAVE_POLL
 102 #endif
 103 
 104 #include &quot;gstpoll.h&quot;
 105 
 106 #define GST_CAT_DEFAULT GST_CAT_POLL
 107 
 108 #ifdef G_OS_WIN32
 109 typedef struct _WinsockFd WinsockFd;
 110 
 111 struct _WinsockFd
 112 {
 113   gint fd;
 114   glong event_mask;
 115   WSANETWORKEVENTS events;
 116   glong ignored_event_mask;
 117 };
 118 #endif
 119 
 120 typedef enum
 121 {
 122   GST_POLL_MODE_AUTO,
 123   GST_POLL_MODE_SELECT,
 124   GST_POLL_MODE_PSELECT,
 125   GST_POLL_MODE_POLL,
 126   GST_POLL_MODE_PPOLL,
 127   GST_POLL_MODE_WINDOWS
 128 } GstPollMode;
 129 
 130 struct _GstPoll
 131 {
 132   GstPollMode mode;
 133 
 134   GMutex lock;
 135   /* array of fds, always written to and read from with lock */
 136   GArray *fds;
 137   /* array of active fds, only written to from the waiting thread with the
 138    * lock and read from with the lock or without the lock from the waiting
 139    * thread */
 140   GArray *active_fds;
 141 
 142 #ifndef G_OS_WIN32
 143   GstPollFD control_read_fd;
 144   GstPollFD control_write_fd;
 145 #else
 146   GArray *active_fds_ignored;
 147   GArray *events;
 148   GArray *active_events;
 149 
 150   HANDLE wakeup_event;
 151 #endif
 152 
 153   gboolean controllable;
 154   volatile gint waiting;
 155   volatile gint control_pending;
 156   volatile gint flushing;
 157   gboolean timer;
 158   volatile gint rebuild;
 159 };
 160 
 161 static gboolean gst_poll_fd_ctl_read_unlocked (GstPoll * set, GstPollFD * fd,
 162     gboolean active);
 163 static gboolean gst_poll_add_fd_unlocked (GstPoll * set, GstPollFD * fd);
 164 
 165 #define IS_FLUSHING(s)      (g_atomic_int_get(&amp;(s)-&gt;flushing))
 166 #define SET_FLUSHING(s,val) (g_atomic_int_set(&amp;(s)-&gt;flushing, (val)))
 167 
 168 #define INC_WAITING(s)      (g_atomic_int_add(&amp;(s)-&gt;waiting, 1))
 169 #define DEC_WAITING(s)      (g_atomic_int_add(&amp;(s)-&gt;waiting, -1))
 170 #define GET_WAITING(s)      (g_atomic_int_get(&amp;(s)-&gt;waiting))
 171 
 172 #define TEST_REBUILD(s)     (g_atomic_int_compare_and_exchange(&amp;(s)-&gt;rebuild, 1, 0))
 173 #define MARK_REBUILD(s)     (g_atomic_int_set(&amp;(s)-&gt;rebuild, 1))
 174 
 175 #ifndef G_OS_WIN32
 176 
 177 static gboolean
 178 wake_event (GstPoll * set)
 179 {
 180   ssize_t num_written;
 181   while ((num_written = write (set-&gt;control_write_fd.fd, &quot;W&quot;, 1)) != 1) {
 182     if (num_written == -1 &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) {
 183       g_critical (&quot;%p: failed to wake event: %s&quot;, set, strerror (errno));
 184       return FALSE;
 185     }
 186   }
 187   return TRUE;
 188 }
 189 
 190 static gboolean
 191 release_event (GstPoll * set)
 192 {
 193   gchar buf[1] = { &#39;\0&#39; };
 194   ssize_t num_read;
 195   while ((num_read = read (set-&gt;control_read_fd.fd, buf, 1)) != 1) {
 196     if (num_read == -1 &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) {
 197       g_critical (&quot;%p: failed to release event: %s&quot;, set, strerror (errno));
 198       return FALSE;
 199     }
 200   }
 201   return TRUE;
 202 }
 203 
 204 #else
 205 
 206 static void
 207 format_last_error (gchar * buf, size_t buf_len)
 208 {
 209   DWORD flags = FORMAT_MESSAGE_FROM_SYSTEM;
 210   LPCVOID src = NULL;
 211   DWORD lang = 0;
 212   DWORD id;
 213   id = GetLastError ();
 214   FormatMessage (flags, src, id, lang, buf, (DWORD) buf_len, NULL);
 215   SetLastError (id);
 216 }
 217 
 218 static gboolean
 219 wake_event (GstPoll * set)
 220 {
 221   SetLastError (0);
 222   errno = 0;
 223   if (!SetEvent (set-&gt;wakeup_event)) {
 224     gchar msg[1024] = &quot;&lt;unknown&gt;&quot;;
 225     format_last_error (msg, sizeof (msg));
 226     g_critical (&quot;%p: failed to set wakup_event: %s&quot;, set, msg);
 227     errno = EBADF;
 228     return FALSE;
 229   }
 230 
 231   return TRUE;
 232 }
 233 
 234 static gboolean
 235 release_event (GstPoll * set)
 236 {
 237   DWORD status;
 238   SetLastError (0);
 239   errno = 0;
 240 
 241   status = WaitForSingleObject (set-&gt;wakeup_event, INFINITE);
 242   if (status) {
 243     const gchar *reason = &quot;unknown&quot;;
 244     gchar msg[1024] = &quot;&lt;unknown&gt;&quot;;
 245     switch (status) {
 246       case WAIT_ABANDONED:
 247         reason = &quot;WAIT_ABANDONED&quot;;
 248         break;
 249       case WAIT_TIMEOUT:
 250         reason = &quot;WAIT_TIMEOUT&quot;;
 251         break;
 252       case WAIT_FAILED:
 253         format_last_error (msg, sizeof (msg));
 254         reason = msg;
 255         break;
 256       default:
 257         reason = &quot;other&quot;;
 258         break;
 259     }
 260     g_critical (&quot;%p: failed to block on wakup_event: %s&quot;, set, reason);
 261     errno = EBADF;
 262     return FALSE;
 263   }
 264 
 265   if (!ResetEvent (set-&gt;wakeup_event)) {
 266     gchar msg[1024] = &quot;&lt;unknown&gt;&quot;;
 267     format_last_error (msg, sizeof (msg));
 268     g_critical (&quot;%p: failed to reset wakup_event: %s&quot;, set, msg);
 269     errno = EBADF;
 270     return FALSE;
 271   }
 272 
 273   return TRUE;
 274 }
 275 
 276 #endif
 277 
 278 /* the poll/select call is also performed on a control socket, that way
 279  * we can send special commands to control it */
 280 static inline gboolean
 281 raise_wakeup (GstPoll * set)
 282 {
 283   gboolean result = TRUE;
 284 
 285   /* makes testing control_pending and WAKE_EVENT() atomic. */
 286   g_mutex_lock (&amp;set-&gt;lock);
 287 
 288   if (set-&gt;control_pending == 0) {
 289     /* raise when nothing pending */
 290     GST_LOG (&quot;%p: raise&quot;, set);
 291     result = wake_event (set);
 292   }
 293 
 294   if (result) {
 295     set-&gt;control_pending++;
 296   }
 297 
 298   g_mutex_unlock (&amp;set-&gt;lock);
 299 
 300   return result;
 301 }
 302 
 303 static inline gboolean
 304 release_wakeup (GstPoll * set)
 305 {
 306   gboolean result = FALSE;
 307 
 308   /* makes testing/modifying control_pending and RELEASE_EVENT() atomic. */
 309   g_mutex_lock (&amp;set-&gt;lock);
 310 
 311   if (set-&gt;control_pending &gt; 0) {
 312     /* release, only if this was the last pending. */
 313     if (set-&gt;control_pending == 1) {
<a name="2" id="anc2"></a><span class="line-modified"> 314     GST_LOG (&quot;%p: release&quot;, set);</span>
 315       result = release_event (set);
 316     } else {
 317       result = TRUE;
<a name="3" id="anc3"></a><span class="line-modified"> 318   }</span>
 319 
 320     if (result) {
 321       set-&gt;control_pending--;
 322     }
 323   } else {
 324     errno = EWOULDBLOCK;
 325   }
 326 
 327   g_mutex_unlock (&amp;set-&gt;lock);
 328 
 329   return result;
 330 }
 331 
 332 static inline gint
 333 release_all_wakeup (GstPoll * set)
 334 {
 335   gint old;
 336 
 337   /* makes testing control_pending and RELEASE_EVENT() atomic. */
 338   g_mutex_lock (&amp;set-&gt;lock);
 339 
 340   if ((old = set-&gt;control_pending) &gt; 0) {
 341     GST_LOG (&quot;%p: releasing %d&quot;, set, old);
 342     if (release_event (set)) {
 343       set-&gt;control_pending = 0;
 344     } else {
 345       old = 0;
 346     }
 347   }
 348 
 349   g_mutex_unlock (&amp;set-&gt;lock);
 350 
 351   return old;
 352 }
 353 
 354 static gint
 355 find_index (GArray * array, GstPollFD * fd)
 356 {
 357 #ifndef G_OS_WIN32
 358   struct pollfd *ifd;
 359 #else
 360   WinsockFd *ifd;
 361 #endif
 362   guint i;
 363 
 364   /* start by assuming the index found in the fd is still valid */
 365   if (fd-&gt;idx &gt;= 0 &amp;&amp; fd-&gt;idx &lt; array-&gt;len) {
 366 #ifndef G_OS_WIN32
 367     ifd = &amp;g_array_index (array, struct pollfd, fd-&gt;idx);
 368 #else
 369     ifd = &amp;g_array_index (array, WinsockFd, fd-&gt;idx);
 370 #endif
 371 
 372     if (ifd-&gt;fd == fd-&gt;fd) {
 373       return fd-&gt;idx;
 374     }
 375   }
 376 
 377   /* the pollfd array has changed and we need to lookup the fd again */
 378   for (i = 0; i &lt; array-&gt;len; i++) {
 379 #ifndef G_OS_WIN32
 380     ifd = &amp;g_array_index (array, struct pollfd, i);
 381 #else
 382     ifd = &amp;g_array_index (array, WinsockFd, i);
 383 #endif
 384 
 385     if (ifd-&gt;fd == fd-&gt;fd) {
 386       fd-&gt;idx = (gint) i;
 387       return fd-&gt;idx;
 388     }
 389   }
 390 
 391   fd-&gt;idx = -1;
 392   return fd-&gt;idx;
 393 }
 394 
 395 #if !defined(HAVE_PPOLL) &amp;&amp; defined(HAVE_POLL)
 396 /* check if all file descriptors will fit in an fd_set */
 397 static gboolean
 398 selectable_fds (GstPoll * set)
 399 {
 400   guint i;
 401 
 402   g_mutex_lock (&amp;set-&gt;lock);
 403   for (i = 0; i &lt; set-&gt;fds-&gt;len; i++) {
 404     struct pollfd *pfd = &amp;g_array_index (set-&gt;fds, struct pollfd, i);
 405 
 406     if (pfd-&gt;fd &gt;= FD_SETSIZE)
 407       goto too_many;
 408   }
 409   g_mutex_unlock (&amp;set-&gt;lock);
 410 
 411   return TRUE;
 412 
 413 too_many:
 414   {
 415     g_mutex_unlock (&amp;set-&gt;lock);
 416     return FALSE;
 417   }
 418 }
 419 
 420 /* check if the timeout will convert to a timeout value used for poll()
 421  * without a loss of precision
 422  */
 423 static gboolean
 424 pollable_timeout (GstClockTime timeout)
 425 {
 426   if (timeout == GST_CLOCK_TIME_NONE)
 427     return TRUE;
 428 
 429   /* not a nice multiple of milliseconds */
 430   if (timeout % 1000000)
 431     return FALSE;
 432 
 433   return TRUE;
 434 }
 435 #endif
 436 
 437 static GstPollMode
 438 choose_mode (GstPoll * set, GstClockTime timeout)
 439 {
 440   GstPollMode mode;
 441 
 442   if (set-&gt;mode == GST_POLL_MODE_AUTO) {
 443 #ifdef HAVE_PPOLL
 444     mode = GST_POLL_MODE_PPOLL;
 445 #elif defined(HAVE_POLL)
 446     if (!selectable_fds (set) || pollable_timeout (timeout)) {
 447       mode = GST_POLL_MODE_POLL;
 448     } else {
 449 #ifdef HAVE_PSELECT
 450       mode = GST_POLL_MODE_PSELECT;
 451 #else
 452       mode = GST_POLL_MODE_SELECT;
 453 #endif
 454     }
 455 #elif defined(HAVE_PSELECT)
 456     mode = GST_POLL_MODE_PSELECT;
 457 #else
 458     mode = GST_POLL_MODE_SELECT;
 459 #endif
 460   } else {
 461     mode = set-&gt;mode;
 462   }
 463   return mode;
 464 }
 465 
 466 #ifndef G_OS_WIN32
 467 static gint
 468 pollfd_to_fd_set (GstPoll * set, fd_set * readfds, fd_set * writefds,
 469     fd_set * errorfds)
 470 {
 471   gint max_fd = -1;
 472   guint i;
 473 
 474   FD_ZERO (readfds);
 475   FD_ZERO (writefds);
 476   FD_ZERO (errorfds);
 477 
 478   g_mutex_lock (&amp;set-&gt;lock);
 479 
 480   for (i = 0; i &lt; set-&gt;active_fds-&gt;len; i++) {
 481     struct pollfd *pfd = &amp;g_array_index (set-&gt;fds, struct pollfd, i);
 482 
 483     if (pfd-&gt;fd &lt; FD_SETSIZE) {
 484       if (pfd-&gt;events &amp; POLLIN)
 485         FD_SET (pfd-&gt;fd, readfds);
 486       if (pfd-&gt;events &amp; POLLOUT)
 487         FD_SET (pfd-&gt;fd, writefds);
 488       if (pfd-&gt;events)
 489         FD_SET (pfd-&gt;fd, errorfds);
 490       if (pfd-&gt;fd &gt; max_fd &amp;&amp; (pfd-&gt;events &amp; (POLLIN | POLLOUT)))
 491         max_fd = pfd-&gt;fd;
 492     }
 493   }
 494 
 495   g_mutex_unlock (&amp;set-&gt;lock);
 496 
 497   return max_fd;
 498 }
 499 
 500 static void
 501 fd_set_to_pollfd (GstPoll * set, fd_set * readfds, fd_set * writefds,
 502     fd_set * errorfds)
 503 {
 504   guint i;
 505 
 506   g_mutex_lock (&amp;set-&gt;lock);
 507 
 508   for (i = 0; i &lt; set-&gt;active_fds-&gt;len; i++) {
 509     struct pollfd *pfd = &amp;g_array_index (set-&gt;active_fds, struct pollfd, i);
 510 
 511     if (pfd-&gt;fd &lt; FD_SETSIZE) {
 512       pfd-&gt;revents = 0;
 513       if (FD_ISSET (pfd-&gt;fd, readfds))
 514         pfd-&gt;revents |= POLLIN;
 515       if (FD_ISSET (pfd-&gt;fd, writefds))
 516         pfd-&gt;revents |= POLLOUT;
 517       if (FD_ISSET (pfd-&gt;fd, errorfds))
 518         pfd-&gt;revents |= POLLERR;
 519     }
 520   }
 521 
 522   g_mutex_unlock (&amp;set-&gt;lock);
 523 }
 524 #else /* G_OS_WIN32 */
 525 /*
 526  * Translate errors thrown by the Winsock API used by GstPoll:
 527  *   WSAEventSelect, WSAWaitForMultipleEvents and WSAEnumNetworkEvents
 528  */
 529 static gint
 530 gst_poll_winsock_error_to_errno (DWORD last_error)
 531 {
 532   switch (last_error) {
 533     case WSA_INVALID_HANDLE:
 534     case WSAEINVAL:
 535     case WSAENOTSOCK:
 536       return EBADF;
 537 
 538     case WSA_NOT_ENOUGH_MEMORY:
 539       return ENOMEM;
 540 
 541       /*
 542        * Anything else, including:
 543        *   WSA_INVALID_PARAMETER, WSAEFAULT, WSAEINPROGRESS, WSAENETDOWN,
 544        *   WSANOTINITIALISED
 545        */
 546     default:
 547       return EINVAL;
 548   }
 549 }
 550 
 551 static void
 552 gst_poll_free_winsock_event (GstPoll * set, gint idx)
 553 {
 554   WinsockFd *wfd = &amp;g_array_index (set-&gt;fds, WinsockFd, idx);
 555   HANDLE event = g_array_index (set-&gt;events, HANDLE, idx);
 556 
 557   WSAEventSelect (wfd-&gt;fd, event, 0);
 558   CloseHandle (event);
 559 }
 560 
 561 static void
 562 gst_poll_update_winsock_event_mask (GstPoll * set, gint idx, glong flags,
 563     gboolean active)
 564 {
 565   WinsockFd *wfd;
 566 
 567   wfd = &amp;g_array_index (set-&gt;fds, WinsockFd, idx);
 568 
 569   if (active)
 570     wfd-&gt;event_mask |= flags;
 571   else
 572     wfd-&gt;event_mask &amp;= ~flags;
 573 
 574   /* reset ignored state if the new mask doesn&#39;t overlap at all */
 575   if ((wfd-&gt;ignored_event_mask &amp; wfd-&gt;event_mask) == 0)
 576     wfd-&gt;ignored_event_mask = 0;
 577 }
 578 
 579 static gboolean
 580 gst_poll_prepare_winsock_active_sets (GstPoll * set)
 581 {
 582   guint i;
 583 
 584   g_array_set_size (set-&gt;active_fds, 0);
 585   g_array_set_size (set-&gt;active_fds_ignored, 0);
 586   g_array_set_size (set-&gt;active_events, 0);
 587   g_array_append_val (set-&gt;active_events, set-&gt;wakeup_event);
 588 
 589   for (i = 0; i &lt; set-&gt;fds-&gt;len; i++) {
 590     WinsockFd *wfd = &amp;g_array_index (set-&gt;fds, WinsockFd, i);
 591     HANDLE event = g_array_index (set-&gt;events, HANDLE, i);
 592 
 593     if (wfd-&gt;ignored_event_mask == 0) {
 594       gint ret;
 595 
 596       g_array_append_val (set-&gt;active_fds, *wfd);
 597       g_array_append_val (set-&gt;active_events, event);
 598 
 599       ret = WSAEventSelect (wfd-&gt;fd, event, wfd-&gt;event_mask);
 600       if (G_UNLIKELY (ret != 0)) {
 601         errno = gst_poll_winsock_error_to_errno (WSAGetLastError ());
 602         return FALSE;
 603       }
 604     } else {
 605       g_array_append_val (set-&gt;active_fds_ignored, wfd);
 606     }
 607   }
 608 
 609   return TRUE;
 610 }
 611 
 612 static gint
 613 gst_poll_collect_winsock_events (GstPoll * set)
 614 {
 615   gint res, i;
 616 
 617   /*
 618    * We need to check which events are signaled, and call
 619    * WSAEnumNetworkEvents for those that are, which resets
 620    * the event and clears the internal network event records.
 621    */
 622   res = 0;
 623   for (i = 0; i &lt; set-&gt;active_fds-&gt;len; i++) {
 624     WinsockFd *wfd = &amp;g_array_index (set-&gt;active_fds, WinsockFd, i);
 625     HANDLE event = g_array_index (set-&gt;active_events, HANDLE, i + 1);
 626     DWORD wait_ret;
 627 
 628     wait_ret = WaitForSingleObject (event, 0);
 629     if (wait_ret == WAIT_OBJECT_0) {
 630       gint enum_ret = WSAEnumNetworkEvents (wfd-&gt;fd, event, &amp;wfd-&gt;events);
 631 
 632       if (G_UNLIKELY (enum_ret != 0)) {
 633         res = -1;
 634         errno = gst_poll_winsock_error_to_errno (WSAGetLastError ());
 635         break;
 636       }
 637 
 638       res++;
 639     } else {
 640       /* clear any previously stored result */
 641       memset (&amp;wfd-&gt;events, 0, sizeof (wfd-&gt;events));
 642     }
 643   }
 644 
 645   /* If all went well we also need to reset the ignored fds. */
 646   if (res &gt;= 0) {
 647     res += set-&gt;active_fds_ignored-&gt;len;
 648 
 649     for (i = 0; i &lt; set-&gt;active_fds_ignored-&gt;len; i++) {
 650       WinsockFd *wfd = g_array_index (set-&gt;active_fds_ignored, WinsockFd *, i);
 651 
 652       wfd-&gt;ignored_event_mask = 0;
 653     }
 654 
 655     g_array_set_size (set-&gt;active_fds_ignored, 0);
 656   }
 657 
 658   return res;
 659 }
 660 #endif
 661 
 662 /**
 663  * gst_poll_new: (skip)
 664  * @controllable: whether it should be possible to control a wait.
 665  *
 666  * Create a new file descriptor set. If @controllable, it
 667  * is possible to restart or flush a call to gst_poll_wait() with
 668  * gst_poll_restart() and gst_poll_set_flushing() respectively.
 669  *
 670  * Free-function: gst_poll_free
 671  *
 672  * Returns: (transfer full) (nullable): a new #GstPoll, or %NULL in
 673  *     case of an error.  Free with gst_poll_free().
 674  */
 675 GstPoll *
 676 gst_poll_new (gboolean controllable)
 677 {
 678   GstPoll *nset;
 679 
 680   nset = g_slice_new0 (GstPoll);
 681   GST_DEBUG (&quot;%p: new controllable : %d&quot;, nset, controllable);
 682   g_mutex_init (&amp;nset-&gt;lock);
 683 #ifndef G_OS_WIN32
 684   nset-&gt;mode = GST_POLL_MODE_AUTO;
 685   nset-&gt;fds = g_array_new (FALSE, FALSE, sizeof (struct pollfd));
 686   nset-&gt;active_fds = g_array_new (FALSE, FALSE, sizeof (struct pollfd));
 687   nset-&gt;control_read_fd.fd = -1;
 688   nset-&gt;control_write_fd.fd = -1;
 689   {
 690     gint control_sock[2];
 691 
 692     if (socketpair (PF_UNIX, SOCK_STREAM, 0, control_sock) &lt; 0)
 693       goto no_socket_pair;
 694 
 695     nset-&gt;control_read_fd.fd = control_sock[0];
 696     nset-&gt;control_write_fd.fd = control_sock[1];
 697 
 698     gst_poll_add_fd_unlocked (nset, &amp;nset-&gt;control_read_fd);
 699     gst_poll_fd_ctl_read_unlocked (nset, &amp;nset-&gt;control_read_fd, TRUE);
 700   }
 701 #else
 702   nset-&gt;mode = GST_POLL_MODE_WINDOWS;
 703   nset-&gt;fds = g_array_new (FALSE, FALSE, sizeof (WinsockFd));
 704   nset-&gt;active_fds = g_array_new (FALSE, FALSE, sizeof (WinsockFd));
 705   nset-&gt;active_fds_ignored = g_array_new (FALSE, FALSE, sizeof (WinsockFd *));
 706   nset-&gt;events = g_array_new (FALSE, FALSE, sizeof (HANDLE));
 707   nset-&gt;active_events = g_array_new (FALSE, FALSE, sizeof (HANDLE));
 708 
 709   nset-&gt;wakeup_event = CreateEvent (NULL, TRUE, FALSE, NULL);
 710 #endif
 711 
 712   /* ensure (re)build, though already sneakily set in non-windows case */
 713   MARK_REBUILD (nset);
 714 
 715   nset-&gt;controllable = controllable;
 716   nset-&gt;control_pending = 0;
 717 
 718   return nset;
 719 
 720   /* ERRORS */
 721 #ifndef G_OS_WIN32
 722 no_socket_pair:
 723   {
 724     GST_WARNING (&quot;%p: can&#39;t create socket pair !&quot;, nset);
 725     gst_poll_free (nset);
 726     return NULL;
 727   }
 728 #endif
 729 }
 730 
 731 /**
 732  * gst_poll_new_timer: (skip)
 733  *
 734  * Create a new poll object that can be used for scheduling cancellable
 735  * timeouts.
 736  *
 737  * A timeout is performed with gst_poll_wait(). Multiple timeouts can be
 738  * performed from different threads.
 739  *
 740  * Free-function: gst_poll_free
 741  *
 742  * Returns: (transfer full) (nullable): a new #GstPoll, or %NULL in
 743  *     case of an error.  Free with gst_poll_free().
 744  */
 745 GstPoll *
 746 gst_poll_new_timer (void)
 747 {
 748   GstPoll *poll;
 749 
 750   /* make a new controllable poll set */
 751   if (!(poll = gst_poll_new (TRUE)))
 752     goto done;
 753 
 754   /* we are a timer */
 755   poll-&gt;timer = TRUE;
 756 
 757 done:
 758   return poll;
 759 }
 760 
 761 /**
 762  * gst_poll_free:
 763  * @set: (transfer full): a file descriptor set.
 764  *
 765  * Free a file descriptor set.
 766  */
 767 void
 768 gst_poll_free (GstPoll * set)
 769 {
 770   g_return_if_fail (set != NULL);
 771 
 772   GST_DEBUG (&quot;%p: freeing&quot;, set);
 773 
 774 #ifndef G_OS_WIN32
 775   if (set-&gt;control_write_fd.fd &gt;= 0)
 776     close (set-&gt;control_write_fd.fd);
 777   if (set-&gt;control_read_fd.fd &gt;= 0)
 778     close (set-&gt;control_read_fd.fd);
 779 #else
 780   CloseHandle (set-&gt;wakeup_event);
 781 
 782   {
 783     guint i;
 784 
 785     for (i = 0; i &lt; set-&gt;events-&gt;len; i++)
 786       gst_poll_free_winsock_event (set, i);
 787   }
 788 
 789   g_array_free (set-&gt;active_events, TRUE);
 790   g_array_free (set-&gt;events, TRUE);
 791   g_array_free (set-&gt;active_fds_ignored, TRUE);
 792 #endif
 793 
 794   g_array_free (set-&gt;active_fds, TRUE);
 795   g_array_free (set-&gt;fds, TRUE);
 796   g_mutex_clear (&amp;set-&gt;lock);
 797   g_slice_free (GstPoll, set);
 798 }
 799 
 800 /**
 801  * gst_poll_get_read_gpollfd:
 802  * @set: a #GstPoll
 803  * @fd: a #GPollFD
 804  *
 805  * Get a GPollFD for the reading part of the control socket. This is useful when
 806  * integrating with a GSource and GMainLoop.
 807  */
 808 void
 809 gst_poll_get_read_gpollfd (GstPoll * set, GPollFD * fd)
 810 {
 811   g_return_if_fail (set != NULL);
 812   g_return_if_fail (fd != NULL);
 813 
 814 #ifndef G_OS_WIN32
 815   fd-&gt;fd = set-&gt;control_read_fd.fd;
 816 #else
 817 #if GLIB_SIZEOF_VOID_P == 8
 818   fd-&gt;fd = (gint64) set-&gt;wakeup_event;
 819 #else
 820   fd-&gt;fd = (gint) set-&gt;wakeup_event;
 821 #endif
 822 #endif
 823   fd-&gt;events = G_IO_IN | G_IO_HUP | G_IO_ERR;
 824   fd-&gt;revents = 0;
 825 }
 826 
 827 /**
 828  * gst_poll_fd_init:
 829  * @fd: a #GstPollFD
 830  *
 831  * Initializes @fd. Alternatively you can initialize it with
 832  * #GST_POLL_FD_INIT.
 833  */
 834 void
 835 gst_poll_fd_init (GstPollFD * fd)
 836 {
 837   g_return_if_fail (fd != NULL);
 838 
 839   fd-&gt;fd = -1;
 840   fd-&gt;idx = -1;
 841 }
 842 
 843 static gboolean
 844 gst_poll_add_fd_unlocked (GstPoll * set, GstPollFD * fd)
 845 {
 846   gint idx;
 847 
 848   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d)&quot;, set, fd-&gt;fd, fd-&gt;idx);
 849 
 850   idx = find_index (set-&gt;fds, fd);
 851   if (idx &lt; 0) {
 852 #ifndef G_OS_WIN32
 853     struct pollfd nfd;
 854 
 855     nfd.fd = fd-&gt;fd;
 856     nfd.events = POLLERR | POLLNVAL | POLLHUP;
 857     nfd.revents = 0;
 858 
 859     g_array_append_val (set-&gt;fds, nfd);
 860 
 861     fd-&gt;idx = set-&gt;fds-&gt;len - 1;
 862 #else
 863     WinsockFd wfd;
 864     HANDLE event;
 865 
 866     wfd.fd = fd-&gt;fd;
 867     wfd.event_mask = FD_CLOSE;
 868     memset (&amp;wfd.events, 0, sizeof (wfd.events));
 869     wfd.ignored_event_mask = 0;
 870     event = WSACreateEvent ();
 871 
 872     g_array_append_val (set-&gt;fds, wfd);
 873     g_array_append_val (set-&gt;events, event);
 874 
 875     fd-&gt;idx = set-&gt;fds-&gt;len - 1;
 876 #endif
 877     MARK_REBUILD (set);
 878   } else {
 879     GST_WARNING (&quot;%p: fd already added !&quot;, set);
 880   }
 881 
 882   return TRUE;
 883 }
 884 
 885 /**
 886  * gst_poll_add_fd:
 887  * @set: a file descriptor set.
 888  * @fd: a file descriptor.
 889  *
 890  * Add a file descriptor to the file descriptor set.
 891  *
 892  * Returns: %TRUE if the file descriptor was successfully added to the set.
 893  */
 894 gboolean
 895 gst_poll_add_fd (GstPoll * set, GstPollFD * fd)
 896 {
 897   gboolean ret;
 898 
 899   g_return_val_if_fail (set != NULL, FALSE);
 900   g_return_val_if_fail (fd != NULL, FALSE);
 901   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
 902 
 903   g_mutex_lock (&amp;set-&gt;lock);
 904 
 905   ret = gst_poll_add_fd_unlocked (set, fd);
 906 
 907   g_mutex_unlock (&amp;set-&gt;lock);
 908 
 909   return ret;
 910 }
 911 
 912 /**
 913  * gst_poll_remove_fd:
 914  * @set: a file descriptor set.
 915  * @fd: a file descriptor.
 916  *
 917  * Remove a file descriptor from the file descriptor set.
 918  *
 919  * Returns: %TRUE if the file descriptor was successfully removed from the set.
 920  */
 921 gboolean
 922 gst_poll_remove_fd (GstPoll * set, GstPollFD * fd)
 923 {
 924   gint idx;
 925 
 926   g_return_val_if_fail (set != NULL, FALSE);
 927   g_return_val_if_fail (fd != NULL, FALSE);
 928   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
 929 
 930 
 931   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d)&quot;, set, fd-&gt;fd, fd-&gt;idx);
 932 
 933   g_mutex_lock (&amp;set-&gt;lock);
 934 
 935   /* get the index, -1 is an fd that is not added */
 936   idx = find_index (set-&gt;fds, fd);
 937   if (idx &gt;= 0) {
 938 #ifdef G_OS_WIN32
 939     gst_poll_free_winsock_event (set, idx);
 940     g_array_remove_index_fast (set-&gt;events, idx);
 941 #endif
 942 
 943     /* remove the fd at index, we use _remove_index_fast, which copies the last
 944      * element of the array to the freed index */
 945     g_array_remove_index_fast (set-&gt;fds, idx);
 946 
 947     /* mark fd as removed by setting the index to -1 */
 948     fd-&gt;idx = -1;
 949     MARK_REBUILD (set);
 950   } else {
 951     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
 952   }
 953 
 954   g_mutex_unlock (&amp;set-&gt;lock);
 955 
 956   return idx &gt;= 0;
 957 }
 958 
 959 /**
 960  * gst_poll_fd_ctl_write:
 961  * @set: a file descriptor set.
 962  * @fd: a file descriptor.
 963  * @active: a new status.
 964  *
 965  * Control whether the descriptor @fd in @set will be monitored for
 966  * writability.
 967  *
 968  * Returns: %TRUE if the descriptor was successfully updated.
 969  */
 970 gboolean
 971 gst_poll_fd_ctl_write (GstPoll * set, GstPollFD * fd, gboolean active)
 972 {
 973   gint idx;
 974 
 975   g_return_val_if_fail (set != NULL, FALSE);
 976   g_return_val_if_fail (fd != NULL, FALSE);
 977   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
 978 
 979   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d), active : %d&quot;, set,
 980       fd-&gt;fd, fd-&gt;idx, active);
 981 
 982   g_mutex_lock (&amp;set-&gt;lock);
 983 
 984   idx = find_index (set-&gt;fds, fd);
 985   if (idx &gt;= 0) {
 986 #ifndef G_OS_WIN32
 987     struct pollfd *pfd = &amp;g_array_index (set-&gt;fds, struct pollfd, idx);
 988 
 989     if (active)
 990       pfd-&gt;events |= POLLOUT;
 991     else
 992       pfd-&gt;events &amp;= ~POLLOUT;
 993 
 994     GST_LOG (&quot;%p: pfd-&gt;events now %d (POLLOUT:%d)&quot;, set, pfd-&gt;events, POLLOUT);
 995 #else
 996     gst_poll_update_winsock_event_mask (set, idx, FD_WRITE | FD_CONNECT,
 997         active);
 998 #endif
 999     MARK_REBUILD (set);
1000   } else {
1001     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1002   }
1003 
1004   g_mutex_unlock (&amp;set-&gt;lock);
1005 
1006   return idx &gt;= 0;
1007 }
1008 
1009 static gboolean
1010 gst_poll_fd_ctl_read_unlocked (GstPoll * set, GstPollFD * fd, gboolean active)
1011 {
1012   gint idx;
1013 
1014   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d), active : %d&quot;, set,
1015       fd-&gt;fd, fd-&gt;idx, active);
1016 
1017   idx = find_index (set-&gt;fds, fd);
1018 
1019   if (idx &gt;= 0) {
1020 #ifndef G_OS_WIN32
1021     struct pollfd *pfd = &amp;g_array_index (set-&gt;fds, struct pollfd, idx);
1022 
1023     if (active)
<a name="4" id="anc4"></a><span class="line-modified">1024       pfd-&gt;events |= (POLLIN | POLLPRI);</span>
1025     else
<a name="5" id="anc5"></a><span class="line-modified">1026       pfd-&gt;events &amp;= ~(POLLIN | POLLPRI);</span>
1027 #else
1028     gst_poll_update_winsock_event_mask (set, idx, FD_READ | FD_ACCEPT, active);
1029 #endif
1030     MARK_REBUILD (set);
1031   } else {
1032     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1033   }
1034 
1035   return idx &gt;= 0;
1036 }
1037 
1038 /**
1039  * gst_poll_fd_ctl_read:
1040  * @set: a file descriptor set.
1041  * @fd: a file descriptor.
1042  * @active: a new status.
1043  *
1044  * Control whether the descriptor @fd in @set will be monitored for
1045  * readability.
1046  *
1047  * Returns: %TRUE if the descriptor was successfully updated.
1048  */
1049 gboolean
1050 gst_poll_fd_ctl_read (GstPoll * set, GstPollFD * fd, gboolean active)
1051 {
1052   gboolean ret;
1053 
1054   g_return_val_if_fail (set != NULL, FALSE);
1055   g_return_val_if_fail (fd != NULL, FALSE);
1056   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
1057 
1058   g_mutex_lock (&amp;set-&gt;lock);
1059 
1060   ret = gst_poll_fd_ctl_read_unlocked (set, fd, active);
1061 
1062   g_mutex_unlock (&amp;set-&gt;lock);
1063 
1064   return ret;
1065 }
1066 
<a name="6" id="anc6"></a>




















































1067 /**
1068  * gst_poll_fd_ignored:
1069  * @set: a file descriptor set.
1070  * @fd: a file descriptor.
1071  *
1072  * Mark @fd as ignored so that the next call to gst_poll_wait() will yield
1073  * the same result for @fd as last time. This function must be called if no
1074  * operation (read/write/recv/send/etc.) will be performed on @fd before
1075  * the next call to gst_poll_wait().
1076  *
1077  * The reason why this is needed is because the underlying implementation
1078  * might not allow querying the fd more than once between calls to one of
1079  * the re-enabling operations.
1080  */
1081 void
1082 gst_poll_fd_ignored (GstPoll * set, GstPollFD * fd)
1083 {
1084 #ifdef G_OS_WIN32
1085   gint idx;
1086 
1087   g_return_if_fail (set != NULL);
1088   g_return_if_fail (fd != NULL);
1089   g_return_if_fail (fd-&gt;fd &gt;= 0);
1090 
1091   g_mutex_lock (&amp;set-&gt;lock);
1092 
1093   idx = find_index (set-&gt;fds, fd);
1094   if (idx &gt;= 0) {
1095     WinsockFd *wfd = &amp;g_array_index (set-&gt;fds, WinsockFd, idx);
1096 
1097     wfd-&gt;ignored_event_mask = wfd-&gt;event_mask &amp; (FD_READ | FD_WRITE);
1098     MARK_REBUILD (set);
1099   }
1100 
1101   g_mutex_unlock (&amp;set-&gt;lock);
1102 #endif
1103 }
1104 
1105 /**
1106  * gst_poll_fd_has_closed:
1107  * @set: a file descriptor set.
1108  * @fd: a file descriptor.
1109  *
1110  * Check if @fd in @set has closed the connection.
1111  *
1112  * Returns: %TRUE if the connection was closed.
1113  */
1114 gboolean
1115 gst_poll_fd_has_closed (const GstPoll * set, GstPollFD * fd)
1116 {
1117   gboolean res = FALSE;
1118   gint idx;
1119 
1120   g_return_val_if_fail (set != NULL, FALSE);
1121   g_return_val_if_fail (fd != NULL, FALSE);
1122   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
1123 
1124   g_mutex_lock (&amp;((GstPoll *) set)-&gt;lock);
1125 
1126   idx = find_index (set-&gt;active_fds, fd);
1127   if (idx &gt;= 0) {
1128 #ifndef G_OS_WIN32
1129     struct pollfd *pfd = &amp;g_array_index (set-&gt;active_fds, struct pollfd, idx);
1130 
1131     res = (pfd-&gt;revents &amp; POLLHUP) != 0;
1132 #else
1133     WinsockFd *wfd = &amp;g_array_index (set-&gt;active_fds, WinsockFd, idx);
1134 
1135     res = (wfd-&gt;events.lNetworkEvents &amp; FD_CLOSE) != 0;
1136 #endif
1137   } else {
1138     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1139   }
1140   g_mutex_unlock (&amp;((GstPoll *) set)-&gt;lock);
1141 
1142   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d) %d&quot;, set, fd-&gt;fd, fd-&gt;idx, res);
1143 
1144   return res;
1145 }
1146 
1147 /**
1148  * gst_poll_fd_has_error:
1149  * @set: a file descriptor set.
1150  * @fd: a file descriptor.
1151  *
1152  * Check if @fd in @set has an error.
1153  *
1154  * Returns: %TRUE if the descriptor has an error.
1155  */
1156 gboolean
1157 gst_poll_fd_has_error (const GstPoll * set, GstPollFD * fd)
1158 {
1159   gboolean res = FALSE;
1160   gint idx;
1161 
1162   g_return_val_if_fail (set != NULL, FALSE);
1163   g_return_val_if_fail (fd != NULL, FALSE);
1164   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
1165 
1166   g_mutex_lock (&amp;((GstPoll *) set)-&gt;lock);
1167 
1168   idx = find_index (set-&gt;active_fds, fd);
1169   if (idx &gt;= 0) {
1170 #ifndef G_OS_WIN32
1171     struct pollfd *pfd = &amp;g_array_index (set-&gt;active_fds, struct pollfd, idx);
1172 
1173     res = (pfd-&gt;revents &amp; (POLLERR | POLLNVAL)) != 0;
1174 #else
1175     WinsockFd *wfd = &amp;g_array_index (set-&gt;active_fds, WinsockFd, idx);
1176 
1177     res = (wfd-&gt;events.iErrorCode[FD_CLOSE_BIT] != 0) ||
1178         (wfd-&gt;events.iErrorCode[FD_READ_BIT] != 0) ||
1179         (wfd-&gt;events.iErrorCode[FD_WRITE_BIT] != 0) ||
1180         (wfd-&gt;events.iErrorCode[FD_ACCEPT_BIT] != 0) ||
1181         (wfd-&gt;events.iErrorCode[FD_CONNECT_BIT] != 0);
1182 #endif
1183   } else {
1184     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1185   }
1186   g_mutex_unlock (&amp;((GstPoll *) set)-&gt;lock);
1187 
1188   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d) %d&quot;, set, fd-&gt;fd, fd-&gt;idx, res);
1189 
1190   return res;
1191 }
1192 
1193 static gboolean
1194 gst_poll_fd_can_read_unlocked (const GstPoll * set, GstPollFD * fd)
1195 {
1196   gboolean res = FALSE;
1197   gint idx;
1198 
1199   idx = find_index (set-&gt;active_fds, fd);
1200   if (idx &gt;= 0) {
1201 #ifndef G_OS_WIN32
1202     struct pollfd *pfd = &amp;g_array_index (set-&gt;active_fds, struct pollfd, idx);
1203 
<a name="7" id="anc7"></a><span class="line-modified">1204     res = (pfd-&gt;revents &amp; (POLLIN | POLLPRI)) != 0;</span>
1205 #else
1206     WinsockFd *wfd = &amp;g_array_index (set-&gt;active_fds, WinsockFd, idx);
1207 
1208     res = (wfd-&gt;events.lNetworkEvents &amp; (FD_READ | FD_ACCEPT)) != 0;
1209 #endif
1210   } else {
1211     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1212   }
1213   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d) %d&quot;, set, fd-&gt;fd, fd-&gt;idx, res);
1214 
1215   return res;
1216 }
1217 
1218 /**
1219  * gst_poll_fd_can_read:
1220  * @set: a file descriptor set.
1221  * @fd: a file descriptor.
1222  *
1223  * Check if @fd in @set has data to be read.
1224  *
1225  * Returns: %TRUE if the descriptor has data to be read.
1226  */
1227 gboolean
1228 gst_poll_fd_can_read (const GstPoll * set, GstPollFD * fd)
1229 {
1230   gboolean res = FALSE;
1231 
1232   g_return_val_if_fail (set != NULL, FALSE);
1233   g_return_val_if_fail (fd != NULL, FALSE);
1234   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
1235 
1236   g_mutex_lock (&amp;((GstPoll *) set)-&gt;lock);
1237 
1238   res = gst_poll_fd_can_read_unlocked (set, fd);
1239 
1240   g_mutex_unlock (&amp;((GstPoll *) set)-&gt;lock);
1241 
1242   return res;
1243 }
1244 
1245 /**
1246  * gst_poll_fd_can_write:
1247  * @set: a file descriptor set.
1248  * @fd: a file descriptor.
1249  *
1250  * Check if @fd in @set can be used for writing.
1251  *
1252  * Returns: %TRUE if the descriptor can be used for writing.
1253  */
1254 gboolean
1255 gst_poll_fd_can_write (const GstPoll * set, GstPollFD * fd)
1256 {
1257   gboolean res = FALSE;
1258   gint idx;
1259 
1260   g_return_val_if_fail (set != NULL, FALSE);
1261   g_return_val_if_fail (fd != NULL, FALSE);
1262   g_return_val_if_fail (fd-&gt;fd &gt;= 0, FALSE);
1263 
1264   g_mutex_lock (&amp;((GstPoll *) set)-&gt;lock);
1265 
1266   idx = find_index (set-&gt;active_fds, fd);
1267   if (idx &gt;= 0) {
1268 #ifndef G_OS_WIN32
1269     struct pollfd *pfd = &amp;g_array_index (set-&gt;active_fds, struct pollfd, idx);
1270 
1271     res = (pfd-&gt;revents &amp; POLLOUT) != 0;
1272 #else
1273     WinsockFd *wfd = &amp;g_array_index (set-&gt;active_fds, WinsockFd, idx);
1274 
1275     res = (wfd-&gt;events.lNetworkEvents &amp; FD_WRITE) != 0;
1276 #endif
1277   } else {
1278     GST_WARNING (&quot;%p: couldn&#39;t find fd !&quot;, set);
1279   }
1280   g_mutex_unlock (&amp;((GstPoll *) set)-&gt;lock);
1281 
1282   GST_DEBUG (&quot;%p: fd (fd:%d, idx:%d) %d&quot;, set, fd-&gt;fd, fd-&gt;idx, res);
1283 
1284   return res;
1285 }
1286 
<a name="8" id="anc8"></a>











































1287 /**
1288  * gst_poll_wait:
1289  * @set: a #GstPoll.
1290  * @timeout: a timeout in nanoseconds.
1291  *
1292  * Wait for activity on the file descriptors in @set. This function waits up to
1293  * the specified @timeout.  A timeout of #GST_CLOCK_TIME_NONE waits forever.
1294  *
1295  * For #GstPoll objects created with gst_poll_new(), this function can only be
1296  * called from a single thread at a time.  If called from multiple threads,
1297  * -1 will be returned with errno set to EPERM.
1298  *
1299  * This is not true for timer #GstPoll objects created with
1300  * gst_poll_new_timer(), where it is allowed to have multiple threads waiting
1301  * simultaneously.
1302  *
1303  * Returns: The number of #GstPollFD in @set that have activity or 0 when no
1304  * activity was detected after @timeout. If an error occurs, -1 is returned
1305  * and errno is set.
1306  */
1307 gint
1308 gst_poll_wait (GstPoll * set, GstClockTime timeout)
1309 {
1310   gboolean restarting;
1311   gboolean is_timer;
1312   int res;
1313   gint old_waiting;
1314 
1315   g_return_val_if_fail (set != NULL, -1);
1316 
1317   GST_DEBUG (&quot;%p: timeout :%&quot; GST_TIME_FORMAT, set, GST_TIME_ARGS (timeout));
1318 
1319   is_timer = set-&gt;timer;
1320 
1321   /* add one more waiter */
1322   old_waiting = INC_WAITING (set);
1323 
1324   /* we cannot wait from multiple threads unless we are a timer */
1325   if (G_UNLIKELY (old_waiting &gt; 0 &amp;&amp; !is_timer))
1326     goto already_waiting;
1327 
1328   /* flushing, exit immediately */
1329   if (G_UNLIKELY (IS_FLUSHING (set)))
1330     goto flushing;
1331 
1332   do {
1333     GstPollMode mode;
1334 
1335     res = -1;
1336     restarting = FALSE;
1337 
1338     mode = choose_mode (set, timeout);
1339 
1340     if (TEST_REBUILD (set)) {
1341       g_mutex_lock (&amp;set-&gt;lock);
1342 #ifndef G_OS_WIN32
1343       g_array_set_size (set-&gt;active_fds, set-&gt;fds-&gt;len);
1344       memcpy (set-&gt;active_fds-&gt;data, set-&gt;fds-&gt;data,
1345           set-&gt;fds-&gt;len * sizeof (struct pollfd));
1346 #else
1347       if (!gst_poll_prepare_winsock_active_sets (set))
1348         goto winsock_error;
1349 #endif
1350       g_mutex_unlock (&amp;set-&gt;lock);
1351     }
1352 
1353     switch (mode) {
1354       case GST_POLL_MODE_AUTO:
1355         g_assert_not_reached ();
1356         break;
1357       case GST_POLL_MODE_PPOLL:
1358       {
1359 #ifdef HAVE_PPOLL
1360         struct timespec ts;
1361         struct timespec *tsptr;
1362 
1363         if (timeout != GST_CLOCK_TIME_NONE) {
1364           GST_TIME_TO_TIMESPEC (timeout, ts);
1365           tsptr = &amp;ts;
1366         } else {
1367           tsptr = NULL;
1368         }
1369 
1370         res =
1371             ppoll ((struct pollfd *) set-&gt;active_fds-&gt;data,
1372             set-&gt;active_fds-&gt;len, tsptr, NULL);
1373 #else
1374         g_assert_not_reached ();
1375         errno = ENOSYS;
1376 #endif
1377         break;
1378       }
1379       case GST_POLL_MODE_POLL:
1380       {
1381 #ifdef HAVE_POLL
1382         gint t;
1383 
1384         if (timeout != GST_CLOCK_TIME_NONE) {
1385           t = GST_TIME_AS_MSECONDS (timeout);
1386         } else {
1387           t = -1;
1388         }
1389 
1390         res =
1391             poll ((struct pollfd *) set-&gt;active_fds-&gt;data,
1392             set-&gt;active_fds-&gt;len, t);
1393 #else
1394         g_assert_not_reached ();
1395         errno = ENOSYS;
1396 #endif
1397         break;
1398       }
1399       case GST_POLL_MODE_PSELECT:
1400 #ifndef HAVE_PSELECT
1401       {
1402         g_assert_not_reached ();
1403         errno = ENOSYS;
1404         break;
1405       }
1406 #endif
1407       case GST_POLL_MODE_SELECT:
1408       {
1409 #ifndef G_OS_WIN32
1410         fd_set readfds;
1411         fd_set writefds;
1412         fd_set errorfds;
1413         gint max_fd;
1414 
1415         max_fd = pollfd_to_fd_set (set, &amp;readfds, &amp;writefds, &amp;errorfds);
1416 
1417         if (mode == GST_POLL_MODE_SELECT) {
1418           struct timeval tv;
1419           struct timeval *tvptr;
1420 
1421           if (timeout != GST_CLOCK_TIME_NONE) {
1422             GST_TIME_TO_TIMEVAL (timeout, tv);
1423             tvptr = &amp;tv;
1424           } else {
1425             tvptr = NULL;
1426           }
1427 
1428           GST_DEBUG (&quot;%p: Calling select&quot;, set);
1429           res = select (max_fd + 1, &amp;readfds, &amp;writefds, &amp;errorfds, tvptr);
1430           GST_DEBUG (&quot;%p: After select, res:%d&quot;, set, res);
1431         } else {
1432 #ifdef HAVE_PSELECT
1433           struct timespec ts;
1434           struct timespec *tsptr;
1435 
1436           if (timeout != GST_CLOCK_TIME_NONE) {
1437             GST_TIME_TO_TIMESPEC (timeout, ts);
1438             tsptr = &amp;ts;
1439           } else {
1440             tsptr = NULL;
1441           }
1442 
1443           GST_DEBUG (&quot;%p: Calling pselect&quot;, set);
1444           res =
1445               pselect (max_fd + 1, &amp;readfds, &amp;writefds, &amp;errorfds, tsptr, NULL);
1446           GST_DEBUG (&quot;%p: After pselect, res:%d&quot;, set, res);
1447 #endif
1448         }
1449 
1450         if (res &gt;= 0) {
1451           fd_set_to_pollfd (set, &amp;readfds, &amp;writefds, &amp;errorfds);
1452         }
1453 #else /* G_OS_WIN32 */
1454         g_assert_not_reached ();
1455         errno = ENOSYS;
1456 #endif
1457         break;
1458       }
1459       case GST_POLL_MODE_WINDOWS:
1460       {
1461 #ifdef G_OS_WIN32
1462         gint ignore_count = set-&gt;active_fds_ignored-&gt;len;
1463         DWORD t, wait_ret;
1464 
1465         if (G_LIKELY (ignore_count == 0)) {
1466           if (timeout != GST_CLOCK_TIME_NONE)
1467             t = GST_TIME_AS_MSECONDS (timeout);
1468           else
1469             t = INFINITE;
1470         } else {
1471           /* already one or more ignored fds, so we quickly sweep the others */
1472           t = 0;
1473         }
1474 
1475         if (set-&gt;active_events-&gt;len != 0) {
1476           wait_ret = WSAWaitForMultipleEvents (set-&gt;active_events-&gt;len,
1477               (HANDLE *) set-&gt;active_events-&gt;data, FALSE, t, FALSE);
1478         } else {
1479           wait_ret = WSA_WAIT_FAILED;
1480           WSASetLastError (WSA_INVALID_PARAMETER);
1481         }
1482 
1483         if (ignore_count == 0 &amp;&amp; wait_ret == WSA_WAIT_TIMEOUT) {
1484           res = 0;
1485         } else if (wait_ret == WSA_WAIT_FAILED) {
1486           res = -1;
1487           errno = gst_poll_winsock_error_to_errno (WSAGetLastError ());
1488         } else {
1489           /* the first entry is the wakeup event */
1490           if (wait_ret - WSA_WAIT_EVENT_0 &gt;= 1) {
1491             res = gst_poll_collect_winsock_events (set);
1492           } else {
1493             res = 1;            /* wakeup event */
1494           }
1495         }
1496 #else
1497         g_assert_not_reached ();
1498         errno = ENOSYS;
1499 #endif
1500         break;
1501       }
1502     }
1503 
1504     if (!is_timer) {
1505       /* Applications needs to clear the control socket themselves for timer
1506        * polls.
1507        * For other polls, we need to clear the control socket. If there was only
1508        * one socket with activity and it was the control socket, we need to
1509        * restart */
1510       if (release_all_wakeup (set) &gt; 0 &amp;&amp; res == 1)
1511         restarting = TRUE;
1512     }
1513 
1514     /* we got woken up and we are flushing, we need to stop */
1515     if (G_UNLIKELY (IS_FLUSHING (set)))
1516       goto flushing;
1517 
1518   } while (G_UNLIKELY (restarting));
1519 
1520   DEC_WAITING (set);
1521 
1522   return res;
1523 
1524   /* ERRORS */
1525 already_waiting:
1526   {
1527     GST_LOG (&quot;%p: we are already waiting&quot;, set);
1528     DEC_WAITING (set);
1529     errno = EPERM;
1530     return -1;
1531   }
1532 flushing:
1533   {
1534     GST_LOG (&quot;%p: we are flushing&quot;, set);
1535     DEC_WAITING (set);
1536     errno = EBUSY;
1537     return -1;
1538   }
1539 #ifdef G_OS_WIN32
1540 winsock_error:
1541   {
1542     GST_LOG (&quot;%p: winsock error&quot;, set);
1543     g_mutex_unlock (&amp;set-&gt;lock);
1544     DEC_WAITING (set);
1545     return -1;
1546   }
1547 #endif
1548 }
1549 
1550 /**
1551  * gst_poll_set_controllable:
1552  * @set: a #GstPoll.
1553  * @controllable: new controllable state.
1554  *
1555  * When @controllable is %TRUE, this function ensures that future calls to
1556  * gst_poll_wait() will be affected by gst_poll_restart() and
1557  * gst_poll_set_flushing().
1558  *
1559  * This function only works for non-timer #GstPoll objects created with
1560  * gst_poll_new().
1561  *
1562  * Returns: %TRUE if the controllability of @set could be updated.
1563  */
1564 gboolean
1565 gst_poll_set_controllable (GstPoll * set, gboolean controllable)
1566 {
1567   g_return_val_if_fail (set != NULL, FALSE);
1568   g_return_val_if_fail (!set-&gt;timer, FALSE);
1569 
1570   GST_LOG (&quot;%p: controllable : %d&quot;, set, controllable);
1571 
1572   set-&gt;controllable = controllable;
1573 
1574   return TRUE;
1575 }
1576 
1577 /**
1578  * gst_poll_restart:
1579  * @set: a #GstPoll.
1580  *
1581  * Restart any gst_poll_wait() that is in progress. This function is typically
1582  * used after adding or removing descriptors to @set.
1583  *
1584  * If @set is not controllable, then this call will have no effect.
1585  *
1586  * This function only works for non-timer #GstPoll objects created with
1587  * gst_poll_new().
1588  */
1589 void
1590 gst_poll_restart (GstPoll * set)
1591 {
1592   g_return_if_fail (set != NULL);
1593   g_return_if_fail (!set-&gt;timer);
1594 
1595   if (set-&gt;controllable &amp;&amp; GET_WAITING (set) &gt; 0) {
1596     /* we are controllable and waiting, wake up the waiter. The socket will be
1597      * cleared by the _wait() thread and the poll will be restarted */
1598     raise_wakeup (set);
1599   }
1600 }
1601 
1602 /**
1603  * gst_poll_set_flushing:
1604  * @set: a #GstPoll.
1605  * @flushing: new flushing state.
1606  *
1607  * When @flushing is %TRUE, this function ensures that current and future calls
1608  * to gst_poll_wait() will return -1, with errno set to EBUSY.
1609  *
1610  * Unsetting the flushing state will restore normal operation of @set.
1611  *
1612  * This function only works for non-timer #GstPoll objects created with
1613  * gst_poll_new().
1614  */
1615 void
1616 gst_poll_set_flushing (GstPoll * set, gboolean flushing)
1617 {
1618   g_return_if_fail (set != NULL);
1619   g_return_if_fail (!set-&gt;timer);
1620 
1621   GST_LOG (&quot;%p: flushing: %d&quot;, set, flushing);
1622 
1623   /* update the new state first */
1624   SET_FLUSHING (set, flushing);
1625 
1626   if (flushing &amp;&amp; set-&gt;controllable &amp;&amp; GET_WAITING (set) &gt; 0) {
1627     /* we are flushing, controllable and waiting, wake up the waiter. When we
1628      * stop the flushing operation we don&#39;t clear the wakeup fd here, this will
1629      * happen in the _wait() thread. */
1630     raise_wakeup (set);
1631   }
1632 }
1633 
1634 /**
1635  * gst_poll_write_control:
1636  * @set: a #GstPoll.
1637  *
1638  * Write a byte to the control socket of the controllable @set.
1639  * This function is mostly useful for timer #GstPoll objects created with
1640  * gst_poll_new_timer().
1641  *
1642  * It will make any current and future gst_poll_wait() function return with
1643  * 1, meaning the control socket is set. After an equal amount of calls to
1644  * gst_poll_read_control() have been performed, calls to gst_poll_wait() will
1645  * block again until their timeout expired.
1646  *
1647  * This function only works for timer #GstPoll objects created with
1648  * gst_poll_new_timer().
1649  *
1650  * Returns: %TRUE on success. %FALSE when when the byte could not be written.
1651  * errno contains the detailed error code but will never be EAGAIN, EINTR or
1652  * EWOULDBLOCK. %FALSE always signals a critical error.
1653  */
1654 gboolean
1655 gst_poll_write_control (GstPoll * set)
1656 {
1657   gboolean res;
1658 
1659   g_return_val_if_fail (set != NULL, FALSE);
1660   g_return_val_if_fail (set-&gt;timer, FALSE);
1661 
1662   res = raise_wakeup (set);
1663 
1664   return res;
1665 }
1666 
1667 /**
1668  * gst_poll_read_control:
1669  * @set: a #GstPoll.
1670  *
1671  * Read a byte from the control socket of the controllable @set.
1672  *
1673  * This function only works for timer #GstPoll objects created with
1674  * gst_poll_new_timer().
1675  *
1676  * Returns: %TRUE on success. %FALSE when when there was no byte to read or
1677  * reading the byte failed. If there was no byte to read, and only then, errno
1678  * will contain EWOULDBLOCK or EAGAIN. For all other values of errno this always signals a
1679  * critical error.
1680  */
1681 gboolean
1682 gst_poll_read_control (GstPoll * set)
1683 {
1684   gboolean res;
1685 
1686   g_return_val_if_fail (set != NULL, FALSE);
1687   g_return_val_if_fail (set-&gt;timer, FALSE);
1688 
1689   res = release_wakeup (set);
1690 
1691   return res;
1692 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>