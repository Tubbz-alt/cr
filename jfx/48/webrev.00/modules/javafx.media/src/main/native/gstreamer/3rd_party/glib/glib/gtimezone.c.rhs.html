<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2010 Codethink Limited</span>
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 /* Prologue {{{1 */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;gtimezone.h&quot;
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gmappedfile.h&quot;
  31 #include &quot;gtestutils.h&quot;
  32 #include &quot;gfileutils.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;ghash.h&quot;
  35 #include &quot;gthread.h&quot;
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;gslice.h&quot;
  38 #include &quot;gdatetime.h&quot;
  39 #include &quot;gdate.h&quot;
  40 
  41 #ifdef G_OS_WIN32
<a name="2" id="anc2"></a><span class="line-added">  42 </span>
  43 #define STRICT
  44 #include &lt;windows.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  45 #include &lt;wchar.h&gt;</span>
  46 #endif
  47 
  48 /**
  49  * SECTION:timezone
  50  * @title: GTimeZone
  51  * @short_description: a structure representing a time zone
  52  * @see_also: #GDateTime
  53  *
  54  * #GTimeZone is a structure that represents a time zone, at no
  55  * particular point in time.  It is refcounted and immutable.
  56  *
<a name="4" id="anc4"></a><span class="line-modified">  57  * Each time zone has an identifier (for example, &#39;Europe/London&#39;) which is</span>
  58  * platform dependent. See g_time_zone_new() for information on the identifier
  59  * formats. The identifier of a time zone can be retrieved using
  60  * g_time_zone_get_identifier().
  61  *
  62  * A time zone contains a number of intervals.  Each interval has
<a name="5" id="anc5"></a><span class="line-modified">  63  * an abbreviation to describe it (for example, &#39;PDT&#39;), an offet to UTC and a</span>
  64  * flag indicating if the daylight savings time is in effect during that
<a name="6" id="anc6"></a><span class="line-modified">  65  * interval.  A time zone always has at least one interval - interval 0. Note</span>
  66  * that interval abbreviations are not the same as time zone identifiers
<a name="7" id="anc7"></a><span class="line-modified">  67  * (apart from &#39;UTC&#39;), and cannot be passed to g_time_zone_new().</span>
  68  *
  69  * Every UTC time is contained within exactly one interval, but a given
  70  * local time may be contained within zero, one or two intervals (due to
  71  * incontinuities associated with daylight savings time).
  72  *
  73  * An interval may refer to a specific period of time (eg: the duration
  74  * of daylight savings time during 2010) or it may refer to many periods
  75  * of time that share the same properties (eg: all periods of daylight
  76  * savings time).  It is also possible (usually for political reasons)
  77  * that some properties (like the abbreviation) change between intervals
  78  * without other properties changing.
  79  *
  80  * #GTimeZone is available since GLib 2.26.
  81  */
  82 
  83 /**
  84  * GTimeZone:
  85  *
  86  * #GTimeZone is an opaque structure whose members cannot be accessed
  87  * directly.
  88  *
  89  * Since: 2.26
  90  **/
  91 
  92 /* IANA zoneinfo file format {{{1 */
  93 
  94 /* unaligned */
  95 typedef struct { gchar bytes[8]; } gint64_be;
  96 typedef struct { gchar bytes[4]; } gint32_be;
  97 typedef struct { gchar bytes[4]; } guint32_be;
  98 
  99 static inline gint64 gint64_from_be (const gint64_be be) {
 100   gint64 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GINT64_FROM_BE (tmp);
 101 }
 102 
 103 static inline gint32 gint32_from_be (const gint32_be be) {
 104   gint32 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GINT32_FROM_BE (tmp);
 105 }
 106 
 107 static inline guint32 guint32_from_be (const guint32_be be) {
 108   guint32 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GUINT32_FROM_BE (tmp);
 109 }
 110 
 111 /* The layout of an IANA timezone file header */
 112 struct tzhead
 113 {
 114   gchar      tzh_magic[4];
 115   gchar      tzh_version;
 116   guchar     tzh_reserved[15];
 117 
 118   guint32_be tzh_ttisgmtcnt;
 119   guint32_be tzh_ttisstdcnt;
 120   guint32_be tzh_leapcnt;
 121   guint32_be tzh_timecnt;
 122   guint32_be tzh_typecnt;
 123   guint32_be tzh_charcnt;
 124 };
 125 
 126 struct ttinfo
 127 {
 128   gint32_be tt_gmtoff;
 129   guint8    tt_isdst;
 130   guint8    tt_abbrind;
 131 };
 132 
 133 /* A Transition Date structure for TZ Rules, an intermediate structure
 134    for parsing MSWindows and Environment-variable time zones. It
 135    Generalizes MSWindows&#39;s SYSTEMTIME struct.
 136  */
 137 typedef struct
 138 {
 139   gint     year;
 140   gint     mon;
 141   gint     mday;
 142   gint     wday;
 143   gint     week;
 144   gint     hour;
 145   gint     min;
 146   gint     sec;
 147 } TimeZoneDate;
 148 
 149 /* POSIX Timezone abbreviations are typically 3 or 4 characters, but
 150    Microsoft uses 32-character names. We&#39;ll use one larger to ensure
 151    we have room for the terminating \0.
 152  */
 153 #define NAME_SIZE 33
 154 
 155 /* A MSWindows-style time zone transition rule. Generalizes the
 156    MSWindows TIME_ZONE_INFORMATION struct. Also used to compose time
 157    zones from tzset-style identifiers.
 158  */
 159 typedef struct
 160 {
 161   gint         start_year;
 162   gint32       std_offset;
 163   gint32       dlt_offset;
 164   TimeZoneDate dlt_start;
 165   TimeZoneDate dlt_end;
 166   gchar std_name[NAME_SIZE];
 167   gchar dlt_name[NAME_SIZE];
 168 } TimeZoneRule;
 169 
 170 /* GTimeZone&#39;s internal representation of a Daylight Savings (Summer)
 171    time interval.
 172  */
 173 typedef struct
 174 {
 175   gint32     gmt_offset;
 176   gboolean   is_dst;
 177   gchar     *abbrev;
 178 } TransitionInfo;
 179 
 180 /* GTimeZone&#39;s representation of a transition time to or from Daylight
 181    Savings (Summer) time and Standard time for the zone. */
 182 typedef struct
 183 {
 184   gint64 time;
 185   gint   info_index;
 186 } Transition;
 187 
 188 /* GTimeZone structure */
 189 struct _GTimeZone
 190 {
 191   gchar   *name;
 192   GArray  *t_info;         /* Array of TransitionInfo */
 193   GArray  *transitions;    /* Array of Transition */
 194   gint     ref_count;
 195 };
 196 
 197 G_LOCK_DEFINE_STATIC (time_zones);
 198 static GHashTable/*&lt;string?, GTimeZone&gt;*/ *time_zones;
 199 
 200 #define MIN_TZYEAR 1916 /* Daylight Savings started in WWI */
 201 #define MAX_TZYEAR 2999 /* And it&#39;s not likely ever to go away, but
 202                            there&#39;s no point in getting carried
 203                            away. */
 204 
 205 /**
 206  * g_time_zone_unref:
 207  * @tz: a #GTimeZone
 208  *
 209  * Decreases the reference count on @tz.
 210  *
 211  * Since: 2.26
 212  **/
 213 void
 214 g_time_zone_unref (GTimeZone *tz)
 215 {
 216   int ref_count;
 217 
 218 again:
 219   ref_count = g_atomic_int_get (&amp;tz-&gt;ref_count);
 220 
 221   g_assert (ref_count &gt; 0);
 222 
 223   if (ref_count == 1)
 224     {
 225       if (tz-&gt;name != NULL)
 226         {
 227           G_LOCK(time_zones);
 228 
 229           /* someone else might have grabbed a ref in the meantime */
 230           if G_UNLIKELY (g_atomic_int_get (&amp;tz-&gt;ref_count) != 1)
 231             {
 232               G_UNLOCK(time_zones);
 233               goto again;
 234             }
 235 
 236           g_hash_table_remove (time_zones, tz-&gt;name);
 237           G_UNLOCK(time_zones);
 238         }
 239 
 240       if (tz-&gt;t_info != NULL)
 241         {
<a name="8" id="anc8"></a><span class="line-modified"> 242           guint idx;</span>
 243           for (idx = 0; idx &lt; tz-&gt;t_info-&gt;len; idx++)
 244             {
 245               TransitionInfo *info = &amp;g_array_index (tz-&gt;t_info, TransitionInfo, idx);
 246               g_free (info-&gt;abbrev);
 247             }
 248           g_array_free (tz-&gt;t_info, TRUE);
 249         }
 250       if (tz-&gt;transitions != NULL)
 251         g_array_free (tz-&gt;transitions, TRUE);
 252       g_free (tz-&gt;name);
 253 
 254       g_slice_free (GTimeZone, tz);
 255     }
 256 
 257   else if G_UNLIKELY (!g_atomic_int_compare_and_exchange (&amp;tz-&gt;ref_count,
 258                                                           ref_count,
 259                                                           ref_count - 1))
 260     goto again;
 261 }
 262 
 263 /**
 264  * g_time_zone_ref:
 265  * @tz: a #GTimeZone
 266  *
 267  * Increases the reference count on @tz.
 268  *
 269  * Returns: a new reference to @tz.
 270  *
 271  * Since: 2.26
 272  **/
 273 GTimeZone *
 274 g_time_zone_ref (GTimeZone *tz)
 275 {
 276   g_assert (tz-&gt;ref_count &gt; 0);
 277 
 278   g_atomic_int_inc (&amp;tz-&gt;ref_count);
 279 
 280   return tz;
 281 }
 282 
 283 /* fake zoneinfo creation (for RFC3339/ISO 8601 timezones) {{{1 */
 284 /*
 285  * parses strings of the form h or hh[[:]mm[[[:]ss]]] where:
 286  *  - h[h] is 0 to 23
 287  *  - mm is 00 to 59
 288  *  - ss is 00 to 59
 289  */
 290 static gboolean
 291 parse_time (const gchar *time_,
 292             gint32      *offset)
 293 {
 294   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 295     return FALSE;
 296 
 297   *offset = 60 * 60 * (*time_++ - &#39;0&#39;);
 298 
 299   if (*time_ == &#39;\0&#39;)
 300     return TRUE;
 301 
 302   if (*time_ != &#39;:&#39;)
 303     {
 304       if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 305         return FALSE;
 306 
 307       *offset *= 10;
 308       *offset += 60 * 60 * (*time_++ - &#39;0&#39;);
 309 
 310       if (*offset &gt; 23 * 60 * 60)
 311         return FALSE;
 312 
 313       if (*time_ == &#39;\0&#39;)
 314         return TRUE;
 315     }
 316 
 317   if (*time_ == &#39;:&#39;)
 318     time_++;
 319 
 320   if (*time_ &lt; &#39;0&#39; || &#39;5&#39; &lt; *time_)
 321     return FALSE;
 322 
 323   *offset += 10 * 60 * (*time_++ - &#39;0&#39;);
 324 
 325   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 326     return FALSE;
 327 
 328   *offset += 60 * (*time_++ - &#39;0&#39;);
 329 
 330   if (*time_ == &#39;\0&#39;)
 331     return TRUE;
 332 
 333   if (*time_ == &#39;:&#39;)
 334     time_++;
 335 
 336   if (*time_ &lt; &#39;0&#39; || &#39;5&#39; &lt; *time_)
 337     return FALSE;
 338 
 339   *offset += 10 * (*time_++ - &#39;0&#39;);
 340 
 341   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 342     return FALSE;
 343 
 344   *offset += *time_++ - &#39;0&#39;;
 345 
 346   return *time_ == &#39;\0&#39;;
 347 }
 348 
 349 static gboolean
 350 parse_constant_offset (const gchar *name,
 351                        gint32      *offset)
 352 {
 353   if (g_strcmp0 (name, &quot;UTC&quot;) == 0)
 354     {
 355       *offset = 0;
 356       return TRUE;
 357     }
 358 
 359   if (*name &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *name)
 360     return parse_time (name, offset);
 361 
 362   switch (*name++)
 363     {
 364     case &#39;Z&#39;:
 365       *offset = 0;
 366       return !*name;
 367 
 368     case &#39;+&#39;:
 369       return parse_time (name, offset);
 370 
 371     case &#39;-&#39;:
 372       if (parse_time (name, offset))
 373         {
 374           *offset = -*offset;
 375           return TRUE;
 376         }
<a name="9" id="anc9"></a><span class="line-added"> 377       else</span>
<span class="line-added"> 378         return FALSE;</span>
 379 
 380     default:
 381       return FALSE;
 382     }
 383 }
 384 
 385 static void
 386 zone_for_constant_offset (GTimeZone *gtz, const gchar *name)
 387 {
 388   gint32 offset;
 389   TransitionInfo info;
 390 
 391   if (name == NULL || !parse_constant_offset (name, &amp;offset))
 392     return;
 393 
 394   info.gmt_offset = offset;
 395   info.is_dst = FALSE;
 396   info.abbrev =  g_strdup (name);
 397 
 398   gtz-&gt;name = g_strdup (name);
 399   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo), 1);
 400   g_array_append_val (gtz-&gt;t_info, info);
 401 
 402   /* Constant offset, no transitions */
 403   gtz-&gt;transitions = NULL;
 404 }
 405 
 406 #ifdef G_OS_UNIX
 407 static GBytes*
 408 zone_info_unix (const gchar  *identifier,
 409                 gchar       **out_identifier)
 410 {
 411   gchar *filename;
 412   GMappedFile *file = NULL;
 413   GBytes *zoneinfo = NULL;
 414   gchar *resolved_identifier = NULL;
 415   const gchar *tzdir;
 416 
 417   tzdir = getenv (&quot;TZDIR&quot;);
 418   if (tzdir == NULL)
 419     tzdir = &quot;/usr/share/zoneinfo&quot;;
 420 
 421   /* identifier can be a relative or absolute path name;
 422      if relative, it is interpreted starting from /usr/share/zoneinfo
 423      while the POSIX standard says it should start with :,
 424      glibc allows both syntaxes, so we should too */
 425   if (identifier != NULL)
 426     {
 427       resolved_identifier = g_strdup (identifier);
 428 
 429       if (*identifier == &#39;:&#39;)
 430         identifier ++;
 431 
 432       if (g_path_is_absolute (identifier))
 433         filename = g_strdup (identifier);
 434       else
 435         filename = g_build_filename (tzdir, identifier, NULL);
 436     }
 437   else
 438     {
 439       gsize prefix_len = 0;
 440       gchar *canonical_path = NULL;
 441       GError *read_link_err = NULL;
 442 
<a name="10" id="anc10"></a><span class="line-modified"> 443       filename = g_strdup (&quot;/etc/localtime&quot;);</span>
 444 
 445       /* Resolve the actual timezone pointed to by /etc/localtime. */
 446       resolved_identifier = g_file_read_link (filename, &amp;read_link_err);
 447       if (resolved_identifier == NULL)
 448         {
 449           gboolean not_a_symlink = g_error_matches (read_link_err,
 450                                                     G_FILE_ERROR,
 451                                                     G_FILE_ERROR_INVAL);
 452           g_clear_error (&amp;read_link_err);
 453 
 454           /* Fallback to the content of /var/db/zoneinfo or /etc/timezone
 455            * if /etc/localtime is not a symlink. /var/db/zoneinfo is
 456            * where &#39;tzsetup&#39; program on FreeBSD and DragonflyBSD stores
 457            * the timezone chosen by the user. /etc/timezone is where user
 458            * choice is expressed on Gentoo OpenRC and others. */
 459           if (not_a_symlink &amp;&amp; (g_file_get_contents (&quot;/var/db/zoneinfo&quot;,
 460                                                      &amp;resolved_identifier,
 461                                                      NULL, NULL) ||
 462                                 g_file_get_contents (&quot;/etc/timezone&quot;,
 463                                                      &amp;resolved_identifier,
 464                                                      NULL, NULL)))
 465             g_strchomp (resolved_identifier);
 466           else
 467             {
 468               /* Error */
 469               g_assert (resolved_identifier == NULL);
 470               goto out;
 471             }
 472         }
 473       else
 474         {
 475           /* Resolve relative path */
 476           canonical_path = g_canonicalize_filename (resolved_identifier, &quot;/etc&quot;);
 477           g_free (resolved_identifier);
 478           resolved_identifier = g_steal_pointer (&amp;canonical_path);
 479         }
 480 
 481       /* Strip the prefix and slashes if possible. */
 482       if (g_str_has_prefix (resolved_identifier, tzdir))
 483         {
 484           prefix_len = strlen (tzdir);
 485           while (*(resolved_identifier + prefix_len) == &#39;/&#39;)
 486             prefix_len++;
 487         }
 488 
 489       if (prefix_len &gt; 0)
 490         memmove (resolved_identifier, resolved_identifier + prefix_len,
 491                  strlen (resolved_identifier) - prefix_len + 1  /* nul terminator */);
 492 
 493       g_free (canonical_path);
 494     }
 495 
 496   file = g_mapped_file_new (filename, FALSE, NULL);
 497   if (file != NULL)
 498     {
 499       zoneinfo = g_bytes_new_with_free_func (g_mapped_file_get_contents (file),
 500                                              g_mapped_file_get_length (file),
 501                                              (GDestroyNotify)g_mapped_file_unref,
 502                                              g_mapped_file_ref (file));
 503       g_mapped_file_unref (file);
 504     }
 505 
 506   g_assert (resolved_identifier != NULL);
 507 
 508 out:
 509   if (out_identifier != NULL)
 510     *out_identifier = g_steal_pointer (&amp;resolved_identifier);
 511 
 512   g_free (resolved_identifier);
 513   g_free (filename);
 514 
 515   return zoneinfo;
 516 }
 517 
 518 static void
 519 init_zone_from_iana_info (GTimeZone *gtz,
 520                           GBytes    *zoneinfo,
 521                           gchar     *identifier  /* (transfer full) */)
 522 {
 523   gsize size;
 524   guint index;
 525   guint32 time_count, type_count;
 526   guint8 *tz_transitions, *tz_type_index, *tz_ttinfo;
 527   guint8 *tz_abbrs;
 528   gsize timesize = sizeof (gint32);
 529   const struct tzhead *header = g_bytes_get_data (zoneinfo, &amp;size);
 530 
 531   g_return_if_fail (size &gt;= sizeof (struct tzhead) &amp;&amp;
 532                     memcmp (header, &quot;TZif&quot;, 4) == 0);
 533 
 534   if (header-&gt;tzh_version == &#39;2&#39;)
 535       {
 536         /* Skip ahead to the newer 64-bit data if it&#39;s available. */
 537         header = (const struct tzhead *)
 538           (((const gchar *) (header + 1)) +
 539            guint32_from_be(header-&gt;tzh_ttisgmtcnt) +
 540            guint32_from_be(header-&gt;tzh_ttisstdcnt) +
 541            8 * guint32_from_be(header-&gt;tzh_leapcnt) +
 542            5 * guint32_from_be(header-&gt;tzh_timecnt) +
 543            6 * guint32_from_be(header-&gt;tzh_typecnt) +
 544            guint32_from_be(header-&gt;tzh_charcnt));
 545         timesize = sizeof (gint64);
 546       }
 547   time_count = guint32_from_be(header-&gt;tzh_timecnt);
 548   type_count = guint32_from_be(header-&gt;tzh_typecnt);
 549 
 550   tz_transitions = ((guint8 *) (header) + sizeof (*header));
 551   tz_type_index = tz_transitions + timesize * time_count;
 552   tz_ttinfo = tz_type_index + time_count;
 553   tz_abbrs = tz_ttinfo + sizeof (struct ttinfo) * type_count;
 554 
 555   gtz-&gt;name = g_steal_pointer (&amp;identifier);
 556   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo),
 557                                    type_count);
 558   gtz-&gt;transitions = g_array_sized_new (FALSE, TRUE, sizeof (Transition),
 559                                         time_count);
 560 
 561   for (index = 0; index &lt; type_count; index++)
 562     {
 563       TransitionInfo t_info;
 564       struct ttinfo info = ((struct ttinfo*)tz_ttinfo)[index];
 565       t_info.gmt_offset = gint32_from_be (info.tt_gmtoff);
 566       t_info.is_dst = info.tt_isdst ? TRUE : FALSE;
 567       t_info.abbrev = g_strdup ((gchar *) &amp;tz_abbrs[info.tt_abbrind]);
 568       g_array_append_val (gtz-&gt;t_info, t_info);
 569     }
 570 
 571   for (index = 0; index &lt; time_count; index++)
 572     {
 573       Transition trans;
 574       if (header-&gt;tzh_version == &#39;2&#39;)
 575         trans.time = gint64_from_be (((gint64_be*)tz_transitions)[index]);
 576       else
 577         trans.time = gint32_from_be (((gint32_be*)tz_transitions)[index]);
 578       trans.info_index = tz_type_index[index];
 579       g_assert (trans.info_index &gt;= 0);
<a name="11" id="anc11"></a><span class="line-modified"> 580       g_assert ((guint) trans.info_index &lt; gtz-&gt;t_info-&gt;len);</span>
 581       g_array_append_val (gtz-&gt;transitions, trans);
 582     }
 583 }
 584 
 585 #elif defined (G_OS_WIN32)
 586 
 587 static void
 588 copy_windows_systemtime (SYSTEMTIME *s_time, TimeZoneDate *tzdate)
 589 {
 590   tzdate-&gt;sec = s_time-&gt;wSecond;
 591   tzdate-&gt;min = s_time-&gt;wMinute;
 592   tzdate-&gt;hour = s_time-&gt;wHour;
 593   tzdate-&gt;mon = s_time-&gt;wMonth;
 594   tzdate-&gt;year = s_time-&gt;wYear;
 595   tzdate-&gt;wday = s_time-&gt;wDayOfWeek ? s_time-&gt;wDayOfWeek : 7;
 596 
 597   if (s_time-&gt;wYear)
 598     {
 599       tzdate-&gt;mday = s_time-&gt;wDay;
 600       tzdate-&gt;wday = 0;
 601     }
 602   else
 603     tzdate-&gt;week = s_time-&gt;wDay;
 604 }
 605 
 606 /* UTC = local time + bias while local time = UTC + offset */
<a name="12" id="anc12"></a><span class="line-modified"> 607 static gboolean</span>
 608 rule_from_windows_time_zone_info (TimeZoneRule *rule,
 609                                   TIME_ZONE_INFORMATION *tzi)
 610 {
<a name="13" id="anc13"></a><span class="line-added"> 611   gchar *std_name, *dlt_name;</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613   std_name = g_utf16_to_utf8 ((gunichar2 *)tzi-&gt;StandardName, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 614   if (std_name == NULL)</span>
<span class="line-added"> 615     return FALSE;</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617   dlt_name = g_utf16_to_utf8 ((gunichar2 *)tzi-&gt;DaylightName, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 618   if (dlt_name == NULL)</span>
<span class="line-added"> 619     {</span>
<span class="line-added"> 620       g_free (std_name);</span>
<span class="line-added"> 621       return FALSE;</span>
<span class="line-added"> 622     }</span>
<span class="line-added"> 623 </span>
 624   /* Set offset */
 625   if (tzi-&gt;StandardDate.wMonth)
 626     {
 627       rule-&gt;std_offset = -(tzi-&gt;Bias + tzi-&gt;StandardBias) * 60;
 628       rule-&gt;dlt_offset = -(tzi-&gt;Bias + tzi-&gt;DaylightBias) * 60;
 629       copy_windows_systemtime (&amp;(tzi-&gt;DaylightDate), &amp;(rule-&gt;dlt_start));
 630 
 631       copy_windows_systemtime (&amp;(tzi-&gt;StandardDate), &amp;(rule-&gt;dlt_end));
<a name="14" id="anc14"></a>
 632     }
 633 
 634   else
 635     {
 636       rule-&gt;std_offset = -tzi-&gt;Bias * 60;
 637       rule-&gt;dlt_start.mon = 0;
 638     }
<a name="15" id="anc15"></a><span class="line-modified"> 639   strncpy (rule-&gt;std_name, std_name, NAME_SIZE - 1);</span>
<span class="line-modified"> 640   strncpy (rule-&gt;dlt_name, dlt_name, NAME_SIZE - 1);</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642   g_free (std_name);</span>
<span class="line-added"> 643   g_free (dlt_name);</span>
<span class="line-added"> 644 </span>
<span class="line-added"> 645   return TRUE;</span>
 646 }
 647 
 648 static gchar*
 649 windows_default_tzname (void)
 650 {
<a name="16" id="anc16"></a><span class="line-modified"> 651   const gunichar2 *subkey =</span>
<span class="line-modified"> 652     L&quot;SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation&quot;;</span>
 653   HKEY key;
 654   gchar *key_name = NULL;
<a name="17" id="anc17"></a><span class="line-modified"> 655   gunichar2 *key_name_w = NULL;</span>
<span class="line-added"> 656   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey, 0,</span>
 657                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 658     {
 659       DWORD size = 0;
<a name="18" id="anc18"></a><span class="line-modified"> 660       if (RegQueryValueExW (key, L&quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
 661                             NULL, &amp;size) == ERROR_SUCCESS)
 662         {
<a name="19" id="anc19"></a><span class="line-modified"> 663           key_name_w = g_malloc ((gint)size);</span>
<span class="line-modified"> 664 </span>
<span class="line-modified"> 665           if (key_name_w == NULL ||</span>
<span class="line-added"> 666               RegQueryValueExW (key, L&quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
<span class="line-added"> 667                                 (LPBYTE)key_name_w, &amp;size) != ERROR_SUCCESS)</span>
 668             {
<a name="20" id="anc20"></a><span class="line-modified"> 669               g_free (key_name_w);</span>
 670               key_name = NULL;
 671             }
<a name="21" id="anc21"></a><span class="line-added"> 672           else</span>
<span class="line-added"> 673             key_name = g_utf16_to_utf8 (key_name_w, -1, NULL, NULL, NULL);</span>
 674         }
 675       RegCloseKey (key);
 676     }
 677   return key_name;
 678 }
 679 
 680 typedef   struct
 681 {
 682   LONG Bias;
 683   LONG StandardBias;
 684   LONG DaylightBias;
 685   SYSTEMTIME StandardDate;
 686   SYSTEMTIME DaylightDate;
 687 } RegTZI;
 688 
 689 static void
 690 system_time_copy (SYSTEMTIME *orig, SYSTEMTIME *target)
 691 {
 692   g_return_if_fail (orig != NULL);
 693   g_return_if_fail (target != NULL);
 694 
 695   target-&gt;wYear = orig-&gt;wYear;
 696   target-&gt;wMonth = orig-&gt;wMonth;
 697   target-&gt;wDayOfWeek = orig-&gt;wDayOfWeek;
 698   target-&gt;wDay = orig-&gt;wDay;
 699   target-&gt;wHour = orig-&gt;wHour;
 700   target-&gt;wMinute = orig-&gt;wMinute;
 701   target-&gt;wSecond = orig-&gt;wSecond;
 702   target-&gt;wMilliseconds = orig-&gt;wMilliseconds;
 703 }
 704 
 705 static void
 706 register_tzi_to_tzi (RegTZI *reg, TIME_ZONE_INFORMATION *tzi)
 707 {
 708   g_return_if_fail (reg != NULL);
 709   g_return_if_fail (tzi != NULL);
 710   tzi-&gt;Bias = reg-&gt;Bias;
 711   system_time_copy (&amp;(reg-&gt;StandardDate), &amp;(tzi-&gt;StandardDate));
 712   tzi-&gt;StandardBias = reg-&gt;StandardBias;
 713   system_time_copy (&amp;(reg-&gt;DaylightDate), &amp;(tzi-&gt;DaylightDate));
 714   tzi-&gt;DaylightBias = reg-&gt;DaylightBias;
 715 }
 716 
<a name="22" id="anc22"></a><span class="line-modified"> 717 static guint</span>
 718 rules_from_windows_time_zone (const gchar   *identifier,
 719                               gchar        **out_identifier,
<a name="23" id="anc23"></a><span class="line-modified"> 720                               TimeZoneRule **rules,</span>
<span class="line-added"> 721                               gboolean       copy_identifier)</span>
 722 {
 723   HKEY key;
<a name="24" id="anc24"></a><span class="line-modified"> 724   gchar *subkey = NULL;</span>
<span class="line-added"> 725   gchar *subkey_dynamic = NULL;</span>
 726   gchar *key_name = NULL;
 727   const gchar *reg_key =
 728     &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;
 729   TIME_ZONE_INFORMATION tzi;
 730   DWORD size;
<a name="25" id="anc25"></a><span class="line-modified"> 731   guint rules_num = 0;</span>
 732   RegTZI regtzi, regtzi_prev;
<a name="26" id="anc26"></a><span class="line-added"> 733   WCHAR winsyspath[MAX_PATH];</span>
<span class="line-added"> 734   gunichar2 *subkey_w, *subkey_dynamic_w;</span>
 735 
<a name="27" id="anc27"></a><span class="line-modified"> 736   if (GetSystemDirectoryW (winsyspath, MAX_PATH) == 0)</span>
<span class="line-added"> 737     return 0;</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739   g_assert (copy_identifier == FALSE || out_identifier != NULL);</span>
 740   g_assert (rules != NULL);
 741 
<a name="28" id="anc28"></a><span class="line-modified"> 742   if (copy_identifier)</span>
<span class="line-added"> 743     *out_identifier = NULL;</span>
<span class="line-added"> 744 </span>
 745   *rules = NULL;
 746   key_name = NULL;
 747 
 748   if (!identifier)
 749     key_name = windows_default_tzname ();
 750   else
 751     key_name = g_strdup (identifier);
 752 
 753   if (!key_name)
 754     return 0;
 755 
 756   subkey = g_strconcat (reg_key, key_name, NULL);
<a name="29" id="anc29"></a><span class="line-added"> 757   subkey_w = g_utf8_to_utf16 (subkey, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 758   if (subkey_w == NULL)</span>
<span class="line-added"> 759     goto utf16_conv_failed;</span>
<span class="line-added"> 760 </span>
 761   subkey_dynamic = g_strconcat (subkey, &quot;\\Dynamic DST&quot;, NULL);
<a name="30" id="anc30"></a><span class="line-added"> 762   subkey_dynamic_w = g_utf8_to_utf16 (subkey_dynamic, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 763   if (subkey_dynamic_w == NULL)</span>
<span class="line-added"> 764     goto utf16_conv_failed;</span>
 765 
<a name="31" id="anc31"></a><span class="line-modified"> 766   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,</span>
 767                      KEY_QUERY_VALUE, &amp;key) != ERROR_SUCCESS)
<a name="32" id="anc32"></a><span class="line-modified"> 768       goto utf16_conv_failed;</span>
<span class="line-added"> 769 </span>
 770   size = sizeof tzi.StandardName;
<a name="33" id="anc33"></a><span class="line-modified"> 771 </span>
<span class="line-modified"> 772   /* use RegLoadMUIStringW() to query MUI_Std from the registry if possible, otherwise</span>
<span class="line-modified"> 773      fallback to querying Std */</span>
<span class="line-added"> 774   if (RegLoadMUIStringW (key, L&quot;MUI_Std&quot;, tzi.StandardName,</span>
<span class="line-added"> 775                          size, &amp;size, 0, winsyspath) != ERROR_SUCCESS)</span>
<span class="line-added"> 776     {</span>
<span class="line-added"> 777       size = sizeof tzi.StandardName;</span>
<span class="line-added"> 778       if (RegQueryValueExW (key, L&quot;Std&quot;, NULL, NULL,</span>
<span class="line-added"> 779                             (LPBYTE)&amp;(tzi.StandardName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 780         goto registry_failed;</span>
<span class="line-added"> 781     }</span>
 782 
 783   size = sizeof tzi.DaylightName;
 784 
<a name="34" id="anc34"></a><span class="line-modified"> 785   /* use RegLoadMUIStringW() to query MUI_Dlt from the registry if possible, otherwise</span>
<span class="line-modified"> 786      fallback to querying Dlt */</span>
<span class="line-modified"> 787   if (RegLoadMUIStringW (key, L&quot;MUI_Dlt&quot;, tzi.DaylightName,</span>
<span class="line-added"> 788                          size, &amp;size, 0, winsyspath) != ERROR_SUCCESS)</span>
<span class="line-added"> 789     {</span>
<span class="line-added"> 790       size = sizeof tzi.DaylightName;</span>
<span class="line-added"> 791       if (RegQueryValueExW (key, L&quot;Dlt&quot;, NULL, NULL,</span>
<span class="line-added"> 792                             (LPBYTE)&amp;(tzi.DaylightName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 793         goto registry_failed;</span>
<span class="line-added"> 794     }</span>
 795 
 796   RegCloseKey (key);
<a name="35" id="anc35"></a><span class="line-modified"> 797   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_dynamic_w, 0,</span>
 798                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 799     {
 800       DWORD first, last;
 801       int year, i;
<a name="36" id="anc36"></a><span class="line-modified"> 802       wchar_t s[12];</span>
 803 
 804       size = sizeof first;
<a name="37" id="anc37"></a><span class="line-modified"> 805       if (RegQueryValueExW (key, L&quot;FirstEntry&quot;, NULL, NULL,</span>
 806                             (LPBYTE) &amp;first, &amp;size) != ERROR_SUCCESS)
<a name="38" id="anc38"></a><span class="line-modified"> 807         goto registry_failed;</span>
 808 
 809       size = sizeof last;
<a name="39" id="anc39"></a><span class="line-modified"> 810       if (RegQueryValueExW (key, L&quot;LastEntry&quot;, NULL, NULL,</span>
 811                             (LPBYTE) &amp;last, &amp;size) != ERROR_SUCCESS)
<a name="40" id="anc40"></a><span class="line-modified"> 812         goto registry_failed;</span>
 813 
 814       rules_num = last - first + 2;
 815       *rules = g_new0 (TimeZoneRule, rules_num);
 816 
<a name="41" id="anc41"></a><span class="line-modified"> 817       for (year = first, i = 0; *rules != NULL &amp;&amp; year &lt;= last; year++)</span>
 818         {
<a name="42" id="anc42"></a><span class="line-modified"> 819           gboolean failed = FALSE;</span>
<span class="line-added"> 820           swprintf_s (s, 11, L&quot;%d&quot;, year);</span>
<span class="line-added"> 821 </span>
<span class="line-added"> 822           if (!failed)</span>
<span class="line-added"> 823             {</span>
<span class="line-added"> 824               size = sizeof regtzi;</span>
<span class="line-added"> 825               if (RegQueryValueExW (key, s, NULL, NULL,</span>
<span class="line-added"> 826                                     (LPBYTE) &amp;regtzi, &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 827                 failed = TRUE;</span>
<span class="line-added"> 828             }</span>
 829 
<a name="43" id="anc43"></a><span class="line-modified"> 830           if (failed)</span>


 831             {
 832               g_free (*rules);
 833               *rules = NULL;
 834               break;
 835             }
 836 
<a name="44" id="anc44"></a>

 837           if (year &gt; first &amp;&amp; memcmp (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi) == 0)
 838               continue;
 839           else
 840             memcpy (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi);
 841 
 842           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<a name="45" id="anc45"></a><span class="line-modified"> 843 </span>
<span class="line-added"> 844           if (!rule_from_windows_time_zone_info (&amp;(*rules)[i], &amp;tzi))</span>
<span class="line-added"> 845             {</span>
<span class="line-added"> 846               g_free (*rules);</span>
<span class="line-added"> 847               *rules = NULL;</span>
<span class="line-added"> 848               break;</span>
<span class="line-added"> 849             }</span>
<span class="line-added"> 850 </span>
 851           (*rules)[i++].start_year = year;
 852         }
 853 
 854       rules_num = i + 1;
 855 
<a name="46" id="anc46"></a><span class="line-modified"> 856 registry_failed:</span>
 857       RegCloseKey (key);
 858     }
<a name="47" id="anc47"></a><span class="line-modified"> 859   else if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,</span>
 860                           KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 861     {
 862       size = sizeof regtzi;
<a name="48" id="anc48"></a><span class="line-modified"> 863       if (RegQueryValueExW (key, L&quot;TZI&quot;, NULL, NULL,</span>
 864                             (LPBYTE) &amp;regtzi, &amp;size) == ERROR_SUCCESS)
 865         {
 866           rules_num = 2;
 867           *rules = g_new0 (TimeZoneRule, 2);
 868           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<a name="49" id="anc49"></a><span class="line-modified"> 869 </span>
<span class="line-added"> 870           if (!rule_from_windows_time_zone_info (&amp;(*rules)[0], &amp;tzi))</span>
<span class="line-added"> 871             {</span>
<span class="line-added"> 872               g_free (*rules);</span>
<span class="line-added"> 873               *rules = NULL;</span>
<span class="line-added"> 874             }</span>
 875         }
 876 
 877       RegCloseKey (key);
 878     }
 879 
<a name="50" id="anc50"></a><span class="line-added"> 880 utf16_conv_failed:</span>
<span class="line-added"> 881   g_free (subkey_dynamic_w);</span>
 882   g_free (subkey_dynamic);
<a name="51" id="anc51"></a><span class="line-added"> 883   g_free (subkey_w);</span>
 884   g_free (subkey);
 885 
 886   if (*rules)
 887     {
 888       (*rules)[0].start_year = MIN_TZYEAR;
 889       if ((*rules)[rules_num - 2].start_year &lt; MAX_TZYEAR)
 890         (*rules)[rules_num - 1].start_year = MAX_TZYEAR;
 891       else
 892         (*rules)[rules_num - 1].start_year = (*rules)[rules_num - 2].start_year + 1;
 893 
<a name="52" id="anc52"></a><span class="line-modified"> 894       if (copy_identifier)</span>
<span class="line-added"> 895         *out_identifier = g_steal_pointer (&amp;key_name);</span>
<span class="line-added"> 896       else</span>
<span class="line-added"> 897         g_free (key_name);</span>
 898 
 899       return rules_num;
 900     }
 901 
 902   g_free (key_name);
 903 
<a name="53" id="anc53"></a><span class="line-modified"> 904   return 0;</span>
 905 }
 906 
 907 #endif
 908 
 909 static void
 910 find_relative_date (TimeZoneDate *buffer)
 911 {
<a name="54" id="anc54"></a><span class="line-modified"> 912   guint wday;</span>
 913   GDate date;
 914   g_date_clear (&amp;date, 1);
 915   wday = buffer-&gt;wday;
 916 
 917   /* Get last day if last is needed, first day otherwise */
 918   if (buffer-&gt;mon == 13 || buffer-&gt;mon == 14) /* Julian Date */
 919     {
 920       g_date_set_dmy (&amp;date, 1, 1, buffer-&gt;year);
 921       if (wday &gt;= 59 &amp;&amp; buffer-&gt;mon == 13 &amp;&amp; g_date_is_leap_year (buffer-&gt;year))
 922         g_date_add_days (&amp;date, wday);
 923       else
 924         g_date_add_days (&amp;date, wday - 1);
 925       buffer-&gt;mon = (int) g_date_get_month (&amp;date);
 926       buffer-&gt;mday = (int) g_date_get_day (&amp;date);
 927       buffer-&gt;wday = 0;
 928     }
 929   else /* M.W.D */
 930     {
 931       guint days;
 932 #ifdef GSTREAMER_LITE
 933       guint days_in_month = g_date_get_days_in_month (buffer-&gt;mon, buffer-&gt;year);
 934 #else // GSTREAMER_LITE
 935       guint days_in_month = g_date_days_in_month (buffer-&gt;mon, buffer-&gt;year);
 936 #endif // GSTREAMER_LITE
 937       GDateWeekday first_wday;
 938 
 939       g_date_set_dmy (&amp;date, 1, buffer-&gt;mon, buffer-&gt;year);
 940       first_wday = g_date_get_weekday (&amp;date);
 941 
 942       if (first_wday &gt; wday)
 943         ++(buffer-&gt;week);
 944       /* week is 1 &lt;= w &lt;= 5, we need 0-based */
 945       days = 7 * (buffer-&gt;week - 1) + wday - first_wday;
 946 
 947       while (days &gt; days_in_month)
 948         days -= 7;
 949 
 950       g_date_add_days (&amp;date, days);
 951 
 952       buffer-&gt;mday = g_date_get_day (&amp;date);
 953     }
 954 }
 955 
 956 /* Offset is previous offset of local time. Returns 0 if month is 0 */
 957 static gint64
 958 boundary_for_year (TimeZoneDate *boundary,
 959                    gint          year,
 960                    gint32        offset)
 961 {
 962   TimeZoneDate buffer;
 963   GDate date;
 964   const guint64 unix_epoch_start = 719163L;
 965   const guint64 seconds_per_day = 86400L;
 966 
 967   if (!boundary-&gt;mon)
 968     return 0;
 969   buffer = *boundary;
 970 
 971   if (boundary-&gt;year == 0)
 972     {
 973       buffer.year = year;
 974 
 975       if (buffer.wday)
 976         find_relative_date (&amp;buffer);
 977     }
 978 
 979   g_assert (buffer.year == year);
 980   g_date_clear (&amp;date, 1);
 981   g_date_set_dmy (&amp;date, buffer.mday, buffer.mon, buffer.year);
 982   return ((g_date_get_julian (&amp;date) - unix_epoch_start) * seconds_per_day +
 983           buffer.hour * 3600 + buffer.min * 60 + buffer.sec - offset);
 984 }
 985 
 986 static void
 987 fill_transition_info_from_rule (TransitionInfo *info,
 988                                 TimeZoneRule   *rule,
 989                                 gboolean        is_dst)
 990 {
 991   gint offset = is_dst ? rule-&gt;dlt_offset : rule-&gt;std_offset;
 992   gchar *name = is_dst ? rule-&gt;dlt_name : rule-&gt;std_name;
 993 
 994   info-&gt;gmt_offset = offset;
 995   info-&gt;is_dst = is_dst;
 996 
 997   if (name)
 998     info-&gt;abbrev = g_strdup (name);
 999 
1000   else
1001     info-&gt;abbrev = g_strdup_printf (&quot;%+03d%02d&quot;,
1002                                       (int) offset / 3600,
1003                                       (int) abs (offset / 60) % 60);
1004 }
1005 
1006 static void
1007 init_zone_from_rules (GTimeZone    *gtz,
1008                       TimeZoneRule *rules,
<a name="55" id="anc55"></a><span class="line-modified">1009                       guint         rules_num,</span>
1010                       gchar        *identifier  /* (transfer full) */)
1011 {
1012   guint type_count = 0, trans_count = 0, info_index = 0;
1013   guint ri; /* rule index */
1014   gboolean skip_first_std_trans = TRUE;
1015   gint32 last_offset;
1016 
1017   type_count = 0;
1018   trans_count = 0;
1019 
1020   /* Last rule only contains max year */
1021   for (ri = 0; ri &lt; rules_num - 1; ri++)
1022     {
1023       if (rules[ri].dlt_start.mon || rules[ri].dlt_end.mon)
1024         {
1025           guint rulespan = (rules[ri + 1].start_year - rules[ri].start_year);
1026           guint transitions = rules[ri].dlt_start.mon &gt; 0 ? 1 : 0;
1027           transitions += rules[ri].dlt_end.mon &gt; 0 ? 1 : 0;
1028           type_count += rules[ri].dlt_start.mon &gt; 0 ? 2 : 1;
1029           trans_count += transitions * rulespan;
1030         }
1031       else
1032         type_count++;
1033     }
1034 
1035   gtz-&gt;name = g_steal_pointer (&amp;identifier);
1036   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo), type_count);
1037   gtz-&gt;transitions = g_array_sized_new (FALSE, TRUE, sizeof (Transition), trans_count);
1038 
1039   last_offset = rules[0].std_offset;
1040 
1041   for (ri = 0; ri &lt; rules_num - 1; ri++)
1042     {
1043       if ((rules[ri].std_offset || rules[ri].dlt_offset) &amp;&amp;
1044           rules[ri].dlt_start.mon == 0 &amp;&amp; rules[ri].dlt_end.mon == 0)
1045         {
1046           TransitionInfo std_info;
1047           /* Standard */
1048           fill_transition_info_from_rule (&amp;std_info, &amp;(rules[ri]), FALSE);
1049           g_array_append_val (gtz-&gt;t_info, std_info);
1050 
1051           if (ri &gt; 0 &amp;&amp;
1052               ((rules[ri - 1].dlt_start.mon &gt; 12 &amp;&amp;
1053                 rules[ri - 1].dlt_start.wday &gt; rules[ri - 1].dlt_end.wday) ||
1054                 rules[ri - 1].dlt_start.mon &gt; rules[ri - 1].dlt_end.mon))
1055             {
1056               /* The previous rule was a southern hemisphere rule that
1057                  starts the year with DST, so we need to add a
1058                  transition to return to standard time */
1059               guint year = rules[ri].start_year;
1060               gint64 std_time =  boundary_for_year (&amp;rules[ri].dlt_end,
1061                                                     year, last_offset);
1062               Transition std_trans = {std_time, info_index};
1063               g_array_append_val (gtz-&gt;transitions, std_trans);
1064 
1065             }
1066           last_offset = rules[ri].std_offset;
1067           ++info_index;
1068           skip_first_std_trans = TRUE;
1069          }
1070       else
1071         {
1072           const guint start_year = rules[ri].start_year;
1073           const guint end_year = rules[ri + 1].start_year;
1074           gboolean dlt_first;
1075           guint year;
1076           TransitionInfo std_info, dlt_info;
1077           if (rules[ri].dlt_start.mon &gt; 12)
1078             dlt_first = rules[ri].dlt_start.wday &gt; rules[ri].dlt_end.wday;
1079           else
1080             dlt_first = rules[ri].dlt_start.mon &gt; rules[ri].dlt_end.mon;
1081           /* Standard rules are always even, because before the first
1082              transition is always standard time, and 0 is even. */
1083           fill_transition_info_from_rule (&amp;std_info, &amp;(rules[ri]), FALSE);
1084           fill_transition_info_from_rule (&amp;dlt_info, &amp;(rules[ri]), TRUE);
1085 
1086           g_array_append_val (gtz-&gt;t_info, std_info);
1087           g_array_append_val (gtz-&gt;t_info, dlt_info);
1088 
1089           /* Transition dates. We hope that a year which ends daylight
1090              time in a southern-hemisphere country (i.e., one that
1091              begins the year in daylight time) will include a rule
1092              which has only a dlt_end. */
1093           for (year = start_year; year &lt; end_year; year++)
1094             {
1095               gint32 dlt_offset = (dlt_first ? last_offset :
1096                                    rules[ri].dlt_offset);
1097               gint32 std_offset = (dlt_first ? rules[ri].std_offset :
1098                                    last_offset);
1099               /* NB: boundary_for_year returns 0 if mon == 0 */
1100               gint64 std_time =  boundary_for_year (&amp;rules[ri].dlt_end,
1101                                                     year, dlt_offset);
1102               gint64 dlt_time = boundary_for_year (&amp;rules[ri].dlt_start,
1103                                                    year, std_offset);
1104               Transition std_trans = {std_time, info_index};
1105               Transition dlt_trans = {dlt_time, info_index + 1};
1106               last_offset = (dlt_first ? rules[ri].dlt_offset :
1107                              rules[ri].std_offset);
1108               if (dlt_first)
1109                 {
1110                   if (skip_first_std_trans)
1111                     skip_first_std_trans = FALSE;
1112                   else if (std_time)
1113                     g_array_append_val (gtz-&gt;transitions, std_trans);
1114                   if (dlt_time)
1115                     g_array_append_val (gtz-&gt;transitions, dlt_trans);
1116                 }
1117               else
1118                 {
1119                   if (dlt_time)
1120                     g_array_append_val (gtz-&gt;transitions, dlt_trans);
1121                   if (std_time)
1122                     g_array_append_val (gtz-&gt;transitions, std_trans);
1123                 }
1124             }
1125 
1126           info_index += 2;
1127         }
1128     }
1129   if (ri &gt; 0 &amp;&amp;
1130       ((rules[ri - 1].dlt_start.mon &gt; 12 &amp;&amp;
1131         rules[ri - 1].dlt_start.wday &gt; rules[ri - 1].dlt_end.wday) ||
1132        rules[ri - 1].dlt_start.mon &gt; rules[ri - 1].dlt_end.mon))
1133     {
1134       /* The previous rule was a southern hemisphere rule that
1135          starts the year with DST, so we need to add a
1136          transition to return to standard time */
1137       TransitionInfo info;
1138       guint year = rules[ri].start_year;
1139       Transition trans;
1140       fill_transition_info_from_rule (&amp;info, &amp;(rules[ri - 1]), FALSE);
1141       g_array_append_val (gtz-&gt;t_info, info);
1142       trans.time = boundary_for_year (&amp;rules[ri - 1].dlt_end,
1143                                       year, last_offset);
1144       trans.info_index = info_index;
1145       g_array_append_val (gtz-&gt;transitions, trans);
1146      }
1147 }
1148 
1149 /*
1150  * parses date[/time] for parsing TZ environment variable
1151  *
1152  * date is either Mm.w.d, Jn or N
1153  * - m is 1 to 12
1154  * - w is 1 to 5
1155  * - d is 0 to 6
1156  * - n is 1 to 365
1157  * - N is 0 to 365
1158  *
1159  * time is either h or hh[[:]mm[[[:]ss]]]
1160  *  - h[h] is 0 to 23
1161  *  - mm is 00 to 59
1162  *  - ss is 00 to 59
1163  */
1164 static gboolean
1165 parse_mwd_boundary (gchar **pos, TimeZoneDate *boundary)
1166 {
1167   gint month, week, day;
1168 
1169   if (**pos == &#39;\0&#39; || **pos &lt; &#39;0&#39; || &#39;9&#39; &lt; **pos)
1170     return FALSE;
1171 
1172   month = *(*pos)++ - &#39;0&#39;;
1173 
1174   if ((month == 1 &amp;&amp; **pos &gt;= &#39;0&#39; &amp;&amp; &#39;2&#39; &gt;= **pos) ||
1175       (month == 0 &amp;&amp; **pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos))
1176     {
1177       month *= 10;
1178       month += *(*pos)++ - &#39;0&#39;;
1179     }
1180 
1181   if (*(*pos)++ != &#39;.&#39; || month == 0)
1182     return FALSE;
1183 
1184   if (**pos == &#39;\0&#39; || **pos &lt; &#39;1&#39; || &#39;5&#39; &lt; **pos)
1185     return FALSE;
1186 
1187   week = *(*pos)++ - &#39;0&#39;;
1188 
1189   if (*(*pos)++ != &#39;.&#39;)
1190     return FALSE;
1191 
1192   if (**pos == &#39;\0&#39; || **pos &lt; &#39;0&#39; || &#39;6&#39; &lt; **pos)
1193     return FALSE;
1194 
1195   day = *(*pos)++ - &#39;0&#39;;
1196 
1197   if (!day)
1198     day += 7;
1199 
1200   boundary-&gt;year = 0;
1201   boundary-&gt;mon = month;
1202   boundary-&gt;week = week;
1203   boundary-&gt;wday = day;
1204   return TRUE;
1205 }
1206 
1207 /* Different implementations of tzset interpret the Julian day field
1208    differently. For example, Linux specifies that it should be 1-based
1209    (1 Jan is JD 1) for both Jn and n formats, while zOS and BSD
1210    specify that a Jn JD is 1-based while an n JD is 0-based. Rather
1211    than trying to follow different specs, we will follow GDate&#39;s
1212    practice thatIn order to keep it simple, we will follow Linux&#39;s
1213    practice. */
1214 
1215 static gboolean
1216 parse_julian_boundary (gchar** pos, TimeZoneDate *boundary,
1217                        gboolean ignore_leap)
1218 {
1219   gint day = 0;
1220   GDate date;
1221 
1222   while (**pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos)
1223     {
1224       day *= 10;
1225       day += *(*pos)++ - &#39;0&#39;;
1226     }
1227 
1228   if (day &lt; 1 || 365 &lt; day)
1229     return FALSE;
1230 
1231   g_date_clear (&amp;date, 1);
1232   g_date_set_julian (&amp;date, day);
1233   boundary-&gt;year = 0;
1234   boundary-&gt;mon = (int) g_date_get_month (&amp;date);
1235   boundary-&gt;mday = (int) g_date_get_day (&amp;date);
1236   boundary-&gt;wday = 0;
1237 
1238   if (!ignore_leap &amp;&amp; day &gt;= 59)
1239     boundary-&gt;mday++;
1240 
1241   return TRUE;
1242 }
1243 
1244 static gboolean
1245 parse_tz_boundary (const gchar  *identifier,
1246                    TimeZoneDate *boundary)
1247 {
1248   gchar *pos;
1249 
1250   pos = (gchar*)identifier;
1251   /* Month-week-weekday */
1252   if (*pos == &#39;M&#39;)
1253     {
1254       ++pos;
1255       if (!parse_mwd_boundary (&amp;pos, boundary))
1256         return FALSE;
1257     }
1258   /* Julian date which ignores Feb 29 in leap years */
1259   else if (*pos == &#39;J&#39;)
1260     {
1261       ++pos;
1262       if (!parse_julian_boundary (&amp;pos, boundary, FALSE))
1263         return FALSE ;
1264     }
1265   /* Julian date which counts Feb 29 in leap years */
1266   else if (*pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *pos)
1267     {
1268       if (!parse_julian_boundary (&amp;pos, boundary, TRUE))
1269         return FALSE;
1270     }
1271   else
1272     return FALSE;
1273 
1274   /* Time */
1275 
1276   if (*pos == &#39;/&#39;)
1277     {
1278       gint32 offset;
1279 
1280       if (!parse_time (++pos, &amp;offset))
1281         return FALSE;
1282 
1283       boundary-&gt;hour = offset / 3600;
1284       boundary-&gt;min = (offset / 60) % 60;
1285       boundary-&gt;sec = offset % 3600;
1286 
1287       return TRUE;
1288     }
1289 
1290   else
1291     {
1292       boundary-&gt;hour = 2;
1293       boundary-&gt;min = 0;
1294       boundary-&gt;sec = 0;
1295 
1296       return *pos == &#39;\0&#39;;
1297     }
1298 }
1299 
<a name="56" id="anc56"></a><span class="line-modified">1300 static guint</span>
1301 create_ruleset_from_rule (TimeZoneRule **rules, TimeZoneRule *rule)
1302 {
1303   *rules = g_new0 (TimeZoneRule, 2);
1304 
1305   (*rules)[0].start_year = MIN_TZYEAR;
1306   (*rules)[1].start_year = MAX_TZYEAR;
1307 
1308   (*rules)[0].std_offset = -rule-&gt;std_offset;
1309   (*rules)[0].dlt_offset = -rule-&gt;dlt_offset;
1310   (*rules)[0].dlt_start  = rule-&gt;dlt_start;
1311   (*rules)[0].dlt_end = rule-&gt;dlt_end;
1312   strcpy ((*rules)[0].std_name, rule-&gt;std_name);
1313   strcpy ((*rules)[0].dlt_name, rule-&gt;dlt_name);
1314   return 2;
1315 }
1316 
1317 static gboolean
1318 parse_offset (gchar **pos, gint32 *target)
1319 {
1320   gchar *buffer;
1321   gchar *target_pos = *pos;
1322   gboolean ret;
1323 
1324   while (**pos == &#39;+&#39; || **pos == &#39;-&#39; || **pos == &#39;:&#39; ||
1325          (**pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos))
1326     ++(*pos);
1327 
1328   buffer = g_strndup (target_pos, *pos - target_pos);
1329   ret = parse_constant_offset (buffer, target);
1330   g_free (buffer);
1331 
1332   return ret;
1333 }
1334 
1335 static gboolean
1336 parse_identifier_boundary (gchar **pos, TimeZoneDate *target)
1337 {
1338   gchar *buffer;
1339   gchar *target_pos = *pos;
1340   gboolean ret;
1341 
1342   while (**pos != &#39;,&#39; &amp;&amp; **pos != &#39;\0&#39;)
1343     ++(*pos);
1344   buffer = g_strndup (target_pos, *pos - target_pos);
1345   ret = parse_tz_boundary (buffer, target);
1346   g_free (buffer);
1347 
1348   return ret;
1349 }
1350 
1351 static gboolean
1352 set_tz_name (gchar **pos, gchar *buffer, guint size)
1353 {
1354   gchar *name_pos = *pos;
1355   guint len;
1356 
1357   /* Name is ASCII alpha (Is this necessarily true?) */
1358   while (g_ascii_isalpha (**pos))
1359     ++(*pos);
1360 
1361   /* Name should be three or more alphabetic characters */
1362   if (*pos - name_pos &lt; 3)
1363     return FALSE;
1364 
1365   memset (buffer, 0, NAME_SIZE);
1366   /* name_pos isn&#39;t 0-terminated, so we have to limit the length expressly */
1367   len = *pos - name_pos &gt; size - 1 ? size - 1 : *pos - name_pos;
1368   strncpy (buffer, name_pos, len);
1369   return TRUE;
1370 }
1371 
1372 static gboolean
1373 parse_identifier_boundaries (gchar **pos, TimeZoneRule *tzr)
1374 {
1375   if (*(*pos)++ != &#39;,&#39;)
1376     return FALSE;
1377 
1378   /* Start date */
1379   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_start)) || *(*pos)++ != &#39;,&#39;)
1380     return FALSE;
1381 
1382   /* End date */
1383   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_end)))
1384     return FALSE;
1385   return TRUE;
1386 }
1387 
1388 /*
1389  * Creates an array of TimeZoneRule from a TZ environment variable
1390  * type of identifier.  Should free rules afterwards
1391  */
<a name="57" id="anc57"></a><span class="line-modified">1392 static guint</span>
1393 rules_from_identifier (const gchar   *identifier,
1394                        gchar        **out_identifier,
1395                        TimeZoneRule **rules)
1396 {
1397   gchar *pos;
1398   TimeZoneRule tzr;
1399 
1400   g_assert (out_identifier != NULL);
1401   g_assert (rules != NULL);
1402 
1403   *out_identifier = NULL;
1404   *rules = NULL;
1405 
1406   if (!identifier)
1407     return 0;
1408 
1409   pos = (gchar*)identifier;
1410   memset (&amp;tzr, 0, sizeof (tzr));
1411   /* Standard offset */
1412   if (!(set_tz_name (&amp;pos, tzr.std_name, NAME_SIZE)) ||
1413       !parse_offset (&amp;pos, &amp;(tzr.std_offset)))
1414     return 0;
1415 
1416   if (*pos == 0)
1417     {
1418       *out_identifier = g_strdup (identifier);
1419       return create_ruleset_from_rule (rules, &amp;tzr);
1420     }
1421 
1422   /* Format 2 */
1423   if (!(set_tz_name (&amp;pos, tzr.dlt_name, NAME_SIZE)))
1424     return 0;
1425   parse_offset (&amp;pos, &amp;(tzr.dlt_offset));
1426   if (tzr.dlt_offset == 0) /* No daylight offset given, assume it&#39;s 1
1427                               hour earlier that standard */
1428     tzr.dlt_offset = tzr.std_offset - 3600;
1429   if (*pos == &#39;\0&#39;)
1430 #ifdef G_OS_WIN32
1431     /* Windows allows us to use the US DST boundaries if they&#39;re not given */
1432     {
1433       int i;
1434       guint rules_num = 0;
1435 
1436       /* Use US rules, Windows&#39; default is Pacific Standard Time */
1437       if ((rules_num = rules_from_windows_time_zone (&quot;Pacific Standard Time&quot;,
<a name="58" id="anc58"></a><span class="line-modified">1438                                                      NULL,</span>
<span class="line-modified">1439                                                      rules,</span>
<span class="line-added">1440                                                      FALSE)))</span>
1441         {
<a name="59" id="anc59"></a><span class="line-added">1442           /* We don&#39;t want to hardcode our identifier here as</span>
<span class="line-added">1443            * &quot;Pacific Standard Time&quot;, use what was passed in</span>
<span class="line-added">1444            */</span>
<span class="line-added">1445           *out_identifier = g_strdup (identifier);</span>
<span class="line-added">1446 </span>
1447           for (i = 0; i &lt; rules_num - 1; i++)
1448             {
1449               (*rules)[i].std_offset = - tzr.std_offset;
1450               (*rules)[i].dlt_offset = - tzr.dlt_offset;
1451               strcpy ((*rules)[i].std_name, tzr.std_name);
1452               strcpy ((*rules)[i].dlt_name, tzr.dlt_name);
1453             }
1454 
1455           return rules_num;
1456         }
1457       else
1458         return 0;
1459     }
1460 #else
1461   return 0;
1462 #endif
1463   /* Start and end required (format 2) */
1464   if (!parse_identifier_boundaries (&amp;pos, &amp;tzr))
1465     return 0;
1466 
1467   *out_identifier = g_strdup (identifier);
1468   return create_ruleset_from_rule (rules, &amp;tzr);
1469 }
1470 
1471 /* Construction {{{1 */
1472 /**
1473  * g_time_zone_new:
1474  * @identifier: (nullable): a timezone identifier
1475  *
1476  * Creates a #GTimeZone corresponding to @identifier.
1477  *
1478  * @identifier can either be an RFC3339/ISO 8601 time offset or
1479  * something that would pass as a valid value for the `TZ` environment
1480  * variable (including %NULL).
1481  *
1482  * In Windows, @identifier can also be the unlocalized name of a time
1483  * zone for standard time, for example &quot;Pacific Standard Time&quot;.
1484  *
1485  * Valid RFC3339 time offsets are &#39;&quot;Z&quot;&#39; (for UTC) or
1486  * &#39;&quot;+|-hh:mm&quot;&#39;.  ISO 8601 additionally specifies
1487  * &#39;&quot;+|-hhmm&quot;&#39; and &#39;&quot;+|-hh&quot;&#39;.  Offsets are
1488  * time values to be added to Coordinated Universal Time (UTC) to get
1489  * the local time.
1490  *
1491  * In UNIX, the &#39;TZ&#39; environment variable typically corresponds
1492  * to the name of a file in the zoneinfo database, or string in
1493  * &quot;std offset [dst [offset],start[/time],end[/time]]&quot; (POSIX) format.
1494  * There  are  no spaces in the specification. The name of standard
1495  * and daylight savings time zone must be three or more alphabetic
1496  * characters. Offsets are time values to be added to local time to
1497  * get Coordinated Universal Time (UTC) and should be
1498  * &#39;&quot;[+|-]hh[[:]mm[:ss]]&quot;&#39;.  Dates are either
1499  * &#39;&quot;Jn&quot;&#39; (Julian day with n between 1 and 365, leap
1500  * years not counted), &#39;&quot;n&quot;&#39; (zero-based Julian day
1501  * with n between 0 and 365) or &#39;&quot;Mm.w.d&quot;&#39; (day d
1502  * (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
1503  * 0 is a Sunday).  Times are in local wall clock time, the default is
1504  * 02:00:00.
1505  *
1506  * In Windows, the &quot;tzn[+|-]hh[:mm[:ss]][dzn]&quot; format is used, but also
1507  * accepts POSIX format.  The Windows format uses US rules for all time
1508  * zones; daylight savings time is 60 minutes behind the standard time
1509  * with date and time of change taken from Pacific Standard Time.
1510  * Offsets are time values to be added to the local time to get
1511  * Coordinated Universal Time (UTC).
1512  *
1513  * g_time_zone_new_local() calls this function with the value of the
1514  * &#39;TZ&#39; environment variable. This function itself is independent of
1515  * the value of &#39;TZ&#39;, but if @identifier is %NULL then &#39;/etc/localtime&#39;
1516  * will be consulted to discover the correct time zone on UNIX and the
1517  * registry will be consulted or GetTimeZoneInformation() will be used
1518  * to get the local time zone on Windows.
1519  *
1520  * If intervals are not available, only time zone rules from `TZ`
1521  * environment variable or other means, then they will be computed
1522  * from year 1900 to 2037.  If the maximum year for the rules is
1523  * available and it is greater than 2037, then it will followed
1524  * instead.
1525  *
1526  * See
<a name="60" id="anc60"></a><span class="line-modified">1527  * [RFC3339 5.6](http://tools.ietf.org/html/rfc3339#section-5.6)</span>
1528  * for a precise definition of valid RFC3339 time offsets
1529  * (the `time-offset` expansion) and ISO 8601 for the
1530  * full list of valid time offsets.  See
1531  * [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
1532  * for an explanation of the possible
1533  * values of the `TZ` environment variable. See
1534  * [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
1535  * for the list of time zones on Windows.
1536  *
1537  * You should release the return value by calling g_time_zone_unref()
1538  * when you are done with it.
1539  *
1540  * Returns: the requested timezone
1541  *
1542  * Since: 2.26
1543  **/
1544 GTimeZone *
1545 g_time_zone_new (const gchar *identifier)
1546 {
1547   GTimeZone *tz = NULL;
1548   TimeZoneRule *rules;
1549   gint rules_num;
1550   gchar *resolved_identifier = NULL;
1551 
1552   G_LOCK (time_zones);
1553   if (time_zones == NULL)
1554     time_zones = g_hash_table_new (g_str_hash, g_str_equal);
1555 
1556   if (identifier)
1557     {
1558       tz = g_hash_table_lookup (time_zones, identifier);
1559       if (tz)
1560         {
1561           g_atomic_int_inc (&amp;tz-&gt;ref_count);
1562           G_UNLOCK (time_zones);
1563           return tz;
1564         }
1565     }
1566 
1567   tz = g_slice_new0 (GTimeZone);
1568   tz-&gt;ref_count = 0;
1569 
1570   zone_for_constant_offset (tz, identifier);
1571 
1572   if (tz-&gt;t_info == NULL &amp;&amp;
1573       (rules_num = rules_from_identifier (identifier, &amp;resolved_identifier, &amp;rules)))
1574     {
1575       init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1576       g_free (rules);
1577     }
1578 
1579   if (tz-&gt;t_info == NULL)
1580     {
1581 #ifdef G_OS_UNIX
1582       GBytes *zoneinfo = zone_info_unix (identifier, &amp;resolved_identifier);
1583       if (zoneinfo != NULL)
1584         {
1585           init_zone_from_iana_info (tz, zoneinfo, g_steal_pointer (&amp;resolved_identifier));
1586           g_bytes_unref (zoneinfo);
1587         }
1588 #elif defined (G_OS_WIN32)
1589       if ((rules_num = rules_from_windows_time_zone (identifier,
1590                                                      &amp;resolved_identifier,
<a name="61" id="anc61"></a><span class="line-modified">1591                                                      &amp;rules,</span>
<span class="line-added">1592                                                      TRUE)))</span>
1593         {
1594           init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1595           g_free (rules);
1596         }
1597 #endif
1598     }
1599 
1600 #if defined (G_OS_WIN32)
1601   if (tz-&gt;t_info == NULL)
1602     {
1603       if (identifier == NULL)
1604         {
1605           TIME_ZONE_INFORMATION tzi;
1606 
1607           if (GetTimeZoneInformation (&amp;tzi) != TIME_ZONE_ID_INVALID)
1608             {
1609               rules = g_new0 (TimeZoneRule, 2);
1610 
<a name="62" id="anc62"></a><span class="line-modified">1611               if (rule_from_windows_time_zone_info (&amp;rules[0], &amp;tzi))</span>
<span class="line-modified">1612                 {</span>
<span class="line-modified">1613                   memset (rules[0].std_name, 0, NAME_SIZE);</span>
<span class="line-modified">1614                   memset (rules[0].dlt_name, 0, NAME_SIZE);</span>
1615 
<a name="63" id="anc63"></a><span class="line-modified">1616                   rules[0].start_year = MIN_TZYEAR;</span>
<span class="line-modified">1617                   rules[1].start_year = MAX_TZYEAR;</span>
1618 
<a name="64" id="anc64"></a><span class="line-modified">1619                   init_zone_from_rules (tz, rules, 2, windows_default_tzname ());</span>
<span class="line-added">1620                 }</span>
1621 
1622               g_free (rules);
1623             }
1624         }
1625     }
1626 #endif
1627 
1628   g_free (resolved_identifier);
1629 
1630   /* Always fall back to UTC. */
1631   if (tz-&gt;t_info == NULL)
1632     zone_for_constant_offset (tz, &quot;UTC&quot;);
1633 
1634   g_assert (tz-&gt;name != NULL);
1635   g_assert (tz-&gt;t_info != NULL);
1636 
1637   if (tz-&gt;t_info != NULL)
1638     {
1639       if (identifier)
1640         g_hash_table_insert (time_zones, tz-&gt;name, tz);
1641     }
1642   g_atomic_int_inc (&amp;tz-&gt;ref_count);
1643   G_UNLOCK (time_zones);
1644 
1645   return tz;
1646 }
1647 
1648 /**
1649  * g_time_zone_new_utc:
1650  *
1651  * Creates a #GTimeZone corresponding to UTC.
1652  *
1653  * This is equivalent to calling g_time_zone_new() with a value like
1654  * &quot;Z&quot;, &quot;UTC&quot;, &quot;+00&quot;, etc.
1655  *
1656  * You should release the return value by calling g_time_zone_unref()
1657  * when you are done with it.
1658  *
1659  * Returns: the universal timezone
1660  *
1661  * Since: 2.26
1662  **/
1663 GTimeZone *
1664 g_time_zone_new_utc (void)
1665 {
1666   return g_time_zone_new (&quot;UTC&quot;);
1667 }
1668 
1669 /**
1670  * g_time_zone_new_local:
1671  *
1672  * Creates a #GTimeZone corresponding to local time.  The local time
1673  * zone may change between invocations to this function; for example,
1674  * if the system administrator changes it.
1675  *
1676  * This is equivalent to calling g_time_zone_new() with the value of
1677  * the `TZ` environment variable (including the possibility of %NULL).
1678  *
1679  * You should release the return value by calling g_time_zone_unref()
1680  * when you are done with it.
1681  *
1682  * Returns: the local timezone
1683  *
1684  * Since: 2.26
1685  **/
1686 GTimeZone *
1687 g_time_zone_new_local (void)
1688 {
1689   return g_time_zone_new (getenv (&quot;TZ&quot;));
1690 }
1691 
1692 /**
1693  * g_time_zone_new_offset:
1694  * @seconds: offset to UTC, in seconds
1695  *
1696  * Creates a #GTimeZone corresponding to the given constant offset from UTC,
1697  * in seconds.
1698  *
1699  * This is equivalent to calling g_time_zone_new() with a string in the form
1700  * `[+|-]hh[:mm[:ss]]`.
1701  *
1702  * Returns: (transfer full): a timezone at the given offset from UTC
1703  * Since: 2.58
1704  */
1705 GTimeZone *
1706 g_time_zone_new_offset (gint32 seconds)
1707 {
1708   GTimeZone *tz = NULL;
1709   gchar *identifier = NULL;
1710 
1711   /* Seemingly, we should be using @seconds directly to set the
1712    * #TransitionInfo.gmt_offset to avoid all this string building and parsing.
1713    * However, we always need to set the #GTimeZone.name to a constructed
1714    * string anyway, so we might as well reuse its code. */
1715   identifier = g_strdup_printf (&quot;%c%02u:%02u:%02u&quot;,
1716                                 (seconds &gt;= 0) ? &#39;+&#39; : &#39;-&#39;,
1717                                 (ABS (seconds) / 60) / 60,
1718                                 (ABS (seconds) / 60) % 60,
1719                                 ABS (seconds) % 60);
1720   tz = g_time_zone_new (identifier);
1721   g_free (identifier);
1722 
1723   g_assert (g_time_zone_get_offset (tz, 0) == seconds);
1724 
1725   return tz;
1726 }
1727 
1728 #define TRANSITION(n)         g_array_index (tz-&gt;transitions, Transition, n)
1729 #define TRANSITION_INFO(n)    g_array_index (tz-&gt;t_info, TransitionInfo, n)
1730 
1731 /* Internal helpers {{{1 */
1732 /* NB: Interval 0 is before the first transition, so there&#39;s no
1733  * transition structure to point to which TransitionInfo to
1734  * use. Rule-based zones are set up so that TI 0 is always standard
1735  * time (which is what&#39;s in effect before Daylight time got started
1736  * in the early 20th century), but IANA tzfiles don&#39;t follow that
1737  * convention. The tzfile documentation says to use the first
1738  * standard-time (i.e., non-DST) tinfo, so that&#39;s what we do.
1739  */
1740 inline static const TransitionInfo*
1741 interval_info (GTimeZone *tz,
1742                guint      interval)
1743 {
1744   guint index;
1745   g_return_val_if_fail (tz-&gt;t_info != NULL, NULL);
1746   if (interval &amp;&amp; tz-&gt;transitions &amp;&amp; interval &lt;= tz-&gt;transitions-&gt;len)
1747     index = (TRANSITION(interval - 1)).info_index;
1748   else
1749     {
1750       for (index = 0; index &lt; tz-&gt;t_info-&gt;len; index++)
1751         {
1752           TransitionInfo *tzinfo = &amp;(TRANSITION_INFO(index));
1753           if (!tzinfo-&gt;is_dst)
1754             return tzinfo;
1755         }
1756       index = 0;
1757     }
1758 
1759   return &amp;(TRANSITION_INFO(index));
1760 }
1761 
1762 inline static gint64
1763 interval_start (GTimeZone *tz,
1764                 guint      interval)
1765 {
1766   if (!interval || tz-&gt;transitions == NULL || tz-&gt;transitions-&gt;len == 0)
1767     return G_MININT64;
1768   if (interval &gt; tz-&gt;transitions-&gt;len)
1769     interval = tz-&gt;transitions-&gt;len;
1770   return (TRANSITION(interval - 1)).time;
1771 }
1772 
1773 inline static gint64
1774 interval_end (GTimeZone *tz,
1775               guint      interval)
1776 {
1777   if (tz-&gt;transitions &amp;&amp; interval &lt; tz-&gt;transitions-&gt;len)
1778     {
1779       gint64 lim = (TRANSITION(interval)).time;
1780       return lim - (lim != G_MININT64);
1781     }
1782   return G_MAXINT64;
1783 }
1784 
1785 inline static gint32
1786 interval_offset (GTimeZone *tz,
1787                  guint      interval)
1788 {
1789   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1790   return interval_info (tz, interval)-&gt;gmt_offset;
1791 }
1792 
1793 inline static gboolean
1794 interval_isdst (GTimeZone *tz,
1795                 guint      interval)
1796 {
1797   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1798   return interval_info (tz, interval)-&gt;is_dst;
1799 }
1800 
1801 
1802 inline static gchar*
1803 interval_abbrev (GTimeZone *tz,
1804                   guint      interval)
1805 {
1806   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1807   return interval_info (tz, interval)-&gt;abbrev;
1808 }
1809 
1810 inline static gint64
1811 interval_local_start (GTimeZone *tz,
1812                       guint      interval)
1813 {
1814   if (interval)
1815     return interval_start (tz, interval) + interval_offset (tz, interval);
1816 
1817   return G_MININT64;
1818 }
1819 
1820 inline static gint64
1821 interval_local_end (GTimeZone *tz,
1822                     guint      interval)
1823 {
1824   if (tz-&gt;transitions &amp;&amp; interval &lt; tz-&gt;transitions-&gt;len)
1825     return interval_end (tz, interval) + interval_offset (tz, interval);
1826 
1827   return G_MAXINT64;
1828 }
1829 
1830 static gboolean
1831 interval_valid (GTimeZone *tz,
1832                 guint      interval)
1833 {
1834   if ( tz-&gt;transitions == NULL)
1835     return interval == 0;
1836   return interval &lt;= tz-&gt;transitions-&gt;len;
1837 }
1838 
1839 /* g_time_zone_find_interval() {{{1 */
1840 
1841 /**
1842  * g_time_zone_adjust_time:
1843  * @tz: a #GTimeZone
1844  * @type: the #GTimeType of @time_
1845  * @time_: a pointer to a number of seconds since January 1, 1970
1846  *
1847  * Finds an interval within @tz that corresponds to the given @time_,
1848  * possibly adjusting @time_ if required to fit into an interval.
1849  * The meaning of @time_ depends on @type.
1850  *
1851  * This function is similar to g_time_zone_find_interval(), with the
1852  * difference that it always succeeds (by making the adjustments
1853  * described below).
1854  *
1855  * In any of the cases where g_time_zone_find_interval() succeeds then
1856  * this function returns the same value, without modifying @time_.
1857  *
1858  * This function may, however, modify @time_ in order to deal with
1859  * non-existent times.  If the non-existent local @time_ of 02:30 were
1860  * requested on March 14th 2010 in Toronto then this function would
1861  * adjust @time_ to be 03:00 and return the interval containing the
1862  * adjusted time.
1863  *
1864  * Returns: the interval containing @time_, never -1
1865  *
1866  * Since: 2.26
1867  **/
1868 gint
1869 g_time_zone_adjust_time (GTimeZone *tz,
1870                          GTimeType  type,
1871                          gint64    *time_)
1872 {
<a name="65" id="anc65"></a><span class="line-modified">1873   guint i, intervals;</span>
<span class="line-modified">1874   gboolean interval_is_dst;</span>
1875 
1876   if (tz-&gt;transitions == NULL)
1877     return 0;
1878 
1879   intervals = tz-&gt;transitions-&gt;len;
1880 
1881   /* find the interval containing *time UTC
1882    * TODO: this could be binary searched (or better) */
1883   for (i = 0; i &lt;= intervals; i++)
1884     if (*time_ &lt;= interval_end (tz, i))
1885       break;
1886 
1887   g_assert (interval_start (tz, i) &lt;= *time_ &amp;&amp; *time_ &lt;= interval_end (tz, i));
1888 
1889   if (type != G_TIME_TYPE_UNIVERSAL)
1890     {
1891       if (*time_ &lt; interval_local_start (tz, i))
1892         /* if time came before the start of this interval... */
1893         {
1894           i--;
1895 
1896           /* if it&#39;s not in the previous interval... */
1897           if (*time_ &gt; interval_local_end (tz, i))
1898             {
1899               /* it doesn&#39;t exist.  fast-forward it. */
1900               i++;
1901               *time_ = interval_local_start (tz, i);
1902             }
1903         }
1904 
1905       else if (*time_ &gt; interval_local_end (tz, i))
1906         /* if time came after the end of this interval... */
1907         {
1908           i++;
1909 
1910           /* if it&#39;s not in the next interval... */
1911           if (*time_ &lt; interval_local_start (tz, i))
1912             /* it doesn&#39;t exist.  fast-forward it. */
1913             *time_ = interval_local_start (tz, i);
1914         }
1915 
<a name="66" id="anc66"></a><span class="line-modified">1916       else</span>


1917         {
<a name="67" id="anc67"></a><span class="line-modified">1918           interval_is_dst = interval_isdst (tz, i);</span>
<span class="line-modified">1919           if ((interval_is_dst &amp;&amp; type != G_TIME_TYPE_DAYLIGHT) ||</span>
<span class="line-modified">1920               (!interval_is_dst &amp;&amp; type == G_TIME_TYPE_DAYLIGHT))</span>
<span class="line-modified">1921             {</span>
<span class="line-modified">1922               /* it&#39;s in this interval, but dst flag doesn&#39;t match.</span>
<span class="line-modified">1923                * check neighbours for a better fit. */</span>
<span class="line-added">1924               if (i &amp;&amp; *time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-added">1925                 i--;</span>
<span class="line-added">1926 </span>
<span class="line-added">1927               else if (i &lt; intervals &amp;&amp;</span>
<span class="line-added">1928                        *time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-added">1929                 i++;</span>
<span class="line-added">1930             }</span>
1931         }
1932     }
1933 
1934   return i;
1935 }
1936 
1937 /**
1938  * g_time_zone_find_interval:
1939  * @tz: a #GTimeZone
1940  * @type: the #GTimeType of @time_
1941  * @time_: a number of seconds since January 1, 1970
1942  *
<a name="68" id="anc68"></a><span class="line-modified">1943  * Finds an interval within @tz that corresponds to the given @time_.</span>
1944  * The meaning of @time_ depends on @type.
1945  *
1946  * If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
1947  * succeed (since universal time is monotonic and continuous).
1948  *
1949  * Otherwise @time_ is treated as local time.  The distinction between
1950  * %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
1951  * the case that the given @time_ is ambiguous.  In Toronto, for example,
1952  * 01:30 on November 7th 2010 occurred twice (once inside of daylight
1953  * savings time and the next, an hour later, outside of daylight savings
1954  * time).  In this case, the different value of @type would result in a
1955  * different interval being returned.
1956  *
1957  * It is still possible for this function to fail.  In Toronto, for
1958  * example, 02:00 on March 14th 2010 does not exist (due to the leap
1959  * forward to begin daylight savings time).  -1 is returned in that
1960  * case.
1961  *
1962  * Returns: the interval containing @time_, or -1 in case of failure
1963  *
1964  * Since: 2.26
1965  */
1966 gint
1967 g_time_zone_find_interval (GTimeZone *tz,
1968                            GTimeType  type,
1969                            gint64     time_)
1970 {
<a name="69" id="anc69"></a><span class="line-modified">1971   guint i, intervals;</span>
<span class="line-modified">1972   gboolean interval_is_dst;</span>
1973 
1974   if (tz-&gt;transitions == NULL)
1975     return 0;
1976   intervals = tz-&gt;transitions-&gt;len;
1977   for (i = 0; i &lt;= intervals; i++)
1978     if (time_ &lt;= interval_end (tz, i))
1979       break;
1980 
1981   if (type == G_TIME_TYPE_UNIVERSAL)
1982     return i;
1983 
1984   if (time_ &lt; interval_local_start (tz, i))
1985     {
1986       if (time_ &gt; interval_local_end (tz, --i))
1987         return -1;
1988     }
1989 
1990   else if (time_ &gt; interval_local_end (tz, i))
1991     {
1992       if (time_ &lt; interval_local_start (tz, ++i))
1993         return -1;
1994     }
1995 
<a name="70" id="anc70"></a><span class="line-modified">1996   else</span>
1997     {
<a name="71" id="anc71"></a><span class="line-modified">1998       interval_is_dst = interval_isdst (tz, i);</span>
<span class="line-modified">1999       if  ((interval_is_dst &amp;&amp; type != G_TIME_TYPE_DAYLIGHT) ||</span>
<span class="line-added">2000            (!interval_is_dst &amp;&amp; type == G_TIME_TYPE_DAYLIGHT))</span>
<span class="line-added">2001         {</span>
<span class="line-added">2002           if (i &amp;&amp; time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-added">2003             i--;</span>
2004 
<a name="72" id="anc72"></a><span class="line-modified">2005           else if (i &lt; intervals &amp;&amp; time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-modified">2006             i++;</span>
<span class="line-added">2007         }</span>
2008     }
2009 
2010   return i;
2011 }
2012 
2013 /* Public API accessors {{{1 */
2014 
2015 /**
2016  * g_time_zone_get_abbreviation:
2017  * @tz: a #GTimeZone
2018  * @interval: an interval within the timezone
2019  *
2020  * Determines the time zone abbreviation to be used during a particular
2021  * @interval of time in the time zone @tz.
2022  *
2023  * For example, in Toronto this is currently &quot;EST&quot; during the winter
2024  * months and &quot;EDT&quot; during the summer months when daylight savings time
2025  * is in effect.
2026  *
2027  * Returns: the time zone abbreviation, which belongs to @tz
2028  *
2029  * Since: 2.26
2030  **/
2031 const gchar *
2032 g_time_zone_get_abbreviation (GTimeZone *tz,
2033                               gint       interval)
2034 {
2035   g_return_val_if_fail (interval_valid (tz, (guint)interval), NULL);
2036 
2037   return interval_abbrev (tz, (guint)interval);
2038 }
2039 
2040 /**
2041  * g_time_zone_get_offset:
2042  * @tz: a #GTimeZone
2043  * @interval: an interval within the timezone
2044  *
2045  * Determines the offset to UTC in effect during a particular @interval
2046  * of time in the time zone @tz.
2047  *
2048  * The offset is the number of seconds that you add to UTC time to
2049  * arrive at local time for @tz (ie: negative numbers for time zones
2050  * west of GMT, positive numbers for east).
2051  *
2052  * Returns: the number of seconds that should be added to UTC to get the
2053  *          local time in @tz
2054  *
2055  * Since: 2.26
2056  **/
2057 gint32
2058 g_time_zone_get_offset (GTimeZone *tz,
2059                         gint       interval)
2060 {
2061   g_return_val_if_fail (interval_valid (tz, (guint)interval), 0);
2062 
2063   return interval_offset (tz, (guint)interval);
2064 }
2065 
2066 /**
2067  * g_time_zone_is_dst:
2068  * @tz: a #GTimeZone
2069  * @interval: an interval within the timezone
2070  *
2071  * Determines if daylight savings time is in effect during a particular
2072  * @interval of time in the time zone @tz.
2073  *
2074  * Returns: %TRUE if daylight savings time is in effect
2075  *
2076  * Since: 2.26
2077  **/
2078 gboolean
2079 g_time_zone_is_dst (GTimeZone *tz,
2080                     gint       interval)
2081 {
2082   g_return_val_if_fail (interval_valid (tz, interval), FALSE);
2083 
2084   if (tz-&gt;transitions == NULL)
2085     return FALSE;
2086 
2087   return interval_isdst (tz, (guint)interval);
2088 }
2089 
2090 /**
2091  * g_time_zone_get_identifier:
2092  * @tz: a #GTimeZone
2093  *
2094  * Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
2095  * If the identifier passed at construction time was not recognised, `UTC` will
2096  * be returned. If it was %NULL, the identifier of the local timezone at
2097  * construction time will be returned.
2098  *
2099  * The identifier will be returned in the same format as provided at
2100  * construction time: if provided as a time offset, that will be returned by
2101  * this function.
2102  *
2103  * Returns: identifier for this timezone
2104  * Since: 2.58
2105  */
2106 const gchar *
2107 g_time_zone_get_identifier (GTimeZone *tz)
2108 {
2109   g_return_val_if_fail (tz != NULL, NULL);
2110 
2111   return tz-&gt;name;
2112 }
2113 
2114 /* Epilogue {{{1 */
2115 /* vim:set foldmethod=marker: */
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>