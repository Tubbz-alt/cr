<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-converter.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2005 Wim Taymans &lt;wim at fluendo dot com&gt;
   3  *           (C) 2015 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   4  *
   5  * audioconverter.c: Convert audio to different audio formats automatically
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 #ifdef HAVE_CONFIG_H
  24 #include &quot;config.h&quot;
  25 #endif
  26 
  27 #include &lt;math.h&gt;
  28 #include &lt;string.h&gt;
  29 
  30 #include &quot;audio-converter.h&quot;
  31 #include &quot;gstaudiopack.h&quot;
  32 
  33 /**
  34  * SECTION:audioconverter
  35  * @title: GstAudioConverter
  36  * @short_description: Generic audio conversion
  37  *
  38  * This object is used to convert audio samples from one format to another.
  39  * The object can perform conversion of:
  40  *
  41  *  * audio format with optional dithering and noise shaping
  42  *
  43  *  * audio samplerate
  44  *
  45  *  * audio channels and channel layout
  46  *
  47  */
  48 
  49 #ifndef GST_DISABLE_GST_DEBUG
  50 #define GST_CAT_DEFAULT ensure_debug_category()
  51 static GstDebugCategory *
  52 ensure_debug_category (void)
  53 {
  54   static gsize cat_gonce = 0;
  55 
  56   if (g_once_init_enter (&amp;cat_gonce)) {
  57     gsize cat_done;
  58 
  59     cat_done = (gsize) _gst_debug_category_new (&quot;audio-converter&quot;, 0,
  60         &quot;audio-converter object&quot;);
  61 
  62     g_once_init_leave (&amp;cat_gonce, cat_done);
  63   }
  64 
  65   return (GstDebugCategory *) cat_gonce;
  66 }
  67 #else
  68 #define ensure_debug_category() /* NOOP */
  69 #endif /* GST_DISABLE_GST_DEBUG */
  70 
  71 typedef struct _AudioChain AudioChain;
  72 
  73 typedef void (*AudioConvertFunc) (gpointer dst, const gpointer src, gint count);
  74 typedef gboolean (*AudioConvertSamplesFunc) (GstAudioConverter * convert,
  75     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
  76     gpointer out[], gsize out_frames);
  77 typedef void (*AudioConvertEndianFunc) (gpointer dst, const gpointer src,
  78     gint count);
  79 
  80 /*                           int/int    int/float  float/int float/float
  81  *
  82  *  unpack                     S32          S32         F64       F64
  83  *  convert                               S32-&gt;F64
  84  *  channel mix                S32          F64         F64       F64
  85  *  convert                                           F64-&gt;S32
  86  *  quantize                   S32                      S32
  87  *  pack                       S32          F64         S32       F64
  88  *
  89  *
  90  *  interleave
  91  *  deinterleave
  92  *  resample
  93  */
  94 struct _GstAudioConverter
  95 {
  96   GstAudioInfo in;
  97   GstAudioInfo out;
  98 
  99   GstStructure *config;
 100 
 101   GstAudioConverterFlags flags;
 102   GstAudioFormat current_format;
 103   GstAudioLayout current_layout;
 104   gint current_channels;
 105 
 106   gboolean in_writable;
 107   gpointer *in_data;
 108   gsize in_frames;
 109   gpointer *out_data;
 110   gsize out_frames;
 111 
 112   gboolean in_place;            /* the conversion can be done in place; returned by gst_audio_converter_supports_inplace() */
 113 
 114   /* unpack */
 115   gboolean in_default;
 116   gboolean unpack_ip;
 117 
 118   /* convert in */
 119   AudioConvertFunc convert_in;
 120 
 121   /* channel mix */
 122   gboolean mix_passthrough;
 123   GstAudioChannelMixer *mix;
 124 
 125   /* resample */
 126   GstAudioResampler *resampler;
 127 
 128   /* convert out */
 129   AudioConvertFunc convert_out;
 130 
 131   /* quant */
 132   GstAudioQuantize *quant;
 133 
 134   /* pack */
 135   gboolean out_default;
 136   AudioChain *chain_end;        /* NULL for empty chain or points to the last element in the chain */
 137 
 138   /* endian swap */
 139   AudioConvertEndianFunc swap_endian;
 140 
 141   AudioConvertSamplesFunc convert;
 142 };
 143 
 144 static GstAudioConverter *
 145 gst_audio_converter_copy (GstAudioConverter * convert)
 146 {
 147   GstAudioConverter *res =
 148       gst_audio_converter_new (convert-&gt;flags, &amp;convert-&gt;in, &amp;convert-&gt;out,
 149       convert-&gt;config);
 150 
 151   return res;
 152 }
 153 
 154 G_DEFINE_BOXED_TYPE (GstAudioConverter, gst_audio_converter,
 155     (GBoxedCopyFunc) gst_audio_converter_copy,
 156     (GBoxedFreeFunc) gst_audio_converter_free);
 157 
 158 typedef gboolean (*AudioChainFunc) (AudioChain * chain, gpointer user_data);
 159 typedef gpointer *(*AudioChainAllocFunc) (AudioChain * chain, gsize num_samples,
 160     gpointer user_data);
 161 
 162 struct _AudioChain
 163 {
 164   AudioChain *prev;
 165 
 166   AudioChainFunc make_func;
 167   gpointer make_func_data;
 168   GDestroyNotify make_func_notify;
 169 
 170   const GstAudioFormatInfo *finfo;
 171   gint stride;
 172   gint inc;
 173   gint blocks;
 174 
 175   gboolean pass_alloc;
 176   gboolean allow_ip;
 177 
 178   AudioChainAllocFunc alloc_func;
 179   gpointer alloc_data;
 180 
 181   gpointer *tmp;
 182   gsize allocated_samples;
 183 
 184   gpointer *samples;
 185   gsize num_samples;
 186 };
 187 
 188 static AudioChain *
 189 audio_chain_new (AudioChain * prev, GstAudioConverter * convert)
 190 {
 191   AudioChain *chain;
 192 
 193   chain = g_slice_new0 (AudioChain);
 194   chain-&gt;prev = prev;
 195 
 196   if (convert-&gt;current_layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {
 197     chain-&gt;inc = 1;
 198     chain-&gt;blocks = convert-&gt;current_channels;
 199   } else {
 200     chain-&gt;inc = convert-&gt;current_channels;
 201     chain-&gt;blocks = 1;
 202   }
 203   chain-&gt;finfo = gst_audio_format_get_info (convert-&gt;current_format);
 204   chain-&gt;stride = (chain-&gt;finfo-&gt;width * chain-&gt;inc) / 8;
 205 
 206   return chain;
 207 }
 208 
 209 static void
 210 audio_chain_set_make_func (AudioChain * chain,
 211     AudioChainFunc make_func, gpointer user_data, GDestroyNotify notify)
 212 {
 213   chain-&gt;make_func = make_func;
 214   chain-&gt;make_func_data = user_data;
 215   chain-&gt;make_func_notify = notify;
 216 }
 217 
 218 static void
 219 audio_chain_free (AudioChain * chain)
 220 {
 221   GST_LOG (&quot;free chain %p&quot;, chain);
 222   if (chain-&gt;make_func_notify)
 223     chain-&gt;make_func_notify (chain-&gt;make_func_data);
 224   g_free (chain-&gt;tmp);
 225   g_slice_free (AudioChain, chain);
 226 }
 227 
 228 static gpointer *
 229 audio_chain_alloc_samples (AudioChain * chain, gsize num_samples)
 230 {
 231   return chain-&gt;alloc_func (chain, num_samples, chain-&gt;alloc_data);
 232 }
 233 
 234 static void
 235 audio_chain_set_samples (AudioChain * chain, gpointer * samples,
 236     gsize num_samples)
 237 {
 238   GST_LOG (&quot;set samples %p %&quot; G_GSIZE_FORMAT, samples, num_samples);
 239 
 240   chain-&gt;samples = samples;
 241   chain-&gt;num_samples = num_samples;
 242 }
 243 
 244 static gpointer *
 245 audio_chain_get_samples (AudioChain * chain, gsize * avail)
 246 {
 247   gpointer *res;
 248 
 249   while (!chain-&gt;samples)
 250     chain-&gt;make_func (chain, chain-&gt;make_func_data);
 251 
 252   res = chain-&gt;samples;
 253   *avail = chain-&gt;num_samples;
 254   chain-&gt;samples = NULL;
 255 
 256   return res;
 257 }
 258 
 259 /*
 260 static guint
 261 get_opt_uint (GstAudioConverter * convert, const gchar * opt, guint def)
 262 {
 263   guint res;
 264   if (!gst_structure_get_uint (convert-&gt;config, opt, &amp;res))
 265     res = def;
 266   return res;
 267 }
 268 */
 269 
 270 static gint
 271 get_opt_enum (GstAudioConverter * convert, const gchar * opt, GType type,
 272     gint def)
 273 {
 274   gint res;
 275   if (!gst_structure_get_enum (convert-&gt;config, opt, type, &amp;res))
 276     res = def;
 277   return res;
 278 }
 279 
 280 static const GValue *
 281 get_opt_value (GstAudioConverter * convert, const gchar * opt)
 282 {
 283   return gst_structure_get_value (convert-&gt;config, opt);
 284 }
 285 
 286 #define DEFAULT_OPT_RESAMPLER_METHOD GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL
 287 #define DEFAULT_OPT_DITHER_METHOD GST_AUDIO_DITHER_NONE
 288 #define DEFAULT_OPT_NOISE_SHAPING_METHOD GST_AUDIO_NOISE_SHAPING_NONE
 289 #define DEFAULT_OPT_QUANTIZATION 1
 290 
 291 #define GET_OPT_RESAMPLER_METHOD(c) get_opt_enum(c, \
 292     GST_AUDIO_CONVERTER_OPT_RESAMPLER_METHOD, GST_TYPE_AUDIO_RESAMPLER_METHOD, \
 293     DEFAULT_OPT_RESAMPLER_METHOD)
 294 #define GET_OPT_DITHER_METHOD(c) get_opt_enum(c, \
 295     GST_AUDIO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_AUDIO_DITHER_METHOD, \
 296     DEFAULT_OPT_DITHER_METHOD)
 297 #define GET_OPT_NOISE_SHAPING_METHOD(c) get_opt_enum(c, \
 298     GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD, GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, \
 299     DEFAULT_OPT_NOISE_SHAPING_METHOD)
 300 #define GET_OPT_QUANTIZATION(c) get_opt_uint(c, \
 301     GST_AUDIO_CONVERTER_OPT_QUANTIZATION, DEFAULT_OPT_QUANTIZATION)
 302 #define GET_OPT_MIX_MATRIX(c) get_opt_value(c, \
 303     GST_AUDIO_CONVERTER_OPT_MIX_MATRIX)
 304 
 305 static gboolean
 306 copy_config (GQuark field_id, const GValue * value, gpointer user_data)
 307 {
 308   GstAudioConverter *convert = user_data;
 309 
 310   gst_structure_id_set_value (convert-&gt;config, field_id, value);
 311 
 312   return TRUE;
 313 }
 314 
 315 /**
 316  * gst_audio_converter_update_config:
 317  * @convert: a #GstAudioConverter
 318  * @in_rate: input rate
 319  * @out_rate: output rate
 320  * @config: (transfer full) (allow-none): a #GstStructure or %NULL
 321  *
 322  * Set @in_rate, @out_rate and @config as extra configuration for @convert.
 323  *
 324  * @in_rate and @out_rate specify the new sample rates of input and output
 325  * formats. A value of 0 leaves the sample rate unchanged.
 326  *
 327  * @config can be %NULL, in which case, the current configuration is not
 328  * changed.
 329  *
 330  * If the parameters in @config can not be set exactly, this function returns
 331  * %FALSE and will try to update as much state as possible. The new state can
 332  * then be retrieved and refined with gst_audio_converter_get_config().
 333  *
 334  * Look at the #GST_AUDIO_CONVERTER_OPT_* fields to check valid configuration
 335  * option and values.
 336  *
 337  * Returns: %TRUE when the new parameters could be set
 338  */
 339 gboolean
 340 gst_audio_converter_update_config (GstAudioConverter * convert,
 341     gint in_rate, gint out_rate, GstStructure * config)
 342 {
 343   g_return_val_if_fail (convert != NULL, FALSE);
 344   g_return_val_if_fail ((in_rate == 0 &amp;&amp; out_rate == 0) ||
 345       convert-&gt;flags &amp; GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE, FALSE);
 346 
 347   GST_LOG (&quot;new rate %d -&gt; %d&quot;, in_rate, out_rate);
 348 
 349   if (in_rate &lt;= 0)
 350     in_rate = convert-&gt;in.rate;
 351   if (out_rate &lt;= 0)
 352     out_rate = convert-&gt;out.rate;
 353 
 354   convert-&gt;in.rate = in_rate;
 355   convert-&gt;out.rate = out_rate;
 356 
 357   if (convert-&gt;resampler)
 358     gst_audio_resampler_update (convert-&gt;resampler, in_rate, out_rate, config);
 359 
 360   if (config) {
 361     gst_structure_foreach (config, copy_config, convert);
 362     gst_structure_free (config);
 363   }
 364 
 365   return TRUE;
 366 }
 367 
 368 /**
 369  * gst_audio_converter_get_config:
 370  * @convert: a #GstAudioConverter
 371  * @in_rate: (out) (optional): result input rate
 372  * @out_rate: (out) (optional): result output rate
 373  *
 374  * Get the current configuration of @convert.
 375  *
 376  * Returns: (transfer none):
 377  *   a #GstStructure that remains valid for as long as @convert is valid
 378  *   or until gst_audio_converter_update_config() is called.
 379  */
 380 const GstStructure *
 381 gst_audio_converter_get_config (GstAudioConverter * convert,
 382     gint * in_rate, gint * out_rate)
 383 {
 384   g_return_val_if_fail (convert != NULL, NULL);
 385 
 386   if (in_rate)
 387     *in_rate = convert-&gt;in.rate;
 388   if (out_rate)
 389     *out_rate = convert-&gt;out.rate;
 390 
 391   return convert-&gt;config;
 392 }
 393 
 394 static gpointer *
 395 get_output_samples (AudioChain * chain, gsize num_samples, gpointer user_data)
 396 {
 397   GstAudioConverter *convert = user_data;
 398 
 399   GST_LOG (&quot;output samples %p %&quot; G_GSIZE_FORMAT, convert-&gt;out_data,
 400       num_samples);
 401 
 402   return convert-&gt;out_data;
 403 }
 404 
 405 #define MEM_ALIGN(m,a) ((gint8 *)((guintptr)((gint8 *)(m) + ((a)-1)) &amp; ~((a)-1)))
 406 #define ALIGN 16
 407 
 408 static gpointer *
 409 get_temp_samples (AudioChain * chain, gsize num_samples, gpointer user_data)
 410 {
 411   if (num_samples &gt; chain-&gt;allocated_samples) {
 412     gint i;
 413     gint8 *s;
 414     gsize stride = GST_ROUND_UP_N (num_samples * chain-&gt;stride, ALIGN);
 415     /* first part contains the pointers, second part the data, add some extra bytes
 416      * for alignement */
 417     gsize needed = (stride + sizeof (gpointer)) * chain-&gt;blocks + ALIGN - 1;
 418 
 419     GST_DEBUG (&quot;alloc samples %d %&quot; G_GSIZE_FORMAT &quot; %&quot; G_GSIZE_FORMAT,
 420         chain-&gt;stride, num_samples, needed);
 421     chain-&gt;tmp = g_realloc (chain-&gt;tmp, needed);
 422     chain-&gt;allocated_samples = num_samples;
 423 
 424     /* pointer to the data, make sure it&#39;s 16 bytes aligned */
 425     s = MEM_ALIGN (&amp;chain-&gt;tmp[chain-&gt;blocks], ALIGN);
 426 
 427     /* set up the pointers */
 428     for (i = 0; i &lt; chain-&gt;blocks; i++)
 429       chain-&gt;tmp[i] = s + i * stride;
 430   }
 431   GST_LOG (&quot;temp samples %p %&quot; G_GSIZE_FORMAT, chain-&gt;tmp, num_samples);
 432 
 433   return chain-&gt;tmp;
 434 }
 435 
 436 static gboolean
 437 do_unpack (AudioChain * chain, gpointer user_data)
 438 {
 439   GstAudioConverter *convert = user_data;
 440   gsize num_samples;
 441   gpointer *tmp;
 442   gboolean in_writable;
 443 
 444   in_writable = convert-&gt;in_writable;
 445   num_samples = convert-&gt;in_frames;
 446 
 447   if (!chain-&gt;allow_ip || !in_writable || !convert-&gt;in_default) {
 448     gint i;
 449 
 450     if (in_writable &amp;&amp; chain-&gt;allow_ip) {
 451       tmp = convert-&gt;in_data;
 452       GST_LOG (&quot;unpack in-place %p, %&quot; G_GSIZE_FORMAT, tmp, num_samples);
 453     } else {
 454       tmp = audio_chain_alloc_samples (chain, num_samples);
 455       GST_LOG (&quot;unpack to tmp %p, %&quot; G_GSIZE_FORMAT, tmp, num_samples);
 456     }
 457 
 458     if (convert-&gt;in_data) {
 459       for (i = 0; i &lt; chain-&gt;blocks; i++) {
 460         if (convert-&gt;in_default) {
 461           GST_LOG (&quot;copy %p, %p, %&quot; G_GSIZE_FORMAT, tmp[i], convert-&gt;in_data[i],
 462               num_samples);
 463           memcpy (tmp[i], convert-&gt;in_data[i], num_samples * chain-&gt;stride);
 464         } else {
 465           GST_LOG (&quot;unpack %p, %p, %&quot; G_GSIZE_FORMAT, tmp[i],
 466               convert-&gt;in_data[i], num_samples);
 467           convert-&gt;in.finfo-&gt;unpack_func (convert-&gt;in.finfo,
 468               GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE, tmp[i], convert-&gt;in_data[i],
 469               num_samples * chain-&gt;inc);
 470         }
 471       }
 472     } else {
 473       for (i = 0; i &lt; chain-&gt;blocks; i++) {
 474         gst_audio_format_fill_silence (chain-&gt;finfo, tmp[i],
 475             num_samples * chain-&gt;inc);
 476       }
 477     }
 478   } else {
 479     tmp = convert-&gt;in_data;
 480     GST_LOG (&quot;get in samples %p&quot;, tmp);
 481   }
 482   audio_chain_set_samples (chain, tmp, num_samples);
 483 
 484   return TRUE;
 485 }
 486 
 487 static gboolean
 488 do_convert_in (AudioChain * chain, gpointer user_data)
 489 {
 490   gsize num_samples;
 491   GstAudioConverter *convert = user_data;
 492   gpointer *in, *out;
 493   gint i;
 494 
 495   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 496   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 497   GST_LOG (&quot;convert in %p, %p, %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 498 
 499   for (i = 0; i &lt; chain-&gt;blocks; i++)
 500     convert-&gt;convert_in (out[i], in[i], num_samples * chain-&gt;inc);
 501 
 502   audio_chain_set_samples (chain, out, num_samples);
 503 
 504   return TRUE;
 505 }
 506 
 507 static gboolean
 508 do_mix (AudioChain * chain, gpointer user_data)
 509 {
 510   gsize num_samples;
 511   GstAudioConverter *convert = user_data;
 512   gpointer *in, *out;
 513 
 514   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 515   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 516   GST_LOG (&quot;mix %p, %p, %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 517 
 518   gst_audio_channel_mixer_samples (convert-&gt;mix, in, out, num_samples);
 519 
 520   audio_chain_set_samples (chain, out, num_samples);
 521 
 522   return TRUE;
 523 }
 524 
 525 static gboolean
 526 do_resample (AudioChain * chain, gpointer user_data)
 527 {
 528   GstAudioConverter *convert = user_data;
 529   gpointer *in, *out;
 530   gsize in_frames, out_frames;
 531 
 532   in = audio_chain_get_samples (chain-&gt;prev, &amp;in_frames);
 533   out_frames = convert-&gt;out_frames;
 534   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, out_frames));
 535 
 536   GST_LOG (&quot;resample %p %p,%&quot; G_GSIZE_FORMAT &quot; %&quot; G_GSIZE_FORMAT, in,
 537       out, in_frames, out_frames);
 538 
 539   gst_audio_resampler_resample (convert-&gt;resampler, in, in_frames, out,
 540       out_frames);
 541 
 542   audio_chain_set_samples (chain, out, out_frames);
 543 
 544   return TRUE;
 545 }
 546 
 547 static gboolean
 548 do_convert_out (AudioChain * chain, gpointer user_data)
 549 {
 550   GstAudioConverter *convert = user_data;
 551   gsize num_samples;
 552   gpointer *in, *out;
 553   gint i;
 554 
 555   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 556   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 557   GST_LOG (&quot;convert out %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 558 
 559   for (i = 0; i &lt; chain-&gt;blocks; i++)
 560     convert-&gt;convert_out (out[i], in[i], num_samples * chain-&gt;inc);
 561 
 562   audio_chain_set_samples (chain, out, num_samples);
 563 
 564   return TRUE;
 565 }
 566 
 567 static gboolean
 568 do_quantize (AudioChain * chain, gpointer user_data)
 569 {
 570   GstAudioConverter *convert = user_data;
 571   gsize num_samples;
 572   gpointer *in, *out;
 573 
 574   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 575   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 576   GST_LOG (&quot;quantize %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 577 
 578   gst_audio_quantize_samples (convert-&gt;quant, in, out, num_samples);
 579 
 580   audio_chain_set_samples (chain, out, num_samples);
 581 
 582   return TRUE;
 583 }
 584 
 585 static gboolean
 586 is_intermediate_format (GstAudioFormat format)
 587 {
 588   return (format == GST_AUDIO_FORMAT_S16 ||
 589       format == GST_AUDIO_FORMAT_S32 ||
 590       format == GST_AUDIO_FORMAT_F32 || format == GST_AUDIO_FORMAT_F64);
 591 }
 592 
 593 static AudioChain *
 594 chain_unpack (GstAudioConverter * convert)
 595 {
 596   AudioChain *prev;
 597   GstAudioInfo *in = &amp;convert-&gt;in;
 598   GstAudioInfo *out = &amp;convert-&gt;out;
 599   gboolean same_format;
 600 
 601   same_format = in-&gt;finfo-&gt;format == out-&gt;finfo-&gt;format;
 602 
 603   /* do not unpack if we have the same input format as the output format
 604    * and it is a possible intermediate format */
 605   if (same_format &amp;&amp; is_intermediate_format (in-&gt;finfo-&gt;format)) {
 606     convert-&gt;current_format = in-&gt;finfo-&gt;format;
 607   } else {
 608     convert-&gt;current_format = in-&gt;finfo-&gt;unpack_format;
 609   }
 610   convert-&gt;current_layout = in-&gt;layout;
 611   convert-&gt;current_channels = in-&gt;channels;
 612 
 613   convert-&gt;in_default = convert-&gt;current_format == in-&gt;finfo-&gt;format;
 614 
 615   GST_INFO (&quot;unpack format %s to %s&quot;,
 616       gst_audio_format_to_string (in-&gt;finfo-&gt;format),
 617       gst_audio_format_to_string (convert-&gt;current_format));
 618 
 619   prev = audio_chain_new (NULL, convert);
 620   prev-&gt;allow_ip = prev-&gt;finfo-&gt;width &lt;= in-&gt;finfo-&gt;width;
 621   prev-&gt;pass_alloc = FALSE;
 622   audio_chain_set_make_func (prev, do_unpack, convert, NULL);
 623 
 624   return prev;
 625 }
 626 
 627 static AudioChain *
 628 chain_convert_in (GstAudioConverter * convert, AudioChain * prev)
 629 {
 630   gboolean in_int, out_int;
 631   GstAudioInfo *in = &amp;convert-&gt;in;
 632   GstAudioInfo *out = &amp;convert-&gt;out;
 633 
 634   in_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (in-&gt;finfo);
 635   out_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (out-&gt;finfo);
 636 
 637   if (in_int &amp;&amp; !out_int) {
 638     GST_INFO (&quot;convert S32 to F64&quot;);
 639     convert-&gt;convert_in = (AudioConvertFunc) audio_orc_s32_to_double;
 640     convert-&gt;current_format = GST_AUDIO_FORMAT_F64;
 641 
 642     prev = audio_chain_new (prev, convert);
 643     prev-&gt;allow_ip = FALSE;
 644     prev-&gt;pass_alloc = FALSE;
 645     audio_chain_set_make_func (prev, do_convert_in, convert, NULL);
 646   }
 647   return prev;
 648 }
 649 
 650 static gboolean
 651 check_mix_matrix (guint in_channels, guint out_channels, const GValue * value)
 652 {
 653   guint i, j;
 654 
 655   /* audio-channel-mixer will generate an identity matrix */
 656   if (gst_value_array_get_size (value) == 0)
 657     return TRUE;
 658 
 659   if (gst_value_array_get_size (value) != out_channels) {
 660     GST_ERROR (&quot;Invalid mix matrix size, should be %d&quot;, out_channels);
 661     goto fail;
 662   }
 663 
 664   for (j = 0; j &lt; out_channels; j++) {
 665     const GValue *row = gst_value_array_get_value (value, j);
 666 
 667     if (gst_value_array_get_size (row) != in_channels) {
 668       GST_ERROR (&quot;Invalid mix matrix row size, should be %d&quot;, in_channels);
 669       goto fail;
 670     }
 671 
 672     for (i = 0; i &lt; in_channels; i++) {
 673       const GValue *itm;
 674 
 675       itm = gst_value_array_get_value (row, i);
 676       if (!G_VALUE_HOLDS_FLOAT (itm)) {
 677         GST_ERROR (&quot;Invalid mix matrix element type, should be float&quot;);
 678         goto fail;
 679       }
 680     }
 681   }
 682 
 683   return TRUE;
 684 
 685 fail:
 686   return FALSE;
 687 }
 688 
 689 static gfloat **
 690 mix_matrix_from_g_value (guint in_channels, guint out_channels,
 691     const GValue * value)
 692 {
 693   guint i, j;
 694   gfloat **matrix = g_new (gfloat *, in_channels);
 695 
 696   for (i = 0; i &lt; in_channels; i++)
 697     matrix[i] = g_new (gfloat, out_channels);
 698 
 699   for (j = 0; j &lt; out_channels; j++) {
 700     const GValue *row = gst_value_array_get_value (value, j);
 701 
 702     for (i = 0; i &lt; in_channels; i++) {
 703       const GValue *itm;
 704       gfloat coefficient;
 705 
 706       itm = gst_value_array_get_value (row, i);
 707       coefficient = g_value_get_float (itm);
 708       matrix[i][j] = coefficient;
 709     }
 710   }
 711 
 712   return matrix;
 713 }
 714 
 715 static AudioChain *
 716 chain_mix (GstAudioConverter * convert, AudioChain * prev)
 717 {
 718   GstAudioInfo *in = &amp;convert-&gt;in;
 719   GstAudioInfo *out = &amp;convert-&gt;out;
 720   GstAudioFormat format = convert-&gt;current_format;
 721   const GValue *opt_matrix = GET_OPT_MIX_MATRIX (convert);
 722 
 723   convert-&gt;current_channels = out-&gt;channels;
 724 
 725   if (opt_matrix) {
 726     gfloat **matrix = NULL;
 727 
 728     if (gst_value_array_get_size (opt_matrix))
 729       matrix =
 730           mix_matrix_from_g_value (in-&gt;channels, out-&gt;channels, opt_matrix);
 731 
 732     convert-&gt;mix =
 733         gst_audio_channel_mixer_new_with_matrix (0, format, in-&gt;channels,
 734         out-&gt;channels, matrix);
 735   } else {
 736     GstAudioChannelMixerFlags flags;
 737 
 738     flags =
 739         GST_AUDIO_INFO_IS_UNPOSITIONED (in) ?
 740         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN : 0;
 741     flags |=
 742         GST_AUDIO_INFO_IS_UNPOSITIONED (out) ?
 743         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT : 0;
 744 
 745     convert-&gt;mix =
 746         gst_audio_channel_mixer_new (flags, format, in-&gt;channels, in-&gt;position,
 747         out-&gt;channels, out-&gt;position);
 748   }
 749 
 750   convert-&gt;mix_passthrough =
 751       gst_audio_channel_mixer_is_passthrough (convert-&gt;mix);
 752   GST_INFO (&quot;mix format %s, passthrough %d, in_channels %d, out_channels %d&quot;,
 753       gst_audio_format_to_string (format), convert-&gt;mix_passthrough,
 754       in-&gt;channels, out-&gt;channels);
 755 
 756   if (!convert-&gt;mix_passthrough) {
 757     prev = audio_chain_new (prev, convert);
 758     prev-&gt;allow_ip = FALSE;
 759     prev-&gt;pass_alloc = FALSE;
 760     audio_chain_set_make_func (prev, do_mix, convert, NULL);
 761   }
 762   return prev;
 763 }
 764 
 765 static AudioChain *
 766 chain_resample (GstAudioConverter * convert, AudioChain * prev)
 767 {
 768   GstAudioInfo *in = &amp;convert-&gt;in;
 769   GstAudioInfo *out = &amp;convert-&gt;out;
 770   GstAudioResamplerMethod method;
 771   GstAudioResamplerFlags flags;
 772   GstAudioFormat format = convert-&gt;current_format;
 773   gint channels = convert-&gt;current_channels;
 774   gboolean variable_rate;
 775 
 776   variable_rate = convert-&gt;flags &amp; GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE;
 777 
 778   if (in-&gt;rate != out-&gt;rate || variable_rate) {
 779     method = GET_OPT_RESAMPLER_METHOD (convert);
 780 
 781     flags = 0;
 782     if (convert-&gt;current_layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {
 783       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN;
 784       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT;
 785     }
 786     if (variable_rate)
 787       flags |= GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE;
 788 
 789     convert-&gt;resampler =
 790         gst_audio_resampler_new (method, flags, format, channels, in-&gt;rate,
 791         out-&gt;rate, convert-&gt;config);
 792 
 793     prev = audio_chain_new (prev, convert);
 794     prev-&gt;allow_ip = FALSE;
 795     prev-&gt;pass_alloc = FALSE;
 796     audio_chain_set_make_func (prev, do_resample, convert, NULL);
 797   }
 798   return prev;
 799 }
 800 
 801 static AudioChain *
 802 chain_convert_out (GstAudioConverter * convert, AudioChain * prev)
 803 {
 804   gboolean in_int, out_int;
 805   GstAudioInfo *in = &amp;convert-&gt;in;
 806   GstAudioInfo *out = &amp;convert-&gt;out;
 807 
 808   in_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (in-&gt;finfo);
 809   out_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (out-&gt;finfo);
 810 
 811   if (!in_int &amp;&amp; out_int) {
 812     convert-&gt;convert_out = (AudioConvertFunc) audio_orc_double_to_s32;
 813     convert-&gt;current_format = GST_AUDIO_FORMAT_S32;
 814 
 815     GST_INFO (&quot;convert F64 to S32&quot;);
 816     prev = audio_chain_new (prev, convert);
 817     prev-&gt;allow_ip = TRUE;
 818     prev-&gt;pass_alloc = FALSE;
 819     audio_chain_set_make_func (prev, do_convert_out, convert, NULL);
 820   }
 821   return prev;
 822 }
 823 
 824 static AudioChain *
 825 chain_quantize (GstAudioConverter * convert, AudioChain * prev)
 826 {
 827   const GstAudioFormatInfo *cur_finfo;
 828   GstAudioInfo *out = &amp;convert-&gt;out;
 829   gint in_depth, out_depth;
 830   gboolean in_int, out_int;
 831   GstAudioDitherMethod dither;
 832   GstAudioNoiseShapingMethod ns;
 833 
 834   dither = GET_OPT_DITHER_METHOD (convert);
 835   ns = GET_OPT_NOISE_SHAPING_METHOD (convert);
 836 
 837   cur_finfo = gst_audio_format_get_info (convert-&gt;current_format);
 838 
 839   in_depth = GST_AUDIO_FORMAT_INFO_DEPTH (cur_finfo);
 840   out_depth = GST_AUDIO_FORMAT_INFO_DEPTH (out-&gt;finfo);
 841   GST_INFO (&quot;depth in %d, out %d&quot;, in_depth, out_depth);
 842 
 843   in_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (cur_finfo);
 844   out_int = GST_AUDIO_FORMAT_INFO_IS_INTEGER (out-&gt;finfo);
 845 
 846   /* Don&#39;t dither or apply noise shaping if target depth is bigger than 20 bits
 847    * as DA converters only can do a SNR up to 20 bits in reality.
 848    * Also don&#39;t dither or apply noise shaping if target depth is larger than
 849    * source depth. */
 850   if (out_depth &gt; 20 || (in_int &amp;&amp; out_depth &gt;= in_depth)) {
 851     dither = GST_AUDIO_DITHER_NONE;
 852     ns = GST_AUDIO_NOISE_SHAPING_NONE;
 853     GST_INFO (&quot;using no dither and noise shaping&quot;);
 854   } else {
 855     GST_INFO (&quot;using dither %d and noise shaping %d&quot;, dither, ns);
 856     /* Use simple error feedback when output sample rate is smaller than
 857      * 32000 as the other methods might move the noise to audible ranges */
 858     if (ns &gt; GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK &amp;&amp; out-&gt;rate &lt; 32000)
 859       ns = GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK;
 860   }
 861   /* we still want to run the quantization step when reducing bits to get
 862    * the rounding correct */
 863   if (out_int &amp;&amp; out_depth &lt; 32
 864       &amp;&amp; convert-&gt;current_format == GST_AUDIO_FORMAT_S32) {
 865     GST_INFO (&quot;quantize to %d bits, dither %d, ns %d&quot;, out_depth, dither, ns);
 866     convert-&gt;quant =
 867         gst_audio_quantize_new (dither, ns, 0, convert-&gt;current_format,
 868         out-&gt;channels, 1U &lt;&lt; (32 - out_depth));
 869 
 870     prev = audio_chain_new (prev, convert);
 871     prev-&gt;allow_ip = TRUE;
 872     prev-&gt;pass_alloc = TRUE;
 873     audio_chain_set_make_func (prev, do_quantize, convert, NULL);
 874   }
 875   return prev;
 876 }
 877 
 878 static AudioChain *
 879 chain_pack (GstAudioConverter * convert, AudioChain * prev)
 880 {
 881   GstAudioInfo *out = &amp;convert-&gt;out;
 882   GstAudioFormat format = convert-&gt;current_format;
 883 
 884   convert-&gt;current_format = out-&gt;finfo-&gt;format;
 885 
 886   convert-&gt;out_default = format == out-&gt;finfo-&gt;format;
 887   GST_INFO (&quot;pack format %s to %s&quot;, gst_audio_format_to_string (format),
 888       gst_audio_format_to_string (out-&gt;finfo-&gt;format));
 889 
 890   return prev;
 891 }
 892 
 893 static void
 894 setup_allocators (GstAudioConverter * convert)
 895 {
 896   AudioChain *chain;
 897   AudioChainAllocFunc alloc_func;
 898   gboolean allow_ip;
 899 
 900   /* start with using dest if we can directly write into it */
 901   if (convert-&gt;out_default) {
 902     alloc_func = get_output_samples;
 903     allow_ip = FALSE;
 904   } else {
 905     alloc_func = get_temp_samples;
 906     allow_ip = TRUE;
 907   }
 908   /* now walk backwards, we try to write into the dest samples directly
 909    * and keep track if the source needs to be writable */
 910   for (chain = convert-&gt;chain_end; chain; chain = chain-&gt;prev) {
 911     chain-&gt;alloc_func = alloc_func;
 912     chain-&gt;alloc_data = convert;
 913     chain-&gt;allow_ip = allow_ip &amp;&amp; chain-&gt;allow_ip;
 914     GST_LOG (&quot;chain %p: %d %d&quot;, chain, allow_ip, chain-&gt;allow_ip);
 915 
 916     if (!chain-&gt;pass_alloc) {
 917       /* can&#39;t pass allocator, make new temp line allocator */
 918       alloc_func = get_temp_samples;
 919       allow_ip = TRUE;
 920     }
 921   }
 922 }
 923 
 924 static gboolean
 925 converter_passthrough (GstAudioConverter * convert,
 926     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
 927     gpointer out[], gsize out_frames)
 928 {
 929   gint i;
 930   AudioChain *chain;
 931   gsize samples;
 932 
 933   /* in-place passthrough -&gt; do nothing */
 934   if (in == out) {
 935     g_assert (convert-&gt;in_place);
 936     return TRUE;
 937   }
 938 
 939   chain = convert-&gt;chain_end;
 940 
 941   samples = in_frames * chain-&gt;inc;
 942 
 943   GST_LOG (&quot;passthrough: %&quot; G_GSIZE_FORMAT &quot; / %&quot; G_GSIZE_FORMAT &quot; samples&quot;,
 944       in_frames, samples);
 945 
 946   if (in) {
 947     gsize bytes;
 948 
 949     bytes = samples * (convert-&gt;in.bpf / convert-&gt;in.channels);
 950 
 951     for (i = 0; i &lt; chain-&gt;blocks; i++) {
 952       if (out[i] == in[i]) {
 953         g_assert (convert-&gt;in_place);
 954         continue;
 955       }
 956 
 957       memcpy (out[i], in[i], bytes);
 958     }
 959   } else {
 960     for (i = 0; i &lt; chain-&gt;blocks; i++)
 961       gst_audio_format_fill_silence (convert-&gt;in.finfo, out[i], samples);
 962   }
 963   return TRUE;
 964 }
 965 
 966 /* perform LE&lt;-&gt;BE conversion on a block of @count 16-bit samples
 967  * dst may equal src for in-place conversion
 968  */
 969 static void
 970 converter_swap_endian_16 (gpointer dst, const gpointer src, gint count)
 971 {
 972   guint16 *out = dst;
 973   const guint16 *in = src;
 974   gint i;
 975 
 976   for (i = 0; i &lt; count; i++)
 977     out[i] = GUINT16_SWAP_LE_BE (in[i]);
 978 }
 979 
 980 /* perform LE&lt;-&gt;BE conversion on a block of @count 24-bit samples
 981  * dst may equal src for in-place conversion
 982  *
 983  * naive algorithm, which performs better with -O3 and worse with -O2
 984  * than the commented out optimized algorithm below
 985  */
 986 static void
 987 converter_swap_endian_24 (gpointer dst, const gpointer src, gint count)
 988 {
 989   guint8 *out = dst;
 990   const guint8 *in = src;
 991   gint i;
 992 
 993   count *= 3;
 994 
 995   for (i = 0; i &lt; count; i += 3) {
 996     guint8 x = in[i + 0];
 997     out[i + 0] = in[i + 2];
 998     out[i + 1] = in[i + 1];
 999     out[i + 2] = x;
1000   }
1001 }
1002 
1003 /* the below code performs better with -O2 but worse with -O3 */
1004 #if 0
1005 /* perform LE&lt;-&gt;BE conversion on a block of @count 24-bit samples
1006  * dst may equal src for in-place conversion
1007  *
1008  * assumes that dst and src are 32-bit aligned
1009  */
1010 static void
1011 converter_swap_endian_24 (gpointer dst, const gpointer src, gint count)
1012 {
1013   guint32 *out = dst;
1014   const guint32 *in = src;
1015   guint8 *out8;
1016   const guint8 *in8;
1017   gint i;
1018 
1019   /* first convert 24-bit samples in multiples of 4 reading 3x 32-bits in one cycle
1020    *
1021    * input:               A1 B1 C1 A2 , B2 C2 A3 B3 , C3 A4 B4 C4
1022    * 32-bit endian swap:  A2 C1 B1 A1 , B3 A3 C2 B2 , C4 B4 A4 C3
1023    *                      &lt;--  x  --&gt;   &lt;--  y  --&gt; , &lt;--  z  --&gt;
1024    *
1025    * desired output:      C1 B1 A1 C2 , B2 A2 C3 B3 , A3 C4 B4 A4
1026    */
1027   for (i = 0; i &lt; count / 4; i++, in += 3, out += 3) {
1028     guint32 x, y, z;
1029 
1030     x = GUINT32_SWAP_LE_BE (in[0]);
1031     y = GUINT32_SWAP_LE_BE (in[1]);
1032     z = GUINT32_SWAP_LE_BE (in[2]);
1033 
1034 #if G_BYTE_ORDER == G_BIG_ENDIAN
1035     out[0] = (x &lt;&lt; 8) + ((y &gt;&gt; 8) &amp; 0xff);
1036     out[1] = (in[1] &amp; 0xff0000ff) + ((x &gt;&gt; 8) &amp; 0xff0000) + ((z &lt;&lt; 8) &amp; 0xff00);
1037     out[2] = (z &gt;&gt; 8) + ((y &lt;&lt; 8) &amp; 0xff000000);
1038 #else
1039     out[0] = (x &gt;&gt; 8) + ((y &lt;&lt; 8) &amp; 0xff000000);
1040     out[1] = (in[1] &amp; 0xff0000ff) + ((x &lt;&lt; 8) &amp; 0xff00) + ((z &gt;&gt; 8) &amp; 0xff0000);
1041     out[2] = (z &lt;&lt; 8) + ((y &gt;&gt; 8) &amp; 0xff);
1042 #endif
1043   }
1044 
1045   /* convert the remainder less efficiently */
1046   for (out8 = (guint8 *) out, in8 = (const guint8 *) in, i = 0; i &lt; (count &amp; 3);
1047       i++) {
1048     guint8 x = in8[i + 0];
1049     out8[i + 0] = in8[i + 2];
1050     out8[i + 1] = in8[i + 1];
1051     out8[i + 2] = x;
1052   }
1053 }
1054 #endif
1055 
1056 /* perform LE&lt;-&gt;BE conversion on a block of @count 32-bit samples
1057  * dst may equal src for in-place conversion
1058  */
1059 static void
1060 converter_swap_endian_32 (gpointer dst, const gpointer src, gint count)
1061 {
1062   guint32 *out = dst;
1063   const guint32 *in = src;
1064   gint i;
1065 
1066   for (i = 0; i &lt; count; i++)
1067     out[i] = GUINT32_SWAP_LE_BE (in[i]);
1068 }
1069 
1070 /* perform LE&lt;-&gt;BE conversion on a block of @count 64-bit samples
1071  * dst may equal src for in-place conversion
1072  */
1073 static void
1074 converter_swap_endian_64 (gpointer dst, const gpointer src, gint count)
1075 {
1076   guint64 *out = dst;
1077   const guint64 *in = src;
1078   gint i;
1079 
1080   for (i = 0; i &lt; count; i++)
1081     out[i] = GUINT64_SWAP_LE_BE (in[i]);
1082 }
1083 
1084 /* the worker function to perform endian-conversion only
1085  * assuming finfo and foutinfo have the same depth
1086  */
1087 static gboolean
1088 converter_endian (GstAudioConverter * convert,
1089     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1090     gpointer out[], gsize out_frames)
1091 {
1092   gint i;
1093   AudioChain *chain;
1094   gsize samples;
1095 
1096   chain = convert-&gt;chain_end;
1097   samples = in_frames * chain-&gt;inc;
1098 
1099   GST_LOG (&quot;convert endian: %&quot; G_GSIZE_FORMAT &quot; / %&quot; G_GSIZE_FORMAT &quot; samples&quot;,
1100       in_frames, samples);
1101 
1102   if (in) {
1103     for (i = 0; i &lt; chain-&gt;blocks; i++)
1104       convert-&gt;swap_endian (out[i], in[i], samples);
1105   } else {
1106     for (i = 0; i &lt; chain-&gt;blocks; i++)
1107       gst_audio_format_fill_silence (convert-&gt;in.finfo, out[i], samples);
1108   }
1109   return TRUE;
1110 }
1111 
1112 static gboolean
1113 converter_generic (GstAudioConverter * convert,
1114     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1115     gpointer out[], gsize out_frames)
1116 {
1117   AudioChain *chain;
1118   gpointer *tmp;
1119   gint i;
1120   gsize produced;
1121 
1122   chain = convert-&gt;chain_end;
1123 
1124   convert-&gt;in_writable = flags &amp; GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE;
1125   convert-&gt;in_data = in;
1126   convert-&gt;in_frames = in_frames;
1127   convert-&gt;out_data = out;
1128   convert-&gt;out_frames = out_frames;
1129 
1130   /* get frames to pack */
1131   tmp = audio_chain_get_samples (chain, &amp;produced);
1132 
1133   if (!convert-&gt;out_default) {
1134     GST_LOG (&quot;pack %p, %p %&quot; G_GSIZE_FORMAT, tmp, out, produced);
1135     /* and pack if needed */
1136     for (i = 0; i &lt; chain-&gt;blocks; i++)
1137       convert-&gt;out.finfo-&gt;pack_func (convert-&gt;out.finfo, 0, tmp[i], out[i],
1138           produced * chain-&gt;inc);
1139   }
1140   return TRUE;
1141 }
1142 
1143 static gboolean
1144 converter_resample (GstAudioConverter * convert,
1145     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1146     gpointer out[], gsize out_frames)
1147 {
1148   gst_audio_resampler_resample (convert-&gt;resampler, in, in_frames, out,
1149       out_frames);
1150 
1151   return TRUE;
1152 }
1153 
1154 #define GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION(info1, info2) \
1155         ( \
1156             !(((info1)-&gt;flags ^ (info2)-&gt;flags) &amp; (~GST_AUDIO_FORMAT_FLAG_UNPACK)) &amp;&amp; \
1157             (info1)-&gt;endianness != (info2)-&gt;endianness &amp;&amp; \
1158             (info1)-&gt;width == (info2)-&gt;width &amp;&amp; \
1159             (info1)-&gt;depth == (info2)-&gt;depth \
1160         )
1161 
1162 /**
1163  * gst_audio_converter_new:
1164  * @flags: extra #GstAudioConverterFlags
1165  * @in_info: a source #GstAudioInfo
1166  * @out_info: a destination #GstAudioInfo
1167  * @config: (transfer full) (nullable): a #GstStructure with configuration options
1168  *
1169  * Create a new #GstAudioConverter that is able to convert between @in and @out
1170  * audio formats.
1171  *
1172  * @config contains extra configuration options, see #GST_VIDEO_CONVERTER_OPT_*
1173  * parameters for details about the options and values.
1174  *
1175  * Returns: a #GstAudioConverter or %NULL if conversion is not possible.
1176  */
1177 GstAudioConverter *
1178 gst_audio_converter_new (GstAudioConverterFlags flags, GstAudioInfo * in_info,
1179     GstAudioInfo * out_info, GstStructure * config)
1180 {
1181   GstAudioConverter *convert;
1182   AudioChain *prev;
1183   const GValue *opt_matrix = NULL;
1184 
1185   g_return_val_if_fail (in_info != NULL, FALSE);
1186   g_return_val_if_fail (out_info != NULL, FALSE);
1187   g_return_val_if_fail (in_info-&gt;layout == GST_AUDIO_LAYOUT_INTERLEAVED, FALSE);
1188   g_return_val_if_fail (in_info-&gt;layout == out_info-&gt;layout, FALSE);
1189 
1190   if (config)
1191     opt_matrix =
1192         gst_structure_get_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX);
1193 
1194   if (opt_matrix
1195       &amp;&amp; !check_mix_matrix (in_info-&gt;channels, out_info-&gt;channels, opt_matrix))
1196     goto invalid_mix_matrix;
1197 
1198   if ((GST_AUDIO_INFO_CHANNELS (in_info) != GST_AUDIO_INFO_CHANNELS (out_info))
1199       &amp;&amp; (GST_AUDIO_INFO_IS_UNPOSITIONED (in_info)
1200           || GST_AUDIO_INFO_IS_UNPOSITIONED (out_info))
1201       &amp;&amp; !opt_matrix)
1202     goto unpositioned;
1203 
1204   convert = g_slice_new0 (GstAudioConverter);
1205 
1206   convert-&gt;flags = flags;
1207   convert-&gt;in = *in_info;
1208   convert-&gt;out = *out_info;
1209 
1210   /* default config */
1211   convert-&gt;config = gst_structure_new_empty (&quot;GstAudioConverter&quot;);
1212   if (config)
1213     gst_audio_converter_update_config (convert, 0, 0, config);
1214 
1215   GST_INFO (&quot;unitsizes: %d -&gt; %d&quot;, in_info-&gt;bpf, out_info-&gt;bpf);
1216 
1217   /* step 1, unpack */
1218   prev = chain_unpack (convert);
1219   /* step 2, optional convert from S32 to F64 for channel mix */
1220   prev = chain_convert_in (convert, prev);
1221   /* step 3, channel mix */
1222   prev = chain_mix (convert, prev);
1223   /* step 4, resample */
1224   prev = chain_resample (convert, prev);
1225   /* step 5, optional convert for quantize */
1226   prev = chain_convert_out (convert, prev);
1227   /* step 6, optional quantize */
1228   prev = chain_quantize (convert, prev);
1229   /* step 7, pack */
1230   convert-&gt;chain_end = chain_pack (convert, prev);
1231 
1232   convert-&gt;convert = converter_generic;
1233   convert-&gt;in_place = FALSE;
1234 
1235   /* optimize */
1236   if (convert-&gt;mix_passthrough) {
1237     if (out_info-&gt;finfo-&gt;format == in_info-&gt;finfo-&gt;format) {
1238       if (convert-&gt;resampler == NULL) {
1239         GST_INFO
1240             (&quot;same formats, no resampler and passthrough mixing -&gt; passthrough&quot;);
1241         convert-&gt;convert = converter_passthrough;
1242         convert-&gt;in_place = TRUE;
1243       } else {
1244         if (is_intermediate_format (in_info-&gt;finfo-&gt;format)) {
1245           GST_INFO (&quot;same formats, and passthrough mixing -&gt; only resampling&quot;);
1246           convert-&gt;convert = converter_resample;
1247         }
1248       }
1249     } else if (GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION (out_info-&gt;finfo,
1250             in_info-&gt;finfo)) {
1251       if (convert-&gt;resampler == NULL) {
1252         GST_INFO (&quot;no resampler, passthrough mixing -&gt; only endian conversion&quot;);
1253         convert-&gt;convert = converter_endian;
1254         convert-&gt;in_place = TRUE;
1255 
1256         switch (GST_AUDIO_INFO_BPS (in_info)) {
1257           case 2:
1258             GST_DEBUG (&quot;initializing 16-bit endian conversion&quot;);
1259             convert-&gt;swap_endian = converter_swap_endian_16;
1260             break;
1261           case 3:
1262             GST_DEBUG (&quot;initializing 24-bit endian conversion&quot;);
1263             convert-&gt;swap_endian = converter_swap_endian_24;
1264             break;
1265           case 4:
1266             GST_DEBUG (&quot;initializing 32-bit endian conversion&quot;);
1267             convert-&gt;swap_endian = converter_swap_endian_32;
1268             break;
1269           case 8:
1270             GST_DEBUG (&quot;initializing 64-bit endian conversion&quot;);
1271             convert-&gt;swap_endian = converter_swap_endian_64;
1272             break;
1273           default:
1274             GST_ERROR (&quot;unsupported sample width for endian conversion&quot;);
1275             g_assert_not_reached ();
1276         }
1277       }
1278     }
1279   }
1280 
1281   setup_allocators (convert);
1282 
1283   return convert;
1284 
1285   /* ERRORS */
1286 unpositioned:
1287   {
1288     GST_WARNING (&quot;unpositioned channels&quot;);
1289     return NULL;
1290   }
1291 
1292 invalid_mix_matrix:
1293   {
1294     GST_WARNING (&quot;Invalid mix matrix&quot;);
1295     return NULL;
1296   }
1297 }
1298 
1299 /**
1300  * gst_audio_converter_free:
1301  * @convert: a #GstAudioConverter
1302  *
1303  * Free a previously allocated @convert instance.
1304  */
1305 void
1306 gst_audio_converter_free (GstAudioConverter * convert)
1307 {
1308   AudioChain *chain;
1309 
1310   g_return_if_fail (convert != NULL);
1311 
1312   /* walk the chain backwards and free all elements */
1313   for (chain = convert-&gt;chain_end; chain;) {
1314     AudioChain *prev = chain-&gt;prev;
1315     audio_chain_free (chain);
1316     chain = prev;
1317   }
1318 
1319   if (convert-&gt;quant)
1320     gst_audio_quantize_free (convert-&gt;quant);
1321   if (convert-&gt;mix)
1322     gst_audio_channel_mixer_free (convert-&gt;mix);
1323   if (convert-&gt;resampler)
1324     gst_audio_resampler_free (convert-&gt;resampler);
1325   gst_audio_info_init (&amp;convert-&gt;in);
1326   gst_audio_info_init (&amp;convert-&gt;out);
1327 
1328   gst_structure_free (convert-&gt;config);
1329 
1330   g_slice_free (GstAudioConverter, convert);
1331 }
1332 
1333 /**
1334  * gst_audio_converter_get_out_frames:
1335  * @convert: a #GstAudioConverter
1336  * @in_frames: number of input frames
1337  *
1338  * Calculate how many output frames can be produced when @in_frames input
1339  * frames are given to @convert.
1340  *
1341  * Returns: the number of output frames
1342  */
1343 gsize
1344 gst_audio_converter_get_out_frames (GstAudioConverter * convert,
1345     gsize in_frames)
1346 {
1347   if (convert-&gt;resampler)
1348     return gst_audio_resampler_get_out_frames (convert-&gt;resampler, in_frames);
1349   else
1350     return in_frames;
1351 }
1352 
1353 /**
1354  * gst_audio_converter_get_in_frames:
1355  * @convert: a #GstAudioConverter
1356  * @out_frames: number of output frames
1357  *
1358  * Calculate how many input frames are currently needed by @convert to produce
1359  * @out_frames of output frames.
1360  *
1361  * Returns: the number of input frames
1362  */
1363 gsize
1364 gst_audio_converter_get_in_frames (GstAudioConverter * convert,
1365     gsize out_frames)
1366 {
1367   if (convert-&gt;resampler)
1368     return gst_audio_resampler_get_in_frames (convert-&gt;resampler, out_frames);
1369   else
1370     return out_frames;
1371 }
1372 
1373 /**
1374  * gst_audio_converter_get_max_latency:
1375  * @convert: a #GstAudioConverter
1376  *
1377  * Get the maximum number of input frames that the converter would
1378  * need before producing output.
1379  *
1380  * Returns: the latency of @convert as expressed in the number of
1381  * frames.
1382  */
1383 gsize
1384 gst_audio_converter_get_max_latency (GstAudioConverter * convert)
1385 {
1386   if (convert-&gt;resampler)
1387     return gst_audio_resampler_get_max_latency (convert-&gt;resampler);
1388   else
1389     return 0;
1390 }
1391 
1392 /**
1393  * gst_audio_converter_reset:
1394  * @convert: a #GstAudioConverter
1395  *
1396  * Reset @convert to the state it was when it was first created, clearing
1397  * any history it might currently have.
1398  */
1399 void
1400 gst_audio_converter_reset (GstAudioConverter * convert)
1401 {
1402   if (convert-&gt;resampler)
1403     gst_audio_resampler_reset (convert-&gt;resampler);
1404   if (convert-&gt;quant)
1405     gst_audio_quantize_reset (convert-&gt;quant);
1406 }
1407 
1408 /**
1409  * gst_audio_converter_samples:
1410  * @convert: a #GstAudioConverter
1411  * @flags: extra #GstAudioConverterFlags
1412  * @in: input frames
1413  * @in_frames: number of input frames
1414  * @out: output frames
1415  * @out_frames: number of output frames
1416  *
1417  * Perform the conversion with @in_frames in @in to @out_frames in @out
1418  * using @convert.
1419  *
1420  * In case the samples are interleaved, @in and @out must point to an
1421  * array with a single element pointing to a block of interleaved samples.
1422  *
1423  * If non-interleaved samples are used, @in and @out must point to an
1424  * array with pointers to memory blocks, one for each channel.
1425  *
1426  * @in may be %NULL, in which case @in_frames of silence samples are processed
1427  * by the converter.
1428  *
1429  * This function always produces @out_frames of output and consumes @in_frames of
1430  * input. Use gst_audio_converter_get_out_frames() and
1431  * gst_audio_converter_get_in_frames() to make sure @in_frames and @out_frames
1432  * are matching and @in and @out point to enough memory.
1433  *
1434  * Returns: %TRUE is the conversion could be performed.
1435  */
1436 gboolean
1437 gst_audio_converter_samples (GstAudioConverter * convert,
1438     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1439     gpointer out[], gsize out_frames)
1440 {
1441   g_return_val_if_fail (convert != NULL, FALSE);
1442   g_return_val_if_fail (out != NULL, FALSE);
1443 
1444   if (in_frames == 0) {
1445     GST_LOG (&quot;skipping empty buffer&quot;);
1446     return TRUE;
1447   }
1448   return convert-&gt;convert (convert, flags, in, in_frames, out, out_frames);
1449 }
1450 
1451 /**
1452  * gst_audio_converter_convert:
1453  * @flags: extra #GstAudioConverterFlags
1454  * @in: (array length=in_size) (element-type guint8): input data
1455  * @in_size: size of @in
1456  * @out: (out) (array length=out_size) (element-type guint8): a pointer where
1457  *  the output data will be written
1458  * @out_size: (out): a pointer where the size of @out will be written
1459  *
1460  * Convenience wrapper around gst_audio_converter_samples(), which will
1461  * perform allocation of the output buffer based on the result from
1462  * gst_audio_converter_get_out_frames().
1463  *
1464  * Returns: %TRUE is the conversion could be performed.
1465  *
1466  * Since: 1.14
1467  */
1468 gboolean
1469 gst_audio_converter_convert (GstAudioConverter * convert,
1470     GstAudioConverterFlags flags, gpointer in, gsize in_size,
1471     gpointer * out, gsize * out_size)
1472 {
1473   gsize in_frames;
1474   gsize out_frames;
1475 
1476   g_return_val_if_fail (convert != NULL, FALSE);
1477   g_return_val_if_fail (flags ^ GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE, FALSE);
1478 
1479   in_frames = in_size / convert-&gt;in.bpf;
1480   out_frames = gst_audio_converter_get_out_frames (convert, in_frames);
1481 
1482   *out_size = out_frames * convert-&gt;out.bpf;
1483   *out = g_malloc0 (*out_size);
1484 
1485   return gst_audio_converter_samples (convert, flags, &amp;in, in_frames, out,
1486       out_frames);
1487 }
1488 
1489 /**
1490  * gst_audio_converter_supports_inplace:
1491  * @convert: a #GstAudioConverter
1492  *
1493  * Returns whether the audio converter can perform the conversion in-place.
1494  * The return value would be typically input to gst_base_transform_set_in_place()
1495  *
1496  * Returns: %TRUE when the conversion can be done in place.
1497  */
1498 gboolean
1499 gst_audio_converter_supports_inplace (GstAudioConverter * convert)
1500 {
1501   return convert-&gt;in_place;
1502 }
    </pre>
  </body>
</html>