<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;
  32 #include &lt;stdlib.h&gt;
  33 
  34 #include &quot;garray.h&quot;
  35 
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;ghash.h&quot;
  38 #include &quot;gslice.h&quot;
  39 #include &quot;gmem.h&quot;
  40 #include &quot;gtestutils.h&quot;
  41 #include &quot;gthread.h&quot;
  42 #include &quot;gmessages.h&quot;
  43 #include &quot;gqsort.h&quot;
  44 #include &quot;grefcount.h&quot;
  45 
  46 /**
  47  * SECTION:arrays
  48  * @title: Arrays
  49  * @short_description: arrays of arbitrary elements which grow
  50  *     automatically as elements are added
  51  *
  52  * Arrays are similar to standard C arrays, except that they grow
  53  * automatically as elements are added.
  54  *
  55  * Array elements can be of any size (though all elements of one array
  56  * are the same size), and the array can be automatically cleared to
  57  * &#39;0&#39;s and zero-terminated.
  58  *
  59  * To create a new array use g_array_new().
  60  *
  61  * To add elements to an array, use g_array_append_val(),
  62  * g_array_append_vals(), g_array_prepend_val(), and
  63  * g_array_prepend_vals().
  64  *
  65  * To access an element of an array, use g_array_index().
  66  *
  67  * To set the size of an array, use g_array_set_size().
  68  *
  69  * To free an array, use g_array_free().
  70  *
  71  * Here is an example that stores integers in a #GArray:
  72  * |[&lt;!-- language=&quot;C&quot; --&gt;
  73  *   GArray *garray;
  74  *   gint i;
  75  *   // We create a new array to store gint values.
  76  *   // We don&#39;t want it zero-terminated or cleared to 0&#39;s.
  77  *   garray = g_array_new (FALSE, FALSE, sizeof (gint));
  78  *   for (i = 0; i &lt; 10000; i++)
  79  *     g_array_append_val (garray, i);
  80  *   for (i = 0; i &lt; 10000; i++)
  81  *     if (g_array_index (garray, gint, i) != i)
  82  *       g_print (&quot;ERROR: got %d instead of %d\n&quot;,
  83  *                g_array_index (garray, gint, i), i);
  84  *   g_array_free (garray, TRUE);
  85  * ]|
  86  */
  87 
  88 #define MIN_ARRAY_SIZE  16
  89 
  90 typedef struct _GRealArray  GRealArray;
  91 
  92 /**
  93  * GArray:
  94  * @data: a pointer to the element data. The data may be moved as
  95  *     elements are added to the #GArray.
  96  * @len: the number of elements in the #GArray not including the
  97  *     possible terminating zero element.
  98  *
  99  * Contains the public fields of a GArray.
 100  */
 101 struct _GRealArray
 102 {
 103   guint8 *data;
 104   guint   len;
 105   guint   alloc;
 106   guint   elt_size;
 107   guint   zero_terminated : 1;
 108   guint   clear : 1;
 109   gatomicrefcount ref_count;
 110   GDestroyNotify clear_func;
 111 };
 112 
 113 /**
 114  * g_array_index:
 115  * @a: a #GArray
 116  * @t: the type of the elements
 117  * @i: the index of the element to return
 118  *
 119  * Returns the element of a #GArray at the given index. The return
 120  * value is cast to the given type.
 121  *
 122  * This example gets a pointer to an element in a #GArray:
 123  * |[&lt;!-- language=&quot;C&quot; --&gt;
 124  *   EDayViewEvent *event;
 125  *   // This gets a pointer to the 4th element in the array of
 126  *   // EDayViewEvent structs.
 127  *   event = &amp;g_array_index (events, EDayViewEvent, 3);
 128  * ]|
 129  *
 130  * Returns: the element of the #GArray at the index given by @i
 131  */
 132 
 133 #define g_array_elt_len(array,i) ((array)-&gt;elt_size * (i))
 134 #define g_array_elt_pos(array,i) ((array)-&gt;data + g_array_elt_len((array),(i)))
 135 #define g_array_elt_zero(array, pos, len)                               \
 136   (memset (g_array_elt_pos ((array), pos), 0,  g_array_elt_len ((array), len)))
 137 #define g_array_zero_terminate(array) G_STMT_START{                     \
 138   if ((array)-&gt;zero_terminated)                                         \
 139     g_array_elt_zero ((array), (array)-&gt;len, 1);                        \
 140 }G_STMT_END
 141 
 142 static guint g_nearest_pow        (guint       num) G_GNUC_CONST;
 143 static void  g_array_maybe_expand (GRealArray *array,
 144                                    guint       len);
 145 
 146 /**
 147  * g_array_new:
 148  * @zero_terminated: %TRUE if the array should have an extra element at
 149  *     the end which is set to 0
 150  * @clear_: %TRUE if #GArray elements should be automatically cleared
 151  *     to 0 when they are allocated
 152  * @element_size: the size of each element in bytes
 153  *
 154  * Creates a new #GArray with a reference count of 1.
 155  *
 156  * Returns: the new #GArray
 157  */
 158 GArray*
 159 g_array_new (gboolean zero_terminated,
 160              gboolean clear,
 161              guint    elt_size)
 162 {
 163   g_return_val_if_fail (elt_size &gt; 0, NULL);
 164 
 165   return g_array_sized_new (zero_terminated, clear, elt_size, 0);
 166 }
 167 
 168 /**
 169  * g_array_sized_new:
 170  * @zero_terminated: %TRUE if the array should have an extra element at
 171  *     the end with all bits cleared
 172  * @clear_: %TRUE if all bits in the array should be cleared to 0 on
 173  *     allocation
 174  * @element_size: size of each element in the array
 175  * @reserved_size: number of elements preallocated
 176  *
 177  * Creates a new #GArray with @reserved_size elements preallocated and
 178  * a reference count of 1. This avoids frequent reallocation, if you
 179  * are going to add many elements to the array. Note however that the
 180  * size of the array is still 0.
 181  *
 182  * Returns: the new #GArray
 183  */
 184 GArray*
 185 g_array_sized_new (gboolean zero_terminated,
 186                    gboolean clear,
 187                    guint    elt_size,
 188                    guint    reserved_size)
 189 {
 190   GRealArray *array;
 191 
 192   g_return_val_if_fail (elt_size &gt; 0, NULL);
 193 
 194   array = g_slice_new (GRealArray);
 195 #ifdef GSTREAMER_LITE
 196   if (array == NULL) {
 197     return NULL;
 198   }
 199 #endif // GSTREAMER_LITE
 200 
 201   array-&gt;data            = NULL;
 202   array-&gt;len             = 0;
 203   array-&gt;alloc           = 0;
 204   array-&gt;zero_terminated = (zero_terminated ? 1 : 0);
 205   array-&gt;clear           = (clear ? 1 : 0);
 206   array-&gt;elt_size        = elt_size;
 207   array-&gt;clear_func      = NULL;
 208 
 209   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
 210 
 211   if (array-&gt;zero_terminated || reserved_size != 0)
 212     {
 213       g_array_maybe_expand (array, reserved_size);
 214       g_array_zero_terminate(array);
 215     }
 216 
 217   return (GArray*) array;
 218 }
 219 
 220 /**
 221  * g_array_set_clear_func:
 222  * @array: A #GArray
 223  * @clear_func: a function to clear an element of @array
 224  *
 225  * Sets a function to clear an element of @array.
 226  *
 227  * The @clear_func will be called when an element in the array
 228  * data segment is removed and when the array is freed and data
 229  * segment is deallocated as well. @clear_func will be passed a
 230  * pointer to the element to clear, rather than the element itself.
 231  *
 232  * Note that in contrast with other uses of #GDestroyNotify
 233  * functions, @clear_func is expected to clear the contents of
 234  * the array element it is given, but not free the element itself.
 235  *
 236  * Since: 2.32
 237  */
 238 void
 239 g_array_set_clear_func (GArray         *array,
 240                         GDestroyNotify  clear_func)
 241 {
 242   GRealArray *rarray = (GRealArray *) array;
 243 
 244   g_return_if_fail (array != NULL);
 245 
 246   rarray-&gt;clear_func = clear_func;
 247 }
 248 
 249 /**
 250  * g_array_ref:
 251  * @array: A #GArray
 252  *
 253  * Atomically increments the reference count of @array by one.
 254  * This function is thread-safe and may be called from any thread.
 255  *
 256  * Returns: The passed in #GArray
 257  *
 258  * Since: 2.22
 259  */
 260 GArray *
 261 g_array_ref (GArray *array)
 262 {
 263   GRealArray *rarray = (GRealArray*) array;
 264   g_return_val_if_fail (array, NULL);
 265 
 266   g_atomic_ref_count_inc (&amp;rarray-&gt;ref_count);
 267 
 268   return array;
 269 }
 270 
 271 typedef enum
 272 {
 273   FREE_SEGMENT = 1 &lt;&lt; 0,
 274   PRESERVE_WRAPPER = 1 &lt;&lt; 1
 275 } ArrayFreeFlags;
 276 
 277 static gchar *array_free (GRealArray *, ArrayFreeFlags);
 278 
 279 /**
 280  * g_array_unref:
 281  * @array: A #GArray
 282  *
 283  * Atomically decrements the reference count of @array by one. If the
 284  * reference count drops to 0, all memory allocated by the array is
 285  * released. This function is thread-safe and may be called from any
 286  * thread.
 287  *
 288  * Since: 2.22
 289  */
 290 void
 291 g_array_unref (GArray *array)
 292 {
 293   GRealArray *rarray = (GRealArray*) array;
 294   g_return_if_fail (array);
 295 
 296   if (g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
 297     array_free (rarray, FREE_SEGMENT);
 298 }
 299 
 300 /**
 301  * g_array_get_element_size:
 302  * @array: A #GArray
 303  *
 304  * Gets the size of the elements in @array.
 305  *
 306  * Returns: Size of each element, in bytes
 307  *
 308  * Since: 2.22
 309  */
 310 guint
 311 g_array_get_element_size (GArray *array)
 312 {
 313   GRealArray *rarray = (GRealArray*) array;
 314 
 315   g_return_val_if_fail (array, 0);
 316 
 317   return rarray-&gt;elt_size;
 318 }
 319 
 320 /**
 321  * g_array_free:
 322  * @array: a #GArray
 323  * @free_segment: if %TRUE the actual element data is freed as well
 324  *
 325  * Frees the memory allocated for the #GArray. If @free_segment is
 326  * %TRUE it frees the memory block holding the elements as well and
 327  * also each element if @array has a @element_free_func set. Pass
 328  * %FALSE if you want to free the #GArray wrapper but preserve the
 329  * underlying array for use elsewhere. If the reference count of @array
 330  * is greater than one, the #GArray wrapper is preserved but the size
 331  * of @array will be set to zero.
 332  *
 333  * If array elements contain dynamically-allocated memory, they should
 334  * be freed separately.
 335  *
 336  * This function is not thread-safe. If using a #GArray from multiple
 337  * threads, use only the atomic g_array_ref() and g_array_unref()
 338  * functions.
 339  *
 340  * Returns: the element data if @free_segment is %FALSE, otherwise
 341  *     %NULL. The element data should be freed using g_free().
 342  */
 343 gchar*
 344 g_array_free (GArray   *farray,
 345               gboolean  free_segment)
 346 {
 347   GRealArray *array = (GRealArray*) farray;
 348   ArrayFreeFlags flags;
 349 
 350   g_return_val_if_fail (array, NULL);
 351 
 352   flags = (free_segment ? FREE_SEGMENT : 0);
 353 
 354   /* if others are holding a reference, preserve the wrapper but do free/return the data */
 355   if (!g_atomic_ref_count_dec (&amp;array-&gt;ref_count))
 356     flags |= PRESERVE_WRAPPER;
 357 
 358   return array_free (array, flags);
 359 }
 360 
 361 static gchar *
 362 array_free (GRealArray     *array,
 363             ArrayFreeFlags  flags)
 364 {
 365   gchar *segment;
 366 
 367   if (flags &amp; FREE_SEGMENT)
 368     {
 369       if (array-&gt;clear_func != NULL)
 370         {
 371           guint i;
 372 
 373           for (i = 0; i &lt; array-&gt;len; i++)
 374             array-&gt;clear_func (g_array_elt_pos (array, i));
 375         }
 376 
 377       g_free (array-&gt;data);
 378       segment = NULL;
 379     }
 380   else
 381     segment = (gchar*) array-&gt;data;
 382 
 383   if (flags &amp; PRESERVE_WRAPPER)
 384     {
 385       array-&gt;data            = NULL;
 386       array-&gt;len             = 0;
 387       array-&gt;alloc           = 0;
 388     }
 389   else
 390     {
 391       g_slice_free1 (sizeof (GRealArray), array);
 392     }
 393 
 394   return segment;
 395 }
 396 
 397 /**
 398  * g_array_append_vals:
 399  * @array: a #GArray
 400  * @data: (not nullable): a pointer to the elements to append to the end of the array
 401  * @len: the number of elements to append
 402  *
 403  * Adds @len elements onto the end of the array.
 404  *
 405  * Returns: the #GArray
 406  */
 407 /**
 408  * g_array_append_val:
 409  * @a: a #GArray
 410  * @v: the value to append to the #GArray
 411  *
 412  * Adds the value on to the end of the array. The array will grow in
 413  * size automatically if necessary.
 414  *
 415  * g_array_append_val() is a macro which uses a reference to the value
 416  * parameter @v. This means that you cannot use it with literal values
 417  * such as &quot;27&quot;. You must use variables.
 418  *
 419  * Returns: the #GArray
 420  */
 421 GArray*
 422 g_array_append_vals (GArray       *farray,
 423                      gconstpointer data,
 424                      guint         len)
 425 {
 426   GRealArray *array = (GRealArray*) farray;
 427 
 428   g_return_val_if_fail (array, NULL);
 429 
 430   if (len == 0)
 431     return farray;
 432 
 433   g_array_maybe_expand (array, len);
 434 
 435   memcpy (g_array_elt_pos (array, array-&gt;len), data,
 436           g_array_elt_len (array, len));
 437 
 438   array-&gt;len += len;
 439 
 440   g_array_zero_terminate (array);
 441 
 442   return farray;
 443 }
 444 
 445 /**
 446  * g_array_prepend_vals:
 447  * @array: a #GArray
 448  * @data: (nullable): a pointer to the elements to prepend to the start of the array
 449  * @len: the number of elements to prepend, which may be zero
 450  *
 451  * Adds @len elements onto the start of the array.
 452  *
 453  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 454  * function is a no-op.
 455  *
 456  * This operation is slower than g_array_append_vals() since the
 457  * existing elements in the array have to be moved to make space for
 458  * the new elements.
 459  *
 460  * Returns: the #GArray
 461  */
 462 /**
 463  * g_array_prepend_val:
 464  * @a: a #GArray
 465  * @v: the value to prepend to the #GArray
 466  *
 467  * Adds the value on to the start of the array. The array will grow in
 468  * size automatically if necessary.
 469  *
 470  * This operation is slower than g_array_append_val() since the
 471  * existing elements in the array have to be moved to make space for
 472  * the new element.
 473  *
 474  * g_array_prepend_val() is a macro which uses a reference to the value
 475  * parameter @v. This means that you cannot use it with literal values
 476  * such as &quot;27&quot;. You must use variables.
 477  *
 478  * Returns: the #GArray
 479  */
 480 GArray*
 481 g_array_prepend_vals (GArray        *farray,
 482                       gconstpointer  data,
 483                       guint          len)
 484 {
 485   GRealArray *array = (GRealArray*) farray;
 486 
 487   g_return_val_if_fail (array, NULL);
 488 
 489   if (len == 0)
 490     return farray;
 491 
 492   g_array_maybe_expand (array, len);
 493 
 494   memmove (g_array_elt_pos (array, len), g_array_elt_pos (array, 0),
 495            g_array_elt_len (array, array-&gt;len));
 496 
 497   memcpy (g_array_elt_pos (array, 0), data, g_array_elt_len (array, len));
 498 
 499   array-&gt;len += len;
 500 
 501   g_array_zero_terminate (array);
 502 
 503   return farray;
 504 }
 505 
 506 /**
 507  * g_array_insert_vals:
 508  * @array: a #GArray
 509  * @index_: the index to place the elements at
 510  * @data: (nullable): a pointer to the elements to insert
 511  * @len: the number of elements to insert
 512  *
 513  * Inserts @len elements into a #GArray at the given index.
 514  *
 515  * If @index_ is greater than the array’s current length, the array is expanded.
 516  * The elements between the old end of the array and the newly inserted elements
 517  * will be initialised to zero if the array was configured to clear elements;
 518  * otherwise their values will be undefined.
 519  *
 520  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 521  * function is a no-op.
 522  *
 523  * Returns: the #GArray
 524  */
 525 /**
 526  * g_array_insert_val:
 527  * @a: a #GArray
 528  * @i: the index to place the element at
 529  * @v: the value to insert into the array
 530  *
 531  * Inserts an element into an array at the given index.
 532  *
 533  * g_array_insert_val() is a macro which uses a reference to the value
 534  * parameter @v. This means that you cannot use it with literal values
 535  * such as &quot;27&quot;. You must use variables.
 536  *
 537  * Returns: the #GArray
 538  */
 539 GArray*
 540 g_array_insert_vals (GArray        *farray,
 541                      guint          index_,
 542                      gconstpointer  data,
 543                      guint          len)
 544 {
 545   GRealArray *array = (GRealArray*) farray;
 546 
 547   g_return_val_if_fail (array, NULL);
 548 
 549   if (len == 0)
 550     return farray;
 551 
 552   /* Is the index off the end of the array, and hence do we need to over-allocate
 553    * and clear some elements? */
 554   if (index_ &gt;= array-&gt;len)
 555     {
 556       g_array_maybe_expand (array, index_ - array-&gt;len + len);
 557       return g_array_append_vals (g_array_set_size (farray, index_), data, len);
 558     }
 559 
 560   g_array_maybe_expand (array, len);
 561 
 562   memmove (g_array_elt_pos (array, len + index_),
 563            g_array_elt_pos (array, index_),
 564            g_array_elt_len (array, array-&gt;len - index_));
 565 
 566   memcpy (g_array_elt_pos (array, index_), data, g_array_elt_len (array, len));
 567 
 568   array-&gt;len += len;
 569 
 570   g_array_zero_terminate (array);
 571 
 572   return farray;
 573 }
 574 
 575 /**
 576  * g_array_set_size:
 577  * @array: a #GArray
 578  * @length: the new size of the #GArray
 579  *
 580  * Sets the size of the array, expanding it if necessary. If the array
 581  * was created with @clear_ set to %TRUE, the new elements are set to 0.
 582  *
 583  * Returns: the #GArray
 584  */
 585 GArray*
 586 g_array_set_size (GArray *farray,
 587                   guint   length)
 588 {
 589   GRealArray *array = (GRealArray*) farray;
 590 
 591   g_return_val_if_fail (array, NULL);
 592 
 593   if (length &gt; array-&gt;len)
 594     {
 595       g_array_maybe_expand (array, length - array-&gt;len);
 596 
 597       if (array-&gt;clear)
 598         g_array_elt_zero (array, array-&gt;len, length - array-&gt;len);
 599     }
 600   else if (length &lt; array-&gt;len)
 601     g_array_remove_range (farray, length, array-&gt;len - length);
 602 
 603   array-&gt;len = length;
 604 
 605   g_array_zero_terminate (array);
 606 
 607   return farray;
 608 }
 609 
 610 /**
 611  * g_array_remove_index:
 612  * @array: a #GArray
 613  * @index_: the index of the element to remove
 614  *
 615  * Removes the element at the given index from a #GArray. The following
 616  * elements are moved down one place.
 617  *
 618  * Returns: the #GArray
 619  */
 620 GArray*
 621 g_array_remove_index (GArray *farray,
 622                       guint   index_)
 623 {
 624   GRealArray* array = (GRealArray*) farray;
 625 
 626   g_return_val_if_fail (array, NULL);
 627 
 628   g_return_val_if_fail (index_ &lt; array-&gt;len, NULL);
 629 
 630   if (array-&gt;clear_func != NULL)
 631     array-&gt;clear_func (g_array_elt_pos (array, index_));
 632 
 633   if (index_ != array-&gt;len - 1)
 634     memmove (g_array_elt_pos (array, index_),
 635              g_array_elt_pos (array, index_ + 1),
 636              g_array_elt_len (array, array-&gt;len - index_ - 1));
 637 
 638   array-&gt;len -= 1;
 639 
 640   if (G_UNLIKELY (g_mem_gc_friendly))
 641     g_array_elt_zero (array, array-&gt;len, 1);
 642   else
 643     g_array_zero_terminate (array);
 644 
 645   return farray;
 646 }
 647 
 648 /**
 649  * g_array_remove_index_fast:
 650  * @array: a @GArray
 651  * @index_: the index of the element to remove
 652  *
 653  * Removes the element at the given index from a #GArray. The last
 654  * element in the array is used to fill in the space, so this function
 655  * does not preserve the order of the #GArray. But it is faster than
 656  * g_array_remove_index().
 657  *
 658  * Returns: the #GArray
 659  */
 660 GArray*
 661 g_array_remove_index_fast (GArray *farray,
 662                            guint   index_)
 663 {
 664   GRealArray* array = (GRealArray*) farray;
 665 
 666   g_return_val_if_fail (array, NULL);
 667 
 668   g_return_val_if_fail (index_ &lt; array-&gt;len, NULL);
 669 
 670   if (array-&gt;clear_func != NULL)
 671     array-&gt;clear_func (g_array_elt_pos (array, index_));
 672 
 673   if (index_ != array-&gt;len - 1)
 674     memcpy (g_array_elt_pos (array, index_),
 675             g_array_elt_pos (array, array-&gt;len - 1),
 676             g_array_elt_len (array, 1));
 677 
 678   array-&gt;len -= 1;
 679 
 680   if (G_UNLIKELY (g_mem_gc_friendly))
 681     g_array_elt_zero (array, array-&gt;len, 1);
 682   else
 683     g_array_zero_terminate (array);
 684 
 685   return farray;
 686 }
 687 
 688 /**
 689  * g_array_remove_range:
 690  * @array: a @GArray
 691  * @index_: the index of the first element to remove
 692  * @length: the number of elements to remove
 693  *
 694  * Removes the given number of elements starting at the given index
 695  * from a #GArray.  The following elements are moved to close the gap.
 696  *
 697  * Returns: the #GArray
 698  *
 699  * Since: 2.4
 700  */
 701 GArray*
 702 g_array_remove_range (GArray *farray,
 703                       guint   index_,
 704                       guint   length)
 705 {
 706   GRealArray *array = (GRealArray*) farray;
 707 
 708   g_return_val_if_fail (array, NULL);
 709   g_return_val_if_fail (index_ &lt;= array-&gt;len, NULL);
 710   g_return_val_if_fail (index_ + length &lt;= array-&gt;len, NULL);
 711 
 712   if (array-&gt;clear_func != NULL)
 713     {
 714       guint i;
 715 
 716       for (i = 0; i &lt; length; i++)
 717         array-&gt;clear_func (g_array_elt_pos (array, index_ + i));
 718     }
 719 
 720   if (index_ + length != array-&gt;len)
 721     memmove (g_array_elt_pos (array, index_),
 722              g_array_elt_pos (array, index_ + length),
 723              (array-&gt;len - (index_ + length)) * array-&gt;elt_size);
 724 
 725   array-&gt;len -= length;
 726   if (G_UNLIKELY (g_mem_gc_friendly))
 727     g_array_elt_zero (array, array-&gt;len, length);
 728   else
 729     g_array_zero_terminate (array);
 730 
 731   return farray;
 732 }
 733 
 734 /**
 735  * g_array_sort:
 736  * @array: a #GArray
 737  * @compare_func: comparison function
 738  *
 739  * Sorts a #GArray using @compare_func which should be a qsort()-style
 740  * comparison function (returns less than zero for first arg is less
 741  * than second arg, zero for equal, greater zero if first arg is
 742  * greater than second arg).
 743  *
 744  * This is guaranteed to be a stable sort since version 2.32.
 745  */
 746 void
 747 g_array_sort (GArray       *farray,
 748               GCompareFunc  compare_func)
 749 {
 750   GRealArray *array = (GRealArray*) farray;
 751 
 752   g_return_if_fail (array != NULL);
 753 
 754   /* Don&#39;t use qsort as we want a guaranteed stable sort */
 755   g_qsort_with_data (array-&gt;data,
 756                      array-&gt;len,
 757                      array-&gt;elt_size,
 758                      (GCompareDataFunc)compare_func,
 759                      NULL);
 760 }
 761 
 762 /**
 763  * g_array_sort_with_data:
 764  * @array: a #GArray
 765  * @compare_func: comparison function
 766  * @user_data: data to pass to @compare_func
 767  *
 768  * Like g_array_sort(), but the comparison function receives an extra
 769  * user data argument.
 770  *
 771  * This is guaranteed to be a stable sort since version 2.32.
 772  *
 773  * There used to be a comment here about making the sort stable by
 774  * using the addresses of the elements in the comparison function.
 775  * This did not actually work, so any such code should be removed.
 776  */
 777 void
 778 g_array_sort_with_data (GArray           *farray,
 779                         GCompareDataFunc  compare_func,
 780                         gpointer          user_data)
 781 {
 782   GRealArray *array = (GRealArray*) farray;
 783 
 784   g_return_if_fail (array != NULL);
 785 
 786   g_qsort_with_data (array-&gt;data,
 787                      array-&gt;len,
 788                      array-&gt;elt_size,
 789                      compare_func,
 790                      user_data);
 791 }
 792 
 793 /* Returns the smallest power of 2 greater than n, or n if
 794  * such power does not fit in a guint
 795  */
 796 static guint
 797 g_nearest_pow (guint num)
 798 {
 799   guint n = 1;
 800 
 801   while (n &lt; num &amp;&amp; n &gt; 0)
 802     n &lt;&lt;= 1;
 803 
 804   return n ? n : num;
 805 }
 806 
 807 static void
 808 g_array_maybe_expand (GRealArray *array,
 809                       guint       len)
 810 {
 811   guint want_alloc;
 812 
 813   /* Detect potential overflow */
 814   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
 815     g_error (&quot;adding %u to array would overflow&quot;, len);
 816 
 817   want_alloc = g_array_elt_len (array, array-&gt;len + len +
 818                                       array-&gt;zero_terminated);
 819 
 820   if (want_alloc &gt; array-&gt;alloc)
 821     {
 822       want_alloc = g_nearest_pow (want_alloc);
 823       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
 824 
 825       array-&gt;data = g_realloc (array-&gt;data, want_alloc);
 826 
 827       if (G_UNLIKELY (g_mem_gc_friendly))
 828         memset (array-&gt;data + array-&gt;alloc, 0, want_alloc - array-&gt;alloc);
 829 
 830       array-&gt;alloc = want_alloc;
 831     }
 832 }
 833 
 834 /**
 835  * SECTION:arrays_pointer
 836  * @title: Pointer Arrays
 837  * @short_description: arrays of pointers to any type of data, which
 838  *     grow automatically as new elements are added
 839  *
 840  * Pointer Arrays are similar to Arrays but are used only for storing
 841  * pointers.
 842  *
 843  * If you remove elements from the array, elements at the end of the
 844  * array are moved into the space previously occupied by the removed
 845  * element. This means that you should not rely on the index of particular
 846  * elements remaining the same. You should also be careful when deleting
 847  * elements while iterating over the array.
 848  *
 849  * To create a pointer array, use g_ptr_array_new().
 850  *
 851  * To add elements to a pointer array, use g_ptr_array_add().
 852  *
 853  * To remove elements from a pointer array, use g_ptr_array_remove(),
 854  * g_ptr_array_remove_index() or g_ptr_array_remove_index_fast().
 855  *
 856  * To access an element of a pointer array, use g_ptr_array_index().
 857  *
 858  * To set the size of a pointer array, use g_ptr_array_set_size().
 859  *
 860  * To free a pointer array, use g_ptr_array_free().
 861  *
 862  * An example using a #GPtrArray:
 863  * |[&lt;!-- language=&quot;C&quot; --&gt;
 864  *   GPtrArray *array;
 865  *   gchar *string1 = &quot;one&quot;;
 866  *   gchar *string2 = &quot;two&quot;;
 867  *   gchar *string3 = &quot;three&quot;;
 868  *
 869  *   array = g_ptr_array_new ();
 870  *   g_ptr_array_add (array, (gpointer) string1);
 871  *   g_ptr_array_add (array, (gpointer) string2);
 872  *   g_ptr_array_add (array, (gpointer) string3);
 873  *
 874  *   if (g_ptr_array_index (array, 0) != (gpointer) string1)
 875  *     g_print (&quot;ERROR: got %p instead of %p\n&quot;,
 876  *              g_ptr_array_index (array, 0), string1);
 877  *
 878  *   g_ptr_array_free (array, TRUE);
 879  * ]|
 880  */
 881 
 882 typedef struct _GRealPtrArray  GRealPtrArray;
 883 
 884 /**
 885  * GPtrArray:
 886  * @pdata: points to the array of pointers, which may be moved when the
 887  *     array grows
 888  * @len: number of pointers in the array
 889  *
 890  * Contains the public fields of a pointer array.
 891  */
 892 struct _GRealPtrArray
 893 {
 894   gpointer       *pdata;
 895   guint           len;
 896   guint           alloc;
 897   gatomicrefcount ref_count;
 898   GDestroyNotify  element_free_func;
 899 };
 900 
 901 /**
 902  * g_ptr_array_index:
 903  * @array: a #GPtrArray
 904  * @index_: the index of the pointer to return
 905  *
 906  * Returns the pointer at the given index of the pointer array.
 907  *
 908  * This does not perform bounds checking on the given @index_,
 909  * so you are responsible for checking it against the array length.
 910  *
 911  * Returns: the pointer at the given index
 912  */
 913 
 914 static void g_ptr_array_maybe_expand (GRealPtrArray *array,
 915                                       gint           len);
 916 
 917 /**
 918  * g_ptr_array_new:
 919  *
 920  * Creates a new #GPtrArray with a reference count of 1.
 921  *
 922  * Returns: the new #GPtrArray
 923  */
 924 GPtrArray*
 925 g_ptr_array_new (void)
 926 {
 927   return g_ptr_array_sized_new (0);
 928 }
 929 
 930 /**
 931  * g_ptr_array_sized_new:
 932  * @reserved_size: number of pointers preallocated
 933  *
 934  * Creates a new #GPtrArray with @reserved_size pointers preallocated
 935  * and a reference count of 1. This avoids frequent reallocation, if
 936  * you are going to add many pointers to the array. Note however that
 937  * the size of the array is still 0.
 938  *
 939  * Returns: the new #GPtrArray
 940  */
 941 GPtrArray*
 942 g_ptr_array_sized_new (guint reserved_size)
 943 {
 944   GRealPtrArray *array;
 945 
 946   array = g_slice_new (GRealPtrArray);
 947 #ifdef GSTREAMER_LITE
 948   if (array == NULL) {
 949     return NULL;
 950   }
 951 #endif // GSTREAMER_LITE
 952 
 953   array-&gt;pdata = NULL;
 954   array-&gt;len = 0;
 955   array-&gt;alloc = 0;
 956   array-&gt;element_free_func = NULL;
 957 
 958   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
 959 
 960   if (reserved_size != 0)
 961     g_ptr_array_maybe_expand (array, reserved_size);
 962 
 963   return (GPtrArray*) array;
 964 }
 965 
 966 /**
 967  * g_ptr_array_new_with_free_func:
 968  * @element_free_func: (nullable): A function to free elements with
 969  *     destroy @array or %NULL
 970  *
 971  * Creates a new #GPtrArray with a reference count of 1 and use
 972  * @element_free_func for freeing each element when the array is destroyed
 973  * either via g_ptr_array_unref(), when g_ptr_array_free() is called with
 974  * @free_segment set to %TRUE or when removing elements.
 975  *
 976  * Returns: A new #GPtrArray
 977  *
 978  * Since: 2.22
 979  */
 980 GPtrArray*
 981 g_ptr_array_new_with_free_func (GDestroyNotify element_free_func)
 982 {
 983   GPtrArray *array;
 984 
 985   array = g_ptr_array_new ();
 986   g_ptr_array_set_free_func (array, element_free_func);
 987 
 988   return array;
 989 }
 990 
 991 /**
 992  * g_ptr_array_new_full:
 993  * @reserved_size: number of pointers preallocated
 994  * @element_free_func: (nullable): A function to free elements with
 995  *     destroy @array or %NULL
 996  *
 997  * Creates a new #GPtrArray with @reserved_size pointers preallocated
 998  * and a reference count of 1. This avoids frequent reallocation, if
 999  * you are going to add many pointers to the array. Note however that
1000  * the size of the array is still 0. It also set @element_free_func
1001  * for freeing each element when the array is destroyed either via
1002  * g_ptr_array_unref(), when g_ptr_array_free() is called with
1003  * @free_segment set to %TRUE or when removing elements.
1004  *
1005  * Returns: A new #GPtrArray
1006  *
1007  * Since: 2.30
1008  */
1009 GPtrArray*
1010 g_ptr_array_new_full (guint          reserved_size,
1011                       GDestroyNotify element_free_func)
1012 {
1013   GPtrArray *array;
1014 
1015   array = g_ptr_array_sized_new (reserved_size);
1016   g_ptr_array_set_free_func (array, element_free_func);
1017 
1018   return array;
1019 }
1020 
1021 /**
1022  * g_ptr_array_set_free_func:
1023  * @array: A #GPtrArray
1024  * @element_free_func: (nullable): A function to free elements with
1025  *     destroy @array or %NULL
1026  *
1027  * Sets a function for freeing each element when @array is destroyed
1028  * either via g_ptr_array_unref(), when g_ptr_array_free() is called
1029  * with @free_segment set to %TRUE or when removing elements.
1030  *
1031  * Since: 2.22
1032  */
1033 void
1034 g_ptr_array_set_free_func (GPtrArray      *array,
1035                            GDestroyNotify  element_free_func)
1036 {
1037   GRealPtrArray *rarray = (GRealPtrArray *)array;
1038 
1039   g_return_if_fail (array);
1040 #ifdef GSTREAMER_LITE
1041   if (array == NULL)
1042     return;
1043 #endif // GSTREAMER_LITE
1044 
1045   rarray-&gt;element_free_func = element_free_func;
1046 }
1047 
1048 /**
1049  * g_ptr_array_ref:
1050  * @array: a #GPtrArray
1051  *
1052  * Atomically increments the reference count of @array by one.
1053  * This function is thread-safe and may be called from any thread.
1054  *
1055  * Returns: The passed in #GPtrArray
1056  *
1057  * Since: 2.22
1058  */
1059 GPtrArray*
1060 g_ptr_array_ref (GPtrArray *array)
1061 {
1062   GRealPtrArray *rarray = (GRealPtrArray *)array;
1063 
1064   g_return_val_if_fail (array, NULL);
1065 
1066   g_atomic_ref_count_inc (&amp;rarray-&gt;ref_count);
1067 
1068   return array;
1069 }
1070 
1071 static gpointer *ptr_array_free (GPtrArray *, ArrayFreeFlags);
1072 
1073 /**
1074  * g_ptr_array_unref:
1075  * @array: A #GPtrArray
1076  *
1077  * Atomically decrements the reference count of @array by one. If the
1078  * reference count drops to 0, the effect is the same as calling
1079  * g_ptr_array_free() with @free_segment set to %TRUE. This function
1080  * is thread-safe and may be called from any thread.
1081  *
1082  * Since: 2.22
1083  */
1084 void
1085 g_ptr_array_unref (GPtrArray *array)
1086 {
1087   GRealPtrArray *rarray = (GRealPtrArray *)array;
1088 
1089   g_return_if_fail (array);
1090 
1091   if (g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
1092     ptr_array_free (array, FREE_SEGMENT);
1093 }
1094 
1095 /**
1096  * g_ptr_array_free:
1097  * @array: a #GPtrArray
1098  * @free_seg: if %TRUE the actual pointer array is freed as well
1099  *
1100  * Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
1101  * it frees the memory block holding the elements as well. Pass %FALSE
1102  * if you want to free the #GPtrArray wrapper but preserve the
1103  * underlying array for use elsewhere. If the reference count of @array
1104  * is greater than one, the #GPtrArray wrapper is preserved but the
1105  * size of @array will be set to zero.
1106  *
1107  * If array contents point to dynamically-allocated memory, they should
1108  * be freed separately if @free_seg is %TRUE and no #GDestroyNotify
1109  * function has been set for @array.
1110  *
1111  * This function is not thread-safe. If using a #GPtrArray from multiple
1112  * threads, use only the atomic g_ptr_array_ref() and g_ptr_array_unref()
1113  * functions.
1114  *
1115  * Returns: the pointer array if @free_seg is %FALSE, otherwise %NULL.
1116  *     The pointer array should be freed using g_free().
1117  */
1118 gpointer*
1119 g_ptr_array_free (GPtrArray *array,
1120                   gboolean   free_segment)
1121 {
1122   GRealPtrArray *rarray = (GRealPtrArray *)array;
1123   ArrayFreeFlags flags;
1124 
1125   g_return_val_if_fail (rarray, NULL);
1126 
1127   flags = (free_segment ? FREE_SEGMENT : 0);
1128 
1129   /* if others are holding a reference, preserve the wrapper but
1130    * do free/return the data
1131    */
1132   if (!g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
1133     flags |= PRESERVE_WRAPPER;
1134 
1135   return ptr_array_free (array, flags);
1136 }
1137 
1138 static gpointer *
1139 ptr_array_free (GPtrArray      *array,
1140                 ArrayFreeFlags  flags)
1141 {
1142   GRealPtrArray *rarray = (GRealPtrArray *)array;
1143   gpointer *segment;
1144 
1145   if (flags &amp; FREE_SEGMENT)
1146     {
1147       /* Data here is stolen and freed manually. It is an
1148        * error to attempt to access the array data (including
1149        * mutating the array bounds) during destruction).
1150        *
1151        * https://bugzilla.gnome.org/show_bug.cgi?id=769064
1152        */
1153       gpointer *stolen_pdata = g_steal_pointer (&amp;rarray-&gt;pdata);
1154       if (rarray-&gt;element_free_func != NULL)
1155         {
1156           gsize i;
1157           for (i = 0; i &lt; rarray-&gt;len; ++i)
1158             rarray-&gt;element_free_func (stolen_pdata[i]);
1159         }
1160 
1161       g_free (stolen_pdata);
1162       segment = NULL;
1163     }
1164   else
1165     segment = rarray-&gt;pdata;
1166 
1167   if (flags &amp; PRESERVE_WRAPPER)
1168     {
1169       rarray-&gt;pdata = NULL;
1170       rarray-&gt;len = 0;
1171       rarray-&gt;alloc = 0;
1172     }
1173   else
1174     {
1175       g_slice_free1 (sizeof (GRealPtrArray), rarray);
1176     }
1177 
1178   return segment;
1179 }
1180 
1181 static void
1182 g_ptr_array_maybe_expand (GRealPtrArray *array,
1183                           gint           len)
1184 {
1185   /* Detect potential overflow */
1186   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
1187     g_error (&quot;adding %u to array would overflow&quot;, len);
1188 
1189   if ((array-&gt;len + len) &gt; array-&gt;alloc)
1190     {
1191       guint old_alloc = array-&gt;alloc;
1192       array-&gt;alloc = g_nearest_pow (array-&gt;len + len);
1193       array-&gt;alloc = MAX (array-&gt;alloc, MIN_ARRAY_SIZE);
1194       array-&gt;pdata = g_realloc (array-&gt;pdata, sizeof (gpointer) * array-&gt;alloc);
1195       if (G_UNLIKELY (g_mem_gc_friendly))
1196         for ( ; old_alloc &lt; array-&gt;alloc; old_alloc++)
1197           array-&gt;pdata [old_alloc] = NULL;
1198     }
1199 }
1200 
1201 /**
1202  * g_ptr_array_set_size:
1203  * @array: a #GPtrArray
1204  * @length: the new length of the pointer array
1205  *
1206  * Sets the size of the array. When making the array larger,
1207  * newly-added elements will be set to %NULL. When making it smaller,
1208  * if @array has a non-%NULL #GDestroyNotify function then it will be
1209  * called for the removed elements.
1210  */
1211 void
1212 g_ptr_array_set_size  (GPtrArray *array,
1213                        gint       length)
1214 {
1215   GRealPtrArray *rarray = (GRealPtrArray *)array;
1216   guint length_unsigned;
1217 
1218   g_return_if_fail (rarray);
1219   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1220   g_return_if_fail (length &gt;= 0);
1221 
1222   length_unsigned = (guint) length;
1223 
1224   if (length_unsigned &gt; rarray-&gt;len)
1225     {
1226       guint i;
1227       g_ptr_array_maybe_expand (rarray, (length_unsigned - rarray-&gt;len));
1228       /* This is not
1229        *     memset (array-&gt;pdata + array-&gt;len, 0,
1230        *            sizeof (gpointer) * (length_unsigned - array-&gt;len));
1231        * to make it really portable. Remember (void*)NULL needn&#39;t be
1232        * bitwise zero. It of course is silly not to use memset (..,0,..).
1233        */
1234       for (i = rarray-&gt;len; i &lt; length_unsigned; i++)
1235         rarray-&gt;pdata[i] = NULL;
1236     }
1237   else if (length_unsigned &lt; rarray-&gt;len)
1238     g_ptr_array_remove_range (array, length_unsigned, rarray-&gt;len - length_unsigned);
1239 
1240   rarray-&gt;len = length_unsigned;
1241 }
1242 
1243 static gpointer
1244 ptr_array_remove_index (GPtrArray *array,
1245                         guint      index_,
1246                         gboolean   fast,
1247                         gboolean   free_element)
1248 {
1249   GRealPtrArray *rarray = (GRealPtrArray *) array;
1250   gpointer result;
1251 
1252   g_return_val_if_fail (rarray, NULL);
1253   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), NULL);
1254 
1255   g_return_val_if_fail (index_ &lt; rarray-&gt;len, NULL);
1256 
1257   result = rarray-&gt;pdata[index_];
1258 
1259   if (rarray-&gt;element_free_func != NULL &amp;&amp; free_element)
1260     rarray-&gt;element_free_func (rarray-&gt;pdata[index_]);
1261 
1262   if (index_ != rarray-&gt;len - 1 &amp;&amp; !fast)
1263     memmove (rarray-&gt;pdata + index_, rarray-&gt;pdata + index_ + 1,
1264              sizeof (gpointer) * (rarray-&gt;len - index_ - 1));
1265   else if (index_ != rarray-&gt;len - 1)
1266     rarray-&gt;pdata[index_] = rarray-&gt;pdata[rarray-&gt;len - 1];
1267 
1268   rarray-&gt;len -= 1;
1269 
1270   if (G_UNLIKELY (g_mem_gc_friendly))
1271     rarray-&gt;pdata[rarray-&gt;len] = NULL;
1272 
1273   return result;
1274 }
1275 
1276 /**
1277  * g_ptr_array_remove_index:
1278  * @array: a #GPtrArray
1279  * @index_: the index of the pointer to remove
1280  *
1281  * Removes the pointer at the given index from the pointer array.
1282  * The following elements are moved down one place. If @array has
1283  * a non-%NULL #GDestroyNotify function it is called for the removed
1284  * element. If so, the return value from this function will potentially point
1285  * to freed memory (depending on the #GDestroyNotify implementation).
1286  *
1287  * Returns: (nullable): the pointer which was removed
1288  */
1289 gpointer
1290 g_ptr_array_remove_index (GPtrArray *array,
1291                           guint      index_)
1292 {
1293   return ptr_array_remove_index (array, index_, FALSE, TRUE);
1294 }
1295 
1296 /**
1297  * g_ptr_array_remove_index_fast:
1298  * @array: a #GPtrArray
1299  * @index_: the index of the pointer to remove
1300  *
1301  * Removes the pointer at the given index from the pointer array.
1302  * The last element in the array is used to fill in the space, so
1303  * this function does not preserve the order of the array. But it
1304  * is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
1305  * #GDestroyNotify function it is called for the removed element. If so, the
1306  * return value from this function will potentially point to freed memory
1307  * (depending on the #GDestroyNotify implementation).
1308  *
1309  * Returns: (nullable): the pointer which was removed
1310  */
1311 gpointer
1312 g_ptr_array_remove_index_fast (GPtrArray *array,
1313                                guint      index_)
1314 {
1315   return ptr_array_remove_index (array, index_, TRUE, TRUE);
1316 }
1317 
1318 /**
1319  * g_ptr_array_steal_index:
1320  * @array: a #GPtrArray
1321  * @index_: the index of the pointer to steal
1322  *
1323  * Removes the pointer at the given index from the pointer array.
1324  * The following elements are moved down one place. The #GDestroyNotify for
1325  * @array is *not* called on the removed element; ownership is transferred to
1326  * the caller of this function.
1327  *
1328  * Returns: (transfer full) (nullable): the pointer which was removed
1329  * Since: 2.58
1330  */
1331 gpointer
1332 g_ptr_array_steal_index (GPtrArray *array,
1333                          guint      index_)
1334 {
1335   return ptr_array_remove_index (array, index_, FALSE, FALSE);
1336 }
1337 
1338 /**
1339  * g_ptr_array_steal_index_fast:
1340  * @array: a #GPtrArray
1341  * @index_: the index of the pointer to steal
1342  *
1343  * Removes the pointer at the given index from the pointer array.
1344  * The last element in the array is used to fill in the space, so
1345  * this function does not preserve the order of the array. But it
1346  * is faster than g_ptr_array_steal_index(). The #GDestroyNotify for @array is
1347  * *not* called on the removed element; ownership is transferred to the caller
1348  * of this function.
1349  *
1350  * Returns: (transfer full) (nullable): the pointer which was removed
1351  * Since: 2.58
1352  */
1353 gpointer
1354 g_ptr_array_steal_index_fast (GPtrArray *array,
1355                               guint      index_)
1356 {
1357   return ptr_array_remove_index (array, index_, TRUE, FALSE);
1358 }
1359 
1360 /**
1361  * g_ptr_array_remove_range:
1362  * @array: a @GPtrArray
1363  * @index_: the index of the first pointer to remove
1364  * @length: the number of pointers to remove
1365  *
1366  * Removes the given number of pointers starting at the given index
1367  * from a #GPtrArray. The following elements are moved to close the
1368  * gap. If @array has a non-%NULL #GDestroyNotify function it is
1369  * called for the removed elements.
1370  *
1371  * Returns: the @array
1372  *
1373  * Since: 2.4
1374  */
1375 GPtrArray*
1376 g_ptr_array_remove_range (GPtrArray *array,
1377                           guint      index_,
1378                           guint      length)
1379 {
1380   GRealPtrArray *rarray = (GRealPtrArray *)array;
1381   guint n;
1382 
1383   g_return_val_if_fail (rarray != NULL, NULL);
1384   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), NULL);
1385   g_return_val_if_fail (index_ &lt;= rarray-&gt;len, NULL);
1386   g_return_val_if_fail (index_ + length &lt;= rarray-&gt;len, NULL);
1387 
1388   if (rarray-&gt;element_free_func != NULL)
1389     {
1390       for (n = index_; n &lt; index_ + length; n++)
1391         rarray-&gt;element_free_func (rarray-&gt;pdata[n]);
1392     }
1393 
1394   if (index_ + length != rarray-&gt;len)
1395     {
1396       memmove (&amp;rarray-&gt;pdata[index_],
1397                &amp;rarray-&gt;pdata[index_ + length],
1398                (rarray-&gt;len - (index_ + length)) * sizeof (gpointer));
1399     }
1400 
1401   rarray-&gt;len -= length;
1402   if (G_UNLIKELY (g_mem_gc_friendly))
1403     {
1404       guint i;
1405       for (i = 0; i &lt; length; i++)
1406         rarray-&gt;pdata[rarray-&gt;len + i] = NULL;
1407     }
1408 
1409   return array;
1410 }
1411 
1412 /**
1413  * g_ptr_array_remove:
1414  * @array: a #GPtrArray
1415  * @data: the pointer to remove
1416  *
1417  * Removes the first occurrence of the given pointer from the pointer
1418  * array. The following elements are moved down one place. If @array
1419  * has a non-%NULL #GDestroyNotify function it is called for the
1420  * removed element.
1421  *
1422  * It returns %TRUE if the pointer was removed, or %FALSE if the
1423  * pointer was not found.
1424  *
1425  * Returns: %TRUE if the pointer is removed, %FALSE if the pointer
1426  *     is not found in the array
1427  */
1428 gboolean
1429 g_ptr_array_remove (GPtrArray *array,
1430                     gpointer   data)
1431 {
1432   guint i;
1433 
1434   g_return_val_if_fail (array, FALSE);
1435   g_return_val_if_fail (array-&gt;len == 0 || (array-&gt;len != 0 &amp;&amp; array-&gt;pdata != NULL), FALSE);
1436 
1437   for (i = 0; i &lt; array-&gt;len; i += 1)
1438     {
1439       if (array-&gt;pdata[i] == data)
1440         {
1441           g_ptr_array_remove_index (array, i);
1442           return TRUE;
1443         }
1444     }
1445 
1446   return FALSE;
1447 }
1448 
1449 /**
1450  * g_ptr_array_remove_fast:
1451  * @array: a #GPtrArray
1452  * @data: the pointer to remove
1453  *
1454  * Removes the first occurrence of the given pointer from the pointer
1455  * array. The last element in the array is used to fill in the space,
1456  * so this function does not preserve the order of the array. But it
1457  * is faster than g_ptr_array_remove(). If @array has a non-%NULL
1458  * #GDestroyNotify function it is called for the removed element.
1459  *
1460  * It returns %TRUE if the pointer was removed, or %FALSE if the
1461  * pointer was not found.
1462  *
1463  * Returns: %TRUE if the pointer was found in the array
1464  */
1465 gboolean
1466 g_ptr_array_remove_fast (GPtrArray *array,
1467                          gpointer   data)
1468 {
1469   GRealPtrArray *rarray = (GRealPtrArray *)array;
1470   guint i;
1471 
1472   g_return_val_if_fail (rarray, FALSE);
1473   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), FALSE);
1474 
1475   for (i = 0; i &lt; rarray-&gt;len; i += 1)
1476     {
1477       if (rarray-&gt;pdata[i] == data)
1478         {
1479           g_ptr_array_remove_index_fast (array, i);
1480           return TRUE;
1481         }
1482     }
1483 
1484   return FALSE;
1485 }
1486 
1487 /**
1488  * g_ptr_array_add:
1489  * @array: a #GPtrArray
1490  * @data: the pointer to add
1491  *
1492  * Adds a pointer to the end of the pointer array. The array will grow
1493  * in size automatically if necessary.
1494  */
1495 void
1496 g_ptr_array_add (GPtrArray *array,
1497                  gpointer   data)
1498 {
1499   GRealPtrArray *rarray = (GRealPtrArray *)array;
1500 
1501   g_return_if_fail (rarray);
1502   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1503 
1504   g_ptr_array_maybe_expand (rarray, 1);
1505 
1506   rarray-&gt;pdata[rarray-&gt;len++] = data;
1507 }
1508 
1509 /**
1510  * g_ptr_array_insert:
1511  * @array: a #GPtrArray
1512  * @index_: the index to place the new element at, or -1 to append
1513  * @data: the pointer to add.
1514  *
1515  * Inserts an element into the pointer array at the given index. The
1516  * array will grow in size automatically if necessary.
1517  *
1518  * Since: 2.40
1519  */
1520 void
1521 g_ptr_array_insert (GPtrArray *array,
1522                     gint       index_,
1523                     gpointer   data)
1524 {
1525   GRealPtrArray *rarray = (GRealPtrArray *)array;
1526 
1527   g_return_if_fail (rarray);
1528   g_return_if_fail (index_ &gt;= -1);
1529   g_return_if_fail (index_ &lt;= (gint)rarray-&gt;len);
1530 
1531   g_ptr_array_maybe_expand (rarray, 1);
1532 
1533   if (index_ &lt; 0)
1534     index_ = rarray-&gt;len;
1535 
1536   if (index_ &lt; rarray-&gt;len)
1537     memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
1538              &amp;(rarray-&gt;pdata[index_]),
1539              (rarray-&gt;len - index_) * sizeof (gpointer));
1540 
1541   rarray-&gt;len++;
1542   rarray-&gt;pdata[index_] = data;
1543 }
1544 
1545 /**
1546  * g_ptr_array_sort:
1547  * @array: a #GPtrArray
1548  * @compare_func: comparison function
1549  *
1550  * Sorts the array, using @compare_func which should be a qsort()-style
1551  * comparison function (returns less than zero for first arg is less
1552  * than second arg, zero for equal, greater than zero if irst arg is
1553  * greater than second arg).
1554  *
1555  * Note that the comparison function for g_ptr_array_sort() doesn&#39;t
1556  * take the pointers from the array as arguments, it takes pointers to
1557  * the pointers in the array.
1558  *
1559  * This is guaranteed to be a stable sort since version 2.32.
1560  */
1561 void
1562 g_ptr_array_sort (GPtrArray    *array,
1563                   GCompareFunc  compare_func)
1564 {
1565   g_return_if_fail (array != NULL);
1566 
1567   /* Don&#39;t use qsort as we want a guaranteed stable sort */
1568   g_qsort_with_data (array-&gt;pdata,
1569                      array-&gt;len,
1570                      sizeof (gpointer),
1571                      (GCompareDataFunc)compare_func,
1572                      NULL);
1573 }
1574 
1575 /**
1576  * g_ptr_array_sort_with_data:
1577  * @array: a #GPtrArray
1578  * @compare_func: comparison function
1579  * @user_data: data to pass to @compare_func
1580  *
1581  * Like g_ptr_array_sort(), but the comparison function has an extra
1582  * user data argument.
1583  *
1584  * Note that the comparison function for g_ptr_array_sort_with_data()
1585  * doesn&#39;t take the pointers from the array as arguments, it takes
1586  * pointers to the pointers in the array.
1587  *
1588  * This is guaranteed to be a stable sort since version 2.32.
1589  */
1590 void
1591 g_ptr_array_sort_with_data (GPtrArray        *array,
1592                             GCompareDataFunc  compare_func,
1593                             gpointer          user_data)
1594 {
1595   g_return_if_fail (array != NULL);
1596 
1597   g_qsort_with_data (array-&gt;pdata,
1598                      array-&gt;len,
1599                      sizeof (gpointer),
1600                      compare_func,
1601                      user_data);
1602 }
1603 
1604 /**
1605  * g_ptr_array_foreach:
1606  * @array: a #GPtrArray
1607  * @func: the function to call for each array element
1608  * @user_data: user data to pass to the function
1609  *
1610  * Calls a function for each element of a #GPtrArray. @func must not
1611  * add elements to or remove elements from the array.
1612  *
1613  * Since: 2.4
1614  */
1615 void
1616 g_ptr_array_foreach (GPtrArray *array,
1617                      GFunc      func,
1618                      gpointer   user_data)
1619 {
1620   guint i;
1621 
1622   g_return_if_fail (array);
1623 
1624   for (i = 0; i &lt; array-&gt;len; i++)
1625     (*func) (array-&gt;pdata[i], user_data);
1626 }
1627 
1628 /**
1629  * g_ptr_array_find: (skip)
1630  * @haystack: pointer array to be searched
1631  * @needle: pointer to look for
1632  * @index_: (optional) (out caller-allocates): return location for the index of
1633  *    the element, if found
1634  *
1635  * Checks whether @needle exists in @haystack. If the element is found, %TRUE is
1636  * returned and the element&#39;s index is returned in @index_ (if non-%NULL).
1637  * Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
1638  * multiple times in @haystack, the index of the first instance is returned.
1639  *
1640  * This does pointer comparisons only. If you want to use more complex equality
1641  * checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
1642  *
1643  * Returns: %TRUE if @needle is one of the elements of @haystack
1644  * Since: 2.54
1645  */
1646 gboolean
1647 g_ptr_array_find (GPtrArray     *haystack,
1648                   gconstpointer  needle,
1649                   guint         *index_)
1650 {
1651   return g_ptr_array_find_with_equal_func (haystack, needle, NULL, index_);
1652 }
1653 
1654 /**
1655  * g_ptr_array_find_with_equal_func: (skip)
1656  * @haystack: pointer array to be searched
1657  * @needle: pointer to look for
1658  * @equal_func: (nullable): the function to call for each element, which should
1659  *    return %TRUE when the desired element is found; or %NULL to use pointer
1660  *    equality
1661  * @index_: (optional) (out caller-allocates): return location for the index of
1662  *    the element, if found
1663  *
1664  * Checks whether @needle exists in @haystack, using the given @equal_func.
1665  * If the element is found, %TRUE is returned and the element&#39;s index is
1666  * returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
1667  * is undefined. If @needle exists multiple times in @haystack, the index of
1668  * the first instance is returned.
1669  *
1670  * @equal_func is called with the element from the array as its first parameter,
1671  * and @needle as its second parameter. If @equal_func is %NULL, pointer
1672  * equality is used.
1673  *
1674  * Returns: %TRUE if @needle is one of the elements of @haystack
1675  * Since: 2.54
1676  */
1677 gboolean
1678 g_ptr_array_find_with_equal_func (GPtrArray     *haystack,
1679                                   gconstpointer  needle,
1680                                   GEqualFunc     equal_func,
1681                                   guint         *index_)
1682 {
1683   guint i;
1684 
1685   g_return_val_if_fail (haystack != NULL, FALSE);
1686 
1687   if (equal_func == NULL)
1688     equal_func = g_direct_equal;
1689 
1690   for (i = 0; i &lt; haystack-&gt;len; i++)
1691     {
1692       if (equal_func (g_ptr_array_index (haystack, i), needle))
1693         {
1694           if (index_ != NULL)
1695             *index_ = i;
1696           return TRUE;
1697         }
1698     }
1699 
1700   return FALSE;
1701 }
1702 
1703 /**
1704  * SECTION:arrays_byte
1705  * @title: Byte Arrays
1706  * @short_description: arrays of bytes
1707  *
1708  * #GByteArray is a mutable array of bytes based on #GArray, to provide arrays
1709  * of bytes which grow automatically as elements are added.
1710  *
1711  * To create a new #GByteArray use g_byte_array_new(). To add elements to a
1712  * #GByteArray, use g_byte_array_append(), and g_byte_array_prepend().
1713  *
1714  * To set the size of a #GByteArray, use g_byte_array_set_size().
1715  *
1716  * To free a #GByteArray, use g_byte_array_free().
1717  *
1718  * An example for using a #GByteArray:
1719  * |[&lt;!-- language=&quot;C&quot; --&gt;
1720  *   GByteArray *gbarray;
1721  *   gint i;
1722  *
1723  *   gbarray = g_byte_array_new ();
1724  *   for (i = 0; i &lt; 10000; i++)
1725  *     g_byte_array_append (gbarray, (guint8*) &quot;abcd&quot;, 4);
1726  *
1727  *   for (i = 0; i &lt; 10000; i++)
1728  *     {
1729  *       g_assert (gbarray-&gt;data[4*i] == &#39;a&#39;);
1730  *       g_assert (gbarray-&gt;data[4*i+1] == &#39;b&#39;);
1731  *       g_assert (gbarray-&gt;data[4*i+2] == &#39;c&#39;);
1732  *       g_assert (gbarray-&gt;data[4*i+3] == &#39;d&#39;);
1733  *     }
1734  *
1735  *   g_byte_array_free (gbarray, TRUE);
1736  * ]|
1737  *
1738  * See #GBytes if you are interested in an immutable object representing a
1739  * sequence of bytes.
1740  */
1741 
1742 /**
1743  * GByteArray:
1744  * @data: a pointer to the element data. The data may be moved as
1745  *     elements are added to the #GByteArray
1746  * @len: the number of elements in the #GByteArray
1747  *
1748  * Contains the public fields of a GByteArray.
1749  */
1750 
1751 /**
1752  * g_byte_array_new:
1753  *
1754  * Creates a new #GByteArray with a reference count of 1.
1755  *
1756  * Returns: (transfer full): the new #GByteArray
1757  */
1758 GByteArray*
1759 g_byte_array_new (void)
1760 {
1761   return (GByteArray *)g_array_sized_new (FALSE, FALSE, 1, 0);
1762 }
1763 
1764 /**
1765  * g_byte_array_new_take:
1766  * @data: (transfer full) (array length=len): byte data for the array
1767  * @len: length of @data
1768  *
1769  * Create byte array containing the data. The data will be owned by the array
1770  * and will be freed with g_free(), i.e. it could be allocated using g_strdup().
1771  *
1772  * Since: 2.32
1773  *
1774  * Returns: (transfer full): a new #GByteArray
1775  */
1776 GByteArray*
1777 g_byte_array_new_take (guint8 *data,
1778                        gsize   len)
1779 {
1780   GByteArray *array;
1781   GRealArray *real;
1782 
1783   array = g_byte_array_new ();
1784 #ifdef GSTREAMER_LITE
1785   if (array == NULL)
1786     return NULL;
1787 #endif // GSTREAMER_LITE
1788   real = (GRealArray *)array;
1789   g_assert (real-&gt;data == NULL);
1790   g_assert (real-&gt;len == 0);
1791 
1792   real-&gt;data = data;
1793   real-&gt;len = len;
1794   real-&gt;alloc = len;
1795 
1796   return array;
1797 }
1798 
1799 /**
1800  * g_byte_array_sized_new:
1801  * @reserved_size: number of bytes preallocated
1802  *
1803  * Creates a new #GByteArray with @reserved_size bytes preallocated.
1804  * This avoids frequent reallocation, if you are going to add many
1805  * bytes to the array. Note however that the size of the array is still
1806  * 0.
1807  *
1808  * Returns: the new #GByteArray
1809  */
1810 GByteArray*
1811 g_byte_array_sized_new (guint reserved_size)
1812 {
1813   return (GByteArray *)g_array_sized_new (FALSE, FALSE, 1, reserved_size);
1814 }
1815 
1816 /**
1817  * g_byte_array_free:
1818  * @array: a #GByteArray
1819  * @free_segment: if %TRUE the actual byte data is freed as well
1820  *
1821  * Frees the memory allocated by the #GByteArray. If @free_segment is
1822  * %TRUE it frees the actual byte data. If the reference count of
1823  * @array is greater than one, the #GByteArray wrapper is preserved but
1824  * the size of @array will be set to zero.
1825  *
1826  * Returns: the element data if @free_segment is %FALSE, otherwise
1827  *          %NULL.  The element data should be freed using g_free().
1828  */
1829 guint8*
1830 g_byte_array_free (GByteArray *array,
1831                    gboolean    free_segment)
1832 {
1833   return (guint8 *)g_array_free ((GArray *)array, free_segment);
1834 }
1835 
1836 /**
1837  * g_byte_array_free_to_bytes:
1838  * @array: (transfer full): a #GByteArray
1839  *
1840  * Transfers the data from the #GByteArray into a new immutable #GBytes.
1841  *
1842  * The #GByteArray is freed unless the reference count of @array is greater
1843  * than one, the #GByteArray wrapper is preserved but the size of @array
1844  * will be set to zero.
1845  *
1846  * This is identical to using g_bytes_new_take() and g_byte_array_free()
1847  * together.
1848  *
1849  * Since: 2.32
1850  *
1851  * Returns: (transfer full): a new immutable #GBytes representing same
1852  *     byte data that was in the array
1853  */
1854 GBytes*
1855 g_byte_array_free_to_bytes (GByteArray *array)
1856 {
1857   gsize length;
1858 
1859   g_return_val_if_fail (array != NULL, NULL);
1860 
1861   length = array-&gt;len;
1862   return g_bytes_new_take (g_byte_array_free (array, FALSE), length);
1863 }
1864 
1865 /**
1866  * g_byte_array_ref:
1867  * @array: A #GByteArray
1868  *
1869  * Atomically increments the reference count of @array by one.
1870  * This function is thread-safe and may be called from any thread.
1871  *
1872  * Returns: The passed in #GByteArray
1873  *
1874  * Since: 2.22
1875  */
1876 GByteArray*
1877 g_byte_array_ref (GByteArray *array)
1878 {
1879   return (GByteArray *)g_array_ref ((GArray *)array);
1880 }
1881 
1882 /**
1883  * g_byte_array_unref:
1884  * @array: A #GByteArray
1885  *
1886  * Atomically decrements the reference count of @array by one. If the
1887  * reference count drops to 0, all memory allocated by the array is
1888  * released. This function is thread-safe and may be called from any
1889  * thread.
1890  *
1891  * Since: 2.22
1892  */
1893 void
1894 g_byte_array_unref (GByteArray *array)
1895 {
1896   g_array_unref ((GArray *)array);
1897 }
1898 
1899 /**
1900  * g_byte_array_append:
1901  * @array: a #GByteArray
1902  * @data: the byte data to be added
1903  * @len: the number of bytes to add
1904  *
1905  * Adds the given bytes to the end of the #GByteArray.
1906  * The array will grow in size automatically if necessary.
1907  *
1908  * Returns: the #GByteArray
1909  */
1910 GByteArray*
1911 g_byte_array_append (GByteArray   *array,
1912                      const guint8 *data,
1913                      guint         len)
1914 {
1915   g_array_append_vals ((GArray *)array, (guint8 *)data, len);
1916 
1917   return array;
1918 }
1919 
1920 /**
1921  * g_byte_array_prepend:
1922  * @array: a #GByteArray
1923  * @data: the byte data to be added
1924  * @len: the number of bytes to add
1925  *
1926  * Adds the given data to the start of the #GByteArray.
1927  * The array will grow in size automatically if necessary.
1928  *
1929  * Returns: the #GByteArray
1930  */
1931 GByteArray*
1932 g_byte_array_prepend (GByteArray   *array,
1933                       const guint8 *data,
1934                       guint         len)
1935 {
1936   g_array_prepend_vals ((GArray *)array, (guint8 *)data, len);
1937 
1938   return array;
1939 }
1940 
1941 /**
1942  * g_byte_array_set_size:
1943  * @array: a #GByteArray
1944  * @length: the new size of the #GByteArray
1945  *
1946  * Sets the size of the #GByteArray, expanding it if necessary.
1947  *
1948  * Returns: the #GByteArray
1949  */
1950 GByteArray*
1951 g_byte_array_set_size (GByteArray *array,
1952                        guint       length)
1953 {
1954   g_array_set_size ((GArray *)array, length);
1955 
1956   return array;
1957 }
1958 
1959 /**
1960  * g_byte_array_remove_index:
1961  * @array: a #GByteArray
1962  * @index_: the index of the byte to remove
1963  *
1964  * Removes the byte at the given index from a #GByteArray.
1965  * The following bytes are moved down one place.
1966  *
1967  * Returns: the #GByteArray
1968  **/
1969 GByteArray*
1970 g_byte_array_remove_index (GByteArray *array,
1971                            guint       index_)
1972 {
1973   g_array_remove_index ((GArray *)array, index_);
1974 
1975   return array;
1976 }
1977 
1978 /**
1979  * g_byte_array_remove_index_fast:
1980  * @array: a #GByteArray
1981  * @index_: the index of the byte to remove
1982  *
1983  * Removes the byte at the given index from a #GByteArray. The last
1984  * element in the array is used to fill in the space, so this function
1985  * does not preserve the order of the #GByteArray. But it is faster
1986  * than g_byte_array_remove_index().
1987  *
1988  * Returns: the #GByteArray
1989  */
1990 GByteArray*
1991 g_byte_array_remove_index_fast (GByteArray *array,
1992                                 guint       index_)
1993 {
1994   g_array_remove_index_fast ((GArray *)array, index_);
1995 
1996   return array;
1997 }
1998 
1999 /**
2000  * g_byte_array_remove_range:
2001  * @array: a @GByteArray
2002  * @index_: the index of the first byte to remove
2003  * @length: the number of bytes to remove
2004  *
2005  * Removes the given number of bytes starting at the given index from a
2006  * #GByteArray.  The following elements are moved to close the gap.
2007  *
2008  * Returns: the #GByteArray
2009  *
2010  * Since: 2.4
2011  */
2012 GByteArray*
2013 g_byte_array_remove_range (GByteArray *array,
2014                            guint       index_,
2015                            guint       length)
2016 {
2017   g_return_val_if_fail (array, NULL);
2018   g_return_val_if_fail (index_ &lt;= array-&gt;len, NULL);
2019   g_return_val_if_fail (index_ + length &lt;= array-&gt;len, NULL);
2020 
2021   return (GByteArray *)g_array_remove_range ((GArray *)array, index_, length);
2022 }
2023 
2024 /**
2025  * g_byte_array_sort:
2026  * @array: a #GByteArray
2027  * @compare_func: comparison function
2028  *
2029  * Sorts a byte array, using @compare_func which should be a
2030  * qsort()-style comparison function (returns less than zero for first
2031  * arg is less than second arg, zero for equal, greater than zero if
2032  * first arg is greater than second arg).
2033  *
2034  * If two array elements compare equal, their order in the sorted array
2035  * is undefined. If you want equal elements to keep their order (i.e.
2036  * you want a stable sort) you can write a comparison function that,
2037  * if two elements would otherwise compare equal, compares them by
2038  * their addresses.
2039  */
2040 void
2041 g_byte_array_sort (GByteArray   *array,
2042                    GCompareFunc  compare_func)
2043 {
2044   g_array_sort ((GArray *)array, compare_func);
2045 }
2046 
2047 /**
2048  * g_byte_array_sort_with_data:
2049  * @array: a #GByteArray
2050  * @compare_func: comparison function
2051  * @user_data: data to pass to @compare_func
2052  *
2053  * Like g_byte_array_sort(), but the comparison function takes an extra
2054  * user data argument.
2055  */
2056 void
2057 g_byte_array_sort_with_data (GByteArray       *array,
2058                              GCompareDataFunc  compare_func,
2059                              gpointer          user_data)
2060 {
2061   g_array_sort_with_data ((GArray *)array, compare_func, user_data);
2062 }
    </pre>
  </body>
</html>