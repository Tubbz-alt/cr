<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/wavparse/gstwavparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* -*- Mode: C; tab-width: 2; indent-tabs-mode: t; c-basic-offset: 2 -*- */
   2 /* GStreamer
   3  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   4  * Copyright (C) &lt;2006&gt; Nokia Corporation, Stefan Kost &lt;stefan.kost@nokia.com&gt;.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:element-wavparse
  24  *
  25  * Parse a .wav file into raw or compressed audio.
  26  *
  27  * Wavparse supports both push and pull mode operations, making it possible to
  28  * stream from a network source.
  29  *
  30  * &lt;refsect2&gt;
  31  * &lt;title&gt;Example launch line&lt;/title&gt;
  32  * |[
  33  * gst-launch-1.0 filesrc location=sine.wav ! wavparse ! audioconvert ! alsasink
  34  * ]| Read a wav file and output to the soundcard using the ALSA element. The
  35  * wav file is assumed to contain raw uncompressed samples.
  36  * |[
  37  * gst-launch-1.0 gnomevfssrc location=http://www.example.org/sine.wav ! queue ! wavparse ! audioconvert ! alsasink
  38  * ]| Stream data from a network url.
  39  * &lt;/refsect2&gt;
  40  */
  41 
  42 /*
  43  * TODO:
  44  * http://replaygain.hydrogenaudio.org/file_format_wav.html
  45  */
  46 
  47 #ifdef HAVE_CONFIG_H
  48 #include &quot;config.h&quot;
  49 #endif
  50 
  51 #include &lt;string.h&gt;
  52 #include &lt;math.h&gt;
  53 
  54 #include &quot;gstwavparse.h&quot;
  55 #include &quot;gst/riff/riff-media.h&quot;
  56 #include &lt;gst/base/gsttypefindhelper.h&gt;
  57 #include &lt;gst/pbutils/descriptions.h&gt;
  58 #include &lt;gst/gst-i18n-plugin.h&gt;
  59 
  60 #ifdef GSTREAMER_LITE
  61 #include &lt;fxplugins_common.h&gt;
  62 #endif // GSTREAMER_LITE
  63 
  64 GST_DEBUG_CATEGORY_STATIC (wavparse_debug);
  65 #define GST_CAT_DEFAULT (wavparse_debug)
  66 
  67 /* Data size chunk of RF64,
  68  * see http://tech.ebu.ch/docs/tech/tech3306-2009.pdf */
  69 #define GST_RS64_TAG_DS64 GST_MAKE_FOURCC (&#39;d&#39;,&#39;s&#39;,&#39;6&#39;,&#39;4&#39;)
  70 
  71 static void gst_wavparse_dispose (GObject * object);
  72 
  73 static gboolean gst_wavparse_sink_activate (GstPad * sinkpad,
  74     GstObject * parent);
  75 static gboolean gst_wavparse_sink_activate_mode (GstPad * sinkpad,
  76     GstObject * parent, GstPadMode mode, gboolean active);
  77 static gboolean gst_wavparse_send_event (GstElement * element,
  78     GstEvent * event);
  79 static GstStateChangeReturn gst_wavparse_change_state (GstElement * element,
  80     GstStateChange transition);
  81 #ifdef GSTREAMER_LITE
  82 static gboolean gst_wavparse_sink_query (GstPad * pad, GstObject *parent, GstQuery * query);
  83 #endif // GSTREAMER_LITE
  84 
  85 static gboolean gst_wavparse_pad_query (GstPad * pad, GstObject * parent,
  86     GstQuery * query);
  87 static gboolean gst_wavparse_pad_convert (GstPad * pad, GstFormat src_format,
  88     gint64 src_value, GstFormat * dest_format, gint64 * dest_value);
  89 
  90 static GstFlowReturn gst_wavparse_chain (GstPad * pad, GstObject * parent,
  91     GstBuffer * buf);
  92 static gboolean gst_wavparse_sink_event (GstPad * pad, GstObject * parent,
  93     GstEvent * event);
  94 static void gst_wavparse_loop (GstPad * pad);
  95 static gboolean gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent,
  96     GstEvent * event);
  97 
  98 static void gst_wavparse_set_property (GObject * object, guint prop_id,
  99     const GValue * value, GParamSpec * pspec);
 100 static void gst_wavparse_get_property (GObject * object, guint prop_id,
 101     GValue * value, GParamSpec * pspec);
 102 
 103 #define DEFAULT_IGNORE_LENGTH FALSE
 104 
 105 enum
 106 {
 107   PROP_0,
 108   PROP_IGNORE_LENGTH,
 109 };
 110 
 111 static GstStaticPadTemplate sink_template_factory =
<a name="1" id="anc1"></a><span class="line-modified"> 112     GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,</span>
 113     GST_PAD_SINK,
 114     GST_PAD_ALWAYS,
<a name="2" id="anc2"></a><span class="line-modified"> 115     GST_STATIC_CAPS (&quot;audio/x-wav;audio/x-rf64&quot;)</span>
 116     );
 117 
 118 #define DEBUG_INIT \
 119   GST_DEBUG_CATEGORY_INIT (wavparse_debug, &quot;wavparse&quot;, 0, &quot;WAV parser&quot;);
 120 
 121 #define gst_wavparse_parent_class parent_class
 122 G_DEFINE_TYPE_WITH_CODE (GstWavParse, gst_wavparse, GST_TYPE_ELEMENT,
 123     DEBUG_INIT);
 124 
 125 typedef struct
 126 {
 127   /* Offset Size    Description   Value
 128    * 0x00   4       ID            unique identification value
 129    * 0x04   4       Position      play order position
 130    * 0x08   4       Data Chunk ID RIFF ID of corresponding data chunk
 131    * 0x0c   4       Chunk Start   Byte Offset of Data Chunk *
 132    * 0x10   4       Block Start   Byte Offset to sample of First Channel
 133    * 0x14   4       Sample Offset Byte Offset to sample byte of First Channel
 134    */
 135   guint32 id;
 136   guint32 position;
 137   guint32 data_chunk_id;
 138   guint32 chunk_start;
 139   guint32 block_start;
 140   guint32 sample_offset;
 141 } GstWavParseCue;
 142 
 143 typedef struct
 144 {
 145   /* Offset Size    Description     Value
 146    * 0x08   4       Cue Point ID    0 - 0xFFFFFFFF
 147    * 0x0c           Text
 148    */
 149   guint32 cue_point_id;
 150   gchar *text;
 151 } GstWavParseLabl, GstWavParseNote;
 152 
 153 static void
 154 gst_wavparse_class_init (GstWavParseClass * klass)
 155 {
 156   GstElementClass *gstelement_class;
 157   GObjectClass *object_class;
 158   GstPadTemplate *src_template;
 159 
 160   gstelement_class = (GstElementClass *) klass;
 161   object_class = (GObjectClass *) klass;
 162 
 163   parent_class = g_type_class_peek_parent (klass);
 164 
 165   object_class-&gt;dispose = gst_wavparse_dispose;
 166 
 167   object_class-&gt;set_property = gst_wavparse_set_property;
 168   object_class-&gt;get_property = gst_wavparse_get_property;
 169 
 170   /**
 171    * GstWavParse:ignore-length:
 172    *
 173    * This selects whether the length found in a data chunk
 174    * should be ignored. This may be useful for streamed audio
 175    * where the length is unknown until the end of streaming,
 176    * and various software/hardware just puts some random value
 177    * in there and hopes it doesn&#39;t break too much.
 178    */
 179   g_object_class_install_property (object_class, PROP_IGNORE_LENGTH,
 180       g_param_spec_boolean (&quot;ignore-length&quot;,
 181           &quot;Ignore length&quot;,
 182           &quot;Ignore length from the Wave header&quot;,
 183           DEFAULT_IGNORE_LENGTH, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)
 184       );
 185 
 186   gstelement_class-&gt;change_state = gst_wavparse_change_state;
 187   gstelement_class-&gt;send_event = gst_wavparse_send_event;
 188 
 189   /* register pads */
 190   gst_element_class_add_static_pad_template (gstelement_class,
 191       &amp;sink_template_factory);
 192 
 193   src_template = gst_pad_template_new (&quot;src&quot;, GST_PAD_SRC,
 194       GST_PAD_ALWAYS, gst_riff_create_audio_template_caps ());
 195   gst_element_class_add_pad_template (gstelement_class, src_template);
 196 
 197   gst_element_class_set_static_metadata (gstelement_class, &quot;WAV audio demuxer&quot;,
 198       &quot;Codec/Demuxer/Audio&quot;,
 199       &quot;Parse a .wav file into raw audio&quot;,
 200       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;&quot;);
 201 }
 202 
 203 static void
 204 gst_wavparse_notes_free (GstWavParseNote * note)
 205 {
 206   if (note)
 207     g_free (note-&gt;text);
 208   g_free (note);
 209 }
 210 
 211 static void
 212 gst_wavparse_labls_free (GstWavParseLabl * labl)
 213 {
 214   if (labl)
 215     g_free (labl-&gt;text);
 216   g_free (labl);
 217 }
 218 
 219 static void
 220 gst_wavparse_reset (GstWavParse * wav)
 221 {
 222   wav-&gt;state = GST_WAVPARSE_START;
 223 
 224   /* These will all be set correctly in the fmt chunk */
 225   wav-&gt;depth = 0;
 226   wav-&gt;rate = 0;
 227   wav-&gt;width = 0;
 228   wav-&gt;channels = 0;
 229   wav-&gt;blockalign = 0;
 230   wav-&gt;bps = 0;
 231   wav-&gt;fact = 0;
 232   wav-&gt;offset = 0;
 233   wav-&gt;end_offset = 0;
 234   wav-&gt;dataleft = 0;
 235   wav-&gt;datasize = 0;
 236   wav-&gt;datastart = 0;
 237   wav-&gt;chunk_size = 0;
 238   wav-&gt;duration = 0;
 239   wav-&gt;got_fmt = FALSE;
 240   wav-&gt;first = TRUE;
 241 
 242   if (wav-&gt;seek_event)
 243     gst_event_unref (wav-&gt;seek_event);
 244   wav-&gt;seek_event = NULL;
 245   if (wav-&gt;adapter) {
 246     gst_adapter_clear (wav-&gt;adapter);
 247     g_object_unref (wav-&gt;adapter);
 248     wav-&gt;adapter = NULL;
 249   }
 250   if (wav-&gt;tags)
 251     gst_tag_list_unref (wav-&gt;tags);
 252   wav-&gt;tags = NULL;
 253   if (wav-&gt;toc)
 254     gst_toc_unref (wav-&gt;toc);
 255   wav-&gt;toc = NULL;
 256   if (wav-&gt;cues)
 257     g_list_free_full (wav-&gt;cues, g_free);
 258   wav-&gt;cues = NULL;
 259   if (wav-&gt;labls)
 260     g_list_free_full (wav-&gt;labls, (GDestroyNotify) gst_wavparse_labls_free);
 261   wav-&gt;labls = NULL;
 262   if (wav-&gt;notes)
 263     g_list_free_full (wav-&gt;notes, (GDestroyNotify) gst_wavparse_notes_free);
 264   wav-&gt;notes = NULL;
 265   if (wav-&gt;caps)
 266     gst_caps_unref (wav-&gt;caps);
 267   wav-&gt;caps = NULL;
 268   if (wav-&gt;start_segment)
 269     gst_event_unref (wav-&gt;start_segment);
 270   wav-&gt;start_segment = NULL;
 271 }
 272 
 273 static void
 274 gst_wavparse_dispose (GObject * object)
 275 {
 276   GstWavParse *wav = GST_WAVPARSE (object);
 277 
 278   GST_DEBUG_OBJECT (wav, &quot;WAV: Dispose&quot;);
 279   gst_wavparse_reset (wav);
 280 
 281   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 282 }
 283 
 284 static void
 285 gst_wavparse_init (GstWavParse * wavparse)
 286 {
 287 #ifdef GSTREAMER_LITE
 288     GstElementClass *klass = GST_ELEMENT_GET_CLASS (wavparse);
 289     GstPadTemplate *src_template;
 290 #endif // GSTREAMER_LITE
 291 
 292   gst_wavparse_reset (wavparse);
 293 
 294   /* sink */
 295   wavparse-&gt;sinkpad =
 296       gst_pad_new_from_static_template (&amp;sink_template_factory, &quot;sink&quot;);
 297   gst_pad_set_activate_function (wavparse-&gt;sinkpad,
 298       GST_DEBUG_FUNCPTR (gst_wavparse_sink_activate));
 299   gst_pad_set_activatemode_function (wavparse-&gt;sinkpad,
 300       GST_DEBUG_FUNCPTR (gst_wavparse_sink_activate_mode));
 301   gst_pad_set_chain_function (wavparse-&gt;sinkpad,
 302       GST_DEBUG_FUNCPTR (gst_wavparse_chain));
 303   gst_pad_set_event_function (wavparse-&gt;sinkpad,
 304       GST_DEBUG_FUNCPTR (gst_wavparse_sink_event));
 305 
 306 #ifdef GSTREAMER_LITE
 307     gst_pad_set_query_function (wavparse-&gt;sinkpad,
 308             GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));
 309 #endif // GSTREAMER_LITE
 310 
 311   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;sinkpad);
 312 
 313   /* src */
 314   wavparse-&gt;srcpad =
 315       gst_pad_new_from_template (gst_element_class_get_pad_template
 316       (GST_ELEMENT_GET_CLASS (wavparse), &quot;src&quot;), &quot;src&quot;);
 317   gst_pad_use_fixed_caps (wavparse-&gt;srcpad);
 318   gst_pad_set_query_function (wavparse-&gt;srcpad,
 319       GST_DEBUG_FUNCPTR (gst_wavparse_pad_query));
 320   gst_pad_set_event_function (wavparse-&gt;srcpad,
 321       GST_DEBUG_FUNCPTR (gst_wavparse_srcpad_event));
<a name="3" id="anc3"></a><span class="line-modified"> 322   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;srcpad);</span>
 323 }
 324 
 325 static gboolean
 326 gst_wavparse_parse_file_header (GstElement * element, GstBuffer * buf)
 327 {
 328   guint32 doctype;
 329 
 330   if (!gst_riff_parse_file_header (element, buf, &amp;doctype))
 331     return FALSE;
 332 
 333   if (doctype != GST_RIFF_RIFF_WAVE)
 334     goto not_wav;
 335 
 336   return TRUE;
 337 
 338   /* ERRORS */
 339 not_wav:
 340   {
 341     GST_ELEMENT_ERROR (element, STREAM, WRONG_TYPE, (NULL),
 342         (&quot;File is not a WAVE file: 0x%&quot; G_GINT32_MODIFIER &quot;x&quot;, doctype));
 343     return FALSE;
 344   }
 345 }
 346 
 347 static GstFlowReturn
 348 gst_wavparse_stream_init (GstWavParse * wav)
 349 {
 350   GstFlowReturn res;
 351   GstBuffer *buf = NULL;
 352 
 353   if ((res = gst_pad_pull_range (wav-&gt;sinkpad,
 354               wav-&gt;offset, 12, &amp;buf)) != GST_FLOW_OK)
 355     return res;
 356   else if (!gst_wavparse_parse_file_header (GST_ELEMENT_CAST (wav), buf))
 357     return GST_FLOW_ERROR;
 358 
 359   wav-&gt;offset += 12;
 360 
 361   return GST_FLOW_OK;
 362 }
 363 
 364 static gboolean
 365 gst_wavparse_time_to_bytepos (GstWavParse * wav, gint64 ts, gint64 * bytepos)
 366 {
 367   /* -1 always maps to -1 */
 368   if (ts == -1) {
 369     *bytepos = -1;
 370     return TRUE;
 371   }
 372 
 373   /* 0 always maps to 0 */
 374   if (ts == 0) {
 375     *bytepos = 0;
 376     return TRUE;
 377   }
 378 
 379   if (wav-&gt;bps &gt; 0) {
 380     *bytepos = gst_util_uint64_scale_ceil (ts, (guint64) wav-&gt;bps, GST_SECOND);
 381     return TRUE;
 382   } else if (wav-&gt;fact) {
 383     guint64 bps = gst_util_uint64_scale (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
 384     *bytepos = gst_util_uint64_scale_ceil (ts, bps, GST_SECOND);
 385     return TRUE;
 386   }
 387 
 388   return FALSE;
 389 }
 390 
 391 /* This function is used to perform seeks on the element.
 392  *
 393  * It also works when event is NULL, in which case it will just
 394  * start from the last configured segment. This technique is
 395  * used when activating the element and to perform the seek in
 396  * READY.
 397  */
 398 static gboolean
 399 gst_wavparse_perform_seek (GstWavParse * wav, GstEvent * event)
 400 {
 401   gboolean res;
 402   gdouble rate;
 403   GstFormat format, bformat;
 404   GstSeekFlags flags;
 405   GstSeekType cur_type = GST_SEEK_TYPE_NONE, stop_type;
 406   gint64 cur, stop, upstream_size;
 407   gboolean flush;
 408   gboolean update;
 409   GstSegment seeksegment = { 0, };
 410   gint64 last_stop;
<a name="4" id="anc4"></a><span class="line-modified"> 411   guint32 seqnum = GST_SEQNUM_INVALID;</span>
 412 
 413   if (event) {
 414     GST_DEBUG_OBJECT (wav, &quot;doing seek with event&quot;);
 415 
 416     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 417         &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 418     seqnum = gst_event_get_seqnum (event);
 419 
 420     /* no negative rates yet */
 421     if (rate &lt; 0.0)
 422       goto negative_rate;
 423 
 424     if (format != wav-&gt;segment.format) {
 425       GST_INFO_OBJECT (wav, &quot;converting seek-event from %s to %s&quot;,
 426           gst_format_get_name (format),
 427           gst_format_get_name (wav-&gt;segment.format));
 428       res = TRUE;
 429       if (cur_type != GST_SEEK_TYPE_NONE)
 430         res =
 431             gst_pad_query_convert (wav-&gt;srcpad, format, cur,
 432             wav-&gt;segment.format, &amp;cur);
 433       if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE)
 434         res =
 435             gst_pad_query_convert (wav-&gt;srcpad, format, stop,
 436             wav-&gt;segment.format, &amp;stop);
 437       if (!res)
 438         goto no_format;
 439 
 440       format = wav-&gt;segment.format;
 441     }
 442   } else {
 443     GST_DEBUG_OBJECT (wav, &quot;doing seek without event&quot;);
 444     flags = 0;
 445     rate = 1.0;
 446     cur_type = GST_SEEK_TYPE_SET;
 447     stop_type = GST_SEEK_TYPE_SET;
 448   }
 449 
 450   /* in push mode, we must delegate to upstream */
 451   if (wav-&gt;streaming) {
 452     gboolean res = FALSE;
 453 
 454     /* if streaming not yet started; only prepare initial newsegment */
 455     if (!event || wav-&gt;state != GST_WAVPARSE_DATA) {
 456       if (wav-&gt;start_segment)
 457         gst_event_unref (wav-&gt;start_segment);
 458       wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
 459       res = TRUE;
 460     } else {
 461       /* convert seek positions to byte positions in data sections */
 462       if (format == GST_FORMAT_TIME) {
 463         /* should not fail */
 464         if (!gst_wavparse_time_to_bytepos (wav, cur, &amp;cur))
 465           goto no_position;
 466         if (!gst_wavparse_time_to_bytepos (wav, stop, &amp;stop))
 467           goto no_position;
 468       }
 469       /* mind sample boundary and header */
 470       if (cur &gt;= 0) {
 471         cur -= (cur % wav-&gt;bytes_per_sample);
 472         cur += wav-&gt;datastart;
 473       }
 474       if (stop &gt;= 0) {
 475         stop -= (stop % wav-&gt;bytes_per_sample);
 476         stop += wav-&gt;datastart;
 477       }
 478       GST_DEBUG_OBJECT (wav, &quot;Pushing BYTE seek rate %g, &quot;
 479           &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, cur,
 480           stop);
 481       /* BYTE seek event */
 482       event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, cur,
 483           stop_type, stop);
<a name="5" id="anc5"></a><span class="line-modified"> 484       if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 485         gst_event_set_seqnum (event, seqnum);</span>
 486       res = gst_pad_push_event (wav-&gt;sinkpad, event);
 487     }
 488     return res;
 489   }
 490 
 491   /* get flush flag */
 492   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 493 
 494   /* now we need to make sure the streaming thread is stopped. We do this by
 495    * either sending a FLUSH_START event downstream which will cause the
 496    * streaming thread to stop with a WRONG_STATE.
 497    * For a non-flushing seek we simply pause the task, which will happen as soon
 498    * as it completes one iteration (and thus might block when the sink is
 499    * blocking in preroll). */
 500   if (flush) {
 501     GstEvent *fevent;
<a name="6" id="anc6"></a><span class="line-modified"> 502     GST_DEBUG_OBJECT (wav, &quot;sending flush start&quot;);</span>
 503 
 504     fevent = gst_event_new_flush_start ();
<a name="7" id="anc7"></a><span class="line-modified"> 505     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 506       gst_event_set_seqnum (fevent, seqnum);</span>
 507     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 508     gst_pad_push_event (wav-&gt;srcpad, fevent);
 509   } else {
 510     gst_pad_pause_task (wav-&gt;sinkpad);
 511   }
 512 
 513   /* we should now be able to grab the streaming thread because we stopped it
 514    * with the above flush/pause code */
 515   GST_PAD_STREAM_LOCK (wav-&gt;sinkpad);
 516 
 517   /* save current position */
 518   last_stop = wav-&gt;segment.position;
 519 
 520   GST_DEBUG_OBJECT (wav, &quot;stopped streaming at %&quot; G_GINT64_FORMAT, last_stop);
 521 
 522   /* copy segment, we need this because we still need the old
 523    * segment when we close the current segment. */
 524   memcpy (&amp;seeksegment, &amp;wav-&gt;segment, sizeof (GstSegment));
 525 
 526   /* configure the seek parameters in the seeksegment. We will then have the
 527    * right values in the segment to perform the seek */
 528   if (event) {
 529     GST_DEBUG_OBJECT (wav, &quot;configuring seek&quot;);
 530     gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 531         cur_type, cur, stop_type, stop, &amp;update);
 532   }
 533 
 534   /* figure out the last position we need to play. If it&#39;s configured (stop !=
 535    * -1), use that, else we play until the total duration of the file */
 536   if ((stop = seeksegment.stop) == -1)
 537     stop = seeksegment.duration;
 538 
 539   GST_DEBUG_OBJECT (wav, &quot;cur_type =%d&quot;, cur_type);
 540   if ((cur_type != GST_SEEK_TYPE_NONE)) {
 541     /* bring offset to bytes, if the bps is 0, we have the segment in BYTES and
 542      * we can just copy the last_stop. If not, we use the bps to convert TIME to
 543      * bytes. */
 544     if (!gst_wavparse_time_to_bytepos (wav, seeksegment.position,
 545             (gint64 *) &amp; wav-&gt;offset))
 546       wav-&gt;offset = seeksegment.position;
 547     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 548     wav-&gt;offset -= (wav-&gt;offset % wav-&gt;bytes_per_sample);
 549     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 550     wav-&gt;offset += wav-&gt;datastart;
 551     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 552   } else {
 553     GST_LOG_OBJECT (wav, &quot;continue from offset=%&quot; G_GUINT64_FORMAT,
 554         wav-&gt;offset);
 555   }
 556 
 557   if (stop_type != GST_SEEK_TYPE_NONE) {
 558     if (!gst_wavparse_time_to_bytepos (wav, stop, (gint64 *) &amp; wav-&gt;end_offset))
 559       wav-&gt;end_offset = stop;
 560     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 561     wav-&gt;end_offset -= (wav-&gt;end_offset % wav-&gt;bytes_per_sample);
 562     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 563     wav-&gt;end_offset += wav-&gt;datastart;
 564     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 565   } else {
 566     GST_LOG_OBJECT (wav, &quot;continue to end_offset=%&quot; G_GUINT64_FORMAT,
 567         wav-&gt;end_offset);
 568   }
 569 
 570   /* make sure filesize is not exceeded due to rounding errors or so,
 571    * same precaution as in _stream_headers */
 572   bformat = GST_FORMAT_BYTES;
 573   if (gst_pad_peer_query_duration (wav-&gt;sinkpad, bformat, &amp;upstream_size))
 574     wav-&gt;end_offset = MIN (wav-&gt;end_offset, upstream_size);
 575 
 576   if (wav-&gt;datasize &gt; 0 &amp;&amp; wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize)
 577     wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
 578 
 579   /* this is the range of bytes we will use for playback */
 580   wav-&gt;offset = MIN (wav-&gt;offset, wav-&gt;end_offset);
 581   wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
 582 
 583   GST_DEBUG_OBJECT (wav,
 584       &quot;seek: rate %lf, offset %&quot; G_GUINT64_FORMAT &quot;, end %&quot; G_GUINT64_FORMAT
 585       &quot;, segment %&quot; GST_TIME_FORMAT &quot; -- %&quot; GST_TIME_FORMAT, rate, wav-&gt;offset,
 586       wav-&gt;end_offset, GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (stop));
 587 
 588   /* prepare for streaming again */
<a name="8" id="anc8"></a><span class="line-modified"> 589   if (flush) {</span>
 590     GstEvent *fevent;
 591 
<a name="9" id="anc9"></a><span class="line-modified"> 592     /* if we sent a FLUSH_START, we now send a FLUSH_STOP */</span>
<span class="line-modified"> 593     GST_DEBUG_OBJECT (wav, &quot;sending flush stop&quot;);</span>
 594 
 595     fevent = gst_event_new_flush_stop (TRUE);
<a name="10" id="anc10"></a><span class="line-modified"> 596     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 597       gst_event_set_seqnum (fevent, seqnum);</span>
 598     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 599     gst_pad_push_event (wav-&gt;srcpad, fevent);
<a name="11" id="anc11"></a><span class="line-modified"> 600   }</span>
 601 
 602   /* now we did the seek and can activate the new segment values */
 603   memcpy (&amp;wav-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 604 
 605   /* if we&#39;re doing a segment seek, post a SEGMENT_START message */
 606   if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 607     gst_element_post_message (GST_ELEMENT_CAST (wav),
 608         gst_message_new_segment_start (GST_OBJECT_CAST (wav),
 609             wav-&gt;segment.format, wav-&gt;segment.position));
 610   }
 611 
 612   /* now create the newsegment */
 613   GST_DEBUG_OBJECT (wav, &quot;Creating newsegment from %&quot; G_GINT64_FORMAT
 614       &quot; to %&quot; G_GINT64_FORMAT, wav-&gt;segment.position, stop);
 615 
 616   /* store the newsegment event so it can be sent from the streaming thread. */
 617   if (wav-&gt;start_segment)
 618     gst_event_unref (wav-&gt;start_segment);
 619   wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
<a name="12" id="anc12"></a><span class="line-modified"> 620   if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 621     gst_event_set_seqnum (wav-&gt;start_segment, seqnum);</span>
 622 
 623   /* mark discont if we are going to stream from another position. */
 624   if (last_stop != wav-&gt;segment.position) {
 625     GST_DEBUG_OBJECT (wav, &quot;mark DISCONT, we did a seek to another position&quot;);
 626     wav-&gt;discont = TRUE;
 627   }
 628 
 629   /* and start the streaming task again */
 630   if (!wav-&gt;streaming) {
 631     gst_pad_start_task (wav-&gt;sinkpad, (GstTaskFunction) gst_wavparse_loop,
 632         wav-&gt;sinkpad, NULL);
 633   }
 634 
 635   GST_PAD_STREAM_UNLOCK (wav-&gt;sinkpad);
 636 
 637   return TRUE;
 638 
 639   /* ERRORS */
 640 negative_rate:
 641   {
 642     GST_DEBUG_OBJECT (wav, &quot;negative playback rates are not supported yet.&quot;);
 643     return FALSE;
 644   }
 645 no_format:
 646   {
 647     GST_DEBUG_OBJECT (wav, &quot;unsupported format given, seek aborted.&quot;);
 648     return FALSE;
 649   }
 650 no_position:
 651   {
 652     GST_DEBUG_OBJECT (wav,
 653         &quot;Could not determine byte position for desired time&quot;);
 654     return FALSE;
 655   }
 656 }
 657 
 658 /*
 659  * gst_wavparse_peek_chunk_info:
 660  * @wav Wavparse object
 661  * @tag holder for tag
 662  * @size holder for tag size
 663  *
 664  * Peek next chunk info (tag and size)
 665  *
 666  * Returns: %TRUE when the chunk info (header) is available
 667  */
 668 static gboolean
 669 gst_wavparse_peek_chunk_info (GstWavParse * wav, guint32 * tag, guint32 * size)
 670 {
 671   const guint8 *data = NULL;
 672 
 673   if (gst_adapter_available (wav-&gt;adapter) &lt; 8)
 674     return FALSE;
 675 
 676   data = gst_adapter_map (wav-&gt;adapter, 8);
 677   *tag = GST_READ_UINT32_LE (data);
 678   *size = GST_READ_UINT32_LE (data + 4);
 679   gst_adapter_unmap (wav-&gt;adapter);
 680 
 681   GST_DEBUG (&quot;Next chunk size is %u bytes, type %&quot; GST_FOURCC_FORMAT, *size,
 682       GST_FOURCC_ARGS (*tag));
 683 
 684   return TRUE;
 685 }
 686 
 687 /*
 688  * gst_wavparse_peek_chunk:
 689  * @wav Wavparse object
 690  * @tag holder for tag
 691  * @size holder for tag size
 692  *
 693  * Peek enough data for one full chunk
 694  *
 695  * Returns: %TRUE when the full chunk is available
 696  */
 697 static gboolean
 698 gst_wavparse_peek_chunk (GstWavParse * wav, guint32 * tag, guint32 * size)
 699 {
 700   guint32 peek_size = 0;
 701   guint available;
 702 
 703   if (!gst_wavparse_peek_chunk_info (wav, tag, size))
 704     return FALSE;
 705 
 706   /* size 0 -&gt; empty data buffer would surprise most callers,
 707    * large size -&gt; do not bother trying to squeeze that into adapter,
 708    * so we throw poor man&#39;s exception, which can be caught if caller really
 709    * wants to handle 0 size chunk */
 710   if (!(*size) || (*size) &gt;= (1 &lt;&lt; 30)) {
 711     GST_INFO (&quot;Invalid/unexpected chunk size %u for tag %&quot; GST_FOURCC_FORMAT,
 712         *size, GST_FOURCC_ARGS (*tag));
 713     /* chain should give up */
 714     wav-&gt;abort_buffering = TRUE;
 715     return FALSE;
 716   }
 717   peek_size = (*size + 1) &amp; ~1;
 718   available = gst_adapter_available (wav-&gt;adapter);
 719 
 720   if (available &gt;= (8 + peek_size)) {
 721     return TRUE;
 722   } else {
 723     GST_LOG (&quot;but only %u bytes available now&quot;, available);
 724     return FALSE;
 725   }
 726 }
 727 
 728 /*
 729  * gst_wavparse_calculate_duration:
 730  * @wav: wavparse object
 731  *
 732  * Calculate duration on demand and store in @wav. Prefer bps, but use fact as a
 733  * fallback.
 734  *
 735  * Returns: %TRUE if duration is available.
 736  */
 737 static gboolean
 738 gst_wavparse_calculate_duration (GstWavParse * wav)
 739 {
 740   if (wav-&gt;duration &gt; 0)
 741     return TRUE;
 742 
 743   if (wav-&gt;bps &gt; 0) {
 744     GST_INFO_OBJECT (wav, &quot;Got datasize %&quot; G_GUINT64_FORMAT, wav-&gt;datasize);
 745     wav-&gt;duration =
 746         gst_util_uint64_scale_ceil (wav-&gt;datasize, GST_SECOND,
 747         (guint64) wav-&gt;bps);
 748     GST_INFO_OBJECT (wav, &quot;Got duration (bps) %&quot; GST_TIME_FORMAT,
 749         GST_TIME_ARGS (wav-&gt;duration));
 750     return TRUE;
 751   } else if (wav-&gt;fact) {
 752     wav-&gt;duration =
 753         gst_util_uint64_scale_ceil (GST_SECOND, wav-&gt;fact, wav-&gt;rate);
 754     GST_INFO_OBJECT (wav, &quot;Got duration (fact) %&quot; GST_TIME_FORMAT,
 755         GST_TIME_ARGS (wav-&gt;duration));
 756     return TRUE;
 757   }
 758   return FALSE;
 759 }
 760 
 761 static gboolean
 762 gst_waveparse_ignore_chunk (GstWavParse * wav, GstBuffer * buf, guint32 tag,
 763     guint32 size)
 764 {
 765   guint flush;
 766 
 767   if (wav-&gt;streaming) {
 768     if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size))
 769       return FALSE;
 770   }
 771   GST_DEBUG_OBJECT (wav, &quot;Ignoring tag %&quot; GST_FOURCC_FORMAT,
 772       GST_FOURCC_ARGS (tag));
 773   flush = 8 + ((size + 1) &amp; ~1);
 774   wav-&gt;offset += flush;
 775   if (wav-&gt;streaming) {
 776     gst_adapter_flush (wav-&gt;adapter, flush);
 777   } else {
 778     gst_buffer_unref (buf);
 779   }
 780 
 781   return TRUE;
 782 }
 783 
 784 /*
 785  * gst_wavparse_cue_chunk:
 786  * @wav GstWavParse object
 787  * @data holder for data
 788  * @size holder for data size
 789  *
 790  * Parse cue chunk from @data to wav-&gt;cues.
 791  *
 792  * Returns: %TRUE when cue chunk is available
 793  */
 794 static gboolean
 795 gst_wavparse_cue_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 796 {
 797   guint32 i, ncues;
 798   GList *cues = NULL;
 799   GstWavParseCue *cue;
 800 
 801   if (wav-&gt;cues) {
 802     GST_WARNING_OBJECT (wav, &quot;found another cue&#39;s&quot;);
 803     return TRUE;
 804   }
 805 
 806   ncues = GST_READ_UINT32_LE (data);
 807 
 808   if (size &lt; 4 + ncues * 24) {
 809     GST_WARNING_OBJECT (wav, &quot;broken file %d %d&quot;, size, ncues);
 810     return FALSE;
 811   }
 812 
 813   /* parse data */
 814   data += 4;
 815   for (i = 0; i &lt; ncues; i++) {
 816     cue = g_new0 (GstWavParseCue, 1);
 817     cue-&gt;id = GST_READ_UINT32_LE (data);
 818     cue-&gt;position = GST_READ_UINT32_LE (data + 4);
 819     cue-&gt;data_chunk_id = GST_READ_UINT32_LE (data + 8);
 820     cue-&gt;chunk_start = GST_READ_UINT32_LE (data + 12);
 821     cue-&gt;block_start = GST_READ_UINT32_LE (data + 16);
 822     cue-&gt;sample_offset = GST_READ_UINT32_LE (data + 20);
 823     cues = g_list_append (cues, cue);
 824     data += 24;
 825   }
 826 
 827   wav-&gt;cues = cues;
 828 
 829   return TRUE;
 830 }
 831 
 832 /*
 833  * gst_wavparse_labl_chunk:
 834  * @wav GstWavParse object
 835  * @data holder for data
 836  * @size holder for data size
 837  *
 838  * Parse labl from @data to wav-&gt;labls.
 839  *
 840  * Returns: %TRUE when labl chunk is available
 841  */
 842 static gboolean
 843 gst_wavparse_labl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 844 {
 845   GstWavParseLabl *labl;
 846 
 847   if (size &lt; 5)
 848     return FALSE;
 849 
 850   labl = g_new0 (GstWavParseLabl, 1);
 851 
 852   /* parse data */
 853   data += 8;
 854   labl-&gt;cue_point_id = GST_READ_UINT32_LE (data);
 855   labl-&gt;text = g_memdup (data + 4, size - 4);
 856 
 857   wav-&gt;labls = g_list_append (wav-&gt;labls, labl);
 858 
 859   return TRUE;
 860 }
 861 
 862 /*
 863  * gst_wavparse_note_chunk:
 864  * @wav GstWavParse object
 865  * @data holder for data
 866  * @size holder for data size
 867  *
 868  * Parse note from @data to wav-&gt;notes.
 869  *
 870  * Returns: %TRUE when note chunk is available
 871  */
 872 static gboolean
 873 gst_wavparse_note_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 874 {
 875   GstWavParseNote *note;
 876 
 877   if (size &lt; 5)
 878     return FALSE;
 879 
 880   note = g_new0 (GstWavParseNote, 1);
 881 
 882   /* parse data */
 883   data += 8;
 884   note-&gt;cue_point_id = GST_READ_UINT32_LE (data);
 885   note-&gt;text = g_memdup (data + 4, size - 4);
 886 
 887   wav-&gt;notes = g_list_append (wav-&gt;notes, note);
 888 
 889   return TRUE;
 890 }
 891 
 892 /*
 893  * gst_wavparse_smpl_chunk:
 894  * @wav GstWavParse object
 895  * @data holder for data
 896  * @size holder for data size
 897  *
 898  * Parse smpl chunk from @data.
 899  *
 900  * Returns: %TRUE when cue chunk is available
 901  */
 902 static gboolean
 903 gst_wavparse_smpl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 904 {
 905   guint32 note_number;
 906 
 907   /*
 908      manufacturer_id = GST_READ_UINT32_LE (data);
 909      product_id = GST_READ_UINT32_LE (data + 4);
 910      sample_period = GST_READ_UINT32_LE (data + 8);
 911    */
 912   note_number = GST_READ_UINT32_LE (data + 12);
 913   /*
 914      pitch_fraction = GST_READ_UINT32_LE (data + 16);
 915      SMPTE_format = GST_READ_UINT32_LE (data + 20);
 916      SMPTE_offset = GST_READ_UINT32_LE (data + 24);
 917      num_sample_loops = GST_READ_UINT32_LE (data + 28);
 918      List of Sample Loops, 24 bytes each
 919    */
 920 
 921   if (!wav-&gt;tags)
 922     wav-&gt;tags = gst_tag_list_new_empty ();
 923   gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
 924       GST_TAG_MIDI_BASE_NOTE, (guint) note_number, NULL);
 925   return TRUE;
 926 }
 927 
 928 /*
 929  * gst_wavparse_adtl_chunk:
 930  * @wav GstWavParse object
 931  * @data holder for data
 932  * @size holder for data size
 933  *
 934  * Parse adtl from @data.
 935  *
 936  * Returns: %TRUE when adtl chunk is available
 937  */
 938 static gboolean
 939 gst_wavparse_adtl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 940 {
 941   guint32 ltag, lsize, offset = 0;
 942 
 943   while (size &gt;= 8) {
 944     ltag = GST_READ_UINT32_LE (data + offset);
 945     lsize = GST_READ_UINT32_LE (data + offset + 4);
 946 
 947     if (lsize + 8 &gt; size) {
 948       GST_WARNING_OBJECT (wav, &quot;Invalid adtl size: %u + 8 &gt; %u&quot;, lsize, size);
 949       return FALSE;
 950     }
 951 
 952     switch (ltag) {
 953       case GST_RIFF_TAG_labl:
 954         gst_wavparse_labl_chunk (wav, data + offset, size);
 955         break;
 956       case GST_RIFF_TAG_note:
 957         gst_wavparse_note_chunk (wav, data + offset, size);
 958         break;
 959       default:
 960         GST_WARNING_OBJECT (wav, &quot;Unknowm adtl %&quot; GST_FOURCC_FORMAT,
 961             GST_FOURCC_ARGS (ltag));
 962         GST_MEMDUMP_OBJECT (wav, &quot;Unknowm adtl&quot;, &amp;data[offset], lsize);
 963         break;
 964     }
 965     offset += 8 + GST_ROUND_UP_2 (lsize);
 966     size -= 8 + GST_ROUND_UP_2 (lsize);
 967   }
 968 
 969   return TRUE;
 970 }
 971 
 972 static GstTagList *
 973 gst_wavparse_get_tags_toc_entry (GstToc * toc, gchar * id)
 974 {
 975   GstTagList *tags = NULL;
 976   GstTocEntry *entry = NULL;
 977 
 978   entry = gst_toc_find_entry (toc, id);
 979   if (entry != NULL) {
 980     tags = gst_toc_entry_get_tags (entry);
 981     if (tags == NULL) {
 982       tags = gst_tag_list_new_empty ();
 983       gst_toc_entry_set_tags (entry, tags);
 984     }
 985   }
 986 
 987   return tags;
 988 }
 989 
 990 /*
 991  * gst_wavparse_create_toc:
 992  * @wav GstWavParse object
 993  *
 994  * Create TOC from wav-&gt;cues and wav-&gt;labls.
 995  */
 996 static gboolean
 997 gst_wavparse_create_toc (GstWavParse * wav)
 998 {
 999   gint64 start, stop;
1000   gchar *id;
1001   GList *list;
1002   GstWavParseCue *cue;
1003   GstWavParseLabl *labl;
1004   GstWavParseNote *note;
1005   GstTagList *tags;
1006   GstToc *toc;
1007   GstTocEntry *entry = NULL, *cur_subentry = NULL, *prev_subentry = NULL;
1008 
1009   GST_OBJECT_LOCK (wav);
1010   if (wav-&gt;toc) {
1011     GST_OBJECT_UNLOCK (wav);
1012     GST_WARNING_OBJECT (wav, &quot;found another TOC&quot;);
1013     return FALSE;
1014   }
1015 
1016   if (!wav-&gt;cues) {
1017     GST_OBJECT_UNLOCK (wav);
1018     return TRUE;
1019   }
1020 
1021   /* FIXME: send CURRENT scope toc too */
1022   toc = gst_toc_new (GST_TOC_SCOPE_GLOBAL);
1023 
1024   /* add cue edition */
1025   entry = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, &quot;cue&quot;);
1026   gst_toc_entry_set_start_stop_times (entry, 0, wav-&gt;duration);
1027   gst_toc_append_entry (toc, entry);
1028 
1029   /* add tracks in cue edition */
1030   list = wav-&gt;cues;
1031   while (list) {
1032     cue = list-&gt;data;
1033     prev_subentry = cur_subentry;
1034     /* previous track stop time = current track start time */
1035     if (prev_subentry != NULL) {
1036       gst_toc_entry_get_start_stop_times (prev_subentry, &amp;start, NULL);
1037       stop = gst_util_uint64_scale_round (cue-&gt;position, GST_SECOND, wav-&gt;rate);
1038       gst_toc_entry_set_start_stop_times (prev_subentry, start, stop);
1039     }
1040     id = g_strdup_printf (&quot;%08x&quot;, cue-&gt;id);
1041     cur_subentry = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_TRACK, id);
1042     g_free (id);
1043     start = gst_util_uint64_scale_round (cue-&gt;position, GST_SECOND, wav-&gt;rate);
1044     stop = wav-&gt;duration;
1045     gst_toc_entry_set_start_stop_times (cur_subentry, start, stop);
1046     gst_toc_entry_append_sub_entry (entry, cur_subentry);
1047     list = g_list_next (list);
1048   }
1049 
1050   /* add tags in tracks */
1051   list = wav-&gt;labls;
1052   while (list) {
1053     labl = list-&gt;data;
1054     id = g_strdup_printf (&quot;%08x&quot;, labl-&gt;cue_point_id);
1055     tags = gst_wavparse_get_tags_toc_entry (toc, id);
1056     g_free (id);
1057     if (tags != NULL) {
1058       gst_tag_list_add (tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE, labl-&gt;text,
1059           NULL);
1060     }
1061     list = g_list_next (list);
1062   }
1063   list = wav-&gt;notes;
1064   while (list) {
1065     note = list-&gt;data;
1066     id = g_strdup_printf (&quot;%08x&quot;, note-&gt;cue_point_id);
1067     tags = gst_wavparse_get_tags_toc_entry (toc, id);
1068     g_free (id);
1069     if (tags != NULL) {
1070       gst_tag_list_add (tags, GST_TAG_MERGE_PREPEND, GST_TAG_COMMENT,
1071           note-&gt;text, NULL);
1072     }
1073     list = g_list_next (list);
1074   }
1075 
1076   /* send data as TOC */
1077   wav-&gt;toc = toc;
1078 
1079   /* send TOC event */
1080   if (wav-&gt;toc) {
1081     GST_OBJECT_UNLOCK (wav);
1082     gst_pad_push_event (wav-&gt;srcpad, gst_event_new_toc (wav-&gt;toc, FALSE));
1083   }
1084 
1085   return TRUE;
1086 }
1087 
1088 #define MAX_BUFFER_SIZE 4096
1089 
1090 static gboolean
1091 parse_ds64 (GstWavParse * wav, GstBuffer * buf)
1092 {
1093   GstMapInfo map;
1094   guint32 dataSizeLow, dataSizeHigh;
1095   guint32 sampleCountLow, sampleCountHigh;
1096 
1097   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1098   dataSizeLow = GST_READ_UINT32_LE (map.data + 2 * 4);
1099   dataSizeHigh = GST_READ_UINT32_LE (map.data + 3 * 4);
1100   sampleCountLow = GST_READ_UINT32_LE (map.data + 4 * 4);
1101   sampleCountHigh = GST_READ_UINT32_LE (map.data + 5 * 4);
1102   gst_buffer_unmap (buf, &amp;map);
1103   if (dataSizeHigh != 0xFFFFFFFF &amp;&amp; dataSizeLow != 0xFFFFFFFF) {
1104     wav-&gt;datasize = ((guint64) dataSizeHigh &lt;&lt; 32) | dataSizeLow;
1105   }
1106   if (sampleCountHigh != 0xFFFFFFFF &amp;&amp; sampleCountLow != 0xFFFFFFFF) {
1107     wav-&gt;fact = ((guint64) sampleCountHigh &lt;&lt; 32) | sampleCountLow;
1108   }
1109 
1110   GST_DEBUG_OBJECT (wav, &quot;Got &#39;ds64&#39; TAG, datasize : %&quot; G_GINT64_FORMAT
1111       &quot; fact: %&quot; G_GINT64_FORMAT, wav-&gt;datasize, wav-&gt;fact);
1112   return TRUE;
1113 }
1114 
1115 static GstFlowReturn
1116 gst_wavparse_stream_headers (GstWavParse * wav)
1117 {
1118   GstFlowReturn res = GST_FLOW_OK;
1119   GstBuffer *buf = NULL;
1120   gst_riff_strf_auds *header = NULL;
1121   guint32 tag, size;
1122   gboolean gotdata = FALSE;
1123   GstCaps *caps = NULL;
1124   gchar *codec_name = NULL;
1125   gint64 upstream_size = 0;
1126   GstStructure *s;
1127 
1128   /* search for &quot;_fmt&quot; chunk, which must be before &quot;data&quot; */
1129   while (!wav-&gt;got_fmt) {
1130     GstBuffer *extra;
1131 
1132     if (wav-&gt;streaming) {
1133       if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size))
1134         return res;
1135 
1136       gst_adapter_flush (wav-&gt;adapter, 8);
1137       wav-&gt;offset += 8;
1138 
1139       if (size) {
1140         buf = gst_adapter_take_buffer (wav-&gt;adapter, size);
1141         if (size &amp; 1)
1142           gst_adapter_flush (wav-&gt;adapter, 1);
1143         wav-&gt;offset += GST_ROUND_UP_2 (size);
1144       } else {
1145         buf = gst_buffer_new ();
1146       }
1147     } else {
1148       if ((res = gst_riff_read_chunk (GST_ELEMENT_CAST (wav), wav-&gt;sinkpad,
1149                   &amp;wav-&gt;offset, &amp;tag, &amp;buf)) != GST_FLOW_OK)
1150         return res;
1151     }
1152 
1153     if (tag == GST_RS64_TAG_DS64) {
1154       if (!parse_ds64 (wav, buf))
1155         goto fail;
1156       else
1157         continue;
1158     }
1159 
1160     if (tag != GST_RIFF_TAG_fmt) {
1161       GST_DEBUG_OBJECT (wav, &quot;skipping %&quot; GST_FOURCC_FORMAT &quot; chunk&quot;,
1162           GST_FOURCC_ARGS (tag));
1163       gst_buffer_unref (buf);
1164       buf = NULL;
1165       continue;
1166     }
1167 
1168     if (!(gst_riff_parse_strf_auds (GST_ELEMENT_CAST (wav), buf, &amp;header,
1169                 &amp;extra)))
1170       goto parse_header_error;
1171 
1172     buf = NULL;                 /* parse_strf_auds() took ownership of buffer */
1173 
1174     /* do sanity checks of header fields */
1175     if (header-&gt;channels == 0)
1176       goto no_channels;
1177     if (header-&gt;rate == 0)
1178       goto no_rate;
1179 
1180     GST_DEBUG_OBJECT (wav, &quot;creating the caps&quot;);
1181 
1182     /* Note: gst_riff_create_audio_caps might need to fix values in
1183      * the header header depending on the format, so call it first */
1184     /* FIXME: Need to handle the channel reorder map */
1185     caps = gst_riff_create_audio_caps (header-&gt;format, NULL, header, extra,
1186         NULL, &amp;codec_name, NULL);
1187 
1188     if (extra)
1189       gst_buffer_unref (extra);
1190 
1191     if (!caps)
1192       goto unknown_format;
1193 
1194     /* If we got raw audio from upstream, we remove the codec_data field,
1195      * which may have been added if the wav header included an extended
1196      * chunk. We want to keep it for non raw audio.
1197      */
1198     s = gst_caps_get_structure (caps, 0);
1199     if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;)) {
1200       gst_structure_remove_field (s, &quot;codec_data&quot;);
1201     }
1202 
1203     /* do more sanity checks of header fields
1204      * (these can be sanitized by gst_riff_create_audio_caps()
1205      */
1206     wav-&gt;format = header-&gt;format;
1207     wav-&gt;rate = header-&gt;rate;
1208     wav-&gt;channels = header-&gt;channels;
1209     wav-&gt;blockalign = header-&gt;blockalign;
1210     wav-&gt;depth = header-&gt;bits_per_sample;
1211     wav-&gt;av_bps = header-&gt;av_bps;
1212     wav-&gt;vbr = FALSE;
1213 
1214     g_free (header);
1215     header = NULL;
1216 
1217     /* do format specific handling */
1218     switch (wav-&gt;format) {
1219       case GST_RIFF_WAVE_FORMAT_MPEGL12:
1220       case GST_RIFF_WAVE_FORMAT_MPEGL3:
1221       {
1222         /* Note: workaround for mp2/mp3 embedded in wav, that relies on the
1223          * bitrate inside the mpeg stream */
1224         GST_INFO (&quot;resetting bps from %u to 0 for mp2/3&quot;, wav-&gt;av_bps);
1225         wav-&gt;bps = 0;
1226         break;
1227       }
1228       case GST_RIFF_WAVE_FORMAT_PCM:
1229         if (wav-&gt;blockalign &gt; wav-&gt;channels * ((wav-&gt;depth + 7) / 8))
1230           goto invalid_blockalign;
1231         /* fall through */
1232       default:
1233         if (wav-&gt;av_bps &gt; wav-&gt;blockalign * wav-&gt;rate)
1234           goto invalid_bps;
1235         /* use the configured bps */
1236         wav-&gt;bps = wav-&gt;av_bps;
1237         break;
1238     }
1239 
1240     wav-&gt;width = (wav-&gt;blockalign * 8) / wav-&gt;channels;
1241     wav-&gt;bytes_per_sample = wav-&gt;channels * wav-&gt;width / 8;
1242 
1243     if (wav-&gt;bytes_per_sample &lt;= 0)
1244       goto no_bytes_per_sample;
1245 
1246     GST_DEBUG_OBJECT (wav, &quot;blockalign = %u&quot;, (guint) wav-&gt;blockalign);
1247     GST_DEBUG_OBJECT (wav, &quot;width      = %u&quot;, (guint) wav-&gt;width);
1248     GST_DEBUG_OBJECT (wav, &quot;depth      = %u&quot;, (guint) wav-&gt;depth);
1249     GST_DEBUG_OBJECT (wav, &quot;av_bps     = %u&quot;, (guint) wav-&gt;av_bps);
1250     GST_DEBUG_OBJECT (wav, &quot;frequency  = %u&quot;, (guint) wav-&gt;rate);
1251     GST_DEBUG_OBJECT (wav, &quot;channels   = %u&quot;, (guint) wav-&gt;channels);
1252     GST_DEBUG_OBJECT (wav, &quot;bytes_per_sample = %u&quot;, wav-&gt;bytes_per_sample);
1253 
1254     /* bps can be 0 when we don&#39;t have a valid bitrate (mostly for compressed
1255      * formats). This will make the element output a BYTE format segment and
1256      * will not timestamp the outgoing buffers.
1257      */
1258     GST_DEBUG_OBJECT (wav, &quot;bps        = %u&quot;, (guint) wav-&gt;bps);
1259 
1260     GST_DEBUG_OBJECT (wav, &quot;caps = %&quot; GST_PTR_FORMAT, caps);
1261 
1262     /* create pad later so we can sniff the first few bytes
1263      * of the real data and correct our caps if necessary */
1264     gst_caps_replace (&amp;wav-&gt;caps, caps);
1265     gst_caps_replace (&amp;caps, NULL);
1266 
1267     wav-&gt;got_fmt = TRUE;
1268 
1269     if (wav-&gt;tags == NULL)
1270       wav-&gt;tags = gst_tag_list_new_empty ();
1271 
1272     {
1273       GstCaps *templ_caps = gst_pad_get_pad_template_caps (wav-&gt;sinkpad);
1274       gst_pb_utils_add_codec_description_to_tag_list (wav-&gt;tags,
1275           GST_TAG_CONTAINER_FORMAT, templ_caps);
1276       gst_caps_unref (templ_caps);
1277     }
1278 
1279     /* If bps is nonzero, then we do have a valid bitrate that can be
1280      * announced in a tag list. */
1281     if (wav-&gt;bps) {
1282       guint bitrate = wav-&gt;bps * 8;
1283       gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1284           GST_TAG_BITRATE, bitrate, NULL);
1285     }
1286 
1287     if (codec_name) {
1288       gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1289           GST_TAG_AUDIO_CODEC, codec_name, NULL);
1290 
1291       g_free (codec_name);
1292       codec_name = NULL;
1293     }
1294 
1295   }
1296 
1297   gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES, &amp;upstream_size);
1298   GST_DEBUG_OBJECT (wav, &quot;upstream size %&quot; G_GUINT64_FORMAT, upstream_size);
1299 
1300   /* loop headers until we get data */
1301   while (!gotdata) {
1302     if (wav-&gt;streaming) {
1303       if (!gst_wavparse_peek_chunk_info (wav, &amp;tag, &amp;size))
1304         goto exit;
1305     } else {
1306       GstMapInfo map;
1307 
1308       buf = NULL;
1309       if ((res =
1310               gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset, 8,
1311                   &amp;buf)) != GST_FLOW_OK)
1312 #ifdef GSTREAMER_LITE
1313         if (res == GST_FLOW_FLUSHING)
1314           goto exit;
1315         else
1316 #endif // GSTREAMER_LITE
1317         goto header_read_error;
1318       gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1319       tag = GST_READ_UINT32_LE (map.data);
1320       size = GST_READ_UINT32_LE (map.data + 4);
1321       gst_buffer_unmap (buf, &amp;map);
1322     }
1323 
1324     GST_INFO_OBJECT (wav,
1325         &quot;Got TAG: %&quot; GST_FOURCC_FORMAT &quot;, offset %&quot; G_GUINT64_FORMAT &quot;, size %&quot;
1326         G_GUINT32_FORMAT, GST_FOURCC_ARGS (tag), wav-&gt;offset, size);
1327 
1328     /* Maximum valid size is INT_MAX */
1329     if (size &amp; 0x80000000) {
1330       GST_WARNING_OBJECT (wav, &quot;Invalid size, clipping to 0x7fffffff&quot;);
1331       size = 0x7fffffff;
1332     }
1333 
1334     /* Clip to upstream size if known */
1335     if (upstream_size &gt; 0 &amp;&amp; size + wav-&gt;offset &gt; upstream_size) {
1336       GST_WARNING_OBJECT (wav, &quot;Clipping chunk size to file size&quot;);
1337       g_assert (upstream_size &gt;= wav-&gt;offset);
1338       size = upstream_size - wav-&gt;offset;
1339     }
1340 
1341     /* wav is a st00pid format, we don&#39;t know for sure where data starts.
1342      * So we have to go bit by bit until we find the &#39;data&#39; header
1343      */
1344     switch (tag) {
1345       case GST_RIFF_TAG_data:{
1346         guint64 size64;
1347 
1348         GST_DEBUG_OBJECT (wav, &quot;Got &#39;data&#39; TAG, size : %u&quot;, size);
1349         size64 = size;
1350         if (wav-&gt;ignore_length) {
1351           GST_DEBUG_OBJECT (wav, &quot;Ignoring length&quot;);
1352           size64 = 0;
1353         }
1354         if (wav-&gt;streaming) {
1355           gst_adapter_flush (wav-&gt;adapter, 8);
1356           gotdata = TRUE;
1357         } else {
1358           gst_buffer_unref (buf);
1359         }
1360         wav-&gt;offset += 8;
1361         wav-&gt;datastart = wav-&gt;offset;
1362         /* use size from ds64 chunk if available */
1363         if (size64 == -1 &amp;&amp; wav-&gt;datasize &gt; 0) {
1364           GST_DEBUG_OBJECT (wav, &quot;Using ds64 datasize&quot;);
1365           size64 = wav-&gt;datasize;
1366         }
1367         wav-&gt;chunk_size = size64;
1368 
1369         /* If size is zero, then the data chunk probably actually extends to
1370            the end of the file */
1371         if (size64 == 0 &amp;&amp; upstream_size) {
1372           size64 = upstream_size - wav-&gt;datastart;
1373         }
1374         /* Or the file might be truncated */
1375         else if (upstream_size) {
1376           size64 = MIN (size64, (upstream_size - wav-&gt;datastart));
1377         }
1378         wav-&gt;datasize = size64;
1379         wav-&gt;dataleft = size64;
1380         wav-&gt;end_offset = size64 + wav-&gt;datastart;
1381         if (!wav-&gt;streaming) {
1382           /* We will continue parsing tags &#39;till end */
1383           wav-&gt;offset += size64;
1384         }
1385         GST_DEBUG_OBJECT (wav, &quot;datasize = %&quot; G_GUINT64_FORMAT, size64);
1386         break;
1387       }
1388       case GST_RIFF_TAG_fact:{
1389         if (wav-&gt;fact == 0 &amp;&amp;
1390             wav-&gt;format != GST_RIFF_WAVE_FORMAT_MPEGL12 &amp;&amp;
1391             wav-&gt;format != GST_RIFF_WAVE_FORMAT_MPEGL3) {
1392           const guint data_size = 4;
1393 
1394           GST_INFO_OBJECT (wav, &quot;Have fact chunk&quot;);
1395           if (size &lt; data_size) {
1396             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1397               /* need more data */
1398               goto exit;
1399             }
1400             GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1401                 data_size, size);
1402             break;
1403           }
1404           /* number of samples (for compressed formats) */
1405           if (wav-&gt;streaming) {
1406             const guint8 *data = NULL;
1407 
1408             if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1409               goto exit;
1410             }
1411             gst_adapter_flush (wav-&gt;adapter, 8);
1412             data = gst_adapter_map (wav-&gt;adapter, data_size);
1413 #ifdef GSTREAMER_LITE
1414             if (data == NULL) {
<a name="13" id="anc13"></a><span class="line-modified">1415               goto header_read_error;</span>
1416             }
1417 #endif // GSTREAMER_LITE
1418             wav-&gt;fact = GST_READ_UINT32_LE (data);
1419             gst_adapter_unmap (wav-&gt;adapter);
1420             gst_adapter_flush (wav-&gt;adapter, GST_ROUND_UP_2 (size));
1421           } else {
1422             gst_buffer_unref (buf);
1423             buf = NULL;
1424             if ((res =
1425                     gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1426                         data_size, &amp;buf)) != GST_FLOW_OK)
1427 #ifdef GSTREAMER_LITE
1428             if (res == GST_FLOW_FLUSHING)
1429               goto exit;
1430             else
1431 #endif // GSTREAMER_LITE
1432               goto header_read_error;
1433             gst_buffer_extract (buf, 0, &amp;wav-&gt;fact, 4);
1434             wav-&gt;fact = GUINT32_FROM_LE (wav-&gt;fact);
1435             gst_buffer_unref (buf);
1436           }
1437           GST_DEBUG_OBJECT (wav, &quot;have fact %&quot; G_GUINT64_FORMAT, wav-&gt;fact);
1438           wav-&gt;offset += 8 + GST_ROUND_UP_2 (size);
1439           break;
1440         } else {
1441           if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1442             /* need more data */
1443             goto exit;
1444           }
1445         }
1446         break;
1447       }
1448       case GST_RIFF_TAG_acid:{
1449         const gst_riff_acid *acid = NULL;
1450         const guint data_size = sizeof (gst_riff_acid);
1451         gfloat tempo;
1452 
1453         GST_INFO_OBJECT (wav, &quot;Have acid chunk&quot;);
1454         if (size &lt; data_size) {
1455           if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1456             /* need more data */
1457             goto exit;
1458           }
1459           GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1460               data_size, size);
1461           break;
1462         }
1463         if (wav-&gt;streaming) {
1464           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1465             goto exit;
1466           }
1467           gst_adapter_flush (wav-&gt;adapter, 8);
1468           acid = (const gst_riff_acid *) gst_adapter_map (wav-&gt;adapter,
1469               data_size);
1470           tempo = acid-&gt;tempo;
1471           gst_adapter_unmap (wav-&gt;adapter);
1472         } else {
1473           GstMapInfo map;
1474           gst_buffer_unref (buf);
1475           buf = NULL;
1476           if ((res =
1477                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1478                       size, &amp;buf)) != GST_FLOW_OK)
1479 #ifdef GSTREAMER_LITE
1480           if (res == GST_FLOW_FLUSHING)
1481             goto exit;
1482           else
1483 #endif // GSTREAMER_LITE
1484             goto header_read_error;
1485           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1486           acid = (const gst_riff_acid *) map.data;
1487           tempo = acid-&gt;tempo;
1488           gst_buffer_unmap (buf, &amp;map);
1489         }
1490         /* send data as tags */
1491         if (!wav-&gt;tags)
1492           wav-&gt;tags = gst_tag_list_new_empty ();
1493         gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1494             GST_TAG_BEATS_PER_MINUTE, tempo, NULL);
1495 
1496         size = GST_ROUND_UP_2 (size);
1497         if (wav-&gt;streaming) {
1498           gst_adapter_flush (wav-&gt;adapter, size);
1499         } else {
1500           gst_buffer_unref (buf);
1501         }
1502         wav-&gt;offset += 8 + size;
1503         break;
1504       }
1505         /* FIXME: all list tags after data are ignored in streaming mode */
1506       case GST_RIFF_TAG_LIST:{
1507         guint32 ltag;
1508 
1509         if (wav-&gt;streaming) {
1510           const guint8 *data = NULL;
1511 
1512           if (gst_adapter_available (wav-&gt;adapter) &lt; 12) {
1513             goto exit;
1514           }
1515           data = gst_adapter_map (wav-&gt;adapter, 12);
1516           ltag = GST_READ_UINT32_LE (data + 8);
1517           gst_adapter_unmap (wav-&gt;adapter);
1518         } else {
1519           gst_buffer_unref (buf);
1520           buf = NULL;
1521           if ((res =
1522                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset, 12,
1523                       &amp;buf)) != GST_FLOW_OK)
1524 #ifdef GSTREAMER_LITE
1525           if (res == GST_FLOW_FLUSHING)
1526             goto exit;
1527           else
1528 #endif // GSTREAMER_LITE
1529             goto header_read_error;
1530           gst_buffer_extract (buf, 8, &amp;ltag, 4);
1531           ltag = GUINT32_FROM_LE (ltag);
1532         }
1533         switch (ltag) {
1534           case GST_RIFF_LIST_INFO:{
1535             const gint data_size = size - 4;
1536             GstTagList *new;
1537 
1538             GST_INFO_OBJECT (wav, &quot;Have LIST chunk INFO size %u&quot;, data_size);
1539             if (wav-&gt;streaming) {
1540               if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1541                 goto exit;
1542               }
1543               gst_adapter_flush (wav-&gt;adapter, 12);
1544               wav-&gt;offset += 12;
1545               if (data_size &gt; 0) {
1546                 buf = gst_adapter_take_buffer (wav-&gt;adapter, data_size);
1547                 if (data_size &amp; 1)
1548                   gst_adapter_flush (wav-&gt;adapter, 1);
1549               }
1550             } else {
1551               wav-&gt;offset += 12;
1552               gst_buffer_unref (buf);
1553               buf = NULL;
1554               if (data_size &gt; 0) {
1555                 if ((res =
1556                         gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1557                             data_size, &amp;buf)) != GST_FLOW_OK)
1558 #ifdef GSTREAMER_LITE
1559                 if (res == GST_FLOW_FLUSHING)
1560                   goto exit;
1561                 else
1562 #endif // GSTREAMER_LITE
1563                   goto header_read_error;
1564               }
1565             }
1566             if (data_size &gt; 0) {
1567               /* parse tags */
1568               gst_riff_parse_info (GST_ELEMENT (wav), buf, &amp;new);
1569               if (new) {
1570                 GstTagList *old = wav-&gt;tags;
1571                 wav-&gt;tags =
1572                     gst_tag_list_merge (old, new, GST_TAG_MERGE_REPLACE);
1573                 if (old)
1574                   gst_tag_list_unref (old);
1575                 gst_tag_list_unref (new);
1576               }
1577               gst_buffer_unref (buf);
1578               wav-&gt;offset += GST_ROUND_UP_2 (data_size);
1579             }
1580             break;
1581           }
1582           case GST_RIFF_LIST_adtl:{
1583             const gint data_size = size - 4;
1584 
1585             GST_INFO_OBJECT (wav, &quot;Have &#39;adtl&#39; LIST, size %u&quot;, data_size);
1586             if (wav-&gt;streaming) {
1587               const guint8 *data = NULL;
1588 
1589               gst_adapter_flush (wav-&gt;adapter, 12);
1590               wav-&gt;offset += 12;
1591               data = gst_adapter_map (wav-&gt;adapter, data_size);
1592               gst_wavparse_adtl_chunk (wav, data, data_size);
1593               gst_adapter_unmap (wav-&gt;adapter);
1594             } else {
1595               GstMapInfo map;
1596 
1597               gst_buffer_unref (buf);
1598               buf = NULL;
1599               wav-&gt;offset += 12;
1600               if ((res =
1601                       gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1602                           data_size, &amp;buf)) != GST_FLOW_OK)
1603                 goto header_read_error;
1604               gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1605               gst_wavparse_adtl_chunk (wav, (const guint8 *) map.data,
1606                   data_size);
1607               gst_buffer_unmap (buf, &amp;map);
1608             }
1609             wav-&gt;offset += GST_ROUND_UP_2 (data_size);
1610             break;
1611           }
1612           default:
1613             GST_WARNING_OBJECT (wav, &quot;Ignoring LIST chunk %&quot; GST_FOURCC_FORMAT,
1614                 GST_FOURCC_ARGS (ltag));
1615             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size))
1616               /* need more data */
1617               goto exit;
1618             break;
1619         }
1620         break;
1621       }
1622       case GST_RIFF_TAG_cue:{
1623         const guint data_size = size;
1624 
1625         GST_DEBUG_OBJECT (wav, &quot;Have &#39;cue&#39; TAG, size : %u&quot;, data_size);
1626         if (wav-&gt;streaming) {
1627           const guint8 *data = NULL;
1628 
1629           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1630             goto exit;
1631           }
1632           gst_adapter_flush (wav-&gt;adapter, 8);
1633           wav-&gt;offset += 8;
1634           data = gst_adapter_map (wav-&gt;adapter, data_size);
1635           if (!gst_wavparse_cue_chunk (wav, data, data_size)) {
1636             goto header_read_error;
1637           }
1638           gst_adapter_unmap (wav-&gt;adapter);
1639         } else {
1640           GstMapInfo map;
1641 
1642           wav-&gt;offset += 8;
1643           gst_buffer_unref (buf);
1644           buf = NULL;
1645           if ((res =
1646                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1647                       data_size, &amp;buf)) != GST_FLOW_OK)
1648             goto header_read_error;
1649           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1650           if (!gst_wavparse_cue_chunk (wav, (const guint8 *) map.data,
1651                   data_size)) {
1652             goto header_read_error;
1653           }
1654           gst_buffer_unmap (buf, &amp;map);
1655         }
1656         size = GST_ROUND_UP_2 (size);
1657         if (wav-&gt;streaming) {
1658           gst_adapter_flush (wav-&gt;adapter, size);
1659         } else {
1660           gst_buffer_unref (buf);
1661         }
1662         size = GST_ROUND_UP_2 (size);
1663         wav-&gt;offset += size;
1664         break;
1665       }
1666       case GST_RIFF_TAG_smpl:{
1667         const gint data_size = size;
1668 
1669         GST_DEBUG_OBJECT (wav, &quot;Have &#39;smpl&#39; TAG, size : %u&quot;, data_size);
1670         if (wav-&gt;streaming) {
1671           const guint8 *data = NULL;
1672 
1673           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1674             goto exit;
1675           }
1676           gst_adapter_flush (wav-&gt;adapter, 8);
1677           wav-&gt;offset += 8;
1678           data = gst_adapter_map (wav-&gt;adapter, data_size);
1679           if (!gst_wavparse_smpl_chunk (wav, data, data_size)) {
1680             goto header_read_error;
1681           }
1682           gst_adapter_unmap (wav-&gt;adapter);
1683         } else {
1684           GstMapInfo map;
1685 
1686           wav-&gt;offset += 8;
1687           gst_buffer_unref (buf);
1688           buf = NULL;
1689           if ((res =
1690                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1691                       data_size, &amp;buf)) != GST_FLOW_OK)
1692             goto header_read_error;
1693           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1694           if (!gst_wavparse_smpl_chunk (wav, (const guint8 *) map.data,
1695                   data_size)) {
1696             goto header_read_error;
1697           }
1698           gst_buffer_unmap (buf, &amp;map);
1699         }
1700         size = GST_ROUND_UP_2 (size);
1701         if (wav-&gt;streaming) {
1702           gst_adapter_flush (wav-&gt;adapter, size);
1703         } else {
1704           gst_buffer_unref (buf);
1705         }
1706         size = GST_ROUND_UP_2 (size);
1707         wav-&gt;offset += size;
1708         break;
1709       }
1710       default:
1711         GST_WARNING_OBJECT (wav, &quot;Ignoring chunk %&quot; GST_FOURCC_FORMAT,
1712             GST_FOURCC_ARGS (tag));
1713         if (!gst_waveparse_ignore_chunk (wav, buf, tag, size))
1714           /* need more data */
1715           goto exit;
1716         break;
1717     }
1718 
1719     if (upstream_size &amp;&amp; (wav-&gt;offset &gt;= upstream_size)) {
1720       /* Now we are gone through the whole file */
1721       gotdata = TRUE;
1722     }
1723   }
1724 
1725   GST_DEBUG_OBJECT (wav, &quot;Finished parsing headers&quot;);
1726 
1727   if (wav-&gt;bps &lt;= 0 &amp;&amp; wav-&gt;fact) {
1728 #if 0
1729     /* not a good idea, as for embedded mp2/mp3 we set bps to 0 earlier */
1730     wav-&gt;bps =
1731         (guint32) gst_util_uint64_scale ((guint64) wav-&gt;rate, wav-&gt;datasize,
1732         (guint64) wav-&gt;fact);
1733     GST_INFO_OBJECT (wav, &quot;calculated bps : %u, enabling VBR&quot;, wav-&gt;bps);
1734 #endif
1735     wav-&gt;vbr = TRUE;
1736   }
1737 
1738   if (gst_wavparse_calculate_duration (wav)) {
1739     gst_segment_init (&amp;wav-&gt;segment, GST_FORMAT_TIME);
1740     if (!wav-&gt;ignore_length)
1741       wav-&gt;segment.duration = wav-&gt;duration;
1742     if (!wav-&gt;toc)
1743       gst_wavparse_create_toc (wav);
1744   } else {
1745     /* no bitrate, let downstream peer do the math, we&#39;ll feed it bytes. */
1746     gst_segment_init (&amp;wav-&gt;segment, GST_FORMAT_BYTES);
1747     if (!wav-&gt;ignore_length)
1748       wav-&gt;segment.duration = wav-&gt;datasize;
1749   }
1750 
1751   /* now we have all the info to perform a pending seek if any, if no
1752    * event, this will still do the right thing and it will also send
1753    * the right newsegment event downstream. */
1754   gst_wavparse_perform_seek (wav, wav-&gt;seek_event);
1755   /* remove pending event */
1756   gst_event_replace (&amp;wav-&gt;seek_event, NULL);
1757 
1758   /* we just started, we are discont */
1759   wav-&gt;discont = TRUE;
1760 
1761   wav-&gt;state = GST_WAVPARSE_DATA;
1762 
1763   /* determine reasonable max buffer size,
1764    * that is, buffers not too small either size or time wise
1765    * so we do not end up with too many of them */
1766   /* var abuse */
1767   if (gst_wavparse_time_to_bytepos (wav, 40 * GST_MSECOND, &amp;upstream_size))
<a name="14" id="anc14"></a><span class="line-modified">1768     wav-&gt;max_buf_size = upstream_size;</span>
1769   else
1770     wav-&gt;max_buf_size = 0;
1771   wav-&gt;max_buf_size = MAX (wav-&gt;max_buf_size, MAX_BUFFER_SIZE);
1772   if (wav-&gt;blockalign &gt; 0)
1773     wav-&gt;max_buf_size -= (wav-&gt;max_buf_size % wav-&gt;blockalign);
1774 
1775   GST_DEBUG_OBJECT (wav, &quot;max buffer size %u&quot;, wav-&gt;max_buf_size);
1776 
1777   return GST_FLOW_OK;
1778 
1779   /* ERROR */
1780 exit:
1781   {
<a name="15" id="anc15"></a><span class="line-modified">1782     g_free (codec_name);</span>
<span class="line-modified">1783     g_free (header);</span>
1784     if (caps)
1785       gst_caps_unref (caps);
1786     return res;
1787   }
1788 fail:
1789   {
1790     res = GST_FLOW_ERROR;
1791     goto exit;
1792   }
1793 parse_header_error:
1794   {
1795     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1796         (&quot;Couldn&#39;t parse audio header&quot;));
1797     goto fail;
1798   }
1799 no_channels:
1800   {
1801     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1802         (&quot;Stream claims to contain no channels - invalid data&quot;));
1803     goto fail;
1804   }
1805 no_rate:
1806   {
1807     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1808         (&quot;Stream with sample_rate == 0 - invalid data&quot;));
1809     goto fail;
1810   }
1811 invalid_blockalign:
1812   {
1813     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1814         (&quot;Stream claims blockalign = %u, which is more than %u - invalid data&quot;,
1815             wav-&gt;blockalign, wav-&gt;channels * ((wav-&gt;depth + 7) / 8)));
1816     goto fail;
1817   }
1818 invalid_bps:
1819   {
1820     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1821         (&quot;Stream claims av_bsp = %u, which is more than %u - invalid data&quot;,
1822             wav-&gt;av_bps, wav-&gt;blockalign * wav-&gt;rate));
1823     goto fail;
1824   }
1825 no_bytes_per_sample:
1826   {
1827     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1828         (&quot;Could not caluclate bytes per sample - invalid data&quot;));
1829     goto fail;
1830   }
1831 unknown_format:
1832   {
1833     GST_ELEMENT_ERROR (wav, STREAM, TYPE_NOT_FOUND, (NULL),
1834         (&quot;No caps found for format 0x%x, %u channels, %u Hz&quot;,
1835             wav-&gt;format, wav-&gt;channels, wav-&gt;rate));
1836     goto fail;
1837   }
1838 header_read_error:
1839   {
1840     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1841         (&quot;Couldn&#39;t read in header %d (%s)&quot;, res, gst_flow_get_name (res)));
1842     goto fail;
1843   }
1844 }
1845 
1846 /*
1847  * Read WAV file tag when streaming
1848  */
1849 static GstFlowReturn
1850 gst_wavparse_parse_stream_init (GstWavParse * wav)
1851 {
1852   if (gst_adapter_available (wav-&gt;adapter) &gt;= 12) {
1853     GstBuffer *tmp;
1854 
1855     /* _take flushes the data */
1856     tmp = gst_adapter_take_buffer (wav-&gt;adapter, 12);
1857 
1858     GST_DEBUG (&quot;Parsing wav header&quot;);
1859     if (!gst_wavparse_parse_file_header (GST_ELEMENT_CAST (wav), tmp))
1860       return GST_FLOW_ERROR;
1861 
1862     wav-&gt;offset += 12;
1863     /* Go to next state */
1864     wav-&gt;state = GST_WAVPARSE_HEADER;
1865   }
1866   return GST_FLOW_OK;
1867 }
1868 
1869 /* handle an event sent directly to the element.
1870  *
1871  * This event can be sent either in the READY state or the
1872  * &gt;READY state. The only event of interest really is the seek
1873  * event.
1874  *
1875  * In the READY state we can only store the event and try to
1876  * respect it when going to PAUSED. We assume we are in the
1877  * READY state when our parsing state != GST_WAVPARSE_DATA.
1878  *
1879  * When we are steaming, we can simply perform the seek right
1880  * away.
1881  */
1882 static gboolean
1883 gst_wavparse_send_event (GstElement * element, GstEvent * event)
1884 {
1885   GstWavParse *wav = GST_WAVPARSE (element);
1886   gboolean res = FALSE;
1887 
1888   GST_DEBUG_OBJECT (wav, &quot;received event %s&quot;, GST_EVENT_TYPE_NAME (event));
1889 
1890   switch (GST_EVENT_TYPE (event)) {
1891     case GST_EVENT_SEEK:
1892       if (wav-&gt;state == GST_WAVPARSE_DATA) {
1893         /* we can handle the seek directly when streaming data */
1894         res = gst_wavparse_perform_seek (wav, event);
1895       } else {
1896         GST_DEBUG_OBJECT (wav, &quot;queuing seek for later&quot;);
1897 
1898         gst_event_replace (&amp;wav-&gt;seek_event, event);
1899 
1900         /* we always return true */
1901         res = TRUE;
1902       }
1903       break;
1904     default:
1905       break;
1906   }
1907   gst_event_unref (event);
1908   return res;
1909 }
1910 
1911 static gboolean
1912 gst_wavparse_have_dts_caps (const GstCaps * caps, GstTypeFindProbability prob)
1913 {
1914   GstStructure *s;
1915 
1916   s = gst_caps_get_structure (caps, 0);
1917   if (!gst_structure_has_name (s, &quot;audio/x-dts&quot;))
1918     return FALSE;
1919   /* typefind behavior for DTS:
1920    *  MAXIMUM: multiple frame syncs detected, certainly DTS
1921    *  LIKELY: single frame sync at offset 0.  Maybe DTS?
1922    *  POSSIBLE: single frame sync, not at offset 0.  Highly unlikely
1923    *    to be DTS.  */
1924   if (prob &gt; GST_TYPE_FIND_LIKELY)
1925     return TRUE;
1926   if (prob &lt;= GST_TYPE_FIND_POSSIBLE)
1927     return FALSE;
1928   /* for maybe, check for at least a valid-looking rate and channels */
1929   if (!gst_structure_has_field (s, &quot;channels&quot;))
1930     return FALSE;
1931   /* and for extra assurance we could also check the rate from the DTS frame
1932    * against the one in the wav header, but for now let&#39;s not do that */
1933   return gst_structure_has_field (s, &quot;rate&quot;);
1934 }
1935 
1936 static GstTagList *
1937 gst_wavparse_get_upstream_tags (GstWavParse * wav, GstTagScope scope)
1938 {
1939   GstTagList *tags = NULL;
1940   GstEvent *ev;
1941   gint i;
1942 
1943   i = 0;
1944   while ((ev = gst_pad_get_sticky_event (wav-&gt;sinkpad, GST_EVENT_TAG, i++))) {
1945     gst_event_parse_tag (ev, &amp;tags);
1946     if (tags != NULL &amp;&amp; gst_tag_list_get_scope (tags) == scope) {
1947       tags = gst_tag_list_copy (tags);
1948       gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);
1949       gst_event_unref (ev);
1950       break;
1951     }
1952     tags = NULL;
1953     gst_event_unref (ev);
1954   }
1955   return tags;
1956 }
1957 
1958 static void
1959 gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
1960 {
1961   GstStructure *s;
1962   GstTagList *tags, *utags;
1963 
1964   GST_DEBUG_OBJECT (wav, &quot;adding src pad&quot;);
1965 
1966   g_assert (wav-&gt;caps != NULL);
1967 
<a name="16" id="anc16"></a><span class="line-modified">1968   s = gst_caps_get_structure (wav-&gt;caps, 0);</span>
1969   if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;) &amp;&amp; buf != NULL) {
<a name="17" id="anc17"></a><span class="line-modified">1970     GstTypeFindProbability prob;</span>
<span class="line-modified">1971     GstCaps *tf_caps;</span>
<span class="line-modified">1972 </span>
<span class="line-modified">1973     tf_caps = gst_type_find_helper_for_buffer (GST_OBJECT (wav), buf, &amp;prob);</span>
<span class="line-modified">1974     if (tf_caps != NULL) {</span>
<span class="line-modified">1975       GST_LOG (&quot;typefind caps = %&quot; GST_PTR_FORMAT &quot;, P=%d&quot;, tf_caps, prob);</span>
<span class="line-modified">1976       if (gst_wavparse_have_dts_caps (tf_caps, prob)) {</span>
<span class="line-modified">1977         GST_INFO_OBJECT (wav, &quot;Found DTS marker in file marked as raw PCM&quot;);</span>
<span class="line-modified">1978         gst_caps_unref (wav-&gt;caps);</span>
<span class="line-modified">1979         wav-&gt;caps = tf_caps;</span>
<span class="line-modified">1980 </span>
<span class="line-modified">1981         gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,</span>
<span class="line-modified">1982             GST_TAG_AUDIO_CODEC, &quot;dts&quot;, NULL);</span>
<span class="line-modified">1983       } else {</span>
<span class="line-modified">1984         GST_DEBUG_OBJECT (wav, &quot;found caps %&quot; GST_PTR_FORMAT &quot; for stream &quot;</span>
<span class="line-modified">1985             &quot;marked as raw PCM audio, but ignoring for now&quot;, tf_caps);</span>
<span class="line-modified">1986         gst_caps_unref (tf_caps);</span>

1987       }
1988     }
<a name="18" id="anc18"></a><span class="line-added">1989   }</span>
1990 
1991   gst_pad_set_caps (wav-&gt;srcpad, wav-&gt;caps);
1992 
1993   if (wav-&gt;start_segment) {
1994     GST_DEBUG_OBJECT (wav, &quot;Send start segment event on newpad&quot;);
1995     gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
1996     wav-&gt;start_segment = NULL;
1997   }
1998 
1999   /* upstream tags, e.g. from id3/ape tag before the wav file; assume for now
2000    * that there&#39;ll be only one scope/type of tag list from upstream, if any */
2001   utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_GLOBAL);
2002   if (utags == NULL)
2003     utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_STREAM);
2004 
2005   /* if there&#39;s a tag upstream it&#39;s probably been added to override the
2006    * tags from inside the wav header, so keep upstream tags if in doubt */
2007   tags = gst_tag_list_merge (utags, wav-&gt;tags, GST_TAG_MERGE_KEEP);
2008 
2009   if (wav-&gt;tags != NULL) {
2010     gst_tag_list_unref (wav-&gt;tags);
2011     wav-&gt;tags = NULL;
2012   }
2013 
2014   if (utags != NULL)
2015     gst_tag_list_unref (utags);
2016 
2017   /* send tags downstream, if any */
2018   if (tags != NULL)
2019     gst_pad_push_event (wav-&gt;srcpad, gst_event_new_tag (tags));
2020 }
2021 
2022 static GstFlowReturn
2023 gst_wavparse_stream_data (GstWavParse * wav)
2024 {
2025   GstBuffer *buf = NULL;
2026   GstFlowReturn res = GST_FLOW_OK;
2027   guint64 desired, obtained;
2028   GstClockTime timestamp, next_timestamp, duration;
2029   guint64 pos, nextpos;
2030 
2031 iterate_adapter:
2032   GST_LOG_OBJECT (wav,
2033       &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT &quot; , dataleft: %&quot;
2034       G_GINT64_FORMAT, wav-&gt;offset, wav-&gt;end_offset, wav-&gt;dataleft);
2035 
2036   if ((wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)) {
2037     /* In case chunk size is not declared in the begining get size from the
2038      * file size directly */
2039     if (wav-&gt;chunk_size == 0) {
2040       gint64 upstream_size = 0;
2041 
2042       /* Get the size of the file   */
2043       if (!gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES,
2044               &amp;upstream_size))
2045         goto found_eos;
2046 
2047       if (upstream_size &lt; wav-&gt;offset + wav-&gt;datastart)
2048         goto found_eos;
2049 
2050       /* If file has updated since the beggining continue reading the file */
2051       wav-&gt;dataleft = upstream_size - wav-&gt;offset - wav-&gt;datastart;
2052       wav-&gt;end_offset = upstream_size;
2053 
2054       /* Get the next n bytes and output them, if we can */
<a name="19" id="anc19"></a><span class="line-modified">2055       if (wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)</span>
<span class="line-modified">2056         goto found_eos;</span>
2057     } else {
2058       goto found_eos;
2059     }
2060   }
2061 
2062   /* scale the amount of data by the segment rate so we get equal
2063    * amounts of data regardless of the playback rate */
2064   desired =
2065       MIN (gst_guint64_to_gdouble (wav-&gt;dataleft),
2066       wav-&gt;max_buf_size * ABS (wav-&gt;segment.rate));
2067 
2068   if (desired &gt;= wav-&gt;blockalign &amp;&amp; wav-&gt;blockalign &gt; 0)
2069     desired -= (desired % wav-&gt;blockalign);
2070 
2071 #ifdef GSTREAMER_LITE
2072   if (desired == 0) {
2073     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
2074               (&quot;Invalid stream&quot;));
2075     return GST_FLOW_ERROR;
2076   }
2077 #endif // GSTREAMER_LITE
2078 
2079   GST_LOG_OBJECT (wav, &quot;Fetching %&quot; G_GINT64_FORMAT &quot; bytes of data &quot;
2080       &quot;from the sinkpad&quot;, desired);
2081 
2082   if (wav-&gt;streaming) {
2083     guint avail = gst_adapter_available (wav-&gt;adapter);
2084     guint extra;
2085 
2086     /* flush some bytes if evil upstream sends segment that starts
2087      * before data or does is not send sample aligned segment */
2088     if (G_LIKELY (wav-&gt;offset &gt;= wav-&gt;datastart)) {
2089       extra = (wav-&gt;offset - wav-&gt;datastart) % wav-&gt;bytes_per_sample;
2090     } else {
2091       extra = wav-&gt;datastart - wav-&gt;offset;
2092     }
2093 
2094     if (G_UNLIKELY (extra)) {
2095       extra = wav-&gt;bytes_per_sample - extra;
2096       if (extra &lt;= avail) {
2097         GST_DEBUG_OBJECT (wav, &quot;flushing %u bytes to sample boundary&quot;, extra);
2098         gst_adapter_flush (wav-&gt;adapter, extra);
2099         wav-&gt;offset += extra;
2100         wav-&gt;dataleft -= extra;
2101         goto iterate_adapter;
2102       } else {
2103         GST_DEBUG_OBJECT (wav, &quot;flushing %u bytes&quot;, avail);
2104         gst_adapter_clear (wav-&gt;adapter);
2105         wav-&gt;offset += avail;
2106         wav-&gt;dataleft -= avail;
2107         return GST_FLOW_OK;
2108       }
2109     }
2110 
2111     if (avail &lt; desired) {
2112       GST_LOG_OBJECT (wav, &quot;Got only %u bytes of data from the sinkpad&quot;, avail);
2113       return GST_FLOW_OK;
2114     }
2115 
2116     buf = gst_adapter_take_buffer (wav-&gt;adapter, desired);
2117   } else {
2118     if ((res = gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
2119                 desired, &amp;buf)) != GST_FLOW_OK)
2120       goto pull_error;
2121 
2122     /* we may get a short buffer at the end of the file */
2123     if (gst_buffer_get_size (buf) &lt; desired) {
2124       gsize size = gst_buffer_get_size (buf);
2125 
2126       GST_LOG_OBJECT (wav, &quot;Got only %&quot; G_GSIZE_FORMAT &quot; bytes of data&quot;, size);
2127       if (size &gt;= wav-&gt;blockalign) {
2128         if (wav-&gt;blockalign &gt; 0) {
2129           buf = gst_buffer_make_writable (buf);
2130           gst_buffer_resize (buf, 0, size - (size % wav-&gt;blockalign));
2131         }
2132       } else {
2133         gst_buffer_unref (buf);
2134         goto found_eos;
2135       }
2136     }
2137   }
2138 
2139   obtained = gst_buffer_get_size (buf);
2140 
2141   /* our positions in bytes */
2142   pos = wav-&gt;offset - wav-&gt;datastart;
2143   nextpos = pos + obtained;
2144 
2145   /* update offsets, does not overflow. */
2146   buf = gst_buffer_make_writable (buf);
2147   GST_BUFFER_OFFSET (buf) = pos / wav-&gt;bytes_per_sample;
2148   GST_BUFFER_OFFSET_END (buf) = nextpos / wav-&gt;bytes_per_sample;
2149 
2150   /* first chunk of data? create the source pad. We do this only here so
2151    * we can detect broken .wav files with dts disguised as raw PCM (sigh) */
2152   if (G_UNLIKELY (wav-&gt;first)) {
2153     wav-&gt;first = FALSE;
2154     /* this will also push the segment events */
2155     gst_wavparse_add_src_pad (wav, buf);
2156   } else {
2157     /* If we have a pending start segment, send it now. */
2158     if (G_UNLIKELY (wav-&gt;start_segment != NULL)) {
2159       gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
2160       wav-&gt;start_segment = NULL;
2161     }
2162   }
2163 
2164   if (wav-&gt;bps &gt; 0) {
2165     /* and timestamps if we have a bitrate, be careful for overflows */
2166     timestamp =
2167         gst_util_uint64_scale_ceil (pos, GST_SECOND, (guint64) wav-&gt;bps);
2168     next_timestamp =
2169         gst_util_uint64_scale_ceil (nextpos, GST_SECOND, (guint64) wav-&gt;bps);
2170     duration = next_timestamp - timestamp;
2171 
2172     /* update current running segment position */
2173     if (G_LIKELY (next_timestamp &gt;= wav-&gt;segment.start))
2174       wav-&gt;segment.position = next_timestamp;
2175   } else if (wav-&gt;fact) {
2176     guint64 bps =
2177         gst_util_uint64_scale_int (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
2178     /* and timestamps if we have a bitrate, be careful for overflows */
2179     timestamp = gst_util_uint64_scale_ceil (pos, GST_SECOND, bps);
2180     next_timestamp = gst_util_uint64_scale_ceil (nextpos, GST_SECOND, bps);
2181     duration = next_timestamp - timestamp;
2182   } else {
2183     /* no bitrate, all we know is that the first sample has timestamp 0, all
2184      * other positions and durations have unknown timestamp. */
2185     if (pos == 0)
2186       timestamp = 0;
2187     else
2188       timestamp = GST_CLOCK_TIME_NONE;
2189     duration = GST_CLOCK_TIME_NONE;
2190     /* update current running segment position with byte offset */
2191     if (G_LIKELY (nextpos &gt;= wav-&gt;segment.start))
2192       wav-&gt;segment.position = nextpos;
2193   }
2194   if ((pos &gt; 0) &amp;&amp; wav-&gt;vbr) {
2195     /* don&#39;t set timestamps for VBR files if it&#39;s not the first buffer */
2196     timestamp = GST_CLOCK_TIME_NONE;
2197     duration = GST_CLOCK_TIME_NONE;
2198   }
2199   if (wav-&gt;discont) {
2200     GST_DEBUG_OBJECT (wav, &quot;marking DISCONT&quot;);
2201     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
2202     wav-&gt;discont = FALSE;
2203   }
2204 
2205   GST_BUFFER_TIMESTAMP (buf) = timestamp;
2206   GST_BUFFER_DURATION (buf) = duration;
2207 
2208   GST_LOG_OBJECT (wav,
2209       &quot;Got buffer. timestamp:%&quot; GST_TIME_FORMAT &quot; , duration:%&quot; GST_TIME_FORMAT
2210       &quot;, size:%&quot; G_GSIZE_FORMAT, GST_TIME_ARGS (timestamp),
2211       GST_TIME_ARGS (duration), gst_buffer_get_size (buf));
2212 
2213   if ((res = gst_pad_push (wav-&gt;srcpad, buf)) != GST_FLOW_OK)
2214     goto push_error;
2215 
2216   if (obtained &lt; wav-&gt;dataleft) {
2217     wav-&gt;offset += obtained;
2218     wav-&gt;dataleft -= obtained;
2219   } else {
2220     wav-&gt;offset += wav-&gt;dataleft;
2221     wav-&gt;dataleft = 0;
2222   }
2223 
2224   /* Iterate until need more data, so adapter size won&#39;t grow */
2225   if (wav-&gt;streaming) {
2226     GST_LOG_OBJECT (wav,
2227         &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT, wav-&gt;offset,
2228         wav-&gt;end_offset);
2229     goto iterate_adapter;
2230   }
2231   return res;
2232 
2233   /* ERROR */
2234 found_eos:
2235   {
2236     GST_DEBUG_OBJECT (wav, &quot;found EOS&quot;);
2237     return GST_FLOW_EOS;
2238   }
2239 pull_error:
2240   {
2241     /* check if we got EOS */
2242     if (res == GST_FLOW_EOS)
2243       goto found_eos;
2244 
2245     GST_WARNING_OBJECT (wav,
2246         &quot;Error getting %&quot; G_GINT64_FORMAT &quot; bytes from the &quot;
2247         &quot;sinkpad (dataleft = %&quot; G_GINT64_FORMAT &quot;)&quot;, desired, wav-&gt;dataleft);
2248     return res;
2249   }
2250 push_error:
2251   {
2252     GST_INFO_OBJECT (wav,
2253         &quot;Error pushing on srcpad %s:%s, reason %s, is linked? = %d&quot;,
2254         GST_DEBUG_PAD_NAME (wav-&gt;srcpad), gst_flow_get_name (res),
2255         gst_pad_is_linked (wav-&gt;srcpad));
2256     return res;
2257   }
2258 }
2259 
2260 static void
2261 gst_wavparse_loop (GstPad * pad)
2262 {
2263   GstFlowReturn ret;
2264   GstWavParse *wav = GST_WAVPARSE (GST_PAD_PARENT (pad));
2265   GstEvent *event;
2266   gchar *stream_id;
2267 
2268   GST_LOG_OBJECT (wav, &quot;process data&quot;);
2269 
2270   switch (wav-&gt;state) {
2271     case GST_WAVPARSE_START:
2272       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2273       if ((ret = gst_wavparse_stream_init (wav)) != GST_FLOW_OK)
2274         goto pause;
2275 
2276       stream_id =
2277           gst_pad_create_stream_id (wav-&gt;srcpad, GST_ELEMENT_CAST (wav), NULL);
2278       event = gst_event_new_stream_start (stream_id);
2279       gst_event_set_group_id (event, gst_util_group_id_next ());
2280       gst_pad_push_event (wav-&gt;srcpad, event);
2281       g_free (stream_id);
2282 
2283       wav-&gt;state = GST_WAVPARSE_HEADER;
2284       /* fall-through */
2285 
2286     case GST_WAVPARSE_HEADER:
2287       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_HEADER&quot;);
2288       if ((ret = gst_wavparse_stream_headers (wav)) != GST_FLOW_OK)
2289         goto pause;
2290 
2291       wav-&gt;state = GST_WAVPARSE_DATA;
2292       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_DATA&quot;);
2293       /* fall-through */
2294 
2295     case GST_WAVPARSE_DATA:
2296       if ((ret = gst_wavparse_stream_data (wav)) != GST_FLOW_OK)
2297         goto pause;
2298       break;
2299     default:
2300       g_assert_not_reached ();
2301   }
2302   return;
2303 
2304   /* ERRORS */
2305 pause:
2306   {
2307     const gchar *reason = gst_flow_get_name (ret);
2308 
2309     GST_DEBUG_OBJECT (wav, &quot;pausing task, reason %s&quot;, reason);
2310     gst_pad_pause_task (pad);
2311 
2312     if (ret == GST_FLOW_EOS) {
2313       /* handle end-of-stream/segment */
2314       /* so align our position with the end of it, if there is one
2315        * this ensures a subsequent will arrive at correct base/acc time */
2316       if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2317         if (wav-&gt;segment.rate &gt; 0.0 &amp;&amp;
2318             GST_CLOCK_TIME_IS_VALID (wav-&gt;segment.stop))
2319           wav-&gt;segment.position = wav-&gt;segment.stop;
2320         else if (wav-&gt;segment.rate &lt; 0.0)
2321           wav-&gt;segment.position = wav-&gt;segment.start;
2322       }
2323       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2324         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2325             (&quot;No valid input found before end of stream&quot;));
2326         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2327       } else {
<a name="20" id="anc20"></a><span class="line-modified">2328         /* add pad before we perform EOS */</span>
<span class="line-modified">2329         if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2330           wav-&gt;first = FALSE;</span>
<span class="line-modified">2331           gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2332         }</span>
2333 
<a name="21" id="anc21"></a><span class="line-modified">2334         /* perform EOS logic */</span>
<span class="line-modified">2335         if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {</span>
<span class="line-modified">2336           GstClockTime stop;</span>
2337 
<a name="22" id="anc22"></a><span class="line-modified">2338           if ((stop = wav-&gt;segment.stop) == -1)</span>
<span class="line-modified">2339             stop = wav-&gt;segment.duration;</span>
2340 
<a name="23" id="anc23"></a><span class="line-modified">2341           gst_element_post_message (GST_ELEMENT_CAST (wav),</span>
<span class="line-modified">2342               gst_message_new_segment_done (GST_OBJECT_CAST (wav),</span>
<span class="line-modified">2343                   wav-&gt;segment.format, stop));</span>
2344           gst_pad_push_event (wav-&gt;srcpad,
2345               gst_event_new_segment_done (wav-&gt;segment.format, stop));
<a name="24" id="anc24"></a><span class="line-modified">2346         } else {</span>
2347           gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
<a name="25" id="anc25"></a><span class="line-modified">2348         }</span>
2349       }
2350     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
2351       /* for fatal errors we post an error message, post the error
2352        * first so the app knows about the error first. */
2353       GST_ELEMENT_FLOW_ERROR (wav, ret);
<a name="26" id="anc26"></a><span class="line-modified">2354       gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());</span>
2355     }
2356     return;
2357   }
2358 }
2359 
2360 static GstFlowReturn
2361 gst_wavparse_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
2362 {
2363   GstFlowReturn ret;
2364   GstWavParse *wav = GST_WAVPARSE (parent);
2365 
2366   GST_LOG_OBJECT (wav, &quot;adapter_push %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
2367       gst_buffer_get_size (buf));
2368 
2369   gst_adapter_push (wav-&gt;adapter, buf);
2370 
2371   switch (wav-&gt;state) {
2372     case GST_WAVPARSE_START:
2373       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2374       if ((ret = gst_wavparse_parse_stream_init (wav)) != GST_FLOW_OK)
2375         goto done;
2376 
2377       if (wav-&gt;state != GST_WAVPARSE_HEADER)
2378         break;
2379 
2380       /* otherwise fall-through */
2381     case GST_WAVPARSE_HEADER:
2382       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_HEADER&quot;);
2383       if ((ret = gst_wavparse_stream_headers (wav)) != GST_FLOW_OK)
2384         goto done;
2385 
2386       if (!wav-&gt;got_fmt || wav-&gt;datastart == 0)
2387         break;
2388 
2389       wav-&gt;state = GST_WAVPARSE_DATA;
2390       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_DATA&quot;);
2391 
2392       /* fall-through */
2393     case GST_WAVPARSE_DATA:
2394       if (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))
2395         wav-&gt;discont = TRUE;
2396       if ((ret = gst_wavparse_stream_data (wav)) != GST_FLOW_OK)
2397         goto done;
2398       break;
2399     default:
2400       g_return_val_if_reached (GST_FLOW_ERROR);
2401   }
2402 done:
2403   if (G_UNLIKELY (wav-&gt;abort_buffering)) {
2404     wav-&gt;abort_buffering = FALSE;
2405     ret = GST_FLOW_ERROR;
2406     /* sort of demux/parse error */
2407     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL), (&quot;unhandled buffer size&quot;));
2408   }
2409 #ifdef GSTREAMER_LITE
2410   else if (G_UNLIKELY(ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_FLUSHING &amp;&amp; ret != GST_FLOW_EOS))
2411   {
2412       GST_ELEMENT_ERROR (wav, STREAM, FAILED,
2413           (_(&quot;Internal data flow error.&quot;)),
2414           (&quot;streaming task paused, reason %s (%d)&quot;,
2415               gst_flow_get_name (ret), ret));
2416   }
2417 #endif // GSTREAMER_LITE
2418 
2419   return ret;
2420 }
2421 
2422 static GstFlowReturn
2423 gst_wavparse_flush_data (GstWavParse * wav)
2424 {
2425   GstFlowReturn ret = GST_FLOW_OK;
2426   guint av;
2427 
2428   if ((av = gst_adapter_available (wav-&gt;adapter)) &gt; 0) {
2429     ret = gst_wavparse_stream_data (wav);
2430   }
2431 
2432   return ret;
2433 }
2434 
2435 static gboolean
2436 gst_wavparse_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
2437 {
2438   GstWavParse *wav = GST_WAVPARSE (parent);
2439   gboolean ret = TRUE;
2440 
2441   GST_LOG_OBJECT (wav, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
2442 
2443   switch (GST_EVENT_TYPE (event)) {
2444     case GST_EVENT_CAPS:
2445     {
2446       /* discard, we&#39;ll come up with proper src caps */
2447       gst_event_unref (event);
2448       break;
2449     }
2450     case GST_EVENT_SEGMENT:
2451     {
2452       gint64 start, stop, offset = 0, end_offset = -1;
2453       GstSegment segment;
2454 
2455       /* some debug output */
2456       gst_event_copy_segment (event, &amp;segment);
2457       GST_DEBUG_OBJECT (wav, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
2458           &amp;segment);
2459 
2460       if (wav-&gt;state != GST_WAVPARSE_DATA) {
2461         GST_DEBUG_OBJECT (wav, &quot;still starting, eating event&quot;);
2462         goto exit;
2463       }
2464 
2465       /* now we are either committed to TIME or BYTE format,
2466        * and we only expect a BYTE segment, e.g. following a seek */
2467       if (segment.format == GST_FORMAT_BYTES) {
2468         /* handle (un)signed issues */
2469         start = segment.start;
2470         stop = segment.stop;
2471         if (start &gt; 0) {
2472           offset = start;
2473           start -= wav-&gt;datastart;
2474           start = MAX (start, 0);
2475         }
2476         if (stop &gt; 0) {
2477           end_offset = stop;
2478           stop -= wav-&gt;datastart;
2479           stop = MAX (stop, 0);
2480         }
2481         if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2482           guint64 bps = wav-&gt;bps;
2483 
2484           /* operating in format TIME, so we can convert */
2485           if (!bps &amp;&amp; wav-&gt;fact)
2486             bps =
2487                 gst_util_uint64_scale_int (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
2488           if (bps) {
2489             if (start &gt;= 0)
2490               start =
2491                   gst_util_uint64_scale_ceil (start, GST_SECOND,
2492                   (guint64) wav-&gt;bps);
2493             if (stop &gt;= 0)
2494               stop =
2495                   gst_util_uint64_scale_ceil (stop, GST_SECOND,
2496                   (guint64) wav-&gt;bps);
2497           }
2498         }
2499       } else {
2500         GST_DEBUG_OBJECT (wav, &quot;unsupported segment format, ignoring&quot;);
2501         goto exit;
2502       }
2503 
2504       segment.start = start;
2505       segment.stop = stop;
2506 
2507       /* accept upstream&#39;s notion of segment and distribute along */
2508       segment.format = wav-&gt;segment.format;
2509       segment.time = segment.position = segment.start;
2510       segment.duration = wav-&gt;segment.duration;
2511       segment.base = gst_segment_to_running_time (&amp;wav-&gt;segment,
2512           GST_FORMAT_TIME, wav-&gt;segment.position);
2513 
2514       gst_segment_copy_into (&amp;segment, &amp;wav-&gt;segment);
2515 
2516       /* also store the newsegment event for the streaming thread */
2517       if (wav-&gt;start_segment)
2518         gst_event_unref (wav-&gt;start_segment);
2519       GST_DEBUG_OBJECT (wav, &quot;Storing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
2520       wav-&gt;start_segment = gst_event_new_segment (&amp;segment);
2521 
2522       /* stream leftover data in current segment */
2523       gst_wavparse_flush_data (wav);
2524       /* and set up streaming thread for next one */
2525       wav-&gt;offset = offset;
2526       wav-&gt;end_offset = end_offset;
2527 
2528       if (wav-&gt;datasize &gt; 0 &amp;&amp; (wav-&gt;end_offset == -1
2529               || wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize))
2530         wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
2531 
2532       if (wav-&gt;end_offset != -1) {
2533 #ifdef GSTREAMER_LITE
2534         wav-&gt;dataleft = MIN(wav-&gt;datasize, wav-&gt;end_offset - wav-&gt;offset);
2535 #else
2536         wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
2537 #endif // GSTREAMER_LITE
2538       } else {
2539         /* infinity; upstream will EOS when done */
2540         wav-&gt;dataleft = G_MAXUINT64;
2541       }
2542     exit:
2543       gst_event_unref (event);
2544       break;
2545     }
2546 #ifdef GSTREAMER_LITE
2547     case FX_EVENT_RANGE_READY: // This event appears only in pull mode during outrange seeking.
2548         ret = gst_pad_start_task (pad, (GstTaskFunction) gst_wavparse_loop, pad, NULL);
2549         gst_event_unref(event);
2550         break;
2551 #endif // GSTREAMER_LITE
2552     case GST_EVENT_EOS:
2553       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2554         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2555             (&quot;No valid input found before end of stream&quot;));
2556       } else {
<a name="27" id="anc27"></a><span class="line-modified">2557         /* add pad if needed so EOS is seen downstream */</span>
<span class="line-modified">2558         if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2559           wav-&gt;first = FALSE;</span>
<span class="line-modified">2560           gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2561         } else {</span>
<span class="line-modified">2562           /* stream leftover data in current segment */</span>
<span class="line-modified">2563           gst_wavparse_flush_data (wav);</span>
<span class="line-modified">2564         }</span>
2565       }
2566 
2567       /* fall-through */
2568     case GST_EVENT_FLUSH_STOP:
2569     {
2570       GstClockTime dur;
2571 
2572       if (wav-&gt;adapter)
<a name="28" id="anc28"></a><span class="line-modified">2573         gst_adapter_clear (wav-&gt;adapter);</span>
2574       wav-&gt;discont = TRUE;
2575       dur = wav-&gt;segment.duration;
2576       gst_segment_init (&amp;wav-&gt;segment, wav-&gt;segment.format);
2577       wav-&gt;segment.duration = dur;
2578       /* fall-through */
2579     }
2580     default:
2581       ret = gst_pad_event_default (wav-&gt;sinkpad, parent, event);
2582       break;
2583   }
2584 
2585   return ret;
2586 }
2587 
2588 #if 0
2589 /* convert and query stuff */
2590 static const GstFormat *
2591 gst_wavparse_get_formats (GstPad * pad)
2592 {
2593   static const GstFormat formats[] = {
2594     GST_FORMAT_TIME,
2595     GST_FORMAT_BYTES,
2596     GST_FORMAT_DEFAULT,         /* a &quot;frame&quot;, ie a set of samples per Hz */
2597     0
2598   };
2599 
2600   return formats;
2601 }
2602 #endif
2603 
2604 static gboolean
2605 gst_wavparse_pad_convert (GstPad * pad,
2606     GstFormat src_format, gint64 src_value,
2607     GstFormat * dest_format, gint64 * dest_value)
2608 {
2609   GstWavParse *wavparse;
2610   gboolean res = TRUE;
2611 
2612   wavparse = GST_WAVPARSE (GST_PAD_PARENT (pad));
2613 
2614   if (*dest_format == src_format) {
2615     *dest_value = src_value;
2616     return TRUE;
2617   }
2618 
2619   if ((wavparse-&gt;bps == 0) &amp;&amp; !wavparse-&gt;fact)
2620     goto no_bps_fact;
2621 
2622   GST_INFO_OBJECT (wavparse, &quot;converting value from %s to %s&quot;,
2623       gst_format_get_name (src_format), gst_format_get_name (*dest_format));
2624 
2625   switch (src_format) {
2626     case GST_FORMAT_BYTES:
2627       switch (*dest_format) {
2628         case GST_FORMAT_DEFAULT:
2629           *dest_value = src_value / wavparse-&gt;bytes_per_sample;
2630           /* make sure we end up on a sample boundary */
2631           *dest_value -= *dest_value % wavparse-&gt;bytes_per_sample;
2632           break;
2633         case GST_FORMAT_TIME:
2634           /* src_value + datastart = offset */
2635           GST_INFO_OBJECT (wavparse,
2636               &quot;src=%&quot; G_GINT64_FORMAT &quot;, offset=%&quot; G_GINT64_FORMAT, src_value,
2637               wavparse-&gt;offset);
2638           if (wavparse-&gt;bps &gt; 0)
2639             *dest_value = gst_util_uint64_scale_ceil (src_value, GST_SECOND,
2640                 (guint64) wavparse-&gt;bps);
2641           else if (wavparse-&gt;fact) {
2642             guint64 bps = gst_util_uint64_scale_int_ceil (wavparse-&gt;datasize,
2643                 wavparse-&gt;rate, wavparse-&gt;fact);
2644 
2645             *dest_value =
2646                 gst_util_uint64_scale_int_ceil (src_value, GST_SECOND, bps);
2647           } else {
2648             res = FALSE;
2649           }
2650           break;
2651         default:
2652           res = FALSE;
2653           goto done;
2654       }
2655       break;
2656 
2657     case GST_FORMAT_DEFAULT:
2658       switch (*dest_format) {
2659         case GST_FORMAT_BYTES:
2660           *dest_value = src_value * wavparse-&gt;bytes_per_sample;
2661           break;
2662         case GST_FORMAT_TIME:
2663           *dest_value = gst_util_uint64_scale (src_value, GST_SECOND,
2664               (guint64) wavparse-&gt;rate);
2665           break;
2666         default:
2667           res = FALSE;
2668           goto done;
2669       }
2670       break;
2671 
2672     case GST_FORMAT_TIME:
2673       switch (*dest_format) {
2674         case GST_FORMAT_BYTES:
2675           if (wavparse-&gt;bps &gt; 0)
2676             *dest_value = gst_util_uint64_scale (src_value,
2677                 (guint64) wavparse-&gt;bps, GST_SECOND);
2678           else {
2679             guint64 bps = gst_util_uint64_scale_int (wavparse-&gt;datasize,
2680                 wavparse-&gt;rate, wavparse-&gt;fact);
2681 
2682             *dest_value = gst_util_uint64_scale (src_value, bps, GST_SECOND);
2683           }
2684           /* make sure we end up on a sample boundary */
2685           *dest_value -= *dest_value % wavparse-&gt;blockalign;
2686           break;
2687         case GST_FORMAT_DEFAULT:
2688           *dest_value = gst_util_uint64_scale (src_value,
2689               (guint64) wavparse-&gt;rate, GST_SECOND);
2690           break;
2691         default:
2692           res = FALSE;
2693           goto done;
2694       }
2695       break;
2696 
2697     default:
2698       res = FALSE;
2699       goto done;
2700   }
2701 
2702 done:
2703   return res;
2704 
2705   /* ERRORS */
2706 no_bps_fact:
2707   {
2708     GST_DEBUG_OBJECT (wavparse, &quot;bps 0 or no fact chunk, cannot convert&quot;);
2709     res = FALSE;
2710     goto done;
2711   }
2712 }
2713 
2714 /* handle queries for location and length in requested format */
2715 static gboolean
2716 gst_wavparse_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
2717 {
2718   gboolean res = TRUE;
2719   GstWavParse *wav = GST_WAVPARSE (parent);
2720 
2721   /* only if we know */
2722   if (wav-&gt;state != GST_WAVPARSE_DATA) {
2723     return FALSE;
2724   }
2725 
2726   GST_LOG_OBJECT (pad, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
2727 
2728   switch (GST_QUERY_TYPE (query)) {
2729     case GST_QUERY_POSITION:
2730     {
2731       gint64 curb;
2732       gint64 cur;
2733       GstFormat format;
2734 
2735       /* this is not very precise, as we have pushed severla buffer upstream for prerolling */
2736       curb = wav-&gt;offset - wav-&gt;datastart;
2737       gst_query_parse_position (query, &amp;format, NULL);
2738       GST_INFO_OBJECT (wav, &quot;pos query at %&quot; G_GINT64_FORMAT, curb);
2739 
2740       switch (format) {
2741         case GST_FORMAT_BYTES:
2742           format = GST_FORMAT_BYTES;
2743           cur = curb;
2744           break;
2745         default:
2746           res = gst_wavparse_pad_convert (pad, GST_FORMAT_BYTES, curb,
2747               &amp;format, &amp;cur);
2748           break;
2749       }
2750       if (res)
2751         gst_query_set_position (query, format, cur);
2752       break;
2753     }
2754     case GST_QUERY_DURATION:
2755     {
2756       gint64 duration = 0;
2757       GstFormat format;
2758 
2759       if (wav-&gt;ignore_length) {
2760         res = FALSE;
2761         break;
2762       }
2763 
2764       gst_query_parse_duration (query, &amp;format, NULL);
2765 
2766       switch (format) {
2767         case GST_FORMAT_BYTES:{
2768           format = GST_FORMAT_BYTES;
2769           duration = wav-&gt;datasize;
2770           break;
2771         }
2772         case GST_FORMAT_TIME:
2773           if ((res = gst_wavparse_calculate_duration (wav))) {
2774             duration = wav-&gt;duration;
2775           }
2776           break;
2777         default:
2778           res = FALSE;
2779           break;
2780       }
2781       if (res)
2782         gst_query_set_duration (query, format, duration);
2783       break;
2784     }
2785     case GST_QUERY_CONVERT:
2786     {
2787       gint64 srcvalue, dstvalue;
2788       GstFormat srcformat, dstformat;
2789 
2790       gst_query_parse_convert (query, &amp;srcformat, &amp;srcvalue,
2791           &amp;dstformat, &amp;dstvalue);
2792       res = gst_wavparse_pad_convert (pad, srcformat, srcvalue,
2793           &amp;dstformat, &amp;dstvalue);
2794       if (res)
2795         gst_query_set_convert (query, srcformat, srcvalue, dstformat, dstvalue);
2796       break;
2797     }
2798     case GST_QUERY_SEEKING:{
2799       GstFormat fmt;
2800       gboolean seekable = FALSE;
2801 
2802       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
2803       if (fmt == wav-&gt;segment.format) {
2804         if (wav-&gt;streaming) {
2805           GstQuery *q;
2806 
2807           q = gst_query_new_seeking (GST_FORMAT_BYTES);
2808           if ((res = gst_pad_peer_query (wav-&gt;sinkpad, q))) {
2809             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);
2810             GST_LOG_OBJECT (wav, &quot;upstream BYTE seekable %d&quot;, seekable);
2811           }
2812           gst_query_unref (q);
2813         } else {
2814           GST_LOG_OBJECT (wav, &quot;looping =&gt; seekable&quot;);
2815           seekable = TRUE;
2816           res = TRUE;
2817         }
2818       } else if (fmt == GST_FORMAT_TIME) {
2819         res = TRUE;
2820       }
2821       if (res) {
2822         gst_query_set_seeking (query, fmt, seekable, 0, wav-&gt;segment.duration);
2823       }
2824       break;
2825     }
<a name="29" id="anc29"></a><span class="line-added">2826     case GST_QUERY_SEGMENT:</span>
<span class="line-added">2827     {</span>
<span class="line-added">2828       GstFormat format;</span>
<span class="line-added">2829       gint64 start, stop;</span>
<span class="line-added">2830 </span>
<span class="line-added">2831       format = wav-&gt;segment.format;</span>
<span class="line-added">2832 </span>
<span class="line-added">2833       start =</span>
<span class="line-added">2834           gst_segment_to_stream_time (&amp;wav-&gt;segment, format,</span>
<span class="line-added">2835           wav-&gt;segment.start);</span>
<span class="line-added">2836       if ((stop = wav-&gt;segment.stop) == -1)</span>
<span class="line-added">2837         stop = wav-&gt;segment.duration;</span>
<span class="line-added">2838       else</span>
<span class="line-added">2839         stop = gst_segment_to_stream_time (&amp;wav-&gt;segment, format, stop);</span>
<span class="line-added">2840 </span>
<span class="line-added">2841       gst_query_set_segment (query, wav-&gt;segment.rate, format, start, stop);</span>
<span class="line-added">2842       res = TRUE;</span>
<span class="line-added">2843       break;</span>
<span class="line-added">2844     }</span>
2845     default:
2846       res = gst_pad_query_default (pad, parent, query);
2847       break;
2848   }
2849   return res;
2850 }
2851 
2852 #ifdef GSTREAMER_LITE
2853 static gboolean
2854 gst_wavparse_sink_query (GstPad* pad, GstObject *parent, GstQuery* query)
2855 {
2856     gboolean result = TRUE;
2857     switch (GST_QUERY_TYPE(query))
2858     {
2859         case GST_QUERY_CUSTOM:
2860         {
2861             const GstStructure *s = gst_query_get_structure(query);
2862             if (gst_structure_has_name(s, GETRANGE_QUERY_NAME))
2863                 gst_structure_set(s, GETRANGE_QUERY_SUPPORTS_FIELDNANE,
2864                                      GETRANGE_QUERY_SUPPORTS_FIELDTYPE,
2865                                      TRUE,
2866                                      NULL);
2867             break;
2868         }
2869         default:
2870             result = gst_pad_query_default(pad, parent, query);
2871             break;
2872     }
2873     return result;
2874 }
2875 #endif // GSTREAMER_LITE
2876 
2877 static gboolean
2878 gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
2879 {
2880   GstWavParse *wavparse = GST_WAVPARSE (parent);
2881   gboolean res = FALSE;
2882 
2883   GST_DEBUG_OBJECT (wavparse, &quot;%s event&quot;, GST_EVENT_TYPE_NAME (event));
2884 
2885   switch (GST_EVENT_TYPE (event)) {
2886     case GST_EVENT_SEEK:
2887       /* can only handle events when we are in the data state */
2888       if (wavparse-&gt;state == GST_WAVPARSE_DATA) {
2889         res = gst_wavparse_perform_seek (wavparse, event);
2890       }
2891       gst_event_unref (event);
2892       break;
2893 
2894     case GST_EVENT_TOC_SELECT:
2895     {
2896       char *uid = NULL;
2897       GstTocEntry *entry = NULL;
2898       GstEvent *seek_event;
2899       gint64 start_pos;
2900 
2901       if (!wavparse-&gt;toc) {
2902         GST_DEBUG_OBJECT (wavparse, &quot;no TOC to select&quot;);
2903         return FALSE;
2904       } else {
2905         gst_event_parse_toc_select (event, &amp;uid);
2906         if (uid != NULL) {
2907           GST_OBJECT_LOCK (wavparse);
2908           entry = gst_toc_find_entry (wavparse-&gt;toc, uid);
2909           if (entry == NULL) {
2910             GST_OBJECT_UNLOCK (wavparse);
2911             GST_WARNING_OBJECT (wavparse, &quot;no TOC entry with given UID: %s&quot;,
2912                 uid);
2913             res = FALSE;
2914           } else {
2915             gst_toc_entry_get_start_stop_times (entry, &amp;start_pos, NULL);
2916             GST_OBJECT_UNLOCK (wavparse);
2917             seek_event = gst_event_new_seek (1.0,
2918                 GST_FORMAT_TIME,
2919                 GST_SEEK_FLAG_FLUSH,
2920                 GST_SEEK_TYPE_SET, start_pos, GST_SEEK_TYPE_SET, -1);
2921             res = gst_wavparse_perform_seek (wavparse, seek_event);
2922             gst_event_unref (seek_event);
2923           }
2924           g_free (uid);
2925         } else {
2926           GST_WARNING_OBJECT (wavparse, &quot;received empty TOC select event&quot;);
2927           res = FALSE;
2928         }
2929       }
2930       gst_event_unref (event);
2931       break;
2932     }
2933 
2934     default:
2935       res = gst_pad_push_event (wavparse-&gt;sinkpad, event);
2936       break;
2937   }
2938   return res;
2939 }
2940 
2941 static gboolean
2942 gst_wavparse_sink_activate (GstPad * sinkpad, GstObject * parent)
2943 {
2944   GstWavParse *wav = GST_WAVPARSE (parent);
2945   GstQuery *query;
2946   gboolean pull_mode;
2947 
2948   if (wav-&gt;adapter) {
2949     gst_adapter_clear (wav-&gt;adapter);
2950     g_object_unref (wav-&gt;adapter);
2951     wav-&gt;adapter = NULL;
2952   }
2953 
2954   query = gst_query_new_scheduling ();
2955 
2956   if (!gst_pad_peer_query (sinkpad, query)) {
2957     gst_query_unref (query);
2958     goto activate_push;
2959   }
2960 
2961   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
2962       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
2963   gst_query_unref (query);
2964 
2965   if (!pull_mode)
2966     goto activate_push;
2967 
2968   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
<a name="30" id="anc30"></a><span class="line-modified">2969   wav-&gt;streaming = FALSE;</span>
2970   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
2971 
2972 activate_push:
2973   {
2974     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
2975     wav-&gt;streaming = TRUE;
2976     wav-&gt;adapter = gst_adapter_new ();
2977     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
2978   }
2979 }
2980 
2981 
2982 static gboolean
2983 gst_wavparse_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
2984     GstPadMode mode, gboolean active)
2985 {
2986   gboolean res;
2987 
2988   switch (mode) {
2989     case GST_PAD_MODE_PUSH:
2990       res = TRUE;
2991       break;
2992     case GST_PAD_MODE_PULL:
<a name="31" id="anc31"></a><span class="line-modified">2993       if (active) {</span>
<span class="line-modified">2994         /* if we have a scheduler we can start the task */</span>
2995         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_wavparse_loop,
2996             sinkpad, NULL);
<a name="32" id="anc32"></a><span class="line-modified">2997       } else {</span>
2998         res = gst_pad_stop_task (sinkpad);
<a name="33" id="anc33"></a><span class="line-modified">2999       }</span>
3000       break;
3001     default:
3002       res = FALSE;
3003       break;
3004   }
3005   return res;
3006 }
3007 
3008 static GstStateChangeReturn
3009 gst_wavparse_change_state (GstElement * element, GstStateChange transition)
3010 {
3011   GstStateChangeReturn ret;
3012   GstWavParse *wav = GST_WAVPARSE (element);
3013 
3014   switch (transition) {
3015     case GST_STATE_CHANGE_NULL_TO_READY:
3016       break;
3017     case GST_STATE_CHANGE_READY_TO_PAUSED:
3018       gst_wavparse_reset (wav);
3019       break;
3020     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
3021       break;
3022     default:
3023       break;
3024   }
3025 
3026   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
3027 
3028   switch (transition) {
3029     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
3030       break;
3031     case GST_STATE_CHANGE_PAUSED_TO_READY:
3032 #ifndef GSTREAMER_LITE
3033       gst_wavparse_destroy_sourcepad (wav);
3034 #endif // GSTREAMER_LITE
3035       gst_wavparse_reset (wav);
3036       break;
3037     case GST_STATE_CHANGE_READY_TO_NULL:
3038       break;
3039     default:
3040       break;
3041   }
3042   return ret;
3043 }
3044 
3045 static void
3046 gst_wavparse_set_property (GObject * object, guint prop_id,
3047     const GValue * value, GParamSpec * pspec)
3048 {
3049   GstWavParse *self;
3050 
3051   g_return_if_fail (GST_IS_WAVPARSE (object));
3052   self = GST_WAVPARSE (object);
3053 
3054   switch (prop_id) {
3055     case PROP_IGNORE_LENGTH:
3056       self-&gt;ignore_length = g_value_get_boolean (value);
3057       break;
3058     default:
3059       G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
3060   }
3061 
3062 }
3063 
3064 static void
3065 gst_wavparse_get_property (GObject * object, guint prop_id,
3066     GValue * value, GParamSpec * pspec)
3067 {
3068   GstWavParse *self;
3069 
3070   g_return_if_fail (GST_IS_WAVPARSE (object));
3071   self = GST_WAVPARSE (object);
3072 
3073   switch (prop_id) {
3074     case PROP_IGNORE_LENGTH:
3075       g_value_set_boolean (value, self-&gt;ignore_length);
3076       break;
3077     default:
3078       G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
3079   }
3080 }
3081 
3082 #ifdef GSTREAMER_LITE
3083 gboolean
3084 plugin_init_wavparse (GstPlugin * plugin)
3085 #else // GSTREAMER_LITE
3086 static gboolean
3087 plugin_init (GstPlugin * plugin)
3088 #endif // GSTREAMER_LITE
3089 {
3090   gst_riff_init ();
3091 
3092   return gst_element_register (plugin, &quot;wavparse&quot;, GST_RANK_PRIMARY,
3093       GST_TYPE_WAVPARSE);
3094 }
3095 
3096 #ifndef GSTREAMER_LITE
3097 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
3098     GST_VERSION_MINOR,
3099     wavparse,
3100     &quot;Parse a .wav file into raw audio&quot;,
3101     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
3102 #endif // GSTREAMER_LITE
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>