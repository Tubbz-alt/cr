<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbase64.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* gbase64.c - Base64 encoding/decoding
  2  *
  3  *  Copyright (C) 2006 Alexander Larsson &lt;alexl@redhat.com&gt;
  4  *  Copyright (C) 2000-2003 Ximian Inc.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Lesser General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2.1 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Lesser General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Lesser General Public License
 17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 18  *
 19  * This is based on code in camel, written by:
 20  *    Michael Zucchi &lt;notzed@ximian.com&gt;
 21  *    Jeffrey Stedfast &lt;fejj@ximian.com&gt;
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 
 26 #include &lt;string.h&gt;
 27 
 28 #include &quot;gbase64.h&quot;
 29 #include &quot;gtestutils.h&quot;
 30 #include &quot;glibintl.h&quot;
 31 
 32 
 33 /**
 34  * SECTION:base64
 35  * @title: Base64 Encoding
 36  * @short_description: encodes and decodes data in Base64 format
 37  *
 38  * Base64 is an encoding that allows a sequence of arbitrary bytes to be
 39  * encoded as a sequence of printable ASCII characters. For the definition
 40  * of Base64, see
 41  * [RFC 1421](http://www.ietf.org/rfc/rfc1421.txt)
 42  * or
 43  * [RFC 2045](http://www.ietf.org/rfc/rfc2045.txt).
 44  * Base64 is most commonly used as a MIME transfer encoding
 45  * for email.
 46  *
 47  * GLib supports incremental encoding using g_base64_encode_step() and
 48  * g_base64_encode_close(). Incremental decoding can be done with
 49  * g_base64_decode_step(). To encode or decode data in one go, use
 50  * g_base64_encode() or g_base64_decode(). To avoid memory allocation when
 51  * decoding, you can use g_base64_decode_inplace().
 52  *
 53  * Support for Base64 encoding has been added in GLib 2.12.
 54  */
 55 
 56 static const char base64_alphabet[] =
 57         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
 58 
 59 /**
 60  * g_base64_encode_step:
 61  * @in: (array length=len) (element-type guint8): the binary data to encode
 62  * @len: the length of @in
 63  * @break_lines: whether to break long lines
 64  * @out: (out) (array) (element-type guint8): pointer to destination buffer
 65  * @state: (inout): Saved state between steps, initialize to 0
 66  * @save: (inout): Saved state between steps, initialize to 0
 67  *
 68  * Incrementally encode a sequence of binary data into its Base-64 stringified
 69  * representation. By calling this function multiple times you can convert
 70  * data in chunks to avoid having to have the full encoded data in memory.
 71  *
 72  * When all of the data has been converted you must call
 73  * g_base64_encode_close() to flush the saved state.
 74  *
 75  * The output buffer must be large enough to fit all the data that will
 76  * be written to it. Due to the way base64 encodes you will need
 77  * at least: (@len / 3 + 1) * 4 + 4 bytes (+ 4 may be needed in case of
 78  * non-zero state). If you enable line-breaking you will need at least:
 79  * ((@len / 3 + 1) * 4 + 4) / 72 + 1 bytes of extra space.
 80  *
 81  * @break_lines is typically used when putting base64-encoded data in emails.
 82  * It breaks the lines at 72 columns instead of putting all of the text on
 83  * the same line. This avoids problems with long lines in the email system.
 84  * Note however that it breaks the lines with `LF` characters, not
 85  * `CR LF` sequences, so the result cannot be passed directly to SMTP
 86  * or certain other protocols.
 87  *
 88  * Returns: The number of bytes of output that was written
 89  *
 90  * Since: 2.12
 91  */
 92 gsize
 93 g_base64_encode_step (const guchar *in,
 94                       gsize         len,
 95                       gboolean      break_lines,
 96                       gchar        *out,
 97                       gint         *state,
 98                       gint         *save)
 99 {
100   char *outptr;
101   const guchar *inptr;
102 
103   g_return_val_if_fail (in != NULL, 0);
104   g_return_val_if_fail (out != NULL, 0);
105   g_return_val_if_fail (state != NULL, 0);
106   g_return_val_if_fail (save != NULL, 0);
107 
108   if (len &lt;= 0)
109     return 0;
110 
111   inptr = in;
112   outptr = out;
113 
114   if (len + ((char *) save) [0] &gt; 2)
115     {
116       const guchar *inend = in+len-2;
117       int c1, c2, c3;
118       int already;
119 
120       already = *state;
121 
122       switch (((char *) save) [0])
123         {
124         case 1:
125           c1 = ((unsigned char *) save) [1];
126           goto skip1;
127         case 2:
128           c1 = ((unsigned char *) save) [1];
129           c2 = ((unsigned char *) save) [2];
130           goto skip2;
131         }
132 
133       /*
134        * yes, we jump into the loop, no i&#39;m not going to change it,
135        * it&#39;s beautiful!
136        */
137       while (inptr &lt; inend)
138         {
139           c1 = *inptr++;
140         skip1:
141           c2 = *inptr++;
142         skip2:
143           c3 = *inptr++;
144           *outptr++ = base64_alphabet [ c1 &gt;&gt; 2 ];
145           *outptr++ = base64_alphabet [ c2 &gt;&gt; 4 |
146                                         ((c1&amp;0x3) &lt;&lt; 4) ];
147           *outptr++ = base64_alphabet [ ((c2 &amp;0x0f) &lt;&lt; 2) |
148                                         (c3 &gt;&gt; 6) ];
149           *outptr++ = base64_alphabet [ c3 &amp; 0x3f ];
150           /* this is a bit ugly ... */
151           if (break_lines &amp;&amp; (++already) &gt;= 19)
152             {
153               *outptr++ = &#39;\n&#39;;
154               already = 0;
155             }
156         }
157 
158       ((char *)save)[0] = 0;
159       len = 2 - (inptr - inend);
160       *state = already;
161     }
162 
163   if (len&gt;0)
164     {
165       char *saveout;
166 
167       /* points to the slot for the next char to save */
168       saveout = &amp; (((char *)save)[1]) + ((char *)save)[0];
169 
170       /* len can only be 0 1 or 2 */
171       switch(len)
172         {
173         case 2: *saveout++ = *inptr++;
174         case 1: *saveout++ = *inptr++;
175         }
176       ((char *)save)[0] += len;
177     }
178 
179   return outptr - out;
180 }
181 
182 /**
183  * g_base64_encode_close:
184  * @break_lines: whether to break long lines
185  * @out: (out) (array) (element-type guint8): pointer to destination buffer
186  * @state: (inout): Saved state from g_base64_encode_step()
187  * @save: (inout): Saved state from g_base64_encode_step()
188  *
189  * Flush the status from a sequence of calls to g_base64_encode_step().
190  *
191  * The output buffer must be large enough to fit all the data that will
192  * be written to it. It will need up to 4 bytes, or up to 5 bytes if
193  * line-breaking is enabled.
194  *
195  * The @out array will not be automatically nul-terminated.
196  *
197  * Returns: The number of bytes of output that was written
198  *
199  * Since: 2.12
200  */
201 gsize
202 g_base64_encode_close (gboolean  break_lines,
203                        gchar    *out,
204                        gint     *state,
205                        gint     *save)
206 {
207   int c1, c2;
208   char *outptr = out;
209 
210   g_return_val_if_fail (out != NULL, 0);
211   g_return_val_if_fail (state != NULL, 0);
212   g_return_val_if_fail (save != NULL, 0);
213 
214   c1 = ((unsigned char *) save) [1];
215   c2 = ((unsigned char *) save) [2];
216 
217   switch (((char *) save) [0])
218     {
219     case 2:
220       outptr [2] = base64_alphabet[ ( (c2 &amp;0x0f) &lt;&lt; 2 ) ];
221       g_assert (outptr [2] != 0);
222       goto skip;
223     case 1:
224       outptr[2] = &#39;=&#39;;
225       c2 = 0;  /* saved state here is not relevant */
226     skip:
227       outptr [0] = base64_alphabet [ c1 &gt;&gt; 2 ];
228       outptr [1] = base64_alphabet [ c2 &gt;&gt; 4 | ( (c1&amp;0x3) &lt;&lt; 4 )];
229       outptr [3] = &#39;=&#39;;
230       outptr += 4;
231       break;
232     }
233   if (break_lines)
234     *outptr++ = &#39;\n&#39;;
235 
236   *save = 0;
237   *state = 0;
238 
239   return outptr - out;
240 }
241 
242 /**
243  * g_base64_encode:
244  * @data: (array length=len) (element-type guint8): the binary data to encode
245  * @len: the length of @data
246  *
247  * Encode a sequence of binary data into its Base-64 stringified
248  * representation.
249  *
250  * Returns: (transfer full): a newly allocated, zero-terminated Base-64
251  *               encoded string representing @data. The returned string must
252  *               be freed with g_free().
253  *
254  * Since: 2.12
255  */
256 gchar *
257 g_base64_encode (const guchar *data,
258                  gsize         len)
259 {
260   gchar *out;
261   gint state = 0, outlen;
262   gint save = 0;
263 
264   g_return_val_if_fail (data != NULL || len == 0, NULL);
265 
266   /* We can use a smaller limit here, since we know the saved state is 0,
267      +1 is needed for trailing \0, also check for unlikely integer overflow */
268 #ifndef GSTREAMER_LITE
269   if (len &gt;= ((G_MAXSIZE - 1) / 4 - 1) * 3)
270     g_error(&quot;%s: input too large for Base64 encoding (%&quot;G_GSIZE_FORMAT&quot; chars)&quot;,
271         G_STRLOC, len);
272 #else // GSTREAMER_LITE
273   if (len &gt;= ((G_MAXSIZE - 1) / 4 - 1) * 3)
274   {
275     g_error(&quot;%s: input too large for Base64 encoding (%&quot;G_GSIZE_FORMAT&quot; chars)&quot;, G_STRLOC, len);
276     return NULL;
277   }
278 #endif // GSTREAMER_LITE
279 
280   out = g_malloc ((len / 3 + 1) * 4 + 1);
281 #ifdef GSTREAMER_LITE
282   if (out == NULL)
283       return NULL;
284 #endif // GSTREAMER_LITE
285 
286   outlen = g_base64_encode_step (data, len, FALSE, out, &amp;state, &amp;save);
287   outlen += g_base64_encode_close (FALSE, out + outlen, &amp;state, &amp;save);
288   out[outlen] = &#39;\0&#39;;
289 
290   return (gchar *) out;
291 }
292 
293 static const unsigned char mime_base64_rank[256] = {
294   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
295   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
296   255,255,255,255,255,255,255,255,255,255,255, 62,255,255,255, 63,
297    52, 53, 54, 55, 56, 57, 58, 59, 60, 61,255,255,255,  0,255,255,
298   255,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
299    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,255,255,255,255,255,
300   255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
301    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,255,255,255,255,255,
302   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
303   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
304   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
305   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
306   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
307   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
308   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
309   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
310 };
311 
312 /**
313  * g_base64_decode_step: (skip)
314  * @in: (array length=len) (element-type guint8): binary input data
315  * @len: max length of @in data to decode
316  * @out: (out caller-allocates) (array) (element-type guint8): output buffer
317  * @state: (inout): Saved state between steps, initialize to 0
318  * @save: (inout): Saved state between steps, initialize to 0
319  *
320  * Incrementally decode a sequence of binary data from its Base-64 stringified
321  * representation. By calling this function multiple times you can convert
322  * data in chunks to avoid having to have the full encoded data in memory.
323  *
324  * The output buffer must be large enough to fit all the data that will
325  * be written to it. Since base64 encodes 3 bytes in 4 chars you need
326  * at least: (@len / 4) * 3 + 3 bytes (+ 3 may be needed in case of non-zero
327  * state).
328  *
329  * Returns: The number of bytes of output that was written
330  *
331  * Since: 2.12
332  **/
333 gsize
334 g_base64_decode_step (const gchar  *in,
335                       gsize         len,
336                       guchar       *out,
337                       gint         *state,
338                       guint        *save)
339 {
340   const guchar *inptr;
341   guchar *outptr;
342   const guchar *inend;
343   guchar c, rank;
344   guchar last[2];
345   unsigned int v;
346   int i;
347 
348   g_return_val_if_fail (in != NULL, 0);
349   g_return_val_if_fail (out != NULL, 0);
350   g_return_val_if_fail (state != NULL, 0);
351   g_return_val_if_fail (save != NULL, 0);
352 
353   if (len &lt;= 0)
354     return 0;
355 
356   inend = (const guchar *)in+len;
357   outptr = out;
358 
359   /* convert 4 base64 bytes to 3 normal bytes */
360   v=*save;
361   i=*state;
362 
363   last[0] = last[1] = 0;
364 
365   /* we use the sign in the state to determine if we got a padding character
366      in the previous sequence */
367   if (i &lt; 0)
368     {
369       i = -i;
370       last[0] = &#39;=&#39;;
371     }
372 
373   inptr = (const guchar *)in;
374   while (inptr &lt; inend)
375     {
376       c = *inptr++;
377       rank = mime_base64_rank [c];
378       if (rank != 0xff)
379         {
380           last[1] = last[0];
381           last[0] = c;
382           v = (v&lt;&lt;6) | rank;
383           i++;
384           if (i==4)
385             {
386               *outptr++ = v&gt;&gt;16;
387               if (last[1] != &#39;=&#39;)
388                 *outptr++ = v&gt;&gt;8;
389               if (last[0] != &#39;=&#39;)
390                 *outptr++ = v;
391               i=0;
392             }
393         }
394     }
395 
396   *save = v;
397   *state = last[0] == &#39;=&#39; ? -i : i;
398 
399   return outptr - out;
400 }
401 
402 /**
403  * g_base64_decode:
404  * @text: zero-terminated string with base64 text to decode
405  * @out_len: (out): The length of the decoded data is written here
406  *
407  * Decode a sequence of Base-64 encoded text into binary data.  Note
408  * that the returned binary data is not necessarily zero-terminated,
409  * so it should not be used as a character string.
410  *
411  * Returns: (transfer full) (array length=out_len) (element-type guint8):
412  *               newly allocated buffer containing the binary data
413  *               that @text represents. The returned buffer must
414  *               be freed with g_free().
415  *
416  * Since: 2.12
417  */
418 guchar *
419 g_base64_decode (const gchar *text,
420                  gsize       *out_len)
421 {
422   guchar *ret;
423   gsize input_length;
424   gint state = 0;
425   guint save = 0;
426 
427   g_return_val_if_fail (text != NULL, NULL);
428   g_return_val_if_fail (out_len != NULL, NULL);
429 
430   input_length = strlen (text);
431 
432   /* We can use a smaller limit here, since we know the saved state is 0,
433      +1 used to avoid calling g_malloc0(0), and hence returning NULL */
434   ret = g_malloc0 ((input_length / 4) * 3 + 1);
435 
436   *out_len = g_base64_decode_step (text, input_length, ret, &amp;state, &amp;save);
437 
438   return ret;
439 }
440 
441 /**
442  * g_base64_decode_inplace:
443  * @text: (inout) (array length=out_len) (element-type guint8): zero-terminated
444  *        string with base64 text to decode
445  * @out_len: (inout): The length of the decoded data is written here
446  *
447  * Decode a sequence of Base-64 encoded text into binary data
448  * by overwriting the input data.
449  *
450  * Returns: (transfer none): The binary data that @text responds. This pointer
451  *               is the same as the input @text.
452  *
453  * Since: 2.20
454  */
455 guchar *
456 g_base64_decode_inplace (gchar *text,
457                          gsize *out_len)
458 {
459   gint input_length, state = 0;
460   guint save = 0;
461 
462   g_return_val_if_fail (text != NULL, NULL);
463   g_return_val_if_fail (out_len != NULL, NULL);
464 
465   input_length = strlen (text);
466 
467   g_return_val_if_fail (input_length &gt; 1, NULL);
468 
469   *out_len = g_base64_decode_step (text, input_length, (guchar *) text, &amp;state, &amp;save);
470 
471   return (guchar *) text;
472 }
    </pre>
  </body>
</html>