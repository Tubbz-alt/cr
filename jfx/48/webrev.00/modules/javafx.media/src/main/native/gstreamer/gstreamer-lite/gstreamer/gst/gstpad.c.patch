diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c
@@ -116,16 +116,13 @@
   PAD_PROP_0,
   PAD_PROP_CAPS,
   PAD_PROP_DIRECTION,
   PAD_PROP_TEMPLATE,
   PAD_PROP_OFFSET
-  /* FILL ME */
+      /* FILL ME */
 };
 
-#define GST_PAD_GET_PRIVATE(obj)  \
-   (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_PAD, GstPadPrivate))
-
 #define _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH (GST_PAD_PROBE_TYPE_ALL_BOTH | GST_PAD_PROBE_TYPE_EVENT_FLUSH)
 
 /* we have a pending and an active event on the pad. On source pads only the
  * active event is used. On sinkpads, events are copied to the pending entry and
  * moved to the active event when the eventfunc returned %TRUE. */
@@ -170,11 +167,11 @@
   gboolean dropped;
   gboolean pass;
   gboolean handled;
   gboolean marshalled;
 
-  GHook **called_probes;
+  gulong *called_probes;
   guint n_called_probes;
   guint called_probes_size;
   gboolean retry;
 } ProbeMarshall;
 
@@ -309,32 +306,31 @@
   \
   buffer_quark = g_quark_from_static_string ("buffer"); \
   buffer_list_quark = g_quark_from_static_string ("bufferlist"); \
   event_quark = g_quark_from_static_string ("event"); \
   \
-  for (i = 0; i < G_N_ELEMENTS (flow_quarks); i++) {            \
+  for (i = 0; i < G_N_ELEMENTS (flow_quarks); i++) {      \
     flow_quarks[i].quark = g_quark_from_static_string (flow_quarks[i].name); \
   } \
   \
   GST_DEBUG_CATEGORY_INIT (debug_dataflow, "GST_DATAFLOW", \
       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, "dataflow inside pads"); \
 }
 
 #define gst_pad_parent_class parent_class
-G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT, _do_init);
+G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT,
+    G_ADD_PRIVATE (GstPad) _do_init);
 
 static void
 gst_pad_class_init (GstPadClass * klass)
 {
   GObjectClass *gobject_class;
   GstObjectClass *gstobject_class;
 
   gobject_class = G_OBJECT_CLASS (klass);
   gstobject_class = GST_OBJECT_CLASS (klass);
 
-  g_type_class_add_private (klass, sizeof (GstPadPrivate));
-
   gobject_class->dispose = gst_pad_dispose;
   gobject_class->finalize = gst_pad_finalize;
   gobject_class->set_property = gst_pad_set_property;
   gobject_class->get_property = gst_pad_get_property;
 
@@ -400,11 +396,11 @@
 }
 
 static void
 gst_pad_init (GstPad * pad)
 {
-  pad->priv = GST_PAD_GET_PRIVATE (pad);
+  pad->priv = gst_pad_get_instance_private (pad);
 
   GST_PAD_DIRECTION (pad) = GST_PAD_UNKNOWN;
 
   GST_PAD_ACTIVATEFUNC (pad) = gst_pad_activate_default;
   GST_PAD_EVENTFUNC (pad) = gst_pad_event_default;
@@ -603,11 +599,11 @@
 
     ev = &g_array_index (events, PadEvent, i);
     if (G_UNLIKELY (ev->event == NULL))
       goto next;
 
-    /* take aditional ref, func might release the lock */
+    /* take additional ref, func might release the lock */
     ev_ret.event = gst_event_ref (ev->event);
     ev_ret.received = ev->received;
 
     ret = func (pad, &ev_ret, user_data);
 
@@ -649,38 +645,38 @@
 /* should be called with LOCK */
 static GstEvent *
 _apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream,
     gint64 pad_offset)
 {
-    gint64 offset;
+  gint64 offset;
 
   GST_DEBUG_OBJECT (pad, "apply pad offset %" GST_STIME_FORMAT,
       GST_STIME_ARGS (pad_offset));
 
-    if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {
-      GstSegment segment;
+  if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {
+    GstSegment segment;
 
-      g_assert (!upstream);
+    g_assert (!upstream);
 
-      /* copy segment values */
-      gst_event_copy_segment (event, &segment);
-      gst_event_unref (event);
+    /* copy segment values */
+    gst_event_copy_segment (event, &segment);
+    gst_event_unref (event);
 
     gst_segment_offset_running_time (&segment, segment.format, pad_offset);
-      event = gst_event_new_segment (&segment);
-    }
+    event = gst_event_new_segment (&segment);
+  }
 
-    event = gst_event_make_writable (event);
-    offset = gst_event_get_running_time_offset (event);
-    if (upstream)
+  event = gst_event_make_writable (event);
+  offset = gst_event_get_running_time_offset (event);
+  if (upstream)
     offset -= pad_offset;
-    else
+  else
     offset += pad_offset;
-    gst_event_set_running_time_offset (event, offset);
+  gst_event_set_running_time_offset (event, offset);
 
   return event;
-  }
+}
 
 static inline GstEvent *
 apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream)
 {
   if (G_UNLIKELY (pad->offset != 0))
@@ -834,12 +830,11 @@
  * Creates a new pad with the given name in the given direction.
  * If name is %NULL, a guaranteed unique name (across all pads)
  * will be assigned.
  * This function makes a copy of the name so you can safely free the name.
  *
- * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
- * case of an error.
+ * Returns: (transfer floating): a new #GstPad.
  *
  * MT safe.
  */
 GstPad *
 gst_pad_new (const gchar * name, GstPadDirection direction)
@@ -856,12 +851,11 @@
  * Creates a new pad with the given name from the given template.
  * If name is %NULL, a guaranteed unique name (across all pads)
  * will be assigned.
  * This function makes a copy of the name so you can safely free the name.
  *
- * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
- * case of an error.
+ * Returns: (transfer floating): a new #GstPad.
  */
 GstPad *
 gst_pad_new_from_template (GstPadTemplate * templ, const gchar * name)
 {
   GType pad_type =
@@ -882,12 +876,11 @@
  * Creates a new pad with the given name from the given static template.
  * If name is %NULL, a guaranteed unique name (across all pads)
  * will be assigned.
  * This function makes a copy of the name so you can safely free the name.
  *
- * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
- * case of an error.
+ * Returns: (transfer floating): a new #GstPad.
  */
 GstPad *
 gst_pad_new_from_static_template (GstStaticPadTemplate * templ,
     const gchar * name)
 {
@@ -1218,19 +1211,19 @@
 
   /* pre_activate returns TRUE if we weren't already in the process of
    * switching to the 'new' mode */
   if (pre_activate (pad, new)) {
 
-  if (GST_PAD_ACTIVATEMODEFUNC (pad)) {
-    if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,
-                active)))
-      goto failure;
-  } else {
-    /* can happen for sinks of passthrough elements */
-  }
+    if (GST_PAD_ACTIVATEMODEFUNC (pad)) {
+      if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,
+                  active)))
+        goto failure;
+    } else {
+      /* can happen for sinks of passthrough elements */
+    }
 
-  post_activate (pad, new);
+    post_activate (pad, new);
   }
 
   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, "%s in %s mode",
       active ? "activated" : "deactivated", gst_pad_mode_get_name (mode));
 
@@ -1374,10 +1367,13 @@
 static void
 cleanup_hook (GstPad * pad, GHook * hook)
 {
   GstPadProbeType type;
 
+  GST_DEBUG_OBJECT (pad,
+      "cleaning up hook %lu with flags %08x", hook->hook_id, hook->flags);
+
   if (!G_HOOK_IS_VALID (hook))
     return;
 
   type = (hook->flags) >> G_HOOK_FLAG_USER_SHIFT;
 
@@ -1442,11 +1438,11 @@
   hook = g_hook_alloc (&pad->probes);
 
   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, "adding probe for mask 0x%08x",
       mask);
 
-  /* when no contraints are given for the types, assume all types are
+  /* when no constraints are given for the types, assume all types are
    * acceptable */
   if ((mask & _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH) == 0)
     mask |= GST_PAD_PROBE_TYPE_ALL_BOTH;
   if ((mask & GST_PAD_PROBE_TYPE_SCHEDULING) == 0)
     mask |= GST_PAD_PROBE_TYPE_SCHEDULING;
@@ -1458,11 +1454,11 @@
   hook->destroy = destroy_data;
 
   /* add the probe */
   g_hook_append (&pad->probes, hook);
   pad->num_probes++;
-  /* incremenent cookie so that the new hook get's called */
+  /* incremenent cookie so that the new hook gets called */
   pad->priv->probe_list_cookie++;
 
   /* get the id of the hook, we return this and it can be used to remove the
    * probe later */
   res = hook->hook_id;
@@ -2084,10 +2080,14 @@
  * @user_data: user_data passed to @notify
  * @notify: notify called when @unlink will not be used anymore.
  *
  * Sets the given unlink function for the pad. It will be called
  * when the pad is unlinked.
+ *
+ * Note that the pad's lock is already held when the unlink
+ * function is called, so most pad functions cannot be called
+ * from within the callback.
  */
 void
 gst_pad_set_unlink_function_full (GstPad * pad, GstPadUnlinkFunction unlink,
     gpointer user_data, GDestroyNotify notify)
 {
@@ -2584,11 +2584,11 @@
 
   GST_CAT_INFO (GST_CAT_PADS, "linked %s:%s and %s:%s, successful",
       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
 
   if (!(flags & GST_PAD_LINK_CHECK_NO_RECONFIGURE))
-  gst_pad_send_event (srcpad, gst_event_new_reconfigure ());
+    gst_pad_send_event (srcpad, gst_event_new_reconfigure ());
 
 done:
   if (G_LIKELY (parent)) {
     gst_element_post_message (parent,
         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
@@ -3134,20 +3134,20 @@
     result = gst_pad_proxy_query_accept_caps (pad, query);
     if (result)
       allowed = gst_pad_get_pad_template_caps (pad);
     else
       goto done;
-    }
+  }
 
   gst_query_parse_accept_caps (query, &caps);
   if (!allowed) {
     if (GST_PAD_IS_ACCEPT_TEMPLATE (pad)) {
       allowed = gst_pad_get_pad_template_caps (pad);
     } else {
-  GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,
-      "fallback ACCEPT_CAPS query, consider implementing a specialized version");
-  allowed = gst_pad_query_caps (pad, caps);
+      GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,
+          "fallback ACCEPT_CAPS query, consider implementing a specialized version");
+      allowed = gst_pad_query_caps (pad, caps);
     }
   }
 
   if (allowed) {
     if (GST_PAD_IS_ACCEPT_INTERSECT (pad)) {
@@ -3417,10 +3417,14 @@
       break;
     case GST_QUERY_LATENCY:
       ret = gst_pad_query_latency_default (pad, query);
       forward = FALSE;
       break;
+    case GST_QUERY_BITRATE:
+      /* FIXME: better default handling */
+      forward = TRUE;
+      break;
     case GST_QUERY_POSITION:
     case GST_QUERY_SEEKING:
     case GST_QUERY_FORMATS:
     case GST_QUERY_JITTER:
     case GST_QUERY_RATE:
@@ -3470,34 +3474,34 @@
 
   /* if we have called this callback, do nothing. But only check
    * if we're actually calling probes a second time */
   if (data->retry) {
     for (i = 0; i < data->n_called_probes; i++) {
-      if (data->called_probes[i] == hook) {
-    GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
+      if (data->called_probes[i] == hook->hook_id) {
+        GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
             "hook %lu already called", hook->hook_id);
-    return;
-  }
+        return;
+      }
     }
   }
 
   /* reallocate on the heap if we had more than 16 probes */
   if (data->n_called_probes == data->called_probes_size) {
     if (data->called_probes_size > N_STACK_ALLOCATE_PROBES) {
       data->called_probes_size *= 2;
       data->called_probes =
-          g_renew (GHook *, data->called_probes, data->called_probes_size);
+          g_renew (gulong, data->called_probes, data->called_probes_size);
     } else {
-      GHook **tmp = data->called_probes;
+      gulong *tmp = data->called_probes;
 
       data->called_probes_size *= 2;
-      data->called_probes = g_new (GHook *, data->called_probes_size);
+      data->called_probes = g_new (gulong, data->called_probes_size);
       memcpy (data->called_probes, tmp,
-          N_STACK_ALLOCATE_PROBES * sizeof (GHook *));
+          N_STACK_ALLOCATE_PROBES * sizeof (gulong));
     }
   }
-  data->called_probes[data->n_called_probes++] = hook;
+  data->called_probes[data->n_called_probes++] = hook->hook_id;
 
   flags = hook->flags >> G_HOOK_FLAG_USER_SHIFT;
   type = info->type;
   original_data = info->data;
 
@@ -3514,19 +3518,19 @@
         "probe previously returned DROPPED, not calling again");
     goto no_match;
   }
 
   if (type & GST_PAD_PROBE_TYPE_PUSH) {
-  /* one of the data types for non-idle probes */
-  if ((type & GST_PAD_PROBE_TYPE_IDLE) == 0
+    /* one of the data types for non-idle probes */
+    if ((type & GST_PAD_PROBE_TYPE_IDLE) == 0
         && (flags & _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH & type) == 0)
-    goto no_match;
+      goto no_match;
   } else if (type & GST_PAD_PROBE_TYPE_PULL) {
     /* one of the data types for non-idle probes */
     if ((type & GST_PAD_PROBE_TYPE_BLOCKING) == 0
         && (flags & _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH & type) == 0)
-    goto no_match;
+      goto no_match;
   } else {
     /* Type must have PULL or PUSH probe types */
     g_assert_not_reached ();
   }
 
@@ -3563,11 +3567,12 @@
   GST_OBJECT_LOCK (pad);
 
   if ((flags & GST_PAD_PROBE_TYPE_IDLE))
     pad->priv->idle_running--;
 
-  if (original_data != NULL && info->data == NULL) {
+  if (ret != GST_PAD_PROBE_HANDLED && original_data != NULL
+      && info->data == NULL) {
     GST_DEBUG_OBJECT (pad, "data item in pad probe info was dropped");
     info->type = GST_PAD_PROBE_TYPE_INVALID;
     data->dropped = TRUE;
   }
 
@@ -3611,47 +3616,47 @@
   }
 }
 
 /* a probe that does not take or return any data */
 #define PROBE_NO_DATA(pad,mask,label,defaultval)                \
-  G_STMT_START {                        \
-    if (G_UNLIKELY (pad->num_probes)) {             \
-      GstFlowReturn pval = defaultval;              \
+  G_STMT_START {            \
+    if (G_UNLIKELY (pad->num_probes)) {       \
+      GstFlowReturn pval = defaultval;        \
       /* pass NULL as the data item */                          \
-      GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };       \
-      info.ABI.abi.flow_ret = defaultval;           \
-      ret = do_probe_callbacks (pad, &info, defaultval);    \
-      if (G_UNLIKELY (ret != pval && ret != GST_FLOW_OK))   \
-        goto label;                     \
-    }                               \
+      GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };   \
+      info.ABI.abi.flow_ret = defaultval;     \
+      ret = do_probe_callbacks (pad, &info, defaultval);  \
+      if (G_UNLIKELY (ret != pval && ret != GST_FLOW_OK)) \
+        goto label;           \
+    }               \
   } G_STMT_END
 
 #define PROBE_FULL(pad,mask,data,offs,size,label,handleable,handle_label) \
-  G_STMT_START {                            \
-    if (G_UNLIKELY (pad->num_probes)) {                 \
-      /* pass the data item */                      \
-      GstPadProbeInfo info = { mask, 0, data, offs, size };     \
-      info.ABI.abi.flow_ret = GST_FLOW_OK;              \
-      ret = do_probe_callbacks (pad, &info, GST_FLOW_OK);       \
-      /* store the possibly updated data item */            \
-      data = GST_PAD_PROBE_INFO_DATA (&info);               \
-      /* if something went wrong, exit */               \
-      if (G_UNLIKELY (ret != GST_FLOW_OK)) {                \
-    if (handleable && ret == GST_FLOW_CUSTOM_SUCCESS_1) {       \
-      ret = info.ABI.abi.flow_ret;                      \
-      goto handle_label;                        \
-    }                               \
-    goto label;                         \
-      }                                 \
-    }                                   \
+  G_STMT_START {              \
+    if (G_UNLIKELY (pad->num_probes)) {         \
+      /* pass the data item */            \
+      GstPadProbeInfo info = { mask, 0, data, offs, size };   \
+      info.ABI.abi.flow_ret = GST_FLOW_OK;        \
+      ret = do_probe_callbacks (pad, &info, GST_FLOW_OK);   \
+      /* store the possibly updated data item */      \
+      data = GST_PAD_PROBE_INFO_DATA (&info);       \
+      /* if something went wrong, exit */       \
+      if (G_UNLIKELY (ret != GST_FLOW_OK)) {        \
+  if (handleable && ret == GST_FLOW_CUSTOM_SUCCESS_1) {   \
+    ret = info.ABI.abi.flow_ret;            \
+    goto handle_label;            \
+  }               \
+  goto label;             \
+      }                 \
+    }                 \
   } G_STMT_END
 
-#define PROBE_PUSH(pad,mask,data,label)     \
+#define PROBE_PUSH(pad,mask,data,label)   \
   PROBE_FULL(pad, mask, data, -1, -1, label, FALSE, label);
 #define PROBE_HANDLE(pad,mask,data,label,handle_label)  \
   PROBE_FULL(pad, mask, data, -1, -1, label, TRUE, handle_label);
-#define PROBE_PULL(pad,mask,data,offs,size,label)       \
+#define PROBE_PULL(pad,mask,data,offs,size,label)   \
   PROBE_FULL(pad, mask, data, offs, size, label, FALSE, label);
 
 static GstFlowReturn
 do_pad_idle_probe_wait (GstPad * pad)
 {
@@ -3689,11 +3694,11 @@
     GstFlowReturn defaultval)
 {
   ProbeMarshall data;
   guint cookie;
   gboolean is_block;
-  GHook *called_probes[N_STACK_ALLOCATE_PROBES];
+  gulong called_probes[N_STACK_ALLOCATE_PROBES];
 
   data.pad = pad;
   data.info = info;
   data.pass = FALSE;
   data.handled = FALSE;
@@ -3816,11 +3821,11 @@
   {
     GST_DEBUG_OBJECT (pad, "data was handled");
     if (data.called_probes_size > N_STACK_ALLOCATE_PROBES)
       g_free (data.called_probes);
     return GST_FLOW_CUSTOM_SUCCESS_1;
-}
+  }
 }
 
 /* pad offsets */
 
 /**
@@ -4381,11 +4386,11 @@
   {
     GST_OBJECT_UNLOCK (pad);
     GST_PAD_STREAM_UNLOCK (pad);
     /* We unref the buffer, except if the probe handled it (CUSTOM_SUCCESS_1) */
     if (!handled)
-    gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
+      gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
 
     switch (ret) {
       case GST_FLOW_CUSTOM_SUCCESS:
       case GST_FLOW_CUSTOM_SUCCESS_1:
         GST_DEBUG_OBJECT (pad, "dropped or handled buffer");
@@ -4634,11 +4639,11 @@
   /* PASSTHROUGH */
 probe_stopped:
   {
     GST_OBJECT_UNLOCK (pad);
     if (data != NULL && !handled)
-    gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
+      gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
 
     switch (ret) {
       case GST_FLOW_CUSTOM_SUCCESS:
       case GST_FLOW_CUSTOM_SUCCESS_1:
         GST_DEBUG_OBJECT (pad, "dropped or handled buffer");
@@ -5126,12 +5131,12 @@
       gst_buffer_unref (res_buf);
     goto done;
   }
 done:
   GST_TRACER_PAD_PULL_RANGE_POST (pad, NULL, ret);
-    return ret;
-  }
+  return ret;
+}
 
 /* must be called with pad object lock */
 static GstFlowReturn
 store_sticky_event (GstPad * pad, GstEvent * event)
 {
@@ -5437,11 +5442,11 @@
   }
 probe_stopped:
   {
     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
-    gst_event_unref (event);
+      gst_event_unref (event);
 
     switch (ret) {
       case GST_FLOW_CUSTOM_SUCCESS_1:
         GST_DEBUG_OBJECT (pad, "handled event");
         break;
@@ -5587,12 +5592,12 @@
     gst_event_unref (event);
     goto done;
   }
 done:
   GST_TRACER_PAD_PUSH_EVENT_POST (pad, FALSE);
-    return FALSE;
-  }
+  return FALSE;
+}
 
 /* Check if we can call the event function with the given event */
 static GstFlowReturn
 pre_eventfunc_check (GstPad * pad, GstEvent * event)
 {
@@ -5665,12 +5670,12 @@
        * Also, some elements restart a streaming thread in flush-stop which we
        * can't allow on inactive pads */
       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
         goto inactive;
 
-        GST_PAD_UNSET_FLUSHING (pad);
-        GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, "cleared flush flag");
+      GST_PAD_UNSET_FLUSHING (pad);
+      GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, "cleared flush flag");
       /* Remove pending EOS events */
       GST_LOG_OBJECT (pad, "Removing pending EOS and SEGMENT events");
       remove_event_by_type (pad, GST_EVENT_EOS);
       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
       remove_event_by_type (pad, GST_EVENT_SEGMENT);
@@ -5834,11 +5839,11 @@
     GST_OBJECT_UNLOCK (pad);
     if (need_unlock)
       GST_PAD_STREAM_UNLOCK (pad);
     /* Only unref if unhandled */
     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
-    gst_event_unref (event);
+      gst_event_unref (event);
 
     switch (ret) {
       case GST_FLOW_CUSTOM_SUCCESS_1:
       case GST_FLOW_CUSTOM_SUCCESS:
         GST_DEBUG_OBJECT (pad, "dropped or handled event");
