<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* goption.c - Option parser
   2  *
   3  *  Copyright (C) 1999, 2003 Red Hat Software
   4  *  Copyright (C) 2004       Anders Carlsson &lt;andersca@gnome.org&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public License
  17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 /**
  21  * SECTION:option
  22  * @Short_description: parses commandline options
  23  * @Title: Commandline option parser
  24  *
  25  * The GOption commandline parser is intended to be a simpler replacement
  26  * for the popt library. It supports short and long commandline options,
  27  * as shown in the following example:
  28  *
  29  * `testtreemodel -r 1 --max-size 20 --rand --display=:1.0 -vb -- file1 file2`
  30  *
  31  * The example demonstrates a number of features of the GOption
  32  * commandline parser:
  33  *
  34  * - Options can be single letters, prefixed by a single dash.
  35  *
  36  * - Multiple short options can be grouped behind a single dash.
  37  *
  38  * - Long options are prefixed by two consecutive dashes.
  39  *
  40  * - Options can have an extra argument, which can be a number, a string or
  41  *   a filename. For long options, the extra argument can be appended with
  42  *   an equals sign after the option name, which is useful if the extra
  43  *   argument starts with a dash, which would otherwise cause it to be
  44  *   interpreted as another option.
  45  *
  46  * - Non-option arguments are returned to the application as rest arguments.
  47  *
  48  * - An argument consisting solely of two dashes turns off further parsing,
  49  *   any remaining arguments (even those starting with a dash) are returned
  50  *   to the application as rest arguments.
  51  *
  52  * Another important feature of GOption is that it can automatically
  53  * generate nicely formatted help output. Unless it is explicitly turned
  54  * off with g_option_context_set_help_enabled(), GOption will recognize
  55  * the `--help`, `-?`, `--help-all` and `--help-groupname` options
  56  * (where `groupname` is the name of a #GOptionGroup) and write a text
  57  * similar to the one shown in the following example to stdout.
  58  *
  59  * |[
  60  * Usage:
  61  *   testtreemodel [OPTION...] - test tree model performance
  62  *
  63  * Help Options:
  64  *   -h, --help               Show help options
  65  *   --help-all               Show all help options
  66  *   --help-gtk               Show GTK+ Options
  67  *
  68  * Application Options:
  69  *   -r, --repeats=N          Average over N repetitions
  70  *   -m, --max-size=M         Test up to 2^M items
  71  *   --display=DISPLAY        X display to use
  72  *   -v, --verbose            Be verbose
  73  *   -b, --beep               Beep when done
  74  *   --rand                   Randomize the data
  75  * ]|
  76  *
  77  * GOption groups options in #GOptionGroups, which makes it easy to
  78  * incorporate options from multiple sources. The intended use for this is
  79  * to let applications collect option groups from the libraries it uses,
  80  * add them to their #GOptionContext, and parse all options by a single call
  81  * to g_option_context_parse(). See gtk_get_option_group() for an example.
  82  *
  83  * If an option is declared to be of type string or filename, GOption takes
  84  * care of converting it to the right encoding; strings are returned in
  85  * UTF-8, filenames are returned in the GLib filename encoding. Note that
  86  * this only works if setlocale() has been called before
  87  * g_option_context_parse().
  88  *
  89  * Here is a complete example of setting up GOption to parse the example
  90  * commandline above and produce the example help output.
  91  * |[&lt;!-- language=&quot;C&quot; --&gt;
  92  * static gint repeats = 2;
  93  * static gint max_size = 8;
  94  * static gboolean verbose = FALSE;
  95  * static gboolean beep = FALSE;
  96  * static gboolean randomize = FALSE;
  97  *
  98  * static GOptionEntry entries[] =
  99  * {
 100  *   { &quot;repeats&quot;, &#39;r&#39;, 0, G_OPTION_ARG_INT, &amp;repeats, &quot;Average over N repetitions&quot;, &quot;N&quot; },
 101  *   { &quot;max-size&quot;, &#39;m&#39;, 0, G_OPTION_ARG_INT, &amp;max_size, &quot;Test up to 2^M items&quot;, &quot;M&quot; },
 102  *   { &quot;verbose&quot;, &#39;v&#39;, 0, G_OPTION_ARG_NONE, &amp;verbose, &quot;Be verbose&quot;, NULL },
 103  *   { &quot;beep&quot;, &#39;b&#39;, 0, G_OPTION_ARG_NONE, &amp;beep, &quot;Beep when done&quot;, NULL },
 104  *   { &quot;rand&quot;, 0, 0, G_OPTION_ARG_NONE, &amp;randomize, &quot;Randomize the data&quot;, NULL },
 105  *   { NULL }
 106  * };
 107  *
 108  * int
 109  * main (int argc, char *argv[])
 110  * {
 111  *   GError *error = NULL;
 112  *   GOptionContext *context;
 113  *
 114  *   context = g_option_context_new (&quot;- test tree model performance&quot;);
 115  *   g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);
 116  *   g_option_context_add_group (context, gtk_get_option_group (TRUE));
 117  *   if (!g_option_context_parse (context, &amp;argc, &amp;argv, &amp;error))
 118  *     {
 119  *       g_print (&quot;option parsing failed: %s\n&quot;, error-&gt;message);
 120  *       exit (1);
 121  *     }
 122  *
 123  *   ...
 124  *
 125  * }
 126  * ]|
 127  *
 128  * On UNIX systems, the argv that is passed to main() has no particular
 129  * encoding, even to the extent that different parts of it may have
 130  * different encodings.  In general, normal arguments and flags will be
 131  * in the current locale and filenames should be considered to be opaque
 132  * byte strings.  Proper use of %G_OPTION_ARG_FILENAME vs
 133  * %G_OPTION_ARG_STRING is therefore important.
 134  *
 135  * Note that on Windows, filenames do have an encoding, but using
 136  * #GOptionContext with the argv as passed to main() will result in a
 137  * program that can only accept commandline arguments with characters
 138  * from the system codepage.  This can cause problems when attempting to
 139  * deal with filenames containing Unicode characters that fall outside
 140  * of the codepage.
 141  *
 142  * A solution to this is to use g_win32_get_command_line() and
 143  * g_option_context_parse_strv() which will properly handle full Unicode
 144  * filenames.  If you are using #GApplication, this is done
 145  * automatically for you.
 146  *
 147  * The following example shows how you can use #GOptionContext directly
 148  * in order to correctly deal with Unicode filenames on Windows:
 149  *
 150  * |[&lt;!-- language=&quot;C&quot; --&gt;
 151  * int
 152  * main (int argc, char **argv)
 153  * {
 154  *   GError *error = NULL;
 155  *   GOptionContext *context;
 156  *   gchar **args;
 157  *
 158  * #ifdef G_OS_WIN32
 159  *   args = g_win32_get_command_line ();
 160  * #else
 161  *   args = g_strdupv (argv);
 162  * #endif
 163  *
 164  *   // set up context
 165  *
 166  *   if (!g_option_context_parse_strv (context, &amp;args, &amp;error))
 167  *     {
 168  *       // error happened
 169  *     }
 170  *
 171  *   ...
 172  *
 173  *   g_strfreev (args);
 174  *
 175  *   ...
 176  * }
 177  * ]|
 178  */
 179 
 180 #include &quot;config.h&quot;
 181 
 182 #include &lt;string.h&gt;
 183 #include &lt;stdlib.h&gt;
 184 #include &lt;stdio.h&gt;
 185 #include &lt;errno.h&gt;
 186 
 187 #if defined __OpenBSD__
 188 #include &lt;unistd.h&gt;
 189 #include &lt;sys/sysctl.h&gt;
 190 #endif
 191 
 192 #include &quot;goption.h&quot;
 193 
 194 #include &quot;gprintf.h&quot;
 195 #include &quot;glibintl.h&quot;
 196 
 197 #define TRANSLATE(group, str) (((group)-&gt;translate_func ? (* (group)-&gt;translate_func) ((str), (group)-&gt;translate_data) : (str)))
 198 
 199 #define NO_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_NONE ||       \
 200                        ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 201                         ((entry)-&gt;flags &amp; G_OPTION_FLAG_NO_ARG)))
 202 
 203 #define OPTIONAL_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 204                        (entry)-&gt;flags &amp; G_OPTION_FLAG_OPTIONAL_ARG)
 205 
 206 typedef struct
 207 {
 208   GOptionArg arg_type;
 209   gpointer arg_data;
 210   union
 211   {
 212     gboolean bool;
 213     gint integer;
 214     gchar *str;
 215     gchar **array;
 216     gdouble dbl;
 217     gint64 int64;
 218   } prev;
 219   union
 220   {
 221     gchar *str;
 222     struct
 223     {
 224       gint len;
 225       gchar **data;
 226     } array;
 227   } allocated;
 228 } Change;
 229 
 230 typedef struct
 231 {
 232   gchar **ptr;
 233   gchar *value;
 234 } PendingNull;
 235 
 236 struct _GOptionContext
 237 {
 238   GList           *groups;
 239 
 240   gchar           *parameter_string;
 241   gchar           *summary;
 242   gchar           *description;
 243 
 244   GTranslateFunc   translate_func;
 245   GDestroyNotify   translate_notify;
 246   gpointer         translate_data;
 247 
 248   guint            help_enabled   : 1;
 249   guint            ignore_unknown : 1;
 250   guint            strv_mode      : 1;
 251   guint            strict_posix   : 1;
 252 
 253   GOptionGroup    *main_group;
 254 
 255   /* We keep a list of change so we can revert them */
 256   GList           *changes;
 257 
 258   /* We also keep track of all argv elements
 259    * that should be NULLed or modified.
 260    */
 261   GList           *pending_nulls;
 262 };
 263 
 264 struct _GOptionGroup
 265 {
 266   gchar           *name;
 267   gchar           *description;
 268   gchar           *help_description;
 269 
 270   gint             ref_count;
 271 
 272   GDestroyNotify   destroy_notify;
 273   gpointer         user_data;
 274 
 275   GTranslateFunc   translate_func;
 276   GDestroyNotify   translate_notify;
 277   gpointer         translate_data;
 278 
 279   GOptionEntry    *entries;
 280   gint             n_entries;
 281 
 282   GOptionParseFunc pre_parse_func;
 283   GOptionParseFunc post_parse_func;
 284   GOptionErrorFunc error_func;
 285 };
 286 
 287 static void free_changes_list (GOptionContext *context,
 288                                gboolean        revert);
 289 static void free_pending_nulls (GOptionContext *context,
 290                                 gboolean        perform_nulls);
 291 
 292 
 293 static int
 294 _g_unichar_get_width (gunichar c)
 295 {
 296   if (G_UNLIKELY (g_unichar_iszerowidth (c)))
 297     return 0;
 298 
 299   /* we ignore the fact that we should call g_unichar_iswide_cjk() under
 300    * some locales (legacy East Asian ones) */
 301   if (g_unichar_iswide (c))
 302     return 2;
 303 
 304   return 1;
 305 }
 306 
 307 static glong
 308 _g_utf8_strwidth (const gchar *p)
 309 {
 310   glong len = 0;
 311   g_return_val_if_fail (p != NULL, 0);
 312 
 313   while (*p)
 314     {
 315       len += _g_unichar_get_width (g_utf8_get_char (p));
 316       p = g_utf8_next_char (p);
 317     }
 318 
 319   return len;
 320 }
 321 
 322 G_DEFINE_QUARK (g-option-context-error-quark, g_option_error)
 323 
 324 /**
 325  * g_option_context_new:
 326  * @parameter_string: (nullable): a string which is displayed in
 327  *    the first line of `--help` output, after the usage summary
 328  *    `programname [OPTION...]`
 329  *
 330  * Creates a new option context.
 331  *
 332  * The @parameter_string can serve multiple purposes. It can be used
 333  * to add descriptions for &quot;rest&quot; arguments, which are not parsed by
 334  * the #GOptionContext, typically something like &quot;FILES&quot; or
 335  * &quot;FILE1 FILE2...&quot;. If you are using #G_OPTION_REMAINING for
 336  * collecting &quot;rest&quot; arguments, GLib handles this automatically by
 337  * using the @arg_description of the corresponding #GOptionEntry in
 338  * the usage summary.
 339  *
 340  * Another usage is to give a short summary of the program
 341  * functionality, like &quot; - frob the strings&quot;, which will be displayed
 342  * in the same line as the usage. For a longer description of the
 343  * program functionality that should be displayed as a paragraph
 344  * below the usage line, use g_option_context_set_summary().
 345  *
 346  * Note that the @parameter_string is translated using the
 347  * function set with g_option_context_set_translate_func(), so
 348  * it should normally be passed untranslated.
 349  *
 350  * Returns: a newly created #GOptionContext, which must be
 351  *    freed with g_option_context_free() after use.
 352  *
 353  * Since: 2.6
 354  */
 355 GOptionContext *
 356 g_option_context_new (const gchar *parameter_string)
 357 
 358 {
 359   GOptionContext *context;
 360 
 361   context = g_new0 (GOptionContext, 1);
 362 
 363   context-&gt;parameter_string = g_strdup (parameter_string);
 364   context-&gt;strict_posix = FALSE;
 365   context-&gt;help_enabled = TRUE;
 366   context-&gt;ignore_unknown = FALSE;
 367 
 368   return context;
 369 }
 370 
 371 /**
 372  * g_option_context_free:
 373  * @context: a #GOptionContext
 374  *
 375  * Frees context and all the groups which have been
 376  * added to it.
 377  *
 378  * Please note that parsed arguments need to be freed separately (see
 379  * #GOptionEntry).
 380  *
 381  * Since: 2.6
 382  */
 383 void g_option_context_free (GOptionContext *context)
 384 {
 385   g_return_if_fail (context != NULL);
 386 
 387   g_list_free_full (context-&gt;groups, (GDestroyNotify) g_option_group_unref);
 388 
 389   if (context-&gt;main_group)
 390     g_option_group_unref (context-&gt;main_group);
 391 
 392   free_changes_list (context, FALSE);
 393   free_pending_nulls (context, FALSE);
 394 
 395   g_free (context-&gt;parameter_string);
 396   g_free (context-&gt;summary);
 397   g_free (context-&gt;description);
 398 
 399   if (context-&gt;translate_notify)
 400     (* context-&gt;translate_notify) (context-&gt;translate_data);
 401 
 402   g_free (context);
 403 }
 404 
 405 
 406 /**
 407  * g_option_context_set_help_enabled:
 408  * @context: a #GOptionContext
 409  * @help_enabled: %TRUE to enable `--help`, %FALSE to disable it
 410  *
 411  * Enables or disables automatic generation of `--help` output.
 412  * By default, g_option_context_parse() recognizes `--help`, `-h`,
 413  * `-?`, `--help-all` and `--help-groupname` and creates suitable
 414  * output to stdout.
 415  *
 416  * Since: 2.6
 417  */
 418 void g_option_context_set_help_enabled (GOptionContext *context,
 419                                         gboolean        help_enabled)
 420 
 421 {
 422   g_return_if_fail (context != NULL);
 423 
 424   context-&gt;help_enabled = help_enabled;
 425 }
 426 
 427 /**
 428  * g_option_context_get_help_enabled:
 429  * @context: a #GOptionContext
 430  *
 431  * Returns whether automatic `--help` generation
 432  * is turned on for @context. See g_option_context_set_help_enabled().
 433  *
 434  * Returns: %TRUE if automatic help generation is turned on.
 435  *
 436  * Since: 2.6
 437  */
 438 gboolean
 439 g_option_context_get_help_enabled (GOptionContext *context)
 440 {
 441   g_return_val_if_fail (context != NULL, FALSE);
 442 
 443   return context-&gt;help_enabled;
 444 }
 445 
 446 /**
 447  * g_option_context_set_ignore_unknown_options:
 448  * @context: a #GOptionContext
 449  * @ignore_unknown: %TRUE to ignore unknown options, %FALSE to produce
 450  *    an error when unknown options are met
 451  *
 452  * Sets whether to ignore unknown options or not. If an argument is
 453  * ignored, it is left in the @argv array after parsing. By default,
 454  * g_option_context_parse() treats unknown options as error.
 455  *
 456  * This setting does not affect non-option arguments (i.e. arguments
 457  * which don&#39;t start with a dash). But note that GOption cannot reliably
 458  * determine whether a non-option belongs to a preceding unknown option.
 459  *
 460  * Since: 2.6
 461  **/
 462 void
 463 g_option_context_set_ignore_unknown_options (GOptionContext *context,
 464                                              gboolean        ignore_unknown)
 465 {
 466   g_return_if_fail (context != NULL);
 467 
 468   context-&gt;ignore_unknown = ignore_unknown;
 469 }
 470 
 471 /**
 472  * g_option_context_get_ignore_unknown_options:
 473  * @context: a #GOptionContext
 474  *
 475  * Returns whether unknown options are ignored or not. See
 476  * g_option_context_set_ignore_unknown_options().
 477  *
 478  * Returns: %TRUE if unknown options are ignored.
 479  *
 480  * Since: 2.6
 481  **/
 482 gboolean
 483 g_option_context_get_ignore_unknown_options (GOptionContext *context)
 484 {
 485   g_return_val_if_fail (context != NULL, FALSE);
 486 
 487   return context-&gt;ignore_unknown;
 488 }
 489 
 490 /**
 491  * g_option_context_set_strict_posix:
 492  * @context: a #GOptionContext
 493  * @strict_posix: the new value
 494  *
 495  * Sets strict POSIX mode.
 496  *
 497  * By default, this mode is disabled.
 498  *
 499  * In strict POSIX mode, the first non-argument parameter encountered
 500  * (eg: filename) terminates argument processing.  Remaining arguments
 501  * are treated as non-options and are not attempted to be parsed.
 502  *
 503  * If strict POSIX mode is disabled then parsing is done in the GNU way
 504  * where option arguments can be freely mixed with non-options.
 505  *
 506  * As an example, consider &quot;ls foo -l&quot;.  With GNU style parsing, this
 507  * will list &quot;foo&quot; in long mode.  In strict POSIX style, this will list
 508  * the files named &quot;foo&quot; and &quot;-l&quot;.
 509  *
 510  * It may be useful to force strict POSIX mode when creating &quot;verb
 511  * style&quot; command line tools.  For example, the &quot;gsettings&quot; command line
 512  * tool supports the global option &quot;--schemadir&quot; as well as many
 513  * subcommands (&quot;get&quot;, &quot;set&quot;, etc.) which each have their own set of
 514  * arguments.  Using strict POSIX mode will allow parsing the global
 515  * options up to the verb name while leaving the remaining options to be
 516  * parsed by the relevant subcommand (which can be determined by
 517  * examining the verb name, which should be present in argv[1] after
 518  * parsing).
 519  *
 520  * Since: 2.44
 521  **/
 522 void
 523 g_option_context_set_strict_posix (GOptionContext *context,
 524                                    gboolean        strict_posix)
 525 {
 526   g_return_if_fail (context != NULL);
 527 
 528   context-&gt;strict_posix = strict_posix;
 529 }
 530 
 531 /**
 532  * g_option_context_get_strict_posix:
 533  * @context: a #GOptionContext
 534  *
 535  * Returns whether strict POSIX code is enabled.
 536  *
 537  * See g_option_context_set_strict_posix() for more information.
 538  *
 539  * Returns: %TRUE if strict POSIX is enabled, %FALSE otherwise.
 540  *
 541  * Since: 2.44
 542  **/
 543 gboolean
 544 g_option_context_get_strict_posix (GOptionContext *context)
 545 {
 546   g_return_val_if_fail (context != NULL, FALSE);
 547 
 548   return context-&gt;strict_posix;
 549 }
 550 
 551 /**
 552  * g_option_context_add_group:
 553  * @context: a #GOptionContext
 554  * @group: (transfer full): the group to add
 555  *
 556  * Adds a #GOptionGroup to the @context, so that parsing with @context
 557  * will recognize the options in the group. Note that this will take
 558  * ownership of the @group and thus the @group should not be freed.
 559  *
 560  * Since: 2.6
 561  **/
 562 void
 563 g_option_context_add_group (GOptionContext *context,
 564                             GOptionGroup   *group)
 565 {
 566   GList *list;
 567 
 568   g_return_if_fail (context != NULL);
 569   g_return_if_fail (group != NULL);
 570   g_return_if_fail (group-&gt;name != NULL);
 571   g_return_if_fail (group-&gt;description != NULL);
 572   g_return_if_fail (group-&gt;help_description != NULL);
 573 
 574   for (list = context-&gt;groups; list; list = list-&gt;next)
 575     {
 576       GOptionGroup *g = (GOptionGroup *)list-&gt;data;
 577 
 578       if ((group-&gt;name == NULL &amp;&amp; g-&gt;name == NULL) ||
 579           (group-&gt;name &amp;&amp; g-&gt;name &amp;&amp; strcmp (group-&gt;name, g-&gt;name) == 0))
 580         g_warning (&quot;A group named \&quot;%s\&quot; is already part of this GOptionContext&quot;,
 581                    group-&gt;name);
 582     }
 583 
 584   context-&gt;groups = g_list_append (context-&gt;groups, group);
 585 }
 586 
 587 /**
 588  * g_option_context_set_main_group:
 589  * @context: a #GOptionContext
 590  * @group: (transfer full): the group to set as main group
 591  *
 592  * Sets a #GOptionGroup as main group of the @context.
 593  * This has the same effect as calling g_option_context_add_group(),
 594  * the only difference is that the options in the main group are
 595  * treated differently when generating `--help` output.
 596  *
 597  * Since: 2.6
 598  **/
 599 void
 600 g_option_context_set_main_group (GOptionContext *context,
 601                                  GOptionGroup   *group)
 602 {
 603   g_return_if_fail (context != NULL);
 604   g_return_if_fail (group != NULL);
 605 
 606   if (context-&gt;main_group)
 607     {
 608       g_warning (&quot;This GOptionContext already has a main group&quot;);
 609 
 610       return;
 611     }
 612 
 613   context-&gt;main_group = group;
 614 }
 615 
 616 /**
 617  * g_option_context_get_main_group:
 618  * @context: a #GOptionContext
 619  *
 620  * Returns a pointer to the main group of @context.
 621  *
 622  * Returns: (transfer none): the main group of @context, or %NULL if
 623  *  @context doesn&#39;t have a main group. Note that group belongs to
 624  *  @context and should not be modified or freed.
 625  *
 626  * Since: 2.6
 627  **/
 628 GOptionGroup *
 629 g_option_context_get_main_group (GOptionContext *context)
 630 {
 631   g_return_val_if_fail (context != NULL, NULL);
 632 
 633   return context-&gt;main_group;
 634 }
 635 
 636 /**
 637  * g_option_context_add_main_entries:
 638  * @context: a #GOptionContext
 639  * @entries: a %NULL-terminated array of #GOptionEntrys
 640  * @translation_domain: (nullable): a translation domain to use for translating
 641  *    the `--help` output for the options in @entries
 642  *    with gettext(), or %NULL
 643  *
 644  * A convenience function which creates a main group if it doesn&#39;t
 645  * exist, adds the @entries to it and sets the translation domain.
 646  *
 647  * Since: 2.6
 648  **/
 649 void
 650 g_option_context_add_main_entries (GOptionContext      *context,
 651                                    const GOptionEntry  *entries,
 652                                    const gchar         *translation_domain)
 653 {
 654   g_return_if_fail (entries != NULL);
 655 
 656   if (!context-&gt;main_group)
 657     context-&gt;main_group = g_option_group_new (NULL, NULL, NULL, NULL, NULL);
 658 
 659   g_option_group_add_entries (context-&gt;main_group, entries);
 660   g_option_group_set_translation_domain (context-&gt;main_group, translation_domain);
 661 }
 662 
 663 static gint
 664 calculate_max_length (GOptionGroup *group,
 665                       GHashTable   *aliases)
 666 {
 667   GOptionEntry *entry;
 668   gint i, len, max_length;
 669   const gchar *long_name;
 670 
 671   max_length = 0;
 672 
 673   for (i = 0; i &lt; group-&gt;n_entries; i++)
 674     {
 675       entry = &amp;group-&gt;entries[i];
 676 
 677       if (entry-&gt;flags &amp; G_OPTION_FLAG_HIDDEN)
 678         continue;
 679 
 680       long_name = g_hash_table_lookup (aliases, &amp;entry-&gt;long_name);
 681       if (!long_name)
 682         long_name = entry-&gt;long_name;
 683       len = _g_utf8_strwidth (long_name);
 684 
 685       if (entry-&gt;short_name)
 686         len += 4;
 687 
 688       if (!NO_ARG (entry) &amp;&amp; entry-&gt;arg_description)
 689         len += 1 + _g_utf8_strwidth (TRANSLATE (group, entry-&gt;arg_description));
 690 
 691       max_length = MAX (max_length, len);
 692     }
 693 
 694   return max_length;
 695 }
 696 
 697 static void
 698 print_entry (GOptionGroup       *group,
 699              gint                max_length,
 700              const GOptionEntry *entry,
 701              GString            *string,
 702              GHashTable         *aliases)
 703 {
 704   GString *str;
 705   const gchar *long_name;
 706 
 707   if (entry-&gt;flags &amp; G_OPTION_FLAG_HIDDEN)
 708     return;
 709 
 710   if (entry-&gt;long_name[0] == 0)
 711     return;
 712 
 713   long_name = g_hash_table_lookup (aliases, &amp;entry-&gt;long_name);
 714   if (!long_name)
 715     long_name = entry-&gt;long_name;
 716 
 717   str = g_string_new (NULL);
 718 
 719   if (entry-&gt;short_name)
 720     g_string_append_printf (str, &quot;  -%c, --%s&quot;, entry-&gt;short_name, long_name);
 721   else
 722     g_string_append_printf (str, &quot;  --%s&quot;, long_name);
 723 
 724   if (entry-&gt;arg_description)
 725     g_string_append_printf (str, &quot;=%s&quot;, TRANSLATE (group, entry-&gt;arg_description));
 726 
 727   g_string_append_printf (string, &quot;%s%*s %s\n&quot;, str-&gt;str,
 728                           (int) (max_length + 4 - _g_utf8_strwidth (str-&gt;str)), &quot;&quot;,
 729                           entry-&gt;description ? TRANSLATE (group, entry-&gt;description) : &quot;&quot;);
 730   g_string_free (str, TRUE);
 731 }
 732 
 733 static gboolean
 734 group_has_visible_entries (GOptionContext *context,
 735                            GOptionGroup *group,
 736                            gboolean      main_entries)
 737 {
 738   GOptionFlags reject_filter = G_OPTION_FLAG_HIDDEN;
 739   GOptionEntry *entry;
 740   gint i, l;
 741   gboolean main_group = group == context-&gt;main_group;
 742 
 743   if (!main_entries)
 744     reject_filter |= G_OPTION_FLAG_IN_MAIN;
 745 
 746   for (i = 0, l = (group ? group-&gt;n_entries : 0); i &lt; l; i++)
 747     {
 748       entry = &amp;group-&gt;entries[i];
 749 
 750       if (main_entries &amp;&amp; !main_group &amp;&amp; !(entry-&gt;flags &amp; G_OPTION_FLAG_IN_MAIN))
 751         continue;
 752       if (entry-&gt;long_name[0] == 0) /* ignore rest entry */
 753         continue;
 754       if (!(entry-&gt;flags &amp; reject_filter))
 755         return TRUE;
 756     }
 757 
 758   return FALSE;
 759 }
 760 
 761 static gboolean
 762 group_list_has_visible_entries (GOptionContext *context,
 763                                 GList          *group_list,
 764                                 gboolean       main_entries)
 765 {
 766   while (group_list)
 767     {
 768       if (group_has_visible_entries (context, group_list-&gt;data, main_entries))
 769         return TRUE;
 770 
 771       group_list = group_list-&gt;next;
 772     }
 773 
 774   return FALSE;
 775 }
 776 
 777 static gboolean
 778 context_has_h_entry (GOptionContext *context)
 779 {
 780   gsize i;
 781   GList *list;
 782 
 783   if (context-&gt;main_group)
 784     {
 785       for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
 786         {
 787           if (context-&gt;main_group-&gt;entries[i].short_name == &#39;h&#39;)
 788             return TRUE;
 789         }
 790     }
 791 
 792   for (list = context-&gt;groups; list != NULL; list = g_list_next (list))
 793     {
 794      GOptionGroup *group;
 795 
 796       group = (GOptionGroup*)list-&gt;data;
 797       for (i = 0; i &lt; group-&gt;n_entries; i++)
 798         {
 799           if (group-&gt;entries[i].short_name == &#39;h&#39;)
 800             return TRUE;
 801         }
 802     }
 803   return FALSE;
 804 }
 805 
 806 /**
 807  * g_option_context_get_help:
 808  * @context: a #GOptionContext
 809  * @main_help: if %TRUE, only include the main group
 810  * @group: (nullable): the #GOptionGroup to create help for, or %NULL
 811  *
 812  * Returns a formatted, translated help text for the given context.
 813  * To obtain the text produced by `--help`, call
 814  * `g_option_context_get_help (context, TRUE, NULL)`.
 815  * To obtain the text produced by `--help-all`, call
 816  * `g_option_context_get_help (context, FALSE, NULL)`.
 817  * To obtain the help text for an option group, call
 818  * `g_option_context_get_help (context, FALSE, group)`.
 819  *
 820  * Returns: A newly allocated string containing the help text
 821  *
 822  * Since: 2.14
 823  */
 824 gchar *
 825 g_option_context_get_help (GOptionContext *context,
 826                            gboolean        main_help,
 827                            GOptionGroup   *group)
 828 {
 829   GList *list;
 830   gint max_length = 0, len;
 831   gint i;
 832   GOptionEntry *entry;
 833   GHashTable *shadow_map;
 834   GHashTable *aliases;
 835   gboolean seen[256];
 836   const gchar *rest_description;
 837   GString *string;
 838   guchar token;
 839 
 840   string = g_string_sized_new (1024);
 841 
 842   rest_description = NULL;
 843   if (context-&gt;main_group)
 844     {
 845 
 846       for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
 847         {
 848           entry = &amp;context-&gt;main_group-&gt;entries[i];
 849           if (entry-&gt;long_name[0] == 0)
 850             {
 851               rest_description = TRANSLATE (context-&gt;main_group, entry-&gt;arg_description);
 852               break;
 853             }
 854         }
 855     }
 856 
 857   g_string_append_printf (string, &quot;%s\n  %s&quot;, _(&quot;Usage:&quot;), g_get_prgname ());
 858   if (context-&gt;help_enabled ||
 859       (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;n_entries &gt; 0) ||
 860       context-&gt;groups != NULL)
 861     g_string_append_printf (string, &quot; %s&quot;, _(&quot;[OPTION...]&quot;));
 862 
 863   if (rest_description)
 864     {
 865       g_string_append (string, &quot; &quot;);
 866       g_string_append (string, rest_description);
 867     }
 868 
 869   if (context-&gt;parameter_string)
 870     {
 871       g_string_append (string, &quot; &quot;);
 872       g_string_append (string, TRANSLATE (context, context-&gt;parameter_string));
 873     }
 874 
 875   g_string_append (string, &quot;\n\n&quot;);
 876 
 877   if (context-&gt;summary)
 878     {
 879       g_string_append (string, TRANSLATE (context, context-&gt;summary));
 880       g_string_append (string, &quot;\n\n&quot;);
 881     }
 882 
 883   memset (seen, 0, sizeof (gboolean) * 256);
 884   shadow_map = g_hash_table_new (g_str_hash, g_str_equal);
 885   aliases = g_hash_table_new_full (NULL, NULL, NULL, g_free);
 886 
 887   if (context-&gt;main_group)
 888     {
 889       for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
 890         {
 891           entry = &amp;context-&gt;main_group-&gt;entries[i];
 892           g_hash_table_insert (shadow_map,
 893                                (gpointer)entry-&gt;long_name,
 894                                entry);
 895 
 896           if (seen[(guchar)entry-&gt;short_name])
 897             entry-&gt;short_name = 0;
 898           else
 899             seen[(guchar)entry-&gt;short_name] = TRUE;
 900         }
 901     }
 902 
 903   list = context-&gt;groups;
 904   while (list != NULL)
 905     {
 906       GOptionGroup *g = list-&gt;data;
 907       for (i = 0; i &lt; g-&gt;n_entries; i++)
 908         {
 909           entry = &amp;g-&gt;entries[i];
 910           if (g_hash_table_lookup (shadow_map, entry-&gt;long_name) &amp;&amp;
 911               !(entry-&gt;flags &amp; G_OPTION_FLAG_NOALIAS))
 912             {
 913               g_hash_table_insert (aliases, &amp;entry-&gt;long_name,
 914                                    g_strdup_printf (&quot;%s-%s&quot;, g-&gt;name, entry-&gt;long_name));
 915             }
 916           else
 917             g_hash_table_insert (shadow_map, (gpointer)entry-&gt;long_name, entry);
 918 
 919           if (seen[(guchar)entry-&gt;short_name] &amp;&amp;
 920               !(entry-&gt;flags &amp; G_OPTION_FLAG_NOALIAS))
 921             entry-&gt;short_name = 0;
 922           else
 923             seen[(guchar)entry-&gt;short_name] = TRUE;
 924         }
 925       list = list-&gt;next;
 926     }
 927 
 928   g_hash_table_destroy (shadow_map);
 929 
 930   list = context-&gt;groups;
 931 
 932   if (context-&gt;help_enabled)
 933     {
 934       max_length = _g_utf8_strwidth (&quot;-?, --help&quot;);
 935 
 936       if (list)
 937         {
 938           len = _g_utf8_strwidth (&quot;--help-all&quot;);
 939           max_length = MAX (max_length, len);
 940         }
 941     }
 942 
 943   if (context-&gt;main_group)
 944     {
 945       len = calculate_max_length (context-&gt;main_group, aliases);
 946       max_length = MAX (max_length, len);
 947     }
 948 
 949   while (list != NULL)
 950     {
 951       GOptionGroup *g = list-&gt;data;
 952 
 953       if (context-&gt;help_enabled)
 954         {
 955           /* First, we check the --help-&lt;groupname&gt; options */
 956           len = _g_utf8_strwidth (&quot;--help-&quot;) + _g_utf8_strwidth (g-&gt;name);
 957           max_length = MAX (max_length, len);
 958         }
 959 
 960       /* Then we go through the entries */
 961       len = calculate_max_length (g, aliases);
 962       max_length = MAX (max_length, len);
 963 
 964       list = list-&gt;next;
 965     }
 966 
 967   /* Add a bit of padding */
 968   max_length += 4;
 969 
 970   if (!group &amp;&amp; context-&gt;help_enabled)
 971     {
 972       list = context-&gt;groups;
 973 
 974       token = context_has_h_entry (context) ? &#39;?&#39; : &#39;h&#39;;
 975 
 976       g_string_append_printf (string, &quot;%s\n  -%c, --%-*s %s\n&quot;,
 977                               _(&quot;Help Options:&quot;), token, max_length - 4, &quot;help&quot;,
 978                               _(&quot;Show help options&quot;));
 979 
 980       /* We only want --help-all when there are groups */
 981       if (list)
 982         g_string_append_printf (string, &quot;  --%-*s %s\n&quot;,
 983                                 max_length, &quot;help-all&quot;,
 984                                 _(&quot;Show all help options&quot;));
 985 
 986       while (list)
 987         {
 988           GOptionGroup *g = list-&gt;data;
 989 
 990           if (group_has_visible_entries (context, g, FALSE))
 991             g_string_append_printf (string, &quot;  --help-%-*s %s\n&quot;,
 992                                     max_length - 5, g-&gt;name,
 993                                     TRANSLATE (g, g-&gt;help_description));
 994 
 995           list = list-&gt;next;
 996         }
 997 
 998       g_string_append (string, &quot;\n&quot;);
 999     }
1000 
1001   if (group)
1002     {
1003       /* Print a certain group */
1004 
1005       if (group_has_visible_entries (context, group, FALSE))
1006         {
1007           g_string_append (string, TRANSLATE (group, group-&gt;description));
1008           g_string_append (string, &quot;\n&quot;);
1009           for (i = 0; i &lt; group-&gt;n_entries; i++)
1010             print_entry (group, max_length, &amp;group-&gt;entries[i], string, aliases);
1011           g_string_append (string, &quot;\n&quot;);
1012         }
1013     }
1014   else if (!main_help)
1015     {
1016       /* Print all groups */
1017 
1018       list = context-&gt;groups;
1019 
1020       while (list)
1021         {
1022           GOptionGroup *g = list-&gt;data;
1023 
1024           if (group_has_visible_entries (context, g, FALSE))
1025             {
1026               g_string_append (string, g-&gt;description);
1027               g_string_append (string, &quot;\n&quot;);
1028               for (i = 0; i &lt; g-&gt;n_entries; i++)
1029                 if (!(g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN))
1030                   print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1031 
1032               g_string_append (string, &quot;\n&quot;);
1033             }
1034 
1035           list = list-&gt;next;
1036         }
1037     }
1038 
1039   /* Print application options if --help or --help-all has been specified */
1040   if ((main_help || !group) &amp;&amp;
1041       (group_has_visible_entries (context, context-&gt;main_group, TRUE) ||
1042        group_list_has_visible_entries (context, context-&gt;groups, TRUE)))
1043     {
1044       list = context-&gt;groups;
1045 
1046       if (context-&gt;help_enabled || list)
1047       g_string_append (string,  _(&quot;Application Options:&quot;));
1048       else
1049         g_string_append (string, _(&quot;Options:&quot;));
1050       g_string_append (string, &quot;\n&quot;);
1051       if (context-&gt;main_group)
1052         for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
1053           print_entry (context-&gt;main_group, max_length,
1054                        &amp;context-&gt;main_group-&gt;entries[i], string, aliases);
1055 
1056       while (list != NULL)
1057         {
1058           GOptionGroup *g = list-&gt;data;
1059 
1060           /* Print main entries from other groups */
1061           for (i = 0; i &lt; g-&gt;n_entries; i++)
1062             if (g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN)
1063               print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1064 
1065           list = list-&gt;next;
1066         }
1067 
1068       g_string_append (string, &quot;\n&quot;);
1069     }
1070 
1071   if (context-&gt;description)
1072     {
1073       g_string_append (string, TRANSLATE (context, context-&gt;description));
1074       g_string_append (string, &quot;\n&quot;);
1075     }
1076 
1077   g_hash_table_destroy (aliases);
1078 
1079   return g_string_free (string, FALSE);
1080 }
1081 
1082 G_GNUC_NORETURN
1083 static void
1084 print_help (GOptionContext *context,
1085             gboolean        main_help,
1086             GOptionGroup   *group)
1087 {
1088   gchar *help;
1089 
1090   help = g_option_context_get_help (context, main_help, group);
1091   g_print (&quot;%s&quot;, help);
1092   g_free (help);
1093 
1094   exit (0);
1095 }
1096 
1097 static gboolean
1098 parse_int (const gchar *arg_name,
1099            const gchar *arg,
1100            gint        *result,
1101            GError     **error)
1102 {
1103   gchar *end;
1104   glong tmp;
1105 
1106   errno = 0;
1107   tmp = strtol (arg, &amp;end, 0);
1108 
1109   if (*arg == &#39;\0&#39; || *end != &#39;\0&#39;)
1110     {
1111       g_set_error (error,
1112                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1113                    _(&quot;Cannot parse integer value &#39;%s&#39; for %s&quot;),
1114                    arg, arg_name);
1115       return FALSE;
1116     }
1117 
1118   *result = tmp;
1119   if (*result != tmp || errno == ERANGE)
1120     {
1121       g_set_error (error,
1122                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1123                    _(&quot;Integer value &#39;%s&#39; for %s out of range&quot;),
1124                    arg, arg_name);
1125       return FALSE;
1126     }
1127 
1128   return TRUE;
1129 }
1130 
1131 
1132 static gboolean
1133 parse_double (const gchar *arg_name,
1134            const gchar *arg,
1135            gdouble        *result,
1136            GError     **error)
1137 {
1138   gchar *end;
1139   gdouble tmp;
1140 
1141   errno = 0;
1142   tmp = g_strtod (arg, &amp;end);
1143 
1144   if (*arg == &#39;\0&#39; || *end != &#39;\0&#39;)
1145     {
1146       g_set_error (error,
1147                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1148                    _(&quot;Cannot parse double value &#39;%s&#39; for %s&quot;),
1149                    arg, arg_name);
1150       return FALSE;
1151     }
1152   if (errno == ERANGE)
1153     {
1154       g_set_error (error,
1155                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1156                    _(&quot;Double value &#39;%s&#39; for %s out of range&quot;),
1157                    arg, arg_name);
1158       return FALSE;
1159     }
1160 
1161   *result = tmp;
1162 
1163   return TRUE;
1164 }
1165 
1166 
1167 static gboolean
1168 parse_int64 (const gchar *arg_name,
1169              const gchar *arg,
1170              gint64      *result,
1171              GError     **error)
1172 {
1173   gchar *end;
1174   gint64 tmp;
1175 
1176   errno = 0;
1177   tmp = g_ascii_strtoll (arg, &amp;end, 0);
1178 
1179   if (*arg == &#39;\0&#39; || *end != &#39;\0&#39;)
1180     {
1181       g_set_error (error,
1182                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1183                    _(&quot;Cannot parse integer value &#39;%s&#39; for %s&quot;),
1184                    arg, arg_name);
1185       return FALSE;
1186     }
1187   if (errno == ERANGE)
1188     {
1189       g_set_error (error,
1190                    G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1191                    _(&quot;Integer value &#39;%s&#39; for %s out of range&quot;),
1192                    arg, arg_name);
1193       return FALSE;
1194     }
1195 
1196   *result = tmp;
1197 
1198   return TRUE;
1199 }
1200 
1201 
1202 static Change *
1203 get_change (GOptionContext *context,
1204             GOptionArg      arg_type,
1205             gpointer        arg_data)
1206 {
1207   GList *list;
1208   Change *change = NULL;
1209 
1210   for (list = context-&gt;changes; list != NULL; list = list-&gt;next)
1211     {
1212       change = list-&gt;data;
1213 
1214       if (change-&gt;arg_data == arg_data)
1215         goto found;
1216     }
1217 
1218   change = g_new0 (Change, 1);
1219   change-&gt;arg_type = arg_type;
1220   change-&gt;arg_data = arg_data;
1221 
1222   context-&gt;changes = g_list_prepend (context-&gt;changes, change);
1223 
1224  found:
1225 
1226   return change;
1227 }
1228 
1229 static void
1230 add_pending_null (GOptionContext *context,
1231                   gchar         **ptr,
1232                   gchar          *value)
1233 {
1234   PendingNull *n;
1235 
1236   n = g_new0 (PendingNull, 1);
1237   n-&gt;ptr = ptr;
1238   n-&gt;value = value;
1239 
1240   context-&gt;pending_nulls = g_list_prepend (context-&gt;pending_nulls, n);
1241 }
1242 
1243 static gboolean
1244 parse_arg (GOptionContext *context,
1245            GOptionGroup   *group,
1246            GOptionEntry   *entry,
1247            const gchar    *value,
1248            const gchar    *option_name,
1249            GError        **error)
1250 
1251 {
1252   Change *change;
1253 
1254   g_assert (value || OPTIONAL_ARG (entry) || NO_ARG (entry));
1255 
1256   switch (entry-&gt;arg)
1257     {
1258     case G_OPTION_ARG_NONE:
1259       {
1260         (void) get_change (context, G_OPTION_ARG_NONE,
1261                            entry-&gt;arg_data);
1262 
1263         *(gboolean *)entry-&gt;arg_data = !(entry-&gt;flags &amp; G_OPTION_FLAG_REVERSE);
1264         break;
1265       }
1266     case G_OPTION_ARG_STRING:
1267       {
1268         gchar *data;
1269 
1270 #ifdef G_OS_WIN32
1271         if (!context-&gt;strv_mode)
1272           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1273         else
1274           data = g_strdup (value);
1275 #else
1276         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1277 #endif
1278 
1279         if (!data)
1280           return FALSE;
1281 
1282         change = get_change (context, G_OPTION_ARG_STRING,
1283                              entry-&gt;arg_data);
1284 
1285         if (!change-&gt;allocated.str)
1286           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1287         else
1288         g_free (change-&gt;allocated.str);
1289 
1290         change-&gt;allocated.str = data;
1291 
1292         *(gchar **)entry-&gt;arg_data = data;
1293         break;
1294       }
1295     case G_OPTION_ARG_STRING_ARRAY:
1296       {
1297         gchar *data;
1298 
1299 #ifdef G_OS_WIN32
1300         if (!context-&gt;strv_mode)
1301           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1302         else
1303           data = g_strdup (value);
1304 #else
1305         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1306 #endif
1307 
1308         if (!data)
1309           return FALSE;
1310 
1311         change = get_change (context, G_OPTION_ARG_STRING_ARRAY,
1312                              entry-&gt;arg_data);
1313 
1314         if (change-&gt;allocated.array.len == 0)
1315           {
1316             change-&gt;prev.array = *(gchar ***)entry-&gt;arg_data;
1317             change-&gt;allocated.array.data = g_new (gchar *, 2);
1318           }
1319         else
1320           change-&gt;allocated.array.data =
1321             g_renew (gchar *, change-&gt;allocated.array.data,
1322                      change-&gt;allocated.array.len + 2);
1323 
1324         change-&gt;allocated.array.data[change-&gt;allocated.array.len] = data;
1325         change-&gt;allocated.array.data[change-&gt;allocated.array.len + 1] = NULL;
1326 
1327         change-&gt;allocated.array.len ++;
1328 
1329         *(gchar ***)entry-&gt;arg_data = change-&gt;allocated.array.data;
1330 
1331         break;
1332       }
1333 
1334     case G_OPTION_ARG_FILENAME:
1335       {
1336         gchar *data;
1337 
1338 #ifdef G_OS_WIN32
1339         if (!context-&gt;strv_mode)
1340           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1341         else
1342           data = g_strdup (value);
1343 
1344         if (!data)
1345           return FALSE;
1346 #else
1347         data = g_strdup (value);
1348 #endif
1349         change = get_change (context, G_OPTION_ARG_FILENAME,
1350                              entry-&gt;arg_data);
1351 
1352         if (!change-&gt;allocated.str)
1353           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1354         else
1355         g_free (change-&gt;allocated.str);
1356 
1357         change-&gt;allocated.str = data;
1358 
1359         *(gchar **)entry-&gt;arg_data = data;
1360         break;
1361       }
1362 
1363     case G_OPTION_ARG_FILENAME_ARRAY:
1364       {
1365         gchar *data;
1366 
1367 #ifdef G_OS_WIN32
1368         if (!context-&gt;strv_mode)
1369           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1370         else
1371           data = g_strdup (value);
1372 
1373         if (!data)
1374           return FALSE;
1375 #else
1376         data = g_strdup (value);
1377 #endif
1378         change = get_change (context, G_OPTION_ARG_STRING_ARRAY,
1379                              entry-&gt;arg_data);
1380 
1381         if (change-&gt;allocated.array.len == 0)
1382           {
1383             change-&gt;prev.array = *(gchar ***)entry-&gt;arg_data;
1384             change-&gt;allocated.array.data = g_new (gchar *, 2);
1385           }
1386         else
1387           change-&gt;allocated.array.data =
1388             g_renew (gchar *, change-&gt;allocated.array.data,
1389                      change-&gt;allocated.array.len + 2);
1390 
1391         change-&gt;allocated.array.data[change-&gt;allocated.array.len] = data;
1392         change-&gt;allocated.array.data[change-&gt;allocated.array.len + 1] = NULL;
1393 
1394         change-&gt;allocated.array.len ++;
1395 
1396         *(gchar ***)entry-&gt;arg_data = change-&gt;allocated.array.data;
1397 
1398         break;
1399       }
1400 
1401     case G_OPTION_ARG_INT:
1402       {
1403         gint data;
1404 
1405         if (!parse_int (option_name, value,
1406                         &amp;data,
1407                         error))
1408           return FALSE;
1409 
1410         change = get_change (context, G_OPTION_ARG_INT,
1411                              entry-&gt;arg_data);
1412         change-&gt;prev.integer = *(gint *)entry-&gt;arg_data;
1413         *(gint *)entry-&gt;arg_data = data;
1414         break;
1415       }
1416     case G_OPTION_ARG_CALLBACK:
1417       {
1418         gchar *data;
1419         gboolean retval;
1420 
1421         if (!value &amp;&amp; entry-&gt;flags &amp; G_OPTION_FLAG_OPTIONAL_ARG)
1422           data = NULL;
1423         else if (entry-&gt;flags &amp; G_OPTION_FLAG_NO_ARG)
1424           data = NULL;
1425         else if (entry-&gt;flags &amp; G_OPTION_FLAG_FILENAME)
1426           {
1427 #ifdef G_OS_WIN32
1428             if (!context-&gt;strv_mode)
1429               data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1430             else
1431               data = g_strdup (value);
1432 #else
1433             data = g_strdup (value);
1434 #endif
1435           }
1436         else
1437           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1438 
1439         if (!(entry-&gt;flags &amp; (G_OPTION_FLAG_NO_ARG|G_OPTION_FLAG_OPTIONAL_ARG)) &amp;&amp;
1440             !data)
1441           return FALSE;
1442 
1443         retval = (* (GOptionArgFunc) entry-&gt;arg_data) (option_name, data, group-&gt;user_data, error);
1444 
1445         if (!retval &amp;&amp; error != NULL &amp;&amp; *error == NULL)
1446           g_set_error (error,
1447                        G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
1448                        _(&quot;Error parsing option %s&quot;), option_name);
1449 
1450         g_free (data);
1451 
1452         return retval;
1453 
1454         break;
1455       }
1456     case G_OPTION_ARG_DOUBLE:
1457       {
1458         gdouble data;
1459 
1460         if (!parse_double (option_name, value,
1461                         &amp;data,
1462                         error))
1463           {
1464             return FALSE;
1465           }
1466 
1467         change = get_change (context, G_OPTION_ARG_DOUBLE,
1468                              entry-&gt;arg_data);
1469         change-&gt;prev.dbl = *(gdouble *)entry-&gt;arg_data;
1470         *(gdouble *)entry-&gt;arg_data = data;
1471         break;
1472       }
1473     case G_OPTION_ARG_INT64:
1474       {
1475         gint64 data;
1476 
1477         if (!parse_int64 (option_name, value,
1478                          &amp;data,
1479                          error))
1480           {
1481             return FALSE;
1482           }
1483 
1484         change = get_change (context, G_OPTION_ARG_INT64,
1485                              entry-&gt;arg_data);
1486         change-&gt;prev.int64 = *(gint64 *)entry-&gt;arg_data;
1487         *(gint64 *)entry-&gt;arg_data = data;
1488         break;
1489       }
1490     default:
1491       g_assert_not_reached ();
1492     }
1493 
1494   return TRUE;
1495 }
1496 
1497 static gboolean
1498 parse_short_option (GOptionContext *context,
1499                     GOptionGroup   *group,
1500                     gint            idx,
1501                     gint           *new_idx,
1502                     gchar           arg,
1503                     gint           *argc,
1504                     gchar        ***argv,
1505                     GError        **error,
1506                     gboolean       *parsed)
1507 {
1508   gint j;
1509 
1510   for (j = 0; j &lt; group-&gt;n_entries; j++)
1511     {
1512       if (arg == group-&gt;entries[j].short_name)
1513         {
1514           gchar *option_name;
1515           gchar *value = NULL;
1516 
1517           option_name = g_strdup_printf (&quot;-%c&quot;, group-&gt;entries[j].short_name);
1518 
1519           if (NO_ARG (&amp;group-&gt;entries[j]))
1520             value = NULL;
1521           else
1522             {
1523               if (*new_idx &gt; idx)
1524                 {
1525                   g_set_error (error,
1526                                G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
1527                                _(&quot;Error parsing option %s&quot;), option_name);
1528                   g_free (option_name);
1529                   return FALSE;
1530                 }
1531 
1532               if (idx &lt; *argc - 1)
1533                 {
1534                   if (!OPTIONAL_ARG (&amp;group-&gt;entries[j]))
1535                     {
1536                       value = (*argv)[idx + 1];
1537                       add_pending_null (context, &amp;((*argv)[idx + 1]), NULL);
1538                       *new_idx = idx + 1;
1539                     }
1540                   else
1541                     {
1542                       if ((*argv)[idx + 1][0] == &#39;-&#39;)
1543                         value = NULL;
1544                       else
1545                         {
1546                           value = (*argv)[idx + 1];
1547                           add_pending_null (context, &amp;((*argv)[idx + 1]), NULL);
1548                           *new_idx = idx + 1;
1549                         }
1550                     }
1551                 }
1552               else if (idx &gt;= *argc - 1 &amp;&amp; OPTIONAL_ARG (&amp;group-&gt;entries[j]))
1553                 value = NULL;
1554               else
1555                 {
1556                   g_set_error (error,
1557                                G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1558                                _(&quot;Missing argument for %s&quot;), option_name);
1559                   g_free (option_name);
1560                   return FALSE;
1561                 }
1562             }
1563 
1564           if (!parse_arg (context, group, &amp;group-&gt;entries[j],
1565                           value, option_name, error))
1566             {
1567               g_free (option_name);
1568               return FALSE;
1569             }
1570 
1571           g_free (option_name);
1572           *parsed = TRUE;
1573         }
1574     }
1575 
1576   return TRUE;
1577 }
1578 
1579 static gboolean
1580 parse_long_option (GOptionContext *context,
1581                    GOptionGroup   *group,
1582                    gint           *idx,
1583                    gchar          *arg,
1584                    gboolean        aliased,
1585                    gint           *argc,
1586                    gchar        ***argv,
1587                    GError        **error,
1588                    gboolean       *parsed)
1589 {
1590   gint j;
1591 
1592   for (j = 0; j &lt; group-&gt;n_entries; j++)
1593     {
1594       if (*idx &gt;= *argc)
1595         return TRUE;
1596 
1597       if (aliased &amp;&amp; (group-&gt;entries[j].flags &amp; G_OPTION_FLAG_NOALIAS))
1598         continue;
1599 
1600       if (NO_ARG (&amp;group-&gt;entries[j]) &amp;&amp;
1601           strcmp (arg, group-&gt;entries[j].long_name) == 0)
1602         {
1603           gchar *option_name;
1604           gboolean retval;
1605 
1606           option_name = g_strconcat (&quot;--&quot;, group-&gt;entries[j].long_name, NULL);
1607           retval = parse_arg (context, group, &amp;group-&gt;entries[j],
1608                               NULL, option_name, error);
1609           g_free (option_name);
1610 
1611           add_pending_null (context, &amp;((*argv)[*idx]), NULL);
1612           *parsed = TRUE;
1613 
1614           return retval;
1615         }
1616       else
1617         {
1618           gint len = strlen (group-&gt;entries[j].long_name);
1619 
1620           if (strncmp (arg, group-&gt;entries[j].long_name, len) == 0 &amp;&amp;
1621               (arg[len] == &#39;=&#39; || arg[len] == 0))
1622             {
1623               gchar *value = NULL;
1624               gchar *option_name;
1625 
1626               add_pending_null (context, &amp;((*argv)[*idx]), NULL);
1627               option_name = g_strconcat (&quot;--&quot;, group-&gt;entries[j].long_name, NULL);
1628 
1629               if (arg[len] == &#39;=&#39;)
1630                 value = arg + len + 1;
1631               else if (*idx &lt; *argc - 1)
1632                 {
1633                   if (!OPTIONAL_ARG (&amp;group-&gt;entries[j]))
1634                     {
1635                       value = (*argv)[*idx + 1];
1636                       add_pending_null (context, &amp;((*argv)[*idx + 1]), NULL);
1637                       (*idx)++;
1638                     }
1639                   else
1640                     {
1641                       if ((*argv)[*idx + 1][0] == &#39;-&#39;)
1642                         {
1643                           gboolean retval;
1644                           retval = parse_arg (context, group, &amp;group-&gt;entries[j],
1645                                               NULL, option_name, error);
1646                           *parsed = TRUE;
1647                           g_free (option_name);
1648                           return retval;
1649                         }
1650                       else
1651                         {
1652                           value = (*argv)[*idx + 1];
1653                           add_pending_null (context, &amp;((*argv)[*idx + 1]), NULL);
1654                           (*idx)++;
1655                         }
1656                     }
1657                 }
1658               else if (*idx &gt;= *argc - 1 &amp;&amp; OPTIONAL_ARG (&amp;group-&gt;entries[j]))
1659                 {
1660                     gboolean retval;
1661                     retval = parse_arg (context, group, &amp;group-&gt;entries[j],
1662                                         NULL, option_name, error);
1663                     *parsed = TRUE;
1664                     g_free (option_name);
1665                     return retval;
1666                 }
1667               else
1668                 {
1669                   g_set_error (error,
1670                                G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,
1671                                _(&quot;Missing argument for %s&quot;), option_name);
1672                   g_free (option_name);
1673                   return FALSE;
1674                 }
1675 
1676               if (!parse_arg (context, group, &amp;group-&gt;entries[j],
1677                               value, option_name, error))
1678                 {
1679                   g_free (option_name);
1680                   return FALSE;
1681                 }
1682 
1683               g_free (option_name);
1684               *parsed = TRUE;
1685             }
1686         }
1687     }
1688 
1689   return TRUE;
1690 }
1691 
1692 static gboolean
1693 parse_remaining_arg (GOptionContext *context,
1694                      GOptionGroup   *group,
1695                      gint           *idx,
1696                      gint           *argc,
1697                      gchar        ***argv,
1698                      GError        **error,
1699                      gboolean       *parsed)
1700 {
1701   gint j;
1702 
1703   for (j = 0; j &lt; group-&gt;n_entries; j++)
1704     {
1705       if (*idx &gt;= *argc)
1706         return TRUE;
1707 
1708       if (group-&gt;entries[j].long_name[0])
1709         continue;
1710 
1711       g_return_val_if_fail (group-&gt;entries[j].arg == G_OPTION_ARG_CALLBACK ||
1712                             group-&gt;entries[j].arg == G_OPTION_ARG_STRING_ARRAY ||
1713                             group-&gt;entries[j].arg == G_OPTION_ARG_FILENAME_ARRAY, FALSE);
1714 
1715       add_pending_null (context, &amp;((*argv)[*idx]), NULL);
1716 
1717       if (!parse_arg (context, group, &amp;group-&gt;entries[j], (*argv)[*idx], &quot;&quot;, error))
1718         return FALSE;
1719 
1720       *parsed = TRUE;
1721       return TRUE;
1722     }
1723 
1724   return TRUE;
1725 }
1726 
1727 static void
1728 free_changes_list (GOptionContext *context,
1729                    gboolean        revert)
1730 {
1731   GList *list;
1732 
1733   for (list = context-&gt;changes; list != NULL; list = list-&gt;next)
1734     {
1735       Change *change = list-&gt;data;
1736 
1737       if (revert)
1738         {
1739           switch (change-&gt;arg_type)
1740             {
1741             case G_OPTION_ARG_NONE:
1742               *(gboolean *)change-&gt;arg_data = change-&gt;prev.bool;
1743               break;
1744             case G_OPTION_ARG_INT:
1745               *(gint *)change-&gt;arg_data = change-&gt;prev.integer;
1746               break;
1747             case G_OPTION_ARG_STRING:
1748             case G_OPTION_ARG_FILENAME:
1749               g_free (change-&gt;allocated.str);
1750               *(gchar **)change-&gt;arg_data = change-&gt;prev.str;
1751               break;
1752             case G_OPTION_ARG_STRING_ARRAY:
1753             case G_OPTION_ARG_FILENAME_ARRAY:
1754               g_strfreev (change-&gt;allocated.array.data);
1755               *(gchar ***)change-&gt;arg_data = change-&gt;prev.array;
1756               break;
1757             case G_OPTION_ARG_DOUBLE:
1758               *(gdouble *)change-&gt;arg_data = change-&gt;prev.dbl;
1759               break;
1760             case G_OPTION_ARG_INT64:
1761               *(gint64 *)change-&gt;arg_data = change-&gt;prev.int64;
1762               break;
1763             default:
1764               g_assert_not_reached ();
1765             }
1766         }
1767 
1768       g_free (change);
1769     }
1770 
1771   g_list_free (context-&gt;changes);
1772   context-&gt;changes = NULL;
1773 }
1774 
1775 static void
1776 free_pending_nulls (GOptionContext *context,
1777                     gboolean        perform_nulls)
1778 {
1779   GList *list;
1780 
1781   for (list = context-&gt;pending_nulls; list != NULL; list = list-&gt;next)
1782     {
1783       PendingNull *n = list-&gt;data;
1784 
1785       if (perform_nulls)
1786         {
1787           if (n-&gt;value)
1788             {
1789               /* Copy back the short options */
1790               *(n-&gt;ptr)[0] = &#39;-&#39;;
1791               strcpy (*n-&gt;ptr + 1, n-&gt;value);
1792             }
1793           else
1794             {
1795               if (context-&gt;strv_mode)
1796                 g_free (*n-&gt;ptr);
1797 
1798               *n-&gt;ptr = NULL;
1799             }
1800         }
1801 
1802       g_free (n-&gt;value);
1803       g_free (n);
1804     }
1805 
1806   g_list_free (context-&gt;pending_nulls);
1807   context-&gt;pending_nulls = NULL;
1808 }
1809 
1810 /* Use a platform-specific mechanism to look up the first argument to
1811  * the current process.
1812  * Note if you implement this for other platforms, also add it to
1813  * tests/option-argv0.c
1814  */
1815 static char *
1816 platform_get_argv0 (void)
1817 {
1818 #if defined __linux
1819   char *cmdline;
1820   char *base_arg0;
1821   gsize len;
1822 
1823   if (!g_file_get_contents (&quot;/proc/self/cmdline&quot;,
1824                 &amp;cmdline,
1825                 &amp;len,
1826                 NULL))
1827     return NULL;
1828   /* Sanity check for a NUL terminator. */
1829   if (!memchr (cmdline, 0, len))
1830     return NULL;
1831   /* We could just return cmdline, but I think it&#39;s better
1832    * to hold on to a smaller malloc block; the arguments
1833    * could be large.
1834    */
1835   base_arg0 = g_path_get_basename (cmdline);
1836   g_free (cmdline);
1837   return base_arg0;
1838 #elif defined __OpenBSD__
1839   char **cmdline;
1840   char *base_arg0;
1841   gsize len;
1842 
1843   int mib[] = { CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ARGV };
1844 
1845   if (sysctl (mib, G_N_ELEMENTS (mib), NULL, &amp;len, NULL, 0) == -1)
1846       return NULL;
1847 
1848   cmdline = g_malloc0 (len);
1849 
1850   if (sysctl (mib, G_N_ELEMENTS (mib), cmdline, &amp;len, NULL, 0) == -1)
1851     {
1852       g_free (cmdline);
1853       return NULL;
1854     }
1855 
1856   /* We could just return cmdline, but I think it&#39;s better
1857    * to hold on to a smaller malloc block; the arguments
1858    * could be large.
1859    */
1860   base_arg0 = g_path_get_basename (*cmdline);
1861   g_free (cmdline);
1862   return base_arg0;
1863 #endif
1864 
1865   return NULL;
1866 }
1867 
1868 /**
1869  * g_option_context_parse:
1870  * @context: a #GOptionContext
1871  * @argc: (inout) (optional): a pointer to the number of command line arguments
1872  * @argv: (inout) (array length=argc) (optional): a pointer to the array of command line arguments
1873  * @error: a return location for errors
1874  *
1875  * Parses the command line arguments, recognizing options
1876  * which have been added to @context. A side-effect of
1877  * calling this function is that g_set_prgname() will be
1878  * called.
1879  *
1880  * If the parsing is successful, any parsed arguments are
1881  * removed from the array and @argc and @argv are updated
1882  * accordingly. A &#39;--&#39; option is stripped from @argv
1883  * unless there are unparsed options before and after it,
1884  * or some of the options after it start with &#39;-&#39;. In case
1885  * of an error, @argc and @argv are left unmodified.
1886  *
1887  * If automatic `--help` support is enabled
1888  * (see g_option_context_set_help_enabled()), and the
1889  * @argv array contains one of the recognized help options,
1890  * this function will produce help output to stdout and
1891  * call `exit (0)`.
1892  *
1893  * Note that function depends on the [current locale][setlocale] for
1894  * automatic character set conversion of string and filename
1895  * arguments.
1896  *
1897  * Returns: %TRUE if the parsing was successful,
1898  *               %FALSE if an error occurred
1899  *
1900  * Since: 2.6
1901  **/
1902 gboolean
1903 g_option_context_parse (GOptionContext   *context,
1904                         gint             *argc,
1905                         gchar          ***argv,
1906                         GError          **error)
1907 {
1908   gint i, j, k;
1909   GList *list;
1910 
1911   /* Set program name */
1912   if (!g_get_prgname())
1913     {
1914       gchar *prgname;
1915 
1916       if (argc &amp;&amp; argv &amp;&amp; *argc)
1917     prgname = g_path_get_basename ((*argv)[0]);
1918       else
1919     prgname = platform_get_argv0 ();
1920 
1921       if (prgname)
1922     g_set_prgname (prgname);
1923       else
1924     g_set_prgname (&quot;&lt;unknown&gt;&quot;);
1925 
1926       g_free (prgname);
1927     }
1928 
1929   /* Call pre-parse hooks */
1930   list = context-&gt;groups;
1931   while (list)
1932     {
1933       GOptionGroup *group = list-&gt;data;
1934 
1935       if (group-&gt;pre_parse_func)
1936         {
1937           if (!(* group-&gt;pre_parse_func) (context, group,
1938                                           group-&gt;user_data, error))
1939             goto fail;
1940         }
1941 
1942       list = list-&gt;next;
1943     }
1944 
1945   if (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;pre_parse_func)
1946     {
1947       if (!(* context-&gt;main_group-&gt;pre_parse_func) (context, context-&gt;main_group,
1948                                                     context-&gt;main_group-&gt;user_data, error))
1949         goto fail;
1950     }
1951 
1952   if (argc &amp;&amp; argv)
1953     {
1954       gboolean stop_parsing = FALSE;
1955       gboolean has_unknown = FALSE;
1956       gint separator_pos = 0;
1957 
1958       for (i = 1; i &lt; *argc; i++)
1959         {
1960           gchar *arg, *dash;
1961           gboolean parsed = FALSE;
1962 
1963           if ((*argv)[i][0] == &#39;-&#39; &amp;&amp; (*argv)[i][1] != &#39;\0&#39; &amp;&amp; !stop_parsing)
1964             {
1965               if ((*argv)[i][1] == &#39;-&#39;)
1966                 {
1967                   /* -- option */
1968 
1969                   arg = (*argv)[i] + 2;
1970 
1971                   /* &#39;--&#39; terminates list of arguments */
1972                   if (*arg == 0)
1973                     {
1974                       separator_pos = i;
1975                       stop_parsing = TRUE;
1976                       continue;
1977                     }
1978 
1979                   /* Handle help options */
1980                   if (context-&gt;help_enabled)
1981                     {
1982                       if (strcmp (arg, &quot;help&quot;) == 0)
1983                         print_help (context, TRUE, NULL);
1984                       else if (strcmp (arg, &quot;help-all&quot;) == 0)
1985                         print_help (context, FALSE, NULL);
1986                       else if (strncmp (arg, &quot;help-&quot;, 5) == 0)
1987                         {
1988                           list = context-&gt;groups;
1989 
1990                           while (list)
1991                             {
1992                               GOptionGroup *group = list-&gt;data;
1993 
1994                               if (strcmp (arg + 5, group-&gt;name) == 0)
1995                                 print_help (context, FALSE, group);
1996 
1997                               list = list-&gt;next;
1998                             }
1999                         }
2000                     }
2001 
2002                   if (context-&gt;main_group &amp;&amp;
2003                       !parse_long_option (context, context-&gt;main_group, &amp;i, arg,
2004                                           FALSE, argc, argv, error, &amp;parsed))
2005                     goto fail;
2006 
2007                   if (parsed)
2008                     continue;
2009 
2010                   /* Try the groups */
2011                   list = context-&gt;groups;
2012                   while (list)
2013                     {
2014                       GOptionGroup *group = list-&gt;data;
2015 
2016                       if (!parse_long_option (context, group, &amp;i, arg,
2017                                               FALSE, argc, argv, error, &amp;parsed))
2018                         goto fail;
2019 
2020                       if (parsed)
2021                         break;
2022 
2023                       list = list-&gt;next;
2024                     }
2025 
2026                   if (parsed)
2027                     continue;
2028 
2029                   /* Now look for --&lt;group&gt;-&lt;option&gt; */
2030                   dash = strchr (arg, &#39;-&#39;);
2031                   if (dash &amp;&amp; arg &lt; dash)
2032                     {
2033                       /* Try the groups */
2034                       list = context-&gt;groups;
2035                       while (list)
2036                         {
2037                           GOptionGroup *group = list-&gt;data;
2038 
2039                           if (strncmp (group-&gt;name, arg, dash - arg) == 0)
2040                             {
2041                               if (!parse_long_option (context, group, &amp;i, dash + 1,
2042                                                       TRUE, argc, argv, error, &amp;parsed))
2043                                 goto fail;
2044 
2045                               if (parsed)
2046                                 break;
2047                             }
2048 
2049                           list = list-&gt;next;
2050                         }
2051                     }
2052 
2053                   if (context-&gt;ignore_unknown)
2054                     continue;
2055                 }
2056               else
2057                 { /* short option */
2058                   gint new_i = i, arg_length;
2059                   gboolean *nulled_out = NULL;
2060                   gboolean has_h_entry = context_has_h_entry (context);
2061                   arg = (*argv)[i] + 1;
2062                   arg_length = strlen (arg);
2063                   nulled_out = g_newa (gboolean, arg_length);
2064                   memset (nulled_out, 0, arg_length * sizeof (gboolean));
2065                   for (j = 0; j &lt; arg_length; j++)
2066                     {
2067                       if (context-&gt;help_enabled &amp;&amp; (arg[j] == &#39;?&#39; ||
2068                         (arg[j] == &#39;h&#39; &amp;&amp; !has_h_entry)))
2069                         print_help (context, TRUE, NULL);
2070                       parsed = FALSE;
2071                       if (context-&gt;main_group &amp;&amp;
2072                           !parse_short_option (context, context-&gt;main_group,
2073                                                i, &amp;new_i, arg[j],
2074                                                argc, argv, error, &amp;parsed))
2075                         goto fail;
2076                       if (!parsed)
2077                         {
2078                           /* Try the groups */
2079                           list = context-&gt;groups;
2080                           while (list)
2081                             {
2082                               GOptionGroup *group = list-&gt;data;
2083                               if (!parse_short_option (context, group, i, &amp;new_i, arg[j],
2084                                                        argc, argv, error, &amp;parsed))
2085                                 goto fail;
2086                               if (parsed)
2087                                 break;
2088                               list = list-&gt;next;
2089                             }
2090                         }
2091 
2092                       if (context-&gt;ignore_unknown &amp;&amp; parsed)
2093                         nulled_out[j] = TRUE;
2094                       else if (context-&gt;ignore_unknown)
2095                         continue;
2096                       else if (!parsed)
2097                         break;
2098                       /* !context-&gt;ignore_unknown &amp;&amp; parsed */
2099                     }
2100                   if (context-&gt;ignore_unknown)
2101                     {
2102                       gchar *new_arg = NULL;
2103                       gint arg_index = 0;
2104                       for (j = 0; j &lt; arg_length; j++)
2105                         {
2106                           if (!nulled_out[j])
2107                             {
2108                               if (!new_arg)
2109                                 new_arg = g_malloc (arg_length + 1);
2110                               new_arg[arg_index++] = arg[j];
2111                             }
2112                         }
2113                       if (new_arg)
2114                         new_arg[arg_index] = &#39;\0&#39;;
2115                       add_pending_null (context, &amp;((*argv)[i]), new_arg);
2116                       i = new_i;
2117                     }
2118                   else if (parsed)
2119                     {
2120                       add_pending_null (context, &amp;((*argv)[i]), NULL);
2121                       i = new_i;
2122                     }
2123                 }
2124 
2125               if (!parsed)
2126                 has_unknown = TRUE;
2127 
2128               if (!parsed &amp;&amp; !context-&gt;ignore_unknown)
2129                 {
2130                   g_set_error (error,
2131                                G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
2132                                    _(&quot;Unknown option %s&quot;), (*argv)[i]);
2133                   goto fail;
2134                 }
2135             }
2136           else
2137             {
2138               if (context-&gt;strict_posix)
2139                 stop_parsing = TRUE;
2140 
2141               /* Collect remaining args */
2142               if (context-&gt;main_group &amp;&amp;
2143                   !parse_remaining_arg (context, context-&gt;main_group, &amp;i,
2144                                         argc, argv, error, &amp;parsed))
2145                 goto fail;
2146 
2147               if (!parsed &amp;&amp; (has_unknown || (*argv)[i][0] == &#39;-&#39;))
2148                 separator_pos = 0;
2149             }
2150         }
2151 
2152       if (separator_pos &gt; 0)
2153         add_pending_null (context, &amp;((*argv)[separator_pos]), NULL);
2154 
2155     }
2156 
2157   /* Call post-parse hooks */
2158   list = context-&gt;groups;
2159   while (list)
2160     {
2161       GOptionGroup *group = list-&gt;data;
2162 
2163       if (group-&gt;post_parse_func)
2164         {
2165           if (!(* group-&gt;post_parse_func) (context, group,
2166                                            group-&gt;user_data, error))
2167             goto fail;
2168         }
2169 
2170       list = list-&gt;next;
2171     }
2172 
2173   if (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;post_parse_func)
2174     {
2175       if (!(* context-&gt;main_group-&gt;post_parse_func) (context, context-&gt;main_group,
2176                                                      context-&gt;main_group-&gt;user_data, error))
2177         goto fail;
2178     }
2179 
2180   if (argc &amp;&amp; argv)
2181     {
2182       free_pending_nulls (context, TRUE);
2183 
2184       for (i = 1; i &lt; *argc; i++)
2185         {
2186           for (k = i; k &lt; *argc; k++)
2187             if ((*argv)[k] != NULL)
2188               break;
2189 
2190           if (k &gt; i)
2191             {
2192               k -= i;
2193               for (j = i + k; j &lt; *argc; j++)
2194                 {
2195                   (*argv)[j-k] = (*argv)[j];
2196                   (*argv)[j] = NULL;
2197                 }
2198               *argc -= k;
2199             }
2200         }
2201     }
2202 
2203   return TRUE;
2204 
2205  fail:
2206 
2207   /* Call error hooks */
2208   list = context-&gt;groups;
2209   while (list)
2210     {
2211       GOptionGroup *group = list-&gt;data;
2212 
2213       if (group-&gt;error_func)
2214         (* group-&gt;error_func) (context, group,
2215                                group-&gt;user_data, error);
2216 
2217       list = list-&gt;next;
2218     }
2219 
2220   if (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;error_func)
2221     (* context-&gt;main_group-&gt;error_func) (context, context-&gt;main_group,
2222                                          context-&gt;main_group-&gt;user_data, error);
2223 
2224   free_changes_list (context, TRUE);
2225   free_pending_nulls (context, FALSE);
2226 
2227   return FALSE;
2228 }
2229 
2230 /**
2231  * g_option_group_new:
2232  * @name: the name for the option group, this is used to provide
2233  *   help for the options in this group with `--help-`@name
2234  * @description: a description for this group to be shown in
2235  *   `--help`. This string is translated using the translation
2236  *   domain or translation function of the group
2237  * @help_description: a description for the `--help-`@name option.
2238  *   This string is translated using the translation domain or translation function
2239  *   of the group
2240  * @user_data: (nullable): user data that will be passed to the pre- and post-parse hooks,
2241  *   the error hook and to callbacks of %G_OPTION_ARG_CALLBACK options, or %NULL
2242  * @destroy: (nullable): a function that will be called to free @user_data, or %NULL
2243  *
2244  * Creates a new #GOptionGroup.
2245  *
2246  * Returns: a newly created option group. It should be added
2247  *   to a #GOptionContext or freed with g_option_group_unref().
2248  *
2249  * Since: 2.6
2250  **/
2251 GOptionGroup *
2252 g_option_group_new (const gchar    *name,
2253                     const gchar    *description,
2254                     const gchar    *help_description,
2255                     gpointer        user_data,
2256                     GDestroyNotify  destroy)
2257 
2258 {
2259   GOptionGroup *group;
2260 
2261   group = g_new0 (GOptionGroup, 1);
2262   group-&gt;ref_count = 1;
2263   group-&gt;name = g_strdup (name);
2264   group-&gt;description = g_strdup (description);
2265   group-&gt;help_description = g_strdup (help_description);
2266   group-&gt;user_data = user_data;
2267   group-&gt;destroy_notify = destroy;
2268 
2269   return group;
2270 }
2271 
2272 
2273 /**
2274  * g_option_group_free:
2275  * @group: a #GOptionGroup
2276  *
2277  * Frees a #GOptionGroup. Note that you must not free groups
2278  * which have been added to a #GOptionContext.
2279  *
2280  * Since: 2.6
2281  *
2282  * Deprecated: 2.44: Use g_option_group_unref() instead.
2283  */
2284 void
2285 g_option_group_free (GOptionGroup *group)
2286 {
2287   g_option_group_unref (group);
2288 }
2289 
2290 /**
2291  * g_option_group_ref:
2292  * @group: a #GOptionGroup
2293  *
2294  * Increments the reference count of @group by one.
2295  *
2296  * Returns: a #GOptionGroup
2297  *
2298  * Since: 2.44
2299  */
2300 GOptionGroup *
2301 g_option_group_ref (GOptionGroup *group)
2302 {
2303   g_return_val_if_fail (group != NULL, NULL);
2304 
2305   group-&gt;ref_count++;
2306 
2307   return group;
2308 }
2309 
2310 /**
2311  * g_option_group_unref:
2312  * @group: a #GOptionGroup
2313  *
2314  * Decrements the reference count of @group by one.
2315  * If the reference count drops to 0, the @group will be freed.
2316  * and all memory allocated by the @group is released.
2317  *
2318  * Since: 2.44
2319  */
2320 void
2321 g_option_group_unref (GOptionGroup *group)
2322 {
2323   g_return_if_fail (group != NULL);
2324 
2325   if (--group-&gt;ref_count == 0)
2326     {
2327   g_free (group-&gt;name);
2328   g_free (group-&gt;description);
2329   g_free (group-&gt;help_description);
2330 
2331   g_free (group-&gt;entries);
2332 
2333   if (group-&gt;destroy_notify)
2334     (* group-&gt;destroy_notify) (group-&gt;user_data);
2335 
2336   if (group-&gt;translate_notify)
2337     (* group-&gt;translate_notify) (group-&gt;translate_data);
2338 
2339   g_free (group);
2340 }
2341 }
2342 
2343 /**
2344  * g_option_group_add_entries:
2345  * @group: a #GOptionGroup
2346  * @entries: a %NULL-terminated array of #GOptionEntrys
2347  *
2348  * Adds the options specified in @entries to @group.
2349  *
2350  * Since: 2.6
2351  **/
2352 void
2353 g_option_group_add_entries (GOptionGroup       *group,
2354                             const GOptionEntry *entries)
2355 {
2356   gint i, n_entries;
2357 
2358   g_return_if_fail (entries != NULL);
2359 
2360   for (n_entries = 0; entries[n_entries].long_name != NULL; n_entries++) ;
2361 
2362   group-&gt;entries = g_renew (GOptionEntry, group-&gt;entries, group-&gt;n_entries + n_entries);
2363 
2364   /* group-&gt;entries could be NULL in the trivial case where we add no
2365    * entries to no entries */
2366   if (n_entries != 0)
2367   memcpy (group-&gt;entries + group-&gt;n_entries, entries, sizeof (GOptionEntry) * n_entries);
2368 
2369   for (i = group-&gt;n_entries; i &lt; group-&gt;n_entries + n_entries; i++)
2370     {
2371       gchar c = group-&gt;entries[i].short_name;
2372 
2373       if (c == &#39;-&#39; || (c != 0 &amp;&amp; !g_ascii_isprint (c)))
2374         {
2375           g_warning (G_STRLOC &quot;: ignoring invalid short option &#39;%c&#39; (%d) in entry %s:%s&quot;,
2376               c, c, group-&gt;name, group-&gt;entries[i].long_name);
2377           group-&gt;entries[i].short_name = &#39;\0&#39;;
2378         }
2379 
2380       if (group-&gt;entries[i].arg != G_OPTION_ARG_NONE &amp;&amp;
2381           (group-&gt;entries[i].flags &amp; G_OPTION_FLAG_REVERSE) != 0)
2382         {
2383           g_warning (G_STRLOC &quot;: ignoring reverse flag on option of arg-type %d in entry %s:%s&quot;,
2384               group-&gt;entries[i].arg, group-&gt;name, group-&gt;entries[i].long_name);
2385 
2386           group-&gt;entries[i].flags &amp;= ~G_OPTION_FLAG_REVERSE;
2387         }
2388 
2389       if (group-&gt;entries[i].arg != G_OPTION_ARG_CALLBACK &amp;&amp;
2390           (group-&gt;entries[i].flags &amp; (G_OPTION_FLAG_NO_ARG|G_OPTION_FLAG_OPTIONAL_ARG|G_OPTION_FLAG_FILENAME)) != 0)
2391         {
2392           g_warning (G_STRLOC &quot;: ignoring no-arg, optional-arg or filename flags (%d) on option of arg-type %d in entry %s:%s&quot;,
2393               group-&gt;entries[i].flags, group-&gt;entries[i].arg, group-&gt;name, group-&gt;entries[i].long_name);
2394 
2395           group-&gt;entries[i].flags &amp;= ~(G_OPTION_FLAG_NO_ARG|G_OPTION_FLAG_OPTIONAL_ARG|G_OPTION_FLAG_FILENAME);
2396         }
2397     }
2398 
2399   group-&gt;n_entries += n_entries;
2400 }
2401 
2402 /**
2403  * g_option_group_set_parse_hooks:
2404  * @group: a #GOptionGroup
2405  * @pre_parse_func: (nullable): a function to call before parsing, or %NULL
2406  * @post_parse_func: (nullable): a function to call after parsing, or %NULL
2407  *
2408  * Associates two functions with @group which will be called
2409  * from g_option_context_parse() before the first option is parsed
2410  * and after the last option has been parsed, respectively.
2411  *
2412  * Note that the user data to be passed to @pre_parse_func and
2413  * @post_parse_func can be specified when constructing the group
2414  * with g_option_group_new().
2415  *
2416  * Since: 2.6
2417  **/
2418 void
2419 g_option_group_set_parse_hooks (GOptionGroup     *group,
2420                                 GOptionParseFunc  pre_parse_func,
2421                                 GOptionParseFunc  post_parse_func)
2422 {
2423   g_return_if_fail (group != NULL);
2424 
2425   group-&gt;pre_parse_func = pre_parse_func;
2426   group-&gt;post_parse_func = post_parse_func;
2427 }
2428 
2429 /**
2430  * g_option_group_set_error_hook:
2431  * @group: a #GOptionGroup
2432  * @error_func: a function to call when an error occurs
2433  *
2434  * Associates a function with @group which will be called
2435  * from g_option_context_parse() when an error occurs.
2436  *
2437  * Note that the user data to be passed to @error_func can be
2438  * specified when constructing the group with g_option_group_new().
2439  *
2440  * Since: 2.6
2441  **/
2442 void
2443 g_option_group_set_error_hook (GOptionGroup     *group,
2444                                GOptionErrorFunc  error_func)
2445 {
2446   g_return_if_fail (group != NULL);
2447 
2448   group-&gt;error_func = error_func;
2449 }
2450 
2451 
2452 /**
2453  * g_option_group_set_translate_func:
2454  * @group: a #GOptionGroup
2455  * @func: (nullable): the #GTranslateFunc, or %NULL
2456  * @data: (nullable): user data to pass to @func, or %NULL
2457  * @destroy_notify: (nullable): a function which gets called to free @data, or %NULL
2458  *
2459  * Sets the function which is used to translate user-visible strings,
2460  * for `--help` output. Different groups can use different
2461  * #GTranslateFuncs. If @func is %NULL, strings are not translated.
2462  *
2463  * If you are using gettext(), you only need to set the translation
2464  * domain, see g_option_group_set_translation_domain().
2465  *
2466  * Since: 2.6
2467  **/
2468 void
2469 g_option_group_set_translate_func (GOptionGroup   *group,
2470                                    GTranslateFunc  func,
2471                                    gpointer        data,
2472                                    GDestroyNotify  destroy_notify)
2473 {
2474   g_return_if_fail (group != NULL);
2475 
2476   if (group-&gt;translate_notify)
2477     group-&gt;translate_notify (group-&gt;translate_data);
2478 
2479   group-&gt;translate_func = func;
2480   group-&gt;translate_data = data;
2481   group-&gt;translate_notify = destroy_notify;
2482 }
2483 
2484 static const gchar *
2485 dgettext_swapped (const gchar *msgid,
2486                   const gchar *domainname)
2487 {
2488   return g_dgettext (domainname, msgid);
2489 }
2490 
2491 /**
2492  * g_option_group_set_translation_domain:
2493  * @group: a #GOptionGroup
2494  * @domain: the domain to use
2495  *
2496  * A convenience function to use gettext() for translating
2497  * user-visible strings.
2498  *
2499  * Since: 2.6
2500  **/
2501 void
2502 g_option_group_set_translation_domain (GOptionGroup *group,
2503                                        const gchar  *domain)
2504 {
2505   g_return_if_fail (group != NULL);
2506 
2507   g_option_group_set_translate_func (group,
2508                                      (GTranslateFunc)dgettext_swapped,
2509                                      g_strdup (domain),
2510                                      g_free);
2511 }
2512 
2513 /**
2514  * g_option_context_set_translate_func:
2515  * @context: a #GOptionContext
2516  * @func: (nullable): the #GTranslateFunc, or %NULL
2517  * @data: (nullable): user data to pass to @func, or %NULL
2518  * @destroy_notify: (nullable): a function which gets called to free @data, or %NULL
2519  *
2520  * Sets the function which is used to translate the contexts
2521  * user-visible strings, for `--help` output. If @func is %NULL,
2522  * strings are not translated.
2523  *
2524  * Note that option groups have their own translation functions,
2525  * this function only affects the @parameter_string (see g_option_context_new()),
2526  * the summary (see g_option_context_set_summary()) and the description
2527  * (see g_option_context_set_description()).
2528  *
2529  * If you are using gettext(), you only need to set the translation
2530  * domain, see g_option_context_set_translation_domain().
2531  *
2532  * Since: 2.12
2533  **/
2534 void
2535 g_option_context_set_translate_func (GOptionContext *context,
2536                                      GTranslateFunc func,
2537                                      gpointer       data,
2538                                      GDestroyNotify destroy_notify)
2539 {
2540   g_return_if_fail (context != NULL);
2541 
2542   if (context-&gt;translate_notify)
2543     context-&gt;translate_notify (context-&gt;translate_data);
2544 
2545   context-&gt;translate_func = func;
2546   context-&gt;translate_data = data;
2547   context-&gt;translate_notify = destroy_notify;
2548 }
2549 
2550 /**
2551  * g_option_context_set_translation_domain:
2552  * @context: a #GOptionContext
2553  * @domain: the domain to use
2554  *
2555  * A convenience function to use gettext() for translating
2556  * user-visible strings.
2557  *
2558  * Since: 2.12
2559  **/
2560 void
2561 g_option_context_set_translation_domain (GOptionContext *context,
2562                                          const gchar     *domain)
2563 {
2564   g_return_if_fail (context != NULL);
2565 
2566   g_option_context_set_translate_func (context,
2567                                        (GTranslateFunc)dgettext_swapped,
2568                                        g_strdup (domain),
2569                                        g_free);
2570 }
2571 
2572 /**
2573  * g_option_context_set_summary:
2574  * @context: a #GOptionContext
2575  * @summary: (nullable): a string to be shown in `--help` output
2576  *  before the list of options, or %NULL
2577  *
2578  * Adds a string to be displayed in `--help` output before the list
2579  * of options. This is typically a summary of the program functionality.
2580  *
2581  * Note that the summary is translated (see
2582  * g_option_context_set_translate_func() and
2583  * g_option_context_set_translation_domain()).
2584  *
2585  * Since: 2.12
2586  */
2587 void
2588 g_option_context_set_summary (GOptionContext *context,
2589                               const gchar    *summary)
2590 {
2591   g_return_if_fail (context != NULL);
2592 
2593   g_free (context-&gt;summary);
2594   context-&gt;summary = g_strdup (summary);
2595 }
2596 
2597 
2598 /**
2599  * g_option_context_get_summary:
2600  * @context: a #GOptionContext
2601  *
2602  * Returns the summary. See g_option_context_set_summary().
2603  *
2604  * Returns: the summary
2605  *
2606  * Since: 2.12
2607  */
2608 const gchar *
2609 g_option_context_get_summary (GOptionContext *context)
2610 {
2611   g_return_val_if_fail (context != NULL, NULL);
2612 
2613   return context-&gt;summary;
2614 }
2615 
2616 /**
2617  * g_option_context_set_description:
2618  * @context: a #GOptionContext
2619  * @description: (nullable): a string to be shown in `--help` output
2620  *   after the list of options, or %NULL
2621  *
2622  * Adds a string to be displayed in `--help` output after the list
2623  * of options. This text often includes a bug reporting address.
2624  *
2625  * Note that the summary is translated (see
2626  * g_option_context_set_translate_func()).
2627  *
2628  * Since: 2.12
2629  */
2630 void
2631 g_option_context_set_description (GOptionContext *context,
2632                                   const gchar    *description)
2633 {
2634   g_return_if_fail (context != NULL);
2635 
2636   g_free (context-&gt;description);
2637   context-&gt;description = g_strdup (description);
2638 }
2639 
2640 
2641 /**
2642  * g_option_context_get_description:
2643  * @context: a #GOptionContext
2644  *
2645  * Returns the description. See g_option_context_set_description().
2646  *
2647  * Returns: the description
2648  *
2649  * Since: 2.12
2650  */
2651 const gchar *
2652 g_option_context_get_description (GOptionContext *context)
2653 {
2654   g_return_val_if_fail (context != NULL, NULL);
2655 
2656   return context-&gt;description;
2657 }
2658 
2659 /**
2660  * g_option_context_parse_strv:
2661  * @context: a #GOptionContext
2662  * @arguments: (inout) (array null-terminated=1): a pointer to the
2663  *    command line arguments (which must be in UTF-8 on Windows)
2664  * @error: a return location for errors
2665  *
2666  * Parses the command line arguments.
2667  *
2668  * This function is similar to g_option_context_parse() except that it
2669  * respects the normal memory rules when dealing with a strv instead of
2670  * assuming that the passed-in array is the argv of the main function.
2671  *
2672  * In particular, strings that are removed from the arguments list will
2673  * be freed using g_free().
2674  *
2675  * On Windows, the strings are expected to be in UTF-8.  This is in
2676  * contrast to g_option_context_parse() which expects them to be in the
2677  * system codepage, which is how they are passed as @argv to main().
2678  * See g_win32_get_command_line() for a solution.
2679  *
2680  * This function is useful if you are trying to use #GOptionContext with
2681  * #GApplication.
2682  *
2683  * Returns: %TRUE if the parsing was successful,
2684  *          %FALSE if an error occurred
2685  *
2686  * Since: 2.40
2687  **/
2688 gboolean
2689 g_option_context_parse_strv (GOptionContext   *context,
2690                              gchar          ***arguments,
2691                              GError          **error)
2692 {
2693   gboolean success;
2694   gint argc;
2695 
2696   context-&gt;strv_mode = TRUE;
2697   argc = g_strv_length (*arguments);
2698   success = g_option_context_parse (context, &amp;argc, arguments, error);
2699   context-&gt;strv_mode = FALSE;
2700 
2701   return success;
2702 }
    </pre>
  </body>
</html>