<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * gmain.c: Main loop abstraction, timeouts, and idle functions
   5  * Copyright 1998 Owen Taylor
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;glibconfig.h&quot;
  34 #include &quot;glib_trace.h&quot;
  35 
  36 /* Uncomment the next line (and the corresponding line in gpoll.c) to
  37  * enable debugging printouts if the environment variable
  38  * G_MAIN_POLL_DEBUG is set to some value.
  39  */
  40 /* #define G_MAIN_POLL_DEBUG */
  41 
  42 #ifdef _WIN32
  43 /* Always enable debugging printout on Windows, as it is more often
  44  * needed there...
  45  */
  46 #define G_MAIN_POLL_DEBUG
  47 #endif
  48 
  49 #ifdef G_OS_UNIX
  50 #include &quot;glib-unix.h&quot;
  51 #include &lt;pthread.h&gt;
  52 #ifdef HAVE_EVENTFD
  53 #include &lt;sys/eventfd.h&gt;
  54 #endif
  55 #endif
  56 
  57 #include &lt;signal.h&gt;
  58 #include &lt;sys/types.h&gt;
  59 #include &lt;time.h&gt;
  60 #include &lt;stdlib.h&gt;
  61 #ifdef HAVE_SYS_TIME_H
  62 #include &lt;sys/time.h&gt;
  63 #endif /* HAVE_SYS_TIME_H */
  64 #ifdef G_OS_UNIX
  65 #include &lt;unistd.h&gt;
  66 #endif /* G_OS_UNIX */
  67 #include &lt;errno.h&gt;
  68 #include &lt;string.h&gt;
  69 
  70 #ifdef G_OS_WIN32
  71 #define STRICT
  72 #include &lt;windows.h&gt;
  73 #endif /* G_OS_WIN32 */
  74 
  75 #ifdef HAVE_MACH_MACH_TIME_H
  76 #include &lt;mach/mach_time.h&gt;
  77 #endif
  78 
  79 #include &quot;glib_trace.h&quot;
  80 
  81 #include &quot;gmain.h&quot;
  82 
  83 #include &quot;garray.h&quot;
  84 #include &quot;giochannel.h&quot;
  85 #include &quot;ghash.h&quot;
  86 #include &quot;ghook.h&quot;
  87 #include &quot;gqueue.h&quot;
  88 #include &quot;gstrfuncs.h&quot;
  89 #include &quot;gtestutils.h&quot;
<a name="1" id="anc1"></a>
  90 
  91 #ifdef G_OS_WIN32
  92 #include &quot;gwin32.h&quot;
  93 #endif
  94 
  95 #ifdef  G_MAIN_POLL_DEBUG
  96 #include &quot;gtimer.h&quot;
  97 #endif
  98 
  99 #include &quot;gwakeup.h&quot;
 100 #include &quot;gmain-internal.h&quot;
 101 #include &quot;glib-init.h&quot;
 102 #include &quot;glib-private.h&quot;
 103 
 104 /**
 105  * SECTION:main
 106  * @title: The Main Event Loop
 107  * @short_description: manages all available sources of events
 108  *
 109  * The main event loop manages all the available sources of events for
 110  * GLib and GTK+ applications. These events can come from any number of
 111  * different types of sources such as file descriptors (plain files,
 112  * pipes or sockets) and timeouts. New types of event sources can also
 113  * be added using g_source_attach().
 114  *
 115  * To allow multiple independent sets of sources to be handled in
 116  * different threads, each source is associated with a #GMainContext.
 117  * A GMainContext can only be running in a single thread, but
 118  * sources can be added to it and removed from it from other threads.
 119  *
 120  * Each event source is assigned a priority. The default priority,
 121  * #G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.
 122  * Values greater than 0 denote lower priorities. Events from high priority
 123  * sources are always processed before events from lower priority sources.
 124  *
 125  * Idle functions can also be added, and assigned a priority. These will
 126  * be run whenever no events with a higher priority are ready to be processed.
 127  *
 128  * The #GMainLoop data type represents a main event loop. A GMainLoop is
 129  * created with g_main_loop_new(). After adding the initial event sources,
 130  * g_main_loop_run() is called. This continuously checks for new events from
 131  * each of the event sources and dispatches them. Finally, the processing of
 132  * an event from one of the sources leads to a call to g_main_loop_quit() to
 133  * exit the main loop, and g_main_loop_run() returns.
 134  *
 135  * It is possible to create new instances of #GMainLoop recursively.
 136  * This is often used in GTK+ applications when showing modal dialog
 137  * boxes. Note that event sources are associated with a particular
 138  * #GMainContext, and will be checked and dispatched for all main
 139  * loops associated with that GMainContext.
 140  *
 141  * GTK+ contains wrappers of some of these functions, e.g. gtk_main(),
 142  * gtk_main_quit() and gtk_events_pending().
 143  *
 144  * ## Creating new source types
 145  *
 146  * One of the unusual features of the #GMainLoop functionality
 147  * is that new types of event source can be created and used in
 148  * addition to the builtin type of event source. A new event source
 149  * type is used for handling GDK events. A new source type is created
 150  * by &quot;deriving&quot; from the #GSource structure. The derived type of
 151  * source is represented by a structure that has the #GSource structure
 152  * as a first element, and other elements specific to the new source
 153  * type. To create an instance of the new source type, call
 154  * g_source_new() passing in the size of the derived structure and
 155  * a table of functions. These #GSourceFuncs determine the behavior of
 156  * the new source type.
 157  *
 158  * New source types basically interact with the main context
 159  * in two ways. Their prepare function in #GSourceFuncs can set a timeout
 160  * to determine the maximum amount of time that the main loop will sleep
 161  * before checking the source again. In addition, or as well, the source
 162  * can add file descriptors to the set that the main context checks using
 163  * g_source_add_poll().
 164  *
 165  * ## Customizing the main loop iteration
 166  *
 167  * Single iterations of a #GMainContext can be run with
 168  * g_main_context_iteration(). In some cases, more detailed control
 169  * of exactly how the details of the main loop work is desired, for
 170  * instance, when integrating the #GMainLoop with an external main loop.
 171  * In such cases, you can call the component functions of
 172  * g_main_context_iteration() directly. These functions are
 173  * g_main_context_prepare(), g_main_context_query(),
 174  * g_main_context_check() and g_main_context_dispatch().
 175  *
 176  * ## State of a Main Context # {#mainloop-states}
 177  *
 178  * The operation of these functions can best be seen in terms
 179  * of a state diagram, as shown in this image.
 180  *
 181  * ![](mainloop-states.gif)
 182  *
 183  * On UNIX, the GLib mainloop is incompatible with fork(). Any program
 184  * using the mainloop must either exec() or exit() from the child
 185  * without returning to the mainloop.
 186  *
 187  * ## Memory management of sources # {#mainloop-memory-management}
 188  *
 189  * There are two options for memory management of the user data passed to a
 190  * #GSource to be passed to its callback on invocation. This data is provided
 191  * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
 192  * more generally, using g_source_set_callback(). This data is typically an
<a name="2" id="anc2"></a><span class="line-modified"> 193  * object which �owns� the timeout or idle callback, such as a widget or a</span>
 194  * network protocol implementation. In many cases, it is an error for the
 195  * callback to be invoked after this owning object has been destroyed, as that
 196  * results in use of freed memory.
 197  *
 198  * The first, and preferred, option is to store the source ID returned by
 199  * functions such as g_timeout_add() or g_source_attach(), and explicitly
 200  * remove that source from the main context using g_source_remove() when the
 201  * owning object is finalized. This ensures that the callback can only be
 202  * invoked while the object is still alive.
 203  *
 204  * The second option is to hold a strong reference to the object in the
<a name="3" id="anc3"></a><span class="line-modified"> 205  * callback, and to release it in the callback�s #GDestroyNotify. This ensures</span>
 206  * that the object is kept alive until after the source is finalized, which is
 207  * guaranteed to be after it is invoked for the final time. The #GDestroyNotify
<a name="4" id="anc4"></a><span class="line-modified"> 208  * is another callback passed to the �full� variants of #GSource functions (for</span>
 209  * example, g_timeout_add_full()). It is called when the source is finalized,
 210  * and is designed for releasing references like this.
 211  *
 212  * One important caveat of this second approach is that it will keep the object
 213  * alive indefinitely if the main loop is stopped before the #GSource is
 214  * invoked, which may be undesirable.
 215  */
 216 
 217 /* Types */
 218 
 219 typedef struct _GTimeoutSource GTimeoutSource;
 220 typedef struct _GChildWatchSource GChildWatchSource;
 221 typedef struct _GUnixSignalWatchSource GUnixSignalWatchSource;
 222 typedef struct _GPollRec GPollRec;
 223 typedef struct _GSourceCallback GSourceCallback;
 224 
 225 typedef enum
 226 {
 227   G_SOURCE_READY = 1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT,
 228   G_SOURCE_CAN_RECURSE = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 1),
 229   G_SOURCE_BLOCKED = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 2)
 230 } GSourceFlags;
 231 
 232 typedef struct _GSourceList GSourceList;
 233 
 234 struct _GSourceList
 235 {
 236   GSource *head, *tail;
 237   gint priority;
 238 };
 239 
 240 typedef struct _GMainWaiter GMainWaiter;
 241 
 242 struct _GMainWaiter
 243 {
 244   GCond *cond;
 245   GMutex *mutex;
 246 };
 247 
 248 typedef struct _GMainDispatch GMainDispatch;
 249 
 250 struct _GMainDispatch
 251 {
 252   gint depth;
 253   GSource *source;
 254 };
 255 
 256 #ifdef G_MAIN_POLL_DEBUG
 257 gboolean _g_main_poll_debug = FALSE;
 258 #endif
 259 
 260 struct _GMainContext
 261 {
 262   /* The following lock is used for both the list of sources
 263    * and the list of poll records
 264    */
 265   GMutex mutex;
 266   GCond cond;
 267   GThread *owner;
 268   guint owner_count;
 269   GSList *waiters;
 270 
 271   volatile gint ref_count;
 272 
 273   GHashTable *sources;              /* guint -&gt; GSource */
 274 
 275   GPtrArray *pending_dispatches;
<a name="5" id="anc5"></a><span class="line-modified"> 276   gint timeout;         /* Timeout for current iteration */</span>
 277 
 278   guint next_id;
 279   GList *source_lists;
 280   gint in_check_or_prepare;
 281 
 282   GPollRec *poll_records;
 283   guint n_poll_records;
 284   GPollFD *cached_poll_array;
 285   guint cached_poll_array_size;
 286 
 287   GWakeup *wakeup;
 288 
 289   GPollFD wake_up_rec;
 290 
 291 /* Flag indicating whether the set of fd&#39;s changed during a poll */
 292   gboolean poll_changed;
 293 
 294   GPollFunc poll_func;
 295 
 296   gint64   time;
 297   gboolean time_is_fresh;
 298 };
 299 
 300 struct _GSourceCallback
 301 {
 302   volatile gint ref_count;
 303   GSourceFunc func;
 304   gpointer    data;
 305   GDestroyNotify notify;
 306 };
 307 
 308 struct _GMainLoop
 309 {
 310   GMainContext *context;
<a name="6" id="anc6"></a><span class="line-modified"> 311   gboolean is_running;</span>
 312   volatile gint ref_count;
 313 };
 314 
 315 struct _GTimeoutSource
 316 {
 317   GSource     source;
<a name="7" id="anc7"></a>
 318   guint       interval;
 319   gboolean    seconds;
 320 };
 321 
 322 struct _GChildWatchSource
 323 {
 324   GSource     source;
 325   GPid        pid;
 326   gint        child_status;
 327 #ifdef G_OS_WIN32
 328   GPollFD     poll;
 329 #else /* G_OS_WIN32 */
<a name="8" id="anc8"></a><span class="line-modified"> 330   gboolean    child_exited;</span>
 331 #endif /* G_OS_WIN32 */
 332 };
 333 
 334 struct _GUnixSignalWatchSource
 335 {
 336   GSource     source;
 337   int         signum;
<a name="9" id="anc9"></a><span class="line-modified"> 338   gboolean    pending;</span>
 339 };
 340 
 341 struct _GPollRec
 342 {
 343   GPollFD *fd;
 344   GPollRec *prev;
 345   GPollRec *next;
 346   gint priority;
 347 };
 348 
 349 struct _GSourcePrivate
 350 {
 351   GSList *child_sources;
 352   GSource *parent_source;
 353 
 354   gint64 ready_time;
 355 
 356   /* This is currently only used on UNIX, but we always declare it (and
 357    * let it remain empty on Windows) to avoid #ifdef all over the place.
 358    */
 359   GSList *fds;
 360 };
 361 
 362 typedef struct _GSourceIter
 363 {
 364   GMainContext *context;
 365   gboolean may_modify;
 366   GList *current_list;
 367   GSource *source;
 368 } GSourceIter;
 369 
 370 #define LOCK_CONTEXT(context) g_mutex_lock (&amp;context-&gt;mutex)
 371 #define UNLOCK_CONTEXT(context) g_mutex_unlock (&amp;context-&gt;mutex)
 372 #define G_THREAD_SELF g_thread_self ()
 373 
 374 #define SOURCE_DESTROYED(source) (((source)-&gt;flags &amp; G_HOOK_FLAG_ACTIVE) == 0)
 375 #define SOURCE_BLOCKED(source) (((source)-&gt;flags &amp; G_SOURCE_BLOCKED) != 0)
 376 
<a name="10" id="anc10"></a><span class="line-removed"> 377 #define SOURCE_UNREF(source, context)                       \</span>
<span class="line-removed"> 378    G_STMT_START {                                           \</span>
<span class="line-removed"> 379     if ((source)-&gt;ref_count &gt; 1)                            \</span>
<span class="line-removed"> 380       (source)-&gt;ref_count--;                                \</span>
<span class="line-removed"> 381     else                                                    \</span>
<span class="line-removed"> 382       g_source_unref_internal ((source), (context), TRUE);  \</span>
<span class="line-removed"> 383    } G_STMT_END</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385 </span>
 386 /* Forward declarations */
 387 
 388 static void g_source_unref_internal             (GSource      *source,
<a name="11" id="anc11"></a><span class="line-modified"> 389                          GMainContext *context,</span>
<span class="line-modified"> 390                          gboolean      have_lock);</span>
 391 static void g_source_destroy_internal           (GSource      *source,
<a name="12" id="anc12"></a><span class="line-modified"> 392                          GMainContext *context,</span>
<span class="line-modified"> 393                          gboolean      have_lock);</span>
 394 static void g_source_set_priority_unlocked      (GSource      *source,
<a name="13" id="anc13"></a><span class="line-modified"> 395                          GMainContext *context,</span>
<span class="line-modified"> 396                          gint          priority);</span>
 397 static void g_child_source_remove_internal      (GSource      *child_source,
 398                                                  GMainContext *context);
 399 
 400 static void g_main_context_poll                 (GMainContext *context,
<a name="14" id="anc14"></a><span class="line-modified"> 401                          gint          timeout,</span>
<span class="line-modified"> 402                          gint          priority,</span>
<span class="line-modified"> 403                          GPollFD      *fds,</span>
<span class="line-modified"> 404                          gint          n_fds);</span>
 405 static void g_main_context_add_poll_unlocked    (GMainContext *context,
<a name="15" id="anc15"></a><span class="line-modified"> 406                          gint          priority,</span>
<span class="line-modified"> 407                          GPollFD      *fd);</span>
 408 static void g_main_context_remove_poll_unlocked (GMainContext *context,
<a name="16" id="anc16"></a><span class="line-modified"> 409                          GPollFD      *fd);</span>
 410 
 411 static void     g_source_iter_init  (GSourceIter   *iter,
<a name="17" id="anc17"></a><span class="line-modified"> 412                      GMainContext  *context,</span>
<span class="line-modified"> 413                      gboolean       may_modify);</span>
 414 static gboolean g_source_iter_next  (GSourceIter   *iter,
<a name="18" id="anc18"></a><span class="line-modified"> 415                      GSource      **source);</span>
 416 static void     g_source_iter_clear (GSourceIter   *iter);
 417 
 418 static gboolean g_timeout_dispatch (GSource     *source,
<a name="19" id="anc19"></a><span class="line-modified"> 419                     GSourceFunc  callback,</span>
<span class="line-modified"> 420                     gpointer     user_data);</span>
 421 static gboolean g_child_watch_prepare  (GSource     *source,
<a name="20" id="anc20"></a><span class="line-modified"> 422                         gint        *timeout);</span>
 423 static gboolean g_child_watch_check    (GSource     *source);
 424 static gboolean g_child_watch_dispatch (GSource     *source,
<a name="21" id="anc21"></a><span class="line-modified"> 425                     GSourceFunc  callback,</span>
<span class="line-modified"> 426                     gpointer     user_data);</span>
 427 static void     g_child_watch_finalize (GSource     *source);
 428 #ifdef G_OS_UNIX
 429 static void g_unix_signal_handler (int signum);
 430 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
<a name="22" id="anc22"></a><span class="line-modified"> 431                           gint        *timeout);</span>
 432 static gboolean g_unix_signal_watch_check    (GSource     *source);
 433 static gboolean g_unix_signal_watch_dispatch (GSource     *source,
<a name="23" id="anc23"></a><span class="line-modified"> 434                           GSourceFunc  callback,</span>
<span class="line-modified"> 435                           gpointer     user_data);</span>
 436 static void     g_unix_signal_watch_finalize  (GSource     *source);
 437 #endif
 438 static gboolean g_idle_prepare     (GSource     *source,
<a name="24" id="anc24"></a><span class="line-modified"> 439                     gint        *timeout);</span>
 440 static gboolean g_idle_check       (GSource     *source);
 441 static gboolean g_idle_dispatch    (GSource     *source,
<a name="25" id="anc25"></a><span class="line-modified"> 442                     GSourceFunc  callback,</span>
<span class="line-modified"> 443                     gpointer     user_data);</span>
 444 
 445 static void block_source (GSource *source);
 446 
 447 static GMainContext *glib_worker_context;
 448 
 449 G_LOCK_DEFINE_STATIC (main_loop);
 450 static GMainContext *default_main_context;
 451 
 452 #ifndef G_OS_WIN32
 453 
 454 
 455 /* UNIX signals work by marking one of these variables then waking the
 456  * worker context to check on them and dispatch accordingly.
 457  */
 458 #ifdef HAVE_SIG_ATOMIC_T
 459 static volatile sig_atomic_t unix_signal_pending[NSIG];
 460 static volatile sig_atomic_t any_unix_signal_pending;
 461 #else
 462 static volatile int unix_signal_pending[NSIG];
 463 static volatile int any_unix_signal_pending;
 464 #endif
<a name="26" id="anc26"></a><span class="line-removed"> 465 static volatile guint unix_signal_refcount[NSIG];</span>
 466 
 467 /* Guards all the data below */
 468 G_LOCK_DEFINE_STATIC (unix_signal_lock);
<a name="27" id="anc27"></a>
 469 static GSList *unix_signal_watches;
 470 static GSList *unix_child_watches;
 471 
 472 GSourceFuncs g_unix_signal_funcs =
 473 {
 474   g_unix_signal_watch_prepare,
 475   g_unix_signal_watch_check,
 476   g_unix_signal_watch_dispatch,
<a name="28" id="anc28"></a><span class="line-modified"> 477   g_unix_signal_watch_finalize</span>

 478 };
 479 #endif /* !G_OS_WIN32 */
 480 G_LOCK_DEFINE_STATIC (main_context_list);
 481 static GSList *main_context_list = NULL;
 482 
 483 GSourceFuncs g_timeout_funcs =
 484 {
 485   NULL, /* prepare */
 486   NULL, /* check */
 487   g_timeout_dispatch,
<a name="29" id="anc29"></a><span class="line-modified"> 488   NULL</span>
 489 };
 490 
 491 GSourceFuncs g_child_watch_funcs =
 492 {
 493   g_child_watch_prepare,
 494   g_child_watch_check,
 495   g_child_watch_dispatch,
<a name="30" id="anc30"></a><span class="line-modified"> 496   g_child_watch_finalize</span>

 497 };
 498 
 499 GSourceFuncs g_idle_funcs =
 500 {
 501   g_idle_prepare,
 502   g_idle_check,
 503   g_idle_dispatch,
<a name="31" id="anc31"></a><span class="line-modified"> 504   NULL</span>
 505 };
 506 
 507 /**
 508  * g_main_context_ref:
 509  * @context: a #GMainContext
 510  *
 511  * Increases the reference count on a #GMainContext object by one.
 512  *
 513  * Returns: the @context that was passed in (since 2.6)
 514  **/
 515 GMainContext *
 516 g_main_context_ref (GMainContext *context)
 517 {
 518   g_return_val_if_fail (context != NULL, NULL);
 519   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
 520 
 521   g_atomic_int_inc (&amp;context-&gt;ref_count);
 522 
 523   return context;
 524 }
 525 
 526 static inline void
 527 poll_rec_list_free (GMainContext *context,
<a name="32" id="anc32"></a><span class="line-modified"> 528             GPollRec     *list)</span>
 529 {
 530   g_slice_free_chain (GPollRec, list, next);
 531 }
 532 
 533 /**
 534  * g_main_context_unref:
 535  * @context: a #GMainContext
 536  *
 537  * Decreases the reference count on a #GMainContext object by one. If
 538  * the result is zero, free the context and free all associated memory.
 539  **/
 540 void
 541 g_main_context_unref (GMainContext *context)
 542 {
 543   GSourceIter iter;
 544   GSource *source;
 545   GList *sl_iter;
 546   GSourceList *list;
 547   guint i;
 548 
 549   g_return_if_fail (context != NULL);
 550   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
 551 
 552   if (!g_atomic_int_dec_and_test (&amp;context-&gt;ref_count))
 553     return;
 554 
 555   G_LOCK (main_context_list);
 556   main_context_list = g_slist_remove (main_context_list, context);
 557   G_UNLOCK (main_context_list);
 558 
 559   /* Free pending dispatches */
 560   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
 561     g_source_unref_internal (context-&gt;pending_dispatches-&gt;pdata[i], context, FALSE);
 562 
 563   /* g_source_iter_next() assumes the context is locked. */
 564   LOCK_CONTEXT (context);
 565   g_source_iter_init (&amp;iter, context, TRUE);
 566   while (g_source_iter_next (&amp;iter, &amp;source))
 567     {
 568       source-&gt;context = NULL;
 569       g_source_destroy_internal (source, context, TRUE);
 570     }
 571   UNLOCK_CONTEXT (context);
 572 
 573   for (sl_iter = context-&gt;source_lists; sl_iter; sl_iter = sl_iter-&gt;next)
 574     {
 575       list = sl_iter-&gt;data;
 576       g_slice_free (GSourceList, list);
 577     }
 578   g_list_free (context-&gt;source_lists);
 579 
 580   g_hash_table_destroy (context-&gt;sources);
 581 
 582   g_mutex_clear (&amp;context-&gt;mutex);
 583 
 584   g_ptr_array_free (context-&gt;pending_dispatches, TRUE);
 585   g_free (context-&gt;cached_poll_array);
 586 
 587   poll_rec_list_free (context, context-&gt;poll_records);
 588 
 589   g_wakeup_free (context-&gt;wakeup);
 590   g_cond_clear (&amp;context-&gt;cond);
 591 
 592   g_free (context);
 593 }
 594 
 595 /* Helper function used by mainloop/overflow test.
 596  */
 597 GMainContext *
 598 g_main_context_new_with_next_id (guint next_id)
 599 {
 600   GMainContext *ret = g_main_context_new ();
 601 
 602   ret-&gt;next_id = next_id;
 603 
 604   return ret;
 605 }
 606 
 607 /**
 608  * g_main_context_new:
 609  *
 610  * Creates a new #GMainContext structure.
 611  *
 612  * Returns: the new #GMainContext
 613  **/
 614 GMainContext *
 615 g_main_context_new (void)
 616 {
 617   static gsize initialised;
 618   GMainContext *context;
 619 
 620   if (g_once_init_enter (&amp;initialised))
 621     {
 622 #ifdef G_MAIN_POLL_DEBUG
 623       if (getenv (&quot;G_MAIN_POLL_DEBUG&quot;) != NULL)
 624         _g_main_poll_debug = TRUE;
 625 #endif
 626 
 627       g_once_init_leave (&amp;initialised, TRUE);
 628     }
 629 
 630   context = g_new0 (GMainContext, 1);
 631 
 632   TRACE (GLIB_MAIN_CONTEXT_NEW (context));
 633 
 634   g_mutex_init (&amp;context-&gt;mutex);
 635   g_cond_init (&amp;context-&gt;cond);
 636 
 637   context-&gt;sources = g_hash_table_new (NULL, NULL);
 638   context-&gt;owner = NULL;
 639   context-&gt;waiters = NULL;
 640 
 641   context-&gt;ref_count = 1;
 642 
 643   context-&gt;next_id = 1;
 644 
 645   context-&gt;source_lists = NULL;
 646 
 647   context-&gt;poll_func = g_poll;
 648 
 649   context-&gt;cached_poll_array = NULL;
 650   context-&gt;cached_poll_array_size = 0;
 651 
 652   context-&gt;pending_dispatches = g_ptr_array_new ();
 653 
 654   context-&gt;time_is_fresh = FALSE;
 655 
 656   context-&gt;wakeup = g_wakeup_new ();
 657   g_wakeup_get_pollfd (context-&gt;wakeup, &amp;context-&gt;wake_up_rec);
 658   g_main_context_add_poll_unlocked (context, 0, &amp;context-&gt;wake_up_rec);
 659 
 660   G_LOCK (main_context_list);
 661   main_context_list = g_slist_append (main_context_list, context);
 662 
 663 #ifdef G_MAIN_POLL_DEBUG
 664   if (_g_main_poll_debug)
 665     g_print (&quot;created context=%p\n&quot;, context);
 666 #endif
 667 
 668   G_UNLOCK (main_context_list);
 669 
 670   return context;
 671 }
 672 
 673 /**
 674  * g_main_context_default:
 675  *
 676  * Returns the global default main context. This is the main context
 677  * used for main loop functions when a main loop is not explicitly
 678  * specified, and corresponds to the &quot;main&quot; main loop. See also
 679  * g_main_context_get_thread_default().
 680  *
 681  * Returns: (transfer none): the global default main context.
 682  **/
 683 GMainContext *
 684 g_main_context_default (void)
 685 {
 686   /* Slow, but safe */
 687 
 688   G_LOCK (main_loop);
 689 
 690   if (!default_main_context)
 691     {
 692       default_main_context = g_main_context_new ();
 693 
 694       TRACE (GLIB_MAIN_CONTEXT_DEFAULT (default_main_context));
 695 
 696 #ifdef G_MAIN_POLL_DEBUG
 697       if (_g_main_poll_debug)
<a name="33" id="anc33"></a><span class="line-modified"> 698     g_print (&quot;default context=%p\n&quot;, default_main_context);</span>
 699 #endif
 700     }
 701 
 702   G_UNLOCK (main_loop);
 703 
 704   return default_main_context;
 705 }
 706 
 707 static void
 708 free_context (gpointer data)
 709 {
 710   GMainContext *context = data;
 711 
 712   TRACE (GLIB_MAIN_CONTEXT_FREE (context));
 713 
 714   g_main_context_release (context);
 715   if (context)
 716     g_main_context_unref (context);
 717 }
 718 
 719 static void
 720 free_context_stack (gpointer data)
 721 {
 722   g_queue_free_full((GQueue *) data, (GDestroyNotify) free_context);
 723 }
 724 
 725 static GPrivate thread_context_stack = G_PRIVATE_INIT (free_context_stack);
 726 
 727 /**
 728  * g_main_context_push_thread_default:
 729  * @context: (nullable): a #GMainContext, or %NULL for the global default context
 730  *
 731  * Acquires @context and sets it as the thread-default context for the
 732  * current thread. This will cause certain asynchronous operations
 733  * (such as most [gio][gio]-based I/O) which are
 734  * started in this thread to run under @context and deliver their
 735  * results to its main loop, rather than running under the global
 736  * default context in the main thread. Note that calling this function
 737  * changes the context returned by g_main_context_get_thread_default(),
 738  * not the one returned by g_main_context_default(), so it does not affect
 739  * the context used by functions like g_idle_add().
 740  *
 741  * Normally you would call this function shortly after creating a new
 742  * thread, passing it a #GMainContext which will be run by a
 743  * #GMainLoop in that thread, to set a new default context for all
 744  * async operations in that thread. In this case you may not need to
 745  * ever call g_main_context_pop_thread_default(), assuming you want the
 746  * new #GMainContext to be the default for the whole lifecycle of the
 747  * thread.
 748  *
 749  * If you don&#39;t have control over how the new thread was created (e.g.
 750  * in the new thread isn&#39;t newly created, or if the thread life
 751  * cycle is managed by a #GThreadPool), it is always suggested to wrap
 752  * the logic that needs to use the new #GMainContext inside a
 753  * g_main_context_push_thread_default() / g_main_context_pop_thread_default()
 754  * pair, otherwise threads that are re-used will end up never explicitly
 755  * releasing the #GMainContext reference they hold.
 756  *
 757  * In some cases you may want to schedule a single operation in a
 758  * non-default context, or temporarily use a non-default context in
 759  * the main thread. In that case, you can wrap the call to the
 760  * asynchronous operation inside a
 761  * g_main_context_push_thread_default() /
 762  * g_main_context_pop_thread_default() pair, but it is up to you to
 763  * ensure that no other asynchronous operations accidentally get
 764  * started while the non-default context is active.
 765  *
 766  * Beware that libraries that predate this function may not correctly
 767  * handle being used from a thread with a thread-default context. Eg,
 768  * see g_file_supports_thread_contexts().
 769  *
 770  * Since: 2.22
 771  **/
 772 void
 773 g_main_context_push_thread_default (GMainContext *context)
 774 {
 775   GQueue *stack;
 776   gboolean acquired_context;
 777 
 778   acquired_context = g_main_context_acquire (context);
 779   g_return_if_fail (acquired_context);
 780 
 781   if (context == g_main_context_default ())
 782     context = NULL;
 783   else if (context)
 784     g_main_context_ref (context);
 785 
 786   stack = g_private_get (&amp;thread_context_stack);
 787   if (!stack)
 788     {
 789       stack = g_queue_new ();
 790       g_private_set (&amp;thread_context_stack, stack);
 791     }
 792 
 793   g_queue_push_head (stack, context);
 794 
 795   TRACE (GLIB_MAIN_CONTEXT_PUSH_THREAD_DEFAULT (context));
 796 }
 797 
 798 /**
 799  * g_main_context_pop_thread_default:
 800  * @context: (nullable): a #GMainContext object, or %NULL
 801  *
 802  * Pops @context off the thread-default context stack (verifying that
 803  * it was on the top of the stack).
 804  *
 805  * Since: 2.22
 806  **/
 807 void
 808 g_main_context_pop_thread_default (GMainContext *context)
 809 {
 810   GQueue *stack;
 811 
 812   if (context == g_main_context_default ())
 813     context = NULL;
 814 
 815   stack = g_private_get (&amp;thread_context_stack);
 816 
 817   g_return_if_fail (stack != NULL);
 818   g_return_if_fail (g_queue_peek_head (stack) == context);
 819 
 820   TRACE (GLIB_MAIN_CONTEXT_POP_THREAD_DEFAULT (context));
 821 
 822   g_queue_pop_head (stack);
 823 
 824   g_main_context_release (context);
 825   if (context)
 826     g_main_context_unref (context);
 827 }
 828 
 829 /**
 830  * g_main_context_get_thread_default:
 831  *
 832  * Gets the thread-default #GMainContext for this thread. Asynchronous
 833  * operations that want to be able to be run in contexts other than
 834  * the default one should call this method or
 835  * g_main_context_ref_thread_default() to get a #GMainContext to add
 836  * their #GSources to. (Note that even in single-threaded
 837  * programs applications may sometimes want to temporarily push a
 838  * non-default context, so it is not safe to assume that this will
 839  * always return %NULL if you are running in the default thread.)
 840  *
 841  * If you need to hold a reference on the context, use
 842  * g_main_context_ref_thread_default() instead.
 843  *
 844  * Returns: (transfer none): the thread-default #GMainContext, or
 845  * %NULL if the thread-default context is the global default context.
 846  *
 847  * Since: 2.22
 848  **/
 849 GMainContext *
 850 g_main_context_get_thread_default (void)
 851 {
 852   GQueue *stack;
 853 
 854   stack = g_private_get (&amp;thread_context_stack);
 855   if (stack)
 856     return g_queue_peek_head (stack);
 857   else
 858     return NULL;
 859 }
 860 
 861 /**
 862  * g_main_context_ref_thread_default:
 863  *
 864  * Gets the thread-default #GMainContext for this thread, as with
 865  * g_main_context_get_thread_default(), but also adds a reference to
 866  * it with g_main_context_ref(). In addition, unlike
 867  * g_main_context_get_thread_default(), if the thread-default context
 868  * is the global default context, this will return that #GMainContext
 869  * (with a ref added to it) rather than returning %NULL.
 870  *
 871  * Returns: (transfer full): the thread-default #GMainContext. Unref
 872  *     with g_main_context_unref() when you are done with it.
 873  *
 874  * Since: 2.32
 875  */
 876 GMainContext *
 877 g_main_context_ref_thread_default (void)
 878 {
 879   GMainContext *context;
 880 
 881   context = g_main_context_get_thread_default ();
 882   if (!context)
 883     context = g_main_context_default ();
 884   return g_main_context_ref (context);
 885 }
 886 
 887 /* Hooks for adding to the main loop */
 888 
 889 /**
 890  * g_source_new:
 891  * @source_funcs: structure containing functions that implement
 892  *                the sources behavior.
 893  * @struct_size: size of the #GSource structure to create.
 894  *
 895  * Creates a new #GSource structure. The size is specified to
 896  * allow creating structures derived from #GSource that contain
 897  * additional data. The size passed in must be at least
 898  * `sizeof (GSource)`.
 899  *
 900  * The source will not initially be associated with any #GMainContext
 901  * and must be added to one with g_source_attach() before it will be
 902  * executed.
 903  *
 904  * Returns: the newly-created #GSource.
 905  **/
 906 GSource *
 907 g_source_new (GSourceFuncs *source_funcs,
<a name="34" id="anc34"></a><span class="line-modified"> 908           guint         struct_size)</span>
 909 {
 910   GSource *source;
 911 
 912   g_return_val_if_fail (source_funcs != NULL, NULL);
 913   g_return_val_if_fail (struct_size &gt;= sizeof (GSource), NULL);
 914 
 915   source = (GSource*) g_malloc0 (struct_size);
 916 #ifdef GSTREAMER_LITE
 917   if (source == NULL)
 918     return NULL;
 919 #endif // GSTREAMER_LITE
 920   source-&gt;priv = g_slice_new0 (GSourcePrivate);
 921 #ifdef GSTREAMER_LITE
 922   if (source-&gt;priv == NULL)
 923   {
 924     g_free(source);
 925     return NULL;
 926   }
 927 #endif // GSTREAMER_LITE
 928   source-&gt;source_funcs = source_funcs;
 929   source-&gt;ref_count = 1;
 930 
 931   source-&gt;priority = G_PRIORITY_DEFAULT;
 932 
 933   source-&gt;flags = G_HOOK_FLAG_ACTIVE;
 934 
 935   source-&gt;priv-&gt;ready_time = -1;
 936 
 937   /* NULL/0 initialization for all other fields */
 938 
 939   TRACE (GLIB_SOURCE_NEW (source, source_funcs-&gt;prepare, source_funcs-&gt;check,
 940                           source_funcs-&gt;dispatch, source_funcs-&gt;finalize,
 941                           struct_size));
 942 
 943   return source;
 944 }
 945 
 946 /* Holds context&#39;s lock */
 947 static void
 948 g_source_iter_init (GSourceIter  *iter,
<a name="35" id="anc35"></a><span class="line-modified"> 949             GMainContext *context,</span>
<span class="line-modified"> 950             gboolean      may_modify)</span>
 951 {
 952   iter-&gt;context = context;
 953   iter-&gt;current_list = NULL;
 954   iter-&gt;source = NULL;
 955   iter-&gt;may_modify = may_modify;
 956 }
 957 
 958 /* Holds context&#39;s lock */
 959 static gboolean
 960 g_source_iter_next (GSourceIter *iter, GSource **source)
 961 {
 962   GSource *next_source;
 963 
 964   if (iter-&gt;source)
 965     next_source = iter-&gt;source-&gt;next;
 966   else
 967     next_source = NULL;
 968 
 969   if (!next_source)
 970     {
 971       if (iter-&gt;current_list)
<a name="36" id="anc36"></a><span class="line-modified"> 972     iter-&gt;current_list = iter-&gt;current_list-&gt;next;</span>
 973       else
<a name="37" id="anc37"></a><span class="line-modified"> 974     iter-&gt;current_list = iter-&gt;context-&gt;source_lists;</span>
 975 
 976       if (iter-&gt;current_list)
<a name="38" id="anc38"></a><span class="line-modified"> 977     {</span>
<span class="line-modified"> 978       GSourceList *source_list = iter-&gt;current_list-&gt;data;</span>
 979 
<a name="39" id="anc39"></a><span class="line-modified"> 980       next_source = source_list-&gt;head;</span>
<span class="line-modified"> 981     }</span>
 982     }
 983 
 984   /* Note: unreffing iter-&gt;source could potentially cause its
 985    * GSourceList to be removed from source_lists (if iter-&gt;source is
 986    * the only source in its list, and it is destroyed), so we have to
 987    * keep it reffed until after we advance iter-&gt;current_list, above.
 988    */
 989 
 990   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<a name="40" id="anc40"></a><span class="line-modified"> 991     SOURCE_UNREF (iter-&gt;source, iter-&gt;context);</span>
 992   iter-&gt;source = next_source;
 993   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<a name="41" id="anc41"></a><span class="line-modified"> 994     iter-&gt;source-&gt;ref_count++;</span>
 995 
 996   *source = iter-&gt;source;
 997   return *source != NULL;
 998 }
 999 
1000 /* Holds context&#39;s lock. Only necessary to call if you broke out of
1001  * the g_source_iter_next() loop early.
1002  */
1003 static void
1004 g_source_iter_clear (GSourceIter *iter)
1005 {
1006   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
1007     {
<a name="42" id="anc42"></a><span class="line-modified">1008       SOURCE_UNREF (iter-&gt;source, iter-&gt;context);</span>
1009       iter-&gt;source = NULL;
1010     }
1011 }
1012 
1013 /* Holds context&#39;s lock
1014  */
1015 static GSourceList *
1016 find_source_list_for_priority (GMainContext *context,
<a name="43" id="anc43"></a><span class="line-modified">1017                    gint          priority,</span>
<span class="line-modified">1018                    gboolean      create)</span>
1019 {
1020   GList *iter, *last;
1021   GSourceList *source_list;
1022 
1023   last = NULL;
1024   for (iter = context-&gt;source_lists; iter != NULL; last = iter, iter = iter-&gt;next)
1025     {
1026       source_list = iter-&gt;data;
1027 
1028       if (source_list-&gt;priority == priority)
<a name="44" id="anc44"></a><span class="line-modified">1029     return source_list;</span>
1030 
1031       if (source_list-&gt;priority &gt; priority)
<a name="45" id="anc45"></a><span class="line-modified">1032     {</span>
<span class="line-modified">1033       if (!create)</span>
<span class="line-modified">1034         return NULL;</span>
<span class="line-modified">1035 </span>
<span class="line-modified">1036       source_list = g_slice_new0 (GSourceList);</span>
<span class="line-modified">1037       source_list-&gt;priority = priority;</span>
<span class="line-modified">1038       context-&gt;source_lists = g_list_insert_before (context-&gt;source_lists,</span>
<span class="line-modified">1039                             iter,</span>
<span class="line-modified">1040                             source_list);</span>
<span class="line-modified">1041       return source_list;</span>
<span class="line-modified">1042     }</span>
1043     }
1044 
1045   if (!create)
1046     return NULL;
1047 
1048   source_list = g_slice_new0 (GSourceList);
1049   source_list-&gt;priority = priority;
1050 
1051   if (!last)
1052     context-&gt;source_lists = g_list_append (NULL, source_list);
1053   else
1054     {
1055       /* This just appends source_list to the end of
1056        * context-&gt;source_lists without having to walk the list again.
1057        */
1058       last = g_list_append (last, source_list);
1059     }
1060   return source_list;
1061 }
1062 
1063 /* Holds context&#39;s lock
1064  */
1065 static void
1066 source_add_to_context (GSource      *source,
<a name="46" id="anc46"></a><span class="line-modified">1067                GMainContext *context)</span>
1068 {
1069   GSourceList *source_list;
1070   GSource *prev, *next;
1071 
1072   source_list = find_source_list_for_priority (context, source-&gt;priority, TRUE);
1073 
1074   if (source-&gt;priv-&gt;parent_source)
1075     {
1076       g_assert (source_list-&gt;head != NULL);
1077 
1078       /* Put the source immediately before its parent */
1079       prev = source-&gt;priv-&gt;parent_source-&gt;prev;
1080       next = source-&gt;priv-&gt;parent_source;
1081     }
1082   else
1083     {
1084       prev = source_list-&gt;tail;
1085       next = NULL;
1086     }
1087 
1088   source-&gt;next = next;
1089   if (next)
1090     next-&gt;prev = source;
1091   else
1092     source_list-&gt;tail = source;
1093 
1094   source-&gt;prev = prev;
1095   if (prev)
1096     prev-&gt;next = source;
1097   else
1098     source_list-&gt;head = source;
1099 }
1100 
1101 /* Holds context&#39;s lock
1102  */
1103 static void
1104 source_remove_from_context (GSource      *source,
<a name="47" id="anc47"></a><span class="line-modified">1105                 GMainContext *context)</span>
1106 {
1107   GSourceList *source_list;
1108 
1109   source_list = find_source_list_for_priority (context, source-&gt;priority, FALSE);
1110   g_return_if_fail (source_list != NULL);
1111 #ifdef GSTREAMER_LITE
1112   if (source_list == NULL)
1113     return;
1114 #endif // GSTREAMER_LITE
1115 
1116   if (source-&gt;prev)
1117     source-&gt;prev-&gt;next = source-&gt;next;
1118   else
1119     source_list-&gt;head = source-&gt;next;
1120 
1121   if (source-&gt;next)
1122     source-&gt;next-&gt;prev = source-&gt;prev;
1123   else
1124     source_list-&gt;tail = source-&gt;prev;
1125 
1126   source-&gt;prev = NULL;
1127   source-&gt;next = NULL;
1128 
1129   if (source_list-&gt;head == NULL)
1130     {
1131       context-&gt;source_lists = g_list_remove (context-&gt;source_lists, source_list);
1132       g_slice_free (GSourceList, source_list);
1133     }
1134 }
1135 
1136 static guint
1137 g_source_attach_unlocked (GSource      *source,
1138                           GMainContext *context,
1139                           gboolean      do_wakeup)
1140 {
1141   GSList *tmp_list;
1142   guint id;
1143 
1144   /* The counter may have wrapped, so we must ensure that we do not
1145    * reuse the source id of an existing source.
1146    */
1147   do
1148     id = context-&gt;next_id++;
1149   while (id == 0 || g_hash_table_contains (context-&gt;sources, GUINT_TO_POINTER (id)));
1150 
1151   source-&gt;context = context;
1152   source-&gt;source_id = id;
<a name="48" id="anc48"></a><span class="line-modified">1153   source-&gt;ref_count++;</span>
1154 
1155   g_hash_table_insert (context-&gt;sources, GUINT_TO_POINTER (id), source);
1156 
1157   source_add_to_context (source, context);
1158 
1159   if (!SOURCE_BLOCKED (source))
1160     {
1161       tmp_list = source-&gt;poll_fds;
1162       while (tmp_list)
1163         {
1164           g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1165           tmp_list = tmp_list-&gt;next;
1166         }
1167 
1168       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1169         g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1170     }
1171 
1172   tmp_list = source-&gt;priv-&gt;child_sources;
1173   while (tmp_list)
1174     {
1175       g_source_attach_unlocked (tmp_list-&gt;data, context, FALSE);
1176       tmp_list = tmp_list-&gt;next;
1177     }
1178 
1179   /* If another thread has acquired the context, wake it up since it
1180    * might be in poll() right now.
1181    */
1182   if (do_wakeup &amp;&amp; context-&gt;owner &amp;&amp; context-&gt;owner != G_THREAD_SELF)
1183     g_wakeup_signal (context-&gt;wakeup);
1184 
1185   return source-&gt;source_id;
1186 }
1187 
1188 /**
1189  * g_source_attach:
1190  * @source: a #GSource
1191  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
1192  *
1193  * Adds a #GSource to a @context so that it will be executed within
1194  * that context. Remove it by calling g_source_destroy().
1195  *
1196  * Returns: the ID (greater than 0) for the source within the
1197  *   #GMainContext.
1198  **/
1199 guint
1200 g_source_attach (GSource      *source,
<a name="49" id="anc49"></a><span class="line-modified">1201          GMainContext *context)</span>
1202 {
1203   guint result = 0;
1204 
1205 #ifdef GSTREAMER_LITE
1206   if (source == NULL) {
1207     return 0;
1208   }
1209 #endif // GSTREAMER_LITE
1210 
1211   g_return_val_if_fail (source-&gt;context == NULL, 0);
1212   g_return_val_if_fail (!SOURCE_DESTROYED (source), 0);
1213 
1214   if (!context)
1215     context = g_main_context_default ();
1216 
1217   LOCK_CONTEXT (context);
1218 
1219   result = g_source_attach_unlocked (source, context, TRUE);
1220 
1221   TRACE (GLIB_MAIN_SOURCE_ATTACH (g_source_get_name (source), source, context,
1222                                   result));
1223 
1224   UNLOCK_CONTEXT (context);
1225 
1226   return result;
1227 }
1228 
1229 static void
1230 g_source_destroy_internal (GSource      *source,
<a name="50" id="anc50"></a><span class="line-modified">1231                GMainContext *context,</span>
<span class="line-modified">1232                gboolean      have_lock)</span>
1233 {
1234   TRACE (GLIB_MAIN_SOURCE_DESTROY (g_source_get_name (source), source,
1235                                    context));
1236 
1237   if (!have_lock)
1238     LOCK_CONTEXT (context);
1239 
1240   if (!SOURCE_DESTROYED (source))
1241     {
1242       GSList *tmp_list;
1243       gpointer old_cb_data;
1244       GSourceCallbackFuncs *old_cb_funcs;
1245 
1246       source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1247 
1248       old_cb_data = source-&gt;callback_data;
1249       old_cb_funcs = source-&gt;callback_funcs;
1250 
1251       source-&gt;callback_data = NULL;
1252       source-&gt;callback_funcs = NULL;
1253 
1254       if (old_cb_funcs)
<a name="51" id="anc51"></a><span class="line-modified">1255     {</span>
<span class="line-modified">1256       UNLOCK_CONTEXT (context);</span>
<span class="line-modified">1257       old_cb_funcs-&gt;unref (old_cb_data);</span>
<span class="line-modified">1258       LOCK_CONTEXT (context);</span>
<span class="line-modified">1259     }</span>
1260 
1261       if (!SOURCE_BLOCKED (source))
<a name="52" id="anc52"></a><span class="line-modified">1262     {</span>
<span class="line-modified">1263       tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1264       while (tmp_list)</span>
<span class="line-modified">1265         {</span>
<span class="line-modified">1266           g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1267           tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1268         }</span>
1269 
1270           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1271             g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
<a name="53" id="anc53"></a><span class="line-modified">1272     }</span>
1273 
1274       while (source-&gt;priv-&gt;child_sources)
1275         g_child_source_remove_internal (source-&gt;priv-&gt;child_sources-&gt;data, context);
1276 
1277       if (source-&gt;priv-&gt;parent_source)
1278         g_child_source_remove_internal (source, context);
1279 
1280       g_source_unref_internal (source, context, TRUE);
1281     }
1282 
1283   if (!have_lock)
1284     UNLOCK_CONTEXT (context);
1285 }
1286 
1287 /**
1288  * g_source_destroy:
1289  * @source: a #GSource
1290  *
1291  * Removes a source from its #GMainContext, if any, and mark it as
1292  * destroyed.  The source cannot be subsequently added to another
1293  * context. It is safe to call this on sources which have already been
1294  * removed from their context.
<a name="54" id="anc54"></a><span class="line-modified">1295  **/</span>



1296 void
1297 g_source_destroy (GSource *source)
1298 {
1299   GMainContext *context;
1300 
1301   g_return_if_fail (source != NULL);
1302 
1303   context = source-&gt;context;
1304 
1305   if (context)
1306     g_source_destroy_internal (source, context, FALSE);
1307   else
1308     source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1309 }
1310 
1311 /**
1312  * g_source_get_id:
1313  * @source: a #GSource
1314  *
1315  * Returns the numeric ID for a particular source. The ID of a source
1316  * is a positive integer which is unique within a particular main loop
1317  * context. The reverse
1318  * mapping from ID to source is done by g_main_context_find_source_by_id().
1319  *
1320  * You can only call this function while the source is associated to a
1321  * #GMainContext instance; calling this function before g_source_attach()
1322  * or after g_source_destroy() yields undefined behavior. The ID returned
1323  * is unique within the #GMainContext instance passed to g_source_attach().
1324  *
1325  * Returns: the ID (greater than 0) for the source
1326  **/
1327 guint
1328 g_source_get_id (GSource *source)
1329 {
1330   guint result;
1331 
1332   g_return_val_if_fail (source != NULL, 0);
1333   g_return_val_if_fail (source-&gt;context != NULL, 0);
1334 
1335   LOCK_CONTEXT (source-&gt;context);
1336   result = source-&gt;source_id;
1337   UNLOCK_CONTEXT (source-&gt;context);
1338 
1339   return result;
1340 }
1341 
1342 /**
1343  * g_source_get_context:
1344  * @source: a #GSource
1345  *
1346  * Gets the #GMainContext with which the source is associated.
1347  *
1348  * You can call this on a source that has been destroyed, provided
1349  * that the #GMainContext it was attached to still exists (in which
1350  * case it will return that #GMainContext). In particular, you can
1351  * always call this function on the source returned from
1352  * g_main_current_source(). But calling this function on a source
1353  * whose #GMainContext has been destroyed is an error.
1354  *
1355  * Returns: (transfer none) (nullable): the #GMainContext with which the
1356  *               source is associated, or %NULL if the context has not
1357  *               yet been added to a source.
1358  **/
1359 GMainContext *
1360 g_source_get_context (GSource *source)
1361 {
1362   g_return_val_if_fail (source-&gt;context != NULL || !SOURCE_DESTROYED (source), NULL);
1363 
1364   return source-&gt;context;
1365 }
1366 
1367 /**
1368  * g_source_add_poll:
1369  * @source:a #GSource
1370  * @fd: a #GPollFD structure holding information about a file
1371  *      descriptor to watch.
1372  *
1373  * Adds a file descriptor to the set of file descriptors polled for
1374  * this source. This is usually combined with g_source_new() to add an
1375  * event source. The event source&#39;s check function will typically test
1376  * the @revents field in the #GPollFD struct and return %TRUE if events need
1377  * to be processed.
1378  *
1379  * This API is only intended to be used by implementations of #GSource.
1380  * Do not call this API on a #GSource that you did not create.
1381  *
1382  * Using this API forces the linear scanning of event sources on each
1383  * main loop iteration.  Newly-written event sources should try to use
1384  * g_source_add_unix_fd() instead of this API.
1385  **/
1386 void
1387 g_source_add_poll (GSource *source,
<a name="55" id="anc55"></a><span class="line-modified">1388            GPollFD *fd)</span>
1389 {
1390   GMainContext *context;
1391 
1392   g_return_if_fail (source != NULL);
1393   g_return_if_fail (fd != NULL);
1394   g_return_if_fail (!SOURCE_DESTROYED (source));
1395 
1396 #ifdef GSTREAMER_LITE
1397   if (source == NULL)
1398     return;
1399 #endif // GSTREAMER_LITE
1400 
1401   context = source-&gt;context;
1402 
1403   if (context)
1404     LOCK_CONTEXT (context);
1405 
1406   source-&gt;poll_fds = g_slist_prepend (source-&gt;poll_fds, fd);
1407 
1408   if (context)
1409     {
1410       if (!SOURCE_BLOCKED (source))
<a name="56" id="anc56"></a><span class="line-modified">1411     g_main_context_add_poll_unlocked (context, source-&gt;priority, fd);</span>
1412       UNLOCK_CONTEXT (context);
1413     }
1414 }
1415 
1416 /**
1417  * g_source_remove_poll:
1418  * @source:a #GSource
1419  * @fd: a #GPollFD structure previously passed to g_source_add_poll().
1420  *
1421  * Removes a file descriptor from the set of file descriptors polled for
1422  * this source.
1423  *
1424  * This API is only intended to be used by implementations of #GSource.
1425  * Do not call this API on a #GSource that you did not create.
1426  **/
1427 void
1428 g_source_remove_poll (GSource *source,
<a name="57" id="anc57"></a><span class="line-modified">1429               GPollFD *fd)</span>
1430 {
1431   GMainContext *context;
1432 
1433   g_return_if_fail (source != NULL);
1434   g_return_if_fail (fd != NULL);
1435   g_return_if_fail (!SOURCE_DESTROYED (source));
1436 
1437   context = source-&gt;context;
1438 
1439   if (context)
1440     LOCK_CONTEXT (context);
1441 
1442   source-&gt;poll_fds = g_slist_remove (source-&gt;poll_fds, fd);
1443 
1444   if (context)
1445     {
1446       if (!SOURCE_BLOCKED (source))
<a name="58" id="anc58"></a><span class="line-modified">1447     g_main_context_remove_poll_unlocked (context, fd);</span>
1448       UNLOCK_CONTEXT (context);
1449     }
1450 }
1451 
1452 /**
1453  * g_source_add_child_source:
1454  * @source:a #GSource
1455  * @child_source: a second #GSource that @source should &quot;poll&quot;
1456  *
1457  * Adds @child_source to @source as a &quot;polled&quot; source; when @source is
1458  * added to a #GMainContext, @child_source will be automatically added
1459  * with the same priority, when @child_source is triggered, it will
1460  * cause @source to dispatch (in addition to calling its own
1461  * callback), and when @source is destroyed, it will destroy
1462  * @child_source as well. (@source will also still be dispatched if
1463  * its own prepare/check functions indicate that it is ready.)
1464  *
1465  * If you don&#39;t need @child_source to do anything on its own when it
1466  * triggers, you can call g_source_set_dummy_callback() on it to set a
1467  * callback that does nothing (except return %TRUE if appropriate).
1468  *
1469  * @source will hold a reference on @child_source while @child_source
1470  * is attached to it.
1471  *
1472  * This API is only intended to be used by implementations of #GSource.
1473  * Do not call this API on a #GSource that you did not create.
1474  *
1475  * Since: 2.28
1476  **/
1477 void
1478 g_source_add_child_source (GSource *source,
<a name="59" id="anc59"></a><span class="line-modified">1479                GSource *child_source)</span>
1480 {
1481   GMainContext *context;
1482 
1483   g_return_if_fail (source != NULL);
1484   g_return_if_fail (child_source != NULL);
1485   g_return_if_fail (!SOURCE_DESTROYED (source));
1486   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1487   g_return_if_fail (child_source-&gt;context == NULL);
1488   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == NULL);
1489 
1490   context = source-&gt;context;
1491 
1492   if (context)
1493     LOCK_CONTEXT (context);
1494 
1495   TRACE (GLIB_SOURCE_ADD_CHILD_SOURCE (source, child_source));
1496 
1497   source-&gt;priv-&gt;child_sources = g_slist_prepend (source-&gt;priv-&gt;child_sources,
<a name="60" id="anc60"></a><span class="line-modified">1498                          g_source_ref (child_source));</span>
1499   child_source-&gt;priv-&gt;parent_source = source;
1500   g_source_set_priority_unlocked (child_source, NULL, source-&gt;priority);
1501   if (SOURCE_BLOCKED (source))
1502     block_source (child_source);
1503 
1504   if (context)
1505     {
1506       g_source_attach_unlocked (child_source, context, TRUE);
1507       UNLOCK_CONTEXT (context);
1508     }
1509 }
1510 
1511 static void
1512 g_child_source_remove_internal (GSource *child_source,
1513                                 GMainContext *context)
1514 {
1515   GSource *parent_source = child_source-&gt;priv-&gt;parent_source;
1516 
1517   parent_source-&gt;priv-&gt;child_sources =
1518     g_slist_remove (parent_source-&gt;priv-&gt;child_sources, child_source);
1519   child_source-&gt;priv-&gt;parent_source = NULL;
1520 
1521   g_source_destroy_internal (child_source, context, TRUE);
1522   g_source_unref_internal (child_source, context, TRUE);
1523 }
1524 
1525 /**
1526  * g_source_remove_child_source:
1527  * @source:a #GSource
1528  * @child_source: a #GSource previously passed to
1529  *     g_source_add_child_source().
1530  *
1531  * Detaches @child_source from @source and destroys it.
1532  *
1533  * This API is only intended to be used by implementations of #GSource.
1534  * Do not call this API on a #GSource that you did not create.
1535  *
1536  * Since: 2.28
1537  **/
1538 void
1539 g_source_remove_child_source (GSource *source,
<a name="61" id="anc61"></a><span class="line-modified">1540                   GSource *child_source)</span>
1541 {
1542   GMainContext *context;
1543 
1544   g_return_if_fail (source != NULL);
1545   g_return_if_fail (child_source != NULL);
1546   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == source);
1547   g_return_if_fail (!SOURCE_DESTROYED (source));
1548   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1549 
1550   context = source-&gt;context;
1551 
1552   if (context)
1553     LOCK_CONTEXT (context);
1554 
1555   g_child_source_remove_internal (child_source, context);
1556 
1557   if (context)
1558     UNLOCK_CONTEXT (context);
1559 }
1560 
1561 static void
1562 g_source_callback_ref (gpointer cb_data)
1563 {
1564   GSourceCallback *callback = cb_data;
1565 
1566   g_atomic_int_inc (&amp;callback-&gt;ref_count);
1567 }
1568 
1569 static void
1570 g_source_callback_unref (gpointer cb_data)
1571 {
1572   GSourceCallback *callback = cb_data;
1573 
1574   if (g_atomic_int_dec_and_test (&amp;callback-&gt;ref_count))
1575     {
1576       if (callback-&gt;notify)
1577         callback-&gt;notify (callback-&gt;data);
1578       g_free (callback);
1579     }
1580 }
1581 
1582 static void
1583 g_source_callback_get (gpointer     cb_data,
<a name="62" id="anc62"></a><span class="line-modified">1584                GSource     *source,</span>
<span class="line-modified">1585                GSourceFunc *func,</span>
<span class="line-modified">1586                gpointer    *data)</span>
1587 {
1588   GSourceCallback *callback = cb_data;
1589 
1590   *func = callback-&gt;func;
1591   *data = callback-&gt;data;
1592 }
1593 
1594 static GSourceCallbackFuncs g_source_callback_funcs = {
1595   g_source_callback_ref,
1596   g_source_callback_unref,
1597   g_source_callback_get,
1598 };
1599 
1600 /**
1601  * g_source_set_callback_indirect:
1602  * @source: the source
1603  * @callback_data: pointer to callback data &quot;object&quot;
1604  * @callback_funcs: functions for reference counting @callback_data
1605  *                  and getting the callback and data
1606  *
1607  * Sets the callback function storing the data as a refcounted callback
1608  * &quot;object&quot;. This is used internally. Note that calling
1609  * g_source_set_callback_indirect() assumes
1610  * an initial reference count on @callback_data, and thus
1611  * @callback_funcs-&gt;unref will eventually be called once more
1612  * than @callback_funcs-&gt;ref.
<a name="63" id="anc63"></a>



1613  **/
1614 void
1615 g_source_set_callback_indirect (GSource              *source,
<a name="64" id="anc64"></a><span class="line-modified">1616                 gpointer              callback_data,</span>
<span class="line-modified">1617                 GSourceCallbackFuncs *callback_funcs)</span>
1618 {
1619   GMainContext *context;
1620   gpointer old_cb_data;
1621   GSourceCallbackFuncs *old_cb_funcs;
1622 
1623   g_return_if_fail (source != NULL);
1624   g_return_if_fail (callback_funcs != NULL || callback_data == NULL);
1625 
1626   context = source-&gt;context;
1627 
1628   if (context)
1629     LOCK_CONTEXT (context);
1630 
1631   if (callback_funcs != &amp;g_source_callback_funcs)
<a name="65" id="anc65"></a><span class="line-modified">1632     TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,</span>
<span class="line-modified">1633                                               callback_funcs-&gt;ref,</span>
<span class="line-modified">1634                                               callback_funcs-&gt;unref,</span>
<span class="line-modified">1635                                               callback_funcs-&gt;get));</span>


1636 
1637   old_cb_data = source-&gt;callback_data;
1638   old_cb_funcs = source-&gt;callback_funcs;
1639 
1640   source-&gt;callback_data = callback_data;
1641   source-&gt;callback_funcs = callback_funcs;
1642 
1643   if (context)
1644     UNLOCK_CONTEXT (context);
1645 
1646   if (old_cb_funcs)
1647     old_cb_funcs-&gt;unref (old_cb_data);
1648 }
1649 
1650 /**
1651  * g_source_set_callback:
1652  * @source: the source
1653  * @func: a callback function
1654  * @data: the data to pass to callback function
1655  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
1656  *
1657  * Sets the callback function for a source. The callback for a source is
1658  * called from the source&#39;s dispatch function.
1659  *
1660  * The exact type of @func depends on the type of source; ie. you
1661  * should not count on @func being called with @data as its first
1662  * parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
1663  * incompatible function types.
1664  *
1665  * See [memory management of sources][mainloop-memory-management] for details
1666  * on how to handle memory management of @data.
1667  *
1668  * Typically, you won&#39;t use this function. Instead use functions specific
<a name="66" id="anc66"></a><span class="line-modified">1669  * to the type of source you are using.</span>




1670  **/
1671 void
1672 g_source_set_callback (GSource        *source,
<a name="67" id="anc67"></a><span class="line-modified">1673                GSourceFunc     func,</span>
<span class="line-modified">1674                gpointer        data,</span>
<span class="line-modified">1675                GDestroyNotify  notify)</span>
1676 {
1677   GSourceCallback *new_callback;
1678 
1679   g_return_if_fail (source != NULL);
1680 #ifdef GSTREAMER_LITE
1681   if (source == NULL)
1682     return;
1683 #endif // GSTREAMER_LITE
1684 
1685   TRACE (GLIB_SOURCE_SET_CALLBACK (source, func, data, notify));
1686 
1687   new_callback = g_new (GSourceCallback, 1);
1688 
1689   new_callback-&gt;ref_count = 1;
1690   new_callback-&gt;func = func;
1691   new_callback-&gt;data = data;
1692   new_callback-&gt;notify = notify;
1693 
1694   g_source_set_callback_indirect (source, new_callback, &amp;g_source_callback_funcs);
1695 }
1696 
1697 
1698 /**
1699  * g_source_set_funcs:
1700  * @source: a #GSource
1701  * @funcs: the new #GSourceFuncs
1702  *
1703  * Sets the source functions (can be used to override
1704  * default implementations) of an unattached source.
1705  *
1706  * Since: 2.12
1707  */
1708 void
1709 g_source_set_funcs (GSource     *source,
<a name="68" id="anc68"></a><span class="line-modified">1710                GSourceFuncs *funcs)</span>
1711 {
1712   g_return_if_fail (source != NULL);
1713   g_return_if_fail (source-&gt;context == NULL);
<a name="69" id="anc69"></a><span class="line-modified">1714   g_return_if_fail (source-&gt;ref_count &gt; 0);</span>
1715   g_return_if_fail (funcs != NULL);
1716 
1717   source-&gt;source_funcs = funcs;
1718 }
1719 
1720 static void
1721 g_source_set_priority_unlocked (GSource      *source,
<a name="70" id="anc70"></a><span class="line-modified">1722                 GMainContext *context,</span>
<span class="line-modified">1723                 gint          priority)</span>
1724 {
1725   GSList *tmp_list;
1726 
1727 #ifdef GSTREAMER_LITE
1728   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1729     return;
1730 
1731   if (context == NULL)
1732     return;
1733 #endif // GSTREAMER_LITE
1734 
1735   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL ||
<a name="71" id="anc71"></a><span class="line-modified">1736             source-&gt;priv-&gt;parent_source-&gt;priority == priority);</span>
1737 
1738   TRACE (GLIB_SOURCE_SET_PRIORITY (source, context, priority));
1739 
1740   if (context)
1741     {
1742       /* Remove the source from the context&#39;s source and then
1743        * add it back after so it is sorted in the correct place
1744        */
1745       source_remove_from_context (source, source-&gt;context);
1746     }
1747 
1748   source-&gt;priority = priority;
1749 
1750   if (context)
1751     {
1752       source_add_to_context (source, source-&gt;context);
1753 
1754       if (!SOURCE_BLOCKED (source))
<a name="72" id="anc72"></a><span class="line-modified">1755     {</span>
<span class="line-modified">1756       tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1757       while (tmp_list)</span>
<span class="line-modified">1758         {</span>
<span class="line-modified">1759           g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1760           g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);</span>
1761 
<a name="73" id="anc73"></a><span class="line-modified">1762           tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1763         }</span>
1764 
1765           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1766             {
1767               g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1768               g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);
1769             }
<a name="74" id="anc74"></a><span class="line-modified">1770     }</span>
1771     }
1772 
1773   if (source-&gt;priv-&gt;child_sources)
1774     {
1775       tmp_list = source-&gt;priv-&gt;child_sources;
1776       while (tmp_list)
<a name="75" id="anc75"></a><span class="line-modified">1777     {</span>
<span class="line-modified">1778       g_source_set_priority_unlocked (tmp_list-&gt;data, context, priority);</span>
<span class="line-modified">1779       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1780     }</span>
1781     }
1782 }
1783 
1784 /**
1785  * g_source_set_priority:
1786  * @source: a #GSource
1787  * @priority: the new priority.
1788  *
1789  * Sets the priority of a source. While the main loop is being run, a
1790  * source will be dispatched if it is ready to be dispatched and no
1791  * sources at a higher (numerically smaller) priority are ready to be
1792  * dispatched.
1793  *
1794  * A child source always has the same priority as its parent.  It is not
1795  * permitted to change the priority of a source once it has been added
1796  * as a child of another source.
1797  **/
1798 void
1799 g_source_set_priority (GSource  *source,
<a name="76" id="anc76"></a><span class="line-modified">1800                gint      priority)</span>
1801 {
1802   GMainContext *context;
1803 
1804 #ifdef GSTREAMER_LITE
1805   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1806     return;
1807 #endif // GSTREAMER_LITE
1808 
1809   g_return_if_fail (source != NULL);
1810   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL);
1811 
1812   context = source-&gt;context;
1813 
1814   if (context)
1815     LOCK_CONTEXT (context);
1816   g_source_set_priority_unlocked (source, context, priority);
1817   if (context)
1818     UNLOCK_CONTEXT (context);
1819 }
1820 
1821 /**
1822  * g_source_get_priority:
1823  * @source: a #GSource
1824  *
1825  * Gets the priority of a source.
1826  *
1827  * Returns: the priority of the source
1828  **/
1829 gint
1830 g_source_get_priority (GSource *source)
1831 {
1832   g_return_val_if_fail (source != NULL, 0);
1833 
1834   return source-&gt;priority;
1835 }
1836 
1837 /**
1838  * g_source_set_ready_time:
1839  * @source: a #GSource
1840  * @ready_time: the monotonic time at which the source will be ready,
1841  *              0 for &quot;immediately&quot;, -1 for &quot;never&quot;
1842  *
1843  * Sets a #GSource to be dispatched when the given monotonic time is
1844  * reached (or passed).  If the monotonic time is in the past (as it
1845  * always will be if @ready_time is 0) then the source will be
1846  * dispatched immediately.
1847  *
1848  * If @ready_time is -1 then the source is never woken up on the basis
1849  * of the passage of time.
1850  *
1851  * Dispatching the source does not reset the ready time.  You should do
1852  * so yourself, from the source dispatch function.
1853  *
1854  * Note that if you have a pair of sources where the ready time of one
1855  * suggests that it will be delivered first but the priority for the
1856  * other suggests that it would be delivered first, and the ready time
1857  * for both sources is reached during the same main context iteration,
1858  * then the order of dispatch is undefined.
1859  *
1860  * It is a no-op to call this function on a #GSource which has already been
1861  * destroyed with g_source_destroy().
1862  *
1863  * This API is only intended to be used by implementations of #GSource.
1864  * Do not call this API on a #GSource that you did not create.
1865  *
1866  * Since: 2.36
1867  **/
1868 void
1869 g_source_set_ready_time (GSource *source,
1870                          gint64   ready_time)
1871 {
1872   GMainContext *context;
1873 
1874   g_return_if_fail (source != NULL);
1875   /* We deliberately don&#39;t check for ref_count &gt; 0 here, because that
1876    * breaks cancellable_source_cancelled() in GCancellable: it has no
1877    * way to find out that the last-unref has happened until the
1878    * finalize() function is called, but that&#39;s too late, because the
1879    * ref_count already has already reached 0 before that time.
1880    * However, priv is only poisoned (set to NULL) after finalize(),
1881    * so we can use this as a simple guard against use-after-free.
1882    * See https://bugzilla.gnome.org/show_bug.cgi?id=791754 */
1883   g_return_if_fail (source-&gt;priv != NULL);
1884 
1885 #ifdef GSTREAMER_LITE
1886   if (source == NULL)
1887     return;
1888 #endif // GSTREAMER_LITE
1889 
1890   context = source-&gt;context;
1891 
1892   if (context)
1893     LOCK_CONTEXT (context);
1894 
1895   if (source-&gt;priv-&gt;ready_time == ready_time)
1896     {
1897       if (context)
1898         UNLOCK_CONTEXT (context);
1899 
1900       return;
1901     }
1902 
1903   source-&gt;priv-&gt;ready_time = ready_time;
1904 
1905   TRACE (GLIB_SOURCE_SET_READY_TIME (source, ready_time));
1906 
1907   if (context)
1908     {
1909       /* Quite likely that we need to change the timeout on the poll */
1910       if (!SOURCE_BLOCKED (source))
1911         g_wakeup_signal (context-&gt;wakeup);
1912       UNLOCK_CONTEXT (context);
1913     }
1914 }
1915 
1916 /**
1917  * g_source_get_ready_time:
1918  * @source: a #GSource
1919  *
1920  * Gets the &quot;ready time&quot; of @source, as set by
1921  * g_source_set_ready_time().
1922  *
1923  * Any time before the current monotonic time (including 0) is an
1924  * indication that the source will fire immediately.
1925  *
1926  * Returns: the monotonic ready time, -1 for &quot;never&quot;
1927  **/
1928 gint64
1929 g_source_get_ready_time (GSource *source)
1930 {
1931   g_return_val_if_fail (source != NULL, -1);
1932 
1933   return source-&gt;priv-&gt;ready_time;
1934 }
1935 
1936 /**
1937  * g_source_set_can_recurse:
1938  * @source: a #GSource
1939  * @can_recurse: whether recursion is allowed for this source
1940  *
1941  * Sets whether a source can be called recursively. If @can_recurse is
1942  * %TRUE, then while the source is being dispatched then this source
1943  * will be processed normally. Otherwise, all processing of this
1944  * source is blocked until the dispatch function returns.
1945  **/
1946 void
1947 g_source_set_can_recurse (GSource  *source,
<a name="77" id="anc77"></a><span class="line-modified">1948               gboolean  can_recurse)</span>
1949 {
1950   GMainContext *context;
1951 
1952   g_return_if_fail (source != NULL);
1953 
1954   context = source-&gt;context;
1955 
1956   if (context)
1957     LOCK_CONTEXT (context);
1958 
1959   if (can_recurse)
1960     source-&gt;flags |= G_SOURCE_CAN_RECURSE;
1961   else
1962     source-&gt;flags &amp;= ~G_SOURCE_CAN_RECURSE;
1963 
1964   if (context)
1965     UNLOCK_CONTEXT (context);
1966 }
1967 
1968 /**
1969  * g_source_get_can_recurse:
1970  * @source: a #GSource
1971  *
1972  * Checks whether a source is allowed to be called recursively.
1973  * see g_source_set_can_recurse().
1974  *
1975  * Returns: whether recursion is allowed.
1976  **/
1977 gboolean
1978 g_source_get_can_recurse (GSource  *source)
1979 {
1980   g_return_val_if_fail (source != NULL, FALSE);
1981 
1982   return (source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) != 0;
1983 }
1984 
1985 
1986 /**
1987  * g_source_set_name:
1988  * @source: a #GSource
1989  * @name: debug name for the source
1990  *
1991  * Sets a name for the source, used in debugging and profiling.
1992  * The name defaults to #NULL.
1993  *
1994  * The source name should describe in a human-readable way
1995  * what the source does. For example, &quot;X11 event queue&quot;
1996  * or &quot;GTK+ repaint idle handler&quot; or whatever it is.
1997  *
1998  * It is permitted to call this function multiple times, but is not
1999  * recommended due to the potential performance impact.  For example,
2000  * one could change the name in the &quot;check&quot; function of a #GSourceFuncs
2001  * to include details like the event type in the source name.
2002  *
2003  * Use caution if changing the name while another thread may be
2004  * accessing it with g_source_get_name(); that function does not copy
2005  * the value, and changing the value will free it while the other thread
2006  * may be attempting to use it.
2007  *
2008  * Since: 2.26
2009  **/
2010 void
2011 g_source_set_name (GSource    *source,
2012                    const char *name)
2013 {
2014   GMainContext *context;
2015 
2016   g_return_if_fail (source != NULL);
2017 
2018   context = source-&gt;context;
2019 
2020   if (context)
2021     LOCK_CONTEXT (context);
2022 
2023   TRACE (GLIB_SOURCE_SET_NAME (source, name));
2024 
2025   /* setting back to NULL is allowed, just because it&#39;s
2026    * weird if get_name can return NULL but you can&#39;t
2027    * set that.
2028    */
2029 
2030   g_free (source-&gt;name);
2031   source-&gt;name = g_strdup (name);
2032 
2033   if (context)
2034     UNLOCK_CONTEXT (context);
2035 }
2036 
2037 /**
2038  * g_source_get_name:
2039  * @source: a #GSource
2040  *
2041  * Gets a name for the source, used in debugging and profiling.  The
2042  * name may be #NULL if it has never been set with g_source_set_name().
2043  *
2044  * Returns: the name of the source
2045  *
2046  * Since: 2.26
2047  **/
2048 const char *
2049 g_source_get_name (GSource *source)
2050 {
2051   g_return_val_if_fail (source != NULL, NULL);
2052 
2053   return source-&gt;name;
2054 }
2055 
2056 /**
2057  * g_source_set_name_by_id:
2058  * @tag: a #GSource ID
2059  * @name: debug name for the source
2060  *
2061  * Sets the name of a source using its ID.
2062  *
2063  * This is a convenience utility to set source names from the return
2064  * value of g_idle_add(), g_timeout_add(), etc.
2065  *
2066  * It is a programmer error to attempt to set the name of a non-existent
2067  * source.
2068  *
2069  * More specifically: source IDs can be reissued after a source has been
2070  * destroyed and therefore it is never valid to use this function with a
2071  * source ID which may have already been removed.  An example is when
2072  * scheduling an idle to run in another thread with g_idle_add(): the
2073  * idle may already have run and been removed by the time this function
2074  * is called on its (now invalid) source ID.  This source ID may have
2075  * been reissued, leading to the operation being performed against the
2076  * wrong source.
2077  *
2078  * Since: 2.26
2079  **/
2080 void
2081 g_source_set_name_by_id (guint           tag,
2082                          const char     *name)
2083 {
2084   GSource *source;
2085 
2086   g_return_if_fail (tag &gt; 0);
2087 
2088   source = g_main_context_find_source_by_id (NULL, tag);
2089   if (source == NULL)
2090     return;
2091 
2092   g_source_set_name (source, name);
2093 }
2094 
2095 
2096 /**
2097  * g_source_ref:
2098  * @source: a #GSource
2099  *
2100  * Increases the reference count on a source by one.
2101  *
2102  * Returns: @source
2103  **/
2104 GSource *
2105 g_source_ref (GSource *source)
2106 {
<a name="78" id="anc78"></a><span class="line-removed">2107   GMainContext *context;</span>
<span class="line-removed">2108 </span>
2109   g_return_val_if_fail (source != NULL, NULL);
2110 
<a name="79" id="anc79"></a><span class="line-modified">2111   context = source-&gt;context;</span>
<span class="line-removed">2112 </span>
<span class="line-removed">2113   if (context)</span>
<span class="line-removed">2114     LOCK_CONTEXT (context);</span>
<span class="line-removed">2115 </span>
<span class="line-removed">2116   source-&gt;ref_count++;</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118   if (context)</span>
<span class="line-removed">2119     UNLOCK_CONTEXT (context);</span>
2120 
2121   return source;
2122 }
2123 
2124 /* g_source_unref() but possible to call within context lock
2125  */
2126 static void
2127 g_source_unref_internal (GSource      *source,
<a name="80" id="anc80"></a><span class="line-modified">2128              GMainContext *context,</span>
<span class="line-modified">2129              gboolean      have_lock)</span>
2130 {
2131   gpointer old_cb_data = NULL;
2132   GSourceCallbackFuncs *old_cb_funcs = NULL;
2133 
2134   g_return_if_fail (source != NULL);
2135 
2136   if (!have_lock &amp;&amp; context)
2137     LOCK_CONTEXT (context);
2138 
<a name="81" id="anc81"></a><span class="line-modified">2139   source-&gt;ref_count--;</span>
<span class="line-removed">2140   if (source-&gt;ref_count == 0)</span>
2141     {
2142       TRACE (GLIB_SOURCE_BEFORE_FREE (source, context,
2143                                       source-&gt;source_funcs-&gt;finalize));
2144 
2145       old_cb_data = source-&gt;callback_data;
2146       old_cb_funcs = source-&gt;callback_funcs;
2147 
2148       source-&gt;callback_data = NULL;
2149       source-&gt;callback_funcs = NULL;
2150 
2151       if (context)
<a name="82" id="anc82"></a><span class="line-modified">2152     {</span>
<span class="line-modified">2153       if (!SOURCE_DESTROYED (source))</span>
<span class="line-modified">2154         g_warning (G_STRLOC &quot;: ref_count == 0, but source was still attached to a context!&quot;);</span>
<span class="line-modified">2155       source_remove_from_context (source, context);</span>
2156 
2157           g_hash_table_remove (context-&gt;sources, GUINT_TO_POINTER (source-&gt;source_id));
<a name="83" id="anc83"></a><span class="line-modified">2158     }</span>
2159 
2160       if (source-&gt;source_funcs-&gt;finalize)
<a name="84" id="anc84"></a><span class="line-modified">2161     {</span>
2162           /* Temporarily increase the ref count again so that GSource methods
2163            * can be called from finalize(). */
<a name="85" id="anc85"></a><span class="line-modified">2164           source-&gt;ref_count++;</span>
<span class="line-modified">2165       if (context)</span>
<span class="line-modified">2166         UNLOCK_CONTEXT (context);</span>
<span class="line-modified">2167       source-&gt;source_funcs-&gt;finalize (source);</span>
<span class="line-modified">2168       if (context)</span>
<span class="line-modified">2169         LOCK_CONTEXT (context);</span>
<span class="line-modified">2170           source-&gt;ref_count--;</span>
<span class="line-modified">2171     }</span>
2172 
2173       if (old_cb_funcs)
2174         {
2175           /* Temporarily increase the ref count again so that GSource methods
2176            * can be called from callback_funcs.unref(). */
<a name="86" id="anc86"></a><span class="line-modified">2177           source-&gt;ref_count++;</span>
2178           if (context)
2179             UNLOCK_CONTEXT (context);
2180 
2181           old_cb_funcs-&gt;unref (old_cb_data);
2182 
2183           if (context)
2184             LOCK_CONTEXT (context);
<a name="87" id="anc87"></a><span class="line-modified">2185           source-&gt;ref_count--;</span>
2186         }
2187 
2188       g_free (source-&gt;name);
2189       source-&gt;name = NULL;
2190 
2191       g_slist_free (source-&gt;poll_fds);
2192       source-&gt;poll_fds = NULL;
2193 
2194       g_slist_free_full (source-&gt;priv-&gt;fds, g_free);
2195 
2196       while (source-&gt;priv-&gt;child_sources)
2197         {
2198           GSource *child_source = source-&gt;priv-&gt;child_sources-&gt;data;
2199 
2200           source-&gt;priv-&gt;child_sources =
2201             g_slist_remove (source-&gt;priv-&gt;child_sources, child_source);
2202           child_source-&gt;priv-&gt;parent_source = NULL;
2203 
2204           g_source_unref_internal (child_source, context, have_lock);
2205         }
2206 
2207       g_slice_free (GSourcePrivate, source-&gt;priv);
2208       source-&gt;priv = NULL;
2209 
2210       g_free (source);
2211     }
2212 
2213   if (!have_lock &amp;&amp; context)
2214     UNLOCK_CONTEXT (context);
<a name="88" id="anc88"></a><span class="line-modified">2215     }</span>
2216 
2217 /**
2218  * g_source_unref:
2219  * @source: a #GSource
2220  *
2221  * Decreases the reference count of a source by one. If the
2222  * resulting reference count is zero the source and associated
2223  * memory will be destroyed.
2224  **/
2225 void
2226 g_source_unref (GSource *source)
2227 {
2228   g_return_if_fail (source != NULL);
2229 #ifdef GSTREAMER_LITE
2230   if (source == NULL)
2231     return;
2232 #endif // GSTREAMER_LITE
2233 
2234   g_source_unref_internal (source, source-&gt;context, FALSE);
2235 }
2236 
2237 /**
2238  * g_main_context_find_source_by_id:
2239  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
2240  * @source_id: the source ID, as returned by g_source_get_id().
2241  *
2242  * Finds a #GSource given a pair of context and ID.
2243  *
<a name="89" id="anc89"></a><span class="line-modified">2244  * It is a programmer error to attempt to lookup a non-existent source.</span>
2245  *
2246  * More specifically: source IDs can be reissued after a source has been
2247  * destroyed and therefore it is never valid to use this function with a
2248  * source ID which may have already been removed.  An example is when
2249  * scheduling an idle to run in another thread with g_idle_add(): the
2250  * idle may already have run and been removed by the time this function
2251  * is called on its (now invalid) source ID.  This source ID may have
2252  * been reissued, leading to the operation being performed against the
2253  * wrong source.
2254  *
2255  * Returns: (transfer none): the #GSource
2256  **/
2257 GSource *
2258 g_main_context_find_source_by_id (GMainContext *context,
2259                                   guint         source_id)
2260 {
2261   GSource *source;
2262 
2263   g_return_val_if_fail (source_id &gt; 0, NULL);
2264 
2265   if (context == NULL)
2266     context = g_main_context_default ();
2267 
2268   LOCK_CONTEXT (context);
2269   source = g_hash_table_lookup (context-&gt;sources, GUINT_TO_POINTER (source_id));
2270   UNLOCK_CONTEXT (context);
2271 
2272   if (source &amp;&amp; SOURCE_DESTROYED (source))
2273     source = NULL;
2274 
2275   return source;
2276 }
2277 
2278 /**
2279  * g_main_context_find_source_by_funcs_user_data:
2280  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used).
2281  * @funcs: the @source_funcs passed to g_source_new().
2282  * @user_data: the user data from the callback.
2283  *
2284  * Finds a source with the given source functions and user data.  If
2285  * multiple sources exist with the same source function and user data,
2286  * the first one found will be returned.
2287  *
2288  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2289  **/
2290 GSource *
2291 g_main_context_find_source_by_funcs_user_data (GMainContext *context,
<a name="90" id="anc90"></a><span class="line-modified">2292                            GSourceFuncs *funcs,</span>
<span class="line-modified">2293                            gpointer      user_data)</span>
2294 {
2295   GSourceIter iter;
2296   GSource *source;
2297 
2298   g_return_val_if_fail (funcs != NULL, NULL);
2299 
2300   if (context == NULL)
2301     context = g_main_context_default ();
2302 
2303   LOCK_CONTEXT (context);
2304 
2305   g_source_iter_init (&amp;iter, context, FALSE);
2306   while (g_source_iter_next (&amp;iter, &amp;source))
2307     {
2308       if (!SOURCE_DESTROYED (source) &amp;&amp;
<a name="91" id="anc91"></a><span class="line-modified">2309       source-&gt;source_funcs == funcs &amp;&amp;</span>
<span class="line-modified">2310       source-&gt;callback_funcs)</span>
<span class="line-modified">2311     {</span>
<span class="line-modified">2312       GSourceFunc callback;</span>
<span class="line-modified">2313       gpointer callback_data;</span>
2314 
<a name="92" id="anc92"></a><span class="line-modified">2315       source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2316 
<a name="93" id="anc93"></a><span class="line-modified">2317       if (callback_data == user_data)</span>
<span class="line-modified">2318         break;</span>
<span class="line-modified">2319     }</span>
2320     }
2321   g_source_iter_clear (&amp;iter);
2322 
2323   UNLOCK_CONTEXT (context);
2324 
2325   return source;
2326 }
2327 
2328 /**
2329  * g_main_context_find_source_by_user_data:
2330  * @context: a #GMainContext
2331  * @user_data: the user_data for the callback.
2332  *
2333  * Finds a source with the given user data for the callback.  If
2334  * multiple sources exist with the same user data, the first
2335  * one found will be returned.
2336  *
2337  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2338  **/
2339 GSource *
2340 g_main_context_find_source_by_user_data (GMainContext *context,
<a name="94" id="anc94"></a><span class="line-modified">2341                      gpointer      user_data)</span>
2342 {
2343   GSourceIter iter;
2344   GSource *source;
2345 
2346   if (context == NULL)
2347     context = g_main_context_default ();
2348 
2349   LOCK_CONTEXT (context);
2350 
2351   g_source_iter_init (&amp;iter, context, FALSE);
2352   while (g_source_iter_next (&amp;iter, &amp;source))
2353     {
2354       if (!SOURCE_DESTROYED (source) &amp;&amp;
<a name="95" id="anc95"></a><span class="line-modified">2355       source-&gt;callback_funcs)</span>
<span class="line-modified">2356     {</span>
<span class="line-modified">2357       GSourceFunc callback;</span>
<span class="line-modified">2358       gpointer callback_data = NULL;</span>
2359 
<a name="96" id="anc96"></a><span class="line-modified">2360       source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2361 
<a name="97" id="anc97"></a><span class="line-modified">2362       if (callback_data == user_data)</span>
<span class="line-modified">2363         break;</span>
<span class="line-modified">2364     }</span>
2365     }
2366   g_source_iter_clear (&amp;iter);
2367 
2368   UNLOCK_CONTEXT (context);
2369 
2370   return source;
2371 }
2372 
2373 /**
2374  * g_source_remove:
2375  * @tag: the ID of the source to remove.
2376  *
2377  * Removes the source with the given ID from the default main context. You must
2378  * use g_source_destroy() for sources added to a non-default main context.
2379  *
2380  * The ID of a #GSource is given by g_source_get_id(), or will be
2381  * returned by the functions g_source_attach(), g_idle_add(),
2382  * g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
2383  * g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
2384  * g_io_add_watch_full().
2385  *
2386  * It is a programmer error to attempt to remove a non-existent source.
2387  *
2388  * More specifically: source IDs can be reissued after a source has been
2389  * destroyed and therefore it is never valid to use this function with a
2390  * source ID which may have already been removed.  An example is when
2391  * scheduling an idle to run in another thread with g_idle_add(): the
2392  * idle may already have run and been removed by the time this function
2393  * is called on its (now invalid) source ID.  This source ID may have
2394  * been reissued, leading to the operation being performed against the
2395  * wrong source.
2396  *
2397  * Returns: For historical reasons, this function always returns %TRUE
2398  **/
2399 gboolean
2400 g_source_remove (guint tag)
2401 {
2402   GSource *source;
2403 
2404   g_return_val_if_fail (tag &gt; 0, FALSE);
2405 
2406   source = g_main_context_find_source_by_id (NULL, tag);
2407   if (source)
2408     g_source_destroy (source);
2409   else
2410     g_critical (&quot;Source ID %u was not found when attempting to remove it&quot;, tag);
2411 
2412   return source != NULL;
2413 }
2414 
2415 /**
2416  * g_source_remove_by_user_data:
2417  * @user_data: the user_data for the callback.
2418  *
2419  * Removes a source from the default main loop context given the user
2420  * data for the callback. If multiple sources exist with the same user
2421  * data, only one will be destroyed.
2422  *
2423  * Returns: %TRUE if a source was found and removed.
2424  **/
2425 gboolean
2426 g_source_remove_by_user_data (gpointer user_data)
2427 {
2428   GSource *source;
2429 
2430   source = g_main_context_find_source_by_user_data (NULL, user_data);
2431   if (source)
2432     {
2433       g_source_destroy (source);
2434       return TRUE;
2435     }
2436   else
2437     return FALSE;
2438 }
2439 
2440 /**
2441  * g_source_remove_by_funcs_user_data:
2442  * @funcs: The @source_funcs passed to g_source_new()
2443  * @user_data: the user data for the callback
2444  *
2445  * Removes a source from the default main loop context given the
2446  * source functions and user data. If multiple sources exist with the
2447  * same source functions and user data, only one will be destroyed.
2448  *
2449  * Returns: %TRUE if a source was found and removed.
2450  **/
2451 gboolean
2452 g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
<a name="98" id="anc98"></a><span class="line-modified">2453                     gpointer      user_data)</span>
2454 {
2455   GSource *source;
2456 
2457   g_return_val_if_fail (funcs != NULL, FALSE);
2458 
2459   source = g_main_context_find_source_by_funcs_user_data (NULL, funcs, user_data);
2460   if (source)
2461     {
2462       g_source_destroy (source);
2463       return TRUE;
2464     }
2465   else
2466     return FALSE;
2467 }
2468 
2469 /**
2470  * g_clear_handle_id: (skip)
2471  * @tag_ptr: (not nullable): a pointer to the handler ID
2472  * @clear_func: (not nullable): the function to call to clear the handler
2473  *
2474  * Clears a numeric handler, such as a #GSource ID.
2475  *
2476  * @tag_ptr must be a valid pointer to the variable holding the handler.
2477  *
2478  * If the ID is zero then this function does nothing.
2479  * Otherwise, clear_func() is called with the ID as a parameter, and the tag is
2480  * set to zero.
2481  *
2482  * A macro is also included that allows this function to be used without
2483  * pointer casts.
2484  *
2485  * Since: 2.56
2486  */
2487 #undef g_clear_handle_id
2488 void
2489 g_clear_handle_id (guint            *tag_ptr,
2490                    GClearHandleFunc  clear_func)
2491 {
2492   guint _handle_id;
2493 
2494   _handle_id = *tag_ptr;
2495   if (_handle_id &gt; 0)
2496     {
2497       *tag_ptr = 0;
2498       clear_func (_handle_id);
2499     }
2500 }
2501 
2502 #ifdef G_OS_UNIX
2503 /**
2504  * g_source_add_unix_fd:
2505  * @source: a #GSource
2506  * @fd: the fd to monitor
2507  * @events: an event mask
2508  *
2509  * Monitors @fd for the IO events in @events.
2510  *
2511  * The tag returned by this function can be used to remove or modify the
2512  * monitoring of the fd using g_source_remove_unix_fd() or
2513  * g_source_modify_unix_fd().
2514  *
2515  * It is not necessary to remove the fd before destroying the source; it
2516  * will be cleaned up automatically.
2517  *
2518  * This API is only intended to be used by implementations of #GSource.
2519  * Do not call this API on a #GSource that you did not create.
2520  *
2521  * As the name suggests, this function is not available on Windows.
2522  *
2523  * Returns: (not nullable): an opaque tag
2524  *
2525  * Since: 2.36
2526  **/
2527 gpointer
2528 g_source_add_unix_fd (GSource      *source,
2529                       gint          fd,
2530                       GIOCondition  events)
2531 {
2532   GMainContext *context;
2533   GPollFD *poll_fd;
2534 
2535   g_return_val_if_fail (source != NULL, NULL);
2536   g_return_val_if_fail (!SOURCE_DESTROYED (source), NULL);
2537 
2538   poll_fd = g_new (GPollFD, 1);
2539   poll_fd-&gt;fd = fd;
2540   poll_fd-&gt;events = events;
2541   poll_fd-&gt;revents = 0;
2542 
2543   context = source-&gt;context;
2544 
2545   if (context)
2546     LOCK_CONTEXT (context);
2547 
2548   source-&gt;priv-&gt;fds = g_slist_prepend (source-&gt;priv-&gt;fds, poll_fd);
2549 
2550   if (context)
2551     {
2552       if (!SOURCE_BLOCKED (source))
2553         g_main_context_add_poll_unlocked (context, source-&gt;priority, poll_fd);
2554       UNLOCK_CONTEXT (context);
2555     }
2556 
2557   return poll_fd;
2558 }
2559 
2560 /**
2561  * g_source_modify_unix_fd:
2562  * @source: a #GSource
2563  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2564  * @new_events: the new event mask to watch
2565  *
2566  * Updates the event mask to watch for the fd identified by @tag.
2567  *
2568  * @tag is the tag returned from g_source_add_unix_fd().
2569  *
2570  * If you want to remove a fd, don&#39;t set its event mask to zero.
2571  * Instead, call g_source_remove_unix_fd().
2572  *
2573  * This API is only intended to be used by implementations of #GSource.
2574  * Do not call this API on a #GSource that you did not create.
2575  *
2576  * As the name suggests, this function is not available on Windows.
2577  *
2578  * Since: 2.36
2579  **/
2580 void
2581 g_source_modify_unix_fd (GSource      *source,
2582                          gpointer      tag,
2583                          GIOCondition  new_events)
2584 {
2585   GMainContext *context;
2586   GPollFD *poll_fd;
2587 
2588   g_return_if_fail (source != NULL);
2589   g_return_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag));
2590 
2591   context = source-&gt;context;
2592   poll_fd = tag;
2593 
2594   poll_fd-&gt;events = new_events;
2595 
2596   if (context)
2597     g_main_context_wakeup (context);
2598 }
2599 
2600 /**
2601  * g_source_remove_unix_fd:
2602  * @source: a #GSource
2603  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2604  *
2605  * Reverses the effect of a previous call to g_source_add_unix_fd().
2606  *
2607  * You only need to call this if you want to remove an fd from being
2608  * watched while keeping the same source around.  In the normal case you
2609  * will just want to destroy the source.
2610  *
2611  * This API is only intended to be used by implementations of #GSource.
2612  * Do not call this API on a #GSource that you did not create.
2613  *
2614  * As the name suggests, this function is not available on Windows.
2615  *
2616  * Since: 2.36
2617  **/
2618 void
2619 g_source_remove_unix_fd (GSource  *source,
2620                          gpointer  tag)
2621 {
2622   GMainContext *context;
2623   GPollFD *poll_fd;
2624 
2625   g_return_if_fail (source != NULL);
2626   g_return_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag));
2627 
2628   context = source-&gt;context;
2629   poll_fd = tag;
2630 
2631   if (context)
2632     LOCK_CONTEXT (context);
2633 
2634   source-&gt;priv-&gt;fds = g_slist_remove (source-&gt;priv-&gt;fds, poll_fd);
2635 
2636   if (context)
2637     {
2638       if (!SOURCE_BLOCKED (source))
2639         g_main_context_remove_poll_unlocked (context, poll_fd);
2640 
2641       UNLOCK_CONTEXT (context);
2642     }
2643 
2644   g_free (poll_fd);
2645 }
2646 
2647 /**
2648  * g_source_query_unix_fd:
2649  * @source: a #GSource
2650  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2651  *
2652  * Queries the events reported for the fd corresponding to @tag on
2653  * @source during the last poll.
2654  *
2655  * The return value of this function is only defined when the function
2656  * is called from the check or dispatch functions for @source.
2657  *
2658  * This API is only intended to be used by implementations of #GSource.
2659  * Do not call this API on a #GSource that you did not create.
2660  *
2661  * As the name suggests, this function is not available on Windows.
2662  *
2663  * Returns: the conditions reported on the fd
2664  *
2665  * Since: 2.36
2666  **/
2667 GIOCondition
2668 g_source_query_unix_fd (GSource  *source,
2669                         gpointer  tag)
2670 {
2671   GPollFD *poll_fd;
2672 
2673   g_return_val_if_fail (source != NULL, 0);
2674   g_return_val_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag), 0);
2675 
2676   poll_fd = tag;
2677 
2678   return poll_fd-&gt;revents;
2679 }
2680 #endif /* G_OS_UNIX */
2681 
2682 /**
2683  * g_get_current_time:
2684  * @result: #GTimeVal structure in which to store current time.
2685  *
2686  * Equivalent to the UNIX gettimeofday() function, but portable.
2687  *
2688  * You may find g_get_real_time() to be more convenient.
<a name="99" id="anc99"></a>


2689  **/
<a name="100" id="anc100"></a>
2690 void
2691 g_get_current_time (GTimeVal *result)
2692 {
<a name="101" id="anc101"></a><span class="line-modified">2693 #ifndef G_OS_WIN32</span>
<span class="line-removed">2694   struct timeval r;</span>
<span class="line-removed">2695 </span>
<span class="line-removed">2696   g_return_if_fail (result != NULL);</span>
<span class="line-removed">2697 </span>
<span class="line-removed">2698   /*this is required on alpha, there the timeval structs are int&#39;s</span>
<span class="line-removed">2699     not longs and a cast only would fail horribly*/</span>
<span class="line-removed">2700   gettimeofday (&amp;r, NULL);</span>
<span class="line-removed">2701   result-&gt;tv_sec = r.tv_sec;</span>
<span class="line-removed">2702   result-&gt;tv_usec = r.tv_usec;</span>
<span class="line-removed">2703 #else</span>
<span class="line-removed">2704   FILETIME ft;</span>
<span class="line-removed">2705   guint64 time64;</span>
2706 
2707   g_return_if_fail (result != NULL);
2708 
<a name="102" id="anc102"></a><span class="line-modified">2709   GetSystemTimeAsFileTime (&amp;ft);</span>
<span class="line-removed">2710   memmove (&amp;time64, &amp;ft, sizeof (FILETIME));</span>
2711 
<a name="103" id="anc103"></a><span class="line-modified">2712   /* Convert from 100s of nanoseconds since 1601-01-01</span>
<span class="line-modified">2713    * to Unix epoch. Yes, this is Y2038 unsafe.</span>
<span class="line-removed">2714    */</span>
<span class="line-removed">2715   time64 -= G_GINT64_CONSTANT (116444736000000000);</span>
<span class="line-removed">2716   time64 /= 10;</span>
<span class="line-removed">2717 </span>
<span class="line-removed">2718   result-&gt;tv_sec = time64 / 1000000;</span>
<span class="line-removed">2719   result-&gt;tv_usec = time64 % 1000000;</span>
<span class="line-removed">2720 #endif</span>
2721 }
<a name="104" id="anc104"></a>
2722 
2723 /**
2724  * g_get_real_time:
2725  *
2726  * Queries the system wall-clock time.
2727  *
2728  * This call is functionally equivalent to g_get_current_time() except
2729  * that the return value is often more convenient than dealing with a
2730  * #GTimeVal.
2731  *
2732  * You should only use this call if you are actually interested in the real
2733  * wall-clock time.  g_get_monotonic_time() is probably more useful for
2734  * measuring intervals.
2735  *
2736  * Returns: the number of microseconds since January 1, 1970 UTC.
2737  *
2738  * Since: 2.28
2739  **/
2740 gint64
2741 g_get_real_time (void)
2742 {
<a name="105" id="anc105"></a><span class="line-modified">2743   GTimeVal tv;</span>

2744 
<a name="106" id="anc106"></a><span class="line-modified">2745   g_get_current_time (&amp;tv);</span>


2746 
<a name="107" id="anc107"></a><span class="line-modified">2747   return (((gint64) tv.tv_sec) * 1000000) + tv.tv_usec;</span>















2748 }
2749 
2750 /**
2751  * g_get_monotonic_time:
2752  *
2753  * Queries the system monotonic time.
2754  *
2755  * The monotonic clock will always increase and doesn&#39;t suffer
2756  * discontinuities when the user (or NTP) changes the system time.  It
2757  * may or may not continue to tick during times where the machine is
2758  * suspended.
2759  *
2760  * We try to use the clock that corresponds as closely as possible to
2761  * the passage of time as measured by system calls such as poll() but it
2762  * may not always be possible to do this.
2763  *
2764  * Returns: the monotonic time, in microseconds
2765  *
2766  * Since: 2.28
2767  **/
2768 #if defined (G_OS_WIN32)
2769 /* NOTE:
2770  * time_usec = ticks_since_boot * usec_per_sec / ticks_per_sec
2771  *
2772  * Doing (ticks_since_boot * usec_per_sec) before the division can overflow 64 bits
2773  * (ticks_since_boot  / ticks_per_sec) and then multiply would not be accurate enough.
2774  * So for now we calculate (usec_per_sec / ticks_per_sec) and use floating point
2775  */
2776 static gdouble g_monotonic_usec_per_tick = 0;
2777 
2778 void
2779 g_clock_win32_init (void)
2780 {
2781   LARGE_INTEGER freq;
2782 
2783   if (!QueryPerformanceFrequency (&amp;freq) || freq.QuadPart == 0)
2784     {
2785       /* The documentation says that this should never happen */
2786       g_assert_not_reached ();
2787       return;
<a name="108" id="anc108"></a><span class="line-modified">2788 }</span>
2789 
2790   g_monotonic_usec_per_tick = (gdouble)G_USEC_PER_SEC / freq.QuadPart;
2791 }
2792 
2793 gint64
2794 g_get_monotonic_time (void)
2795 {
2796   if (G_LIKELY (g_monotonic_usec_per_tick != 0))
2797     {
2798       LARGE_INTEGER ticks;
2799 
2800       if (QueryPerformanceCounter (&amp;ticks))
2801         return (gint64)(ticks.QuadPart * g_monotonic_usec_per_tick);
2802 
2803       g_warning (&quot;QueryPerformanceCounter Failed (%lu)&quot;, GetLastError ());
2804       g_monotonic_usec_per_tick = 0;
2805     }
2806 
2807   return 0;
<a name="109" id="anc109"></a><span class="line-modified">2808         }</span>
2809 #elif defined(HAVE_MACH_MACH_TIME_H) /* Mac OS */
2810 gint64
2811 g_get_monotonic_time (void)
2812 {
2813   static mach_timebase_info_data_t timebase_info;
2814 
2815   if (timebase_info.denom == 0)
2816     {
2817       /* This is a fraction that we must use to scale
2818        * mach_absolute_time() by in order to reach nanoseconds.
2819        *
2820        * We&#39;ve only ever observed this to be 1/1, but maybe it could be
2821        * 1000/1 if mach time is microseconds already, or 1/1000 if
2822        * picoseconds.  Try to deal nicely with that.
2823        */
2824       mach_timebase_info (&amp;timebase_info);
2825 
2826       /* We actually want microseconds... */
2827       if (timebase_info.numer % 1000 == 0)
2828         timebase_info.numer /= 1000;
2829       else
2830         timebase_info.denom *= 1000;
2831 
2832       /* We want to make the numer 1 to avoid having to multiply... */
2833       if (timebase_info.denom % timebase_info.numer == 0)
2834         {
2835           timebase_info.denom /= timebase_info.numer;
2836           timebase_info.numer = 1;
2837         }
2838       else
2839         {
2840           /* We could just multiply by timebase_info.numer below, but why
2841            * bother for a case that may never actually exist...
2842            *
2843            * Plus -- performing the multiplication would risk integer
2844            * overflow.  If we ever actually end up in this situation, we
2845            * should more carefully evaluate the correct course of action.
2846            */
2847           mach_timebase_info (&amp;timebase_info); /* Get a fresh copy for a better message */
2848           g_error (&quot;Got weird mach timebase info of %d/%d.  Please file a bug against GLib.&quot;,
2849                    timebase_info.numer, timebase_info.denom);
2850         }
2851     }
2852 
2853   return mach_absolute_time () / timebase_info.denom;
2854 }
2855 #else
2856 gint64
2857 g_get_monotonic_time (void)
2858 {
2859   struct timespec ts;
2860   gint result;
2861 
2862   result = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
2863 
2864   if G_UNLIKELY (result != 0)
2865     g_error (&quot;GLib requires working CLOCK_MONOTONIC&quot;);
2866 
2867   return (((gint64) ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);
2868 }
2869 #endif
2870 
2871 static void
2872 g_main_dispatch_free (gpointer dispatch)
2873 {
<a name="110" id="anc110"></a><span class="line-modified">2874   g_slice_free (GMainDispatch, dispatch);</span>
2875 }
2876 
2877 /* Running the main loop */
2878 
2879 static GMainDispatch *
2880 get_dispatch (void)
2881 {
2882   static GPrivate depth_private = G_PRIVATE_INIT (g_main_dispatch_free);
2883   GMainDispatch *dispatch;
2884 
2885   dispatch = g_private_get (&amp;depth_private);
2886 
2887   if (!dispatch)
<a name="111" id="anc111"></a><span class="line-modified">2888     {</span>
<span class="line-removed">2889       dispatch = g_slice_new0 (GMainDispatch);</span>
<span class="line-removed">2890       g_private_set (&amp;depth_private, dispatch);</span>
<span class="line-removed">2891     }</span>
2892 
2893   return dispatch;
2894 }
2895 
2896 /**
2897  * g_main_depth:
2898  *
2899  * Returns the depth of the stack of calls to
2900  * g_main_context_dispatch() on any #GMainContext in the current thread.
2901  *  That is, when called from the toplevel, it gives 0. When
2902  * called from within a callback from g_main_context_iteration()
2903  * (or g_main_loop_run(), etc.) it returns 1. When called from within
2904  * a callback to a recursive call to g_main_context_iteration(),
2905  * it returns 2. And so forth.
2906  *
2907  * This function is useful in a situation like the following:
2908  * Imagine an extremely simple &quot;garbage collected&quot; system.
2909  *
2910  * |[&lt;!-- language=&quot;C&quot; --&gt;
2911  * static GList *free_list;
2912  *
2913  * gpointer
2914  * allocate_memory (gsize size)
2915  * {
2916  *   gpointer result = g_malloc (size);
2917  *   free_list = g_list_prepend (free_list, result);
2918  *   return result;
2919  * }
2920  *
2921  * void
2922  * free_allocated_memory (void)
2923  * {
2924  *   GList *l;
2925  *   for (l = free_list; l; l = l-&gt;next);
2926  *     g_free (l-&gt;data);
2927  *   g_list_free (free_list);
2928  *   free_list = NULL;
2929  *  }
2930  *
2931  * [...]
2932  *
2933  * while (TRUE);
2934  *  {
2935  *    g_main_context_iteration (NULL, TRUE);
2936  *    free_allocated_memory();
2937  *   }
2938  * ]|
2939  *
2940  * This works from an application, however, if you want to do the same
2941  * thing from a library, it gets more difficult, since you no longer
2942  * control the main loop. You might think you can simply use an idle
2943  * function to make the call to free_allocated_memory(), but that
2944  * doesn&#39;t work, since the idle function could be called from a
2945  * recursive callback. This can be fixed by using g_main_depth()
2946  *
2947  * |[&lt;!-- language=&quot;C&quot; --&gt;
2948  * gpointer
2949  * allocate_memory (gsize size)
2950  * {
2951  *   FreeListBlock *block = g_new (FreeListBlock, 1);
2952  *   block-&gt;mem = g_malloc (size);
2953  *   block-&gt;depth = g_main_depth ();
2954  *   free_list = g_list_prepend (free_list, block);
2955  *   return block-&gt;mem;
2956  * }
2957  *
2958  * void
2959  * free_allocated_memory (void)
2960  * {
2961  *   GList *l;
2962  *
2963  *   int depth = g_main_depth ();
2964  *   for (l = free_list; l; );
2965  *     {
2966  *       GList *next = l-&gt;next;
2967  *       FreeListBlock *block = l-&gt;data;
2968  *       if (block-&gt;depth &gt; depth)
2969  *         {
2970  *           g_free (block-&gt;mem);
2971  *           g_free (block);
2972  *           free_list = g_list_delete_link (free_list, l);
2973  *         }
2974  *
2975  *       l = next;
2976  *     }
2977  *   }
2978  * ]|
2979  *
2980  * There is a temptation to use g_main_depth() to solve
2981  * problems with reentrancy. For instance, while waiting for data
2982  * to be received from the network in response to a menu item,
2983  * the menu item might be selected again. It might seem that
2984  * one could make the menu item&#39;s callback return immediately
2985  * and do nothing if g_main_depth() returns a value greater than 1.
2986  * However, this should be avoided since the user then sees selecting
2987  * the menu item do nothing. Furthermore, you&#39;ll find yourself adding
2988  * these checks all over your code, since there are doubtless many,
2989  * many things that the user could do. Instead, you can use the
2990  * following techniques:
2991  *
2992  * 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
2993  *    the user from interacting with elements while the main
2994  *    loop is recursing.
2995  *
2996  * 2. Avoid main loop recursion in situations where you can&#39;t handle
2997  *    arbitrary  callbacks. Instead, structure your code so that you
2998  *    simply return to the main loop and then get called again when
2999  *    there is more work to do.
3000  *
3001  * Returns: The main loop recursion level in the current thread
3002  */
3003 int
3004 g_main_depth (void)
3005 {
3006   GMainDispatch *dispatch = get_dispatch ();
3007   return dispatch-&gt;depth;
3008 }
3009 
3010 /**
3011  * g_main_current_source:
3012  *
3013  * Returns the currently firing source for this thread.
3014  *
3015  * Returns: (transfer none): The currently firing source or %NULL.
3016  *
3017  * Since: 2.12
3018  */
3019 GSource *
3020 g_main_current_source (void)
3021 {
3022   GMainDispatch *dispatch = get_dispatch ();
3023   return dispatch-&gt;source;
3024 }
3025 
3026 /**
3027  * g_source_is_destroyed:
3028  * @source: a #GSource
3029  *
3030  * Returns whether @source has been destroyed.
3031  *
3032  * This is important when you operate upon your objects
3033  * from within idle handlers, but may have freed the object
3034  * before the dispatch of your idle handler.
3035  *
3036  * |[&lt;!-- language=&quot;C&quot; --&gt;
3037  * static gboolean
3038  * idle_callback (gpointer data)
3039  * {
3040  *   SomeWidget *self = data;
3041  *
3042  *   GDK_THREADS_ENTER ();
3043  *   // do stuff with self
3044  *   self-&gt;idle_id = 0;
3045  *   GDK_THREADS_LEAVE ();
3046  *
3047  *   return G_SOURCE_REMOVE;
3048  * }
3049  *
3050  * static void
3051  * some_widget_do_stuff_later (SomeWidget *self)
3052  * {
3053  *   self-&gt;idle_id = g_idle_add (idle_callback, self);
3054  * }
3055  *
3056  * static void
3057  * some_widget_finalize (GObject *object)
3058  * {
3059  *   SomeWidget *self = SOME_WIDGET (object);
3060  *
3061  *   if (self-&gt;idle_id)
3062  *     g_source_remove (self-&gt;idle_id);
3063  *
3064  *   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
3065  * }
3066  * ]|
3067  *
3068  * This will fail in a multi-threaded application if the
3069  * widget is destroyed before the idle handler fires due
3070  * to the use after free in the callback. A solution, to
3071  * this particular problem, is to check to if the source
3072  * has already been destroy within the callback.
3073  *
3074  * |[&lt;!-- language=&quot;C&quot; --&gt;
3075  * static gboolean
3076  * idle_callback (gpointer data)
3077  * {
3078  *   SomeWidget *self = data;
3079  *
3080  *   GDK_THREADS_ENTER ();
3081  *   if (!g_source_is_destroyed (g_main_current_source ()))
3082  *     {
3083  *       // do stuff with self
3084  *     }
3085  *   GDK_THREADS_LEAVE ();
3086  *
3087  *   return FALSE;
3088  * }
3089  * ]|
3090  *
3091  * Calls to this function from a thread other than the one acquired by the
3092  * #GMainContext the #GSource is attached to are typically redundant, as the
3093  * source could be destroyed immediately after this function returns. However,
3094  * once a source is destroyed it cannot be un-destroyed, so this function can be
3095  * used for opportunistic checks from any thread.
3096  *
3097  * Returns: %TRUE if the source has been destroyed
3098  *
3099  * Since: 2.12
3100  */
3101 gboolean
3102 g_source_is_destroyed (GSource *source)
3103 {
3104   return SOURCE_DESTROYED (source);
3105 }
3106 
3107 /* Temporarily remove all this source&#39;s file descriptors from the
3108  * poll(), so that if data comes available for one of the file descriptors
3109  * we don&#39;t continually spin in the poll()
3110  */
3111 /* HOLDS: source-&gt;context&#39;s lock */
3112 static void
3113 block_source (GSource *source)
3114 {
3115   GSList *tmp_list;
3116 
3117   g_return_if_fail (!SOURCE_BLOCKED (source));
3118 
3119   source-&gt;flags |= G_SOURCE_BLOCKED;
3120 
3121   if (source-&gt;context)
3122     {
3123       tmp_list = source-&gt;poll_fds;
3124       while (tmp_list)
3125         {
3126           g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3127           tmp_list = tmp_list-&gt;next;
3128         }
3129 
3130       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3131         g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3132     }
3133 
3134   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3135     {
3136       tmp_list = source-&gt;priv-&gt;child_sources;
3137       while (tmp_list)
<a name="112" id="anc112"></a><span class="line-modified">3138     {</span>
<span class="line-modified">3139       block_source (tmp_list-&gt;data);</span>
<span class="line-modified">3140       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3141     }</span>
3142     }
3143 }
3144 
3145 /* HOLDS: source-&gt;context&#39;s lock */
3146 static void
3147 unblock_source (GSource *source)
3148 {
3149   GSList *tmp_list;
3150 
3151   g_return_if_fail (SOURCE_BLOCKED (source)); /* Source already unblocked */
3152   g_return_if_fail (!SOURCE_DESTROYED (source));
3153 
3154   source-&gt;flags &amp;= ~G_SOURCE_BLOCKED;
3155 
3156   tmp_list = source-&gt;poll_fds;
3157   while (tmp_list)
3158     {
3159       g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3160       tmp_list = tmp_list-&gt;next;
3161     }
3162 
3163   for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3164     g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3165 
3166   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3167     {
3168       tmp_list = source-&gt;priv-&gt;child_sources;
3169       while (tmp_list)
<a name="113" id="anc113"></a><span class="line-modified">3170     {</span>
<span class="line-modified">3171       unblock_source (tmp_list-&gt;data);</span>
<span class="line-modified">3172       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3173     }</span>
3174     }
3175 }
3176 
3177 /* HOLDS: context&#39;s lock */
3178 static void
3179 g_main_dispatch (GMainContext *context)
3180 {
3181   GMainDispatch *current = get_dispatch ();
3182   guint i;
3183 
3184   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3185     {
3186       GSource *source = context-&gt;pending_dispatches-&gt;pdata[i];
3187 
3188       context-&gt;pending_dispatches-&gt;pdata[i] = NULL;
3189       g_assert (source);
3190 
3191       source-&gt;flags &amp;= ~G_SOURCE_READY;
3192 
3193       if (!SOURCE_DESTROYED (source))
<a name="114" id="anc114"></a><span class="line-modified">3194     {</span>
<span class="line-modified">3195       gboolean was_in_call;</span>
<span class="line-modified">3196       gpointer user_data = NULL;</span>
<span class="line-modified">3197       GSourceFunc callback = NULL;</span>
<span class="line-modified">3198       GSourceCallbackFuncs *cb_funcs;</span>
<span class="line-modified">3199       gpointer cb_data;</span>
<span class="line-modified">3200       gboolean need_destroy;</span>
<span class="line-modified">3201 </span>
<span class="line-modified">3202       gboolean (*dispatch) (GSource *,</span>
<span class="line-modified">3203                 GSourceFunc,</span>
<span class="line-modified">3204                 gpointer);</span>
3205           GSource *prev_source;
3206 
<a name="115" id="anc115"></a><span class="line-modified">3207       dispatch = source-&gt;source_funcs-&gt;dispatch;</span>
<span class="line-modified">3208       cb_funcs = source-&gt;callback_funcs;</span>
<span class="line-modified">3209       cb_data = source-&gt;callback_data;</span>
3210 
<a name="116" id="anc116"></a><span class="line-modified">3211       if (cb_funcs)</span>
<span class="line-modified">3212         cb_funcs-&gt;ref (cb_data);</span>
3213 
<a name="117" id="anc117"></a><span class="line-modified">3214       if ((source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) == 0)</span>
<span class="line-modified">3215         block_source (source);</span>
3216 
<a name="118" id="anc118"></a><span class="line-modified">3217       was_in_call = source-&gt;flags &amp; G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">3218       source-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
3219 
<a name="119" id="anc119"></a><span class="line-modified">3220       if (cb_funcs)</span>
<span class="line-modified">3221         cb_funcs-&gt;get (cb_data, source, &amp;callback, &amp;user_data);</span>
3222 
<a name="120" id="anc120"></a><span class="line-modified">3223       UNLOCK_CONTEXT (context);</span>
3224 
3225           /* These operations are safe because &#39;current&#39; is thread-local
3226            * and not modified from anywhere but this function.
3227            */
3228           prev_source = current-&gt;source;
3229           current-&gt;source = source;
3230           current-&gt;depth++;
3231 
3232           TRACE (GLIB_MAIN_BEFORE_DISPATCH (g_source_get_name (source), source,
3233                                             dispatch, callback, user_data));
3234           need_destroy = !(* dispatch) (source, callback, user_data);
3235           TRACE (GLIB_MAIN_AFTER_DISPATCH (g_source_get_name (source), source,
3236                                            dispatch, need_destroy));
3237 
3238           current-&gt;source = prev_source;
3239           current-&gt;depth--;
3240 
<a name="121" id="anc121"></a><span class="line-modified">3241       if (cb_funcs)</span>
<span class="line-modified">3242         cb_funcs-&gt;unref (cb_data);</span>
3243 
<a name="122" id="anc122"></a><span class="line-modified">3244       LOCK_CONTEXT (context);</span>
3245 
<a name="123" id="anc123"></a><span class="line-modified">3246       if (!was_in_call)</span>
<span class="line-modified">3247         source-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
3248 
<a name="124" id="anc124"></a><span class="line-modified">3249       if (SOURCE_BLOCKED (source) &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3250         unblock_source (source);</span>
3251 
<a name="125" id="anc125"></a><span class="line-modified">3252       /* Note: this depends on the fact that we can&#39;t switch</span>
<span class="line-modified">3253        * sources from one main context to another</span>
<span class="line-modified">3254        */</span>
<span class="line-modified">3255       if (need_destroy &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3256         {</span>
<span class="line-modified">3257           g_assert (source-&gt;context == context);</span>
<span class="line-modified">3258           g_source_destroy_internal (source, context, TRUE);</span>
<span class="line-modified">3259         }</span>
<span class="line-modified">3260     }</span>
3261 
<a name="126" id="anc126"></a><span class="line-modified">3262       SOURCE_UNREF (source, context);</span>
3263     }
3264 
3265   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3266 }
3267 
3268 /**
3269  * g_main_context_acquire:
3270  * @context: a #GMainContext
3271  *
3272  * Tries to become the owner of the specified context.
3273  * If some other thread is the owner of the context,
3274  * returns %FALSE immediately. Ownership is properly
3275  * recursive: the owner can require ownership again
3276  * and will release ownership when g_main_context_release()
3277  * is called as many times as g_main_context_acquire().
3278  *
3279  * You must be the owner of a context before you
3280  * can call g_main_context_prepare(), g_main_context_query(),
3281  * g_main_context_check(), g_main_context_dispatch().
3282  *
3283  * Returns: %TRUE if the operation succeeded, and
3284  *   this thread is now the owner of @context.
3285  **/
3286 gboolean
3287 g_main_context_acquire (GMainContext *context)
3288 {
3289   gboolean result = FALSE;
3290   GThread *self = G_THREAD_SELF;
3291 
3292   if (context == NULL)
3293     context = g_main_context_default ();
3294 
3295   LOCK_CONTEXT (context);
3296 
3297   if (!context-&gt;owner)
3298     {
3299       context-&gt;owner = self;
3300       g_assert (context-&gt;owner_count == 0);
3301       TRACE (GLIB_MAIN_CONTEXT_ACQUIRE (context, TRUE  /* success */));
3302     }
3303 
3304   if (context-&gt;owner == self)
3305     {
3306       context-&gt;owner_count++;
3307       result = TRUE;
3308     }
3309   else
3310     {
3311       TRACE (GLIB_MAIN_CONTEXT_ACQUIRE (context, FALSE  /* failure */));
3312     }
3313 
3314   UNLOCK_CONTEXT (context);
3315 
3316   return result;
3317 }
3318 
3319 /**
3320  * g_main_context_release:
3321  * @context: a #GMainContext
3322  *
3323  * Releases ownership of a context previously acquired by this thread
3324  * with g_main_context_acquire(). If the context was acquired multiple
3325  * times, the ownership will be released only when g_main_context_release()
3326  * is called as many times as it was acquired.
3327  **/
3328 void
3329 g_main_context_release (GMainContext *context)
3330 {
3331   if (context == NULL)
3332     context = g_main_context_default ();
3333 
3334   LOCK_CONTEXT (context);
3335 
3336   context-&gt;owner_count--;
3337   if (context-&gt;owner_count == 0)
3338     {
3339       TRACE (GLIB_MAIN_CONTEXT_RELEASE (context));
3340 
3341       context-&gt;owner = NULL;
3342 
3343       if (context-&gt;waiters)
<a name="127" id="anc127"></a><span class="line-modified">3344     {</span>
<span class="line-modified">3345       GMainWaiter *waiter = context-&gt;waiters-&gt;data;</span>
<span class="line-modified">3346       gboolean loop_internal_waiter = (waiter-&gt;mutex == &amp;context-&gt;mutex);</span>
<span class="line-modified">3347       context-&gt;waiters = g_slist_delete_link (context-&gt;waiters,</span>
<span class="line-modified">3348                           context-&gt;waiters);</span>
<span class="line-modified">3349       if (!loop_internal_waiter)</span>
<span class="line-modified">3350         g_mutex_lock (waiter-&gt;mutex);</span>
3351 
<a name="128" id="anc128"></a><span class="line-modified">3352       g_cond_signal (waiter-&gt;cond);</span>
3353 
<a name="129" id="anc129"></a><span class="line-modified">3354       if (!loop_internal_waiter)</span>
<span class="line-modified">3355         g_mutex_unlock (waiter-&gt;mutex);</span>
<span class="line-modified">3356     }</span>
3357     }
3358 
3359   UNLOCK_CONTEXT (context);
3360 }
3361 
3362 static gboolean
3363 g_main_context_wait_internal (GMainContext *context,
<a name="130" id="anc130"></a><span class="line-modified">3364              GCond        *cond,</span>
<span class="line-modified">3365              GMutex       *mutex)</span>
3366 {
3367   gboolean result = FALSE;
3368   GThread *self = G_THREAD_SELF;
3369   gboolean loop_internal_waiter;
3370 
3371   if (context == NULL)
3372     context = g_main_context_default ();
3373 
3374   loop_internal_waiter = (mutex == &amp;context-&gt;mutex);
3375 
3376   if (!loop_internal_waiter)
3377     LOCK_CONTEXT (context);
3378 
3379   if (context-&gt;owner &amp;&amp; context-&gt;owner != self)
3380     {
3381       GMainWaiter waiter;
3382 
3383       waiter.cond = cond;
3384       waiter.mutex = mutex;
3385 
3386       context-&gt;waiters = g_slist_append (context-&gt;waiters, &amp;waiter);
3387 
3388       if (!loop_internal_waiter)
<a name="131" id="anc131"></a><span class="line-modified">3389     UNLOCK_CONTEXT (context);</span>
3390       g_cond_wait (cond, mutex);
3391       if (!loop_internal_waiter)
<a name="132" id="anc132"></a><span class="line-modified">3392     LOCK_CONTEXT (context);</span>
3393 
3394       context-&gt;waiters = g_slist_remove (context-&gt;waiters, &amp;waiter);
3395     }
3396 
3397   if (!context-&gt;owner)
3398     {
3399       context-&gt;owner = self;
3400       g_assert (context-&gt;owner_count == 0);
3401     }
3402 
3403   if (context-&gt;owner == self)
3404     {
3405       context-&gt;owner_count++;
3406       result = TRUE;
3407     }
3408 
3409   if (!loop_internal_waiter)
3410     UNLOCK_CONTEXT (context);
3411 
3412   return result;
3413 }
3414 
3415 /**
3416  * g_main_context_wait:
3417  * @context: a #GMainContext
3418  * @cond: a condition variable
3419  * @mutex: a mutex, currently held
3420  *
3421  * Tries to become the owner of the specified context,
3422  * as with g_main_context_acquire(). But if another thread
3423  * is the owner, atomically drop @mutex and wait on @cond until
3424  * that owner releases ownership or until @cond is signaled, then
3425  * try again (once) to become the owner.
3426  *
3427  * Returns: %TRUE if the operation succeeded, and
3428  *   this thread is now the owner of @context.
3429  * Deprecated: 2.58: Use g_main_context_is_owner() and separate locking instead.
3430  */
3431 gboolean
3432 g_main_context_wait (GMainContext *context,
3433                      GCond        *cond,
3434                      GMutex       *mutex)
3435 {
3436   if (context == NULL)
3437     context = g_main_context_default ();
3438 
3439   if (G_UNLIKELY (cond != &amp;context-&gt;cond || mutex != &amp;context-&gt;mutex))
3440     {
3441       static gboolean warned;
3442 
3443       if (!warned)
3444         {
3445           g_critical (&quot;WARNING!! g_main_context_wait() will be removed in a future release.  &quot;
3446                       &quot;If you see this message, please file a bug immediately.&quot;);
3447           warned = TRUE;
3448         }
3449     }
3450 
3451   return g_main_context_wait_internal (context, cond, mutex);
3452 }
3453 
3454 /**
3455  * g_main_context_prepare:
3456  * @context: a #GMainContext
<a name="133" id="anc133"></a><span class="line-modified">3457  * @priority: location to store priority of highest priority</span>
3458  *            source already ready.
3459  *
3460  * Prepares to poll sources within a main loop. The resulting information
3461  * for polling is determined by calling g_main_context_query ().
3462  *
3463  * You must have successfully acquired the context with
3464  * g_main_context_acquire() before you may call this function.
3465  *
3466  * Returns: %TRUE if some source is ready to be dispatched
3467  *               prior to polling.
3468  **/
3469 gboolean
3470 g_main_context_prepare (GMainContext *context,
<a name="134" id="anc134"></a><span class="line-modified">3471             gint         *priority)</span>
3472 {
3473   guint i;
3474   gint n_ready = 0;
3475   gint current_priority = G_MAXINT;
3476   GSource *source;
3477   GSourceIter iter;
3478 
3479   if (context == NULL)
3480     context = g_main_context_default ();
3481 
3482   LOCK_CONTEXT (context);
3483 
3484   context-&gt;time_is_fresh = FALSE;
3485 
3486   if (context-&gt;in_check_or_prepare)
3487     {
3488       g_warning (&quot;g_main_context_prepare() called recursively from within a source&#39;s check() or &quot;
<a name="135" id="anc135"></a><span class="line-modified">3489          &quot;prepare() member.&quot;);</span>
3490       UNLOCK_CONTEXT (context);
3491       return FALSE;
3492     }
3493 
3494   TRACE (GLIB_MAIN_CONTEXT_BEFORE_PREPARE (context));
3495 
3496 #if 0
3497   /* If recursing, finish up current dispatch, before starting over */
3498   if (context-&gt;pending_dispatches)
3499     {
3500       if (dispatch)
<a name="136" id="anc136"></a><span class="line-modified">3501     g_main_dispatch (context, &amp;current_time);</span>
3502 
3503       UNLOCK_CONTEXT (context);
3504       return TRUE;
3505     }
3506 #endif
3507 
3508   /* If recursing, clear list of pending dispatches */
3509 
3510   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3511     {
3512       if (context-&gt;pending_dispatches-&gt;pdata[i])
<a name="137" id="anc137"></a><span class="line-modified">3513     SOURCE_UNREF ((GSource *)context-&gt;pending_dispatches-&gt;pdata[i], context);</span>
3514     }
3515   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3516 
3517   /* Prepare all sources */
3518 
3519   context-&gt;timeout = -1;
3520 
3521   g_source_iter_init (&amp;iter, context, TRUE);
3522   while (g_source_iter_next (&amp;iter, &amp;source))
3523     {
3524       gint source_timeout = -1;
3525 
3526       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<a name="138" id="anc138"></a><span class="line-modified">3527     continue;</span>
3528       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; current_priority))
<a name="139" id="anc139"></a><span class="line-modified">3529     break;</span>
3530 
3531       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<a name="140" id="anc140"></a><span class="line-modified">3532     {</span>
<span class="line-modified">3533       gboolean result;</span>
<span class="line-modified">3534       gboolean (* prepare) (GSource  *source,</span>
3535                                 gint     *timeout);
3536 
3537           prepare = source-&gt;source_funcs-&gt;prepare;
3538 
3539           if (prepare)
3540             {
3541               context-&gt;in_check_or_prepare++;
3542               UNLOCK_CONTEXT (context);
3543 
3544               result = (* prepare) (source, &amp;source_timeout);
3545               TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout));
3546 
3547               LOCK_CONTEXT (context);
3548               context-&gt;in_check_or_prepare--;
3549             }
3550           else
3551             {
3552               source_timeout = -1;
3553               result = FALSE;
3554             }
3555 
3556           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3557             {
3558               if (!context-&gt;time_is_fresh)
3559                 {
3560                   context-&gt;time = g_get_monotonic_time ();
3561                   context-&gt;time_is_fresh = TRUE;
3562                 }
3563 
3564               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3565                 {
3566                   source_timeout = 0;
3567                   result = TRUE;
3568                 }
3569               else
3570                 {
<a name="141" id="anc141"></a><span class="line-modified">3571                   gint timeout;</span>
3572 
3573                   /* rounding down will lead to spinning, so always round up */
3574                   timeout = (source-&gt;priv-&gt;ready_time - context-&gt;time + 999) / 1000;
3575 
3576                   if (source_timeout &lt; 0 || timeout &lt; source_timeout)
<a name="142" id="anc142"></a><span class="line-modified">3577                     source_timeout = timeout;</span>
3578                 }
3579             }
3580 
<a name="143" id="anc143"></a><span class="line-modified">3581       if (result)</span>
<span class="line-modified">3582         {</span>
<span class="line-modified">3583           GSource *ready_source = source;</span>
3584 
<a name="144" id="anc144"></a><span class="line-modified">3585           while (ready_source)</span>
<span class="line-modified">3586         {</span>
<span class="line-modified">3587           ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3588           ready_source = ready_source-&gt;priv-&gt;parent_source;</span>
<span class="line-removed">3589         }</span>
<span class="line-removed">3590         }</span>
3591     }
<a name="145" id="anc145"></a>

3592 
3593       if (source-&gt;flags &amp; G_SOURCE_READY)
<a name="146" id="anc146"></a><span class="line-modified">3594     {</span>
<span class="line-modified">3595       n_ready++;</span>
<span class="line-modified">3596       current_priority = source-&gt;priority;</span>
<span class="line-modified">3597       context-&gt;timeout = 0;</span>
<span class="line-modified">3598     }</span>
3599 
3600       if (source_timeout &gt;= 0)
<a name="147" id="anc147"></a><span class="line-modified">3601     {</span>
<span class="line-modified">3602       if (context-&gt;timeout &lt; 0)</span>
<span class="line-modified">3603         context-&gt;timeout = source_timeout;</span>
<span class="line-modified">3604       else</span>
<span class="line-modified">3605         context-&gt;timeout = MIN (context-&gt;timeout, source_timeout);</span>
<span class="line-modified">3606     }</span>
3607     }
3608   g_source_iter_clear (&amp;iter);
3609 
3610   TRACE (GLIB_MAIN_CONTEXT_AFTER_PREPARE (context, current_priority, n_ready));
3611 
3612   UNLOCK_CONTEXT (context);
3613 
3614   if (priority)
3615     *priority = current_priority;
3616 
3617   return (n_ready &gt; 0);
3618 }
3619 
3620 /**
3621  * g_main_context_query:
3622  * @context: a #GMainContext
3623  * @max_priority: maximum priority source to check
3624  * @timeout_: (out): location to store timeout to be used in polling
3625  * @fds: (out caller-allocates) (array length=n_fds): location to
3626  *       store #GPollFD records that need to be polled.
3627  * @n_fds: (in): length of @fds.
3628  *
3629  * Determines information necessary to poll this main loop.
3630  *
3631  * You must have successfully acquired the context with
3632  * g_main_context_acquire() before you may call this function.
3633  *
3634  * Returns: the number of records actually stored in @fds,
3635  *   or, if more than @n_fds records need to be stored, the number
3636  *   of records that need to be stored.
3637  **/
3638 gint
3639 g_main_context_query (GMainContext *context,
<a name="148" id="anc148"></a><span class="line-modified">3640               gint          max_priority,</span>
<span class="line-modified">3641               gint         *timeout,</span>
<span class="line-modified">3642               GPollFD      *fds,</span>
<span class="line-modified">3643               gint          n_fds)</span>
3644 {
3645   gint n_poll;
3646   GPollRec *pollrec, *lastpollrec;
3647   gushort events;
3648 
3649   LOCK_CONTEXT (context);
3650 
3651   TRACE (GLIB_MAIN_CONTEXT_BEFORE_QUERY (context, max_priority));
3652 
3653   n_poll = 0;
3654   lastpollrec = NULL;
3655   for (pollrec = context-&gt;poll_records; pollrec; pollrec = pollrec-&gt;next)
3656     {
3657       if (pollrec-&gt;priority &gt; max_priority)
3658         continue;
3659 
3660       /* In direct contradiction to the Unix98 spec, IRIX runs into
3661        * difficulty if you pass in POLLERR, POLLHUP or POLLNVAL
3662        * flags in the events field of the pollfd while it should
3663        * just ignoring them. So we mask them out here.
3664        */
3665       events = pollrec-&gt;fd-&gt;events &amp; ~(G_IO_ERR|G_IO_HUP|G_IO_NVAL);
3666 
3667       if (lastpollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == lastpollrec-&gt;fd-&gt;fd)
3668         {
3669           if (n_poll - 1 &lt; n_fds)
3670             fds[n_poll - 1].events |= events;
3671         }
3672       else
3673         {
3674           if (n_poll &lt; n_fds)
3675             {
3676               fds[n_poll].fd = pollrec-&gt;fd-&gt;fd;
3677               fds[n_poll].events = events;
<a name="149" id="anc149"></a><span class="line-modified">3678       fds[n_poll].revents = 0;</span>
<span class="line-modified">3679     }</span>
3680 
<a name="150" id="anc150"></a><span class="line-modified">3681       n_poll++;</span>
<span class="line-modified">3682     }</span>
3683 
3684       lastpollrec = pollrec;
3685     }
3686 
3687   context-&gt;poll_changed = FALSE;
3688 
3689   if (timeout)
3690     {
3691       *timeout = context-&gt;timeout;
3692       if (*timeout != 0)
3693         context-&gt;time_is_fresh = FALSE;
3694     }
3695 
3696   TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context-&gt;timeout,
3697                                         fds, n_poll));
3698 
3699   UNLOCK_CONTEXT (context);
3700 
3701   return n_poll;
3702 }
3703 
3704 /**
3705  * g_main_context_check:
3706  * @context: a #GMainContext
3707  * @max_priority: the maximum numerical priority of sources to check
3708  * @fds: (array length=n_fds): array of #GPollFD&#39;s that was passed to
3709  *       the last call to g_main_context_query()
3710  * @n_fds: return value of g_main_context_query()
3711  *
3712  * Passes the results of polling back to the main loop.
3713  *
3714  * You must have successfully acquired the context with
3715  * g_main_context_acquire() before you may call this function.
3716  *
3717  * Returns: %TRUE if some sources are ready to be dispatched.
3718  **/
3719 gboolean
3720 g_main_context_check (GMainContext *context,
<a name="151" id="anc151"></a><span class="line-modified">3721               gint          max_priority,</span>
<span class="line-modified">3722               GPollFD      *fds,</span>
<span class="line-modified">3723               gint          n_fds)</span>
3724 {
3725   GSource *source;
3726   GSourceIter iter;
3727   GPollRec *pollrec;
3728   gint n_ready = 0;
3729   gint i;
3730 
3731   LOCK_CONTEXT (context);
3732 
3733   if (context-&gt;in_check_or_prepare)
3734     {
3735       g_warning (&quot;g_main_context_check() called recursively from within a source&#39;s check() or &quot;
<a name="152" id="anc152"></a><span class="line-modified">3736          &quot;prepare() member.&quot;);</span>
3737       UNLOCK_CONTEXT (context);
3738       return FALSE;
3739     }
3740 
3741   TRACE (GLIB_MAIN_CONTEXT_BEFORE_CHECK (context, max_priority, fds, n_fds));
3742 
3743   for (i = 0; i &lt; n_fds; i++)
3744     {
3745       if (fds[i].fd == context-&gt;wake_up_rec.fd)
3746         {
3747           if (fds[i].revents)
3748             {
3749               TRACE (GLIB_MAIN_CONTEXT_WAKEUP_ACKNOWLEDGE (context));
<a name="153" id="anc153"></a><span class="line-modified">3750     g_wakeup_acknowledge (context-&gt;wakeup);</span>
3751             }
3752           break;
3753         }
3754     }
3755 
3756   /* If the set of poll file descriptors changed, bail out
3757    * and let the main loop rerun
3758    */
3759   if (context-&gt;poll_changed)
3760     {
3761       TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, 0));
3762 
3763       UNLOCK_CONTEXT (context);
3764       return FALSE;
3765     }
3766 
3767   pollrec = context-&gt;poll_records;
3768   i = 0;
3769   while (pollrec &amp;&amp; i &lt; n_fds)
3770     {
3771       while (pollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == fds[i].fd)
3772         {
3773           if (pollrec-&gt;priority &lt;= max_priority)
3774             {
3775               pollrec-&gt;fd-&gt;revents =
3776                 fds[i].revents &amp; (pollrec-&gt;fd-&gt;events | G_IO_ERR | G_IO_HUP | G_IO_NVAL);
3777             }
3778           pollrec = pollrec-&gt;next;
3779         }
3780 
3781       i++;
3782     }
3783 
3784   g_source_iter_init (&amp;iter, context, TRUE);
3785   while (g_source_iter_next (&amp;iter, &amp;source))
3786     {
3787       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<a name="154" id="anc154"></a><span class="line-modified">3788     continue;</span>
3789       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; max_priority))
<a name="155" id="anc155"></a><span class="line-modified">3790     break;</span>
3791 
3792       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<a name="156" id="anc156"></a><span class="line-modified">3793     {</span>
3794           gboolean result;
3795           gboolean (* check) (GSource *source);
3796 
3797           check = source-&gt;source_funcs-&gt;check;
3798 
3799           if (check)
3800             {
3801               /* If the check function is set, call it. */
3802               context-&gt;in_check_or_prepare++;
3803               UNLOCK_CONTEXT (context);
3804 
3805               result = (* check) (source);
3806 
3807               TRACE (GLIB_MAIN_AFTER_CHECK (source, check, result));
3808 
3809               LOCK_CONTEXT (context);
3810               context-&gt;in_check_or_prepare--;
3811             }
3812           else
3813             result = FALSE;
3814 
3815           if (result == FALSE)
3816             {
3817               GSList *tmp_list;
3818 
3819               /* If not already explicitly flagged ready by -&gt;check()
3820                * (or if we have no check) then we can still be ready if
3821                * any of our fds poll as ready.
3822                */
3823               for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3824                 {
3825                   GPollFD *pollfd = tmp_list-&gt;data;
3826 
3827                   if (pollfd-&gt;revents)
3828                     {
3829                       result = TRUE;
3830                       break;
3831                     }
3832                 }
3833             }
3834 
3835           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3836             {
3837               if (!context-&gt;time_is_fresh)
3838                 {
3839                   context-&gt;time = g_get_monotonic_time ();
3840                   context-&gt;time_is_fresh = TRUE;
3841                 }
3842 
3843               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3844                 result = TRUE;
3845             }
3846 
<a name="157" id="anc157"></a><span class="line-modified">3847       if (result)</span>
<span class="line-modified">3848         {</span>
<span class="line-modified">3849           GSource *ready_source = source;</span>
3850 
<a name="158" id="anc158"></a><span class="line-modified">3851           while (ready_source)</span>
<span class="line-modified">3852         {</span>
<span class="line-modified">3853           ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3854           ready_source = ready_source-&gt;priv-&gt;parent_source;</span>
<span class="line-removed">3855         }</span>
<span class="line-removed">3856         }</span>
3857     }
<a name="159" id="anc159"></a>

3858 
3859       if (source-&gt;flags &amp; G_SOURCE_READY)
<a name="160" id="anc160"></a><span class="line-modified">3860     {</span>
<span class="line-modified">3861       source-&gt;ref_count++;</span>
<span class="line-modified">3862       g_ptr_array_add (context-&gt;pending_dispatches, source);</span>
3863 
<a name="161" id="anc161"></a><span class="line-modified">3864       n_ready++;</span>
3865 
3866           /* never dispatch sources with less priority than the first
3867            * one we choose to dispatch
3868            */
3869           max_priority = source-&gt;priority;
<a name="162" id="anc162"></a><span class="line-modified">3870     }</span>
3871     }
3872   g_source_iter_clear (&amp;iter);
3873 
3874   TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, n_ready));
3875 
3876   UNLOCK_CONTEXT (context);
3877 
3878   return n_ready &gt; 0;
3879 }
3880 
3881 /**
3882  * g_main_context_dispatch:
3883  * @context: a #GMainContext
3884  *
3885  * Dispatches all pending sources.
3886  *
3887  * You must have successfully acquired the context with
3888  * g_main_context_acquire() before you may call this function.
3889  **/
3890 void
3891 g_main_context_dispatch (GMainContext *context)
3892 {
3893   LOCK_CONTEXT (context);
3894 
3895   TRACE (GLIB_MAIN_CONTEXT_BEFORE_DISPATCH (context));
3896 
3897   if (context-&gt;pending_dispatches-&gt;len &gt; 0)
3898     {
3899       g_main_dispatch (context);
3900     }
3901 
3902   TRACE (GLIB_MAIN_CONTEXT_AFTER_DISPATCH (context));
3903 
3904   UNLOCK_CONTEXT (context);
3905 }
3906 
3907 /* HOLDS context lock */
3908 static gboolean
3909 g_main_context_iterate (GMainContext *context,
<a name="163" id="anc163"></a><span class="line-modified">3910             gboolean      block,</span>
<span class="line-modified">3911             gboolean      dispatch,</span>
<span class="line-modified">3912             GThread      *self)</span>
3913 {
3914   gint max_priority;
3915   gint timeout;
3916   gboolean some_ready;
3917   gint nfds, allocated_nfds;
3918   GPollFD *fds = NULL;
3919 
3920   UNLOCK_CONTEXT (context);
3921 
3922   if (!g_main_context_acquire (context))
3923     {
3924       gboolean got_ownership;
3925 
3926       LOCK_CONTEXT (context);
3927 
3928       if (!block)
<a name="164" id="anc164"></a><span class="line-modified">3929     return FALSE;</span>
3930 
3931       got_ownership = g_main_context_wait_internal (context,
3932                                                     &amp;context-&gt;cond,
3933                                                     &amp;context-&gt;mutex);
3934 
3935       if (!got_ownership)
<a name="165" id="anc165"></a><span class="line-modified">3936     return FALSE;</span>
3937     }
3938   else
3939     LOCK_CONTEXT (context);
3940 
3941   if (!context-&gt;cached_poll_array)
3942     {
3943       context-&gt;cached_poll_array_size = context-&gt;n_poll_records;
3944       context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records);
3945     }
3946 
3947   allocated_nfds = context-&gt;cached_poll_array_size;
3948   fds = context-&gt;cached_poll_array;
3949 
3950   UNLOCK_CONTEXT (context);
3951 
3952   g_main_context_prepare (context, &amp;max_priority);
3953 
3954   while ((nfds = g_main_context_query (context, max_priority, &amp;timeout, fds,
<a name="166" id="anc166"></a><span class="line-modified">3955                        allocated_nfds)) &gt; allocated_nfds)</span>
3956     {
3957       LOCK_CONTEXT (context);
3958       g_free (fds);
3959       context-&gt;cached_poll_array_size = allocated_nfds = nfds;
3960       context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);
3961       UNLOCK_CONTEXT (context);
3962 #ifdef GSTREAMER_LITE
3963       if (fds == NULL) {
3964         return FALSE;
3965       }
3966 #endif // GSTREAMER_LITE
3967     }
3968 
3969   if (!block)
3970     timeout = 0;
3971 
3972   g_main_context_poll (context, timeout, max_priority, fds, nfds);
3973 
3974   some_ready = g_main_context_check (context, max_priority, fds, nfds);
3975 
3976   if (dispatch)
3977     g_main_context_dispatch (context);
3978 
3979   g_main_context_release (context);
3980 
3981   LOCK_CONTEXT (context);
3982 
3983   return some_ready;
3984 }
3985 
3986 /**
3987  * g_main_context_pending:
3988  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
3989  *
3990  * Checks if any sources have pending events for the given context.
3991  *
3992  * Returns: %TRUE if events are pending.
3993  **/
3994 gboolean
3995 g_main_context_pending (GMainContext *context)
3996 {
3997   gboolean retval;
3998 
3999   if (!context)
4000     context = g_main_context_default();
4001 
4002   LOCK_CONTEXT (context);
4003   retval = g_main_context_iterate (context, FALSE, FALSE, G_THREAD_SELF);
4004   UNLOCK_CONTEXT (context);
4005 
4006   return retval;
4007 }
4008 
4009 /**
4010  * g_main_context_iteration:
4011  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
4012  * @may_block: whether the call may block.
4013  *
4014  * Runs a single iteration for the given main loop. This involves
4015  * checking to see if any event sources are ready to be processed,
4016  * then if no events sources are ready and @may_block is %TRUE, waiting
4017  * for a source to become ready, then dispatching the highest priority
4018  * events sources that are ready. Otherwise, if @may_block is %FALSE
4019  * sources are not waited to become ready, only those highest priority
4020  * events sources will be dispatched (if any), that are ready at this
4021  * given moment without further waiting.
4022  *
4023  * Note that even when @may_block is %TRUE, it is still possible for
4024  * g_main_context_iteration() to return %FALSE, since the wait may
4025  * be interrupted for other reasons than an event source becoming ready.
4026  *
4027  * Returns: %TRUE if events were dispatched.
4028  **/
4029 gboolean
4030 g_main_context_iteration (GMainContext *context, gboolean may_block)
4031 {
4032   gboolean retval;
4033 
4034   if (!context)
4035     context = g_main_context_default();
4036 
4037   LOCK_CONTEXT (context);
4038   retval = g_main_context_iterate (context, may_block, TRUE, G_THREAD_SELF);
4039   UNLOCK_CONTEXT (context);
4040 
4041   return retval;
4042 }
4043 
4044 /**
4045  * g_main_loop_new:
4046  * @context: (nullable): a #GMainContext  (if %NULL, the default context will be used).
4047  * @is_running: set to %TRUE to indicate that the loop is running. This
4048  * is not very important since calling g_main_loop_run() will set this to
4049  * %TRUE anyway.
4050  *
4051  * Creates a new #GMainLoop structure.
4052  *
4053  * Returns: a new #GMainLoop.
4054  **/
4055 GMainLoop *
4056 g_main_loop_new (GMainContext *context,
<a name="167" id="anc167"></a><span class="line-modified">4057          gboolean      is_running)</span>
4058 {
4059   GMainLoop *loop;
4060 
4061   if (!context)
4062     context = g_main_context_default();
4063 
4064   g_main_context_ref (context);
4065 
4066   loop = g_new0 (GMainLoop, 1);
4067   loop-&gt;context = context;
4068   loop-&gt;is_running = is_running != FALSE;
4069   loop-&gt;ref_count = 1;
4070 
4071   TRACE (GLIB_MAIN_LOOP_NEW (loop, context));
4072 
4073   return loop;
4074 }
4075 
4076 /**
4077  * g_main_loop_ref:
4078  * @loop: a #GMainLoop
4079  *
4080  * Increases the reference count on a #GMainLoop object by one.
4081  *
4082  * Returns: @loop
4083  **/
4084 GMainLoop *
4085 g_main_loop_ref (GMainLoop *loop)
4086 {
4087   g_return_val_if_fail (loop != NULL, NULL);
4088   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4089 
4090   g_atomic_int_inc (&amp;loop-&gt;ref_count);
4091 
4092   return loop;
4093 }
4094 
4095 /**
4096  * g_main_loop_unref:
4097  * @loop: a #GMainLoop
4098  *
4099  * Decreases the reference count on a #GMainLoop object by one. If
4100  * the result is zero, free the loop and free all associated memory.
4101  **/
4102 void
4103 g_main_loop_unref (GMainLoop *loop)
4104 {
4105   g_return_if_fail (loop != NULL);
4106   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4107 
4108   if (!g_atomic_int_dec_and_test (&amp;loop-&gt;ref_count))
4109     return;
4110 
4111   g_main_context_unref (loop-&gt;context);
4112   g_free (loop);
4113 }
4114 
4115 /**
4116  * g_main_loop_run:
4117  * @loop: a #GMainLoop
4118  *
4119  * Runs a main loop until g_main_loop_quit() is called on the loop.
4120  * If this is called for the thread of the loop&#39;s #GMainContext,
4121  * it will process events from the loop, otherwise it will
4122  * simply wait.
4123  **/
4124 void
4125 g_main_loop_run (GMainLoop *loop)
4126 {
4127   GThread *self = G_THREAD_SELF;
4128 
4129   g_return_if_fail (loop != NULL);
4130   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4131 
4132   if (!g_main_context_acquire (loop-&gt;context))
4133     {
4134       gboolean got_ownership = FALSE;
4135 
4136       /* Another thread owns this context */
4137       LOCK_CONTEXT (loop-&gt;context);
4138 
4139       g_atomic_int_inc (&amp;loop-&gt;ref_count);
<a name="168" id="anc168"></a>
4140 
<a name="169" id="anc169"></a><span class="line-modified">4141       if (!loop-&gt;is_running)</span>
<span class="line-removed">4142     loop-&gt;is_running = TRUE;</span>
<span class="line-removed">4143 </span>
<span class="line-removed">4144       while (loop-&gt;is_running &amp;&amp; !got_ownership)</span>
4145         got_ownership = g_main_context_wait_internal (loop-&gt;context,
4146                                                       &amp;loop-&gt;context-&gt;cond,
4147                                                       &amp;loop-&gt;context-&gt;mutex);
4148 
<a name="170" id="anc170"></a><span class="line-modified">4149       if (!loop-&gt;is_running)</span>
<span class="line-modified">4150     {</span>
<span class="line-modified">4151       UNLOCK_CONTEXT (loop-&gt;context);</span>
<span class="line-modified">4152       if (got_ownership)</span>
<span class="line-modified">4153         g_main_context_release (loop-&gt;context);</span>
<span class="line-modified">4154       g_main_loop_unref (loop);</span>
<span class="line-modified">4155       return;</span>
<span class="line-modified">4156     }</span>
4157 
4158       g_assert (got_ownership);
4159     }
4160   else
4161     LOCK_CONTEXT (loop-&gt;context);
4162 
4163   if (loop-&gt;context-&gt;in_check_or_prepare)
4164     {
4165       g_warning (&quot;g_main_loop_run(): called recursively from within a source&#39;s &quot;
<a name="171" id="anc171"></a><span class="line-modified">4166          &quot;check() or prepare() member, iteration not possible.&quot;);</span>
4167       return;
4168     }
4169 
4170   g_atomic_int_inc (&amp;loop-&gt;ref_count);
<a name="172" id="anc172"></a><span class="line-modified">4171   loop-&gt;is_running = TRUE;</span>
<span class="line-modified">4172   while (loop-&gt;is_running)</span>
4173     g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self);
4174 
4175   UNLOCK_CONTEXT (loop-&gt;context);
4176 
4177   g_main_context_release (loop-&gt;context);
4178 
4179   g_main_loop_unref (loop);
4180 }
4181 
4182 /**
4183  * g_main_loop_quit:
4184  * @loop: a #GMainLoop
4185  *
4186  * Stops a #GMainLoop from running. Any calls to g_main_loop_run()
4187  * for the loop will return.
4188  *
4189  * Note that sources that have already been dispatched when
4190  * g_main_loop_quit() is called will still be executed.
4191  **/
4192 void
4193 g_main_loop_quit (GMainLoop *loop)
4194 {
4195   g_return_if_fail (loop != NULL);
4196   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4197 
4198   LOCK_CONTEXT (loop-&gt;context);
<a name="173" id="anc173"></a><span class="line-modified">4199   loop-&gt;is_running = FALSE;</span>
4200   g_wakeup_signal (loop-&gt;context-&gt;wakeup);
4201 
4202   g_cond_broadcast (&amp;loop-&gt;context-&gt;cond);
4203 
4204   UNLOCK_CONTEXT (loop-&gt;context);
4205 
4206   TRACE (GLIB_MAIN_LOOP_QUIT (loop));
4207 }
4208 
4209 /**
4210  * g_main_loop_is_running:
4211  * @loop: a #GMainLoop.
4212  *
4213  * Checks to see if the main loop is currently being run via g_main_loop_run().
4214  *
4215  * Returns: %TRUE if the mainloop is currently being run.
4216  **/
4217 gboolean
4218 g_main_loop_is_running (GMainLoop *loop)
4219 {
4220   g_return_val_if_fail (loop != NULL, FALSE);
4221   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, FALSE);
4222 
<a name="174" id="anc174"></a><span class="line-modified">4223   return loop-&gt;is_running;</span>
4224 }
4225 
4226 /**
4227  * g_main_loop_get_context:
4228  * @loop: a #GMainLoop.
4229  *
4230  * Returns the #GMainContext of @loop.
4231  *
4232  * Returns: (transfer none): the #GMainContext of @loop
4233  **/
4234 GMainContext *
4235 g_main_loop_get_context (GMainLoop *loop)
4236 {
4237   g_return_val_if_fail (loop != NULL, NULL);
4238   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4239 
4240   return loop-&gt;context;
4241 }
4242 
4243 /* HOLDS: context&#39;s lock */
4244 static void
4245 g_main_context_poll (GMainContext *context,
<a name="175" id="anc175"></a><span class="line-modified">4246              gint          timeout,</span>
<span class="line-modified">4247              gint          priority,</span>
<span class="line-modified">4248              GPollFD      *fds,</span>
<span class="line-modified">4249              gint          n_fds)</span>
4250 {
4251 #ifdef  G_MAIN_POLL_DEBUG
4252   GTimer *poll_timer;
4253   GPollRec *pollrec;
4254   gint i;
4255 #endif
4256 
4257   GPollFunc poll_func;
4258 
4259   if (n_fds || timeout != 0)
4260     {
4261       int ret, errsv;
4262 
4263 #ifdef  G_MAIN_POLL_DEBUG
4264       poll_timer = NULL;
4265       if (_g_main_poll_debug)
<a name="176" id="anc176"></a><span class="line-modified">4266     {</span>
<span class="line-modified">4267       g_print (&quot;polling context=%p n=%d timeout=%d\n&quot;,</span>
<span class="line-modified">4268            context, n_fds, timeout);</span>
<span class="line-modified">4269       poll_timer = g_timer_new ();</span>
<span class="line-modified">4270     }</span>
4271 #endif
4272 
4273       LOCK_CONTEXT (context);
4274 
4275       poll_func = context-&gt;poll_func;
4276 
4277       UNLOCK_CONTEXT (context);
4278       ret = (*poll_func) (fds, n_fds, timeout);
4279       errsv = errno;
4280       if (ret &lt; 0 &amp;&amp; errsv != EINTR)
<a name="177" id="anc177"></a><span class="line-modified">4281     {</span>
4282 #ifndef G_OS_WIN32
<a name="178" id="anc178"></a><span class="line-modified">4283       g_warning (&quot;poll(2) failed due to: %s.&quot;,</span>
<span class="line-modified">4284              g_strerror (errsv));</span>
4285 #else
<a name="179" id="anc179"></a><span class="line-modified">4286       /* If g_poll () returns -1, it has already called g_warning() */</span>
4287 #endif
<a name="180" id="anc180"></a><span class="line-modified">4288     }</span>
4289 
4290 #ifdef  G_MAIN_POLL_DEBUG
4291       if (_g_main_poll_debug)
<a name="181" id="anc181"></a><span class="line-modified">4292     {</span>
<span class="line-modified">4293       LOCK_CONTEXT (context);</span>
<span class="line-removed">4294 </span>
<span class="line-removed">4295       g_print (&quot;g_main_poll(%d) timeout: %d - elapsed %12.10f seconds&quot;,</span>
<span class="line-removed">4296            n_fds,</span>
<span class="line-removed">4297            timeout,</span>
<span class="line-removed">4298            g_timer_elapsed (poll_timer, NULL));</span>
<span class="line-removed">4299       g_timer_destroy (poll_timer);</span>
<span class="line-removed">4300       pollrec = context-&gt;poll_records;</span>
4301 
<a name="182" id="anc182"></a><span class="line-modified">4302       while (pollrec != NULL)</span>
<span class="line-modified">4303         {</span>
<span class="line-modified">4304           i = 0;</span>
<span class="line-modified">4305           while (i &lt; n_fds)</span>











4306         {
<a name="183" id="anc183"></a><span class="line-modified">4307           if (fds[i].fd == pollrec-&gt;fd-&gt;fd &amp;&amp;</span>
<span class="line-modified">4308               pollrec-&gt;fd-&gt;events &amp;&amp;</span>
<span class="line-modified">4309               fds[i].revents)</span>
<span class="line-modified">4310             {</span>
<span class="line-modified">4311               g_print (&quot; [&quot; G_POLLFD_FORMAT &quot; :&quot;, fds[i].fd);</span>
<span class="line-modified">4312               if (fds[i].revents &amp; G_IO_IN)</span>
<span class="line-modified">4313             g_print (&quot;i&quot;);</span>
<span class="line-modified">4314               if (fds[i].revents &amp; G_IO_OUT)</span>
<span class="line-modified">4315             g_print (&quot;o&quot;);</span>
<span class="line-modified">4316               if (fds[i].revents &amp; G_IO_PRI)</span>
<span class="line-modified">4317             g_print (&quot;p&quot;);</span>
<span class="line-modified">4318               if (fds[i].revents &amp; G_IO_ERR)</span>
<span class="line-modified">4319             g_print (&quot;e&quot;);</span>
<span class="line-modified">4320               if (fds[i].revents &amp; G_IO_HUP)</span>
<span class="line-removed">4321             g_print (&quot;h&quot;);</span>
<span class="line-removed">4322               if (fds[i].revents &amp; G_IO_NVAL)</span>
<span class="line-removed">4323             g_print (&quot;n&quot;);</span>
<span class="line-removed">4324               g_print (&quot;]&quot;);</span>
<span class="line-removed">4325             }</span>
<span class="line-removed">4326           i++;</span>
4327         }
<a name="184" id="anc184"></a><span class="line-modified">4328           pollrec = pollrec-&gt;next;</span>
<span class="line-removed">4329         }</span>
<span class="line-removed">4330       g_print (&quot;\n&quot;);</span>
<span class="line-removed">4331 </span>
<span class="line-removed">4332       UNLOCK_CONTEXT (context);</span>
4333     }
<a name="185" id="anc185"></a>





4334 #endif
4335     } /* if (n_fds || timeout != 0) */
4336 }
4337 
4338 /**
4339  * g_main_context_add_poll:
4340  * @context: (nullable): a #GMainContext (or %NULL for the default context)
4341  * @fd: a #GPollFD structure holding information about a file
4342  *      descriptor to watch.
4343  * @priority: the priority for this file descriptor which should be
4344  *      the same as the priority used for g_source_attach() to ensure that the
4345  *      file descriptor is polled whenever the results may be needed.
4346  *
4347  * Adds a file descriptor to the set of file descriptors polled for
4348  * this context. This will very seldom be used directly. Instead
4349  * a typical event source will use g_source_add_unix_fd() instead.
4350  **/
4351 void
4352 g_main_context_add_poll (GMainContext *context,
<a name="186" id="anc186"></a><span class="line-modified">4353              GPollFD      *fd,</span>
<span class="line-modified">4354              gint          priority)</span>
4355 {
4356   if (!context)
4357     context = g_main_context_default ();
4358 
4359   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4360   g_return_if_fail (fd);
4361 
4362   LOCK_CONTEXT (context);
4363   g_main_context_add_poll_unlocked (context, priority, fd);
4364   UNLOCK_CONTEXT (context);
4365 }
4366 
4367 /* HOLDS: main_loop_lock */
4368 static void
4369 g_main_context_add_poll_unlocked (GMainContext *context,
<a name="187" id="anc187"></a><span class="line-modified">4370                   gint          priority,</span>
<span class="line-modified">4371                   GPollFD      *fd)</span>
4372 {
4373   GPollRec *prevrec, *nextrec;
4374   GPollRec *newrec = g_slice_new (GPollRec);
4375 #ifdef GSTREAMER_LITE
4376   if (newrec == NULL) {
4377     return;
4378   }
4379 #endif // GSTREAMER_LITE
4380 
4381   /* This file descriptor may be checked before we ever poll */
4382   fd-&gt;revents = 0;
4383   newrec-&gt;fd = fd;
4384   newrec-&gt;priority = priority;
4385 
4386   prevrec = NULL;
4387   nextrec = context-&gt;poll_records;
4388   while (nextrec)
4389     {
4390       if (nextrec-&gt;fd-&gt;fd &gt; fd-&gt;fd)
4391         break;
4392       prevrec = nextrec;
4393       nextrec = nextrec-&gt;next;
4394     }
4395 
4396   if (prevrec)
4397     prevrec-&gt;next = newrec;
4398   else
4399     context-&gt;poll_records = newrec;
4400 
4401   newrec-&gt;prev = prevrec;
4402   newrec-&gt;next = nextrec;
4403 
4404   if (nextrec)
4405     nextrec-&gt;prev = newrec;
4406 
4407   context-&gt;n_poll_records++;
4408 
4409   context-&gt;poll_changed = TRUE;
4410 
4411   /* Now wake up the main loop if it is waiting in the poll() */
4412   g_wakeup_signal (context-&gt;wakeup);
4413 }
4414 
4415 /**
4416  * g_main_context_remove_poll:
4417  * @context:a #GMainContext
4418  * @fd: a #GPollFD descriptor previously added with g_main_context_add_poll()
4419  *
4420  * Removes file descriptor from the set of file descriptors to be
4421  * polled for a particular context.
4422  **/
4423 void
4424 g_main_context_remove_poll (GMainContext *context,
<a name="188" id="anc188"></a><span class="line-modified">4425                 GPollFD      *fd)</span>
4426 {
4427   if (!context)
4428     context = g_main_context_default ();
4429 
4430   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4431   g_return_if_fail (fd);
4432 
4433   LOCK_CONTEXT (context);
4434   g_main_context_remove_poll_unlocked (context, fd);
4435   UNLOCK_CONTEXT (context);
4436 }
4437 
4438 static void
4439 g_main_context_remove_poll_unlocked (GMainContext *context,
<a name="189" id="anc189"></a><span class="line-modified">4440                      GPollFD      *fd)</span>
4441 {
4442   GPollRec *pollrec, *prevrec, *nextrec;
4443 
4444   prevrec = NULL;
4445   pollrec = context-&gt;poll_records;
4446 
4447   while (pollrec)
4448     {
4449       nextrec = pollrec-&gt;next;
4450       if (pollrec-&gt;fd == fd)
<a name="190" id="anc190"></a><span class="line-modified">4451     {</span>
<span class="line-modified">4452       if (prevrec != NULL)</span>
<span class="line-modified">4453         prevrec-&gt;next = nextrec;</span>
<span class="line-modified">4454       else</span>
<span class="line-modified">4455         context-&gt;poll_records = nextrec;</span>
4456 
<a name="191" id="anc191"></a><span class="line-modified">4457       if (nextrec != NULL)</span>
<span class="line-modified">4458         nextrec-&gt;prev = prevrec;</span>
4459 
<a name="192" id="anc192"></a><span class="line-modified">4460       g_slice_free (GPollRec, pollrec);</span>
4461 
<a name="193" id="anc193"></a><span class="line-modified">4462       context-&gt;n_poll_records--;</span>
<span class="line-modified">4463       break;</span>
<span class="line-modified">4464     }</span>
4465       prevrec = pollrec;
4466       pollrec = nextrec;
4467     }
4468 
4469   context-&gt;poll_changed = TRUE;
4470 
4471   /* Now wake up the main loop if it is waiting in the poll() */
4472   g_wakeup_signal (context-&gt;wakeup);
4473 }
4474 
4475 /**
4476  * g_source_get_current_time:
4477  * @source:  a #GSource
4478  * @timeval: #GTimeVal structure in which to store current time.
4479  *
4480  * This function ignores @source and is otherwise the same as
4481  * g_get_current_time().
4482  *
4483  * Deprecated: 2.28: use g_source_get_time() instead
4484  **/
<a name="194" id="anc194"></a>
4485 void
4486 g_source_get_current_time (GSource  *source,
<a name="195" id="anc195"></a><span class="line-modified">4487                GTimeVal *timeval)</span>
4488 {
4489   g_get_current_time (timeval);
4490 }
<a name="196" id="anc196"></a>
4491 
4492 /**
4493  * g_source_get_time:
4494  * @source: a #GSource
4495  *
4496  * Gets the time to be used when checking this source. The advantage of
4497  * calling this function over calling g_get_monotonic_time() directly is
4498  * that when checking multiple sources, GLib can cache a single value
4499  * instead of having to repeatedly get the system monotonic time.
4500  *
4501  * The time here is the system monotonic time, if available, or some
4502  * other reasonable alternative otherwise.  See g_get_monotonic_time().
4503  *
4504  * Returns: the monotonic time in microseconds
4505  *
4506  * Since: 2.28
4507  **/
4508 gint64
4509 g_source_get_time (GSource *source)
4510 {
4511   GMainContext *context;
4512   gint64 result;
4513 
4514   g_return_val_if_fail (source-&gt;context != NULL, 0);
4515 
4516   context = source-&gt;context;
4517 
4518   LOCK_CONTEXT (context);
4519 
4520   if (!context-&gt;time_is_fresh)
4521     {
4522       context-&gt;time = g_get_monotonic_time ();
4523       context-&gt;time_is_fresh = TRUE;
4524     }
4525 
4526   result = context-&gt;time;
4527 
4528   UNLOCK_CONTEXT (context);
4529 
4530   return result;
4531 }
4532 
4533 /**
4534  * g_main_context_set_poll_func:
4535  * @context: a #GMainContext
4536  * @func: the function to call to poll all file descriptors
4537  *
4538  * Sets the function to use to handle polling of file descriptors. It
4539  * will be used instead of the poll() system call
4540  * (or GLib&#39;s replacement function, which is used where
4541  * poll() isn&#39;t available).
4542  *
4543  * This function could possibly be used to integrate the GLib event
4544  * loop with an external event loop.
4545  **/
4546 void
4547 g_main_context_set_poll_func (GMainContext *context,
<a name="197" id="anc197"></a><span class="line-modified">4548                   GPollFunc     func)</span>
4549 {
4550   if (!context)
4551     context = g_main_context_default ();
4552 
4553   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4554 
4555   LOCK_CONTEXT (context);
4556 
4557   if (func)
4558     context-&gt;poll_func = func;
4559   else
4560     context-&gt;poll_func = g_poll;
4561 
4562   UNLOCK_CONTEXT (context);
4563 }
4564 
4565 /**
4566  * g_main_context_get_poll_func:
4567  * @context: a #GMainContext
4568  *
4569  * Gets the poll function set by g_main_context_set_poll_func().
4570  *
4571  * Returns: the poll function
4572  **/
4573 GPollFunc
4574 g_main_context_get_poll_func (GMainContext *context)
4575 {
4576   GPollFunc result;
4577 
4578   if (!context)
4579     context = g_main_context_default ();
4580 
4581   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
4582 
4583   LOCK_CONTEXT (context);
4584   result = context-&gt;poll_func;
4585   UNLOCK_CONTEXT (context);
4586 
4587   return result;
4588 }
4589 
4590 /**
4591  * g_main_context_wakeup:
4592  * @context: a #GMainContext
4593  *
4594  * If @context is currently blocking in g_main_context_iteration()
4595  * waiting for a source to become ready, cause it to stop blocking
4596  * and return.  Otherwise, cause the next invocation of
4597  * g_main_context_iteration() to return without blocking.
4598  *
4599  * This API is useful for low-level control over #GMainContext; for
4600  * example, integrating it with main loop implementations such as
4601  * #GMainLoop.
4602  *
4603  * Another related use for this function is when implementing a main
4604  * loop with a termination condition, computed from multiple threads:
4605  *
4606  * |[&lt;!-- language=&quot;C&quot; --&gt;
4607  *   #define NUM_TASKS 10
4608  *   static volatile gint tasks_remaining = NUM_TASKS;
4609  *   ...
4610  *
4611  *   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
4612  *     g_main_context_iteration (NULL, TRUE);
4613  * ]|
4614  *
4615  * Then in a thread:
4616  * |[&lt;!-- language=&quot;C&quot; --&gt;
4617  *   perform_work();
4618  *
4619  *   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
4620  *     g_main_context_wakeup (NULL);
4621  * ]|
4622  **/
4623 void
4624 g_main_context_wakeup (GMainContext *context)
4625 {
4626   if (!context)
4627     context = g_main_context_default ();
4628 
4629   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4630 
4631   TRACE (GLIB_MAIN_CONTEXT_WAKEUP (context));
4632 
4633   g_wakeup_signal (context-&gt;wakeup);
4634 }
4635 
4636 /**
4637  * g_main_context_is_owner:
4638  * @context: a #GMainContext
4639  *
4640  * Determines whether this thread holds the (recursive)
4641  * ownership of this #GMainContext. This is useful to
4642  * know before waiting on another thread that may be
4643  * blocking to get ownership of @context.
4644  *
4645  * Returns: %TRUE if current thread is owner of @context.
4646  *
4647  * Since: 2.10
4648  **/
4649 gboolean
4650 g_main_context_is_owner (GMainContext *context)
4651 {
4652   gboolean is_owner;
4653 
4654   if (!context)
4655     context = g_main_context_default ();
4656 
4657   LOCK_CONTEXT (context);
4658   is_owner = context-&gt;owner == G_THREAD_SELF;
4659   UNLOCK_CONTEXT (context);
4660 
4661   return is_owner;
4662 }
4663 
4664 /* Timeouts */
4665 
4666 static void
4667 g_timeout_set_expiration (GTimeoutSource *timeout_source,
4668                           gint64          current_time)
4669 {
4670   gint64 expiration;
4671 
<a name="198" id="anc198"></a><span class="line-removed">4672   expiration = current_time + (guint64) timeout_source-&gt;interval * 1000;</span>
<span class="line-removed">4673 </span>
4674   if (timeout_source-&gt;seconds)
4675     {
4676       gint64 remainder;
4677       static gint timer_perturb = -1;
4678 
4679       if (timer_perturb == -1)
4680         {
4681           /*
4682            * we want a per machine/session unique &#39;random&#39; value; try the dbus
4683            * address first, that has a UUID in it. If there is no dbus, use the
4684            * hostname for hashing.
4685            */
4686           const char *session_bus_address = g_getenv (&quot;DBUS_SESSION_BUS_ADDRESS&quot;);
4687           if (!session_bus_address)
4688             session_bus_address = g_getenv (&quot;HOSTNAME&quot;);
4689           if (session_bus_address)
4690             timer_perturb = ABS ((gint) g_str_hash (session_bus_address)) % 1000000;
4691           else
4692             timer_perturb = 0;
4693         }
4694 
<a name="199" id="anc199"></a>

4695       /* We want the microseconds part of the timeout to land on the
4696        * &#39;timer_perturb&#39; mark, but we need to make sure we don&#39;t try to
4697        * set the timeout in the past.  We do this by ensuring that we
4698        * always only *increase* the expiration time by adding a full
4699        * second in the case that the microsecond portion decreases.
4700        */
4701       expiration -= timer_perturb;
4702 
4703       remainder = expiration % 1000000;
4704       if (remainder &gt;= 1000000/4)
4705         expiration += 1000000;
4706 
4707       expiration -= remainder;
4708       expiration += timer_perturb;
4709     }
<a name="200" id="anc200"></a>



4710 
4711   g_source_set_ready_time ((GSource *) timeout_source, expiration);
4712 }
4713 
4714 static gboolean
4715 g_timeout_dispatch (GSource     *source,
4716                     GSourceFunc  callback,
4717                     gpointer     user_data)
4718 {
4719   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4720   gboolean again;
4721 
4722   if (!callback)
4723     {
4724       g_warning (&quot;Timeout source dispatched without callback. &quot;
4725                  &quot;You must call g_source_set_callback().&quot;);
4726       return FALSE;
4727     }
4728 
4729   again = callback (user_data);
4730 
4731   TRACE (GLIB_TIMEOUT_DISPATCH (source, source-&gt;context, callback, user_data, again));
4732 
4733   if (again)
4734     g_timeout_set_expiration (timeout_source, g_source_get_time (source));
4735 
4736   return again;
4737 }
4738 
4739 /**
4740  * g_timeout_source_new:
4741  * @interval: the timeout interval in milliseconds.
4742  *
4743  * Creates a new timeout source.
4744  *
4745  * The source will not initially be associated with any #GMainContext
4746  * and must be added to one with g_source_attach() before it will be
4747  * executed.
4748  *
4749  * The interval given is in terms of monotonic time, not wall clock
4750  * time.  See g_get_monotonic_time().
4751  *
4752  * Returns: the newly-created timeout source
4753  **/
4754 GSource *
4755 g_timeout_source_new (guint interval)
4756 {
4757   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4758   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4759 #ifdef GSTREAMER_LITE
4760   if (timeout_source == NULL)
4761       return NULL;
4762 #endif // GSTREAMER_LITE
4763 
4764   timeout_source-&gt;interval = interval;
4765   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4766 
4767   return source;
4768 }
4769 
4770 #ifndef GSTREAMER_LITE
4771 /**
4772  * g_timeout_source_new_seconds:
4773  * @interval: the timeout interval in seconds
4774  *
4775  * Creates a new timeout source.
4776  *
4777  * The source will not initially be associated with any #GMainContext
4778  * and must be added to one with g_source_attach() before it will be
4779  * executed.
4780  *
4781  * The scheduling granularity/accuracy of this timeout source will be
4782  * in seconds.
4783  *
4784  * The interval given is in terms of monotonic time, not wall clock time.
4785  * See g_get_monotonic_time().
4786  *
4787  * Returns: the newly-created timeout source
4788  *
4789  * Since: 2.14
4790  **/
4791 GSource *
4792 g_timeout_source_new_seconds (guint interval)
4793 {
4794   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4795   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4796 
<a name="201" id="anc201"></a><span class="line-modified">4797   timeout_source-&gt;interval = 1000 * interval;</span>
4798   timeout_source-&gt;seconds = TRUE;
4799 
4800   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4801 
4802   return source;
4803 }
4804 #endif // GSTREAMER_LITE
4805 
4806 
4807 /**
4808  * g_timeout_add_full: (rename-to g_timeout_add)
4809  * @priority: the priority of the timeout source. Typically this will be in
4810  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4811  * @interval: the time between calls to the function, in milliseconds
4812  *             (1/1000ths of a second)
4813  * @function: function to call
4814  * @data:     data to pass to @function
4815  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4816  *
4817  * Sets a function to be called at regular intervals, with the given
4818  * priority.  The function is called repeatedly until it returns
4819  * %FALSE, at which point the timeout is automatically destroyed and
4820  * the function will not be called again.  The @notify function is
4821  * called when the timeout is destroyed.  The first call to the
4822  * function will be at the end of the first @interval.
4823  *
4824  * Note that timeout functions may be delayed, due to the processing of other
4825  * event sources. Thus they should not be relied on for precise timing.
4826  * After each call to the timeout function, the time of the next
4827  * timeout is recalculated based on the current time and the given interval
4828  * (it does not try to &#39;catch up&#39; time lost in delays).
4829  *
4830  * See [memory management of sources][mainloop-memory-management] for details
4831  * on how to handle the return value and memory management of @data.
4832  *
4833  * This internally creates a main loop source using g_timeout_source_new()
4834  * and attaches it to the global #GMainContext using g_source_attach(), so
4835  * the callback will be invoked in whichever thread is running that main
4836  * context. You can do these steps manually if you need greater control or to
4837  * use a custom main context.
4838  *
4839  * The interval given is in terms of monotonic time, not wall clock time.
4840  * See g_get_monotonic_time().
4841  *
4842  * Returns: the ID (greater than 0) of the event source.
4843  **/
4844 guint
4845 g_timeout_add_full (gint           priority,
<a name="202" id="anc202"></a><span class="line-modified">4846             guint          interval,</span>
<span class="line-modified">4847             GSourceFunc    function,</span>
<span class="line-modified">4848             gpointer       data,</span>
<span class="line-modified">4849             GDestroyNotify notify)</span>
4850 {
4851   GSource *source;
4852   guint id;
4853 
4854   g_return_val_if_fail (function != NULL, 0);
4855 
4856   source = g_timeout_source_new (interval);
4857 #ifdef GSTREAMER_LITE
4858   if (source == NULL)
4859       return 0;
4860 #endif // GSTREAMER_LITE
4861 
4862   if (priority != G_PRIORITY_DEFAULT)
4863     g_source_set_priority (source, priority);
4864 
4865   g_source_set_callback (source, function, data, notify);
4866   id = g_source_attach (source, NULL);
4867 
4868   TRACE (GLIB_TIMEOUT_ADD (source, g_main_context_default (), id, priority, interval, function, data));
4869 
4870   g_source_unref (source);
4871 
4872   return id;
4873 }
4874 
4875 /**
4876  * g_timeout_add:
4877  * @interval: the time between calls to the function, in milliseconds
4878  *             (1/1000ths of a second)
4879  * @function: function to call
4880  * @data:     data to pass to @function
4881  *
4882  * Sets a function to be called at regular intervals, with the default
4883  * priority, #G_PRIORITY_DEFAULT.  The function is called repeatedly
4884  * until it returns %FALSE, at which point the timeout is automatically
4885  * destroyed and the function will not be called again.  The first call
4886  * to the function will be at the end of the first @interval.
4887  *
4888  * Note that timeout functions may be delayed, due to the processing of other
4889  * event sources. Thus they should not be relied on for precise timing.
4890  * After each call to the timeout function, the time of the next
4891  * timeout is recalculated based on the current time and the given interval
4892  * (it does not try to &#39;catch up&#39; time lost in delays).
4893  *
4894  * See [memory management of sources][mainloop-memory-management] for details
4895  * on how to handle the return value and memory management of @data.
4896  *
4897  * If you want to have a timer in the &quot;seconds&quot; range and do not care
4898  * about the exact time of the first call of the timer, use the
4899  * g_timeout_add_seconds() function; this function allows for more
4900  * optimizations and more efficient system power usage.
4901  *
4902  * This internally creates a main loop source using g_timeout_source_new()
4903  * and attaches it to the global #GMainContext using g_source_attach(), so
4904  * the callback will be invoked in whichever thread is running that main
4905  * context. You can do these steps manually if you need greater control or to
4906  * use a custom main context.
4907  *
4908  * The interval given is in terms of monotonic time, not wall clock
4909  * time.  See g_get_monotonic_time().
4910  *
4911  * Returns: the ID (greater than 0) of the event source.
4912  **/
4913 guint
4914 g_timeout_add (guint32        interval,
<a name="203" id="anc203"></a><span class="line-modified">4915            GSourceFunc    function,</span>
<span class="line-modified">4916            gpointer       data)</span>
4917 {
4918   return g_timeout_add_full (G_PRIORITY_DEFAULT,
<a name="204" id="anc204"></a><span class="line-modified">4919                  interval, function, data, NULL);</span>
4920 }
4921 
4922 #ifndef GSTREAMER_LITE
4923 /**
4924  * g_timeout_add_seconds_full: (rename-to g_timeout_add_seconds)
4925  * @priority: the priority of the timeout source. Typically this will be in
4926  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4927  * @interval: the time between calls to the function, in seconds
4928  * @function: function to call
4929  * @data:     data to pass to @function
4930  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4931  *
4932  * Sets a function to be called at regular intervals, with @priority.
4933  * The function is called repeatedly until it returns %FALSE, at which
4934  * point the timeout is automatically destroyed and the function will
4935  * not be called again.
4936  *
4937  * Unlike g_timeout_add(), this function operates at whole second granularity.
4938  * The initial starting point of the timer is determined by the implementation
4939  * and the implementation is expected to group multiple timers together so that
4940  * they fire all at the same time.
4941  * To allow this grouping, the @interval to the first timer is rounded
4942  * and can deviate up to one second from the specified interval.
4943  * Subsequent timer iterations will generally run at the specified interval.
4944  *
4945  * Note that timeout functions may be delayed, due to the processing of other
4946  * event sources. Thus they should not be relied on for precise timing.
4947  * After each call to the timeout function, the time of the next
4948  * timeout is recalculated based on the current time and the given @interval
4949  *
4950  * See [memory management of sources][mainloop-memory-management] for details
4951  * on how to handle the return value and memory management of @data.
4952  *
4953  * If you want timing more precise than whole seconds, use g_timeout_add()
4954  * instead.
4955  *
4956  * The grouping of timers to fire at the same time results in a more power
4957  * and CPU efficient behavior so if your timer is in multiples of seconds
4958  * and you don&#39;t require the first timer exactly one second from now, the
4959  * use of g_timeout_add_seconds() is preferred over g_timeout_add().
4960  *
4961  * This internally creates a main loop source using
4962  * g_timeout_source_new_seconds() and attaches it to the main loop context
4963  * using g_source_attach(). You can do these steps manually if you need
4964  * greater control.
4965  *
4966  * The interval given is in terms of monotonic time, not wall clock
4967  * time.  See g_get_monotonic_time().
4968  *
4969  * Returns: the ID (greater than 0) of the event source.
4970  *
4971  * Since: 2.14
4972  **/
4973 guint
4974 g_timeout_add_seconds_full (gint           priority,
4975                             guint32        interval,
4976                             GSourceFunc    function,
4977                             gpointer       data,
4978                             GDestroyNotify notify)
4979 {
4980   GSource *source;
4981   guint id;
4982 
4983   g_return_val_if_fail (function != NULL, 0);
4984 
4985   source = g_timeout_source_new_seconds (interval);
4986 
4987   if (priority != G_PRIORITY_DEFAULT)
4988     g_source_set_priority (source, priority);
4989 
4990   g_source_set_callback (source, function, data, notify);
4991   id = g_source_attach (source, NULL);
4992   g_source_unref (source);
4993 
4994   return id;
4995 }
4996 
4997 /**
4998  * g_timeout_add_seconds:
4999  * @interval: the time between calls to the function, in seconds
5000  * @function: function to call
5001  * @data: data to pass to @function
5002  *
5003  * Sets a function to be called at regular intervals with the default
5004  * priority, #G_PRIORITY_DEFAULT. The function is called repeatedly until
5005  * it returns %FALSE, at which point the timeout is automatically destroyed
5006  * and the function will not be called again.
5007  *
5008  * This internally creates a main loop source using
5009  * g_timeout_source_new_seconds() and attaches it to the main loop context
5010  * using g_source_attach(). You can do these steps manually if you need
5011  * greater control. Also see g_timeout_add_seconds_full().
5012  *
5013  * Note that the first call of the timer may not be precise for timeouts
5014  * of one second. If you need finer precision and have such a timeout,
5015  * you may want to use g_timeout_add() instead.
5016  *
5017  * See [memory management of sources][mainloop-memory-management] for details
5018  * on how to handle the return value and memory management of @data.
5019  *
5020  * The interval given is in terms of monotonic time, not wall clock
5021  * time.  See g_get_monotonic_time().
5022  *
5023  * Returns: the ID (greater than 0) of the event source.
5024  *
5025  * Since: 2.14
5026  **/
5027 guint
5028 g_timeout_add_seconds (guint       interval,
5029                        GSourceFunc function,
5030                        gpointer    data)
5031 {
5032   g_return_val_if_fail (function != NULL, 0);
5033 
5034   return g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, interval, function, data, NULL);
5035 }
5036 #endif // GSTREAMER_LITE
5037 
5038 /* Child watch functions */
5039 
5040 #ifdef G_OS_WIN32
5041 
5042 static gboolean
5043 g_child_watch_prepare (GSource *source,
<a name="205" id="anc205"></a><span class="line-modified">5044                gint    *timeout)</span>
5045 {
5046   *timeout = -1;
5047   return FALSE;
5048 }
5049 
5050 static gboolean
5051 g_child_watch_check (GSource  *source)
5052 {
5053   GChildWatchSource *child_watch_source;
5054   gboolean child_exited;
5055 
5056   child_watch_source = (GChildWatchSource *) source;
5057 
5058   child_exited = child_watch_source-&gt;poll.revents &amp; G_IO_IN;
5059 
5060   if (child_exited)
5061     {
5062       DWORD child_status;
5063 
5064       /*
5065        * Note: We do _not_ check for the special value of STILL_ACTIVE
5066        * since we know that the process has exited and doing so runs into
5067        * problems if the child process &quot;happens to return STILL_ACTIVE(259)&quot;
5068        * as Microsoft&#39;s Platform SDK puts it.
5069        */
5070       if (!GetExitCodeProcess (child_watch_source-&gt;pid, &amp;child_status))
5071         {
<a name="206" id="anc206"></a><span class="line-modified">5072       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">5073       g_warning (G_STRLOC &quot;: GetExitCodeProcess() failed: %s&quot;, emsg);</span>
<span class="line-modified">5074       g_free (emsg);</span>
5075 
<a name="207" id="anc207"></a><span class="line-modified">5076       child_watch_source-&gt;child_status = -1;</span>
<span class="line-modified">5077     }</span>
5078       else
<a name="208" id="anc208"></a><span class="line-modified">5079     child_watch_source-&gt;child_status = child_status;</span>
5080     }
5081 
5082   return child_exited;
5083 }
5084 
5085 static void
5086 g_child_watch_finalize (GSource *source)
5087 {
5088 }
5089 
5090 #else /* G_OS_WIN32 */
5091 
5092 static void
5093 wake_source (GSource *source)
5094 {
5095   GMainContext *context;
5096 
5097   /* This should be thread-safe:
5098    *
5099    *  - if the source is currently being added to a context, that
5100    *    context will be woken up anyway
5101    *
5102    *  - if the source is currently being destroyed, we simply need not
5103    *    to crash:
5104    *
5105    *    - the memory for the source will remain valid until after the
5106    *      source finalize function was called (which would remove the
5107    *      source from the global list which we are currently holding the
5108    *      lock for)
5109    *
5110    *    - the GMainContext will either be NULL or point to a live
5111    *      GMainContext
5112    *
5113    *    - the GMainContext will remain valid since we hold the
5114    *      main_context_list lock
5115    *
5116    *  Since we are holding a lot of locks here, don&#39;t try to enter any
5117    *  more GMainContext functions for fear of dealock -- just hit the
5118    *  GWakeup and run.  Even if that&#39;s safe now, it could easily become
5119    *  unsafe with some very minor changes in the future, and signal
5120    *  handling is not the most well-tested codepath.
5121    */
5122   G_LOCK(main_context_list);
5123   context = source-&gt;context;
5124   if (context)
5125     g_wakeup_signal (context-&gt;wakeup);
5126   G_UNLOCK(main_context_list);
5127 }
5128 
5129 static void
5130 dispatch_unix_signals_unlocked (void)
5131 {
5132   gboolean pending[NSIG];
5133   GSList *node;
5134   gint i;
5135 
5136   /* clear this first in case another one arrives while we&#39;re processing */
5137   any_unix_signal_pending = FALSE;
5138 
5139   /* We atomically test/clear the bit from the global array in case
5140    * other signals arrive while we are dispatching.
5141    *
5142    * We then can safely use our own array below without worrying about
5143    * races.
5144    */
5145   for (i = 0; i &lt; NSIG; i++)
5146     {
5147       /* Be very careful with (the volatile) unix_signal_pending.
5148        *
5149        * We must ensure that it&#39;s not possible that we clear it without
5150        * handling the signal.  We therefore must ensure that our pending
5151        * array has a field set (ie: we will do something about the
5152        * signal) before we clear the item in unix_signal_pending.
5153        *
5154        * Note specifically: we must check _our_ array.
5155        */
5156       pending[i] = unix_signal_pending[i];
5157       if (pending[i])
5158         unix_signal_pending[i] = FALSE;
5159     }
5160 
5161   /* handle GChildWatchSource instances */
5162   if (pending[SIGCHLD])
5163     {
5164       /* The only way we can do this is to scan all of the children.
5165        *
5166        * The docs promise that we will not reap children that we are not
5167        * explicitly watching, so that ties our hands from calling
5168        * waitpid(-1).  We also can&#39;t use siginfo&#39;s si_pid field since if
5169        * multiple SIGCHLD arrive at the same time, one of them can be
5170        * dropped (since a given UNIX signal can only be pending once).
5171        */
5172       for (node = unix_child_watches; node; node = node-&gt;next)
5173         {
5174           GChildWatchSource *source = node-&gt;data;
5175 
<a name="209" id="anc209"></a><span class="line-modified">5176           if (!source-&gt;child_exited)</span>
5177             {
5178               pid_t pid;
5179               do
5180                 {
5181                   g_assert (source-&gt;pid &gt; 0);
5182 
5183                   pid = waitpid (source-&gt;pid, &amp;source-&gt;child_status, WNOHANG);
5184                   if (pid &gt; 0)
5185                     {
<a name="210" id="anc210"></a><span class="line-modified">5186                       source-&gt;child_exited = TRUE;</span>
5187                       wake_source ((GSource *) source);
5188                     }
5189                   else if (pid == -1 &amp;&amp; errno == ECHILD)
5190                     {
5191                       g_warning (&quot;GChildWatchSource: Exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.&quot;);
<a name="211" id="anc211"></a><span class="line-removed">5192                       source-&gt;child_exited = TRUE;</span>
5193                       source-&gt;child_status = 0;
<a name="212" id="anc212"></a>
5194                       wake_source ((GSource *) source);
5195                     }
5196                 }
5197               while (pid == -1 &amp;&amp; errno == EINTR);
5198             }
5199         }
5200     }
5201 
5202   /* handle GUnixSignalWatchSource instances */
5203   for (node = unix_signal_watches; node; node = node-&gt;next)
5204     {
5205       GUnixSignalWatchSource *source = node-&gt;data;
5206 
<a name="213" id="anc213"></a><span class="line-modified">5207       if (!source-&gt;pending)</span>

5208         {
<a name="214" id="anc214"></a><span class="line-modified">5209           if (pending[source-&gt;signum])</span>
<span class="line-removed">5210             {</span>
<span class="line-removed">5211               source-&gt;pending = TRUE;</span>
<span class="line-removed">5212 </span>
<span class="line-removed">5213               wake_source ((GSource *) source);</span>
<span class="line-removed">5214             }</span>
5215         }
5216     }
5217 
5218 }
5219 
5220 static void
5221 dispatch_unix_signals (void)
5222 {
5223   G_LOCK(unix_signal_lock);
5224   dispatch_unix_signals_unlocked ();
5225   G_UNLOCK(unix_signal_lock);
5226 }
5227 
5228 static gboolean
5229 g_child_watch_prepare (GSource *source,
<a name="215" id="anc215"></a><span class="line-modified">5230                gint    *timeout)</span>
5231 {
5232   GChildWatchSource *child_watch_source;
5233 
5234   child_watch_source = (GChildWatchSource *) source;
5235 
<a name="216" id="anc216"></a><span class="line-modified">5236   return child_watch_source-&gt;child_exited;</span>
5237 }
5238 
5239 static gboolean
5240 g_child_watch_check (GSource *source)
5241 {
5242   GChildWatchSource *child_watch_source;
5243 
5244   child_watch_source = (GChildWatchSource *) source;
5245 
<a name="217" id="anc217"></a><span class="line-modified">5246   return child_watch_source-&gt;child_exited;</span>
5247 }
5248 
5249 static gboolean
5250 g_unix_signal_watch_prepare (GSource *source,
<a name="218" id="anc218"></a><span class="line-modified">5251                  gint    *timeout)</span>
5252 {
5253   GUnixSignalWatchSource *unix_signal_source;
5254 
5255   unix_signal_source = (GUnixSignalWatchSource *) source;
5256 
<a name="219" id="anc219"></a><span class="line-modified">5257   return unix_signal_source-&gt;pending;</span>
5258 }
5259 
5260 static gboolean
5261 g_unix_signal_watch_check (GSource  *source)
5262 {
5263   GUnixSignalWatchSource *unix_signal_source;
5264 
5265   unix_signal_source = (GUnixSignalWatchSource *) source;
5266 
<a name="220" id="anc220"></a><span class="line-modified">5267   return unix_signal_source-&gt;pending;</span>
5268 }
5269 
5270 static gboolean
5271 g_unix_signal_watch_dispatch (GSource    *source,
<a name="221" id="anc221"></a><span class="line-modified">5272                   GSourceFunc callback,</span>
<span class="line-modified">5273                   gpointer    user_data)</span>
5274 {
5275   GUnixSignalWatchSource *unix_signal_source;
5276   gboolean again;
5277 
5278   unix_signal_source = (GUnixSignalWatchSource *) source;
5279 
5280   if (!callback)
5281     {
5282       g_warning (&quot;Unix signal source dispatched without callback. &quot;
<a name="222" id="anc222"></a><span class="line-modified">5283          &quot;You must call g_source_set_callback().&quot;);</span>
5284       return FALSE;
5285     }
5286 
<a name="223" id="anc223"></a><span class="line-modified">5287   again = (callback) (user_data);</span>
5288 
<a name="224" id="anc224"></a><span class="line-modified">5289   unix_signal_source-&gt;pending = FALSE;</span>
5290 
5291   return again;
5292 }
5293 
5294 static void
5295 ref_unix_signal_handler_unlocked (int signum)
5296 {
5297   /* Ensure we have the worker context */
5298   g_get_worker_context ();
5299   unix_signal_refcount[signum]++;
5300   if (unix_signal_refcount[signum] == 1)
5301     {
5302       struct sigaction action;
5303       action.sa_handler = g_unix_signal_handler;
5304       sigemptyset (&amp;action.sa_mask);
5305 #ifdef SA_RESTART
5306       action.sa_flags = SA_RESTART | SA_NOCLDSTOP;
5307 #else
5308       action.sa_flags = SA_NOCLDSTOP;
5309 #endif
5310       sigaction (signum, &amp;action, NULL);
5311     }
5312 }
5313 
5314 static void
5315 unref_unix_signal_handler_unlocked (int signum)
5316 {
5317   unix_signal_refcount[signum]--;
5318   if (unix_signal_refcount[signum] == 0)
5319     {
5320       struct sigaction action;
5321       memset (&amp;action, 0, sizeof (action));
5322       action.sa_handler = SIG_DFL;
5323       sigemptyset (&amp;action.sa_mask);
5324       sigaction (signum, &amp;action, NULL);
5325     }
5326 }
5327 
5328 /* Return a const string to avoid allocations. We lose precision in the case the
5329  * @signum is unrecognised, but that&#39;ll do. */
5330 static const gchar *
5331 signum_to_string (int signum)
5332 {
5333   /* See &#39;man signal.h&#39; */
5334 #define SIGNAL(s) \
5335     case (s): \
5336       return (&quot;GUnixSignalSource: &quot; #s);
5337   switch (signum)
5338     {
5339     /* These signals are guaranteed to exist by POSIX. */
5340     SIGNAL (SIGABRT)
5341     SIGNAL (SIGFPE)
5342     SIGNAL (SIGILL)
5343     SIGNAL (SIGINT)
5344     SIGNAL (SIGSEGV)
5345     SIGNAL (SIGTERM)
5346     /* Frustratingly, these are not, and hence for brevity the list is
5347      * incomplete. */
5348 #ifdef SIGALRM
5349     SIGNAL (SIGALRM)
5350 #endif
5351 #ifdef SIGCHLD
5352     SIGNAL (SIGCHLD)
5353 #endif
5354 #ifdef SIGHUP
5355     SIGNAL (SIGHUP)
5356 #endif
5357 #ifdef SIGKILL
5358     SIGNAL (SIGKILL)
5359 #endif
5360 #ifdef SIGPIPE
5361     SIGNAL (SIGPIPE)
5362 #endif
5363 #ifdef SIGQUIT
5364     SIGNAL (SIGQUIT)
5365 #endif
5366 #ifdef SIGSTOP
5367     SIGNAL (SIGSTOP)
5368 #endif
5369 #ifdef SIGUSR1
5370     SIGNAL (SIGUSR1)
5371 #endif
5372 #ifdef SIGUSR2
5373     SIGNAL (SIGUSR2)
5374 #endif
5375 #ifdef SIGPOLL
5376     SIGNAL (SIGPOLL)
5377 #endif
5378 #ifdef SIGPROF
5379     SIGNAL (SIGPROF)
5380 #endif
5381 #ifdef SIGTRAP
5382     SIGNAL (SIGTRAP)
5383 #endif
5384     default:
5385       return &quot;GUnixSignalSource: Unrecognized signal&quot;;
5386     }
5387 #undef SIGNAL
5388 }
5389 
5390 GSource *
5391 _g_main_create_unix_signal_watch (int signum)
5392 {
5393   GSource *source;
5394   GUnixSignalWatchSource *unix_signal_source;
5395 
5396   source = g_source_new (&amp;g_unix_signal_funcs, sizeof (GUnixSignalWatchSource));
5397   unix_signal_source = (GUnixSignalWatchSource *) source;
5398 
5399   unix_signal_source-&gt;signum = signum;
5400   unix_signal_source-&gt;pending = FALSE;
5401 
5402   /* Set a default name on the source, just in case the caller does not. */
5403   g_source_set_name (source, signum_to_string (signum));
5404 
5405   G_LOCK (unix_signal_lock);
5406   ref_unix_signal_handler_unlocked (signum);
5407   unix_signal_watches = g_slist_prepend (unix_signal_watches, unix_signal_source);
5408   dispatch_unix_signals_unlocked ();
5409   G_UNLOCK (unix_signal_lock);
5410 
5411   return source;
5412 }
5413 
5414 static void
5415 g_unix_signal_watch_finalize (GSource    *source)
5416 {
5417   GUnixSignalWatchSource *unix_signal_source;
5418 
5419   unix_signal_source = (GUnixSignalWatchSource *) source;
5420 
5421   G_LOCK (unix_signal_lock);
5422   unref_unix_signal_handler_unlocked (unix_signal_source-&gt;signum);
5423   unix_signal_watches = g_slist_remove (unix_signal_watches, source);
5424   G_UNLOCK (unix_signal_lock);
5425 }
5426 
5427 static void
5428 g_child_watch_finalize (GSource *source)
5429 {
5430   G_LOCK (unix_signal_lock);
5431   unix_child_watches = g_slist_remove (unix_child_watches, source);
5432   unref_unix_signal_handler_unlocked (SIGCHLD);
5433   G_UNLOCK (unix_signal_lock);
5434 }
5435 
5436 #endif /* G_OS_WIN32 */
5437 
5438 static gboolean
5439 g_child_watch_dispatch (GSource    *source,
<a name="225" id="anc225"></a><span class="line-modified">5440             GSourceFunc callback,</span>
<span class="line-modified">5441             gpointer    user_data)</span>
5442 {
5443   GChildWatchSource *child_watch_source;
5444   GChildWatchFunc child_watch_callback = (GChildWatchFunc) callback;
5445 
5446   child_watch_source = (GChildWatchSource *) source;
5447 
5448   if (!callback)
5449     {
5450       g_warning (&quot;Child watch source dispatched without callback. &quot;
<a name="226" id="anc226"></a><span class="line-modified">5451          &quot;You must call g_source_set_callback().&quot;);</span>
5452       return FALSE;
5453     }
5454 
5455   (child_watch_callback) (child_watch_source-&gt;pid, child_watch_source-&gt;child_status, user_data);
5456 
5457   /* We never keep a child watch source around as the child is gone */
5458   return FALSE;
5459 }
5460 
5461 #ifndef G_OS_WIN32
5462 
5463 static void
5464 g_unix_signal_handler (int signum)
5465 {
5466   gint saved_errno = errno;
5467 
5468   unix_signal_pending[signum] = TRUE;
5469   any_unix_signal_pending = TRUE;
5470 
5471   g_wakeup_signal (glib_worker_context-&gt;wakeup);
5472 
5473   errno = saved_errno;
5474 }
5475 
5476 #endif /* !G_OS_WIN32 */
5477 
5478 /**
5479  * g_child_watch_source_new:
5480  * @pid: process to watch. On POSIX the positive pid of a child process. On
5481  * Windows a handle for a process (which doesn&#39;t have to be a child).
5482  *
5483  * Creates a new child_watch source.
5484  *
5485  * The source will not initially be associated with any #GMainContext
5486  * and must be added to one with g_source_attach() before it will be
5487  * executed.
5488  *
5489  * Note that child watch sources can only be used in conjunction with
5490  * `g_spawn...` when the %G_SPAWN_DO_NOT_REAP_CHILD flag is used.
5491  *
5492  * Note that on platforms where #GPid must be explicitly closed
5493  * (see g_spawn_close_pid()) @pid must not be closed while the
5494  * source is still active. Typically, you will want to call
5495  * g_spawn_close_pid() in the callback function for the source.
5496  *
5497  * On POSIX platforms, the following restrictions apply to this API
5498  * due to limitations in POSIX process interfaces:
5499  *
5500  * * @pid must be a child of this process
5501  * * @pid must be positive
5502  * * the application must not call `waitpid` with a non-positive
5503  *   first argument, for instance in another thread
5504  * * the application must not wait for @pid to exit by any other
5505  *   mechanism, including `waitpid(pid, ...)` or a second child-watch
5506  *   source for the same @pid
5507  * * the application must not ignore SIGCHILD
5508  *
5509  * If any of those conditions are not met, this and related APIs will
5510  * not work correctly. This can often be diagnosed via a GLib warning
5511  * stating that `ECHILD` was received by `waitpid`.
5512  *
5513  * Calling `waitpid` for specific processes other than @pid remains a
5514  * valid thing to do.
5515  *
5516  * Returns: the newly-created child watch source
5517  *
5518  * Since: 2.4
5519  **/
5520 GSource *
5521 g_child_watch_source_new (GPid pid)
5522 {
5523   GSource *source;
5524   GChildWatchSource *child_watch_source;
5525 
5526 #ifndef G_OS_WIN32
5527   g_return_val_if_fail (pid &gt; 0, NULL);
5528 #endif
5529 
5530   source = g_source_new (&amp;g_child_watch_funcs, sizeof (GChildWatchSource));
5531 #ifdef GSTREAMER_LITE
5532   if (source == NULL)
5533       return NULL;
5534 #endif // GSTREAMER_LITE
5535   child_watch_source = (GChildWatchSource *)source;
5536 
5537   /* Set a default name on the source, just in case the caller does not. */
5538   g_source_set_name (source, &quot;GChildWatchSource&quot;);
5539 
5540   child_watch_source-&gt;pid = pid;
5541 
5542 #ifdef G_OS_WIN32
5543   child_watch_source-&gt;poll.fd = (gintptr) pid;
5544   child_watch_source-&gt;poll.events = G_IO_IN;
5545 
5546   g_source_add_poll (source, &amp;child_watch_source-&gt;poll);
5547 #else /* G_OS_WIN32 */
5548   G_LOCK (unix_signal_lock);
5549   ref_unix_signal_handler_unlocked (SIGCHLD);
5550   unix_child_watches = g_slist_prepend (unix_child_watches, child_watch_source);
5551   if (waitpid (pid, &amp;child_watch_source-&gt;child_status, WNOHANG) &gt; 0)
5552     child_watch_source-&gt;child_exited = TRUE;
5553   G_UNLOCK (unix_signal_lock);
5554 #endif /* G_OS_WIN32 */
5555 
5556   return source;
5557 }
5558 
5559 /**
5560  * g_child_watch_add_full: (rename-to g_child_watch_add)
5561  * @priority: the priority of the idle source. Typically this will be in the
5562  *            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
5563  * @pid:      process to watch. On POSIX the positive pid of a child process. On
5564  * Windows a handle for a process (which doesn&#39;t have to be a child).
5565  * @function: function to call
5566  * @data:     data to pass to @function
5567  * @notify: (nullable): function to call when the idle is removed, or %NULL
5568  *
5569  * Sets a function to be called when the child indicated by @pid
5570  * exits, at the priority @priority.
5571  *
5572  * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
5573  * you will need to pass #G_SPAWN_DO_NOT_REAP_CHILD as flag to
5574  * the spawn function for the child watching to work.
5575  *
5576  * In many programs, you will want to call g_spawn_check_exit_status()
5577  * in the callback to determine whether or not the child exited
5578  * successfully.
5579  *
5580  * Also, note that on platforms where #GPid must be explicitly closed
5581  * (see g_spawn_close_pid()) @pid must not be closed while the source
5582  * is still active.  Typically, you should invoke g_spawn_close_pid()
5583  * in the callback function for the source.
5584  *
5585  * GLib supports only a single callback per process id.
5586  * On POSIX platforms, the same restrictions mentioned for
5587  * g_child_watch_source_new() apply to this function.
5588  *
5589  * This internally creates a main loop source using
5590  * g_child_watch_source_new() and attaches it to the main loop context
5591  * using g_source_attach(). You can do these steps manually if you
5592  * need greater control.
5593  *
5594  * Returns: the ID (greater than 0) of the event source.
5595  *
5596  * Since: 2.4
5597  **/
5598 guint
5599 g_child_watch_add_full (gint            priority,
<a name="227" id="anc227"></a><span class="line-modified">5600             GPid            pid,</span>
<span class="line-modified">5601             GChildWatchFunc function,</span>
<span class="line-modified">5602             gpointer        data,</span>
<span class="line-modified">5603             GDestroyNotify  notify)</span>
5604 {
5605   GSource *source;
5606   guint id;
5607 
5608   g_return_val_if_fail (function != NULL, 0);
5609 #ifndef G_OS_WIN32
5610   g_return_val_if_fail (pid &gt; 0, 0);
5611 #endif
5612 
5613   source = g_child_watch_source_new (pid);
5614 
5615   if (priority != G_PRIORITY_DEFAULT)
5616     g_source_set_priority (source, priority);
5617 
5618   g_source_set_callback (source, (GSourceFunc) function, data, notify);
5619   id = g_source_attach (source, NULL);
5620   g_source_unref (source);
5621 
5622   return id;
5623 }
5624 
5625 /**
5626  * g_child_watch_add:
5627  * @pid:      process id to watch. On POSIX the positive pid of a child
5628  * process. On Windows a handle for a process (which doesn&#39;t have to be
5629  * a child).
5630  * @function: function to call
5631  * @data:     data to pass to @function
5632  *
5633  * Sets a function to be called when the child indicated by @pid
5634  * exits, at a default priority, #G_PRIORITY_DEFAULT.
5635  *
5636  * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
5637  * you will need to pass #G_SPAWN_DO_NOT_REAP_CHILD as flag to
5638  * the spawn function for the child watching to work.
5639  *
5640  * Note that on platforms where #GPid must be explicitly closed
5641  * (see g_spawn_close_pid()) @pid must not be closed while the
5642  * source is still active. Typically, you will want to call
5643  * g_spawn_close_pid() in the callback function for the source.
5644  *
5645  * GLib supports only a single callback per process id.
5646  * On POSIX platforms, the same restrictions mentioned for
5647  * g_child_watch_source_new() apply to this function.
5648  *
5649  * This internally creates a main loop source using
5650  * g_child_watch_source_new() and attaches it to the main loop context
5651  * using g_source_attach(). You can do these steps manually if you
5652  * need greater control.
5653  *
5654  * Returns: the ID (greater than 0) of the event source.
5655  *
5656  * Since: 2.4
5657  **/
5658 guint
5659 g_child_watch_add (GPid            pid,
<a name="228" id="anc228"></a><span class="line-modified">5660            GChildWatchFunc function,</span>
<span class="line-modified">5661            gpointer        data)</span>
5662 {
5663   return g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, function, data, NULL);
5664 }
5665 
5666 
5667 /* Idle functions */
5668 
5669 static gboolean
5670 g_idle_prepare  (GSource  *source,
<a name="229" id="anc229"></a><span class="line-modified">5671          gint     *timeout)</span>
5672 {
5673   *timeout = 0;
5674 
5675   return TRUE;
5676 }
5677 
5678 static gboolean
5679 g_idle_check    (GSource  *source)
5680 {
5681   return TRUE;
5682 }
5683 
5684 static gboolean
5685 g_idle_dispatch (GSource    *source,
<a name="230" id="anc230"></a><span class="line-modified">5686          GSourceFunc callback,</span>
<span class="line-modified">5687          gpointer    user_data)</span>
5688 {
5689   gboolean again;
5690 
5691   if (!callback)
5692     {
5693       g_warning (&quot;Idle source dispatched without callback. &quot;
<a name="231" id="anc231"></a><span class="line-modified">5694          &quot;You must call g_source_set_callback().&quot;);</span>
5695       return FALSE;
5696     }
5697 
5698   again = callback (user_data);
5699 
5700   TRACE (GLIB_IDLE_DISPATCH (source, source-&gt;context, callback, user_data, again));
5701 
5702   return again;
5703 }
5704 
5705 /**
5706  * g_idle_source_new:
5707  *
5708  * Creates a new idle source.
5709  *
5710  * The source will not initially be associated with any #GMainContext
5711  * and must be added to one with g_source_attach() before it will be
5712  * executed. Note that the default priority for idle sources is
5713  * %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
5714  * have a default priority of %G_PRIORITY_DEFAULT.
5715  *
5716  * Returns: the newly-created idle source
5717  **/
5718 GSource *
5719 g_idle_source_new (void)
5720 {
5721   GSource *source;
5722 
5723   source = g_source_new (&amp;g_idle_funcs, sizeof (GSource));
5724   g_source_set_priority (source, G_PRIORITY_DEFAULT_IDLE);
5725 
5726   /* Set a default name on the source, just in case the caller does not. */
5727   g_source_set_name (source, &quot;GIdleSource&quot;);
5728 
5729   return source;
5730 }
5731 
5732 /**
5733  * g_idle_add_full: (rename-to g_idle_add)
5734  * @priority: the priority of the idle source. Typically this will be in the
5735  *            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
5736  * @function: function to call
5737  * @data:     data to pass to @function
5738  * @notify: (nullable): function to call when the idle is removed, or %NULL
5739  *
5740  * Adds a function to be called whenever there are no higher priority
5741  * events pending.  If the function returns %FALSE it is automatically
5742  * removed from the list of event sources and will not be called again.
5743  *
5744  * See [memory management of sources][mainloop-memory-management] for details
5745  * on how to handle the return value and memory management of @data.
5746  *
5747  * This internally creates a main loop source using g_idle_source_new()
5748  * and attaches it to the global #GMainContext using g_source_attach(), so
5749  * the callback will be invoked in whichever thread is running that main
5750  * context. You can do these steps manually if you need greater control or to
5751  * use a custom main context.
5752  *
5753  * Returns: the ID (greater than 0) of the event source.
5754  **/
5755 guint
5756 g_idle_add_full (gint           priority,
<a name="232" id="anc232"></a><span class="line-modified">5757          GSourceFunc    function,</span>
<span class="line-modified">5758          gpointer       data,</span>
<span class="line-modified">5759          GDestroyNotify notify)</span>
5760 {
5761   GSource *source;
5762   guint id;
5763 
5764   g_return_val_if_fail (function != NULL, 0);
5765 
5766   source = g_idle_source_new ();
5767 
5768   if (priority != G_PRIORITY_DEFAULT_IDLE)
5769     g_source_set_priority (source, priority);
5770 
5771   g_source_set_callback (source, function, data, notify);
5772   id = g_source_attach (source, NULL);
5773 
5774   TRACE (GLIB_IDLE_ADD (source, g_main_context_default (), id, priority, function, data));
5775 
5776   g_source_unref (source);
5777 
5778   return id;
5779 }
5780 
5781 /**
5782  * g_idle_add:
5783  * @function: function to call
5784  * @data: data to pass to @function.
5785  *
5786  * Adds a function to be called whenever there are no higher priority
5787  * events pending to the default main loop. The function is given the
5788  * default idle priority, #G_PRIORITY_DEFAULT_IDLE.  If the function
5789  * returns %FALSE it is automatically removed from the list of event
5790  * sources and will not be called again.
5791  *
5792  * See [memory management of sources][mainloop-memory-management] for details
5793  * on how to handle the return value and memory management of @data.
5794  *
5795  * This internally creates a main loop source using g_idle_source_new()
5796  * and attaches it to the global #GMainContext using g_source_attach(), so
5797  * the callback will be invoked in whichever thread is running that main
5798  * context. You can do these steps manually if you need greater control or to
5799  * use a custom main context.
5800  *
5801  * Returns: the ID (greater than 0) of the event source.
5802  **/
5803 guint
5804 g_idle_add (GSourceFunc    function,
<a name="233" id="anc233"></a><span class="line-modified">5805         gpointer       data)</span>
5806 {
5807   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, function, data, NULL);
5808 }
5809 
5810 /**
5811  * g_idle_remove_by_data:
5812  * @data: the data for the idle source&#39;s callback.
5813  *
5814  * Removes the idle function with the given data.
5815  *
5816  * Returns: %TRUE if an idle source was found and removed.
5817  **/
5818 gboolean
5819 g_idle_remove_by_data (gpointer data)
5820 {
5821   return g_source_remove_by_funcs_user_data (&amp;g_idle_funcs, data);
5822 }
5823 
5824 /**
5825  * g_main_context_invoke:
5826  * @context: (nullable): a #GMainContext, or %NULL
5827  * @function: function to call
5828  * @data: data to pass to @function
5829  *
5830  * Invokes a function in such a way that @context is owned during the
5831  * invocation of @function.
5832  *
<a name="234" id="anc234"></a><span class="line-modified">5833  * If @context is %NULL then the global default main context as</span>
<span class="line-modified">5834  * returned by g_main_context_default() is used.</span>
5835  *
5836  * If @context is owned by the current thread, @function is called
5837  * directly.  Otherwise, if @context is the thread-default main context
5838  * of the current thread and g_main_context_acquire() succeeds, then
5839  * @function is called and g_main_context_release() is called
5840  * afterwards.
5841  *
5842  * In any other case, an idle source is created to call @function and
5843  * that source is attached to @context (presumably to be run in another
5844  * thread).  The idle source is attached with #G_PRIORITY_DEFAULT
5845  * priority.  If you want a different priority, use
5846  * g_main_context_invoke_full().
5847  *
5848  * Note that, as with normal idle functions, @function should probably
5849  * return %FALSE.  If it returns %TRUE, it will be continuously run in a
5850  * loop (and may prevent this call from returning).
5851  *
5852  * Since: 2.28
5853  **/
5854 void
5855 g_main_context_invoke (GMainContext *context,
5856                        GSourceFunc   function,
5857                        gpointer      data)
5858 {
5859   g_main_context_invoke_full (context,
5860                               G_PRIORITY_DEFAULT,
5861                               function, data, NULL);
5862 }
5863 
5864 /**
5865  * g_main_context_invoke_full:
5866  * @context: (nullable): a #GMainContext, or %NULL
5867  * @priority: the priority at which to run @function
5868  * @function: function to call
5869  * @data: data to pass to @function
5870  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
5871  *
5872  * Invokes a function in such a way that @context is owned during the
5873  * invocation of @function.
5874  *
5875  * This function is the same as g_main_context_invoke() except that it
5876  * lets you specify the priority in case @function ends up being
5877  * scheduled as an idle and also lets you give a #GDestroyNotify for @data.
5878  *
5879  * @notify should not assume that it is called from any particular
5880  * thread or with any particular context acquired.
5881  *
5882  * Since: 2.28
5883  **/
5884 void
5885 g_main_context_invoke_full (GMainContext   *context,
5886                             gint            priority,
5887                             GSourceFunc     function,
5888                             gpointer        data,
5889                             GDestroyNotify  notify)
5890 {
5891   g_return_if_fail (function != NULL);
5892 
5893   if (!context)
5894     context = g_main_context_default ();
5895 
5896   if (g_main_context_is_owner (context))
5897     {
5898       while (function (data));
5899       if (notify != NULL)
5900         notify (data);
5901     }
5902 
5903   else
5904     {
5905       GMainContext *thread_default;
5906 
5907       thread_default = g_main_context_get_thread_default ();
5908 
5909       if (!thread_default)
5910         thread_default = g_main_context_default ();
5911 
5912       if (thread_default == context &amp;&amp; g_main_context_acquire (context))
5913         {
5914           while (function (data));
5915 
5916           g_main_context_release (context);
5917 
5918           if (notify != NULL)
5919             notify (data);
5920         }
5921       else
5922         {
5923           GSource *source;
5924 
5925           source = g_idle_source_new ();
5926           g_source_set_priority (source, priority);
5927           g_source_set_callback (source, function, data, notify);
5928           g_source_attach (source, context);
5929           g_source_unref (source);
5930         }
5931     }
5932 }
5933 
5934 static gpointer
5935 glib_worker_main (gpointer data)
5936 {
5937   while (TRUE)
5938     {
5939       g_main_context_iteration (glib_worker_context, TRUE);
5940 
5941 #ifdef G_OS_UNIX
5942       if (any_unix_signal_pending)
5943         dispatch_unix_signals ();
5944 #endif
5945     }
5946 
5947   return NULL; /* worst GCC warning message ever... */
5948 }
5949 
5950 GMainContext *
5951 g_get_worker_context (void)
5952 {
5953   static gsize initialised;
5954 
5955   if (g_once_init_enter (&amp;initialised))
5956     {
5957       /* mask all signals in the worker thread */
5958 #ifdef G_OS_UNIX
5959       sigset_t prev_mask;
5960       sigset_t all;
5961 
5962       sigfillset (&amp;all);
5963       pthread_sigmask (SIG_SETMASK, &amp;all, &amp;prev_mask);
5964 #endif
5965       glib_worker_context = g_main_context_new ();
5966       g_thread_new (&quot;gmain&quot;, glib_worker_main, NULL);
5967 #ifdef G_OS_UNIX
5968       pthread_sigmask (SIG_SETMASK, &amp;prev_mask, NULL);
5969 #endif
5970       g_once_init_leave (&amp;initialised, TRUE);
5971     }
5972 
5973   return glib_worker_context;
5974 }
<a name="235" id="anc235"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="235" type="hidden" />
</body>
</html>