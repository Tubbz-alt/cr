<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtypemodule.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtypemodule.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtypemodule.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62 typedef struct _ModuleInterfaceInfo ModuleInterfaceInfo;
 63 
 64 struct _ModuleTypeInfo
 65 {
 66   gboolean  loaded;
 67   GType     type;
 68   GType     parent_type;
 69   GTypeInfo info;
 70 };
 71 
 72 struct _ModuleInterfaceInfo
 73 {
 74   gboolean       loaded;
 75   GType          instance_type;
 76   GType          interface_type;
 77   GInterfaceInfo info;
 78 };
 79 
 80 static void g_type_module_use_plugin              (GTypePlugin     *plugin);
 81 static void g_type_module_complete_type_info      (GTypePlugin     *plugin,
<span class="line-modified"> 82                            GType            g_type,</span>
<span class="line-modified"> 83                            GTypeInfo       *info,</span>
<span class="line-modified"> 84                            GTypeValueTable *value_table);</span>
 85 static void g_type_module_complete_interface_info (GTypePlugin     *plugin,
<span class="line-modified"> 86                            GType            instance_type,</span>
<span class="line-modified"> 87                            GType            interface_type,</span>
<span class="line-modified"> 88                            GInterfaceInfo  *info);</span>
 89 
 90 static gpointer parent_class = NULL;
 91 
 92 static void
 93 g_type_module_dispose (GObject *object)
 94 {
 95   GTypeModule *module = G_TYPE_MODULE (object);
 96 
 97   if (module-&gt;type_infos || module-&gt;interface_infos)
 98     {
 99       g_warning (G_STRLOC &quot;: unsolicitated invocation of g_object_run_dispose() on GTypeModule&quot;);
100 
101       g_object_ref (object);
102     }
103 
104   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
105 }
106 
107 static void
108 g_type_module_finalize (GObject *object)
</pre>
<hr />
<pre>
158         NULL,               /* interface_data */
159       };
160 
161       type_module_type = g_type_register_static (G_TYPE_OBJECT, g_intern_static_string (&quot;GTypeModule&quot;), &amp;type_module_info, G_TYPE_FLAG_ABSTRACT);
162 
163       g_type_add_interface_static (type_module_type, G_TYPE_TYPE_PLUGIN, &amp;iface_info);
164     }
165 
166   return type_module_type;
167 }
168 
169 /**
170  * g_type_module_set_name:
171  * @module: a #GTypeModule.
172  * @name: a human-readable name to use in error messages.
173  *
174  * Sets the name for a #GTypeModule
175  */
176 void
177 g_type_module_set_name (GTypeModule  *module,
<span class="line-modified">178             const gchar  *name)</span>
179 {
180   g_return_if_fail (G_IS_TYPE_MODULE (module));
181 
182   g_free (module-&gt;name);
183   module-&gt;name = g_strdup (name);
184 }
185 
186 static ModuleTypeInfo *
187 g_type_module_find_type_info (GTypeModule *module,
<span class="line-modified">188                   GType        type)</span>
189 {
190   GSList *tmp_list = module-&gt;type_infos;
191   while (tmp_list)
192     {
193       ModuleTypeInfo *type_info = tmp_list-&gt;data;
194       if (type_info-&gt;type == type)
<span class="line-modified">195     return type_info;</span>
196 
197       tmp_list = tmp_list-&gt;next;
198     }
199 
200   return NULL;
201 }
202 
203 static ModuleInterfaceInfo *
204 g_type_module_find_interface_info (GTypeModule *module,
<span class="line-modified">205                    GType        instance_type,</span>
<span class="line-modified">206                    GType        interface_type)</span>
207 {
208   GSList *tmp_list = module-&gt;interface_infos;
209   while (tmp_list)
210     {
211       ModuleInterfaceInfo *interface_info = tmp_list-&gt;data;
212       if (interface_info-&gt;instance_type == instance_type &amp;&amp;
<span class="line-modified">213       interface_info-&gt;interface_type == interface_type)</span>
<span class="line-modified">214     return interface_info;</span>
215 
216       tmp_list = tmp_list-&gt;next;
217     }
218 
219   return NULL;
220 }
221 
222 /**
223  * g_type_module_use:
224  * @module: a #GTypeModule
225  *
226  * Increases the use count of a #GTypeModule by one. If the
227  * use count was zero before, the plugin will be loaded.
228  * If loading the plugin fails, the use count is reset to
229  * its prior value.
230  *
231  * Returns: %FALSE if the plugin needed to be loaded and
232  *  loading the plugin failed.
233  */
234 gboolean
235 g_type_module_use (GTypeModule *module)
236 {
237   g_return_val_if_fail (G_IS_TYPE_MODULE (module), FALSE);
238 
239   module-&gt;use_count++;
240   if (module-&gt;use_count == 1)
241     {
242       GSList *tmp_list;
243 
244       if (!G_TYPE_MODULE_GET_CLASS (module)-&gt;load (module))
<span class="line-modified">245     {</span>
<span class="line-modified">246       module-&gt;use_count--;</span>
<span class="line-modified">247       return FALSE;</span>
<span class="line-modified">248     }</span>
249 
250       tmp_list = module-&gt;type_infos;
251       while (tmp_list)
<span class="line-modified">252     {</span>
<span class="line-modified">253       ModuleTypeInfo *type_info = tmp_list-&gt;data;</span>
<span class="line-modified">254       if (!type_info-&gt;loaded)</span>
<span class="line-modified">255         {</span>
<span class="line-modified">256           g_warning (&quot;plugin &#39;%s&#39; failed to register type &#39;%s&#39;&quot;,</span>
<span class="line-modified">257              module-&gt;name ? module-&gt;name : &quot;(unknown)&quot;,</span>
<span class="line-modified">258              g_type_name (type_info-&gt;type));</span>
<span class="line-modified">259           module-&gt;use_count--;</span>
<span class="line-modified">260           return FALSE;</span>
<span class="line-modified">261         }</span>
262 
<span class="line-modified">263       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">264     }</span>
265     }
266 
267   return TRUE;
268 }
269 
270 /**
271  * g_type_module_unuse:
272  * @module: a #GTypeModule
273  *
274  * Decreases the use count of a #GTypeModule by one. If the
275  * result is zero, the module will be unloaded. (However, the
276  * #GTypeModule will not be freed, and types associated with the
277  * #GTypeModule are not unregistered. Once a #GTypeModule is
278  * initialized, it must exist forever.)
279  */
280 void
281 g_type_module_unuse (GTypeModule *module)
282 {
283   g_return_if_fail (G_IS_TYPE_MODULE (module));
284   g_return_if_fail (module-&gt;use_count &gt; 0);
285 
286   module-&gt;use_count--;
287 
288   if (module-&gt;use_count == 0)
289     {
290       GSList *tmp_list;
291 
292       G_TYPE_MODULE_GET_CLASS (module)-&gt;unload (module);
293 
294       tmp_list = module-&gt;type_infos;
295       while (tmp_list)
<span class="line-modified">296     {</span>
<span class="line-modified">297       ModuleTypeInfo *type_info = tmp_list-&gt;data;</span>
<span class="line-modified">298       type_info-&gt;loaded = FALSE;</span>
299 
<span class="line-modified">300       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">301     }</span>
302     }
303 }
304 
305 static void
306 g_type_module_use_plugin (GTypePlugin *plugin)
307 {
308   GTypeModule *module = G_TYPE_MODULE (plugin);
309 
310   if (!g_type_module_use (module))
311     {
312       g_warning (&quot;Fatal error - Could not reload previously loaded plugin &#39;%s&#39;&quot;,
<span class="line-modified">313          module-&gt;name ? module-&gt;name : &quot;(unknown)&quot;);</span>
314       exit (1);
315     }
316 }
317 
318 static void
319 g_type_module_complete_type_info (GTypePlugin     *plugin,
<span class="line-modified">320                   GType            g_type,</span>
<span class="line-modified">321                   GTypeInfo       *info,</span>
<span class="line-modified">322                   GTypeValueTable *value_table)</span>
323 {
324   GTypeModule *module = G_TYPE_MODULE (plugin);
325   ModuleTypeInfo *module_type_info = g_type_module_find_type_info (module, g_type);
326 #ifdef GSTREAMER_LITE
327   if (module_type_info == NULL)
328   {
329     g_warning (&quot;Cannot find module type info.&quot;);
330     return;
331   }
332 #endif // GSTREAMER_LITE
333 
334   *info = module_type_info-&gt;info;
335 
336   if (module_type_info-&gt;info.value_table)
337     *value_table = *module_type_info-&gt;info.value_table;
338 }
339 
340 static void
341 g_type_module_complete_interface_info (GTypePlugin    *plugin,
<span class="line-modified">342                        GType           instance_type,</span>
<span class="line-modified">343                        GType           interface_type,</span>
<span class="line-modified">344                        GInterfaceInfo *info)</span>
345 {
346   GTypeModule *module = G_TYPE_MODULE (plugin);
347   ModuleInterfaceInfo *module_interface_info = g_type_module_find_interface_info (module, instance_type, interface_type);
348 
349   *info = module_interface_info-&gt;info;
350 }
351 
352 /**
353  * g_type_module_register_type:
354  * @module: (nullable): a #GTypeModule
355  * @parent_type: the type for the parent class
356  * @type_name: name for the type
357  * @type_info: type information structure
358  * @flags: flags field providing details about the type
359  *
360  * Looks up or registers a type that is implemented with a particular
361  * type plugin. If a type with name @type_name was previously registered,
362  * the #GType identifier for the type is returned, otherwise the type
363  * is newly registered, and the resulting #GType identifier returned.
364  *
365  * When reregistering a type (typically because a module is unloaded
366  * then reloaded, and reinitialized), @module and @parent_type must
367  * be the same as they were previously.
368  *
369  * As long as any instances of the type exist, the type plugin will
370  * not be unloaded.
371  *
372  * Since 2.56 if @module is %NULL this will call g_type_register_static()
373  * instead. This can be used when making a static build of the module.
374  *
375  * Returns: the new or existing type ID
376  */
377 GType
378 g_type_module_register_type (GTypeModule     *module,
<span class="line-modified">379                  GType            parent_type,</span>
<span class="line-modified">380                  const gchar     *type_name,</span>
<span class="line-modified">381                  const GTypeInfo *type_info,</span>
<span class="line-modified">382                  GTypeFlags       flags)</span>
383 {
384   ModuleTypeInfo *module_type_info = NULL;
385   GType type;
386 
387   g_return_val_if_fail (type_name != NULL, 0);
388   g_return_val_if_fail (type_info != NULL, 0);
389 
390   if (module == NULL)
391     {
392       /* Cannot pass type_info directly to g_type_register_static() here because
393        * it has class_finalize != NULL and that&#39;s forbidden for static types */
394       return g_type_register_static_simple (parent_type,
395                                             type_name,
396                                             type_info-&gt;class_size,
397                                             type_info-&gt;class_init,
398                                             type_info-&gt;instance_size,
399                                             type_info-&gt;instance_init,
400                                             flags);
401     }
402 
403   type = g_type_from_name (type_name);
404   if (type)
405     {
406       GTypePlugin *old_plugin = g_type_get_plugin (type);
407 
408       if (old_plugin != G_TYPE_PLUGIN (module))
<span class="line-modified">409     {</span>
<span class="line-modified">410       g_warning (&quot;Two different plugins tried to register &#39;%s&#39;.&quot;, type_name);</span>
<span class="line-modified">411       return 0;</span>
<span class="line-modified">412     }</span>
413     }
414 
415   if (type)
416     {
417       module_type_info = g_type_module_find_type_info (module, type);
418 #ifdef GSTREAMER_LITE
419       if (module_type_info == NULL)
420       {
421         g_warning (&quot;Cannot find module type info.&quot;);
422         return 0;
423       }
424 #endif // GSTREAMER_LITE
425 
426       if (module_type_info-&gt;parent_type != parent_type)
<span class="line-modified">427     {</span>
<span class="line-modified">428       const gchar *parent_type_name = g_type_name (parent_type);</span>
429 
<span class="line-modified">430       g_warning (&quot;Type &#39;%s&#39; recreated with different parent type.&quot;</span>
<span class="line-modified">431                  &quot;(was &#39;%s&#39;, now &#39;%s&#39;)&quot;, type_name,</span>
<span class="line-modified">432                  g_type_name (module_type_info-&gt;parent_type),</span>
<span class="line-modified">433                  parent_type_name ? parent_type_name : &quot;(unknown)&quot;);</span>
<span class="line-modified">434       return 0;</span>
<span class="line-modified">435     }</span>
436 
437       if (module_type_info-&gt;info.value_table)
<span class="line-modified">438     g_free ((GTypeValueTable *) module_type_info-&gt;info.value_table);</span>
439     }
440   else
441     {
442       module_type_info = g_new (ModuleTypeInfo, 1);
443 
444       module_type_info-&gt;parent_type = parent_type;
445       module_type_info-&gt;type = g_type_register_dynamic (parent_type, type_name, G_TYPE_PLUGIN (module), flags);
446 
447       module-&gt;type_infos = g_slist_prepend (module-&gt;type_infos, module_type_info);
448     }
449 
450   module_type_info-&gt;loaded = TRUE;
451   module_type_info-&gt;info = *type_info;
452   if (type_info-&gt;value_table)
453     module_type_info-&gt;info.value_table = g_memdup (type_info-&gt;value_table,
<span class="line-modified">454                            sizeof (GTypeValueTable));</span>
455 
456   return module_type_info-&gt;type;
457 }
458 
459 /**
460  * g_type_module_add_interface:
461  * @module: (nullable): a #GTypeModule
462  * @instance_type: type to which to add the interface.
463  * @interface_type: interface type to add
464  * @interface_info: type information structure
465  *
466  * Registers an additional interface for a type, whose interface lives
467  * in the given type plugin. If the interface was already registered
468  * for the type in this plugin, nothing will be done.
469  *
470  * As long as any instances of the type exist, the type plugin will
471  * not be unloaded.
472  *
473  * Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
474  * instead. This can be used when making a static build of the module.
475  */
476 void
477 g_type_module_add_interface (GTypeModule          *module,
<span class="line-modified">478                  GType                 instance_type,</span>
<span class="line-modified">479                  GType                 interface_type,</span>
<span class="line-modified">480                  const GInterfaceInfo *interface_info)</span>
481 {
482   ModuleInterfaceInfo *module_interface_info = NULL;
483 
484   g_return_if_fail (interface_info != NULL);
485 
486   if (module == NULL)
487     {
488       g_type_add_interface_static (instance_type, interface_type, interface_info);
489       return;
490     }
491 
492   if (g_type_is_a (instance_type, interface_type))
493     {
494       GTypePlugin *old_plugin = g_type_interface_get_plugin (instance_type,
<span class="line-modified">495                                  interface_type);</span>
496 
497       if (!old_plugin)
<span class="line-modified">498     {</span>
<span class="line-modified">499       g_warning (&quot;Interface &#39;%s&#39; for &#39;%s&#39; was previously registered statically or for a parent type.&quot;,</span>
<span class="line-modified">500              g_type_name (interface_type), g_type_name (instance_type));</span>
<span class="line-modified">501       return;</span>
<span class="line-modified">502     }</span>
503       else if (old_plugin != G_TYPE_PLUGIN (module))
<span class="line-modified">504     {</span>
<span class="line-modified">505       g_warning (&quot;Two different plugins tried to register interface &#39;%s&#39; for &#39;%s&#39;.&quot;,</span>
<span class="line-modified">506              g_type_name (interface_type), g_type_name (instance_type));</span>
<span class="line-modified">507       return;</span>
<span class="line-modified">508     }</span>
509 
510       module_interface_info = g_type_module_find_interface_info (module, instance_type, interface_type);
511 
512       g_assert (module_interface_info);
513     }
514   else
515     {
516       module_interface_info = g_new (ModuleInterfaceInfo, 1);
517 
518       module_interface_info-&gt;instance_type = instance_type;
519       module_interface_info-&gt;interface_type = interface_type;
520 
521       g_type_add_interface_dynamic (instance_type, interface_type, G_TYPE_PLUGIN (module));
522 
523       module-&gt;interface_infos = g_slist_prepend (module-&gt;interface_infos, module_interface_info);
524     }
525 
526   module_interface_info-&gt;loaded = TRUE;
527   module_interface_info-&gt;info = *interface_info;
528 }
</pre>
</td>
<td>
<hr />
<pre>
 62 typedef struct _ModuleInterfaceInfo ModuleInterfaceInfo;
 63 
 64 struct _ModuleTypeInfo
 65 {
 66   gboolean  loaded;
 67   GType     type;
 68   GType     parent_type;
 69   GTypeInfo info;
 70 };
 71 
 72 struct _ModuleInterfaceInfo
 73 {
 74   gboolean       loaded;
 75   GType          instance_type;
 76   GType          interface_type;
 77   GInterfaceInfo info;
 78 };
 79 
 80 static void g_type_module_use_plugin              (GTypePlugin     *plugin);
 81 static void g_type_module_complete_type_info      (GTypePlugin     *plugin,
<span class="line-modified"> 82                GType            g_type,</span>
<span class="line-modified"> 83                GTypeInfo       *info,</span>
<span class="line-modified"> 84                GTypeValueTable *value_table);</span>
 85 static void g_type_module_complete_interface_info (GTypePlugin     *plugin,
<span class="line-modified"> 86                GType            instance_type,</span>
<span class="line-modified"> 87                GType            interface_type,</span>
<span class="line-modified"> 88                GInterfaceInfo  *info);</span>
 89 
 90 static gpointer parent_class = NULL;
 91 
 92 static void
 93 g_type_module_dispose (GObject *object)
 94 {
 95   GTypeModule *module = G_TYPE_MODULE (object);
 96 
 97   if (module-&gt;type_infos || module-&gt;interface_infos)
 98     {
 99       g_warning (G_STRLOC &quot;: unsolicitated invocation of g_object_run_dispose() on GTypeModule&quot;);
100 
101       g_object_ref (object);
102     }
103 
104   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
105 }
106 
107 static void
108 g_type_module_finalize (GObject *object)
</pre>
<hr />
<pre>
158         NULL,               /* interface_data */
159       };
160 
161       type_module_type = g_type_register_static (G_TYPE_OBJECT, g_intern_static_string (&quot;GTypeModule&quot;), &amp;type_module_info, G_TYPE_FLAG_ABSTRACT);
162 
163       g_type_add_interface_static (type_module_type, G_TYPE_TYPE_PLUGIN, &amp;iface_info);
164     }
165 
166   return type_module_type;
167 }
168 
169 /**
170  * g_type_module_set_name:
171  * @module: a #GTypeModule.
172  * @name: a human-readable name to use in error messages.
173  *
174  * Sets the name for a #GTypeModule
175  */
176 void
177 g_type_module_set_name (GTypeModule  *module,
<span class="line-modified">178       const gchar  *name)</span>
179 {
180   g_return_if_fail (G_IS_TYPE_MODULE (module));
181 
182   g_free (module-&gt;name);
183   module-&gt;name = g_strdup (name);
184 }
185 
186 static ModuleTypeInfo *
187 g_type_module_find_type_info (GTypeModule *module,
<span class="line-modified">188             GType        type)</span>
189 {
190   GSList *tmp_list = module-&gt;type_infos;
191   while (tmp_list)
192     {
193       ModuleTypeInfo *type_info = tmp_list-&gt;data;
194       if (type_info-&gt;type == type)
<span class="line-modified">195   return type_info;</span>
196 
197       tmp_list = tmp_list-&gt;next;
198     }
199 
200   return NULL;
201 }
202 
203 static ModuleInterfaceInfo *
204 g_type_module_find_interface_info (GTypeModule *module,
<span class="line-modified">205            GType        instance_type,</span>
<span class="line-modified">206            GType        interface_type)</span>
207 {
208   GSList *tmp_list = module-&gt;interface_infos;
209   while (tmp_list)
210     {
211       ModuleInterfaceInfo *interface_info = tmp_list-&gt;data;
212       if (interface_info-&gt;instance_type == instance_type &amp;&amp;
<span class="line-modified">213     interface_info-&gt;interface_type == interface_type)</span>
<span class="line-modified">214   return interface_info;</span>
215 
216       tmp_list = tmp_list-&gt;next;
217     }
218 
219   return NULL;
220 }
221 
222 /**
223  * g_type_module_use:
224  * @module: a #GTypeModule
225  *
226  * Increases the use count of a #GTypeModule by one. If the
227  * use count was zero before, the plugin will be loaded.
228  * If loading the plugin fails, the use count is reset to
229  * its prior value.
230  *
231  * Returns: %FALSE if the plugin needed to be loaded and
232  *  loading the plugin failed.
233  */
234 gboolean
235 g_type_module_use (GTypeModule *module)
236 {
237   g_return_val_if_fail (G_IS_TYPE_MODULE (module), FALSE);
238 
239   module-&gt;use_count++;
240   if (module-&gt;use_count == 1)
241     {
242       GSList *tmp_list;
243 
244       if (!G_TYPE_MODULE_GET_CLASS (module)-&gt;load (module))
<span class="line-modified">245   {</span>
<span class="line-modified">246     module-&gt;use_count--;</span>
<span class="line-modified">247     return FALSE;</span>
<span class="line-modified">248   }</span>
249 
250       tmp_list = module-&gt;type_infos;
251       while (tmp_list)
<span class="line-modified">252   {</span>
<span class="line-modified">253     ModuleTypeInfo *type_info = tmp_list-&gt;data;</span>
<span class="line-modified">254     if (!type_info-&gt;loaded)</span>
<span class="line-modified">255       {</span>
<span class="line-modified">256         g_warning (&quot;plugin &#39;%s&#39; failed to register type &#39;%s&#39;&quot;,</span>
<span class="line-modified">257        module-&gt;name ? module-&gt;name : &quot;(unknown)&quot;,</span>
<span class="line-modified">258        g_type_name (type_info-&gt;type));</span>
<span class="line-modified">259         module-&gt;use_count--;</span>
<span class="line-modified">260         return FALSE;</span>
<span class="line-modified">261       }</span>
262 
<span class="line-modified">263     tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">264   }</span>
265     }
266 
267   return TRUE;
268 }
269 
270 /**
271  * g_type_module_unuse:
272  * @module: a #GTypeModule
273  *
274  * Decreases the use count of a #GTypeModule by one. If the
275  * result is zero, the module will be unloaded. (However, the
276  * #GTypeModule will not be freed, and types associated with the
277  * #GTypeModule are not unregistered. Once a #GTypeModule is
278  * initialized, it must exist forever.)
279  */
280 void
281 g_type_module_unuse (GTypeModule *module)
282 {
283   g_return_if_fail (G_IS_TYPE_MODULE (module));
284   g_return_if_fail (module-&gt;use_count &gt; 0);
285 
286   module-&gt;use_count--;
287 
288   if (module-&gt;use_count == 0)
289     {
290       GSList *tmp_list;
291 
292       G_TYPE_MODULE_GET_CLASS (module)-&gt;unload (module);
293 
294       tmp_list = module-&gt;type_infos;
295       while (tmp_list)
<span class="line-modified">296   {</span>
<span class="line-modified">297     ModuleTypeInfo *type_info = tmp_list-&gt;data;</span>
<span class="line-modified">298     type_info-&gt;loaded = FALSE;</span>
299 
<span class="line-modified">300     tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">301   }</span>
302     }
303 }
304 
305 static void
306 g_type_module_use_plugin (GTypePlugin *plugin)
307 {
308   GTypeModule *module = G_TYPE_MODULE (plugin);
309 
310   if (!g_type_module_use (module))
311     {
312       g_warning (&quot;Fatal error - Could not reload previously loaded plugin &#39;%s&#39;&quot;,
<span class="line-modified">313      module-&gt;name ? module-&gt;name : &quot;(unknown)&quot;);</span>
314       exit (1);
315     }
316 }
317 
318 static void
319 g_type_module_complete_type_info (GTypePlugin     *plugin,
<span class="line-modified">320           GType            g_type,</span>
<span class="line-modified">321           GTypeInfo       *info,</span>
<span class="line-modified">322           GTypeValueTable *value_table)</span>
323 {
324   GTypeModule *module = G_TYPE_MODULE (plugin);
325   ModuleTypeInfo *module_type_info = g_type_module_find_type_info (module, g_type);
326 #ifdef GSTREAMER_LITE
327   if (module_type_info == NULL)
328   {
329     g_warning (&quot;Cannot find module type info.&quot;);
330     return;
331   }
332 #endif // GSTREAMER_LITE
333 
334   *info = module_type_info-&gt;info;
335 
336   if (module_type_info-&gt;info.value_table)
337     *value_table = *module_type_info-&gt;info.value_table;
338 }
339 
340 static void
341 g_type_module_complete_interface_info (GTypePlugin    *plugin,
<span class="line-modified">342                GType           instance_type,</span>
<span class="line-modified">343                GType           interface_type,</span>
<span class="line-modified">344                GInterfaceInfo *info)</span>
345 {
346   GTypeModule *module = G_TYPE_MODULE (plugin);
347   ModuleInterfaceInfo *module_interface_info = g_type_module_find_interface_info (module, instance_type, interface_type);
348 
349   *info = module_interface_info-&gt;info;
350 }
351 
352 /**
353  * g_type_module_register_type:
354  * @module: (nullable): a #GTypeModule
355  * @parent_type: the type for the parent class
356  * @type_name: name for the type
357  * @type_info: type information structure
358  * @flags: flags field providing details about the type
359  *
360  * Looks up or registers a type that is implemented with a particular
361  * type plugin. If a type with name @type_name was previously registered,
362  * the #GType identifier for the type is returned, otherwise the type
363  * is newly registered, and the resulting #GType identifier returned.
364  *
365  * When reregistering a type (typically because a module is unloaded
366  * then reloaded, and reinitialized), @module and @parent_type must
367  * be the same as they were previously.
368  *
369  * As long as any instances of the type exist, the type plugin will
370  * not be unloaded.
371  *
372  * Since 2.56 if @module is %NULL this will call g_type_register_static()
373  * instead. This can be used when making a static build of the module.
374  *
375  * Returns: the new or existing type ID
376  */
377 GType
378 g_type_module_register_type (GTypeModule     *module,
<span class="line-modified">379            GType            parent_type,</span>
<span class="line-modified">380            const gchar     *type_name,</span>
<span class="line-modified">381            const GTypeInfo *type_info,</span>
<span class="line-modified">382            GTypeFlags       flags)</span>
383 {
384   ModuleTypeInfo *module_type_info = NULL;
385   GType type;
386 
387   g_return_val_if_fail (type_name != NULL, 0);
388   g_return_val_if_fail (type_info != NULL, 0);
389 
390   if (module == NULL)
391     {
392       /* Cannot pass type_info directly to g_type_register_static() here because
393        * it has class_finalize != NULL and that&#39;s forbidden for static types */
394       return g_type_register_static_simple (parent_type,
395                                             type_name,
396                                             type_info-&gt;class_size,
397                                             type_info-&gt;class_init,
398                                             type_info-&gt;instance_size,
399                                             type_info-&gt;instance_init,
400                                             flags);
401     }
402 
403   type = g_type_from_name (type_name);
404   if (type)
405     {
406       GTypePlugin *old_plugin = g_type_get_plugin (type);
407 
408       if (old_plugin != G_TYPE_PLUGIN (module))
<span class="line-modified">409   {</span>
<span class="line-modified">410     g_warning (&quot;Two different plugins tried to register &#39;%s&#39;.&quot;, type_name);</span>
<span class="line-modified">411     return 0;</span>
<span class="line-modified">412   }</span>
413     }
414 
415   if (type)
416     {
417       module_type_info = g_type_module_find_type_info (module, type);
418 #ifdef GSTREAMER_LITE
419       if (module_type_info == NULL)
420       {
421         g_warning (&quot;Cannot find module type info.&quot;);
422         return 0;
423       }
424 #endif // GSTREAMER_LITE
425 
426       if (module_type_info-&gt;parent_type != parent_type)
<span class="line-modified">427   {</span>
<span class="line-modified">428     const gchar *parent_type_name = g_type_name (parent_type);</span>
429 
<span class="line-modified">430     g_warning (&quot;Type &#39;%s&#39; recreated with different parent type.&quot;</span>
<span class="line-modified">431          &quot;(was &#39;%s&#39;, now &#39;%s&#39;)&quot;, type_name,</span>
<span class="line-modified">432          g_type_name (module_type_info-&gt;parent_type),</span>
<span class="line-modified">433          parent_type_name ? parent_type_name : &quot;(unknown)&quot;);</span>
<span class="line-modified">434     return 0;</span>
<span class="line-modified">435   }</span>
436 
437       if (module_type_info-&gt;info.value_table)
<span class="line-modified">438   g_free ((GTypeValueTable *) module_type_info-&gt;info.value_table);</span>
439     }
440   else
441     {
442       module_type_info = g_new (ModuleTypeInfo, 1);
443 
444       module_type_info-&gt;parent_type = parent_type;
445       module_type_info-&gt;type = g_type_register_dynamic (parent_type, type_name, G_TYPE_PLUGIN (module), flags);
446 
447       module-&gt;type_infos = g_slist_prepend (module-&gt;type_infos, module_type_info);
448     }
449 
450   module_type_info-&gt;loaded = TRUE;
451   module_type_info-&gt;info = *type_info;
452   if (type_info-&gt;value_table)
453     module_type_info-&gt;info.value_table = g_memdup (type_info-&gt;value_table,
<span class="line-modified">454                sizeof (GTypeValueTable));</span>
455 
456   return module_type_info-&gt;type;
457 }
458 
459 /**
460  * g_type_module_add_interface:
461  * @module: (nullable): a #GTypeModule
462  * @instance_type: type to which to add the interface.
463  * @interface_type: interface type to add
464  * @interface_info: type information structure
465  *
466  * Registers an additional interface for a type, whose interface lives
467  * in the given type plugin. If the interface was already registered
468  * for the type in this plugin, nothing will be done.
469  *
470  * As long as any instances of the type exist, the type plugin will
471  * not be unloaded.
472  *
473  * Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
474  * instead. This can be used when making a static build of the module.
475  */
476 void
477 g_type_module_add_interface (GTypeModule          *module,
<span class="line-modified">478            GType                 instance_type,</span>
<span class="line-modified">479            GType                 interface_type,</span>
<span class="line-modified">480            const GInterfaceInfo *interface_info)</span>
481 {
482   ModuleInterfaceInfo *module_interface_info = NULL;
483 
484   g_return_if_fail (interface_info != NULL);
485 
486   if (module == NULL)
487     {
488       g_type_add_interface_static (instance_type, interface_type, interface_info);
489       return;
490     }
491 
492   if (g_type_is_a (instance_type, interface_type))
493     {
494       GTypePlugin *old_plugin = g_type_interface_get_plugin (instance_type,
<span class="line-modified">495                    interface_type);</span>
496 
497       if (!old_plugin)
<span class="line-modified">498   {</span>
<span class="line-modified">499     g_warning (&quot;Interface &#39;%s&#39; for &#39;%s&#39; was previously registered statically or for a parent type.&quot;,</span>
<span class="line-modified">500          g_type_name (interface_type), g_type_name (instance_type));</span>
<span class="line-modified">501     return;</span>
<span class="line-modified">502   }</span>
503       else if (old_plugin != G_TYPE_PLUGIN (module))
<span class="line-modified">504   {</span>
<span class="line-modified">505     g_warning (&quot;Two different plugins tried to register interface &#39;%s&#39; for &#39;%s&#39;.&quot;,</span>
<span class="line-modified">506          g_type_name (interface_type), g_type_name (instance_type));</span>
<span class="line-modified">507     return;</span>
<span class="line-modified">508   }</span>
509 
510       module_interface_info = g_type_module_find_interface_info (module, instance_type, interface_type);
511 
512       g_assert (module_interface_info);
513     }
514   else
515     {
516       module_interface_info = g_new (ModuleInterfaceInfo, 1);
517 
518       module_interface_info-&gt;instance_type = instance_type;
519       module_interface_info-&gt;interface_type = interface_type;
520 
521       g_type_add_interface_dynamic (instance_type, interface_type, G_TYPE_PLUGIN (module));
522 
523       module-&gt;interface_infos = g_slist_prepend (module-&gt;interface_infos, module_interface_info);
524     }
525 
526   module_interface_info-&gt;loaded = TRUE;
527   module_interface_info-&gt;info = *interface_info;
528 }
</pre>
</td>
</tr>
</table>
<center><a href="gtype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtypemodule.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>