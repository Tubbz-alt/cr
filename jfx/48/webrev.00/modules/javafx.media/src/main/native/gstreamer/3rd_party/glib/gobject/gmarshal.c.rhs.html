<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /* GObject - GLib Type, Object, Parameter and Signal Library</span>























































































































































































































































































































































































































































































































































































































































































































































































   2  *
<a name="2" id="anc2"></a><span class="line-modified">   3  * This library is free software; you can redistribute it and/or</span>
<span class="line-modified">   4  * modify it under the terms of the GNU Lesser General Public</span>
<span class="line-modified">   5  * License as published by the Free Software Foundation; either</span>
<span class="line-modified">   6  * version 2.1 of the License, or (at your option) any later version.</span>












   7  *
<a name="3" id="anc3"></a><span class="line-modified">   8  * This library is distributed in the hope that it will be useful,</span>
<span class="line-modified">   9  * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="line-modified">  10  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="line-modified">  11  * Lesser General Public License for more details.</span>












  12  *
<a name="4" id="anc4"></a><span class="line-modified">  13  * You should have received a copy of the GNU Lesser General</span>
<span class="line-added">  14  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15  */
  16 
<a name="5" id="anc5"></a><span class="line-added">  17 #include &quot;config.h&quot;</span>
<span class="line-added">  18 </span>
<span class="line-added">  19 #include &quot;gobject.h&quot;</span>
<span class="line-added">  20 #include &quot;genums.h&quot;</span>
<span class="line-added">  21 #include &quot;gboxed.h&quot;</span>
<span class="line-added">  22 #include &quot;gvaluetypes.h&quot;</span>
<span class="line-added">  23 </span>
<span class="line-added">  24 </span>
  25 #ifdef G_ENABLE_DEBUG
  26 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
  27 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
  28 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
  29 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
  30 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
  31 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
  32 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
  33 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
  34 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
  35 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
  36 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
  37 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
  38 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
  39 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
  40 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
  41 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
  42 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
  43 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
  44 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
  45 #else /* !G_ENABLE_DEBUG */
  46 /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
  47  *          Do not access GValues directly in your code. Instead, use the
  48  *          g_value_get_*() functions
  49  */
  50 #define g_marshal_value_peek_boolean(v)  (v)-&gt;data[0].v_int
  51 #define g_marshal_value_peek_char(v)     (v)-&gt;data[0].v_int
  52 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
  53 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
  54 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
  55 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
  56 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
  57 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
  58 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
  59 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
  60 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
  61 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
  62 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
  63 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
  64 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
  65 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
  66 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
  67 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
  68 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
  69 #endif /* !G_ENABLE_DEBUG */
  70 
  71 
<a name="6" id="anc6"></a><span class="line-modified">  72 /**</span>
<span class="line-added">  73  * g_cclosure_marshal_VOID__VOID:</span>
<span class="line-added">  74  * @closure: A #GClosure.</span>
<span class="line-added">  75  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">  76  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">  77  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">  78  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">  79  *   on which to invoke the callback of closure.</span>
<span class="line-added">  80  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">  81  *   g_closure_invoke().</span>
<span class="line-added">  82  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">  83  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">  84  *   g_closure_set_meta_marshal()</span>
<span class="line-added">  85  *</span>
<span class="line-added">  86  * A #GClosureMarshal function for use with signals with no arguments.</span>
<span class="line-added">  87  */</span>
<span class="line-added">  88 /* VOID:VOID */</span>
  89 void
  90 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
  91                                GValue       *return_value G_GNUC_UNUSED,
  92                                guint         n_param_values,
  93                                const GValue *param_values,
  94                                gpointer      invocation_hint G_GNUC_UNUSED,
  95                                gpointer      marshal_data)
  96 {
  97   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
  98                                            gpointer     data2);
  99   GMarshalFunc_VOID__VOID callback;
 100   GCClosure *cc = (GCClosure*) closure;
 101   gpointer data1, data2;
 102 
 103   g_return_if_fail (n_param_values == 1);
 104 
 105   if (G_CCLOSURE_SWAP_DATA (closure))
 106     {
 107       data1 = closure-&gt;data;
 108       data2 = g_value_peek_pointer (param_values + 0);
 109     }
 110   else
 111     {
 112       data1 = g_value_peek_pointer (param_values + 0);
 113       data2 = closure-&gt;data;
 114     }
 115   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 116 
 117   callback (data1,
 118             data2);
 119 }
<a name="7" id="anc7"></a><span class="line-added"> 120 </span>
<span class="line-added"> 121 /**</span>
<span class="line-added"> 122  * g_cclosure_marshal_VOID__VOIDv:</span>
<span class="line-added"> 123  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 124  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 125  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 126  *  value.</span>
<span class="line-added"> 127  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 128  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 129  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 130  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 131  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 132  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 133  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 134  *  @args.</span>
<span class="line-added"> 135  *</span>
<span class="line-added"> 136  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().</span>
<span class="line-added"> 137  */</span>
 138 void
 139 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 140                                 GValue       *return_value,
 141                                 gpointer      instance,
 142                                 va_list       args,
 143                                 gpointer      marshal_data,
 144                                 int           n_params,
 145                                 GType        *param_types)
 146 {
 147   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 148                                            gpointer     data);
 149   GCClosure *cc = (GCClosure*) closure;
 150   gpointer data1, data2;
 151   GMarshalFunc_VOID__VOID callback;
 152 
 153   if (G_CCLOSURE_SWAP_DATA (closure))
 154     {
 155       data1 = closure-&gt;data;
 156       data2 = instance;
 157     }
 158   else
 159     {
 160       data1 = instance;
 161       data2 = closure-&gt;data;
 162     }
 163   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 164 
 165   callback (data1,
 166             data2);
 167 }
 168 
<a name="8" id="anc8"></a><span class="line-modified"> 169 /**</span>
<span class="line-modified"> 170  * g_cclosure_marshal_VOID__BOOLEAN:</span>
<span class="line-added"> 171  * @closure: A #GClosure.</span>
<span class="line-added"> 172  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 173  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 174  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 175  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 176  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 177  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 178  *   g_closure_invoke().</span>
<span class="line-added"> 179  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 180  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 181  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 182  *</span>
<span class="line-added"> 183  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 184  * boolean argument.</span>
<span class="line-added"> 185  */</span>
<span class="line-added"> 186 /* VOID:BOOLEAN */</span>
 187 void
 188 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 189                                   GValue       *return_value G_GNUC_UNUSED,
 190                                   guint         n_param_values,
 191                                   const GValue *param_values,
 192                                   gpointer      invocation_hint G_GNUC_UNUSED,
 193                                   gpointer      marshal_data)
 194 {
 195   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 196                                               gboolean     arg_1,
 197                                               gpointer     data2);
 198   GMarshalFunc_VOID__BOOLEAN callback;
 199   GCClosure *cc = (GCClosure*) closure;
 200   gpointer data1, data2;
 201 
 202   g_return_if_fail (n_param_values == 2);
 203 
 204   if (G_CCLOSURE_SWAP_DATA (closure))
 205     {
 206       data1 = closure-&gt;data;
 207       data2 = g_value_peek_pointer (param_values + 0);
 208     }
 209   else
 210     {
 211       data1 = g_value_peek_pointer (param_values + 0);
 212       data2 = closure-&gt;data;
 213     }
 214   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 215 
 216   callback (data1,
 217             g_marshal_value_peek_boolean (param_values + 1),
 218             data2);
 219 }
<a name="9" id="anc9"></a><span class="line-added"> 220 </span>
<span class="line-added"> 221 /**</span>
<span class="line-added"> 222  * g_cclosure_marshal_VOID__BOOLEANv:</span>
<span class="line-added"> 223  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 224  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 225  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 226  *  value.</span>
<span class="line-added"> 227  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 228  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 229  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 230  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 231  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 232  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 233  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 234  *  @args.</span>
<span class="line-added"> 235  *</span>
<span class="line-added"> 236  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().</span>
<span class="line-added"> 237  */</span>
 238 void
 239 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 240                                    GValue       *return_value,
 241                                    gpointer      instance,
 242                                    va_list       args,
 243                                    gpointer      marshal_data,
 244                                    int           n_params,
 245                                    GType        *param_types)
 246 {
 247   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 248                                               gboolean     arg_0,
 249                                               gpointer     data);
 250   GCClosure *cc = (GCClosure*) closure;
 251   gpointer data1, data2;
 252   GMarshalFunc_VOID__BOOLEAN callback;
 253   gboolean arg0;
 254   va_list args_copy;
 255 
 256   G_VA_COPY (args_copy, args);
 257   arg0 = (gboolean) va_arg (args_copy, gboolean);
 258   va_end (args_copy);
 259 
 260   if (G_CCLOSURE_SWAP_DATA (closure))
 261     {
 262       data1 = closure-&gt;data;
 263       data2 = instance;
 264     }
 265   else
 266     {
 267       data1 = instance;
 268       data2 = closure-&gt;data;
 269     }
 270   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 271 
 272   callback (data1,
 273             arg0,
 274             data2);
 275 }
 276 
<a name="10" id="anc10"></a><span class="line-modified"> 277 /**</span>
<span class="line-modified"> 278  * g_cclosure_marshal_VOID__CHAR:</span>
<span class="line-added"> 279  * @closure: A #GClosure.</span>
<span class="line-added"> 280  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 281  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 282  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 283  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 284  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 285  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 286  *   g_closure_invoke().</span>
<span class="line-added"> 287  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 288  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 289  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 290  *</span>
<span class="line-added"> 291  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 292  * character argument.</span>
<span class="line-added"> 293  */</span>
<span class="line-added"> 294 /* VOID:CHAR */</span>
 295 void
 296 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 297                                GValue       *return_value G_GNUC_UNUSED,
 298                                guint         n_param_values,
 299                                const GValue *param_values,
 300                                gpointer      invocation_hint G_GNUC_UNUSED,
 301                                gpointer      marshal_data)
 302 {
 303   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 304                                            gchar        arg_1,
 305                                            gpointer     data2);
 306   GMarshalFunc_VOID__CHAR callback;
 307   GCClosure *cc = (GCClosure*) closure;
 308   gpointer data1, data2;
 309 
 310   g_return_if_fail (n_param_values == 2);
 311 
 312   if (G_CCLOSURE_SWAP_DATA (closure))
 313     {
 314       data1 = closure-&gt;data;
 315       data2 = g_value_peek_pointer (param_values + 0);
 316     }
 317   else
 318     {
 319       data1 = g_value_peek_pointer (param_values + 0);
 320       data2 = closure-&gt;data;
 321     }
 322   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 323 
 324   callback (data1,
 325             g_marshal_value_peek_char (param_values + 1),
 326             data2);
 327 }
<a name="11" id="anc11"></a><span class="line-added"> 328 </span>
<span class="line-added"> 329 /**</span>
<span class="line-added"> 330  * g_cclosure_marshal_VOID__CHARv:</span>
<span class="line-added"> 331  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 332  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 333  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 334  *  value.</span>
<span class="line-added"> 335  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 336  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 337  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 338  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 339  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 340  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 341  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 342  *  @args.</span>
<span class="line-added"> 343  *</span>
<span class="line-added"> 344  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().</span>
<span class="line-added"> 345  */</span>
 346 void
 347 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
 348                                 GValue       *return_value,
 349                                 gpointer      instance,
 350                                 va_list       args,
 351                                 gpointer      marshal_data,
 352                                 int           n_params,
 353                                 GType        *param_types)
 354 {
 355   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
 356                                            gchar        arg_0,
 357                                            gpointer     data);
 358   GCClosure *cc = (GCClosure*) closure;
 359   gpointer data1, data2;
 360   GMarshalFunc_VOID__CHAR callback;
 361   gchar arg0;
 362   va_list args_copy;
 363 
 364   G_VA_COPY (args_copy, args);
 365   arg0 = (gchar) va_arg (args_copy, gint);
 366   va_end (args_copy);
 367 
 368   if (G_CCLOSURE_SWAP_DATA (closure))
 369     {
 370       data1 = closure-&gt;data;
 371       data2 = instance;
 372     }
 373   else
 374     {
 375       data1 = instance;
 376       data2 = closure-&gt;data;
 377     }
 378   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 379 
 380   callback (data1,
 381             arg0,
 382             data2);
 383 }
 384 
<a name="12" id="anc12"></a><span class="line-modified"> 385 /**</span>
<span class="line-modified"> 386  * g_cclosure_marshal_VOID__UCHAR:</span>
<span class="line-added"> 387  * @closure: A #GClosure.</span>
<span class="line-added"> 388  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 389  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 390  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 391  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 392  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 393  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 394  *   g_closure_invoke().</span>
<span class="line-added"> 395  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 396  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 397  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 398  *</span>
<span class="line-added"> 399  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 400  * unsigned character argument.</span>
<span class="line-added"> 401  */</span>
<span class="line-added"> 402 /* VOID:UCHAR */</span>
 403 void
 404 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
 405                                 GValue       *return_value G_GNUC_UNUSED,
 406                                 guint         n_param_values,
 407                                 const GValue *param_values,
 408                                 gpointer      invocation_hint G_GNUC_UNUSED,
 409                                 gpointer      marshal_data)
 410 {
 411   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
 412                                             guchar       arg_1,
 413                                             gpointer     data2);
 414   GMarshalFunc_VOID__UCHAR callback;
 415   GCClosure *cc = (GCClosure*) closure;
 416   gpointer data1, data2;
 417 
 418   g_return_if_fail (n_param_values == 2);
 419 
 420   if (G_CCLOSURE_SWAP_DATA (closure))
 421     {
 422       data1 = closure-&gt;data;
 423       data2 = g_value_peek_pointer (param_values + 0);
 424     }
 425   else
 426     {
 427       data1 = g_value_peek_pointer (param_values + 0);
 428       data2 = closure-&gt;data;
 429     }
 430   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 431 
 432   callback (data1,
 433             g_marshal_value_peek_uchar (param_values + 1),
 434             data2);
 435 }
<a name="13" id="anc13"></a><span class="line-added"> 436 </span>
<span class="line-added"> 437 /**</span>
<span class="line-added"> 438  * g_cclosure_marshal_VOID__UCHARv:</span>
<span class="line-added"> 439  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 440  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 441  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 442  *  value.</span>
<span class="line-added"> 443  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 444  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 445  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 446  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 447  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 448  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 449  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 450  *  @args.</span>
<span class="line-added"> 451  *</span>
<span class="line-added"> 452  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().</span>
<span class="line-added"> 453  */</span>
 454 void
 455 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
 456                                  GValue       *return_value,
 457                                  gpointer      instance,
 458                                  va_list       args,
 459                                  gpointer      marshal_data,
 460                                  int           n_params,
 461                                  GType        *param_types)
 462 {
 463   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
 464                                             guchar       arg_0,
 465                                             gpointer     data);
 466   GCClosure *cc = (GCClosure*) closure;
 467   gpointer data1, data2;
 468   GMarshalFunc_VOID__UCHAR callback;
 469   guchar arg0;
 470   va_list args_copy;
 471 
 472   G_VA_COPY (args_copy, args);
 473   arg0 = (guchar) va_arg (args_copy, guint);
 474   va_end (args_copy);
 475 
 476   if (G_CCLOSURE_SWAP_DATA (closure))
 477     {
 478       data1 = closure-&gt;data;
 479       data2 = instance;
 480     }
 481   else
 482     {
 483       data1 = instance;
 484       data2 = closure-&gt;data;
 485     }
 486   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 487 
 488   callback (data1,
 489             arg0,
 490             data2);
 491 }
 492 
<a name="14" id="anc14"></a><span class="line-modified"> 493 /**</span>
<span class="line-modified"> 494  * g_cclosure_marshal_VOID__INT:</span>
<span class="line-added"> 495  * @closure: A #GClosure.</span>
<span class="line-added"> 496  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 497  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 498  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 499  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 500  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 501  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 502  *   g_closure_invoke().</span>
<span class="line-added"> 503  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 504  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 505  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 506  *</span>
<span class="line-added"> 507  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 508  * integer argument.</span>
<span class="line-added"> 509  */</span>
<span class="line-added"> 510 /* VOID:INT */</span>
 511 void
 512 g_cclosure_marshal_VOID__INT (GClosure     *closure,
 513                               GValue       *return_value G_GNUC_UNUSED,
 514                               guint         n_param_values,
 515                               const GValue *param_values,
 516                               gpointer      invocation_hint G_GNUC_UNUSED,
 517                               gpointer      marshal_data)
 518 {
 519   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
 520                                           gint         arg_1,
 521                                           gpointer     data2);
 522   GMarshalFunc_VOID__INT callback;
 523   GCClosure *cc = (GCClosure*) closure;
 524   gpointer data1, data2;
 525 
 526   g_return_if_fail (n_param_values == 2);
 527 
 528   if (G_CCLOSURE_SWAP_DATA (closure))
 529     {
 530       data1 = closure-&gt;data;
 531       data2 = g_value_peek_pointer (param_values + 0);
 532     }
 533   else
 534     {
 535       data1 = g_value_peek_pointer (param_values + 0);
 536       data2 = closure-&gt;data;
 537     }
 538   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 539 
 540   callback (data1,
 541             g_marshal_value_peek_int (param_values + 1),
 542             data2);
 543 }
<a name="15" id="anc15"></a><span class="line-added"> 544 </span>
<span class="line-added"> 545 /**</span>
<span class="line-added"> 546  * g_cclosure_marshal_VOID__INTv:</span>
<span class="line-added"> 547  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 548  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 549  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 550  *  value.</span>
<span class="line-added"> 551  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 552  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 553  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 554  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 555  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 556  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 557  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 558  *  @args.</span>
<span class="line-added"> 559  *</span>
<span class="line-added"> 560  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().</span>
<span class="line-added"> 561  */</span>
 562 void
 563 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
 564                                GValue       *return_value,
 565                                gpointer      instance,
 566                                va_list       args,
 567                                gpointer      marshal_data,
 568                                int           n_params,
 569                                GType        *param_types)
 570 {
 571   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
 572                                           gint         arg_0,
 573                                           gpointer     data);
 574   GCClosure *cc = (GCClosure*) closure;
 575   gpointer data1, data2;
 576   GMarshalFunc_VOID__INT callback;
 577   gint arg0;
 578   va_list args_copy;
 579 
 580  G_VA_COPY (args_copy, args);
 581   arg0 = (gint) va_arg (args_copy, gint);
 582   va_end (args_copy);
 583 
 584   if (G_CCLOSURE_SWAP_DATA (closure))
 585     {
 586       data1 = closure-&gt;data;
 587       data2 = instance;
 588     }
 589   else
 590     {
 591       data1 = instance;
 592       data2 = closure-&gt;data;
 593     }
 594   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 595 
 596   callback (data1,
 597             arg0,
 598             data2);
 599 }
 600 
<a name="16" id="anc16"></a><span class="line-modified"> 601 /**</span>
<span class="line-modified"> 602  * g_cclosure_marshal_VOID__UINT:</span>
<span class="line-added"> 603  * @closure: A #GClosure.</span>
<span class="line-added"> 604  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 605  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 606  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 607  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 608  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 609  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 610  *   g_closure_invoke().</span>
<span class="line-added"> 611  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 612  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 613  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 614  *</span>
<span class="line-added"> 615  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-added"> 616  * unsigned integer argument.</span>
<span class="line-added"> 617  */</span>
<span class="line-added"> 618 /* VOID:UINT */</span>
 619 void
 620 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
 621                                GValue       *return_value G_GNUC_UNUSED,
 622                                guint         n_param_values,
 623                                const GValue *param_values,
 624                                gpointer      invocation_hint G_GNUC_UNUSED,
 625                                gpointer      marshal_data)
 626 {
 627   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
 628                                            guint        arg_1,
 629                                            gpointer     data2);
 630   GMarshalFunc_VOID__UINT callback;
 631   GCClosure *cc = (GCClosure*) closure;
 632   gpointer data1, data2;
 633 
 634   g_return_if_fail (n_param_values == 2);
 635 
 636   if (G_CCLOSURE_SWAP_DATA (closure))
 637     {
 638       data1 = closure-&gt;data;
 639       data2 = g_value_peek_pointer (param_values + 0);
 640     }
 641   else
 642     {
 643       data1 = g_value_peek_pointer (param_values + 0);
 644       data2 = closure-&gt;data;
 645     }
 646   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 647 
 648   callback (data1,
 649             g_marshal_value_peek_uint (param_values + 1),
 650             data2);
 651 }
<a name="17" id="anc17"></a><span class="line-added"> 652 </span>
<span class="line-added"> 653 /**</span>
<span class="line-added"> 654  * g_cclosure_marshal_VOID__UINTv:</span>
<span class="line-added"> 655  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 656  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 657  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 658  *  value.</span>
<span class="line-added"> 659  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 660  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 661  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 662  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 663  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 664  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 665  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 666  *  @args.</span>
<span class="line-added"> 667  *</span>
<span class="line-added"> 668  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().</span>
<span class="line-added"> 669  */</span>
 670 void
 671 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
 672                                 GValue       *return_value,
 673                                 gpointer      instance,
 674                                 va_list       args,
 675                                 gpointer      marshal_data,
 676                                 int           n_params,
 677                                 GType        *param_types)
 678 {
 679   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
 680                                            guint        arg_0,
 681                                            gpointer     data);
 682   GCClosure *cc = (GCClosure*) closure;
 683   gpointer data1, data2;
 684   GMarshalFunc_VOID__UINT callback;
 685   guint arg0;
 686   va_list args_copy;
 687 
 688   G_VA_COPY (args_copy, args);
 689   arg0 = (guint) va_arg (args_copy, guint);
 690   va_end (args_copy);
 691 
 692   if (G_CCLOSURE_SWAP_DATA (closure))
 693     {
 694       data1 = closure-&gt;data;
 695       data2 = instance;
 696     }
 697   else
 698     {
 699       data1 = instance;
 700       data2 = closure-&gt;data;
 701     }
 702   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 703 
 704   callback (data1,
 705             arg0,
 706             data2);
 707 }
 708 
<a name="18" id="anc18"></a><span class="line-modified"> 709 /**</span>
<span class="line-modified"> 710  * g_cclosure_marshal_VOID__LONG:</span>
<span class="line-added"> 711  * @closure: A #GClosure.</span>
<span class="line-added"> 712  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 713  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 714  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 715  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 716  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 717  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 718  *   g_closure_invoke().</span>
<span class="line-added"> 719  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 720  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 721  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 722  *</span>
<span class="line-added"> 723  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-added"> 724  * long integer argument.</span>
<span class="line-added"> 725  */</span>
<span class="line-added"> 726 /* VOID:LONG */</span>
 727 void
 728 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
 729                                GValue       *return_value G_GNUC_UNUSED,
 730                                guint         n_param_values,
 731                                const GValue *param_values,
 732                                gpointer      invocation_hint G_GNUC_UNUSED,
 733                                gpointer      marshal_data)
 734 {
 735   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
 736                                            glong        arg_1,
 737                                            gpointer     data2);
 738   GMarshalFunc_VOID__LONG callback;
 739   GCClosure *cc = (GCClosure*) closure;
 740   gpointer data1, data2;
 741 
 742   g_return_if_fail (n_param_values == 2);
 743 
 744   if (G_CCLOSURE_SWAP_DATA (closure))
 745     {
 746       data1 = closure-&gt;data;
 747       data2 = g_value_peek_pointer (param_values + 0);
 748     }
 749   else
 750     {
 751       data1 = g_value_peek_pointer (param_values + 0);
 752       data2 = closure-&gt;data;
 753     }
 754   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 755 
 756   callback (data1,
 757             g_marshal_value_peek_long (param_values + 1),
 758             data2);
 759 }
<a name="19" id="anc19"></a><span class="line-added"> 760 </span>
<span class="line-added"> 761 /**</span>
<span class="line-added"> 762  * g_cclosure_marshal_VOID__LONGv:</span>
<span class="line-added"> 763  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 764  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 765  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 766  *  value.</span>
<span class="line-added"> 767  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 768  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 769  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 770  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 771  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 772  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 773  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 774  *  @args.</span>
<span class="line-added"> 775  *</span>
<span class="line-added"> 776  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().</span>
<span class="line-added"> 777  */</span>
 778 void
 779 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
 780                                 GValue       *return_value,
 781                                 gpointer      instance,
 782                                 va_list       args,
 783                                 gpointer      marshal_data,
 784                                 int           n_params,
 785                                 GType        *param_types)
 786 {
 787   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
 788                                            glong        arg_0,
 789                                            gpointer     data);
 790   GCClosure *cc = (GCClosure*) closure;
 791   gpointer data1, data2;
 792   GMarshalFunc_VOID__LONG callback;
 793   glong arg0;
 794   va_list args_copy;
 795 
 796   G_VA_COPY (args_copy, args);
 797   arg0 = (glong) va_arg (args_copy, glong);
 798   va_end (args_copy);
 799 
 800   if (G_CCLOSURE_SWAP_DATA (closure))
 801     {
 802       data1 = closure-&gt;data;
 803       data2 = instance;
 804     }
 805   else
 806     {
 807       data1 = instance;
 808       data2 = closure-&gt;data;
 809     }
 810   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 811 
 812   callback (data1,
 813             arg0,
 814             data2);
 815 }
 816 
<a name="20" id="anc20"></a><span class="line-modified"> 817 /**</span>
<span class="line-modified"> 818  * g_cclosure_marshal_VOID__ULONG:</span>
<span class="line-added"> 819  * @closure: A #GClosure.</span>
<span class="line-added"> 820  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 821  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 822  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 823  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 824  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 825  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 826  *   g_closure_invoke().</span>
<span class="line-added"> 827  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 828  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 829  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 830  *</span>
<span class="line-added"> 831  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 832  * unsigned long integer argument.</span>
<span class="line-added"> 833  */</span>
<span class="line-added"> 834 /* VOID:ULONG */</span>
 835 void
 836 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
 837                                 GValue       *return_value G_GNUC_UNUSED,
 838                                 guint         n_param_values,
 839                                 const GValue *param_values,
 840                                 gpointer      invocation_hint G_GNUC_UNUSED,
 841                                 gpointer      marshal_data)
 842 {
 843   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
 844                                             gulong       arg_1,
 845                                             gpointer     data2);
 846   GMarshalFunc_VOID__ULONG callback;
 847   GCClosure *cc = (GCClosure*) closure;
 848   gpointer data1, data2;
 849 
 850   g_return_if_fail (n_param_values == 2);
 851 
 852   if (G_CCLOSURE_SWAP_DATA (closure))
 853     {
 854       data1 = closure-&gt;data;
 855       data2 = g_value_peek_pointer (param_values + 0);
 856     }
 857   else
 858     {
 859       data1 = g_value_peek_pointer (param_values + 0);
 860       data2 = closure-&gt;data;
 861     }
 862   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 863 
 864   callback (data1,
 865             g_marshal_value_peek_ulong (param_values + 1),
 866             data2);
 867 }
<a name="21" id="anc21"></a><span class="line-added"> 868 </span>
<span class="line-added"> 869 /**</span>
<span class="line-added"> 870  * g_cclosure_marshal_VOID__ULONGv:</span>
<span class="line-added"> 871  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 872  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 873  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 874  *  value.</span>
<span class="line-added"> 875  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 876  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 877  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 878  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 879  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 880  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 881  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 882  *  @args.</span>
<span class="line-added"> 883  *</span>
<span class="line-added"> 884  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().</span>
<span class="line-added"> 885  */</span>
 886 void
 887 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
 888                                  GValue       *return_value,
 889                                  gpointer      instance,
 890                                  va_list       args,
 891                                  gpointer      marshal_data,
 892                                  int           n_params,
 893                                  GType        *param_types)
 894 {
 895   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
 896                                             gulong       arg_0,
 897                                             gpointer     data);
 898   GCClosure *cc = (GCClosure*) closure;
 899   gpointer data1, data2;
 900   GMarshalFunc_VOID__ULONG callback;
 901   gulong arg0;
 902   va_list args_copy;
 903 
 904   G_VA_COPY (args_copy, args);
 905   arg0 = (gulong) va_arg (args_copy, gulong);
 906   va_end (args_copy);
 907 
 908   if (G_CCLOSURE_SWAP_DATA (closure))
 909     {
 910       data1 = closure-&gt;data;
 911       data2 = instance;
 912     }
 913   else
 914     {
 915       data1 = instance;
 916       data2 = closure-&gt;data;
 917     }
 918   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 919 
 920   callback (data1,
 921             arg0,
 922             data2);
 923 }
 924 
<a name="22" id="anc22"></a><span class="line-modified"> 925 /**</span>
<span class="line-modified"> 926  * g_cclosure_marshal_VOID__ENUM:</span>
<span class="line-added"> 927  * @closure: A #GClosure.</span>
<span class="line-added"> 928  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 929  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 930  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 931  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 932  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 933  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 934  *   g_closure_invoke().</span>
<span class="line-added"> 935  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 936  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 937  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 938  *</span>
<span class="line-added"> 939  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 940  * argument with an enumerated type.</span>
<span class="line-added"> 941  */</span>
<span class="line-added"> 942 /* VOID:ENUM */</span>
 943 void
 944 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
 945                                GValue       *return_value G_GNUC_UNUSED,
 946                                guint         n_param_values,
 947                                const GValue *param_values,
 948                                gpointer      invocation_hint G_GNUC_UNUSED,
 949                                gpointer      marshal_data)
 950 {
 951   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
 952                                            gint         arg_1,
 953                                            gpointer     data2);
 954   GMarshalFunc_VOID__ENUM callback;
 955   GCClosure *cc = (GCClosure*) closure;
 956   gpointer data1, data2;
 957 
 958   g_return_if_fail (n_param_values == 2);
 959 
 960   if (G_CCLOSURE_SWAP_DATA (closure))
 961     {
 962       data1 = closure-&gt;data;
 963       data2 = g_value_peek_pointer (param_values + 0);
 964     }
 965   else
 966     {
 967       data1 = g_value_peek_pointer (param_values + 0);
 968       data2 = closure-&gt;data;
 969     }
 970   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
 971 
 972   callback (data1,
 973             g_marshal_value_peek_enum (param_values + 1),
 974             data2);
 975 }
<a name="23" id="anc23"></a><span class="line-added"> 976 </span>
<span class="line-added"> 977 /**</span>
<span class="line-added"> 978  * g_cclosure_marshal_VOID__ENUMv:</span>
<span class="line-added"> 979  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 980  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 981  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 982  *  value.</span>
<span class="line-added"> 983  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 984  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 985  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 986  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 987  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 988  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 989  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 990  *  @args.</span>
<span class="line-added"> 991  *</span>
<span class="line-added"> 992  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().</span>
<span class="line-added"> 993  */</span>
 994 void
 995 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
 996                                 GValue       *return_value,
 997                                 gpointer      instance,
 998                                 va_list       args,
 999                                 gpointer      marshal_data,
1000                                 int           n_params,
1001                                 GType        *param_types)
1002 {
1003   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1004                                            gint         arg_0,
1005                                            gpointer     data);
1006   GCClosure *cc = (GCClosure*) closure;
1007   gpointer data1, data2;
1008   GMarshalFunc_VOID__ENUM callback;
1009   gint arg0;
1010   va_list args_copy;
1011 
1012   G_VA_COPY (args_copy, args);
1013   arg0 = (gint) va_arg (args_copy, gint);
1014   va_end (args_copy);
1015 
1016   if (G_CCLOSURE_SWAP_DATA (closure))
1017     {
1018       data1 = closure-&gt;data;
1019       data2 = instance;
1020     }
1021   else
1022     {
1023       data1 = instance;
1024       data2 = closure-&gt;data;
1025     }
1026   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1027 
1028   callback (data1,
1029             arg0,
1030             data2);
1031 }
1032 
<a name="24" id="anc24"></a><span class="line-modified">1033 /**</span>
<span class="line-modified">1034  * g_cclosure_marshal_VOID__FLAGS:</span>
<span class="line-added">1035  * @closure: A #GClosure.</span>
<span class="line-added">1036  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1037  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1038  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1039  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1040  *   on which to invoke the callback of closure.</span>
<span class="line-added">1041  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1042  *   g_closure_invoke().</span>
<span class="line-added">1043  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1044  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1045  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1046  *</span>
<span class="line-added">1047  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1048  * argument with a flags types.</span>
<span class="line-added">1049  */</span>
<span class="line-added">1050 /* VOID:FLAGS */</span>
1051 void
1052 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1053                                 GValue       *return_value G_GNUC_UNUSED,
1054                                 guint         n_param_values,
1055                                 const GValue *param_values,
1056                                 gpointer      invocation_hint G_GNUC_UNUSED,
1057                                 gpointer      marshal_data)
1058 {
1059   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1060                                             guint        arg_1,
1061                                             gpointer     data2);
1062   GMarshalFunc_VOID__FLAGS callback;
1063   GCClosure *cc = (GCClosure*) closure;
1064   gpointer data1, data2;
1065 
1066   g_return_if_fail (n_param_values == 2);
1067 
1068   if (G_CCLOSURE_SWAP_DATA (closure))
1069     {
1070       data1 = closure-&gt;data;
1071       data2 = g_value_peek_pointer (param_values + 0);
1072     }
1073   else
1074     {
1075       data1 = g_value_peek_pointer (param_values + 0);
1076       data2 = closure-&gt;data;
1077     }
1078   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1079 
1080   callback (data1,
1081             g_marshal_value_peek_flags (param_values + 1),
1082             data2);
1083 }
<a name="25" id="anc25"></a><span class="line-added">1084 </span>
<span class="line-added">1085 /**</span>
<span class="line-added">1086  * g_cclosure_marshal_VOID__FLAGSv:</span>
<span class="line-added">1087  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1088  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1089  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1090  *  value.</span>
<span class="line-added">1091  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1092  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1093  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1094  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1095  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1096  * @n_params: the length of the @param_types array</span>
<span class="line-added">1097  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1098  *  @args.</span>
<span class="line-added">1099  *</span>
<span class="line-added">1100  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().</span>
<span class="line-added">1101  */</span>
1102 void
1103 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1104                                  GValue       *return_value,
1105                                  gpointer      instance,
1106                                  va_list       args,
1107                                  gpointer      marshal_data,
1108                                  int           n_params,
1109                                  GType        *param_types)
1110 {
1111   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1112                                             guint        arg_0,
1113                                             gpointer     data);
1114   GCClosure *cc = (GCClosure*) closure;
1115   gpointer data1, data2;
1116   GMarshalFunc_VOID__FLAGS callback;
1117   guint arg0;
1118   va_list args_copy;
1119 
1120   G_VA_COPY (args_copy, args);
1121   arg0 = (guint) va_arg (args_copy, guint);
1122   va_end (args_copy);
1123 
1124   if (G_CCLOSURE_SWAP_DATA (closure))
1125     {
1126       data1 = closure-&gt;data;
1127       data2 = instance;
1128     }
1129   else
1130     {
1131       data1 = instance;
1132       data2 = closure-&gt;data;
1133     }
1134   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1135 
1136   callback (data1,
1137             arg0,
1138             data2);
1139 }
1140 
<a name="26" id="anc26"></a><span class="line-modified">1141 /**</span>
<span class="line-modified">1142  * g_cclosure_marshal_VOID__FLOAT:</span>
<span class="line-added">1143  * @closure: A #GClosure.</span>
<span class="line-added">1144  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1145  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1146  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1147  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1148  *   on which to invoke the callback of closure.</span>
<span class="line-added">1149  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1150  *   g_closure_invoke().</span>
<span class="line-added">1151  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1152  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1153  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1154  *</span>
<span class="line-added">1155  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-added">1156  * single-precision floating point argument.</span>
<span class="line-added">1157  */</span>
<span class="line-added">1158 /* VOID:FLOAT */</span>
1159 void
1160 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1161                                 GValue       *return_value G_GNUC_UNUSED,
1162                                 guint         n_param_values,
1163                                 const GValue *param_values,
1164                                 gpointer      invocation_hint G_GNUC_UNUSED,
1165                                 gpointer      marshal_data)
1166 {
1167   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1168                                             gfloat       arg_1,
1169                                             gpointer     data2);
1170   GMarshalFunc_VOID__FLOAT callback;
1171   GCClosure *cc = (GCClosure*) closure;
1172   gpointer data1, data2;
1173 
1174   g_return_if_fail (n_param_values == 2);
1175 
1176   if (G_CCLOSURE_SWAP_DATA (closure))
1177     {
1178       data1 = closure-&gt;data;
1179       data2 = g_value_peek_pointer (param_values + 0);
1180     }
1181   else
1182     {
1183       data1 = g_value_peek_pointer (param_values + 0);
1184       data2 = closure-&gt;data;
1185     }
1186   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1187 
1188   callback (data1,
1189             g_marshal_value_peek_float (param_values + 1),
1190             data2);
1191 }
<a name="27" id="anc27"></a><span class="line-added">1192 </span>
<span class="line-added">1193 /**</span>
<span class="line-added">1194  * g_cclosure_marshal_VOID__FLOATv:</span>
<span class="line-added">1195  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1196  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1197  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1198  *  value.</span>
<span class="line-added">1199  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1200  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1201  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1202  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1203  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1204  * @n_params: the length of the @param_types array</span>
<span class="line-added">1205  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1206  *  @args.</span>
<span class="line-added">1207  *</span>
<span class="line-added">1208  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().</span>
<span class="line-added">1209  */</span>
1210 void
1211 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1212                                  GValue       *return_value,
1213                                  gpointer      instance,
1214                                  va_list       args,
1215                                  gpointer      marshal_data,
1216                                  int           n_params,
1217                                  GType        *param_types)
1218 {
1219   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1220                                             gfloat       arg_0,
1221                                             gpointer     data);
1222   GCClosure *cc = (GCClosure*) closure;
1223   gpointer data1, data2;
1224   GMarshalFunc_VOID__FLOAT callback;
1225   gfloat arg0;
1226   va_list args_copy;
1227 
1228   G_VA_COPY (args_copy, args);
1229   arg0 = (gfloat) va_arg (args_copy, gdouble);
1230   va_end (args_copy);
1231 
1232   if (G_CCLOSURE_SWAP_DATA (closure))
1233     {
1234       data1 = closure-&gt;data;
1235       data2 = instance;
1236     }
1237   else
1238     {
1239       data1 = instance;
1240       data2 = closure-&gt;data;
1241     }
1242   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1243 
1244   callback (data1,
1245             arg0,
1246             data2);
1247 }
1248 
<a name="28" id="anc28"></a><span class="line-modified">1249 /**</span>
<span class="line-modified">1250  * g_cclosure_marshal_VOID__DOUBLE:</span>
<span class="line-added">1251  * @closure: A #GClosure.</span>
<span class="line-added">1252  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1253  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1254  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1255  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1256  *   on which to invoke the callback of closure.</span>
<span class="line-added">1257  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1258  *   g_closure_invoke().</span>
<span class="line-added">1259  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1260  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1261  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1262  *</span>
<span class="line-added">1263  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-added">1264  * double-precision floating point argument.</span>
<span class="line-added">1265  */</span>
<span class="line-added">1266 /* VOID:DOUBLE */</span>
1267 void
1268 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1269                                  GValue       *return_value G_GNUC_UNUSED,
1270                                  guint         n_param_values,
1271                                  const GValue *param_values,
1272                                  gpointer      invocation_hint G_GNUC_UNUSED,
1273                                  gpointer      marshal_data)
1274 {
1275   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1276                                              gdouble      arg_1,
1277                                              gpointer     data2);
1278   GMarshalFunc_VOID__DOUBLE callback;
1279   GCClosure *cc = (GCClosure*) closure;
1280   gpointer data1, data2;
1281 
1282   g_return_if_fail (n_param_values == 2);
1283 
1284   if (G_CCLOSURE_SWAP_DATA (closure))
1285     {
1286       data1 = closure-&gt;data;
1287       data2 = g_value_peek_pointer (param_values + 0);
1288     }
1289   else
1290     {
1291       data1 = g_value_peek_pointer (param_values + 0);
1292       data2 = closure-&gt;data;
1293     }
1294   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1295 
1296   callback (data1,
1297             g_marshal_value_peek_double (param_values + 1),
1298             data2);
1299 }
<a name="29" id="anc29"></a><span class="line-added">1300 </span>
<span class="line-added">1301 /**</span>
<span class="line-added">1302  * g_cclosure_marshal_VOID__DOUBLEv:</span>
<span class="line-added">1303  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1304  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1305  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1306  *  value.</span>
<span class="line-added">1307  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1308  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1309  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1310  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1311  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1312  * @n_params: the length of the @param_types array</span>
<span class="line-added">1313  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1314  *  @args.</span>
<span class="line-added">1315  *</span>
<span class="line-added">1316  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().</span>
<span class="line-added">1317  */</span>
1318 void
1319 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1320                                   GValue       *return_value,
1321                                   gpointer      instance,
1322                                   va_list       args,
1323                                   gpointer      marshal_data,
1324                                   int           n_params,
1325                                   GType        *param_types)
1326 {
1327   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1328                                              gdouble      arg_0,
1329                                              gpointer     data);
1330   GCClosure *cc = (GCClosure*) closure;
1331   gpointer data1, data2;
1332   GMarshalFunc_VOID__DOUBLE callback;
1333   gdouble arg0;
1334   va_list args_copy;
1335 
1336   G_VA_COPY (args_copy, args);
1337   arg0 = (gdouble) va_arg (args_copy, gdouble);
1338   va_end (args_copy);
1339 
1340   if (G_CCLOSURE_SWAP_DATA (closure))
1341     {
1342       data1 = closure-&gt;data;
1343       data2 = instance;
1344     }
1345   else
1346     {
1347       data1 = instance;
1348       data2 = closure-&gt;data;
1349     }
1350   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1351 
1352   callback (data1,
1353             arg0,
1354             data2);
1355 }
1356 
<a name="30" id="anc30"></a><span class="line-modified">1357 /**</span>
<span class="line-modified">1358  * g_cclosure_marshal_VOID__STRING:</span>
<span class="line-added">1359  * @closure: A #GClosure.</span>
<span class="line-added">1360  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1361  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1362  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1363  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1364  *   on which to invoke the callback of closure.</span>
<span class="line-added">1365  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1366  *   g_closure_invoke().</span>
<span class="line-added">1367  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1368  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1369  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1370  *</span>
<span class="line-added">1371  * A #GClosureMarshal function for use with signals with a single string</span>
<span class="line-added">1372  * argument.</span>
<span class="line-added">1373  */</span>
<span class="line-added">1374 /* VOID:STRING */</span>
1375 void
1376 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1377                                  GValue       *return_value G_GNUC_UNUSED,
1378                                  guint         n_param_values,
1379                                  const GValue *param_values,
1380                                  gpointer      invocation_hint G_GNUC_UNUSED,
1381                                  gpointer      marshal_data)
1382 {
1383   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1384                                              gpointer     arg_1,
1385                                              gpointer     data2);
1386   GMarshalFunc_VOID__STRING callback;
1387   GCClosure *cc = (GCClosure*) closure;
1388   gpointer data1, data2;
1389 
1390   g_return_if_fail (n_param_values == 2);
1391 
1392   if (G_CCLOSURE_SWAP_DATA (closure))
1393     {
1394       data1 = closure-&gt;data;
1395       data2 = g_value_peek_pointer (param_values + 0);
1396     }
1397   else
1398     {
1399       data1 = g_value_peek_pointer (param_values + 0);
1400       data2 = closure-&gt;data;
1401     }
1402   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1403 
1404   callback (data1,
1405             g_marshal_value_peek_string (param_values + 1),
1406             data2);
1407 }
<a name="31" id="anc31"></a><span class="line-added">1408 </span>
<span class="line-added">1409 /**</span>
<span class="line-added">1410  * g_cclosure_marshal_VOID__STRINGv:</span>
<span class="line-added">1411  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1412  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1413  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1414  *  value.</span>
<span class="line-added">1415  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1416  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1417  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1418  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1419  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1420  * @n_params: the length of the @param_types array</span>
<span class="line-added">1421  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1422  *  @args.</span>
<span class="line-added">1423  *</span>
<span class="line-added">1424  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().</span>
<span class="line-added">1425  */</span>
1426 void
1427 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1428                                   GValue       *return_value,
1429                                   gpointer      instance,
1430                                   va_list       args,
1431                                   gpointer      marshal_data,
1432                                   int           n_params,
1433                                   GType        *param_types)
1434 {
1435   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1436                                              gpointer     arg_0,
1437                                              gpointer     data);
1438   GCClosure *cc = (GCClosure*) closure;
1439   gpointer data1, data2;
1440   GMarshalFunc_VOID__STRING callback;
1441   gpointer arg0;
1442   va_list args_copy;
1443 
1444   G_VA_COPY (args_copy, args);
1445   arg0 = (gpointer) va_arg (args_copy, gpointer);
1446   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1447     arg0 = g_strdup (arg0);
1448   va_end (args_copy);
1449 
1450   if (G_CCLOSURE_SWAP_DATA (closure))
1451     {
1452       data1 = closure-&gt;data;
1453       data2 = instance;
1454     }
1455   else
1456     {
1457       data1 = instance;
1458       data2 = closure-&gt;data;
1459     }
1460   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1461 
1462   callback (data1,
1463             arg0,
1464             data2);
1465   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1466     g_free (arg0);
1467 }
1468 
<a name="32" id="anc32"></a><span class="line-modified">1469 /**</span>
<span class="line-modified">1470  * g_cclosure_marshal_VOID__PARAM:</span>
<span class="line-added">1471  * @closure: A #GClosure.</span>
<span class="line-added">1472  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1473  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1474  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1475  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1476  *   on which to invoke the callback of closure.</span>
<span class="line-added">1477  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1478  *   g_closure_invoke().</span>
<span class="line-added">1479  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1480  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1481  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1482  *</span>
<span class="line-added">1483  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1484  * argument of type #GParamSpec.</span>
<span class="line-added">1485  */</span>
<span class="line-added">1486 /* VOID:PARAM */</span>
1487 void
1488 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1489                                 GValue       *return_value G_GNUC_UNUSED,
1490                                 guint         n_param_values,
1491                                 const GValue *param_values,
1492                                 gpointer      invocation_hint G_GNUC_UNUSED,
1493                                 gpointer      marshal_data)
1494 {
1495   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1496                                             gpointer     arg_1,
1497                                             gpointer     data2);
1498   GMarshalFunc_VOID__PARAM callback;
1499   GCClosure *cc = (GCClosure*) closure;
1500   gpointer data1, data2;
1501 
1502   g_return_if_fail (n_param_values == 2);
1503 
1504   if (G_CCLOSURE_SWAP_DATA (closure))
1505     {
1506       data1 = closure-&gt;data;
1507       data2 = g_value_peek_pointer (param_values + 0);
1508     }
1509   else
1510     {
1511       data1 = g_value_peek_pointer (param_values + 0);
1512       data2 = closure-&gt;data;
1513     }
1514   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1515 
1516   callback (data1,
1517             g_marshal_value_peek_param (param_values + 1),
1518             data2);
1519 }
<a name="33" id="anc33"></a><span class="line-added">1520 </span>
<span class="line-added">1521 /**</span>
<span class="line-added">1522  * g_cclosure_marshal_VOID__PARAMv:</span>
<span class="line-added">1523  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1524  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1525  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1526  *  value.</span>
<span class="line-added">1527  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1528  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1529  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1530  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1531  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1532  * @n_params: the length of the @param_types array</span>
<span class="line-added">1533  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1534  *  @args.</span>
<span class="line-added">1535  *</span>
<span class="line-added">1536  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().</span>
<span class="line-added">1537  */</span>
1538 void
1539 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1540                                  GValue       *return_value,
1541                                  gpointer      instance,
1542                                  va_list       args,
1543                                  gpointer      marshal_data,
1544                                  int           n_params,
1545                                  GType        *param_types)
1546 {
1547   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1548                                             gpointer     arg_0,
1549                                             gpointer     data);
1550   GCClosure *cc = (GCClosure*) closure;
1551   gpointer data1, data2;
1552   GMarshalFunc_VOID__PARAM callback;
1553   gpointer arg0;
1554   va_list args_copy;
1555 
1556   G_VA_COPY (args_copy, args);
1557   arg0 = (gpointer) va_arg (args_copy, gpointer);
1558   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1559     arg0 = g_param_spec_ref (arg0);
1560   va_end (args_copy);
1561 
1562   if (G_CCLOSURE_SWAP_DATA (closure))
1563     {
1564       data1 = closure-&gt;data;
1565       data2 = instance;
1566     }
1567   else
1568     {
1569       data1 = instance;
1570       data2 = closure-&gt;data;
1571     }
1572   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1573 
1574   callback (data1,
1575             arg0,
1576             data2);
1577   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1578     g_param_spec_unref (arg0);
1579 }
1580 
<a name="34" id="anc34"></a><span class="line-modified">1581 /**</span>
<span class="line-modified">1582  * g_cclosure_marshal_VOID__BOXED:</span>
<span class="line-added">1583  * @closure: A #GClosure.</span>
<span class="line-added">1584  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1585  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1586  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1587  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1588  *   on which to invoke the callback of closure.</span>
<span class="line-added">1589  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1590  *   g_closure_invoke().</span>
<span class="line-added">1591  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1592  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1593  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1594  *</span>
<span class="line-added">1595  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1596  * argument which is any boxed pointer type.</span>
<span class="line-added">1597  */</span>
<span class="line-added">1598 /* VOID:BOXED */</span>
1599 void
1600 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1601                                 GValue       *return_value G_GNUC_UNUSED,
1602                                 guint         n_param_values,
1603                                 const GValue *param_values,
1604                                 gpointer      invocation_hint G_GNUC_UNUSED,
1605                                 gpointer      marshal_data)
1606 {
1607   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1608                                             gpointer     arg_1,
1609                                             gpointer     data2);
1610   GMarshalFunc_VOID__BOXED callback;
1611   GCClosure *cc = (GCClosure*) closure;
1612   gpointer data1, data2;
1613 
1614   g_return_if_fail (n_param_values == 2);
1615 
1616   if (G_CCLOSURE_SWAP_DATA (closure))
1617     {
1618       data1 = closure-&gt;data;
1619       data2 = g_value_peek_pointer (param_values + 0);
1620     }
1621   else
1622     {
1623       data1 = g_value_peek_pointer (param_values + 0);
1624       data2 = closure-&gt;data;
1625     }
1626   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1627 
1628   callback (data1,
1629             g_marshal_value_peek_boxed (param_values + 1),
1630             data2);
1631 }
<a name="35" id="anc35"></a><span class="line-added">1632 </span>
<span class="line-added">1633 /**</span>
<span class="line-added">1634  * g_cclosure_marshal_VOID__BOXEDv:</span>
<span class="line-added">1635  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1636  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1637  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1638  *  value.</span>
<span class="line-added">1639  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1640  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1641  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1642  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1643  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1644  * @n_params: the length of the @param_types array</span>
<span class="line-added">1645  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1646  *  @args.</span>
<span class="line-added">1647  *</span>
<span class="line-added">1648  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().</span>
<span class="line-added">1649  */</span>
1650 void
1651 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1652                                  GValue       *return_value,
1653                                  gpointer      instance,
1654                                  va_list       args,
1655                                  gpointer      marshal_data,
1656                                  int           n_params,
1657                                  GType        *param_types)
1658 {
1659   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1660                                             gpointer     arg_0,
1661                                             gpointer     data);
1662   GCClosure *cc = (GCClosure*) closure;
1663   gpointer data1, data2;
1664   GMarshalFunc_VOID__BOXED callback;
1665   gpointer arg0;
1666   va_list args_copy;
1667 
1668   G_VA_COPY (args_copy, args);
1669   arg0 = (gpointer) va_arg (args_copy, gpointer);
1670   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1671     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1672   va_end (args_copy);
1673 
1674   if (G_CCLOSURE_SWAP_DATA (closure))
1675     {
1676       data1 = closure-&gt;data;
1677       data2 = instance;
1678     }
1679   else
1680     {
1681       data1 = instance;
1682       data2 = closure-&gt;data;
1683     }
1684   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1685 
1686   callback (data1,
1687             arg0,
1688             data2);
1689   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1690     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1691 }
1692 
<a name="36" id="anc36"></a><span class="line-modified">1693 /**</span>
<span class="line-modified">1694  * g_cclosure_marshal_VOID__POINTER:</span>
<span class="line-added">1695  * @closure: A #GClosure.</span>
<span class="line-added">1696  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1697  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1698  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1699  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1700  *   on which to invoke the callback of closure.</span>
<span class="line-added">1701  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1702  *   g_closure_invoke().</span>
<span class="line-added">1703  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1704  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1705  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1706  *</span>
<span class="line-added">1707  * A #GClosureMarshal function for use with signals with a single raw</span>
<span class="line-added">1708  * pointer argument type.</span>
<span class="line-added">1709  *</span>
<span class="line-added">1710  * If it is possible, it is better to use one of the more specific</span>
<span class="line-added">1711  * functions such as g_cclosure_marshal_VOID__OBJECT() or</span>
<span class="line-added">1712  * g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-added">1713  */</span>
<span class="line-added">1714 /* VOID:POINTER */</span>
1715 void
1716 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1717                                   GValue       *return_value G_GNUC_UNUSED,
1718                                   guint         n_param_values,
1719                                   const GValue *param_values,
1720                                   gpointer      invocation_hint G_GNUC_UNUSED,
1721                                   gpointer      marshal_data)
1722 {
1723   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1724                                               gpointer     arg_1,
1725                                               gpointer     data2);
1726   GMarshalFunc_VOID__POINTER callback;
1727   GCClosure *cc = (GCClosure*) closure;
1728   gpointer data1, data2;
1729 
1730   g_return_if_fail (n_param_values == 2);
1731 
1732   if (G_CCLOSURE_SWAP_DATA (closure))
1733     {
1734       data1 = closure-&gt;data;
1735       data2 = g_value_peek_pointer (param_values + 0);
1736     }
1737   else
1738     {
1739       data1 = g_value_peek_pointer (param_values + 0);
1740       data2 = closure-&gt;data;
1741     }
1742   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1743 
1744   callback (data1,
1745             g_marshal_value_peek_pointer (param_values + 1),
1746             data2);
1747 }
<a name="37" id="anc37"></a><span class="line-added">1748 </span>
<span class="line-added">1749 /**</span>
<span class="line-added">1750  * g_cclosure_marshal_VOID__POINTERv:</span>
<span class="line-added">1751  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1752  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1753  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1754  *  value.</span>
<span class="line-added">1755  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1756  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1757  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1758  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1759  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1760  * @n_params: the length of the @param_types array</span>
<span class="line-added">1761  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1762  *  @args.</span>
<span class="line-added">1763  *</span>
<span class="line-added">1764  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().</span>
<span class="line-added">1765  */</span>
1766 void
1767 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1768                                    GValue       *return_value,
1769                                    gpointer      instance,
1770                                    va_list       args,
1771                                    gpointer      marshal_data,
1772                                    int           n_params,
1773                                    GType        *param_types)
1774 {
1775   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
1776                                               gpointer     arg_0,
1777                                               gpointer     data);
1778   GCClosure *cc = (GCClosure*) closure;
1779   gpointer data1, data2;
1780   GMarshalFunc_VOID__POINTER callback;
1781   gpointer arg0;
1782   va_list args_copy;
1783 
1784   G_VA_COPY (args_copy, args);
1785   arg0 = (gpointer) va_arg (args_copy, gpointer);
1786   va_end (args_copy);
1787 
1788   if (G_CCLOSURE_SWAP_DATA (closure))
1789     {
1790       data1 = closure-&gt;data;
1791       data2 = instance;
1792     }
1793   else
1794     {
1795       data1 = instance;
1796       data2 = closure-&gt;data;
1797     }
1798   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1799 
1800   callback (data1,
1801             arg0,
1802             data2);
1803 }
1804 
<a name="38" id="anc38"></a><span class="line-modified">1805 /**</span>
<span class="line-modified">1806  * g_cclosure_marshal_VOID__OBJECT:</span>
<span class="line-added">1807  * @closure: A #GClosure.</span>
<span class="line-added">1808  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1809  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1810  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1811  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1812  *   on which to invoke the callback of closure.</span>
<span class="line-added">1813  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1814  *   g_closure_invoke().</span>
<span class="line-added">1815  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1816  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1817  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1818  *</span>
<span class="line-added">1819  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1820  * #GObject argument.</span>
<span class="line-added">1821  */</span>
<span class="line-added">1822 /* VOID:OBJECT */</span>
1823 void
1824 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
1825                                  GValue       *return_value G_GNUC_UNUSED,
1826                                  guint         n_param_values,
1827                                  const GValue *param_values,
1828                                  gpointer      invocation_hint G_GNUC_UNUSED,
1829                                  gpointer      marshal_data)
1830 {
1831   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
1832                                              gpointer     arg_1,
1833                                              gpointer     data2);
1834   GMarshalFunc_VOID__OBJECT callback;
1835   GCClosure *cc = (GCClosure*) closure;
1836   gpointer data1, data2;
1837 
1838   g_return_if_fail (n_param_values == 2);
1839 
1840   if (G_CCLOSURE_SWAP_DATA (closure))
1841     {
1842       data1 = closure-&gt;data;
1843       data2 = g_value_peek_pointer (param_values + 0);
1844     }
1845   else
1846     {
1847       data1 = g_value_peek_pointer (param_values + 0);
1848       data2 = closure-&gt;data;
1849     }
1850   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1851 
1852   callback (data1,
1853             g_marshal_value_peek_object (param_values + 1),
1854             data2);
1855 }
<a name="39" id="anc39"></a><span class="line-added">1856 </span>
<span class="line-added">1857 /**</span>
<span class="line-added">1858  * g_cclosure_marshal_VOID__OBJECTv:</span>
<span class="line-added">1859  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1860  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1861  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1862  *  value.</span>
<span class="line-added">1863  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1864  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1865  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1866  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1867  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1868  * @n_params: the length of the @param_types array</span>
<span class="line-added">1869  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1870  *  @args.</span>
<span class="line-added">1871  *</span>
<span class="line-added">1872  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-added">1873  */</span>
1874 void
1875 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
1876                                   GValue       *return_value,
1877                                   gpointer      instance,
1878                                   va_list       args,
1879                                   gpointer      marshal_data,
1880                                   int           n_params,
1881                                   GType        *param_types)
1882 {
1883   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
1884                                              gpointer     arg_0,
1885                                              gpointer     data);
1886   GCClosure *cc = (GCClosure*) closure;
1887   gpointer data1, data2;
1888   GMarshalFunc_VOID__OBJECT callback;
1889   gpointer arg0;
1890   va_list args_copy;
1891 
1892   G_VA_COPY (args_copy, args);
1893   arg0 = (gpointer) va_arg (args_copy, gpointer);
1894   if (arg0 != NULL)
1895     arg0 = g_object_ref (arg0);
1896   va_end (args_copy);
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = instance;
1902     }
1903   else
1904     {
1905       data1 = instance;
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             arg0,
1912             data2);
1913   if (arg0 != NULL)
1914     g_object_unref (arg0);
1915 }
1916 
<a name="40" id="anc40"></a><span class="line-modified">1917 /**</span>
<span class="line-modified">1918  * g_cclosure_marshal_VOID__VARIANT:</span>
<span class="line-added">1919  * @closure: A #GClosure.</span>
<span class="line-added">1920  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1921  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1922  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1923  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1924  *   on which to invoke the callback of closure.</span>
<span class="line-added">1925  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1926  *   g_closure_invoke().</span>
<span class="line-added">1927  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1928  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1929  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1930  *</span>
<span class="line-added">1931  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1932  * #GVariant argument.</span>
<span class="line-added">1933  */</span>
<span class="line-added">1934 /* VOID:VARIANT */</span>
1935 void
1936 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
1937                                   GValue       *return_value G_GNUC_UNUSED,
1938                                   guint         n_param_values,
1939                                   const GValue *param_values,
1940                                   gpointer      invocation_hint G_GNUC_UNUSED,
1941                                   gpointer      marshal_data)
1942 {
1943   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
1944                                               gpointer     arg_1,
1945                                               gpointer     data2);
1946   GMarshalFunc_VOID__VARIANT callback;
1947   GCClosure *cc = (GCClosure*) closure;
1948   gpointer data1, data2;
1949 
1950   g_return_if_fail (n_param_values == 2);
1951 
1952   if (G_CCLOSURE_SWAP_DATA (closure))
1953     {
1954       data1 = closure-&gt;data;
1955       data2 = g_value_peek_pointer (param_values + 0);
1956     }
1957   else
1958     {
1959       data1 = g_value_peek_pointer (param_values + 0);
1960       data2 = closure-&gt;data;
1961     }
1962   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
1963 
1964   callback (data1,
1965             g_marshal_value_peek_variant (param_values + 1),
1966             data2);
1967 }
<a name="41" id="anc41"></a><span class="line-added">1968 </span>
<span class="line-added">1969 /**</span>
<span class="line-added">1970  * g_cclosure_marshal_VOID__VARIANTv:</span>
<span class="line-added">1971  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1972  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1973  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1974  *  value.</span>
<span class="line-added">1975  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1976  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1977  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1978  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1979  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1980  * @n_params: the length of the @param_types array</span>
<span class="line-added">1981  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1982  *  @args.</span>
<span class="line-added">1983  *</span>
<span class="line-added">1984  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().</span>
<span class="line-added">1985  */</span>
1986 void
1987 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
1988                                    GValue       *return_value,
1989                                    gpointer      instance,
1990                                    va_list       args,
1991                                    gpointer      marshal_data,
1992                                    int           n_params,
1993                                    GType        *param_types)
1994 {
1995   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
1996                                               gpointer     arg_0,
1997                                               gpointer     data);
1998   GCClosure *cc = (GCClosure*) closure;
1999   gpointer data1, data2;
2000   GMarshalFunc_VOID__VARIANT callback;
2001   gpointer arg0;
2002   va_list args_copy;
2003 
2004   G_VA_COPY (args_copy, args);
2005   arg0 = (gpointer) va_arg (args_copy, gpointer);
2006   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2007     arg0 = g_variant_ref_sink (arg0);
2008   va_end (args_copy);
2009 
2010   if (G_CCLOSURE_SWAP_DATA (closure))
2011     {
2012       data1 = closure-&gt;data;
2013       data2 = instance;
2014     }
2015   else
2016     {
2017       data1 = instance;
2018       data2 = closure-&gt;data;
2019     }
2020   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2021 
2022   callback (data1,
2023             arg0,
2024             data2);
2025   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2026     g_variant_unref (arg0);
2027 }
2028 
<a name="42" id="anc42"></a><span class="line-modified">2029 /**</span>
<span class="line-modified">2030  * g_cclosure_marshal_VOID__UINT_POINTER:</span>
<span class="line-added">2031  * @closure: A #GClosure.</span>
<span class="line-added">2032  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2033  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2034  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2035  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2036  *   on which to invoke the callback of closure.</span>
<span class="line-added">2037  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2038  *   g_closure_invoke().</span>
<span class="line-added">2039  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2040  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2041  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2042  *</span>
<span class="line-added">2043  * A #GClosureMarshal function for use with signals with an unsigned int</span>
<span class="line-added">2044  * and a pointer as arguments.</span>
<span class="line-added">2045  */</span>
<span class="line-added">2046 /* VOID:UINT,POINTER */</span>
2047 void
2048 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2049                                        GValue       *return_value G_GNUC_UNUSED,
2050                                        guint         n_param_values,
2051                                        const GValue *param_values,
2052                                        gpointer      invocation_hint G_GNUC_UNUSED,
2053                                        gpointer      marshal_data)
2054 {
2055   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2056                                                    guint        arg_1,
2057                                                    gpointer     arg_2,
2058                                                    gpointer     data2);
2059   GMarshalFunc_VOID__UINT_POINTER callback;
2060   GCClosure *cc = (GCClosure*) closure;
2061   gpointer data1, data2;
2062 
2063   g_return_if_fail (n_param_values == 3);
2064 
2065   if (G_CCLOSURE_SWAP_DATA (closure))
2066     {
2067       data1 = closure-&gt;data;
2068       data2 = g_value_peek_pointer (param_values + 0);
2069     }
2070   else
2071     {
2072       data1 = g_value_peek_pointer (param_values + 0);
2073       data2 = closure-&gt;data;
2074     }
2075   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2076 
2077   callback (data1,
2078             g_marshal_value_peek_uint (param_values + 1),
2079             g_marshal_value_peek_pointer (param_values + 2),
2080             data2);
2081 }
<a name="43" id="anc43"></a><span class="line-added">2082 </span>
<span class="line-added">2083 /**</span>
<span class="line-added">2084  * g_cclosure_marshal_VOID__UINT_POINTERv:</span>
<span class="line-added">2085  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2086  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2087  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2088  *  value.</span>
<span class="line-added">2089  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2090  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2091  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2092  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2093  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2094  * @n_params: the length of the @param_types array</span>
<span class="line-added">2095  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2096  *  @args.</span>
<span class="line-added">2097  *</span>
<span class="line-added">2098  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().</span>
<span class="line-added">2099  */</span>
2100 void
2101 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2102                                         GValue       *return_value,
2103                                         gpointer      instance,
2104                                         va_list       args,
2105                                         gpointer      marshal_data,
2106                                         int           n_params,
2107                                         GType        *param_types)
2108 {
2109   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2110                                                    guint        arg_0,
2111                                                    gpointer     arg_1,
2112                                                    gpointer     data);
2113   GCClosure *cc = (GCClosure*) closure;
2114   gpointer data1, data2;
2115   GMarshalFunc_VOID__UINT_POINTER callback;
2116   guint arg0;
2117   gpointer arg1;
2118   va_list args_copy;
2119 
2120   G_VA_COPY (args_copy, args);
2121   arg0 = (guint) va_arg (args_copy, guint);
2122   arg1 = (gpointer) va_arg (args_copy, gpointer);
2123   va_end (args_copy);
2124 
2125   if (G_CCLOSURE_SWAP_DATA (closure))
2126     {
2127       data1 = closure-&gt;data;
2128       data2 = instance;
2129     }
2130   else
2131     {
2132       data1 = instance;
2133       data2 = closure-&gt;data;
2134     }
2135   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2136 
2137   callback (data1,
2138             arg0,
2139             arg1,
2140             data2);
2141 }
2142 
<a name="44" id="anc44"></a><span class="line-modified">2143 /**</span>
<span class="line-modified">2144  * g_cclosure_marshal_BOOLEAN__FLAGS:</span>
<span class="line-added">2145  * @closure: A #GClosure.</span>
<span class="line-added">2146  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2147  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2148  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2149  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2150  *   on which to invoke the callback of closure.</span>
<span class="line-added">2151  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2152  *   g_closure_invoke().</span>
<span class="line-added">2153  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2154  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2155  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2156  *</span>
<span class="line-added">2157  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2158  * take a flags type as an argument and return a boolean.  If you have</span>
<span class="line-added">2159  * such a signal, you will probably also need to use an accumulator,</span>
<span class="line-added">2160  * such as g_signal_accumulator_true_handled().</span>
<span class="line-added">2161  */</span>
<span class="line-added">2162 /* BOOL:FLAGS */</span>
2163 void
2164 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2165                                    GValue       *return_value G_GNUC_UNUSED,
2166                                    guint         n_param_values,
2167                                    const GValue *param_values,
2168                                    gpointer      invocation_hint G_GNUC_UNUSED,
2169                                    gpointer      marshal_data)
2170 {
2171   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2172                                                    guint        arg_1,
2173                                                    gpointer     data2);
2174   GMarshalFunc_BOOLEAN__FLAGS callback;
2175   GCClosure *cc = (GCClosure*) closure;
2176   gpointer data1, data2;
2177   gboolean v_return;
2178 
2179   g_return_if_fail (return_value != NULL);
2180   g_return_if_fail (n_param_values == 2);
2181 
2182   if (G_CCLOSURE_SWAP_DATA (closure))
2183     {
2184       data1 = closure-&gt;data;
2185       data2 = g_value_peek_pointer (param_values + 0);
2186     }
2187   else
2188     {
2189       data1 = g_value_peek_pointer (param_values + 0);
2190       data2 = closure-&gt;data;
2191     }
2192   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2193 
2194   v_return = callback (data1,
2195                        g_marshal_value_peek_flags (param_values + 1),
2196                        data2);
2197 
2198   g_value_set_boolean (return_value, v_return);
2199 }
<a name="45" id="anc45"></a><span class="line-added">2200 </span>
<span class="line-added">2201 /**</span>
<span class="line-added">2202  * g_cclosure_marshal_BOOLEAN__FLAGSv:</span>
<span class="line-added">2203  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2204  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2205  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2206  *  value.</span>
<span class="line-added">2207  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2208  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2209  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2210  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2211  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2212  * @n_params: the length of the @param_types array</span>
<span class="line-added">2213  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2214  *  @args.</span>
<span class="line-added">2215  *</span>
<span class="line-added">2216  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-added">2217  */</span>
2218 void
2219 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2220                                     GValue       *return_value,
2221                                     gpointer      instance,
2222                                     va_list       args,
2223                                     gpointer      marshal_data,
2224                                     int           n_params,
2225                                     GType        *param_types)
2226 {
2227   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2228                                                    guint        arg_0,
2229                                                    gpointer     data);
2230   GCClosure *cc = (GCClosure*) closure;
2231   gpointer data1, data2;
2232   GMarshalFunc_BOOLEAN__FLAGS callback;
2233   guint arg0;
2234   va_list args_copy;
2235   gboolean v_return;
2236 
2237   g_return_if_fail (return_value != NULL);
2238 
2239   G_VA_COPY (args_copy, args);
2240   arg0 = (guint) va_arg (args_copy, guint);
2241   va_end (args_copy);
2242 
2243   if (G_CCLOSURE_SWAP_DATA (closure))
2244     {
2245       data1 = closure-&gt;data;
2246       data2 = instance;
2247     }
2248   else
2249     {
2250       data1 = instance;
2251       data2 = closure-&gt;data;
2252     }
2253   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2254 
2255   v_return = callback (data1,
2256                        arg0,
2257                        data2);
2258 
2259   g_value_set_boolean (return_value, v_return);
2260 }
2261 
<a name="46" id="anc46"></a><span class="line-modified">2262 /**</span>
<span class="line-modified">2263  * g_cclosure_marshal_STRING__OBJECT_POINTER:</span>
<span class="line-added">2264  * @closure: A #GClosure.</span>
<span class="line-added">2265  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2266  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2267  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2268  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2269  *   on which to invoke the callback of closure.</span>
<span class="line-added">2270  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2271  *   g_closure_invoke().</span>
<span class="line-added">2272  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2273  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2274  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2275  *</span>
<span class="line-added">2276  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2277  * take a #GObject and a pointer and produce a string.  It is highly</span>
<span class="line-added">2278  * unlikely that your signal handler fits this description.</span>
<span class="line-added">2279  */</span>
<span class="line-added">2280 /* STRING:OBJECT,POINTER */</span>
2281 void
2282 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2283                                            GValue       *return_value G_GNUC_UNUSED,
2284                                            guint         n_param_values,
2285                                            const GValue *param_values,
2286                                            gpointer      invocation_hint G_GNUC_UNUSED,
2287                                            gpointer      marshal_data)
2288 {
2289   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2290                                                          gpointer     arg_1,
2291                                                          gpointer     arg_2,
2292                                                          gpointer     data2);
2293   GMarshalFunc_STRING__OBJECT_POINTER callback;
2294   GCClosure *cc = (GCClosure*) closure;
2295   gpointer data1, data2;
2296   gchar* v_return;
2297 
2298   g_return_if_fail (return_value != NULL);
2299   g_return_if_fail (n_param_values == 3);
2300 
2301   if (G_CCLOSURE_SWAP_DATA (closure))
2302     {
2303       data1 = closure-&gt;data;
2304       data2 = g_value_peek_pointer (param_values + 0);
2305     }
2306   else
2307     {
2308       data1 = g_value_peek_pointer (param_values + 0);
2309       data2 = closure-&gt;data;
2310     }
2311   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2312 
2313   v_return = callback (data1,
2314                        g_marshal_value_peek_object (param_values + 1),
2315                        g_marshal_value_peek_pointer (param_values + 2),
2316                        data2);
2317 
2318   g_value_take_string (return_value, v_return);
2319 }
<a name="47" id="anc47"></a><span class="line-added">2320 </span>
<span class="line-added">2321 /**</span>
<span class="line-added">2322  * g_cclosure_marshal_STRING__OBJECT_POINTERv:</span>
<span class="line-added">2323  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2324  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2325  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2326  *  value.</span>
<span class="line-added">2327  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2328  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2329  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2330  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2331  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2332  * @n_params: the length of the @param_types array</span>
<span class="line-added">2333  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2334  *  @args.</span>
<span class="line-added">2335  *</span>
<span class="line-added">2336  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().</span>
<span class="line-added">2337  */</span>
2338 void
2339 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2340                                             GValue       *return_value,
2341                                             gpointer      instance,
2342                                             va_list       args,
2343                                             gpointer      marshal_data,
2344                                             int           n_params,
2345                                             GType        *param_types)
2346 {
2347   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2348                                                          gpointer     arg_0,
2349                                                          gpointer     arg_1,
2350                                                          gpointer     data);
2351   GCClosure *cc = (GCClosure*) closure;
2352   gpointer data1, data2;
2353   GMarshalFunc_STRING__OBJECT_POINTER callback;
2354   gpointer arg0;
2355   gpointer arg1;
2356   va_list args_copy;
2357   gchar* v_return;
2358 
2359   g_return_if_fail (return_value != NULL);
2360 
2361   G_VA_COPY (args_copy, args);
2362   arg0 = (gpointer) va_arg (args_copy, gpointer);
2363   if (arg0 != NULL)
2364     arg0 = g_object_ref (arg0);
2365   arg1 = (gpointer) va_arg (args_copy, gpointer);
2366   va_end (args_copy);
2367 
2368   if (G_CCLOSURE_SWAP_DATA (closure))
2369     {
2370       data1 = closure-&gt;data;
2371       data2 = instance;
2372     }
2373   else
2374     {
2375       data1 = instance;
2376       data2 = closure-&gt;data;
2377     }
2378   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2379 
2380   v_return = callback (data1,
2381                        arg0,
2382                        arg1,
2383                        data2);
2384   if (arg0 != NULL)
2385     g_object_unref (arg0);
2386 
2387   g_value_take_string (return_value, v_return);
2388 }
2389 
<a name="48" id="anc48"></a><span class="line-modified">2390 /**</span>
<span class="line-modified">2391  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:</span>
<span class="line-added">2392  * @closure: A #GClosure.</span>
<span class="line-added">2393  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2394  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2395  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2396  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2397  *   on which to invoke the callback of closure.</span>
<span class="line-added">2398  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2399  *   g_closure_invoke().</span>
<span class="line-added">2400  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2401  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2402  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2403  *</span>
<span class="line-added">2404  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2405  * take two boxed pointers as arguments and return a boolean.  If you</span>
<span class="line-added">2406  * have such a signal, you will probably also need to use an</span>
<span class="line-added">2407  * accumulator, such as g_signal_accumulator_true_handled().</span>
<span class="line-added">2408  */</span>
<span class="line-added">2409 /* BOOL:BOXED,BOXED */</span>
2410 void
2411 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2412                                          GValue       *return_value G_GNUC_UNUSED,
2413                                          guint         n_param_values,
2414                                          const GValue *param_values,
2415                                          gpointer      invocation_hint G_GNUC_UNUSED,
2416                                          gpointer      marshal_data)
2417 {
2418   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2419                                                          gpointer     arg_1,
2420                                                          gpointer     arg_2,
2421                                                          gpointer     data2);
2422   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2423   GCClosure *cc = (GCClosure*) closure;
2424   gpointer data1, data2;
2425   gboolean v_return;
2426 
2427   g_return_if_fail (return_value != NULL);
2428   g_return_if_fail (n_param_values == 3);
2429 
2430   if (G_CCLOSURE_SWAP_DATA (closure))
2431     {
2432       data1 = closure-&gt;data;
2433       data2 = g_value_peek_pointer (param_values + 0);
2434     }
2435   else
2436     {
2437       data1 = g_value_peek_pointer (param_values + 0);
2438       data2 = closure-&gt;data;
2439     }
2440   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2441 
2442   v_return = callback (data1,
2443                        g_marshal_value_peek_boxed (param_values + 1),
2444                        g_marshal_value_peek_boxed (param_values + 2),
2445                        data2);
2446 
2447   g_value_set_boolean (return_value, v_return);
2448 }
<a name="49" id="anc49"></a><span class="line-added">2449 </span>
<span class="line-added">2450 /**</span>
<span class="line-added">2451  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:</span>
<span class="line-added">2452  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2453  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2454  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2455  *  value.</span>
<span class="line-added">2456  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2457  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2458  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2459  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2460  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2461  * @n_params: the length of the @param_types array</span>
<span class="line-added">2462  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2463  *  @args.</span>
<span class="line-added">2464  *</span>
<span class="line-added">2465  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>
<span class="line-added">2466  */</span>
2467 void
2468 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2469                                           GValue       *return_value,
2470                                           gpointer      instance,
2471                                           va_list       args,
2472                                           gpointer      marshal_data,
2473                                           int           n_params,
2474                                           GType        *param_types)
2475 {
2476   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2477                                                          gpointer     arg_0,
2478                                                          gpointer     arg_1,
2479                                                          gpointer     data);
2480   GCClosure *cc = (GCClosure*) closure;
2481   gpointer data1, data2;
2482   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2483   gpointer arg0;
2484   gpointer arg1;
2485   va_list args_copy;
2486   gboolean v_return;
2487 
2488   g_return_if_fail (return_value != NULL);
2489 
2490   G_VA_COPY (args_copy, args);
2491   arg0 = (gpointer) va_arg (args_copy, gpointer);
2492   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2493     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2494   arg1 = (gpointer) va_arg (args_copy, gpointer);
2495   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2496     arg1 = g_boxed_copy (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2497   va_end (args_copy);
2498 
2499   if (G_CCLOSURE_SWAP_DATA (closure))
2500     {
2501       data1 = closure-&gt;data;
2502       data2 = instance;
2503     }
2504   else
2505     {
2506       data1 = instance;
2507       data2 = closure-&gt;data;
2508     }
2509   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2510 
2511   v_return = callback (data1,
2512                        arg0,
2513                        arg1,
2514                        data2);
2515   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2516     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2517   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2518     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2519 
2520   g_value_set_boolean (return_value, v_return);
2521 }
<a name="50" id="anc50"></a>

<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>