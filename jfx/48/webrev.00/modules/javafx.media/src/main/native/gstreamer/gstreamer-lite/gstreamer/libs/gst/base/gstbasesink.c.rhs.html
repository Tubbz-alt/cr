<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2005-2007 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   3  *
   4  * gstbasesink.c: Base class for sink elements
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstbasesink
  24  * @title: GstBaseSink
  25  * @short_description: Base class for sink elements
  26  * @see_also: #GstBaseTransform, #GstBaseSrc
  27  *
  28  * #GstBaseSink is the base class for sink elements in GStreamer, such as
  29  * xvimagesink or filesink. It is a layer on top of #GstElement that provides a
  30  * simplified interface to plugin writers. #GstBaseSink handles many details
  31  * for you, for example: preroll, clock synchronization, state changes,
  32  * activation in push or pull mode, and queries.
  33  *
  34  * In most cases, when writing sink elements, there is no need to implement
  35  * class methods from #GstElement or to set functions on pads, because the
  36  * #GstBaseSink infrastructure should be sufficient.
  37  *
  38  * #GstBaseSink provides support for exactly one sink pad, which should be
  39  * named &quot;sink&quot;. A sink implementation (subclass of #GstBaseSink) should
  40  * install a pad template in its class_init function, like so:
  41  * |[&lt;!-- language=&quot;C&quot; --&gt;
  42  * static void
  43  * my_element_class_init (GstMyElementClass *klass)
  44  * {
  45  *   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
  46  *
  47  *   // sinktemplate should be a #GstStaticPadTemplate with direction
  48  *   // %GST_PAD_SINK and name &quot;sink&quot;
  49  *   gst_element_class_add_static_pad_template (gstelement_class, &amp;amp;sinktemplate);
  50  *
  51  *   gst_element_class_set_static_metadata (gstelement_class,
  52  *       &quot;Sink name&quot;,
  53  *       &quot;Sink&quot;,
  54  *       &quot;My Sink element&quot;,
  55  *       &quot;The author &lt;my.sink@my.email&gt;&quot;);
  56  * }
  57  * ]|
  58  *
  59  * #GstBaseSink will handle the prerolling correctly. This means that it will
  60  * return %GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first
  61  * buffer arrives in this element. The base class will call the
  62  * #GstBaseSinkClass.preroll() vmethod with this preroll buffer and will then
  63  * commit the state change to the next asynchronously pending state.
  64  *
  65  * When the element is set to PLAYING, #GstBaseSink will synchronise on the
  66  * clock using the times returned from #GstBaseSinkClass.get_times(). If this
  67  * function returns %GST_CLOCK_TIME_NONE for the start time, no synchronisation
  68  * will be done. Synchronisation can be disabled entirely by setting the object
  69  * #GstBaseSink:sync property to %FALSE.
  70  *
  71  * After synchronisation the virtual method #GstBaseSinkClass.render() will be
  72  * called. Subclasses should minimally implement this method.
  73  *
  74  * Subclasses that synchronise on the clock in the #GstBaseSinkClass.render()
  75  * method are supported as well. These classes typically receive a buffer in
  76  * the render method and can then potentially block on the clock while
  77  * rendering. A typical example is an audiosink.
  78  * These subclasses can use gst_base_sink_wait_preroll() to perform the
  79  * blocking wait.
  80  *
  81  * Upon receiving the EOS event in the PLAYING state, #GstBaseSink will wait
  82  * for the clock to reach the time indicated by the stop time of the last
  83  * #GstBaseSinkClass.get_times() call before posting an EOS message. When the
  84  * element receives EOS in PAUSED, preroll completes, the event is queued and an
  85  * EOS message is posted when going to PLAYING.
  86  *
  87  * #GstBaseSink will internally use the %GST_EVENT_SEGMENT events to schedule
  88  * synchronisation and clipping of buffers. Buffers that fall completely outside
  89  * of the current segment are dropped. Buffers that fall partially in the
  90  * segment are rendered (and prerolled). Subclasses should do any subbuffer
  91  * clipping themselves when needed.
  92  *
  93  * #GstBaseSink will by default report the current playback position in
  94  * %GST_FORMAT_TIME based on the current clock time and segment information.
  95  * If no clock has been set on the element, the query will be forwarded
  96  * upstream.
  97  *
  98  * The #GstBaseSinkClass.set_caps() function will be called when the subclass
  99  * should configure itself to process a specific media type.
 100  *
 101  * The #GstBaseSinkClass.start() and #GstBaseSinkClass.stop() virtual methods
 102  * will be called when resources should be allocated. Any
 103  * #GstBaseSinkClass.preroll(), #GstBaseSinkClass.render() and
 104  * #GstBaseSinkClass.set_caps() function will be called between the
 105  * #GstBaseSinkClass.start() and #GstBaseSinkClass.stop() calls.
 106  *
 107  * The #GstBaseSinkClass.event() virtual method will be called when an event is
 108  * received by #GstBaseSink. Normally this method should only be overridden by
 109  * very specific elements (such as file sinks) which need to handle the
 110  * newsegment event specially.
 111  *
 112  * The #GstBaseSinkClass.unlock() method is called when the elements should
 113  * unblock any blocking operations they perform in the
 114  * #GstBaseSinkClass.render() method. This is mostly useful when the
 115  * #GstBaseSinkClass.render() method performs a blocking write on a file
 116  * descriptor, for example.
 117  *
 118  * The #GstBaseSink:max-lateness property affects how the sink deals with
 119  * buffers that arrive too late in the sink. A buffer arrives too late in the
 120  * sink when the presentation time (as a combination of the last segment, buffer
 121  * timestamp and element base_time) plus the duration is before the current
 122  * time of the clock.
 123  * If the frame is later than max-lateness, the sink will drop the buffer
 124  * without calling the render method.
 125  * This feature is disabled if sync is disabled, the
 126  * #GstBaseSinkClass.get_times() method does not return a valid start time or
 127  * max-lateness is set to -1 (the default).
 128  * Subclasses can use gst_base_sink_set_max_lateness() to configure the
 129  * max-lateness value.
 130  *
 131  * The #GstBaseSink:qos property will enable the quality-of-service features of
 132  * the basesink which gather statistics about the real-time performance of the
 133  * clock synchronisation. For each buffer received in the sink, statistics are
 134  * gathered and a QOS event is sent upstream with these numbers. This
 135  * information can then be used by upstream elements to reduce their processing
 136  * rate, for example.
 137  *
 138  * The #GstBaseSink:async property can be used to instruct the sink to never
 139  * perform an ASYNC state change. This feature is mostly usable when dealing
 140  * with non-synchronized streams or sparse streams.
 141  */
 142 
 143 #ifdef HAVE_CONFIG_H
 144 #  include &quot;config.h&quot;
 145 #endif
 146 
 147 #include &lt;gst/gst_private.h&gt;
 148 
 149 #include &quot;gstbasesink.h&quot;
 150 #include &lt;gst/gst-i18n-lib.h&gt;
 151 
 152 GST_DEBUG_CATEGORY_STATIC (gst_base_sink_debug);
 153 #define GST_CAT_DEFAULT gst_base_sink_debug
 154 
<a name="1" id="anc1"></a>


 155 #define GST_FLOW_STEP GST_FLOW_CUSTOM_ERROR
 156 
 157 typedef struct
 158 {
 159   gboolean valid;               /* if this info is valid */
 160   guint32 seqnum;               /* the seqnum of the STEP event */
 161   GstFormat format;             /* the format of the amount */
 162   guint64 amount;               /* the total amount of data to skip */
 163   guint64 position;             /* the position in the stepped data */
 164   guint64 duration;             /* the duration in time of the skipped data */
 165   guint64 start;                /* running_time of the start */
 166   gdouble rate;                 /* rate of skipping */
 167   gdouble start_rate;           /* rate before skipping */
 168   guint64 start_start;          /* start position skipping */
 169   guint64 start_stop;           /* stop position skipping */
 170   gboolean flush;               /* if this was a flushing step */
 171   gboolean intermediate;        /* if this is an intermediate step */
 172   gboolean need_preroll;        /* if we need preroll after this step */
 173 } GstStepInfo;
 174 
 175 struct _GstBaseSinkPrivate
 176 {
 177   gint qos_enabled;             /* ATOMIC */
 178   gboolean async_enabled;
 179   GstClockTimeDiff ts_offset;
 180   GstClockTime render_delay;
<a name="2" id="anc2"></a><span class="line-added"> 181   GstClockTime processing_deadline;</span>
 182 
 183   /* start, stop of current buffer, stream time, used to report position */
 184   GstClockTime current_sstart;
 185   GstClockTime current_sstop;
 186 
 187   /* start, stop and jitter of current buffer, running time */
 188   GstClockTime current_rstart;
 189   GstClockTime current_rstop;
 190   GstClockTimeDiff current_jitter;
 191   /* the running time of the previous buffer */
 192   GstClockTime prev_rstart;
 193 
 194   /* EOS sync time in running time */
 195   GstClockTime eos_rtime;
 196 
 197   /* last buffer that arrived in time, running time */
 198   GstClockTime last_render_time;
 199   /* when the last buffer left the sink, running time */
 200   GstClockTime last_left;
 201 
 202   /* running averages go here these are done on running time */
 203   GstClockTime avg_pt, avg_in_diff;
 204   gdouble avg_rate;             /* average with infinite window */
 205 
 206   /* number of rendered and dropped frames */
 207   guint64 rendered;
 208   guint64 dropped;
 209 
 210   /* latency stuff */
 211   GstClockTime latency;
 212 
<a name="3" id="anc3"></a><span class="line-modified"> 213   /* if we already committed the state */</span>
<span class="line-modified"> 214   gboolean committed;</span>
 215   /* state change to playing ongoing */
 216   gboolean to_playing;
 217 
 218   /* when we received EOS */
 219   gboolean received_eos;
 220 
 221   /* when we are prerolled and able to report latency */
 222   gboolean have_latency;
 223 
 224   /* the last buffer we prerolled or rendered. Useful for making snapshots */
 225   gint enable_last_sample;      /* atomic */
 226   GstBuffer *last_buffer;
 227   GstCaps *last_caps;
 228   GstBufferList *last_buffer_list;
 229 
 230   /* negotiated caps */
 231   GstCaps *caps;
 232 
 233   /* blocksize for pulling */
 234   guint blocksize;
 235 
 236   gboolean discont;
 237 
 238   /* seqnum of the stream */
 239   guint32 seqnum;
 240 
 241   gboolean call_preroll;
 242   gboolean step_unlock;
 243 
 244   /* we have a pending and a current step operation */
 245   GstStepInfo current_step;
 246   GstStepInfo pending_step;
 247 
 248   /* Cached GstClockID */
 249   GstClockID cached_clock_id;
 250 
 251   /* for throttling and QoS */
 252   GstClockTime earliest_in_time;
 253   GstClockTime throttle_time;
 254 
 255   /* for rate control */
 256   guint64 max_bitrate;
 257   GstClockTime rc_time;
 258   GstClockTime rc_next;
 259   gsize rc_accumulated;
 260 
 261   gboolean drop_out_of_segment;
 262 };
 263 
 264 #define DO_RUNNING_AVG(avg,val,size) (((val) + ((size)-1) * (avg)) / (size))
 265 
 266 /* generic running average, this has a neutral window size */
 267 #define UPDATE_RUNNING_AVG(avg,val)   DO_RUNNING_AVG(avg,val,8)
 268 
 269 /* the windows for these running averages are experimentally obtained.
 270  * positive values get averaged more while negative values use a small
 271  * window so we can react faster to badness. */
 272 #define UPDATE_RUNNING_AVG_P(avg,val) DO_RUNNING_AVG(avg,val,16)
 273 #define UPDATE_RUNNING_AVG_N(avg,val) DO_RUNNING_AVG(avg,val,4)
 274 
 275 /* BaseSink properties */
 276 
 277 #define DEFAULT_CAN_ACTIVATE_PULL FALSE /* fixme: enable me */
 278 #define DEFAULT_CAN_ACTIVATE_PUSH TRUE
 279 
 280 #define DEFAULT_SYNC                TRUE
 281 #define DEFAULT_MAX_LATENESS        -1
 282 #define DEFAULT_QOS                 FALSE
 283 #define DEFAULT_ASYNC               TRUE
 284 #define DEFAULT_TS_OFFSET           0
 285 #define DEFAULT_BLOCKSIZE           4096
 286 #define DEFAULT_RENDER_DELAY        0
 287 #define DEFAULT_ENABLE_LAST_SAMPLE  TRUE
 288 #define DEFAULT_THROTTLE_TIME       0
 289 #define DEFAULT_MAX_BITRATE         0
 290 #define DEFAULT_DROP_OUT_OF_SEGMENT TRUE
<a name="4" id="anc4"></a><span class="line-added"> 291 #define DEFAULT_PROCESSING_DEADLINE (20 * GST_MSECOND)</span>
 292 
 293 enum
 294 {
 295   PROP_0,
 296   PROP_SYNC,
 297   PROP_MAX_LATENESS,
 298   PROP_QOS,
 299   PROP_ASYNC,
 300   PROP_TS_OFFSET,
 301   PROP_ENABLE_LAST_SAMPLE,
 302   PROP_LAST_SAMPLE,
 303   PROP_BLOCKSIZE,
 304   PROP_RENDER_DELAY,
 305   PROP_THROTTLE_TIME,
 306   PROP_MAX_BITRATE,
<a name="5" id="anc5"></a><span class="line-added"> 307   PROP_PROCESSING_DEADLINE,</span>
 308   PROP_LAST
 309 };
 310 
 311 static GstElementClass *parent_class = NULL;
<a name="6" id="anc6"></a><span class="line-added"> 312 static gint private_offset = 0;</span>
 313 
 314 static void gst_base_sink_class_init (GstBaseSinkClass * klass);
 315 static void gst_base_sink_init (GstBaseSink * trans, gpointer g_class);
 316 static void gst_base_sink_finalize (GObject * object);
 317 
 318 GType
 319 gst_base_sink_get_type (void)
 320 {
 321   static volatile gsize base_sink_type = 0;
 322 
 323   if (g_once_init_enter (&amp;base_sink_type)) {
 324     GType _type;
 325     static const GTypeInfo base_sink_info = {
 326       sizeof (GstBaseSinkClass),
 327       NULL,
 328       NULL,
 329       (GClassInitFunc) gst_base_sink_class_init,
 330       NULL,
 331       NULL,
 332       sizeof (GstBaseSink),
 333       0,
 334       (GInstanceInitFunc) gst_base_sink_init,
 335     };
 336 
 337     _type = g_type_register_static (GST_TYPE_ELEMENT,
 338         &quot;GstBaseSink&quot;, &amp;base_sink_info, G_TYPE_FLAG_ABSTRACT);
<a name="7" id="anc7"></a><span class="line-added"> 339 </span>
<span class="line-added"> 340     private_offset =</span>
<span class="line-added"> 341         g_type_add_instance_private (_type, sizeof (GstBaseSinkPrivate));</span>
<span class="line-added"> 342 </span>
 343     g_once_init_leave (&amp;base_sink_type, _type);
 344   }
 345   return base_sink_type;
 346 }
 347 
<a name="8" id="anc8"></a><span class="line-added"> 348 static inline GstBaseSinkPrivate *</span>
<span class="line-added"> 349 gst_base_sink_get_instance_private (GstBaseSink * self)</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 352 }</span>
<span class="line-added"> 353 </span>
 354 static void gst_base_sink_set_property (GObject * object, guint prop_id,
 355     const GValue * value, GParamSpec * pspec);
 356 static void gst_base_sink_get_property (GObject * object, guint prop_id,
 357     GValue * value, GParamSpec * pspec);
 358 
 359 static gboolean gst_base_sink_send_event (GstElement * element,
 360     GstEvent * event);
 361 static gboolean default_element_query (GstElement * element, GstQuery * query);
 362 
 363 static GstCaps *gst_base_sink_default_get_caps (GstBaseSink * sink,
 364     GstCaps * caps);
 365 static gboolean gst_base_sink_default_set_caps (GstBaseSink * sink,
 366     GstCaps * caps);
 367 static void gst_base_sink_default_get_times (GstBaseSink * basesink,
 368     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 369 static gboolean gst_base_sink_set_flushing (GstBaseSink * basesink,
 370     GstPad * pad, gboolean flushing);
 371 static gboolean gst_base_sink_default_activate_pull (GstBaseSink * basesink,
 372     gboolean active);
 373 static gboolean gst_base_sink_default_do_seek (GstBaseSink * sink,
 374     GstSegment * segment);
 375 static gboolean gst_base_sink_default_prepare_seek_segment (GstBaseSink * sink,
 376     GstEvent * event, GstSegment * segment);
 377 
 378 static GstStateChangeReturn gst_base_sink_change_state (GstElement * element,
 379     GstStateChange transition);
 380 
 381 static gboolean gst_base_sink_sink_query (GstPad * pad, GstObject * parent,
 382     GstQuery * query);
 383 static GstFlowReturn gst_base_sink_chain (GstPad * pad, GstObject * parent,
 384     GstBuffer * buffer);
 385 static GstFlowReturn gst_base_sink_chain_list (GstPad * pad, GstObject * parent,
 386     GstBufferList * list);
 387 
 388 static void gst_base_sink_loop (GstPad * pad);
 389 static gboolean gst_base_sink_pad_activate (GstPad * pad, GstObject * parent);
 390 static gboolean gst_base_sink_pad_activate_mode (GstPad * pad,
 391     GstObject * parent, GstPadMode mode, gboolean active);
 392 static gboolean gst_base_sink_default_event (GstBaseSink * basesink,
 393     GstEvent * event);
 394 static GstFlowReturn gst_base_sink_default_wait_event (GstBaseSink * basesink,
 395     GstEvent * event);
 396 static gboolean gst_base_sink_event (GstPad * pad, GstObject * parent,
 397     GstEvent * event);
 398 
 399 static gboolean gst_base_sink_default_query (GstBaseSink * sink,
 400     GstQuery * query);
 401 
 402 static gboolean gst_base_sink_negotiate_pull (GstBaseSink * basesink);
 403 static GstCaps *gst_base_sink_default_fixate (GstBaseSink * bsink,
 404     GstCaps * caps);
 405 static GstCaps *gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps);
 406 
 407 /* check if an object was too late */
 408 static gboolean gst_base_sink_is_too_late (GstBaseSink * basesink,
 409     GstMiniObject * obj, GstClockTime rstart, GstClockTime rstop,
 410     GstClockReturn status, GstClockTimeDiff jitter, gboolean render);
 411 
 412 static void
 413 gst_base_sink_class_init (GstBaseSinkClass * klass)
 414 {
 415   GObjectClass *gobject_class;
 416   GstElementClass *gstelement_class;
 417 
 418   gobject_class = G_OBJECT_CLASS (klass);
 419   gstelement_class = GST_ELEMENT_CLASS (klass);
 420 
<a name="9" id="anc9"></a><span class="line-added"> 421   if (private_offset != 0)</span>
<span class="line-added"> 422     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
<span class="line-added"> 423 </span>
 424   GST_DEBUG_CATEGORY_INIT (gst_base_sink_debug, &quot;basesink&quot;, 0,
 425       &quot;basesink element&quot;);
 426 
<a name="10" id="anc10"></a>

 427   parent_class = g_type_class_peek_parent (klass);
 428 
 429   gobject_class-&gt;finalize = gst_base_sink_finalize;
 430   gobject_class-&gt;set_property = gst_base_sink_set_property;
 431   gobject_class-&gt;get_property = gst_base_sink_get_property;
 432 
 433   g_object_class_install_property (gobject_class, PROP_SYNC,
 434       g_param_spec_boolean (&quot;sync&quot;, &quot;Sync&quot;, &quot;Sync on the clock&quot;, DEFAULT_SYNC,
 435           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 436 
 437   g_object_class_install_property (gobject_class, PROP_MAX_LATENESS,
 438       g_param_spec_int64 (&quot;max-lateness&quot;, &quot;Max Lateness&quot;,
 439           &quot;Maximum number of nanoseconds that a buffer can be late before it &quot;
 440           &quot;is dropped (-1 unlimited)&quot;, -1, G_MAXINT64, DEFAULT_MAX_LATENESS,
 441           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 442 
 443   g_object_class_install_property (gobject_class, PROP_QOS,
 444       g_param_spec_boolean (&quot;qos&quot;, &quot;Qos&quot;,
 445           &quot;Generate Quality-of-Service events upstream&quot;, DEFAULT_QOS,
 446           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 447   /**
 448    * GstBaseSink:async:
 449    *
 450    * If set to %TRUE, the basesink will perform asynchronous state changes.
 451    * When set to %FALSE, the sink will not signal the parent when it prerolls.
 452    * Use this option when dealing with sparse streams or when synchronisation is
 453    * not required.
 454    */
 455   g_object_class_install_property (gobject_class, PROP_ASYNC,
 456       g_param_spec_boolean (&quot;async&quot;, &quot;Async&quot;,
 457           &quot;Go asynchronously to PAUSED&quot;, DEFAULT_ASYNC,
 458           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 459   /**
 460    * GstBaseSink:ts-offset:
 461    *
 462    * Controls the final synchronisation, a negative value will render the buffer
 463    * earlier while a positive value delays playback. This property can be
 464    * used to fix synchronisation in bad files.
 465    */
 466   g_object_class_install_property (gobject_class, PROP_TS_OFFSET,
 467       g_param_spec_int64 (&quot;ts-offset&quot;, &quot;TS Offset&quot;,
 468           &quot;Timestamp offset in nanoseconds&quot;, G_MININT64, G_MAXINT64,
 469           DEFAULT_TS_OFFSET, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 470 
 471   /**
 472    * GstBaseSink:enable-last-sample:
 473    *
 474    * Enable the last-sample property. If %FALSE, basesink doesn&#39;t keep a
 475    * reference to the last buffer arrived and the last-sample property is always
 476    * set to %NULL. This can be useful if you need buffers to be released as soon
 477    * as possible, eg. if you&#39;re using a buffer pool.
 478    */
 479   g_object_class_install_property (gobject_class, PROP_ENABLE_LAST_SAMPLE,
 480       g_param_spec_boolean (&quot;enable-last-sample&quot;, &quot;Enable Last Buffer&quot;,
 481           &quot;Enable the last-sample property&quot;, DEFAULT_ENABLE_LAST_SAMPLE,
 482           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 483 
 484   /**
 485    * GstBaseSink:last-sample:
 486    *
 487    * The last buffer that arrived in the sink and was used for preroll or for
 488    * rendering. This property can be used to generate thumbnails. This property
 489    * can be %NULL when the sink has not yet received a buffer.
 490    */
 491   g_object_class_install_property (gobject_class, PROP_LAST_SAMPLE,
 492       g_param_spec_boxed (&quot;last-sample&quot;, &quot;Last Sample&quot;,
 493           &quot;The last sample received in the sink&quot;, GST_TYPE_SAMPLE,
 494           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 495   /**
 496    * GstBaseSink:blocksize:
 497    *
 498    * The amount of bytes to pull when operating in pull mode.
 499    */
 500   /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
 501   g_object_class_install_property (gobject_class, PROP_BLOCKSIZE,
 502       g_param_spec_uint (&quot;blocksize&quot;, &quot;Block size&quot;,
 503           &quot;Size in bytes to pull per buffer (0 = default)&quot;, 0, G_MAXUINT,
 504           DEFAULT_BLOCKSIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 505   /**
 506    * GstBaseSink:render-delay:
 507    *
 508    * The additional delay between synchronisation and actual rendering of the
 509    * media. This property will add additional latency to the device in order to
 510    * make other sinks compensate for the delay.
 511    */
 512   g_object_class_install_property (gobject_class, PROP_RENDER_DELAY,
 513       g_param_spec_uint64 (&quot;render-delay&quot;, &quot;Render Delay&quot;,
 514           &quot;Additional render delay of the sink in nanoseconds&quot;, 0, G_MAXUINT64,
 515           DEFAULT_RENDER_DELAY, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 516   /**
 517    * GstBaseSink:throttle-time:
 518    *
 519    * The time to insert between buffers. This property can be used to control
 520    * the maximum amount of buffers per second to render. Setting this property
 521    * to a value bigger than 0 will make the sink create THROTTLE QoS events.
 522    */
 523   g_object_class_install_property (gobject_class, PROP_THROTTLE_TIME,
 524       g_param_spec_uint64 (&quot;throttle-time&quot;, &quot;Throttle time&quot;,
 525           &quot;The time to keep between rendered buffers (0 = disabled)&quot;, 0,
 526           G_MAXUINT64, DEFAULT_THROTTLE_TIME,
 527           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 528   /**
 529    * GstBaseSink:max-bitrate:
 530    *
 531    * Control the maximum amount of bits that will be rendered per second.
 532    * Setting this property to a value bigger than 0 will make the sink delay
 533    * rendering of the buffers when it would exceed to max-bitrate.
 534    *
 535    * Since: 1.2
 536    */
 537   g_object_class_install_property (gobject_class, PROP_MAX_BITRATE,
 538       g_param_spec_uint64 (&quot;max-bitrate&quot;, &quot;Max Bitrate&quot;,
 539           &quot;The maximum bits per second to render (0 = disabled)&quot;, 0,
 540           G_MAXUINT64, DEFAULT_MAX_BITRATE,
 541           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
<a name="11" id="anc11"></a><span class="line-added"> 542   /**</span>
<span class="line-added"> 543    * GstBaseSink:processing-deadline:</span>
<span class="line-added"> 544    *</span>
<span class="line-added"> 545    * Maximum amount of time (in nanoseconds) that the pipeline can take</span>
<span class="line-added"> 546    * for processing the buffer. This is added to the latency of live</span>
<span class="line-added"> 547    * pipelines.</span>
<span class="line-added"> 548    *</span>
<span class="line-added"> 549    * Since: 1.16</span>
<span class="line-added"> 550    */</span>
<span class="line-added"> 551   g_object_class_install_property (gobject_class, PROP_PROCESSING_DEADLINE,</span>
<span class="line-added"> 552       g_param_spec_uint64 (&quot;processing-deadline&quot;, &quot;Processing deadline&quot;,</span>
<span class="line-added"> 553           &quot;Maximum processing deadline in nanoseconds&quot;, 0, G_MAXUINT64,</span>
<span class="line-added"> 554           DEFAULT_PROCESSING_DEADLINE,</span>
<span class="line-added"> 555           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span>
 556 
 557   gstelement_class-&gt;change_state =
 558       GST_DEBUG_FUNCPTR (gst_base_sink_change_state);
 559   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_base_sink_send_event);
 560   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (default_element_query);
 561 
 562   klass-&gt;get_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_caps);
 563   klass-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_set_caps);
 564   klass-&gt;fixate = GST_DEBUG_FUNCPTR (gst_base_sink_default_fixate);
 565   klass-&gt;activate_pull =
 566       GST_DEBUG_FUNCPTR (gst_base_sink_default_activate_pull);
 567   klass-&gt;get_times = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_times);
 568   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_sink_default_query);
 569   klass-&gt;event = GST_DEBUG_FUNCPTR (gst_base_sink_default_event);
 570   klass-&gt;wait_event = GST_DEBUG_FUNCPTR (gst_base_sink_default_wait_event);
 571 
 572   /* Registering debug symbols for function pointers */
 573   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_fixate);
 574   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate);
 575   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate_mode);
 576   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_event);
 577   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_chain);
 578   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_chain_list);
 579   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_sink_query);
 580 }
 581 
 582 static GstCaps *
 583 gst_base_sink_query_caps (GstBaseSink * bsink, GstPad * pad, GstCaps * filter)
 584 {
 585   GstBaseSinkClass *bclass;
 586   GstCaps *caps = NULL;
 587   gboolean fixed;
 588 
 589   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 590   fixed = GST_PAD_IS_FIXED_CAPS (pad);
 591 
 592   if (fixed || bsink-&gt;pad_mode == GST_PAD_MODE_PULL) {
 593     /* if we are operating in pull mode or fixed caps, we only accept the
 594      * currently negotiated caps */
 595     caps = gst_pad_get_current_caps (pad);
 596   }
 597   if (caps == NULL) {
 598     if (bclass-&gt;get_caps)
 599       caps = bclass-&gt;get_caps (bsink, filter);
 600 
 601     if (caps == NULL) {
 602       GstPadTemplate *pad_template;
 603 
 604       pad_template =
 605           gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass),
 606           &quot;sink&quot;);
 607       if (pad_template != NULL) {
 608         caps = gst_pad_template_get_caps (pad_template);
 609 
 610         if (filter) {
 611           GstCaps *intersection;
 612 
 613           intersection =
 614               gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
 615           gst_caps_unref (caps);
 616           caps = intersection;
 617         }
 618       }
 619     }
 620   }
 621 
 622   return caps;
 623 }
 624 
 625 static GstCaps *
 626 gst_base_sink_default_fixate (GstBaseSink * bsink, GstCaps * caps)
 627 {
 628   GST_DEBUG_OBJECT (bsink, &quot;using default caps fixate function&quot;);
 629   return gst_caps_fixate (caps);
 630 }
 631 
 632 static GstCaps *
 633 gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
 634 {
 635   GstBaseSinkClass *bclass;
 636 
 637   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 638 
 639   if (bclass-&gt;fixate)
 640     caps = bclass-&gt;fixate (bsink, caps);
 641 
 642   return caps;
 643 }
 644 
 645 static void
 646 gst_base_sink_init (GstBaseSink * basesink, gpointer g_class)
 647 {
 648   GstPadTemplate *pad_template;
 649   GstBaseSinkPrivate *priv;
 650 
<a name="12" id="anc12"></a><span class="line-modified"> 651   basesink-&gt;priv = priv = gst_base_sink_get_instance_private (basesink);</span>
 652 
 653   pad_template =
 654       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 655   g_return_if_fail (pad_template != NULL);
 656 
 657   basesink-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 658 
 659   gst_pad_set_activate_function (basesink-&gt;sinkpad, gst_base_sink_pad_activate);
 660   gst_pad_set_activatemode_function (basesink-&gt;sinkpad,
 661       gst_base_sink_pad_activate_mode);
 662   gst_pad_set_query_function (basesink-&gt;sinkpad, gst_base_sink_sink_query);
 663   gst_pad_set_event_function (basesink-&gt;sinkpad, gst_base_sink_event);
 664   gst_pad_set_chain_function (basesink-&gt;sinkpad, gst_base_sink_chain);
 665   gst_pad_set_chain_list_function (basesink-&gt;sinkpad, gst_base_sink_chain_list);
 666   gst_element_add_pad (GST_ELEMENT_CAST (basesink), basesink-&gt;sinkpad);
 667 
 668   basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
 669   g_mutex_init (&amp;basesink-&gt;preroll_lock);
 670   g_cond_init (&amp;basesink-&gt;preroll_cond);
 671   priv-&gt;have_latency = FALSE;
 672 
 673   basesink-&gt;can_activate_push = DEFAULT_CAN_ACTIVATE_PUSH;
 674   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 675 
 676   basesink-&gt;sync = DEFAULT_SYNC;
 677   basesink-&gt;max_lateness = DEFAULT_MAX_LATENESS;
 678   g_atomic_int_set (&amp;priv-&gt;qos_enabled, DEFAULT_QOS);
 679   priv-&gt;async_enabled = DEFAULT_ASYNC;
 680   priv-&gt;ts_offset = DEFAULT_TS_OFFSET;
 681   priv-&gt;render_delay = DEFAULT_RENDER_DELAY;
<a name="13" id="anc13"></a><span class="line-added"> 682   priv-&gt;processing_deadline = DEFAULT_PROCESSING_DEADLINE;</span>
 683   priv-&gt;blocksize = DEFAULT_BLOCKSIZE;
 684   priv-&gt;cached_clock_id = NULL;
 685   g_atomic_int_set (&amp;priv-&gt;enable_last_sample, DEFAULT_ENABLE_LAST_SAMPLE);
 686   priv-&gt;throttle_time = DEFAULT_THROTTLE_TIME;
 687   priv-&gt;max_bitrate = DEFAULT_MAX_BITRATE;
 688 
 689   priv-&gt;drop_out_of_segment = DEFAULT_DROP_OUT_OF_SEGMENT;
 690 
 691   GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_SINK);
 692 }
 693 
 694 static void
 695 gst_base_sink_finalize (GObject * object)
 696 {
 697   GstBaseSink *basesink;
 698 
 699   basesink = GST_BASE_SINK (object);
 700 
 701   g_mutex_clear (&amp;basesink-&gt;preroll_lock);
 702   g_cond_clear (&amp;basesink-&gt;preroll_cond);
 703 
 704   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 705 }
 706 
 707 /**
 708  * gst_base_sink_set_sync:
 709  * @sink: the sink
 710  * @sync: the new sync value.
 711  *
 712  * Configures @sink to synchronize on the clock or not. When
 713  * @sync is %FALSE, incoming samples will be played as fast as
 714  * possible. If @sync is %TRUE, the timestamps of the incoming
 715  * buffers will be used to schedule the exact render time of its
 716  * contents.
 717  */
 718 void
 719 gst_base_sink_set_sync (GstBaseSink * sink, gboolean sync)
 720 {
 721   g_return_if_fail (GST_IS_BASE_SINK (sink));
 722 
 723   GST_OBJECT_LOCK (sink);
 724   sink-&gt;sync = sync;
 725   GST_OBJECT_UNLOCK (sink);
 726 }
 727 
 728 /**
 729  * gst_base_sink_get_sync:
 730  * @sink: the sink
 731  *
 732  * Checks if @sink is currently configured to synchronize against the
 733  * clock.
 734  *
 735  * Returns: %TRUE if the sink is configured to synchronize against the clock.
 736  */
 737 gboolean
 738 gst_base_sink_get_sync (GstBaseSink * sink)
 739 {
 740   gboolean res;
 741 
 742   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 743 
 744   GST_OBJECT_LOCK (sink);
 745   res = sink-&gt;sync;
 746   GST_OBJECT_UNLOCK (sink);
 747 
 748   return res;
 749 }
 750 
 751 /**
 752  * gst_base_sink_set_drop_out_of_segment:
 753  * @sink: the sink
 754  * @drop_out_of_segment: drop buffers outside the segment
 755  *
 756  * Configure @sink to drop buffers which are outside the current segment
 757  *
 758  * Since: 1.12
 759  */
 760 void
 761 gst_base_sink_set_drop_out_of_segment (GstBaseSink * sink,
 762     gboolean drop_out_of_segment)
 763 {
<a name="14" id="anc14"></a>

 764   g_return_if_fail (GST_IS_BASE_SINK (sink));
 765 
<a name="15" id="anc15"></a>

 766   GST_OBJECT_LOCK (sink);
<a name="16" id="anc16"></a><span class="line-modified"> 767   sink-&gt;priv-&gt;drop_out_of_segment = drop_out_of_segment;</span>
 768   GST_OBJECT_UNLOCK (sink);
 769 
 770 }
 771 
 772 /**
 773  * gst_base_sink_get_drop_out_of_segment:
 774  * @sink: the sink
 775  *
 776  * Checks if @sink is currently configured to drop buffers which are outside
 777  * the current segment
 778  *
 779  * Returns: %TRUE if the sink is configured to drop buffers outside the
 780  * current segment.
 781  *
 782  * Since: 1.12
 783  */
 784 gboolean
 785 gst_base_sink_get_drop_out_of_segment (GstBaseSink * sink)
 786 {
<a name="17" id="anc17"></a>
 787   gboolean res;
 788 
 789   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 790 
<a name="18" id="anc18"></a>

 791   GST_OBJECT_LOCK (sink);
<a name="19" id="anc19"></a><span class="line-modified"> 792   res = sink-&gt;priv-&gt;drop_out_of_segment;</span>
 793   GST_OBJECT_UNLOCK (sink);
 794 
 795   return res;
 796 }
 797 
 798 /**
 799  * gst_base_sink_set_max_lateness:
 800  * @sink: the sink
 801  * @max_lateness: the new max lateness value.
 802  *
 803  * Sets the new max lateness value to @max_lateness. This value is
 804  * used to decide if a buffer should be dropped or not based on the
 805  * buffer timestamp and the current clock time. A value of -1 means
 806  * an unlimited time.
 807  */
 808 void
 809 gst_base_sink_set_max_lateness (GstBaseSink * sink, gint64 max_lateness)
 810 {
 811   g_return_if_fail (GST_IS_BASE_SINK (sink));
 812 
 813   GST_OBJECT_LOCK (sink);
 814   sink-&gt;max_lateness = max_lateness;
 815   GST_OBJECT_UNLOCK (sink);
 816 }
 817 
 818 /**
 819  * gst_base_sink_get_max_lateness:
 820  * @sink: the sink
 821  *
 822  * Gets the max lateness value. See gst_base_sink_set_max_lateness() for
 823  * more details.
 824  *
 825  * Returns: The maximum time in nanoseconds that a buffer can be late
 826  * before it is dropped and not rendered. A value of -1 means an
 827  * unlimited time.
 828  */
 829 gint64
 830 gst_base_sink_get_max_lateness (GstBaseSink * sink)
 831 {
 832   gint64 res;
 833 
 834   g_return_val_if_fail (GST_IS_BASE_SINK (sink), -1);
 835 
 836   GST_OBJECT_LOCK (sink);
 837   res = sink-&gt;max_lateness;
 838   GST_OBJECT_UNLOCK (sink);
 839 
 840   return res;
 841 }
 842 
 843 /**
 844  * gst_base_sink_set_qos_enabled:
 845  * @sink: the sink
 846  * @enabled: the new qos value.
 847  *
 848  * Configures @sink to send Quality-of-Service events upstream.
 849  */
 850 void
 851 gst_base_sink_set_qos_enabled (GstBaseSink * sink, gboolean enabled)
 852 {
 853   g_return_if_fail (GST_IS_BASE_SINK (sink));
 854 
 855   g_atomic_int_set (&amp;sink-&gt;priv-&gt;qos_enabled, enabled);
 856 }
 857 
 858 /**
 859  * gst_base_sink_is_qos_enabled:
 860  * @sink: the sink
 861  *
 862  * Checks if @sink is currently configured to send Quality-of-Service events
 863  * upstream.
 864  *
 865  * Returns: %TRUE if the sink is configured to perform Quality-of-Service.
 866  */
 867 gboolean
 868 gst_base_sink_is_qos_enabled (GstBaseSink * sink)
 869 {
 870   gboolean res;
 871 
 872   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 873 
 874   res = g_atomic_int_get (&amp;sink-&gt;priv-&gt;qos_enabled);
 875 
 876   return res;
 877 }
 878 
 879 /**
 880  * gst_base_sink_set_async_enabled:
 881  * @sink: the sink
 882  * @enabled: the new async value.
 883  *
 884  * Configures @sink to perform all state changes asynchronously. When async is
 885  * disabled, the sink will immediately go to PAUSED instead of waiting for a
 886  * preroll buffer. This feature is useful if the sink does not synchronize
 887  * against the clock or when it is dealing with sparse streams.
 888  */
 889 void
 890 gst_base_sink_set_async_enabled (GstBaseSink * sink, gboolean enabled)
 891 {
 892   g_return_if_fail (GST_IS_BASE_SINK (sink));
 893 
 894   GST_BASE_SINK_PREROLL_LOCK (sink);
 895   g_atomic_int_set (&amp;sink-&gt;priv-&gt;async_enabled, enabled);
 896   GST_LOG_OBJECT (sink, &quot;set async enabled to %d&quot;, enabled);
 897   GST_BASE_SINK_PREROLL_UNLOCK (sink);
 898 }
 899 
 900 /**
 901  * gst_base_sink_is_async_enabled:
 902  * @sink: the sink
 903  *
 904  * Checks if @sink is currently configured to perform asynchronous state
 905  * changes to PAUSED.
 906  *
 907  * Returns: %TRUE if the sink is configured to perform asynchronous state
 908  * changes.
 909  */
 910 gboolean
 911 gst_base_sink_is_async_enabled (GstBaseSink * sink)
 912 {
 913   gboolean res;
 914 
 915   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 916 
 917   res = g_atomic_int_get (&amp;sink-&gt;priv-&gt;async_enabled);
 918 
 919   return res;
 920 }
 921 
 922 /**
 923  * gst_base_sink_set_ts_offset:
 924  * @sink: the sink
 925  * @offset: the new offset
 926  *
 927  * Adjust the synchronisation of @sink with @offset. A negative value will
 928  * render buffers earlier than their timestamp. A positive value will delay
 929  * rendering. This function can be used to fix playback of badly timestamped
 930  * buffers.
 931  */
 932 void
 933 gst_base_sink_set_ts_offset (GstBaseSink * sink, GstClockTimeDiff offset)
 934 {
 935   g_return_if_fail (GST_IS_BASE_SINK (sink));
 936 
 937   GST_OBJECT_LOCK (sink);
 938   sink-&gt;priv-&gt;ts_offset = offset;
 939   GST_LOG_OBJECT (sink, &quot;set time offset to %&quot; G_GINT64_FORMAT, offset);
 940   GST_OBJECT_UNLOCK (sink);
 941 }
 942 
 943 /**
 944  * gst_base_sink_get_ts_offset:
 945  * @sink: the sink
 946  *
 947  * Get the synchronisation offset of @sink.
 948  *
 949  * Returns: The synchronisation offset.
 950  */
 951 GstClockTimeDiff
 952 gst_base_sink_get_ts_offset (GstBaseSink * sink)
 953 {
 954   GstClockTimeDiff res;
 955 
 956   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
 957 
 958   GST_OBJECT_LOCK (sink);
 959   res = sink-&gt;priv-&gt;ts_offset;
 960   GST_OBJECT_UNLOCK (sink);
 961 
 962   return res;
 963 }
 964 
 965 /**
 966  * gst_base_sink_get_last_sample:
 967  * @sink: the sink
 968  *
 969  * Get the last sample that arrived in the sink and was used for preroll or for
 970  * rendering. This property can be used to generate thumbnails.
 971  *
 972  * The #GstCaps on the sample can be used to determine the type of the buffer.
 973  *
 974  * Free-function: gst_sample_unref
 975  *
 976  * Returns: (transfer full) (nullable): a #GstSample. gst_sample_unref() after
 977  *     usage.  This function returns %NULL when no buffer has arrived in the
 978  *     sink yet or when the sink is not in PAUSED or PLAYING.
 979  */
 980 GstSample *
 981 gst_base_sink_get_last_sample (GstBaseSink * sink)
 982 {
 983   GstSample *res = NULL;
 984 
 985   g_return_val_if_fail (GST_IS_BASE_SINK (sink), NULL);
 986 
 987   GST_OBJECT_LOCK (sink);
 988   if (sink-&gt;priv-&gt;last_buffer_list) {
 989     GstBuffer *first_buffer = NULL;
 990 
 991     /* Set the first buffer in the list to last sample&#39;s buffer */
 992     first_buffer = gst_buffer_list_get (sink-&gt;priv-&gt;last_buffer_list, 0);
 993     res =
 994         gst_sample_new (first_buffer, sink-&gt;priv-&gt;last_caps, &amp;sink-&gt;segment,
 995         NULL);
 996     gst_sample_set_buffer_list (res, sink-&gt;priv-&gt;last_buffer_list);
 997   } else if (sink-&gt;priv-&gt;last_buffer) {
 998     res = gst_sample_new (sink-&gt;priv-&gt;last_buffer,
 999         sink-&gt;priv-&gt;last_caps, &amp;sink-&gt;segment, NULL);
1000   }
1001   GST_OBJECT_UNLOCK (sink);
1002 
1003   return res;
1004 }
1005 
1006 /* with OBJECT_LOCK */
1007 static void
1008 gst_base_sink_set_last_buffer_unlocked (GstBaseSink * sink, GstBuffer * buffer)
1009 {
1010   GstBuffer *old;
1011 
1012   old = sink-&gt;priv-&gt;last_buffer;
1013   if (G_LIKELY (old != buffer)) {
1014     GST_DEBUG_OBJECT (sink, &quot;setting last buffer to %p&quot;, buffer);
1015     if (G_LIKELY (buffer))
1016       gst_buffer_ref (buffer);
1017     sink-&gt;priv-&gt;last_buffer = buffer;
1018     if (buffer)
1019       /* copy over the caps */
1020       gst_caps_replace (&amp;sink-&gt;priv-&gt;last_caps, sink-&gt;priv-&gt;caps);
1021     else
1022       gst_caps_replace (&amp;sink-&gt;priv-&gt;last_caps, NULL);
1023   } else {
1024     old = NULL;
1025   }
1026   /* avoid unreffing with the lock because cleanup code might want to take the
1027    * lock too */
1028   if (G_LIKELY (old)) {
1029     GST_OBJECT_UNLOCK (sink);
1030     gst_buffer_unref (old);
1031     GST_OBJECT_LOCK (sink);
1032   }
1033 }
1034 
1035 /* with OBJECT_LOCK */
1036 static void
1037 gst_base_sink_set_last_buffer_list_unlocked (GstBaseSink * sink,
1038     GstBufferList * buffer_list)
1039 {
1040   GstBufferList *old;
1041 
1042   old = sink-&gt;priv-&gt;last_buffer_list;
1043   if (G_LIKELY (old != buffer_list)) {
1044     GST_DEBUG_OBJECT (sink, &quot;setting last buffer list to %p&quot;, buffer_list);
1045     if (G_LIKELY (buffer_list))
1046       gst_mini_object_ref (GST_MINI_OBJECT_CAST (buffer_list));
1047     sink-&gt;priv-&gt;last_buffer_list = buffer_list;
1048   } else {
1049     old = NULL;
1050   }
1051 
1052   /* avoid unreffing with the lock because cleanup code might want to take the
1053    * lock too */
1054   if (G_LIKELY (old)) {
1055     GST_OBJECT_UNLOCK (sink);
1056     gst_mini_object_unref (GST_MINI_OBJECT_CAST (old));
1057     GST_OBJECT_LOCK (sink);
1058   }
1059 }
1060 
1061 static void
1062 gst_base_sink_set_last_buffer (GstBaseSink * sink, GstBuffer * buffer)
1063 {
1064   if (!g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample))
1065     return;
1066 
1067   GST_OBJECT_LOCK (sink);
1068   gst_base_sink_set_last_buffer_unlocked (sink, buffer);
1069   GST_OBJECT_UNLOCK (sink);
1070 }
1071 
1072 static void
1073 gst_base_sink_set_last_buffer_list (GstBaseSink * sink,
1074     GstBufferList * buffer_list)
1075 {
1076   if (!g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample))
1077     return;
1078 
1079   GST_OBJECT_LOCK (sink);
1080   gst_base_sink_set_last_buffer_list_unlocked (sink, buffer_list);
1081   GST_OBJECT_UNLOCK (sink);
1082 }
1083 
1084 /**
1085  * gst_base_sink_set_last_sample_enabled:
1086  * @sink: the sink
1087  * @enabled: the new enable-last-sample value.
1088  *
1089  * Configures @sink to store the last received sample in the last-sample
1090  * property.
1091  */
1092 void
1093 gst_base_sink_set_last_sample_enabled (GstBaseSink * sink, gboolean enabled)
1094 {
1095   g_return_if_fail (GST_IS_BASE_SINK (sink));
1096 
1097   /* Only take lock if we change the value */
1098   if (g_atomic_int_compare_and_exchange (&amp;sink-&gt;priv-&gt;enable_last_sample,
1099           !enabled, enabled) &amp;&amp; !enabled) {
1100     GST_OBJECT_LOCK (sink);
1101     gst_base_sink_set_last_buffer_unlocked (sink, NULL);
1102     gst_base_sink_set_last_buffer_list_unlocked (sink, NULL);
1103     GST_OBJECT_UNLOCK (sink);
1104   }
1105 }
1106 
1107 /**
1108  * gst_base_sink_is_last_sample_enabled:
1109  * @sink: the sink
1110  *
1111  * Checks if @sink is currently configured to store the last received sample in
1112  * the last-sample property.
1113  *
1114  * Returns: %TRUE if the sink is configured to store the last received sample.
1115  */
1116 gboolean
1117 gst_base_sink_is_last_sample_enabled (GstBaseSink * sink)
1118 {
1119   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
1120 
1121   return g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample);
1122 }
1123 
1124 /**
1125  * gst_base_sink_get_latency:
1126  * @sink: the sink
1127  *
1128  * Get the currently configured latency.
1129  *
1130  * Returns: The configured latency.
1131  */
1132 GstClockTime
1133 gst_base_sink_get_latency (GstBaseSink * sink)
1134 {
1135   GstClockTime res;
1136 
1137   GST_OBJECT_LOCK (sink);
1138   res = sink-&gt;priv-&gt;latency;
1139   GST_OBJECT_UNLOCK (sink);
1140 
1141   return res;
1142 }
1143 
1144 /**
1145  * gst_base_sink_query_latency:
1146  * @sink: the sink
1147  * @live: (out) (allow-none): if the sink is live
1148  * @upstream_live: (out) (allow-none): if an upstream element is live
1149  * @min_latency: (out) (allow-none): the min latency of the upstream elements
1150  * @max_latency: (out) (allow-none): the max latency of the upstream elements
1151  *
1152  * Query the sink for the latency parameters. The latency will be queried from
1153  * the upstream elements. @live will be %TRUE if @sink is configured to
1154  * synchronize against the clock. @upstream_live will be %TRUE if an upstream
1155  * element is live.
1156  *
1157  * If both @live and @upstream_live are %TRUE, the sink will want to compensate
1158  * for the latency introduced by the upstream elements by setting the
1159  * @min_latency to a strictly positive value.
1160  *
1161  * This function is mostly used by subclasses.
1162  *
1163  * Returns: %TRUE if the query succeeded.
1164  */
1165 gboolean
1166 gst_base_sink_query_latency (GstBaseSink * sink, gboolean * live,
1167     gboolean * upstream_live, GstClockTime * min_latency,
1168     GstClockTime * max_latency)
1169 {
1170   gboolean l, us_live, res, have_latency;
<a name="20" id="anc20"></a><span class="line-modified">1171   GstClockTime min, max, render_delay, processing_deadline;</span>
1172   GstQuery *query;
1173   GstClockTime us_min, us_max;
1174 
1175   /* we are live when we sync to the clock */
1176   GST_OBJECT_LOCK (sink);
1177   l = sink-&gt;sync;
1178   have_latency = sink-&gt;priv-&gt;have_latency;
1179   render_delay = sink-&gt;priv-&gt;render_delay;
<a name="21" id="anc21"></a><span class="line-added">1180   processing_deadline = sink-&gt;priv-&gt;processing_deadline;</span>
1181   GST_OBJECT_UNLOCK (sink);
1182 
1183   /* assume no latency */
1184   min = 0;
1185   max = -1;
1186   us_live = FALSE;
1187 
1188   if (have_latency) {
1189     GST_DEBUG_OBJECT (sink, &quot;we are ready for LATENCY query&quot;);
1190     /* we are ready for a latency query this is when we preroll or when we are
1191      * not async. */
1192     query = gst_query_new_latency ();
1193 
1194     /* ask the peer for the latency */
1195     if ((res = gst_pad_peer_query (sink-&gt;sinkpad, query))) {
1196       /* get upstream min and max latency */
1197       gst_query_parse_latency (query, &amp;us_live, &amp;us_min, &amp;us_max);
1198 
1199       if (us_live) {
1200         /* upstream live, use its latency, subclasses should use these
1201          * values to create the complete latency. */
1202         min = us_min;
1203         max = us_max;
<a name="22" id="anc22"></a><span class="line-added">1204 </span>
<span class="line-added">1205         if (l) {</span>
<span class="line-added">1206           if (max == -1 || min + processing_deadline &lt;= max)</span>
<span class="line-added">1207             min += processing_deadline;</span>
<span class="line-added">1208           else {</span>
<span class="line-added">1209             GST_ELEMENT_WARNING (sink, CORE, CLOCK,</span>
<span class="line-added">1210                 (_(&quot;Pipeline construction is invalid, please add queues.&quot;)),</span>
<span class="line-added">1211                 (&quot;Not enough buffering available for &quot;</span>
<span class="line-added">1212                     &quot; the processing deadline of %&quot; GST_TIME_FORMAT</span>
<span class="line-added">1213                     &quot;, add enough queues to buffer  %&quot; GST_TIME_FORMAT</span>
<span class="line-added">1214                     &quot; additional data. Shortening processing latency to %&quot;</span>
<span class="line-added">1215                     GST_TIME_FORMAT &quot;.&quot;,</span>
<span class="line-added">1216                     GST_TIME_ARGS (processing_deadline),</span>
<span class="line-added">1217                     GST_TIME_ARGS (min + processing_deadline - max),</span>
<span class="line-added">1218                     GST_TIME_ARGS (max - min)));</span>
<span class="line-added">1219             min = max;</span>
<span class="line-added">1220           }</span>
<span class="line-added">1221         }</span>
1222       }
1223       if (l) {
1224         /* we need to add the render delay if we are live */
1225         min += render_delay;
1226         if (max != -1)
1227           max += render_delay;
1228       }
1229     }
1230     gst_query_unref (query);
1231   } else {
1232     GST_DEBUG_OBJECT (sink, &quot;we are not yet ready for LATENCY query&quot;);
1233     res = FALSE;
1234   }
1235 
1236   /* not live, we tried to do the query, if it failed we return TRUE anyway */
1237   if (!res) {
1238     if (!l) {
1239       res = TRUE;
1240       GST_DEBUG_OBJECT (sink, &quot;latency query failed but we are not live&quot;);
1241     } else {
1242       GST_DEBUG_OBJECT (sink, &quot;latency query failed and we are live&quot;);
1243     }
1244   }
1245 
1246   if (res) {
1247     GST_DEBUG_OBJECT (sink, &quot;latency query: live: %d, have_latency %d,&quot;
1248         &quot; upstream: %d, min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT, l,
1249         have_latency, us_live, GST_TIME_ARGS (min), GST_TIME_ARGS (max));
1250 
1251     if (live)
1252       *live = l;
1253     if (upstream_live)
1254       *upstream_live = us_live;
1255     if (min_latency)
1256       *min_latency = min;
1257     if (max_latency)
1258       *max_latency = max;
1259   }
1260   return res;
1261 }
1262 
1263 /**
1264  * gst_base_sink_set_render_delay:
1265  * @sink: a #GstBaseSink
1266  * @delay: the new delay
1267  *
1268  * Set the render delay in @sink to @delay. The render delay is the time
1269  * between actual rendering of a buffer and its synchronisation time. Some
1270  * devices might delay media rendering which can be compensated for with this
1271  * function.
1272  *
1273  * After calling this function, this sink will report additional latency and
1274  * other sinks will adjust their latency to delay the rendering of their media.
1275  *
1276  * This function is usually called by subclasses.
1277  */
1278 void
1279 gst_base_sink_set_render_delay (GstBaseSink * sink, GstClockTime delay)
1280 {
1281   GstClockTime old_render_delay;
1282 
1283   g_return_if_fail (GST_IS_BASE_SINK (sink));
1284 
1285   GST_OBJECT_LOCK (sink);
1286   old_render_delay = sink-&gt;priv-&gt;render_delay;
1287   sink-&gt;priv-&gt;render_delay = delay;
1288   GST_LOG_OBJECT (sink, &quot;set render delay to %&quot; GST_TIME_FORMAT,
1289       GST_TIME_ARGS (delay));
1290   GST_OBJECT_UNLOCK (sink);
1291 
1292   if (delay != old_render_delay) {
1293     GST_DEBUG_OBJECT (sink, &quot;posting latency changed&quot;);
1294     gst_element_post_message (GST_ELEMENT_CAST (sink),
1295         gst_message_new_latency (GST_OBJECT_CAST (sink)));
1296   }
1297 }
1298 
1299 /**
1300  * gst_base_sink_get_render_delay:
1301  * @sink: a #GstBaseSink
1302  *
1303  * Get the render delay of @sink. see gst_base_sink_set_render_delay() for more
1304  * information about the render delay.
1305  *
1306  * Returns: the render delay of @sink.
1307  */
1308 GstClockTime
1309 gst_base_sink_get_render_delay (GstBaseSink * sink)
1310 {
1311   GstClockTimeDiff res;
1312 
1313   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1314 
1315   GST_OBJECT_LOCK (sink);
1316   res = sink-&gt;priv-&gt;render_delay;
1317   GST_OBJECT_UNLOCK (sink);
1318 
1319   return res;
1320 }
1321 
1322 /**
1323  * gst_base_sink_set_blocksize:
1324  * @sink: a #GstBaseSink
1325  * @blocksize: the blocksize in bytes
1326  *
1327  * Set the number of bytes that the sink will pull when it is operating in pull
1328  * mode.
1329  */
1330 /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
1331 void
1332 gst_base_sink_set_blocksize (GstBaseSink * sink, guint blocksize)
1333 {
1334   g_return_if_fail (GST_IS_BASE_SINK (sink));
1335 
1336   GST_OBJECT_LOCK (sink);
1337   sink-&gt;priv-&gt;blocksize = blocksize;
1338   GST_LOG_OBJECT (sink, &quot;set blocksize to %u&quot;, blocksize);
1339   GST_OBJECT_UNLOCK (sink);
1340 }
1341 
1342 /**
1343  * gst_base_sink_get_blocksize:
1344  * @sink: a #GstBaseSink
1345  *
1346  * Get the number of bytes that the sink will pull when it is operating in pull
1347  * mode.
1348  *
1349  * Returns: the number of bytes @sink will pull in pull mode.
1350  */
1351 /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
1352 guint
1353 gst_base_sink_get_blocksize (GstBaseSink * sink)
1354 {
1355   guint res;
1356 
1357   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1358 
1359   GST_OBJECT_LOCK (sink);
1360   res = sink-&gt;priv-&gt;blocksize;
1361   GST_OBJECT_UNLOCK (sink);
1362 
1363   return res;
1364 }
1365 
1366 /**
1367  * gst_base_sink_set_throttle_time:
1368  * @sink: a #GstBaseSink
1369  * @throttle: the throttle time in nanoseconds
1370  *
1371  * Set the time that will be inserted between rendered buffers. This
1372  * can be used to control the maximum buffers per second that the sink
1373  * will render.
1374  */
1375 void
1376 gst_base_sink_set_throttle_time (GstBaseSink * sink, guint64 throttle)
1377 {
1378   g_return_if_fail (GST_IS_BASE_SINK (sink));
1379 
1380   GST_OBJECT_LOCK (sink);
1381   sink-&gt;priv-&gt;throttle_time = throttle;
1382   GST_LOG_OBJECT (sink, &quot;set throttle_time to %&quot; G_GUINT64_FORMAT, throttle);
1383   GST_OBJECT_UNLOCK (sink);
1384 }
1385 
1386 /**
1387  * gst_base_sink_get_throttle_time:
1388  * @sink: a #GstBaseSink
1389  *
1390  * Get the time that will be inserted between frames to control the
1391  * maximum buffers per second.
1392  *
1393  * Returns: the number of nanoseconds @sink will put between frames.
1394  */
1395 guint64
1396 gst_base_sink_get_throttle_time (GstBaseSink * sink)
1397 {
1398   guint64 res;
1399 
1400   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1401 
1402   GST_OBJECT_LOCK (sink);
1403   res = sink-&gt;priv-&gt;throttle_time;
1404   GST_OBJECT_UNLOCK (sink);
1405 
1406   return res;
1407 }
1408 
1409 /**
1410  * gst_base_sink_set_max_bitrate:
1411  * @sink: a #GstBaseSink
1412  * @max_bitrate: the max_bitrate in bits per second
1413  *
1414  * Set the maximum amount of bits per second that the sink will render.
1415  *
1416  * Since: 1.2
1417  */
1418 void
1419 gst_base_sink_set_max_bitrate (GstBaseSink * sink, guint64 max_bitrate)
1420 {
1421   g_return_if_fail (GST_IS_BASE_SINK (sink));
1422 
1423   GST_OBJECT_LOCK (sink);
1424   sink-&gt;priv-&gt;max_bitrate = max_bitrate;
1425   GST_LOG_OBJECT (sink, &quot;set max_bitrate to %&quot; G_GUINT64_FORMAT, max_bitrate);
1426   GST_OBJECT_UNLOCK (sink);
1427 }
1428 
1429 /**
1430  * gst_base_sink_get_max_bitrate:
1431  * @sink: a #GstBaseSink
1432  *
1433  * Get the maximum amount of bits per second that the sink will render.
1434  *
1435  * Returns: the maximum number of bits per second @sink will render.
1436  *
1437  * Since: 1.2
1438  */
1439 guint64
1440 gst_base_sink_get_max_bitrate (GstBaseSink * sink)
1441 {
1442   guint64 res;
1443 
1444   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1445 
1446   GST_OBJECT_LOCK (sink);
1447   res = sink-&gt;priv-&gt;max_bitrate;
1448   GST_OBJECT_UNLOCK (sink);
1449 
1450   return res;
1451 }
1452 
<a name="23" id="anc23"></a><span class="line-added">1453 /**</span>
<span class="line-added">1454  * gst_base_sink_set_processing_deadline:</span>
<span class="line-added">1455  * @sink: a #GstBaseSink</span>
<span class="line-added">1456  * @processing_deadline: the new processing deadline in nanoseconds.</span>
<span class="line-added">1457  *</span>
<span class="line-added">1458  * Maximum amount of time (in nanoseconds) that the pipeline can take</span>
<span class="line-added">1459  * for processing the buffer. This is added to the latency of live</span>
<span class="line-added">1460  * pipelines.</span>
<span class="line-added">1461  *</span>
<span class="line-added">1462  * This function is usually called by subclasses.</span>
<span class="line-added">1463  *</span>
<span class="line-added">1464  * Since: 1.16</span>
<span class="line-added">1465  */</span>
<span class="line-added">1466 void</span>
<span class="line-added">1467 gst_base_sink_set_processing_deadline (GstBaseSink * sink,</span>
<span class="line-added">1468     GstClockTime processing_deadline)</span>
<span class="line-added">1469 {</span>
<span class="line-added">1470   GstClockTime old_processing_deadline;</span>
<span class="line-added">1471 </span>
<span class="line-added">1472   g_return_if_fail (GST_IS_BASE_SINK (sink));</span>
<span class="line-added">1473 </span>
<span class="line-added">1474   GST_OBJECT_LOCK (sink);</span>
<span class="line-added">1475   old_processing_deadline = sink-&gt;priv-&gt;processing_deadline;</span>
<span class="line-added">1476   sink-&gt;priv-&gt;processing_deadline = processing_deadline;</span>
<span class="line-added">1477   GST_LOG_OBJECT (sink, &quot;set render processing_deadline to %&quot; GST_TIME_FORMAT,</span>
<span class="line-added">1478       GST_TIME_ARGS (processing_deadline));</span>
<span class="line-added">1479   GST_OBJECT_UNLOCK (sink);</span>
<span class="line-added">1480 </span>
<span class="line-added">1481   if (processing_deadline != old_processing_deadline) {</span>
<span class="line-added">1482     GST_DEBUG_OBJECT (sink, &quot;posting latency changed&quot;);</span>
<span class="line-added">1483     gst_element_post_message (GST_ELEMENT_CAST (sink),</span>
<span class="line-added">1484         gst_message_new_latency (GST_OBJECT_CAST (sink)));</span>
<span class="line-added">1485   }</span>
<span class="line-added">1486 }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488 /**</span>
<span class="line-added">1489  * gst_base_sink_get_processing_deadline:</span>
<span class="line-added">1490  * @sink: a #GstBaseSink</span>
<span class="line-added">1491  *</span>
<span class="line-added">1492  * Get the processing deadline of @sink. see</span>
<span class="line-added">1493  * gst_base_sink_set_processing_deadline() for more information about</span>
<span class="line-added">1494  * the processing deadline.</span>
<span class="line-added">1495  *</span>
<span class="line-added">1496  * Returns: the processing deadline</span>
<span class="line-added">1497  *</span>
<span class="line-added">1498  * Since: 1.16</span>
<span class="line-added">1499  */</span>
<span class="line-added">1500 GstClockTime</span>
<span class="line-added">1501 gst_base_sink_get_processing_deadline (GstBaseSink * sink)</span>
<span class="line-added">1502 {</span>
<span class="line-added">1503   GstClockTimeDiff res;</span>
<span class="line-added">1504 </span>
<span class="line-added">1505   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);</span>
<span class="line-added">1506 </span>
<span class="line-added">1507   GST_OBJECT_LOCK (sink);</span>
<span class="line-added">1508   res = sink-&gt;priv-&gt;processing_deadline;</span>
<span class="line-added">1509   GST_OBJECT_UNLOCK (sink);</span>
<span class="line-added">1510 </span>
<span class="line-added">1511   return res;</span>
<span class="line-added">1512 }</span>
<span class="line-added">1513 </span>
1514 static void
1515 gst_base_sink_set_property (GObject * object, guint prop_id,
1516     const GValue * value, GParamSpec * pspec)
1517 {
1518   GstBaseSink *sink = GST_BASE_SINK (object);
1519 
1520   switch (prop_id) {
1521     case PROP_SYNC:
1522       gst_base_sink_set_sync (sink, g_value_get_boolean (value));
1523       break;
1524     case PROP_MAX_LATENESS:
1525       gst_base_sink_set_max_lateness (sink, g_value_get_int64 (value));
1526       break;
1527     case PROP_QOS:
1528       gst_base_sink_set_qos_enabled (sink, g_value_get_boolean (value));
1529       break;
1530     case PROP_ASYNC:
1531       gst_base_sink_set_async_enabled (sink, g_value_get_boolean (value));
1532       break;
1533     case PROP_TS_OFFSET:
1534       gst_base_sink_set_ts_offset (sink, g_value_get_int64 (value));
1535       break;
1536     case PROP_BLOCKSIZE:
1537       gst_base_sink_set_blocksize (sink, g_value_get_uint (value));
1538       break;
1539     case PROP_RENDER_DELAY:
1540       gst_base_sink_set_render_delay (sink, g_value_get_uint64 (value));
1541       break;
1542     case PROP_ENABLE_LAST_SAMPLE:
1543       gst_base_sink_set_last_sample_enabled (sink, g_value_get_boolean (value));
1544       break;
1545     case PROP_THROTTLE_TIME:
1546       gst_base_sink_set_throttle_time (sink, g_value_get_uint64 (value));
1547       break;
1548     case PROP_MAX_BITRATE:
1549       gst_base_sink_set_max_bitrate (sink, g_value_get_uint64 (value));
1550       break;
<a name="24" id="anc24"></a><span class="line-added">1551     case PROP_PROCESSING_DEADLINE:</span>
<span class="line-added">1552       gst_base_sink_set_processing_deadline (sink, g_value_get_uint64 (value));</span>
<span class="line-added">1553       break;</span>
1554     default:
1555       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1556       break;
1557   }
1558 }
1559 
1560 static void
1561 gst_base_sink_get_property (GObject * object, guint prop_id, GValue * value,
1562     GParamSpec * pspec)
1563 {
1564   GstBaseSink *sink = GST_BASE_SINK (object);
1565 
1566   switch (prop_id) {
1567     case PROP_SYNC:
1568       g_value_set_boolean (value, gst_base_sink_get_sync (sink));
1569       break;
1570     case PROP_MAX_LATENESS:
1571       g_value_set_int64 (value, gst_base_sink_get_max_lateness (sink));
1572       break;
1573     case PROP_QOS:
1574       g_value_set_boolean (value, gst_base_sink_is_qos_enabled (sink));
1575       break;
1576     case PROP_ASYNC:
1577       g_value_set_boolean (value, gst_base_sink_is_async_enabled (sink));
1578       break;
1579     case PROP_TS_OFFSET:
1580       g_value_set_int64 (value, gst_base_sink_get_ts_offset (sink));
1581       break;
1582     case PROP_LAST_SAMPLE:
1583       gst_value_take_sample (value, gst_base_sink_get_last_sample (sink));
1584       break;
1585     case PROP_ENABLE_LAST_SAMPLE:
1586       g_value_set_boolean (value, gst_base_sink_is_last_sample_enabled (sink));
1587       break;
1588     case PROP_BLOCKSIZE:
1589       g_value_set_uint (value, gst_base_sink_get_blocksize (sink));
1590       break;
1591     case PROP_RENDER_DELAY:
1592       g_value_set_uint64 (value, gst_base_sink_get_render_delay (sink));
1593       break;
1594     case PROP_THROTTLE_TIME:
1595       g_value_set_uint64 (value, gst_base_sink_get_throttle_time (sink));
1596       break;
1597     case PROP_MAX_BITRATE:
1598       g_value_set_uint64 (value, gst_base_sink_get_max_bitrate (sink));
1599       break;
<a name="25" id="anc25"></a><span class="line-added">1600     case PROP_PROCESSING_DEADLINE:</span>
<span class="line-added">1601       g_value_set_uint64 (value, gst_base_sink_get_processing_deadline (sink));</span>
<span class="line-added">1602       break;</span>
1603     default:
1604       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1605       break;
1606   }
1607 }
1608 
1609 
1610 static GstCaps *
1611 gst_base_sink_default_get_caps (GstBaseSink * sink, GstCaps * filter)
1612 {
1613   return NULL;
1614 }
1615 
1616 static gboolean
1617 gst_base_sink_default_set_caps (GstBaseSink * sink, GstCaps * caps)
1618 {
1619   return TRUE;
1620 }
1621 
1622 /* with PREROLL_LOCK, STREAM_LOCK */
1623 static gboolean
1624 gst_base_sink_commit_state (GstBaseSink * basesink)
1625 {
1626   /* commit state and proceed to next pending state */
1627   GstState current, next, pending, post_pending;
1628   gboolean post_paused = FALSE;
1629   gboolean post_async_done = FALSE;
1630   gboolean post_playing = FALSE;
1631 
1632   /* we are certainly not playing async anymore now */
1633   basesink-&gt;playing_async = FALSE;
1634 
1635   GST_OBJECT_LOCK (basesink);
1636   current = GST_STATE (basesink);
1637   next = GST_STATE_NEXT (basesink);
1638   pending = GST_STATE_PENDING (basesink);
1639   post_pending = pending;
1640 
1641   switch (pending) {
1642     case GST_STATE_PLAYING:
1643     {
<a name="26" id="anc26"></a><span class="line-modified">1644       GST_DEBUG_OBJECT (basesink, &quot;committing state to PLAYING&quot;);</span>
1645 
1646       basesink-&gt;need_preroll = FALSE;
1647       post_async_done = TRUE;
<a name="27" id="anc27"></a><span class="line-modified">1648       basesink-&gt;priv-&gt;committed = TRUE;</span>
1649       post_playing = TRUE;
1650       /* post PAUSED too when we were READY */
1651       if (current == GST_STATE_READY) {
1652         post_paused = TRUE;
1653       }
1654       break;
1655     }
1656     case GST_STATE_PAUSED:
<a name="28" id="anc28"></a><span class="line-modified">1657       GST_DEBUG_OBJECT (basesink, &quot;committing state to PAUSED&quot;);</span>
1658       post_paused = TRUE;
1659       post_async_done = TRUE;
<a name="29" id="anc29"></a><span class="line-modified">1660       basesink-&gt;priv-&gt;committed = TRUE;</span>
1661       post_pending = GST_STATE_VOID_PENDING;
1662       break;
1663     case GST_STATE_READY:
1664     case GST_STATE_NULL:
1665       goto stopping;
1666     case GST_STATE_VOID_PENDING:
1667       goto nothing_pending;
1668     default:
1669       break;
1670   }
1671 
1672   /* we can report latency queries now */
1673   basesink-&gt;priv-&gt;have_latency = TRUE;
1674 
1675   GST_STATE (basesink) = pending;
1676   GST_STATE_NEXT (basesink) = GST_STATE_VOID_PENDING;
1677   GST_STATE_PENDING (basesink) = GST_STATE_VOID_PENDING;
1678   GST_STATE_RETURN (basesink) = GST_STATE_CHANGE_SUCCESS;
1679   GST_OBJECT_UNLOCK (basesink);
1680 
1681   if (post_paused) {
1682     GST_DEBUG_OBJECT (basesink, &quot;posting PAUSED state change message&quot;);
1683     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1684         gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
1685             current, next, post_pending));
1686   }
1687   if (post_async_done) {
1688     GST_DEBUG_OBJECT (basesink, &quot;posting async-done message&quot;);
1689     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1690         gst_message_new_async_done (GST_OBJECT_CAST (basesink),
1691             GST_CLOCK_TIME_NONE));
1692   }
1693   if (post_playing) {
1694     if (post_paused) {
1695       GstElementClass *klass;
1696 
1697       klass = GST_ELEMENT_GET_CLASS (basesink);
1698       basesink-&gt;have_preroll = TRUE;
1699       /* after releasing this lock, the state change function
1700        * can execute concurrently with this thread. There is nothing we do to
1701        * prevent this for now. subclasses should be prepared to handle it. */
1702       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
1703 
1704       if (klass-&gt;change_state)
1705         klass-&gt;change_state (GST_ELEMENT_CAST (basesink),
1706             GST_STATE_CHANGE_PAUSED_TO_PLAYING);
1707 
1708       GST_BASE_SINK_PREROLL_LOCK (basesink);
1709       /* state change function could have been executed and we could be
1710        * flushing now */
1711       if (G_UNLIKELY (basesink-&gt;flushing))
1712         goto stopping_unlocked;
1713     }
1714     GST_DEBUG_OBJECT (basesink, &quot;posting PLAYING state change message&quot;);
1715     /* FIXME, we released the PREROLL lock above, it&#39;s possible that this
1716      * message is not correct anymore when the element went back to PAUSED */
1717     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1718         gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
1719             next, pending, GST_STATE_VOID_PENDING));
1720   }
1721 
1722   GST_STATE_BROADCAST (basesink);
1723 
1724   return TRUE;
1725 
1726 nothing_pending:
1727   {
1728     /* Depending on the state, set our vars. We get in this situation when the
1729      * state change function got a change to update the state vars before the
1730      * streaming thread did. This is fine but we need to make sure that we
1731      * update the need_preroll var since it was %TRUE when we got here and might
1732      * become %FALSE if we got to PLAYING. */
1733     GST_DEBUG_OBJECT (basesink, &quot;nothing to commit, now in %s&quot;,
1734         gst_element_state_get_name (current));
1735     switch (current) {
1736       case GST_STATE_PLAYING:
1737         basesink-&gt;need_preroll = FALSE;
1738         break;
1739       case GST_STATE_PAUSED:
1740         basesink-&gt;need_preroll = TRUE;
1741         break;
1742       default:
1743         basesink-&gt;need_preroll = FALSE;
1744         basesink-&gt;flushing = TRUE;
1745         break;
1746     }
1747     /* we can report latency queries now */
1748     basesink-&gt;priv-&gt;have_latency = TRUE;
1749     GST_OBJECT_UNLOCK (basesink);
1750     return TRUE;
1751   }
1752 stopping_unlocked:
1753   {
1754     GST_OBJECT_LOCK (basesink);
1755     goto stopping;
1756   }
1757 stopping:
1758   {
1759     /* app is going to READY */
1760     GST_DEBUG_OBJECT (basesink, &quot;stopping&quot;);
1761     basesink-&gt;need_preroll = FALSE;
1762     basesink-&gt;flushing = TRUE;
1763     GST_OBJECT_UNLOCK (basesink);
1764     return FALSE;
1765   }
1766 }
1767 
1768 static void
1769 start_stepping (GstBaseSink * sink, GstSegment * segment,
1770     GstStepInfo * pending, GstStepInfo * current)
1771 {
1772   gint64 end;
1773   GstMessage *message;
1774 
1775   GST_DEBUG_OBJECT (sink, &quot;update pending step&quot;);
1776 
1777   GST_OBJECT_LOCK (sink);
1778   memcpy (current, pending, sizeof (GstStepInfo));
1779   pending-&gt;valid = FALSE;
1780   GST_OBJECT_UNLOCK (sink);
1781 
1782   /* post message first */
1783   message =
1784       gst_message_new_step_start (GST_OBJECT (sink), TRUE, current-&gt;format,
1785       current-&gt;amount, current-&gt;rate, current-&gt;flush, current-&gt;intermediate);
1786   gst_message_set_seqnum (message, current-&gt;seqnum);
1787   gst_element_post_message (GST_ELEMENT (sink), message);
1788 
1789   /* get the running time of where we paused and remember it */
1790   current-&gt;start = gst_element_get_start_time (GST_ELEMENT_CAST (sink));
1791   gst_segment_set_running_time (segment, GST_FORMAT_TIME, current-&gt;start);
1792 
1793   /* set the new rate for the remainder of the segment */
1794   current-&gt;start_rate = segment-&gt;rate;
1795   segment-&gt;rate *= current-&gt;rate;
1796 
1797   /* save values */
1798   if (segment-&gt;rate &gt; 0.0)
1799     current-&gt;start_stop = segment-&gt;stop;
1800   else
1801     current-&gt;start_start = segment-&gt;start;
1802 
1803   if (current-&gt;format == GST_FORMAT_TIME) {
1804     /* calculate the running-time when the step operation should stop */
1805     if (current-&gt;amount != -1)
1806       end = current-&gt;start + current-&gt;amount;
1807     else
1808       end = -1;
1809 
1810     if (!current-&gt;flush) {
1811       gint64 position;
1812 
1813       /* update the segment clipping regions for non-flushing seeks */
1814       if (segment-&gt;rate &gt; 0.0) {
1815         if (end != -1)
1816           position =
1817               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1818               end);
1819         else
1820           position = segment-&gt;stop;
1821 
1822         segment-&gt;stop = position;
1823         segment-&gt;position = position;
1824       } else {
1825         if (end != -1)
1826           position =
1827               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1828               end);
1829         else
1830           position = segment-&gt;start;
1831 
1832         segment-&gt;time = position;
1833         segment-&gt;start = position;
1834         segment-&gt;position = position;
1835       }
1836     }
1837   }
1838 
1839   GST_DEBUG_OBJECT (sink, &quot;segment now %&quot; GST_SEGMENT_FORMAT, segment);
1840   GST_DEBUG_OBJECT (sink, &quot;step started at running_time %&quot; GST_TIME_FORMAT,
1841       GST_TIME_ARGS (current-&gt;start));
1842 
1843   GST_DEBUG_OBJECT (sink, &quot;step amount: %&quot; G_GUINT64_FORMAT &quot;, format: %s, &quot;
1844       &quot;rate: %f&quot;, current-&gt;amount, gst_format_get_name (current-&gt;format),
1845       current-&gt;rate);
1846 }
1847 
1848 static void
1849 stop_stepping (GstBaseSink * sink, GstSegment * segment,
1850     GstStepInfo * current, gint64 rstart, gint64 rstop, gboolean eos)
1851 {
1852   gint64 stop, position;
1853   GstMessage *message;
1854 
1855   GST_DEBUG_OBJECT (sink, &quot;step complete&quot;);
1856 
1857   if (segment-&gt;rate &gt; 0.0)
1858     stop = rstart;
1859   else
1860     stop = rstop;
1861 
1862   GST_DEBUG_OBJECT (sink,
1863       &quot;step stop at running_time %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (stop));
1864 
1865   if (stop == -1)
1866     current-&gt;duration = current-&gt;position;
1867   else
1868     current-&gt;duration = stop - current-&gt;start;
1869 
1870   GST_DEBUG_OBJECT (sink, &quot;step elapsed running_time %&quot; GST_TIME_FORMAT,
1871       GST_TIME_ARGS (current-&gt;duration));
1872 
1873   position = current-&gt;start + current-&gt;duration;
1874 
1875   /* now move the segment to the new running time */
1876   gst_segment_set_running_time (segment, GST_FORMAT_TIME, position);
1877 
1878   if (current-&gt;flush) {
1879     /* and remove the time we flushed, start time did not change */
1880     segment-&gt;base = current-&gt;start;
1881   } else {
1882     /* start time is now the stepped position */
1883     gst_element_set_start_time (GST_ELEMENT_CAST (sink), position);
1884   }
1885 
1886   /* restore the previous rate */
1887   segment-&gt;rate = current-&gt;start_rate;
1888 
1889   if (segment-&gt;rate &gt; 0.0)
1890     segment-&gt;stop = current-&gt;start_stop;
1891   else
1892     segment-&gt;start = current-&gt;start_start;
1893 
1894   /* post the step done when we know the stepped duration in TIME */
1895   message =
1896       gst_message_new_step_done (GST_OBJECT_CAST (sink), current-&gt;format,
1897       current-&gt;amount, current-&gt;rate, current-&gt;flush, current-&gt;intermediate,
1898       current-&gt;duration, eos);
1899   gst_message_set_seqnum (message, current-&gt;seqnum);
1900   gst_element_post_message (GST_ELEMENT_CAST (sink), message);
1901 
1902   if (!current-&gt;intermediate)
1903     sink-&gt;need_preroll = current-&gt;need_preroll;
1904 
1905   /* and the current step info finished and becomes invalid */
1906   current-&gt;valid = FALSE;
1907 }
1908 
1909 static gboolean
1910 handle_stepping (GstBaseSink * sink, GstSegment * segment,
1911     GstStepInfo * current, guint64 * cstart, guint64 * cstop, guint64 * rstart,
1912     guint64 * rstop)
1913 {
1914   gboolean step_end = FALSE;
1915 
1916   /* stepping never stops */
1917   if (current-&gt;amount == -1)
1918     return FALSE;
1919 
1920   /* see if we need to skip this buffer because of stepping */
1921   switch (current-&gt;format) {
1922     case GST_FORMAT_TIME:
1923     {
1924       guint64 end;
1925       guint64 first, last;
1926       gdouble abs_rate;
1927 
1928       if (segment-&gt;rate &gt; 0.0) {
1929         if (segment-&gt;stop == *cstop)
1930           *rstop = *rstart + current-&gt;amount;
1931 
1932         first = *rstart;
1933         last = *rstop;
1934       } else {
1935         if (segment-&gt;start == *cstart)
1936           *rstart = *rstop + current-&gt;amount;
1937 
1938         first = *rstop;
1939         last = *rstart;
1940       }
1941 
1942       end = current-&gt;start + current-&gt;amount;
1943       current-&gt;position = first - current-&gt;start;
1944 
1945       abs_rate = ABS (segment-&gt;rate);
1946       if (G_UNLIKELY (abs_rate != 1.0))
1947         current-&gt;position /= abs_rate;
1948 
1949       GST_DEBUG_OBJECT (sink,
1950           &quot;buffer: %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
1951           GST_TIME_ARGS (first), GST_TIME_ARGS (last));
1952       GST_DEBUG_OBJECT (sink,
1953           &quot;got time step %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT &quot;/%&quot;
1954           GST_TIME_FORMAT, GST_TIME_ARGS (current-&gt;position),
1955           GST_TIME_ARGS (last - current-&gt;start),
1956           GST_TIME_ARGS (current-&gt;amount));
1957 
1958       if ((current-&gt;flush &amp;&amp; current-&gt;position &gt;= current-&gt;amount)
1959           || last &gt;= end) {
1960         GST_DEBUG_OBJECT (sink, &quot;step ended, we need clipping&quot;);
1961         step_end = TRUE;
1962         if (segment-&gt;rate &gt; 0.0) {
1963           *rstart = end;
1964           *cstart =
1965               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1966               end);
1967         } else {
1968           *rstop = end;
1969           *cstop =
1970               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1971               end);
1972         }
1973       }
1974       GST_DEBUG_OBJECT (sink,
1975           &quot;cstart %&quot; GST_TIME_FORMAT &quot;, rstart %&quot; GST_TIME_FORMAT,
1976           GST_TIME_ARGS (*cstart), GST_TIME_ARGS (*rstart));
1977       GST_DEBUG_OBJECT (sink,
1978           &quot;cstop %&quot; GST_TIME_FORMAT &quot;, rstop %&quot; GST_TIME_FORMAT,
1979           GST_TIME_ARGS (*cstop), GST_TIME_ARGS (*rstop));
1980       break;
1981     }
1982     case GST_FORMAT_BUFFERS:
1983       GST_DEBUG_OBJECT (sink,
1984           &quot;got default step %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT,
1985           current-&gt;position, current-&gt;amount);
1986 
1987       if (current-&gt;position &lt; current-&gt;amount) {
1988         current-&gt;position++;
1989       } else {
1990         step_end = TRUE;
1991       }
1992       break;
1993     case GST_FORMAT_DEFAULT:
1994     default:
1995       GST_DEBUG_OBJECT (sink,
1996           &quot;got unknown step %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT,
1997           current-&gt;position, current-&gt;amount);
1998       break;
1999   }
2000   return step_end;
2001 }
2002 
2003 /* with STREAM_LOCK, PREROLL_LOCK
2004  *
2005  * Returns %TRUE if the object needs synchronisation and takes therefore
2006  * part in prerolling.
2007  *
2008  * rsstart/rsstop contain the start/stop in stream time.
2009  * rrstart/rrstop contain the start/stop in running time.
2010  */
2011 static gboolean
2012 gst_base_sink_get_sync_times (GstBaseSink * basesink, GstMiniObject * obj,
2013     GstClockTime * rsstart, GstClockTime * rsstop,
2014     GstClockTime * rrstart, GstClockTime * rrstop, GstClockTime * rrnext,
2015     gboolean * do_sync, gboolean * stepped, GstStepInfo * step,
2016     gboolean * step_end)
2017 {
2018   GstBaseSinkClass *bclass;
2019   GstClockTime start, stop;     /* raw start/stop timestamps */
2020   guint64 cstart, cstop;        /* clipped raw timestamps */
2021   guint64 rstart, rstop, rnext; /* clipped timestamps converted to running time */
2022   GstClockTime sstart, sstop;   /* clipped timestamps converted to stream time */
2023   GstFormat format;
2024   GstBaseSinkPrivate *priv;
2025   GstSegment *segment;
2026   gboolean eos;
2027 
2028   priv = basesink-&gt;priv;
2029   segment = &amp;basesink-&gt;segment;
2030 
2031   bclass = GST_BASE_SINK_GET_CLASS (basesink);
2032 
2033 again:
2034   /* start with nothing */
2035   start = stop = GST_CLOCK_TIME_NONE;
2036   eos = FALSE;
2037 
2038   if (G_UNLIKELY (GST_IS_EVENT (obj))) {
2039     GstEvent *event = GST_EVENT_CAST (obj);
2040 
2041     switch (GST_EVENT_TYPE (event)) {
2042         /* EOS event needs syncing */
2043       case GST_EVENT_EOS:
2044       {
2045         if (segment-&gt;rate &gt;= 0.0) {
2046           sstart = sstop = priv-&gt;current_sstop;
2047           if (!GST_CLOCK_TIME_IS_VALID (sstart)) {
2048             /* we have not seen a buffer yet, use the segment values */
2049             sstart = sstop = gst_segment_to_stream_time (segment,
2050                 segment-&gt;format, segment-&gt;stop);
2051           }
2052         } else {
2053           sstart = sstop = priv-&gt;current_sstart;
2054           if (!GST_CLOCK_TIME_IS_VALID (sstart)) {
2055             /* we have not seen a buffer yet, use the segment values */
2056             sstart = sstop = gst_segment_to_stream_time (segment,
2057                 segment-&gt;format, segment-&gt;start);
2058           }
2059         }
2060 
2061         rstart = rstop = rnext = priv-&gt;eos_rtime;
2062         *do_sync = GST_CLOCK_TIME_IS_VALID (rstart);
2063         GST_DEBUG_OBJECT (basesink, &quot;sync times for EOS %&quot; GST_TIME_FORMAT,
2064             GST_TIME_ARGS (rstart));
2065         /* if we are stepping, we end now */
2066         *step_end = step-&gt;valid;
2067         eos = TRUE;
2068         goto eos_done;
2069       }
2070       case GST_EVENT_GAP:
2071       {
2072         GstClockTime timestamp, duration;
2073         gst_event_parse_gap (event, &amp;timestamp, &amp;duration);
2074 
2075         GST_DEBUG_OBJECT (basesink, &quot;Got Gap time %&quot; GST_TIME_FORMAT
2076             &quot; duration %&quot; GST_TIME_FORMAT,
2077             GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));
2078 
2079         if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
2080           start = timestamp;
2081           if (GST_CLOCK_TIME_IS_VALID (duration))
2082             stop = start + duration;
2083         }
2084         *do_sync = TRUE;
2085         break;
2086       }
2087       default:
2088         /* other events do not need syncing */
2089         return FALSE;
2090     }
2091   } else {
2092     /* else do buffer sync code */
2093     GstBuffer *buffer = GST_BUFFER_CAST (obj);
2094 
2095     /* just get the times to see if we need syncing, if the retuned start is -1
2096      * we don&#39;t sync. */
2097     if (bclass-&gt;get_times)
2098       bclass-&gt;get_times (basesink, buffer, &amp;start, &amp;stop);
2099 
2100     if (!GST_CLOCK_TIME_IS_VALID (start)) {
2101       /* we don&#39;t need to sync but we still want to get the timestamps for
2102        * tracking the position */
2103       gst_base_sink_default_get_times (basesink, buffer, &amp;start, &amp;stop);
2104       *do_sync = FALSE;
2105     } else {
2106       *do_sync = TRUE;
2107     }
2108   }
2109 
2110   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
2111       &quot;, stop: %&quot; GST_TIME_FORMAT &quot;, do_sync %d&quot;, GST_TIME_ARGS (start),
2112       GST_TIME_ARGS (stop), *do_sync);
2113 
2114   /* collect segment and format for code clarity */
2115   format = segment-&gt;format;
2116 
2117   /* clip */
2118   if (G_UNLIKELY (!gst_segment_clip (segment, format,
2119               start, stop, &amp;cstart, &amp;cstop))) {
2120     if (step-&gt;valid) {
2121       GST_DEBUG_OBJECT (basesink, &quot;step out of segment&quot;);
2122       /* when we are stepping, pretend we&#39;re at the end of the segment */
2123       if (segment-&gt;rate &gt; 0.0) {
2124         cstart = segment-&gt;stop;
2125         cstop = segment-&gt;stop;
2126       } else {
2127         cstart = segment-&gt;start;
2128         cstop = segment-&gt;start;
2129       }
2130       goto do_times;
2131     }
2132     goto out_of_segment;
2133   }
2134 
2135   if (G_UNLIKELY (start != cstart || stop != cstop)) {
2136     GST_DEBUG_OBJECT (basesink, &quot;clipped to: start %&quot; GST_TIME_FORMAT
2137         &quot;, stop: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (cstart),
2138         GST_TIME_ARGS (cstop));
2139   }
2140 
2141   /* set last stop position */
2142   if (G_LIKELY (stop != GST_CLOCK_TIME_NONE &amp;&amp; cstop != GST_CLOCK_TIME_NONE))
2143     segment-&gt;position = cstop;
2144   else
2145     segment-&gt;position = cstart;
2146 
2147 do_times:
2148   rstart = gst_segment_to_running_time (segment, format, cstart);
2149   rstop = gst_segment_to_running_time (segment, format, cstop);
2150 
2151   if (GST_CLOCK_TIME_IS_VALID (stop))
2152     rnext = rstop;
2153   else
2154     rnext = rstart;
2155 
2156   if (G_UNLIKELY (step-&gt;valid)) {
2157     if (!(*step_end = handle_stepping (basesink, segment, step, &amp;cstart, &amp;cstop,
2158                 &amp;rstart, &amp;rstop))) {
2159       /* step is still busy, we discard data when we are flushing */
2160       *stepped = step-&gt;flush;
2161       GST_DEBUG_OBJECT (basesink, &quot;stepping busy&quot;);
2162     }
2163   }
2164   /* this can produce wrong values if we accumulated non-TIME segments. If this happens,
2165    * upstream is behaving very badly */
2166   sstart = gst_segment_to_stream_time (segment, format, cstart);
2167   sstop = gst_segment_to_stream_time (segment, format, cstop);
2168 
2169 eos_done:
2170   /* eos_done label only called when doing EOS, we also stop stepping then */
2171   if (*step_end &amp;&amp; step-&gt;flush) {
2172     GST_DEBUG_OBJECT (basesink, &quot;flushing step ended&quot;);
2173     stop_stepping (basesink, segment, step, rstart, rstop, eos);
2174     *step_end = FALSE;
2175     /* re-determine running start times for adjusted segment
2176      * (which has a flushed amount of running/accumulated time removed) */
2177     if (!GST_IS_EVENT (obj)) {
2178       GST_DEBUG_OBJECT (basesink, &quot;refresh sync times&quot;);
2179       goto again;
2180     }
2181   }
2182 
2183   /* save times */
2184   *rsstart = sstart;
2185   *rsstop = sstop;
2186   *rrstart = rstart;
2187   *rrstop = rstop;
2188   *rrnext = rnext;
2189 
2190   /* buffers and EOS always need syncing and preroll */
2191   return TRUE;
2192 
2193   /* special cases */
2194 out_of_segment:
2195   {
2196     /* we usually clip in the chain function already but stepping could cause
2197      * the segment to be updated later. we return %FALSE so that we don&#39;t try
2198      * to sync on it. */
2199     GST_LOG_OBJECT (basesink, &quot;buffer skipped, not in segment&quot;);
2200     return FALSE;
2201   }
2202 }
2203 
2204 /* with STREAM_LOCK, PREROLL_LOCK, LOCK
2205  * adjust a timestamp with the latency and timestamp offset. This function does
2206  * not adjust for the render delay. */
2207 static GstClockTime
2208 gst_base_sink_adjust_time (GstBaseSink * basesink, GstClockTime time)
2209 {
2210   GstClockTimeDiff ts_offset;
2211 
2212   /* don&#39;t do anything funny with invalid timestamps */
2213   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2214     return time;
2215 
2216   time += basesink-&gt;priv-&gt;latency;
2217 
2218   /* apply offset, be careful for underflows */
2219   ts_offset = basesink-&gt;priv-&gt;ts_offset;
2220   if (ts_offset &lt; 0) {
2221     ts_offset = -ts_offset;
2222     if (ts_offset &lt; time)
2223       time -= ts_offset;
2224     else
2225       time = 0;
2226   } else
2227     time += ts_offset;
2228 
2229   /* subtract the render delay again, which was included in the latency */
2230   if (time &gt; basesink-&gt;priv-&gt;render_delay)
2231     time -= basesink-&gt;priv-&gt;render_delay;
2232   else
2233     time = 0;
2234 
2235   return time;
2236 }
2237 
2238 /**
2239  * gst_base_sink_wait_clock:
2240  * @sink: the sink
2241  * @time: the running_time to be reached
2242  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2243  *
2244  * This function will block until @time is reached. It is usually called by
2245  * subclasses that use their own internal synchronisation.
2246  *
2247  * If @time is not valid, no synchronisation is done and %GST_CLOCK_BADTIME is
2248  * returned. Likewise, if synchronisation is disabled in the element or there
2249  * is no clock, no synchronisation is done and %GST_CLOCK_BADTIME is returned.
2250  *
2251  * This function should only be called with the PREROLL_LOCK held, like when
2252  * receiving an EOS event in the #GstBaseSinkClass.event() vmethod or when
2253  * receiving a buffer in
2254  * the #GstBaseSinkClass.render() vmethod.
2255  *
2256  * The @time argument should be the running_time of when this method should
2257  * return and is not adjusted with any latency or offset configured in the
2258  * sink.
2259  *
2260  * Returns: #GstClockReturn
2261  */
2262 GstClockReturn
2263 gst_base_sink_wait_clock (GstBaseSink * sink, GstClockTime time,
2264     GstClockTimeDiff * jitter)
2265 {
2266   GstClockReturn ret;
2267   GstClock *clock;
2268   GstClockTime base_time;
2269 
2270   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2271     goto invalid_time;
2272 
2273   GST_OBJECT_LOCK (sink);
2274   if (G_UNLIKELY (!sink-&gt;sync))
2275     goto no_sync;
2276 
2277   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (sink)) == NULL))
2278     goto no_clock;
2279 
2280   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
2281   GST_LOG_OBJECT (sink,
2282       &quot;time %&quot; GST_TIME_FORMAT &quot;, base_time %&quot; GST_TIME_FORMAT,
2283       GST_TIME_ARGS (time), GST_TIME_ARGS (base_time));
2284 
2285   /* add base_time to running_time to get the time against the clock */
2286   time += base_time;
2287 
2288   /* Re-use existing clockid if available */
<a name="30" id="anc30"></a>

2289   if (G_LIKELY (sink-&gt;priv-&gt;cached_clock_id != NULL
<a name="31" id="anc31"></a><span class="line-modified">2290           &amp;&amp; gst_clock_id_uses_clock (sink-&gt;priv-&gt;cached_clock_id, clock))) {</span>

2291     if (!gst_clock_single_shot_id_reinit (clock, sink-&gt;priv-&gt;cached_clock_id,
2292             time)) {
2293       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2294       sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2295     }
2296   } else {
2297     if (sink-&gt;priv-&gt;cached_clock_id != NULL)
2298       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2299     sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2300   }
2301   GST_OBJECT_UNLOCK (sink);
2302 
2303   /* A blocking wait is performed on the clock. We save the ClockID
2304    * so we can unlock the entry at any time. While we are blocking, we
2305    * release the PREROLL_LOCK so that other threads can interrupt the
2306    * entry. */
2307   sink-&gt;clock_id = sink-&gt;priv-&gt;cached_clock_id;
2308   /* release the preroll lock while waiting */
2309   GST_BASE_SINK_PREROLL_UNLOCK (sink);
2310 
2311   ret = gst_clock_id_wait (sink-&gt;priv-&gt;cached_clock_id, jitter);
2312 
2313   GST_BASE_SINK_PREROLL_LOCK (sink);
2314   sink-&gt;clock_id = NULL;
2315 
2316   return ret;
2317 
2318   /* no syncing needed */
2319 invalid_time:
2320   {
2321     GST_DEBUG_OBJECT (sink, &quot;time not valid, no sync needed&quot;);
2322     return GST_CLOCK_BADTIME;
2323   }
2324 no_sync:
2325   {
2326     GST_DEBUG_OBJECT (sink, &quot;sync disabled&quot;);
2327     GST_OBJECT_UNLOCK (sink);
2328     return GST_CLOCK_BADTIME;
2329   }
2330 no_clock:
2331   {
2332     GST_DEBUG_OBJECT (sink, &quot;no clock, can&#39;t sync&quot;);
2333     GST_OBJECT_UNLOCK (sink);
2334     return GST_CLOCK_BADTIME;
2335   }
2336 }
2337 
2338 /**
2339  * gst_base_sink_wait_preroll:
2340  * @sink: the sink
2341  *
2342  * If the #GstBaseSinkClass.render() method performs its own synchronisation
2343  * against the clock it must unblock when going from PLAYING to the PAUSED state
2344  * and call this method before continuing to render the remaining data.
2345  *
2346  * If the #GstBaseSinkClass.render() method can block on something else than
2347  * the clock, it must also be ready to unblock immediately on
2348  * the #GstBaseSinkClass.unlock() method and cause the
2349  * #GstBaseSinkClass.render() method to immediately call this function.
2350  * In this case, the subclass must be prepared to continue rendering where it
2351  * left off if this function returns %GST_FLOW_OK.
2352  *
2353  * This function will block until a state change to PLAYING happens (in which
2354  * case this function returns %GST_FLOW_OK) or the processing must be stopped due
2355  * to a state change to READY or a FLUSH event (in which case this function
2356  * returns %GST_FLOW_FLUSHING).
2357  *
2358  * This function should only be called with the PREROLL_LOCK held, like in the
2359  * render function.
2360  *
2361  * Returns: %GST_FLOW_OK if the preroll completed and processing can
2362  * continue. Any other return value should be returned from the render vmethod.
2363  */
2364 GstFlowReturn
2365 gst_base_sink_wait_preroll (GstBaseSink * sink)
2366 {
2367   sink-&gt;have_preroll = TRUE;
2368   GST_DEBUG_OBJECT (sink, &quot;waiting in preroll for flush or PLAYING&quot;);
2369   /* block until the state changes, or we get a flush, or something */
2370   GST_BASE_SINK_PREROLL_WAIT (sink);
2371   sink-&gt;have_preroll = FALSE;
2372   if (G_UNLIKELY (sink-&gt;flushing))
2373     goto stopping;
2374   if (G_UNLIKELY (sink-&gt;priv-&gt;step_unlock))
2375     goto step_unlocked;
2376   GST_DEBUG_OBJECT (sink, &quot;continue after preroll&quot;);
2377 
2378   return GST_FLOW_OK;
2379 
2380   /* ERRORS */
2381 stopping:
2382   {
2383     GST_DEBUG_OBJECT (sink, &quot;preroll interrupted because of flush&quot;);
2384     return GST_FLOW_FLUSHING;
2385   }
2386 step_unlocked:
2387   {
2388     sink-&gt;priv-&gt;step_unlock = FALSE;
2389     GST_DEBUG_OBJECT (sink, &quot;preroll interrupted because of step&quot;);
2390     return GST_FLOW_STEP;
2391   }
2392 }
2393 
2394 /**
2395  * gst_base_sink_do_preroll:
2396  * @sink: the sink
2397  * @obj: (transfer none): the mini object that caused the preroll
2398  *
2399  * If the @sink spawns its own thread for pulling buffers from upstream it
2400  * should call this method after it has pulled a buffer. If the element needed
2401  * to preroll, this function will perform the preroll and will then block
2402  * until the element state is changed.
2403  *
2404  * This function should be called with the PREROLL_LOCK held.
2405  *
2406  * Returns: %GST_FLOW_OK if the preroll completed and processing can
2407  * continue. Any other return value should be returned from the render vmethod.
2408  */
2409 GstFlowReturn
2410 gst_base_sink_do_preroll (GstBaseSink * sink, GstMiniObject * obj)
2411 {
2412   GstFlowReturn ret;
2413 
2414   while (G_UNLIKELY (sink-&gt;need_preroll)) {
2415     GST_DEBUG_OBJECT (sink, &quot;prerolling object %p&quot;, obj);
2416 
2417     /* if it&#39;s a buffer, we need to call the preroll method */
2418     if (sink-&gt;priv-&gt;call_preroll) {
2419       GstBaseSinkClass *bclass;
2420       GstBuffer *buf;
2421 
2422       if (GST_IS_BUFFER_LIST (obj)) {
2423         buf = gst_buffer_list_get (GST_BUFFER_LIST_CAST (obj), 0);
2424         gst_base_sink_set_last_buffer (sink, buf);
2425         gst_base_sink_set_last_buffer_list (sink, GST_BUFFER_LIST_CAST (obj));
2426         g_assert (NULL != buf);
2427       } else if (GST_IS_BUFFER (obj)) {
2428         buf = GST_BUFFER_CAST (obj);
2429         /* For buffer lists do not set last buffer for now */
2430         gst_base_sink_set_last_buffer (sink, buf);
2431         gst_base_sink_set_last_buffer_list (sink, NULL);
2432       } else {
2433         buf = NULL;
2434       }
2435 
2436       if (buf) {
2437         GST_DEBUG_OBJECT (sink, &quot;preroll buffer %&quot; GST_TIME_FORMAT,
2438             GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
2439 
2440         bclass = GST_BASE_SINK_GET_CLASS (sink);
2441 
2442         if (bclass-&gt;prepare)
2443           if ((ret = bclass-&gt;prepare (sink, buf)) != GST_FLOW_OK)
2444             goto prepare_canceled;
2445 
2446         if (bclass-&gt;preroll)
2447           if ((ret = bclass-&gt;preroll (sink, buf)) != GST_FLOW_OK)
2448             goto preroll_canceled;
2449 
2450         sink-&gt;priv-&gt;call_preroll = FALSE;
2451       }
2452     }
2453 
2454     /* commit state */
2455     if (G_LIKELY (sink-&gt;playing_async)) {
2456       if (G_UNLIKELY (!gst_base_sink_commit_state (sink)))
2457         goto stopping;
2458     }
2459 
2460     /* need to recheck here because the commit state could have
2461      * made us not need the preroll anymore */
2462     if (G_LIKELY (sink-&gt;need_preroll)) {
2463       /* block until the state changes, or we get a flush, or something */
2464       ret = gst_base_sink_wait_preroll (sink);
2465       if ((ret != GST_FLOW_OK) &amp;&amp; (ret != GST_FLOW_STEP))
2466         goto preroll_failed;
2467     }
2468   }
2469   return GST_FLOW_OK;
2470 
2471   /* ERRORS */
2472 prepare_canceled:
2473   {
2474     GST_DEBUG_OBJECT (sink, &quot;prepare failed, abort state&quot;);
2475     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2476     return ret;
2477   }
2478 preroll_canceled:
2479   {
2480     GST_DEBUG_OBJECT (sink, &quot;preroll failed, abort state&quot;);
2481     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2482     return ret;
2483   }
2484 stopping:
2485   {
<a name="32" id="anc32"></a><span class="line-modified">2486     GST_DEBUG_OBJECT (sink, &quot;stopping while committing state&quot;);</span>
2487     return GST_FLOW_FLUSHING;
2488   }
2489 preroll_failed:
2490   {
2491     GST_DEBUG_OBJECT (sink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
2492     return ret;
2493   }
2494 }
2495 
2496 /**
2497  * gst_base_sink_wait:
2498  * @sink: the sink
2499  * @time: the running_time to be reached
2500  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2501  *
2502  * This function will wait for preroll to complete and will then block until @time
2503  * is reached. It is usually called by subclasses that use their own internal
2504  * synchronisation but want to let some synchronization (like EOS) be handled
2505  * by the base class.
2506  *
2507  * This function should only be called with the PREROLL_LOCK held (like when
2508  * receiving an EOS event in the ::event vmethod or when handling buffers in
2509  * ::render).
2510  *
2511  * The @time argument should be the running_time of when the timeout should happen
2512  * and will be adjusted with any latency and offset configured in the sink.
2513  *
2514  * Returns: #GstFlowReturn
2515  */
2516 GstFlowReturn
2517 gst_base_sink_wait (GstBaseSink * sink, GstClockTime time,
2518     GstClockTimeDiff * jitter)
2519 {
2520   GstClockReturn status;
2521   GstFlowReturn ret;
2522 
2523   do {
2524     GstClockTime stime;
2525 
2526     GST_DEBUG_OBJECT (sink, &quot;checking preroll&quot;);
2527 
2528     /* first wait for the playing state before we can continue */
2529     while (G_UNLIKELY (sink-&gt;need_preroll)) {
2530       ret = gst_base_sink_wait_preroll (sink);
2531       if ((ret != GST_FLOW_OK) &amp;&amp; (ret != GST_FLOW_STEP))
2532         goto flushing;
2533     }
2534 
2535     /* preroll done, we can sync since we are in PLAYING now. */
2536     GST_DEBUG_OBJECT (sink, &quot;possibly waiting for clock to reach %&quot;
2537         GST_TIME_FORMAT, GST_TIME_ARGS (time));
2538 
2539     /* compensate for latency, ts_offset and render delay */
2540     stime = gst_base_sink_adjust_time (sink, time);
2541 
2542     /* wait for the clock, this can be interrupted because we got shut down or
2543      * we PAUSED. */
2544     status = gst_base_sink_wait_clock (sink, stime, jitter);
2545 
2546     GST_DEBUG_OBJECT (sink, &quot;clock returned %d&quot;, status);
2547 
2548     /* invalid time, no clock or sync disabled, just continue then */
2549     if (status == GST_CLOCK_BADTIME)
2550       break;
2551 
2552     /* waiting could have been interrupted and we can be flushing now */
2553     if (G_UNLIKELY (sink-&gt;flushing))
2554       goto flushing;
2555 
2556     /* retry if we got unscheduled, which means we did not reach the timeout
<a name="33" id="anc33"></a><span class="line-modified">2557      * yet. if some other error occurs, we continue. */</span>
2558   } while (status == GST_CLOCK_UNSCHEDULED);
2559 
2560   GST_DEBUG_OBJECT (sink, &quot;end of stream&quot;);
2561 
2562   return GST_FLOW_OK;
2563 
2564   /* ERRORS */
2565 flushing:
2566   {
2567     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2568     return GST_FLOW_FLUSHING;
2569   }
2570 }
2571 
2572 /* with STREAM_LOCK, PREROLL_LOCK
2573  *
2574  * Make sure we are in PLAYING and synchronize an object to the clock.
2575  *
2576  * If we need preroll, we are not in PLAYING. We try to commit the state
2577  * if needed and then block if we still are not PLAYING.
2578  *
2579  * We start waiting on the clock in PLAYING. If we got interrupted, we
2580  * immediately try to re-preroll.
2581  *
2582  * Some objects do not need synchronisation (most events) and so this function
2583  * immediately returns GST_FLOW_OK.
2584  *
2585  * for objects that arrive later than max-lateness to be synchronized to the
2586  * clock have the @late boolean set to %TRUE.
2587  *
2588  * This function keeps a running average of the jitter (the diff between the
2589  * clock time and the requested sync time). The jitter is negative for
2590  * objects that arrive in time and positive for late buffers.
2591  *
2592  * does not take ownership of obj.
2593  */
2594 static GstFlowReturn
2595 gst_base_sink_do_sync (GstBaseSink * basesink,
2596     GstMiniObject * obj, gboolean * late, gboolean * step_end)
2597 {
2598   GstClockTimeDiff jitter = 0;
2599   gboolean syncable;
2600   GstClockReturn status = GST_CLOCK_OK;
2601   GstClockTime rstart, rstop, rnext, sstart, sstop, stime;
2602   gboolean do_sync;
2603   GstBaseSinkPrivate *priv;
2604   GstFlowReturn ret;
2605   GstStepInfo *current, *pending;
2606   gboolean stepped;
2607 
2608   priv = basesink-&gt;priv;
2609 
2610 do_step:
2611   sstart = sstop = rstart = rstop = rnext = GST_CLOCK_TIME_NONE;
2612   do_sync = TRUE;
2613   stepped = FALSE;
2614 
2615   priv-&gt;current_rstart = GST_CLOCK_TIME_NONE;
2616 
2617   /* get stepping info */
2618   current = &amp;priv-&gt;current_step;
2619   pending = &amp;priv-&gt;pending_step;
2620 
2621   /* get timing information for this object against the render segment */
2622   syncable = gst_base_sink_get_sync_times (basesink, obj,
2623       &amp;sstart, &amp;sstop, &amp;rstart, &amp;rstop, &amp;rnext, &amp;do_sync, &amp;stepped, current,
2624       step_end);
2625 
2626   if (G_UNLIKELY (stepped))
2627     goto step_skipped;
2628 
2629   /* a syncable object needs to participate in preroll and
2630    * clocking. All buffers and EOS are syncable. */
2631   if (G_UNLIKELY (!syncable))
2632     goto not_syncable;
2633 
2634   /* store timing info for current object */
2635   priv-&gt;current_rstart = rstart;
2636   priv-&gt;current_rstop = (GST_CLOCK_TIME_IS_VALID (rstop) ? rstop : rstart);
2637 
2638   /* save sync time for eos when the previous object needed sync */
2639   priv-&gt;eos_rtime = (do_sync ? rnext : GST_CLOCK_TIME_NONE);
2640 
2641   /* calculate inter frame spacing */
2642   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;prev_rstart) &amp;&amp;
2643           priv-&gt;prev_rstart &lt; rstart)) {
2644     GstClockTime in_diff;
2645 
2646     in_diff = rstart - priv-&gt;prev_rstart;
2647 
2648     if (priv-&gt;avg_in_diff == -1)
2649       priv-&gt;avg_in_diff = in_diff;
2650     else
2651       priv-&gt;avg_in_diff = UPDATE_RUNNING_AVG (priv-&gt;avg_in_diff, in_diff);
2652 
2653     GST_LOG_OBJECT (basesink, &quot;avg frame diff %&quot; GST_TIME_FORMAT,
2654         GST_TIME_ARGS (priv-&gt;avg_in_diff));
2655 
2656   }
2657   priv-&gt;prev_rstart = rstart;
2658 
2659   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;earliest_in_time) &amp;&amp;
2660           rstart &lt; priv-&gt;earliest_in_time))
2661     goto qos_dropped;
2662 
2663 again:
2664   /* first do preroll, this makes sure we commit our state
2665    * to PAUSED and can continue to PLAYING. We cannot perform
2666    * any clock sync in PAUSED because there is no clock. */
2667   ret = gst_base_sink_do_preroll (basesink, obj);
2668   if (G_UNLIKELY (ret != GST_FLOW_OK))
2669     goto preroll_failed;
2670 
2671   /* update the segment with a pending step if the current one is invalid and we
2672    * have a new pending one. We only accept new step updates after a preroll */
2673   if (G_UNLIKELY (pending-&gt;valid &amp;&amp; !current-&gt;valid)) {
2674     start_stepping (basesink, &amp;basesink-&gt;segment, pending, current);
2675     goto do_step;
2676   }
2677 
2678   /* After rendering we store the position of the last buffer so that we can use
2679    * it to report the position. We need to take the lock here. */
2680   GST_OBJECT_LOCK (basesink);
2681   priv-&gt;current_sstart = sstart;
2682   priv-&gt;current_sstop = (GST_CLOCK_TIME_IS_VALID (sstop) ? sstop : sstart);
2683   GST_OBJECT_UNLOCK (basesink);
2684 
2685   if (!do_sync)
2686     goto done;
2687 
2688   /* adjust for latency */
2689   stime = gst_base_sink_adjust_time (basesink, rstart);
2690 
2691   /* adjust for rate control */
2692   if (priv-&gt;rc_next == -1 || (stime != -1 &amp;&amp; stime &gt;= priv-&gt;rc_next)) {
2693     GST_DEBUG_OBJECT (basesink, &quot;reset rc_time to time %&quot; GST_TIME_FORMAT,
2694         GST_TIME_ARGS (stime));
2695     priv-&gt;rc_time = stime;
2696     priv-&gt;rc_accumulated = 0;
2697   } else {
2698     GST_DEBUG_OBJECT (basesink, &quot;rate control next %&quot; GST_TIME_FORMAT,
2699         GST_TIME_ARGS (priv-&gt;rc_next));
2700     stime = priv-&gt;rc_next;
2701   }
2702 
2703   /* preroll done, we can sync since we are in PLAYING now. */
2704   GST_DEBUG_OBJECT (basesink, &quot;possibly waiting for clock to reach %&quot;
2705       GST_TIME_FORMAT &quot;, adjusted %&quot; GST_TIME_FORMAT,
2706       GST_TIME_ARGS (rstart), GST_TIME_ARGS (stime));
2707 
2708   /* This function will return immediately if start == -1, no clock
2709    * or sync is disabled with GST_CLOCK_BADTIME. */
2710   status = gst_base_sink_wait_clock (basesink, stime, &amp;jitter);
2711 
2712   GST_DEBUG_OBJECT (basesink, &quot;clock returned %d, jitter %c%&quot; GST_TIME_FORMAT,
2713       status, (jitter &lt; 0 ? &#39;-&#39; : &#39; &#39;), GST_TIME_ARGS (ABS (jitter)));
2714 
2715   /* invalid time, no clock or sync disabled, just render */
2716   if (status == GST_CLOCK_BADTIME)
2717     goto done;
2718 
2719   /* waiting could have been interrupted and we can be flushing now */
2720   if (G_UNLIKELY (basesink-&gt;flushing))
2721     goto flushing;
2722 
2723   /* check for unlocked by a state change, we are not flushing so
2724    * we can try to preroll on the current buffer. */
2725   if (G_UNLIKELY (status == GST_CLOCK_UNSCHEDULED)) {
2726     GST_DEBUG_OBJECT (basesink, &quot;unscheduled, waiting some more&quot;);
2727     priv-&gt;call_preroll = TRUE;
2728     goto again;
2729   }
2730 
2731   /* successful syncing done, record observation */
2732   priv-&gt;current_jitter = jitter;
2733 
2734   /* check if the object should be dropped */
2735   *late = gst_base_sink_is_too_late (basesink, obj, rstart, rstop,
2736       status, jitter, TRUE);
2737 
2738 done:
2739   return GST_FLOW_OK;
2740 
2741   /* ERRORS */
2742 step_skipped:
2743   {
2744     GST_DEBUG_OBJECT (basesink, &quot;skipped stepped object %p&quot;, obj);
2745     *late = TRUE;
2746     return GST_FLOW_OK;
2747   }
2748 not_syncable:
2749   {
2750     GST_DEBUG_OBJECT (basesink, &quot;non syncable object %p&quot;, obj);
2751     return GST_FLOW_OK;
2752   }
2753 qos_dropped:
2754   {
2755     GST_DEBUG_OBJECT (basesink, &quot;dropped because of QoS %p&quot;, obj);
2756     *late = TRUE;
2757     return GST_FLOW_OK;
2758   }
2759 flushing:
2760   {
2761     GST_DEBUG_OBJECT (basesink, &quot;we are flushing&quot;);
2762     return GST_FLOW_FLUSHING;
2763   }
2764 preroll_failed:
2765   {
2766     GST_DEBUG_OBJECT (basesink, &quot;preroll failed&quot;);
2767     *step_end = FALSE;
2768     return ret;
2769   }
2770 }
2771 
2772 static gboolean
2773 gst_base_sink_send_qos (GstBaseSink * basesink, GstQOSType type,
2774     gdouble proportion, GstClockTime time, GstClockTimeDiff diff)
2775 {
2776   GstEvent *event;
2777   gboolean res;
2778 
2779   /* generate Quality-of-Service event */
2780   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
2781       &quot;qos: type %d, proportion: %lf, diff %&quot; G_GINT64_FORMAT &quot;, timestamp %&quot;
2782       GST_TIME_FORMAT, type, proportion, diff, GST_TIME_ARGS (time));
2783 
2784   event = gst_event_new_qos (type, proportion, diff, time);
2785 
2786   /* send upstream */
2787   res = gst_pad_push_event (basesink-&gt;sinkpad, event);
2788 
2789   return res;
2790 }
2791 
2792 static void
2793 gst_base_sink_perform_qos (GstBaseSink * sink, gboolean dropped)
2794 {
2795   GstBaseSinkPrivate *priv;
2796   GstClockTime start, stop;
2797   GstClockTimeDiff jitter;
2798   GstClockTime pt, entered, left;
2799   GstClockTime duration;
2800   gdouble rate;
2801 
2802   priv = sink-&gt;priv;
2803 
2804   start = priv-&gt;current_rstart;
2805 
2806   if (priv-&gt;current_step.valid)
2807     return;
2808 
2809   /* if Quality-of-Service disabled, do nothing */
2810   if (!g_atomic_int_get (&amp;priv-&gt;qos_enabled) ||
2811       !GST_CLOCK_TIME_IS_VALID (start))
2812     return;
2813 
2814   stop = priv-&gt;current_rstop;
2815   jitter = priv-&gt;current_jitter;
2816 
2817   if (jitter &lt; 0) {
2818     /* this is the time the buffer entered the sink */
2819     if (start &lt; -jitter)
2820       entered = 0;
2821     else
2822       entered = start + jitter;
2823     left = start;
2824   } else {
2825     /* this is the time the buffer entered the sink */
2826     entered = start + jitter;
2827     /* this is the time the buffer left the sink */
2828     left = start + jitter;
2829   }
2830 
2831   /* calculate duration of the buffer, only use buffer durations if not in
2832    * trick mode or key-unit mode. Otherwise the buffer durations will be
2833    * meaningless as frames are being dropped in-between without updating the
2834    * durations. */
2835   duration = priv-&gt;avg_in_diff;
2836 
2837   /* if we have the time when the last buffer left us, calculate
2838    * processing time */
2839   if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_left)) {
2840     if (entered &gt; priv-&gt;last_left) {
2841       pt = entered - priv-&gt;last_left;
2842     } else {
2843       pt = 0;
2844     }
2845   } else {
2846     pt = priv-&gt;avg_pt;
2847   }
2848 
2849   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink, &quot;start: %&quot; GST_TIME_FORMAT
2850       &quot;, stop %&quot; GST_TIME_FORMAT &quot;, entered %&quot; GST_TIME_FORMAT &quot;, left %&quot;
2851       GST_TIME_FORMAT &quot;, pt: %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT
2852       &quot;,jitter %&quot; G_GINT64_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (stop),
2853       GST_TIME_ARGS (entered), GST_TIME_ARGS (left), GST_TIME_ARGS (pt),
2854       GST_TIME_ARGS (duration), jitter);
2855 
2856   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink,
2857       &quot;avg_pt: %&quot; GST_TIME_FORMAT &quot;, avg_rate: %g&quot;,
2858       GST_TIME_ARGS (priv-&gt;avg_pt), priv-&gt;avg_rate);
2859 
2860   /* collect running averages. for first observations, we copy the
2861    * values */
2862   if (!GST_CLOCK_TIME_IS_VALID (priv-&gt;avg_pt))
2863     priv-&gt;avg_pt = pt;
2864   else
2865     priv-&gt;avg_pt = UPDATE_RUNNING_AVG (priv-&gt;avg_pt, pt);
2866 
2867   if (duration != -1 &amp;&amp; duration != 0) {
2868     rate =
2869         gst_guint64_to_gdouble (priv-&gt;avg_pt) /
2870         gst_guint64_to_gdouble (duration);
2871   } else {
2872     rate = 1.0;
2873   }
2874 
2875   if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_left)) {
2876     if (dropped || priv-&gt;avg_rate &lt; 0.0) {
2877       priv-&gt;avg_rate = rate;
2878     } else {
2879       if (rate &gt; 1.0)
2880         priv-&gt;avg_rate = UPDATE_RUNNING_AVG_N (priv-&gt;avg_rate, rate);
2881       else
2882         priv-&gt;avg_rate = UPDATE_RUNNING_AVG_P (priv-&gt;avg_rate, rate);
2883     }
2884   }
2885 
2886   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink,
2887       &quot;updated: avg_pt: %&quot; GST_TIME_FORMAT
2888       &quot;, avg_rate: %g&quot;, GST_TIME_ARGS (priv-&gt;avg_pt), priv-&gt;avg_rate);
2889 
2890 
2891   if (priv-&gt;avg_rate &gt;= 0.0) {
2892     GstQOSType type;
2893     GstClockTimeDiff diff;
2894 
2895     /* if we have a valid rate, start sending QoS messages */
2896     if (priv-&gt;current_jitter &lt; 0) {
2897       /* make sure we never go below 0 when adding the jitter to the
2898        * timestamp. */
2899       if (priv-&gt;current_rstart &lt; -priv-&gt;current_jitter)
2900         priv-&gt;current_jitter = -priv-&gt;current_rstart;
2901     }
2902 
2903     if (priv-&gt;throttle_time &gt; 0) {
2904       diff = priv-&gt;throttle_time;
2905       type = GST_QOS_TYPE_THROTTLE;
2906     } else {
2907       diff = priv-&gt;current_jitter;
2908       if (diff &lt;= 0)
2909         type = GST_QOS_TYPE_OVERFLOW;
2910       else
2911         type = GST_QOS_TYPE_UNDERFLOW;
2912     }
2913 
2914     gst_base_sink_send_qos (sink, type, priv-&gt;avg_rate, priv-&gt;current_rstart,
2915         diff);
2916   }
2917 
2918   /* record when this buffer will leave us */
2919   priv-&gt;last_left = left;
2920 }
2921 
2922 /* reset all qos measuring */
2923 static void
2924 gst_base_sink_reset_qos (GstBaseSink * sink)
2925 {
2926   GstBaseSinkPrivate *priv;
2927 
2928   priv = sink-&gt;priv;
2929 
2930   priv-&gt;last_render_time = GST_CLOCK_TIME_NONE;
2931   priv-&gt;prev_rstart = GST_CLOCK_TIME_NONE;
2932   priv-&gt;earliest_in_time = GST_CLOCK_TIME_NONE;
2933   priv-&gt;last_left = GST_CLOCK_TIME_NONE;
2934   priv-&gt;avg_pt = GST_CLOCK_TIME_NONE;
2935   priv-&gt;avg_rate = -1.0;
2936   priv-&gt;avg_in_diff = GST_CLOCK_TIME_NONE;
2937   priv-&gt;rendered = 0;
2938   priv-&gt;dropped = 0;
2939 
2940 }
2941 
2942 /* Checks if the object was scheduled too late.
2943  *
2944  * rstart/rstop contain the running_time start and stop values
2945  * of the object.
2946  *
2947  * status and jitter contain the return values from the clock wait.
2948  *
2949  * returns %TRUE if the buffer was too late.
2950  */
2951 static gboolean
2952 gst_base_sink_is_too_late (GstBaseSink * basesink, GstMiniObject * obj,
2953     GstClockTime rstart, GstClockTime rstop,
2954     GstClockReturn status, GstClockTimeDiff jitter, gboolean render)
2955 {
2956   gboolean late;
2957   guint64 max_lateness;
2958   GstBaseSinkPrivate *priv;
2959 
2960   priv = basesink-&gt;priv;
2961 
2962   late = FALSE;
2963 
2964   /* only for objects that were too late */
2965   if (G_LIKELY (status != GST_CLOCK_EARLY))
2966     goto in_time;
2967 
2968   max_lateness = basesink-&gt;max_lateness;
2969 
2970   /* check if frame dropping is enabled */
2971   if (max_lateness == -1)
2972     goto no_drop;
2973 
2974   /* only check for buffers */
2975   if (G_UNLIKELY (!GST_IS_BUFFER (obj)))
2976     goto not_buffer;
2977 
2978   /* can&#39;t do check if we don&#39;t have a timestamp */
2979   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (rstart)))
2980     goto no_timestamp;
2981 
2982   /* we can add a valid stop time */
2983   if (GST_CLOCK_TIME_IS_VALID (rstop))
2984     max_lateness += rstop;
2985   else {
2986     max_lateness += rstart;
2987     /* no stop time, use avg frame diff */
2988     if (priv-&gt;avg_in_diff != -1)
2989       max_lateness += priv-&gt;avg_in_diff;
2990   }
2991 
2992   /* if the jitter bigger than duration and lateness we are too late */
2993   if ((late = rstart + jitter &gt; max_lateness)) {
2994     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, basesink,
2995         &quot;buffer is too late %&quot; GST_TIME_FORMAT
2996         &quot; &gt; %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (rstart + jitter),
2997         GST_TIME_ARGS (max_lateness));
2998     /* !!emergency!!, if we did not receive anything valid for more than a
2999      * second, render it anyway so the user sees something */
3000     if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_render_time) &amp;&amp;
3001         rstart - priv-&gt;last_render_time &gt; GST_SECOND) {
3002       late = FALSE;
3003       GST_ELEMENT_WARNING (basesink, CORE, CLOCK,
3004           (_(&quot;A lot of buffers are being dropped.&quot;)),
3005           (&quot;There may be a timestamping problem, or this computer is too slow.&quot;));
3006       GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, basesink,
3007           &quot;**emergency** last buffer at %&quot; GST_TIME_FORMAT &quot; &gt; GST_SECOND&quot;,
3008           GST_TIME_ARGS (priv-&gt;last_render_time));
3009     }
3010   }
3011 
3012 done:
3013   if (render &amp;&amp; (!late || !GST_CLOCK_TIME_IS_VALID (priv-&gt;last_render_time))) {
3014     priv-&gt;last_render_time = rstart;
3015     /* the next allowed input timestamp */
3016     if (priv-&gt;throttle_time &gt; 0)
3017       priv-&gt;earliest_in_time = rstart + priv-&gt;throttle_time;
3018   }
3019   return late;
3020 
3021   /* all is fine */
3022 in_time:
3023   {
3024     GST_DEBUG_OBJECT (basesink, &quot;object was scheduled in time&quot;);
3025     goto done;
3026   }
3027 no_drop:
3028   {
3029     GST_DEBUG_OBJECT (basesink, &quot;frame dropping disabled&quot;);
3030     goto done;
3031   }
3032 not_buffer:
3033   {
3034     GST_DEBUG_OBJECT (basesink, &quot;object is not a buffer&quot;);
3035     return FALSE;
3036   }
3037 no_timestamp:
3038   {
3039     GST_DEBUG_OBJECT (basesink, &quot;buffer has no timestamp&quot;);
3040     return FALSE;
3041   }
3042 }
3043 
3044 static void
3045 gst_base_sink_update_start_time (GstBaseSink * basesink)
3046 {
3047   GstClock *clock;
3048 
3049   GST_OBJECT_LOCK (basesink);
3050   if (GST_STATE (basesink) == GST_STATE_PLAYING
3051       &amp;&amp; (clock = GST_ELEMENT_CLOCK (basesink))) {
3052     GstClockTime now;
3053 
3054     gst_object_ref (clock);
3055     GST_OBJECT_UNLOCK (basesink);
3056 
3057     /* calculate the time when we stopped */
3058     now = gst_clock_get_time (clock);
3059     gst_object_unref (clock);
3060 
3061     GST_OBJECT_LOCK (basesink);
3062     /* store the current running time */
3063     if (GST_ELEMENT_START_TIME (basesink) != GST_CLOCK_TIME_NONE) {
3064       if (now != GST_CLOCK_TIME_NONE)
3065         GST_ELEMENT_START_TIME (basesink) =
3066             now - GST_ELEMENT_CAST (basesink)-&gt;base_time;
3067       else
3068         GST_WARNING_OBJECT (basesink,
3069             &quot;Clock %s returned invalid time, can&#39;t calculate &quot;
3070             &quot;running_time when going to the PAUSED state&quot;,
3071             GST_OBJECT_NAME (clock));
3072     }
3073     GST_DEBUG_OBJECT (basesink,
3074         &quot;start_time=%&quot; GST_TIME_FORMAT &quot;, now=%&quot; GST_TIME_FORMAT
3075         &quot;, base_time %&quot; GST_TIME_FORMAT,
3076         GST_TIME_ARGS (GST_ELEMENT_START_TIME (basesink)),
3077         GST_TIME_ARGS (now),
3078         GST_TIME_ARGS (GST_ELEMENT_CAST (basesink)-&gt;base_time));
3079   }
3080   GST_OBJECT_UNLOCK (basesink);
3081 }
3082 
3083 static void
3084 gst_base_sink_flush_start (GstBaseSink * basesink, GstPad * pad)
3085 {
3086   /* make sure we are not blocked on the clock also clear any pending
3087    * eos state. */
3088   gst_base_sink_set_flushing (basesink, pad, TRUE);
3089 
3090   /* we grab the stream lock but that is not needed since setting the
3091    * sink to flushing would make sure no state commit is being done
3092    * anymore */
3093   GST_PAD_STREAM_LOCK (pad);
3094   gst_base_sink_reset_qos (basesink);
3095   /* and we need to commit our state again on the next
3096    * prerolled buffer */
3097   basesink-&gt;playing_async = TRUE;
3098   if (basesink-&gt;priv-&gt;async_enabled) {
3099     gst_base_sink_update_start_time (basesink);
3100     gst_element_lost_state (GST_ELEMENT_CAST (basesink));
3101   } else {
3102     /* start time reset in above case as well;
3103      * arranges for a.o. proper position reporting when flushing in PAUSED */
3104     gst_element_set_start_time (GST_ELEMENT_CAST (basesink), 0);
3105     basesink-&gt;priv-&gt;have_latency = TRUE;
3106   }
3107   gst_base_sink_set_last_buffer (basesink, NULL);
3108   gst_base_sink_set_last_buffer_list (basesink, NULL);
3109   GST_PAD_STREAM_UNLOCK (pad);
3110 }
3111 
3112 static void
3113 gst_base_sink_flush_stop (GstBaseSink * basesink, GstPad * pad,
3114     gboolean reset_time)
3115 {
3116   /* unset flushing so we can accept new data, this also flushes out any EOS
3117    * event. */
3118   gst_base_sink_set_flushing (basesink, pad, FALSE);
3119 
3120   /* for position reporting */
3121   GST_OBJECT_LOCK (basesink);
3122   basesink-&gt;priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
3123   basesink-&gt;priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
3124   basesink-&gt;priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
3125   basesink-&gt;priv-&gt;call_preroll = TRUE;
3126   basesink-&gt;priv-&gt;current_step.valid = FALSE;
3127   basesink-&gt;priv-&gt;pending_step.valid = FALSE;
3128   if (basesink-&gt;pad_mode == GST_PAD_MODE_PUSH) {
3129     /* we need new segment info after the flush. */
3130     basesink-&gt;have_newsegment = FALSE;
3131     if (reset_time) {
3132       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
3133       GST_ELEMENT_START_TIME (basesink) = 0;
3134     }
3135   }
3136   GST_OBJECT_UNLOCK (basesink);
3137 
3138   if (reset_time) {
3139     GST_DEBUG_OBJECT (basesink, &quot;posting reset-time message&quot;);
3140     gst_element_post_message (GST_ELEMENT_CAST (basesink),
3141         gst_message_new_reset_time (GST_OBJECT_CAST (basesink), 0));
3142   }
3143 }
3144 
3145 static GstFlowReturn
3146 gst_base_sink_default_wait_event (GstBaseSink * basesink, GstEvent * event)
3147 {
3148   GstFlowReturn ret;
3149   gboolean late, step_end = FALSE;
3150 
3151   ret = gst_base_sink_do_sync (basesink, GST_MINI_OBJECT_CAST (event),
3152       &amp;late, &amp;step_end);
3153 
3154   return ret;
3155 }
3156 
3157 static GstFlowReturn
3158 gst_base_sink_wait_event (GstBaseSink * basesink, GstEvent * event)
3159 {
3160   GstFlowReturn ret;
3161   GstBaseSinkClass *bclass;
3162 
3163   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3164 
3165   if (G_LIKELY (bclass-&gt;wait_event))
3166     ret = bclass-&gt;wait_event (basesink, event);
3167   else
3168     ret = GST_FLOW_NOT_SUPPORTED;
3169 
3170   return ret;
3171 }
3172 
3173 static gboolean
3174 gst_base_sink_default_event (GstBaseSink * basesink, GstEvent * event)
3175 {
3176   gboolean result = TRUE;
3177   GstBaseSinkClass *bclass;
3178 
3179   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3180 
3181   switch (GST_EVENT_TYPE (event)) {
3182     case GST_EVENT_FLUSH_START:
3183     {
3184       GST_DEBUG_OBJECT (basesink, &quot;flush-start %p&quot;, event);
3185       gst_base_sink_flush_start (basesink, basesink-&gt;sinkpad);
3186       break;
3187     }
3188     case GST_EVENT_FLUSH_STOP:
3189     {
3190       gboolean reset_time;
3191 
3192       gst_event_parse_flush_stop (event, &amp;reset_time);
3193       GST_DEBUG_OBJECT (basesink, &quot;flush-stop %p, reset_time: %d&quot;, event,
3194           reset_time);
3195       gst_base_sink_flush_stop (basesink, basesink-&gt;sinkpad, reset_time);
3196       break;
3197     }
3198     case GST_EVENT_EOS:
3199     {
3200       GstMessage *message;
3201       guint32 seqnum;
3202 
3203       /* we set the received EOS flag here so that we can use it when testing if
3204        * we are prerolled and to refuse more buffers. */
3205       basesink-&gt;priv-&gt;received_eos = TRUE;
3206 
3207       /* wait for EOS */
3208       if (G_UNLIKELY (gst_base_sink_wait_event (basesink,
3209                   event) != GST_FLOW_OK)) {
3210         result = FALSE;
3211         goto done;
3212       }
3213 
3214       /* the EOS event is completely handled so we mark
3215        * ourselves as being in the EOS state. eos is also
3216        * protected by the object lock so we can read it when
3217        * answering the POSITION query. */
3218       GST_OBJECT_LOCK (basesink);
3219       basesink-&gt;eos = TRUE;
3220       GST_OBJECT_UNLOCK (basesink);
3221 
3222       /* ok, now we can post the message */
3223       GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
3224 
3225       seqnum = basesink-&gt;priv-&gt;seqnum = gst_event_get_seqnum (event);
3226       GST_DEBUG_OBJECT (basesink, &quot;Got seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3227 
3228       message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
3229       gst_message_set_seqnum (message, seqnum);
3230       gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
3231       break;
3232     }
3233     case GST_EVENT_STREAM_START:
3234     {
3235       GstMessage *message;
3236       guint32 seqnum;
3237       guint group_id;
3238 
3239       seqnum = gst_event_get_seqnum (event);
3240       GST_DEBUG_OBJECT (basesink, &quot;Now posting STREAM_START (seqnum:%d)&quot;,
3241           seqnum);
3242       message = gst_message_new_stream_start (GST_OBJECT_CAST (basesink));
3243       if (gst_event_parse_group_id (event, &amp;group_id)) {
3244         gst_message_set_group_id (message, group_id);
3245       } else {
3246         GST_FIXME_OBJECT (basesink, &quot;stream-start event without group-id. &quot;
3247             &quot;Consider implementing group-id handling in the upstream &quot;
3248             &quot;elements&quot;);
3249       }
3250       gst_message_set_seqnum (message, seqnum);
3251       gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
3252       break;
3253     }
3254     case GST_EVENT_CAPS:
3255     {
3256       GstCaps *caps, *current_caps;
3257 
3258       GST_DEBUG_OBJECT (basesink, &quot;caps %p&quot;, event);
3259 
3260       gst_event_parse_caps (event, &amp;caps);
3261       current_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (basesink));
3262 
3263       if (current_caps &amp;&amp; gst_caps_is_equal (current_caps, caps)) {
3264         GST_DEBUG_OBJECT (basesink,
3265             &quot;New caps equal to old ones: %&quot; GST_PTR_FORMAT, caps);
3266       } else {
3267         if (bclass-&gt;set_caps)
3268           result = bclass-&gt;set_caps (basesink, caps);
3269 
3270         if (result) {
3271           GST_OBJECT_LOCK (basesink);
3272           gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, caps);
3273           GST_OBJECT_UNLOCK (basesink);
3274         }
3275       }
3276       if (current_caps)
3277         gst_caps_unref (current_caps);
3278       break;
3279     }
3280     case GST_EVENT_SEGMENT:
3281       /* configure the segment */
3282       /* The segment is protected with both the STREAM_LOCK and the OBJECT_LOCK.
3283        * We protect with the OBJECT_LOCK so that we can use the values to
3284        * safely answer a POSITION query. */
3285       GST_OBJECT_LOCK (basesink);
3286       /* the newsegment event is needed to bring the buffer timestamps to the
3287        * stream time and to drop samples outside of the playback segment. */
3288       gst_event_copy_segment (event, &amp;basesink-&gt;segment);
3289       GST_DEBUG_OBJECT (basesink, &quot;configured segment %&quot; GST_SEGMENT_FORMAT,
3290           &amp;basesink-&gt;segment);
3291       basesink-&gt;have_newsegment = TRUE;
3292       gst_base_sink_reset_qos (basesink);
3293       GST_OBJECT_UNLOCK (basesink);
3294       break;
3295     case GST_EVENT_GAP:
3296     {
3297       if (G_UNLIKELY (gst_base_sink_wait_event (basesink,
3298                   event) != GST_FLOW_OK))
3299         result = FALSE;
3300       break;
3301     }
3302     case GST_EVENT_TAG:
3303     {
3304       GstTagList *taglist;
3305 
3306       gst_event_parse_tag (event, &amp;taglist);
3307 
3308       gst_element_post_message (GST_ELEMENT_CAST (basesink),
3309           gst_message_new_tag (GST_OBJECT_CAST (basesink),
3310               gst_tag_list_copy (taglist)));
3311       break;
3312     }
3313     case GST_EVENT_TOC:
3314     {
3315       GstToc *toc;
3316       gboolean updated;
3317 
3318       gst_event_parse_toc (event, &amp;toc, &amp;updated);
3319 
3320       gst_element_post_message (GST_ELEMENT_CAST (basesink),
3321           gst_message_new_toc (GST_OBJECT_CAST (basesink), toc, updated));
3322 
3323       gst_toc_unref (toc);
3324       break;
3325     }
3326     case GST_EVENT_SINK_MESSAGE:
3327     {
3328       GstMessage *msg = NULL;
3329 
3330       gst_event_parse_sink_message (event, &amp;msg);
3331       if (msg)
3332         gst_element_post_message (GST_ELEMENT_CAST (basesink), msg);
3333       break;
3334     }
3335     default:
3336       break;
3337   }
3338 done:
3339   gst_event_unref (event);
3340 
3341   return result;
3342 }
3343 
3344 static gboolean
3345 gst_base_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
3346 {
3347   GstBaseSink *basesink;
3348   gboolean result = TRUE;
3349   GstBaseSinkClass *bclass;
3350 
3351   basesink = GST_BASE_SINK_CAST (parent);
3352   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3353 
3354   GST_DEBUG_OBJECT (basesink, &quot;received event %p %&quot; GST_PTR_FORMAT, event,
3355       event);
3356 
3357   switch (GST_EVENT_TYPE (event)) {
3358     case GST_EVENT_FLUSH_STOP:
3359       /* special case for this serialized event because we don&#39;t want to grab
3360        * the PREROLL lock or check if we were flushing */
3361       if (bclass-&gt;event)
3362         result = bclass-&gt;event (basesink, event);
3363       break;
3364     default:
3365       if (GST_EVENT_IS_SERIALIZED (event)) {
3366         GST_BASE_SINK_PREROLL_LOCK (basesink);
3367         if (G_UNLIKELY (basesink-&gt;flushing))
3368           goto flushing;
3369 
3370         if (G_UNLIKELY (basesink-&gt;priv-&gt;received_eos))
3371           goto after_eos;
3372 
3373         if (bclass-&gt;event)
3374           result = bclass-&gt;event (basesink, event);
3375 
3376         GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3377       } else {
3378         if (bclass-&gt;event)
3379           result = bclass-&gt;event (basesink, event);
3380       }
3381       break;
3382   }
3383 done:
3384   return result;
3385 
3386   /* ERRORS */
3387 flushing:
3388   {
3389     GST_DEBUG_OBJECT (basesink, &quot;we are flushing&quot;);
3390     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3391     gst_event_unref (event);
3392     result = FALSE;
3393     goto done;
3394   }
3395 
3396 after_eos:
3397   {
3398     GST_DEBUG_OBJECT (basesink, &quot;Event received after EOS, dropping&quot;);
3399     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3400     gst_event_unref (event);
3401     result = FALSE;
3402     goto done;
3403   }
3404 }
3405 
3406 /* default implementation to calculate the start and end
3407  * timestamps on a buffer, subclasses can override
3408  */
3409 static void
3410 gst_base_sink_default_get_times (GstBaseSink * basesink, GstBuffer * buffer,
3411     GstClockTime * start, GstClockTime * end)
3412 {
3413   GstClockTime timestamp, duration;
3414 
3415   /* first sync on DTS, else use PTS */
3416   timestamp = GST_BUFFER_DTS (buffer);
3417   if (!GST_CLOCK_TIME_IS_VALID (timestamp))
3418     timestamp = GST_BUFFER_PTS (buffer);
3419 
3420   if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
3421     /* get duration to calculate end time */
3422     duration = GST_BUFFER_DURATION (buffer);
3423     if (GST_CLOCK_TIME_IS_VALID (duration)) {
3424       *end = timestamp + duration;
3425     }
3426     *start = timestamp;
3427   }
3428 }
3429 
3430 /* must be called with PREROLL_LOCK */
3431 static gboolean
3432 gst_base_sink_needs_preroll (GstBaseSink * basesink)
3433 {
3434   gboolean is_prerolled, res;
3435 
3436   /* we have 2 cases where the PREROLL_LOCK is released:
3437    *  1) we are blocking in the PREROLL_LOCK and thus are prerolled.
3438    *  2) we are syncing on the clock
3439    */
3440   is_prerolled = basesink-&gt;have_preroll || basesink-&gt;priv-&gt;received_eos;
3441   res = !is_prerolled;
3442 
3443   GST_DEBUG_OBJECT (basesink, &quot;have_preroll: %d, EOS: %d =&gt; needs preroll: %d&quot;,
3444       basesink-&gt;have_preroll, basesink-&gt;priv-&gt;received_eos, res);
3445 
3446   return res;
3447 }
3448 
3449 /* with STREAM_LOCK, PREROLL_LOCK
3450  *
3451  * Takes a buffer and compare the timestamps with the last segment.
3452  * If the buffer falls outside of the segment boundaries, drop it.
3453  * Else send the buffer for preroll and rendering.
3454  *
3455  * This function takes ownership of the buffer.
3456  */
3457 static GstFlowReturn
3458 gst_base_sink_chain_unlocked (GstBaseSink * basesink, GstPad * pad,
3459     gpointer obj, gboolean is_list)
3460 {
3461   GstBaseSinkClass *bclass;
3462   GstBaseSinkPrivate *priv = basesink-&gt;priv;
3463   GstFlowReturn ret = GST_FLOW_OK;
3464   GstClockTime start = GST_CLOCK_TIME_NONE, end = GST_CLOCK_TIME_NONE;
3465   GstSegment *segment;
3466   GstBuffer *sync_buf;
3467   gboolean late, step_end, prepared = FALSE;
3468 
3469   if (G_UNLIKELY (basesink-&gt;flushing))
3470     goto flushing;
3471 
3472   if (G_UNLIKELY (priv-&gt;received_eos))
3473     goto was_eos;
3474 
3475   if (is_list) {
3476     GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
3477 
3478     if (gst_buffer_list_length (buffer_list) == 0)
3479       goto empty_list;
3480 
3481     sync_buf = gst_buffer_list_get (buffer_list, 0);
3482     g_assert (NULL != sync_buf);
3483   } else {
3484     sync_buf = GST_BUFFER_CAST (obj);
3485   }
3486 
3487   /* for code clarity */
3488   segment = &amp;basesink-&gt;segment;
3489 
3490   if (G_UNLIKELY (!basesink-&gt;have_newsegment)) {
3491     gboolean sync;
3492 
3493     sync = gst_base_sink_get_sync (basesink);
3494     if (sync) {
3495       GST_ELEMENT_WARNING (basesink, STREAM, FAILED,
3496           (_(&quot;Internal data flow problem.&quot;)),
3497           (&quot;Received buffer without a new-segment. Assuming timestamps start from 0.&quot;));
3498     }
3499 
3500     /* this means this sink will assume timestamps start from 0 */
3501     GST_OBJECT_LOCK (basesink);
3502     segment-&gt;start = 0;
3503     segment-&gt;stop = -1;
3504     basesink-&gt;segment.start = 0;
3505     basesink-&gt;segment.stop = -1;
3506     basesink-&gt;have_newsegment = TRUE;
3507     GST_OBJECT_UNLOCK (basesink);
3508   }
3509 
3510   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3511 
3512   /* check if the buffer needs to be dropped, we first ask the subclass for the
3513    * start and end */
3514   if (bclass-&gt;get_times)
3515     bclass-&gt;get_times (basesink, sync_buf, &amp;start, &amp;end);
3516 
3517   if (!GST_CLOCK_TIME_IS_VALID (start)) {
3518     /* if the subclass does not want sync, we use our own values so that we at
3519      * least clip the buffer to the segment */
3520     gst_base_sink_default_get_times (basesink, sync_buf, &amp;start, &amp;end);
3521   }
3522 
3523   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
3524       &quot;, end: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (end));
3525 
3526   /* a dropped buffer does not participate in anything. Buffer can only be
<a name="34" id="anc34"></a><span class="line-modified">3527    * dropped if their PTS falls completely outside the segment, while we sync</span>
3528    * preferably on DTS */
3529   if (GST_CLOCK_TIME_IS_VALID (start) &amp;&amp; (segment-&gt;format == GST_FORMAT_TIME)) {
3530     GstClockTime pts = GST_BUFFER_PTS (sync_buf);
3531     GstClockTime pts_end = GST_CLOCK_TIME_NONE;
3532 
3533     if (!GST_CLOCK_TIME_IS_VALID (pts))
3534       pts = start;
3535 
3536     if (GST_CLOCK_TIME_IS_VALID (end))
3537       pts_end = pts + (end - start);
3538 
3539     if (G_UNLIKELY (!gst_segment_clip (segment,
3540                 GST_FORMAT_TIME, pts, pts_end, NULL, NULL)
3541             &amp;&amp; priv-&gt;drop_out_of_segment))
3542       goto out_of_segment;
3543   }
3544 
3545   if (bclass-&gt;prepare || bclass-&gt;prepare_list) {
3546     gboolean do_sync = TRUE, stepped = FALSE, syncable = TRUE;
3547     GstClockTime sstart, sstop, rstart, rstop, rnext;
3548     GstStepInfo *current;
3549 
3550     late = FALSE;
3551     step_end = FALSE;
3552 
3553     current = &amp;priv-&gt;current_step;
3554     syncable =
3555         gst_base_sink_get_sync_times (basesink, obj, &amp;sstart, &amp;sstop, &amp;rstart,
3556         &amp;rstop, &amp;rnext, &amp;do_sync, &amp;stepped, current, &amp;step_end);
3557 
3558     if (G_UNLIKELY (stepped))
3559       goto dropped;
3560 
3561     if (syncable &amp;&amp; do_sync &amp;&amp; gst_base_sink_get_sync (basesink)) {
3562       GstClock *clock;
3563 
3564       GST_OBJECT_LOCK (basesink);
3565       clock = GST_ELEMENT_CLOCK (basesink);
3566       if (clock &amp;&amp; GST_STATE (basesink) == GST_STATE_PLAYING) {
3567         GstClockTime base_time;
3568         GstClockTime stime;
3569         GstClockTime now;
3570 
3571         base_time = GST_ELEMENT_CAST (basesink)-&gt;base_time;
3572         stime = base_time + gst_base_sink_adjust_time (basesink, rstart);
3573         now = gst_clock_get_time (clock);
3574         GST_OBJECT_UNLOCK (basesink);
3575 
3576         late =
3577             gst_base_sink_is_too_late (basesink, obj, rstart, rstop,
3578             GST_CLOCK_EARLY, GST_CLOCK_DIFF (stime, now), FALSE);
3579       } else {
3580         GST_OBJECT_UNLOCK (basesink);
3581       }
3582     }
3583 
3584     /* We are about to prepare the first frame, make sure we have prerolled
3585      * already. This prevent nesting prepare/render calls. */
3586     ret = gst_base_sink_do_preroll (basesink, obj);
3587     if (G_UNLIKELY (ret != GST_FLOW_OK))
3588       goto preroll_failed;
3589 
3590     if (G_UNLIKELY (late))
3591       goto dropped;
3592 
3593     if (!is_list) {
3594       if (bclass-&gt;prepare) {
3595         ret = bclass-&gt;prepare (basesink, GST_BUFFER_CAST (obj));
3596         if (G_UNLIKELY (ret != GST_FLOW_OK))
3597           goto prepare_failed;
3598       }
3599     } else {
3600       if (bclass-&gt;prepare_list) {
3601         ret = bclass-&gt;prepare_list (basesink, GST_BUFFER_LIST_CAST (obj));
3602         if (G_UNLIKELY (ret != GST_FLOW_OK))
3603           goto prepare_failed;
3604       }
3605     }
3606 
3607     prepared = TRUE;
3608   }
3609 
3610 again:
3611   late = FALSE;
3612   step_end = FALSE;
3613 
3614   /* synchronize this object, non syncable objects return OK
3615    * immediately. */
3616   ret = gst_base_sink_do_sync (basesink, GST_MINI_OBJECT_CAST (sync_buf),
3617       &amp;late, &amp;step_end);
3618   if (G_UNLIKELY (ret != GST_FLOW_OK))
3619     goto sync_failed;
3620 
3621   /* Don&#39;t skip if prepare() was called on time */
3622   late = late &amp;&amp; !prepared;
3623 
3624   /* drop late buffers unconditionally, let&#39;s hope it&#39;s unlikely */
3625   if (G_UNLIKELY (late))
3626     goto dropped;
3627 
3628   if (priv-&gt;max_bitrate) {
3629     gsize size;
3630 
3631     if (is_list)
3632       size = gst_buffer_list_calculate_size (GST_BUFFER_LIST_CAST (obj));
3633     else
3634       size = gst_buffer_get_size (GST_BUFFER_CAST (obj));
3635 
3636     priv-&gt;rc_accumulated += size;
3637     priv-&gt;rc_next = priv-&gt;rc_time + gst_util_uint64_scale (priv-&gt;rc_accumulated,
3638         8 * GST_SECOND, priv-&gt;max_bitrate);
3639   }
3640 
3641   GST_DEBUG_OBJECT (basesink, &quot;rendering object %p&quot;, obj);
3642 
3643   if (!is_list) {
3644     /* For buffer lists do not set last buffer for now. */
3645     gst_base_sink_set_last_buffer (basesink, GST_BUFFER_CAST (obj));
3646     gst_base_sink_set_last_buffer_list (basesink, NULL);
3647 
3648     if (bclass-&gt;render)
3649       ret = bclass-&gt;render (basesink, GST_BUFFER_CAST (obj));
3650   } else {
3651     GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
3652 
3653     if (bclass-&gt;render_list)
3654       ret = bclass-&gt;render_list (basesink, buffer_list);
3655 
3656     /* Set the first buffer and buffer list to be included in last sample */
3657     gst_base_sink_set_last_buffer (basesink, sync_buf);
3658     gst_base_sink_set_last_buffer_list (basesink, buffer_list);
3659   }
3660 
3661   if (ret == GST_FLOW_STEP)
3662     goto again;
3663 
3664   if (G_UNLIKELY (basesink-&gt;flushing))
3665     goto flushing;
3666 
3667   priv-&gt;rendered++;
3668 
3669 done:
3670   if (step_end) {
3671     /* the step ended, check if we need to activate a new step */
3672     GST_DEBUG_OBJECT (basesink, &quot;step ended&quot;);
3673     stop_stepping (basesink, &amp;basesink-&gt;segment, &amp;priv-&gt;current_step,
3674         priv-&gt;current_rstart, priv-&gt;current_rstop, basesink-&gt;eos);
3675     goto again;
3676   }
3677 
3678   gst_base_sink_perform_qos (basesink, late);
3679 
3680   GST_DEBUG_OBJECT (basesink, &quot;object unref after render %p&quot;, obj);
3681   gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3682 
3683   return ret;
3684 
3685   /* ERRORS */
3686 flushing:
3687   {
3688     GST_DEBUG_OBJECT (basesink, &quot;sink is flushing&quot;);
3689     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3690     return GST_FLOW_FLUSHING;
3691   }
3692 was_eos:
3693   {
3694     GST_DEBUG_OBJECT (basesink, &quot;we are EOS, dropping object, return EOS&quot;);
3695     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3696     return GST_FLOW_EOS;
3697   }
3698 empty_list:
3699   {
3700     GST_DEBUG_OBJECT (basesink, &quot;buffer list with no buffers&quot;);
3701     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3702     return GST_FLOW_OK;
3703   }
3704 out_of_segment:
3705   {
3706     GST_DEBUG_OBJECT (basesink, &quot;dropping buffer, out of clipping segment&quot;);
3707     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3708     return GST_FLOW_OK;
3709   }
3710 prepare_failed:
3711   {
3712     GST_DEBUG_OBJECT (basesink, &quot;prepare buffer failed %s&quot;,
3713         gst_flow_get_name (ret));
3714     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3715     return ret;
3716   }
3717 sync_failed:
3718   {
3719     GST_DEBUG_OBJECT (basesink, &quot;do_sync returned %s&quot;, gst_flow_get_name (ret));
3720     goto done;
3721   }
3722 dropped:
3723   {
3724     priv-&gt;dropped++;
3725     GST_DEBUG_OBJECT (basesink, &quot;buffer late, dropping&quot;);
3726 
3727     if (g_atomic_int_get (&amp;priv-&gt;qos_enabled)) {
3728       GstMessage *qos_msg;
3729       GstClockTime timestamp, duration;
3730 
3731       timestamp = GST_BUFFER_TIMESTAMP (GST_BUFFER_CAST (sync_buf));
3732       duration = GST_BUFFER_DURATION (GST_BUFFER_CAST (sync_buf));
3733 
3734       GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
3735           &quot;qos: dropped buffer rt %&quot; GST_TIME_FORMAT &quot;, st %&quot; GST_TIME_FORMAT
3736           &quot;, ts %&quot; GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT,
3737           GST_TIME_ARGS (priv-&gt;current_rstart),
3738           GST_TIME_ARGS (priv-&gt;current_sstart), GST_TIME_ARGS (timestamp),
3739           GST_TIME_ARGS (duration));
3740       GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
3741           &quot;qos: rendered %&quot; G_GUINT64_FORMAT &quot;, dropped %&quot; G_GUINT64_FORMAT,
3742           priv-&gt;rendered, priv-&gt;dropped);
3743 
3744       qos_msg =
3745           gst_message_new_qos (GST_OBJECT_CAST (basesink), basesink-&gt;sync,
3746           priv-&gt;current_rstart, priv-&gt;current_sstart, timestamp, duration);
3747       gst_message_set_qos_values (qos_msg, priv-&gt;current_jitter, priv-&gt;avg_rate,
3748           1000000);
3749       gst_message_set_qos_stats (qos_msg, GST_FORMAT_BUFFERS, priv-&gt;rendered,
3750           priv-&gt;dropped);
3751       gst_element_post_message (GST_ELEMENT_CAST (basesink), qos_msg);
3752     }
3753     goto done;
3754   }
3755 preroll_failed:
3756   {
3757     GST_DEBUG_OBJECT (basesink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
3758     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3759     return ret;
3760   }
3761 }
3762 
3763 /* with STREAM_LOCK
3764  */
3765 static GstFlowReturn
3766 gst_base_sink_chain_main (GstBaseSink * basesink, GstPad * pad, gpointer obj,
3767     gboolean is_list)
3768 {
3769   GstFlowReturn result;
3770 
3771   if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PUSH))
3772     goto wrong_mode;
3773 
3774   GST_BASE_SINK_PREROLL_LOCK (basesink);
3775   result = gst_base_sink_chain_unlocked (basesink, pad, obj, is_list);
3776   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3777 
3778 done:
3779   return result;
3780 
3781   /* ERRORS */
3782 wrong_mode:
3783   {
3784     GST_OBJECT_LOCK (pad);
3785     GST_WARNING_OBJECT (basesink,
3786         &quot;Push on pad %s:%s, but it was not activated in push mode&quot;,
3787         GST_DEBUG_PAD_NAME (pad));
3788     GST_OBJECT_UNLOCK (pad);
3789     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3790     /* we don&#39;t post an error message this will signal to the peer
3791      * pushing that EOS is reached. */
3792     result = GST_FLOW_EOS;
3793     goto done;
3794   }
3795 }
3796 
3797 static GstFlowReturn
3798 gst_base_sink_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
3799 {
3800   GstBaseSink *basesink;
3801 
3802   basesink = GST_BASE_SINK (parent);
3803 
3804   return gst_base_sink_chain_main (basesink, pad, buf, FALSE);
3805 }
3806 
3807 static GstFlowReturn
3808 gst_base_sink_chain_list (GstPad * pad, GstObject * parent,
3809     GstBufferList * list)
3810 {
3811   GstBaseSink *basesink;
3812   GstBaseSinkClass *bclass;
3813   GstFlowReturn result;
3814 
3815   basesink = GST_BASE_SINK (parent);
3816   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3817 
3818   if (G_LIKELY (bclass-&gt;render_list)) {
3819     result = gst_base_sink_chain_main (basesink, pad, list, TRUE);
3820   } else {
3821     guint i, len;
3822     GstBuffer *buffer;
3823 
3824     GST_LOG_OBJECT (pad, &quot;chaining each buffer in list&quot;);
3825 
3826     len = gst_buffer_list_length (list);
3827 
3828     result = GST_FLOW_OK;
3829     for (i = 0; i &lt; len; i++) {
3830       buffer = gst_buffer_list_get (list, i);
3831       result = gst_base_sink_chain_main (basesink, pad,
3832           gst_buffer_ref (buffer), FALSE);
3833       if (result != GST_FLOW_OK)
3834         break;
3835     }
3836     gst_buffer_list_unref (list);
3837   }
3838   return result;
3839 }
3840 
3841 
3842 static gboolean
3843 gst_base_sink_default_do_seek (GstBaseSink * sink, GstSegment * segment)
3844 {
3845   gboolean res = TRUE;
3846 
3847   /* update our offset if the start/stop position was updated */
3848   if (segment-&gt;format == GST_FORMAT_BYTES) {
3849     segment-&gt;time = segment-&gt;start;
3850   } else if (segment-&gt;start == 0) {
3851     /* seek to start, we can implement a default for this. */
3852     segment-&gt;time = 0;
3853   } else {
3854     res = FALSE;
3855     GST_INFO_OBJECT (sink, &quot;Can&#39;t do a default seek&quot;);
3856   }
3857 
3858   return res;
3859 }
3860 
3861 #define SEEK_TYPE_IS_RELATIVE(t) (((t) != GST_SEEK_TYPE_NONE) &amp;&amp; ((t) != GST_SEEK_TYPE_SET))
3862 
3863 static gboolean
3864 gst_base_sink_default_prepare_seek_segment (GstBaseSink * sink,
3865     GstEvent * event, GstSegment * segment)
3866 {
3867   /* By default, we try one of 2 things:
3868    *   - For absolute seek positions, convert the requested position to our
3869    *     configured processing format and place it in the output segment \
3870    *   - For relative seek positions, convert our current (input) values to the
3871    *     seek format, adjust by the relative seek offset and then convert back to
3872    *     the processing format
3873    */
3874   GstSeekType start_type, stop_type;
3875   gint64 start, stop;
3876   GstSeekFlags flags;
3877   GstFormat seek_format;
3878   gdouble rate;
3879   gboolean update;
3880   gboolean res = TRUE;
3881 
3882   gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
3883       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
3884 
3885   if (seek_format == segment-&gt;format) {
3886     gst_segment_do_seek (segment, rate, seek_format, flags,
3887         start_type, start, stop_type, stop, &amp;update);
3888     return TRUE;
3889   }
3890 
3891   if (start_type != GST_SEEK_TYPE_NONE) {
3892     /* FIXME: Handle seek_end by converting the input segment vals */
3893     res =
3894         gst_pad_query_convert (sink-&gt;sinkpad, seek_format, start,
3895         segment-&gt;format, &amp;start);
3896     start_type = GST_SEEK_TYPE_SET;
3897   }
3898 
3899   if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE) {
3900     /* FIXME: Handle seek_end by converting the input segment vals */
3901     res =
3902         gst_pad_query_convert (sink-&gt;sinkpad, seek_format, stop,
3903         segment-&gt;format, &amp;stop);
3904     stop_type = GST_SEEK_TYPE_SET;
3905   }
3906 
3907   /* And finally, configure our output segment in the desired format */
3908   gst_segment_do_seek (segment, rate, segment-&gt;format, flags, start_type, start,
3909       stop_type, stop, &amp;update);
3910 
3911   if (!res)
3912     goto no_format;
3913 
3914   return res;
3915 
3916 no_format:
3917   {
3918     GST_DEBUG_OBJECT (sink, &quot;undefined format given, seek aborted.&quot;);
3919     return FALSE;
3920   }
3921 }
3922 
3923 /* perform a seek, only executed in pull mode */
3924 static gboolean
3925 gst_base_sink_perform_seek (GstBaseSink * sink, GstPad * pad, GstEvent * event)
3926 {
3927   gboolean flush;
3928   gdouble rate;
3929   GstFormat seek_format, dest_format;
3930   GstSeekFlags flags;
3931   GstSeekType start_type, stop_type;
3932   gboolean seekseg_configured = FALSE;
3933   gint64 start, stop;
3934   gboolean update, res = TRUE;
3935   GstSegment seeksegment;
3936 
3937   dest_format = sink-&gt;segment.format;
3938 
3939   if (event) {
3940     GST_DEBUG_OBJECT (sink, &quot;performing seek with event %p&quot;, event);
3941     gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
3942         &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
3943 
3944     flush = flags &amp; GST_SEEK_FLAG_FLUSH;
3945   } else {
3946     GST_DEBUG_OBJECT (sink, &quot;performing seek without event&quot;);
3947     flush = FALSE;
3948   }
3949 
3950   if (flush) {
3951     GST_DEBUG_OBJECT (sink, &quot;flushing upstream&quot;);
3952     gst_pad_push_event (pad, gst_event_new_flush_start ());
3953     gst_base_sink_flush_start (sink, pad);
3954   } else {
3955     GST_DEBUG_OBJECT (sink, &quot;pausing pulling thread&quot;);
3956   }
3957 
3958   GST_PAD_STREAM_LOCK (pad);
3959 
3960   /* If we configured the seeksegment above, don&#39;t overwrite it now. Otherwise
3961    * copy the current segment info into the temp segment that we can actually
3962    * attempt the seek with. We only update the real segment if the seek succeeds. */
3963   if (!seekseg_configured) {
3964     memcpy (&amp;seeksegment, &amp;sink-&gt;segment, sizeof (GstSegment));
3965 
3966     /* now configure the final seek segment */
3967     if (event) {
3968       if (sink-&gt;segment.format != seek_format) {
3969         /* OK, here&#39;s where we give the subclass a chance to convert the relative
3970          * seek into an absolute one in the processing format. We set up any
3971          * absolute seek above, before taking the stream lock. */
3972         if (!gst_base_sink_default_prepare_seek_segment (sink, event,
3973                 &amp;seeksegment)) {
3974           GST_DEBUG_OBJECT (sink,
3975               &quot;Preparing the seek failed after flushing. &quot; &quot;Aborting seek&quot;);
3976           res = FALSE;
3977         }
3978       } else {
3979         /* The seek format matches our processing format, no need to ask the
3980          * the subclass to configure the segment. */
3981         gst_segment_do_seek (&amp;seeksegment, rate, seek_format, flags,
3982             start_type, start, stop_type, stop, &amp;update);
3983       }
3984     }
3985     /* Else, no seek event passed, so we&#39;re just (re)starting the
3986        current segment. */
3987   }
3988 
3989   if (res) {
3990     GST_DEBUG_OBJECT (sink, &quot;segment configured from %&quot; G_GINT64_FORMAT
3991         &quot; to %&quot; G_GINT64_FORMAT &quot;, position %&quot; G_GINT64_FORMAT,
3992         seeksegment.start, seeksegment.stop, seeksegment.position);
3993 
3994     /* do the seek, segment.position contains the new position. */
3995     res = gst_base_sink_default_do_seek (sink, &amp;seeksegment);
3996   }
3997 
3998   if (flush) {
3999     GST_DEBUG_OBJECT (sink, &quot;stop flushing upstream&quot;);
4000     gst_pad_push_event (pad, gst_event_new_flush_stop (TRUE));
4001     gst_base_sink_flush_stop (sink, pad, TRUE);
4002   } else if (res &amp;&amp; sink-&gt;running) {
4003     /* we are running the current segment and doing a non-flushing seek,
4004      * close the segment first based on the position. */
4005     GST_DEBUG_OBJECT (sink, &quot;closing running segment %&quot; G_GINT64_FORMAT
4006         &quot; to %&quot; G_GINT64_FORMAT, sink-&gt;segment.start, sink-&gt;segment.position);
4007   }
4008 
4009   /* The subclass must have converted the segment to the processing format
4010    * by now */
4011   if (res &amp;&amp; seeksegment.format != dest_format) {
4012     GST_DEBUG_OBJECT (sink, &quot;Subclass failed to prepare a seek segment &quot;
4013         &quot;in the correct format. Aborting seek.&quot;);
4014     res = FALSE;
4015   }
4016 
4017   GST_INFO_OBJECT (sink, &quot;seeking done %d: %&quot; GST_SEGMENT_FORMAT, res,
4018       &amp;seeksegment);
4019 
4020   /* if successful seek, we update our real segment and push
4021    * out the new segment. */
4022   if (res) {
4023     gst_segment_copy_into (&amp;seeksegment, &amp;sink-&gt;segment);
4024 
4025     if (sink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
4026       gst_element_post_message (GST_ELEMENT (sink),
4027           gst_message_new_segment_start (GST_OBJECT (sink),
4028               sink-&gt;segment.format, sink-&gt;segment.position));
4029     }
4030   }
4031 
4032   sink-&gt;priv-&gt;discont = TRUE;
4033   sink-&gt;running = TRUE;
4034 
4035   GST_PAD_STREAM_UNLOCK (pad);
4036 
4037   return res;
4038 }
4039 
4040 static void
4041 set_step_info (GstBaseSink * sink, GstStepInfo * current, GstStepInfo * pending,
4042     guint seqnum, GstFormat format, guint64 amount, gdouble rate,
4043     gboolean flush, gboolean intermediate)
4044 {
4045   GST_OBJECT_LOCK (sink);
4046   pending-&gt;seqnum = seqnum;
4047   pending-&gt;format = format;
4048   pending-&gt;amount = amount;
4049   pending-&gt;position = 0;
4050   pending-&gt;rate = rate;
4051   pending-&gt;flush = flush;
4052   pending-&gt;intermediate = intermediate;
4053   pending-&gt;valid = TRUE;
4054   /* flush invalidates the current stepping segment */
4055   if (flush)
4056     current-&gt;valid = FALSE;
4057   GST_OBJECT_UNLOCK (sink);
4058 }
4059 
4060 static gboolean
4061 gst_base_sink_perform_step (GstBaseSink * sink, GstPad * pad, GstEvent * event)
4062 {
4063   GstBaseSinkPrivate *priv;
4064   GstBaseSinkClass *bclass;
4065   gboolean flush, intermediate;
4066   gdouble rate;
4067   GstFormat format;
4068   guint64 amount;
4069   guint seqnum;
4070   GstStepInfo *pending, *current;
4071   GstMessage *message;
4072 
4073   bclass = GST_BASE_SINK_GET_CLASS (sink);
4074   priv = sink-&gt;priv;
4075 
4076   GST_DEBUG_OBJECT (sink, &quot;performing step with event %p&quot;, event);
4077 
4078   gst_event_parse_step (event, &amp;format, &amp;amount, &amp;rate, &amp;flush, &amp;intermediate);
4079   seqnum = gst_event_get_seqnum (event);
4080 
4081   pending = &amp;priv-&gt;pending_step;
4082   current = &amp;priv-&gt;current_step;
4083 
4084   /* post message first */
4085   message = gst_message_new_step_start (GST_OBJECT (sink), FALSE, format,
4086       amount, rate, flush, intermediate);
4087   gst_message_set_seqnum (message, seqnum);
4088   gst_element_post_message (GST_ELEMENT (sink), message);
4089 
4090   if (flush) {
4091     /* we need to call ::unlock before locking PREROLL_LOCK
4092      * since we lock it before going into ::render */
4093     if (bclass-&gt;unlock)
4094       bclass-&gt;unlock (sink);
4095 
4096     GST_BASE_SINK_PREROLL_LOCK (sink);
4097     /* now that we have the PREROLL lock, clear our unlock request */
4098     if (bclass-&gt;unlock_stop)
4099       bclass-&gt;unlock_stop (sink);
4100 
4101     /* update the stepinfo and make it valid */
4102     set_step_info (sink, current, pending, seqnum, format, amount, rate, flush,
4103         intermediate);
4104 
4105     if (sink-&gt;priv-&gt;async_enabled) {
4106       /* and we need to commit our state again on the next
4107        * prerolled buffer */
4108       sink-&gt;playing_async = TRUE;
4109       priv-&gt;pending_step.need_preroll = TRUE;
4110       sink-&gt;need_preroll = FALSE;
4111       gst_base_sink_update_start_time (sink);
4112       gst_element_lost_state (GST_ELEMENT_CAST (sink));
4113     } else {
4114       sink-&gt;priv-&gt;have_latency = TRUE;
4115       sink-&gt;need_preroll = FALSE;
4116     }
4117     priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
4118     priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
4119     priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
4120     priv-&gt;call_preroll = TRUE;
4121     gst_base_sink_set_last_buffer (sink, NULL);
4122     gst_base_sink_set_last_buffer_list (sink, NULL);
4123     gst_base_sink_reset_qos (sink);
4124 
4125     if (sink-&gt;clock_id) {
4126       gst_clock_id_unschedule (sink-&gt;clock_id);
4127     }
4128 
4129     if (sink-&gt;have_preroll) {
4130       GST_DEBUG_OBJECT (sink, &quot;signal waiter&quot;);
4131       priv-&gt;step_unlock = TRUE;
4132       GST_BASE_SINK_PREROLL_SIGNAL (sink);
4133     }
4134     GST_BASE_SINK_PREROLL_UNLOCK (sink);
4135   } else {
4136     /* update the stepinfo and make it valid */
4137     set_step_info (sink, current, pending, seqnum, format, amount, rate, flush,
4138         intermediate);
4139   }
4140 
4141   return TRUE;
4142 }
4143 
4144 /* with STREAM_LOCK
4145  */
4146 static void
4147 gst_base_sink_loop (GstPad * pad)
4148 {
4149   GstObject *parent;
4150   GstBaseSink *basesink;
4151   GstBuffer *buf = NULL;
4152   GstFlowReturn result;
4153   guint blocksize;
4154   guint64 offset;
4155 
4156   parent = GST_OBJECT_PARENT (pad);
4157   basesink = GST_BASE_SINK (parent);
4158 
4159   g_assert (basesink-&gt;pad_mode == GST_PAD_MODE_PULL);
4160 
4161   if ((blocksize = basesink-&gt;priv-&gt;blocksize) == 0)
4162     blocksize = -1;
4163 
4164   offset = basesink-&gt;segment.position;
4165 
4166   GST_DEBUG_OBJECT (basesink, &quot;pulling %&quot; G_GUINT64_FORMAT &quot;, %u&quot;,
4167       offset, blocksize);
4168 
4169   result = gst_pad_pull_range (pad, offset, blocksize, &amp;buf);
4170   if (G_UNLIKELY (result != GST_FLOW_OK))
4171     goto paused;
4172 
4173   if (G_UNLIKELY (buf == NULL))
4174     goto no_buffer;
4175 
4176   offset += gst_buffer_get_size (buf);
4177 
4178   basesink-&gt;segment.position = offset;
4179 
4180   GST_BASE_SINK_PREROLL_LOCK (basesink);
4181   result = gst_base_sink_chain_unlocked (basesink, pad, buf, FALSE);
4182   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
4183   if (G_UNLIKELY (result != GST_FLOW_OK))
4184     goto paused;
4185 
4186   return;
4187 
4188   /* ERRORS */
4189 paused:
4190   {
4191     GST_LOG_OBJECT (basesink, &quot;pausing task, reason %s&quot;,
4192         gst_flow_get_name (result));
4193     gst_pad_pause_task (pad);
4194     if (result == GST_FLOW_EOS) {
4195       /* perform EOS logic */
4196       if (basesink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
4197         gst_element_post_message (GST_ELEMENT_CAST (basesink),
4198             gst_message_new_segment_done (GST_OBJECT_CAST (basesink),
4199                 basesink-&gt;segment.format, basesink-&gt;segment.position));
4200         gst_base_sink_event (pad, parent,
4201             gst_event_new_segment_done (basesink-&gt;segment.format,
4202                 basesink-&gt;segment.position));
4203       } else {
4204         gst_base_sink_event (pad, parent, gst_event_new_eos ());
4205       }
4206     } else if (result == GST_FLOW_NOT_LINKED || result &lt;= GST_FLOW_EOS) {
4207       /* for fatal errors we post an error message, post the error
4208        * first so the app knows about the error first.
4209        * wrong-state is not a fatal error because it happens due to
4210        * flushing and posting an error message in that case is the
4211        * wrong thing to do, e.g. when basesrc is doing a flushing
4212        * seek. */
4213       GST_ELEMENT_FLOW_ERROR (basesink, result);
4214       gst_base_sink_event (pad, parent, gst_event_new_eos ());
4215     }
4216     return;
4217   }
4218 no_buffer:
4219   {
4220     GST_LOG_OBJECT (basesink, &quot;no buffer, pausing&quot;);
4221     GST_ELEMENT_ERROR (basesink, STREAM, FAILED,
4222         (_(&quot;Internal data flow error.&quot;)), (&quot;element returned NULL buffer&quot;));
4223     result = GST_FLOW_ERROR;
4224     goto paused;
4225   }
4226 }
4227 
4228 static gboolean
4229 gst_base_sink_set_flushing (GstBaseSink * basesink, GstPad * pad,
4230     gboolean flushing)
4231 {
4232   GstBaseSinkClass *bclass;
4233 
4234   bclass = GST_BASE_SINK_GET_CLASS (basesink);
4235 
4236   if (flushing) {
4237     /* unlock any subclasses, we need to do this before grabbing the
4238      * PREROLL_LOCK since we hold this lock before going into ::render. */
4239     if (bclass-&gt;unlock)
4240       bclass-&gt;unlock (basesink);
4241   }
4242 
4243   GST_BASE_SINK_PREROLL_LOCK (basesink);
4244   basesink-&gt;flushing = flushing;
4245   if (flushing) {
4246     /* step 1, now that we have the PREROLL lock, clear our unlock request */
4247     if (bclass-&gt;unlock_stop)
4248       bclass-&gt;unlock_stop (basesink);
4249 
4250     /* set need_preroll before we unblock the clock. If the clock is unblocked
4251      * before timing out, we can reuse the buffer for preroll. */
4252     basesink-&gt;need_preroll = TRUE;
4253 
4254     /* step 2, unblock clock sync (if any) or any other blocking thing */
4255     if (basesink-&gt;clock_id) {
4256       gst_clock_id_unschedule (basesink-&gt;clock_id);
4257     }
4258 
4259     /* flush out the data thread if it&#39;s locked in finish_preroll, this will
4260      * also flush out the EOS state */
4261     GST_DEBUG_OBJECT (basesink,
4262         &quot;flushing out data thread, need preroll to TRUE&quot;);
4263 
4264     /* we can&#39;t have EOS anymore now */
4265     basesink-&gt;eos = FALSE;
4266     basesink-&gt;priv-&gt;received_eos = FALSE;
4267     basesink-&gt;have_preroll = FALSE;
4268     basesink-&gt;priv-&gt;step_unlock = FALSE;
4269     /* can&#39;t report latency anymore until we preroll again */
4270     if (basesink-&gt;priv-&gt;async_enabled) {
4271       GST_OBJECT_LOCK (basesink);
4272       basesink-&gt;priv-&gt;have_latency = FALSE;
4273       GST_OBJECT_UNLOCK (basesink);
4274     }
4275     /* and signal any waiters now */
4276     GST_BASE_SINK_PREROLL_SIGNAL (basesink);
4277   }
4278   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
4279 
4280   return TRUE;
4281 }
4282 
4283 static gboolean
4284 gst_base_sink_default_activate_pull (GstBaseSink * basesink, gboolean active)
4285 {
4286   gboolean result;
4287 
4288   if (active) {
4289     /* start task */
4290     result = gst_pad_start_task (basesink-&gt;sinkpad,
4291         (GstTaskFunction) gst_base_sink_loop, basesink-&gt;sinkpad, NULL);
4292   } else {
4293     /* step 2, make sure streaming finishes */
4294     result = gst_pad_stop_task (basesink-&gt;sinkpad);
4295   }
4296 
4297   return result;
4298 }
4299 
4300 static gboolean
4301 gst_base_sink_pad_activate (GstPad * pad, GstObject * parent)
4302 {
4303   gboolean result = FALSE;
4304   GstBaseSink *basesink;
4305   GstQuery *query;
4306   gboolean pull_mode;
4307 
4308   basesink = GST_BASE_SINK (parent);
4309 
4310   GST_DEBUG_OBJECT (basesink, &quot;Trying pull mode first&quot;);
4311 
4312   gst_base_sink_set_flushing (basesink, pad, FALSE);
4313 
4314   /* we need to have the pull mode enabled */
4315   if (!basesink-&gt;can_activate_pull) {
4316     GST_DEBUG_OBJECT (basesink, &quot;pull mode disabled&quot;);
4317     goto fallback;
4318   }
4319 
4320   /* check if downstreams supports pull mode at all */
4321   query = gst_query_new_scheduling ();
4322 
4323   if (!gst_pad_peer_query (pad, query)) {
4324     gst_query_unref (query);
<a name="35" id="anc35"></a><span class="line-modified">4325     GST_DEBUG_OBJECT (basesink, &quot;peer query failed, no pull mode&quot;);</span>
4326     goto fallback;
4327   }
4328 
4329   /* parse result of the query */
4330   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL);
4331   gst_query_unref (query);
4332 
4333   if (!pull_mode) {
4334     GST_DEBUG_OBJECT (basesink, &quot;pull mode not supported&quot;);
4335     goto fallback;
4336   }
4337 
4338   /* set the pad mode before starting the task so that it&#39;s in the
4339    * correct state for the new thread. also the sink set_caps and get_caps
4340    * function checks this */
4341   basesink-&gt;pad_mode = GST_PAD_MODE_PULL;
4342 
4343   /* we first try to negotiate a format so that when we try to activate
4344    * downstream, it knows about our format */
4345   if (!gst_base_sink_negotiate_pull (basesink)) {
4346     GST_DEBUG_OBJECT (basesink, &quot;failed to negotiate in pull mode&quot;);
4347     goto fallback;
4348   }
4349 
4350   /* ok activate now */
4351   if (!gst_pad_activate_mode (pad, GST_PAD_MODE_PULL, TRUE)) {
4352     /* clear any pending caps */
4353     GST_OBJECT_LOCK (basesink);
4354     gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
4355     GST_OBJECT_UNLOCK (basesink);
4356     GST_DEBUG_OBJECT (basesink, &quot;failed to activate in pull mode&quot;);
4357     goto fallback;
4358   }
4359 
4360   GST_DEBUG_OBJECT (basesink, &quot;Success activating pull mode&quot;);
4361   result = TRUE;
4362   goto done;
4363 
4364   /* push mode fallback */
4365 fallback:
4366   GST_DEBUG_OBJECT (basesink, &quot;Falling back to push mode&quot;);
4367   if ((result = gst_pad_activate_mode (pad, GST_PAD_MODE_PUSH, TRUE))) {
4368     GST_DEBUG_OBJECT (basesink, &quot;Success activating push mode&quot;);
4369   }
4370 
4371 done:
4372   if (!result) {
4373     GST_WARNING_OBJECT (basesink, &quot;Could not activate pad in either mode&quot;);
4374     gst_base_sink_set_flushing (basesink, pad, TRUE);
4375   }
4376 
4377   return result;
4378 }
4379 
4380 static gboolean
4381 gst_base_sink_pad_activate_push (GstPad * pad, GstObject * parent,
4382     gboolean active)
4383 {
4384   gboolean result;
4385   GstBaseSink *basesink;
4386 
4387   basesink = GST_BASE_SINK (parent);
4388 
4389   if (active) {
4390     if (!basesink-&gt;can_activate_push) {
4391       result = FALSE;
4392       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4393     } else {
4394       result = TRUE;
4395       basesink-&gt;pad_mode = GST_PAD_MODE_PUSH;
4396     }
4397   } else {
4398     if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PUSH)) {
4399       g_warning (&quot;Internal GStreamer activation error!!!&quot;);
4400       result = FALSE;
4401     } else {
4402       gst_base_sink_set_flushing (basesink, pad, TRUE);
4403       result = TRUE;
4404       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4405     }
4406   }
4407 
4408   return result;
4409 }
4410 
4411 static gboolean
4412 gst_base_sink_negotiate_pull (GstBaseSink * basesink)
4413 {
4414   GstCaps *caps;
4415   gboolean result;
4416 
4417   result = FALSE;
4418 
4419   /* this returns the intersection between our caps and the peer caps. If there
4420    * is no peer, it returns %NULL and we can&#39;t operate in pull mode so we can
4421    * fail the negotiation. */
4422   caps = gst_pad_get_allowed_caps (GST_BASE_SINK_PAD (basesink));
4423   if (caps == NULL || gst_caps_is_empty (caps))
4424     goto no_caps_possible;
4425 
4426   GST_DEBUG_OBJECT (basesink, &quot;allowed caps: %&quot; GST_PTR_FORMAT, caps);
4427 
4428   if (gst_caps_is_any (caps)) {
4429     GST_DEBUG_OBJECT (basesink, &quot;caps were ANY after fixating, &quot;
4430         &quot;allowing pull()&quot;);
4431     /* neither side has template caps in this case, so they are prepared for
4432        pull() without setcaps() */
4433     result = TRUE;
4434   } else {
4435     /* try to fixate */
4436     caps = gst_base_sink_fixate (basesink, caps);
4437     GST_DEBUG_OBJECT (basesink, &quot;fixated to: %&quot; GST_PTR_FORMAT, caps);
4438 
4439     if (gst_caps_is_fixed (caps)) {
4440       if (!gst_pad_set_caps (GST_BASE_SINK_PAD (basesink), caps))
4441         goto could_not_set_caps;
4442 
4443       result = TRUE;
4444     }
4445   }
4446 
4447   gst_caps_unref (caps);
4448 
4449   return result;
4450 
4451 no_caps_possible:
4452   {
4453     GST_INFO_OBJECT (basesink, &quot;Pipeline could not agree on caps&quot;);
4454     GST_DEBUG_OBJECT (basesink, &quot;get_allowed_caps() returned EMPTY&quot;);
4455     if (caps)
4456       gst_caps_unref (caps);
4457     return FALSE;
4458   }
4459 could_not_set_caps:
4460   {
4461     GST_INFO_OBJECT (basesink, &quot;Could not set caps: %&quot; GST_PTR_FORMAT, caps);
4462     gst_caps_unref (caps);
4463     return FALSE;
4464   }
4465 }
4466 
4467 /* this won&#39;t get called until we implement an activate function */
4468 static gboolean
4469 gst_base_sink_pad_activate_pull (GstPad * pad, GstObject * parent,
4470     gboolean active)
4471 {
4472   gboolean result = FALSE;
4473   GstBaseSink *basesink;
4474   GstBaseSinkClass *bclass;
4475 
4476   basesink = GST_BASE_SINK (parent);
4477   bclass = GST_BASE_SINK_GET_CLASS (basesink);
4478 
4479   if (active) {
4480     gint64 duration;
4481 
4482     /* we mark we have a newsegment here because pull based
4483      * mode works just fine without having a newsegment before the
4484      * first buffer */
4485     gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_BYTES);
4486     GST_OBJECT_LOCK (basesink);
4487     basesink-&gt;have_newsegment = TRUE;
4488     GST_OBJECT_UNLOCK (basesink);
4489 
4490     /* get the peer duration in bytes */
4491     result = gst_pad_peer_query_duration (pad, GST_FORMAT_BYTES, &amp;duration);
4492     if (result) {
4493       GST_DEBUG_OBJECT (basesink,
4494           &quot;setting duration in bytes to %&quot; G_GINT64_FORMAT, duration);
4495       basesink-&gt;segment.duration = duration;
4496     } else {
4497       GST_DEBUG_OBJECT (basesink, &quot;unknown duration&quot;);
4498     }
4499 
4500     if (bclass-&gt;activate_pull)
4501       result = bclass-&gt;activate_pull (basesink, TRUE);
4502     else
4503       result = FALSE;
4504 
4505     if (!result)
4506       goto activate_failed;
4507 
4508   } else {
4509     if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PULL)) {
4510       g_warning (&quot;Internal GStreamer activation error!!!&quot;);
4511       result = FALSE;
4512     } else {
4513       result = gst_base_sink_set_flushing (basesink, pad, TRUE);
4514       if (bclass-&gt;activate_pull)
4515         result &amp;= bclass-&gt;activate_pull (basesink, FALSE);
4516       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4517     }
4518   }
4519 
4520   return result;
4521 
4522   /* ERRORS */
4523 activate_failed:
4524   {
4525     /* reset, as starting the thread failed */
4526     basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4527 
4528     GST_ERROR_OBJECT (basesink, &quot;subclass failed to activate in pull mode&quot;);
4529     return FALSE;
4530   }
4531 }
4532 
4533 static gboolean
4534 gst_base_sink_pad_activate_mode (GstPad * pad, GstObject * parent,
4535     GstPadMode mode, gboolean active)
4536 {
4537   gboolean res;
4538 
4539   switch (mode) {
4540     case GST_PAD_MODE_PULL:
4541       res = gst_base_sink_pad_activate_pull (pad, parent, active);
4542       break;
4543     case GST_PAD_MODE_PUSH:
4544       res = gst_base_sink_pad_activate_push (pad, parent, active);
4545       break;
4546     default:
4547       GST_LOG_OBJECT (pad, &quot;unknown activation mode %d&quot;, mode);
4548       res = FALSE;
4549       break;
4550   }
4551   return res;
4552 }
4553 
4554 /* send an event to our sinkpad peer. */
4555 static gboolean
4556 gst_base_sink_send_event (GstElement * element, GstEvent * event)
4557 {
4558   GstPad *pad;
4559   GstBaseSink *basesink = GST_BASE_SINK (element);
4560   gboolean forward, result = TRUE;
4561   GstPadMode mode;
4562 
4563   GST_OBJECT_LOCK (element);
4564   /* get the pad and the scheduling mode */
4565   pad = gst_object_ref (basesink-&gt;sinkpad);
4566   mode = basesink-&gt;pad_mode;
4567   GST_OBJECT_UNLOCK (element);
4568 
4569   /* only push UPSTREAM events upstream */
4570   forward = GST_EVENT_IS_UPSTREAM (event);
4571 
4572   GST_DEBUG_OBJECT (basesink, &quot;handling event %p %&quot; GST_PTR_FORMAT, event,
4573       event);
4574 
4575   switch (GST_EVENT_TYPE (event)) {
4576     case GST_EVENT_LATENCY:
4577     {
4578       GstClockTime latency;
4579 
4580       gst_event_parse_latency (event, &amp;latency);
4581 
4582       /* store the latency. We use this to adjust the running_time before syncing
4583        * it to the clock. */
4584       GST_OBJECT_LOCK (element);
4585       basesink-&gt;priv-&gt;latency = latency;
4586       if (!basesink-&gt;priv-&gt;have_latency)
4587         forward = FALSE;
4588       GST_OBJECT_UNLOCK (element);
4589       GST_DEBUG_OBJECT (basesink, &quot;latency set to %&quot; GST_TIME_FORMAT,
4590           GST_TIME_ARGS (latency));
4591 
4592       /* We forward this event so that all elements know about the global pipeline
4593        * latency. This is interesting for an element when it wants to figure out
4594        * when a particular piece of data will be rendered. */
4595       break;
4596     }
4597     case GST_EVENT_SEEK:
4598       /* in pull mode we will execute the seek */
4599       if (mode == GST_PAD_MODE_PULL)
4600         result = gst_base_sink_perform_seek (basesink, pad, event);
4601       break;
4602     case GST_EVENT_STEP:
4603       result = gst_base_sink_perform_step (basesink, pad, event);
4604       forward = FALSE;
4605       break;
4606     default:
4607       break;
4608   }
4609 
4610   if (forward) {
4611     GST_DEBUG_OBJECT (basesink, &quot;sending event %p %&quot; GST_PTR_FORMAT, event,
4612         event);
4613     result = gst_pad_push_event (pad, event);
4614   } else {
4615     /* not forwarded, unref the event */
4616     gst_event_unref (event);
4617   }
4618 
4619   gst_object_unref (pad);
4620 
4621   GST_DEBUG_OBJECT (basesink, &quot;handled event: %d&quot;, result);
4622 
4623   return result;
4624 }
4625 
4626 static gboolean
4627 gst_base_sink_get_position (GstBaseSink * basesink, GstFormat format,
4628     gint64 * cur, gboolean * upstream)
4629 {
4630   GstClock *clock = NULL;
4631   gboolean res = FALSE;
4632   GstFormat oformat;
4633   GstSegment *segment;
4634   GstClockTime now, latency;
4635   GstClockTimeDiff base_time;
4636   gint64 time, base, offset, duration;
4637   gdouble rate;
4638   gint64 last;
4639   gboolean last_seen, with_clock, in_paused;
4640 
4641   GST_OBJECT_LOCK (basesink);
4642   /* we can only get the segment when we are not NULL or READY */
4643   if (!basesink-&gt;have_newsegment)
4644     goto wrong_state;
4645 
4646   in_paused = FALSE;
4647   /* when not in PLAYING or when we&#39;re busy with a state change, we
4648    * cannot read from the clock so we report time based on the
4649    * last seen timestamp. */
4650   if (GST_STATE (basesink) != GST_STATE_PLAYING ||
4651       GST_STATE_PENDING (basesink) != GST_STATE_VOID_PENDING) {
4652     in_paused = TRUE;
4653   }
4654 
4655   segment = &amp;basesink-&gt;segment;
4656 
4657   /* get the format in the segment */
4658   oformat = segment-&gt;format;
4659 
4660   /* report with last seen position when EOS */
4661   last_seen = basesink-&gt;eos;
4662 
4663   /* assume we will use the clock for getting the current position */
4664   with_clock = TRUE;
4665   if (!basesink-&gt;sync)
4666     with_clock = FALSE;
4667 
4668   /* and we need a clock */
4669   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (basesink)) == NULL))
4670     with_clock = FALSE;
4671   else
4672     gst_object_ref (clock);
4673 
4674   /* mainloop might be querying position when going to playing async,
4675    * while (audio) rendering might be quickly advancing stream position,
4676    * so use clock asap rather than last reported position */
4677   if (in_paused &amp;&amp; with_clock &amp;&amp; g_atomic_int_get (&amp;basesink-&gt;priv-&gt;to_playing)) {
4678     GST_DEBUG_OBJECT (basesink, &quot;going to PLAYING, so not PAUSED&quot;);
4679     in_paused = FALSE;
4680   }
4681 
4682   /* collect all data we need holding the lock */
4683   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;time))
4684     time = segment-&gt;time;
4685   else
4686     time = 0;
4687 
4688   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;offset))
4689     offset = segment-&gt;offset;
4690   else
4691     offset = 0;
4692 
4693   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;stop))
4694     duration = segment-&gt;stop - segment-&gt;start;
4695   else
4696     duration = 0;
4697 
4698   base = segment-&gt;base;
4699   rate = segment-&gt;rate * segment-&gt;applied_rate;
4700   latency = basesink-&gt;priv-&gt;latency;
4701 
4702   if (in_paused) {
4703     /* in paused, use start_time */
4704     base_time = GST_ELEMENT_START_TIME (basesink);
4705     GST_DEBUG_OBJECT (basesink, &quot;in paused, using start time %&quot; GST_TIME_FORMAT,
4706         GST_TIME_ARGS (base_time));
4707   } else if (with_clock) {
4708     /* else use clock when needed */
4709     base_time = GST_ELEMENT_CAST (basesink)-&gt;base_time;
4710     GST_DEBUG_OBJECT (basesink, &quot;using clock and base time %&quot; GST_TIME_FORMAT,
4711         GST_TIME_ARGS (base_time));
4712   } else {
4713     /* else, no sync or clock -&gt; no base time */
4714     GST_DEBUG_OBJECT (basesink, &quot;no sync or no clock&quot;);
4715     base_time = -1;
4716   }
4717 
4718   /* no base_time, we can&#39;t calculate running_time, use last seem timestamp to report
4719    * time */
4720   if (base_time == -1)
4721     last_seen = TRUE;
4722 
4723   if (oformat == GST_FORMAT_TIME) {
4724     gint64 start, stop;
4725 
4726     start = basesink-&gt;priv-&gt;current_sstart;
4727     stop = basesink-&gt;priv-&gt;current_sstop;
4728 
4729     if (last_seen) {
4730       /* when we don&#39;t use the clock, we use the last position as a lower bound */
4731       if (stop == -1 || segment-&gt;rate &gt; 0.0)
4732         last = start;
4733       else
4734         last = stop;
4735 
4736       GST_DEBUG_OBJECT (basesink, &quot;in PAUSED using last %&quot; GST_TIME_FORMAT,
4737           GST_TIME_ARGS (last));
4738     } else {
4739       /* in playing and paused, use last stop time as upper bound */
4740       if (start == -1 || segment-&gt;rate &gt; 0.0)
4741         last = stop;
4742       else
4743         last = start;
4744 
4745       GST_DEBUG_OBJECT (basesink, &quot;in PLAYING using last %&quot; GST_TIME_FORMAT,
4746           GST_TIME_ARGS (last));
4747     }
4748   } else {
4749     /* convert position to stream time */
4750     last = gst_segment_to_stream_time (segment, oformat, segment-&gt;position);
4751 
4752     GST_DEBUG_OBJECT (basesink, &quot;in using last %&quot; G_GINT64_FORMAT, last);
4753   }
4754 
4755   /* need to release the object lock before we can get the time,
4756    * a clock might take the LOCK of the provider, which could be
4757    * a basesink subclass. */
4758   GST_OBJECT_UNLOCK (basesink);
4759 
4760   if (last_seen) {
4761     /* in EOS or when no valid stream_time, report the value of last seen
4762      * timestamp */
4763     if (last == -1) {
4764       /* no timestamp, we need to ask upstream */
4765       GST_DEBUG_OBJECT (basesink, &quot;no last seen timestamp, asking upstream&quot;);
4766       res = FALSE;
4767       *upstream = TRUE;
4768       goto done;
4769     }
4770     GST_DEBUG_OBJECT (basesink, &quot;using last seen timestamp %&quot; GST_TIME_FORMAT,
4771         GST_TIME_ARGS (last));
4772     *cur = last;
4773   } else {
4774     if (oformat != GST_FORMAT_TIME) {
4775       /* convert base, time and duration to time */
4776       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, base,
4777               GST_FORMAT_TIME, &amp;base))
4778         goto convert_failed;
4779       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, duration,
4780               GST_FORMAT_TIME, &amp;duration))
4781         goto convert_failed;
4782       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, time,
4783               GST_FORMAT_TIME, &amp;time))
4784         goto convert_failed;
4785       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, last,
4786               GST_FORMAT_TIME, &amp;last))
4787         goto convert_failed;
4788 
4789       /* assume time format from now on */
4790       oformat = GST_FORMAT_TIME;
4791     }
4792 
4793     if (!in_paused &amp;&amp; with_clock) {
4794       now = gst_clock_get_time (clock);
4795     } else {
4796       now = base_time;
4797       base_time = 0;
4798     }
4799 
4800     /* subtract base time and base time from the clock time.
4801      * Make sure we don&#39;t go negative. This is the current time in
4802      * the segment which we need to scale with the combined
4803      * rate and applied rate. */
4804     base_time += base;
4805     base_time += latency;
4806     if (GST_CLOCK_DIFF (base_time, now) &lt; 0)
4807       base_time = now;
4808 
4809     /* for negative rates we need to count back from the segment
4810      * duration. */
4811     if (rate &lt; 0.0)
4812       time += duration;
4813 
4814     *cur = time + offset + gst_guint64_to_gdouble (now - base_time) * rate;
4815 
4816     /* never report more than last seen position */
4817     if (last != -1) {
4818       if (rate &gt; 0.0)
4819         *cur = MIN (last, *cur);
4820       else
4821         *cur = MAX (last, *cur);
4822     }
4823 
4824     GST_DEBUG_OBJECT (basesink,
4825         &quot;now %&quot; GST_TIME_FORMAT &quot; - base_time %&quot; GST_TIME_FORMAT &quot; - base %&quot;
4826         GST_TIME_FORMAT &quot; + time %&quot; GST_TIME_FORMAT &quot;  last %&quot; GST_TIME_FORMAT,
4827         GST_TIME_ARGS (now), GST_TIME_ARGS (base_time), GST_TIME_ARGS (base),
4828         GST_TIME_ARGS (time), GST_TIME_ARGS (last));
4829   }
4830 
4831   if (oformat != format) {
4832     /* convert to final format */
4833     if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, *cur, format, cur))
4834       goto convert_failed;
4835   }
4836 
4837   res = TRUE;
4838 
4839 done:
4840   GST_DEBUG_OBJECT (basesink, &quot;res: %d, POSITION: %&quot; GST_TIME_FORMAT,
4841       res, GST_TIME_ARGS (*cur));
4842 
4843   if (clock)
4844     gst_object_unref (clock);
4845 
4846   return res;
4847 
4848   /* special cases */
4849 wrong_state:
4850   {
4851     /* in NULL or READY we always return FALSE and -1 */
4852     GST_DEBUG_OBJECT (basesink, &quot;position in wrong state, return -1&quot;);
4853     res = FALSE;
4854     *cur = -1;
4855     GST_OBJECT_UNLOCK (basesink);
4856     goto done;
4857   }
4858 convert_failed:
4859   {
4860     GST_DEBUG_OBJECT (basesink, &quot;convert failed, try upstream&quot;);
4861     *upstream = TRUE;
4862     res = FALSE;
4863     goto done;
4864   }
4865 }
4866 
4867 static gboolean
4868 gst_base_sink_get_duration (GstBaseSink * basesink, GstFormat format,
4869     gint64 * dur, gboolean * upstream)
4870 {
4871   gboolean res = FALSE;
4872 
4873   if (basesink-&gt;pad_mode == GST_PAD_MODE_PULL) {
4874     gint64 uduration;
4875 
4876     /* get the duration in bytes, in pull mode that&#39;s all we are sure to
4877      * know. We have to explicitly get this value from upstream instead of
4878      * using our cached value because it might change. Duration caching
4879      * should be done at a higher level. */
4880     res =
4881         gst_pad_peer_query_duration (basesink-&gt;sinkpad, GST_FORMAT_BYTES,
4882         &amp;uduration);
4883     if (res) {
4884       basesink-&gt;segment.duration = uduration;
4885       if (format != GST_FORMAT_BYTES) {
4886         /* convert to the requested format */
4887         res =
4888             gst_pad_query_convert (basesink-&gt;sinkpad, GST_FORMAT_BYTES,
4889             uduration, format, dur);
4890       } else {
4891         *dur = uduration;
4892       }
4893     }
4894     *upstream = FALSE;
4895   } else {
4896     *upstream = TRUE;
4897   }
4898 
4899   return res;
4900 }
4901 
4902 static gboolean
4903 default_element_query (GstElement * element, GstQuery * query)
4904 {
4905   gboolean res = FALSE;
4906 
4907   GstBaseSink *basesink = GST_BASE_SINK (element);
4908 
4909   switch (GST_QUERY_TYPE (query)) {
4910     case GST_QUERY_POSITION:
4911     {
4912       gint64 cur = 0;
4913       GstFormat format;
4914       gboolean upstream = FALSE;
4915 
4916       gst_query_parse_position (query, &amp;format, NULL);
4917 
4918       GST_DEBUG_OBJECT (basesink, &quot;position query in format %s&quot;,
4919           gst_format_get_name (format));
4920 
4921       /* first try to get the position based on the clock */
4922       if ((res =
4923               gst_base_sink_get_position (basesink, format, &amp;cur, &amp;upstream))) {
4924         gst_query_set_position (query, format, cur);
4925       } else if (upstream) {
4926         /* fallback to peer query */
4927         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4928       }
4929       if (!res) {
4930         /* we can handle a few things if upstream failed */
4931         if (format == GST_FORMAT_PERCENT) {
4932           gint64 dur = 0;
4933 
4934           res = gst_base_sink_get_position (basesink, GST_FORMAT_TIME, &amp;cur,
4935               &amp;upstream);
4936           if (!res &amp;&amp; upstream) {
4937             res =
4938                 gst_pad_peer_query_position (basesink-&gt;sinkpad, GST_FORMAT_TIME,
4939                 &amp;cur);
4940           }
4941           if (res) {
4942             res = gst_base_sink_get_duration (basesink, GST_FORMAT_TIME, &amp;dur,
4943                 &amp;upstream);
4944             if (!res &amp;&amp; upstream) {
4945               res =
4946                   gst_pad_peer_query_duration (basesink-&gt;sinkpad,
4947                   GST_FORMAT_TIME, &amp;dur);
4948             }
4949           }
4950           if (res) {
4951             gint64 pos;
4952 
4953             pos = gst_util_uint64_scale (100 * GST_FORMAT_PERCENT_SCALE, cur,
4954                 dur);
4955             gst_query_set_position (query, GST_FORMAT_PERCENT, pos);
4956           }
4957         }
4958       }
4959       break;
4960     }
4961     case GST_QUERY_DURATION:
4962     {
4963       gint64 dur = 0;
4964       GstFormat format;
4965       gboolean upstream = FALSE;
4966 
4967       gst_query_parse_duration (query, &amp;format, NULL);
4968 
4969       GST_DEBUG_OBJECT (basesink, &quot;duration query in format %s&quot;,
4970           gst_format_get_name (format));
4971 
4972       if ((res =
4973               gst_base_sink_get_duration (basesink, format, &amp;dur, &amp;upstream))) {
4974         gst_query_set_duration (query, format, dur);
4975       } else if (upstream) {
4976         /* fallback to peer query */
4977         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4978       }
4979       if (!res) {
4980         /* we can handle a few things if upstream failed */
4981         if (format == GST_FORMAT_PERCENT) {
4982           gst_query_set_duration (query, GST_FORMAT_PERCENT,
4983               GST_FORMAT_PERCENT_MAX);
4984           res = TRUE;
4985         }
4986       }
4987       break;
4988     }
4989     case GST_QUERY_LATENCY:
4990     {
4991       gboolean live, us_live;
4992       GstClockTime min, max;
4993 
4994       if ((res = gst_base_sink_query_latency (basesink, &amp;live, &amp;us_live, &amp;min,
4995                   &amp;max))) {
4996         gst_query_set_latency (query, live, min, max);
4997       }
4998       break;
4999     }
5000     case GST_QUERY_JITTER:
5001       break;
5002     case GST_QUERY_RATE:
5003       /* gst_query_set_rate (query, basesink-&gt;segment_rate); */
5004       res = TRUE;
5005       break;
5006     case GST_QUERY_SEGMENT:
5007     {
5008       if (basesink-&gt;pad_mode == GST_PAD_MODE_PULL) {
5009         GstFormat format;
5010         gint64 start, stop;
5011 
5012         format = basesink-&gt;segment.format;
5013 
5014         start =
5015             gst_segment_to_stream_time (&amp;basesink-&gt;segment, format,
5016             basesink-&gt;segment.start);
5017         if ((stop = basesink-&gt;segment.stop) == -1)
5018           stop = basesink-&gt;segment.duration;
5019         else
5020           stop = gst_segment_to_stream_time (&amp;basesink-&gt;segment, format, stop);
5021 
5022         gst_query_set_segment (query, basesink-&gt;segment.rate, format, start,
5023             stop);
5024         res = TRUE;
5025       } else {
5026         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
5027       }
5028       break;
5029     }
5030     case GST_QUERY_SEEKING:
5031     case GST_QUERY_CONVERT:
5032     case GST_QUERY_FORMATS:
5033     default:
5034       res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
5035       break;
5036   }
5037   GST_DEBUG_OBJECT (basesink, &quot;query %s returns %d&quot;,
5038       GST_QUERY_TYPE_NAME (query), res);
5039   return res;
5040 }
5041 
5042 static void
5043 gst_base_sink_drain (GstBaseSink * basesink)
5044 {
5045   GstBuffer *old;
5046   GstBufferList *old_list;
5047 
5048   GST_OBJECT_LOCK (basesink);
5049   if ((old = basesink-&gt;priv-&gt;last_buffer))
5050     basesink-&gt;priv-&gt;last_buffer = gst_buffer_copy_deep (old);
5051 
5052   if ((old_list = basesink-&gt;priv-&gt;last_buffer_list))
5053     basesink-&gt;priv-&gt;last_buffer_list = gst_buffer_list_copy_deep (old_list);
5054   GST_OBJECT_UNLOCK (basesink);
5055 
5056   if (old)
5057     gst_buffer_unref (old);
5058   if (old_list)
5059     gst_mini_object_unref (GST_MINI_OBJECT_CAST (old_list));
5060 }
5061 
5062 static gboolean
5063 gst_base_sink_default_query (GstBaseSink * basesink, GstQuery * query)
5064 {
5065   gboolean res;
5066   GstBaseSinkClass *bclass;
5067 
5068   bclass = GST_BASE_SINK_GET_CLASS (basesink);
5069 
5070   switch (GST_QUERY_TYPE (query)) {
5071     case GST_QUERY_ALLOCATION:
5072     {
5073       gst_base_sink_drain (basesink);
5074       if (bclass-&gt;propose_allocation)
5075         res = bclass-&gt;propose_allocation (basesink, query);
5076       else
5077         res = FALSE;
5078       break;
5079     }
5080     case GST_QUERY_CAPS:
5081     {
5082       GstCaps *caps, *filter;
5083 
5084       gst_query_parse_caps (query, &amp;filter);
5085       caps = gst_base_sink_query_caps (basesink, basesink-&gt;sinkpad, filter);
5086       gst_query_set_caps_result (query, caps);
5087       gst_caps_unref (caps);
5088       res = TRUE;
5089       break;
5090     }
5091     case GST_QUERY_ACCEPT_CAPS:
5092     {
5093       GstCaps *caps, *allowed;
5094       gboolean subset;
5095 
5096       /* slightly faster than the default implementation */
5097       gst_query_parse_accept_caps (query, &amp;caps);
5098       allowed = gst_base_sink_query_caps (basesink, basesink-&gt;sinkpad, NULL);
5099       subset = gst_caps_is_subset (caps, allowed);
5100       GST_DEBUG_OBJECT (basesink, &quot;Checking if requested caps %&quot; GST_PTR_FORMAT
5101           &quot; are a subset of pad caps %&quot; GST_PTR_FORMAT &quot; result %d&quot;, caps,
5102           allowed, subset);
5103       gst_caps_unref (allowed);
5104       gst_query_set_accept_caps_result (query, subset);
5105       res = TRUE;
5106       break;
5107     }
5108     case GST_QUERY_DRAIN:
5109     {
5110       gst_base_sink_drain (basesink);
5111       res = TRUE;
5112       break;
5113     }
5114     case GST_QUERY_POSITION:
5115     {
5116       res = default_element_query (GST_ELEMENT (basesink), query);
5117       break;
5118     }
5119     default:
5120       res =
5121           gst_pad_query_default (basesink-&gt;sinkpad, GST_OBJECT_CAST (basesink),
5122           query);
5123       break;
5124   }
5125   return res;
5126 }
5127 
5128 static gboolean
5129 gst_base_sink_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
5130 {
5131   GstBaseSink *basesink;
5132   GstBaseSinkClass *bclass;
5133   gboolean res;
5134 
5135   basesink = GST_BASE_SINK_CAST (parent);
5136   bclass = GST_BASE_SINK_GET_CLASS (basesink);
5137 
5138   if (bclass-&gt;query)
5139     res = bclass-&gt;query (basesink, query);
5140   else
5141     res = FALSE;
5142 
5143   return res;
5144 }
5145 
5146 static GstStateChangeReturn
5147 gst_base_sink_change_state (GstElement * element, GstStateChange transition)
5148 {
5149   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
5150   GstBaseSink *basesink = GST_BASE_SINK (element);
5151   GstBaseSinkClass *bclass;
5152   GstBaseSinkPrivate *priv;
5153 
5154   priv = basesink-&gt;priv;
5155 
5156   bclass = GST_BASE_SINK_GET_CLASS (basesink);
5157 
5158   switch (transition) {
5159     case GST_STATE_CHANGE_NULL_TO_READY:
5160       if (bclass-&gt;start)
5161         if (!bclass-&gt;start (basesink))
5162           goto start_failed;
5163       break;
5164     case GST_STATE_CHANGE_READY_TO_PAUSED:
5165       /* need to complete preroll before this state change completes, there
5166        * is no data flow in READY so we can safely assume we need to preroll. */
5167       GST_BASE_SINK_PREROLL_LOCK (basesink);
5168       GST_DEBUG_OBJECT (basesink, &quot;READY to PAUSED&quot;);
5169       basesink-&gt;have_newsegment = FALSE;
5170       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
5171       basesink-&gt;offset = 0;
5172       basesink-&gt;have_preroll = FALSE;
5173       priv-&gt;step_unlock = FALSE;
5174       basesink-&gt;need_preroll = TRUE;
5175       basesink-&gt;playing_async = TRUE;
5176       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5177       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5178       priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
5179       priv-&gt;latency = 0;
5180       basesink-&gt;eos = FALSE;
5181       priv-&gt;received_eos = FALSE;
5182       gst_base_sink_reset_qos (basesink);
5183       priv-&gt;rc_next = -1;
<a name="36" id="anc36"></a><span class="line-modified">5184       priv-&gt;committed = FALSE;</span>
5185       priv-&gt;call_preroll = TRUE;
5186       priv-&gt;current_step.valid = FALSE;
5187       priv-&gt;pending_step.valid = FALSE;
5188       if (priv-&gt;async_enabled) {
5189         GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5190         /* when async enabled, post async-start message and return ASYNC from
5191          * the state change function */
5192         ret = GST_STATE_CHANGE_ASYNC;
5193         gst_element_post_message (GST_ELEMENT_CAST (basesink),
5194             gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5195       } else {
5196         priv-&gt;have_latency = TRUE;
5197       }
5198       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5199       break;
5200     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5201       GST_BASE_SINK_PREROLL_LOCK (basesink);
5202       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, TRUE);
5203       if (!gst_base_sink_needs_preroll (basesink)) {
5204         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, don&#39;t need preroll&quot;);
5205         /* no preroll needed anymore now. */
5206         basesink-&gt;playing_async = FALSE;
5207         basesink-&gt;need_preroll = FALSE;
5208         if (basesink-&gt;eos) {
5209           GstMessage *message;
5210 
5211           /* need to post EOS message here */
5212           GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
5213           message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
5214           gst_message_set_seqnum (message, basesink-&gt;priv-&gt;seqnum);
5215           gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
5216         } else {
5217           GST_DEBUG_OBJECT (basesink, &quot;signal preroll&quot;);
5218           GST_BASE_SINK_PREROLL_SIGNAL (basesink);
5219         }
5220       } else {
5221         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, we are not prerolled&quot;);
5222         basesink-&gt;need_preroll = TRUE;
5223         basesink-&gt;playing_async = TRUE;
5224         priv-&gt;call_preroll = TRUE;
<a name="37" id="anc37"></a><span class="line-modified">5225         priv-&gt;committed = FALSE;</span>
5226         if (priv-&gt;async_enabled) {
5227           GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5228           ret = GST_STATE_CHANGE_ASYNC;
5229           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5230               gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5231         }
5232       }
5233       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5234       break;
5235     default:
5236       break;
5237   }
5238 
5239   {
5240     GstStateChangeReturn bret;
5241 
5242     bret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
5243     if (G_UNLIKELY (bret == GST_STATE_CHANGE_FAILURE))
5244       goto activate_failed;
5245   }
5246 
5247   switch (transition) {
5248     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5249       /* completed transition, so need not be marked any longer
5250        * And it should be unmarked, since e.g. losing our position upon flush
5251        * does not really change state to PAUSED ... */
5252       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, FALSE);
5253       break;
5254     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
5255       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, FALSE);
5256       GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED&quot;);
5257       /* FIXME, make sure we cannot enter _render first */
5258 
5259       /* we need to call ::unlock before locking PREROLL_LOCK
5260        * since we lock it before going into ::render */
5261       if (bclass-&gt;unlock)
5262         bclass-&gt;unlock (basesink);
5263 
5264       GST_BASE_SINK_PREROLL_LOCK (basesink);
5265       GST_DEBUG_OBJECT (basesink, &quot;got preroll lock&quot;);
5266       /* now that we have the PREROLL lock, clear our unlock request */
5267       if (bclass-&gt;unlock_stop)
5268         bclass-&gt;unlock_stop (basesink);
5269 
5270       if (basesink-&gt;clock_id) {
5271         GST_DEBUG_OBJECT (basesink, &quot;unschedule clock&quot;);
5272         gst_clock_id_unschedule (basesink-&gt;clock_id);
5273       }
5274 
5275       /* if we don&#39;t have a preroll buffer we need to wait for a preroll and
5276        * return ASYNC. */
5277       if (!gst_base_sink_needs_preroll (basesink)) {
5278         GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED, we are prerolled&quot;);
5279         basesink-&gt;playing_async = FALSE;
5280         basesink-&gt;need_preroll = FALSE;
5281       } else {
5282         if (GST_STATE_TARGET (GST_ELEMENT (basesink)) &lt;= GST_STATE_READY) {
5283           GST_DEBUG_OBJECT (basesink, &quot;element is &lt;= READY&quot;);
5284           ret = GST_STATE_CHANGE_SUCCESS;
5285         } else {
5286           GST_DEBUG_OBJECT (basesink,
5287               &quot;PLAYING to PAUSED, we are not prerolled&quot;);
5288           basesink-&gt;playing_async = TRUE;
5289           basesink-&gt;need_preroll = TRUE;
<a name="38" id="anc38"></a><span class="line-modified">5290           priv-&gt;committed = FALSE;</span>
5291           priv-&gt;call_preroll = TRUE;
5292           if (priv-&gt;async_enabled) {
5293             GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5294             ret = GST_STATE_CHANGE_ASYNC;
5295             gst_element_post_message (GST_ELEMENT_CAST (basesink),
5296                 gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5297           }
5298         }
5299       }
5300       GST_DEBUG_OBJECT (basesink, &quot;rendered: %&quot; G_GUINT64_FORMAT
5301           &quot;, dropped: %&quot; G_GUINT64_FORMAT, priv-&gt;rendered, priv-&gt;dropped);
5302 
5303       gst_base_sink_reset_qos (basesink);
5304       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5305       break;
5306     case GST_STATE_CHANGE_PAUSED_TO_READY:
5307       GST_BASE_SINK_PREROLL_LOCK (basesink);
5308       /* start by resetting our position state with the object lock so that the
5309        * position query gets the right idea. We do this before we post the
5310        * messages so that the message handlers pick this up. */
5311       GST_OBJECT_LOCK (basesink);
5312       basesink-&gt;have_newsegment = FALSE;
5313       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5314       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5315       priv-&gt;have_latency = FALSE;
5316       if (priv-&gt;cached_clock_id) {
5317         gst_clock_id_unref (priv-&gt;cached_clock_id);
5318         priv-&gt;cached_clock_id = NULL;
5319       }
5320       gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
5321       GST_OBJECT_UNLOCK (basesink);
5322 
5323       gst_base_sink_set_last_buffer (basesink, NULL);
5324       gst_base_sink_set_last_buffer_list (basesink, NULL);
5325       priv-&gt;call_preroll = FALSE;
5326 
<a name="39" id="anc39"></a><span class="line-modified">5327       if (!priv-&gt;committed) {</span>
5328         if (priv-&gt;async_enabled) {
5329           GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, posting async-done&quot;);
5330 
5331           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5332               gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
5333                   GST_STATE_PLAYING, GST_STATE_PAUSED, GST_STATE_READY));
5334 
5335           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5336               gst_message_new_async_done (GST_OBJECT_CAST (basesink),
5337                   GST_CLOCK_TIME_NONE));
5338         }
<a name="40" id="anc40"></a><span class="line-modified">5339         priv-&gt;committed = TRUE;</span>
5340       } else {
5341         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, don&#39;t need_preroll&quot;);
5342       }
5343       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5344       break;
5345     case GST_STATE_CHANGE_READY_TO_NULL:
5346       if (bclass-&gt;stop) {
5347         if (!bclass-&gt;stop (basesink)) {
5348           GST_WARNING_OBJECT (basesink, &quot;failed to stop&quot;);
5349         }
5350       }
5351       gst_base_sink_set_last_buffer (basesink, NULL);
5352       gst_base_sink_set_last_buffer_list (basesink, NULL);
5353       priv-&gt;call_preroll = FALSE;
5354       break;
5355     default:
5356       break;
5357   }
5358 
5359   return ret;
5360 
5361   /* ERRORS */
5362 start_failed:
5363   {
5364     GST_DEBUG_OBJECT (basesink, &quot;failed to start&quot;);
5365     /* subclass is supposed to post a message but we post one as a fallback
5366      * just in case */
5367     GST_ELEMENT_ERROR (basesink, CORE, STATE_CHANGE, (NULL),
5368         (&quot;Failed to start&quot;));
5369     return GST_STATE_CHANGE_FAILURE;
5370   }
5371 activate_failed:
5372   {
5373     GST_DEBUG_OBJECT (basesink,
5374         &quot;element failed to change states -- activation problem?&quot;);
5375     return GST_STATE_CHANGE_FAILURE;
5376   }
5377 }
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>