<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gkeyfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gkeyfile.c - key file parser
   2  *
   3  *  Copyright 2004  Red Hat, Inc.
   4  *  Copyright 2009-2010  Collabora Ltd.
   5  *  Copyright 2009  Nokia Corporation
   6  *
   7  * Written by Ray Strode &lt;rstrode@redhat.com&gt;
   8  *            Matthias Clasen &lt;mclasen@redhat.com&gt;
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Lesser General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2.1 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Lesser General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Lesser General Public License
  21  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 
  26 #include &quot;gkeyfile.h&quot;
  27 #include &quot;gutils.h&quot;
  28 
  29 #include &lt;errno.h&gt;
  30 #include &lt;fcntl.h&gt;
  31 #include &lt;locale.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;stdio.h&gt;
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;sys/types.h&gt;
  36 #include &lt;sys/stat.h&gt;
  37 #ifdef G_OS_UNIX
  38 #include &lt;unistd.h&gt;
  39 #endif
  40 #ifdef G_OS_WIN32
  41 #include &lt;io.h&gt;
  42 
  43 #undef fstat
  44 #define fstat(a,b) _fstati64(a,b)
  45 #undef stat
  46 #define stat _stati64
  47 
  48 #ifndef S_ISREG
  49 #define S_ISREG(mode) ((mode)&amp;_S_IFREG)
  50 #endif
  51 
  52 #endif  /* G_OS_WIN23 */
  53 
  54 #include &quot;gconvert.h&quot;
  55 #include &quot;gdataset.h&quot;
  56 #include &quot;gerror.h&quot;
  57 #include &quot;gfileutils.h&quot;
  58 #include &quot;ghash.h&quot;
  59 #include &quot;glibintl.h&quot;
  60 #include &quot;glist.h&quot;
  61 #include &quot;gslist.h&quot;
  62 #include &quot;gmem.h&quot;
  63 #include &quot;gmessages.h&quot;
  64 #include &quot;gstdio.h&quot;
  65 #include &quot;gstring.h&quot;
  66 #include &quot;gstrfuncs.h&quot;
  67 #include &quot;gutils.h&quot;
  68 
  69 
  70 /**
  71  * SECTION:keyfile
  72  * @title: Key-value file parser
  73  * @short_description: parses .ini-like config files
  74  *
  75  * #GKeyFile lets you parse, edit or create files containing groups of
  76  * key-value pairs, which we call &quot;key files&quot; for lack of a better name.
  77  * Several freedesktop.org specifications use key files now, e.g the
  78  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
  79  * and the
  80  * [Icon Theme Specification](http://freedesktop.org/Standards/icon-theme-spec).
  81  *
  82  * The syntax of key files is described in detail in the
  83  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
  84  * here is a quick summary: Key files
  85  * consists of groups of key-value pairs, interspersed with comments.
  86  *
  87  * |[
  88  * # this is just an example
  89  * # there can be comments before the first group
  90  *
  91  * [First Group]
  92  *
  93  * Name=Key File Example\tthis value shows\nescaping
  94  *
  95  * # localized strings are stored in multiple key-value pairs
  96  * Welcome=Hello
  97  * Welcome[de]=Hallo
  98  * Welcome[fr_FR]=Bonjour
  99  * Welcome[it]=Ciao
 100  * Welcome[be@latin]=Hello
 101  *
 102  * [Another Group]
 103  *
 104  * Numbers=2;20;-200;0
 105  *
 106  * Booleans=true;false;true;true
 107  * ]|
 108  *
 109  * Lines beginning with a &#39;#&#39; and blank lines are considered comments.
 110  *
 111  * Groups are started by a header line containing the group name enclosed
 112  * in &#39;[&#39; and &#39;]&#39;, and ended implicitly by the start of the next group or
 113  * the end of the file. Each key-value pair must be contained in a group.
 114  *
 115  * Key-value pairs generally have the form `key=value`, with the
 116  * exception of localized strings, which have the form
 117  * `key[locale]=value`, with a locale identifier of the
 118  * form `lang_COUNTRY@MODIFIER` where `COUNTRY` and `MODIFIER`
 119  * are optional.
 120  * Space before and after the &#39;=&#39; character are ignored. Newline, tab,
 121  * carriage return and backslash characters in value are escaped as \n,
 122  * \t, \r, and \\\\, respectively. To preserve leading spaces in values,
 123  * these can also be escaped as \s.
 124  *
 125  * Key files can store strings (possibly with localized variants), integers,
 126  * booleans and lists of these. Lists are separated by a separator character,
 127  * typically &#39;;&#39; or &#39;,&#39;. To use the list separator character in a value in
 128  * a list, it has to be escaped by prefixing it with a backslash.
 129  *
 130  * This syntax is obviously inspired by the .ini files commonly met
 131  * on Windows, but there are some important differences:
 132  *
 133  * - .ini files use the &#39;;&#39; character to begin comments,
 134  *   key files use the &#39;#&#39; character.
 135  *
 136  * - Key files do not allow for ungrouped keys meaning only
 137  *   comments can precede the first group.
 138  *
 139  * - Key files are always encoded in UTF-8.
 140  *
 141  * - Key and Group names are case-sensitive. For example, a group called
 142  *   [GROUP] is a different from [group].
 143  *
 144  * - .ini files don&#39;t have a strongly typed boolean entry type,
 145  *    they only have GetProfileInt(). In key files, only
 146  *    true and false (in lower case) are allowed.
 147  *
 148  * Note that in contrast to the
 149  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
 150  * groups in key files may contain the same
 151  * key multiple times; the last entry wins. Key files may also contain
 152  * multiple groups with the same name; they are merged together.
 153  * Another difference is that keys and group names in key files are not
 154  * restricted to ASCII characters.
 155  *
 156  * Here is an example of loading a key file and reading a value:
 157  * |[&lt;!-- language=&quot;C&quot; --&gt;
 158  * g_autoptr(GError) error = NULL;
 159  * g_autoptr(GKeyFile) key_file = g_key_file_new ();
 160  *
 161  * if (!g_key_file_load_from_file (key_file, &quot;key-file.ini&quot;, flags, &amp;error))
 162  *   {
 163  *     if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
 164  *       g_warning (&quot;Error loading key file: %s&quot;, error-&gt;message);
 165  *     return;
 166  *   }
 167  *
 168  * g_autofree gchar *val = g_key_file_get_string (key_file, &quot;Group Name&quot;, &quot;SomeKey&quot;, &amp;error);
 169  * if (val == NULL &amp;&amp;
 170  *     !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
 171  *   {
 172  *     g_warning (&quot;Error finding key in key file: %s&quot;, error-&gt;message);
 173  *     return;
 174  *   }
 175  * else if (val == NULL)
 176  *   {
 177  *     // Fall back to a default value.
 178  *     val = g_strdup (&quot;default-value&quot;);
 179  *   }
 180  * ]|
 181  *
 182  * Here is an example of creating and saving a key file:
 183  * |[&lt;!-- language=&quot;C&quot; --&gt;
 184  * g_autoptr(GKeyFile) key_file = g_key_file_new ();
 185  * const gchar *val = ...;
 186  * g_autoptr(GError) error = NULL;
 187  *
 188  * g_key_file_set_string (key_file, &quot;Group Name&quot;, &quot;SomeKey&quot;, val);
 189  *
 190  * // Save as a file.
 191  * if (!g_key_file_save_to_file (key_file, &quot;key-file.ini&quot;, &amp;error))
 192  *   {
 193  *     g_warning (&quot;Error saving key file: %s&quot;, error-&gt;message);
 194  *     return;
 195  *   }
 196  *
 197  * // Or store to a GBytes for use elsewhere.
 198  * gsize data_len;
 199  * g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &amp;data_len, &amp;error);
 200  * if (data == NULL)
 201  *   {
 202  *     g_warning (&quot;Error saving key file: %s&quot;, error-&gt;message);
 203  *     return;
 204  *   }
 205  * g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&amp;data), data_len);
 206  * ]|
 207  */
 208 
 209 /**
 210  * G_KEY_FILE_ERROR:
 211  *
 212  * Error domain for key file parsing. Errors in this domain will
 213  * be from the #GKeyFileError enumeration.
 214  *
 215  * See #GError for information on error domains.
 216  */
 217 
 218 /**
 219  * GKeyFileError:
 220  * @G_KEY_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was in
 221  *     an unknown encoding
 222  * @G_KEY_FILE_ERROR_PARSE: document was ill-formed
 223  * @G_KEY_FILE_ERROR_NOT_FOUND: the file was not found
 224  * @G_KEY_FILE_ERROR_KEY_NOT_FOUND: a requested key was not found
 225  * @G_KEY_FILE_ERROR_GROUP_NOT_FOUND: a requested group was not found
 226  * @G_KEY_FILE_ERROR_INVALID_VALUE: a value could not be parsed
 227  *
 228  * Error codes returned by key file parsing.
 229  */
 230 
 231 /**
 232  * GKeyFileFlags:
 233  * @G_KEY_FILE_NONE: No flags, default behaviour
 234  * @G_KEY_FILE_KEEP_COMMENTS: Use this flag if you plan to write the
 235  *     (possibly modified) contents of the key file back to a file;
 236  *     otherwise all comments will be lost when the key file is
 237  *     written back.
 238  * @G_KEY_FILE_KEEP_TRANSLATIONS: Use this flag if you plan to write the
 239  *     (possibly modified) contents of the key file back to a file;
 240  *     otherwise only the translations for the current language will be
 241  *     written back.
 242  *
 243  * Flags which influence the parsing.
 244  */
 245 
 246 /**
 247  * G_KEY_FILE_DESKTOP_GROUP:
 248  *
 249  * The name of the main group of a desktop entry file, as defined in the
 250  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).
 251  * Consult the specification for more
 252  * details about the meanings of the keys below.
 253  *
 254  * Since: 2.14
 255  */
 256 
 257 /**
 258  * G_KEY_FILE_DESKTOP_KEY_TYPE:
 259  *
 260  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 261  * giving the type of the desktop entry. Usually
 262  * #G_KEY_FILE_DESKTOP_TYPE_APPLICATION,
 263  * #G_KEY_FILE_DESKTOP_TYPE_LINK, or
 264  * #G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.
 265  *
 266  * Since: 2.14
 267  */
 268 
 269 /**
 270  * G_KEY_FILE_DESKTOP_KEY_VERSION:
 271  *
 272  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 273  * giving the version of the Desktop Entry Specification used for
 274  * the desktop entry file.
 275  *
 276  * Since: 2.14
 277  */
 278 
 279 /**
 280  * G_KEY_FILE_DESKTOP_KEY_NAME:
 281  *
 282  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 283  * string giving the specific name of the desktop entry.
 284  *
 285  * Since: 2.14
 286  */
 287 
 288 /**
 289  * G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME:
 290  *
 291  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 292  * string giving the generic name of the desktop entry.
 293  *
 294  * Since: 2.14
 295  */
 296 
 297 /**
 298  * G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY:
 299  *
 300  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 301  * stating whether the desktop entry should be shown in menus.
 302  *
 303  * Since: 2.14
 304  */
 305 
 306 /**
 307  * G_KEY_FILE_DESKTOP_KEY_COMMENT:
 308  *
 309  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 310  * string giving the tooltip for the desktop entry.
 311  *
 312  * Since: 2.14
 313  */
 314 
 315 /**
 316  * G_KEY_FILE_DESKTOP_KEY_ICON:
 317  *
 318  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 319  * string giving the name of the icon to be displayed for the desktop
 320  * entry.
 321  *
 322  * Since: 2.14
 323  */
 324 
 325 /**
 326  * G_KEY_FILE_DESKTOP_KEY_HIDDEN:
 327  *
 328  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 329  * stating whether the desktop entry has been deleted by the user.
 330  *
 331  * Since: 2.14
 332  */
 333 
 334 /**
 335  * G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN:
 336  *
 337  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
 338  * strings identifying the environments that should display the
 339  * desktop entry.
 340  *
 341  * Since: 2.14
 342  */
 343 
 344 /**
 345  * G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN:
 346  *
 347  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
 348  * strings identifying the environments that should not display the
 349  * desktop entry.
 350  *
 351  * Since: 2.14
 352  */
 353 
 354 /**
 355  * G_KEY_FILE_DESKTOP_KEY_TRY_EXEC:
 356  *
 357  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 358  * giving the file name of a binary on disk used to determine if the
 359  * program is actually installed. It is only valid for desktop entries
 360  * with the `Application` type.
 361  *
 362  * Since: 2.14
 363  */
 364 
 365 /**
 366  * G_KEY_FILE_DESKTOP_KEY_EXEC:
 367  *
 368  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 369  * giving the command line to execute. It is only valid for desktop
 370  * entries with the `Application` type.
 371  *
 372  * Since: 2.14
 373  */
 374 
 375  /**
 376   * G_KEY_FILE_DESKTOP_KEY_PATH:
 377   *
 378   * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 379   * containing the working directory to run the program in. It is only
 380   * valid for desktop entries with the `Application` type.
 381   *
 382   * Since: 2.14
 383   */
 384 
 385 /**
 386  * G_KEY_FILE_DESKTOP_KEY_TERMINAL:
 387  *
 388  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 389  * stating whether the program should be run in a terminal window.
 390  * It is only valid for desktop entries with the
 391  * `Application` type.
 392  *
 393  * Since: 2.14
 394  */
 395 
 396 /**
 397  * G_KEY_FILE_DESKTOP_KEY_MIME_TYPE:
 398  *
 399  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
 400  * of strings giving the MIME types supported by this desktop entry.
 401  *
 402  * Since: 2.14
 403  */
 404 
 405 /**
 406  * G_KEY_FILE_DESKTOP_KEY_CATEGORIES:
 407  *
 408  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
 409  * of strings giving the categories in which the desktop entry
 410  * should be shown in a menu.
 411  *
 412  * Since: 2.14
 413  */
 414 
 415 /**
 416  * G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY:
 417  *
 418  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 419  * stating whether the application supports the
 420  * [Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).
 421  *
 422  * Since: 2.14
 423  */
 424 
 425 /**
 426  * G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS:
 427  *
 428  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is string
 429  * identifying the WM class or name hint of a window that the application
 430  * will create, which can be used to emulate Startup Notification with
 431  * older applications.
 432  *
 433  * Since: 2.14
 434  */
 435 
 436 /**
 437  * G_KEY_FILE_DESKTOP_KEY_URL:
 438  *
 439  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 440  * giving the URL to access. It is only valid for desktop entries
 441  * with the `Link` type.
 442  *
 443  * Since: 2.14
 444  */
 445 
 446 /**
 447  * G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE:
 448  *
 449  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean set to true
 450  * if the application is D-Bus activatable.
 451  *
 452  * Since: 2.38
 453  */
 454 
 455 /**
 456  * G_KEY_FILE_DESKTOP_KEY_ACTIONS:
 457  *
 458  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string list
 459  * giving the available application actions.
 460  *
 461  * Since: 2.38
 462  */
 463 
 464 /**
 465  * G_KEY_FILE_DESKTOP_TYPE_APPLICATION:
 466  *
 467  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 468  * entries representing applications.
 469  *
 470  * Since: 2.14
 471  */
 472 
 473 /**
 474  * G_KEY_FILE_DESKTOP_TYPE_LINK:
 475  *
 476  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 477  * entries representing links to documents.
 478  *
 479  * Since: 2.14
 480  */
 481 
 482 /**
 483  * G_KEY_FILE_DESKTOP_TYPE_DIRECTORY:
 484  *
 485  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 486  * entries representing directories.
 487  *
 488  * Since: 2.14
 489  */
 490 
 491 typedef struct _GKeyFileGroup GKeyFileGroup;
 492 
 493 /**
 494  * GKeyFile:
 495  *
 496  * The GKeyFile struct contains only private data
 497  * and should not be accessed directly.
 498  */
 499 struct _GKeyFile
 500 {
 501   GList *groups;
 502   GHashTable *group_hash;
 503 
 504   GKeyFileGroup *start_group;
 505   GKeyFileGroup *current_group;
 506 
 507   GString *parse_buffer; /* Holds up to one line of not-yet-parsed data */
 508 
 509   gchar list_separator;
 510 
 511   GKeyFileFlags flags;
 512 
 513   gchar **locales;
 514 
 515   volatile gint ref_count;
 516 };
 517 
 518 typedef struct _GKeyFileKeyValuePair GKeyFileKeyValuePair;
 519 
 520 struct _GKeyFileGroup
 521 {
 522   const gchar *name;  /* NULL for above first group (which will be comments) */
 523 
 524   GKeyFileKeyValuePair *comment; /* Special comment that is stuck to the top of a group */
 525 
 526   GList *key_value_pairs;
 527 
 528   /* Used in parallel with key_value_pairs for
 529    * increased lookup performance
 530    */
 531   GHashTable *lookup_map;
 532 };
 533 
 534 struct _GKeyFileKeyValuePair
 535 {
 536   gchar *key;  /* NULL for comments */
 537   gchar *value;
 538 };
 539 
 540 static gint                  find_file_in_data_dirs            (const gchar            *file,
 541                                 const gchar           **data_dirs,
 542                                 gchar                 **output_file,
 543                                 GError                **error);
 544 static gboolean              g_key_file_load_from_fd           (GKeyFile               *key_file,
 545                                 gint                    fd,
 546                                 GKeyFileFlags           flags,
 547                                 GError                **error);
 548 static GList                *g_key_file_lookup_group_node      (GKeyFile               *key_file,
 549                                                     const gchar            *group_name);
 550 static GKeyFileGroup        *g_key_file_lookup_group           (GKeyFile               *key_file,
 551                                 const gchar            *group_name);
 552 
 553 static GList                *g_key_file_lookup_key_value_pair_node  (GKeyFile       *key_file,
 554                                                          GKeyFileGroup  *group,
 555                                                                      const gchar    *key);
 556 static GKeyFileKeyValuePair *g_key_file_lookup_key_value_pair       (GKeyFile       *key_file,
 557                                                                      GKeyFileGroup  *group,
 558                                                                      const gchar    *key);
 559 
 560 static void                  g_key_file_remove_group_node          (GKeyFile      *key_file,
 561                                     GList         *group_node);
 562 static void                  g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
 563                                                                     GKeyFileGroup *group,
 564                                                                     GList         *pair_node);
 565 
 566 static void                  g_key_file_add_key_value_pair     (GKeyFile               *key_file,
 567                                                                 GKeyFileGroup          *group,
 568                                                                 GKeyFileKeyValuePair   *pair);
 569 static void                  g_key_file_add_key                (GKeyFile               *key_file,
 570                                 GKeyFileGroup          *group,
 571                                 const gchar            *key,
 572                                 const gchar            *value);
 573 static void                  g_key_file_add_group              (GKeyFile               *key_file,
 574                                 const gchar            *group_name);
 575 static gboolean              g_key_file_is_group_name          (const gchar *name);
 576 static gboolean              g_key_file_is_key_name            (const gchar *name);
 577 static void                  g_key_file_key_value_pair_free    (GKeyFileKeyValuePair   *pair);
 578 static gboolean              g_key_file_line_is_comment        (const gchar            *line);
 579 static gboolean              g_key_file_line_is_group          (const gchar            *line);
 580 static gboolean              g_key_file_line_is_key_value_pair (const gchar            *line);
 581 static gchar                *g_key_file_parse_value_as_string  (GKeyFile               *key_file,
 582                                 const gchar            *value,
 583                                 GSList                **separators,
 584                                 GError                **error);
 585 static gchar                *g_key_file_parse_string_as_value  (GKeyFile               *key_file,
 586                                 const gchar            *string,
 587                                 gboolean                escape_separator);
 588 static gint                  g_key_file_parse_value_as_integer (GKeyFile               *key_file,
 589                                 const gchar            *value,
 590                                 GError                **error);
 591 static gchar                *g_key_file_parse_integer_as_value (GKeyFile               *key_file,
 592                                 gint                    value);
 593 static gdouble               g_key_file_parse_value_as_double  (GKeyFile               *key_file,
 594                                                                 const gchar            *value,
 595                                                                 GError                **error);
 596 static gboolean              g_key_file_parse_value_as_boolean (GKeyFile               *key_file,
 597                                 const gchar            *value,
 598                                 GError                **error);
 599 static gchar                *g_key_file_parse_boolean_as_value (GKeyFile               *key_file,
 600                                 gboolean                value);
 601 static gchar                *g_key_file_parse_value_as_comment (GKeyFile               *key_file,
 602                                                                 const gchar            *value);
 603 static gchar                *g_key_file_parse_comment_as_value (GKeyFile               *key_file,
 604                                                                 const gchar            *comment);
 605 static void                  g_key_file_parse_key_value_pair   (GKeyFile               *key_file,
 606                                 const gchar            *line,
 607                                 gsize                   length,
 608                                 GError                **error);
 609 static void                  g_key_file_parse_comment          (GKeyFile               *key_file,
 610                                 const gchar            *line,
 611                                 gsize                   length,
 612                                 GError                **error);
 613 static void                  g_key_file_parse_group            (GKeyFile               *key_file,
 614                                 const gchar            *line,
 615                                 gsize                   length,
 616                                 GError                **error);
 617 static gchar                *key_get_locale                    (const gchar            *key);
 618 static void                  g_key_file_parse_data             (GKeyFile               *key_file,
 619                                 const gchar            *data,
 620                                 gsize                   length,
 621                                 GError                **error);
 622 static void                  g_key_file_flush_parse_buffer     (GKeyFile               *key_file,
 623                                 GError                **error);
 624 
 625 G_DEFINE_QUARK (g-key-file-error-quark, g_key_file_error)
 626 
 627 static void
 628 g_key_file_init (GKeyFile *key_file)
 629 {
 630   key_file-&gt;current_group = g_slice_new0 (GKeyFileGroup);
 631   key_file-&gt;groups = g_list_prepend (NULL, key_file-&gt;current_group);
 632   key_file-&gt;group_hash = g_hash_table_new (g_str_hash, g_str_equal);
 633   key_file-&gt;start_group = NULL;
 634   key_file-&gt;parse_buffer = g_string_sized_new (128);
 635   key_file-&gt;list_separator = &#39;;&#39;;
 636   key_file-&gt;flags = 0;
 637   key_file-&gt;locales = g_strdupv ((gchar **)g_get_language_names ());
 638 }
 639 
 640 static void
 641 g_key_file_clear (GKeyFile *key_file)
 642 {
 643   GList *tmp, *group_node;
 644 
 645   if (key_file-&gt;locales)
 646     {
 647       g_strfreev (key_file-&gt;locales);
 648       key_file-&gt;locales = NULL;
 649     }
 650 
 651   if (key_file-&gt;parse_buffer)
 652     {
 653       g_string_free (key_file-&gt;parse_buffer, TRUE);
 654       key_file-&gt;parse_buffer = NULL;
 655     }
 656 
 657   tmp = key_file-&gt;groups;
 658   while (tmp != NULL)
 659     {
 660       group_node = tmp;
 661       tmp = tmp-&gt;next;
 662       g_key_file_remove_group_node (key_file, group_node);
 663     }
 664 
 665   if (key_file-&gt;group_hash != NULL)
 666     {
 667       g_hash_table_destroy (key_file-&gt;group_hash);
 668       key_file-&gt;group_hash = NULL;
 669     }
 670 
 671   g_warn_if_fail (key_file-&gt;groups == NULL);
 672 }
 673 
 674 
 675 /**
 676  * g_key_file_new:
 677  *
 678  * Creates a new empty #GKeyFile object. Use
 679  * g_key_file_load_from_file(), g_key_file_load_from_data(),
 680  * g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
 681  * read an existing key file.
 682  *
 683  * Returns: (transfer full): an empty #GKeyFile.
 684  *
 685  * Since: 2.6
 686  **/
 687 GKeyFile *
 688 g_key_file_new (void)
 689 {
 690   GKeyFile *key_file;
 691 
 692   key_file = g_slice_new0 (GKeyFile);
 693   key_file-&gt;ref_count = 1;
 694   g_key_file_init (key_file);
 695 
 696   return key_file;
 697 }
 698 
 699 /**
 700  * g_key_file_set_list_separator:
 701  * @key_file: a #GKeyFile
 702  * @separator: the separator
 703  *
 704  * Sets the character which is used to separate
 705  * values in lists. Typically &#39;;&#39; or &#39;,&#39; are used
 706  * as separators. The default list separator is &#39;;&#39;.
 707  *
 708  * Since: 2.6
 709  */
 710 void
 711 g_key_file_set_list_separator (GKeyFile *key_file,
 712                    gchar     separator)
 713 {
 714   g_return_if_fail (key_file != NULL);
 715 
 716   key_file-&gt;list_separator = separator;
 717 }
 718 
 719 
 720 /* Iterates through all the directories in *dirs trying to
 721  * open file.  When it successfully locates and opens a file it
 722  * returns the file descriptor to the open file.  It also
 723  * outputs the absolute path of the file in output_file.
 724  */
 725 static gint
 726 find_file_in_data_dirs (const gchar   *file,
 727                         const gchar  **dirs,
 728                         gchar        **output_file,
 729                         GError       **error)
 730 {
 731   const gchar **data_dirs, *data_dir;
 732   gchar *path;
 733   gint fd;
 734 
 735   path = NULL;
 736   fd = -1;
 737 
 738   if (dirs == NULL)
 739     return fd;
 740 
 741   data_dirs = dirs;
 742 
 743   while (data_dirs &amp;&amp; (data_dir = *data_dirs) &amp;&amp; fd == -1)
 744     {
 745       gchar *candidate_file, *sub_dir;
 746 
 747       candidate_file = (gchar *) file;
 748       sub_dir = g_strdup (&quot;&quot;);
 749       while (candidate_file != NULL &amp;&amp; fd == -1)
 750         {
 751           gchar *p;
 752 
 753           path = g_build_filename (data_dir, sub_dir,
 754                                    candidate_file, NULL);
 755 
 756           fd = g_open (path, O_RDONLY, 0);
 757 
 758           if (fd == -1)
 759             {
 760               g_free (path);
 761               path = NULL;
 762             }
 763 
 764           candidate_file = strchr (candidate_file, &#39;-&#39;);
 765 
 766           if (candidate_file == NULL)
 767             break;
 768 
 769           candidate_file++;
 770 
 771           g_free (sub_dir);
 772           sub_dir = g_strndup (file, candidate_file - file - 1);
 773 
 774           for (p = sub_dir; *p != &#39;\0&#39;; p++)
 775             {
 776               if (*p == &#39;-&#39;)
 777                 *p = G_DIR_SEPARATOR;
 778             }
 779         }
 780       g_free (sub_dir);
 781       data_dirs++;
 782     }
 783 
 784   if (fd == -1)
 785     {
 786       g_set_error_literal (error, G_KEY_FILE_ERROR,
 787                            G_KEY_FILE_ERROR_NOT_FOUND,
 788                            _(&quot;Valid key file could not be &quot;
 789                              &quot;found in search dirs&quot;));
 790     }
 791 
 792   if (output_file != NULL &amp;&amp; fd != -1)
 793     *output_file = g_strdup (path);
 794 
 795   g_free (path);
 796 
 797   return fd;
 798 }
 799 
 800 static gboolean
 801 g_key_file_load_from_fd (GKeyFile       *key_file,
 802              gint            fd,
 803              GKeyFileFlags   flags,
 804              GError        **error)
 805 {
 806   GError *key_file_error = NULL;
 807   gssize bytes_read;
 808   struct stat stat_buf;
 809   gchar read_buf[4096];
 810   gchar list_separator;
 811 
 812   if (fstat (fd, &amp;stat_buf) &lt; 0)
 813     {
 814       int errsv = errno;
 815       g_set_error_literal (error, G_FILE_ERROR,
 816                            g_file_error_from_errno (errsv),
 817                            g_strerror (errsv));
 818       return FALSE;
 819     }
 820 
 821   if (!S_ISREG (stat_buf.st_mode))
 822     {
 823       g_set_error_literal (error, G_KEY_FILE_ERROR,
 824                            G_KEY_FILE_ERROR_PARSE,
 825                            _(&quot;Not a regular file&quot;));
 826       return FALSE;
 827     }
 828 
 829   list_separator = key_file-&gt;list_separator;
 830   g_key_file_clear (key_file);
 831   g_key_file_init (key_file);
 832   key_file-&gt;list_separator = list_separator;
 833   key_file-&gt;flags = flags;
 834 
 835   do
 836     {
 837       int errsv;
 838 
 839       bytes_read = read (fd, read_buf, 4096);
 840       errsv = errno;
 841 
 842       if (bytes_read == 0)  /* End of File */
 843         break;
 844 
 845       if (bytes_read &lt; 0)
 846         {
 847           if (errsv == EINTR || errsv == EAGAIN)
 848             continue;
 849 
 850           g_set_error_literal (error, G_FILE_ERROR,
 851                                g_file_error_from_errno (errsv),
 852                                g_strerror (errsv));
 853           return FALSE;
 854         }
 855 
 856       g_key_file_parse_data (key_file,
 857                  read_buf, bytes_read,
 858                  &amp;key_file_error);
 859     }
 860   while (!key_file_error);
 861 
 862   if (key_file_error)
 863     {
 864       g_propagate_error (error, key_file_error);
 865       return FALSE;
 866     }
 867 
 868   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 869 
 870   if (key_file_error)
 871     {
 872       g_propagate_error (error, key_file_error);
 873       return FALSE;
 874     }
 875 
 876   return TRUE;
 877 }
 878 
 879 /**
 880  * g_key_file_load_from_file:
 881  * @key_file: an empty #GKeyFile struct
 882  * @file: (type filename): the path of a filename to load, in the GLib filename encoding
 883  * @flags: flags from #GKeyFileFlags
 884  * @error: return location for a #GError, or %NULL
 885  *
 886  * Loads a key file into an empty #GKeyFile structure.
 887  *
 888  * If the OS returns an error when opening or reading the file, a
 889  * %G_FILE_ERROR is returned. If there is a problem parsing the file, a
 890  * %G_KEY_FILE_ERROR is returned.
 891  *
 892  * This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
 893  * @file is not found, %G_FILE_ERROR_NOENT is returned.
 894  *
 895  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 896  *
 897  * Since: 2.6
 898  **/
 899 gboolean
 900 g_key_file_load_from_file (GKeyFile       *key_file,
 901                const gchar    *file,
 902                GKeyFileFlags   flags,
 903                GError        **error)
 904 {
 905   GError *key_file_error = NULL;
 906   gint fd;
 907   int errsv;
 908 
 909   g_return_val_if_fail (key_file != NULL, FALSE);
 910   g_return_val_if_fail (file != NULL, FALSE);
 911 
 912   fd = g_open (file, O_RDONLY, 0);
 913   errsv = errno;
 914 
 915   if (fd == -1)
 916     {
 917       g_set_error_literal (error, G_FILE_ERROR,
 918                            g_file_error_from_errno (errsv),
 919                            g_strerror (errsv));
 920       return FALSE;
 921     }
 922 
 923   g_key_file_load_from_fd (key_file, fd, flags, &amp;key_file_error);
 924   close (fd);
 925 
 926   if (key_file_error)
 927     {
 928       g_propagate_error (error, key_file_error);
 929       return FALSE;
 930     }
 931 
 932   return TRUE;
 933 }
 934 
 935 /**
 936  * g_key_file_load_from_data:
 937  * @key_file: an empty #GKeyFile struct
 938  * @data: key file loaded in memory
 939  * @length: the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
 940  * @flags: flags from #GKeyFileFlags
 941  * @error: return location for a #GError, or %NULL
 942  *
 943  * Loads a key file from memory into an empty #GKeyFile structure.
 944  * If the object cannot be created then %error is set to a #GKeyFileError.
 945  *
 946  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 947  *
 948  * Since: 2.6
 949  **/
 950 gboolean
 951 g_key_file_load_from_data (GKeyFile       *key_file,
 952                const gchar    *data,
 953                gsize           length,
 954                GKeyFileFlags   flags,
 955                GError        **error)
 956 {
 957   GError *key_file_error = NULL;
 958   gchar list_separator;
 959 
 960   g_return_val_if_fail (key_file != NULL, FALSE);
 961   g_return_val_if_fail (data != NULL || length == 0, FALSE);
 962 
 963   if (length == (gsize)-1)
 964     length = strlen (data);
 965 
 966   list_separator = key_file-&gt;list_separator;
 967   g_key_file_clear (key_file);
 968   g_key_file_init (key_file);
 969   key_file-&gt;list_separator = list_separator;
 970   key_file-&gt;flags = flags;
 971 
 972   g_key_file_parse_data (key_file, data, length, &amp;key_file_error);
 973 
 974   if (key_file_error)
 975     {
 976       g_propagate_error (error, key_file_error);
 977       return FALSE;
 978     }
 979 
 980   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 981 
 982   if (key_file_error)
 983     {
 984       g_propagate_error (error, key_file_error);
 985       return FALSE;
 986     }
 987 
 988   return TRUE;
 989 }
 990 
 991 /**
 992  * g_key_file_load_from_bytes:
 993  * @key_file: an empty #GKeyFile struct
 994  * @bytes: a #GBytes
 995  * @flags: flags from #GKeyFileFlags
 996  * @error: return location for a #GError, or %NULL
 997  *
 998  * Loads a key file from the data in @bytes into an empty #GKeyFile structure.
 999  * If the object cannot be created then %error is set to a #GKeyFileError.
1000  *
1001  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1002  *
1003  * Since: 2.50
1004  **/
1005 gboolean
1006 g_key_file_load_from_bytes (GKeyFile       *key_file,
1007                             GBytes         *bytes,
1008                             GKeyFileFlags   flags,
1009                             GError        **error)
1010 {
1011   const guchar *data;
1012   gsize size;
1013 
1014   g_return_val_if_fail (key_file != NULL, FALSE);
1015   g_return_val_if_fail (bytes != NULL, FALSE);
1016 
1017   data = g_bytes_get_data (bytes, &amp;size);
1018   return g_key_file_load_from_data (key_file, (const gchar *) data, size, flags, error);
1019 }
1020 
1021 /**
1022  * g_key_file_load_from_dirs:
1023  * @key_file: an empty #GKeyFile struct
1024  * @file: (type filename): a relative path to a filename to open and parse
1025  * @search_dirs: (array zero-terminated=1) (element-type filename): %NULL-terminated array of directories to search
1026  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1027  *   of the file, or %NULL
1028  * @flags: flags from #GKeyFileFlags
1029  * @error: return location for a #GError, or %NULL
1030  *
1031  * This function looks for a key file named @file in the paths
1032  * specified in @search_dirs, loads the file into @key_file and
1033  * returns the file&#39;s full path in @full_path.
1034  *
1035  * If the file could not be found in any of the @search_dirs,
1036  * %G_KEY_FILE_ERROR_NOT_FOUND is returned. If
1037  * the file is found but the OS returns an error when opening or reading the
1038  * file, a %G_FILE_ERROR is returned. If there is a problem parsing the file, a
1039  * %G_KEY_FILE_ERROR is returned.
1040  *
1041  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1042  *
1043  * Since: 2.14
1044  **/
1045 gboolean
1046 g_key_file_load_from_dirs (GKeyFile       *key_file,
1047                            const gchar    *file,
1048                            const gchar   **search_dirs,
1049                            gchar         **full_path,
1050                            GKeyFileFlags   flags,
1051                            GError        **error)
1052 {
1053   GError *key_file_error = NULL;
1054   const gchar **data_dirs;
1055   gchar *output_path;
1056   gint fd;
1057   gboolean found_file;
1058 
1059   g_return_val_if_fail (key_file != NULL, FALSE);
1060   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1061   g_return_val_if_fail (search_dirs != NULL, FALSE);
1062 
1063   found_file = FALSE;
1064   data_dirs = search_dirs;
1065   output_path = NULL;
1066   while (*data_dirs != NULL &amp;&amp; !found_file)
1067     {
1068       g_free (output_path);
1069       output_path = NULL;
1070 
1071       fd = find_file_in_data_dirs (file, data_dirs, &amp;output_path,
1072                                    &amp;key_file_error);
1073 
1074       if (fd == -1)
1075         {
1076           if (key_file_error)
1077             g_propagate_error (error, key_file_error);
1078       break;
1079         }
1080 
1081       found_file = g_key_file_load_from_fd (key_file, fd, flags,
1082                                         &amp;key_file_error);
1083       close (fd);
1084 
1085       if (key_file_error)
1086         {
1087       g_propagate_error (error, key_file_error);
1088       break;
1089         }
1090     }
1091 
1092   if (found_file &amp;&amp; full_path)
1093     *full_path = output_path;
1094   else
1095     g_free (output_path);
1096 
1097   return found_file;
1098 }
1099 
1100 /**
1101  * g_key_file_load_from_data_dirs:
1102  * @key_file: an empty #GKeyFile struct
1103  * @file: (type filename): a relative path to a filename to open and parse
1104  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1105  *   of the file, or %NULL
1106  * @flags: flags from #GKeyFileFlags
1107  * @error: return location for a #GError, or %NULL
1108  *
1109  * This function looks for a key file named @file in the paths
1110  * returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1111  * loads the file into @key_file and returns the file&#39;s full path in
1112  * @full_path.  If the file could not be loaded then an %error is
1113  * set to either a #GFileError or #GKeyFileError.
1114  *
1115  * Returns: %TRUE if a key file could be loaded, %FALSE othewise
1116  * Since: 2.6
1117  **/
1118 gboolean
1119 g_key_file_load_from_data_dirs (GKeyFile       *key_file,
1120                 const gchar    *file,
1121                 gchar         **full_path,
1122                 GKeyFileFlags   flags,
1123                 GError        **error)
1124 {
1125   gchar **all_data_dirs;
1126   const gchar * user_data_dir;
1127   const gchar * const * system_data_dirs;
1128   gsize i, j;
1129   gboolean found_file;
1130 
1131   g_return_val_if_fail (key_file != NULL, FALSE);
1132   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1133 
1134   user_data_dir = g_get_user_data_dir ();
1135   system_data_dirs = g_get_system_data_dirs ();
1136   all_data_dirs = g_new (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1137 
1138   i = 0;
1139   all_data_dirs[i++] = g_strdup (user_data_dir);
1140 
1141   j = 0;
1142   while (system_data_dirs[j] != NULL)
1143     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1144   all_data_dirs[i] = NULL;
1145 
1146   found_file = g_key_file_load_from_dirs (key_file,
1147                                           file,
1148                                           (const gchar **)all_data_dirs,
1149                                           full_path,
1150                                           flags,
1151                                           error);
1152 
1153   g_strfreev (all_data_dirs);
1154 
1155   return found_file;
1156 }
1157 
1158 /**
1159  * g_key_file_ref: (skip)
1160  * @key_file: a #GKeyFile
1161  *
1162  * Increases the reference count of @key_file.
1163  *
1164  * Returns: the same @key_file.
1165  *
1166  * Since: 2.32
1167  **/
1168 GKeyFile *
1169 g_key_file_ref (GKeyFile *key_file)
1170 {
1171   g_return_val_if_fail (key_file != NULL, NULL);
1172 
1173   g_atomic_int_inc (&amp;key_file-&gt;ref_count);
1174 
1175   return key_file;
1176 }
1177 
1178 /**
1179  * g_key_file_free: (skip)
1180  * @key_file: a #GKeyFile
1181  *
1182  * Clears all keys and groups from @key_file, and decreases the
1183  * reference count by 1. If the reference count reaches zero,
1184  * frees the key file and all its allocated memory.
1185  *
1186  * Since: 2.6
1187  **/
1188 void
1189 g_key_file_free (GKeyFile *key_file)
1190 {
1191   g_return_if_fail (key_file != NULL);
1192 
1193   g_key_file_clear (key_file);
1194 
1195   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1196     g_slice_free (GKeyFile, key_file);
1197   else
1198     g_key_file_init (key_file);
1199 }
1200 
1201 /**
1202  * g_key_file_unref:
1203  * @key_file: a #GKeyFile
1204  *
1205  * Decreases the reference count of @key_file by 1. If the reference count
1206  * reaches zero, frees the key file and all its allocated memory.
1207  *
1208  * Since: 2.32
1209  **/
1210 void
1211 g_key_file_unref (GKeyFile *key_file)
1212 {
1213   g_return_if_fail (key_file != NULL);
1214 
1215   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1216     {
1217       g_key_file_clear (key_file);
1218       g_slice_free (GKeyFile, key_file);
1219     }
1220 }
1221 
1222 /* If G_KEY_FILE_KEEP_TRANSLATIONS is not set, only returns
1223  * true for locales that match those in g_get_language_names().
1224  */
1225 static gboolean
1226 g_key_file_locale_is_interesting (GKeyFile    *key_file,
1227                   const gchar *locale)
1228 {
1229   gsize i;
1230 
1231   if (key_file-&gt;flags &amp; G_KEY_FILE_KEEP_TRANSLATIONS)
1232     return TRUE;
1233 
1234   for (i = 0; key_file-&gt;locales[i] != NULL; i++)
1235     {
1236       if (g_ascii_strcasecmp (key_file-&gt;locales[i], locale) == 0)
1237     return TRUE;
1238     }
1239 
1240   return FALSE;
1241 }
1242 
1243 static void
1244 g_key_file_parse_line (GKeyFile     *key_file,
1245                const gchar  *line,
1246                gsize         length,
1247                GError      **error)
1248 {
1249   GError *parse_error = NULL;
1250   gchar *line_start;
1251 
1252   g_return_if_fail (key_file != NULL);
1253   g_return_if_fail (line != NULL);
1254 
1255   line_start = (gchar *) line;
1256   while (g_ascii_isspace (*line_start))
1257     line_start++;
1258 
1259   if (g_key_file_line_is_comment (line_start))
1260     g_key_file_parse_comment (key_file, line, length, &amp;parse_error);
1261   else if (g_key_file_line_is_group (line_start))
1262     g_key_file_parse_group (key_file, line_start,
1263                 length - (line_start - line),
1264                 &amp;parse_error);
1265   else if (g_key_file_line_is_key_value_pair (line_start))
1266     g_key_file_parse_key_value_pair (key_file, line_start,
1267                      length - (line_start - line),
1268                      &amp;parse_error);
1269   else
1270     {
1271       gchar *line_utf8 = g_utf8_make_valid (line, length);
1272       g_set_error (error, G_KEY_FILE_ERROR,
1273                    G_KEY_FILE_ERROR_PARSE,
1274                    _(&quot;Key file contains line &#39;%s&#39; which is not &quot;
1275                      &quot;a key-value pair, group, or comment&quot;),
1276                    line_utf8);
1277       g_free (line_utf8);
1278 
1279       return;
1280     }
1281 
1282   if (parse_error)
1283     g_propagate_error (error, parse_error);
1284 }
1285 
1286 static void
1287 g_key_file_parse_comment (GKeyFile     *key_file,
1288               const gchar  *line,
1289               gsize         length,
1290               GError      **error)
1291 {
1292   GKeyFileKeyValuePair *pair;
1293 
1294   if (!(key_file-&gt;flags &amp; G_KEY_FILE_KEEP_COMMENTS))
1295     return;
1296 
1297   g_warn_if_fail (key_file-&gt;current_group != NULL);
1298 
1299   pair = g_slice_new (GKeyFileKeyValuePair);
1300 #ifdef GSTREAMER_LITE
1301   if (pair == NULL) {
1302     g_warn_if_fail(pair != NULL);
1303     return;
1304   }
1305 #endif // GSTREAMER_LITE
1306   pair-&gt;key = NULL;
1307   pair-&gt;value = g_strndup (line, length);
1308 
1309   key_file-&gt;current_group-&gt;key_value_pairs =
1310     g_list_prepend (key_file-&gt;current_group-&gt;key_value_pairs, pair);
1311 }
1312 
1313 static void
1314 g_key_file_parse_group (GKeyFile     *key_file,
1315             const gchar  *line,
1316             gsize         length,
1317             GError      **error)
1318 {
1319   gchar *group_name;
1320   const gchar *group_name_start, *group_name_end;
1321 
1322   /* advance past opening &#39;[&#39;
1323    */
1324   group_name_start = line + 1;
1325   group_name_end = line + length - 1;
1326 
1327   while (*group_name_end != &#39;]&#39;)
1328     group_name_end--;
1329 
1330   group_name = g_strndup (group_name_start,
1331                           group_name_end - group_name_start);
1332 
1333   if (!g_key_file_is_group_name (group_name))
1334     {
1335       g_set_error (error, G_KEY_FILE_ERROR,
1336            G_KEY_FILE_ERROR_PARSE,
1337            _(&quot;Invalid group name: %s&quot;), group_name);
1338       g_free (group_name);
1339       return;
1340     }
1341 
1342   g_key_file_add_group (key_file, group_name);
1343   g_free (group_name);
1344 }
1345 
1346 static void
1347 g_key_file_parse_key_value_pair (GKeyFile     *key_file,
1348                  const gchar  *line,
1349                  gsize         length,
1350                  GError      **error)
1351 {
1352   gchar *key, *value, *key_end, *value_start, *locale;
1353   gsize key_len, value_len;
1354 
1355   if (key_file-&gt;current_group == NULL || key_file-&gt;current_group-&gt;name == NULL)
1356     {
1357       g_set_error_literal (error, G_KEY_FILE_ERROR,
1358                            G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1359                            _(&quot;Key file does not start with a group&quot;));
1360       return;
1361     }
1362 
1363   key_end = value_start = strchr (line, &#39;=&#39;);
1364 
1365   g_warn_if_fail (key_end != NULL);
1366 
1367   key_end--;
1368   value_start++;
1369 
1370   /* Pull the key name from the line (chomping trailing whitespace)
1371    */
1372   while (g_ascii_isspace (*key_end))
1373     key_end--;
1374 
1375   key_len = key_end - line + 2;
1376 
1377   g_warn_if_fail (key_len &lt;= length);
1378 
1379   key = g_strndup (line, key_len - 1);
1380 
1381   if (!g_key_file_is_key_name (key))
1382     {
1383       g_set_error (error, G_KEY_FILE_ERROR,
1384                    G_KEY_FILE_ERROR_PARSE,
1385                    _(&quot;Invalid key name: %s&quot;), key);
1386       g_free (key);
1387       return;
1388     }
1389 
1390   /* Pull the value from the line (chugging leading whitespace)
1391    */
1392   while (g_ascii_isspace (*value_start))
1393     value_start++;
1394 
1395   value_len = line + length - value_start + 1;
1396 
1397   value = g_strndup (value_start, value_len);
1398 
1399   g_warn_if_fail (key_file-&gt;start_group != NULL);
1400 
1401   if (key_file-&gt;current_group
1402       &amp;&amp; key_file-&gt;current_group-&gt;name
1403       &amp;&amp; strcmp (key_file-&gt;start_group-&gt;name,
1404                  key_file-&gt;current_group-&gt;name) == 0
1405       &amp;&amp; strcmp (key, &quot;Encoding&quot;) == 0)
1406     {
1407       if (g_ascii_strcasecmp (value, &quot;UTF-8&quot;) != 0)
1408         {
1409       gchar *value_utf8 = g_utf8_make_valid (value, value_len);
1410           g_set_error (error, G_KEY_FILE_ERROR,
1411                        G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1412                        _(&quot;Key file contains unsupported &quot;
1413                          &quot;encoding &#39;%s&#39;&quot;), value_utf8);
1414           g_free (value_utf8);
1415 
1416           g_free (key);
1417           g_free (value);
1418           return;
1419         }
1420     }
1421 
1422   /* Is this key a translation? If so, is it one that we care about?
1423    */
1424   locale = key_get_locale (key);
1425 
1426   if (locale == NULL || g_key_file_locale_is_interesting (key_file, locale))
1427     {
1428       GKeyFileKeyValuePair *pair;
1429 
1430       pair = g_slice_new (GKeyFileKeyValuePair);
1431 #ifdef GSTREAMER_LITE
1432       if (pair == NULL) {
1433         if (locale != NULL) {
1434           g_free (locale);
1435         }
1436         return;
1437       }
1438 #endif // GSTREAMER_LITE
1439       pair-&gt;key = key;
1440       pair-&gt;value = value;
1441 
1442       g_key_file_add_key_value_pair (key_file, key_file-&gt;current_group, pair);
1443     }
1444   else
1445     {
1446       g_free (key);
1447       g_free (value);
1448     }
1449 
1450   g_free (locale);
1451 }
1452 
1453 static gchar *
1454 key_get_locale (const gchar *key)
1455 {
1456   gchar *locale;
1457 
1458   locale = g_strrstr (key, &quot;[&quot;);
1459 
1460   if (locale &amp;&amp; strlen (locale) &lt;= 2)
1461     locale = NULL;
1462 
1463   if (locale)
1464     locale = g_strndup (locale + 1, strlen (locale) - 2);
1465 
1466   return locale;
1467 }
1468 
1469 static void
1470 g_key_file_parse_data (GKeyFile     *key_file,
1471                const gchar  *data,
1472                gsize         length,
1473                GError      **error)
1474 {
1475   GError *parse_error;
1476   gsize i;
1477 
1478   g_return_if_fail (key_file != NULL);
1479   g_return_if_fail (data != NULL || length == 0);
1480 
1481   parse_error = NULL;
1482 
1483   i = 0;
1484   while (i &lt; length)
1485     {
1486       if (data[i] == &#39;\n&#39;)
1487         {
1488       if (key_file-&gt;parse_buffer-&gt;len &gt; 0
1489           &amp;&amp; (key_file-&gt;parse_buffer-&gt;str[key_file-&gt;parse_buffer-&gt;len - 1]
1490           == &#39;\r&#39;))
1491         g_string_erase (key_file-&gt;parse_buffer,
1492                 key_file-&gt;parse_buffer-&gt;len - 1,
1493                 1);
1494 
1495           /* When a newline is encountered flush the parse buffer so that the
1496            * line can be parsed.  Note that completely blank lines won&#39;t show
1497            * up in the parse buffer, so they get parsed directly.
1498            */
1499           if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1500             g_key_file_flush_parse_buffer (key_file, &amp;parse_error);
1501           else
1502             g_key_file_parse_comment (key_file, &quot;&quot;, 1, &amp;parse_error);
1503 
1504           if (parse_error)
1505             {
1506               g_propagate_error (error, parse_error);
1507               return;
1508             }
1509           i++;
1510         }
1511       else
1512         {
1513           const gchar *start_of_line;
1514           const gchar *end_of_line;
1515           gsize line_length;
1516 
1517           start_of_line = data + i;
1518           end_of_line = memchr (start_of_line, &#39;\n&#39;, length - i);
1519 
1520           if (end_of_line == NULL)
1521             end_of_line = data + length;
1522 
1523           line_length = end_of_line - start_of_line;
1524 
1525           g_string_append_len (key_file-&gt;parse_buffer, start_of_line, line_length);
1526           i += line_length;
1527         }
1528     }
1529 }
1530 
1531 static void
1532 g_key_file_flush_parse_buffer (GKeyFile  *key_file,
1533                    GError   **error)
1534 {
1535   GError *file_error = NULL;
1536 
1537   g_return_if_fail (key_file != NULL);
1538 
1539   file_error = NULL;
1540 
1541   if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1542     {
1543       g_key_file_parse_line (key_file, key_file-&gt;parse_buffer-&gt;str,
1544                  key_file-&gt;parse_buffer-&gt;len,
1545                  &amp;file_error);
1546       g_string_erase (key_file-&gt;parse_buffer, 0, -1);
1547 
1548       if (file_error)
1549         {
1550           g_propagate_error (error, file_error);
1551           return;
1552         }
1553     }
1554 }
1555 
1556 /**
1557  * g_key_file_to_data:
1558  * @key_file: a #GKeyFile
1559  * @length: (out) (optional): return location for the length of the
1560  *   returned string, or %NULL
1561  * @error: return location for a #GError, or %NULL
1562  *
1563  * This function outputs @key_file as a string.
1564  *
1565  * Note that this function never reports an error,
1566  * so it is safe to pass %NULL as @error.
1567  *
1568  * Returns: a newly allocated string holding
1569  *   the contents of the #GKeyFile
1570  *
1571  * Since: 2.6
1572  **/
1573 gchar *
1574 g_key_file_to_data (GKeyFile  *key_file,
1575             gsize     *length,
1576             GError   **error)
1577 {
1578   GString *data_string;
1579   GList *group_node, *key_file_node;
1580 
1581   g_return_val_if_fail (key_file != NULL, NULL);
1582 
1583   data_string = g_string_new (NULL);
1584 
1585   for (group_node = g_list_last (key_file-&gt;groups);
1586        group_node != NULL;
1587        group_node = group_node-&gt;prev)
1588     {
1589       GKeyFileGroup *group;
1590 
1591       group = (GKeyFileGroup *) group_node-&gt;data;
1592 
1593       /* separate groups by at least an empty line */
1594       if (data_string-&gt;len &gt;= 2 &amp;&amp;
1595           data_string-&gt;str[data_string-&gt;len - 2] != &#39;\n&#39;)
1596         g_string_append_c (data_string, &#39;\n&#39;);
1597 
1598       if (group-&gt;comment != NULL)
1599         g_string_append_printf (data_string, &quot;%s\n&quot;, group-&gt;comment-&gt;value);
1600 
1601       if (group-&gt;name != NULL)
1602         g_string_append_printf (data_string, &quot;[%s]\n&quot;, group-&gt;name);
1603 
1604       for (key_file_node = g_list_last (group-&gt;key_value_pairs);
1605            key_file_node != NULL;
1606            key_file_node = key_file_node-&gt;prev)
1607         {
1608           GKeyFileKeyValuePair *pair;
1609 
1610           pair = (GKeyFileKeyValuePair *) key_file_node-&gt;data;
1611 
1612           if (pair-&gt;key != NULL)
1613             g_string_append_printf (data_string, &quot;%s=%s\n&quot;, pair-&gt;key, pair-&gt;value);
1614           else
1615             g_string_append_printf (data_string, &quot;%s\n&quot;, pair-&gt;value);
1616         }
1617     }
1618 
1619   if (length)
1620     *length = data_string-&gt;len;
1621 
1622   return g_string_free (data_string, FALSE);
1623 }
1624 
1625 /**
1626  * g_key_file_get_keys:
1627  * @key_file: a #GKeyFile
1628  * @group_name: a group name
1629  * @length: (out) (optional): return location for the number of keys returned, or %NULL
1630  * @error: return location for a #GError, or %NULL
1631  *
1632  * Returns all keys for the group name @group_name.  The array of
1633  * returned keys will be %NULL-terminated, so @length may
1634  * optionally be %NULL. In the event that the @group_name cannot
1635  * be found, %NULL is returned and @error is set to
1636  * #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1637  *
1638  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1639  *     Use g_strfreev() to free it.
1640  *
1641  * Since: 2.6
1642  **/
1643 gchar **
1644 g_key_file_get_keys (GKeyFile     *key_file,
1645              const gchar  *group_name,
1646              gsize        *length,
1647              GError      **error)
1648 {
1649   GKeyFileGroup *group;
1650   GList *tmp;
1651   gchar **keys;
1652   gsize i, num_keys;
1653 
1654   g_return_val_if_fail (key_file != NULL, NULL);
1655   g_return_val_if_fail (group_name != NULL, NULL);
1656 
1657   group = g_key_file_lookup_group (key_file, group_name);
1658 
1659   if (!group)
1660     {
1661       g_set_error (error, G_KEY_FILE_ERROR,
1662                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1663                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1664 #ifdef GSTREAMER_LITE
1665                    group_name ? group_name : &quot;(null)&quot;);
1666 #else // GSTREAMER_LITE
1667                    group_name);
1668 #endif // GSTREAMER_LITE
1669       return NULL;
1670     }
1671 
1672   num_keys = 0;
1673   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1674     {
1675       GKeyFileKeyValuePair *pair;
1676 
1677       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1678 
1679       if (pair-&gt;key)
1680     num_keys++;
1681     }
1682 
1683   keys = g_new (gchar *, num_keys + 1);
1684 
1685   i = num_keys - 1;
1686   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1687     {
1688       GKeyFileKeyValuePair *pair;
1689 
1690       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1691 
1692       if (pair-&gt;key)
1693     {
1694       keys[i] = g_strdup (pair-&gt;key);
1695       i--;
1696     }
1697     }
1698 
1699   keys[num_keys] = NULL;
1700 
1701   if (length)
1702     *length = num_keys;
1703 
1704   return keys;
1705 }
1706 
1707 /**
1708  * g_key_file_get_start_group:
1709  * @key_file: a #GKeyFile
1710  *
1711  * Returns the name of the start group of the file.
1712  *
1713  * Returns: The start group of the key file.
1714  *
1715  * Since: 2.6
1716  **/
1717 gchar *
1718 g_key_file_get_start_group (GKeyFile *key_file)
1719 {
1720   g_return_val_if_fail (key_file != NULL, NULL);
1721 
1722   if (key_file-&gt;start_group)
1723     return g_strdup (key_file-&gt;start_group-&gt;name);
1724 
1725   return NULL;
1726 }
1727 
1728 /**
1729  * g_key_file_get_groups:
1730  * @key_file: a #GKeyFile
1731  * @length: (out) (optional): return location for the number of returned groups, or %NULL
1732  *
1733  * Returns all groups in the key file loaded with @key_file.
1734  * The array of returned groups will be %NULL-terminated, so
1735  * @length may optionally be %NULL.
1736  *
1737  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1738  *   Use g_strfreev() to free it.
1739  * Since: 2.6
1740  **/
1741 gchar **
1742 g_key_file_get_groups (GKeyFile *key_file,
1743                gsize    *length)
1744 {
1745   GList *group_node;
1746   gchar **groups;
1747   gsize i, num_groups;
1748 
1749   g_return_val_if_fail (key_file != NULL, NULL);
1750 
1751   num_groups = g_list_length (key_file-&gt;groups);
1752 
1753   g_return_val_if_fail (num_groups &gt; 0, NULL);
1754 
1755   group_node = g_list_last (key_file-&gt;groups);
1756 
1757   g_return_val_if_fail (((GKeyFileGroup *) group_node-&gt;data)-&gt;name == NULL, NULL);
1758 
1759   /* Only need num_groups instead of num_groups + 1
1760    * because the first group of the file (last in the
1761    * list) is always the comment group at the top,
1762    * which we skip
1763    */
1764   groups = g_new (gchar *, num_groups);
1765 
1766 
1767   i = 0;
1768   for (group_node = group_node-&gt;prev;
1769        group_node != NULL;
1770        group_node = group_node-&gt;prev)
1771     {
1772       GKeyFileGroup *group;
1773 
1774       group = (GKeyFileGroup *) group_node-&gt;data;
1775 
1776       g_warn_if_fail (group-&gt;name != NULL);
1777 
1778       groups[i++] = g_strdup (group-&gt;name);
1779     }
1780   groups[i] = NULL;
1781 
1782   if (length)
1783     *length = i;
1784 
1785   return groups;
1786 }
1787 
1788 static void
1789 set_not_found_key_error (const char *group_name,
1790                          const char *key,
1791                          GError    **error)
1792 {
1793   g_set_error (error, G_KEY_FILE_ERROR,
1794                G_KEY_FILE_ERROR_KEY_NOT_FOUND,
1795                _(&quot;Key file does not have key &#39;%s&#39; in group &#39;%s&#39;&quot;),
1796                key, group_name);
1797 }
1798 
1799 /**
1800  * g_key_file_get_value:
1801  * @key_file: a #GKeyFile
1802  * @group_name: a group name
1803  * @key: a key
1804  * @error: return location for a #GError, or %NULL
1805  *
1806  * Returns the raw value associated with @key under @group_name.
1807  * Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
1808  *
1809  * In the event the key cannot be found, %NULL is returned and
1810  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1811  * event that the @group_name cannot be found, %NULL is returned
1812  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1813  *
1814  *
1815  * Returns: a newly allocated string or %NULL if the specified
1816  *  key cannot be found.
1817  *
1818  * Since: 2.6
1819  **/
1820 gchar *
1821 g_key_file_get_value (GKeyFile     *key_file,
1822               const gchar  *group_name,
1823               const gchar  *key,
1824               GError      **error)
1825 {
1826   GKeyFileGroup *group;
1827   GKeyFileKeyValuePair *pair;
1828   gchar *value = NULL;
1829 
1830   g_return_val_if_fail (key_file != NULL, NULL);
1831   g_return_val_if_fail (group_name != NULL, NULL);
1832   g_return_val_if_fail (key != NULL, NULL);
1833 
1834   group = g_key_file_lookup_group (key_file, group_name);
1835 
1836   if (!group)
1837     {
1838       g_set_error (error, G_KEY_FILE_ERROR,
1839                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1840                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1841 #ifdef GSTREAMER_LITE
1842                    group_name ? group_name : &quot;(null)&quot;);
1843 #else // GSTREAMER_LITE
1844                    group_name);
1845 #endif // GSTREAMER_LITE
1846       return NULL;
1847     }
1848 
1849   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
1850 
1851   if (pair)
1852     value = g_strdup (pair-&gt;value);
1853   else
1854     set_not_found_key_error (group_name, key, error);
1855 
1856   return value;
1857 }
1858 
1859 /**
1860  * g_key_file_set_value:
1861  * @key_file: a #GKeyFile
1862  * @group_name: a group name
1863  * @key: a key
1864  * @value: a string
1865  *
1866  * Associates a new value with @key under @group_name.
1867  *
1868  * If @key cannot be found then it is created. If @group_name cannot
1869  * be found then it is created. To set an UTF-8 string which may contain
1870  * characters that need escaping (such as newlines or spaces), use
1871  * g_key_file_set_string().
1872  *
1873  * Since: 2.6
1874  **/
1875 void
1876 g_key_file_set_value (GKeyFile    *key_file,
1877               const gchar *group_name,
1878               const gchar *key,
1879               const gchar *value)
1880 {
1881   GKeyFileGroup *group;
1882   GKeyFileKeyValuePair *pair;
1883 
1884   g_return_if_fail (key_file != NULL);
1885   g_return_if_fail (g_key_file_is_group_name (group_name));
1886   g_return_if_fail (g_key_file_is_key_name (key));
1887   g_return_if_fail (value != NULL);
1888 
1889   group = g_key_file_lookup_group (key_file, group_name);
1890 
1891   if (!group)
1892     {
1893       g_key_file_add_group (key_file, group_name);
1894       group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
1895 
1896       g_key_file_add_key (key_file, group, key, value);
1897     }
1898   else
1899     {
1900       pair = g_key_file_lookup_key_value_pair (key_file, group, key);
1901 
1902       if (!pair)
1903         g_key_file_add_key (key_file, group, key, value);
1904       else
1905         {
1906           g_free (pair-&gt;value);
1907           pair-&gt;value = g_strdup (value);
1908         }
1909     }
1910 }
1911 
1912 /**
1913  * g_key_file_get_string:
1914  * @key_file: a #GKeyFile
1915  * @group_name: a group name
1916  * @key: a key
1917  * @error: return location for a #GError, or %NULL
1918  *
1919  * Returns the string value associated with @key under @group_name.
1920  * Unlike g_key_file_get_value(), this function handles escape sequences
1921  * like \s.
1922  *
1923  * In the event the key cannot be found, %NULL is returned and
1924  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1925  * event that the @group_name cannot be found, %NULL is returned
1926  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1927  *
1928  * Returns: a newly allocated string or %NULL if the specified
1929  *   key cannot be found.
1930  *
1931  * Since: 2.6
1932  **/
1933 gchar *
1934 g_key_file_get_string (GKeyFile     *key_file,
1935                const gchar  *group_name,
1936                const gchar  *key,
1937                GError      **error)
1938 {
1939   gchar *value, *string_value;
1940   GError *key_file_error;
1941 
1942   g_return_val_if_fail (key_file != NULL, NULL);
1943   g_return_val_if_fail (group_name != NULL, NULL);
1944   g_return_val_if_fail (key != NULL, NULL);
1945 
1946   key_file_error = NULL;
1947 
1948   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
1949 
1950   if (key_file_error)
1951     {
1952       g_propagate_error (error, key_file_error);
1953       return NULL;
1954     }
1955 
1956   if (!g_utf8_validate (value, -1, NULL))
1957     {
1958       gchar *value_utf8 = g_utf8_make_valid (value, -1);
1959       g_set_error (error, G_KEY_FILE_ERROR,
1960                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1961                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
1962                      &quot;which is not UTF-8&quot;), key, value_utf8);
1963       g_free (value_utf8);
1964       g_free (value);
1965 
1966       return NULL;
1967     }
1968 
1969   string_value = g_key_file_parse_value_as_string (key_file, value, NULL,
1970                            &amp;key_file_error);
1971   g_free (value);
1972 
1973   if (key_file_error)
1974     {
1975       if (g_error_matches (key_file_error,
1976                            G_KEY_FILE_ERROR,
1977                            G_KEY_FILE_ERROR_INVALID_VALUE))
1978         {
1979           g_set_error (error, G_KEY_FILE_ERROR,
1980                        G_KEY_FILE_ERROR_INVALID_VALUE,
1981                        _(&quot;Key file contains key &#39;%s&#39; &quot;
1982                          &quot;which has a value that cannot be interpreted.&quot;),
1983                        key);
1984           g_error_free (key_file_error);
1985         }
1986       else
1987         g_propagate_error (error, key_file_error);
1988     }
1989 
1990   return string_value;
1991 }
1992 
1993 /**
1994  * g_key_file_set_string:
1995  * @key_file: a #GKeyFile
1996  * @group_name: a group name
1997  * @key: a key
1998  * @string: a string
1999  *
2000  * Associates a new string value with @key under @group_name.
2001  * If @key cannot be found then it is created.
2002  * If @group_name cannot be found then it is created.
2003  * Unlike g_key_file_set_value(), this function handles characters
2004  * that need escaping, such as newlines.
2005  *
2006  * Since: 2.6
2007  **/
2008 void
2009 g_key_file_set_string (GKeyFile    *key_file,
2010                const gchar *group_name,
2011                const gchar *key,
2012                const gchar *string)
2013 {
2014   gchar *value;
2015 
2016   g_return_if_fail (key_file != NULL);
2017   g_return_if_fail (string != NULL);
2018 
2019   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2020   g_key_file_set_value (key_file, group_name, key, value);
2021   g_free (value);
2022 }
2023 
2024 /**
2025  * g_key_file_get_string_list:
2026  * @key_file: a #GKeyFile
2027  * @group_name: a group name
2028  * @key: a key
2029  * @length: (out) (optional): return location for the number of returned strings, or %NULL
2030  * @error: return location for a #GError, or %NULL
2031  *
2032  * Returns the values associated with @key under @group_name.
2033  *
2034  * In the event the key cannot be found, %NULL is returned and
2035  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
2036  * event that the @group_name cannot be found, %NULL is returned
2037  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
2038  *
2039  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full):
2040  *  a %NULL-terminated string array or %NULL if the specified
2041  *  key cannot be found. The array should be freed with g_strfreev().
2042  *
2043  * Since: 2.6
2044  **/
2045 gchar **
2046 g_key_file_get_string_list (GKeyFile     *key_file,
2047                 const gchar  *group_name,
2048                 const gchar  *key,
2049                 gsize        *length,
2050                 GError      **error)
2051 {
2052   GError *key_file_error = NULL;
2053   gchar *value, *string_value, **values;
2054   gint i, len;
2055   GSList *p, *pieces = NULL;
2056 
2057   g_return_val_if_fail (key_file != NULL, NULL);
2058   g_return_val_if_fail (group_name != NULL, NULL);
2059   g_return_val_if_fail (key != NULL, NULL);
2060 
2061   if (length)
2062     *length = 0;
2063 
2064   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2065 
2066   if (key_file_error)
2067     {
2068       g_propagate_error (error, key_file_error);
2069       return NULL;
2070     }
2071 
2072   if (!g_utf8_validate (value, -1, NULL))
2073     {
2074       gchar *value_utf8 = g_utf8_make_valid (value, -1);
2075       g_set_error (error, G_KEY_FILE_ERROR,
2076                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
2077                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
2078                      &quot;which is not UTF-8&quot;), key, value_utf8);
2079       g_free (value_utf8);
2080       g_free (value);
2081 
2082       return NULL;
2083     }
2084 
2085   string_value = g_key_file_parse_value_as_string (key_file, value, &amp;pieces, &amp;key_file_error);
2086   g_free (value);
2087   g_free (string_value);
2088 
2089   if (key_file_error)
2090     {
2091       if (g_error_matches (key_file_error,
2092                            G_KEY_FILE_ERROR,
2093                            G_KEY_FILE_ERROR_INVALID_VALUE))
2094         {
2095           g_set_error (error, G_KEY_FILE_ERROR,
2096                        G_KEY_FILE_ERROR_INVALID_VALUE,
2097                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2098                          &quot;which has a value that cannot be interpreted.&quot;),
2099                        key);
2100           g_error_free (key_file_error);
2101         }
2102       else
2103         g_propagate_error (error, key_file_error);
2104 
2105       g_slist_free_full (pieces, g_free);
2106       return NULL;
2107     }
2108 
2109   len = g_slist_length (pieces);
2110   values = g_new (gchar *, len + 1);
2111   for (p = pieces, i = 0; p; p = p-&gt;next)
2112     values[i++] = p-&gt;data;
2113   values[len] = NULL;
2114 
2115   g_slist_free (pieces);
2116 
2117   if (length)
2118     *length = len;
2119 
2120   return values;
2121 }
2122 
2123 /**
2124  * g_key_file_set_string_list:
2125  * @key_file: a #GKeyFile
2126  * @group_name: a group name
2127  * @key: a key
2128  * @list: (array zero-terminated=1 length=length) (element-type utf8): an array of string values
2129  * @length: number of string values in @list
2130  *
2131  * Associates a list of string values for @key under @group_name.
2132  * If @key cannot be found then it is created.
2133  * If @group_name cannot be found then it is created.
2134  *
2135  * Since: 2.6
2136  **/
2137 void
2138 g_key_file_set_string_list (GKeyFile            *key_file,
2139                 const gchar         *group_name,
2140                 const gchar         *key,
2141                 const gchar * const  list[],
2142                 gsize                length)
2143 {
2144   GString *value_list;
2145   gsize i;
2146 
2147   g_return_if_fail (key_file != NULL);
2148   g_return_if_fail (list != NULL || length == 0);
2149 
2150   value_list = g_string_sized_new (length * 128);
2151 #ifdef GSTREAMER_LITE
2152   if (value_list == NULL) {
2153     return;
2154   }
2155 #endif // GSTREAMER_LITE
2156   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2157     {
2158       gchar *value;
2159 
2160       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2161       g_string_append (value_list, value);
2162       g_string_append_c (value_list, key_file-&gt;list_separator);
2163 
2164       g_free (value);
2165     }
2166 
2167   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2168   g_string_free (value_list, TRUE);
2169 }
2170 
2171 /**
2172  * g_key_file_set_locale_string:
2173  * @key_file: a #GKeyFile
2174  * @group_name: a group name
2175  * @key: a key
2176  * @locale: a locale identifier
2177  * @string: a string
2178  *
2179  * Associates a string value for @key and @locale under @group_name.
2180  * If the translation for @key cannot be found then it is created.
2181  *
2182  * Since: 2.6
2183  **/
2184 void
2185 g_key_file_set_locale_string (GKeyFile     *key_file,
2186                   const gchar  *group_name,
2187                   const gchar  *key,
2188                   const gchar  *locale,
2189                   const gchar  *string)
2190 {
2191   gchar *full_key, *value;
2192 
2193   g_return_if_fail (key_file != NULL);
2194   g_return_if_fail (key != NULL);
2195   g_return_if_fail (locale != NULL);
2196   g_return_if_fail (string != NULL);
2197 
2198   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2199   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2200   g_key_file_set_value (key_file, group_name, full_key, value);
2201   g_free (full_key);
2202   g_free (value);
2203 }
2204 
2205 /**
2206  * g_key_file_get_locale_string:
2207  * @key_file: a #GKeyFile
2208  * @group_name: a group name
2209  * @key: a key
2210  * @locale: (nullable): a locale identifier or %NULL
2211  * @error: return location for a #GError, or %NULL
2212  *
2213  * Returns the value associated with @key under @group_name
2214  * translated in the given @locale if available.  If @locale is
2215  * %NULL then the current locale is assumed.
2216  *
2217  * If @locale is to be non-%NULL, or if the current locale will change over
2218  * the lifetime of the #GKeyFile, it must be loaded with
2219  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2220  *
2221  * If @key cannot be found then %NULL is returned and @error is set
2222  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
2223  * with @key cannot be interpreted or no suitable translation can
2224  * be found then the untranslated value is returned.
2225  *
2226  * Returns: a newly allocated string or %NULL if the specified
2227  *   key cannot be found.
2228  *
2229  * Since: 2.6
2230  **/
2231 gchar *
2232 g_key_file_get_locale_string (GKeyFile     *key_file,
2233                   const gchar  *group_name,
2234                   const gchar  *key,
2235                   const gchar  *locale,
2236                   GError      **error)
2237 {
2238   gchar *candidate_key, *translated_value;
2239   GError *key_file_error;
2240   gchar **languages;
2241   gboolean free_languages = FALSE;
2242   gint i;
2243 
2244   g_return_val_if_fail (key_file != NULL, NULL);
2245   g_return_val_if_fail (group_name != NULL, NULL);
2246   g_return_val_if_fail (key != NULL, NULL);
2247 
2248   candidate_key = NULL;
2249   translated_value = NULL;
2250   key_file_error = NULL;
2251 
2252   if (locale)
2253     {
2254       languages = g_get_locale_variants (locale);
2255       free_languages = TRUE;
2256     }
2257   else
2258     {
2259       languages = (gchar **) g_get_language_names ();
2260       free_languages = FALSE;
2261     }
2262 
2263   for (i = 0; languages[i]; i++)
2264     {
2265       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2266 
2267       translated_value = g_key_file_get_string (key_file,
2268                         group_name,
2269                         candidate_key, NULL);
2270       g_free (candidate_key);
2271 
2272       if (translated_value)
2273     break;
2274 
2275       g_free (translated_value);
2276       translated_value = NULL;
2277    }
2278 
2279   /* Fallback to untranslated key
2280    */
2281   if (!translated_value)
2282     {
2283       translated_value = g_key_file_get_string (key_file, group_name, key,
2284                         &amp;key_file_error);
2285 
2286       if (!translated_value)
2287         g_propagate_error (error, key_file_error);
2288     }
2289 
2290   if (free_languages)
2291     g_strfreev (languages);
2292 
2293   return translated_value;
2294 }
2295 
2296 /**
2297  * g_key_file_get_locale_for_key:
2298  * @key_file: a #GKeyFile
2299  * @group_name: a group name
2300  * @key: a key
2301  * @locale: (nullable): a locale identifier or %NULL
2302  *
2303  * Returns the actual locale which the result of
2304  * g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
2305  * came from.
2306  *
2307  * If calling g_key_file_get_locale_string() or
2308  * g_key_file_get_locale_string_list() with exactly the same @key_file,
2309  * @group_name, @key and @locale, the result of those functions will
2310  * have originally been tagged with the locale that is the result of
2311  * this function.
2312  *
2313  * Returns: (nullable): the locale from the file, or %NULL if the key was not
2314  *   found or the entry in the file was was untranslated
2315  *
2316  * Since: 2.56
2317  */
2318 gchar *
2319 g_key_file_get_locale_for_key (GKeyFile    *key_file,
2320                                const gchar *group_name,
2321                                const gchar *key,
2322                                const gchar *locale)
2323 {
2324   gchar **languages_allocated = NULL;
2325   const gchar * const *languages;
2326   gchar *result = NULL;
2327   gsize i;
2328 
2329   g_return_val_if_fail (key_file != NULL, NULL);
2330   g_return_val_if_fail (group_name != NULL, NULL);
2331   g_return_val_if_fail (key != NULL, NULL);
2332 
2333   if (locale != NULL)
2334     {
2335       languages_allocated = g_get_locale_variants (locale);
2336       languages = (const gchar * const *) languages_allocated;
2337     }
2338   else
2339     languages = g_get_language_names ();
2340 
2341   for (i = 0; languages[i] != NULL; i++)
2342     {
2343       gchar *candidate_key, *translated_value;
2344 
2345       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2346       translated_value = g_key_file_get_string (key_file, group_name, candidate_key, NULL);
2347       g_free (translated_value);
2348       g_free (candidate_key);
2349 
2350       if (translated_value != NULL)
2351         break;
2352    }
2353 
2354   result = g_strdup (languages[i]);
2355 
2356   g_strfreev (languages_allocated);
2357 
2358   return result;
2359 }
2360 
2361 /**
2362  * g_key_file_get_locale_string_list:
2363  * @key_file: a #GKeyFile
2364  * @group_name: a group name
2365  * @key: a key
2366  * @locale: (nullable): a locale identifier or %NULL
2367  * @length: (out) (optional): return location for the number of returned strings or %NULL
2368  * @error: return location for a #GError or %NULL
2369  *
2370  * Returns the values associated with @key under @group_name
2371  * translated in the given @locale if available.  If @locale is
2372  * %NULL then the current locale is assumed.
2373  *
2374  * If @locale is to be non-%NULL, or if the current locale will change over
2375  * the lifetime of the #GKeyFile, it must be loaded with
2376  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2377  *
2378  * If @key cannot be found then %NULL is returned and @error is set
2379  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
2380  * with @key cannot be interpreted or no suitable translations
2381  * can be found then the untranslated values are returned. The
2382  * returned array is %NULL-terminated, so @length may optionally
2383  * be %NULL.
2384  *
2385  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full): a newly allocated %NULL-terminated string array
2386  *   or %NULL if the key isn&#39;t found. The string array should be freed
2387  *   with g_strfreev().
2388  *
2389  * Since: 2.6
2390  **/
2391 gchar **
2392 g_key_file_get_locale_string_list (GKeyFile     *key_file,
2393                    const gchar  *group_name,
2394                    const gchar  *key,
2395                    const gchar  *locale,
2396                    gsize        *length,
2397                    GError      **error)
2398 {
2399   GError *key_file_error;
2400   gchar **values, *value;
2401   char list_separator[2];
2402   gsize len;
2403 
2404   g_return_val_if_fail (key_file != NULL, NULL);
2405   g_return_val_if_fail (group_name != NULL, NULL);
2406   g_return_val_if_fail (key != NULL, NULL);
2407 
2408   key_file_error = NULL;
2409 
2410   value = g_key_file_get_locale_string (key_file, group_name,
2411                     key, locale,
2412                     &amp;key_file_error);
2413 
2414   if (key_file_error)
2415     g_propagate_error (error, key_file_error);
2416 
2417   if (!value)
2418     {
2419       if (length)
2420         *length = 0;
2421       return NULL;
2422     }
2423 
2424   len = strlen (value);
2425   if (value[len - 1] == key_file-&gt;list_separator)
2426     value[len - 1] = &#39;\0&#39;;
2427 
2428   list_separator[0] = key_file-&gt;list_separator;
2429   list_separator[1] = &#39;\0&#39;;
2430   values = g_strsplit (value, list_separator, 0);
2431 
2432   g_free (value);
2433 
2434   if (length)
2435     *length = g_strv_length (values);
2436 
2437   return values;
2438 }
2439 
2440 /**
2441  * g_key_file_set_locale_string_list:
2442  * @key_file: a #GKeyFile
2443  * @group_name: a group name
2444  * @key: a key
2445  * @locale: a locale identifier
2446  * @list: (array zero-terminated=1 length=length): a %NULL-terminated array of locale string values
2447  * @length: the length of @list
2448  *
2449  * Associates a list of string values for @key and @locale under
2450  * @group_name.  If the translation for @key cannot be found then
2451  * it is created.
2452  *
2453  * Since: 2.6
2454  **/
2455 void
2456 g_key_file_set_locale_string_list (GKeyFile            *key_file,
2457                    const gchar         *group_name,
2458                    const gchar         *key,
2459                    const gchar         *locale,
2460                    const gchar * const  list[],
2461                    gsize                length)
2462 {
2463   GString *value_list;
2464   gchar *full_key;
2465   gsize i;
2466 
2467   g_return_if_fail (key_file != NULL);
2468   g_return_if_fail (key != NULL);
2469   g_return_if_fail (locale != NULL);
2470   g_return_if_fail (length != 0);
2471 
2472   value_list = g_string_sized_new (length * 128);
2473 #ifdef GSTREAMER_LITE
2474   if (value_list == NULL) {
2475     return;
2476   }
2477 #endif // GSTREAMER_LITE
2478   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2479     {
2480       gchar *value;
2481 
2482       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2483       g_string_append (value_list, value);
2484       g_string_append_c (value_list, key_file-&gt;list_separator);
2485 
2486       g_free (value);
2487     }
2488 
2489   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2490   g_key_file_set_value (key_file, group_name, full_key, value_list-&gt;str);
2491   g_free (full_key);
2492   g_string_free (value_list, TRUE);
2493 }
2494 
2495 /**
2496  * g_key_file_get_boolean:
2497  * @key_file: a #GKeyFile
2498  * @group_name: a group name
2499  * @key: a key
2500  * @error: return location for a #GError
2501  *
2502  * Returns the value associated with @key under @group_name as a
2503  * boolean.
2504  *
2505  * If @key cannot be found then %FALSE is returned and @error is set
2506  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
2507  * associated with @key cannot be interpreted as a boolean then %FALSE
2508  * is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2509  *
2510  * Returns: the value associated with the key as a boolean,
2511  *    or %FALSE if the key was not found or could not be parsed.
2512  *
2513  * Since: 2.6
2514  **/
2515 gboolean
2516 g_key_file_get_boolean (GKeyFile     *key_file,
2517             const gchar  *group_name,
2518             const gchar  *key,
2519             GError      **error)
2520 {
2521   GError *key_file_error = NULL;
2522   gchar *value;
2523   gboolean bool_value;
2524 
2525   g_return_val_if_fail (key_file != NULL, FALSE);
2526   g_return_val_if_fail (group_name != NULL, FALSE);
2527   g_return_val_if_fail (key != NULL, FALSE);
2528 
2529   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2530 
2531   if (!value)
2532     {
2533       g_propagate_error (error, key_file_error);
2534       return FALSE;
2535     }
2536 
2537   bool_value = g_key_file_parse_value_as_boolean (key_file, value,
2538                           &amp;key_file_error);
2539   g_free (value);
2540 
2541   if (key_file_error)
2542     {
2543       if (g_error_matches (key_file_error,
2544                            G_KEY_FILE_ERROR,
2545                            G_KEY_FILE_ERROR_INVALID_VALUE))
2546         {
2547           g_set_error (error, G_KEY_FILE_ERROR,
2548                        G_KEY_FILE_ERROR_INVALID_VALUE,
2549                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2550                          &quot;which has a value that cannot be interpreted.&quot;),
2551                        key);
2552           g_error_free (key_file_error);
2553         }
2554       else
2555         g_propagate_error (error, key_file_error);
2556     }
2557 
2558   return bool_value;
2559 }
2560 
2561 /**
2562  * g_key_file_set_boolean:
2563  * @key_file: a #GKeyFile
2564  * @group_name: a group name
2565  * @key: a key
2566  * @value: %TRUE or %FALSE
2567  *
2568  * Associates a new boolean value with @key under @group_name.
2569  * If @key cannot be found then it is created.
2570  *
2571  * Since: 2.6
2572  **/
2573 void
2574 g_key_file_set_boolean (GKeyFile    *key_file,
2575             const gchar *group_name,
2576             const gchar *key,
2577             gboolean     value)
2578 {
2579   gchar *result;
2580 
2581   g_return_if_fail (key_file != NULL);
2582 
2583   result = g_key_file_parse_boolean_as_value (key_file, value);
2584   g_key_file_set_value (key_file, group_name, key, result);
2585   g_free (result);
2586 }
2587 
2588 /**
2589  * g_key_file_get_boolean_list:
2590  * @key_file: a #GKeyFile
2591  * @group_name: a group name
2592  * @key: a key
2593  * @length: (out): the number of booleans returned
2594  * @error: return location for a #GError
2595  *
2596  * Returns the values associated with @key under @group_name as
2597  * booleans.
2598  *
2599  * If @key cannot be found then %NULL is returned and @error is set to
2600  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2601  * with @key cannot be interpreted as booleans then %NULL is returned
2602  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2603  *
2604  * Returns: (array length=length) (element-type gboolean) (transfer container):
2605  *    the values associated with the key as a list of booleans, or %NULL if the
2606  *    key was not found or could not be parsed. The returned list of booleans
2607  *    should be freed with g_free() when no longer needed.
2608  *
2609  * Since: 2.6
2610  **/
2611 gboolean *
2612 g_key_file_get_boolean_list (GKeyFile     *key_file,
2613                  const gchar  *group_name,
2614                  const gchar  *key,
2615                  gsize        *length,
2616                  GError      **error)
2617 {
2618   GError *key_file_error;
2619   gchar **values;
2620   gboolean *bool_values;
2621   gsize i, num_bools;
2622 
2623   g_return_val_if_fail (key_file != NULL, NULL);
2624   g_return_val_if_fail (group_name != NULL, NULL);
2625   g_return_val_if_fail (key != NULL, NULL);
2626 
2627   if (length)
2628     *length = 0;
2629 
2630   key_file_error = NULL;
2631 
2632   values = g_key_file_get_string_list (key_file, group_name, key,
2633                        &amp;num_bools, &amp;key_file_error);
2634 
2635   if (key_file_error)
2636     g_propagate_error (error, key_file_error);
2637 
2638   if (!values)
2639     return NULL;
2640 
2641   bool_values = g_new (gboolean, num_bools);
2642 
2643   for (i = 0; i &lt; num_bools; i++)
2644     {
2645       bool_values[i] = g_key_file_parse_value_as_boolean (key_file,
2646                               values[i],
2647                               &amp;key_file_error);
2648 
2649       if (key_file_error)
2650         {
2651           g_propagate_error (error, key_file_error);
2652           g_strfreev (values);
2653           g_free (bool_values);
2654 
2655           return NULL;
2656         }
2657     }
2658   g_strfreev (values);
2659 
2660   if (length)
2661     *length = num_bools;
2662 
2663   return bool_values;
2664 }
2665 
2666 /**
2667  * g_key_file_set_boolean_list:
2668  * @key_file: a #GKeyFile
2669  * @group_name: a group name
2670  * @key: a key
2671  * @list: (array length=length): an array of boolean values
2672  * @length: length of @list
2673  *
2674  * Associates a list of boolean values with @key under @group_name.
2675  * If @key cannot be found then it is created.
2676  * If @group_name is %NULL, the start_group is used.
2677  *
2678  * Since: 2.6
2679  **/
2680 void
2681 g_key_file_set_boolean_list (GKeyFile    *key_file,
2682                  const gchar *group_name,
2683                  const gchar *key,
2684                  gboolean     list[],
2685                  gsize        length)
2686 {
2687   GString *value_list;
2688   gsize i;
2689 
2690   g_return_if_fail (key_file != NULL);
2691   g_return_if_fail (list != NULL);
2692 
2693   value_list = g_string_sized_new (length * 8);
2694 #ifdef GSTREAMER_LITE
2695   if (value_list == NULL) {
2696     return;
2697   }
2698 #endif // GSTREAMER_LITE
2699   for (i = 0; i &lt; length; i++)
2700     {
2701       gchar *value;
2702 
2703       value = g_key_file_parse_boolean_as_value (key_file, list[i]);
2704 
2705       g_string_append (value_list, value);
2706       g_string_append_c (value_list, key_file-&gt;list_separator);
2707 
2708       g_free (value);
2709     }
2710 
2711   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2712   g_string_free (value_list, TRUE);
2713 }
2714 
2715 /**
2716  * g_key_file_get_integer:
2717  * @key_file: a #GKeyFile
2718  * @group_name: a group name
2719  * @key: a key
2720  * @error: return location for a #GError
2721  *
2722  * Returns the value associated with @key under @group_name as an
2723  * integer.
2724  *
2725  * If @key cannot be found then 0 is returned and @error is set to
2726  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
2727  * with @key cannot be interpreted as an integer, or is out of range
2728  * for a #gint, then 0 is returned
2729  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2730  *
2731  * Returns: the value associated with the key as an integer, or
2732  *     0 if the key was not found or could not be parsed.
2733  *
2734  * Since: 2.6
2735  **/
2736 gint
2737 g_key_file_get_integer (GKeyFile     *key_file,
2738             const gchar  *group_name,
2739             const gchar  *key,
2740             GError      **error)
2741 {
2742   GError *key_file_error;
2743   gchar *value;
2744   gint int_value;
2745 
2746   g_return_val_if_fail (key_file != NULL, -1);
2747   g_return_val_if_fail (group_name != NULL, -1);
2748   g_return_val_if_fail (key != NULL, -1);
2749 
2750   key_file_error = NULL;
2751 
2752   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2753 
2754   if (key_file_error)
2755     {
2756       g_propagate_error (error, key_file_error);
2757       return 0;
2758     }
2759 
2760   int_value = g_key_file_parse_value_as_integer (key_file, value,
2761                          &amp;key_file_error);
2762   g_free (value);
2763 
2764   if (key_file_error)
2765     {
2766       if (g_error_matches (key_file_error,
2767                            G_KEY_FILE_ERROR,
2768                            G_KEY_FILE_ERROR_INVALID_VALUE))
2769         {
2770           g_set_error (error, G_KEY_FILE_ERROR,
2771                        G_KEY_FILE_ERROR_INVALID_VALUE,
2772                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
2773                          &quot;which has a value that cannot be interpreted.&quot;),
2774                          key, group_name);
2775           g_error_free (key_file_error);
2776         }
2777       else
2778         g_propagate_error (error, key_file_error);
2779     }
2780 
2781   return int_value;
2782 }
2783 
2784 /**
2785  * g_key_file_set_integer:
2786  * @key_file: a #GKeyFile
2787  * @group_name: a group name
2788  * @key: a key
2789  * @value: an integer value
2790  *
2791  * Associates a new integer value with @key under @group_name.
2792  * If @key cannot be found then it is created.
2793  *
2794  * Since: 2.6
2795  **/
2796 void
2797 g_key_file_set_integer (GKeyFile    *key_file,
2798             const gchar *group_name,
2799             const gchar *key,
2800             gint         value)
2801 {
2802   gchar *result;
2803 
2804   g_return_if_fail (key_file != NULL);
2805 
2806   result = g_key_file_parse_integer_as_value (key_file, value);
2807   g_key_file_set_value (key_file, group_name, key, result);
2808   g_free (result);
2809 }
2810 
2811 /**
2812  * g_key_file_get_int64:
2813  * @key_file: a non-%NULL #GKeyFile
2814  * @group_name: a non-%NULL group name
2815  * @key: a non-%NULL key
2816  * @error: return location for a #GError
2817  *
2818  * Returns the value associated with @key under @group_name as a signed
2819  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2820  * 64-bit results without truncation.
2821  *
2822  * Returns: the value associated with the key as a signed 64-bit integer, or
2823  * 0 if the key was not found or could not be parsed.
2824  *
2825  * Since: 2.26
2826  */
2827 gint64
2828 g_key_file_get_int64 (GKeyFile     *key_file,
2829                       const gchar  *group_name,
2830                       const gchar  *key,
2831                       GError      **error)
2832 {
2833   gchar *s, *end;
2834   gint64 v;
2835 
2836   g_return_val_if_fail (key_file != NULL, -1);
2837   g_return_val_if_fail (group_name != NULL, -1);
2838   g_return_val_if_fail (key != NULL, -1);
2839 
2840   s = g_key_file_get_value (key_file, group_name, key, error);
2841 
2842   if (s == NULL)
2843     return 0;
2844 
2845   v = g_ascii_strtoll (s, &amp;end, 10);
2846 
2847   if (*s == &#39;\0&#39; || *end != &#39;\0&#39;)
2848     {
2849       g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE,
2850                    _(&quot;Key &#39;%s&#39; in group &#39;%s&#39; has value &#39;%s&#39; &quot;
2851                      &quot;where %s was expected&quot;),
2852                    key, group_name, s, &quot;int64&quot;);
2853       g_free (s);
2854       return 0;
2855     }
2856 
2857   g_free (s);
2858   return v;
2859 }
2860 
2861 /**
2862  * g_key_file_set_int64:
2863  * @key_file: a #GKeyFile
2864  * @group_name: a group name
2865  * @key: a key
2866  * @value: an integer value
2867  *
2868  * Associates a new integer value with @key under @group_name.
2869  * If @key cannot be found then it is created.
2870  *
2871  * Since: 2.26
2872  **/
2873 void
2874 g_key_file_set_int64 (GKeyFile    *key_file,
2875                       const gchar *group_name,
2876                       const gchar *key,
2877                       gint64       value)
2878 {
2879   gchar *result;
2880 
2881   g_return_if_fail (key_file != NULL);
2882 
2883   result = g_strdup_printf (&quot;%&quot; G_GINT64_FORMAT, value);
2884   g_key_file_set_value (key_file, group_name, key, result);
2885   g_free (result);
2886 }
2887 
2888 /**
2889  * g_key_file_get_uint64:
2890  * @key_file: a non-%NULL #GKeyFile
2891  * @group_name: a non-%NULL group name
2892  * @key: a non-%NULL key
2893  * @error: return location for a #GError
2894  *
2895  * Returns the value associated with @key under @group_name as an unsigned
2896  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2897  * large positive results without truncation.
2898  *
2899  * Returns: the value associated with the key as an unsigned 64-bit integer,
2900  * or 0 if the key was not found or could not be parsed.
2901  *
2902  * Since: 2.26
2903  */
2904 guint64
2905 g_key_file_get_uint64 (GKeyFile     *key_file,
2906                        const gchar  *group_name,
2907                        const gchar  *key,
2908                        GError      **error)
2909 {
2910   gchar *s, *end;
2911   guint64 v;
2912 
2913   g_return_val_if_fail (key_file != NULL, -1);
2914   g_return_val_if_fail (group_name != NULL, -1);
2915   g_return_val_if_fail (key != NULL, -1);
2916 
2917   s = g_key_file_get_value (key_file, group_name, key, error);
2918 
2919   if (s == NULL)
2920     return 0;
2921 
2922   v = g_ascii_strtoull (s, &amp;end, 10);
2923 
2924   if (*s == &#39;\0&#39; || *end != &#39;\0&#39;)
2925     {
2926       g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE,
2927                    _(&quot;Key &#39;%s&#39; in group &#39;%s&#39; has value &#39;%s&#39; &quot;
2928                      &quot;where %s was expected&quot;),
2929                    key, group_name, s, &quot;uint64&quot;);
2930       g_free (s);
2931       return 0;
2932     }
2933 
2934   g_free (s);
2935   return v;
2936 }
2937 
2938 /**
2939  * g_key_file_set_uint64:
2940  * @key_file: a #GKeyFile
2941  * @group_name: a group name
2942  * @key: a key
2943  * @value: an integer value
2944  *
2945  * Associates a new integer value with @key under @group_name.
2946  * If @key cannot be found then it is created.
2947  *
2948  * Since: 2.26
2949  **/
2950 void
2951 g_key_file_set_uint64 (GKeyFile    *key_file,
2952                        const gchar *group_name,
2953                        const gchar *key,
2954                        guint64      value)
2955 {
2956   gchar *result;
2957 
2958   g_return_if_fail (key_file != NULL);
2959 
2960   result = g_strdup_printf (&quot;%&quot; G_GUINT64_FORMAT, value);
2961   g_key_file_set_value (key_file, group_name, key, result);
2962   g_free (result);
2963 }
2964 
2965 /**
2966  * g_key_file_get_integer_list:
2967  * @key_file: a #GKeyFile
2968  * @group_name: a group name
2969  * @key: a key
2970  * @length: (out): the number of integers returned
2971  * @error: return location for a #GError
2972  *
2973  * Returns the values associated with @key under @group_name as
2974  * integers.
2975  *
2976  * If @key cannot be found then %NULL is returned and @error is set to
2977  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2978  * with @key cannot be interpreted as integers, or are out of range for
2979  * #gint, then %NULL is returned
2980  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2981  *
2982  * Returns: (array length=length) (element-type gint) (transfer container):
2983  *     the values associated with the key as a list of integers, or %NULL if
2984  *     the key was not found or could not be parsed. The returned list of
2985  *     integers should be freed with g_free() when no longer needed.
2986  *
2987  * Since: 2.6
2988  **/
2989 gint *
2990 g_key_file_get_integer_list (GKeyFile     *key_file,
2991                  const gchar  *group_name,
2992                  const gchar  *key,
2993                  gsize        *length,
2994                  GError      **error)
2995 {
2996   GError *key_file_error = NULL;
2997   gchar **values;
2998   gint *int_values;
2999   gsize i, num_ints;
3000 
3001   g_return_val_if_fail (key_file != NULL, NULL);
3002   g_return_val_if_fail (group_name != NULL, NULL);
3003   g_return_val_if_fail (key != NULL, NULL);
3004 
3005   if (length)
3006     *length = 0;
3007 
3008   values = g_key_file_get_string_list (key_file, group_name, key,
3009                        &amp;num_ints, &amp;key_file_error);
3010 
3011   if (key_file_error)
3012     g_propagate_error (error, key_file_error);
3013 
3014   if (!values)
3015     return NULL;
3016 
3017   int_values = g_new (gint, num_ints);
3018 
3019   for (i = 0; i &lt; num_ints; i++)
3020     {
3021       int_values[i] = g_key_file_parse_value_as_integer (key_file,
3022                              values[i],
3023                              &amp;key_file_error);
3024 
3025       if (key_file_error)
3026         {
3027           g_propagate_error (error, key_file_error);
3028           g_strfreev (values);
3029           g_free (int_values);
3030 
3031           return NULL;
3032         }
3033     }
3034   g_strfreev (values);
3035 
3036   if (length)
3037     *length = num_ints;
3038 
3039   return int_values;
3040 }
3041 
3042 /**
3043  * g_key_file_set_integer_list:
3044  * @key_file: a #GKeyFile
3045  * @group_name: a group name
3046  * @key: a key
3047  * @list: (array length=length): an array of integer values
3048  * @length: number of integer values in @list
3049  *
3050  * Associates a list of integer values with @key under @group_name.
3051  * If @key cannot be found then it is created.
3052  *
3053  * Since: 2.6
3054  **/
3055 void
3056 g_key_file_set_integer_list (GKeyFile    *key_file,
3057                  const gchar *group_name,
3058                  const gchar *key,
3059                  gint         list[],
3060                  gsize        length)
3061 {
3062   GString *values;
3063   gsize i;
3064 
3065   g_return_if_fail (key_file != NULL);
3066   g_return_if_fail (list != NULL);
3067 
3068   values = g_string_sized_new (length * 16);
3069 #ifdef GSTREAMER_LITE
3070   if (values == NULL) {
3071     return;
3072   }
3073 #endif // GSTREAMER_LITE
3074   for (i = 0; i &lt; length; i++)
3075     {
3076       gchar *value;
3077 
3078       value = g_key_file_parse_integer_as_value (key_file, list[i]);
3079 
3080       g_string_append (values, value);
3081       g_string_append_c (values, key_file-&gt;list_separator);
3082 
3083       g_free (value);
3084     }
3085 
3086   g_key_file_set_value (key_file, group_name, key, values-&gt;str);
3087   g_string_free (values, TRUE);
3088 }
3089 
3090 /**
3091  * g_key_file_get_double:
3092  * @key_file: a #GKeyFile
3093  * @group_name: a group name
3094  * @key: a key
3095  * @error: return location for a #GError
3096  *
3097  * Returns the value associated with @key under @group_name as a
3098  * double. If @group_name is %NULL, the start_group is used.
3099  *
3100  * If @key cannot be found then 0.0 is returned and @error is set to
3101  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
3102  * with @key cannot be interpreted as a double then 0.0 is returned
3103  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
3104  *
3105  * Returns: the value associated with the key as a double, or
3106  *     0.0 if the key was not found or could not be parsed.
3107  *
3108  * Since: 2.12
3109  **/
3110 gdouble
3111 g_key_file_get_double  (GKeyFile     *key_file,
3112                         const gchar  *group_name,
3113                         const gchar  *key,
3114                         GError      **error)
3115 {
3116   GError *key_file_error;
3117   gchar *value;
3118   gdouble double_value;
3119 
3120   g_return_val_if_fail (key_file != NULL, -1);
3121   g_return_val_if_fail (group_name != NULL, -1);
3122   g_return_val_if_fail (key != NULL, -1);
3123 
3124   key_file_error = NULL;
3125 
3126   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
3127 
3128   if (key_file_error)
3129     {
3130       g_propagate_error (error, key_file_error);
3131       return 0;
3132     }
3133 
3134   double_value = g_key_file_parse_value_as_double (key_file, value,
3135                                                   &amp;key_file_error);
3136   g_free (value);
3137 
3138   if (key_file_error)
3139     {
3140       if (g_error_matches (key_file_error,
3141                            G_KEY_FILE_ERROR,
3142                            G_KEY_FILE_ERROR_INVALID_VALUE))
3143         {
3144           g_set_error (error, G_KEY_FILE_ERROR,
3145                        G_KEY_FILE_ERROR_INVALID_VALUE,
3146                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
3147                          &quot;which has a value that cannot be interpreted.&quot;),
3148                        key, group_name);
3149           g_error_free (key_file_error);
3150         }
3151       else
3152         g_propagate_error (error, key_file_error);
3153     }
3154 
3155   return double_value;
3156 }
3157 
3158 /**
3159  * g_key_file_set_double:
3160  * @key_file: a #GKeyFile
3161  * @group_name: a group name
3162  * @key: a key
3163  * @value: an double value
3164  *
3165  * Associates a new double value with @key under @group_name.
3166  * If @key cannot be found then it is created.
3167  *
3168  * Since: 2.12
3169  **/
3170 void
3171 g_key_file_set_double  (GKeyFile    *key_file,
3172                         const gchar *group_name,
3173                         const gchar *key,
3174                         gdouble      value)
3175 {
3176   gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3177 
3178   g_return_if_fail (key_file != NULL);
3179 
3180   g_ascii_dtostr (result, sizeof (result), value);
3181   g_key_file_set_value (key_file, group_name, key, result);
3182 }
3183 
3184 /**
3185  * g_key_file_get_double_list:
3186  * @key_file: a #GKeyFile
3187  * @group_name: a group name
3188  * @key: a key
3189  * @length: (out): the number of doubles returned
3190  * @error: return location for a #GError
3191  *
3192  * Returns the values associated with @key under @group_name as
3193  * doubles.
3194  *
3195  * If @key cannot be found then %NULL is returned and @error is set to
3196  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
3197  * with @key cannot be interpreted as doubles then %NULL is returned
3198  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
3199  *
3200  * Returns: (array length=length) (element-type gdouble) (transfer container):
3201  *     the values associated with the key as a list of doubles, or %NULL if the
3202  *     key was not found or could not be parsed. The returned list of doubles
3203  *     should be freed with g_free() when no longer needed.
3204  *
3205  * Since: 2.12
3206  **/
3207 gdouble *
3208 g_key_file_get_double_list  (GKeyFile     *key_file,
3209                              const gchar  *group_name,
3210                              const gchar  *key,
3211                              gsize        *length,
3212                              GError      **error)
3213 {
3214   GError *key_file_error = NULL;
3215   gchar **values;
3216   gdouble *double_values;
3217   gsize i, num_doubles;
3218 
3219   g_return_val_if_fail (key_file != NULL, NULL);
3220   g_return_val_if_fail (group_name != NULL, NULL);
3221   g_return_val_if_fail (key != NULL, NULL);
3222 
3223   if (length)
3224     *length = 0;
3225 
3226   values = g_key_file_get_string_list (key_file, group_name, key,
3227                                        &amp;num_doubles, &amp;key_file_error);
3228 
3229   if (key_file_error)
3230     g_propagate_error (error, key_file_error);
3231 
3232   if (!values)
3233     return NULL;
3234 
3235   double_values = g_new (gdouble, num_doubles);
3236 
3237   for (i = 0; i &lt; num_doubles; i++)
3238     {
3239       double_values[i] = g_key_file_parse_value_as_double (key_file,
3240                                values[i],
3241                                &amp;key_file_error);
3242 
3243       if (key_file_error)
3244         {
3245           g_propagate_error (error, key_file_error);
3246           g_strfreev (values);
3247           g_free (double_values);
3248 
3249           return NULL;
3250         }
3251     }
3252   g_strfreev (values);
3253 
3254   if (length)
3255     *length = num_doubles;
3256 
3257   return double_values;
3258 }
3259 
3260 /**
3261  * g_key_file_set_double_list:
3262  * @key_file: a #GKeyFile
3263  * @group_name: a group name
3264  * @key: a key
3265  * @list: (array length=length): an array of double values
3266  * @length: number of double values in @list
3267  *
3268  * Associates a list of double values with @key under
3269  * @group_name.  If @key cannot be found then it is created.
3270  *
3271  * Since: 2.12
3272  **/
3273 void
3274 g_key_file_set_double_list (GKeyFile    *key_file,
3275                 const gchar *group_name,
3276                 const gchar *key,
3277                 gdouble      list[],
3278                 gsize        length)
3279 {
3280   GString *values;
3281   gsize i;
3282 
3283   g_return_if_fail (key_file != NULL);
3284   g_return_if_fail (list != NULL);
3285 
3286   values = g_string_sized_new (length * 16);
3287 #ifdef GSTREAMER_LITE
3288   if (values == NULL) {
3289     return;
3290   }
3291 #endif // GSTREAMER_LITE
3292   for (i = 0; i &lt; length; i++)
3293     {
3294       gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3295 
3296       g_ascii_dtostr( result, sizeof (result), list[i] );
3297 
3298       g_string_append (values, result);
3299       g_string_append_c (values, key_file-&gt;list_separator);
3300     }
3301 
3302   g_key_file_set_value (key_file, group_name, key, values-&gt;str);
3303   g_string_free (values, TRUE);
3304 }
3305 
3306 static gboolean
3307 g_key_file_set_key_comment (GKeyFile     *key_file,
3308                             const gchar  *group_name,
3309                             const gchar  *key,
3310                             const gchar  *comment,
3311                             GError      **error)
3312 {
3313   GKeyFileGroup *group;
3314   GKeyFileKeyValuePair *pair;
3315   GList *key_node, *comment_node, *tmp;
3316 
3317   group = g_key_file_lookup_group (key_file, group_name);
3318   if (!group)
3319     {
3320       g_set_error (error, G_KEY_FILE_ERROR,
3321                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3322                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3323                    group_name ? group_name : &quot;(null)&quot;);
3324 
3325       return FALSE;
3326     }
3327 
3328   /* First find the key the comments are supposed to be
3329    * associated with
3330    */
3331   key_node = g_key_file_lookup_key_value_pair_node (key_file, group, key);
3332 
3333   if (key_node == NULL)
3334     {
3335       set_not_found_key_error (group-&gt;name, key, error);
3336       return FALSE;
3337     }
3338 
3339   /* Then find all the comments already associated with the
3340    * key and free them
3341    */
3342   tmp = key_node-&gt;next;
3343   while (tmp != NULL)
3344     {
3345       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3346 
3347       if (pair-&gt;key != NULL)
3348         break;
3349 
3350       comment_node = tmp;
3351       tmp = tmp-&gt;next;
3352       g_key_file_remove_key_value_pair_node (key_file, group,
3353                                              comment_node);
3354     }
3355 
3356   if (comment == NULL)
3357     return TRUE;
3358 
3359   /* Now we can add our new comment
3360    */
3361   pair = g_slice_new (GKeyFileKeyValuePair);
3362 #ifdef GSTREAMER_LITE
3363   if (pair == NULL) {
3364     return FALSE;
3365   }
3366 #endif // GSTREAMER_LITE
3367   pair-&gt;key = NULL;
3368   pair-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3369 
3370   key_node = g_list_insert (key_node, pair, 1);
3371 
3372   return TRUE;
3373 }
3374 
3375 static gboolean
3376 g_key_file_set_group_comment (GKeyFile     *key_file,
3377                               const gchar  *group_name,
3378                               const gchar  *comment,
3379                               GError      **error)
3380 {
3381   GKeyFileGroup *group;
3382 
3383   g_return_val_if_fail (g_key_file_is_group_name (group_name), FALSE);
3384 
3385   group = g_key_file_lookup_group (key_file, group_name);
3386   if (!group)
3387     {
3388       g_set_error (error, G_KEY_FILE_ERROR,
3389                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3390                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3391                    group_name ? group_name : &quot;(null)&quot;);
3392 
3393       return FALSE;
3394     }
3395 
3396   /* First remove any existing comment
3397    */
3398   if (group-&gt;comment)
3399     {
3400       g_key_file_key_value_pair_free (group-&gt;comment);
3401       group-&gt;comment = NULL;
3402     }
3403 
3404   if (comment == NULL)
3405     return TRUE;
3406 
3407   /* Now we can add our new comment
3408    */
3409   group-&gt;comment = g_slice_new (GKeyFileKeyValuePair);
3410 #ifdef GSTREAMER_LITE
3411   if (group-&gt;comment == NULL) {
3412     return FALSE;
3413   }
3414 #endif // GSTREAMER_LITE
3415   group-&gt;comment-&gt;key = NULL;
3416   group-&gt;comment-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3417 
3418   return TRUE;
3419 }
3420 
3421 static gboolean
3422 g_key_file_set_top_comment (GKeyFile     *key_file,
3423                             const gchar  *comment,
3424                             GError      **error)
3425 {
3426   GList *group_node;
3427   GKeyFileGroup *group;
3428   GKeyFileKeyValuePair *pair;
3429 
3430   /* The last group in the list should be the top (comments only)
3431    * group in the file
3432    */
3433   g_warn_if_fail (key_file-&gt;groups != NULL);
3434   group_node = g_list_last (key_file-&gt;groups);
3435   group = (GKeyFileGroup *) group_node-&gt;data;
3436   g_warn_if_fail (group-&gt;name == NULL);
3437 
3438   /* Note all keys must be comments at the top of
3439    * the file, so we can just free it all.
3440    */
3441   g_list_free_full (group-&gt;key_value_pairs, (GDestroyNotify) g_key_file_key_value_pair_free);
3442   group-&gt;key_value_pairs = NULL;
3443 
3444   if (comment == NULL)
3445      return TRUE;
3446 
3447   pair = g_slice_new (GKeyFileKeyValuePair);
3448 #ifdef GSTREAMER_LITE
3449   if (pair == NULL) {
3450     return FALSE;
3451   }
3452 #endif // GSTREAMER_LITE
3453   pair-&gt;key = NULL;
3454   pair-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3455 
3456   group-&gt;key_value_pairs =
3457     g_list_prepend (group-&gt;key_value_pairs, pair);
3458 
3459   return TRUE;
3460 }
3461 
3462 /**
3463  * g_key_file_set_comment:
3464  * @key_file: a #GKeyFile
3465  * @group_name: (nullable): a group name, or %NULL
3466  * @key: (nullable): a key
3467  * @comment: a comment
3468  * @error: return location for a #GError
3469  *
3470  * Places a comment above @key from @group_name.
3471  *
3472  * If @key is %NULL then @comment will be written above @group_name.
3473  * If both @key and @group_name  are %NULL, then @comment will be
3474  * written above the first group in the file.
3475  *
3476  * Note that this function prepends a &#39;#&#39; comment marker to
3477  * each line of @comment.
3478  *
3479  * Returns: %TRUE if the comment was written, %FALSE otherwise
3480  *
3481  * Since: 2.6
3482  **/
3483 gboolean
3484 g_key_file_set_comment (GKeyFile     *key_file,
3485                         const gchar  *group_name,
3486                         const gchar  *key,
3487                         const gchar  *comment,
3488                         GError      **error)
3489 {
3490   g_return_val_if_fail (key_file != NULL, FALSE);
3491 
3492   if (group_name != NULL &amp;&amp; key != NULL)
3493     {
3494       if (!g_key_file_set_key_comment (key_file, group_name, key, comment, error))
3495         return FALSE;
3496     }
3497   else if (group_name != NULL)
3498     {
3499       if (!g_key_file_set_group_comment (key_file, group_name, comment, error))
3500         return FALSE;
3501     }
3502   else
3503     {
3504       if (!g_key_file_set_top_comment (key_file, comment, error))
3505         return FALSE;
3506     }
3507 
3508   return TRUE;
3509 }
3510 
3511 static gchar *
3512 g_key_file_get_key_comment (GKeyFile     *key_file,
3513                             const gchar  *group_name,
3514                             const gchar  *key,
3515                             GError      **error)
3516 {
3517   GKeyFileGroup *group;
3518   GKeyFileKeyValuePair *pair;
3519   GList *key_node, *tmp;
3520   GString *string;
3521   gchar *comment;
3522 
3523   g_return_val_if_fail (g_key_file_is_group_name (group_name), NULL);
3524 
3525   group = g_key_file_lookup_group (key_file, group_name);
3526   if (!group)
3527     {
3528       g_set_error (error, G_KEY_FILE_ERROR,
3529                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3530                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3531                    group_name ? group_name : &quot;(null)&quot;);
3532 
3533       return NULL;
3534     }
3535 
3536   /* First find the key the comments are supposed to be
3537    * associated with
3538    */
3539   key_node = g_key_file_lookup_key_value_pair_node (key_file, group, key);
3540 
3541   if (key_node == NULL)
3542     {
3543       set_not_found_key_error (group-&gt;name, key, error);
3544       return NULL;
3545     }
3546 
3547   string = NULL;
3548 
3549   /* Then find all the comments already associated with the
3550    * key and concatentate them.
3551    */
3552   tmp = key_node-&gt;next;
3553   if (!key_node-&gt;next)
3554     return NULL;
3555 
3556   pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3557   if (pair-&gt;key != NULL)
3558     return NULL;
3559 
3560   while (tmp-&gt;next)
3561     {
3562       pair = (GKeyFileKeyValuePair *) tmp-&gt;next-&gt;data;
3563 
3564       if (pair-&gt;key != NULL)
3565         break;
3566 
3567       tmp = tmp-&gt;next;
3568     }
3569 
3570   while (tmp != key_node)
3571     {
3572       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3573 
3574       if (string == NULL)
3575     string = g_string_sized_new (512);
3576 
3577       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value);
3578       g_string_append (string, comment);
3579       g_free (comment);
3580 
3581       tmp = tmp-&gt;prev;
3582     }
3583 
3584   if (string != NULL)
3585     {
3586       comment = string-&gt;str;
3587       g_string_free (string, FALSE);
3588     }
3589   else
3590     comment = NULL;
3591 
3592   return comment;
3593 }
3594 
3595 static gchar *
3596 get_group_comment (GKeyFile       *key_file,
3597            GKeyFileGroup  *group,
3598            GError        **error)
3599 {
3600   GString *string;
3601   GList *tmp;
3602   gchar *comment;
3603 
3604   string = NULL;
3605 
3606   tmp = group-&gt;key_value_pairs;
3607   while (tmp)
3608     {
3609       GKeyFileKeyValuePair *pair;
3610 
3611       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3612 
3613       if (pair-&gt;key != NULL)
3614     {
3615       tmp = tmp-&gt;prev;
3616       break;
3617     }
3618 
3619       if (tmp-&gt;next == NULL)
3620     break;
3621 
3622       tmp = tmp-&gt;next;
3623     }
3624 
3625   while (tmp != NULL)
3626     {
3627       GKeyFileKeyValuePair *pair;
3628 
3629       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3630 
3631       if (string == NULL)
3632         string = g_string_sized_new (512);
3633 
3634       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value);
3635       g_string_append (string, comment);
3636       g_free (comment);
3637 
3638       tmp = tmp-&gt;prev;
3639     }
3640 
3641   if (string != NULL)
3642     return g_string_free (string, FALSE);
3643 
3644   return NULL;
3645 }
3646 
3647 static gchar *
3648 g_key_file_get_group_comment (GKeyFile     *key_file,
3649                               const gchar  *group_name,
3650                               GError      **error)
3651 {
3652   GList *group_node;
3653   GKeyFileGroup *group;
3654 
3655   group = g_key_file_lookup_group (key_file, group_name);
3656   if (!group)
3657     {
3658       g_set_error (error, G_KEY_FILE_ERROR,
3659                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3660                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3661                    group_name ? group_name : &quot;(null)&quot;);
3662 
3663       return NULL;
3664     }
3665 
3666   if (group-&gt;comment)
3667     return g_strdup (group-&gt;comment-&gt;value);
3668 
3669   group_node = g_key_file_lookup_group_node (key_file, group_name);
3670   group_node = group_node-&gt;next;
3671   group = (GKeyFileGroup *)group_node-&gt;data;
3672   return get_group_comment (key_file, group, error);
3673 }
3674 
3675 static gchar *
3676 g_key_file_get_top_comment (GKeyFile  *key_file,
3677                             GError   **error)
3678 {
3679   GList *group_node;
3680   GKeyFileGroup *group;
3681 
3682   /* The last group in the list should be the top (comments only)
3683    * group in the file
3684    */
3685   g_warn_if_fail (key_file-&gt;groups != NULL);
3686   group_node = g_list_last (key_file-&gt;groups);
3687   group = (GKeyFileGroup *) group_node-&gt;data;
3688   g_warn_if_fail (group-&gt;name == NULL);
3689 
3690   return get_group_comment (key_file, group, error);
3691 }
3692 
3693 /**
3694  * g_key_file_get_comment:
3695  * @key_file: a #GKeyFile
3696  * @group_name: (nullable): a group name, or %NULL
3697  * @key: a key
3698  * @error: return location for a #GError
3699  *
3700  * Retrieves a comment above @key from @group_name.
3701  * If @key is %NULL then @comment will be read from above
3702  * @group_name. If both @key and @group_name are %NULL, then
3703  * @comment will be read from above the first group in the file.
3704  *
3705  * Note that the returned string includes the &#39;#&#39; comment markers.
3706  *
3707  * Returns: a comment that should be freed with g_free()
3708  *
3709  * Since: 2.6
3710  **/
3711 gchar *
3712 g_key_file_get_comment (GKeyFile     *key_file,
3713                         const gchar  *group_name,
3714                         const gchar  *key,
3715                         GError      **error)
3716 {
3717   g_return_val_if_fail (key_file != NULL, NULL);
3718 
3719   if (group_name != NULL &amp;&amp; key != NULL)
3720     return g_key_file_get_key_comment (key_file, group_name, key, error);
3721   else if (group_name != NULL)
3722     return g_key_file_get_group_comment (key_file, group_name, error);
3723   else
3724     return g_key_file_get_top_comment (key_file, error);
3725 }
3726 
3727 /**
3728  * g_key_file_remove_comment:
3729  * @key_file: a #GKeyFile
3730  * @group_name: (nullable): a group name, or %NULL
3731  * @key: (nullable): a key
3732  * @error: return location for a #GError
3733  *
3734  * Removes a comment above @key from @group_name.
3735  * If @key is %NULL then @comment will be removed above @group_name.
3736  * If both @key and @group_name are %NULL, then @comment will
3737  * be removed above the first group in the file.
3738  *
3739  * Returns: %TRUE if the comment was removed, %FALSE otherwise
3740  *
3741  * Since: 2.6
3742  **/
3743 
3744 gboolean
3745 g_key_file_remove_comment (GKeyFile     *key_file,
3746                            const gchar  *group_name,
3747                            const gchar  *key,
3748                            GError      **error)
3749 {
3750   g_return_val_if_fail (key_file != NULL, FALSE);
3751 
3752   if (group_name != NULL &amp;&amp; key != NULL)
3753     return g_key_file_set_key_comment (key_file, group_name, key, NULL, error);
3754   else if (group_name != NULL)
3755     return g_key_file_set_group_comment (key_file, group_name, NULL, error);
3756   else
3757     return g_key_file_set_top_comment (key_file, NULL, error);
3758 }
3759 
3760 /**
3761  * g_key_file_has_group:
3762  * @key_file: a #GKeyFile
3763  * @group_name: a group name
3764  *
3765  * Looks whether the key file has the group @group_name.
3766  *
3767  * Returns: %TRUE if @group_name is a part of @key_file, %FALSE
3768  * otherwise.
3769  * Since: 2.6
3770  **/
3771 gboolean
3772 g_key_file_has_group (GKeyFile    *key_file,
3773               const gchar *group_name)
3774 {
3775   g_return_val_if_fail (key_file != NULL, FALSE);
3776   g_return_val_if_fail (group_name != NULL, FALSE);
3777 
3778   return g_key_file_lookup_group (key_file, group_name) != NULL;
3779 }
3780 
3781 /* This code remains from a historical attempt to add a new public API
3782  * which respects the GError rules.
3783  */
3784 static gboolean
3785 g_key_file_has_key_full (GKeyFile     *key_file,
3786              const gchar  *group_name,
3787              const gchar  *key,
3788              gboolean     *has_key,
3789              GError      **error)
3790 {
3791   GKeyFileKeyValuePair *pair;
3792   GKeyFileGroup *group;
3793 
3794   g_return_val_if_fail (key_file != NULL, FALSE);
3795   g_return_val_if_fail (group_name != NULL, FALSE);
3796   g_return_val_if_fail (key != NULL, FALSE);
3797 
3798   group = g_key_file_lookup_group (key_file, group_name);
3799 
3800   if (!group)
3801     {
3802       g_set_error (error, G_KEY_FILE_ERROR,
3803                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3804                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3805 #ifdef GSTREAMER_LITE
3806                    group_name ? group_name : &quot;(null)&quot;);
3807 #else // GSTREAMER_LITE
3808                    group_name);
3809 #endif // GSTREAMER_LITE
3810 
3811       return FALSE;
3812     }
3813 
3814   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
3815 
3816   if (has_key)
3817     *has_key = pair != NULL;
3818   return TRUE;
3819 }
3820 
3821 /**
3822  * g_key_file_has_key: (skip)
3823  * @key_file: a #GKeyFile
3824  * @group_name: a group name
3825  * @key: a key name
3826  * @error: return location for a #GError
3827  *
3828  * Looks whether the key file has the key @key in the group
3829  * @group_name.
3830  *
3831  * Note that this function does not follow the rules for #GError strictly;
3832  * the return value both carries meaning and signals an error.  To use
3833  * this function, you must pass a #GError pointer in @error, and check
3834  * whether it is not %NULL to see if an error occurred.
3835  *
3836  * Language bindings should use g_key_file_get_value() to test whether
3837  * or not a key exists.
3838  *
3839  * Returns: %TRUE if @key is a part of @group_name, %FALSE otherwise
3840  *
3841  * Since: 2.6
3842  **/
3843 gboolean
3844 g_key_file_has_key (GKeyFile     *key_file,
3845             const gchar  *group_name,
3846             const gchar  *key,
3847             GError      **error)
3848 {
3849   GError *temp_error = NULL;
3850   gboolean has_key;
3851 
3852   if (g_key_file_has_key_full (key_file, group_name, key, &amp;has_key, &amp;temp_error))
3853     {
3854       return has_key;
3855     }
3856   else
3857     {
3858       g_propagate_error (error, temp_error);
3859       return FALSE;
3860     }
3861 }
3862 
3863 static void
3864 g_key_file_add_group (GKeyFile    *key_file,
3865               const gchar *group_name)
3866 {
3867   GKeyFileGroup *group;
3868 
3869   g_return_if_fail (key_file != NULL);
3870   g_return_if_fail (g_key_file_is_group_name (group_name));
3871 
3872   group = g_key_file_lookup_group (key_file, group_name);
3873   if (group != NULL)
3874     {
3875       key_file-&gt;current_group = group;
3876       return;
3877     }
3878 
3879   group = g_slice_new0 (GKeyFileGroup);
3880   group-&gt;name = g_strdup (group_name);
3881   group-&gt;lookup_map = g_hash_table_new (g_str_hash, g_str_equal);
3882   key_file-&gt;groups = g_list_prepend (key_file-&gt;groups, group);
3883   key_file-&gt;current_group = group;
3884 
3885   if (key_file-&gt;start_group == NULL)
3886     key_file-&gt;start_group = group;
3887 
3888   g_hash_table_insert (key_file-&gt;group_hash, (gpointer)group-&gt;name, group);
3889 }
3890 
3891 static void
3892 g_key_file_key_value_pair_free (GKeyFileKeyValuePair *pair)
3893 {
3894   if (pair != NULL)
3895     {
3896       g_free (pair-&gt;key);
3897       g_free (pair-&gt;value);
3898       g_slice_free (GKeyFileKeyValuePair, pair);
3899     }
3900 }
3901 
3902 /* Be careful not to call this function on a node with data in the
3903  * lookup map without removing it from the lookup map, first.
3904  *
3905  * Some current cases where this warning is not a concern are
3906  * when:
3907  *   - the node being removed is a comment node
3908  *   - the entire lookup map is getting destroyed soon after
3909  *     anyway.
3910  */
3911 static void
3912 g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
3913                                        GKeyFileGroup *group,
3914                            GList         *pair_node)
3915 {
3916 
3917   GKeyFileKeyValuePair *pair;
3918 
3919   pair = (GKeyFileKeyValuePair *) pair_node-&gt;data;
3920 
3921   group-&gt;key_value_pairs = g_list_remove_link (group-&gt;key_value_pairs, pair_node);
3922 
3923   g_warn_if_fail (pair-&gt;value != NULL);
3924 
3925   g_key_file_key_value_pair_free (pair);
3926 
3927   g_list_free_1 (pair_node);
3928 }
3929 
3930 static void
3931 g_key_file_remove_group_node (GKeyFile *key_file,
3932                   GList    *group_node)
3933 {
3934   GKeyFileGroup *group;
3935   GList *tmp;
3936 
3937   group = (GKeyFileGroup *) group_node-&gt;data;
3938 
3939   if (group-&gt;name)
3940     g_hash_table_remove (key_file-&gt;group_hash, group-&gt;name);
3941 
3942   /* If the current group gets deleted make the current group the last
3943    * added group.
3944    */
3945   if (key_file-&gt;current_group == group)
3946     {
3947       /* groups should always contain at least the top comment group,
3948        * unless g_key_file_clear has been called
3949        */
3950       if (key_file-&gt;groups)
3951         key_file-&gt;current_group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
3952       else
3953         key_file-&gt;current_group = NULL;
3954     }
3955 
3956   /* If the start group gets deleted make the start group the first
3957    * added group.
3958    */
3959   if (key_file-&gt;start_group == group)
3960     {
3961       tmp = g_list_last (key_file-&gt;groups);
3962       while (tmp != NULL)
3963     {
3964       if (tmp != group_node &amp;&amp;
3965           ((GKeyFileGroup *) tmp-&gt;data)-&gt;name != NULL)
3966         break;
3967 
3968       tmp = tmp-&gt;prev;
3969     }
3970 
3971       if (tmp)
3972         key_file-&gt;start_group = (GKeyFileGroup *) tmp-&gt;data;
3973       else
3974         key_file-&gt;start_group = NULL;
3975     }
3976 
3977   key_file-&gt;groups = g_list_remove_link (key_file-&gt;groups, group_node);
3978 
3979   tmp = group-&gt;key_value_pairs;
3980   while (tmp != NULL)
3981     {
3982       GList *pair_node;
3983 
3984       pair_node = tmp;
3985       tmp = tmp-&gt;next;
3986       g_key_file_remove_key_value_pair_node (key_file, group, pair_node);
3987     }
3988 
3989   g_warn_if_fail (group-&gt;key_value_pairs == NULL);
3990 
3991   if (group-&gt;comment)
3992     {
3993       g_key_file_key_value_pair_free (group-&gt;comment);
3994       group-&gt;comment = NULL;
3995     }
3996 
3997   if (group-&gt;lookup_map)
3998     {
3999       g_hash_table_destroy (group-&gt;lookup_map);
4000       group-&gt;lookup_map = NULL;
4001     }
4002 
4003   g_free ((gchar *) group-&gt;name);
4004   g_slice_free (GKeyFileGroup, group);
4005   g_list_free_1 (group_node);
4006 }
4007 
4008 /**
4009  * g_key_file_remove_group:
4010  * @key_file: a #GKeyFile
4011  * @group_name: a group name
4012  * @error: return location for a #GError or %NULL
4013  *
4014  * Removes the specified group, @group_name,
4015  * from the key file.
4016  *
4017  * Returns: %TRUE if the group was removed, %FALSE otherwise
4018  *
4019  * Since: 2.6
4020  **/
4021 gboolean
4022 g_key_file_remove_group (GKeyFile     *key_file,
4023              const gchar  *group_name,
4024              GError      **error)
4025 {
4026   GList *group_node;
4027 
4028   g_return_val_if_fail (key_file != NULL, FALSE);
4029   g_return_val_if_fail (group_name != NULL, FALSE);
4030 
4031   group_node = g_key_file_lookup_group_node (key_file, group_name);
4032 
4033   if (!group_node)
4034     {
4035       g_set_error (error, G_KEY_FILE_ERROR,
4036                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
4037                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
4038                    group_name);
4039       return FALSE;
4040     }
4041 
4042   g_key_file_remove_group_node (key_file, group_node);
4043 
4044   return TRUE;
4045 }
4046 
4047 static void
4048 g_key_file_add_key_value_pair (GKeyFile             *key_file,
4049                                GKeyFileGroup        *group,
4050                                GKeyFileKeyValuePair *pair)
4051 {
4052   g_hash_table_replace (group-&gt;lookup_map, pair-&gt;key, pair);
4053   group-&gt;key_value_pairs = g_list_prepend (group-&gt;key_value_pairs, pair);
4054 }
4055 
4056 static void
4057 g_key_file_add_key (GKeyFile      *key_file,
4058             GKeyFileGroup *group,
4059             const gchar   *key,
4060             const gchar   *value)
4061 {
4062   GKeyFileKeyValuePair *pair;
4063 
4064   pair = g_slice_new (GKeyFileKeyValuePair);
4065 #ifdef GSTREAMER_LITE
4066   if (pair == NULL) {
4067     return;
4068   }
4069 #endif // GSTREAMER_LITE
4070   pair-&gt;key = g_strdup (key);
4071   pair-&gt;value = g_strdup (value);
4072 
4073   g_key_file_add_key_value_pair (key_file, group, pair);
4074 }
4075 
4076 /**
4077  * g_key_file_remove_key:
4078  * @key_file: a #GKeyFile
4079  * @group_name: a group name
4080  * @key: a key name to remove
4081  * @error: return location for a #GError or %NULL
4082  *
4083  * Removes @key in @group_name from the key file.
4084  *
4085  * Returns: %TRUE if the key was removed, %FALSE otherwise
4086  *
4087  * Since: 2.6
4088  **/
4089 gboolean
4090 g_key_file_remove_key (GKeyFile     *key_file,
4091                const gchar  *group_name,
4092                const gchar  *key,
4093                GError      **error)
4094 {
4095   GKeyFileGroup *group;
4096   GKeyFileKeyValuePair *pair;
4097 
4098   g_return_val_if_fail (key_file != NULL, FALSE);
4099   g_return_val_if_fail (group_name != NULL, FALSE);
4100   g_return_val_if_fail (key != NULL, FALSE);
4101 
4102   pair = NULL;
4103 
4104   group = g_key_file_lookup_group (key_file, group_name);
4105   if (!group)
4106     {
4107       g_set_error (error, G_KEY_FILE_ERROR,
4108                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
4109                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
4110 #ifdef GSTREAMER_LITE
4111                    group_name ? group_name : &quot;(null)&quot;);
4112 #else // GSTREAMER_LITE
4113                    group_name);
4114 #endif // GSTREAMER_LITE
4115       return FALSE;
4116     }
4117 
4118   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
4119 
4120   if (!pair)
4121     {
4122       set_not_found_key_error (group-&gt;name, key, error);
4123       return FALSE;
4124     }
4125 
4126   group-&gt;key_value_pairs = g_list_remove (group-&gt;key_value_pairs, pair);
4127   g_hash_table_remove (group-&gt;lookup_map, pair-&gt;key);
4128   g_key_file_key_value_pair_free (pair);
4129 
4130   return TRUE;
4131 }
4132 
4133 static GList *
4134 g_key_file_lookup_group_node (GKeyFile    *key_file,
4135                   const gchar *group_name)
4136 {
4137   GKeyFileGroup *group;
4138   GList *tmp;
4139 
4140   for (tmp = key_file-&gt;groups; tmp != NULL; tmp = tmp-&gt;next)
4141     {
4142       group = (GKeyFileGroup *) tmp-&gt;data;
4143 
4144       if (group &amp;&amp; group-&gt;name &amp;&amp; strcmp (group-&gt;name, group_name) == 0)
4145         break;
4146     }
4147 
4148   return tmp;
4149 }
4150 
4151 static GKeyFileGroup *
4152 g_key_file_lookup_group (GKeyFile    *key_file,
4153              const gchar *group_name)
4154 {
4155   return (GKeyFileGroup *)g_hash_table_lookup (key_file-&gt;group_hash, group_name);
4156 }
4157 
4158 static GList *
4159 g_key_file_lookup_key_value_pair_node (GKeyFile       *key_file,
4160                            GKeyFileGroup  *group,
4161                                        const gchar    *key)
4162 {
4163   GList *key_node;
4164 
4165   for (key_node = group-&gt;key_value_pairs;
4166        key_node != NULL;
4167        key_node = key_node-&gt;next)
4168     {
4169       GKeyFileKeyValuePair *pair;
4170 
4171       pair = (GKeyFileKeyValuePair *) key_node-&gt;data;
4172 
4173       if (pair-&gt;key &amp;&amp; strcmp (pair-&gt;key, key) == 0)
4174         break;
4175     }
4176 
4177   return key_node;
4178 }
4179 
4180 static GKeyFileKeyValuePair *
4181 g_key_file_lookup_key_value_pair (GKeyFile      *key_file,
4182                   GKeyFileGroup *group,
4183                   const gchar   *key)
4184 {
4185   return (GKeyFileKeyValuePair *) g_hash_table_lookup (group-&gt;lookup_map, key);
4186 }
4187 
4188 /* Lines starting with # or consisting entirely of whitespace are merely
4189  * recorded, not parsed. This function assumes all leading whitespace
4190  * has been stripped.
4191  */
4192 static gboolean
4193 g_key_file_line_is_comment (const gchar *line)
4194 {
4195   return (*line == &#39;#&#39; || *line == &#39;\0&#39; || *line == &#39;\n&#39;);
4196 }
4197 
4198 static gboolean
4199 g_key_file_is_group_name (const gchar *name)
4200 {
4201   gchar *p, *q;
4202 
4203   if (name == NULL)
4204     return FALSE;
4205 
4206   p = q = (gchar *) name;
4207   while (*q &amp;&amp; *q != &#39;]&#39; &amp;&amp; *q != &#39;[&#39; &amp;&amp; !g_ascii_iscntrl (*q))
4208     q = g_utf8_find_next_char (q, NULL);
4209 
4210   if (*q != &#39;\0&#39; || q == p)
4211     return FALSE;
4212 
4213   return TRUE;
4214 }
4215 
4216 static gboolean
4217 g_key_file_is_key_name (const gchar *name)
4218 {
4219   gchar *p, *q;
4220 
4221   if (name == NULL)
4222     return FALSE;
4223 
4224   p = q = (gchar *) name;
4225   /* We accept a little more than the desktop entry spec says,
4226    * since gnome-vfs uses mime-types as keys in its cache.
4227    */
4228   while (*q &amp;&amp; *q != &#39;=&#39; &amp;&amp; *q != &#39;[&#39; &amp;&amp; *q != &#39;]&#39;)
4229     q = g_utf8_find_next_char (q, NULL);
4230 
4231   /* No empty keys, please */
4232   if (q == p)
4233     return FALSE;
4234 
4235   /* We accept spaces in the middle of keys to not break
4236    * existing apps, but we don&#39;t tolerate initial or final
4237    * spaces, which would lead to silent corruption when
4238    * rereading the file.
4239    */
4240   if (*p == &#39; &#39; || q[-1] == &#39; &#39;)
4241     return FALSE;
4242 
4243   if (*q == &#39;[&#39;)
4244     {
4245       q++;
4246       while (*q &amp;&amp; (g_unichar_isalnum (g_utf8_get_char_validated (q, -1)) || *q == &#39;-&#39; || *q == &#39;_&#39; || *q == &#39;.&#39; || *q == &#39;@&#39;))
4247         q = g_utf8_find_next_char (q, NULL);
4248 
4249       if (*q != &#39;]&#39;)
4250         return FALSE;
4251 
4252       q++;
4253     }
4254 
4255   if (*q != &#39;\0&#39;)
4256     return FALSE;
4257 
4258   return TRUE;
4259 }
4260 
4261 /* A group in a key file is made up of a starting &#39;[&#39; followed by one
4262  * or more letters making up the group name followed by &#39;]&#39;.
4263  */
4264 static gboolean
4265 g_key_file_line_is_group (const gchar *line)
4266 {
4267   gchar *p;
4268 
4269   p = (gchar *) line;
4270   if (*p != &#39;[&#39;)
4271     return FALSE;
4272 
4273   p++;
4274 
4275   while (*p &amp;&amp; *p != &#39;]&#39;)
4276     p = g_utf8_find_next_char (p, NULL);
4277 
4278   if (*p != &#39;]&#39;)
4279     return FALSE;
4280 
4281   /* silently accept whitespace after the ] */
4282   p = g_utf8_find_next_char (p, NULL);
4283   while (*p == &#39; &#39; || *p == &#39;\t&#39;)
4284     p = g_utf8_find_next_char (p, NULL);
4285 
4286   if (*p)
4287     return FALSE;
4288 
4289   return TRUE;
4290 }
4291 
4292 static gboolean
4293 g_key_file_line_is_key_value_pair (const gchar *line)
4294 {
4295   gchar *p;
4296 
4297   p = (gchar *) g_utf8_strchr (line, -1, &#39;=&#39;);
4298 
4299   if (!p)
4300     return FALSE;
4301 
4302   /* Key must be non-empty
4303    */
4304   if (*p == line[0])
4305     return FALSE;
4306 
4307   return TRUE;
4308 }
4309 
4310 static gchar *
4311 g_key_file_parse_value_as_string (GKeyFile     *key_file,
4312                   const gchar  *value,
4313                   GSList      **pieces,
4314                   GError      **error)
4315 {
4316   gchar *string_value, *p, *q0, *q;
4317 
4318   string_value = g_new (gchar, strlen (value) + 1);
4319 
4320   p = (gchar *) value;
4321   q0 = q = string_value;
4322   while (*p)
4323     {
4324       if (*p == &#39;\\&#39;)
4325         {
4326           p++;
4327 
4328           switch (*p)
4329             {
4330             case &#39;s&#39;:
4331               *q = &#39; &#39;;
4332               break;
4333 
4334             case &#39;n&#39;:
4335               *q = &#39;\n&#39;;
4336               break;
4337 
4338             case &#39;t&#39;:
4339               *q = &#39;\t&#39;;
4340               break;
4341 
4342             case &#39;r&#39;:
4343               *q = &#39;\r&#39;;
4344               break;
4345 
4346             case &#39;\\&#39;:
4347               *q = &#39;\\&#39;;
4348               break;
4349 
4350         case &#39;\0&#39;:
4351           g_set_error_literal (error, G_KEY_FILE_ERROR,
4352                                    G_KEY_FILE_ERROR_INVALID_VALUE,
4353                                    _(&quot;Key file contains escape character &quot;
4354                                      &quot;at end of line&quot;));
4355           break;
4356 
4357             default:
4358           if (pieces &amp;&amp; *p == key_file-&gt;list_separator)
4359         *q = key_file-&gt;list_separator;
4360           else
4361         {
4362           *q++ = &#39;\\&#39;;
4363           *q = *p;
4364 
4365           if (*error == NULL)
4366             {
4367               gchar sequence[3];
4368 
4369               sequence[0] = &#39;\\&#39;;
4370               sequence[1] = *p;
4371               sequence[2] = &#39;\0&#39;;
4372 
4373               g_set_error (error, G_KEY_FILE_ERROR,
4374                            G_KEY_FILE_ERROR_INVALID_VALUE,
4375                            _(&quot;Key file contains invalid escape &quot;
4376                            &quot;sequence &#39;%s&#39;&quot;), sequence);
4377             }
4378         }
4379               break;
4380             }
4381         }
4382       else
4383     {
4384       *q = *p;
4385       if (pieces &amp;&amp; (*p == key_file-&gt;list_separator))
4386         {
4387           *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));
4388           q0 = q + 1;
4389         }
4390     }
4391 
4392       if (*p == &#39;\0&#39;)
4393     break;
4394 
4395       q++;
4396       p++;
4397     }
4398 
4399   *q = &#39;\0&#39;;
4400   if (pieces)
4401   {
4402     if (q0 &lt; q)
4403       *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));
4404     *pieces = g_slist_reverse (*pieces);
4405   }
4406 
4407   return string_value;
4408 }
4409 
4410 static gchar *
4411 g_key_file_parse_string_as_value (GKeyFile    *key_file,
4412                   const gchar *string,
4413                   gboolean     escape_separator)
4414 {
4415   gchar *value, *p, *q;
4416   gsize length;
4417   gboolean parsing_leading_space;
4418 
4419   length = strlen (string) + 1;
4420 
4421   /* Worst case would be that every character needs to be escaped.
4422    * In other words every character turns to two characters
4423    */
4424   value = g_new (gchar, 2 * length);
4425 
4426   p = (gchar *) string;
4427   q = value;
4428   parsing_leading_space = TRUE;
4429   while (p &lt; (string + length - 1))
4430     {
4431       gchar escaped_character[3] = { &#39;\\&#39;, 0, 0 };
4432 
4433       switch (*p)
4434         {
4435         case &#39; &#39;:
4436           if (parsing_leading_space)
4437             {
4438               escaped_character[1] = &#39;s&#39;;
4439               strcpy (q, escaped_character);
4440               q += 2;
4441             }
4442           else
4443             {
4444           *q = *p;
4445           q++;
4446             }
4447           break;
4448         case &#39;\t&#39;:
4449           if (parsing_leading_space)
4450             {
4451               escaped_character[1] = &#39;t&#39;;
4452               strcpy (q, escaped_character);
4453               q += 2;
4454             }
4455           else
4456             {
4457           *q = *p;
4458           q++;
4459             }
4460           break;
4461         case &#39;\n&#39;:
4462           escaped_character[1] = &#39;n&#39;;
4463           strcpy (q, escaped_character);
4464           q += 2;
4465           break;
4466         case &#39;\r&#39;:
4467           escaped_character[1] = &#39;r&#39;;
4468           strcpy (q, escaped_character);
4469           q += 2;
4470           break;
4471         case &#39;\\&#39;:
4472           escaped_character[1] = &#39;\\&#39;;
4473           strcpy (q, escaped_character);
4474           q += 2;
4475           parsing_leading_space = FALSE;
4476           break;
4477         default:
4478       if (escape_separator &amp;&amp; *p == key_file-&gt;list_separator)
4479         {
4480           escaped_character[1] = key_file-&gt;list_separator;
4481           strcpy (q, escaped_character);
4482           q += 2;
4483               parsing_leading_space = TRUE;
4484         }
4485       else
4486         {
4487           *q = *p;
4488           q++;
4489               parsing_leading_space = FALSE;
4490         }
4491           break;
4492         }
4493       p++;
4494     }
4495   *q = &#39;\0&#39;;
4496 
4497   return value;
4498 }
4499 
4500 static gint
4501 g_key_file_parse_value_as_integer (GKeyFile     *key_file,
4502                    const gchar  *value,
4503                    GError      **error)
4504 {
4505   gchar *eof_int;
4506   glong long_value;
4507   gint int_value;
4508   int errsv;
4509 
4510   errno = 0;
4511   long_value = strtol (value, &amp;eof_int, 10);
4512   errsv = errno;
4513 
4514   if (*value == &#39;\0&#39; || (*eof_int != &#39;\0&#39; &amp;&amp; !g_ascii_isspace(*eof_int)))
4515     {
4516       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4517       g_set_error (error, G_KEY_FILE_ERROR,
4518                    G_KEY_FILE_ERROR_INVALID_VALUE,
4519                    _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
4520                    &quot;as a number.&quot;), value_utf8);
4521       g_free (value_utf8);
4522 
4523       return 0;
4524     }
4525 
4526   int_value = long_value;
4527   if (int_value != long_value || errsv == ERANGE)
4528     {
4529       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4530       g_set_error (error,
4531                    G_KEY_FILE_ERROR,
4532                    G_KEY_FILE_ERROR_INVALID_VALUE,
4533                    _(&quot;Integer value &#39;%s&#39; out of range&quot;),
4534                    value_utf8);
4535       g_free (value_utf8);
4536 
4537       return 0;
4538     }
4539 
4540   return int_value;
4541 }
4542 
4543 static gchar *
4544 g_key_file_parse_integer_as_value (GKeyFile *key_file,
4545                    gint      value)
4546 
4547 {
4548   return g_strdup_printf (&quot;%d&quot;, value);
4549 }
4550 
4551 static gdouble
4552 g_key_file_parse_value_as_double  (GKeyFile     *key_file,
4553                                    const gchar  *value,
4554                                    GError      **error)
4555 {
4556   gchar *end_of_valid_d;
4557   gdouble double_value = 0;
4558 
4559   double_value = g_ascii_strtod (value, &amp;end_of_valid_d);
4560 
4561   if (*end_of_valid_d != &#39;\0&#39; || end_of_valid_d == value)
4562     {
4563       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4564       g_set_error (error, G_KEY_FILE_ERROR,
4565                    G_KEY_FILE_ERROR_INVALID_VALUE,
4566                    _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
4567                    &quot;as a float number.&quot;),
4568                    value_utf8);
4569       g_free (value_utf8);
4570 
4571       double_value = 0;
4572     }
4573 
4574   return double_value;
4575 }
4576 
4577 static gint
4578 strcmp_sized (const gchar *s1, size_t len1, const gchar *s2)
4579 {
4580   size_t len2 = strlen (s2);
4581   return strncmp (s1, s2, MAX (len1, len2));
4582 }
4583 
4584 static gboolean
4585 g_key_file_parse_value_as_boolean (GKeyFile     *key_file,
4586                    const gchar  *value,
4587                    GError      **error)
4588 {
4589   gchar *value_utf8;
4590   gint i, length = 0;
4591 
4592   /* Count the number of non-whitespace characters */
4593   for (i = 0; value[i]; i++)
4594     if (!g_ascii_isspace (value[i]))
4595       length = i + 1;
4596 
4597   if (strcmp_sized (value, length, &quot;true&quot;) == 0 || strcmp_sized (value, length, &quot;1&quot;) == 0)
4598     return TRUE;
4599   else if (strcmp_sized (value, length, &quot;false&quot;) == 0 || strcmp_sized (value, length, &quot;0&quot;) == 0)
4600     return FALSE;
4601 
4602   value_utf8 = g_utf8_make_valid (value, -1);
4603   g_set_error (error, G_KEY_FILE_ERROR,
4604                G_KEY_FILE_ERROR_INVALID_VALUE,
4605                _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
4606                &quot;as a boolean.&quot;), value_utf8);
4607   g_free (value_utf8);
4608 
4609   return FALSE;
4610 }
4611 
4612 static gchar *
4613 g_key_file_parse_boolean_as_value (GKeyFile *key_file,
4614                    gboolean  value)
4615 {
4616   if (value)
4617     return g_strdup (&quot;true&quot;);
4618   else
4619     return g_strdup (&quot;false&quot;);
4620 }
4621 
4622 static gchar *
4623 g_key_file_parse_value_as_comment (GKeyFile    *key_file,
4624                                    const gchar *value)
4625 {
4626   GString *string;
4627   gchar **lines;
4628   gsize i;
4629 
4630   string = g_string_sized_new (512);
4631 
4632   lines = g_strsplit (value, &quot;\n&quot;, 0);
4633 
4634   for (i = 0; lines[i] != NULL; i++)
4635     {
4636         if (lines[i][0] != &#39;#&#39;)
4637            g_string_append_printf (string, &quot;%s\n&quot;, lines[i]);
4638         else
4639            g_string_append_printf (string, &quot;%s\n&quot;, lines[i] + 1);
4640     }
4641   g_strfreev (lines);
4642 
4643   return g_string_free (string, FALSE);
4644 }
4645 
4646 static gchar *
4647 g_key_file_parse_comment_as_value (GKeyFile      *key_file,
4648                                    const gchar   *comment)
4649 {
4650   GString *string;
4651   gchar **lines;
4652   gsize i;
4653 
4654   string = g_string_sized_new (512);
4655 
4656   lines = g_strsplit (comment, &quot;\n&quot;, 0);
4657 
4658   for (i = 0; lines[i] != NULL; i++)
4659     g_string_append_printf (string, &quot;#%s%s&quot;, lines[i],
4660                             lines[i + 1] == NULL? &quot;&quot; : &quot;\n&quot;);
4661   g_strfreev (lines);
4662 
4663   return g_string_free (string, FALSE);
4664 }
4665 
4666 /**
4667  * g_key_file_save_to_file:
4668  * @key_file: a #GKeyFile
4669  * @filename: the name of the file to write to
4670  * @error: a pointer to a %NULL #GError, or %NULL
4671  *
4672  * Writes the contents of @key_file to @filename using
4673  * g_file_set_contents().
4674  *
4675  * This function can fail for any of the reasons that
4676  * g_file_set_contents() may fail.
4677  *
4678  * Returns: %TRUE if successful, else %FALSE with @error set
4679  *
4680  * Since: 2.40
4681  */
4682 gboolean
4683 g_key_file_save_to_file (GKeyFile     *key_file,
4684                          const gchar  *filename,
4685                          GError      **error)
4686 {
4687   gchar *contents;
4688   gboolean success;
4689   gsize length;
4690 
4691   g_return_val_if_fail (key_file != NULL, FALSE);
4692   g_return_val_if_fail (filename != NULL, FALSE);
4693   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
4694 
4695   contents = g_key_file_to_data (key_file, &amp;length, NULL);
4696   g_assert (contents != NULL);
4697 
4698   success = g_file_set_contents (filename, contents, length, error);
4699   g_free (contents);
4700 
4701   return success;
4702 }
    </pre>
  </body>
</html>