<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  * Copyright (C) 2005-2009 Tim-Philipp Müller &lt;tim centricular net&gt;
   4  * Copyright (C) 2009 Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;
   5  *
   6  * gsttypefindfunctions.c: collection of various typefind functions
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #ifdef HAVE_CONFIG_H
  25 #include &quot;config.h&quot;
  26 #endif
  27 
  28 #include &lt;glib.h&gt;
  29 #include &lt;glib/gprintf.h&gt;
  30 
  31 /* don&#39;t want to add gio xdgmime typefinder if gio was disabled via configure */
  32 #ifdef HAVE_GIO
  33 #include &lt;gio/gio.h&gt;
  34 #define USE_GIO
  35 #endif
  36 
  37 #include &lt;gst/gst.h&gt;
  38 
  39 #include &lt;stdio.h&gt;
  40 #include &lt;string.h&gt;
  41 #include &lt;ctype.h&gt;
  42 
  43 #include &lt;gst/pbutils/pbutils.h&gt;
  44 #include &lt;gst/base/gstbytereader.h&gt;
  45 
  46 GST_DEBUG_CATEGORY_STATIC (type_find_debug);
  47 #define GST_CAT_DEFAULT type_find_debug
  48 
  49 /* DataScanCtx: helper for typefind functions that scan through data
  50  * step-by-step, to avoid doing a peek at each and every offset */
  51 
  52 #define DATA_SCAN_CTX_CHUNK_SIZE 4096
  53 
  54 typedef struct
  55 {
  56   guint64 offset;
  57   const guint8 *data;
<a name="1" id="anc1"></a><span class="line-modified">  58   guint size;</span>
  59 } DataScanCtx;
  60 
  61 static inline void
  62 data_scan_ctx_advance (GstTypeFind * tf, DataScanCtx * c, guint bytes_to_skip)
  63 {
  64   c-&gt;offset += bytes_to_skip;
  65   if (G_LIKELY (c-&gt;size &gt; bytes_to_skip)) {
  66     c-&gt;size -= bytes_to_skip;
  67     c-&gt;data += bytes_to_skip;
  68   } else {
  69     c-&gt;data += c-&gt;size;
  70     c-&gt;size = 0;
  71   }
  72 }
  73 
  74 static inline gboolean
<a name="2" id="anc2"></a><span class="line-modified">  75 data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, guint min_len)</span>
  76 {
  77   const guint8 *data;
  78   guint64 len;
  79   guint chunk_len = MAX (DATA_SCAN_CTX_CHUNK_SIZE, min_len);
  80 
  81   if (G_LIKELY (c-&gt;size &gt;= min_len))
  82     return TRUE;
  83 
  84   data = gst_type_find_peek (tf, c-&gt;offset, chunk_len);
  85   if (G_LIKELY (data != NULL)) {
  86     c-&gt;data = data;
  87     c-&gt;size = chunk_len;
  88     return TRUE;
  89   }
  90 
  91   /* if there&#39;s less than our chunk size, try to get as much as we can, but
  92    * always at least min_len bytes (we might be typefinding the first buffer
  93    * of the stream and not have as much data available as we&#39;d like) */
  94   len = gst_type_find_get_length (tf);
  95   if (len &gt; 0) {
  96     len = CLAMP (len - c-&gt;offset, min_len, chunk_len);
  97   } else {
  98     len = min_len;
  99   }
 100 
 101   data = gst_type_find_peek (tf, c-&gt;offset, len);
 102   if (data != NULL) {
 103     c-&gt;data = data;
 104     c-&gt;size = len;
 105     return TRUE;
 106   }
 107 
 108   return FALSE;
 109 }
 110 
 111 static inline gboolean
 112 data_scan_ctx_memcmp (GstTypeFind * tf, DataScanCtx * c, guint offset,
 113     const gchar * data, guint len)
 114 {
<a name="3" id="anc3"></a><span class="line-added"> 115   if (G_UNLIKELY (offset + len &gt;= G_MAXUINT32))</span>
<span class="line-added"> 116     return FALSE;</span>
<span class="line-added"> 117 </span>
 118   if (!data_scan_ctx_ensure_data (tf, c, offset + len))
 119     return FALSE;
 120 
 121   return (memcmp (c-&gt;data + offset, data, len) == 0);
 122 }
 123 
 124 /*** text/plain ***/
 125 static gboolean xml_check_first_element (GstTypeFind * tf,
 126     const gchar * element, guint elen, gboolean strict);
 127 static gboolean sdp_check_header (GstTypeFind * tf);
 128 
 129 static GstStaticCaps utf8_caps = GST_STATIC_CAPS (&quot;text/plain&quot;);
 130 
 131 #define UTF8_CAPS gst_static_caps_get(&amp;utf8_caps)
 132 
 133 static gboolean
 134 utf8_type_find_have_valid_utf8_at_offset (GstTypeFind * tf, guint64 offset,
 135     GstTypeFindProbability * prob)
 136 {
 137   const guint8 *data;
 138 
 139   /* randomly decided values */
 140   guint min_size = 16;          /* minimum size  */
 141   guint size = 32 * 1024;       /* starting size */
 142   guint probability = 95;       /* starting probability */
 143   guint step = 10;              /* how much we reduce probability in each
 144                                  * iteration */
 145 
 146   while (probability &gt; step &amp;&amp; size &gt; min_size) {
 147     data = gst_type_find_peek (tf, offset, size);
 148     if (data) {
 149       gchar *end;
 150       gchar *start = (gchar *) data;
 151 
 152       if (g_utf8_validate (start, size, (const gchar **) &amp;end) || (end - start + 4 &gt; size)) {   /* allow last char to be cut off */
 153         *prob = probability;
 154         return TRUE;
 155       }
 156       *prob = 0;
 157       return FALSE;
 158     }
 159     size /= 2;
 160     probability -= step;
 161   }
 162   *prob = 0;
 163   return FALSE;
 164 }
 165 
 166 static void
 167 utf8_type_find (GstTypeFind * tf, gpointer unused)
 168 {
 169   GstTypeFindProbability start_prob, mid_prob;
 170   guint64 length;
 171 
 172   /* leave xml to the xml typefinders */
 173   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE))
 174     return;
 175 
 176   /* leave sdp to the sdp typefinders */
 177   if (sdp_check_header (tf))
 178     return;
 179 
 180   /* check beginning of stream */
 181   if (!utf8_type_find_have_valid_utf8_at_offset (tf, 0, &amp;start_prob))
 182     return;
 183 
 184   GST_LOG (&quot;start is plain text with probability of %u&quot;, start_prob);
 185 
 186   /* POSSIBLE is the highest probability we ever return if we can&#39;t
 187    * probe into the middle of the file and don&#39;t know its length */
 188 
 189   length = gst_type_find_get_length (tf);
 190   if (length == 0 || length == (guint64) - 1) {
 191     gst_type_find_suggest (tf, MIN (start_prob, GST_TYPE_FIND_POSSIBLE),
 192         UTF8_CAPS);
 193     return;
 194   }
 195 
 196   if (length &lt; 64 * 1024) {
 197     gst_type_find_suggest (tf, start_prob, UTF8_CAPS);
 198     return;
 199   }
 200 
 201   /* check middle of stream */
 202   if (!utf8_type_find_have_valid_utf8_at_offset (tf, length / 2, &amp;mid_prob))
 203     return;
 204 
 205   GST_LOG (&quot;middle is plain text with probability of %u&quot;, mid_prob);
 206   gst_type_find_suggest (tf, (start_prob + mid_prob) / 2, UTF8_CAPS);
 207 }
 208 
 209 /*** text/utf-16 and text/utf-32} ***/
 210 /* While UTF-8 is unicode too, using text/plain for UTF-16 and UTF-32
 211    is going to break stuff. */
 212 
 213 typedef struct
 214 {
 215   size_t bomlen;
 216   const char *const bom;
 217     gboolean (*checker) (const guint8 *, gint, gint);
 218   int boost;
 219   int endianness;
 220 } GstUnicodeTester;
 221 
 222 static gboolean
 223 check_utf16 (const guint8 * data, gint len, gint endianness)
 224 {
 225   GstByteReader br;
 226   guint16 high, low;
 227 
 228   low = high = 0;
 229 
 230   if (len &amp; 1)
 231     return FALSE;
 232 
 233   gst_byte_reader_init (&amp;br, data, len);
 234   while (len &gt;= 2) {
 235     /* test first for a single 16 bit value in the BMP */
 236     if (endianness == G_BIG_ENDIAN)
 237       high = gst_byte_reader_get_uint16_be_unchecked (&amp;br);
 238     else
 239       high = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
 240     if (high &gt;= 0xD800 &amp;&amp; high &lt;= 0xDBFF) {
 241       /* start of a surrogate pair */
 242       if (len &lt; 4)
 243         return FALSE;
 244       len -= 2;
 245       if (endianness == G_BIG_ENDIAN)
 246         low = gst_byte_reader_get_uint16_be_unchecked (&amp;br);
 247       else
 248         low = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
 249       if (low &gt;= 0xDC00 &amp;&amp; low &lt;= 0xDFFF) {
 250         /* second half of the surrogate pair */
 251       } else
 252         return FALSE;
 253     } else {
 254       if (high &gt;= 0xDC00 &amp;&amp; high &lt;= 0xDFFF)
 255         return FALSE;
 256     }
 257     len -= 2;
 258   }
 259   return TRUE;
 260 }
 261 
 262 static gboolean
 263 check_utf32 (const guint8 * data, gint len, gint endianness)
 264 {
 265   if (len &amp; 3)
 266     return FALSE;
 267   while (len &gt; 3) {
 268     guint32 v;
 269     if (endianness == G_BIG_ENDIAN)
 270       v = GST_READ_UINT32_BE (data);
 271     else
 272       v = GST_READ_UINT32_LE (data);
 273     if (v &gt;= 0x10FFFF)
 274       return FALSE;
 275     data += 4;
 276     len -= 4;
 277   }
 278   return TRUE;
 279 }
 280 
 281 static void
 282 unicode_type_find (GstTypeFind * tf, const GstUnicodeTester * tester,
 283     guint n_tester, const char *media_type, gboolean require_bom)
 284 {
<a name="4" id="anc4"></a><span class="line-modified"> 285   gsize n;</span>
<span class="line-modified"> 286   gsize len = 4;</span>
 287   const guint8 *data = gst_type_find_peek (tf, 0, len);
 288   int prob = -1;
 289   const gint max_scan_size = 256 * 1024;
 290   int endianness = 0;
 291 
 292   if (!data) {
 293     len = 2;
 294     data = gst_type_find_peek (tf, 0, len);
 295     if (!data)
 296       return;
 297   }
 298 
 299   /* find a large enough size that works */
 300   while (len &lt; max_scan_size) {
 301     size_t newlen = len &lt;&lt; 1;
 302     const guint8 *newdata = gst_type_find_peek (tf, 0, newlen);
 303     if (!newdata)
 304       break;
 305     len = newlen;
 306     data = newdata;
 307   }
 308 
 309   for (n = 0; n &lt; n_tester; ++n) {
 310     int bom_boost = 0, tmpprob;
 311     if (len &gt;= tester[n].bomlen) {
 312       if (!memcmp (data, tester[n].bom, tester[n].bomlen))
 313         bom_boost = tester[n].boost;
 314     }
 315     if (require_bom &amp;&amp; bom_boost == 0)
 316       continue;
 317     if (!(*tester[n].checker) (data, len, tester[n].endianness))
 318       continue;
 319     tmpprob = GST_TYPE_FIND_POSSIBLE - 20 + bom_boost;
 320     if (tmpprob &gt; prob) {
 321       prob = tmpprob;
 322       endianness = tester[n].endianness;
 323     }
 324   }
 325 
 326   if (prob &gt; 0) {
 327     GST_DEBUG (&quot;This is valid %s %s&quot;, media_type,
 328         endianness == G_BIG_ENDIAN ? &quot;be&quot; : &quot;le&quot;);
 329     gst_type_find_suggest_simple (tf, prob, media_type,
 330         &quot;endianness&quot;, G_TYPE_INT, endianness, NULL);
 331   }
 332 }
 333 
 334 static GstStaticCaps utf16_caps = GST_STATIC_CAPS (&quot;text/utf-16&quot;);
 335 
 336 #define UTF16_CAPS gst_static_caps_get(&amp;utf16_caps)
 337 
 338 static void
 339 utf16_type_find (GstTypeFind * tf, gpointer unused)
 340 {
 341   static const GstUnicodeTester utf16tester[2] = {
 342     {2, &quot;\xff\xfe&quot;, check_utf16, 10, G_LITTLE_ENDIAN},
 343     {2, &quot;\xfe\xff&quot;, check_utf16, 20, G_BIG_ENDIAN},
 344   };
 345   unicode_type_find (tf, utf16tester, G_N_ELEMENTS (utf16tester),
 346       &quot;text/utf-16&quot;, TRUE);
 347 }
 348 
 349 static GstStaticCaps utf32_caps = GST_STATIC_CAPS (&quot;text/utf-32&quot;);
 350 
 351 #define UTF32_CAPS gst_static_caps_get(&amp;utf32_caps)
 352 
 353 static void
 354 utf32_type_find (GstTypeFind * tf, gpointer unused)
 355 {
 356   static const GstUnicodeTester utf32tester[2] = {
 357     {4, &quot;\xff\xfe\x00\x00&quot;, check_utf32, 10, G_LITTLE_ENDIAN},
 358     {4, &quot;\x00\x00\xfe\xff&quot;, check_utf32, 20, G_BIG_ENDIAN}
 359   };
 360   unicode_type_find (tf, utf32tester, G_N_ELEMENTS (utf32tester),
 361       &quot;text/utf-32&quot;, TRUE);
 362 }
 363 
 364 /*** text/uri-list ***/
 365 
 366 static GstStaticCaps uri_caps = GST_STATIC_CAPS (&quot;text/uri-list&quot;);
 367 
 368 #define URI_CAPS (gst_static_caps_get(&amp;uri_caps))
 369 #define BUFFER_SIZE 16          /* If the string is &lt; 16 bytes we&#39;re screwed */
 370 #define INC_BUFFER {                                                    \
 371   pos++;                                                                \
 372   if (pos == BUFFER_SIZE) {                                             \
 373     pos = 0;                                                            \
 374     offset += BUFFER_SIZE;                                              \
 375     data = gst_type_find_peek (tf, offset, BUFFER_SIZE);                \
 376     if (data == NULL) return;                                           \
 377   } else {                                                              \
 378     data++;                                                             \
 379   }                                                                     \
 380 }
 381 static void
 382 uri_type_find (GstTypeFind * tf, gpointer unused)
 383 {
 384   const guint8 *data = gst_type_find_peek (tf, 0, BUFFER_SIZE);
 385   guint pos = 0;
 386   guint offset = 0;
 387 
 388   if (data) {
 389     /* Search for # comment lines */
 390     while (*data == &#39;#&#39;) {
 391       /* Goto end of line */
 392       while (*data != &#39;\n&#39;) {
 393         INC_BUFFER;
 394       }
 395 
 396       INC_BUFFER;
 397     }
 398 
 399     if (!g_ascii_isalpha (*data)) {
 400       /* Had a non alpha char - can&#39;t be uri-list */
 401       return;
 402     }
 403 
 404     INC_BUFFER;
 405 
 406     while (g_ascii_isalnum (*data)) {
 407       INC_BUFFER;
 408     }
 409 
 410     if (*data != &#39;:&#39;) {
 411       /* First non alpha char is not a : */
 412       return;
 413     }
 414 
 415     /* Get the next 2 bytes as well */
 416     data = gst_type_find_peek (tf, offset + pos, 3);
 417     if (data == NULL)
 418       return;
 419 
 420     if (data[1] != &#39;/&#39; &amp;&amp; data[2] != &#39;/&#39;) {
 421       return;
 422     }
 423 
 424     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, URI_CAPS);
 425   }
 426 }
 427 
 428 /*** application/itc ***/
 429 static GstStaticCaps itc_caps = GST_STATIC_CAPS (&quot;application/itc&quot;);
 430 #define ITC_CAPS (gst_static_caps_get(&amp;itc_caps))
 431 
 432 static void
 433 itc_type_find (GstTypeFind * tf, gpointer unused)
 434 {
 435   DataScanCtx c = { 0, NULL, 0 };
 436   guint8 magic[8] = { 0x00, 0x00, 0x01, 0x1C, 0x69, 0x74, 0x63, 0x68 };
 437   guint8 preamble[4] = { 0x00, 0x00, 0x00, 0x02 };
 438   guint8 artwork_marker[8] = { 0x00, 0x00, 0x00, 0x00, 0x61, 0x72, 0x74, 0x77 };
 439   guint8 item_marker[4] = { 0x69, 0x74, 0x65, 0x6D };
 440   GstTypeFindProbability itc_prob = GST_TYPE_FIND_NONE;
 441   int i;
 442 
 443   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 444     return;
 445 
 446   if (memcmp (c.data, magic, 8))
 447     return;
 448 
 449   /* At least we found the right magic */
 450   itc_prob = GST_TYPE_FIND_MINIMUM;
 451   data_scan_ctx_advance (tf, &amp;c, 8);
 452 
 453   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 12)))
 454     goto done;
 455 
 456   /* Check preamble 3 consecutive times */
 457   for (i = 0; i &lt; 3; i++) {
 458     if (memcmp (c.data, preamble, 4))
 459       goto done;
 460     data_scan_ctx_advance (tf, &amp;c, 4);
 461   }
 462 
 463   itc_prob = GST_TYPE_FIND_POSSIBLE;
 464 
 465   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 466     goto done;
 467 
 468   if (memcmp (c.data, artwork_marker, 8))
 469     goto done;
 470 
 471   itc_prob = GST_TYPE_FIND_LIKELY;
 472   data_scan_ctx_advance (tf, &amp;c, 8);
 473 
 474   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 256)))
 475     goto done;
 476 
 477   /* ...and 256 0x00 padding bytes on what looks like the header&#39;s end */
 478   for (i = 0; i &lt; 256; i++) {
 479     if (c.data[i])
 480       goto done;
 481   }
 482 
 483   itc_prob = GST_TYPE_FIND_NEARLY_CERTAIN;
 484   data_scan_ctx_advance (tf, &amp;c, 256);
 485 
 486   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 487     goto done;
 488 
 489   if (memcmp (c.data + 4, item_marker, 4))
 490     goto done;
 491 
 492   itc_prob = GST_TYPE_FIND_MAXIMUM;
 493 
 494 done:
 495   gst_type_find_suggest (tf, itc_prob, ITC_CAPS);
 496 }
 497 
 498 /*** application/x-hls ***/
 499 
 500 static GstStaticCaps hls_caps = GST_STATIC_CAPS (&quot;application/x-hls&quot;);
 501 #define HLS_CAPS (gst_static_caps_get(&amp;hls_caps))
 502 
 503 /* See http://tools.ietf.org/html/draft-pantos-http-live-streaming-05 */
 504 static void
 505 hls_type_find (GstTypeFind * tf, gpointer unused)
 506 {
 507   DataScanCtx c = { 0, NULL, 0 };
 508 
 509   /* Minimum useful size is #EXTM3U\n + 1 tag + &#39;:&#39; = 30 bytes */
 510   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 30)))
 511     return;
 512 
 513   if (memcmp (c.data, &quot;#EXTM3U&quot;, 7))
 514     return;
 515 
 516   data_scan_ctx_advance (tf, &amp;c, 7);
 517 
 518   /* Check only the first 4KB */
 519   while (c.offset &lt; 4096) {
 520     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 21)))
 521       return;
 522 
 523     /* Search for # comment lines */
 524     if (c.data[0] == &#39;#&#39; &amp;&amp; (memcmp (c.data, &quot;#EXT-X-TARGETDURATION&quot;, 21) == 0
 525             || memcmp (c.data, &quot;#EXT-X-STREAM-INF&quot;, 17) == 0
 526             || memcmp (c.data, &quot;#EXT-X-MEDIA&quot;, 12) == 0)) {
 527       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HLS_CAPS);
 528       return;
 529     }
 530 
 531     data_scan_ctx_advance (tf, &amp;c, 1);
 532   }
 533 }
 534 
 535 
 536 /*** application/xml **********************************************************/
 537 
 538 #define XML_BUFFER_SIZE 16
 539 #define XML_INC_BUFFER {                                                \
 540   pos++;                                                                \
 541   if (pos == XML_BUFFER_SIZE) {                                         \
 542     pos = 0;                                                            \
 543     offset += XML_BUFFER_SIZE;                                          \
 544     data = gst_type_find_peek (tf, offset, XML_BUFFER_SIZE);            \
 545     if (data == NULL) return FALSE;                                     \
 546   } else {                                                              \
 547     data++;                                                             \
 548   }                                                                     \
 549 }
 550 
 551 #define XML_INC_BUFFER_DATA {                                           \
 552   pos++;                                                                \
 553   if (pos &gt;= length) {                                                  \
 554     return FALSE;                                                       \
 555   } else {                                                              \
 556     data++;                                                             \
 557   }                                                                     \
 558 }
 559 
 560 static gboolean
 561 xml_check_first_element_from_data (const guint8 * data, guint length,
 562     const gchar * element, guint elen, gboolean strict)
 563 {
 564   gboolean got_xmldec;
 565   guint pos = 0;
 566 
 567   g_return_val_if_fail (data != NULL, FALSE);
 568 
 569   if (length &lt;= 5)
 570     return FALSE;
 571 
 572   /* look for the XMLDec
 573    * see XML spec 2.8, Prolog and Document Type Declaration
 574    * http://www.w3.org/TR/2004/REC-xml-20040204/#sec-prolog-dtd */
 575   got_xmldec = (memcmp (data, &quot;&lt;?xml&quot;, 5) == 0);
 576 
 577   if (strict &amp;&amp; !got_xmldec)
 578     return FALSE;
 579 
 580   /* skip XMLDec in any case if we&#39;ve got one */
 581   if (got_xmldec) {
 582     pos += 5;
 583     data += 5;
 584   }
 585 
 586   /* look for the first element, it has to be the requested element. Bail
 587    * out if it is not within the first 4kB. */
 588   while (pos &lt; MIN (4096, length)) {
 589     while (*data != &#39;&lt;&#39; &amp;&amp; pos &lt; MIN (4096, length)) {
 590       XML_INC_BUFFER_DATA;
 591     }
 592 
 593     XML_INC_BUFFER_DATA;
 594     if (!g_ascii_isalpha (*data)) {
 595       /* if not alphabetic, it&#39;s a PI or an element / attribute declaration
 596        * like &lt;?xxx or &lt;!xxx */
 597       XML_INC_BUFFER_DATA;
 598       continue;
 599     }
 600 
 601     /* the first normal element, check if it&#39;s the one asked for */
 602     if (pos + elen + 1 &gt;= length)
 603       return FALSE;
 604     return (element &amp;&amp; strncmp ((const char *) data, element, elen) == 0);
 605   }
 606 
 607   return FALSE;
 608 }
 609 
 610 static gboolean
 611 xml_check_first_element (GstTypeFind * tf, const gchar * element, guint elen,
 612     gboolean strict)
 613 {
 614   gboolean got_xmldec;
 615   const guint8 *data;
 616   guint offset = 0;
 617   guint pos = 0;
 618 
 619   data = gst_type_find_peek (tf, 0, XML_BUFFER_SIZE);
 620   if (!data)
 621     return FALSE;
 622 
 623   /* look for the XMLDec
 624    * see XML spec 2.8, Prolog and Document Type Declaration
 625    * http://www.w3.org/TR/2004/REC-xml-20040204/#sec-prolog-dtd */
 626   got_xmldec = (memcmp (data, &quot;&lt;?xml&quot;, 5) == 0);
 627 
 628   if (strict &amp;&amp; !got_xmldec)
 629     return FALSE;
 630 
 631   /* skip XMLDec in any case if we&#39;ve got one */
 632   if (got_xmldec) {
 633     pos += 5;
 634     data += 5;
 635   }
 636 
 637   /* look for the first element, it has to be the requested element. Bail
 638    * out if it is not within the first 4kB. */
 639   while (data &amp;&amp; (offset + pos) &lt; 4096) {
 640     while (*data != &#39;&lt;&#39; &amp;&amp; (offset + pos) &lt; 4096) {
 641       XML_INC_BUFFER;
 642     }
 643 
 644     XML_INC_BUFFER;
 645     if (!g_ascii_isalpha (*data)) {
 646       /* if not alphabetic, it&#39;s a PI or an element / attribute declaration
 647        * like &lt;?xxx or &lt;!xxx */
 648       XML_INC_BUFFER;
 649       continue;
 650     }
 651 
 652     /* the first normal element, check if it&#39;s the one asked for */
 653     data = gst_type_find_peek (tf, offset + pos, elen + 1);
 654     return (data &amp;&amp; element &amp;&amp; strncmp ((char *) data, element, elen) == 0);
 655   }
 656 
 657   return FALSE;
 658 }
 659 
 660 static GstStaticCaps generic_xml_caps = GST_STATIC_CAPS (&quot;application/xml&quot;);
 661 
 662 #define GENERIC_XML_CAPS (gst_static_caps_get(&amp;generic_xml_caps))
 663 static void
 664 xml_type_find (GstTypeFind * tf, gpointer unused)
 665 {
 666   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE)) {
 667     gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, GENERIC_XML_CAPS);
 668   }
 669 }
 670 
 671 /*** application/dash+xml ****************************************************/
 672 
 673 static GstStaticCaps dash_caps = GST_STATIC_CAPS (&quot;application/dash+xml&quot;);
 674 
 675 #define DASH_CAPS gst_static_caps_get (&amp;dash_caps)
 676 
 677 static void
 678 dash_mpd_type_find (GstTypeFind * tf, gpointer unused)
 679 {
 680   if (xml_check_first_element (tf, &quot;MPD&quot;, 3, FALSE) ||
 681       xml_check_first_element (tf, &quot;mpd&quot;, 3, FALSE)) {
 682     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DASH_CAPS);
 683   }
 684 }
 685 
<a name="5" id="anc5"></a><span class="line-added"> 686 /*** application/xges ****************************************************/</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688 static GstStaticCaps xges_caps = GST_STATIC_CAPS (&quot;application/xges&quot;);</span>
<span class="line-added"> 689 </span>
<span class="line-added"> 690 #define XGES_CAPS gst_static_caps_get (&amp;xges_caps)</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692 static void</span>
<span class="line-added"> 693 xges_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="line-added"> 694 {</span>
<span class="line-added"> 695   if (xml_check_first_element (tf, &quot;ges&quot;, 3, FALSE)) {</span>
<span class="line-added"> 696     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, XGES_CAPS);</span>
<span class="line-added"> 697   }</span>
<span class="line-added"> 698 }</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700 </span>
 701 /*** application/sdp *********************************************************/
 702 
 703 static GstStaticCaps sdp_caps = GST_STATIC_CAPS (&quot;application/sdp&quot;);
 704 
 705 #define SDP_CAPS (gst_static_caps_get(&amp;sdp_caps))
 706 static gboolean
 707 sdp_check_header (GstTypeFind * tf)
 708 {
 709   const guint8 *data;
 710 
 711   data = gst_type_find_peek (tf, 0, 5);
 712   if (!data)
 713     return FALSE;
 714 
 715   /* sdp must start with v=0[\r]\n */
 716   if (memcmp (data, &quot;v=0&quot;, 3))
 717     return FALSE;
 718 
 719   if (data[3] == &#39;\r&#39; &amp;&amp; data[4] == &#39;\n&#39;)
 720     return TRUE;
 721   if (data[3] == &#39;\n&#39;)
 722     return TRUE;
 723 
 724   return FALSE;
 725 }
 726 
 727 static void
 728 sdp_type_find (GstTypeFind * tf, gpointer unused)
 729 {
 730   if (sdp_check_header (tf))
 731     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SDP_CAPS);
 732 }
 733 
 734 /*** application/smil *********************************************************/
 735 
 736 static GstStaticCaps smil_caps = GST_STATIC_CAPS (&quot;application/smil&quot;);
 737 
 738 #define SMIL_CAPS (gst_static_caps_get(&amp;smil_caps))
 739 static void
 740 smil_type_find (GstTypeFind * tf, gpointer unused)
 741 {
 742   if (xml_check_first_element (tf, &quot;smil&quot;, 4, FALSE)) {
 743     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SMIL_CAPS);
 744   }
 745 }
 746 
 747 /*** application/ttml+xml *****************************************************/
 748 
 749 static GstStaticCaps ttml_xml_caps = GST_STATIC_CAPS (&quot;application/ttml+xml&quot;);
 750 
 751 #define TTML_XML_CAPS (gst_static_caps_get(&amp;ttml_xml_caps))
 752 static void
 753 ttml_xml_type_find (GstTypeFind * tf, gpointer unused)
 754 {
 755   if (xml_check_first_element (tf, &quot;tt&quot;, 2, FALSE)) {
 756     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TTML_XML_CAPS);
 757   }
 758 }
 759 
 760 /*** text/html ***/
 761 
 762 static GstStaticCaps html_caps = GST_STATIC_CAPS (&quot;text/html&quot;);
 763 
 764 #define HTML_CAPS gst_static_caps_get (&amp;html_caps)
 765 
 766 static void
 767 html_type_find (GstTypeFind * tf, gpointer unused)
 768 {
 769   const gchar *d, *data;
 770 
 771   data = (const gchar *) gst_type_find_peek (tf, 0, 16);
 772   if (!data)
 773     return;
 774 
 775   if (!g_ascii_strncasecmp (data, &quot;&lt;!DOCTYPE HTML&quot;, 14)) {
 776     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 777   } else if (xml_check_first_element (tf, &quot;html&quot;, 4, FALSE)) {
 778     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 779   } else if ((d = memchr (data, &#39;&lt;&#39;, 16))) {
 780     data = (const gchar *) gst_type_find_peek (tf, d - data, 6);
 781     if (data &amp;&amp; g_ascii_strncasecmp (data, &quot;&lt;html&gt;&quot;, 6) == 0) {
 782       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 783     }
 784   }
 785 }
 786 
 787 /*** audio/midi ***/
 788 
 789 static GstStaticCaps mid_caps = GST_STATIC_CAPS (&quot;audio/midi&quot;);
 790 
 791 #define MID_CAPS gst_static_caps_get(&amp;mid_caps)
 792 static void
 793 mid_type_find (GstTypeFind * tf, gpointer unused)
 794 {
 795   const guint8 *data = gst_type_find_peek (tf, 0, 4);
 796 
 797   /* http://jedi.ks.uiuc.edu/~johns/links/music/midifile.html */
 798   if (data &amp;&amp; data[0] == &#39;M&#39; &amp;&amp; data[1] == &#39;T&#39; &amp;&amp; data[2] == &#39;h&#39;
 799       &amp;&amp; data[3] == &#39;d&#39;)
 800     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MID_CAPS);
 801 }
 802 
 803 /*** audio/mobile-xmf ***/
 804 
 805 static GstStaticCaps mxmf_caps = GST_STATIC_CAPS (&quot;audio/mobile-xmf&quot;);
 806 
 807 #define MXMF_CAPS gst_static_caps_get(&amp;mxmf_caps)
 808 static void
 809 mxmf_type_find (GstTypeFind * tf, gpointer unused)
 810 {
 811   const guint8 *data = NULL;
 812 
 813   /* Search FileId &quot;XMF_&quot; 4 bytes */
 814   data = gst_type_find_peek (tf, 0, 4);
 815   if (data &amp;&amp; data[0] == &#39;X&#39; &amp;&amp; data[1] == &#39;M&#39; &amp;&amp; data[2] == &#39;F&#39;
 816       &amp;&amp; data[3] == &#39;_&#39;) {
 817     /* Search Format version &quot;2.00&quot; 4 bytes */
 818     data = gst_type_find_peek (tf, 4, 4);
 819     if (data &amp;&amp; data[0] == &#39;2&#39; &amp;&amp; data[1] == &#39;.&#39; &amp;&amp; data[2] == &#39;0&#39;
 820         &amp;&amp; data[3] == &#39;0&#39;) {
 821       /* Search TypeId 2     1 byte */
 822       data = gst_type_find_peek (tf, 11, 1);
 823       if (data &amp;&amp; data[0] == 2) {
 824         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MXMF_CAPS);
 825       }
 826     }
 827   }
 828 }
 829 
 830 
 831 /*** video/x-fli ***/
 832 
 833 static GstStaticCaps flx_caps = GST_STATIC_CAPS (&quot;video/x-fli&quot;);
 834 
 835 #define FLX_CAPS gst_static_caps_get(&amp;flx_caps)
 836 static void
 837 flx_type_find (GstTypeFind * tf, gpointer unused)
 838 {
 839   const guint8 *data = gst_type_find_peek (tf, 0, 134);
 840 
 841   if (data) {
 842     /* check magic and the frame type of the first frame */
 843     if ((data[4] == 0x11 || data[4] == 0x12 ||
 844             data[4] == 0x30 || data[4] == 0x44) &amp;&amp;
 845         data[5] == 0xaf &amp;&amp;
 846         ((data[132] == 0x00 || data[132] == 0xfa) &amp;&amp; data[133] == 0xf1)) {
 847       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLX_CAPS);
 848     }
 849     return;
 850   }
 851   data = gst_type_find_peek (tf, 0, 6);
 852   if (data) {
 853     /* check magic only */
 854     if ((data[4] == 0x11 || data[4] == 0x12 ||
 855             data[4] == 0x30 || data[4] == 0x44) &amp;&amp; data[5] == 0xaf) {
 856       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, FLX_CAPS);
 857     }
 858     return;
 859   }
 860 }
 861 
 862 /*** application/x-id3 ***/
 863 
 864 static GstStaticCaps id3_caps = GST_STATIC_CAPS (&quot;application/x-id3&quot;);
 865 
 866 #define ID3_CAPS gst_static_caps_get(&amp;id3_caps)
 867 static void
 868 id3v2_type_find (GstTypeFind * tf, gpointer unused)
 869 {
 870   const guint8 *data = gst_type_find_peek (tf, 0, 10);
 871 
 872   if (data &amp;&amp; memcmp (data, &quot;ID3&quot;, 3) == 0 &amp;&amp;
 873       data[3] != 0xFF &amp;&amp; data[4] != 0xFF &amp;&amp;
 874       (data[6] &amp; 0x80) == 0 &amp;&amp; (data[7] &amp; 0x80) == 0 &amp;&amp;
 875       (data[8] &amp; 0x80) == 0 &amp;&amp; (data[9] &amp; 0x80) == 0) {
 876     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, ID3_CAPS);
 877   }
 878 }
 879 
 880 static void
 881 id3v1_type_find (GstTypeFind * tf, gpointer unused)
 882 {
 883   const guint8 *data = gst_type_find_peek (tf, -128, 3);
 884 
 885   if (data &amp;&amp; memcmp (data, &quot;TAG&quot;, 3) == 0) {
 886     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, ID3_CAPS);
 887   }
 888 }
 889 
 890 /*** application/x-ape ***/
 891 
 892 static GstStaticCaps apetag_caps = GST_STATIC_CAPS (&quot;application/x-apetag&quot;);
 893 
 894 #define APETAG_CAPS gst_static_caps_get(&amp;apetag_caps)
 895 static void
 896 apetag_type_find (GstTypeFind * tf, gpointer unused)
 897 {
 898   const guint8 *data;
 899 
 900   /* APEv1/2 at start of file */
 901   data = gst_type_find_peek (tf, 0, 8);
 902   if (data &amp;&amp; !memcmp (data, &quot;APETAGEX&quot;, 8)) {
 903     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, APETAG_CAPS);
 904     return;
 905   }
 906 
 907   /* APEv1/2 at end of file */
 908   data = gst_type_find_peek (tf, -32, 8);
 909   if (data &amp;&amp; !memcmp (data, &quot;APETAGEX&quot;, 8)) {
 910     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, APETAG_CAPS);
 911     return;
 912   }
 913 }
 914 
 915 /*** audio/x-ttafile ***/
 916 
 917 static GstStaticCaps tta_caps = GST_STATIC_CAPS (&quot;audio/x-ttafile&quot;);
 918 
 919 #define TTA_CAPS gst_static_caps_get(&amp;tta_caps)
 920 static void
 921 tta_type_find (GstTypeFind * tf, gpointer unused)
 922 {
 923   const guint8 *data = gst_type_find_peek (tf, 0, 3);
 924 
 925   if (data) {
 926     if (memcmp (data, &quot;TTA&quot;, 3) == 0) {
 927       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TTA_CAPS);
 928       return;
 929     }
 930   }
 931 }
 932 
 933 /*** audio/x-flac ***/
 934 static GstStaticCaps flac_caps = GST_STATIC_CAPS (&quot;audio/x-flac&quot;);
 935 
 936 #define FLAC_CAPS (gst_static_caps_get(&amp;flac_caps))
 937 
 938 static void
 939 flac_type_find (GstTypeFind * tf, gpointer unused)
 940 {
 941   DataScanCtx c = { 0, NULL, 0 };
 942 
 943   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
 944     return;
 945 
 946   /* standard flac (also old/broken flac-in-ogg with an initial 4-byte marker
 947    * packet and without the usual packet framing) */
 948   if (memcmp (c.data, &quot;fLaC&quot;, 4) == 0) {
 949     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLAC_CAPS);
 950     return;
 951   }
 952 
 953   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
 954     return;
 955 
 956   /* flac-in-ogg, see http://flac.sourceforge.net/ogg_mapping.html */
 957   if (memcmp (c.data, &quot;\177FLAC\001&quot;, 6) == 0) {
 958     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLAC_CAPS);
 959     return;
 960   }
 961 
 962 /* disabled because it happily typefinds /dev/urandom as audio/x-flac, and
 963  * because I yet have to see header-less flac in the wild */
 964 #if 0
 965   /* flac without headers (subset format) */
 966   /* 64K should be enough */
 967   while (c.offset &lt; (64 * 1024)) {
 968     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
 969       break;
 970 
 971     /* look for frame header,
 972      * http://flac.sourceforge.net/format.html#frame_header
 973      */
 974     if (c.data[0] == 0xff &amp;&amp; (c.data[1] &gt;&gt; 2) == 0x3e) {
 975       /* bit 15 in the header must be 0 */
 976       if (((c.data[1] &gt;&gt; 1) &amp; 0x01) == 0x01)
 977         goto advance;
 978 
 979       /* blocksize must be != 0x00 */
 980       if ((c.data[2] &gt;&gt; 4) == 0x00)
 981         goto advance;
 982 
 983       /* samplerate must be != 0x0f */
 984       if ((c.data[2] &amp; 0x0f) == 0x0f)
 985         goto advance;
 986       /* also 0 is invalid, as it means get the info from the header and we
 987        * don&#39;t have headers if we are here */
 988       if ((c.data[2] &amp; 0x0f) == 0x00)
 989         goto advance;
 990 
 991       /* channel assignment must be &lt; 11 */
 992       if ((c.data[3] &gt;&gt; 4) &gt;= 11)
 993         goto advance;
 994 
 995       /* sample size must be != 0x07 and != 0x05 */
 996       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x07)
 997         goto advance;
 998       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x05)
 999         goto advance;
1000       /* also 0 is invalid, as it means get the info from the header and we
1001        * don&#39;t have headers if we are here */
1002       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x00)
1003         goto advance;
1004 
1005       /* next bit must be 0 */
1006       if ((c.data[3] &amp; 0x01) == 0x01)
1007         goto advance;
1008 
1009       /* FIXME: shouldn&#39;t we include the crc check ? */
1010 
1011       GST_DEBUG (&quot;Found flac without headers at %d&quot;, (gint) c.offset);
1012       gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, FLAC_CAPS);
1013       return;
1014     }
1015   advance:
1016     data_scan_ctx_advance (tf, &amp;c, 1);
1017   }
1018 #endif
1019 }
1020 
1021 /* TODO: we could probably make a generic function for this.. */
1022 static gint
1023 aac_type_find_scan_loas_frames_ep (GstTypeFind * tf, DataScanCtx * scan_ctx,
1024     gint max_frames)
1025 {
1026   DataScanCtx c = *scan_ctx;
1027   guint16 snc;
1028   guint len;
1029   gint count = 0;
1030 
1031   do {
1032     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
1033       break;
1034 
1035     /* EPAudioSyncStream */
1036     len = ((c.data[2] &amp; 0x0f) &lt;&lt; 9) | (c.data[3] &lt;&lt; 1) |
1037         ((c.data[4] &amp; 0x80) &gt;&gt; 7);
1038 
1039     if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 2)) {
1040       GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1041       break;
1042     }
1043 
1044     /* check length of frame  */
1045     snc = GST_READ_UINT16_BE (c.data + len);
1046     if (snc != 0x4de1) {
1047       GST_DEBUG (&quot;No sync found at 0x%&quot; G_GINT64_MODIFIER &quot;x&quot;, c.offset + len);
1048       break;
1049     }
1050 
1051     ++count;
1052 
1053     GST_DEBUG (&quot;Found LOAS syncword #%d at offset 0x%&quot; G_GINT64_MODIFIER &quot;x, &quot;
1054         &quot;framelen %u&quot;, count, c.offset, len);
1055 
1056     data_scan_ctx_advance (tf, &amp;c, len);
1057   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1058 
1059   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1060   return count;
1061 }
1062 
1063 static gint
1064 aac_type_find_scan_loas_frames (GstTypeFind * tf, DataScanCtx * scan_ctx,
1065     gint max_frames)
1066 {
1067   DataScanCtx c = *scan_ctx;
1068   guint16 snc;
1069   guint len;
1070   gint count = 0;
1071 
1072   do {
1073     if (!data_scan_ctx_ensure_data (tf, &amp;c, 3))
1074       break;
1075 
1076     /* AudioSyncStream */
1077     len = ((c.data[1] &amp; 0x1f) &lt;&lt; 8) | c.data[2];
1078     /* add size of sync stream header */
1079     len += 3;
1080 
1081     if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 2)) {
1082       GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1083       break;
1084     }
1085 
1086     /* check length of frame  */
1087     snc = GST_READ_UINT16_BE (c.data + len);
1088     if ((snc &amp; 0xffe0) != 0x56e0) {
1089       GST_DEBUG (&quot;No sync found at 0x%&quot; G_GINT64_MODIFIER &quot;x&quot;, c.offset + len);
1090       break;
1091     }
1092 
1093     ++count;
1094 
1095     GST_DEBUG (&quot;Found LOAS syncword #%d at offset 0x%&quot; G_GINT64_MODIFIER &quot;x, &quot;
1096         &quot;framelen %u&quot;, count, c.offset, len);
1097 
1098     data_scan_ctx_advance (tf, &amp;c, len);
1099   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1100 
1101   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1102   return count;
1103 }
1104 
1105 /*** audio/mpeg version 2, 4 ***/
1106 
1107 static GstStaticCaps aac_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1108     &quot;mpegversion = (int) { 2, 4 }, framed = (bool) false&quot;);
1109 #define AAC_CAPS (gst_static_caps_get(&amp;aac_caps))
1110 #define AAC_AMOUNT (4096)
1111 static void
1112 aac_type_find (GstTypeFind * tf, gpointer unused)
1113 {
1114   DataScanCtx c = { 0, NULL, 0 };
1115   GstTypeFindProbability best_probability = GST_TYPE_FIND_NONE;
1116   GstCaps *best_caps = NULL;
<a name="6" id="anc6"></a><span class="line-modified">1117   gint best_count = 0;</span>
1118 
1119   while (c.offset &lt; AAC_AMOUNT) {
1120     guint snc, len, offset, i;
1121 
1122     /* detect adts header or adif header.
1123      * The ADIF header is 4 bytes, that should be OK. The ADTS header, on
1124      * the other hand, is 14 bits only, so we require one valid frame with
1125      * again a valid syncpoint on the next one (28 bits) for certainty. We
1126      * require 4 kB, which is quite a lot, since frames are generally 200-400
1127      * bytes.
1128      * LOAS has 2 possible syncwords, which are 11 bits and 16 bits long.
1129      * The following stream syntax depends on which one is found.
1130      */
1131     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1132       break;
1133 
1134     snc = GST_READ_UINT16_BE (c.data);
1135     if (G_UNLIKELY ((snc &amp; 0xfff6) == 0xfff0)) {
1136       /* ADTS header - find frame length */
1137       GST_DEBUG (&quot;Found one ADTS syncpoint at offset 0x%&quot; G_GINT64_MODIFIER
1138           &quot;x, tracing next...&quot;, c.offset);
1139       len = ((c.data[3] &amp; 0x03) &lt;&lt; 11) |
1140           (c.data[4] &lt;&lt; 3) | ((c.data[5] &amp; 0xe0) &gt;&gt; 5);
1141 
1142       if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 6)) {
1143         GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1144         goto next;
1145       }
1146 
1147       offset = len;
1148       /* check if there&#39;s a second ADTS frame */
1149       snc = GST_READ_UINT16_BE (c.data + offset);
1150       if ((snc &amp; 0xfff6) == 0xfff0) {
1151         GstCaps *caps;
1152         guint mpegversion, sample_freq_idx, channel_config, profile_idx, rate;
1153         guint8 audio_config[2];
1154 
1155         mpegversion = (c.data[1] &amp; 0x08) ? 2 : 4;
1156         profile_idx = c.data[2] &gt;&gt; 6;
1157         sample_freq_idx = ((c.data[2] &amp; 0x3c) &gt;&gt; 2);
1158         channel_config = ((c.data[2] &amp; 0x01) &lt;&lt; 2) + (c.data[3] &gt;&gt; 6);
1159 
1160         GST_DEBUG (&quot;Found second ADTS-%d syncpoint at offset 0x%&quot;
1161             G_GINT64_MODIFIER &quot;x, framelen %u&quot;, mpegversion, c.offset, len);
1162 
1163         /* 0xd and 0xe are reserved. 0xf means the sample frequency is directly
1164          * specified in the header, but that&#39;s not allowed for ADTS */
1165         if (sample_freq_idx &gt; 0xc) {
1166           GST_DEBUG (&quot;Unexpected sample frequency index %d or wrong sync&quot;,
1167               sample_freq_idx);
1168           goto next;
1169         }
1170 
1171         rate = gst_codec_utils_aac_get_sample_rate_from_index (sample_freq_idx);
1172         GST_LOG (&quot;ADTS: profile=%u, rate=%u&quot;, profile_idx, rate);
1173 
1174         /* The ADTS frame header is slightly different from the
1175          * AudioSpecificConfig defined for the MPEG-4 container, so we just
1176          * construct enough of it for getting the level here. */
1177         /* ADTS counts profiles from 0 instead of 1 to save bits */
1178         audio_config[0] = (profile_idx + 1) &lt;&lt; 3;
1179         audio_config[0] |= (sample_freq_idx &gt;&gt; 1) &amp; 0x7;
1180         audio_config[1] = (sample_freq_idx &amp; 0x1) &lt;&lt; 7;
1181         audio_config[1] |= (channel_config &amp; 0xf) &lt;&lt; 3;
1182 
1183         caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1184             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1185             &quot;mpegversion&quot;, G_TYPE_INT, mpegversion,
1186             &quot;stream-format&quot;, G_TYPE_STRING, &quot;adts&quot;, NULL);
1187 
1188         gst_codec_utils_aac_caps_set_level_and_profile (caps, audio_config, 2);
1189 
1190         /* add rate and number of channels if we can */
1191         if (channel_config != 0 &amp;&amp; channel_config &lt;= 7) {
1192           const guint channels_map[] = { 0, 1, 2, 3, 4, 5, 6, 8 };
1193 
1194           gst_caps_set_simple (caps, &quot;channels&quot;, G_TYPE_INT,
1195               channels_map[channel_config], &quot;rate&quot;, G_TYPE_INT, rate, NULL);
1196         }
1197 
1198         /* length of the second ADTS frame */
1199         len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1200             (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1201 
1202         if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1203           GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
<a name="7" id="anc7"></a><span class="line-modified">1204           gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
1205         } else {
1206           offset += len;
1207           /* find more aac sync to select correctly */
1208           /* check if there&#39;s a third/fourth/fifth/sixth ADTS frame, if there is a sixth frame, set probability to maximum:100% */
1209           for (i = 3; i &lt;= 6; i++) {
1210             len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1211                 (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1212             if (len == 0
1213                 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1214               GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;,
1215                   len);
1216               break;
1217             }
1218             snc = GST_READ_UINT16_BE (c.data + offset);
1219             if ((snc &amp; 0xfff6) == 0xfff0) {
1220               GST_DEBUG (&quot;Find %und Sync..probability is %u &quot;, i,
1221                   GST_TYPE_FIND_LIKELY + 5 * (i - 2));
1222               offset += len;
1223             } else {
1224               break;
1225             }
1226           }
1227           gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY + 5 * (i - 3), caps);
1228 
1229         }
1230         gst_caps_unref (caps);
1231         break;
1232       }
1233 
1234       GST_DEBUG (&quot;No next frame found... (should have been at 0x%x)&quot;, len);
1235     } else if (G_UNLIKELY ((snc &amp; 0xffe0) == 0x56e0 || snc == 0x4de1)) {
1236       gint count;
1237 
1238       /* LOAS frame */
1239       GST_INFO (&quot;Possible LOAS syncword at offset 0x%&quot; G_GINT64_MODIFIER
1240           &quot;x, scanning for more frames...&quot;, c.offset);
1241 
1242       if (snc == 0x4de1)
1243         count = aac_type_find_scan_loas_frames_ep (tf, &amp;c, 20);
1244       else
1245         count = aac_type_find_scan_loas_frames (tf, &amp;c, 20);
1246 
1247       if (count &gt;= 3 &amp;&amp; count &gt; best_count) {
1248         gst_caps_replace (&amp;best_caps, NULL);
1249         best_caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1250             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1251             &quot;mpegversion&quot;, G_TYPE_INT, 4,
1252             &quot;stream-format&quot;, G_TYPE_STRING, &quot;loas&quot;, NULL);
1253         best_count = count;
1254         best_probability = GST_TYPE_FIND_POSSIBLE - 10 + count * 3;
1255         if (best_probability &gt;= GST_TYPE_FIND_LIKELY)
<a name="8" id="anc8"></a><span class="line-modified">1256           break;</span>
1257       }
1258     } else if (!memcmp (c.data, &quot;ADIF&quot;, 4)) {
1259       /* ADIF header */
1260       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, &quot;audio/mpeg&quot;,
1261           &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, &quot;mpegversion&quot;, G_TYPE_INT, 4,
1262           &quot;stream-format&quot;, G_TYPE_STRING, &quot;adif&quot;, NULL);
1263       break;
1264     }
1265 
1266   next:
1267 
1268     data_scan_ctx_advance (tf, &amp;c, 1);
1269   }
1270 
1271   if (best_probability &gt; GST_TYPE_FIND_NONE) {
1272     gst_type_find_suggest (tf, best_probability, best_caps);
1273     gst_caps_unref (best_caps);
1274   }
1275 }
1276 
1277 /*** audio/mpeg version 1 ***/
1278 
1279 /*
1280  * The chance that random data is identified as a valid mp3 header is 63 / 2^18
1281  * (0.024%) per try. This makes the function for calculating false positives
1282  *   1 - (1 - ((63 / 2 ^18) ^ GST_MP3_TYPEFIND_MIN_HEADERS)) ^ buffersize)
1283  * This has the following probabilities of false positives:
1284  * datasize               MIN_HEADERS
1285  * (bytes)      1       2       3       4
1286  * 4096         62.6%    0.02%   0%      0%
1287  * 16384        98%      0.09%   0%      0%
1288  * 1 MiB       100%      5.88%   0%      0%
1289  * 1 GiB       100%    100%      1.44%   0%
1290  * 1 TiB       100%    100%    100%      0.35%
1291  * This means that the current choice (3 headers by most of the time 4096 byte
1292  * buffers is pretty safe for now.
1293  *
1294  * The max. size of each frame is 1440 bytes, which means that for N frames to
1295  * be detected, we need 1440 * GST_MP3_TYPEFIND_MIN_HEADERS + 3 bytes of data.
1296  * Assuming we step into the stream right after the frame header, this
1297  * means we need 1440 * (GST_MP3_TYPEFIND_MIN_HEADERS + 1) - 1 + 3 bytes
1298  * of data (5762) to always detect any mp3.
1299  */
1300 
1301 static const guint mp3types_bitrates[2][3][16] =
1302     { {{0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,},
1303     {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,},
1304     {0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320,}},
1305 {{0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256,},
1306     {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160,},
1307     {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160,}},
1308 };
1309 
1310 static const guint mp3types_freqs[3][3] = { {11025, 12000, 8000},
1311 {22050, 24000, 16000},
1312 {44100, 48000, 32000}
1313 };
1314 
1315 static inline guint
1316 mp3_type_frame_length_from_header (guint32 header, guint * put_layer,
1317     guint * put_channels, guint * put_bitrate, guint * put_samplerate,
1318     gboolean * may_be_free_format, gint possible_free_framelen)
1319 {
1320   guint bitrate, layer, length, mode, samplerate, version, channels;
1321 
1322   if ((header &amp; 0xffe00000) != 0xffe00000)
1323     return 0;
1324 
1325   /* we don&#39;t need extension, copyright, original or
1326    * emphasis for the frame length */
1327   header &gt;&gt;= 6;
1328 
1329   /* mode */
1330   mode = header &amp; 0x3;
1331   header &gt;&gt;= 3;
1332 
1333   /* padding */
1334   length = header &amp; 0x1;
1335   header &gt;&gt;= 1;
1336 
1337   /* sampling frequency */
1338   samplerate = header &amp; 0x3;
1339   if (samplerate == 3)
1340     return 0;
1341   header &gt;&gt;= 2;
1342 
1343   /* bitrate index */
1344   bitrate = header &amp; 0xF;
1345   if (bitrate == 0 &amp;&amp; possible_free_framelen == -1) {
1346     GST_LOG (&quot;Possibly a free format mp3 - signaling&quot;);
1347     *may_be_free_format = TRUE;
1348   }
1349   if (bitrate == 15 || (bitrate == 0 &amp;&amp; possible_free_framelen == -1))
1350     return 0;
1351 
1352   /* ignore error correction, too */
1353   header &gt;&gt;= 5;
1354 
1355   /* layer */
1356   layer = 4 - (header &amp; 0x3);
1357   if (layer == 4)
1358     return 0;
1359   header &gt;&gt;= 2;
1360 
1361   /* version 0=MPEG2.5; 2=MPEG2; 3=MPEG1 */
1362   version = header &amp; 0x3;
1363   if (version == 1)
1364     return 0;
1365 
1366   /* lookup */
1367   channels = (mode == 3) ? 1 : 2;
1368   samplerate = mp3types_freqs[version &gt; 0 ? version - 1 : 0][samplerate];
1369   if (bitrate == 0) {
1370     /* possible freeform mp3 */
1371     if (layer == 1) {
1372       length *= 4;
1373       length += possible_free_framelen;
1374       bitrate = length * samplerate / 48000;
1375     } else {
1376       length += possible_free_framelen;
1377       bitrate = length * samplerate /
1378           ((layer == 3 &amp;&amp; version != 3) ? 72000 : 144000);
1379     }
1380     /* freeform mp3 should have a higher-than-usually-allowed bitrate */
1381     GST_LOG (&quot;calculated bitrate: %u, max usually: %u&quot;, bitrate,
1382         mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][14]);
1383     if (bitrate &lt; mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][14])
1384       return 0;
1385   } else {
1386     /* calculating */
1387     bitrate = mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][bitrate];
1388     if (layer == 1) {
1389       length = ((12000 * bitrate / samplerate) + length) * 4;
1390     } else {
1391       length += ((layer == 3
1392               &amp;&amp; version != 3) ? 72000 : 144000) * bitrate / samplerate;
1393     }
1394   }
1395 
1396   GST_LOG (&quot;mp3typefind: calculated mp3 frame length of %u bytes&quot;, length);
1397   GST_LOG
1398       (&quot;mp3typefind: samplerate = %u - bitrate = %u - layer = %u - version = %u&quot;
1399       &quot; - channels = %u&quot;, samplerate, bitrate, layer, version, channels);
1400 
1401   if (put_layer)
1402     *put_layer = layer;
1403   if (put_channels)
1404     *put_channels = channels;
1405   if (put_bitrate)
1406     *put_bitrate = bitrate;
1407   if (put_samplerate)
1408     *put_samplerate = samplerate;
1409 
1410   return length;
1411 }
1412 
1413 
1414 static GstStaticCaps mp3_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1415     &quot;mpegversion = (int) 1, layer = (int) [ 1, 3 ]&quot;);
1416 #define MP3_CAPS (gst_static_caps_get(&amp;mp3_caps))
1417 /*
1418  * random values for typefinding
1419  * if no more data is available, we will return a probability of
1420  * (found_headers/TRY_HEADERS) * (MAXIMUM * (TRY_SYNC - bytes_skipped)
1421  *        / TRY_SYNC)
1422  * if found_headers &gt;= MIN_HEADERS
1423  */
1424 #define GST_MP3_TYPEFIND_MIN_HEADERS (2)
1425 #define GST_MP3_TYPEFIND_TRY_HEADERS (5)
1426 #define GST_MP3_TYPEFIND_TRY_SYNC (GST_TYPE_FIND_MAXIMUM * 100) /* 10kB */
1427 #define GST_MP3_TYPEFIND_SYNC_SIZE (2048)
1428 #define GST_MP3_WRONG_HEADER (10)
1429 
1430 static void
1431 mp3_type_find_at_offset (GstTypeFind * tf, guint64 start_off,
1432     guint * found_layer, GstTypeFindProbability * found_prob)
1433 {
1434   const guint8 *data = NULL;
1435   const guint8 *data_end = NULL;
1436   guint size;
1437   guint64 skipped;
1438   gint last_free_offset = -1;
1439   gint last_free_framelen = -1;
1440   gboolean headerstart = TRUE;
1441 
1442   *found_layer = 0;
1443   *found_prob = 0;
1444 
1445   size = 0;
1446   skipped = 0;
1447   while (skipped &lt; GST_MP3_TYPEFIND_TRY_SYNC) {
1448     if (size &lt;= 0) {
1449       size = GST_MP3_TYPEFIND_SYNC_SIZE * 2;
1450       do {
1451         size /= 2;
1452         data = gst_type_find_peek (tf, skipped + start_off, size);
1453       } while (size &gt; 10 &amp;&amp; !data);
1454       if (!data)
1455         break;
1456       data_end = data + size;
1457     }
1458     if (*data == 0xFF) {
1459       const guint8 *head_data = NULL;
1460       guint layer = 0, bitrate, samplerate, channels;
1461       guint found = 0;          /* number of valid headers found */
1462       guint64 offset = skipped;
1463       gboolean changed = FALSE;
1464       guint prev_layer = 0;
1465       guint prev_channels = 0, prev_samplerate = 0;
1466 
1467       while (found &lt; GST_MP3_TYPEFIND_TRY_HEADERS) {
1468         guint32 head;
1469         guint length;
1470         gboolean free = FALSE;
1471 
1472         if ((gint64) (offset - skipped + 4) &gt;= 0 &amp;&amp;
1473             data + offset - skipped + 4 &lt; data_end) {
1474           head_data = data + offset - skipped;
1475         } else {
1476           head_data = gst_type_find_peek (tf, offset + start_off, 4);
1477         }
1478         if (!head_data)
1479           break;
1480         head = GST_READ_UINT32_BE (head_data);
1481         if (!(length = mp3_type_frame_length_from_header (head, &amp;layer,
1482                     &amp;channels, &amp;bitrate, &amp;samplerate, &amp;free,
1483                     last_free_framelen))) {
1484           if (free) {
1485             if (last_free_offset == -1)
1486               last_free_offset = offset;
1487             else {
1488               last_free_framelen = offset - last_free_offset;
1489               offset = last_free_offset;
1490               continue;
1491             }
1492           } else {
1493             last_free_framelen = -1;
1494           }
1495 
1496           /* Mark the fact that we didn&#39;t find a valid header at the beginning */
1497           if (found == 0)
1498             headerstart = FALSE;
1499 
1500           GST_LOG (&quot;%d. header at offset %&quot; G_GUINT64_FORMAT
1501               &quot; (0x%&quot; G_GINT64_MODIFIER &quot;x) was not an mp3 header &quot;
1502               &quot;(possibly-free: %s)&quot;, found + 1, start_off + offset,
1503               start_off + offset, free ? &quot;yes&quot; : &quot;no&quot;);
1504           break;
1505         }
1506         if ((prev_layer &amp;&amp; prev_layer != layer) ||
1507             /* (prev_bitrate &amp;&amp; prev_bitrate != bitrate) || &lt;-- VBR */
1508             (prev_samplerate &amp;&amp; prev_samplerate != samplerate) ||
1509             (prev_channels &amp;&amp; prev_channels != channels)) {
1510           /* this means an invalid property, or a change, which might mean
1511            * that this is not a mp3 but just a random bytestream. It could
1512            * be a freaking funky encoded mp3 though. We&#39;ll just not count
1513            * this header*/
1514           if (prev_layer)
1515             changed = TRUE;
1516         } else {
1517           found++;
1518           GST_LOG (&quot;found %d. header at offset %&quot; G_GUINT64_FORMAT &quot; (0x%&quot;
1519               G_GINT64_MODIFIER &quot;X)&quot;, found, start_off + offset,
1520               start_off + offset);
1521         }
1522         prev_layer = layer;
1523         prev_channels = channels;
1524         prev_samplerate = samplerate;
1525 
1526         offset += length;
1527       }
1528       g_assert (found &lt;= GST_MP3_TYPEFIND_TRY_HEADERS);
1529       if (found != 0 &amp;&amp; head_data == NULL &amp;&amp;
1530           gst_type_find_peek (tf, offset + start_off - 1, 1) == NULL)
1531         /* Incomplete last frame - don&#39;t count it. */
1532         found--;
1533       if (found == GST_MP3_TYPEFIND_TRY_HEADERS ||
1534           (found &gt;= GST_MP3_TYPEFIND_MIN_HEADERS &amp;&amp; head_data == NULL)) {
1535         /* we can make a valid guess */
1536         guint probability = found * GST_TYPE_FIND_MAXIMUM *
1537             (GST_MP3_TYPEFIND_TRY_SYNC - skipped) /
1538             GST_MP3_TYPEFIND_TRY_HEADERS / GST_MP3_TYPEFIND_TRY_SYNC;
1539 
1540         if (!headerstart
1541             &amp;&amp; probability &gt; (GST_TYPE_FIND_MINIMUM + GST_MP3_WRONG_HEADER))
1542           probability -= GST_MP3_WRONG_HEADER;
1543         if (probability &lt; GST_TYPE_FIND_MINIMUM)
1544           probability = GST_TYPE_FIND_MINIMUM;
1545         if (start_off &gt; 0)
1546           probability /= 2;
1547         if (!changed)
1548           probability = (probability + GST_TYPE_FIND_MAXIMUM) / 2;
1549 
1550         GST_INFO
1551             (&quot;audio/mpeg calculated %u  =  %u  *  %u / %u  *  (%u - %&quot;
1552             G_GUINT64_FORMAT &quot;) / %u&quot;, probability, GST_TYPE_FIND_MAXIMUM,
1553             found, GST_MP3_TYPEFIND_TRY_HEADERS, GST_MP3_TYPEFIND_TRY_SYNC,
1554             (guint64) skipped, GST_MP3_TYPEFIND_TRY_SYNC);
1555         /* make sure we&#39;re not id3 tagged */
1556         head_data = gst_type_find_peek (tf, -128, 3);
1557         if (head_data &amp;&amp; (memcmp (head_data, &quot;TAG&quot;, 3) == 0)) {
1558           probability = 0;
1559         }
1560         g_assert (probability &lt;= GST_TYPE_FIND_MAXIMUM);
1561 
1562         *found_prob = probability;
1563         if (probability &gt; 0)
1564           *found_layer = layer;
1565         return;
1566       }
1567     }
1568     data++;
1569     skipped++;
1570     size--;
1571   }
1572 }
1573 
1574 static void
1575 mp3_type_find (GstTypeFind * tf, gpointer unused)
1576 {
1577   GstTypeFindProbability prob, mid_prob;
1578   const guint8 *data;
1579   guint layer, mid_layer;
1580   guint64 length;
1581 
1582   mp3_type_find_at_offset (tf, 0, &amp;layer, &amp;prob);
1583   length = gst_type_find_get_length (tf);
1584 
1585   if (length == 0 || length == (guint64) - 1) {
1586     if (prob != 0)
1587       goto suggest;
1588     return;
1589   }
1590 
1591   /* if we&#39;re pretty certain already, skip the additional check */
1592   if (prob &gt;= GST_TYPE_FIND_LIKELY)
1593     goto suggest;
1594 
1595   mp3_type_find_at_offset (tf, length / 2, &amp;mid_layer, &amp;mid_prob);
1596 
1597   if (mid_prob &gt; 0) {
1598     if (prob == 0) {
1599       GST_LOG (&quot;detected audio/mpeg only in the middle (p=%u)&quot;, mid_prob);
1600       layer = mid_layer;
1601       prob = mid_prob;
1602       goto suggest;
1603     }
1604 
1605     if (layer != mid_layer) {
1606       GST_WARNING (&quot;audio/mpeg layer discrepancy: %u vs. %u&quot;, layer, mid_layer);
1607       return;                   /* FIXME: or should we just go with the one in the middle? */
1608     }
1609 
1610     /* detected mpeg audio both in middle of the file and at the start */
1611     prob = (prob + mid_prob) / 2;
1612     goto suggest;
1613   }
1614 
1615   /* a valid header right at the start makes it more likely
1616    * that this is actually plain mpeg-1 audio */
1617   if (prob &gt; 0) {
1618     data = gst_type_find_peek (tf, 0, 4);       /* use min. frame size? */
<a name="9" id="anc9"></a><span class="line-modified">1619     if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="line-modified">1620             &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
1621       prob = MIN (prob + 10, GST_TYPE_FIND_MAXIMUM);
<a name="10" id="anc10"></a><span class="line-modified">1622     }</span>
1623   }
1624 
1625   if (prob &gt; 0)
1626     goto suggest;
1627 
1628   return;
1629 
1630 suggest:
1631   {
1632     g_return_if_fail (layer &gt;= 1 &amp;&amp; layer &lt;= 3);
1633 
1634     gst_type_find_suggest_simple (tf, prob, &quot;audio/mpeg&quot;,
1635         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;layer&quot;, G_TYPE_INT, layer,
1636         &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1637   }
1638 }
1639 
1640 /*** audio/x-musepack ***/
1641 
1642 static GstStaticCaps musepack_caps =
1643 GST_STATIC_CAPS (&quot;audio/x-musepack, streamversion= (int) { 7, 8 }&quot;);
1644 
1645 #define MUSEPACK_CAPS (gst_static_caps_get(&amp;musepack_caps))
1646 static void
1647 musepack_type_find (GstTypeFind * tf, gpointer unused)
1648 {
1649   const guint8 *data = gst_type_find_peek (tf, 0, 4);
1650   GstTypeFindProbability prop = GST_TYPE_FIND_MINIMUM;
1651   gint streamversion = -1;
1652 
1653   if (data &amp;&amp; memcmp (data, &quot;MP+&quot;, 3) == 0) {
1654     streamversion = 7;
1655     if ((data[3] &amp; 0x7f) == 7) {
1656       prop = GST_TYPE_FIND_MAXIMUM;
1657     } else {
1658       prop = GST_TYPE_FIND_LIKELY + 10;
1659     }
1660   } else if (data &amp;&amp; memcmp (data, &quot;MPCK&quot;, 4) == 0) {
1661     streamversion = 8;
1662     prop = GST_TYPE_FIND_MAXIMUM;
1663   }
1664 
1665   if (streamversion != -1) {
1666     gst_type_find_suggest_simple (tf, prop, &quot;audio/x-musepack&quot;,
1667         &quot;streamversion&quot;, G_TYPE_INT, streamversion, NULL);
1668   }
1669 }
1670 
1671 /*** audio/x-ac3 ***/
1672 /* FIXME 0.11: should be audio/ac3, but isn&#39;t for backwards compatibility */
1673 static GstStaticCaps ac3_caps = GST_STATIC_CAPS (&quot;audio/x-ac3&quot;);
1674 
1675 #define AC3_CAPS (gst_static_caps_get(&amp;ac3_caps))
1676 
1677 static GstStaticCaps eac3_caps = GST_STATIC_CAPS (&quot;audio/x-eac3&quot;);
1678 
1679 #define EAC3_CAPS (gst_static_caps_get(&amp;eac3_caps))
1680 
1681 struct ac3_frmsize
1682 {
1683   unsigned short bit_rate;
1684   unsigned short frm_size[3];
1685 };
1686 
1687 static const struct ac3_frmsize ac3_frmsizecod_tbl[] = {
1688   {32, {64, 69, 96}},
1689   {32, {64, 70, 96}},
1690   {40, {80, 87, 120}},
1691   {40, {80, 88, 120}},
1692   {48, {96, 104, 144}},
1693   {48, {96, 105, 144}},
1694   {56, {112, 121, 168}},
1695   {56, {112, 122, 168}},
1696   {64, {128, 139, 192}},
1697   {64, {128, 140, 192}},
1698   {80, {160, 174, 240}},
1699   {80, {160, 175, 240}},
1700   {96, {192, 208, 288}},
1701   {96, {192, 209, 288}},
1702   {112, {224, 243, 336}},
1703   {112, {224, 244, 336}},
1704   {128, {256, 278, 384}},
1705   {128, {256, 279, 384}},
1706   {160, {320, 348, 480}},
1707   {160, {320, 349, 480}},
1708   {192, {384, 417, 576}},
1709   {192, {384, 418, 576}},
1710   {224, {448, 487, 672}},
1711   {224, {448, 488, 672}},
1712   {256, {512, 557, 768}},
1713   {256, {512, 558, 768}},
1714   {320, {640, 696, 960}},
1715   {320, {640, 697, 960}},
1716   {384, {768, 835, 1152}},
1717   {384, {768, 836, 1152}},
1718   {448, {896, 975, 1344}},
1719   {448, {896, 976, 1344}},
1720   {512, {1024, 1114, 1536}},
1721   {512, {1024, 1115, 1536}},
1722   {576, {1152, 1253, 1728}},
1723   {576, {1152, 1254, 1728}},
1724   {640, {1280, 1393, 1920}},
1725   {640, {1280, 1394, 1920}}
1726 };
1727 
1728 static void
1729 ac3_type_find (GstTypeFind * tf, gpointer unused)
1730 {
1731   DataScanCtx c = { 0, NULL, 0 };
1732 
1733   /* Search for an ac3 frame; not necessarily right at the start, but give it
1734    * a lower probability if not found right at the start. Check that the
1735    * frame is followed by a second frame at the expected offset.
1736    * We could also check the two ac3 CRCs, but we don&#39;t do that right now */
1737   while (c.offset &lt; 1024) {
1738     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1739       break;
1740 
1741     if (c.data[0] == 0x0b &amp;&amp; c.data[1] == 0x77) {
1742       guint bsid = c.data[5] &gt;&gt; 3;
1743 
1744       if (bsid &lt;= 8) {
1745         /* ac3 */
1746         guint fscod = c.data[4] &gt;&gt; 6;
1747         guint frmsizecod = c.data[4] &amp; 0x3f;
1748 
1749         if (fscod &lt; 3 &amp;&amp; frmsizecod &lt; 38) {
1750           DataScanCtx c_next = c;
1751           guint frame_size;
1752 
1753           frame_size = ac3_frmsizecod_tbl[frmsizecod].frm_size[fscod];
1754           GST_LOG (&quot;possible AC3 frame sync at offset %&quot;
1755               G_GUINT64_FORMAT &quot;, size=%u&quot;, c.offset, frame_size);
1756           if (data_scan_ctx_ensure_data (tf, &amp;c_next, (frame_size * 2) + 5)) {
1757             data_scan_ctx_advance (tf, &amp;c_next, frame_size * 2);
1758 
1759             if (c_next.data[0] == 0x0b &amp;&amp; c_next.data[1] == 0x77) {
1760               fscod = c_next.data[4] &gt;&gt; 6;
1761               frmsizecod = c_next.data[4] &amp; 0x3f;
1762 
1763               if (fscod &lt; 3 &amp;&amp; frmsizecod &lt; 38) {
1764                 GstTypeFindProbability prob;
1765 
1766                 GST_LOG (&quot;found second AC3 frame (size=%u), looks good&quot;,
1767                     ac3_frmsizecod_tbl[frmsizecod].frm_size[fscod]);
1768                 if (c.offset == 0)
1769                   prob = GST_TYPE_FIND_MAXIMUM;
1770                 else
1771                   prob = GST_TYPE_FIND_NEARLY_CERTAIN;
1772 
1773                 gst_type_find_suggest (tf, prob, AC3_CAPS);
1774                 return;
1775               }
1776             } else {
1777               GST_LOG (&quot;no second AC3 frame found, false sync&quot;);
1778             }
1779           }
1780         }
1781       } else if (bsid &lt;= 16 &amp;&amp; bsid &gt; 10) {
1782         /* eac3 */
1783         DataScanCtx c_next = c;
1784         guint frame_size;
1785 
1786         frame_size = (((c.data[2] &amp; 0x07) &lt;&lt; 8) + c.data[3]) + 1;
1787         GST_LOG (&quot;possible E-AC3 frame sync at offset %&quot;
1788             G_GUINT64_FORMAT &quot;, size=%u&quot;, c.offset, frame_size);
1789         if (data_scan_ctx_ensure_data (tf, &amp;c_next, (frame_size * 2) + 5)) {
1790           data_scan_ctx_advance (tf, &amp;c_next, frame_size * 2);
1791 
1792           if (c_next.data[0] == 0x0b &amp;&amp; c_next.data[1] == 0x77) {
1793             GstTypeFindProbability prob;
1794 
1795             GST_LOG (&quot;found second E-AC3 frame, looks good&quot;);
1796             if (c.offset == 0)
1797               prob = GST_TYPE_FIND_MAXIMUM;
1798             else
1799               prob = GST_TYPE_FIND_NEARLY_CERTAIN;
1800 
1801             gst_type_find_suggest (tf, prob, EAC3_CAPS);
1802             return;
1803           } else {
1804             GST_LOG (&quot;no second E-AC3 frame found, false sync&quot;);
1805           }
1806         }
1807       } else {
1808         GST_LOG (&quot;invalid AC3 BSID: %u&quot;, bsid);
1809       }
1810     }
1811     data_scan_ctx_advance (tf, &amp;c, 1);
1812   }
1813 }
1814 
1815 /*** audio/x-dts ***/
1816 static GstStaticCaps dts_caps = GST_STATIC_CAPS (&quot;audio/x-dts&quot;);
1817 #define DTS_CAPS (gst_static_caps_get (&amp;dts_caps))
1818 #define DTS_MIN_FRAMESIZE 96
1819 #define DTS_MAX_FRAMESIZE 18725 /* 16384*16/14 */
1820 
1821 static gboolean
1822 dts_parse_frame_header (DataScanCtx * c, guint * frame_size,
1823     guint * sample_rate, guint * channels, guint * depth, guint * endianness)
1824 {
1825   static const int sample_rates[16] = { 0, 8000, 16000, 32000, 0, 0, 11025,
1826     22050, 44100, 0, 0, 12000, 24000, 48000, 96000, 192000
1827   };
1828   static const guint8 channels_table[16] = { 1, 2, 2, 2, 2, 3, 3, 4, 4, 5,
1829     6, 6, 6, 7, 8, 8
1830   };
1831   guint16 hdr[8];
1832   guint32 marker;
1833   guint num_blocks, chans, lfe, i;
1834 
1835   marker = GST_READ_UINT32_BE (c-&gt;data);
1836 
1837   /* raw big endian or 14-bit big endian */
1838   if (marker == 0x7FFE8001 || marker == 0x1FFFE800) {
1839     *endianness = G_BIG_ENDIAN;
1840     for (i = 0; i &lt; G_N_ELEMENTS (hdr); ++i)
1841       hdr[i] = GST_READ_UINT16_BE (c-&gt;data + (i * sizeof (guint16)));
1842   } else
1843     /* raw little endian or 14-bit little endian */
1844   if (marker == 0xFE7F0180 || marker == 0xFF1F00E8) {
1845     *endianness = G_LITTLE_ENDIAN;
1846     for (i = 0; i &lt; G_N_ELEMENTS (hdr); ++i)
1847       hdr[i] = GST_READ_UINT16_LE (c-&gt;data + (i * sizeof (guint16)));
1848   } else {
1849     return FALSE;
1850   }
1851 
1852   GST_LOG (&quot;dts sync marker 0x%08x at offset %u&quot;, marker, (guint) c-&gt;offset);
1853 
1854   /* 14-bit mode */
1855   if (marker == 0x1FFFE800 || marker == 0xFF1F00E8) {
1856     if ((hdr[2] &amp; 0xFFF0) != 0x07F0)
1857       return FALSE;
1858     /* discard top 2 bits (2 void), shift in 2 */
1859     hdr[0] = (hdr[0] &lt;&lt; 2) | ((hdr[1] &gt;&gt; 12) &amp; 0x0003);
1860     /* discard top 4 bits (2 void, 2 shifted into hdr[0]), shift in 4 etc. */
1861     hdr[1] = (hdr[1] &lt;&lt; 4) | ((hdr[2] &gt;&gt; 10) &amp; 0x000F);
1862     hdr[2] = (hdr[2] &lt;&lt; 6) | ((hdr[3] &gt;&gt; 8) &amp; 0x003F);
1863     hdr[3] = (hdr[3] &lt;&lt; 8) | ((hdr[4] &gt;&gt; 6) &amp; 0x00FF);
1864     hdr[4] = (hdr[4] &lt;&lt; 10) | ((hdr[5] &gt;&gt; 4) &amp; 0x03FF);
1865     hdr[5] = (hdr[5] &lt;&lt; 12) | ((hdr[6] &gt;&gt; 2) &amp; 0x0FFF);
1866     hdr[6] = (hdr[6] &lt;&lt; 14) | ((hdr[7] &gt;&gt; 0) &amp; 0x3FFF);
1867     g_assert (hdr[0] == 0x7FFE &amp;&amp; hdr[1] == 0x8001);
1868     *depth = 14;
1869   } else {
1870     *depth = 16;
1871   }
1872 
1873   GST_LOG (&quot;frame header: %04x%04x%04x%04x&quot;, hdr[2], hdr[3], hdr[4], hdr[5]);
1874 
1875   num_blocks = (hdr[2] &gt;&gt; 2) &amp; 0x7F;
1876   *frame_size = (((hdr[2] &amp; 0x03) &lt;&lt; 12) | (hdr[3] &gt;&gt; 4)) + 1;
1877   chans = ((hdr[3] &amp; 0x0F) &lt;&lt; 2) | (hdr[4] &gt;&gt; 14);
1878   *sample_rate = sample_rates[(hdr[4] &gt;&gt; 10) &amp; 0x0F];
1879   lfe = (hdr[5] &gt;&gt; 9) &amp; 0x03;
1880 
1881   if (num_blocks &lt; 5 || *frame_size &lt; 96 || *sample_rate == 0)
1882     return FALSE;
1883 
1884   if (marker == 0x1FFFE800 || marker == 0xFF1F00E8)
1885     *frame_size = (*frame_size * 16) / 14;      /* FIXME: round up? */
1886 
1887   if (chans &lt; G_N_ELEMENTS (channels_table))
1888     *channels = channels_table[chans] + ((lfe) ? 1 : 0);
1889   else
1890     *channels = 0;
1891 
1892   return TRUE;
1893 }
1894 
1895 static void
1896 dts_type_find (GstTypeFind * tf, gpointer unused)
1897 {
1898   DataScanCtx c = { 0, NULL, 0 };
1899 
1900   /* Search for an dts frame; not necessarily right at the start, but give it
1901    * a lower probability if not found right at the start. Check that the
1902    * frame is followed by a second frame at the expected offset. */
1903   while (c.offset &lt;= DTS_MAX_FRAMESIZE) {
1904     guint frame_size = 0, rate = 0, chans = 0, depth = 0, endianness = 0;
1905 
1906     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, DTS_MIN_FRAMESIZE)))
1907       return;
1908 
1909     if (G_UNLIKELY (dts_parse_frame_header (&amp;c, &amp;frame_size, &amp;rate, &amp;chans,
1910                 &amp;depth, &amp;endianness))) {
1911       GstTypeFindProbability prob;
1912       DataScanCtx next_c;
1913 
1914       prob = (c.offset == 0) ? GST_TYPE_FIND_LIKELY : GST_TYPE_FIND_POSSIBLE;
1915 
1916       /* check for second frame sync */
1917       next_c = c;
1918       data_scan_ctx_advance (tf, &amp;next_c, frame_size);
1919       if (data_scan_ctx_ensure_data (tf, &amp;next_c, 4)) {
1920         GST_LOG (&quot;frame size: %u 0x%04x&quot;, frame_size, frame_size);
1921         GST_MEMDUMP (&quot;second frame sync&quot;, next_c.data, 4);
1922         if (GST_READ_UINT32_BE (c.data) == GST_READ_UINT32_BE (next_c.data))
1923           prob = GST_TYPE_FIND_MAXIMUM;
1924       }
1925 
1926       if (chans &gt; 0) {
1927         gst_type_find_suggest_simple (tf, prob, &quot;audio/x-dts&quot;,
1928             &quot;rate&quot;, G_TYPE_INT, rate, &quot;channels&quot;, G_TYPE_INT, chans,
1929             &quot;depth&quot;, G_TYPE_INT, depth, &quot;endianness&quot;, G_TYPE_INT, endianness,
1930             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1931       } else {
1932         gst_type_find_suggest_simple (tf, prob, &quot;audio/x-dts&quot;,
1933             &quot;rate&quot;, G_TYPE_INT, rate, &quot;depth&quot;, G_TYPE_INT, depth,
1934             &quot;endianness&quot;, G_TYPE_INT, endianness,
1935             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1936       }
1937 
1938       return;
1939     }
1940 
1941     data_scan_ctx_advance (tf, &amp;c, 1);
1942   }
1943 }
1944 
1945 /*** gsm ***/
1946 
1947 /* can only be detected by using the extension, in which case we use the default
1948  * GSM properties */
1949 static GstStaticCaps gsm_caps =
1950 GST_STATIC_CAPS (&quot;audio/x-gsm, rate=8000, channels=1&quot;);
1951 
1952 #define GSM_CAPS (gst_static_caps_get(&amp;gsm_caps))
1953 
1954 /*** wavpack ***/
1955 
1956 static GstStaticCaps wavpack_caps =
1957 GST_STATIC_CAPS (&quot;audio/x-wavpack, framed = (boolean) false&quot;);
1958 
1959 #define WAVPACK_CAPS (gst_static_caps_get(&amp;wavpack_caps))
1960 
1961 static GstStaticCaps wavpack_correction_caps =
1962 GST_STATIC_CAPS (&quot;audio/x-wavpack-correction, framed = (boolean) false&quot;);
1963 
1964 #define WAVPACK_CORRECTION_CAPS (gst_static_caps_get(&amp;wavpack_correction_caps))
1965 
1966 static void
1967 wavpack_type_find (GstTypeFind * tf, gpointer unused)
1968 {
1969   GstTypeFindProbability base_prob = GST_TYPE_FIND_POSSIBLE;
1970   guint64 offset;
1971   guint32 blocksize;
1972   const guint8 *data;
1973   guint count_wv, count_wvc;
1974 
1975   data = gst_type_find_peek (tf, 0, 32);
1976   if (!data)
1977     return;
1978 
1979   if (data[0] != &#39;w&#39; || data[1] != &#39;v&#39; || data[2] != &#39;p&#39; || data[3] != &#39;k&#39;)
1980     return;
1981 
1982   /* Note: wavpack blocks can be fairly large (easily 60-110k), possibly
1983    * larger than the max. limits imposed by certain typefinding elements
1984    * like id3demux or apedemux, so typefinding is most likely only going to
1985    * work in pull-mode */
1986   blocksize = GST_READ_UINT32_LE (data + 4);
1987   GST_LOG (&quot;wavpack header, blocksize=0x%04x&quot;, blocksize);
1988   /* If bigger than maximum allowed blocksize, refuse */
1989   if (blocksize &gt; 131072)
1990     return;
1991   count_wv = 0;
1992   count_wvc = 0;
1993   offset = 32;
1994   while (offset &lt; 8 + blocksize) {
1995     guint32 sublen;
1996 
1997     /* get chunk header */
1998     GST_LOG (&quot;peeking at chunk at offset 0x%04x&quot;, (guint) offset);
1999     data = gst_type_find_peek (tf, offset, 4);
2000     if (data == NULL)
2001       break;
2002     sublen = ((guint32) data[1]) &lt;&lt; 1;
2003     if (data[0] &amp; 0x80) {
2004       sublen |= (((guint32) data[2]) &lt;&lt; 9) | (((guint32) data[3]) &lt;&lt; 17);
2005       sublen += 1 + 3;          /* id + length */
2006     } else {
2007       sublen += 1 + 1;          /* id + length */
2008     }
2009     if (offset + sublen &gt; 8 + blocksize) {
2010       GST_LOG (&quot;chunk length too big (%u &gt; %&quot; G_GUINT64_FORMAT &quot;)&quot;, sublen,
2011           blocksize - offset);
2012       break;
2013     }
2014     if ((data[0] &amp; 0x20) == 0) {
2015       switch (data[0] &amp; 0x0f) {
2016         case 0xa:              /* ID_WV_BITSTREAM  */
2017         case 0xc:              /* ID_WVX_BITSTREAM */
2018           ++count_wv;
2019           break;
2020         case 0xb:              /* ID_WVC_BITSTREAM */
2021           ++count_wvc;
2022           break;
2023         default:
2024           break;
2025       }
2026       if (count_wv &gt;= 5 || count_wvc &gt;= 5)
2027         break;
2028     }
2029     offset += sublen;
2030   }
2031 
2032   /* check for second block header */
2033   data = gst_type_find_peek (tf, 8 + blocksize, 4);
2034   if (data != NULL &amp;&amp; memcmp (data, &quot;wvpk&quot;, 4) == 0) {
2035     GST_DEBUG (&quot;found second block sync&quot;);
2036     base_prob = GST_TYPE_FIND_LIKELY;
2037   }
2038 
2039   GST_DEBUG (&quot;wvc=%d, wv=%d&quot;, count_wvc, count_wv);
2040 
2041   if (count_wvc &gt; 0 &amp;&amp; count_wvc &gt; count_wv) {
2042     gst_type_find_suggest (tf,
2043         MIN (base_prob + 5 * count_wvc, GST_TYPE_FIND_NEARLY_CERTAIN),
2044         WAVPACK_CORRECTION_CAPS);
2045   } else if (count_wv &gt; 0) {
2046     gst_type_find_suggest (tf,
2047         MIN (base_prob + 5 * count_wv, GST_TYPE_FIND_NEARLY_CERTAIN),
2048         WAVPACK_CAPS);
2049   }
2050 }
2051 
2052 /*** application/postscrip ***/
2053 static GstStaticCaps postscript_caps =
2054 GST_STATIC_CAPS (&quot;application/postscript&quot;);
2055 
2056 #define POSTSCRIPT_CAPS (gst_static_caps_get(&amp;postscript_caps))
2057 
2058 static void
2059 postscript_type_find (GstTypeFind * tf, gpointer unused)
2060 {
2061   const guint8 *data = gst_type_find_peek (tf, 0, 3);
2062   if (!data)
2063     return;
2064 
2065   if (data[0] == 0x04)
2066     data++;
2067   if (data[0] == &#39;%&#39; &amp;&amp; data[1] == &#39;!&#39;)
2068     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, POSTSCRIPT_CAPS);
2069 
2070 }
2071 
2072 /*** image/svg+xml ***/
2073 static GstStaticCaps svg_caps = GST_STATIC_CAPS (&quot;image/svg+xml&quot;);
2074 
2075 #define SVG_CAPS (gst_static_caps_get(&amp;svg_caps))
2076 
2077 static void
2078 svg_type_find (GstTypeFind * tf, gpointer unused)
2079 {
2080   static const gchar svg_doctype[] = &quot;!DOCTYPE svg&quot;;
2081   static const gchar svg_tag[] = &quot;&lt;svg&quot;;
2082   DataScanCtx c = { 0, NULL, 0 };
2083 
2084   while (c.offset &lt;= 1024) {
2085     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 12)))
2086       break;
2087 
2088     if (memcmp (svg_doctype, c.data, 12) == 0) {
2089       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SVG_CAPS);
2090       return;
2091     } else if (memcmp (svg_tag, c.data, 4) == 0) {
2092       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, SVG_CAPS);
2093       return;
2094     }
2095     data_scan_ctx_advance (tf, &amp;c, 1);
2096   }
2097 }
2098 
2099 /*** multipart/x-mixed-replace mimestream ***/
2100 
2101 static GstStaticCaps multipart_caps =
2102 GST_STATIC_CAPS (&quot;multipart/x-mixed-replace&quot;);
2103 #define MULTIPART_CAPS gst_static_caps_get(&amp;multipart_caps)
2104 
2105 /* multipart/x-mixed replace is:
2106  *   &lt;maybe some whitespace&gt;--&lt;some ascii chars&gt;[\r]\n
2107  *   &lt;more ascii chars&gt;[\r]\nContent-type:&lt;more ascii&gt;[\r]\n */
2108 static void
2109 multipart_type_find (GstTypeFind * tf, gpointer unused)
2110 {
2111   const guint8 *data;
2112   const guint8 *x;
2113 
2114 #define MULTIPART_MAX_BOUNDARY_OFFSET 16
2115   data = gst_type_find_peek (tf, 0, MULTIPART_MAX_BOUNDARY_OFFSET);
2116   if (!data)
2117     return;
2118 
2119   for (x = data;
2120       x - data &lt; MULTIPART_MAX_BOUNDARY_OFFSET - 2 &amp;&amp; g_ascii_isspace (*x);
2121       x++);
2122   if (x[0] != &#39;-&#39; || x[1] != &#39;-&#39;)
2123     return;
2124 
2125   /* Could be okay, peek what should be enough for a complete header */
2126 #define MULTIPART_MAX_HEADER_SIZE 256
2127   data = gst_type_find_peek (tf, 0, MULTIPART_MAX_HEADER_SIZE);
2128   if (!data)
2129     return;
2130 
2131   for (x = data; x - data &lt; MULTIPART_MAX_HEADER_SIZE - 14; x++) {
2132     if (!isascii (*x)) {
2133       return;
2134     }
2135     if (*x == &#39;\n&#39; &amp;&amp;
2136         !g_ascii_strncasecmp (&quot;content-type:&quot;, (gchar *) x + 1, 13)) {
2137       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MULTIPART_CAPS);
2138       return;
2139     }
2140   }
2141 }
2142 
2143 /*** video/mpeg systemstream ***/
2144 static GstStaticCaps mpeg_sys_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2145     &quot;systemstream = (boolean) true, mpegversion = (int) [ 1, 2 ]&quot;);
2146 
2147 #define MPEG_SYS_CAPS gst_static_caps_get(&amp;mpeg_sys_caps)
2148 #define IS_MPEG_HEADER(data) (G_UNLIKELY((((guint8 *)(data))[0] == 0x00) &amp;&amp;  \
2149                                          (((guint8 *)(data))[1] == 0x00) &amp;&amp;  \
2150                                          (((guint8 *)(data))[2] == 0x01)))
2151 
2152 #define IS_MPEG_PACK_CODE(b) ((b) == 0xBA)
2153 #define IS_MPEG_SYS_CODE(b) ((b) == 0xBB)
2154 #define IS_MPEG_PACK_HEADER(data)       (IS_MPEG_HEADER (data) &amp;&amp;            \
2155                                          IS_MPEG_PACK_CODE (((guint8 *)(data))[3]))
2156 
2157 #define IS_MPEG_PES_CODE(b) (((b) &amp; 0xF0) == 0xE0 || ((b) &amp; 0xF0) == 0xC0 || \
2158                              (b) &gt;= 0xBD)
2159 #define IS_MPEG_PES_HEADER(data)        (IS_MPEG_HEADER (data) &amp;&amp;            \
2160                                          IS_MPEG_PES_CODE (((guint8 *)(data))[3]))
2161 
2162 #define MPEG2_MAX_PROBE_LENGTH (128 * 1024)     /* 128kB should be 64 packs of the
2163                                                  * most common 2kB pack size. */
2164 
2165 #define MPEG2_MIN_SYS_HEADERS 2
2166 #define MPEG2_MAX_SYS_HEADERS 5
2167 
2168 static gboolean
2169 mpeg_sys_is_valid_pack (GstTypeFind * tf, const guint8 * data, guint len,
2170     guint * pack_size)
2171 {
2172   /* Check the pack header @ offset for validity, assuming that the 4 byte header
2173    * itself has already been checked. */
2174   guint8 stuff_len;
2175 
2176   if (len &lt; 12)
2177     return FALSE;
2178 
2179   /* Check marker bits */
2180   if ((data[4] &amp; 0xC4) == 0x44) {
2181     /* MPEG-2 PACK */
2182     if (len &lt; 14)
2183       return FALSE;
2184 
2185     if ((data[6] &amp; 0x04) != 0x04 ||
2186         (data[8] &amp; 0x04) != 0x04 ||
2187         (data[9] &amp; 0x01) != 0x01 || (data[12] &amp; 0x03) != 0x03)
2188       return FALSE;
2189 
2190     stuff_len = data[13] &amp; 0x07;
2191 
2192     /* Check the following header bytes, if we can */
2193     if ((14 + stuff_len + 4) &lt;= len) {
2194       if (!IS_MPEG_HEADER (data + 14 + stuff_len))
2195         return FALSE;
2196     }
2197     if (pack_size)
2198       *pack_size = 14 + stuff_len;
2199     return TRUE;
2200   } else if ((data[4] &amp; 0xF1) == 0x21) {
2201     /* MPEG-1 PACK */
2202     if ((data[6] &amp; 0x01) != 0x01 ||
2203         (data[8] &amp; 0x01) != 0x01 ||
2204         (data[9] &amp; 0x80) != 0x80 || (data[11] &amp; 0x01) != 0x01)
2205       return FALSE;
2206 
2207     /* Check the following header bytes, if we can */
2208     if ((12 + 4) &lt;= len) {
2209       if (!IS_MPEG_HEADER (data + 12))
2210         return FALSE;
2211     }
2212     if (pack_size)
2213       *pack_size = 12;
2214     return TRUE;
2215   }
2216 
2217   return FALSE;
2218 }
2219 
2220 static gboolean
2221 mpeg_sys_is_valid_pes (GstTypeFind * tf, const guint8 * data, guint len,
2222     guint * pack_size)
2223 {
2224   guint pes_packet_len;
2225 
2226   /* Check the PES header at the given position, assuming the header code itself
2227    * was already checked */
2228   if (len &lt; 6)
2229     return FALSE;
2230 
2231   /* For MPEG Program streams, unbounded PES is not allowed, so we must have a
2232    * valid length present */
2233   pes_packet_len = GST_READ_UINT16_BE (data + 4);
2234   if (pes_packet_len == 0)
2235     return FALSE;
2236 
2237   /* Check the following header, if we can */
2238   if (6 + pes_packet_len + 4 &lt;= len) {
2239     if (!IS_MPEG_HEADER (data + 6 + pes_packet_len))
2240       return FALSE;
2241   }
2242 
2243   if (pack_size)
2244     *pack_size = 6 + pes_packet_len;
2245   return TRUE;
2246 }
2247 
2248 static gboolean
2249 mpeg_sys_is_valid_sys (GstTypeFind * tf, const guint8 * data, guint len,
2250     guint * pack_size)
2251 {
2252   guint sys_hdr_len;
2253 
2254   /* Check the System header at the given position, assuming the header code itself
2255    * was already checked */
2256   if (len &lt; 6)
2257     return FALSE;
2258   sys_hdr_len = GST_READ_UINT16_BE (data + 4);
2259   if (sys_hdr_len &lt; 6)
2260     return FALSE;
2261 
2262   /* Check the following header, if we can */
2263   if (6 + sys_hdr_len + 4 &lt;= len) {
2264     if (!IS_MPEG_HEADER (data + 6 + sys_hdr_len))
2265       return FALSE;
2266   }
2267 
2268   if (pack_size)
2269     *pack_size = 6 + sys_hdr_len;
2270 
2271   return TRUE;
2272 }
2273 
2274 /* calculation of possibility to identify random data as mpeg systemstream:
2275  * bits that must match in header detection:            32 (or more)
2276  * chance that random data is identifed:                1/2^32
2277  * chance that MPEG2_MIN_PACK_HEADERS headers are identified:
2278  *       1/2^(32*MPEG2_MIN_PACK_HEADERS)
2279  * chance that this happens in MPEG2_MAX_PROBE_LENGTH bytes:
2280  *       1-(1+1/2^(32*MPEG2_MIN_PACK_HEADERS)^MPEG2_MAX_PROBE_LENGTH)
2281  * for current values:
2282  *       1-(1+1/2^(32*4)^101024)
2283  *       = &lt;some_number&gt;
2284  * Since we also check marker bits and pes packet lengths, this probability is a
2285  * very coarse upper bound.
2286  */
2287 static void
2288 mpeg_sys_type_find (GstTypeFind * tf, gpointer unused)
2289 {
2290   const guint8 *data, *data0, *first_sync, *end;
2291   gint mpegversion = 0;
2292   guint pack_headers = 0;
2293   guint pes_headers = 0;
2294   guint pack_size;
2295   guint since_last_sync = 0;
2296   guint32 sync_word = 0xffffffff;
2297   guint potential_headers = 0;
2298 
2299   G_STMT_START {
2300     gint len;
2301 
2302     len = MPEG2_MAX_PROBE_LENGTH;
2303 
2304     while (len &gt;= 16) {
2305       data = gst_type_find_peek (tf, 0, 5 + len);
2306       if (data != NULL)
2307         break;
2308       len = len / 2;
2309     }
2310 
2311     if (!data)
2312       return;
2313 
2314     end = data + len;
2315   }
2316   G_STMT_END;
2317 
2318   data0 = data;
2319   first_sync = NULL;
2320 
2321   while (data &lt; end) {
2322     sync_word &lt;&lt;= 8;
2323     if (sync_word == 0x00000100) {
2324       /* Found potential sync word */
2325       if (first_sync == NULL)
2326         first_sync = data - 3;
2327 
2328       if (since_last_sync &gt; 4) {
2329         /* If more than 4 bytes since the last sync word, reset our counters,
2330          * as we&#39;re only interested in counting contiguous packets */
2331         pes_headers = pack_headers = 0;
2332       }
2333       pack_size = 0;
2334 
2335       potential_headers++;
2336       if (IS_MPEG_PACK_CODE (data[0])) {
2337         if ((data[1] &amp; 0xC0) == 0x40) {
2338           /* MPEG-2 */
2339           mpegversion = 2;
2340         } else if ((data[1] &amp; 0xF0) == 0x20) {
2341           mpegversion = 1;
2342         }
2343         if (mpegversion != 0 &amp;&amp;
2344             mpeg_sys_is_valid_pack (tf, data - 3, end - data + 3, &amp;pack_size)) {
2345           pack_headers++;
2346         }
2347       } else if (IS_MPEG_PES_CODE (data[0])) {
2348         /* PES stream */
2349         if (mpeg_sys_is_valid_pes (tf, data - 3, end - data + 3, &amp;pack_size)) {
2350           pes_headers++;
2351           if (mpegversion == 0)
2352             mpegversion = 2;
2353         }
2354       } else if (IS_MPEG_SYS_CODE (data[0])) {
2355         if (mpeg_sys_is_valid_sys (tf, data - 3, end - data + 3, &amp;pack_size)) {
2356           pack_headers++;
2357         }
2358       }
2359 
2360       /* If we found a packet with a known size, skip the bytes in it and loop
2361        * around to check the next packet. */
2362       if (pack_size != 0) {
2363         data += pack_size - 3;
2364         sync_word = 0xffffffff;
2365         since_last_sync = 0;
2366         continue;
2367       }
2368     }
2369 
2370     sync_word |= data[0];
2371     since_last_sync++;
2372     data++;
2373 
2374     /* If we have found MAX headers, and *some* were pes headers (pack headers
2375      * are optional in an mpeg system stream) then return our high-probability
2376      * result */
2377     if (pes_headers &gt; 0 &amp;&amp; (pack_headers + pes_headers) &gt; MPEG2_MAX_SYS_HEADERS)
2378       goto suggest;
2379   }
2380 
2381   /* If we at least saw MIN headers, and *some* were pes headers (pack headers
2382    * are optional in an mpeg system stream) then return a lower-probability
2383    * result */
2384   if (pes_headers &gt; 0 &amp;&amp; (pack_headers + pes_headers) &gt; MPEG2_MIN_SYS_HEADERS)
2385     goto suggest;
2386 
2387   return;
2388 suggest:
2389   {
2390     guint prob;
2391 
2392     prob = GST_TYPE_FIND_POSSIBLE + (10 * (pack_headers + pes_headers));
2393     prob = MIN (prob, GST_TYPE_FIND_MAXIMUM);
2394 
2395     /* With the above test, we get into problems when we try to typefind
2396        a MPEG stream from a small amount of data, which can happen when
2397        we get data pushed from a HTTP source. We thus make a second test
2398        to give higher probability if all the potential headers were either
2399        pack or pes headers (ie, no potential header was unrecognized). */
2400     if (potential_headers == pack_headers + pes_headers) {
2401       GST_LOG (&quot;Only %u headers, but all were recognized&quot;, potential_headers);
2402       prob += 10;
2403       prob = MIN (prob, GST_TYPE_FIND_MAXIMUM);
2404     }
2405 
2406     /* lower probability if the first packet wasn&#39;t right at the start */
2407     if (data0 != first_sync &amp;&amp; prob &gt;= 10)
2408       prob -= 10;
2409 
2410     GST_LOG (&quot;Suggesting MPEG %d system stream, %d packs, %d pes, prob %u%%&quot;,
2411         mpegversion, pack_headers, pes_headers, prob);
2412 
2413     gst_type_find_suggest_simple (tf, prob, &quot;video/mpeg&quot;,
2414         &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2415         &quot;mpegversion&quot;, G_TYPE_INT, mpegversion, NULL);
2416   }
2417 };
2418 
2419 /*** video/mpegts Transport Stream ***/
2420 static GstStaticCaps mpegts_caps = GST_STATIC_CAPS (&quot;video/mpegts, &quot;
2421     &quot;systemstream = (boolean) true, packetsize = (int) [ 188, 208 ]&quot;);
2422 #define MPEGTS_CAPS gst_static_caps_get(&amp;mpegts_caps)
2423 
2424 #define GST_MPEGTS_TYPEFIND_MIN_HEADERS 4
2425 #define GST_MPEGTS_TYPEFIND_MAX_HEADERS 10
2426 #define GST_MPEGTS_MAX_PACKET_SIZE 208
2427 #define GST_MPEGTS_TYPEFIND_SYNC_SIZE \
2428             (GST_MPEGTS_TYPEFIND_MIN_HEADERS * GST_MPEGTS_MAX_PACKET_SIZE)
2429 #define GST_MPEGTS_TYPEFIND_MAX_SYNC \
2430             (GST_MPEGTS_TYPEFIND_MAX_HEADERS * GST_MPEGTS_MAX_PACKET_SIZE)
2431 #define GST_MPEGTS_TYPEFIND_SCAN_LENGTH \
2432             (GST_MPEGTS_TYPEFIND_MAX_SYNC * 4)
2433 
2434 #define MPEGTS_HDR_SIZE 4
2435 /* Check for sync byte, error_indicator == 0 and packet has payload.
2436  * Adaptation control field (data[3] &amp; 0x30) may be zero for TS packets with
2437  * null PIDs. Still, these streams are valid TS streams (for null packets,
2438  * AFC is supposed to be 0x1, but the spec also says decoders should just
2439  * discard any packets with AFC = 0x00) */
2440 #define IS_MPEGTS_HEADER(data) (data[0] == 0x47 &amp;&amp; \
2441                                 (data[1] &amp; 0x80) == 0x00 &amp;&amp; \
2442                                 ((data[3] &amp; 0x30) != 0x00 || \
2443                                 ((data[3] &amp; 0x30) == 0x00 &amp;&amp; (data[1] &amp; 0x1f) == 0x1f &amp;&amp; (data[2] &amp; 0xff) == 0xff)))
2444 
2445 /* Helper function to search ahead at intervals of packet_size for mpegts
2446  * headers */
2447 static gint
2448 mpeg_ts_probe_headers (GstTypeFind * tf, guint64 offset, gint packet_size)
2449 {
2450   /* We always enter this function having found at least one header already */
2451   gint found = 1;
2452   const guint8 *data = NULL;
2453 
2454   GST_LOG (&quot;looking for mpeg-ts packets of size %u&quot;, packet_size);
2455   while (found &lt; GST_MPEGTS_TYPEFIND_MAX_HEADERS) {
2456     offset += packet_size;
2457 
2458     data = gst_type_find_peek (tf, offset, MPEGTS_HDR_SIZE);
2459     if (data == NULL || !IS_MPEGTS_HEADER (data))
2460       return found;
2461 
2462     found++;
2463     GST_LOG (&quot;mpeg-ts sync #%2d at offset %&quot; G_GUINT64_FORMAT, found, offset);
2464   }
2465 
2466   return found;
2467 }
2468 
2469 /* Try and detect at least 4 packets in at most 10 packets worth of
2470  * data. Need to try several possible packet sizes */
2471 static void
2472 mpeg_ts_type_find (GstTypeFind * tf, gpointer unused)
2473 {
2474   /* TS packet sizes to test: normal, DVHS packet size and
2475    * FEC with 16 or 20 byte codes packet size. */
2476   const gint pack_sizes[] = { 188, 192, 204, 208 };
2477   const guint8 *data = NULL;
2478   guint size = 0;
2479   guint64 skipped = 0;
2480 
2481   while (skipped &lt; GST_MPEGTS_TYPEFIND_SCAN_LENGTH) {
2482     if (size &lt; MPEGTS_HDR_SIZE) {
2483       data = gst_type_find_peek (tf, skipped, GST_MPEGTS_TYPEFIND_SYNC_SIZE);
2484       if (!data)
2485         break;
2486       size = GST_MPEGTS_TYPEFIND_SYNC_SIZE;
2487     }
2488 
2489     /* Have at least MPEGTS_HDR_SIZE bytes at this point */
2490     if (IS_MPEGTS_HEADER (data)) {
<a name="11" id="anc11"></a><span class="line-modified">2491       gsize p;</span>
2492 
2493       GST_LOG (&quot;possible mpeg-ts sync at offset %&quot; G_GUINT64_FORMAT, skipped);
2494 
2495       for (p = 0; p &lt; G_N_ELEMENTS (pack_sizes); p++) {
2496         gint found;
2497 
2498         /* Probe ahead at size pack_sizes[p] */
2499         found = mpeg_ts_probe_headers (tf, skipped, pack_sizes[p]);
2500         if (found &gt;= GST_MPEGTS_TYPEFIND_MIN_HEADERS) {
2501           gint probability;
2502 
2503           /* found at least 4 headers. 10 headers = MAXIMUM probability.
2504            * Arbitrarily, I assigned 10% probability for each header we
2505            * found, 40% -&gt; 100% */
2506           probability = MIN (10 * found, GST_TYPE_FIND_MAXIMUM);
2507 
2508           gst_type_find_suggest_simple (tf, probability, &quot;video/mpegts&quot;,
2509               &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2510               &quot;packetsize&quot;, G_TYPE_INT, pack_sizes[p], NULL);
2511           return;
2512         }
2513       }
2514     }
2515     data++;
2516     skipped++;
2517     size--;
2518   }
2519 }
2520 
2521 #define GST_MPEGVID_TYPEFIND_TRY_PICTURES 6
2522 #define GST_MPEGVID_TYPEFIND_TRY_SYNC (100 * 1024)      /* 100 kB */
2523 
2524 /* Scan ahead a maximum of max_extra_offset bytes until the next IS_MPEG_HEADER
2525  * offset.  After the call, offset will be after the 0x000001, i.e. at the 4th
2526  * byte of the MPEG header.  Returns TRUE if a header was found, FALSE if not.
2527  */
2528 static gboolean
2529 mpeg_find_next_header (GstTypeFind * tf, DataScanCtx * c,
2530     guint64 max_extra_offset)
2531 {
2532   guint64 extra_offset;
2533 
2534   for (extra_offset = 0; extra_offset &lt;= max_extra_offset; ++extra_offset) {
2535     if (!data_scan_ctx_ensure_data (tf, c, 4))
2536       return FALSE;
2537     if (IS_MPEG_HEADER (c-&gt;data)) {
2538       data_scan_ctx_advance (tf, c, 3);
2539       return TRUE;
2540     }
2541     data_scan_ctx_advance (tf, c, 1);
2542   }
2543   return FALSE;
2544 }
2545 
2546 /*** video/mpeg MPEG-4 elementary video stream ***/
2547 
2548 static GstStaticCaps mpeg4_video_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2549     &quot;systemstream=(boolean)false, mpegversion=4, parsed=(boolean)false&quot;);
2550 #define MPEG4_VIDEO_CAPS gst_static_caps_get(&amp;mpeg4_video_caps)
2551 
2552 /*
2553  * This typefind is based on the elementary video header defined in
2554  * http://xhelmboyx.tripod.com/formats/mpeg-layout.txt
2555  * In addition, it allows the visual object sequence header to be
2556  * absent, and even the VOS header to be absent.  In the latter case,
2557  * a number of VOPs have to be present.
2558  */
2559 static void
2560 mpeg4_video_type_find (GstTypeFind * tf, gpointer unused)
2561 {
2562   DataScanCtx c = { 0, NULL, 0 };
2563   gboolean seen_vios_at_0 = FALSE;
2564   gboolean seen_vios = FALSE;
2565   gboolean seen_vos = FALSE;
2566   gboolean seen_vol = FALSE;
2567   guint num_vop_headers = 0;
2568   guint8 sc;
2569 
2570   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2571     if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2572       break;
2573 
2574     if (!mpeg_find_next_header (tf, &amp;c,
2575             GST_MPEGVID_TYPEFIND_TRY_SYNC - c.offset))
2576       break;
2577 
2578     sc = c.data[0];
2579 
2580     /* visual_object_sequence_start_code */
2581     if (sc == 0xB0) {
2582       if (seen_vios)
2583         break;                  /* Terminate at second vios */
2584       if (c.offset == 0)
2585         seen_vios_at_0 = TRUE;
2586       seen_vios = TRUE;
2587       data_scan_ctx_advance (tf, &amp;c, 2);
2588       if (!mpeg_find_next_header (tf, &amp;c, 0))
2589         break;
2590 
2591       sc = c.data[0];
2592 
2593       /* Optional metadata */
2594       if (sc == 0xB2)
2595         if (!mpeg_find_next_header (tf, &amp;c, 24))
2596           break;
2597     }
2598 
2599     /* visual_object_start_code (consider it optional) */
2600     if (sc == 0xB5) {
2601       data_scan_ctx_advance (tf, &amp;c, 2);
2602       /* may contain ID marker and YUV clamping */
2603       if (!mpeg_find_next_header (tf, &amp;c, 7))
2604         break;
2605 
2606       sc = c.data[0];
2607     }
2608 
2609     /* video_object_start_code */
2610     if (sc &lt;= 0x1F) {
2611       if (seen_vos)
2612         break;                  /* Terminate at second vos */
2613       seen_vos = TRUE;
2614       data_scan_ctx_advance (tf, &amp;c, 2);
2615       continue;
2616     }
2617 
2618     /* video_object_layer_start_code */
2619     if (sc &gt;= 0x20 &amp;&amp; sc &lt;= 0x2F) {
2620       seen_vol = TRUE;
2621       data_scan_ctx_advance (tf, &amp;c, 5);
2622       continue;
2623     }
2624 
2625     /* video_object_plane_start_code */
2626     if (sc == 0xB6) {
2627       num_vop_headers++;
2628       data_scan_ctx_advance (tf, &amp;c, 2);
2629       continue;
2630     }
2631 
2632     /* Unknown start code. */
2633   }
2634 
2635   if (num_vop_headers &gt; 0 || seen_vol) {
2636     GstTypeFindProbability probability = 0;
2637 
2638     GST_LOG (&quot;Found %d pictures, vios: %d, vos:%d, vol:%d&quot;, num_vop_headers,
2639         seen_vios, seen_vos, seen_vol);
2640 
2641     if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vios_at_0
2642         &amp;&amp; seen_vos &amp;&amp; seen_vol)
2643       probability = GST_TYPE_FIND_MAXIMUM - 1;
2644     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vios
2645         &amp;&amp; seen_vos &amp;&amp; seen_vol)
2646       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 1;
2647     else if (seen_vios_at_0 &amp;&amp; seen_vos &amp;&amp; seen_vol)
2648       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 6;
2649     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vos
2650         &amp;&amp; seen_vol)
2651       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 6;
2652     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vol)
2653       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 9;
2654     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2655       probability = GST_TYPE_FIND_LIKELY - 1;
2656     else if (num_vop_headers &gt; 2 &amp;&amp; seen_vios &amp;&amp; seen_vos &amp;&amp; seen_vol)
2657       probability = GST_TYPE_FIND_LIKELY - 9;
2658     else if (seen_vios &amp;&amp; seen_vos &amp;&amp; seen_vol)
2659       probability = GST_TYPE_FIND_LIKELY - 20;
2660     else if (num_vop_headers &gt; 0 &amp;&amp; seen_vos &amp;&amp; seen_vol)
2661       probability = GST_TYPE_FIND_POSSIBLE;
2662     else if (num_vop_headers &gt; 0)
2663       probability = GST_TYPE_FIND_POSSIBLE - 10;
2664     else if (seen_vos &amp;&amp; seen_vol)
2665       probability = GST_TYPE_FIND_POSSIBLE - 20;
2666 
2667     gst_type_find_suggest (tf, probability, MPEG4_VIDEO_CAPS);
2668   }
2669 }
2670 
2671 /*** video/x-h263 H263 video stream ***/
2672 static GstStaticCaps h263_video_caps =
2673 GST_STATIC_CAPS (&quot;video/x-h263, variant=(string)itu&quot;);
2674 
2675 #define H263_VIDEO_CAPS gst_static_caps_get(&amp;h263_video_caps)
2676 
2677 #define H263_MAX_PROBE_LENGTH (128 * 1024)
2678 
2679 static void
2680 h263_video_type_find (GstTypeFind * tf, gpointer unused)
2681 {
2682   DataScanCtx c = { 0, NULL, 0 };
2683   guint64 data = 0xffff;        /* prevents false positive for first 2 bytes */
2684   guint64 psc = 0;
2685   guint8 ptype = 0;
2686   guint format;
2687   guint good = 0;
2688   guint bad = 0;
2689   guint pc_type, pb_mode;
2690 
2691   while (c.offset &lt; H263_MAX_PROBE_LENGTH) {
2692     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
2693       break;
2694 
2695     /* Find the picture start code */
2696     data = (data &lt;&lt; 8) + c.data[0];
2697     psc = data &amp; G_GUINT64_CONSTANT (0xfffffc0000);
2698     if (psc == 0x800000) {
2699       /* Found PSC */
2700       /* PTYPE */
2701       ptype = (data &amp; 0x3fc) &gt;&gt; 2;
2702       /* Source Format */
2703       format = ptype &amp; 0x07;
2704 
2705       /* Now that we have a Valid PSC, check if we also have a valid PTYPE and
2706          the Source Format, which should range between 1 and 5 */
2707       if (((ptype &gt;&gt; 6) == 0x2) &amp;&amp; (format &gt; 0 &amp;&amp; format &lt; 6)) {
2708         pc_type = data &amp; 0x02;
2709         pb_mode = c.data[1] &amp; 0x20 &gt;&gt; 4;
2710         if (!pc_type &amp;&amp; pb_mode)
2711           bad++;
2712         else
<a name="12" id="anc12"></a><span class="line-modified">2713           good++;</span>
2714       } else
2715         bad++;
2716 
2717       /* FIXME: maybe bail out early if we get mostly bad syncs ? */
2718     }
2719 
2720     data_scan_ctx_advance (tf, &amp;c, 1);
2721   }
2722 
2723   GST_LOG (&quot;good: %d, bad: %d&quot;, good, bad);
2724 
2725   if (good &gt; 2 * bad)
2726     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H263_VIDEO_CAPS);
2727 
2728   return;
2729 }
2730 
2731 /*** video/x-h264 H264 elementary video stream ***/
2732 
2733 static GstStaticCaps h264_video_caps =
2734 GST_STATIC_CAPS (&quot;video/x-h264,stream-format=byte-stream&quot;);
2735 
2736 #define H264_VIDEO_CAPS gst_static_caps_get(&amp;h264_video_caps)
2737 
2738 #define H264_MAX_PROBE_LENGTH (128 * 1024)      /* 128kB for HD should be enough. */
2739 
2740 static void
2741 h264_video_type_find (GstTypeFind * tf, gpointer unused)
2742 {
2743   DataScanCtx c = { 0, NULL, 0 };
2744 
2745   /* Stream consists of: a series of sync codes (00 00 00 01) followed
2746    * by NALs
2747    */
2748   gboolean seen_idr = FALSE;
2749   gboolean seen_sps = FALSE;
2750   gboolean seen_pps = FALSE;
2751   gboolean seen_ssps = FALSE;
2752   int nut, ref;
2753   int good = 0;
2754   int bad = 0;
2755 
2756   while (c.offset &lt; H264_MAX_PROBE_LENGTH) {
2757     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
2758       break;
2759 
2760     if (IS_MPEG_HEADER (c.data)) {
2761       nut = c.data[3] &amp; 0x9f;   /* forbiden_zero_bit | nal_unit_type */
2762       ref = c.data[3] &amp; 0x60;   /* nal_ref_idc */
2763 
2764       /* if forbidden bit is different to 0 won&#39;t be h264 */
2765       if (nut &gt; 0x1f) {
2766         bad++;
2767         break;
2768       }
2769 
2770       /* collect statistics about the NAL types */
2771       if ((nut &gt;= 1 &amp;&amp; nut &lt;= 13) || nut == 19) {
2772         if ((nut == 5 &amp;&amp; ref == 0) ||
2773             ((nut == 6 || (nut &gt;= 9 &amp;&amp; nut &lt;= 12)) &amp;&amp; ref != 0)) {
2774           bad++;
2775         } else {
2776           if (nut == 7)
2777             seen_sps = TRUE;
2778           else if (nut == 8)
2779             seen_pps = TRUE;
2780           else if (nut == 5)
2781             seen_idr = TRUE;
2782 
2783           good++;
2784         }
2785       } else if (nut &gt;= 14 &amp;&amp; nut &lt;= 33) {
2786         if (nut == 15) {
2787           seen_ssps = TRUE;
2788           good++;
2789         } else if (nut == 14 || nut == 20) {
2790           /* Sometimes we see NAL 14 or 20 without SSPS
2791            * if dropped into the middle of a stream -
2792            * just ignore those (don&#39;t add to bad count) */
2793           if (seen_ssps)
<a name="13" id="anc13"></a><span class="line-modified">2794             good++;</span>
2795         } else {
<a name="14" id="anc14"></a><span class="line-modified">2796           /* reserved */</span>
<span class="line-modified">2797           /* Theoretically these are good, since if they exist in the</span>
<span class="line-modified">2798              stream it merely means that a newer backwards-compatible</span>
<span class="line-modified">2799              h.264 stream.  But we should be identifying that separately. */</span>
<span class="line-modified">2800           bad++;</span>
2801         }
2802       } else {
2803         /* unspecified, application specific */
2804         /* don&#39;t consider these bad */
2805       }
2806 
2807       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps:%d&quot;, good, bad,
2808           seen_pps, seen_sps, seen_idr, seen_ssps);
2809 
2810       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_idr &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2811         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H264_VIDEO_CAPS);
2812         return;
2813       }
2814 
2815       data_scan_ctx_advance (tf, &amp;c, 4);
2816     }
2817     data_scan_ctx_advance (tf, &amp;c, 1);
2818   }
2819 
2820   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps=%d&quot;, good, bad,
2821       seen_pps, seen_sps, seen_idr, seen_ssps);
2822 
2823   if (good &gt;= 2 &amp;&amp; bad == 0) {
2824     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H264_VIDEO_CAPS);
2825   }
2826 }
2827 
2828 /*** video/x-h265 H265 elementary video stream ***/
2829 
2830 static GstStaticCaps h265_video_caps =
2831 GST_STATIC_CAPS (&quot;video/x-h265,stream-format=byte-stream&quot;);
2832 
2833 #define H265_VIDEO_CAPS gst_static_caps_get(&amp;h265_video_caps)
2834 
2835 #define H265_MAX_PROBE_LENGTH (128 * 1024)      /* 128kB for HD should be enough. */
2836 
2837 static void
2838 h265_video_type_find (GstTypeFind * tf, gpointer unused)
2839 {
2840   DataScanCtx c = { 0, NULL, 0 };
2841 
2842   /* Stream consists of: a series of sync codes (00 00 00 01) followed
2843    * by NALs
2844    */
2845   gboolean seen_irap = FALSE;
2846   gboolean seen_vps = FALSE;
2847   gboolean seen_sps = FALSE;
2848   gboolean seen_pps = FALSE;
2849   int nut;
2850   int good = 0;
2851   int bad = 0;
2852 
2853   while (c.offset &lt; H265_MAX_PROBE_LENGTH) {
2854     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 5)))
2855       break;
2856 
2857     if (IS_MPEG_HEADER (c.data)) {
2858       /* forbiden_zero_bit | nal_unit_type */
2859       nut = c.data[3] &amp; 0xfe;
2860 
2861       /* if forbidden bit is different to 0 won&#39;t be h265 */
2862       if (nut &gt; 0x7e) {
2863         bad++;
2864         break;
2865       }
2866       nut = nut &gt;&gt; 1;
2867 
2868       /* if nuh_layer_id is not zero or nuh_temporal_id_plus1 is zero then
2869        * it won&#39;t be h265 */
2870       if ((c.data[3] &amp; 0x01) || (c.data[4] &amp; 0xf8) || !(c.data[4] &amp; 0x07)) {
2871         bad++;
2872         break;
2873       }
2874 
2875       /* collect statistics about the NAL types */
2876       if ((nut &gt;= 0 &amp;&amp; nut &lt;= 9) || (nut &gt;= 16 &amp;&amp; nut &lt;= 21) || (nut &gt;= 32
2877               &amp;&amp; nut &lt;= 40)) {
2878         if (nut == 32)
2879           seen_vps = TRUE;
2880         else if (nut == 33)
2881           seen_sps = TRUE;
2882         else if (nut == 34)
2883           seen_pps = TRUE;
2884         else if (nut &gt;= 16 &amp;&amp; nut &lt;= 21) {
2885           /* BLA, IDR and CRA pictures are belongs to be IRAP picture */
2886           /* we are not counting the reserved IRAP pictures (22 and 23) to good */
2887           seen_irap = TRUE;
2888         }
2889 
2890         good++;
2891       } else if ((nut &gt;= 10 &amp;&amp; nut &lt;= 15) || (nut &gt;= 22 &amp;&amp; nut &lt;= 31)
2892           || (nut &gt;= 41 &amp;&amp; nut &lt;= 47)) {
2893         /* reserved values are counting as bad */
2894         bad++;
2895       } else {
2896         /* unspecified (48..63), application specific */
2897         /* don&#39;t consider these as bad */
2898       }
2899 
2900       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d&quot;, good, bad,
2901           seen_pps, seen_sps, seen_vps, seen_irap);
2902 
2903       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_irap &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2904         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H265_VIDEO_CAPS);
2905         return;
2906       }
2907 
2908       data_scan_ctx_advance (tf, &amp;c, 5);
2909     }
2910     data_scan_ctx_advance (tf, &amp;c, 1);
2911   }
2912 
2913   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d&quot;, good, bad,
2914       seen_pps, seen_sps, seen_vps, seen_irap);
2915 
2916   if (good &gt;= 2 &amp;&amp; bad == 0) {
2917     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H265_VIDEO_CAPS);
2918   }
2919 }
2920 
2921 /*** video/mpeg video stream ***/
2922 
2923 static GstStaticCaps mpeg_video_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2924     &quot;systemstream = (boolean) false&quot;);
2925 #define MPEG_VIDEO_CAPS gst_static_caps_get(&amp;mpeg_video_caps)
2926 
2927 /*
2928  * Idea is the same as MPEG system stream typefinding: We check each
2929  * byte of the stream to see if - from that point on - the stream
2930  * matches a predefined set of marker bits as defined in the MPEG
2931  * video specs.
2932  *
2933  * I&#39;m sure someone will do a chance calculation here too.
2934  */
2935 
2936 static void
2937 mpeg_video_stream_type_find (GstTypeFind * tf, gpointer unused)
2938 {
2939   DataScanCtx c = { 0, NULL, 0 };
2940   gboolean seen_seq_at_0 = FALSE;
2941   gboolean seen_seq = FALSE;
2942   gboolean seen_gop = FALSE;
2943   guint64 last_pic_offset = 0;
<a name="15" id="anc15"></a><span class="line-modified">2944   gint num_pic_headers = 0;</span>
2945   gint found = 0;
2946 
2947   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2948     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2949       break;
2950 
2951     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
2952       break;
2953 
2954     if (!IS_MPEG_HEADER (c.data))
2955       goto next;
2956 
2957     /* a pack header indicates that this isn&#39;t an elementary stream */
2958     if (c.data[3] == 0xBA &amp;&amp; mpeg_sys_is_valid_pack (tf, c.data, c.size, NULL))
2959       return;
2960 
2961     /* do we have a sequence header? */
2962     if (c.data[3] == 0xB3) {
2963       seen_seq_at_0 = seen_seq_at_0 || (c.offset == 0);
2964       seen_seq = TRUE;
2965       data_scan_ctx_advance (tf, &amp;c, 4 + 8);
2966       continue;
2967     }
2968 
2969     /* or a GOP header */
2970     if (c.data[3] == 0xB8) {
2971       seen_gop = TRUE;
2972       data_scan_ctx_advance (tf, &amp;c, 8);
2973       continue;
2974     }
2975 
2976     /* but what we&#39;d really like to see is a picture header */
2977     if (c.data[3] == 0x00) {
2978       ++num_pic_headers;
2979       last_pic_offset = c.offset;
2980       data_scan_ctx_advance (tf, &amp;c, 8);
2981       continue;
2982     }
2983 
2984     /* ... each followed by a slice header with slice_vertical_pos=1 that&#39;s
2985      * not too far away from the previously seen picture header. */
2986     if (c.data[3] == 0x01 &amp;&amp; num_pic_headers &gt; found &amp;&amp;
2987         (c.offset - last_pic_offset) &gt;= 4 &amp;&amp;
2988         (c.offset - last_pic_offset) &lt;= 64) {
2989       data_scan_ctx_advance (tf, &amp;c, 4);
2990       found += 1;
2991       continue;
2992     }
2993 
2994   next:
2995 
2996     data_scan_ctx_advance (tf, &amp;c, 1);
2997   }
2998 
2999   if (found &gt; 0 || seen_seq) {
3000     GstTypeFindProbability probability = 0;
3001 
3002     GST_LOG (&quot;Found %d pictures, seq:%d, gop:%d&quot;, found, seen_seq, seen_gop);
3003 
3004     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_seq &amp;&amp; seen_gop)
3005       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 1;
3006     else if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_seq)
3007       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 9;
3008     else if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
3009       probability = GST_TYPE_FIND_LIKELY;
3010     else if (seen_seq_at_0 &amp;&amp; seen_gop &amp;&amp; found &gt; 2)
3011       probability = GST_TYPE_FIND_LIKELY - 10;
3012     else if (seen_seq &amp;&amp; seen_gop &amp;&amp; found &gt; 2)
3013       probability = GST_TYPE_FIND_LIKELY - 20;
3014     else if (seen_seq_at_0 &amp;&amp; found &gt; 0)
3015       probability = GST_TYPE_FIND_POSSIBLE;
3016     else if (seen_seq &amp;&amp; found &gt; 0)
3017       probability = GST_TYPE_FIND_POSSIBLE - 5;
3018     else if (found &gt; 0)
3019       probability = GST_TYPE_FIND_POSSIBLE - 10;
3020     else if (seen_seq)
3021       probability = GST_TYPE_FIND_POSSIBLE - 20;
3022 
3023     gst_type_find_suggest_simple (tf, probability, &quot;video/mpeg&quot;,
3024         &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE,
3025         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
3026   }
3027 }
3028 
3029 /*** audio/x-aiff ***/
3030 
3031 static GstStaticCaps aiff_caps = GST_STATIC_CAPS (&quot;audio/x-aiff&quot;);
3032 
3033 #define AIFF_CAPS gst_static_caps_get(&amp;aiff_caps)
3034 static void
3035 aiff_type_find (GstTypeFind * tf, gpointer unused)
3036 {
3037   const guint8 *data = gst_type_find_peek (tf, 0, 16);
3038 
3039   if (data &amp;&amp; memcmp (data, &quot;FORM&quot;, 4) == 0) {
3040     data += 8;
3041     if (memcmp (data, &quot;AIFF&quot;, 4) == 0 || memcmp (data, &quot;AIFC&quot;, 4) == 0)
3042       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, AIFF_CAPS);
3043   }
3044 }
3045 
3046 /*** audio/x-svx ***/
3047 
3048 static GstStaticCaps svx_caps = GST_STATIC_CAPS (&quot;audio/x-svx&quot;);
3049 
3050 #define SVX_CAPS gst_static_caps_get(&amp;svx_caps)
3051 static void
3052 svx_type_find (GstTypeFind * tf, gpointer unused)
3053 {
3054   const guint8 *data = gst_type_find_peek (tf, 0, 16);
3055 
3056   if (data &amp;&amp; memcmp (data, &quot;FORM&quot;, 4) == 0) {
3057     data += 8;
3058     if (memcmp (data, &quot;8SVX&quot;, 4) == 0 || memcmp (data, &quot;16SV&quot;, 4) == 0)
3059       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SVX_CAPS);
3060   }
3061 }
3062 
3063 /*** audio/x-shorten ***/
3064 
3065 static GstStaticCaps shn_caps = GST_STATIC_CAPS (&quot;audio/x-shorten&quot;);
3066 
3067 #define SHN_CAPS gst_static_caps_get(&amp;shn_caps)
3068 static void
3069 shn_type_find (GstTypeFind * tf, gpointer unused)
3070 {
3071   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3072 
3073   if (data &amp;&amp; memcmp (data, &quot;ajkg&quot;, 4) == 0) {
3074     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SHN_CAPS);
3075   }
3076   data = gst_type_find_peek (tf, -8, 8);
3077   if (data &amp;&amp; memcmp (data, &quot;SHNAMPSK&quot;, 8) == 0) {
3078     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SHN_CAPS);
3079   }
3080 }
3081 
3082 /*** application/x-ape ***/
3083 
3084 static GstStaticCaps ape_caps = GST_STATIC_CAPS (&quot;application/x-ape&quot;);
3085 
3086 #define APE_CAPS gst_static_caps_get(&amp;ape_caps)
3087 static void
3088 ape_type_find (GstTypeFind * tf, gpointer unused)
3089 {
3090   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3091 
3092   if (data &amp;&amp; memcmp (data, &quot;MAC &quot;, 4) == 0) {
3093     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY + 10, APE_CAPS);
3094   }
3095 }
3096 
3097 /*** ISO FORMATS ***/
3098 
3099 /*** audio/x-m4a ***/
3100 
3101 static GstStaticCaps m4a_caps = GST_STATIC_CAPS (&quot;audio/x-m4a&quot;);
3102 
3103 #define M4A_CAPS (gst_static_caps_get(&amp;m4a_caps))
3104 static void
3105 m4a_type_find (GstTypeFind * tf, gpointer unused)
3106 {
3107   const guint8 *data = gst_type_find_peek (tf, 4, 8);
3108 
3109   if (data &amp;&amp; (memcmp (data, &quot;ftypM4A &quot;, 8) == 0)) {
3110     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, M4A_CAPS);
3111   }
3112 }
3113 
3114 /*** application/x-3gp ***/
3115 
3116 /* The Q is there because variables can&#39;t start with a number. */
3117 static GstStaticCaps q3gp_caps = GST_STATIC_CAPS (&quot;application/x-3gp&quot;);
3118 #define Q3GP_CAPS (gst_static_caps_get(&amp;q3gp_caps))
3119 
3120 static const gchar *
3121 q3gp_type_find_get_profile (const guint8 * data)
3122 {
3123   switch (GST_MAKE_FOURCC (data[0], data[1], data[2], 0)) {
3124     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;g&#39;, 0):
3125       return &quot;general&quot;;
3126     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;p&#39;, 0):
3127       return &quot;basic&quot;;
3128     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;s&#39;, 0):
3129       return &quot;streaming-server&quot;;
3130     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;r&#39;, 0):
3131       return &quot;progressive-download&quot;;
3132     default:
3133       break;
3134   }
3135   return NULL;
3136 }
3137 
3138 static void
3139 q3gp_type_find (GstTypeFind * tf, gpointer unused)
3140 {
3141   const gchar *profile;
3142   guint32 ftyp_size = 0;
<a name="16" id="anc16"></a><span class="line-modified">3143   guint32 offset = 0;</span>
3144   const guint8 *data = NULL;
3145 
3146   if ((data = gst_type_find_peek (tf, 0, 12)) == NULL) {
3147     return;
3148   }
3149 
3150   data += 4;
3151   if (memcmp (data, &quot;ftyp&quot;, 4) != 0) {
3152     return;
3153   }
3154 
3155   /* check major brand */
3156   data += 4;
3157   if ((profile = q3gp_type_find_get_profile (data))) {
3158     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
3159         &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
3160     return;
3161   }
3162 
3163   /* check compatible brands */
3164   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3165     ftyp_size = GST_READ_UINT32_BE (data);
3166   }
3167   if ((data = gst_type_find_peek (tf, 0, ftyp_size)) != NULL) {
3168     for (offset = 16; offset + 4 &lt; ftyp_size; offset += 4) {
3169       if ((profile = q3gp_type_find_get_profile (data + offset))) {
<a name="17" id="anc17"></a><span class="line-modified">3170         gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-modified">3171             &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="line-modified">3172         return;</span>
<span class="line-added">3173       }</span>
3174     }
3175   }
<a name="18" id="anc18"></a>
3176 
3177   return;
3178 
3179 }
3180 
3181 /*** video/mj2 and image/jp2 ***/
3182 static GstStaticCaps mj2_caps = GST_STATIC_CAPS (&quot;video/mj2&quot;);
3183 
3184 #define MJ2_CAPS gst_static_caps_get(&amp;mj2_caps)
3185 
3186 static GstStaticCaps jp2_caps = GST_STATIC_CAPS (&quot;image/jp2&quot;);
3187 
3188 #define JP2_CAPS gst_static_caps_get(&amp;jp2_caps)
3189 
3190 static void
3191 jp2_type_find (GstTypeFind * tf, gpointer unused)
3192 {
3193   const guint8 *data;
3194 
3195   data = gst_type_find_peek (tf, 0, 24);
3196   if (!data)
3197     return;
3198 
3199   /* jp2 signature */
3200   if (memcmp (data, &quot;\000\000\000\014jP  \015\012\207\012&quot;, 12) != 0)
3201     return;
3202 
3203   /* check ftyp box */
3204   data += 12;
3205   if (memcmp (data + 4, &quot;ftyp&quot;, 4) == 0) {
3206     if (memcmp (data + 8, &quot;jp2 &quot;, 4) == 0)
3207       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, JP2_CAPS);
3208     else if (memcmp (data + 8, &quot;mjp2&quot;, 4) == 0)
3209       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MJ2_CAPS);
3210   }
3211 }
3212 
3213 
3214 static GstStaticCaps jpc_caps = GST_STATIC_CAPS (&quot;image/x-jpc&quot;);
3215 
3216 #define JPC_CAPS gst_static_caps_get(&amp;jpc_caps)
3217 
3218 static void
3219 jpc_type_find (GstTypeFind * tf, gpointer unused)
3220 {
3221   gboolean found_cod = FALSE;
3222   gboolean found_qcd = FALSE;
3223   gboolean found_sot = FALSE;
3224   const guint8 *data;
3225   gint offset = 0;
3226   const guint8 soc_siz[] = { 0xff, 0x4f, 0xff, 0x51 };
3227 
3228 #define GST_TYPE_FIND_JPC_MARKER_SOT  0xFF90
3229 #define GST_TYPE_FIND_JPC_MARKER_COD  0xFF52
3230 #define GST_TYPE_FIND_JPC_MARKER_QCD  0xFF5C
3231 #define GST_TYPE_FIND_JPC_MARKER_COC  0xFF53
3232 #define GST_TYPE_FIND_JPC_MARKER_RGN  0xFF5E
3233 #define GST_TYPE_FIND_JPC_MARKER_QCC  0xFF5D
3234 #define GST_TYPE_FIND_JPC_MARKER_POC  0xFF5F
3235 #define GST_TYPE_FIND_JPC_MARKER_PLM  0xFF57
3236 #define GST_TYPE_FIND_JPC_MARKER_PPM  0xFF60
3237 #define GST_TYPE_FIND_JPC_MARKER_TLM  0xFF55
3238 #define GST_TYPE_FIND_JPC_MARKER_CRG  0xFF63
3239 #define GST_TYPE_FIND_JPC_MARKER_COM  0xFF64
3240 #define GST_TYPE_FIND_JPC_MARKER_CBD  0xFF78
3241 #define GST_TYPE_FIND_JPC_MARKER_MCC  0xFF75
3242 #define GST_TYPE_FIND_JPC_MARKER_MCT  0xFF74
3243 #define GST_TYPE_FIND_JPC_MARKER_MCO  0xFF77
3244 
3245 
3246   /* SOC marker + SIZ marker */
3247   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3248     if (memcmp (data, soc_siz, 4) != 0)
3249       return;
3250     offset += 4;
3251   } else {
3252     return;
3253   }
3254 
3255   while (!found_sot) {
3256 
3257     /* skip actual marker data */
3258     if ((data = gst_type_find_peek (tf, offset, 2)) != NULL) {
3259       offset += GST_READ_UINT16_BE (data);
3260     } else {
3261       return;
3262     }
3263 
3264     /* read marker */
3265     if ((data = gst_type_find_peek (tf, offset, 2)) != NULL) {
3266       guint16 marker = GST_READ_UINT16_BE (data);
3267       switch (marker) {
3268         case GST_TYPE_FIND_JPC_MARKER_SOT:
3269           found_sot = TRUE;
3270           break;
3271         case GST_TYPE_FIND_JPC_MARKER_COD:
3272           found_cod = TRUE;
3273           break;
3274         case GST_TYPE_FIND_JPC_MARKER_QCD:
3275           found_qcd = TRUE;
3276           break;
3277           /* optional header markers */
3278         case GST_TYPE_FIND_JPC_MARKER_COC:
3279         case GST_TYPE_FIND_JPC_MARKER_RGN:
3280         case GST_TYPE_FIND_JPC_MARKER_QCC:
3281         case GST_TYPE_FIND_JPC_MARKER_POC:
3282         case GST_TYPE_FIND_JPC_MARKER_PLM:
3283         case GST_TYPE_FIND_JPC_MARKER_PPM:
3284         case GST_TYPE_FIND_JPC_MARKER_TLM:
3285         case GST_TYPE_FIND_JPC_MARKER_CRG:
3286         case GST_TYPE_FIND_JPC_MARKER_COM:
3287         case GST_TYPE_FIND_JPC_MARKER_CBD:
3288         case GST_TYPE_FIND_JPC_MARKER_MCC:
3289         case GST_TYPE_FIND_JPC_MARKER_MCT:
3290         case GST_TYPE_FIND_JPC_MARKER_MCO:
3291           break;
3292           /* unrecognized marker */
3293         default:
3294           return;
3295       }
3296       offset += 2;
3297     } else {
3298       return;
3299     }
3300   }
3301 
3302   if (found_cod &amp;&amp; found_qcd &amp;&amp; found_sot)
3303     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, JPC_CAPS);
3304 }
3305 
3306 
3307 /*** video/quicktime ***/
3308 
3309 static GstStaticCaps qt_caps = GST_STATIC_CAPS (&quot;video/quicktime&quot;);
3310 
3311 #define QT_CAPS gst_static_caps_get(&amp;qt_caps)
3312 #define STRNCMP(x,y,z) (strncmp ((char*)(x), (char*)(y), z))
3313 
3314 /* FIXME 0.11: go through http://www.ftyps.com/ */
3315 static void
3316 qt_type_find (GstTypeFind * tf, gpointer unused)
3317 {
3318   const guint8 *data;
3319   guint tip = 0;
3320   guint64 offset = 0;
3321   guint64 size;
3322   const gchar *variant = NULL;
3323 
3324   while ((data = gst_type_find_peek (tf, offset, 12)) != NULL) {
3325     guint64 new_offset;
3326 
3327     if (STRNCMP (&amp;data[4], &quot;ftypqt  &quot;, 8) == 0) {
3328       tip = GST_TYPE_FIND_MAXIMUM;
3329       break;
3330     }
3331 
3332     if (STRNCMP (&amp;data[4], &quot;ftypisom&quot;, 8) == 0 ||
3333         STRNCMP (&amp;data[4], &quot;ftypavc1&quot;, 8) == 0 ||
3334         STRNCMP (&amp;data[4], &quot;ftypmp42&quot;, 8) == 0) {
3335       tip = GST_TYPE_FIND_MAXIMUM;
3336       variant = &quot;iso&quot;;
3337       break;
3338     }
3339 
3340     if (STRNCMP (&amp;data[4], &quot;ftypisml&quot;, 8) == 0 ||
3341         STRNCMP (&amp;data[4], &quot;ftypavc3&quot;, 8) == 0) {
3342       tip = GST_TYPE_FIND_MAXIMUM;
3343       variant = &quot;iso-fragmented&quot;;
3344       break;
3345     }
3346 
3347     if (STRNCMP (&amp;data[4], &quot;ftypccff&quot;, 8) == 0) {
3348       tip = GST_TYPE_FIND_MAXIMUM;
3349       variant = &quot;ccff&quot;;
3350       break;
3351     }
3352 
3353     /* box/atom types that are in common with ISO base media file format */
3354     if (STRNCMP (&amp;data[4], &quot;moov&quot;, 4) == 0 ||
3355         STRNCMP (&amp;data[4], &quot;mdat&quot;, 4) == 0 ||
3356         STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0 ||
3357         STRNCMP (&amp;data[4], &quot;free&quot;, 4) == 0 ||
3358         STRNCMP (&amp;data[4], &quot;uuid&quot;, 4) == 0 ||
3359         STRNCMP (&amp;data[4], &quot;moof&quot;, 4) == 0 ||
3360         STRNCMP (&amp;data[4], &quot;skip&quot;, 4) == 0) {
3361       if (tip == 0) {
3362         tip = GST_TYPE_FIND_LIKELY;
3363       } else {
3364         tip = GST_TYPE_FIND_NEARLY_CERTAIN;
3365       }
3366     }
3367     /* other box/atom types, apparently quicktime specific */
3368     else if (STRNCMP (&amp;data[4], &quot;pnot&quot;, 4) == 0 ||
3369         STRNCMP (&amp;data[4], &quot;PICT&quot;, 4) == 0 ||
3370         STRNCMP (&amp;data[4], &quot;wide&quot;, 4) == 0 ||
3371         STRNCMP (&amp;data[4], &quot;prfl&quot;, 4) == 0) {
3372       tip = GST_TYPE_FIND_MAXIMUM;
3373       break;
3374     } else {
3375       tip = 0;
3376       break;
3377     }
3378 
3379     size = GST_READ_UINT32_BE (data);
3380     if (size + offset &gt;= G_MAXINT64)
3381       break;
3382     /* check compatible brands rather than ever expaning major brands above */
3383     if ((STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0) &amp;&amp; (size &gt;= 16)) {
3384       data = gst_type_find_peek (tf, offset, size);
<a name="19" id="anc19"></a><span class="line-modified">3385       if (data == NULL)</span>
<span class="line-modified">3386         goto done;</span>
3387       new_offset = 12;
3388       while (new_offset + 4 &lt;= size) {
3389         if (STRNCMP (&amp;data[new_offset], &quot;isom&quot;, 4) == 0 ||
3390             STRNCMP (&amp;data[new_offset], &quot;dash&quot;, 4) == 0 ||
3391             STRNCMP (&amp;data[new_offset], &quot;avc1&quot;, 4) == 0 ||
3392             STRNCMP (&amp;data[new_offset], &quot;avc3&quot;, 4) == 0 ||
3393             STRNCMP (&amp;data[new_offset], &quot;mp41&quot;, 4) == 0 ||
3394             STRNCMP (&amp;data[new_offset], &quot;mp42&quot;, 4) == 0) {
3395           tip = GST_TYPE_FIND_MAXIMUM;
3396           variant = &quot;iso&quot;;
3397           goto done;
3398         }
3399         new_offset += 4;
3400       }
3401     }
3402     if (size == 1) {
3403       const guint8 *sizedata;
3404 
3405       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3406       if (sizedata == NULL)
3407         break;
3408 
3409       size = GST_READ_UINT64_BE (sizedata);
3410     } else {
3411       if (size &lt; 8)
3412         break;
3413     }
3414     new_offset = offset + size;
3415     if (new_offset &lt;= offset)
3416       break;
3417     if (new_offset + 16 &gt;= G_MAXINT64)
3418       break;
3419     offset = new_offset;
3420   }
3421 
3422 done:
3423   if (tip &gt; 0) {
3424     if (variant) {
3425       GstCaps *caps = gst_caps_copy (QT_CAPS);
3426 
3427       gst_caps_set_simple (caps, &quot;variant&quot;, G_TYPE_STRING, variant, NULL);
3428       gst_type_find_suggest (tf, tip, caps);
3429       gst_caps_unref (caps);
3430     } else {
3431       gst_type_find_suggest (tf, tip, QT_CAPS);
3432     }
3433   }
3434 };
3435 
3436 
3437 /*** image/x-quicktime ***/
3438 
3439 static GstStaticCaps qtif_caps = GST_STATIC_CAPS (&quot;image/x-quicktime&quot;);
3440 
3441 #define QTIF_CAPS gst_static_caps_get(&amp;qtif_caps)
3442 
3443 /* how many atoms we check before we give up */
3444 #define QTIF_MAXROUNDS 25
3445 
3446 static void
3447 qtif_type_find (GstTypeFind * tf, gpointer unused)
3448 {
3449   const guint8 *data;
3450   gboolean found_idsc = FALSE;
3451   gboolean found_idat = FALSE;
3452   guint64 offset = 0;
3453   guint rounds = 0;
3454 
3455   while ((data = gst_type_find_peek (tf, offset, 8)) != NULL) {
3456     guint64 size;
3457 
3458     size = GST_READ_UINT32_BE (data);
3459     if (size == 1) {
3460       const guint8 *sizedata;
3461 
3462       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3463       if (sizedata == NULL)
3464         break;
3465 
3466       size = GST_READ_UINT64_BE (sizedata);
3467     }
3468     if (size &lt; 8)
3469       break;
3470 
3471     if (STRNCMP (data + 4, &quot;idsc&quot;, 4) == 0)
3472       found_idsc = TRUE;
3473     if (STRNCMP (data + 4, &quot;idat&quot;, 4) == 0)
3474       found_idat = TRUE;
3475 
3476     if (found_idsc &amp;&amp; found_idat) {
3477       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, QTIF_CAPS);
3478       return;
3479     }
3480 
3481     offset += size;
3482     if (offset + 8 &gt;= G_MAXINT64)
3483       break;
3484     if (++rounds &gt; QTIF_MAXROUNDS)
3485       break;
3486   }
3487 
3488   if (found_idsc || found_idat) {
3489     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, QTIF_CAPS);
3490     return;
3491   }
3492 };
3493 
3494 /*** audio/x-mod ***/
3495 
3496 static GstStaticCaps mod_caps = GST_STATIC_CAPS (&quot;audio/x-mod&quot;);
3497 
3498 #define MOD_CAPS gst_static_caps_get(&amp;mod_caps)
3499 /* FIXME: M15 CheckType to do */
3500 static void
3501 mod_type_find (GstTypeFind * tf, gpointer unused)
3502 {
3503   const guint8 *data;
3504   GstTypeFindProbability probability;
3505   const char *mod_type = NULL;
3506 
3507   /* MOD */
3508   if ((data = gst_type_find_peek (tf, 1080, 4)) != NULL) {
3509     /* Protracker and variants */
3510     if ((memcmp (data, &quot;M.K.&quot;, 4) == 0) ||
3511         (memcmp (data, &quot;M!K!&quot;, 4) == 0) ||
3512         (memcmp (data, &quot;M&amp;K!&quot;, 4) == 0) || (memcmp (data, &quot;N.T.&quot;, 4) == 0) ||
3513         /* Star Tracker */
3514         (memcmp (data, &quot;FLT&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3515         (memcmp (data, &quot;EXO&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3516         /* Oktalyzer (Amiga) */
3517         (memcmp (data, &quot;OKTA&quot;, 4) == 0) || (memcmp (data, &quot;OCTA&quot;, 4) == 0) ||
3518         /* Oktalyser (Atari) */
3519         (memcmp (data, &quot;CD81&quot;, 4) == 0) ||
3520         /* Taketracker */
3521         (memcmp (data, &quot;TDZ&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3522         /* Fasttracker */
3523         (memcmp (data + 1, &quot;CHN&quot;, 3) == 0 &amp;&amp; isdigit (data[0])) ||
3524         /* Fasttracker or Taketracker */
3525         (memcmp (data + 2, &quot;CH&quot;, 2) == 0 &amp;&amp; isdigit (data[0])
3526             &amp;&amp; isdigit (data[1])) || (memcmp (data + 2, &quot;CN&quot;, 2) == 0
3527             &amp;&amp; isdigit (data[0]) &amp;&amp; isdigit (data[1]))) {
3528       mod_type = &quot;mod&quot;;
3529       probability = GST_TYPE_FIND_MAXIMUM;
3530       goto suggest_audio_mod_caps;
3531     }
3532   }
3533   /* J2B (Jazz Jackrabbit 2) */
3534   if ((data = gst_type_find_peek (tf, 0, 8)) != NULL) {
3535     if ((memcmp (data, &quot;MUSE\xDE\xAD&quot;, 4) == 0) &amp;&amp;
3536         ((memcmp (data + 6, &quot;\xBE\xEF&quot;, 2) == 0) ||
3537             (memcmp (data + 6, &quot;\xBA\xBE&quot;, 2) == 0))) {
3538       mod_type = &quot;j2b&quot;;
3539       probability = GST_TYPE_FIND_MAXIMUM;
3540       goto suggest_audio_mod_caps;
3541     }
3542   }
3543   /* AMS (Velvet Studio) */
3544   if ((data = gst_type_find_peek (tf, 0, 7)) != NULL) {
3545     if (memcmp (data, &quot;AMShdr\x1A&quot;, 7) == 0) {
3546       mod_type = &quot;velvet-ams&quot;;
3547       probability = GST_TYPE_FIND_MAXIMUM;
3548       goto suggest_audio_mod_caps;
3549     }
3550   }
3551   /* AMS (Extreme Tracker) */
3552   if ((data = gst_type_find_peek (tf, 0, 9)) != NULL) {
3553     if ((memcmp (data, &quot;Extreme&quot;, 7) == 0) &amp;&amp; (data[8] == 1)) {
3554       mod_type = &quot;extreme-ams&quot;;
3555       probability = GST_TYPE_FIND_LIKELY;
3556       goto suggest_audio_mod_caps;
3557     }
3558   }
3559   /* ULT (Ultratracker) */
3560   if ((data = gst_type_find_peek (tf, 0, 14)) != NULL) {
3561     if (memcmp (data, &quot;MAS_UTrack_V00&quot;, 14) == 0) {
3562       mod_type = &quot;ult&quot;;
3563       probability = GST_TYPE_FIND_MAXIMUM;
3564       goto suggest_audio_mod_caps;
3565     }
3566   }
3567   /* DIGI (DigiBooster) */
3568   if ((data = gst_type_find_peek (tf, 0, 20)) != NULL) {
3569     if (memcmp (data, &quot;DIGI Booster module\0&quot;, 20) == 0) {
3570       mod_type = &quot;digi&quot;;
3571       probability = GST_TYPE_FIND_MAXIMUM;
3572       goto suggest_audio_mod_caps;
3573     }
3574   }
3575   /* PTM (PolyTracker) */
3576   if ((data = gst_type_find_peek (tf, 0x2C, 4)) != NULL) {
3577     if (memcmp (data, &quot;PTMF&quot;, 4) == 0) {
3578       mod_type = &quot;ptm&quot;;
3579       probability = GST_TYPE_FIND_LIKELY;
3580       goto suggest_audio_mod_caps;
3581     }
3582   }
3583   /* XM */
3584   if ((data = gst_type_find_peek (tf, 0, 38)) != NULL) {
3585     if ((memcmp (data, &quot;Extended Module: &quot;, 17) == 0) &amp;&amp; (data[37] == 0x1A)) {
3586       mod_type = &quot;xm&quot;;
3587       probability = GST_TYPE_FIND_MAXIMUM;
3588       goto suggest_audio_mod_caps;
3589     }
3590   }
3591   /* OKT */
3592   if (data || (data = gst_type_find_peek (tf, 0, 8)) != NULL) {
3593     if (memcmp (data, &quot;OKTASONG&quot;, 8) == 0) {
3594       mod_type = &quot;okt&quot;;
3595       probability = GST_TYPE_FIND_MAXIMUM;
3596       goto suggest_audio_mod_caps;
3597     }
3598   }
3599   /* Various formats with a 4-byte magic ID at the beginning of the file */
3600   if (data || (data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3601     /* PSM (Protracker Studio PSM) */
3602     if (memcmp (data, &quot;PSM&quot;, 3) == 0) {
3603       unsigned char fbyte = data[3];
3604       if ((fbyte == &#39; &#39;) || (fbyte == 254)) {
3605         mod_type = &quot;psm&quot;;
3606         probability = GST_TYPE_FIND_MAXIMUM;
3607         goto suggest_audio_mod_caps;
3608       }
3609     }
3610     /* 669 */
3611     if ((memcmp (data, &quot;if&quot;, 2) == 0) || (memcmp (data, &quot;JN&quot;, 2) == 0)) {
3612       mod_type = &quot;669&quot;;
3613       probability = GST_TYPE_FIND_LIKELY;
3614       goto suggest_audio_mod_caps;
3615     }
3616     /* AMF */
3617     if ((memcmp (data, &quot;AMF&quot;, 3) == 0) &amp;&amp; (data[3] &gt; 10) &amp;&amp; (data[3] &lt; 14)) {
3618       mod_type = &quot;dsmi-amf&quot;;
3619       probability = GST_TYPE_FIND_MAXIMUM;
3620       goto suggest_audio_mod_caps;
3621     }
<a name="20" id="anc20"></a><span class="line-modified">3622     /* IT */</span>
3623     if (memcmp (data, &quot;IMPM&quot;, 4) == 0) {
3624       mod_type = &quot;it&quot;;
3625       probability = GST_TYPE_FIND_MAXIMUM;
3626       goto suggest_audio_mod_caps;
3627     }
3628     /* DBM (DigiBooster Pro) */
3629     if (memcmp (data, &quot;DBM0&quot;, 4) == 0) {
3630       mod_type = &quot;dbm&quot;;
3631       probability = GST_TYPE_FIND_MAXIMUM;
3632       goto suggest_audio_mod_caps;
3633     }
3634     /* MDL (DigiTrakker) */
3635     if (memcmp (data, &quot;DMDL&quot;, 4) == 0) {
3636       mod_type = &quot;mdl&quot;;
3637       probability = GST_TYPE_FIND_MAXIMUM;
3638       goto suggest_audio_mod_caps;
3639     }
3640     /* MT2 (MadTracker 2.0) */
3641     if (memcmp (data, &quot;MT20&quot;, 4) == 0) {
3642       mod_type = &quot;mt2&quot;;
3643       probability = GST_TYPE_FIND_MAXIMUM;
3644       goto suggest_audio_mod_caps;
3645     }
3646     /* DMF (X-Tracker) */
3647     if (memcmp (data, &quot;DDMF&quot;, 4) == 0) {
3648       mod_type = &quot;dmf&quot;;
3649       probability = GST_TYPE_FIND_MAXIMUM;
3650       goto suggest_audio_mod_caps;
3651     }
<a name="21" id="anc21"></a><span class="line-modified">3652     /* MED */</span>
3653     if ((memcmp (data, &quot;MMD0&quot;, 4) == 0) || (memcmp (data, &quot;MMD1&quot;, 4) == 0)) {
3654       mod_type = &quot;med&quot;;
3655       probability = GST_TYPE_FIND_MAXIMUM;
3656       goto suggest_audio_mod_caps;
3657     }
<a name="22" id="anc22"></a><span class="line-modified">3658     /* MTM */</span>
3659     if (memcmp (data, &quot;MTM&quot;, 3) == 0) {
3660       mod_type = &quot;mtm&quot;;
3661       probability = GST_TYPE_FIND_MAXIMUM;
3662       goto suggest_audio_mod_caps;
3663     }
3664     /* DSM */
3665     if (memcmp (data, &quot;RIFF&quot;, 4) == 0) {
3666       const guint8 *data2 = gst_type_find_peek (tf, 8, 4);
3667 
3668       if (data2) {
3669         if (memcmp (data2, &quot;DSMF&quot;, 4) == 0) {
3670           mod_type = &quot;dsm&quot;;
3671           probability = GST_TYPE_FIND_MAXIMUM;
3672           goto suggest_audio_mod_caps;
3673         }
3674       }
3675     }
3676     /* FAR (Farandole) */
3677     if (memcmp (data, &quot;FAR\xFE&quot;, 4) == 0) {
3678       mod_type = &quot;far&quot;;
3679       probability = GST_TYPE_FIND_MAXIMUM;
3680       goto suggest_audio_mod_caps;
3681     }
3682     /* FAM */
3683     if (memcmp (data, &quot;FAM\xFE&quot;, 4) == 0) {
3684       const guint8 *data2 = gst_type_find_peek (tf, 44, 3);
3685 
3686       if (data2) {
3687         if (memcmp (data2, &quot;compare&quot;, 3) == 0) {
3688           mod_type = &quot;fam&quot;;
3689           probability = GST_TYPE_FIND_MAXIMUM;
3690           goto suggest_audio_mod_caps;
3691         }
3692         /* otherwise do not suggest anything */
3693       } else {
3694         mod_type = &quot;fam&quot;;
3695         probability = GST_TYPE_FIND_LIKELY;
3696         goto suggest_audio_mod_caps;
3697       }
3698     }
3699     /* GDM */
3700     if (memcmp (data, &quot;GDM\xFE&quot;, 4) == 0) {
3701       const guint8 *data2 = gst_type_find_peek (tf, 71, 4);
3702 
3703       if (data2) {
3704         if (memcmp (data2, &quot;GMFS&quot;, 4) == 0) {
3705           mod_type = &quot;gdm&quot;;
3706           probability = GST_TYPE_FIND_MAXIMUM;
3707           goto suggest_audio_mod_caps;
3708         }
3709         /* otherwise do not suggest anything */
3710       } else {
3711         mod_type = &quot;gdm&quot;;
3712         probability = GST_TYPE_FIND_LIKELY;
3713         goto suggest_audio_mod_caps;
3714       }
3715     }
3716     /* UMX */
3717     if (memcmp (data, &quot;\xC1\x83\x2A\x9E&quot;, 4) == 0) {
3718       mod_type = &quot;umx&quot;;
3719       probability = GST_TYPE_FIND_POSSIBLE;
3720       goto suggest_audio_mod_caps;
<a name="23" id="anc23"></a><span class="line-modified">3721     }</span>
3722   }
3723   /* FAR (Farandole) (secondary detection) */
3724   if ((data = gst_type_find_peek (tf, 44, 3)) != NULL) {
3725     if (memcmp (data, &quot;\x0D\x0A\x1A&quot;, 3) == 0) {
3726       mod_type = &quot;far&quot;;
3727       probability = GST_TYPE_FIND_POSSIBLE;
3728       goto suggest_audio_mod_caps;
3729     }
3730   }
3731   /* IMF */
3732   if ((data = gst_type_find_peek (tf, 60, 4)) != NULL) {
3733     if (memcmp (data, &quot;IM10&quot;, 4) == 0) {
3734       mod_type = &quot;imf&quot;;
3735       probability = GST_TYPE_FIND_MAXIMUM;
3736       goto suggest_audio_mod_caps;
3737     }
3738   }
3739   /* S3M */
3740   if ((data = gst_type_find_peek (tf, 44, 4)) != NULL) {
3741     if (memcmp (data, &quot;SCRM&quot;, 4) == 0) {
3742       mod_type = &quot;s3m&quot;;
3743       probability = GST_TYPE_FIND_MAXIMUM;
3744       goto suggest_audio_mod_caps;
3745     }
3746   }
3747   /* STM */
3748   if ((data = gst_type_find_peek (tf, 20, 8)) != NULL) {
3749     if (g_ascii_strncasecmp ((gchar *) data, &quot;!Scream!&quot;, 8) == 0 ||
3750         g_ascii_strncasecmp ((gchar *) data, &quot;BMOD2STM&quot;, 8) == 0) {
3751       const guint8 *id, *stmtype;
3752 
3753       if ((id = gst_type_find_peek (tf, 28, 1)) == NULL)
3754         return;
3755       if ((stmtype = gst_type_find_peek (tf, 29, 1)) == NULL)
3756         return;
3757       if (*id == 0x1A &amp;&amp; *stmtype == 2) {
3758         mod_type = &quot;stm&quot;;
3759         probability = GST_TYPE_FIND_MAXIMUM;
3760         goto suggest_audio_mod_caps;
3761       }
3762     }
3763   }
3764   /* AMF */
3765   if ((data = gst_type_find_peek (tf, 0, 19)) != NULL) {
3766     if (memcmp (data, &quot;ASYLUM Music Format&quot;, 19) == 0) {
3767       mod_type = &quot;asylum-amf&quot;;
3768       probability = GST_TYPE_FIND_MAXIMUM;
3769       goto suggest_audio_mod_caps;
3770     }
3771   }
3772 
3773 suggest_audio_mod_caps:
3774   if (mod_type != NULL) {
3775     GstCaps *caps = gst_caps_new_simple (&quot;audio/x-mod&quot;,
3776         &quot;type&quot;, G_TYPE_STRING, mod_type, NULL);
3777 
3778     gst_type_find_suggest (tf, probability, caps);
3779     gst_caps_unref (caps);
3780   }
3781 }
3782 
3783 /*** application/x-shockwave-flash ***/
3784 
3785 static GstStaticCaps swf_caps =
3786 GST_STATIC_CAPS (&quot;application/x-shockwave-flash&quot;);
3787 #define SWF_CAPS (gst_static_caps_get(&amp;swf_caps))
3788 static void
3789 swf_type_find (GstTypeFind * tf, gpointer unused)
3790 {
3791   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3792 
3793   if (data &amp;&amp; (data[0] == &#39;F&#39; || data[0] == &#39;C&#39;) &amp;&amp;
3794       data[1] == &#39;W&#39; &amp;&amp; data[2] == &#39;S&#39;) {
3795     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SWF_CAPS);
3796   }
3797 }
3798 
3799 /*** application/vnd.ms-sstr+xml ***/
3800 
3801 static void
3802 mss_manifest_load_utf16 (gunichar2 * utf16_ne, const guint8 * utf16_data,
3803     gsize data_size, guint data_endianness)
3804 {
3805   memcpy (utf16_ne, utf16_data, data_size);
3806   if (data_endianness != G_BYTE_ORDER) {
3807     guint i;
3808 
3809     for (i = 0; i &lt; data_size / 2; ++i)
3810       utf16_ne[i] = GUINT16_SWAP_LE_BE (utf16_ne[i]);
3811   }
3812 }
3813 
3814 static GstStaticCaps mss_manifest_caps =
3815 GST_STATIC_CAPS (&quot;application/vnd.ms-sstr+xml&quot;);
3816 #define MSS_MANIFEST_CAPS (gst_static_caps_get(&amp;mss_manifest_caps))
3817 static void
3818 mss_manifest_type_find (GstTypeFind * tf, gpointer unused)
3819 {
3820   gunichar2 utf16_ne[512];
3821   const guint8 *data;
3822   guint data_endianness = 0;
3823   glong n_read = 0, size = 0;
3824   guint length;
3825   gchar *utf8;
3826   gboolean utf8_bom_detected = FALSE;
3827 
3828   if (xml_check_first_element (tf, &quot;SmoothStreamingMedia&quot;, 20, TRUE)) {
3829     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3830     return;
3831   }
3832 
3833   length = gst_type_find_get_length (tf);
3834 
<a name="24" id="anc24"></a><span class="line-modified">3835   /* try detecting the charset */</span>
3836   data = gst_type_find_peek (tf, 0, 3);
3837 
<a name="25" id="anc25"></a><span class="line-modified">3838   if (data == NULL)</span>
<span class="line-modified">3839     return;</span>
3840 
<a name="26" id="anc26"></a><span class="line-modified">3841   /* look for a possible BOM */</span>
3842   if (data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF)
3843     utf8_bom_detected = TRUE;
3844   else if (data[0] == 0xFF &amp;&amp; data[1] == 0xFE)
3845     data_endianness = G_LITTLE_ENDIAN;
3846   else if (data[0] == 0xFE &amp;&amp; data[1] == 0xFF)
3847     data_endianness = G_BIG_ENDIAN;
3848   else
3849     return;
3850 
<a name="27" id="anc27"></a><span class="line-modified">3851   /* try a default that should be enough */</span>
<span class="line-modified">3852   if (length == 0)</span>
<span class="line-modified">3853     length = 512;</span>
3854   else if (length &lt; 64)
3855     return;
3856   else                          /* the first few bytes should be enough */
3857     length = MIN (1024, length);
3858 
<a name="28" id="anc28"></a><span class="line-modified">3859   data = gst_type_find_peek (tf, 0, length);</span>
3860 
3861   if (data == NULL)
3862     return;
3863 
<a name="29" id="anc29"></a><span class="line-modified">3864   /* skip the BOM */</span>
<span class="line-modified">3865   data += 2;</span>
<span class="line-modified">3866   length -= 2;</span>
3867 
3868   if (utf8_bom_detected) {
3869     /* skip last byte of the BOM */
3870     data++;
3871     length--;
3872 
3873     if (xml_check_first_element_from_data (data, length,
<a name="30" id="anc30"></a><span class="line-modified">3874             &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
3875       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3876   } else {
3877     length = GST_ROUND_DOWN_2 (length);
3878 
3879     /* convert to native endian UTF-16 */
3880     mss_manifest_load_utf16 (utf16_ne, data, length, data_endianness);
3881 
3882     /* and now convert to UTF-8 */
3883     utf8 = g_utf16_to_utf8 (utf16_ne, length / 2, &amp;n_read, &amp;size, NULL);
3884     if (utf8 != NULL &amp;&amp; n_read &gt; 0) {
3885       if (xml_check_first_element_from_data ((const guint8 *) utf8, size,
3886               &quot;SmoothStreamingMedia&quot;, 20, TRUE))
3887         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
<a name="31" id="anc31"></a>


3888     }
<a name="32" id="anc32"></a><span class="line-added">3889     g_free (utf8);</span>
<span class="line-added">3890   }</span>
<span class="line-added">3891 }</span>
3892 
3893 /*** image/jpeg ***/
3894 
3895 #define JPEG_MARKER_IS_START_OF_FRAME(x) \
3896     ((x)&gt;=0xc0 &amp;&amp; (x) &lt;= 0xcf &amp;&amp; (x)!=0xc4 &amp;&amp; (x)!=0xc8 &amp;&amp; (x)!=0xcc)
3897 
3898 static GstStaticCaps jpeg_caps = GST_STATIC_CAPS (&quot;image/jpeg&quot;);
3899 
3900 #define JPEG_CAPS (gst_static_caps_get(&amp;jpeg_caps))
3901 static void
3902 jpeg_type_find (GstTypeFind * tf, gpointer unused)
3903 {
3904   GstTypeFindProbability prob = GST_TYPE_FIND_POSSIBLE;
3905   DataScanCtx c = { 0, NULL, 0 };
3906   GstCaps *caps;
3907   guint num_markers;
3908 
3909   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 2)))
3910     return;
3911 
3912   if (c.data[0] != 0xff || c.data[1] != 0xd8)
3913     return;
3914 
3915   num_markers = 1;
3916   data_scan_ctx_advance (tf, &amp;c, 2);
3917 
3918   caps = gst_caps_copy (JPEG_CAPS);
3919 
3920   while (data_scan_ctx_ensure_data (tf, &amp;c, 4) &amp;&amp; c.offset &lt; (200 * 1024)) {
3921     guint16 len;
3922     guint8 marker;
3923 
3924     if (c.data[0] != 0xff)
3925       break;
3926 
3927     marker = c.data[1];
3928     if (G_UNLIKELY (marker == 0xff)) {
3929       data_scan_ctx_advance (tf, &amp;c, 1);
3930       continue;
3931     }
3932 
3933     data_scan_ctx_advance (tf, &amp;c, 2);
3934 
3935     /* we assume all markers we&#39;ll see before SOF have a payload length; if
3936      * that&#39;s not the case we&#39;ll just detect a false sync and bail out, but
3937      * still report POSSIBLE probability */
3938     len = GST_READ_UINT16_BE (c.data);
3939 
3940     GST_LOG (&quot;possible JPEG marker 0x%02x (@0x%04x), segment length %u&quot;,
3941         marker, (guint) c.offset, len);
3942 
3943     if (!data_scan_ctx_ensure_data (tf, &amp;c, len))
3944       break;
3945 
3946     if (marker == 0xc4 ||       /* DEFINE_HUFFMAN_TABLES          */
3947         marker == 0xcc ||       /* DEFINE_ARITHMETIC_CONDITIONING */
3948         marker == 0xdb ||       /* DEFINE_QUANTIZATION_TABLES     */
3949         marker == 0xdd ||       /* DEFINE_RESTART_INTERVAL        */
3950         marker == 0xfe) {       /* COMMENT                        */
3951       data_scan_ctx_advance (tf, &amp;c, len);
3952       ++num_markers;
3953     } else if (marker == 0xe0 &amp;&amp; len &gt;= (2 + 4) &amp;&amp;      /* APP0 */
3954         data_scan_ctx_memcmp (tf, &amp;c, 2, &quot;JFIF&quot;, 4)) {
3955       GST_LOG (&quot;found JFIF tag&quot;);
3956       prob = GST_TYPE_FIND_MAXIMUM;
3957       data_scan_ctx_advance (tf, &amp;c, len);
3958       ++num_markers;
3959       /* we continue until we find a start of frame marker */
3960     } else if (marker == 0xe1 &amp;&amp; len &gt;= (2 + 4) &amp;&amp;      /* APP1 */
3961         data_scan_ctx_memcmp (tf, &amp;c, 2, &quot;Exif&quot;, 4)) {
3962       GST_LOG (&quot;found Exif tag&quot;);
3963       prob = GST_TYPE_FIND_MAXIMUM;
3964       data_scan_ctx_advance (tf, &amp;c, len);
3965       ++num_markers;
3966       /* we continue until we find a start of frame marker */
3967     } else if (marker &gt;= 0xe0 &amp;&amp; marker &lt;= 0xef) {      /* APPn */
3968       data_scan_ctx_advance (tf, &amp;c, len);
3969       ++num_markers;
3970     } else if (JPEG_MARKER_IS_START_OF_FRAME (marker) &amp;&amp; len &gt;= (2 + 8)) {
3971       int h, w;
3972 
3973       h = GST_READ_UINT16_BE (c.data + 2 + 1);
3974       w = GST_READ_UINT16_BE (c.data + 2 + 1 + 2);
3975       if (h == 0 || w == 0) {
3976         GST_WARNING (&quot;bad width %u and/or height %u in SOF header&quot;, w, h);
3977         break;
3978       }
3979 
3980       GST_LOG (&quot;SOF at offset %&quot; G_GUINT64_FORMAT &quot;, num_markers=%d, &quot;
3981           &quot;WxH=%dx%d&quot;, c.offset - 2, num_markers, w, h);
3982 
3983       if (num_markers &gt;= 5 || prob == GST_TYPE_FIND_MAXIMUM)
3984         prob = GST_TYPE_FIND_MAXIMUM;
3985       else
3986         prob = GST_TYPE_FIND_LIKELY;
3987 
3988       gst_caps_set_simple (caps, &quot;width&quot;, G_TYPE_INT, w,
3989           &quot;height&quot;, G_TYPE_INT, h, &quot;sof-marker&quot;, G_TYPE_INT, marker &amp; 0xf,
3990           NULL);
3991 
3992       break;
3993     } else {
3994       GST_WARNING (&quot;bad length or unexpected JPEG marker 0xff 0x%02x&quot;, marker);
3995       break;
3996     }
3997   }
3998 
3999   gst_type_find_suggest (tf, prob, caps);
4000   gst_caps_unref (caps);
4001 }
4002 
4003 /*** image/bmp ***/
4004 
4005 static GstStaticCaps bmp_caps = GST_STATIC_CAPS (&quot;image/bmp&quot;);
4006 
4007 #define BMP_CAPS (gst_static_caps_get(&amp;bmp_caps))
4008 static void
4009 bmp_type_find (GstTypeFind * tf, gpointer unused)
4010 {
4011   DataScanCtx c = { 0, NULL, 0 };
4012   guint32 struct_size, w, h, planes, bpp;
4013 
4014   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 54)))
4015     return;
4016 
4017   if (c.data[0] != &#39;B&#39; || c.data[1] != &#39;M&#39;)
4018     return;
4019 
4020   /* skip marker + size */
4021   data_scan_ctx_advance (tf, &amp;c, 2 + 4);
4022 
4023   /* reserved, must be 0 */
4024   if (c.data[0] != 0 || c.data[1] != 0 || c.data[2] != 0 || c.data[3] != 0)
4025     return;
4026 
4027   data_scan_ctx_advance (tf, &amp;c, 2 + 2);
4028 
4029   /* offset to start of image data in bytes (check for sanity) */
4030   GST_LOG (&quot;offset=%u&quot;, GST_READ_UINT32_LE (c.data));
4031   if (GST_READ_UINT32_LE (c.data) &gt; (10 * 1024 * 1024))
4032     return;
4033 
4034   struct_size = GST_READ_UINT32_LE (c.data + 4);
4035   GST_LOG (&quot;struct_size=%u&quot;, struct_size);
4036 
4037   data_scan_ctx_advance (tf, &amp;c, 4 + 4);
4038 
4039   if (struct_size == 0x0C) {
4040     w = GST_READ_UINT16_LE (c.data);
4041     h = GST_READ_UINT16_LE (c.data + 2);
4042     planes = GST_READ_UINT16_LE (c.data + 2 + 2);
4043     bpp = GST_READ_UINT16_LE (c.data + 2 + 2 + 2);
4044   } else if (struct_size == 40 || struct_size == 64 || struct_size == 108
4045       || struct_size == 124 || struct_size == 0xF0) {
4046     w = GST_READ_UINT32_LE (c.data);
4047     h = GST_READ_UINT32_LE (c.data + 4);
4048     planes = GST_READ_UINT16_LE (c.data + 4 + 4);
4049     bpp = GST_READ_UINT16_LE (c.data + 4 + 4 + 2);
4050   } else {
4051     return;
4052   }
4053 
4054   /* image sizes sanity check */
4055   GST_LOG (&quot;w=%u, h=%u, planes=%u, bpp=%u&quot;, w, h, planes, bpp);
4056   if (w == 0 || w &gt; 0xfffff || h == 0 || h &gt; 0xfffff || planes != 1 ||
4057       (bpp != 1 &amp;&amp; bpp != 4 &amp;&amp; bpp != 8 &amp;&amp; bpp != 16 &amp;&amp; bpp != 24 &amp;&amp; bpp != 32))
4058     return;
4059 
4060   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, &quot;image/bmp&quot;,
4061       &quot;width&quot;, G_TYPE_INT, w, &quot;height&quot;, G_TYPE_INT, h, &quot;bpp&quot;, G_TYPE_INT, bpp,
4062       NULL);
4063 }
4064 
4065 /*** image/tiff ***/
4066 static GstStaticCaps tiff_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4067     &quot;endianness = (int) { BIG_ENDIAN, LITTLE_ENDIAN }&quot;);
4068 #define TIFF_CAPS (gst_static_caps_get(&amp;tiff_caps))
4069 static GstStaticCaps tiff_be_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4070     &quot;endianness = (int) BIG_ENDIAN&quot;);
4071 #define TIFF_BE_CAPS (gst_static_caps_get(&amp;tiff_be_caps))
4072 static GstStaticCaps tiff_le_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4073     &quot;endianness = (int) LITTLE_ENDIAN&quot;);
4074 #define TIFF_LE_CAPS (gst_static_caps_get(&amp;tiff_le_caps))
4075 static void
4076 tiff_type_find (GstTypeFind * tf, gpointer ununsed)
4077 {
4078   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4079   guint8 le_header[4] = { 0x49, 0x49, 0x2A, 0x00 };
4080   guint8 be_header[4] = { 0x4D, 0x4D, 0x00, 0x2A };
4081 
4082   if (data) {
4083     if (memcmp (data, le_header, 4) == 0) {
4084       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TIFF_LE_CAPS);
4085     } else if (memcmp (data, be_header, 4) == 0) {
4086       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TIFF_BE_CAPS);
4087     }
4088   }
4089 }
4090 
4091 /*** image/x-exr ***/
4092 static GstStaticCaps exr_caps = GST_STATIC_CAPS (&quot;image/x-exr&quot;);
4093 #define EXR_CAPS (gst_static_caps_get(&amp;exr_caps))
4094 static void
4095 exr_type_find (GstTypeFind * tf, gpointer ununsed)
4096 {
4097   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4098 
4099   if (data) {
4100     guint32 flags;
4101 
4102     if (GST_READ_UINT32_LE (data) != 0x01312f76)
4103       return;
4104 
4105     flags = GST_READ_UINT32_LE (data + 4);
4106     if ((flags &amp; 0xff) != 1 &amp;&amp; (flags &amp; 0xff) != 2)
4107       return;
4108 
4109     /* If bit 9 is set, bit 11 and 12 must be 0 */
4110     if ((flags &amp; 0x200) &amp;&amp; (flags &amp; 0x1800))
4111       return;
4112 
4113     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, EXR_CAPS);
4114   }
4115 }
4116 
4117 
4118 /*** PNM ***/
4119 
4120 static GstStaticCaps pnm_caps = GST_STATIC_CAPS (&quot;image/x-portable-bitmap; &quot;
4121     &quot;image/x-portable-graymap; image/x-portable-pixmap; &quot;
4122     &quot;image/x-portable-anymap&quot;);
4123 
4124 #define PNM_CAPS (gst_static_caps_get(&amp;pnm_caps))
4125 
4126 #define IS_PNM_WHITESPACE(c) \
4127     ((c) == &#39; &#39; || (c) == &#39;\r&#39; || (c) == &#39;\n&#39; || (c) == &#39;t&#39;)
4128 
4129 static void
4130 pnm_type_find (GstTypeFind * tf, gpointer ununsed)
4131 {
4132   const gchar *media_type = NULL;
4133   DataScanCtx c = { 0, NULL, 0 };
4134   guint h = 0, w = 0;
4135 
4136   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 16)))
4137     return;
4138 
4139   /* see http://en.wikipedia.org/wiki/Netpbm_format */
4140   if (c.data[0] != &#39;P&#39; || c.data[1] &lt; &#39;1&#39; || c.data[1] &gt; &#39;7&#39; ||
4141       !IS_PNM_WHITESPACE (c.data[2]) ||
4142       (c.data[3] != &#39;#&#39; &amp;&amp; c.data[3] &lt; &#39;0&#39; &amp;&amp; c.data[3] &gt; &#39;9&#39;))
4143     return;
4144 
4145   switch (c.data[1]) {
4146     case &#39;1&#39;:
4147       media_type = &quot;image/x-portable-bitmap&quot;;   /* ASCII */
4148       break;
4149     case &#39;2&#39;:
4150       media_type = &quot;image/x-portable-graymap&quot;;  /* ASCII */
4151       break;
4152     case &#39;3&#39;:
4153       media_type = &quot;image/x-portable-pixmap&quot;;   /* ASCII */
4154       break;
4155     case &#39;4&#39;:
4156       media_type = &quot;image/x-portable-bitmap&quot;;   /* Raw */
4157       break;
4158     case &#39;5&#39;:
4159       media_type = &quot;image/x-portable-graymap&quot;;  /* Raw */
4160       break;
4161     case &#39;6&#39;:
4162       media_type = &quot;image/x-portable-pixmap&quot;;   /* Raw */
4163       break;
4164     case &#39;7&#39;:
4165       media_type = &quot;image/x-portable-anymap&quot;;
4166       break;
4167     default:
4168       g_return_if_reached ();
4169   }
4170 
4171   /* try to extract width and height as well */
4172   if (c.data[1] != &#39;7&#39;) {
4173     gchar s[64] = { 0, }
4174     , sep1, sep2;
4175 
4176     /* need to skip any comment lines first */
4177     data_scan_ctx_advance (tf, &amp;c, 3);
4178 
4179     if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4180       return;
4181 
4182     while (c.data[0] == &#39;#&#39;) {  /* we know there&#39;s still data left */
4183       data_scan_ctx_advance (tf, &amp;c, 1);
4184       if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4185         return;
4186 
4187       while (c.data[0] != &#39;\n&#39; &amp;&amp; c.data[0] != &#39;\r&#39;) {
4188         data_scan_ctx_advance (tf, &amp;c, 1);
4189         if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4190           return;
4191       }
4192       data_scan_ctx_advance (tf, &amp;c, 1);
4193       GST_LOG (&quot;skipped comment line in PNM header&quot;);
4194       if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4195         return;
4196     }
4197 
4198     if (!data_scan_ctx_ensure_data (tf, &amp;c, 32) &amp;&amp;
4199         !data_scan_ctx_ensure_data (tf, &amp;c, 4)) {
4200       return;
4201     }
4202 
4203     /* need to NUL-terminate data for sscanf */
4204     memcpy (s, c.data, MIN (sizeof (s) - 1, c.size));
4205     if (sscanf (s, &quot;%u%c%u%c&quot;, &amp;w, &amp;sep1, &amp;h, &amp;sep2) == 4 &amp;&amp;
4206         IS_PNM_WHITESPACE (sep1) &amp;&amp; IS_PNM_WHITESPACE (sep2) &amp;&amp;
4207         w &gt; 0 &amp;&amp; w &lt; G_MAXINT &amp;&amp; h &gt; 0 &amp;&amp; h &lt; G_MAXINT) {
4208       GST_LOG (&quot;extracted PNM width and height: %dx%d&quot;, w, h);
4209     } else {
4210       w = 0;
4211       h = 0;
4212     }
4213   } else {
4214     /* FIXME: extract width + height for anymaps too */
4215   }
4216 
4217   if (w &gt; 0 &amp;&amp; h &gt; 0) {
4218     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, media_type,
4219         &quot;width&quot;, G_TYPE_INT, w, &quot;height&quot;, G_TYPE_INT, h, NULL);
4220   } else {
4221     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, media_type, NULL);
4222   }
4223 }
4224 
4225 static GstStaticCaps sds_caps = GST_STATIC_CAPS (&quot;audio/x-sds&quot;);
4226 
4227 #define SDS_CAPS (gst_static_caps_get(&amp;sds_caps))
4228 static void
4229 sds_type_find (GstTypeFind * tf, gpointer ununsed)
4230 {
4231   const guint8 *data = gst_type_find_peek (tf, 0, 4);
4232   guint8 mask[4] = { 0xFF, 0xFF, 0x80, 0xFF };
4233   guint8 match[4] = { 0xF0, 0x7E, 0, 0x01 };
4234   gint x;
4235 
4236   if (data) {
4237     for (x = 0; x &lt; 4; x++) {
4238       if ((data[x] &amp; mask[x]) != match[x]) {
4239         return;
4240       }
4241     }
4242     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SDS_CAPS);
4243   }
4244 }
4245 
4246 static GstStaticCaps ircam_caps = GST_STATIC_CAPS (&quot;audio/x-ircam&quot;);
4247 
4248 #define IRCAM_CAPS (gst_static_caps_get(&amp;ircam_caps))
4249 static void
4250 ircam_type_find (GstTypeFind * tf, gpointer ununsed)
4251 {
4252   const guint8 *data = gst_type_find_peek (tf, 0, 4);
4253   guint8 mask[4] = { 0xFF, 0xFF, 0xF8, 0xFF };
4254   guint8 match[4] = { 0x64, 0xA3, 0x00, 0x00 };
4255   gint x;
4256   gboolean matched = TRUE;
4257 
4258   if (!data) {
4259     return;
4260   }
4261   for (x = 0; x &lt; 4; x++) {
4262     if ((data[x] &amp; mask[x]) != match[x]) {
4263       matched = FALSE;
4264     }
4265   }
4266   if (matched) {
4267     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, IRCAM_CAPS);
4268     return;
4269   }
4270   /* now try the reverse version */
4271   matched = TRUE;
4272   for (x = 0; x &lt; 4; x++) {
4273     if ((data[x] &amp; mask[3 - x]) != match[3 - x]) {
4274       matched = FALSE;
4275     }
4276   }
4277 }
4278 
4279 /*** Matroska/WebM ***/
4280 
4281 #define EBML_HEADER           0x1A45DFA3
4282 #define EBML_VERSION          0x4286
4283 #define EBML_DOCTYPE          0x4282
4284 #define EBML_DOCTYPE_VERSION  0x4287
4285 #define MATROSKA_SEGMENT      0x18538067
4286 #define MATROSKA_CLUSTER      0x1F43B675
4287 #define MATROSKA_TRACKS       0x1654AE6B
4288 #define MATROSKA_TRACK_ENTRY  0xAE
4289 #define MATROSKA_TRACK_TYPE   0x83
4290 #define MATROSKA_STEREO_MODE  0x53B8
4291 
4292 #define EBML_MAX_LEN (2 * 1024 * 1024)
4293 
4294 typedef enum
4295 {
4296   EBML_DOCTYPE_UNKNOWN = 0,
4297   EBML_DOCTYPE_MATROSKA,
4298   EBML_DOCTYPE_WEBM
4299 } GstEbmlDocType;
4300 
4301 typedef struct
4302 {
4303   GstEbmlDocType doctype;
4304   guint audio;
4305   guint video;
4306   guint other;
4307   guint video_stereo;
4308   guint chunks;
4309   guint tracks_ok;              /* if we&#39;ve seen and fully parsed the TRACKS element */
4310 } GstMatroskaInfo;
4311 
4312 static inline guint
4313 ebml_read_chunk_header (GstTypeFind * tf, DataScanCtx * c, guint max_size,
4314     guint32 * id, guint64 * size)
4315 {
4316   guint64 mask;
4317   guint msbit_set, i, len, id_len;
4318 
4319   if (c-&gt;size &lt; 12 || max_size &lt; 1)
4320     return 0;
4321 
4322   /* element ID */
4323   *id = c-&gt;data[0];
4324   if ((c-&gt;data[0] &amp; 0x80) == 0x80) {
4325     id_len = 1;
4326   } else if ((c-&gt;data[0] &amp; 0xC0) == 0x40) {
4327     id_len = 2;
4328   } else if ((c-&gt;data[0] &amp; 0xE0) == 0x20) {
4329     id_len = 3;
4330   } else if ((c-&gt;data[0] &amp; 0xF0) == 0x10) {
4331     id_len = 4;
4332   } else {
4333     return 0;
4334   }
4335 
4336   if (max_size &lt; id_len)
4337     return 0;
4338 
4339   for (i = 1; i &lt; id_len; ++i) {
4340     *id = (*id &lt;&lt; 8) | c-&gt;data[i];
4341   }
4342 
4343   data_scan_ctx_advance (tf, c, id_len);
4344   max_size -= id_len;
4345 
4346   /* size */
4347   if (max_size &lt; 1 || c-&gt;data[0] == 0)
4348     return 0;
4349 
4350   msbit_set = g_bit_nth_msf (c-&gt;data[0], 8);
4351   mask = ((1 &lt;&lt; msbit_set) - 1);
4352   *size = c-&gt;data[0] &amp; mask;
4353   len = 7 - msbit_set;
4354 
4355   if (max_size &lt; 1 + len)
4356     return 0;
4357   for (i = 0; i &lt; len; ++i) {
4358     mask = (mask &lt;&lt; 8) | 0xff;
4359     *size = (*size &lt;&lt; 8) | c-&gt;data[1 + i];
4360   }
4361 
4362   data_scan_ctx_advance (tf, c, 1 + len);
4363 
4364   /* undefined/unknown size? (all bits 1) */
4365   if (*size == mask) {
4366     /* allow unknown size for SEGMENT chunk, bail out otherwise */
4367     if (*id == MATROSKA_SEGMENT)
4368       *size = G_MAXUINT64;
4369     else
4370       return 0;
4371   }
4372 
4373   return id_len + (1 + len);
4374 }
4375 
4376 static gboolean
4377 ebml_parse_chunk (GstTypeFind * tf, DataScanCtx * ctx, guint32 chunk_id,
4378     guint chunk_size, GstMatroskaInfo * info, guint depth)
4379 {                               /* FIXME: make sure input size is clipped to 32 bit */
4380   static const gchar SPACES[] = &quot;                &quot;;
4381   DataScanCtx c = *ctx;
<a name="33" id="anc33"></a><span class="line-modified">4382   guint64 element_size = 0;</span>
4383   guint32 id, hdr_len;
4384 
4385   if (depth &gt;= 8)               /* keep SPACES large enough for depth */
4386     return FALSE;
4387 
4388   while (chunk_size &gt; 0) {
4389     if (c.offset &gt; EBML_MAX_LEN || !data_scan_ctx_ensure_data (tf, &amp;c, 64))
<a name="34" id="anc34"></a><span class="line-modified">4390       return FALSE;</span>
4391 
4392     hdr_len = ebml_read_chunk_header (tf, &amp;c, chunk_size, &amp;id, &amp;element_size);
4393     if (hdr_len == 0)
<a name="35" id="anc35"></a><span class="line-modified">4394       return FALSE;</span>
4395 
4396     g_assert (hdr_len &lt;= chunk_size);
4397     chunk_size -= hdr_len;
4398 
4399     if (element_size &gt; chunk_size)
<a name="36" id="anc36"></a><span class="line-modified">4400       return FALSE;</span>
4401 
4402     GST_DEBUG (&quot;%s %08x, size %&quot; G_GUINT64_FORMAT &quot; / %&quot; G_GUINT64_FORMAT,
4403         SPACES + sizeof (SPACES) - 1 - (2 * depth), id, element_size,
4404         hdr_len + element_size);
4405 
<a name="37" id="anc37"></a><span class="line-added">4406     if (element_size &gt;= G_MAXUINT32) {</span>
<span class="line-added">4407       GST_DEBUG (&quot;Chunk too big for typefinding&quot;);</span>
<span class="line-added">4408       return FALSE;</span>
<span class="line-added">4409     }</span>
<span class="line-added">4410 </span>
4411     if (!data_scan_ctx_ensure_data (tf, &amp;c, element_size)) {
4412       GST_DEBUG (&quot;not enough data&quot;);
4413       return FALSE;
4414     }
4415 
4416     switch (id) {
4417       case EBML_DOCTYPE:
4418         if (element_size &gt;= 8 &amp;&amp; memcmp (c.data, &quot;matroska&quot;, 8) == 0)
4419           info-&gt;doctype = EBML_DOCTYPE_MATROSKA;
4420         else if (element_size &gt;= 4 &amp;&amp; memcmp (c.data, &quot;webm&quot;, 4) == 0)
4421           info-&gt;doctype = EBML_DOCTYPE_WEBM;
4422         break;
4423       case MATROSKA_SEGMENT:
4424         GST_LOG (&quot;parsing segment&quot;);
4425         ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4426         GST_LOG (&quot;parsed segment, done&quot;);
<a name="38" id="anc38"></a><span class="line-modified">4427         return FALSE;</span>
4428       case MATROSKA_TRACKS:
4429         GST_LOG (&quot;parsing tracks&quot;);
4430         info-&gt;tracks_ok =
4431             ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4432         GST_LOG (&quot;parsed tracks: %s, done (after %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
4433             info-&gt;tracks_ok ? &quot;ok&quot; : &quot;FAIL&quot;, c.offset + element_size);
4434         return FALSE;
4435       case MATROSKA_TRACK_ENTRY:
4436         GST_LOG (&quot;parsing track entry&quot;);
4437         if (!ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1))
4438           return FALSE;
4439         break;
4440       case MATROSKA_TRACK_TYPE:{
4441         guint type = 0, i;
4442 
4443         /* is supposed to always be 1-byte, but not everyone&#39;s following that */
4444         for (i = 0; i &lt; element_size; ++i)
4445           type = (type &lt;&lt; 8) | c.data[i];
4446 
4447         GST_DEBUG (&quot;%s   track type %u&quot;,
4448             SPACES + sizeof (SPACES) - 1 - (2 * depth), type);
4449 
4450         if (type == 1)
4451           ++info-&gt;video;
4452         else if (c.data[0] == 2)
4453           ++info-&gt;audio;
4454         else
4455           ++info-&gt;other;
4456         break;
4457       }
4458       case MATROSKA_STEREO_MODE:
4459         ++info-&gt;video_stereo;
4460         break;
4461       case MATROSKA_CLUSTER:
4462         GST_WARNING (&quot;cluster, bailing out (should&#39;ve found tracks by now)&quot;);
4463         return FALSE;
4464       default:
4465         break;
4466     }
4467     data_scan_ctx_advance (tf, &amp;c, element_size);
4468     chunk_size -= element_size;
4469     ++info-&gt;chunks;
4470   }
4471 
4472   return TRUE;
4473 }
4474 
4475 static GstStaticCaps matroska_caps = GST_STATIC_CAPS (&quot;video/x-matroska&quot;);
4476 
4477 #define MATROSKA_CAPS (gst_static_caps_get(&amp;matroska_caps))
4478 static void
4479 matroska_type_find (GstTypeFind * tf, gpointer ununsed)
4480 {
4481   GstTypeFindProbability prob;
4482   GstMatroskaInfo info = { 0, };
4483   const gchar *type_name;
4484   DataScanCtx c = { 0, NULL, 0 };
4485   gboolean is_audio;
4486   guint64 size;
4487   guint32 id, hdr_len;
4488 
4489   if (!data_scan_ctx_ensure_data (tf, &amp;c, 64))
4490     return;
4491 
4492   if (GST_READ_UINT32_BE (c.data) != EBML_HEADER)
4493     return;
4494 
4495   while (c.offset &lt; EBML_MAX_LEN &amp;&amp; data_scan_ctx_ensure_data (tf, &amp;c, 64)) {
4496     hdr_len = ebml_read_chunk_header (tf, &amp;c, c.size, &amp;id, &amp;size);
4497     if (hdr_len == 0)
4498       return;
4499 
4500     GST_INFO (&quot;=== top-level chunk %08x, size %&quot; G_GUINT64_FORMAT
4501         &quot; / %&quot; G_GUINT64_FORMAT, id, size, size + hdr_len);
4502 
4503     if (!ebml_parse_chunk (tf, &amp;c, id, size, &amp;info, 0))
4504       break;
4505     data_scan_ctx_advance (tf, &amp;c, size);
4506     GST_INFO (&quot;=== done with chunk %08x&quot;, id);
4507     if (id == MATROSKA_SEGMENT)
4508       break;
4509   }
4510 
4511   GST_INFO (&quot;audio=%u video=%u other=%u chunks=%u doctype=%d all_tracks=%d&quot;,
4512       info.audio, info.video, info.other, info.chunks, info.doctype,
4513       info.tracks_ok);
4514 
4515   /* perhaps we should bail out if tracks_ok is FALSE and wait for more data?
4516    * (we would need new API to signal this properly and prevent other
4517    * typefinders from taking over the decision then) */
4518   is_audio = (info.audio &gt; 0 &amp;&amp; info.video == 0 &amp;&amp; info.other == 0);
4519 
4520   if (info.doctype == EBML_DOCTYPE_WEBM) {
4521     type_name = (is_audio) ? &quot;audio/webm&quot; : &quot;video/webm&quot;;
4522   } else if (info.video &gt; 0 &amp;&amp; info.video_stereo) {
4523     type_name = &quot;video/x-matroska-3d&quot;;
4524   } else {
4525     type_name = (is_audio) ? &quot;audio/x-matroska&quot; : &quot;video/x-matroska&quot;;
4526   }
4527 
4528   if (info.doctype == EBML_DOCTYPE_UNKNOWN)
4529     prob = GST_TYPE_FIND_LIKELY;
4530   else
4531     prob = GST_TYPE_FIND_MAXIMUM;
4532 
4533   gst_type_find_suggest_simple (tf, prob, type_name, NULL);
4534 }
4535 
4536 /*** application/mxf ***/
4537 static GstStaticCaps mxf_caps = GST_STATIC_CAPS (&quot;application/mxf&quot;);
4538 
4539 #define MXF_MAX_PROBE_LENGTH (1024 * 64)
4540 #define MXF_CAPS (gst_static_caps_get(&amp;mxf_caps))
4541 
4542 /*
4543  * MXF files start with a header partition pack key of 16 bytes which is defined
4544  * at SMPTE-377M 6.1. Before this there can be up to 64K of run-in which _must_
4545  * not contain the partition pack key.
4546  */
4547 static void
4548 mxf_type_find (GstTypeFind * tf, gpointer ununsed)
4549 {
4550   static const guint8 partition_pack_key[] =
4551       { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01,
4552     0x01
4553   };
4554   DataScanCtx c = { 0, NULL, 0 };
4555 
4556   while (c.offset &lt;= MXF_MAX_PROBE_LENGTH) {
4557     guint i;
4558     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 1024)))
4559       break;
4560 
4561     /* look over in chunks of 1kbytes to avoid too much overhead */
4562 
4563     for (i = 0; i &lt; 1024 - 16; i++) {
4564       /* Check first byte before calling more expensive memcmp function */
4565       if (G_UNLIKELY (c.data[i] == 0x06
4566               &amp;&amp; memcmp (c.data + i, partition_pack_key, 13) == 0)) {
4567         /* Header partition pack? */
4568         if (c.data[i + 13] != 0x02)
4569           goto advance;
4570 
4571         /* Partition status */
4572         if (c.data[i + 14] &gt;= 0x05)
4573           goto advance;
4574 
4575         /* Reserved, must be 0x00 */
4576         if (c.data[i + 15] != 0x00)
4577           goto advance;
4578 
4579         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MXF_CAPS);
4580         return;
4581       }
4582     }
4583 
4584   advance:
4585     data_scan_ctx_advance (tf, &amp;c, 1024 - 16);
4586   }
4587 }
4588 
4589 /*** video/x-dv ***/
4590 
4591 static GstStaticCaps dv_caps = GST_STATIC_CAPS (&quot;video/x-dv, &quot;
4592     &quot;systemstream = (boolean) true&quot;);
4593 #define DV_CAPS (gst_static_caps_get(&amp;dv_caps))
4594 static void
4595 dv_type_find (GstTypeFind * tf, gpointer private)
4596 {
4597   const guint8 *data;
4598 
4599   data = gst_type_find_peek (tf, 0, 5);
4600 
4601   /* check for DIF  and DV flag */
4602   if (data &amp;&amp; (data[0] == 0x1f) &amp;&amp; (data[1] == 0x07) &amp;&amp; (data[2] == 0x00)) {
4603     const gchar *format;
4604 
4605     if (data[3] &amp; 0x80) {
4606       format = &quot;PAL&quot;;
4607     } else {
4608       format = &quot;NTSC&quot;;
4609     }
4610 
4611     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, &quot;video/x-dv&quot;,
4612         &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
4613         &quot;format&quot;, G_TYPE_STRING, format, NULL);
4614   }
4615 }
4616 
4617 
4618 /*** Ogg variants ***/
4619 static GstStaticCaps ogg_caps =
4620     GST_STATIC_CAPS (&quot;application/ogg;video/ogg;audio/ogg;application/kate&quot;);
4621 
4622 #define OGG_CAPS (gst_static_caps_get(&amp;ogg_caps))
4623 
4624 typedef enum
4625 {
4626   OGG_AUDIO = 0,
4627   OGG_VIDEO,
4628   OGG_KATE,
4629   OGG_OTHER,
4630   OGG_SKELETON,
4631   OGG_ANNODEX,
4632   OGG_NUM
4633 } GstOggStreamType;
4634 
4635 static void
4636 ogganx_type_find (GstTypeFind * tf, gpointer private)
4637 {
4638   const gchar *media_type;
4639   DataScanCtx c = { 0, NULL, 0 };
4640   guint ogg_syncs = 0;
4641   guint hdr_count[OGG_NUM] = { 0, };
4642   static const struct
4643   {
4644     const gchar marker[10];
4645     guint8 marker_size;
4646     GstOggStreamType stream_type;
4647   } markers[] = {
4648     {
4649     &quot;\001vorbis&quot;, 7, OGG_AUDIO}, {
4650     &quot;\200theora&quot;, 7, OGG_VIDEO}, {
4651     &quot;fLaC&quot;, 4, OGG_AUDIO}, {
4652     &quot;\177FLAC&quot;, 5, OGG_AUDIO}, {
4653     &quot;Speex&quot;, 5, OGG_AUDIO}, {
4654     &quot;CMML\0\0\0\0&quot;, 8, OGG_OTHER}, {
4655     &quot;PCM     &quot;, 8, OGG_AUDIO}, {
4656     &quot;Annodex&quot;, 7, OGG_ANNODEX}, {
4657     &quot;fishead&quot;, 7, OGG_SKELETON}, {
4658     &quot;AnxData&quot;, 7, OGG_ANNODEX}, {
4659     &quot;CELT    &quot;, 8, OGG_AUDIO}, {
4660     &quot;\200kate\0\0\0&quot;, 8, OGG_KATE}, {
4661     &quot;BBCD\0&quot;, 5, OGG_VIDEO}, {
4662     &quot;OVP80\1\1&quot;, 7, OGG_VIDEO}, {
4663     &quot;OpusHead&quot;, 8, OGG_AUDIO}, {
4664     &quot;\001audio\0\0\0&quot;, 9, OGG_AUDIO}, {
4665     &quot;\001video\0\0\0&quot;, 9, OGG_VIDEO}, {
4666     &quot;\001text\0\0\0&quot;, 9, OGG_OTHER}
4667   };
4668 
4669   while (c.offset &lt; 4096 &amp;&amp; data_scan_ctx_ensure_data (tf, &amp;c, 64)) {
4670     guint size, i;
4671 
4672     if (memcmp (c.data, &quot;OggS&quot;, 5) != 0)
4673       break;
4674 
4675     ++ogg_syncs;
4676 
4677     /* check if BOS */
4678     if (c.data[5] != 0x02)
4679       break;
4680 
4681     /* headers should only have one segment */
4682     if (c.data[26] != 1)
4683       break;
4684 
4685     size = c.data[27];
4686     if (size &lt; 8)
4687       break;
4688 
4689     data_scan_ctx_advance (tf, &amp;c, 28);
4690 
4691     if (!data_scan_ctx_ensure_data (tf, &amp;c, MAX (size, 8)))
4692       break;
4693 
4694     for (i = 0; i &lt; G_N_ELEMENTS (markers); ++i) {
4695       if (memcmp (c.data, markers[i].marker, markers[i].marker_size) == 0) {
4696         ++hdr_count[markers[i].stream_type];
4697         break;
4698       }
4699     }
4700 
4701     if (i == G_N_ELEMENTS (markers)) {
4702       GST_MEMDUMP (&quot;unknown Ogg stream marker&quot;, c.data, size);
4703       ++hdr_count[OGG_OTHER];
4704     }
4705 
4706     data_scan_ctx_advance (tf, &amp;c, size);
4707   }
4708 
4709   if (ogg_syncs == 0)
4710     return;
4711 
4712   /* We don&#39;t bother with annodex types. FIXME: what about XSPF? */
4713   if (hdr_count[OGG_VIDEO] &gt; 0) {
4714     media_type = &quot;video/ogg&quot;;
4715   } else if (hdr_count[OGG_AUDIO] &gt; 0) {
4716     media_type = &quot;audio/ogg&quot;;
4717   } else if (hdr_count[OGG_KATE] &gt; 0 &amp;&amp; hdr_count[OGG_OTHER] == 0) {
4718     media_type = &quot;application/kate&quot;;
4719   } else {
4720     media_type = &quot;application/ogg&quot;;
4721   }
4722 
4723   GST_INFO (&quot;found %s (audio:%u, video:%u, annodex:%u, skeleton:%u, other:%u)&quot;,
4724       media_type, hdr_count[OGG_AUDIO], hdr_count[OGG_VIDEO],
4725       hdr_count[OGG_ANNODEX], hdr_count[OGG_SKELETON], hdr_count[OGG_OTHER]);
4726 
4727   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, media_type, NULL);
4728 }
4729 
4730 /*** audio/x-vorbis ***/
4731 static GstStaticCaps vorbis_caps = GST_STATIC_CAPS (&quot;audio/x-vorbis&quot;);
4732 
4733 #define VORBIS_CAPS (gst_static_caps_get(&amp;vorbis_caps))
4734 static void
4735 vorbis_type_find (GstTypeFind * tf, gpointer private)
4736 {
4737   const guint8 *data = gst_type_find_peek (tf, 0, 30);
4738 
4739   if (data) {
4740     guint blocksize_0;
4741     guint blocksize_1;
4742 
4743     /* 1 byte packet type (identification=0x01)
4744        6 byte string &quot;vorbis&quot;
4745        4 byte vorbis version */
4746     if (memcmp (data, &quot;\001vorbis\000\000\000\000&quot;, 11) != 0)
4747       return;
4748     data += 11;
4749     /* 1 byte channels must be != 0 */
4750     if (data[0] == 0)
4751       return;
4752     data++;
4753     /* 4 byte samplerate must be != 0 */
4754     if (GST_READ_UINT32_LE (data) == 0)
4755       return;
4756     data += 16;
4757     /* blocksize checks */
4758     blocksize_0 = data[0] &amp; 0x0F;
4759     blocksize_1 = (data[0] &amp; 0xF0) &gt;&gt; 4;
4760     if (blocksize_0 &gt; blocksize_1)
4761       return;
4762     if (blocksize_0 &lt; 6 || blocksize_0 &gt; 13)
4763       return;
4764     if (blocksize_1 &lt; 6 || blocksize_1 &gt; 13)
4765       return;
4766     data++;
4767     /* framing bit */
4768     if ((data[0] &amp; 0x01) != 1)
4769       return;
4770     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, VORBIS_CAPS);
4771   }
4772 }
4773 
4774 /*** video/x-theora ***/
4775 
4776 static GstStaticCaps theora_caps = GST_STATIC_CAPS (&quot;video/x-theora&quot;);
4777 
4778 #define THEORA_CAPS (gst_static_caps_get(&amp;theora_caps))
4779 static void
4780 theora_type_find (GstTypeFind * tf, gpointer private)
4781 {
4782   const guint8 *data = gst_type_find_peek (tf, 0, 7);   //42);
4783 
4784   if (data) {
4785     if (data[0] != 0x80)
4786       return;
4787     if (memcmp (&amp;data[1], &quot;theora&quot;, 6) != 0)
4788       return;
4789     /* FIXME: make this more reliable when specs are out */
4790 
4791     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, THEORA_CAPS);
4792   }
4793 }
4794 
4795 /*** kate ***/
4796 static void
4797 kate_type_find (GstTypeFind * tf, gpointer private)
4798 {
4799   const guint8 *data = gst_type_find_peek (tf, 0, 64);
4800   gchar category[16] = { 0, };
4801 
4802   if (G_UNLIKELY (data == NULL))
4803     return;
4804 
4805   /* see: http://wiki.xiph.org/index.php/OggKate#Format_specification */
4806   if (G_LIKELY (memcmp (data, &quot;\200kate\0\0\0&quot;, 8) != 0))
4807     return;
4808 
4809   /* make sure we always have a NUL-terminated string */
4810   memcpy (category, data + 48, 15);
4811   GST_LOG (&quot;kate category: %s&quot;, category);
4812   /* canonical categories for subtitles: subtitles, spu-subtitles, SUB, K-SPU */
4813   if (strcmp (category, &quot;subtitles&quot;) == 0 || strcmp (category, &quot;SUB&quot;) == 0 ||
4814       strcmp (category, &quot;spu-subtitles&quot;) == 0 ||
4815       strcmp (category, &quot;K-SPU&quot;) == 0) {
4816     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
4817         &quot;subtitle/x-kate&quot;, NULL);
4818   } else {
4819     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
4820         &quot;application/x-kate&quot;, NULL);
4821   }
4822 }
4823 
4824 /*** WEBVTTT subtitles ***/
4825 static GstStaticCaps webvtt_caps =
4826 GST_STATIC_CAPS (&quot;application/x-subtitle-vtt, parsed=(boolean)false&quot;);
4827 #define WEBVTT_CAPS (gst_static_caps_get(&amp;webvtt_caps))
4828 
4829 static void
4830 webvtt_type_find (GstTypeFind * tf, gpointer private)
4831 {
4832   const guint8 *data;
4833 
4834   data = gst_type_find_peek (tf, 0, 10);
4835 
4836   if (data == NULL)
4837     return;
4838 
4839   /* there might be a UTF-8 BOM at the beginning */
4840   if (memcmp (data, &quot;WEBVTT&quot;, 6) != 0 &amp;&amp; memcmp (data + 3, &quot;WEBVTT&quot;, 6) != 0) {
4841     return;
4842   }
4843 
4844   if (data[0] != &#39;W&#39;) {
4845     if (data[0] != 0xef || data[1] != 0xbb || data[2] != 0xbf)
4846       return;                   /* Not a UTF-8 BOM */
4847     data += 3;
4848   }
4849 
4850   /* After the WEBVTT magic must be one of these chars:
4851    *   0x20 (space), 0x9 (tab), 0xa (LF) or 0xd (CR) */
4852   if (data[6] != 0x20 &amp;&amp; data[6] != 0x9 &amp;&amp; data[6] != 0xa &amp;&amp; data[6] != 0xd) {
4853     return;
4854   }
4855 
4856   gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, WEBVTT_CAPS);
4857 }
4858 
4859 /*** application/x-ogm-video or audio***/
4860 
4861 static GstStaticCaps ogmvideo_caps =
4862 GST_STATIC_CAPS (&quot;application/x-ogm-video&quot;);
4863 #define OGMVIDEO_CAPS (gst_static_caps_get(&amp;ogmvideo_caps))
4864 static void
4865 ogmvideo_type_find (GstTypeFind * tf, gpointer private)
4866 {
4867   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4868 
4869   if (data) {
4870     if (memcmp (data, &quot;\001video\000\000\000&quot;, 9) != 0)
4871       return;
4872     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMVIDEO_CAPS);
4873   }
4874 }
4875 
4876 static GstStaticCaps ogmaudio_caps =
4877 GST_STATIC_CAPS (&quot;application/x-ogm-audio&quot;);
4878 #define OGMAUDIO_CAPS (gst_static_caps_get(&amp;ogmaudio_caps))
4879 static void
4880 ogmaudio_type_find (GstTypeFind * tf, gpointer private)
4881 {
4882   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4883 
4884   if (data) {
4885     if (memcmp (data, &quot;\001audio\000\000\000&quot;, 9) != 0)
4886       return;
4887     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
4888   }
4889 }
4890 
4891 static GstStaticCaps ogmtext_caps = GST_STATIC_CAPS (&quot;application/x-ogm-text&quot;);
4892 
4893 #define OGMTEXT_CAPS (gst_static_caps_get(&amp;ogmtext_caps))
4894 static void
4895 ogmtext_type_find (GstTypeFind * tf, gpointer private)
4896 {
4897   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4898 
4899   if (data) {
4900     if (memcmp (data, &quot;\001text\000\000\000\000&quot;, 9) != 0)
4901       return;
4902     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMTEXT_CAPS);
4903   }
4904 }
4905 
4906 /*** audio/x-speex ***/
4907 
4908 static GstStaticCaps speex_caps = GST_STATIC_CAPS (&quot;audio/x-speex&quot;);
4909 
4910 #define SPEEX_CAPS (gst_static_caps_get(&amp;speex_caps))
4911 static void
4912 speex_type_find (GstTypeFind * tf, gpointer private)
4913 {
4914   const guint8 *data = gst_type_find_peek (tf, 0, 80);
4915 
4916   if (data) {
4917     /* 8 byte string &quot;Speex   &quot;
4918        24 byte speex version string + int */
4919     if (memcmp (data, &quot;Speex   &quot;, 8) != 0)
4920       return;
4921     data += 32;
4922 
4923     /* 4 byte header size &gt;= 80 */
4924     if (GST_READ_UINT32_LE (data) &lt; 80)
4925       return;
4926     data += 4;
4927 
4928     /* 4 byte sample rate &lt;= 48000 */
4929     if (GST_READ_UINT32_LE (data) &gt; 48000)
4930       return;
4931     data += 4;
4932 
4933     /* currently there are only 3 speex modes. */
4934     if (GST_READ_UINT32_LE (data) &gt; 3)
4935       return;
4936     data += 12;
4937 
4938     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SPEEX_CAPS);
4939   }
4940 }
4941 
4942 /*** audio/x-celt ***/
4943 
4944 static GstStaticCaps celt_caps = GST_STATIC_CAPS (&quot;audio/x-celt&quot;);
4945 
4946 #define CELT_CAPS (gst_static_caps_get(&amp;celt_caps))
4947 static void
4948 celt_type_find (GstTypeFind * tf, gpointer private)
4949 {
4950   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4951 
4952   if (data) {
4953     /* 8 byte string &quot;CELT   &quot; */
4954     if (memcmp (data, &quot;CELT    &quot;, 8) != 0)
4955       return;
4956 
4957     /* TODO: Check other values of the CELT header */
4958     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, CELT_CAPS);
4959   }
4960 }
4961 
4962 /*** application/x-ogg-skeleton ***/
4963 static GstStaticCaps ogg_skeleton_caps =
4964 GST_STATIC_CAPS (&quot;application/x-ogg-skeleton, parsed=(boolean)FALSE&quot;);
4965 #define OGG_SKELETON_CAPS (gst_static_caps_get(&amp;ogg_skeleton_caps))
4966 static void
4967 oggskel_type_find (GstTypeFind * tf, gpointer private)
4968 {
4969   const guint8 *data = gst_type_find_peek (tf, 0, 12);
4970 
4971   if (data) {
4972     /* 8 byte string &quot;fishead\0&quot; for the ogg skeleton stream */
4973     if (memcmp (data, &quot;fishead\0&quot;, 8) != 0)
4974       return;
4975     data += 8;
4976 
4977     /* Require that the header contains version 3.0 */
4978     if (GST_READ_UINT16_LE (data) != 3)
4979       return;
4980     data += 2;
4981     if (GST_READ_UINT16_LE (data) != 0)
4982       return;
4983 
4984     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGG_SKELETON_CAPS);
4985   }
4986 }
4987 
4988 static GstStaticCaps cmml_caps = GST_STATIC_CAPS (&quot;text/x-cmml&quot;);
4989 
4990 #define CMML_CAPS (gst_static_caps_get(&amp;cmml_caps))
4991 static void
4992 cmml_type_find (GstTypeFind * tf, gpointer private)
4993 {
4994   /* Header is 12 bytes minimum (though we don&#39;t check the minor version */
4995   const guint8 *data = gst_type_find_peek (tf, 0, 12);
4996 
4997   if (data) {
4998 
4999     /* 8 byte string &quot;CMML\0\0\0\0&quot; for the magic number */
5000     if (memcmp (data, &quot;CMML\0\0\0\0&quot;, 8) != 0)
5001       return;
5002     data += 8;
5003 
5004     /* Require that the header contains at least version 2.0 */
5005     if (GST_READ_UINT16_LE (data) &lt; 2)
5006       return;
5007 
5008     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, CMML_CAPS);
5009   }
5010 }
5011 
5012 /*** application/x-tar ***/
5013 
5014 static GstStaticCaps tar_caps = GST_STATIC_CAPS (&quot;application/x-tar&quot;);
5015 
5016 #define TAR_CAPS (gst_static_caps_get(&amp;tar_caps))
5017 #define OLDGNU_MAGIC &quot;ustar  &quot;  /* 7 chars and a NUL */
5018 #define NEWGNU_MAGIC &quot;ustar&quot;    /* 5 chars and a NUL */
5019 static void
5020 tar_type_find (GstTypeFind * tf, gpointer unused)
5021 {
5022   const guint8 *data = gst_type_find_peek (tf, 257, 8);
5023 
5024   /* of course we are not certain, but we don&#39;t want other typefind funcs
5025    * to detect formats of files within the tar archive, e.g. mp3s */
5026   if (data) {
5027     if (memcmp (data, OLDGNU_MAGIC, 8) == 0) {  /* sic */
5028       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, TAR_CAPS);
5029     } else if (memcmp (data, NEWGNU_MAGIC, 6) == 0 &amp;&amp;   /* sic */
5030         g_ascii_isdigit (data[6]) &amp;&amp; g_ascii_isdigit (data[7])) {
5031       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, TAR_CAPS);
5032     }
5033   }
5034 }
5035 
5036 /*** application/x-ar ***/
5037 
5038 static GstStaticCaps ar_caps = GST_STATIC_CAPS (&quot;application/x-ar&quot;);
5039 
5040 #define AR_CAPS (gst_static_caps_get(&amp;ar_caps))
5041 static void
5042 ar_type_find (GstTypeFind * tf, gpointer unused)
5043 {
5044   const guint8 *data = gst_type_find_peek (tf, 0, 24);
5045 
5046   if (data &amp;&amp; memcmp (data, &quot;!&lt;arch&gt;&quot;, 7) == 0) {
5047     gint i;
5048 
5049     for (i = 7; i &lt; 24; ++i) {
5050       if (!g_ascii_isprint (data[i]) &amp;&amp; data[i] != &#39;\n&#39;) {
5051         gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, AR_CAPS);
5052       }
5053     }
5054 
5055     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, AR_CAPS);
5056   }
5057 }
5058 
5059 /*** audio/x-au ***/
5060 
5061 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5062  * as it is only possible to register one typefind factory per &#39;name&#39;
5063  * (which is in this case the caps), and the first one would be replaced by
5064  * the second one. */
5065 static GstStaticCaps au_caps = GST_STATIC_CAPS (&quot;audio/x-au&quot;);
5066 
5067 #define AU_CAPS (gst_static_caps_get(&amp;au_caps))
5068 static void
5069 au_type_find (GstTypeFind * tf, gpointer unused)
5070 {
5071   const guint8 *data = gst_type_find_peek (tf, 0, 4);
5072 
5073   if (data) {
5074     if (memcmp (data, &quot;.snd&quot;, 4) == 0 || memcmp (data, &quot;dns.&quot;, 4) == 0) {
5075       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, AU_CAPS);
5076     }
5077   }
5078 }
5079 
5080 
5081 /*** video/x-nuv ***/
5082 
5083 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5084  * as it is only possible to register one typefind factory per &#39;name&#39;
5085  * (which is in this case the caps), and the first one would be replaced by
5086  * the second one. */
5087 static GstStaticCaps nuv_caps = GST_STATIC_CAPS (&quot;video/x-nuv&quot;);
5088 
5089 #define NUV_CAPS (gst_static_caps_get(&amp;nuv_caps))
5090 static void
5091 nuv_type_find (GstTypeFind * tf, gpointer unused)
5092 {
5093   const guint8 *data = gst_type_find_peek (tf, 0, 11);
5094 
5095   if (data) {
5096     if (memcmp (data, &quot;MythTVVideo&quot;, 11) == 0
5097         || memcmp (data, &quot;NuppelVideo&quot;, 11) == 0) {
5098       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, NUV_CAPS);
5099     }
5100   }
5101 }
5102 
5103 /*** audio/x-paris ***/
5104 /* NOTE: do not replace this function with two TYPE_FIND_REGISTER_START_WITH */
5105 static GstStaticCaps paris_caps = GST_STATIC_CAPS (&quot;audio/x-paris&quot;);
5106 
5107 #define PARIS_CAPS (gst_static_caps_get(&amp;paris_caps))
5108 static void
5109 paris_type_find (GstTypeFind * tf, gpointer unused)
5110 {
5111   const guint8 *data = gst_type_find_peek (tf, 0, 4);
5112 
5113   if (data) {
5114     if (memcmp (data, &quot; paf&quot;, 4) == 0 || memcmp (data, &quot;fap &quot;, 4) == 0) {
5115       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, PARIS_CAPS);
5116     }
5117   }
5118 }
5119 
5120 /*** audio/x-sbc ***/
5121 static GstStaticCaps sbc_caps = GST_STATIC_CAPS (&quot;audio/x-sbc&quot;);
5122 #define SBC_CAPS (gst_static_caps_get(&amp;sbc_caps))
5123 
5124 static gsize
5125 sbc_check_header (const guint8 * data, gsize len, guint * rate,
5126     guint * channels)
5127 {
5128   static const guint16 sbc_rates[4] = { 16000, 32000, 44100, 48000 };
5129   static const guint8 sbc_blocks[4] = { 4, 8, 12, 16 };
5130   guint n_blocks, ch_mode, n_subbands, bitpool;
5131 
5132   if (data[0] != 0x9C || len &lt; 4)
5133     return 0;
5134 
5135   n_blocks = sbc_blocks[(data[1] &gt;&gt; 4) &amp; 0x03];
5136   ch_mode = (data[1] &gt;&gt; 2) &amp; 0x03;
5137   n_subbands = (data[1] &amp; 0x01) ? 8 : 4;
5138   bitpool = data[2];
5139   if (bitpool &lt; 2)
5140     return 0;
5141 
5142   *rate = sbc_rates[(data[1] &gt;&gt; 6) &amp; 0x03];
5143   *channels = (ch_mode == 0) ? 1 : 2;
5144 
5145   if (ch_mode == 0)
5146     return 4 + (n_subbands * 1) / 2 + (n_blocks * 1 * bitpool) / 8;
5147   else if (ch_mode == 1)
5148     return 4 + (n_subbands * 2) / 2 + (n_blocks * 2 * bitpool) / 8;
5149   else if (ch_mode == 2)
5150     return 4 + (n_subbands * 2) / 2 + (n_blocks * bitpool) / 8;
5151   else if (ch_mode == 3)
5152     return 4 + (n_subbands * 2) / 2 + (n_subbands + n_blocks * bitpool) / 8;
5153 
5154   return 0;
5155 }
5156 
5157 static void
5158 sbc_type_find (GstTypeFind * tf, gpointer unused)
5159 {
5160   const guint8 *data;
5161   gsize frame_len;
5162   guint i, rate, channels, offset = 0;
5163 
5164   for (i = 0; i &lt; 10; ++i) {
5165     data = gst_type_find_peek (tf, offset, 8);
5166     if (data == NULL)
5167       return;
5168 
5169     frame_len = sbc_check_header (data, 8, &amp;rate, &amp;channels);
5170     if (frame_len == 0)
5171       return;
5172 
5173     offset += frame_len;
5174   }
5175   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE, &quot;audio/x-sbc&quot;,
5176       &quot;rate&quot;, G_TYPE_INT, rate, &quot;channels&quot;, G_TYPE_INT, channels,
5177       &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5178 }
5179 
5180 /*** audio/iLBC-sh ***/
5181 /* NOTE: do not replace this function with two TYPE_FIND_REGISTER_START_WITH */
5182 static GstStaticCaps ilbc_caps = GST_STATIC_CAPS (&quot;audio/iLBC-sh&quot;);
5183 
5184 #define ILBC_CAPS (gst_static_caps_get(&amp;ilbc_caps))
5185 static void
5186 ilbc_type_find (GstTypeFind * tf, gpointer unused)
5187 {
5188   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5189 
5190   if (data) {
5191     if (memcmp (data, &quot;#!iLBC30&quot;, 8) == 0 || memcmp (data, &quot;#!iLBC20&quot;, 8) == 0) {
5192       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, ILBC_CAPS);
5193     }
5194   }
5195 }
5196 
5197 /*** application/x-ms-dos-executable ***/
5198 
5199 static GstStaticCaps msdos_caps =
5200 GST_STATIC_CAPS (&quot;application/x-ms-dos-executable&quot;);
5201 #define MSDOS_CAPS (gst_static_caps_get(&amp;msdos_caps))
5202 /* see http://www.madchat.org/vxdevl/papers/winsys/pefile/pefile.htm */
5203 static void
5204 msdos_type_find (GstTypeFind * tf, gpointer unused)
5205 {
5206   const guint8 *data = gst_type_find_peek (tf, 0, 64);
5207 
5208   if (data &amp;&amp; data[0] == &#39;M&#39; &amp;&amp; data[1] == &#39;Z&#39; &amp;&amp;
5209       GST_READ_UINT16_LE (data + 8) == 4) {
5210     guint32 pe_offset = GST_READ_UINT32_LE (data + 60);
5211 
5212     data = gst_type_find_peek (tf, pe_offset, 2);
5213     if (data &amp;&amp; data[0] == &#39;P&#39; &amp;&amp; data[1] == &#39;E&#39;) {
5214       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, MSDOS_CAPS);
5215     }
5216   }
5217 }
5218 
5219 /*** application/x-mmsh ***/
5220 
5221 static GstStaticCaps mmsh_caps = GST_STATIC_CAPS (&quot;application/x-mmsh&quot;);
5222 
5223 #define MMSH_CAPS gst_static_caps_get(&amp;mmsh_caps)
5224 
5225 /* This is to recognise mssh-over-http */
5226 static void
5227 mmsh_type_find (GstTypeFind * tf, gpointer unused)
5228 {
5229   static const guint8 asf_marker[16] = { 0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66,
5230     0xcf, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c
5231   };
5232 
5233   const guint8 *data;
5234 
5235   data = gst_type_find_peek (tf, 0, 2 + 2 + 4 + 2 + 2 + 16);
5236   if (data &amp;&amp; data[0] == 0x24 &amp;&amp; data[1] == 0x48 &amp;&amp;
5237       GST_READ_UINT16_LE (data + 2) &gt; 2 + 2 + 4 + 2 + 2 + 16 &amp;&amp;
5238       memcmp (data + 2 + 2 + 4 + 2 + 2, asf_marker, 16) == 0) {
5239     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, MMSH_CAPS);
5240   }
5241 }
5242 
5243 /*** video/x-dirac ***/
5244 
5245 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5246  * as it is only possible to register one typefind factory per &#39;name&#39;
5247  * (which is in this case the caps), and the first one would be replaced by
5248  * the second one. */
5249 static GstStaticCaps dirac_caps = GST_STATIC_CAPS (&quot;video/x-dirac&quot;);
5250 
5251 #define DIRAC_CAPS (gst_static_caps_get(&amp;dirac_caps))
5252 static void
5253 dirac_type_find (GstTypeFind * tf, gpointer unused)
5254 {
5255   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5256 
5257   if (data) {
5258     if (memcmp (data, &quot;BBCD&quot;, 4) == 0 || memcmp (data, &quot;KW-DIRAC&quot;, 8) == 0) {
5259       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DIRAC_CAPS);
5260     }
5261   }
5262 }
5263 
<a name="39" id="anc39"></a><span class="line-added">5264 /*** audio/x-tap-tap ***/</span>
<span class="line-added">5265 </span>
<span class="line-added">5266 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,</span>
<span class="line-added">5267  * as it is only possible to register one typefind factory per &#39;name&#39;</span>
<span class="line-added">5268  * (which is in this case the caps), and the first one would be replaced by</span>
<span class="line-added">5269  * the second one. */</span>
<span class="line-added">5270 static GstStaticCaps tap_caps = GST_STATIC_CAPS (&quot;audio/x-tap-tap&quot;);</span>
<span class="line-added">5271 </span>
<span class="line-added">5272 #define TAP_CAPS (gst_static_caps_get(&amp;tap_caps))</span>
<span class="line-added">5273 static void</span>
<span class="line-added">5274 tap_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="line-added">5275 {</span>
<span class="line-added">5276   const guint8 *data = gst_type_find_peek (tf, 0, 16);</span>
<span class="line-added">5277 </span>
<span class="line-added">5278   if (data) {</span>
<span class="line-added">5279     if (memcmp (data, &quot;C64-TAPE-RAW&quot;, 12) == 0</span>
<span class="line-added">5280         || memcmp (data, &quot;C16-TAPE-RAW&quot;, 12) == 0) {</span>
<span class="line-added">5281       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TAP_CAPS);</span>
<span class="line-added">5282     }</span>
<span class="line-added">5283   }</span>
<span class="line-added">5284 }</span>
<span class="line-added">5285 </span>
5286 /*** video/vivo ***/
5287 
5288 static GstStaticCaps vivo_caps = GST_STATIC_CAPS (&quot;video/vivo&quot;);
5289 
5290 #define VIVO_CAPS gst_static_caps_get(&amp;vivo_caps)
5291 
5292 static void
5293 vivo_type_find (GstTypeFind * tf, gpointer unused)
5294 {
5295   static const guint8 vivo_marker[] = { &#39;V&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;,
5296     &#39;:&#39;, &#39;V&#39;, &#39;i&#39;, &#39;v&#39;, &#39;o&#39;, &#39;/&#39;
5297   };
5298   const guint8 *data;
5299   guint hdr_len, pos;
5300 
5301   data = gst_type_find_peek (tf, 0, 1024);
5302   if (data == NULL || data[0] != 0x00)
5303     return;
5304 
5305   if ((data[1] &amp; 0x80)) {
5306     if ((data[2] &amp; 0x80))
5307       return;
5308     hdr_len = ((guint) (data[1] &amp; 0x7f)) &lt;&lt; 7;
5309     hdr_len += data[2];
5310     if (hdr_len &gt; 2048)
5311       return;
5312     pos = 3;
5313   } else {
5314     hdr_len = data[1];
5315     pos = 2;
5316   }
5317 
5318   /* 1008 = 1022 - strlen (&quot;Version:Vivo/&quot;) - 1 */
5319   while (pos &lt; 1008 &amp;&amp; data[pos] == &#39;\r&#39; &amp;&amp; data[pos + 1] == &#39;\n&#39;)
5320     pos += 2;
5321 
5322   if (memcmp (data + pos, vivo_marker, sizeof (vivo_marker)) == 0) {
5323     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, VIVO_CAPS);
5324   }
5325 }
5326 
5327 /*** XDG MIME typefinder (to avoid false positives mostly) ***/
5328 
5329 #ifdef USE_GIO
5330 static void
5331 xdgmime_typefind (GstTypeFind * find, gpointer user_data)
5332 {
5333   gchar *mimetype;
5334   gsize length = 16384;
5335   guint64 tf_length;
5336   const guint8 *data;
5337   gchar *tmp;
5338 
5339   if ((tf_length = gst_type_find_get_length (find)) &gt; 0)
5340     length = MIN (length, tf_length);
5341 
5342   if ((data = gst_type_find_peek (find, 0, length)) == NULL)
5343     return;
5344 
5345   tmp = g_content_type_guess (NULL, data, length, NULL);
5346   if (tmp == NULL || g_content_type_is_unknown (tmp)) {
5347     g_free (tmp);
5348     return;
5349   }
5350 
5351   mimetype = g_content_type_get_mime_type (tmp);
5352   g_free (tmp);
5353 
5354   if (mimetype == NULL)
5355     return;
5356 
5357   GST_DEBUG (&quot;Got mimetype &#39;%s&#39;&quot;, mimetype);
5358 
5359   /* Ignore audio/video types:
5360    *  - our own typefinders in -base are likely to be better at this
5361    *    (and if they&#39;re not, we really want to fix them, that&#39;s why we don&#39;t
5362    *    report xdg-detected audio/video types at all, not even with a low
5363    *    probability)
5364    *  - we want to detect GStreamer media types and not MIME types
5365    *  - the purpose of this xdg mime finder is mainly to prevent false
5366    *    positives of non-media formats, not to typefind audio/video formats */
5367   if (g_str_has_prefix (mimetype, &quot;audio/&quot;) ||
5368       g_str_has_prefix (mimetype, &quot;video/&quot;)) {
5369     GST_LOG (&quot;Ignoring audio/video mime type&quot;);
5370     g_free (mimetype);
5371     return;
5372   }
5373 
5374   /* Again, we mainly want the xdg typefinding to prevent false-positives on
5375    * non-media formats, so suggest the type with a probability that trumps
5376    * uncertain results of our typefinders, but not more than that. */
5377   GST_LOG (&quot;Suggesting &#39;%s&#39; with probability POSSIBLE&quot;, mimetype);
5378   gst_type_find_suggest_simple (find, GST_TYPE_FIND_POSSIBLE, mimetype, NULL);
5379   g_free (mimetype);
5380 }
5381 #endif /* USE_GIO */
5382 
5383 /*** Windows icon typefinder (to avoid false positives mostly) ***/
5384 
5385 static void
5386 windows_icon_typefind (GstTypeFind * find, gpointer user_data)
5387 {
5388   const guint8 *data;
5389   gint64 datalen;
5390   guint16 type, nimages;
5391   gint32 size, offset;
5392 
5393   datalen = gst_type_find_get_length (find);
5394   if (datalen &lt; 22)
5395     return;
5396   if ((data = gst_type_find_peek (find, 0, 6)) == NULL)
5397     return;
5398 
5399   /* header - simple and not enough to rely on it alone */
5400   if (GST_READ_UINT16_LE (data) != 0)
5401     return;
5402   type = GST_READ_UINT16_LE (data + 2);
5403   if (type != 1 &amp;&amp; type != 2)
5404     return;
5405   nimages = GST_READ_UINT16_LE (data + 4);
5406   if (nimages == 0)             /* we can assume we can&#39;t have an empty image file ? */
5407     return;
5408 
5409   /* first image */
5410   if (data[6 + 3] != 0)
5411     return;
5412   if (type == 1) {
5413     guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);
5414     if (planes &gt; 1)
5415       return;
5416   }
5417   size = GST_READ_UINT32_LE (data + 6 + 8);
5418   offset = GST_READ_UINT32_LE (data + 6 + 12);
5419   if (offset &lt; 0 || size &lt;= 0 || size &gt;= datalen || offset &gt;= datalen
5420       || size + offset &gt; datalen)
5421     return;
5422 
5423   gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,
5424       &quot;image/x-icon&quot;, NULL);
5425 }
5426 
5427 /*** WAP WBMP typefinder ***/
5428 
5429 static void
5430 wbmp_typefind (GstTypeFind * find, gpointer user_data)
5431 {
5432   const guint8 *data;
5433   gint64 datalen;
5434   guint w, h, size;
5435 
5436   /* http://en.wikipedia.org/wiki/Wireless_Application_Protocol_Bitmap_Format */
5437   datalen = gst_type_find_get_length (find);
5438   if (datalen == 0)
5439     return;
5440 
5441   data = gst_type_find_peek (find, 0, 5);
5442   if (data == NULL)
5443     return;
5444 
5445   /* want 0x00 0x00 at start */
5446   if (*data++ != 0 || *data++ != 0)
5447     return;
5448 
5449   /* min header size */
5450   size = 4;
5451 
5452   /* let&#39;s assume max width/height is 65536 */
5453   w = *data++;
5454   if ((w &amp; 0x80)) {
5455     w = (w &lt;&lt; 8) | *data++;
5456     if ((w &amp; 0x80))
5457       return;
5458     ++size;
5459     data = gst_type_find_peek (find, 4, 2);
5460     if (data == NULL)
5461       return;
5462   }
5463   h = *data++;
5464   if ((h &amp; 0x80)) {
5465     h = (h &lt;&lt; 8) | *data++;
5466     if ((h &amp; 0x80))
5467       return;
5468     ++size;
5469   }
5470 
5471   if (w == 0 || h == 0)
5472     return;
5473 
5474   /* now add bitmap size */
5475   size += h * (GST_ROUND_UP_8 (w) / 8);
5476 
5477   if (datalen == size) {
5478     gst_type_find_suggest_simple (find, GST_TYPE_FIND_POSSIBLE - 10,
5479         &quot;image/vnd.wap.wbmp&quot;, NULL);
5480   }
5481 }
5482 
5483 /*** DEGAS Atari images (also to avoid false positives, see #625129) ***/
5484 static void
5485 degas_type_find (GstTypeFind * tf, gpointer private)
5486 {
5487   /* No magic, but it should have a fixed size and a few invalid values */
5488   /* http://www.fileformat.info/format/atari/spec/6ecf9f6eb5be494284a47feb8a214687/view.htm */
5489   gint64 len;
5490   const guint8 *data;
5491   guint16 resolution;
5492   int n;
5493 
5494   len = gst_type_find_get_length (tf);
5495   if (len &lt; 34)                 /* smallest header of the lot */
5496     return;
5497   data = gst_type_find_peek (tf, 0, 4);
5498   if (G_UNLIKELY (data == NULL))
5499     return;
5500   resolution = GST_READ_UINT16_BE (data);
5501   if (len == 32034) {
5502     /* could be DEGAS */
5503     if (resolution &lt;= 2)
5504       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5505           &quot;image/x-degas&quot;, NULL);
5506   } else if (len == 32066) {
5507     /* could be DEGAS Elite */
5508     if (resolution &lt;= 2) {
5509       data = gst_type_find_peek (tf, len - 16, 8);
5510       if (G_UNLIKELY (data == NULL))
5511         return;
5512       for (n = 0; n &lt; 4; n++) {
5513         if (GST_READ_UINT16_BE (data + n * 2) &gt; 2)
5514           return;
5515       }
5516       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5517           &quot;image/x-degas&quot;, NULL);
5518     }
5519   } else if (len &gt;= 66 &amp;&amp; len &lt; 32066) {
5520     /* could be compressed DEGAS Elite, but it&#39;s compressed and so we can&#39;t rely on size,
5521        it does have 4 16 bytes values near the end that are 0-2 though. */
5522     if ((resolution &amp; 0x8000) &amp;&amp; (resolution &amp; 0x7fff) &lt;= 2) {
5523       data = gst_type_find_peek (tf, len - 16, 8);
5524       if (G_UNLIKELY (data == NULL))
5525         return;
5526       for (n = 0; n &lt; 4; n++) {
5527         if (GST_READ_UINT16_BE (data + n * 2) &gt; 2)
5528           return;
5529       }
5530       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5531           &quot;image/x-degas&quot;, NULL);
5532     }
5533   }
5534 }
5535 
5536 /*** y4m ***/
5537 
5538 static void
5539 y4m_typefind (GstTypeFind * tf, gpointer private)
5540 {
5541   const guint8 *data;
5542 
5543   data = gst_type_find_peek (tf, 0, 10);
5544   if (data != NULL &amp;&amp; memcmp (data, &quot;YUV4MPEG2 &quot;, 10) == 0) {
5545     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY,
5546         &quot;application/x-yuv4mpeg&quot;, &quot;y4mversion&quot;, G_TYPE_INT, 2, NULL);
5547   }
5548 }
5549 
5550 /*** DVD ISO images (looks like H.264, see #674069) ***/
5551 static void
5552 dvdiso_type_find (GstTypeFind * tf, gpointer private)
5553 {
5554   /* 0x8000 bytes of zeros, then &quot;\001CD001&quot; */
5555   gint64 len;
5556   const guint8 *data;
5557 
5558   len = gst_type_find_get_length (tf);
5559   if (len &lt; 0x8006)
5560     return;
5561   data = gst_type_find_peek (tf, 0, 0x8006);
5562   if (G_UNLIKELY (data == NULL))
5563     return;
5564   for (len = 0; len &lt; 0x8000; len++)
5565     if (data[len])
5566       return;
5567   /* Can the &#39;1&#39; be anything else ? My three samples all have &#39;1&#39;. */
5568   if (memcmp (data + 0x8000, &quot;\001CD001&quot;, 6))
5569     return;
5570 
5571   /* May need more inspection, we may be able to demux some of them */
5572   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY,
5573       &quot;application/octet-stream&quot;, NULL);
5574 }
5575 
5576 /* SSA/ASS subtitles
5577  *
5578  * http://en.wikipedia.org/wiki/SubStation_Alpha
5579  * http://matroska.org/technical/specs/subtitles/ssa.html
5580  */
5581 static void
5582 ssa_type_find (GstTypeFind * tf, gpointer private)
5583 {
5584   const gchar *start, *end, *ver_str, *media_type = NULL;
5585   const guint8 *data;
5586   gchar *str, *script_type, *p = NULL;
5587   gint64 len;
5588 
5589   data = gst_type_find_peek (tf, 0, 32);
5590 
5591   if (data == NULL)
5592     return;
5593 
5594   /* FIXME: detect utf-16/32 BOM and convert before typefinding the rest */
5595 
5596   /* there might be a UTF-8 BOM at the beginning */
5597   if (memcmp (data, &quot;[Script Info]&quot;, 13) != 0 &amp;&amp;
5598       memcmp (data + 3, &quot;[Script Info]&quot;, 13) != 0) {
5599     return;
5600   }
5601 
5602   /* now check if we have SSA or ASS */
5603   len = gst_type_find_get_length (tf);
5604   if (len &gt; 8192)
5605     len = 8192;
5606 
5607   data = gst_type_find_peek (tf, 0, len);
5608   if (data == NULL)
5609     return;
5610 
5611   /* skip BOM */
5612   start = (gchar *) memchr (data, &#39;[&#39;, 5);
5613   g_assert (start);
5614   len -= (start - (gchar *) data);
5615 
5616   /* ignore anything non-UTF8 for now, in future we might at least allow
5617    * other UTF variants that are clearly prefixed with the appropriate BOM */
5618   if (!g_utf8_validate (start, len, &amp;end) &amp;&amp; (len - (end - start)) &gt; 6) {
5619     GST_FIXME (&quot;non-UTF8 SSA/ASS file&quot;);
5620     return;
5621   }
5622 
5623   /* something at start,  but not a UTF-8 BOM? */
5624   if (data[0] != &#39;[&#39; &amp;&amp; (data[0] != 0xEF || data[1] != 0xBB || data[2] != 0xBF))
5625     return;
5626 
5627   /* ignore any partial UTF-8 characters at the end */
5628   len = end - start;
5629 
5630   /* create a NUL-terminated string so it&#39;s easier to process it safely */
5631   str = g_strndup (start, len - 1);
5632   script_type = strstr (str, &quot;ScriptType:&quot;);
5633   if (script_type != NULL) {
5634     gdouble version;
5635 
5636     ver_str = script_type + 11;
5637     while (*ver_str == &#39; &#39; || *ver_str == &#39;v&#39; || *ver_str == &#39;V&#39;)
5638       ++ver_str;
5639     version = g_ascii_strtod (ver_str, &amp;p);
5640     if (version == 4.0 &amp;&amp; p != NULL &amp;&amp; *p == &#39;+&#39;)
5641       media_type = &quot;application/x-ass&quot;;
5642     else if (version &gt;= 1.0 &amp;&amp; version &lt;= 4.0)
5643       media_type = &quot;application/x-ssa&quot;;
5644   }
5645 
5646   if (media_type == NULL) {
5647     if (strstr (str, &quot;[v4+ Styles]&quot;) || strstr (str, &quot;[V4+ Styles]&quot;))
5648       media_type = &quot;application/x-ass&quot;;
5649     else if (strstr (str, &quot;[v4 Styles]&quot;) || strstr (str, &quot;[V4 Styles]&quot;))
5650       media_type = &quot;application/x-ssa&quot;;
5651   }
5652 
5653   if (media_type != NULL) {
5654     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
5655         media_type, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5656   } else {
5657     GST_WARNING (&quot;could not detect SSA/ASS variant&quot;);
5658   }
5659 
5660   g_free (str);
5661 }
5662 
<a name="40" id="anc40"></a><span class="line-added">5663 /*** application/x-mcc ***/</span>
<span class="line-added">5664 static GstStaticCaps mcc_caps = GST_STATIC_CAPS (&quot;application/x-mcc&quot;);</span>
<span class="line-added">5665 </span>
<span class="line-added">5666 #define MCC_CAPS gst_static_caps_get(&amp;mcc_caps)</span>
<span class="line-added">5667 </span>
<span class="line-added">5668 static void</span>
<span class="line-added">5669 mcc_type_find (GstTypeFind * tf, gpointer private)</span>
<span class="line-added">5670 {</span>
<span class="line-added">5671   const guint8 *data;</span>
<span class="line-added">5672 </span>
<span class="line-added">5673   data = gst_type_find_peek (tf, 0, 31);</span>
<span class="line-added">5674 </span>
<span class="line-added">5675   if (data == NULL)</span>
<span class="line-added">5676     return;</span>
<span class="line-added">5677 </span>
<span class="line-added">5678   /* MCC files always start with this followed by the version */</span>
<span class="line-added">5679   if (memcmp (data, &quot;File Format=MacCaption_MCC V&quot;, 28) != 0 ||</span>
<span class="line-added">5680       !g_ascii_isdigit (data[28]) || data[29] != &#39;.&#39; ||</span>
<span class="line-added">5681       !g_ascii_isdigit (data[30])) {</span>
<span class="line-added">5682     return;</span>
<span class="line-added">5683   }</span>
<span class="line-added">5684 </span>
<span class="line-added">5685   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-added">5686       &quot;application/x-mcc&quot;, &quot;version&quot;, G_TYPE_INT, data[28] - &#39;0&#39;, NULL);</span>
<span class="line-added">5687 }</span>
<span class="line-added">5688 </span>
5689 /*** video/x-pva ***/
5690 
5691 static GstStaticCaps pva_caps = GST_STATIC_CAPS (&quot;video/x-pva&quot;);
5692 
5693 #define PVA_CAPS gst_static_caps_get(&amp;pva_caps)
5694 
5695 static void
5696 pva_type_find (GstTypeFind * tf, gpointer private)
5697 {
5698   const guint8 *data;
5699 
5700   data = gst_type_find_peek (tf, 0, 5);
5701 
5702   if (data == NULL)
5703     return;
5704 
5705   if (data[0] == &#39;A&#39; &amp;&amp; data[1] == &#39;V&#39; &amp;&amp; data[2] &lt; 3 &amp;&amp; data[4] == 0x55)
5706     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, PVA_CAPS);
5707 }
5708 
5709 /*** audio/audible ***/
5710 
5711 /* derived from pyaudibletags
5712  * http://code.google.com/p/pyaudibletags/source/browse/trunk/pyaudibletags.py
5713  */
5714 static GstStaticCaps aa_caps = GST_STATIC_CAPS (&quot;audio/x-audible&quot;);
5715 
5716 #define AA_CAPS gst_static_caps_get(&amp;aa_caps)
5717 
5718 static void
5719 aa_type_find (GstTypeFind * tf, gpointer private)
5720 {
5721   const guint8 *data;
5722 
5723   data = gst_type_find_peek (tf, 0, 12);
5724   if (data == NULL)
5725     return;
5726 
5727   if (GST_READ_UINT32_BE (data + 4) == 0x57907536) {
5728     guint64 media_len;
5729 
5730     media_len = gst_type_find_get_length (tf);
5731     if (media_len &gt; 0 &amp;&amp; GST_READ_UINT32_BE (data) == media_len)
5732       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, AA_CAPS);
5733     else
5734       gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, AA_CAPS);
5735   }
5736 }
5737 
5738 /*** generic typefind for streams that have some data at a specific position***/
5739 typedef struct
5740 {
5741   const guint8 *data;
5742   guint size;
5743   guint probability;
5744   GstCaps *caps;
5745 }
5746 GstTypeFindData;
5747 
5748 static void
5749 start_with_type_find (GstTypeFind * tf, gpointer private)
5750 {
5751   GstTypeFindData *start_with = (GstTypeFindData *) private;
5752   const guint8 *data;
5753 
5754   GST_LOG (&quot;trying to find mime type %s with the first %u bytes of data&quot;,
5755       gst_structure_get_name (gst_caps_get_structure (start_with-&gt;caps, 0)),
5756       start_with-&gt;size);
5757   data = gst_type_find_peek (tf, 0, start_with-&gt;size);
5758   if (data &amp;&amp; memcmp (data, start_with-&gt;data, start_with-&gt;size) == 0) {
5759     gst_type_find_suggest (tf, start_with-&gt;probability, start_with-&gt;caps);
5760   }
5761 }
5762 
5763 static void
5764 sw_data_destroy (GstTypeFindData * sw_data)
5765 {
5766   if (G_LIKELY (sw_data-&gt;caps != NULL))
5767     gst_caps_unref (sw_data-&gt;caps);
5768   g_slice_free (GstTypeFindData, sw_data);
5769 }
5770 
5771 #define TYPE_FIND_REGISTER_START_WITH(plugin,name,rank,ext,_data,_size,_probability)\
5772 G_BEGIN_DECLS{                                                          \
5773   GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \
5774   sw_data-&gt;data = (const guint8 *)_data;                                \
5775   sw_data-&gt;size = _size;                                                \
5776   sw_data-&gt;probability = _probability;                                  \
5777   sw_data-&gt;caps = gst_caps_new_empty_simple (name);                     \
5778   if (!gst_type_find_register (plugin, name, rank, start_with_type_find,\
5779                      ext, sw_data-&gt;caps, sw_data,                       \
5780                      (GDestroyNotify) (sw_data_destroy))) {             \
5781     sw_data_destroy (sw_data);                                          \
5782   }                                                                     \
5783 }G_END_DECLS
5784 
5785 /*** same for riff types ***/
5786 
5787 static void
5788 riff_type_find (GstTypeFind * tf, gpointer private)
5789 {
5790   GstTypeFindData *riff_data = (GstTypeFindData *) private;
5791   const guint8 *data = gst_type_find_peek (tf, 0, 12);
5792 
5793   if (data &amp;&amp; (memcmp (data, &quot;RIFF&quot;, 4) == 0 || memcmp (data, &quot;AVF0&quot;, 4) == 0)) {
5794     data += 8;
5795     if (memcmp (data, riff_data-&gt;data, 4) == 0)
5796       gst_type_find_suggest (tf, riff_data-&gt;probability, riff_data-&gt;caps);
5797   }
5798 }
5799 
5800 #define TYPE_FIND_REGISTER_RIFF(plugin,name,rank,ext,_data)             \
5801 G_BEGIN_DECLS{                                                          \
5802   GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \
5803   sw_data-&gt;data = (gpointer)_data;                                      \
5804   sw_data-&gt;size = 4;                                                    \
5805   sw_data-&gt;probability = GST_TYPE_FIND_MAXIMUM;                         \
5806   sw_data-&gt;caps = gst_caps_new_empty_simple (name);                     \
5807   if (!gst_type_find_register (plugin, name, rank, riff_type_find,      \
5808                       ext, sw_data-&gt;caps, sw_data,                      \
5809                       (GDestroyNotify) (sw_data_destroy))) {            \
5810     sw_data_destroy (sw_data);                                          \
5811   }                                                                     \
5812 }G_END_DECLS
5813 
5814 
5815 /*** plugin initialization ***/
5816 
5817 #define TYPE_FIND_REGISTER(plugin,name,rank,func,ext,caps,priv,notify) \
5818 G_BEGIN_DECLS{\
5819   if (!gst_type_find_register (plugin, name, rank, func, ext, caps, priv, notify))\
5820     return FALSE; \
5821 }G_END_DECLS
5822 
5823 
5824 #ifdef GSTREAMER_LITE
5825 gboolean
5826 plugin_init_typefind (GstPlugin * plugin)
5827 #else // GSTREAMER_LITE
5828 static gboolean
5829 plugin_init (GstPlugin * plugin)
5830 #endif // GSTREAMER_LITE
5831 {
5832   /* can&#39;t initialize this via a struct as caps can&#39;t be statically initialized */
5833 
5834   GST_DEBUG_CATEGORY_INIT (type_find_debug, &quot;typefindfunctions&quot;,
5835       GST_DEBUG_FG_GREEN | GST_DEBUG_BG_RED, &quot;generic type find functions&quot;);
5836 
5837   /* note: asx/wax/wmx are XML files, asf doesn&#39;t handle them */
5838   /* must use strings, macros don&#39;t accept initializers */
5839 #ifndef GSTREAMER_LITE
5840   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ms-asf&quot;, GST_RANK_SECONDARY,
5841       &quot;asf,wm,wma,wmv&quot;,
5842       &quot;\060\046\262\165\216\146\317\021\246\331\000\252\000\142\316\154&quot;, 16,
5843       GST_TYPE_FIND_MAXIMUM);
5844   TYPE_FIND_REGISTER (plugin, &quot;audio/x-musepack&quot;, GST_RANK_PRIMARY,
5845       musepack_type_find, &quot;mpc,mpp,mp+&quot;, MUSEPACK_CAPS, NULL, NULL);
5846   TYPE_FIND_REGISTER (plugin, &quot;audio/x-au&quot;, GST_RANK_MARGINAL,
5847       au_type_find, &quot;au,snd&quot;, AU_CAPS, NULL, NULL);
5848   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-msvideo&quot;, GST_RANK_PRIMARY,
5849       &quot;avi&quot;, &quot;AVI &quot;);
5850   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/qcelp&quot;, GST_RANK_PRIMARY,
5851       &quot;qcp&quot;, &quot;QLCM&quot;);
5852   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-cdxa&quot;, GST_RANK_PRIMARY,
5853       &quot;dat&quot;, &quot;CDXA&quot;);
5854   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-vcd&quot;, GST_RANK_PRIMARY,
5855       &quot;dat&quot;, &quot;\000\377\377\377\377\377\377\377\377\377\377\000&quot;, 12,
5856       GST_TYPE_FIND_MAXIMUM);
5857   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-imelody&quot;, GST_RANK_PRIMARY,
5858       &quot;imy,ime,imelody&quot;, &quot;BEGIN:IMELODY&quot;, 13, GST_TYPE_FIND_MAXIMUM);
<a name="41" id="anc41"></a><span class="line-added">5859   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-scc&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">5860       &quot;scc&quot;, &quot;Scenarist_SCC V1.0&quot;, 18, GST_TYPE_FIND_MAXIMUM);</span>
<span class="line-added">5861   TYPE_FIND_REGISTER (plugin, &quot;application/x-mcc&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">5862       mcc_type_find, &quot;mcc&quot;, MCC_CAPS, NULL, NULL);</span>
<span class="line-added">5863 </span>
5864 #if 0
5865   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-smoke&quot;, GST_RANK_PRIMARY,
5866       NULL, &quot;\x80smoke\x00\x01\x00&quot;, 6, GST_TYPE_FIND_MAXIMUM);
5867 #endif
5868   TYPE_FIND_REGISTER (plugin, &quot;audio/midi&quot;, GST_RANK_PRIMARY, mid_type_find,
5869       &quot;mid,midi&quot;, MID_CAPS, NULL, NULL);
5870   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/riff-midi&quot;, GST_RANK_PRIMARY,
5871       &quot;mid,midi&quot;, &quot;RMID&quot;);
5872   TYPE_FIND_REGISTER (plugin, &quot;audio/mobile-xmf&quot;, GST_RANK_PRIMARY,
5873       mxmf_type_find, &quot;mxmf&quot;, MXMF_CAPS, NULL, NULL);
5874   TYPE_FIND_REGISTER (plugin, &quot;video/x-fli&quot;, GST_RANK_MARGINAL, flx_type_find,
5875       &quot;flc,fli&quot;, FLX_CAPS, NULL, NULL);
5876   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v2&quot;, GST_RANK_PRIMARY + 103,
5877       id3v2_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5878   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v1&quot;, GST_RANK_PRIMARY + 101,
5879       id3v1_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5880   TYPE_FIND_REGISTER (plugin, &quot;application/x-apetag&quot;, GST_RANK_PRIMARY + 102,
5881       apetag_type_find, &quot;mp3,ape,mpc,wv&quot;, APETAG_CAPS, NULL, NULL);
5882   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ttafile&quot;, GST_RANK_PRIMARY,
5883       tta_type_find, &quot;tta&quot;, TTA_CAPS, NULL, NULL);
5884   TYPE_FIND_REGISTER (plugin, &quot;audio/x-mod&quot;, GST_RANK_SECONDARY, mod_type_find,
5885       &quot;669,amf,ams,dbm,digi,dmf,dsm,gdm,far,imf,it,j2b,mdl,med,mod,mt2,mtm,&quot;
5886       &quot;okt,psm,ptm,sam,s3m,stm,stx,ult,umx,xm&quot;, MOD_CAPS, NULL, NULL);
5887 #endif // GSTREAMER_LITE
5888   TYPE_FIND_REGISTER (plugin, &quot;audio/mpeg&quot;, GST_RANK_PRIMARY, mp3_type_find,
5889       &quot;mp3,mp2,mp1,mpga&quot;, MP3_CAPS, NULL, NULL);
5890 #ifndef GSTREAMER_LITE
5891   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ac3&quot;, GST_RANK_PRIMARY, ac3_type_find,
5892       &quot;ac3,eac3&quot;, AC3_CAPS, NULL, NULL);
5893   TYPE_FIND_REGISTER (plugin, &quot;audio/x-dts&quot;, GST_RANK_SECONDARY, dts_type_find,
5894       &quot;dts&quot;, DTS_CAPS, NULL, NULL);
5895   TYPE_FIND_REGISTER (plugin, &quot;audio/x-gsm&quot;, GST_RANK_PRIMARY, NULL, &quot;gsm&quot;,
5896       GSM_CAPS, NULL, NULL);
5897   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg-sys&quot;, GST_RANK_PRIMARY,
5898       mpeg_sys_type_find, &quot;mpe,mpeg,mpg&quot;, MPEG_SYS_CAPS, NULL, NULL);
5899   TYPE_FIND_REGISTER (plugin, &quot;video/mpegts&quot;, GST_RANK_PRIMARY,
5900       mpeg_ts_type_find, &quot;ts,mts&quot;, MPEGTS_CAPS, NULL, NULL);
5901   TYPE_FIND_REGISTER (plugin, &quot;application/ogg&quot;, GST_RANK_PRIMARY,
5902       ogganx_type_find, &quot;ogg,oga,ogv,ogm,ogx,spx,anx,axa,axv&quot;, OGG_CAPS,
5903       NULL, NULL);
5904   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg-elementary&quot;, GST_RANK_MARGINAL,
5905       mpeg_video_stream_type_find, &quot;mpv,mpeg,mpg&quot;, MPEG_VIDEO_CAPS, NULL, NULL);
5906   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg4&quot;, GST_RANK_PRIMARY,
5907       mpeg4_video_type_find, &quot;m4v&quot;, MPEG_VIDEO_CAPS, NULL, NULL);
5908   TYPE_FIND_REGISTER (plugin, &quot;video/x-h263&quot;, GST_RANK_SECONDARY,
5909       h263_video_type_find, &quot;h263,263&quot;, H263_VIDEO_CAPS, NULL, NULL);
5910   TYPE_FIND_REGISTER (plugin, &quot;video/x-h264&quot;, GST_RANK_PRIMARY,
5911       h264_video_type_find, &quot;h264,x264,264&quot;, H264_VIDEO_CAPS, NULL, NULL);
5912   TYPE_FIND_REGISTER (plugin, &quot;video/x-h265&quot;, GST_RANK_PRIMARY,
5913       h265_video_type_find, &quot;h265,x265,265&quot;, H265_VIDEO_CAPS, NULL, NULL);
5914   TYPE_FIND_REGISTER (plugin, &quot;video/x-nuv&quot;, GST_RANK_SECONDARY, nuv_type_find,
5915       &quot;nuv&quot;, NUV_CAPS, NULL, NULL);
5916 
5917   /* ISO formats */
5918   TYPE_FIND_REGISTER (plugin, &quot;audio/x-m4a&quot;, GST_RANK_PRIMARY, m4a_type_find,
5919       &quot;m4a&quot;, M4A_CAPS, NULL, NULL);
5920   TYPE_FIND_REGISTER (plugin, &quot;application/x-3gp&quot;, GST_RANK_PRIMARY,
5921       q3gp_type_find, &quot;3gp&quot;, Q3GP_CAPS, NULL, NULL);
5922   TYPE_FIND_REGISTER (plugin, &quot;video/quicktime&quot;, GST_RANK_PRIMARY,
5923       qt_type_find, &quot;mov,mp4&quot;, QT_CAPS, NULL, NULL);
5924   TYPE_FIND_REGISTER (plugin, &quot;image/x-quicktime&quot;, GST_RANK_SECONDARY,
5925       qtif_type_find, &quot;qif,qtif,qti&quot;, QTIF_CAPS, NULL, NULL);
5926   TYPE_FIND_REGISTER (plugin, &quot;image/jp2&quot;, GST_RANK_PRIMARY,
5927       jp2_type_find, &quot;jp2&quot;, JP2_CAPS, NULL, NULL);
5928   TYPE_FIND_REGISTER (plugin, &quot;image/x-jpc&quot;, GST_RANK_PRIMARY,
5929       jpc_type_find, &quot;jpc,j2k&quot;, JPC_CAPS, NULL, NULL);
5930   TYPE_FIND_REGISTER (plugin, &quot;video/mj2&quot;, GST_RANK_PRIMARY,
5931       jp2_type_find, &quot;mj2&quot;, MJ2_CAPS, NULL, NULL);
5932 
5933   TYPE_FIND_REGISTER (plugin, &quot;text/html&quot;, GST_RANK_SECONDARY, html_type_find,
5934       &quot;htm,html&quot;, HTML_CAPS, NULL, NULL);
5935   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/vnd.rn-realmedia&quot;,
5936       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.RMF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5937   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-pn-realaudio&quot;,
5938       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.ra\375&quot;, 4,
5939       GST_TYPE_FIND_MAXIMUM);
5940   TYPE_FIND_REGISTER (plugin, &quot;application/x-shockwave-flash&quot;,
5941       GST_RANK_SECONDARY, swf_type_find, &quot;swf,swfl&quot;, SWF_CAPS, NULL, NULL);
<a name="42" id="anc42"></a><span class="line-added">5942   TYPE_FIND_REGISTER (plugin, &quot;application/xges&quot;,</span>
<span class="line-added">5943       GST_RANK_PRIMARY, xges_type_find, &quot;xges&quot;, XGES_CAPS, NULL, NULL);</span>
5944   TYPE_FIND_REGISTER (plugin, &quot;application/dash+xml&quot;,
5945       GST_RANK_PRIMARY, dash_mpd_type_find, &quot;mpd,MPD&quot;, DASH_CAPS, NULL, NULL);
5946   TYPE_FIND_REGISTER (plugin, &quot;application/vnd.ms-sstr+xml&quot;,
5947       GST_RANK_PRIMARY, mss_manifest_type_find, NULL, MSS_MANIFEST_CAPS, NULL,
5948       NULL);
5949 #endif // GSTREAMER_LITE
5950   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-flv&quot;, GST_RANK_SECONDARY,
5951       &quot;flv&quot;, &quot;FLV&quot;, 3, GST_TYPE_FIND_MAXIMUM);
5952 #ifndef GSTREAMER_LITE
5953   TYPE_FIND_REGISTER (plugin, &quot;text/plain&quot;, GST_RANK_MARGINAL, utf8_type_find,
5954       &quot;txt&quot;, UTF8_CAPS, NULL, NULL);
5955   TYPE_FIND_REGISTER (plugin, &quot;text/utf-16&quot;, GST_RANK_MARGINAL, utf16_type_find,
5956       &quot;txt&quot;, UTF16_CAPS, NULL, NULL);
5957   TYPE_FIND_REGISTER (plugin, &quot;text/utf-32&quot;, GST_RANK_MARGINAL, utf32_type_find,
5958       &quot;txt&quot;, UTF32_CAPS, NULL, NULL);
5959   TYPE_FIND_REGISTER (plugin, &quot;text/uri-list&quot;, GST_RANK_MARGINAL, uri_type_find,
5960       &quot;ram&quot;, URI_CAPS, NULL, NULL);
5961   TYPE_FIND_REGISTER (plugin, &quot;application/itc&quot;, GST_RANK_SECONDARY,
5962       itc_type_find, &quot;itc&quot;, ITC_CAPS, NULL, NULL);
5963   TYPE_FIND_REGISTER (plugin, &quot;application/x-hls&quot;, GST_RANK_MARGINAL,
5964       hls_type_find, &quot;m3u8&quot;, HLS_CAPS, NULL, NULL);
5965   TYPE_FIND_REGISTER (plugin, &quot;application/sdp&quot;, GST_RANK_SECONDARY,
5966       sdp_type_find, &quot;sdp&quot;, SDP_CAPS, NULL, NULL);
5967   TYPE_FIND_REGISTER (plugin, &quot;application/smil&quot;, GST_RANK_SECONDARY,
5968       smil_type_find, &quot;smil&quot;, SMIL_CAPS, NULL, NULL);
5969   TYPE_FIND_REGISTER (plugin, &quot;application/ttml+xml&quot;, GST_RANK_SECONDARY,
5970       ttml_xml_type_find, &quot;ttml+xml&quot;, TTML_XML_CAPS, NULL, NULL);
5971   TYPE_FIND_REGISTER (plugin, &quot;application/xml&quot;, GST_RANK_MARGINAL,
5972       xml_type_find, &quot;xml&quot;, GENERIC_XML_CAPS, NULL, NULL);
5973 #endif // GSTREAMER_LITE
5974   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/x-wav&quot;, GST_RANK_PRIMARY, &quot;wav&quot;,
5975       &quot;WAVE&quot;);
5976   TYPE_FIND_REGISTER (plugin, &quot;audio/x-aiff&quot;, GST_RANK_SECONDARY,
5977       aiff_type_find, &quot;aiff,aif,aifc&quot;, AIFF_CAPS, NULL, NULL);
5978 #ifndef GSTREAMER_LITE
5979   TYPE_FIND_REGISTER (plugin, &quot;audio/x-svx&quot;, GST_RANK_SECONDARY, svx_type_find,
5980       &quot;iff,svx&quot;, SVX_CAPS, NULL, NULL);
5981   TYPE_FIND_REGISTER (plugin, &quot;audio/x-paris&quot;, GST_RANK_SECONDARY,
5982       paris_type_find, &quot;paf&quot;, PARIS_CAPS, NULL, NULL);
5983   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-nist&quot;, GST_RANK_SECONDARY,
5984       &quot;nist&quot;, &quot;NIST&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5985   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-voc&quot;, GST_RANK_SECONDARY,
5986       &quot;voc&quot;, &quot;Creative&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5987   TYPE_FIND_REGISTER (plugin, &quot;audio/x-sds&quot;, GST_RANK_SECONDARY, sds_type_find,
5988       &quot;sds&quot;, SDS_CAPS, NULL, NULL);
5989   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ircam&quot;, GST_RANK_SECONDARY,
5990       ircam_type_find, &quot;sf&quot;, IRCAM_CAPS, NULL, NULL);
5991   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-w64&quot;, GST_RANK_SECONDARY,
5992       &quot;w64&quot;, &quot;riff&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5993   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-rf64&quot;, GST_RANK_PRIMARY,
5994       &quot;rf64&quot;, &quot;RF64&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5995   TYPE_FIND_REGISTER (plugin, &quot;audio/x-shorten&quot;, GST_RANK_SECONDARY,
5996       shn_type_find, &quot;shn&quot;, SHN_CAPS, NULL, NULL);
5997   TYPE_FIND_REGISTER (plugin, &quot;application/x-ape&quot;, GST_RANK_SECONDARY,
5998       ape_type_find, &quot;ape&quot;, APE_CAPS, NULL, NULL);
5999   TYPE_FIND_REGISTER (plugin, &quot;image/jpeg&quot;, GST_RANK_PRIMARY + 15,
6000       jpeg_type_find, &quot;jpg,jpe,jpeg&quot;, JPEG_CAPS, NULL, NULL);
6001   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/gif&quot;, GST_RANK_PRIMARY, &quot;gif&quot;,
6002       &quot;GIF8&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6003   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/png&quot;, GST_RANK_PRIMARY + 14,
6004       &quot;png&quot;, &quot;\211PNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6005   TYPE_FIND_REGISTER (plugin, &quot;image/bmp&quot;, GST_RANK_PRIMARY, bmp_type_find,
6006       &quot;bmp&quot;, BMP_CAPS, NULL, NULL);
6007   TYPE_FIND_REGISTER (plugin, &quot;image/tiff&quot;, GST_RANK_PRIMARY, tiff_type_find,
6008       &quot;tif,tiff&quot;, TIFF_CAPS, NULL, NULL);
6009   TYPE_FIND_REGISTER_RIFF (plugin, &quot;image/webp&quot;, GST_RANK_PRIMARY,
6010       &quot;webp&quot;, &quot;WEBP&quot;);
6011   TYPE_FIND_REGISTER (plugin, &quot;image/x-exr&quot;, GST_RANK_PRIMARY, exr_type_find,
6012       &quot;exr&quot;, EXR_CAPS, NULL, NULL);
6013   TYPE_FIND_REGISTER (plugin, &quot;image/x-portable-pixmap&quot;, GST_RANK_SECONDARY,
6014       pnm_type_find, &quot;pnm,ppm,pgm,pbm&quot;, PNM_CAPS, NULL, NULL);
6015   TYPE_FIND_REGISTER (plugin, &quot;video/x-matroska&quot;, GST_RANK_PRIMARY,
6016       matroska_type_find, &quot;mkv,mka,mk3d,webm&quot;, MATROSKA_CAPS, NULL, NULL);
6017   TYPE_FIND_REGISTER (plugin, &quot;application/mxf&quot;, GST_RANK_PRIMARY,
6018       mxf_type_find, &quot;mxf&quot;, MXF_CAPS, NULL, NULL);
6019   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-mve&quot;, GST_RANK_SECONDARY,
6020       &quot;mve&quot;, &quot;Interplay MVE File\032\000\032\000\000\001\063\021&quot;, 26,
6021       GST_TYPE_FIND_MAXIMUM);
6022   TYPE_FIND_REGISTER (plugin, &quot;video/x-dv&quot;, GST_RANK_SECONDARY, dv_type_find,
6023       &quot;dv,dif&quot;, DV_CAPS, NULL, NULL);
6024   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-amr-nb-sh&quot;, GST_RANK_PRIMARY,
6025       &quot;amr&quot;, &quot;#!AMR&quot;, 5, GST_TYPE_FIND_LIKELY);
6026   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-amr-wb-sh&quot;, GST_RANK_PRIMARY,
6027       &quot;amr&quot;, &quot;#!AMR-WB&quot;, 7, GST_TYPE_FIND_MAXIMUM);
6028   TYPE_FIND_REGISTER (plugin, &quot;audio/iLBC-sh&quot;, GST_RANK_PRIMARY, ilbc_type_find,
6029       &quot;ilbc&quot;, ILBC_CAPS, NULL, NULL);
6030   TYPE_FIND_REGISTER (plugin, &quot;audio/x-sbc&quot;, GST_RANK_MARGINAL, sbc_type_find,
6031       &quot;sbc&quot;, SBC_CAPS, NULL, NULL);
6032   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-sid&quot;, GST_RANK_MARGINAL,
6033       &quot;sid&quot;, &quot;PSID&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6034   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-xcf&quot;, GST_RANK_SECONDARY,
6035       &quot;xcf&quot;, &quot;gimp xcf&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6036   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-mng&quot;, GST_RANK_SECONDARY,
6037       &quot;mng&quot;, &quot;\212MNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6038   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-jng&quot;, GST_RANK_SECONDARY,
6039       &quot;jng&quot;, &quot;\213JNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6040   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-xpixmap&quot;, GST_RANK_SECONDARY,
6041       &quot;xpm&quot;, &quot;/* XPM */&quot;, 9, GST_TYPE_FIND_MAXIMUM);
6042   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-sun-raster&quot;,
6043       GST_RANK_SECONDARY, &quot;ras&quot;, &quot;\131\246\152\225&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6044   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-bzip&quot;,
6045       GST_RANK_SECONDARY, &quot;bz2&quot;, &quot;BZh&quot;, 3, GST_TYPE_FIND_LIKELY);
6046   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-gzip&quot;,
6047       GST_RANK_SECONDARY, &quot;gz&quot;, &quot;\037\213&quot;, 2, GST_TYPE_FIND_LIKELY);
6048   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/zip&quot;, GST_RANK_SECONDARY,
6049       &quot;zip&quot;, &quot;PK\003\004&quot;, 4, GST_TYPE_FIND_LIKELY);
6050   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-compress&quot;,
6051       GST_RANK_SECONDARY, &quot;Z&quot;, &quot;\037\235&quot;, 2, GST_TYPE_FIND_LIKELY);
6052   TYPE_FIND_REGISTER (plugin, &quot;subtitle/x-kate&quot;, GST_RANK_MARGINAL,
6053       kate_type_find, NULL, NULL, NULL, NULL);
6054   TYPE_FIND_REGISTER (plugin, &quot;application/x-subtitle-vtt&quot;, GST_RANK_MARGINAL,
6055       webvtt_type_find, &quot;vtt&quot;, WEBVTT_CAPS, NULL, NULL);
6056   TYPE_FIND_REGISTER (plugin, &quot;audio/x-flac&quot;, GST_RANK_PRIMARY, flac_type_find,
6057       &quot;flac&quot;, FLAC_CAPS, NULL, NULL);
6058   TYPE_FIND_REGISTER (plugin, &quot;audio/x-vorbis&quot;, GST_RANK_PRIMARY,
6059       vorbis_type_find, NULL, VORBIS_CAPS, NULL, NULL);
6060   TYPE_FIND_REGISTER (plugin, &quot;video/x-theora&quot;, GST_RANK_PRIMARY,
6061       theora_type_find, NULL, THEORA_CAPS, NULL, NULL);
6062   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-video&quot;, GST_RANK_PRIMARY,
6063       ogmvideo_type_find, NULL, OGMVIDEO_CAPS, NULL, NULL);
6064   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-audio&quot;, GST_RANK_PRIMARY,
6065       ogmaudio_type_find, NULL, OGMAUDIO_CAPS, NULL, NULL);
6066   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-text&quot;, GST_RANK_PRIMARY,
6067       ogmtext_type_find, NULL, OGMTEXT_CAPS, NULL, NULL);
6068   TYPE_FIND_REGISTER (plugin, &quot;audio/x-speex&quot;, GST_RANK_PRIMARY,
6069       speex_type_find, NULL, SPEEX_CAPS, NULL, NULL);
6070   TYPE_FIND_REGISTER (plugin, &quot;audio/x-celt&quot;, GST_RANK_PRIMARY, celt_type_find,
6071       NULL, CELT_CAPS, NULL, NULL);
6072   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogg-skeleton&quot;, GST_RANK_PRIMARY,
6073       oggskel_type_find, NULL, OGG_SKELETON_CAPS, NULL, NULL);
6074   TYPE_FIND_REGISTER (plugin, &quot;text/x-cmml&quot;, GST_RANK_PRIMARY, cmml_type_find,
6075       NULL, CMML_CAPS, NULL, NULL);
6076   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-executable&quot;,
6077       GST_RANK_MARGINAL, NULL, &quot;\177ELF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6078   TYPE_FIND_REGISTER (plugin, &quot;audio/aac&quot;, GST_RANK_SECONDARY, aac_type_find,
6079       &quot;aac,adts,adif,loas&quot;, AAC_CAPS, NULL, NULL);
6080   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-spc&quot;, GST_RANK_SECONDARY,
6081       &quot;spc&quot;, &quot;SNES-SPC700 Sound File Data&quot;, 27, GST_TYPE_FIND_MAXIMUM);
6082   TYPE_FIND_REGISTER (plugin, &quot;audio/x-wavpack&quot;, GST_RANK_SECONDARY,
6083       wavpack_type_find, &quot;wv,wvp&quot;, WAVPACK_CAPS, NULL, NULL);
6084   TYPE_FIND_REGISTER (plugin, &quot;audio/x-wavpack-correction&quot;, GST_RANK_SECONDARY,
6085       wavpack_type_find, &quot;wvc&quot;, WAVPACK_CORRECTION_CAPS, NULL, NULL);
6086   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-caf&quot;, GST_RANK_SECONDARY,
6087       &quot;caf&quot;, &quot;caff\000\001&quot;, 6, GST_TYPE_FIND_MAXIMUM);
6088   TYPE_FIND_REGISTER (plugin, &quot;application/postscript&quot;, GST_RANK_SECONDARY,
6089       postscript_type_find, &quot;ps&quot;, POSTSCRIPT_CAPS, NULL, NULL);
6090   TYPE_FIND_REGISTER (plugin, &quot;image/svg+xml&quot;, GST_RANK_SECONDARY,
6091       svg_type_find, &quot;svg&quot;, SVG_CAPS, NULL, NULL);
6092   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-rar&quot;,
6093       GST_RANK_SECONDARY, &quot;rar&quot;, &quot;Rar!&quot;, 4, GST_TYPE_FIND_LIKELY);
6094   TYPE_FIND_REGISTER (plugin, &quot;application/x-tar&quot;, GST_RANK_SECONDARY,
6095       tar_type_find, &quot;tar&quot;, TAR_CAPS, NULL, NULL);
6096   TYPE_FIND_REGISTER (plugin, &quot;application/x-ar&quot;, GST_RANK_SECONDARY,
6097       ar_type_find, &quot;a&quot;, AR_CAPS, NULL, NULL);
6098   TYPE_FIND_REGISTER (plugin, &quot;application/x-ms-dos-executable&quot;,
6099       GST_RANK_SECONDARY, msdos_type_find, &quot;dll,exe,ocx,sys,scr,msstyles,cpl&quot;,
6100       MSDOS_CAPS, NULL, NULL);
6101   TYPE_FIND_REGISTER (plugin, &quot;video/x-dirac&quot;, GST_RANK_PRIMARY,
6102       dirac_type_find, NULL, DIRAC_CAPS, NULL, NULL);
6103   TYPE_FIND_REGISTER (plugin, &quot;multipart/x-mixed-replace&quot;, GST_RANK_SECONDARY,
6104       multipart_type_find, NULL, MULTIPART_CAPS, NULL, NULL);
6105   TYPE_FIND_REGISTER (plugin, &quot;application/x-mmsh&quot;, GST_RANK_SECONDARY,
6106       mmsh_type_find, NULL, MMSH_CAPS, NULL, NULL);
6107   TYPE_FIND_REGISTER (plugin, &quot;video/vivo&quot;, GST_RANK_SECONDARY, vivo_type_find,
6108       &quot;viv&quot;, VIVO_CAPS, NULL, NULL);
6109   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-nsf&quot;, GST_RANK_SECONDARY,
6110       &quot;nsf&quot;, &quot;NESM\x1a&quot;, 5, GST_TYPE_FIND_MAXIMUM);
6111   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-gym&quot;, GST_RANK_SECONDARY,
6112       &quot;gym&quot;, &quot;GYMX&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6113   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-ay&quot;, GST_RANK_SECONDARY, &quot;ay&quot;,
6114       &quot;ZXAYEMUL&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6115   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-gbs&quot;, GST_RANK_SECONDARY,
6116       &quot;gbs&quot;, &quot;GBS\x01&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6117   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-vgm&quot;, GST_RANK_SECONDARY,
6118       &quot;vgm&quot;, &quot;Vgm\x20&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6119   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-sap&quot;, GST_RANK_SECONDARY,
6120       &quot;sap&quot;, &quot;SAP\x0d\x0a&quot; &quot;AUTHOR\x20&quot;, 12, GST_TYPE_FIND_MAXIMUM);
6121   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ivf&quot;, GST_RANK_SECONDARY,
6122       &quot;ivf&quot;, &quot;DKIF&quot;, 4, GST_TYPE_FIND_NEARLY_CERTAIN);
6123   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-kss&quot;, GST_RANK_SECONDARY,
6124       &quot;kss&quot;, &quot;KSSX\0&quot;, 5, GST_TYPE_FIND_MAXIMUM);
6125   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/pdf&quot;, GST_RANK_SECONDARY,
6126       &quot;pdf&quot;, &quot;%PDF-&quot;, 5, GST_TYPE_FIND_LIKELY);
6127   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/msword&quot;,
6128       GST_RANK_SECONDARY, &quot;doc&quot;, &quot;\320\317\021\340\241\261\032\341&quot;, 8,
6129       GST_TYPE_FIND_LIKELY);
6130   /* Mac OS X .DS_Store files tend to be taken for video/mpeg */
6131   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/octet-stream&quot;,
6132       GST_RANK_SECONDARY, &quot;DS_Store&quot;, &quot;\000\000\000\001Bud1&quot;, 8,
6133       GST_TYPE_FIND_LIKELY);
6134   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/vnd.adobe.photoshop&quot;,
6135       GST_RANK_SECONDARY, &quot;psd&quot;, &quot;8BPS\000\001\000\000\000\000&quot;, 10,
6136       GST_TYPE_FIND_LIKELY);
6137   TYPE_FIND_REGISTER (plugin, &quot;image/vnd.wap.wbmp&quot;, GST_RANK_MARGINAL,
6138       wbmp_typefind, NULL, NULL, NULL, NULL);
6139   TYPE_FIND_REGISTER (plugin, &quot;application/x-yuv4mpeg&quot;, GST_RANK_SECONDARY,
6140       y4m_typefind, NULL, NULL, NULL, NULL);
6141   TYPE_FIND_REGISTER (plugin, &quot;image/x-icon&quot;, GST_RANK_MARGINAL,
6142       windows_icon_typefind, NULL, NULL, NULL, NULL);
6143 
6144 #ifdef USE_GIO
6145   TYPE_FIND_REGISTER (plugin, &quot;xdgmime-base&quot;, GST_RANK_MARGINAL,
6146       xdgmime_typefind, NULL, NULL, NULL, NULL);
6147 #endif
6148 
6149   TYPE_FIND_REGISTER (plugin, &quot;image/x-degas&quot;, GST_RANK_MARGINAL,
6150       degas_type_find, NULL, NULL, NULL, NULL);
6151   TYPE_FIND_REGISTER (plugin, &quot;application/octet-stream&quot;, GST_RANK_MARGINAL,
6152       dvdiso_type_find, NULL, NULL, NULL, NULL);
6153 
6154   TYPE_FIND_REGISTER (plugin, &quot;application/x-ssa&quot;, GST_RANK_SECONDARY,
6155       ssa_type_find, &quot;ssa,ass&quot;, NULL, NULL, NULL);
6156 
6157   TYPE_FIND_REGISTER (plugin, &quot;video/x-pva&quot;, GST_RANK_SECONDARY,
6158       pva_type_find, &quot;pva&quot;, PVA_CAPS, NULL, NULL);
6159 
6160   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-xi&quot;, GST_RANK_SECONDARY,
6161       &quot;xi&quot;, &quot;Extended Instrument: &quot;, 21, GST_TYPE_FIND_MAXIMUM);
6162 
6163   TYPE_FIND_REGISTER (plugin, &quot;audio/audible&quot;, GST_RANK_MARGINAL,
6164       aa_type_find, &quot;aa,aax&quot;, AA_CAPS, NULL, NULL);
6165 #endif // GSTREAMER_LITE
6166 
<a name="43" id="anc43"></a><span class="line-added">6167   TYPE_FIND_REGISTER (plugin, &quot;audio/x-tap-tap&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">6168       tap_type_find, &quot;tap&quot;, TAP_CAPS, NULL, NULL);</span>
<span class="line-added">6169   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-tap-dmp&quot;,</span>
<span class="line-added">6170       GST_RANK_SECONDARY, &quot;dmp&quot;, &quot;DC2N-TAP-RAW&quot;, 12, GST_TYPE_FIND_LIKELY);</span>
<span class="line-added">6171 </span>
6172   return TRUE;
6173 }
6174 
6175 #ifndef GSTREAMER_LITE
6176 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
6177     GST_VERSION_MINOR,
6178     typefindfunctions,
6179     &quot;default typefind functions&quot;,
6180     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
<a name="44" id="anc44"></a><span class="line-modified">6181 #endif // GSTREAMER_LITE</span>
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>