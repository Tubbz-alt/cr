<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiometa.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstaudioencoder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiometa.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiometa.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  2  * Copyright (C) &lt;2011&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 /**
 21  * SECTION:gstaudiometa
<span class="line-modified"> 22  * @title: GstAudioDownmixMeta</span>
 23  * @short_description: Buffer metadata for audio downmix matrix handling
 24  *
 25  * #GstAudioDownmixMeta defines an audio downmix matrix to be send along with
 26  * audio buffers. These functions in this module help to create and attach the
 27  * meta as well as extracting it.
 28  */



 29 
 30 #include &lt;string.h&gt;
 31 
 32 #include &quot;gstaudiometa.h&quot;
 33 
 34 static gboolean
 35 gst_audio_downmix_meta_init (GstMeta * meta, gpointer params,
 36     GstBuffer * buffer)
 37 {
 38   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 39 
 40   dmeta-&gt;from_position = dmeta-&gt;to_position = NULL;
 41   dmeta-&gt;from_channels = dmeta-&gt;to_channels = 0;
 42   dmeta-&gt;matrix = NULL;
 43 
 44   return TRUE;
 45 }
 46 
 47 static void
 48 gst_audio_downmix_meta_free (GstMeta * meta, GstBuffer * buffer)
 49 {
 50   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 51 
 52   g_free (dmeta-&gt;from_position);
 53   if (dmeta-&gt;matrix) {
 54     g_free (*dmeta-&gt;matrix);
 55     g_free (dmeta-&gt;matrix);
 56   }
 57 }
 58 
 59 static gboolean
 60 gst_audio_downmix_meta_transform (GstBuffer * dest, GstMeta * meta,
 61     GstBuffer * buffer, GQuark type, gpointer data)
 62 {
 63   GstAudioDownmixMeta *smeta, *dmeta;
 64 
 65   smeta = (GstAudioDownmixMeta *) meta;
 66 
 67   if (GST_META_TRANSFORM_IS_COPY (type)) {
 68     dmeta = gst_buffer_add_audio_downmix_meta (dest, smeta-&gt;from_position,
<span class="line-modified"> 69       smeta-&gt;from_channels, smeta-&gt;to_position, smeta-&gt;to_channels,</span>
<span class="line-modified"> 70       (const gfloat **) smeta-&gt;matrix);</span>
 71     if (!dmeta)
 72       return FALSE;
 73   } else {
 74     /* return FALSE, if transform type is not supported */
 75     return FALSE;
 76   }
 77 
 78   return TRUE;
 79 }
 80 
 81 /**
 82  * gst_buffer_get_audio_downmix_meta_for_channels:
 83  * @buffer: a #GstBuffer
 84  * @to_position: (array length=to_channels): the channel positions of
 85  *   the destination
 86  * @to_channels: The number of channels of the destination
 87  *
 88  * Find the #GstAudioDownmixMeta on @buffer for the given destination
 89  * channel positions.
 90  *
</pre>
<hr />
<pre>
287   }
288   return type;
289 }
290 
291 const GstMetaInfo *
292 gst_audio_clipping_meta_get_info (void)
293 {
294   static const GstMetaInfo *audio_clipping_meta_info = NULL;
295 
296   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_clipping_meta_info)) {
297     const GstMetaInfo *meta =
298         gst_meta_register (GST_AUDIO_CLIPPING_META_API_TYPE,
299         &quot;GstAudioClippingMeta&quot;, sizeof (GstAudioClippingMeta),
300         gst_audio_clipping_meta_init, NULL,
301         gst_audio_clipping_meta_transform);
302     g_once_init_leave ((GstMetaInfo **) &amp; audio_clipping_meta_info,
303         (GstMetaInfo *) meta);
304   }
305   return audio_clipping_meta_info;
306 }

























































































































































































</pre>
</td>
<td>
<hr />
<pre>
  2  * Copyright (C) &lt;2011&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 /**
 21  * SECTION:gstaudiometa
<span class="line-modified"> 22  * @title: GstAudio meta</span>
 23  * @short_description: Buffer metadata for audio downmix matrix handling
 24  *
 25  * #GstAudioDownmixMeta defines an audio downmix matrix to be send along with
 26  * audio buffers. These functions in this module help to create and attach the
 27  * meta as well as extracting it.
 28  */
<span class="line-added"> 29 #ifdef HAVE_CONFIG_H</span>
<span class="line-added"> 30 #include &quot;config.h&quot;</span>
<span class="line-added"> 31 #endif</span>
 32 
 33 #include &lt;string.h&gt;
 34 
 35 #include &quot;gstaudiometa.h&quot;
 36 
 37 static gboolean
 38 gst_audio_downmix_meta_init (GstMeta * meta, gpointer params,
 39     GstBuffer * buffer)
 40 {
 41   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 42 
 43   dmeta-&gt;from_position = dmeta-&gt;to_position = NULL;
 44   dmeta-&gt;from_channels = dmeta-&gt;to_channels = 0;
 45   dmeta-&gt;matrix = NULL;
 46 
 47   return TRUE;
 48 }
 49 
 50 static void
 51 gst_audio_downmix_meta_free (GstMeta * meta, GstBuffer * buffer)
 52 {
 53   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 54 
 55   g_free (dmeta-&gt;from_position);
 56   if (dmeta-&gt;matrix) {
 57     g_free (*dmeta-&gt;matrix);
 58     g_free (dmeta-&gt;matrix);
 59   }
 60 }
 61 
 62 static gboolean
 63 gst_audio_downmix_meta_transform (GstBuffer * dest, GstMeta * meta,
 64     GstBuffer * buffer, GQuark type, gpointer data)
 65 {
 66   GstAudioDownmixMeta *smeta, *dmeta;
 67 
 68   smeta = (GstAudioDownmixMeta *) meta;
 69 
 70   if (GST_META_TRANSFORM_IS_COPY (type)) {
 71     dmeta = gst_buffer_add_audio_downmix_meta (dest, smeta-&gt;from_position,
<span class="line-modified"> 72         smeta-&gt;from_channels, smeta-&gt;to_position, smeta-&gt;to_channels,</span>
<span class="line-modified"> 73         (const gfloat **) smeta-&gt;matrix);</span>
 74     if (!dmeta)
 75       return FALSE;
 76   } else {
 77     /* return FALSE, if transform type is not supported */
 78     return FALSE;
 79   }
 80 
 81   return TRUE;
 82 }
 83 
 84 /**
 85  * gst_buffer_get_audio_downmix_meta_for_channels:
 86  * @buffer: a #GstBuffer
 87  * @to_position: (array length=to_channels): the channel positions of
 88  *   the destination
 89  * @to_channels: The number of channels of the destination
 90  *
 91  * Find the #GstAudioDownmixMeta on @buffer for the given destination
 92  * channel positions.
 93  *
</pre>
<hr />
<pre>
290   }
291   return type;
292 }
293 
294 const GstMetaInfo *
295 gst_audio_clipping_meta_get_info (void)
296 {
297   static const GstMetaInfo *audio_clipping_meta_info = NULL;
298 
299   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_clipping_meta_info)) {
300     const GstMetaInfo *meta =
301         gst_meta_register (GST_AUDIO_CLIPPING_META_API_TYPE,
302         &quot;GstAudioClippingMeta&quot;, sizeof (GstAudioClippingMeta),
303         gst_audio_clipping_meta_init, NULL,
304         gst_audio_clipping_meta_transform);
305     g_once_init_leave ((GstMetaInfo **) &amp; audio_clipping_meta_info,
306         (GstMetaInfo *) meta);
307   }
308   return audio_clipping_meta_info;
309 }
<span class="line-added">310 </span>
<span class="line-added">311 </span>
<span class="line-added">312 static gboolean</span>
<span class="line-added">313 gst_audio_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)</span>
<span class="line-added">314 {</span>
<span class="line-added">315   GstAudioMeta *ameta = (GstAudioMeta *) meta;</span>
<span class="line-added">316 </span>
<span class="line-added">317   gst_audio_info_init (&amp;ameta-&gt;info);</span>
<span class="line-added">318   ameta-&gt;samples = 0;</span>
<span class="line-added">319   ameta-&gt;offsets = NULL;</span>
<span class="line-added">320 </span>
<span class="line-added">321   return TRUE;</span>
<span class="line-added">322 }</span>
<span class="line-added">323 </span>
<span class="line-added">324 static void</span>
<span class="line-added">325 gst_audio_meta_free (GstMeta * meta, GstBuffer * buffer)</span>
<span class="line-added">326 {</span>
<span class="line-added">327   GstAudioMeta *ameta = (GstAudioMeta *) meta;</span>
<span class="line-added">328 </span>
<span class="line-added">329   if (ameta-&gt;offsets &amp;&amp; ameta-&gt;offsets != ameta-&gt;priv_offsets_arr)</span>
<span class="line-added">330     g_slice_free1 (ameta-&gt;info.channels * sizeof (gsize), ameta-&gt;offsets);</span>
<span class="line-added">331 }</span>
<span class="line-added">332 </span>
<span class="line-added">333 static gboolean</span>
<span class="line-added">334 gst_audio_meta_transform (GstBuffer * dest, GstMeta * meta,</span>
<span class="line-added">335     GstBuffer * buffer, GQuark type, gpointer data)</span>
<span class="line-added">336 {</span>
<span class="line-added">337   GstAudioMeta *smeta, *dmeta;</span>
<span class="line-added">338 </span>
<span class="line-added">339   smeta = (GstAudioMeta *) meta;</span>
<span class="line-added">340 </span>
<span class="line-added">341   if (GST_META_TRANSFORM_IS_COPY (type)) {</span>
<span class="line-added">342     dmeta = gst_buffer_add_audio_meta (dest, &amp;smeta-&gt;info, smeta-&gt;samples,</span>
<span class="line-added">343         smeta-&gt;offsets);</span>
<span class="line-added">344     if (!dmeta)</span>
<span class="line-added">345       return FALSE;</span>
<span class="line-added">346   } else {</span>
<span class="line-added">347     /* return FALSE, if transform type is not supported */</span>
<span class="line-added">348     return FALSE;</span>
<span class="line-added">349   }</span>
<span class="line-added">350 </span>
<span class="line-added">351   return TRUE;</span>
<span class="line-added">352 }</span>
<span class="line-added">353 </span>
<span class="line-added">354 /**</span>
<span class="line-added">355  * gst_buffer_add_audio_meta:</span>
<span class="line-added">356  * @buffer: a #GstBuffer</span>
<span class="line-added">357  * @info: the audio properties of the buffer</span>
<span class="line-added">358  * @samples: the number of valid samples in the buffer</span>
<span class="line-added">359  * @offsets: (nullable): the offsets (in bytes) where each channel plane starts</span>
<span class="line-added">360  *   in the buffer or %NULL to calculate it (see below); must be %NULL also</span>
<span class="line-added">361  *   when @info-&gt;layout is %GST_AUDIO_LAYOUT_INTERLEAVED</span>
<span class="line-added">362  *</span>
<span class="line-added">363  * Allocates and attaches a #GstAudioMeta on @buffer, which must be writable</span>
<span class="line-added">364  * for that purpose. The fields of the #GstAudioMeta are directly populated</span>
<span class="line-added">365  * from the arguments of this function.</span>
<span class="line-added">366  *</span>
<span class="line-added">367  * When @info-&gt;layout is %GST_AUDIO_LAYOUT_NON_INTERLEAVED and @offsets is</span>
<span class="line-added">368  * %NULL, the offsets are calculated with a formula that assumes the planes are</span>
<span class="line-added">369  * tightly packed and in sequence:</span>
<span class="line-added">370  * offsets[channel] = channel * @samples * sample_stride</span>
<span class="line-added">371  *</span>
<span class="line-added">372  * It is not allowed for channels to overlap in memory,</span>
<span class="line-added">373  * i.e. for each i in [0, channels), the range</span>
<span class="line-added">374  * [@offsets[i], @offsets[i] + @samples * sample_stride) must not overlap</span>
<span class="line-added">375  * with any other such range. This function will assert if the parameters</span>
<span class="line-added">376  * specified cause this restriction to be violated.</span>
<span class="line-added">377  *</span>
<span class="line-added">378  * It is, obviously, also not allowed to specify parameters that would cause</span>
<span class="line-added">379  * out-of-bounds memory access on @buffer. This is also checked, which means</span>
<span class="line-added">380  * that you must add enough memory on the @buffer before adding this meta.</span>
<span class="line-added">381  *</span>
<span class="line-added">382  * Returns: (transfer none): the #GstAudioMeta that was attached on the @buffer</span>
<span class="line-added">383  *</span>
<span class="line-added">384  * Since: 1.16</span>
<span class="line-added">385  */</span>
<span class="line-added">386 GstAudioMeta *</span>
<span class="line-added">387 gst_buffer_add_audio_meta (GstBuffer * buffer, const GstAudioInfo * info,</span>
<span class="line-added">388     gsize samples, gsize offsets[])</span>
<span class="line-added">389 {</span>
<span class="line-added">390   GstAudioMeta *meta;</span>
<span class="line-added">391   gint i;</span>
<span class="line-added">392   gsize plane_size;</span>
<span class="line-added">393 </span>
<span class="line-added">394   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);</span>
<span class="line-added">395   g_return_val_if_fail (info != NULL, NULL);</span>
<span class="line-added">396   g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (info), NULL);</span>
<span class="line-added">397   g_return_val_if_fail (GST_AUDIO_INFO_FORMAT (info) !=</span>
<span class="line-added">398       GST_AUDIO_FORMAT_UNKNOWN, NULL);</span>
<span class="line-added">399   g_return_val_if_fail (info-&gt;layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED</span>
<span class="line-added">400       || !offsets, NULL);</span>
<span class="line-added">401 </span>
<span class="line-added">402   meta =</span>
<span class="line-added">403       (GstAudioMeta *) gst_buffer_add_meta (buffer, GST_AUDIO_META_INFO, NULL);</span>
<span class="line-added">404 </span>
<span class="line-added">405   meta-&gt;info = *info;</span>
<span class="line-added">406   meta-&gt;samples = samples;</span>
<span class="line-added">407   plane_size = samples * info-&gt;finfo-&gt;width / 8;</span>
<span class="line-added">408 </span>
<span class="line-added">409   if (info-&gt;layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
<span class="line-added">410 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">411     gsize max_offset = 0;</span>
<span class="line-added">412     gint j;</span>
<span class="line-added">413 #endif</span>
<span class="line-added">414 </span>
<span class="line-added">415     if (G_UNLIKELY (info-&gt;channels &gt; 8))</span>
<span class="line-added">416       meta-&gt;offsets = g_slice_alloc (info-&gt;channels * sizeof (gsize));</span>
<span class="line-added">417     else</span>
<span class="line-added">418       meta-&gt;offsets = meta-&gt;priv_offsets_arr;</span>
<span class="line-added">419 </span>
<span class="line-added">420     if (offsets) {</span>
<span class="line-added">421       for (i = 0; i &lt; info-&gt;channels; i++) {</span>
<span class="line-added">422         meta-&gt;offsets[i] = offsets[i];</span>
<span class="line-added">423 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">424         max_offset = MAX (max_offset, offsets[i]);</span>
<span class="line-added">425         for (j = 0; j &lt; info-&gt;channels; j++) {</span>
<span class="line-added">426           if (i != j &amp;&amp; !(offsets[j] + plane_size &lt;= offsets[i]</span>
<span class="line-added">427                   || offsets[i] + plane_size &lt;= offsets[j])) {</span>
<span class="line-added">428             g_critical (&quot;GstAudioMeta properties would cause channel memory &quot;</span>
<span class="line-added">429                 &quot;areas to overlap! offsets: %&quot; G_GSIZE_FORMAT &quot; (%d), %&quot;</span>
<span class="line-added">430                 G_GSIZE_FORMAT &quot; (%d) with plane size %&quot; G_GSIZE_FORMAT,</span>
<span class="line-added">431                 offsets[i], i, offsets[j], j, plane_size);</span>
<span class="line-added">432             gst_buffer_remove_meta (buffer, (GstMeta *) meta);</span>
<span class="line-added">433             return NULL;</span>
<span class="line-added">434           }</span>
<span class="line-added">435         }</span>
<span class="line-added">436 #endif</span>
<span class="line-added">437       }</span>
<span class="line-added">438     } else {</span>
<span class="line-added">439       /* default offsets assume channels are laid out sequentially in memory */</span>
<span class="line-added">440       for (i = 0; i &lt; info-&gt;channels; i++)</span>
<span class="line-added">441         meta-&gt;offsets[i] = i * plane_size;</span>
<span class="line-added">442 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">443       max_offset = meta-&gt;offsets[info-&gt;channels - 1];</span>
<span class="line-added">444 #endif</span>
<span class="line-added">445     }</span>
<span class="line-added">446 </span>
<span class="line-added">447 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">448     if (max_offset + plane_size &gt; gst_buffer_get_size (buffer)) {</span>
<span class="line-added">449       g_critical (&quot;GstAudioMeta properties would cause &quot;</span>
<span class="line-added">450           &quot;out-of-bounds memory access on the buffer: max_offset %&quot;</span>
<span class="line-added">451           G_GSIZE_FORMAT &quot;, samples %&quot; G_GSIZE_FORMAT &quot;, bps %u, buffer size %&quot;</span>
<span class="line-added">452           G_GSIZE_FORMAT, max_offset, samples, info-&gt;finfo-&gt;width / 8,</span>
<span class="line-added">453           gst_buffer_get_size (buffer));</span>
<span class="line-added">454       gst_buffer_remove_meta (buffer, (GstMeta *) meta);</span>
<span class="line-added">455       return NULL;</span>
<span class="line-added">456     }</span>
<span class="line-added">457 #endif</span>
<span class="line-added">458   }</span>
<span class="line-added">459 </span>
<span class="line-added">460   return meta;</span>
<span class="line-added">461 }</span>
<span class="line-added">462 </span>
<span class="line-added">463 GType</span>
<span class="line-added">464 gst_audio_meta_api_get_type (void)</span>
<span class="line-added">465 {</span>
<span class="line-added">466   static volatile GType type;</span>
<span class="line-added">467   static const gchar *tags[] = {</span>
<span class="line-added">468     GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_CHANNELS_STR,</span>
<span class="line-added">469     GST_META_TAG_AUDIO_RATE_STR, NULL</span>
<span class="line-added">470   };</span>
<span class="line-added">471 </span>
<span class="line-added">472   if (g_once_init_enter (&amp;type)) {</span>
<span class="line-added">473     GType _type = gst_meta_api_type_register (&quot;GstAudioMetaAPI&quot;, tags);</span>
<span class="line-added">474     g_once_init_leave (&amp;type, _type);</span>
<span class="line-added">475   }</span>
<span class="line-added">476   return type;</span>
<span class="line-added">477 }</span>
<span class="line-added">478 </span>
<span class="line-added">479 const GstMetaInfo *</span>
<span class="line-added">480 gst_audio_meta_get_info (void)</span>
<span class="line-added">481 {</span>
<span class="line-added">482   static const GstMetaInfo *audio_meta_info = NULL;</span>
<span class="line-added">483 </span>
<span class="line-added">484   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_meta_info)) {</span>
<span class="line-added">485     const GstMetaInfo *meta = gst_meta_register (GST_AUDIO_META_API_TYPE,</span>
<span class="line-added">486         &quot;GstAudioMeta&quot;, sizeof (GstAudioMeta),</span>
<span class="line-added">487         gst_audio_meta_init,</span>
<span class="line-added">488         gst_audio_meta_free,</span>
<span class="line-added">489         gst_audio_meta_transform);</span>
<span class="line-added">490     g_once_init_leave ((GstMetaInfo **) &amp; audio_meta_info,</span>
<span class="line-added">491         (GstMetaInfo *) meta);</span>
<span class="line-added">492   }</span>
<span class="line-added">493   return audio_meta_info;</span>
<span class="line-added">494 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="gstaudioencoder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiometa.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>