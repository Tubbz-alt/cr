<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaglist.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  *
   4  * gsttaglist.c: tag support (aka metadata)
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gsttaglist
  24  * @title: GstTagList
  25  * @short_description: List of tags and values used to describe media metadata
  26  *
  27  * List of tags and values used to describe media metadata.
  28  *
  29  * Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
  30  * not allowed. Strings must not be empty or %NULL.
  31  */
  32 
  33 #ifdef HAVE_CONFIG_H
  34 #  include &quot;config.h&quot;
  35 #endif
  36 
  37 #include &quot;gst_private.h&quot;
  38 #include &quot;math-compat.h&quot;
  39 #include &quot;gst-i18n-lib.h&quot;
  40 #include &quot;gsttaglist.h&quot;
  41 #include &quot;gstinfo.h&quot;
  42 #include &quot;gstvalue.h&quot;
  43 #include &quot;gstbuffer.h&quot;
  44 #include &quot;gstquark.h&quot;
  45 #include &quot;gststructure.h&quot;
  46 
  47 #include &lt;gobject/gvaluecollector.h&gt;
  48 #include &lt;string.h&gt;
  49 
  50 /* FIXME: add category for tags */
  51 #define GST_CAT_TAGS GST_CAT_DEFAULT
  52 
  53 #define GST_TAG_IS_VALID(tag)           (gst_tag_get_info (tag) != NULL)
  54 
  55 typedef struct _GstTagListImpl
  56 {
  57   GstTagList taglist;
  58 
  59   GstStructure *structure;
  60   GstTagScope scope;
  61 } GstTagListImpl;
  62 
  63 #define GST_TAG_LIST_STRUCTURE(taglist)  ((GstTagListImpl*)(taglist))-&gt;structure
  64 #define GST_TAG_LIST_SCOPE(taglist)  ((GstTagListImpl*)(taglist))-&gt;scope
  65 
  66 typedef struct
  67 {
  68   GType type;                   /* type the data is in */
  69 
  70   const gchar *nick;            /* translated short description */
  71   const gchar *blurb;           /* translated long description  */
  72 
  73   GstTagMergeFunc merge_func;   /* functions to merge the values */
  74   GstTagFlag flag;              /* type of tag */
  75   GQuark name_quark;            /* quark for the name */
  76 }
  77 GstTagInfo;
  78 
  79 #define g_value_get_char g_value_get_schar
  80 
  81 static GMutex __tag_mutex;
  82 #define TAG_LOCK g_mutex_lock (&amp;__tag_mutex)
  83 #define TAG_UNLOCK g_mutex_unlock (&amp;__tag_mutex)
  84 
  85 /* tags hash table: maps tag name string =&gt; GstTagInfo */
  86 static GHashTable *__tags;
  87 
  88 GType _gst_tag_list_type = 0;
  89 GST_DEFINE_MINI_OBJECT_TYPE (GstTagList, gst_tag_list);
  90 
  91 static void __gst_tag_list_free (GstTagList * list);
  92 static GstTagList *__gst_tag_list_copy (const GstTagList * list);
  93 
  94 /* FIXME: had code:
  95  *    g_value_register_transform_func (_gst_tag_list_type, G_TYPE_STRING,
  96  *      _gst_structure_transform_to_string);
  97  */
  98 void
  99 _priv_gst_tag_initialize (void)
 100 {
 101   g_mutex_init (&amp;__tag_mutex);
 102 
 103   _gst_tag_list_type = gst_tag_list_get_type ();
 104 
 105   __tags = g_hash_table_new (g_str_hash, g_str_equal);
 106   gst_tag_register_static (GST_TAG_TITLE, GST_TAG_FLAG_META,
 107       G_TYPE_STRING,
 108       _(&quot;title&quot;), _(&quot;commonly used title&quot;), gst_tag_merge_strings_with_comma);
 109   gst_tag_register_static (GST_TAG_TITLE_SORTNAME, GST_TAG_FLAG_META,
 110       G_TYPE_STRING,
 111       _(&quot;title sortname&quot;), _(&quot;commonly used title for sorting purposes&quot;), NULL);
 112   gst_tag_register_static (GST_TAG_ARTIST, GST_TAG_FLAG_META,
 113       G_TYPE_STRING,
 114       _(&quot;artist&quot;),
 115       _(&quot;person(s) responsible for the recording&quot;),
 116       gst_tag_merge_strings_with_comma);
 117   gst_tag_register_static (GST_TAG_ARTIST_SORTNAME, GST_TAG_FLAG_META,
 118       G_TYPE_STRING,
 119       _(&quot;artist sortname&quot;),
 120       _(&quot;person(s) responsible for the recording for sorting purposes&quot;), NULL);
 121   gst_tag_register_static (GST_TAG_ALBUM, GST_TAG_FLAG_META,
 122       G_TYPE_STRING,
 123       _(&quot;album&quot;),
 124       _(&quot;album containing this data&quot;), gst_tag_merge_strings_with_comma);
 125   gst_tag_register_static (GST_TAG_ALBUM_SORTNAME, GST_TAG_FLAG_META,
 126       G_TYPE_STRING,
 127       _(&quot;album sortname&quot;),
 128       _(&quot;album containing this data for sorting purposes&quot;), NULL);
 129   gst_tag_register_static (GST_TAG_ALBUM_ARTIST, GST_TAG_FLAG_META,
 130       G_TYPE_STRING,
 131       _(&quot;album artist&quot;),
 132       _(&quot;The artist of the entire album, as it should be displayed&quot;),
 133       gst_tag_merge_strings_with_comma);
 134   gst_tag_register_static (GST_TAG_ALBUM_ARTIST_SORTNAME, GST_TAG_FLAG_META,
 135       G_TYPE_STRING,
 136       _(&quot;album artist sortname&quot;),
 137       _(&quot;The artist of the entire album, as it should be sorted&quot;), NULL);
 138   gst_tag_register_static (GST_TAG_DATE, GST_TAG_FLAG_META, G_TYPE_DATE,
 139       _(&quot;date&quot;), _(&quot;date the data was created (as a GDate structure)&quot;), NULL);
 140   gst_tag_register_static (GST_TAG_DATE_TIME, GST_TAG_FLAG_META,
 141       GST_TYPE_DATE_TIME, _(&quot;datetime&quot;),
 142       _(&quot;date and time the data was created (as a GstDateTime structure)&quot;),
 143       NULL);
 144   gst_tag_register_static (GST_TAG_GENRE, GST_TAG_FLAG_META,
 145       G_TYPE_STRING,
 146       _(&quot;genre&quot;),
 147       _(&quot;genre this data belongs to&quot;), gst_tag_merge_strings_with_comma);
 148   gst_tag_register_static (GST_TAG_COMMENT, GST_TAG_FLAG_META,
 149       G_TYPE_STRING,
 150       _(&quot;comment&quot;),
 151       _(&quot;free text commenting the data&quot;), gst_tag_merge_use_first);
 152   gst_tag_register_static (GST_TAG_EXTENDED_COMMENT, GST_TAG_FLAG_META,
 153       G_TYPE_STRING,
 154       _(&quot;extended comment&quot;),
 155       _(&quot;free text commenting the data in key=value or key[en]=comment form&quot;),
 156       gst_tag_merge_use_first);
 157   gst_tag_register_static (GST_TAG_TRACK_NUMBER, GST_TAG_FLAG_META,
 158       G_TYPE_UINT,
 159       _(&quot;track number&quot;),
 160       _(&quot;track number inside a collection&quot;), gst_tag_merge_use_first);
 161   gst_tag_register_static (GST_TAG_TRACK_COUNT, GST_TAG_FLAG_META,
 162       G_TYPE_UINT,
 163       _(&quot;track count&quot;),
 164       _(&quot;count of tracks inside collection this track belongs to&quot;),
 165       gst_tag_merge_use_first);
 166   gst_tag_register_static (GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_FLAG_META,
 167       G_TYPE_UINT,
 168       _(&quot;disc number&quot;),
 169       _(&quot;disc number inside a collection&quot;), gst_tag_merge_use_first);
 170   gst_tag_register_static (GST_TAG_ALBUM_VOLUME_COUNT, GST_TAG_FLAG_META,
 171       G_TYPE_UINT,
 172       _(&quot;disc count&quot;),
 173       _(&quot;count of discs inside collection this disc belongs to&quot;),
 174       gst_tag_merge_use_first);
 175   gst_tag_register_static (GST_TAG_LOCATION, GST_TAG_FLAG_META,
 176       G_TYPE_STRING,
 177       _(&quot;location&quot;), _(&quot;Origin of media as a URI (location, where the &quot;
 178           &quot;original of the file or stream is hosted)&quot;),
 179       gst_tag_merge_strings_with_comma);
 180   gst_tag_register_static (GST_TAG_HOMEPAGE, GST_TAG_FLAG_META,
 181       G_TYPE_STRING,
 182       _(&quot;homepage&quot;),
 183       _(&quot;Homepage for this media (i.e. artist or movie homepage)&quot;),
 184       gst_tag_merge_strings_with_comma);
 185   gst_tag_register_static (GST_TAG_DESCRIPTION, GST_TAG_FLAG_META,
 186       G_TYPE_STRING, _(&quot;description&quot;),
 187       _(&quot;short text describing the content of the data&quot;),
 188       gst_tag_merge_strings_with_comma);
 189   gst_tag_register_static (GST_TAG_VERSION, GST_TAG_FLAG_META, G_TYPE_STRING,
 190       _(&quot;version&quot;), _(&quot;version of this data&quot;), NULL);
 191   gst_tag_register_static (GST_TAG_ISRC, GST_TAG_FLAG_META, G_TYPE_STRING,
 192       _(&quot;ISRC&quot;),
 193       _
 194       (&quot;International Standard Recording Code - see http://www.ifpi.org/isrc/&quot;),
 195       NULL);
 196   /* FIXME: organization (fix what? tpm) */
 197   gst_tag_register_static (GST_TAG_ORGANIZATION, GST_TAG_FLAG_META,
 198       G_TYPE_STRING, _(&quot;organization&quot;), _(&quot;organization&quot;),
 199       gst_tag_merge_strings_with_comma);
 200   gst_tag_register_static (GST_TAG_COPYRIGHT, GST_TAG_FLAG_META,
 201       G_TYPE_STRING, _(&quot;copyright&quot;), _(&quot;copyright notice of the data&quot;), NULL);
 202   gst_tag_register_static (GST_TAG_COPYRIGHT_URI, GST_TAG_FLAG_META,
 203       G_TYPE_STRING, _(&quot;copyright uri&quot;),
 204       _(&quot;URI to the copyright notice of the data&quot;), NULL);
 205   gst_tag_register_static (GST_TAG_ENCODED_BY, GST_TAG_FLAG_META, G_TYPE_STRING,
 206       _(&quot;encoded by&quot;), _(&quot;name of the encoding person or organization&quot;),
 207       gst_tag_merge_strings_with_comma);
 208   gst_tag_register_static (GST_TAG_CONTACT, GST_TAG_FLAG_META,
 209       G_TYPE_STRING,
 210       _(&quot;contact&quot;), _(&quot;contact information&quot;), gst_tag_merge_strings_with_comma);
 211   gst_tag_register_static (GST_TAG_LICENSE, GST_TAG_FLAG_META,
 212       G_TYPE_STRING, _(&quot;license&quot;), _(&quot;license of data&quot;), NULL);
 213   gst_tag_register_static (GST_TAG_LICENSE_URI, GST_TAG_FLAG_META,
 214       G_TYPE_STRING, _(&quot;license uri&quot;),
 215       _(&quot;URI to the license of the data&quot;), NULL);
 216   gst_tag_register_static (GST_TAG_PERFORMER, GST_TAG_FLAG_META,
 217       G_TYPE_STRING,
 218       _(&quot;performer&quot;),
 219       _(&quot;person(s) performing&quot;), gst_tag_merge_strings_with_comma);
 220   gst_tag_register_static (GST_TAG_COMPOSER, GST_TAG_FLAG_META,
 221       G_TYPE_STRING,
 222       _(&quot;composer&quot;),
 223       _(&quot;person(s) who composed the recording&quot;),
 224       gst_tag_merge_strings_with_comma);
 225   gst_tag_register_static (GST_TAG_CONDUCTOR, GST_TAG_FLAG_META,
 226       G_TYPE_STRING,
 227       _(&quot;conductor&quot;),
 228       _(&quot;conductor/performer refinement&quot;), gst_tag_merge_strings_with_comma);
 229   gst_tag_register_static (GST_TAG_DURATION, GST_TAG_FLAG_DECODED,
 230       G_TYPE_UINT64,
 231       _(&quot;duration&quot;), _(&quot;length in GStreamer time units (nanoseconds)&quot;), NULL);
 232   gst_tag_register_static (GST_TAG_CODEC, GST_TAG_FLAG_ENCODED,
 233       G_TYPE_STRING,
 234       _(&quot;codec&quot;),
 235       _(&quot;codec the data is stored in&quot;), gst_tag_merge_strings_with_comma);
 236   gst_tag_register_static (GST_TAG_VIDEO_CODEC, GST_TAG_FLAG_ENCODED,
 237       G_TYPE_STRING,
 238       _(&quot;video codec&quot;), _(&quot;codec the video data is stored in&quot;), NULL);
 239   gst_tag_register_static (GST_TAG_AUDIO_CODEC, GST_TAG_FLAG_ENCODED,
 240       G_TYPE_STRING,
 241       _(&quot;audio codec&quot;), _(&quot;codec the audio data is stored in&quot;), NULL);
 242   gst_tag_register_static (GST_TAG_SUBTITLE_CODEC, GST_TAG_FLAG_ENCODED,
 243       G_TYPE_STRING,
 244       _(&quot;subtitle codec&quot;), _(&quot;codec the subtitle data is stored in&quot;), NULL);
 245   gst_tag_register_static (GST_TAG_CONTAINER_FORMAT, GST_TAG_FLAG_ENCODED,
 246       G_TYPE_STRING, _(&quot;container format&quot;),
 247       _(&quot;container format the data is stored in&quot;), NULL);
 248   gst_tag_register_static (GST_TAG_BITRATE, GST_TAG_FLAG_ENCODED,
 249       G_TYPE_UINT, _(&quot;bitrate&quot;), _(&quot;exact or average bitrate in bits/s&quot;), NULL);
 250   gst_tag_register_static (GST_TAG_NOMINAL_BITRATE, GST_TAG_FLAG_ENCODED,
 251       G_TYPE_UINT, _(&quot;nominal bitrate&quot;), _(&quot;nominal bitrate in bits/s&quot;), NULL);
 252   gst_tag_register_static (GST_TAG_MINIMUM_BITRATE, GST_TAG_FLAG_ENCODED,
 253       G_TYPE_UINT, _(&quot;minimum bitrate&quot;), _(&quot;minimum bitrate in bits/s&quot;), NULL);
 254   gst_tag_register_static (GST_TAG_MAXIMUM_BITRATE, GST_TAG_FLAG_ENCODED,
 255       G_TYPE_UINT, _(&quot;maximum bitrate&quot;), _(&quot;maximum bitrate in bits/s&quot;), NULL);
 256   gst_tag_register_static (GST_TAG_ENCODER, GST_TAG_FLAG_ENCODED,
 257       G_TYPE_STRING,
 258       _(&quot;encoder&quot;), _(&quot;encoder used to encode this stream&quot;), NULL);
 259   gst_tag_register_static (GST_TAG_ENCODER_VERSION, GST_TAG_FLAG_ENCODED,
 260       G_TYPE_UINT,
 261       _(&quot;encoder version&quot;),
 262       _(&quot;version of the encoder used to encode this stream&quot;), NULL);
 263   gst_tag_register_static (GST_TAG_SERIAL, GST_TAG_FLAG_ENCODED,
 264       G_TYPE_UINT, _(&quot;serial&quot;), _(&quot;serial number of track&quot;), NULL);
 265   gst_tag_register_static (GST_TAG_TRACK_GAIN, GST_TAG_FLAG_META,
 266       G_TYPE_DOUBLE, _(&quot;replaygain track gain&quot;), _(&quot;track gain in db&quot;), NULL);
 267   gst_tag_register_static (GST_TAG_TRACK_PEAK, GST_TAG_FLAG_META,
 268       G_TYPE_DOUBLE, _(&quot;replaygain track peak&quot;), _(&quot;peak of the track&quot;), NULL);
 269   gst_tag_register_static (GST_TAG_ALBUM_GAIN, GST_TAG_FLAG_META,
 270       G_TYPE_DOUBLE, _(&quot;replaygain album gain&quot;), _(&quot;album gain in db&quot;), NULL);
 271   gst_tag_register_static (GST_TAG_ALBUM_PEAK, GST_TAG_FLAG_META,
 272       G_TYPE_DOUBLE, _(&quot;replaygain album peak&quot;), _(&quot;peak of the album&quot;), NULL);
 273   gst_tag_register_static (GST_TAG_REFERENCE_LEVEL, GST_TAG_FLAG_META,
 274       G_TYPE_DOUBLE, _(&quot;replaygain reference level&quot;),
 275       _(&quot;reference level of track and album gain values&quot;), NULL);
 276   gst_tag_register_static (GST_TAG_LANGUAGE_CODE, GST_TAG_FLAG_META,
 277       G_TYPE_STRING, _(&quot;language code&quot;),
 278       _(&quot;language code for this stream, conforming to ISO-639-1 or ISO-639-2&quot;),
 279       NULL);
 280   gst_tag_register_static (GST_TAG_LANGUAGE_NAME, GST_TAG_FLAG_META,
 281       G_TYPE_STRING, _(&quot;language name&quot;),
 282       _(&quot;freeform name of the language this stream is in&quot;), NULL);
 283   gst_tag_register_static (GST_TAG_IMAGE, GST_TAG_FLAG_META, GST_TYPE_SAMPLE,
 284       _(&quot;image&quot;), _(&quot;image related to this stream&quot;), gst_tag_merge_use_first);
 285   gst_tag_register_static (GST_TAG_PREVIEW_IMAGE, GST_TAG_FLAG_META,
 286       GST_TYPE_SAMPLE,
 287       /* TRANSLATORS: &#39;preview image&#39; = image that shows a preview of the full image */
 288       _(&quot;preview image&quot;), _(&quot;preview image related to this stream&quot;), NULL);
 289   gst_tag_register_static (GST_TAG_ATTACHMENT, GST_TAG_FLAG_META,
 290       GST_TYPE_SAMPLE, _(&quot;attachment&quot;), _(&quot;file attached to this stream&quot;),
 291       gst_tag_merge_use_first);
 292   gst_tag_register_static (GST_TAG_BEATS_PER_MINUTE, GST_TAG_FLAG_META,
 293       G_TYPE_DOUBLE, _(&quot;beats per minute&quot;),
 294       _(&quot;number of beats per minute in audio&quot;), NULL);
 295   gst_tag_register_static (GST_TAG_KEYWORDS, GST_TAG_FLAG_META, G_TYPE_STRING,
 296       _(&quot;keywords&quot;), _(&quot;comma separated keywords describing the content&quot;),
 297       gst_tag_merge_strings_with_comma);
 298   gst_tag_register_static (GST_TAG_GEO_LOCATION_NAME, GST_TAG_FLAG_META,
 299       G_TYPE_STRING, _(&quot;geo location name&quot;),
 300       _(&quot;human readable descriptive location of where &quot;
 301           &quot;the media has been recorded or produced&quot;), NULL);
 302   gst_tag_register_static (GST_TAG_GEO_LOCATION_LATITUDE, GST_TAG_FLAG_META,
 303       G_TYPE_DOUBLE, _(&quot;geo location latitude&quot;),
 304       _(&quot;geo latitude location of where the media has been recorded or &quot;
 305           &quot;produced in degrees according to WGS84 (zero at the equator, &quot;
 306           &quot;negative values for southern latitudes)&quot;), NULL);
 307   gst_tag_register_static (GST_TAG_GEO_LOCATION_LONGITUDE, GST_TAG_FLAG_META,
 308       G_TYPE_DOUBLE, _(&quot;geo location longitude&quot;),
 309       _(&quot;geo longitude location of where the media has been recorded or &quot;
 310           &quot;produced in degrees according to WGS84 (zero at the prime meridian &quot;
 311           &quot;in Greenwich/UK,  negative values for western longitudes)&quot;), NULL);
 312   gst_tag_register_static (GST_TAG_GEO_LOCATION_ELEVATION, GST_TAG_FLAG_META,
 313       G_TYPE_DOUBLE, _(&quot;geo location elevation&quot;),
 314       _(&quot;geo elevation of where the media has been recorded or produced in &quot;
 315           &quot;meters according to WGS84 (zero is average sea level)&quot;), NULL);
 316   gst_tag_register_static (GST_TAG_GEO_LOCATION_COUNTRY, GST_TAG_FLAG_META,
 317       G_TYPE_STRING, _(&quot;geo location country&quot;),
 318       _(&quot;country (english name) where the media has been recorded &quot;
 319           &quot;or produced&quot;), NULL);
 320   gst_tag_register_static (GST_TAG_GEO_LOCATION_CITY, GST_TAG_FLAG_META,
 321       G_TYPE_STRING, _(&quot;geo location city&quot;),
 322       _(&quot;city (english name) where the media has been recorded &quot;
 323           &quot;or produced&quot;), NULL);
 324   gst_tag_register_static (GST_TAG_GEO_LOCATION_SUBLOCATION, GST_TAG_FLAG_META,
 325       G_TYPE_STRING, _(&quot;geo location sublocation&quot;),
 326       _(&quot;a location within a city where the media has been produced &quot;
 327           &quot;or created (e.g. the neighborhood)&quot;), NULL);
 328   gst_tag_register_static (GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR,
 329       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location horizontal error&quot;),
 330       _(&quot;expected error of the horizontal positioning measures (in meters)&quot;),
 331       NULL);
 332   gst_tag_register_static (GST_TAG_GEO_LOCATION_MOVEMENT_SPEED,
 333       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location movement speed&quot;),
 334       _(&quot;movement speed of the capturing device while performing the capture &quot;
 335           &quot;in m/s&quot;), NULL);
 336   gst_tag_register_static (GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION,
 337       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location movement direction&quot;),
 338       _(&quot;indicates the movement direction of the device performing the capture&quot;
 339           &quot; of a media. It is represented as degrees in floating point &quot;
 340           &quot;representation, 0 means the geographic north, and increases &quot;
 341           &quot;clockwise&quot;), NULL);
 342   gst_tag_register_static (GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION,
 343       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location capture direction&quot;),
 344       _(&quot;indicates the direction the device is pointing to when capturing &quot;
 345           &quot; a media. It is represented as degrees in floating point &quot;
 346           &quot; representation, 0 means the geographic north, and increases &quot;
 347           &quot;clockwise&quot;), NULL);
 348   gst_tag_register_static (GST_TAG_SHOW_NAME, GST_TAG_FLAG_META, G_TYPE_STRING,
 349       /* TRANSLATORS: &#39;show name&#39; = &#39;TV/radio/podcast show name&#39; here */
 350       _(&quot;show name&quot;),
 351       _(&quot;Name of the tv/podcast/series show the media is from&quot;),
 352       gst_tag_merge_strings_with_comma);
 353   gst_tag_register_static (GST_TAG_SHOW_SORTNAME, GST_TAG_FLAG_META,
 354       G_TYPE_STRING,
 355       /* TRANSLATORS: &#39;show sortname&#39; = &#39;TV/radio/podcast show name as used for sorting purposes&#39; here */
 356       _(&quot;show sortname&quot;),
 357       _(&quot;Name of the tv/podcast/series show the media is from, for sorting &quot;
 358           &quot;purposes&quot;), NULL);
 359   gst_tag_register_static (GST_TAG_SHOW_EPISODE_NUMBER, GST_TAG_FLAG_META,
 360       G_TYPE_UINT, _(&quot;episode number&quot;),
 361       _(&quot;The episode number in the season the media is part of&quot;),
 362       gst_tag_merge_use_first);
 363   gst_tag_register_static (GST_TAG_SHOW_SEASON_NUMBER, GST_TAG_FLAG_META,
 364       G_TYPE_UINT, _(&quot;season number&quot;),
 365       _(&quot;The season number of the show the media is part of&quot;),
 366       gst_tag_merge_use_first);
 367   gst_tag_register_static (GST_TAG_LYRICS, GST_TAG_FLAG_META, G_TYPE_STRING,
 368       _(&quot;lyrics&quot;), _(&quot;The lyrics of the media, commonly used for songs&quot;),
 369       gst_tag_merge_strings_with_comma);
 370   gst_tag_register_static (GST_TAG_COMPOSER_SORTNAME, GST_TAG_FLAG_META,
 371       G_TYPE_STRING, _(&quot;composer sortname&quot;),
 372       _(&quot;person(s) who composed the recording, for sorting purposes&quot;), NULL);
 373   gst_tag_register_static (GST_TAG_GROUPING, GST_TAG_FLAG_META, G_TYPE_STRING,
 374       _(&quot;grouping&quot;),
 375       _(&quot;Groups related media that spans multiple tracks, like the different &quot;
 376           &quot;pieces of a concerto. It is a higher level than a track, &quot;
 377           &quot;but lower than an album&quot;), NULL);
 378   gst_tag_register_static (GST_TAG_USER_RATING, GST_TAG_FLAG_META, G_TYPE_UINT,
 379       _(&quot;user rating&quot;),
 380       _(&quot;Rating attributed by a user. The higher the rank, &quot;
 381           &quot;the more the user likes this media&quot;), NULL);
 382   gst_tag_register_static (GST_TAG_DEVICE_MANUFACTURER, GST_TAG_FLAG_META,
 383       G_TYPE_STRING, _(&quot;device manufacturer&quot;),
 384       _(&quot;Manufacturer of the device used to create this media&quot;), NULL);
 385   gst_tag_register_static (GST_TAG_DEVICE_MODEL, GST_TAG_FLAG_META,
 386       G_TYPE_STRING, _(&quot;device model&quot;),
 387       _(&quot;Model of the device used to create this media&quot;), NULL);
 388   gst_tag_register_static (GST_TAG_APPLICATION_NAME, GST_TAG_FLAG_META,
 389       G_TYPE_STRING, _(&quot;application name&quot;),
 390       _(&quot;Application used to create the media&quot;), NULL);
 391   gst_tag_register_static (GST_TAG_APPLICATION_DATA, GST_TAG_FLAG_META,
 392       GST_TYPE_SAMPLE, _(&quot;application data&quot;),
 393       _(&quot;Arbitrary application data to be serialized into the media&quot;), NULL);
 394   gst_tag_register_static (GST_TAG_IMAGE_ORIENTATION, GST_TAG_FLAG_META,
 395       G_TYPE_STRING, _(&quot;image orientation&quot;),
 396       _(&quot;How the image should be rotated or flipped before display&quot;), NULL);
 397   gst_tag_register_static (GST_TAG_PUBLISHER, GST_TAG_FLAG_META,
 398       G_TYPE_STRING,
 399       _(&quot;publisher&quot;),
 400       _(&quot;Name of the label or publisher&quot;), gst_tag_merge_strings_with_comma);
 401   gst_tag_register_static (GST_TAG_INTERPRETED_BY, GST_TAG_FLAG_META,
 402       G_TYPE_STRING,
 403       _(&quot;interpreted-by&quot;),
 404       _(&quot;Information about the people behind a remix and similar &quot;
 405           &quot;interpretations&quot;), gst_tag_merge_strings_with_comma);
 406   gst_tag_register_static (GST_TAG_MIDI_BASE_NOTE, GST_TAG_FLAG_META,
 407       G_TYPE_UINT,
 408       _(&quot;midi-base-note&quot;), _(&quot;Midi note number of the audio track.&quot;), NULL);
 409   gst_tag_register_static (GST_TAG_PRIVATE_DATA, GST_TAG_FLAG_META,
 410       GST_TYPE_SAMPLE,
 411       _(&quot;private-data&quot;), _(&quot;Private data&quot;), gst_tag_merge_use_first);
 412 
 413 }
 414 
 415 /**
 416  * gst_tag_merge_use_first:
 417  * @dest: (out caller-allocates): uninitialized GValue to store result in
 418  * @src: GValue to copy from
 419  *
 420  * This is a convenience function for the func argument of gst_tag_register().
 421  * It creates a copy of the first value from the list.
 422  */
 423 void
 424 gst_tag_merge_use_first (GValue * dest, const GValue * src)
 425 {
 426   const GValue *ret = gst_value_list_get_value (src, 0);
 427 
 428   g_value_init (dest, G_VALUE_TYPE (ret));
 429   g_value_copy (ret, dest);
 430 }
 431 
 432 /**
 433  * gst_tag_merge_strings_with_comma:
 434  * @dest: (out caller-allocates): uninitialized GValue to store result in
 435  * @src: GValue to copy from
 436  *
 437  * This is a convenience function for the func argument of gst_tag_register().
 438  * It concatenates all given strings using a comma. The tag must be registered
 439  * as a G_TYPE_STRING or this function will fail.
 440  */
 441 void
 442 gst_tag_merge_strings_with_comma (GValue * dest, const GValue * src)
 443 {
 444   GString *str;
 445   gint i, count;
 446 
 447   count = gst_value_list_get_size (src);
 448   str = g_string_new (g_value_get_string (gst_value_list_get_value (src, 0)));
 449   for (i = 1; i &lt; count; i++) {
 450     /* separator between two strings */
 451     g_string_append (str, _(&quot;, &quot;));
 452     g_string_append (str,
 453         g_value_get_string (gst_value_list_get_value (src, i)));
 454   }
 455 
 456   g_value_init (dest, G_TYPE_STRING);
 457   g_value_take_string (dest, str-&gt;str);
 458   g_string_free (str, FALSE);
 459 }
 460 
 461 static GstTagInfo *
 462 gst_tag_lookup (const gchar * tag_name)
 463 {
 464   GstTagInfo *ret;
 465 
 466   TAG_LOCK;
 467   ret = g_hash_table_lookup (__tags, (gpointer) tag_name);
 468   TAG_UNLOCK;
 469 
 470   return ret;
 471 }
 472 
 473 /**
<a name="1" id="anc1"></a><span class="line-modified"> 474  * gst_tag_register:</span>
 475  * @name: the name or identifier string
 476  * @flag: a flag describing the type of tag info
 477  * @type: the type this data is in
 478  * @nick: human-readable name
 479  * @blurb: a human-readable description about this tag
<a name="2" id="anc2"></a><span class="line-modified"> 480  * @func: (allow-none) (scope call): function for merging multiple values of this tag, or %NULL</span>
 481  *
 482  * Registers a new tag type for the use with GStreamer&#39;s type system. If a type
 483  * with that name is already registered, that one is used.
 484  * The old registration may have used a different type however. So don&#39;t rely
 485  * on your supplied values.
 486  *
 487  * Important: if you do not supply a merge function the implication will be
 488  * that there can only be one single value for this tag in a tag list and
 489  * any additional values will silently be discarded when being added (unless
 490  * #GST_TAG_MERGE_REPLACE, #GST_TAG_MERGE_REPLACE_ALL, or
 491  * #GST_TAG_MERGE_PREPEND is used as merge mode, in which case the new
 492  * value will replace the old one in the list).
 493  *
 494  * The merge function will be called from gst_tag_list_copy_value() when
 495  * it is required that one or more values for a tag be condensed into
 496  * one single value. This may happen from gst_tag_list_get_string(),
 497  * gst_tag_list_get_int(), gst_tag_list_get_double() etc. What will happen
 498  * exactly in that case depends on how the tag was registered and if a
 499  * merge function was supplied and if so which one.
 500  *
 501  * Two default merge functions are provided: gst_tag_merge_use_first() and
 502  * gst_tag_merge_strings_with_comma().
 503  */
 504 void
 505 gst_tag_register (const gchar * name, GstTagFlag flag, GType type,
 506     const gchar * nick, const gchar * blurb, GstTagMergeFunc func)
 507 {
 508   g_return_if_fail (name != NULL);
 509   g_return_if_fail (nick != NULL);
 510   g_return_if_fail (blurb != NULL);
 511   g_return_if_fail (type != 0 &amp;&amp; type != GST_TYPE_LIST);
 512 
 513   gst_tag_register_static (g_intern_string (name), flag, type,
 514       g_intern_string (nick), g_intern_string (blurb), func);
 515 }
 516 
 517 /**
<a name="3" id="anc3"></a><span class="line-modified"> 518  * gst_tag_register_static:</span>
 519  * @name: the name or identifier string (string constant)
 520  * @flag: a flag describing the type of tag info
 521  * @type: the type this data is in
 522  * @nick: human-readable name or short description (string constant)
 523  * @blurb: a human-readable description for this tag (string constant)
<a name="4" id="anc4"></a><span class="line-modified"> 524  * @func: (allow-none) (scope call): function for merging multiple values of this tag, or %NULL</span>
 525  *
 526  * Registers a new tag type for the use with GStreamer&#39;s type system.
 527  *
 528  * Same as gst_tag_register(), but @name, @nick, and @blurb must be
 529  * static strings or inlined strings, as they will not be copied. (GStreamer
 530  * plugins will be made resident once loaded, so this function can be used
 531  * even from dynamically loaded plugins.)
 532  */
 533 void
 534 gst_tag_register_static (const gchar * name, GstTagFlag flag, GType type,
 535     const gchar * nick, const gchar * blurb, GstTagMergeFunc func)
 536 {
 537   GstTagInfo *info;
 538 
 539   g_return_if_fail (name != NULL);
 540   g_return_if_fail (nick != NULL);
 541   g_return_if_fail (blurb != NULL);
 542   g_return_if_fail (type != 0 &amp;&amp; type != GST_TYPE_LIST);
 543 
 544   info = gst_tag_lookup (name);
 545 
 546   if (info) {
 547     g_return_if_fail (info-&gt;type == type);
 548     return;
 549   }
 550 
 551   info = g_slice_new (GstTagInfo);
 552   info-&gt;flag = flag;
 553   info-&gt;type = type;
 554   info-&gt;name_quark = g_quark_from_static_string (name);
 555   info-&gt;nick = nick;
 556   info-&gt;blurb = blurb;
 557   info-&gt;merge_func = func;
 558 
 559   TAG_LOCK;
 560   g_hash_table_insert (__tags, (gpointer) name, info);
 561   TAG_UNLOCK;
 562 }
 563 
 564 /**
 565  * gst_tag_exists:
 566  * @tag: name of the tag
 567  *
 568  * Checks if the given type is already registered.
 569  *
 570  * Returns: %TRUE if the type is already registered
 571  */
 572 gboolean
 573 gst_tag_exists (const gchar * tag)
 574 {
 575   g_return_val_if_fail (tag != NULL, FALSE);
 576 
 577   return gst_tag_lookup (tag) != NULL;
 578 }
 579 
 580 /**
 581  * gst_tag_get_type:
 582  * @tag: the tag
 583  *
 584  * Gets the #GType used for this tag.
 585  *
 586  * Returns: the #GType of this tag
 587  */
 588 GType
 589 gst_tag_get_type (const gchar * tag)
 590 {
 591   GstTagInfo *info;
 592 
 593   g_return_val_if_fail (tag != NULL, 0);
 594   info = gst_tag_lookup (tag);
 595   g_return_val_if_fail (info != NULL, 0);
 596 
 597   return info-&gt;type;
 598 }
 599 
 600 /**
 601  * gst_tag_get_nick:
 602  * @tag: the tag
 603  *
 604  * Returns the human-readable name of this tag, You must not change or free
 605  * this string.
 606  *
 607  * Returns: (nullable): the human-readable name of this tag
 608  */
 609 const gchar *
 610 gst_tag_get_nick (const gchar * tag)
 611 {
 612   GstTagInfo *info;
 613 
 614   g_return_val_if_fail (tag != NULL, NULL);
 615   info = gst_tag_lookup (tag);
 616   if (!info) {
<a name="5" id="anc5"></a><span class="line-modified"> 617     GST_WARNING (&quot;Uknown tag: %s&quot;, tag);</span>
 618 
 619     return tag;
 620   }
 621 
 622   return info-&gt;nick;
 623 }
 624 
 625 /**
 626  * gst_tag_get_description:
 627  * @tag: the tag
 628  *
 629  * Returns the human-readable description of this tag, You must not change or
 630  * free this string.
 631  *
 632  * Returns: (nullable): the human-readable description of this tag
 633  */
 634 const gchar *
 635 gst_tag_get_description (const gchar * tag)
 636 {
 637   GstTagInfo *info;
 638 
 639   g_return_val_if_fail (tag != NULL, NULL);
 640   info = gst_tag_lookup (tag);
 641   g_return_val_if_fail (info != NULL, NULL);
 642 
 643   return info-&gt;blurb;
 644 }
 645 
 646 /**
 647  * gst_tag_get_flag:
 648  * @tag: the tag
 649  *
 650  * Gets the flag of @tag.
 651  *
 652  * Returns: the flag of this tag.
 653  */
 654 GstTagFlag
 655 gst_tag_get_flag (const gchar * tag)
 656 {
 657   GstTagInfo *info;
 658 
 659   g_return_val_if_fail (tag != NULL, GST_TAG_FLAG_UNDEFINED);
 660   info = gst_tag_lookup (tag);
 661   g_return_val_if_fail (info != NULL, GST_TAG_FLAG_UNDEFINED);
 662 
 663   return info-&gt;flag;
 664 }
 665 
 666 /**
 667  * gst_tag_is_fixed:
 668  * @tag: tag to check
 669  *
 670  * Checks if the given tag is fixed. A fixed tag can only contain one value.
 671  * Unfixed tags can contain lists of values.
 672  *
 673  * Returns: %TRUE, if the given tag is fixed.
 674  */
 675 gboolean
 676 gst_tag_is_fixed (const gchar * tag)
 677 {
 678   GstTagInfo *info;
 679 
 680   g_return_val_if_fail (tag != NULL, FALSE);
 681   info = gst_tag_lookup (tag);
 682   g_return_val_if_fail (info != NULL, FALSE);
 683 
 684   return info-&gt;merge_func == NULL;
 685 }
 686 
 687 /* takes ownership of the structure */
 688 static GstTagList *
 689 gst_tag_list_new_internal (GstStructure * s, GstTagScope scope)
 690 {
 691   GstTagList *tag_list;
 692 
 693   g_assert (s != NULL);
 694 
 695   tag_list = (GstTagList *) g_slice_new (GstTagListImpl);
 696 
 697   gst_mini_object_init (GST_MINI_OBJECT_CAST (tag_list), 0, GST_TYPE_TAG_LIST,
 698       (GstMiniObjectCopyFunction) __gst_tag_list_copy, NULL,
 699       (GstMiniObjectFreeFunction) __gst_tag_list_free);
 700 
 701   GST_TAG_LIST_STRUCTURE (tag_list) = s;
 702   GST_TAG_LIST_SCOPE (tag_list) = scope;
 703 
 704 #ifdef DEBUG_REFCOUNT
 705   GST_CAT_TRACE (GST_CAT_TAGS, &quot;created taglist %p&quot;, tag_list);
 706 #endif
 707 
 708   return tag_list;
 709 }
 710 
 711 static void
 712 __gst_tag_list_free (GstTagList * list)
 713 {
 714   g_return_if_fail (GST_IS_TAG_LIST (list));
 715 
 716 #ifdef DEBUG_REFCOUNT
 717   GST_CAT_TRACE (GST_CAT_TAGS, &quot;freeing taglist %p&quot;, list);
 718 #endif
 719 
 720   gst_structure_free (GST_TAG_LIST_STRUCTURE (list));
 721 
<a name="6" id="anc6"></a>



 722   g_slice_free1 (sizeof (GstTagListImpl), list);
 723 }
 724 
 725 static GstTagList *
 726 __gst_tag_list_copy (const GstTagList * list)
 727 {
 728   const GstStructure *s;
 729 
 730   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
 731 
 732   s = GST_TAG_LIST_STRUCTURE (list);
 733   return gst_tag_list_new_internal (gst_structure_copy (s),
 734       GST_TAG_LIST_SCOPE (list));
 735 }
 736 
 737 /**
 738  * gst_tag_list_new_empty:
 739  *
 740  * Creates a new empty GstTagList.
 741  *
 742  * Free-function: gst_tag_list_unref
 743  *
 744  * Returns: (transfer full): An empty tag list
 745  */
 746 GstTagList *
 747 gst_tag_list_new_empty (void)
 748 {
 749   GstStructure *s;
 750   GstTagList *tag_list;
 751 
 752   s = gst_structure_new_id_empty (GST_QUARK (TAGLIST));
 753   tag_list = gst_tag_list_new_internal (s, GST_TAG_SCOPE_STREAM);
 754   return tag_list;
 755 }
 756 
 757 /**
 758  * gst_tag_list_new:
 759  * @tag: tag
 760  * @...: %NULL-terminated list of values to set
 761  *
 762  * Creates a new taglist and appends the values for the given tags. It expects
 763  * tag-value pairs like gst_tag_list_add(), and a %NULL terminator after the
 764  * last pair. The type of the values is implicit and is documented in the API
 765  * reference, but can also be queried at runtime with gst_tag_get_type(). It
 766  * is an error to pass a value of a type not matching the tag type into this
 767  * function. The tag list will make copies of any arguments passed
 768  * (e.g. strings, buffers).
 769  *
 770  * After creation you might also want to set a #GstTagScope on the returned
 771  * taglist to signal if the contained tags are global or stream tags. By
 772  * default stream scope is assumes. See gst_tag_list_set_scope().
 773  *
 774  * Free-function: gst_tag_list_unref
 775  *
 776  * Returns: (transfer full): a new #GstTagList. Free with gst_tag_list_unref()
 777  *     when no longer needed.
 778  */
 779 GstTagList *
 780 gst_tag_list_new (const gchar * tag, ...)
 781 {
 782   GstTagList *list;
 783   va_list args;
 784 
 785   g_return_val_if_fail (tag != NULL, NULL);
 786 
 787   list = gst_tag_list_new_empty ();
 788   va_start (args, tag);
 789   gst_tag_list_add_valist (list, GST_TAG_MERGE_APPEND, tag, args);
 790   va_end (args);
 791 
 792   return list;
 793 }
 794 
 795 /**
 796  * gst_tag_list_new_valist:
 797  * @var_args: tag / value pairs to set
 798  *
 799  * Just like gst_tag_list_new(), only that it takes a va_list argument.
 800  * Useful mostly for language bindings.
 801  *
 802  * Free-function: gst_tag_list_unref
 803  *
 804  * Returns: (transfer full): a new #GstTagList. Free with gst_tag_list_unref()
 805  *     when no longer needed.
 806  */
 807 GstTagList *
 808 gst_tag_list_new_valist (va_list var_args)
 809 {
 810   GstTagList *list;
 811   const gchar *tag;
 812 
 813   list = gst_tag_list_new_empty ();
 814 
 815   tag = va_arg (var_args, gchar *);
 816   gst_tag_list_add_valist (list, GST_TAG_MERGE_APPEND, tag, var_args);
 817 
 818   return list;
 819 }
 820 
 821 /**
 822  * gst_tag_list_set_scope:
 823  * @list: a #GstTagList
 824  * @scope: new scope for @list
 825  *
 826  * Sets the scope of @list to @scope. By default the scope
 827  * of a taglist is stream scope.
 828  *
 829  */
 830 void
 831 gst_tag_list_set_scope (GstTagList * list, GstTagScope scope)
 832 {
 833   g_return_if_fail (GST_IS_TAG_LIST (list));
 834   g_return_if_fail (gst_tag_list_is_writable (list));
 835 
 836   GST_TAG_LIST_SCOPE (list) = scope;
 837 }
 838 
 839 /**
 840  * gst_tag_list_get_scope:
 841  * @list: a #GstTagList
 842  *
 843  * Gets the scope of @list.
 844  *
 845  * Returns: The scope of @list
 846  */
 847 GstTagScope
 848 gst_tag_list_get_scope (const GstTagList * list)
 849 {
 850   g_return_val_if_fail (GST_IS_TAG_LIST (list), GST_TAG_SCOPE_STREAM);
 851 
 852   return GST_TAG_LIST_SCOPE (list);
 853 }
 854 
 855 /**
 856  * gst_tag_list_to_string:
 857  * @list: a #GstTagList
 858  *
 859  * Serializes a tag list to a string.
 860  *
 861  * Returns: (nullable): a newly-allocated string, or %NULL in case of
 862  *     an error. The string must be freed with g_free() when no longer
 863  *     needed.
 864  */
 865 gchar *
 866 gst_tag_list_to_string (const GstTagList * list)
 867 {
 868   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
 869 
 870   return gst_structure_to_string (GST_TAG_LIST_STRUCTURE (list));
 871 }
 872 
 873 /**
 874  * gst_tag_list_new_from_string:
 875  * @str: a string created with gst_tag_list_to_string()
 876  *
 877  * Deserializes a tag list.
 878  *
 879  * Returns: (nullable): a new #GstTagList, or %NULL in case of an
 880  * error.
 881  */
 882 GstTagList *
 883 gst_tag_list_new_from_string (const gchar * str)
 884 {
 885   GstTagList *tag_list;
 886   GstStructure *s;
 887 
 888   g_return_val_if_fail (str != NULL, NULL);
 889   g_return_val_if_fail (g_str_has_prefix (str, &quot;taglist&quot;), NULL);
 890 
 891   s = gst_structure_from_string (str, NULL);
 892   if (s == NULL)
 893     return NULL;
 894 
 895   tag_list = gst_tag_list_new_internal (s, GST_TAG_SCOPE_STREAM);
 896 
 897   return tag_list;
 898 }
 899 
 900 /**
 901  * gst_tag_list_n_tags:
 902  * @list: A #GstTagList.
 903  *
 904  * Get the number of tags in @list.
 905  *
 906  * Returns: The number of tags in @list.
 907  */
 908 gint
 909 gst_tag_list_n_tags (const GstTagList * list)
 910 {
 911   g_return_val_if_fail (list != NULL, 0);
 912   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
 913 
 914   return gst_structure_n_fields (GST_TAG_LIST_STRUCTURE (list));
 915 }
 916 
 917 /**
 918  * gst_tag_list_nth_tag_name:
 919  * @list: A #GstTagList.
 920  * @index: the index
 921  *
 922  * Get the name of the tag in @list at @index.
 923  *
 924  * Returns: The name of the tag at @index.
 925  */
 926 const gchar *
 927 gst_tag_list_nth_tag_name (const GstTagList * list, guint index)
 928 {
 929   g_return_val_if_fail (list != NULL, 0);
 930   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
 931 
 932   return gst_structure_nth_field_name (GST_TAG_LIST_STRUCTURE (list), index);
 933 }
 934 
 935 /**
 936  * gst_tag_list_is_empty:
 937  * @list: A #GstTagList.
 938  *
 939  * Checks if the given taglist is empty.
 940  *
 941  * Returns: %TRUE if the taglist is empty, otherwise %FALSE.
 942  */
 943 gboolean
 944 gst_tag_list_is_empty (const GstTagList * list)
 945 {
 946   g_return_val_if_fail (list != NULL, FALSE);
 947   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
 948 
 949   return (gst_structure_n_fields (GST_TAG_LIST_STRUCTURE (list)) == 0);
 950 }
 951 
 952 static gboolean
 953 gst_tag_list_fields_equal (const GValue * value1, const GValue * value2)
 954 {
 955   gdouble d1, d2;
 956 
 957   if (gst_value_compare (value1, value2) == GST_VALUE_EQUAL)
 958     return TRUE;
 959 
 960   /* fields not equal: add some tolerance for doubles, otherwise bail out */
 961   if (!G_VALUE_HOLDS_DOUBLE (value1) || !G_VALUE_HOLDS_DOUBLE (value2))
 962     return FALSE;
 963 
 964   d1 = g_value_get_double (value1);
 965   d2 = g_value_get_double (value2);
 966 
 967   /* This will only work for &#39;normal&#39; values and values around 0,
 968    * which should be good enough for our purposes here
 969    * FIXME: maybe add this to gst_value_compare_double() ? */
 970   return (fabs (d1 - d2) &lt; 0.0000001);
 971 }
 972 
 973 /**
 974  * gst_tag_list_is_equal:
 975  * @list1: a #GstTagList.
 976  * @list2: a #GstTagList.
 977  *
 978  * Checks if the two given taglists are equal.
 979  *
 980  * Returns: %TRUE if the taglists are equal, otherwise %FALSE
 981  */
 982 gboolean
 983 gst_tag_list_is_equal (const GstTagList * list1, const GstTagList * list2)
 984 {
 985   const GstStructure *s1, *s2;
 986   gint num_fields1, num_fields2, i;
 987 
 988   g_return_val_if_fail (GST_IS_TAG_LIST (list1), FALSE);
 989   g_return_val_if_fail (GST_IS_TAG_LIST (list2), FALSE);
 990 
 991   /* we don&#39;t just use gst_structure_is_equal() here so we can add some
 992    * tolerance for doubles, though maybe we should just add that to
 993    * gst_value_compare_double() as well? */
 994   s1 = GST_TAG_LIST_STRUCTURE (list1);
 995   s2 = GST_TAG_LIST_STRUCTURE (list2);
 996 
 997   num_fields1 = gst_structure_n_fields (s1);
 998   num_fields2 = gst_structure_n_fields (s2);
 999 
1000   if (num_fields1 != num_fields2)
1001     return FALSE;
1002 
1003   for (i = 0; i &lt; num_fields1; i++) {
1004     const GValue *value1, *value2;
1005     const gchar *tag_name;
1006 
1007     tag_name = gst_structure_nth_field_name (s1, i);
1008     value1 = gst_structure_get_value (s1, tag_name);
1009     value2 = gst_structure_get_value (s2, tag_name);
1010 
1011     if (value2 == NULL)
1012       return FALSE;
1013 
1014     if (!gst_tag_list_fields_equal (value1, value2))
1015       return FALSE;
1016   }
1017 
1018   return TRUE;
1019 }
1020 
1021 typedef struct
1022 {
1023   GstTagList *list;
1024   GstTagMergeMode mode;
1025 }
1026 GstTagCopyData;
1027 
1028 static void
1029 gst_tag_list_add_value_internal (GstTagList * tag_list, GstTagMergeMode mode,
1030     const gchar * tag, const GValue * value, GstTagInfo * info)
1031 {
1032   GstStructure *list = GST_TAG_LIST_STRUCTURE (tag_list);
1033   const GValue *value2;
1034   GQuark tag_quark;
1035 
1036   if (info == NULL) {
1037     info = gst_tag_lookup (tag);
1038     if (G_UNLIKELY (info == NULL)) {
1039       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1040       return;
1041     }
1042   }
1043 
1044   if (G_UNLIKELY (!G_VALUE_HOLDS (value, info-&gt;type) &amp;&amp;
1045           !GST_VALUE_HOLDS_LIST (value))) {
1046     g_warning (&quot;tag &#39;%s&#39; should hold value of type &#39;%s&#39;, but value of &quot;
1047         &quot;type &#39;%s&#39; passed&quot;, info-&gt;nick, g_type_name (info-&gt;type),
1048         g_type_name (G_VALUE_TYPE (value)));
1049     return;
1050   }
1051 
1052   tag_quark = info-&gt;name_quark;
1053 
1054   if (info-&gt;merge_func
1055       &amp;&amp; (value2 = gst_structure_id_get_value (list, tag_quark)) != NULL) {
1056     GValue dest = { 0, };
1057 
1058     switch (mode) {
1059       case GST_TAG_MERGE_REPLACE_ALL:
1060       case GST_TAG_MERGE_REPLACE:
1061         gst_structure_id_set_value (list, tag_quark, value);
1062         break;
1063       case GST_TAG_MERGE_PREPEND:
1064         if (GST_VALUE_HOLDS_LIST (value2) &amp;&amp; !GST_VALUE_HOLDS_LIST (value))
1065           gst_value_list_prepend_value ((GValue *) value2, value);
1066         else {
1067           gst_value_list_merge (&amp;dest, value, value2);
1068           gst_structure_id_take_value (list, tag_quark, &amp;dest);
1069         }
1070         break;
1071       case GST_TAG_MERGE_APPEND:
1072         if (GST_VALUE_HOLDS_LIST (value2) &amp;&amp; !GST_VALUE_HOLDS_LIST (value))
1073           gst_value_list_append_value ((GValue *) value2, value);
1074         else {
1075           gst_value_list_merge (&amp;dest, value2, value);
1076           gst_structure_id_take_value (list, tag_quark, &amp;dest);
1077         }
1078         break;
1079       case GST_TAG_MERGE_KEEP:
1080       case GST_TAG_MERGE_KEEP_ALL:
1081         break;
1082       default:
1083         g_assert_not_reached ();
1084         break;
1085     }
1086   } else {
1087     switch (mode) {
1088       case GST_TAG_MERGE_APPEND:
1089       case GST_TAG_MERGE_KEEP:
1090         if (gst_structure_id_get_value (list, tag_quark) != NULL)
1091           break;
1092         /* fall through */
1093       case GST_TAG_MERGE_REPLACE_ALL:
1094       case GST_TAG_MERGE_REPLACE:
1095       case GST_TAG_MERGE_PREPEND:
1096         gst_structure_id_set_value (list, tag_quark, value);
1097         break;
1098       case GST_TAG_MERGE_KEEP_ALL:
1099         break;
1100       default:
1101         g_assert_not_reached ();
1102         break;
1103     }
1104   }
1105 }
1106 
1107 static gboolean
1108 gst_tag_list_copy_foreach (GQuark tag_quark, const GValue * value,
1109     gpointer user_data)
1110 {
1111   GstTagCopyData *copy = (GstTagCopyData *) user_data;
1112   const gchar *tag;
1113 
1114   tag = g_quark_to_string (tag_quark);
1115   gst_tag_list_add_value_internal (copy-&gt;list, copy-&gt;mode, tag, value, NULL);
1116 
1117   return TRUE;
1118 }
1119 
1120 /**
1121  * gst_tag_list_insert:
1122  * @into: list to merge into
1123  * @from: list to merge from
1124  * @mode: the mode to use
1125  *
1126  * Inserts the tags of the @from list into the first list using the given mode.
1127  */
1128 void
1129 gst_tag_list_insert (GstTagList * into, const GstTagList * from,
1130     GstTagMergeMode mode)
1131 {
1132   GstTagCopyData data;
1133 
1134   g_return_if_fail (GST_IS_TAG_LIST (into));
1135   g_return_if_fail (gst_tag_list_is_writable (into));
1136   g_return_if_fail (GST_IS_TAG_LIST (from));
1137   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1138 
1139   data.list = into;
1140   data.mode = mode;
1141   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1142     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (into));
1143   }
1144   gst_structure_foreach (GST_TAG_LIST_STRUCTURE (from),
1145       gst_tag_list_copy_foreach, &amp;data);
1146 }
1147 
1148 /**
1149  * gst_tag_list_merge:
1150  * @list1: (allow-none): first list to merge
1151  * @list2: (allow-none): second list to merge
1152  * @mode: the mode to use
1153  *
1154  * Merges the two given lists into a new list. If one of the lists is %NULL, a
1155  * copy of the other is returned. If both lists are %NULL, %NULL is returned.
1156  *
1157  * Free-function: gst_tag_list_unref
1158  *
1159  * Returns: (transfer full) (nullable): the new list
1160  */
1161 GstTagList *
1162 gst_tag_list_merge (const GstTagList * list1, const GstTagList * list2,
1163     GstTagMergeMode mode)
1164 {
1165   GstTagList *list1_cp;
1166   const GstTagList *list2_cp;
1167 
1168   g_return_val_if_fail (list1 == NULL || GST_IS_TAG_LIST (list1), NULL);
1169   g_return_val_if_fail (list2 == NULL || GST_IS_TAG_LIST (list2), NULL);
1170   g_return_val_if_fail (GST_TAG_MODE_IS_VALID (mode), NULL);
1171 
1172   /* nothing to merge */
1173   if (!list1 &amp;&amp; !list2) {
1174     return NULL;
1175   }
1176 
1177   /* create empty list, we need to do this to correctly handling merge modes */
1178   list1_cp = (list1) ? gst_tag_list_copy (list1) : gst_tag_list_new_empty ();
1179   list2_cp = (list2) ? list2 : gst_tag_list_new_empty ();
1180 
1181   gst_tag_list_insert (list1_cp, list2_cp, mode);
1182 
1183   if (!list2)
1184     gst_tag_list_unref ((GstTagList *) list2_cp);
1185 
1186   return list1_cp;
1187 }
1188 
1189 /**
1190  * gst_tag_list_get_tag_size:
1191  * @list: a taglist
1192  * @tag: the tag to query
1193  *
1194  * Checks how many value are stored in this tag list for the given tag.
1195  *
1196  * Returns: The number of tags stored
1197  */
1198 guint
1199 gst_tag_list_get_tag_size (const GstTagList * list, const gchar * tag)
1200 {
1201   const GValue *value;
1202 
1203   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
1204 
1205   value = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1206   if (value == NULL)
1207     return 0;
1208   if (G_VALUE_TYPE (value) != GST_TYPE_LIST)
1209     return 1;
1210 
1211   return gst_value_list_get_size (value);
1212 }
1213 
1214 /**
1215  * gst_tag_list_add:
1216  * @list: list to set tags in
1217  * @mode: the mode to use
1218  * @tag: tag
1219  * @...: %NULL-terminated list of values to set
1220  *
1221  * Sets the values for the given tags using the specified mode.
1222  */
1223 void
1224 gst_tag_list_add (GstTagList * list, GstTagMergeMode mode, const gchar * tag,
1225     ...)
1226 {
1227   va_list args;
1228 
1229   g_return_if_fail (GST_IS_TAG_LIST (list));
1230   g_return_if_fail (gst_tag_list_is_writable (list));
1231   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1232   g_return_if_fail (tag != NULL);
1233 
1234   va_start (args, tag);
1235   gst_tag_list_add_valist (list, mode, tag, args);
1236   va_end (args);
1237 }
1238 
1239 /**
1240  * gst_tag_list_add_values:
1241  * @list: list to set tags in
1242  * @mode: the mode to use
1243  * @tag: tag
1244  * @...: GValues to set
1245  *
1246  * Sets the GValues for the given tags using the specified mode.
1247  */
1248 void
1249 gst_tag_list_add_values (GstTagList * list, GstTagMergeMode mode,
1250     const gchar * tag, ...)
1251 {
1252   va_list args;
1253 
1254   g_return_if_fail (GST_IS_TAG_LIST (list));
1255   g_return_if_fail (gst_tag_list_is_writable (list));
1256   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1257   g_return_if_fail (tag != NULL);
1258 
1259   va_start (args, tag);
1260   gst_tag_list_add_valist_values (list, mode, tag, args);
1261   va_end (args);
1262 }
1263 
1264 /**
1265  * gst_tag_list_add_valist:
1266  * @list: list to set tags in
1267  * @mode: the mode to use
1268  * @tag: tag
1269  * @var_args: tag / value pairs to set
1270  *
1271  * Sets the values for the given tags using the specified mode.
1272  */
1273 void
1274 gst_tag_list_add_valist (GstTagList * list, GstTagMergeMode mode,
1275     const gchar * tag, va_list var_args)
1276 {
1277   GstTagInfo *info;
1278   gchar *error = NULL;
1279 
1280   g_return_if_fail (GST_IS_TAG_LIST (list));
1281   g_return_if_fail (gst_tag_list_is_writable (list));
1282   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1283   g_return_if_fail (tag != NULL);
1284 
1285   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1286     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (list));
1287   }
1288 
1289   while (tag != NULL) {
1290     GValue value = { 0, };
1291 
1292     info = gst_tag_lookup (tag);
1293     if (G_UNLIKELY (info == NULL)) {
1294       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1295       return;
1296     }
1297     G_VALUE_COLLECT_INIT (&amp;value, info-&gt;type, var_args, 0, &amp;error);
1298     if (error) {
1299       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
1300       g_free (error);
1301       /* we purposely leak the value here, it might not be
<a name="7" id="anc7"></a><span class="line-modified">1302        * in a sane state if an error condition occoured</span>
1303        */
1304       return;
1305     }
1306     /* Facilitate GstBuffer -&gt; GstSample transition */
1307     if (G_UNLIKELY (info-&gt;type == GST_TYPE_SAMPLE &amp;&amp;
1308             !GST_IS_SAMPLE (value.data[0].v_pointer))) {
1309       g_warning (&quot;Expected GstSample argument for tag &#39;%s&#39;&quot;, tag);
1310     } else {
1311       gst_tag_list_add_value_internal (list, mode, tag, &amp;value, info);
1312     }
1313     g_value_unset (&amp;value);
1314     tag = va_arg (var_args, gchar *);
1315   }
1316 }
1317 
1318 /**
1319  * gst_tag_list_add_valist_values:
1320  * @list: list to set tags in
1321  * @mode: the mode to use
1322  * @tag: tag
1323  * @var_args: tag / GValue pairs to set
1324  *
1325  * Sets the GValues for the given tags using the specified mode.
1326  */
1327 void
1328 gst_tag_list_add_valist_values (GstTagList * list, GstTagMergeMode mode,
1329     const gchar * tag, va_list var_args)
1330 {
1331   g_return_if_fail (GST_IS_TAG_LIST (list));
1332   g_return_if_fail (gst_tag_list_is_writable (list));
1333   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1334   g_return_if_fail (tag != NULL);
1335 
1336   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1337     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (list));
1338   }
1339 
1340   while (tag != NULL) {
1341     GstTagInfo *info;
1342 
1343     info = gst_tag_lookup (tag);
1344     if (G_UNLIKELY (info == NULL)) {
1345       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1346       return;
1347     }
1348     gst_tag_list_add_value_internal (list, mode, tag, va_arg (var_args,
1349             GValue *), info);
1350     tag = va_arg (var_args, gchar *);
1351   }
1352 }
1353 
1354 /**
1355  * gst_tag_list_add_value:
1356  * @list: list to set tags in
1357  * @mode: the mode to use
1358  * @tag: tag
1359  * @value: GValue for this tag
1360  *
1361  * Sets the GValue for a given tag using the specified mode.
1362  */
1363 void
1364 gst_tag_list_add_value (GstTagList * list, GstTagMergeMode mode,
1365     const gchar * tag, const GValue * value)
1366 {
1367   g_return_if_fail (GST_IS_TAG_LIST (list));
1368   g_return_if_fail (gst_tag_list_is_writable (list));
1369   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1370   g_return_if_fail (tag != NULL);
1371 
1372   gst_tag_list_add_value_internal (list, mode, tag, value, NULL);
1373 }
1374 
1375 /**
1376  * gst_tag_list_remove_tag:
1377  * @list: list to remove tag from
1378  * @tag: tag to remove
1379  *
1380  * Removes the given tag from the taglist.
1381  */
1382 void
1383 gst_tag_list_remove_tag (GstTagList * list, const gchar * tag)
1384 {
1385   g_return_if_fail (GST_IS_TAG_LIST (list));
1386   g_return_if_fail (gst_tag_list_is_writable (list));
1387   g_return_if_fail (tag != NULL);
1388 
1389   gst_structure_remove_field (GST_TAG_LIST_STRUCTURE (list), tag);
1390 }
1391 
1392 typedef struct
1393 {
1394   GstTagForeachFunc func;
1395   const GstTagList *tag_list;
1396   gpointer data;
1397 }
1398 TagForeachData;
1399 
1400 static int
1401 structure_foreach_wrapper (GQuark field_id, const GValue * value,
1402     gpointer user_data)
1403 {
1404   TagForeachData *data = (TagForeachData *) user_data;
1405 
1406   data-&gt;func (data-&gt;tag_list, g_quark_to_string (field_id), data-&gt;data);
1407   return TRUE;
1408 }
1409 
1410 /**
1411  * gst_tag_list_foreach:
1412  * @list: list to iterate over
1413  * @func: (scope call): function to be called for each tag
1414  * @user_data: (closure): user specified data
1415  *
1416  * Calls the given function for each tag inside the tag list. Note that if there
1417  * is no tag, the function won&#39;t be called at all.
1418  */
1419 void
1420 gst_tag_list_foreach (const GstTagList * list, GstTagForeachFunc func,
1421     gpointer user_data)
1422 {
1423   TagForeachData data;
1424 
1425   g_return_if_fail (GST_IS_TAG_LIST (list));
1426   g_return_if_fail (func != NULL);
1427 
1428   data.func = func;
1429   data.tag_list = list;
1430   data.data = user_data;
1431   gst_structure_foreach (GST_TAG_LIST_STRUCTURE (list),
1432       structure_foreach_wrapper, &amp;data);
1433 }
1434 
1435 /**
1436  * gst_tag_list_get_value_index:
1437  * @list: a #GstTagList
1438  * @tag: tag to read out
1439  * @index: number of entry to read out
1440  *
1441  * Gets the value that is at the given index for the given tag in the given
1442  * list.
1443  *
1444  * Returns: (transfer none) (nullable): The GValue for the specified
1445  *          entry or %NULL if the tag wasn&#39;t available or the tag
1446  *          doesn&#39;t have as many entries
1447  */
1448 const GValue *
1449 gst_tag_list_get_value_index (const GstTagList * list, const gchar * tag,
1450     guint index)
1451 {
1452   const GValue *value;
1453 
1454   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
1455   g_return_val_if_fail (tag != NULL, NULL);
1456 
1457   value = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1458   if (value == NULL)
1459     return NULL;
1460 
1461   if (GST_VALUE_HOLDS_LIST (value)) {
1462     if (index &gt;= gst_value_list_get_size (value))
1463       return NULL;
1464     return gst_value_list_get_value (value, index);
1465   } else {
1466     if (index &gt; 0)
1467       return NULL;
1468     return value;
1469   }
1470 }
1471 
1472 /**
1473  * gst_tag_list_copy_value:
1474  * @dest: (out caller-allocates): uninitialized #GValue to copy into
1475  * @list: list to get the tag from
1476  * @tag: tag to read out
1477  *
1478  * Copies the contents for the given tag into the value,
1479  * merging multiple values into one if multiple values are associated
1480  * with the tag.
1481  * You must g_value_unset() the value after use.
1482  *
1483  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1484  *          given list.
1485  */
1486 gboolean
1487 gst_tag_list_copy_value (GValue * dest, const GstTagList * list,
1488     const gchar * tag)
1489 {
1490   const GValue *src;
1491 
1492   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1493   g_return_val_if_fail (tag != NULL, FALSE);
1494   g_return_val_if_fail (dest != NULL, FALSE);
1495   g_return_val_if_fail (G_VALUE_TYPE (dest) == 0, FALSE);
1496 
1497   src = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1498   if (!src)
1499     return FALSE;
1500 
1501   if (G_VALUE_TYPE (src) == GST_TYPE_LIST) {
1502     GstTagInfo *info = gst_tag_lookup (tag);
1503 
1504     if (!info)
1505       return FALSE;
1506 
1507     /* must be there or lists aren&#39;t allowed */
1508     g_assert (info-&gt;merge_func);
1509     info-&gt;merge_func (dest, src);
1510   } else {
1511     g_value_init (dest, G_VALUE_TYPE (src));
1512     g_value_copy (src, dest);
1513   }
1514   return TRUE;
1515 }
1516 
1517 /* FIXME 2.0: this whole merge function business is overdesigned, and the
1518  * _get_foo() API is misleading as well - how many application developers will
1519  * expect gst_tag_list_get_string (list, GST_TAG_ARTIST, &amp;val) might return a
1520  * string with multiple comma-separated artists? _get_foo() should just be
1521  * a convenience wrapper around _get_foo_index (list, tag, 0, &amp;val),
1522  * supplemented by a special _tag_list_get_string_merged() function if needed
1523  * (unless someone can actually think of real use cases where the merge
1524  * function is not &#39;use first&#39; for non-strings and merge for strings) */
1525 
1526 /***** evil macros to get all the gst_tag_list_get_*() functions right *****/
1527 
1528 #define TAG_MERGE_FUNCS(name,type,ret)                                  \
1529 gboolean                                                                \
1530 gst_tag_list_get_ ## name (const GstTagList *list, const gchar *tag,    \
1531                            type *value)                                 \
1532 {                                                                       \
1533   GValue v = { 0, };                                                    \
1534                                                                         \
1535   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);                 \
1536   g_return_val_if_fail (tag != NULL, FALSE);                            \
1537   g_return_val_if_fail (value != NULL, FALSE);                          \
1538                                                                         \
1539   if (!gst_tag_list_copy_value (&amp;v, list, tag))                         \
1540       return FALSE;                                                     \
1541   *value = COPY_FUNC (g_value_get_ ## name (&amp;v));                       \
1542   g_value_unset (&amp;v);                                                   \
1543   return ret;                                                           \
1544 }                                                                       \
1545                                                                         \
1546 gboolean                                                                \
1547 gst_tag_list_get_ ## name ## _index (const GstTagList *list,            \
1548                                      const gchar *tag,                  \
1549                                      guint index, type *value)          \
1550 {                                                                       \
1551   const GValue *v;                                                      \
1552                                                                         \
1553   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);                 \
1554   g_return_val_if_fail (tag != NULL, FALSE);                            \
1555   g_return_val_if_fail (value != NULL, FALSE);                          \
1556                                                                         \
1557   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)    \
1558       return FALSE;                                                     \
1559   *value = COPY_FUNC (g_value_get_ ## name (v));                        \
1560   return ret;                                                           \
1561 }
1562 
1563 #define COPY_FUNC /**/
1564 /**
1565  * gst_tag_list_get_boolean:
1566  * @list: a #GstTagList to get the tag from
1567  * @tag: tag to read out
1568  * @value: (out): location for the result
1569  *
1570  * Copies the contents for the given tag into the value, merging multiple values
1571  * into one if multiple values are associated with the tag.
1572  *
1573  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1574  *              given list.
1575  */
1576 /**
1577  * gst_tag_list_get_boolean_index:
1578  * @list: a #GstTagList to get the tag from
1579  * @tag: tag to read out
1580  * @index: number of entry to read out
1581  * @value: (out): location for the result
1582  *
1583  * Gets the value that is at the given index for the given tag in the given
1584  * list.
1585  *
1586  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1587  *              given list.
1588  */
1589 TAG_MERGE_FUNCS (boolean, gboolean, TRUE);
1590 /**
1591  * gst_tag_list_get_int:
1592  * @list: a #GstTagList to get the tag from
1593  * @tag: tag to read out
1594  * @value: (out): location for the result
1595  *
1596  * Copies the contents for the given tag into the value, merging multiple values
1597  * into one if multiple values are associated with the tag.
1598  *
1599  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1600  *              given list.
1601  */
1602 /**
1603  * gst_tag_list_get_int_index:
1604  * @list: a #GstTagList to get the tag from
1605  * @tag: tag to read out
1606  * @index: number of entry to read out
1607  * @value: (out): location for the result
1608  *
1609  * Gets the value that is at the given index for the given tag in the given
1610  * list.
1611  *
1612  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1613  *              given list.
1614  */
1615 TAG_MERGE_FUNCS (int, gint, TRUE);
1616 /**
1617  * gst_tag_list_get_uint:
1618  * @list: a #GstTagList to get the tag from
1619  * @tag: tag to read out
1620  * @value: (out): location for the result
1621  *
1622  * Copies the contents for the given tag into the value, merging multiple values
1623  * into one if multiple values are associated with the tag.
1624  *
1625  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1626  *              given list.
1627  */
1628 /**
1629  * gst_tag_list_get_uint_index:
1630  * @list: a #GstTagList to get the tag from
1631  * @tag: tag to read out
1632  * @index: number of entry to read out
1633  * @value: (out): location for the result
1634  *
1635  * Gets the value that is at the given index for the given tag in the given
1636  * list.
1637  *
1638  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1639  *              given list.
1640  */
1641 TAG_MERGE_FUNCS (uint, guint, TRUE);
1642 /**
1643  * gst_tag_list_get_int64:
1644  * @list: a #GstTagList to get the tag from
1645  * @tag: tag to read out
1646  * @value: (out): location for the result
1647  *
1648  * Copies the contents for the given tag into the value, merging multiple values
1649  * into one if multiple values are associated with the tag.
1650  *
1651  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1652  *              given list.
1653  */
1654 /**
1655  * gst_tag_list_get_int64_index:
1656  * @list: a #GstTagList to get the tag from
1657  * @tag: tag to read out
1658  * @index: number of entry to read out
1659  * @value: (out): location for the result
1660  *
1661  * Gets the value that is at the given index for the given tag in the given
1662  * list.
1663  *
1664  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1665  *              given list.
1666  */
1667 TAG_MERGE_FUNCS (int64, gint64, TRUE);
1668 /**
1669  * gst_tag_list_get_uint64:
1670  * @list: a #GstTagList to get the tag from
1671  * @tag: tag to read out
1672  * @value: (out): location for the result
1673  *
1674  * Copies the contents for the given tag into the value, merging multiple values
1675  * into one if multiple values are associated with the tag.
1676  *
1677  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1678  *              given list.
1679  */
1680 /**
1681  * gst_tag_list_get_uint64_index:
1682  * @list: a #GstTagList to get the tag from
1683  * @tag: tag to read out
1684  * @index: number of entry to read out
1685  * @value: (out): location for the result
1686  *
1687  * Gets the value that is at the given index for the given tag in the given
1688  * list.
1689  *
1690  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1691  *              given list.
1692  */
1693 TAG_MERGE_FUNCS (uint64, guint64, TRUE);
1694 /**
1695  * gst_tag_list_get_float:
1696  * @list: a #GstTagList to get the tag from
1697  * @tag: tag to read out
1698  * @value: (out): location for the result
1699  *
1700  * Copies the contents for the given tag into the value, merging multiple values
1701  * into one if multiple values are associated with the tag.
1702  *
1703  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1704  *              given list.
1705  */
1706 /**
1707  * gst_tag_list_get_float_index:
1708  * @list: a #GstTagList to get the tag from
1709  * @tag: tag to read out
1710  * @index: number of entry to read out
1711  * @value: (out): location for the result
1712  *
1713  * Gets the value that is at the given index for the given tag in the given
1714  * list.
1715  *
1716  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1717  *              given list.
1718  */
1719 TAG_MERGE_FUNCS (float, gfloat, TRUE);
1720 /**
1721  * gst_tag_list_get_double:
1722  * @list: a #GstTagList to get the tag from
1723  * @tag: tag to read out
1724  * @value: (out): location for the result
1725  *
1726  * Copies the contents for the given tag into the value, merging multiple values
1727  * into one if multiple values are associated with the tag.
1728  *
1729  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1730  *              given list.
1731  */
1732 /**
1733  * gst_tag_list_get_double_index:
1734  * @list: a #GstTagList to get the tag from
1735  * @tag: tag to read out
1736  * @index: number of entry to read out
1737  * @value: (out): location for the result
1738  *
1739  * Gets the value that is at the given index for the given tag in the given
1740  * list.
1741  *
1742  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1743  *              given list.
1744  */
1745 TAG_MERGE_FUNCS (double, gdouble, TRUE);
1746 /**
1747  * gst_tag_list_get_pointer:
1748  * @list: a #GstTagList to get the tag from
1749  * @tag: tag to read out
1750  * @value: (out) (transfer none): location for the result
1751  *
1752  * Copies the contents for the given tag into the value, merging multiple values
1753  * into one if multiple values are associated with the tag.
1754  *
1755  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1756  *              given list.
1757  */
1758 /**
1759  * gst_tag_list_get_pointer_index:
1760  * @list: a #GstTagList to get the tag from
1761  * @tag: tag to read out
1762  * @index: number of entry to read out
1763  * @value: (out) (transfer none): location for the result
1764  *
1765  * Gets the value that is at the given index for the given tag in the given
1766  * list.
1767  *
1768  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1769  *              given list.
1770  */
1771 TAG_MERGE_FUNCS (pointer, gpointer, (*value != NULL));
1772 
1773 static inline gchar *
1774 _gst_strdup0 (const gchar * s)
1775 {
1776   if (s == NULL || *s == &#39;\0&#39;)
1777     return NULL;
1778 
1779   return g_strdup (s);
1780 }
1781 
1782 #undef COPY_FUNC
1783 #define COPY_FUNC _gst_strdup0
1784 
1785 /**
1786  * gst_tag_list_get_string:
1787  * @list: a #GstTagList to get the tag from
1788  * @tag: tag to read out
1789  * @value: (out callee-allocates) (transfer full): location for the result
1790  *
1791  * Copies the contents for the given tag into the value, possibly merging
1792  * multiple values into one if multiple values are associated with the tag.
1793  *
1794  * Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
1795  * to retrieve the first string associated with this tag unmodified.
1796  *
1797  * The resulting string in @value will be in UTF-8 encoding and should be
1798  * freed by the caller using g_free when no longer needed. The
1799  * returned string is also guaranteed to be non-%NULL and non-empty.
1800  *
1801  * Free-function: g_free
1802  *
1803  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1804  *              given list.
1805  */
1806 /**
1807  * gst_tag_list_get_string_index:
1808  * @list: a #GstTagList to get the tag from
1809  * @tag: tag to read out
1810  * @index: number of entry to read out
1811  * @value: (out callee-allocates) (transfer full): location for the result
1812  *
1813  * Gets the value that is at the given index for the given tag in the given
1814  * list.
1815  *
1816  * The resulting string in @value will be in UTF-8 encoding and should be
1817  * freed by the caller using g_free when no longer needed. The
1818  * returned string is also guaranteed to be non-%NULL and non-empty.
1819  *
1820  * Free-function: g_free
1821  *
1822  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1823  *              given list.
1824  */
1825 TAG_MERGE_FUNCS (string, gchar *, (*value != NULL));
1826 
1827 /*
1828  *FIXME 2.0: Instead of _peek (non-copy) and _get (copy), we could have
1829  *            _get (non-copy) and _dup (copy) for strings, seems more
1830  *            widely used
1831  */
1832 /**
1833  * gst_tag_list_peek_string_index:
1834  * @list: a #GstTagList to get the tag from
1835  * @tag: tag to read out
1836  * @index: number of entry to read out
1837  * @value: (out) (transfer none): location for the result
1838  *
1839  * Peeks at the value that is at the given index for the given tag in the given
1840  * list.
1841  *
1842  * The resulting string in @value will be in UTF-8 encoding and doesn&#39;t need
1843  * to be freed by the caller. The returned string is also guaranteed to
1844  * be non-%NULL and non-empty.
1845  *
1846  * Returns: %TRUE, if a value was set, %FALSE if the tag didn&#39;t exist in the
1847  *              given list.
1848  */
1849 gboolean
1850 gst_tag_list_peek_string_index (const GstTagList * list,
1851     const gchar * tag, guint index, const gchar ** value)
1852 {
1853   const GValue *v;
1854 
1855   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1856   g_return_val_if_fail (tag != NULL, FALSE);
1857   g_return_val_if_fail (value != NULL, FALSE);
1858 
1859   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1860     return FALSE;
1861   *value = g_value_get_string (v);
1862   return *value != NULL &amp;&amp; **value != &#39;\0&#39;;
1863 }
1864 
1865 /**
1866  * gst_tag_list_get_date:
1867  * @list: a #GstTagList to get the tag from
1868  * @tag: tag to read out
1869  * @value: (out callee-allocates) (transfer full): address of a GDate pointer
1870  *     variable to store the result into
1871  *
1872  * Copies the first date for the given tag in the taglist into the variable
1873  * pointed to by @value. Free the date with g_date_free() when it is no longer
1874  * needed.
1875  *
1876  * Free-function: g_date_free
1877  *
1878  * Returns: %TRUE, if a date was copied, %FALSE if the tag didn&#39;t exist in the
1879  *              given list or if it was %NULL.
1880  */
1881 gboolean
1882 gst_tag_list_get_date (const GstTagList * list, const gchar * tag,
1883     GDate ** value)
1884 {
1885   GValue v = { 0, };
1886 
1887   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1888   g_return_val_if_fail (tag != NULL, FALSE);
1889   g_return_val_if_fail (value != NULL, FALSE);
1890 
1891   if (!gst_tag_list_copy_value (&amp;v, list, tag))
1892     return FALSE;
1893   *value = (GDate *) g_value_dup_boxed (&amp;v);
1894   g_value_unset (&amp;v);
1895   return (*value != NULL);
1896 }
1897 
1898 /**
1899  * gst_tag_list_get_date_index:
1900  * @list: a #GstTagList to get the tag from
1901  * @tag: tag to read out
1902  * @index: number of entry to read out
1903  * @value: (out callee-allocates) (transfer full): location for the result
1904  *
1905  * Gets the date that is at the given index for the given tag in the given
1906  * list and copies it into the variable pointed to by @value. Free the date
1907  * with g_date_free() when it is no longer needed.
1908  *
1909  * Free-function: g_date_free
1910  *
1911  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1912  *              given list or if it was %NULL.
1913  */
1914 gboolean
1915 gst_tag_list_get_date_index (const GstTagList * list,
1916     const gchar * tag, guint index, GDate ** value)
1917 {
1918   const GValue *v;
1919 
1920   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1921   g_return_val_if_fail (tag != NULL, FALSE);
1922   g_return_val_if_fail (value != NULL, FALSE);
1923 
1924   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1925     return FALSE;
1926   *value = (GDate *) g_value_dup_boxed (v);
1927   return (*value != NULL);
1928 }
1929 
1930 /**
1931  * gst_tag_list_get_date_time:
1932  * @list: a #GstTagList to get the tag from
1933  * @tag: tag to read out
1934  * @value: (out callee-allocates) (transfer full): address of a #GstDateTime
1935  *     pointer variable to store the result into
1936  *
1937  * Copies the first datetime for the given tag in the taglist into the variable
1938  * pointed to by @value. Unref the date with gst_date_time_unref() when
1939  * it is no longer needed.
1940  *
1941  * Free-function: gst_date_time_unref
1942  *
1943  * Returns: %TRUE, if a datetime was copied, %FALSE if the tag didn&#39;t exist in
1944  *              the given list or if it was %NULL.
1945  */
1946 gboolean
1947 gst_tag_list_get_date_time (const GstTagList * list, const gchar * tag,
1948     GstDateTime ** value)
1949 {
1950   GValue v = { 0, };
1951 
1952   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1953   g_return_val_if_fail (tag != NULL, FALSE);
1954   g_return_val_if_fail (value != NULL, FALSE);
1955 
1956   if (!gst_tag_list_copy_value (&amp;v, list, tag))
1957     return FALSE;
1958 
1959   *value = (GstDateTime *) g_value_dup_boxed (&amp;v);
1960   g_value_unset (&amp;v);
1961   return (*value != NULL);
1962 }
1963 
1964 /**
1965  * gst_tag_list_get_date_time_index:
1966  * @list: a #GstTagList to get the tag from
1967  * @tag: tag to read out
1968  * @index: number of entry to read out
1969  * @value: (out callee-allocates) (transfer full): location for the result
1970  *
1971  * Gets the datetime that is at the given index for the given tag in the given
1972  * list and copies it into the variable pointed to by @value. Unref the datetime
1973  * with gst_date_time_unref() when it is no longer needed.
1974  *
1975  * Free-function: gst_date_time_unref
1976  *
1977  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1978  *              given list or if it was %NULL.
1979  */
1980 gboolean
1981 gst_tag_list_get_date_time_index (const GstTagList * list,
1982     const gchar * tag, guint index, GstDateTime ** value)
1983 {
1984   const GValue *v;
1985 
1986   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1987   g_return_val_if_fail (tag != NULL, FALSE);
1988   g_return_val_if_fail (value != NULL, FALSE);
1989 
1990   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1991     return FALSE;
1992   *value = (GstDateTime *) g_value_dup_boxed (v);
1993   return (*value != NULL);
1994 }
1995 
1996 /**
1997  * gst_tag_list_get_sample:
1998  * @list: a #GstTagList to get the tag from
1999  * @tag: tag to read out
2000  * @sample: (out callee-allocates) (transfer full): address of a GstSample
2001  *     pointer variable to store the result into
2002  *
2003  * Copies the first sample for the given tag in the taglist into the variable
2004  * pointed to by @sample. Free the sample with gst_sample_unref() when it is
2005  * no longer needed. You can retrieve the buffer from the sample using
2006  * gst_sample_get_buffer() and the associated caps (if any) with
2007  * gst_sample_get_caps().
2008  *
2009  * Free-function: gst_sample_unref
2010  *
2011  * Returns: %TRUE, if a sample was returned, %FALSE if the tag didn&#39;t exist in
2012  *              the given list or if it was %NULL.
2013  */
2014 gboolean
2015 gst_tag_list_get_sample (const GstTagList * list, const gchar * tag,
2016     GstSample ** sample)
2017 {
2018   GValue v = { 0, };
2019 
2020   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
2021   g_return_val_if_fail (tag != NULL, FALSE);
2022   g_return_val_if_fail (sample != NULL, FALSE);
2023 
2024   if (!gst_tag_list_copy_value (&amp;v, list, tag))
2025     return FALSE;
2026   *sample = g_value_dup_boxed (&amp;v);
2027   g_value_unset (&amp;v);
2028   return (*sample != NULL);
2029 }
2030 
2031 /**
2032  * gst_tag_list_get_sample_index:
2033  * @list: a #GstTagList to get the tag from
2034  * @tag: tag to read out
2035  * @index: number of entry to read out
2036  * @sample: (out callee-allocates) (transfer full): address of a GstSample
2037  *     pointer variable to store the result into
2038  *
2039  * Gets the sample that is at the given index for the given tag in the given
2040  * list and copies it into the variable pointed to by @sample. Free the sample
2041  * with gst_sample_unref() when it is no longer needed. You can retrieve the
2042  * buffer from the sample using gst_sample_get_buffer() and the associated
2043  * caps (if any) with gst_sample_get_caps().
2044  *
2045  * Free-function: gst_sample_unref
2046  *
2047  * Returns: %TRUE, if a sample was copied, %FALSE if the tag didn&#39;t exist in the
2048  *              given list or if it was %NULL.
2049  */
2050 gboolean
2051 gst_tag_list_get_sample_index (const GstTagList * list,
2052     const gchar * tag, guint index, GstSample ** sample)
2053 {
2054   const GValue *v;
2055 
2056   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
2057   g_return_val_if_fail (tag != NULL, FALSE);
2058   g_return_val_if_fail (sample != NULL, FALSE);
2059 
2060   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
2061     return FALSE;
2062   *sample = g_value_dup_boxed (v);
2063   return (*sample != NULL);
2064 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>