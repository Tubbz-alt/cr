<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasetransform.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *                    2005 Andy Wingo &lt;wingo@fluendo.com&gt;
   5  *                    2005 Thomas Vander Stichele &lt;thomas at apestaart dot org&gt;
   6  *                    2008 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstbasetransform
  26  * @title: GstBaseTransform
  27  * @short_description: Base class for simple transform filters
  28  * @see_also: #GstBaseSrc, #GstBaseSink
  29  *
  30  * This base class is for filter elements that process data. Elements
  31  * that are suitable for implementation using #GstBaseTransform are ones
  32  * where the size and caps of the output is known entirely from the input
  33  * caps and buffer sizes. These include elements that directly transform
  34  * one buffer into another, modify the contents of a buffer in-place, as
  35  * well as elements that collate multiple input buffers into one output buffer,
  36  * or that expand one input buffer into multiple output buffers. See below
  37  * for more concrete use cases.
  38  *
  39  * It provides for:
  40  *
  41  * * one sinkpad and one srcpad
  42  * * Possible formats on sink and source pad implemented
  43  *   with custom transform_caps function. By default uses
  44  *   same format on sink and source.
  45  *
  46  * * Handles state changes
  47  * * Does flushing
  48  * * Push mode
  49  * * Pull mode if the sub-class transform can operate on arbitrary data
  50  *
  51  * # Use Cases
  52  *
  53  * ## Passthrough mode
  54  *
  55  *   * Element has no interest in modifying the buffer. It may want to inspect it,
  56  *     in which case the element should have a transform_ip function. If there
  57  *     is no transform_ip function in passthrough mode, the buffer is pushed
  58  *     intact.
  59  *
  60  *   * The #GstBaseTransformClass.passthrough_on_same_caps variable
  61  *     will automatically set/unset passthrough based on whether the
  62  *     element negotiates the same caps on both pads.
  63  *
  64  *   * #GstBaseTransformClass.passthrough_on_same_caps on an element that
  65  *     doesn&#39;t implement a transform_caps function is useful for elements that
  66  *     only inspect data (such as level)
  67  *
  68  *   * Example elements
  69  *
  70  *     * Level
  71  *     * Videoscale, audioconvert, videoconvert, audioresample in certain modes.
  72  *
  73  * ## Modifications in-place - input buffer and output buffer are the same thing.
  74  *
  75  * * The element must implement a transform_ip function.
  76  * * Output buffer size must &lt;= input buffer size
  77  * * If the always_in_place flag is set, non-writable buffers will be copied
  78  *   and passed to the transform_ip function, otherwise a new buffer will be
  79  *   created and the transform function called.
  80  *
  81  * * Incoming writable buffers will be passed to the transform_ip function
  82  *   immediately.
  83  * * only implementing transform_ip and not transform implies always_in_place = %TRUE
  84  *
  85  *   * Example elements:
  86  *     * Volume
  87  *     * Audioconvert in certain modes (signed/unsigned conversion)
  88  *     * videoconvert in certain modes (endianness swapping)
  89  *
  90  * ## Modifications only to the caps/metadata of a buffer
  91  *
  92  * * The element does not require writable data, but non-writable buffers
  93  *   should be subbuffered so that the meta-information can be replaced.
  94  *
  95  * * Elements wishing to operate in this mode should replace the
  96  *   prepare_output_buffer method to create subbuffers of the input buffer
  97  *   and set always_in_place to %TRUE
  98  *
  99  * * Example elements
 100  *   * Capsfilter when setting caps on outgoing buffers that have
 101  *     none.
 102  *   * identity when it is going to re-timestamp buffers by
 103  *     datarate.
 104  *
 105  * ## Normal mode
 106  *   * always_in_place flag is not set, or there is no transform_ip function
 107  *   * Element will receive an input buffer and output buffer to operate on.
 108  *   * Output buffer is allocated by calling the prepare_output_buffer function.
 109  *   * Example elements:
 110  *     * Videoscale, videoconvert, audioconvert when doing
 111  *     scaling/conversions
 112  *
 113  * ## Special output buffer allocations
 114  *   * Elements which need to do special allocation of their output buffers
 115  *     beyond allocating output buffers via the negotiated allocator or
 116  *     buffer pool should implement the prepare_output_buffer method.
 117  *
 118  *   * Example elements:
 119  *     * efence
 120  *
 121  * # Sub-class settable flags on GstBaseTransform
 122  *
 123  * * passthrough
 124  *
 125  *   * Implies that in the current configuration, the sub-class is not interested in modifying the buffers.
 126  *   * Elements which are always in passthrough mode whenever the same caps has been negotiated on both pads can set the class variable passthrough_on_same_caps to have this behaviour automatically.
 127  *
 128  * * always_in_place
 129  *   * Determines whether a non-writable buffer will be copied before passing
 130  *     to the transform_ip function.
 131  *
 132  *   * Implied %TRUE if no transform function is implemented.
 133  *   * Implied %FALSE if ONLY transform function is implemented.
 134  */
 135 
 136 #ifdef HAVE_CONFIG_H
 137 #  include &quot;config.h&quot;
 138 #endif
 139 
 140 #include &lt;stdlib.h&gt;
 141 #include &lt;string.h&gt;
 142 
 143 #include &quot;../../../gst/gst_private.h&quot;
 144 #include &quot;../../../gst/gst-i18n-lib.h&quot;
 145 #include &quot;../../../gst/glib-compat-private.h&quot;
 146 #include &quot;gstbasetransform.h&quot;
 147 
 148 GST_DEBUG_CATEGORY_STATIC (gst_base_transform_debug);
 149 #define GST_CAT_DEFAULT gst_base_transform_debug
 150 
 151 /* BaseTransform signals and args */
 152 enum
 153 {
 154   /* FILL ME */
 155   LAST_SIGNAL
 156 };
 157 
 158 #define DEFAULT_PROP_QOS    FALSE
 159 
 160 enum
 161 {
 162   PROP_0,
 163   PROP_QOS
 164 };
 165 
 166 #define GST_BASE_TRANSFORM_GET_PRIVATE(obj)  \
 167     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_TRANSFORM, GstBaseTransformPrivate))
 168 
 169 struct _GstBaseTransformPrivate
 170 {
 171   /* Set by sub-class */
 172   gboolean passthrough;
 173   gboolean always_in_place;
 174 
 175   GstCaps *cache_caps1;
 176   gsize cache_caps1_size;
 177   GstCaps *cache_caps2;
 178   gsize cache_caps2_size;
 179   gboolean have_same_caps;
 180 
 181   gboolean negotiated;
 182 
 183   /* QoS *//* with LOCK */
 184   gboolean qos_enabled;
 185   gdouble proportion;
 186   GstClockTime earliest_time;
 187   /* previous buffer had a discont */
 188   gboolean discont;
 189 
 190   GstPadMode pad_mode;
 191 
 192   gboolean gap_aware;
 193   gboolean prefer_passthrough;
 194 
 195   /* QoS stats */
 196   guint64 processed;
 197   guint64 dropped;
 198 
 199   GstClockTime position_out;
 200 
 201   GstBufferPool *pool;
 202   gboolean pool_active;
 203   GstAllocator *allocator;
 204   GstAllocationParams params;
 205   GstQuery *query;
 206 };
 207 
 208 
 209 static GstElementClass *parent_class = NULL;
 210 
 211 static void gst_base_transform_class_init (GstBaseTransformClass * klass);
 212 static void gst_base_transform_init (GstBaseTransform * trans,
 213     GstBaseTransformClass * klass);
 214 static GstFlowReturn default_submit_input_buffer (GstBaseTransform * trans,
 215     gboolean is_discont, GstBuffer * input);
 216 static GstFlowReturn default_generate_output (GstBaseTransform * trans,
 217     GstBuffer ** outbuf);
 218 
 219 /* we can&#39;t use G_DEFINE_ABSTRACT_TYPE because we need the klass in the _init
 220  * method to get to the padtemplates */
 221 GType
 222 gst_base_transform_get_type (void)
 223 {
 224   static volatile gsize base_transform_type = 0;
 225 
 226   if (g_once_init_enter (&amp;base_transform_type)) {
 227     GType _type;
 228     static const GTypeInfo base_transform_info = {
 229       sizeof (GstBaseTransformClass),
 230       NULL,
 231       NULL,
 232       (GClassInitFunc) gst_base_transform_class_init,
 233       NULL,
 234       NULL,
 235       sizeof (GstBaseTransform),
 236       0,
 237       (GInstanceInitFunc) gst_base_transform_init,
 238     };
 239 
 240     _type = g_type_register_static (GST_TYPE_ELEMENT,
 241         &quot;GstBaseTransform&quot;, &amp;base_transform_info, G_TYPE_FLAG_ABSTRACT);
 242     g_once_init_leave (&amp;base_transform_type, _type);
 243   }
 244   return base_transform_type;
 245 }
 246 
 247 static void gst_base_transform_finalize (GObject * object);
 248 static void gst_base_transform_set_property (GObject * object, guint prop_id,
 249     const GValue * value, GParamSpec * pspec);
 250 static void gst_base_transform_get_property (GObject * object, guint prop_id,
 251     GValue * value, GParamSpec * pspec);
 252 static gboolean gst_base_transform_src_activate_mode (GstPad * pad,
 253     GstObject * parent, GstPadMode mode, gboolean active);
 254 static gboolean gst_base_transform_sink_activate_mode (GstPad * pad,
 255     GstObject * parent, GstPadMode mode, gboolean active);
 256 static gboolean gst_base_transform_activate (GstBaseTransform * trans,
 257     gboolean active);
 258 static gboolean gst_base_transform_get_unit_size (GstBaseTransform * trans,
 259     GstCaps * caps, gsize * size);
 260 
 261 static gboolean gst_base_transform_src_event (GstPad * pad, GstObject * parent,
 262     GstEvent * event);
 263 static gboolean gst_base_transform_src_eventfunc (GstBaseTransform * trans,
 264     GstEvent * event);
 265 static gboolean gst_base_transform_sink_event (GstPad * pad, GstObject * parent,
 266     GstEvent * event);
 267 static gboolean gst_base_transform_sink_eventfunc (GstBaseTransform * trans,
 268     GstEvent * event);
 269 static GstFlowReturn gst_base_transform_getrange (GstPad * pad,
 270     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 271 static GstFlowReturn gst_base_transform_chain (GstPad * pad, GstObject * parent,
 272     GstBuffer * buffer);
 273 static GstCaps *gst_base_transform_default_transform_caps (GstBaseTransform *
 274     trans, GstPadDirection direction, GstCaps * caps, GstCaps * filter);
 275 static GstCaps *gst_base_transform_default_fixate_caps (GstBaseTransform *
 276     trans, GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);
 277 static GstCaps *gst_base_transform_query_caps (GstBaseTransform * trans,
 278     GstPad * pad, GstCaps * filter);
 279 static gboolean gst_base_transform_acceptcaps_default (GstBaseTransform * trans,
 280     GstPadDirection direction, GstCaps * caps);
 281 static gboolean gst_base_transform_setcaps (GstBaseTransform * trans,
 282     GstPad * pad, GstCaps * caps);
 283 static gboolean gst_base_transform_default_decide_allocation (GstBaseTransform
 284     * trans, GstQuery * query);
 285 static gboolean gst_base_transform_default_propose_allocation (GstBaseTransform
 286     * trans, GstQuery * decide_query, GstQuery * query);
 287 static gboolean gst_base_transform_query (GstPad * pad, GstObject * parent,
 288     GstQuery * query);
 289 static gboolean gst_base_transform_default_query (GstBaseTransform * trans,
 290     GstPadDirection direction, GstQuery * query);
 291 static gboolean gst_base_transform_default_transform_size (GstBaseTransform *
 292     trans, GstPadDirection direction, GstCaps * caps, gsize size,
 293     GstCaps * othercaps, gsize * othersize);
 294 
 295 static GstFlowReturn default_prepare_output_buffer (GstBaseTransform * trans,
 296     GstBuffer * inbuf, GstBuffer ** outbuf);
 297 static gboolean default_copy_metadata (GstBaseTransform * trans,
 298     GstBuffer * inbuf, GstBuffer * outbuf);
 299 static gboolean
 300 gst_base_transform_default_transform_meta (GstBaseTransform * trans,
 301     GstBuffer * inbuf, GstMeta * meta, GstBuffer * outbuf);
 302 
 303 /* static guint gst_base_transform_signals[LAST_SIGNAL] = { 0 }; */
 304 
 305 
 306 static void
 307 gst_base_transform_finalize (GObject * object)
 308 {
 309   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 310 }
 311 
 312 static void
 313 gst_base_transform_class_init (GstBaseTransformClass * klass)
 314 {
 315   GObjectClass *gobject_class;
 316 
 317   gobject_class = G_OBJECT_CLASS (klass);
 318 
 319   GST_DEBUG_CATEGORY_INIT (gst_base_transform_debug, &quot;basetransform&quot;, 0,
 320       &quot;basetransform element&quot;);
 321 
 322   GST_DEBUG (&quot;gst_base_transform_class_init&quot;);
 323 
 324   g_type_class_add_private (klass, sizeof (GstBaseTransformPrivate));
 325 
 326   parent_class = g_type_class_peek_parent (klass);
 327 
 328   gobject_class-&gt;set_property = gst_base_transform_set_property;
 329   gobject_class-&gt;get_property = gst_base_transform_get_property;
 330 
 331   g_object_class_install_property (gobject_class, PROP_QOS,
 332       g_param_spec_boolean (&quot;qos&quot;, &quot;QoS&quot;, &quot;Handle Quality-of-Service events&quot;,
 333           DEFAULT_PROP_QOS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 334 
 335   gobject_class-&gt;finalize = gst_base_transform_finalize;
 336 
 337   klass-&gt;passthrough_on_same_caps = FALSE;
 338   klass-&gt;transform_ip_on_passthrough = TRUE;
 339 
 340   klass-&gt;transform_caps =
 341       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_caps);
 342   klass-&gt;fixate_caps =
 343       GST_DEBUG_FUNCPTR (gst_base_transform_default_fixate_caps);
 344   klass-&gt;accept_caps =
 345       GST_DEBUG_FUNCPTR (gst_base_transform_acceptcaps_default);
 346   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_transform_default_query);
 347   klass-&gt;decide_allocation =
 348       GST_DEBUG_FUNCPTR (gst_base_transform_default_decide_allocation);
 349   klass-&gt;propose_allocation =
 350       GST_DEBUG_FUNCPTR (gst_base_transform_default_propose_allocation);
 351   klass-&gt;transform_size =
 352       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_size);
 353   klass-&gt;transform_meta =
 354       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_meta);
 355 
 356   klass-&gt;sink_event = GST_DEBUG_FUNCPTR (gst_base_transform_sink_eventfunc);
 357   klass-&gt;src_event = GST_DEBUG_FUNCPTR (gst_base_transform_src_eventfunc);
 358   klass-&gt;prepare_output_buffer =
 359       GST_DEBUG_FUNCPTR (default_prepare_output_buffer);
 360   klass-&gt;copy_metadata = GST_DEBUG_FUNCPTR (default_copy_metadata);
 361   klass-&gt;submit_input_buffer = GST_DEBUG_FUNCPTR (default_submit_input_buffer);
 362   klass-&gt;generate_output = GST_DEBUG_FUNCPTR (default_generate_output);
 363 }
 364 
 365 static void
 366 gst_base_transform_init (GstBaseTransform * trans,
 367     GstBaseTransformClass * bclass)
 368 {
 369   GstPadTemplate *pad_template;
 370   GstBaseTransformPrivate *priv;
 371 
 372   GST_DEBUG (&quot;gst_base_transform_init&quot;);
 373 
 374   priv = trans-&gt;priv = GST_BASE_TRANSFORM_GET_PRIVATE (trans);
 375 
 376   pad_template =
 377       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 378   g_return_if_fail (pad_template != NULL);
 379   trans-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 380   gst_pad_set_event_function (trans-&gt;sinkpad,
 381       GST_DEBUG_FUNCPTR (gst_base_transform_sink_event));
 382   gst_pad_set_chain_function (trans-&gt;sinkpad,
 383       GST_DEBUG_FUNCPTR (gst_base_transform_chain));
 384   gst_pad_set_activatemode_function (trans-&gt;sinkpad,
 385       GST_DEBUG_FUNCPTR (gst_base_transform_sink_activate_mode));
 386   gst_pad_set_query_function (trans-&gt;sinkpad,
 387       GST_DEBUG_FUNCPTR (gst_base_transform_query));
 388   gst_element_add_pad (GST_ELEMENT (trans), trans-&gt;sinkpad);
 389 
 390   pad_template =
 391       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 392   g_return_if_fail (pad_template != NULL);
 393   trans-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 394   gst_pad_set_event_function (trans-&gt;srcpad,
 395       GST_DEBUG_FUNCPTR (gst_base_transform_src_event));
 396   gst_pad_set_getrange_function (trans-&gt;srcpad,
 397       GST_DEBUG_FUNCPTR (gst_base_transform_getrange));
 398   gst_pad_set_activatemode_function (trans-&gt;srcpad,
 399       GST_DEBUG_FUNCPTR (gst_base_transform_src_activate_mode));
 400   gst_pad_set_query_function (trans-&gt;srcpad,
 401       GST_DEBUG_FUNCPTR (gst_base_transform_query));
 402   gst_element_add_pad (GST_ELEMENT (trans), trans-&gt;srcpad);
 403 
 404   priv-&gt;qos_enabled = DEFAULT_PROP_QOS;
 405   priv-&gt;cache_caps1 = NULL;
 406   priv-&gt;cache_caps2 = NULL;
 407   priv-&gt;pad_mode = GST_PAD_MODE_NONE;
 408   priv-&gt;gap_aware = FALSE;
 409   priv-&gt;prefer_passthrough = TRUE;
 410 
 411   priv-&gt;passthrough = FALSE;
 412   if (bclass-&gt;transform == NULL) {
 413     /* If no transform function, always_in_place is TRUE */
 414     GST_DEBUG_OBJECT (trans, &quot;setting in_place TRUE&quot;);
 415     priv-&gt;always_in_place = TRUE;
 416 
 417     if (bclass-&gt;transform_ip == NULL) {
 418       GST_DEBUG_OBJECT (trans, &quot;setting passthrough TRUE&quot;);
 419       priv-&gt;passthrough = TRUE;
 420     }
 421   }
 422 
 423   priv-&gt;processed = 0;
 424   priv-&gt;dropped = 0;
 425 }
 426 
 427 static GstCaps *
 428 gst_base_transform_default_transform_caps (GstBaseTransform * trans,
 429     GstPadDirection direction, GstCaps * caps, GstCaps * filter)
 430 {
 431   GstCaps *ret;
 432 
 433   GST_DEBUG_OBJECT (trans, &quot;identity from: %&quot; GST_PTR_FORMAT, caps);
 434   /* no transform function, use the identity transform */
 435   if (filter) {
 436     ret = gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
 437   } else {
 438     ret = gst_caps_ref (caps);
 439   }
 440   return ret;
 441 }
 442 
 443 /* given @caps on the src or sink pad (given by @direction)
 444  * calculate the possible caps on the other pad.
 445  *
 446  * Returns new caps, unref after usage.
 447  */
 448 static GstCaps *
 449 gst_base_transform_transform_caps (GstBaseTransform * trans,
 450     GstPadDirection direction, GstCaps * caps, GstCaps * filter)
 451 {
 452   GstCaps *ret = NULL;
 453   GstBaseTransformClass *klass;
 454 
 455   if (caps == NULL)
 456     return NULL;
 457 
 458   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
 459 
 460   /* if there is a custom transform function, use this */
 461   if (klass-&gt;transform_caps) {
 462     GST_DEBUG_OBJECT (trans, &quot;transform caps (direction = %d)&quot;, direction);
 463 
 464     GST_LOG_OBJECT (trans, &quot;from: %&quot; GST_PTR_FORMAT, caps);
 465     ret = klass-&gt;transform_caps (trans, direction, caps, filter);
 466     GST_LOG_OBJECT (trans, &quot;  to: %&quot; GST_PTR_FORMAT, ret);
 467 
 468 #ifdef GST_ENABLE_EXTRA_CHECKS
 469     if (filter) {
 470       if (!gst_caps_is_subset (ret, filter)) {
 471         GstCaps *intersection;
 472 
 473         GST_ERROR_OBJECT (trans,
 474             &quot;transform_caps returned caps %&quot; GST_PTR_FORMAT
 475             &quot; which are not a real subset of the filter caps %&quot;
 476             GST_PTR_FORMAT, ret, filter);
 477         g_warning (&quot;%s: transform_caps returned caps which are not a real &quot;
 478             &quot;subset of the filter caps&quot;, GST_ELEMENT_NAME (trans));
 479 
 480         intersection =
 481             gst_caps_intersect_full (filter, ret, GST_CAPS_INTERSECT_FIRST);
 482         gst_caps_unref (ret);
 483         ret = intersection;
 484       }
 485     }
 486 #endif
 487   }
 488 
 489   GST_DEBUG_OBJECT (trans, &quot;to: %&quot; GST_PTR_FORMAT, ret);
 490 
 491   return ret;
 492 }
 493 
 494 static gboolean
 495 gst_base_transform_default_transform_meta (GstBaseTransform * trans,
 496     GstBuffer * inbuf, GstMeta * meta, GstBuffer * outbuf)
 497 {
 498   const GstMetaInfo *info = meta-&gt;info;
 499   const gchar *const *tags;
 500 
 501   tags = gst_meta_api_type_get_tags (info-&gt;api);
 502 
 503   if (!tags)
 504     return TRUE;
 505 
 506   return FALSE;
 507 }
 508 
 509 static gboolean
 510 gst_base_transform_default_transform_size (GstBaseTransform * trans,
 511     GstPadDirection direction, GstCaps * caps, gsize size,
 512     GstCaps * othercaps, gsize * othersize)
 513 {
 514   gsize inunitsize, outunitsize, units;
 515   GstBaseTransformClass *klass;
 516 
 517   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
 518 
 519   if (klass-&gt;get_unit_size == NULL) {
 520     /* if there is no transform_size and no unit_size, it means the
 521      * element does not modify the size of a buffer */
 522     *othersize = size;
 523   } else {
 524     /* there is no transform_size function, we have to use the unit_size
 525      * functions. This method assumes there is a fixed unit_size associated with
 526      * each caps. We provide the same amount of units on both sides. */
 527     if (!gst_base_transform_get_unit_size (trans, caps, &amp;inunitsize))
 528       goto no_in_size;
 529 
 530     GST_DEBUG_OBJECT (trans,
 531         &quot;input size %&quot; G_GSIZE_FORMAT &quot;, input unit size %&quot; G_GSIZE_FORMAT,
 532         size, inunitsize);
 533 
 534     /* input size must be a multiple of the unit_size of the input caps */
 535     if (inunitsize == 0 || (size % inunitsize != 0))
 536       goto no_multiple;
 537 
 538     /* get the amount of units */
 539     units = size / inunitsize;
 540 
 541     /* now get the unit size of the output */
 542     if (!gst_base_transform_get_unit_size (trans, othercaps, &amp;outunitsize))
 543       goto no_out_size;
 544 
 545     /* the output size is the unit_size times the amount of units on the
 546      * input */
 547     *othersize = units * outunitsize;
 548     GST_DEBUG_OBJECT (trans, &quot;transformed size to %&quot; G_GSIZE_FORMAT,
 549         *othersize);
 550   }
 551   return TRUE;
 552 
 553   /* ERRORS */
 554 no_in_size:
 555   {
 556     GST_DEBUG_OBJECT (trans, &quot;could not get in_size&quot;);
 557     g_warning (&quot;%s: could not get in_size&quot;, GST_ELEMENT_NAME (trans));
 558     return FALSE;
 559   }
 560 no_multiple:
 561   {
 562     GST_DEBUG_OBJECT (trans, &quot;Size %&quot; G_GSIZE_FORMAT &quot; is not a multiple of&quot;
 563         &quot;unit size %&quot; G_GSIZE_FORMAT, size, inunitsize);
 564     g_warning (&quot;%s: size %&quot; G_GSIZE_FORMAT &quot; is not a multiple of unit size %&quot;
 565         G_GSIZE_FORMAT, GST_ELEMENT_NAME (trans), size, inunitsize);
 566     return FALSE;
 567   }
 568 no_out_size:
 569   {
 570     GST_DEBUG_OBJECT (trans, &quot;could not get out_size&quot;);
 571     g_warning (&quot;%s: could not get out_size&quot;, GST_ELEMENT_NAME (trans));
 572     return FALSE;
 573   }
 574 }
 575 
 576 /* transform a buffer of @size with @caps on the pad with @direction to
 577  * the size of a buffer with @othercaps and store the result in @othersize
 578  *
 579  * We have two ways of doing this:
 580  *  1) use a custom transform size function, this is for complicated custom
 581  *     cases with no fixed unit_size.
 582  *  2) use the unit_size functions where there is a relationship between the
 583  *     caps and the size of a buffer.
 584  */
 585 static gboolean
 586 gst_base_transform_transform_size (GstBaseTransform * trans,
 587     GstPadDirection direction, GstCaps * caps,
 588     gsize size, GstCaps * othercaps, gsize * othersize)
 589 {
 590   GstBaseTransformClass *klass;
 591   gboolean ret = FALSE;
 592 
 593   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
 594 
 595   GST_DEBUG_OBJECT (trans,
 596       &quot;asked to transform size %&quot; G_GSIZE_FORMAT &quot; for caps %&quot;
 597       GST_PTR_FORMAT &quot; to size for caps %&quot; GST_PTR_FORMAT &quot; in direction %s&quot;,
 598       size, caps, othercaps, direction == GST_PAD_SRC ? &quot;SRC&quot; : &quot;SINK&quot;);
 599 
 600   if (klass-&gt;transform_size) {
 601     /* if there is a custom transform function, use this */
 602     ret = klass-&gt;transform_size (trans, direction, caps, size, othercaps,
 603         othersize);
 604   }
 605   return ret;
 606 }
 607 
 608 /* get the caps that can be handled by @pad. We perform:
 609  *
 610  *  - take the caps of peer of otherpad,
 611  *  - filter against the padtemplate of otherpad,
 612  *  - calculate all transforms of remaining caps
 613  *  - filter against template of @pad
 614  *
 615  * If there is no peer, we simply return the caps of the padtemplate of pad.
 616  */
 617 static GstCaps *
 618 gst_base_transform_query_caps (GstBaseTransform * trans, GstPad * pad,
 619     GstCaps * filter)
 620 {
 621   GstPad *otherpad;
 622   GstCaps *peercaps = NULL, *caps, *temp, *peerfilter = NULL;
 623   GstCaps *templ, *otempl;
 624 
 625   otherpad = (pad == trans-&gt;srcpad) ? trans-&gt;sinkpad : trans-&gt;srcpad;
 626 
 627   templ = gst_pad_get_pad_template_caps (pad);
 628   otempl = gst_pad_get_pad_template_caps (otherpad);
 629 
 630   /* first prepare the filter to be send onwards. We need to filter and
 631    * transform it to valid caps for the otherpad. */
 632   if (filter) {
 633     GST_DEBUG_OBJECT (pad, &quot;filter caps  %&quot; GST_PTR_FORMAT, filter);
 634 
 635     /* filtered against our padtemplate of this pad */
 636     GST_DEBUG_OBJECT (pad, &quot;our template  %&quot; GST_PTR_FORMAT, templ);
 637     temp = gst_caps_intersect_full (filter, templ, GST_CAPS_INTERSECT_FIRST);
 638     GST_DEBUG_OBJECT (pad, &quot;intersected %&quot; GST_PTR_FORMAT, temp);
 639 
 640     /* then see what we can transform this to */
 641     peerfilter = gst_base_transform_transform_caps (trans,
 642         GST_PAD_DIRECTION (pad), temp, NULL);
 643     GST_DEBUG_OBJECT (pad, &quot;transformed  %&quot; GST_PTR_FORMAT, peerfilter);
 644     gst_caps_unref (temp);
 645 
 646     if (peerfilter &amp;&amp; !gst_caps_is_empty (peerfilter)) {
 647       /* and filter against the template of the other pad */
 648       GST_DEBUG_OBJECT (pad, &quot;our template  %&quot; GST_PTR_FORMAT, otempl);
 649       /* We keep the caps sorted like the returned caps */
 650       temp =
 651           gst_caps_intersect_full (peerfilter, otempl,
 652           GST_CAPS_INTERSECT_FIRST);
 653       GST_DEBUG_OBJECT (pad, &quot;intersected %&quot; GST_PTR_FORMAT, temp);
 654       gst_caps_unref (peerfilter);
 655       peerfilter = temp;
 656     }
 657   }
 658 
 659   GST_DEBUG_OBJECT (pad, &quot;peer filter caps %&quot; GST_PTR_FORMAT, peerfilter);
 660 
 661   if (peerfilter &amp;&amp; gst_caps_is_empty (peerfilter)) {
 662     GST_DEBUG_OBJECT (pad, &quot;peer filter caps are empty&quot;);
 663     caps = peerfilter;
 664     peerfilter = NULL;
 665     goto done;
 666   }
 667 
 668   /* query the peer with the transformed filter */
 669   peercaps = gst_pad_peer_query_caps (otherpad, peerfilter);
 670 
 671   if (peerfilter)
 672     gst_caps_unref (peerfilter);
 673 
 674   if (peercaps) {
 675     GST_DEBUG_OBJECT (pad, &quot;peer caps  %&quot; GST_PTR_FORMAT, peercaps);
 676 
 677     /* filtered against our padtemplate on the other side */
 678     GST_DEBUG_OBJECT (pad, &quot;our template  %&quot; GST_PTR_FORMAT, otempl);
 679     temp = gst_caps_intersect_full (peercaps, otempl, GST_CAPS_INTERSECT_FIRST);
 680     GST_DEBUG_OBJECT (pad, &quot;intersected %&quot; GST_PTR_FORMAT, temp);
 681   } else {
 682     temp = gst_caps_ref (otempl);
 683   }
 684 
 685   /* then see what we can transform this to */
 686   caps = gst_base_transform_transform_caps (trans,
 687       GST_PAD_DIRECTION (otherpad), temp, filter);
 688   GST_DEBUG_OBJECT (pad, &quot;transformed  %&quot; GST_PTR_FORMAT, caps);
 689   gst_caps_unref (temp);
 690   if (caps == NULL || gst_caps_is_empty (caps))
 691     goto done;
 692 
 693   if (peercaps) {
 694     /* and filter against the template of this pad */
 695     GST_DEBUG_OBJECT (pad, &quot;our template  %&quot; GST_PTR_FORMAT, templ);
 696     /* We keep the caps sorted like the returned caps */
 697     temp = gst_caps_intersect_full (caps, templ, GST_CAPS_INTERSECT_FIRST);
 698     GST_DEBUG_OBJECT (pad, &quot;intersected %&quot; GST_PTR_FORMAT, temp);
 699     gst_caps_unref (caps);
 700     caps = temp;
 701 
 702     if (trans-&gt;priv-&gt;prefer_passthrough) {
 703       /* Now try if we can put the untransformed downstream caps first */
 704       temp = gst_caps_intersect_full (peercaps, caps, GST_CAPS_INTERSECT_FIRST);
 705       if (!gst_caps_is_empty (temp)) {
 706         caps = gst_caps_merge (temp, caps);
 707       } else {
 708         gst_caps_unref (temp);
 709       }
 710     }
 711   } else {
 712     gst_caps_unref (caps);
 713     /* no peer or the peer can do anything, our padtemplate is enough then */
 714     if (filter) {
 715       caps = gst_caps_intersect_full (filter, templ, GST_CAPS_INTERSECT_FIRST);
 716     } else {
 717       caps = gst_caps_ref (templ);
 718     }
 719   }
 720 
 721 done:
 722   GST_DEBUG_OBJECT (trans, &quot;returning  %&quot; GST_PTR_FORMAT, caps);
 723 
 724   if (peercaps)
 725     gst_caps_unref (peercaps);
 726 
 727   gst_caps_unref (templ);
 728   gst_caps_unref (otempl);
 729 
 730   return caps;
 731 }
 732 
 733 /* takes ownership of the pool, allocator and query */
 734 static gboolean
 735 gst_base_transform_set_allocation (GstBaseTransform * trans,
 736     GstBufferPool * pool, GstAllocator * allocator,
 737     GstAllocationParams * params, GstQuery * query)
 738 {
 739   GstAllocator *oldalloc;
 740   GstBufferPool *oldpool;
 741   GstQuery *oldquery;
 742   GstBaseTransformPrivate *priv = trans-&gt;priv;
 743 
 744   GST_OBJECT_LOCK (trans);
 745   oldpool = priv-&gt;pool;
 746   priv-&gt;pool = pool;
 747   priv-&gt;pool_active = FALSE;
 748 
 749   oldalloc = priv-&gt;allocator;
 750   priv-&gt;allocator = allocator;
 751 
 752   oldquery = priv-&gt;query;
 753   priv-&gt;query = query;
 754 
 755   if (params)
 756     priv-&gt;params = *params;
 757   else
 758     gst_allocation_params_init (&amp;priv-&gt;params);
 759   GST_OBJECT_UNLOCK (trans);
 760 
 761   if (oldpool) {
 762     GST_DEBUG_OBJECT (trans, &quot;deactivating old pool %p&quot;, oldpool);
 763     gst_buffer_pool_set_active (oldpool, FALSE);
 764     gst_object_unref (oldpool);
 765   }
 766   if (oldalloc) {
 767     gst_object_unref (oldalloc);
 768   }
 769   if (oldquery) {
 770     gst_query_unref (oldquery);
 771   }
 772   return TRUE;
 773 }
 774 
 775 static gboolean
 776 gst_base_transform_default_decide_allocation (GstBaseTransform * trans,
 777     GstQuery * query)
 778 {
 779   guint i, n_metas;
 780   GstBaseTransformClass *klass;
 781   GstCaps *outcaps;
 782   GstBufferPool *pool;
 783   guint size, min, max;
 784   GstAllocator *allocator;
 785   GstAllocationParams params;
 786   GstStructure *config;
 787   gboolean update_allocator;
 788 
 789   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
 790 
 791   n_metas = gst_query_get_n_allocation_metas (query);
 792   for (i = 0; i &lt; n_metas; i++) {
 793     GType api;
 794     const GstStructure *params;
 795     gboolean remove;
 796 
 797     api = gst_query_parse_nth_allocation_meta (query, i, &amp;params);
 798 
 799     /* by default we remove all metadata, subclasses should implement a
 800      * filter_meta function */
 801     if (gst_meta_api_type_has_tag (api, _gst_meta_tag_memory)) {
 802       /* remove all memory dependent metadata because we are going to have to
 803        * allocate different memory for input and output. */
 804       GST_LOG_OBJECT (trans, &quot;removing memory specific metadata %s&quot;,
 805           g_type_name (api));
 806       remove = TRUE;
 807     } else if (G_LIKELY (klass-&gt;filter_meta)) {
 808       /* remove if the subclass said so */
 809       remove = !klass-&gt;filter_meta (trans, query, api, params);
 810       GST_LOG_OBJECT (trans, &quot;filter_meta for api %s returned: %s&quot;,
 811           g_type_name (api), (remove ? &quot;remove&quot; : &quot;keep&quot;));
 812     } else {
 813       GST_LOG_OBJECT (trans, &quot;removing metadata %s&quot;, g_type_name (api));
 814       remove = TRUE;
 815     }
 816 
 817     if (remove) {
 818       gst_query_remove_nth_allocation_meta (query, i);
 819       i--;
 820       n_metas--;
 821     }
 822   }
 823 
 824   gst_query_parse_allocation (query, &amp;outcaps, NULL);
 825 
 826   /* we got configuration from our peer or the decide_allocation method,
 827    * parse them */
 828   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 829     /* try the allocator */
 830     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
 831     update_allocator = TRUE;
 832   } else {
 833     allocator = NULL;
 834     gst_allocation_params_init (&amp;params);
 835     update_allocator = FALSE;
 836   }
 837 
 838   if (gst_query_get_n_allocation_pools (query) &gt; 0) {
 839     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, &amp;size, &amp;min, &amp;max);
 840 
 841     if (pool == NULL) {
 842       /* no pool, we can make our own */
 843       GST_DEBUG_OBJECT (trans, &quot;no pool, making new pool&quot;);
 844       pool = gst_buffer_pool_new ();
 845     }
 846   } else {
 847     pool = NULL;
 848     size = min = max = 0;
 849   }
 850 
 851   /* now configure */
 852   if (pool) {
 853     config = gst_buffer_pool_get_config (pool);
 854     gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 855     gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 856 
 857     /* buffer pool may have to do some changes */
 858     if (!gst_buffer_pool_set_config (pool, config)) {
 859       config = gst_buffer_pool_get_config (pool);
 860 
 861       /* If change are not acceptable, fallback to generic pool */
 862       if (!gst_buffer_pool_config_validate_params (config, outcaps, size, min,
 863               max)) {
 864         GST_DEBUG_OBJECT (trans, &quot;unsuported pool, making new pool&quot;);
 865 
 866         gst_object_unref (pool);
 867         pool = gst_buffer_pool_new ();
 868         gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 869         gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 870       }
 871 
 872       if (!gst_buffer_pool_set_config (pool, config))
 873         goto config_failed;
 874     }
 875   }
 876 
 877   if (update_allocator)
 878     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
 879   else
 880     gst_query_add_allocation_param (query, allocator, &amp;params);
 881   if (allocator)
 882     gst_object_unref (allocator);
 883 
 884   if (pool) {
 885     gst_query_set_nth_allocation_pool (query, 0, pool, size, min, max);
 886     gst_object_unref (pool);
 887   }
 888 
 889   return TRUE;
 890 
 891 config_failed:
 892   if (pool)
 893     gst_object_unref (pool);
 894 
 895   GST_ELEMENT_ERROR (trans, RESOURCE, SETTINGS,
 896       (&quot;Failed to configure the buffer pool&quot;),
 897       (&quot;Configuration is most likely invalid, please report this issue.&quot;));
 898   return FALSE;
 899 }
 900 
 901 static gboolean
 902 gst_base_transform_do_bufferpool (GstBaseTransform * trans, GstCaps * outcaps)
 903 {
 904   GstQuery *query;
 905   gboolean result = TRUE;
 906   GstBufferPool *pool = NULL;
 907   GstBaseTransformClass *klass;
 908   GstBaseTransformPrivate *priv = trans-&gt;priv;
 909   GstAllocator *allocator;
 910   GstAllocationParams params;
 911 
 912   /* there are these possibilities:
 913    *
 914    * 1) we negotiated passthrough, we can proxy the bufferpool directly and we
 915    *    will do that whenever some upstream does an allocation query.
 916    * 2) we need to do a transform, we need to get a bufferpool from downstream
 917    *    and configure it. When upstream does the ALLOCATION query, the
 918    *    propose_allocation vmethod will be called and we will configure the
 919    *    upstream allocator with our proposed values then.
 920    */
 921   if (priv-&gt;passthrough || priv-&gt;always_in_place) {
 922     /* we are in passthrough, the input buffer is never copied and always passed
 923      * along. We never allocate an output buffer on the srcpad. What we do is
 924      * let the upstream element decide if it wants to use a bufferpool and
 925      * then we will proxy the downstream pool */
 926     GST_DEBUG_OBJECT (trans, &quot;we&#39;re passthough, delay bufferpool&quot;);
 927     gst_base_transform_set_allocation (trans, NULL, NULL, NULL, NULL);
 928     return TRUE;
 929   }
 930 
 931   /* not passthrough, we need to allocate */
 932   /* find a pool for the negotiated caps now */
 933   GST_DEBUG_OBJECT (trans, &quot;doing allocation query&quot;);
 934   query = gst_query_new_allocation (outcaps, TRUE);
 935   if (!gst_pad_peer_query (trans-&gt;srcpad, query)) {
 936     /* not a problem, just debug a little */
 937     GST_DEBUG_OBJECT (trans, &quot;peer ALLOCATION query failed&quot;);
 938   }
 939 
 940   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
 941 
 942   GST_DEBUG_OBJECT (trans, &quot;calling decide_allocation&quot;);
 943   g_assert (klass-&gt;decide_allocation != NULL);
 944   result = klass-&gt;decide_allocation (trans, query);
 945 
 946   GST_DEBUG_OBJECT (trans, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, result,
 947       query);
 948 
 949   if (!result)
 950     goto no_decide_allocation;
 951 
 952   /* check again in case the sub-class have switch to passthrough/in-place
 953    * after looking at the meta APIs */
 954   if (priv-&gt;passthrough || priv-&gt;always_in_place) {
 955     GST_DEBUG_OBJECT (trans, &quot;no doing passthrough, delay bufferpool&quot;);
 956     gst_base_transform_set_allocation (trans, NULL, NULL, NULL, NULL);
 957     gst_query_unref (query);
 958     return TRUE;
 959   }
 960 
 961   /* we got configuration from our peer or the decide_allocation method,
 962    * parse them */
 963   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 964     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
 965   } else {
 966     allocator = NULL;
 967     gst_allocation_params_init (&amp;params);
 968   }
 969 
 970   if (gst_query_get_n_allocation_pools (query) &gt; 0)
 971     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, NULL, NULL, NULL);
 972 
 973   /* now store */
 974   result =
 975       gst_base_transform_set_allocation (trans, pool, allocator, &amp;params,
 976       query);
 977 
 978   return result;
 979 
 980   /* Errors */
 981 no_decide_allocation:
 982   {
 983     GST_WARNING_OBJECT (trans, &quot;Subclass failed to decide allocation&quot;);
 984     gst_query_unref (query);
 985 
 986     return result;
 987   }
 988 }
 989 
 990 /* function triggered when the in and out caps are negotiated and need
 991  * to be configured in the subclass. */
 992 static gboolean
 993 gst_base_transform_configure_caps (GstBaseTransform * trans, GstCaps * in,
 994     GstCaps * out)
 995 {
 996   gboolean ret = TRUE;
 997   GstBaseTransformClass *klass;
 998   GstBaseTransformPrivate *priv = trans-&gt;priv;
 999 
1000   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1001 
1002   GST_DEBUG_OBJECT (trans, &quot;in caps:  %&quot; GST_PTR_FORMAT, in);
1003   GST_DEBUG_OBJECT (trans, &quot;out caps: %&quot; GST_PTR_FORMAT, out);
1004 
1005   /* clear the cache */
1006   gst_caps_replace (&amp;priv-&gt;cache_caps1, NULL);
1007   gst_caps_replace (&amp;priv-&gt;cache_caps2, NULL);
1008 
1009   /* figure out same caps state */
1010   priv-&gt;have_same_caps = gst_caps_is_equal (in, out);
1011   GST_DEBUG_OBJECT (trans, &quot;have_same_caps: %d&quot;, priv-&gt;have_same_caps);
1012 
1013   /* Set the passthrough if the class wants passthrough_on_same_caps
1014    * and we have the same caps on each pad */
1015   if (klass-&gt;passthrough_on_same_caps)
1016     gst_base_transform_set_passthrough (trans, priv-&gt;have_same_caps);
1017 
1018   /* now configure the element with the caps */
1019   if (klass-&gt;set_caps) {
1020     GST_DEBUG_OBJECT (trans, &quot;Calling set_caps method to setup caps&quot;);
1021     ret = klass-&gt;set_caps (trans, in, out);
1022   }
1023 
1024   return ret;
1025 }
1026 
1027 static GstCaps *
1028 gst_base_transform_default_fixate_caps (GstBaseTransform * trans,
1029     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)
1030 {
1031   othercaps = gst_caps_fixate (othercaps);
1032   GST_DEBUG_OBJECT (trans, &quot;fixated to %&quot; GST_PTR_FORMAT, othercaps);
1033 
1034   return othercaps;
1035 }
1036 
1037 /* given a fixed @caps on @pad, create the best possible caps for the
1038  * other pad.
1039  * @caps must be fixed when calling this function.
1040  *
1041  * This function calls the transform caps vmethod of the basetransform to figure
1042  * out the possible target formats. It then tries to select the best format from
1043  * this list by:
1044  *
1045  * - attempt passthrough if the target caps is a superset of the input caps
1046  * - fixating by using peer caps
1047  * - fixating with transform fixate function
1048  * - fixating with pad fixate functions.
1049  *
1050  * this function returns a caps that can be transformed into and is accepted by
1051  * the peer element.
1052  */
1053 static GstCaps *
1054 gst_base_transform_find_transform (GstBaseTransform * trans, GstPad * pad,
1055     GstCaps * caps)
1056 {
1057   GstBaseTransformClass *klass;
1058   GstPad *otherpad, *otherpeer;
1059   GstCaps *othercaps;
1060   gboolean is_fixed;
1061 
1062   /* caps must be fixed here, this is a programming error if it&#39;s not */
1063   g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
1064 
1065   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1066 
1067   otherpad = (pad == trans-&gt;srcpad) ? trans-&gt;sinkpad : trans-&gt;srcpad;
1068   otherpeer = gst_pad_get_peer (otherpad);
1069 
1070   /* see how we can transform the input caps. We need to do this even for
1071    * passthrough because it might be possible that this element cannot support
1072    * passthrough at all. */
1073   othercaps = gst_base_transform_transform_caps (trans,
1074       GST_PAD_DIRECTION (pad), caps, NULL);
1075 
1076   /* The caps we can actually output is the intersection of the transformed
1077    * caps with the pad template for the pad */
1078   if (othercaps &amp;&amp; !gst_caps_is_empty (othercaps)) {
1079     GstCaps *intersect, *templ_caps;
1080 
1081     templ_caps = gst_pad_get_pad_template_caps (otherpad);
1082     GST_DEBUG_OBJECT (trans,
1083         &quot;intersecting against padtemplate %&quot; GST_PTR_FORMAT, templ_caps);
1084 
1085     intersect =
1086         gst_caps_intersect_full (othercaps, templ_caps,
1087         GST_CAPS_INTERSECT_FIRST);
1088 
1089     gst_caps_unref (othercaps);
1090     gst_caps_unref (templ_caps);
1091     othercaps = intersect;
1092   }
1093 
1094   /* check if transform is empty */
1095   if (!othercaps || gst_caps_is_empty (othercaps))
1096     goto no_transform;
1097 
1098   /* if the othercaps are not fixed, we need to fixate them, first attempt
1099    * is by attempting passthrough if the othercaps are a superset of caps. */
1100   /* FIXME. maybe the caps is not fixed because it has multiple structures of
1101    * fixed caps */
1102   is_fixed = gst_caps_is_fixed (othercaps);
1103   if (!is_fixed) {
1104     GST_DEBUG_OBJECT (trans,
1105         &quot;transform returned non fixed  %&quot; GST_PTR_FORMAT, othercaps);
1106 
1107     /* Now let&#39;s see what the peer suggests based on our transformed caps */
1108     if (otherpeer) {
1109       GstCaps *peercaps, *intersection, *templ_caps;
1110 
1111       GST_DEBUG_OBJECT (trans,
1112           &quot;Checking peer caps with filter %&quot; GST_PTR_FORMAT, othercaps);
1113 
1114       peercaps = gst_pad_query_caps (otherpeer, othercaps);
1115       GST_DEBUG_OBJECT (trans, &quot;Resulted in %&quot; GST_PTR_FORMAT, peercaps);
1116       if (!gst_caps_is_empty (peercaps)) {
1117         templ_caps = gst_pad_get_pad_template_caps (otherpad);
1118 
1119         GST_DEBUG_OBJECT (trans,
1120             &quot;Intersecting with template caps %&quot; GST_PTR_FORMAT, templ_caps);
1121 
1122         intersection =
1123             gst_caps_intersect_full (peercaps, templ_caps,
1124             GST_CAPS_INTERSECT_FIRST);
1125         GST_DEBUG_OBJECT (trans, &quot;Intersection: %&quot; GST_PTR_FORMAT,
1126             intersection);
1127         gst_caps_unref (peercaps);
1128         gst_caps_unref (templ_caps);
1129         peercaps = intersection;
1130 
1131         GST_DEBUG_OBJECT (trans,
1132             &quot;Intersecting with transformed caps %&quot; GST_PTR_FORMAT, othercaps);
1133         intersection =
1134             gst_caps_intersect_full (peercaps, othercaps,
1135             GST_CAPS_INTERSECT_FIRST);
1136         GST_DEBUG_OBJECT (trans, &quot;Intersection: %&quot; GST_PTR_FORMAT,
1137             intersection);
1138         gst_caps_unref (peercaps);
1139         gst_caps_unref (othercaps);
1140         othercaps = intersection;
1141       } else {
1142         gst_caps_unref (othercaps);
1143         othercaps = peercaps;
1144       }
1145 
1146       is_fixed = gst_caps_is_fixed (othercaps);
1147     } else {
1148       GST_DEBUG_OBJECT (trans, &quot;no peer, doing passthrough&quot;);
1149       gst_caps_unref (othercaps);
1150       othercaps = gst_caps_ref (caps);
1151       is_fixed = TRUE;
1152     }
1153   }
1154   if (gst_caps_is_empty (othercaps))
1155     goto no_transform_possible;
1156 
1157   GST_DEBUG (&quot;have %sfixed caps %&quot; GST_PTR_FORMAT, (is_fixed ? &quot;&quot; : &quot;non-&quot;),
1158       othercaps);
1159 
1160   /* second attempt at fixation, call the fixate vmethod */
1161   /* caps could be fixed but the subclass may want to add fields */
1162   if (klass-&gt;fixate_caps) {
1163     GST_DEBUG_OBJECT (trans, &quot;calling fixate_caps for %&quot; GST_PTR_FORMAT
1164         &quot; using caps %&quot; GST_PTR_FORMAT &quot; on pad %s:%s&quot;, othercaps, caps,
1165         GST_DEBUG_PAD_NAME (otherpad));
1166     /* note that we pass the complete array of structures to the fixate
1167      * function, it needs to truncate itself */
1168     othercaps =
1169         klass-&gt;fixate_caps (trans, GST_PAD_DIRECTION (pad), caps, othercaps);
1170     is_fixed = gst_caps_is_fixed (othercaps);
1171     GST_DEBUG_OBJECT (trans, &quot;after fixating %&quot; GST_PTR_FORMAT, othercaps);
1172   }
1173 
1174   /* caps should be fixed now, if not we have to fail. */
1175   if (!is_fixed)
1176     goto could_not_fixate;
1177 
1178   /* and peer should accept */
1179   if (otherpeer &amp;&amp; !gst_pad_query_accept_caps (otherpeer, othercaps))
1180     goto peer_no_accept;
1181 
1182   GST_DEBUG_OBJECT (trans, &quot;Input caps were %&quot; GST_PTR_FORMAT
1183       &quot;, and got final caps %&quot; GST_PTR_FORMAT, caps, othercaps);
1184 
1185   if (otherpeer)
1186     gst_object_unref (otherpeer);
1187 
1188   return othercaps;
1189 
1190   /* ERRORS */
1191 no_transform:
1192   {
1193     GST_DEBUG_OBJECT (trans,
1194         &quot;transform returned useless  %&quot; GST_PTR_FORMAT, othercaps);
1195     goto error_cleanup;
1196   }
1197 no_transform_possible:
1198   {
1199     GST_DEBUG_OBJECT (trans,
1200         &quot;transform could not transform %&quot; GST_PTR_FORMAT
1201         &quot; in anything we support&quot;, caps);
1202     goto error_cleanup;
1203   }
1204 could_not_fixate:
1205   {
1206     GST_DEBUG_OBJECT (trans, &quot;FAILED to fixate %&quot; GST_PTR_FORMAT, othercaps);
1207     goto error_cleanup;
1208   }
1209 peer_no_accept:
1210   {
1211     GST_DEBUG_OBJECT (trans, &quot;FAILED to get peer of %&quot; GST_PTR_FORMAT
1212         &quot; to accept %&quot; GST_PTR_FORMAT, otherpad, othercaps);
1213     goto error_cleanup;
1214   }
1215 error_cleanup:
1216   {
1217     if (otherpeer)
1218       gst_object_unref (otherpeer);
1219     if (othercaps)
1220       gst_caps_unref (othercaps);
1221     return NULL;
1222   }
1223 }
1224 
1225 static gboolean
1226 gst_base_transform_acceptcaps_default (GstBaseTransform * trans,
1227     GstPadDirection direction, GstCaps * caps)
1228 {
1229   GstPad *pad, *otherpad;
1230   GstCaps *templ, *otempl, *ocaps = NULL;
1231   gboolean ret = TRUE;
1232 
1233   pad =
1234       (direction ==
1235       GST_PAD_SINK) ? GST_BASE_TRANSFORM_SINK_PAD (trans) :
1236       GST_BASE_TRANSFORM_SRC_PAD (trans);
1237   otherpad =
1238       (direction ==
1239       GST_PAD_SINK) ? GST_BASE_TRANSFORM_SRC_PAD (trans) :
1240       GST_BASE_TRANSFORM_SINK_PAD (trans);
1241 
1242   GST_DEBUG_OBJECT (trans, &quot;accept caps %&quot; GST_PTR_FORMAT, caps);
1243 
1244   templ = gst_pad_get_pad_template_caps (pad);
1245   otempl = gst_pad_get_pad_template_caps (otherpad);
1246 
1247   /* get all the formats we can handle on this pad */
1248   GST_DEBUG_OBJECT (trans, &quot;intersect with pad template: %&quot; GST_PTR_FORMAT,
1249       templ);
1250   if (!gst_caps_can_intersect (caps, templ))
1251     goto reject_caps;
1252 
1253   GST_DEBUG_OBJECT (trans, &quot;trying to transform with filter: %&quot;
1254       GST_PTR_FORMAT &quot; (the other pad template)&quot;, otempl);
1255   ocaps = gst_base_transform_transform_caps (trans, direction, caps, otempl);
1256   if (!ocaps || gst_caps_is_empty (ocaps))
1257     goto no_transform_possible;
1258 
1259 done:
1260   GST_DEBUG_OBJECT (trans, &quot;accept-caps result: %d&quot;, ret);
1261   if (ocaps)
1262     gst_caps_unref (ocaps);
1263   gst_caps_unref (templ);
1264   gst_caps_unref (otempl);
1265   return ret;
1266 
1267   /* ERRORS */
1268 reject_caps:
1269   {
1270     GST_DEBUG_OBJECT (trans, &quot;caps can&#39;t intersect with the template&quot;);
1271     ret = FALSE;
1272     goto done;
1273   }
1274 no_transform_possible:
1275   {
1276     GST_DEBUG_OBJECT (trans,
1277         &quot;transform could not transform %&quot; GST_PTR_FORMAT
1278         &quot; in anything we support&quot;, caps);
1279     ret = FALSE;
1280     goto done;
1281   }
1282 }
1283 
1284 /* called when new caps arrive on the sink pad,
1285  * We try to find the best caps for the other side using our _find_transform()
1286  * function. If there are caps, we configure the transform for this new
1287  * transformation.
1288  */
1289 static gboolean
1290 gst_base_transform_setcaps (GstBaseTransform * trans, GstPad * pad,
1291     GstCaps * incaps)
1292 {
1293   GstBaseTransformPrivate *priv = trans-&gt;priv;
1294   GstCaps *outcaps, *prev_incaps = NULL, *prev_outcaps = NULL;
1295   gboolean ret = TRUE;
1296 
1297   GST_DEBUG_OBJECT (pad, &quot;have new caps %p %&quot; GST_PTR_FORMAT, incaps, incaps);
1298 
1299   /* find best possible caps for the other pad */
1300   outcaps = gst_base_transform_find_transform (trans, pad, incaps);
1301   if (!outcaps || gst_caps_is_empty (outcaps))
1302     goto no_transform_possible;
1303 
1304   /* configure the element now */
1305 
1306   /* if we have the same caps, we can optimize and reuse the input caps */
1307   if (gst_caps_is_equal (incaps, outcaps)) {
1308     GST_INFO_OBJECT (trans, &quot;reuse caps&quot;);
1309     gst_caps_unref (outcaps);
1310     outcaps = gst_caps_ref (incaps);
1311   }
1312 
1313   prev_incaps = gst_pad_get_current_caps (trans-&gt;sinkpad);
1314   prev_outcaps = gst_pad_get_current_caps (trans-&gt;srcpad);
1315   if (prev_incaps &amp;&amp; prev_outcaps &amp;&amp; gst_caps_is_equal (prev_incaps, incaps)
1316       &amp;&amp; gst_caps_is_equal (prev_outcaps, outcaps)) {
1317     GST_DEBUG_OBJECT (trans,
1318         &quot;New caps equal to old ones: %&quot; GST_PTR_FORMAT &quot; -&gt; %&quot; GST_PTR_FORMAT,
1319         incaps, outcaps);
1320     ret = TRUE;
1321   } else {
1322     /* call configure now */
1323     if (!(ret = gst_base_transform_configure_caps (trans, incaps, outcaps)))
1324       goto failed_configure;
1325 
1326     if (!prev_outcaps || !gst_caps_is_equal (outcaps, prev_outcaps))
1327       /* let downstream know about our caps */
1328       ret = gst_pad_set_caps (trans-&gt;srcpad, outcaps);
1329   }
1330 
1331   if (ret) {
1332     /* try to get a pool when needed */
1333     ret = gst_base_transform_do_bufferpool (trans, outcaps);
1334   }
1335 
1336 done:
1337   if (outcaps)
1338     gst_caps_unref (outcaps);
1339   if (prev_incaps)
1340     gst_caps_unref (prev_incaps);
1341   if (prev_outcaps)
1342     gst_caps_unref (prev_outcaps);
1343 
1344   GST_OBJECT_LOCK (trans);
1345   priv-&gt;negotiated = ret;
1346   GST_OBJECT_UNLOCK (trans);
1347 
1348   return ret;
1349 
1350   /* ERRORS */
1351 no_transform_possible:
1352   {
1353     GST_WARNING_OBJECT (trans,
1354         &quot;transform could not transform %&quot; GST_PTR_FORMAT
1355         &quot; in anything we support&quot;, incaps);
1356     ret = FALSE;
1357     goto done;
1358   }
1359 failed_configure:
1360   {
1361     GST_WARNING_OBJECT (trans, &quot;FAILED to configure incaps %&quot; GST_PTR_FORMAT
1362         &quot; and outcaps %&quot; GST_PTR_FORMAT, incaps, outcaps);
1363     ret = FALSE;
1364     goto done;
1365   }
1366 }
1367 
1368 static gboolean
1369 gst_base_transform_default_propose_allocation (GstBaseTransform * trans,
1370     GstQuery * decide_query, GstQuery * query)
1371 {
1372   gboolean ret;
1373 
1374   if (decide_query == NULL) {
1375     GST_DEBUG_OBJECT (trans, &quot;doing passthrough query&quot;);
1376     ret = gst_pad_peer_query (trans-&gt;srcpad, query);
1377   } else {
1378     guint i, n_metas;
1379     /* non-passthrough, copy all metadata, decide_query does not contain the
1380      * metadata anymore that depends on the buffer memory */
1381     n_metas = gst_query_get_n_allocation_metas (decide_query);
1382     for (i = 0; i &lt; n_metas; i++) {
1383       GType api;
1384       const GstStructure *params;
1385 
1386       api = gst_query_parse_nth_allocation_meta (decide_query, i, &amp;params);
1387       GST_DEBUG_OBJECT (trans, &quot;proposing metadata %s&quot;, g_type_name (api));
1388       gst_query_add_allocation_meta (query, api, params);
1389     }
1390     ret = TRUE;
1391   }
1392   return ret;
1393 }
1394 
1395 static gboolean
1396 gst_base_transform_reconfigure (GstBaseTransform * trans)
1397 {
1398   gboolean reconfigure, ret = TRUE;
1399 
1400   reconfigure = gst_pad_check_reconfigure (trans-&gt;srcpad);
1401 
1402   if (G_UNLIKELY (reconfigure)) {
1403     GstCaps *incaps;
1404 
1405     GST_DEBUG_OBJECT (trans, &quot;we had a pending reconfigure&quot;);
1406 
1407     incaps = gst_pad_get_current_caps (trans-&gt;sinkpad);
1408     if (incaps == NULL)
1409       goto done;
1410 
1411     /* if we need to reconfigure we pretend new caps arrived. This
1412      * will reconfigure the transform with the new output format. */
1413     if (!gst_base_transform_setcaps (trans, trans-&gt;sinkpad, incaps)) {
1414       GST_ELEMENT_WARNING (trans, STREAM, FORMAT,
1415           (&quot;not negotiated&quot;), (&quot;not negotiated&quot;));
1416       ret = FALSE;
1417     }
1418 
1419     gst_caps_unref (incaps);
1420   }
1421 
1422 done:
1423 
1424   if (!ret)
1425     gst_pad_mark_reconfigure (trans-&gt;srcpad);
1426 
1427   return ret;
1428 }
1429 
1430 static gboolean
1431 gst_base_transform_default_query (GstBaseTransform * trans,
1432     GstPadDirection direction, GstQuery * query)
1433 {
1434   gboolean ret = FALSE;
1435   GstPad *pad, *otherpad;
1436   GstBaseTransformClass *klass;
1437   GstBaseTransformPrivate *priv = trans-&gt;priv;
1438 
1439   if (direction == GST_PAD_SRC) {
1440     pad = trans-&gt;srcpad;
1441     otherpad = trans-&gt;sinkpad;
1442   } else {
1443     pad = trans-&gt;sinkpad;
1444     otherpad = trans-&gt;srcpad;
1445   }
1446 
1447   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1448 
1449   switch (GST_QUERY_TYPE (query)) {
1450     case GST_QUERY_ALLOCATION:
1451     {
1452       GstQuery *decide_query = NULL;
1453 
1454       /* can only be done on the sinkpad */
1455       if (direction != GST_PAD_SINK)
1456         goto done;
1457 
1458       ret = gst_base_transform_reconfigure (trans);
1459       if (G_UNLIKELY (!ret))
1460         goto done;
1461 
1462       GST_OBJECT_LOCK (trans);
1463       if (!priv-&gt;negotiated &amp;&amp; !priv-&gt;passthrough &amp;&amp; (klass-&gt;set_caps != NULL)) {
1464         GST_DEBUG_OBJECT (trans,
1465             &quot;not negotiated yet but need negotiation, can&#39;t answer ALLOCATION query&quot;);
1466         GST_OBJECT_UNLOCK (trans);
1467         goto done;
1468       }
1469 
1470       decide_query = trans-&gt;priv-&gt;query;
1471       trans-&gt;priv-&gt;query = NULL;
1472       GST_OBJECT_UNLOCK (trans);
1473 
1474       GST_DEBUG_OBJECT (trans,
1475           &quot;calling propose allocation with query %&quot; GST_PTR_FORMAT,
1476           decide_query);
1477 
1478       /* pass the query to the propose_allocation vmethod if any */
1479       if (G_LIKELY (klass-&gt;propose_allocation))
1480         ret = klass-&gt;propose_allocation (trans, decide_query, query);
1481       else
1482         ret = FALSE;
1483 
1484       if (decide_query) {
1485         GST_OBJECT_LOCK (trans);
1486 
1487         if (trans-&gt;priv-&gt;query == NULL)
1488           trans-&gt;priv-&gt;query = decide_query;
1489         else
1490           gst_query_unref (decide_query);
1491 
1492         GST_OBJECT_UNLOCK (trans);
1493       }
1494 
1495       GST_DEBUG_OBJECT (trans, &quot;ALLOCATION ret %d, %&quot; GST_PTR_FORMAT, ret,
1496           query);
1497       break;
1498     }
1499     case GST_QUERY_POSITION:
1500     {
1501       GstFormat format;
1502 
1503       gst_query_parse_position (query, &amp;format, NULL);
1504       if (format == GST_FORMAT_TIME &amp;&amp; trans-&gt;segment.format == GST_FORMAT_TIME) {
1505         gint64 pos;
1506         ret = TRUE;
1507 
1508         if ((direction == GST_PAD_SINK)
1509             || (trans-&gt;priv-&gt;position_out == GST_CLOCK_TIME_NONE)) {
1510           pos =
1511               gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
1512               trans-&gt;segment.position);
1513         } else {
1514           pos = gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
1515               trans-&gt;priv-&gt;position_out);
1516         }
1517         gst_query_set_position (query, format, pos);
1518       } else {
1519         ret = gst_pad_peer_query (otherpad, query);
1520       }
1521       break;
1522     }
1523     case GST_QUERY_ACCEPT_CAPS:
1524     {
1525       GstCaps *caps;
1526 
1527       gst_query_parse_accept_caps (query, &amp;caps);
1528       if (klass-&gt;accept_caps) {
1529         ret = klass-&gt;accept_caps (trans, direction, caps);
1530         gst_query_set_accept_caps_result (query, ret);
1531         /* return TRUE, we answered the query */
1532         ret = TRUE;
1533       }
1534       break;
1535     }
1536     case GST_QUERY_CAPS:
1537     {
1538       GstCaps *filter, *caps;
1539 
1540       gst_query_parse_caps (query, &amp;filter);
1541       caps = gst_base_transform_query_caps (trans, pad, filter);
1542       gst_query_set_caps_result (query, caps);
1543       gst_caps_unref (caps);
1544       ret = TRUE;
1545       break;
1546     }
1547     default:
1548       ret = gst_pad_peer_query (otherpad, query);
1549       break;
1550   }
1551 
1552 done:
1553   return ret;
1554 }
1555 
1556 static gboolean
1557 gst_base_transform_query (GstPad * pad, GstObject * parent, GstQuery * query)
1558 {
1559   GstBaseTransform *trans;
1560   GstBaseTransformClass *bclass;
1561   gboolean ret = FALSE;
1562 
1563   trans = GST_BASE_TRANSFORM_CAST (parent);
1564   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1565 
1566   if (bclass-&gt;query)
1567     ret = bclass-&gt;query (trans, GST_PAD_DIRECTION (pad), query);
1568 
1569   return ret;
1570 }
1571 
1572 /* this function either returns the input buffer without incrementing the
1573  * refcount or it allocates a new (writable) buffer */
1574 static GstFlowReturn
1575 default_prepare_output_buffer (GstBaseTransform * trans,
1576     GstBuffer * inbuf, GstBuffer ** outbuf)
1577 {
1578   GstBaseTransformPrivate *priv;
1579   GstFlowReturn ret;
1580   GstBaseTransformClass *bclass;
1581   GstCaps *incaps, *outcaps;
1582   gsize insize, outsize;
1583   gboolean res;
1584 
1585   priv = trans-&gt;priv;
1586   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1587 
1588   /* figure out how to allocate an output buffer */
1589   if (priv-&gt;passthrough) {
1590     /* passthrough, we will not modify the incoming buffer so we can just
1591      * reuse it */
1592     GST_DEBUG_OBJECT (trans, &quot;passthrough: reusing input buffer&quot;);
1593     *outbuf = inbuf;
1594     goto done;
1595   }
1596 
1597   /* we can&#39;t reuse the input buffer */
1598   if (priv-&gt;pool) {
1599     if (!priv-&gt;pool_active) {
1600       GST_DEBUG_OBJECT (trans, &quot;setting pool %p active&quot;, priv-&gt;pool);
1601       if (!gst_buffer_pool_set_active (priv-&gt;pool, TRUE))
1602         goto activate_failed;
1603       priv-&gt;pool_active = TRUE;
1604     }
1605     GST_DEBUG_OBJECT (trans, &quot;using pool alloc&quot;);
1606     ret = gst_buffer_pool_acquire_buffer (priv-&gt;pool, outbuf, NULL);
1607     if (ret != GST_FLOW_OK)
1608       goto alloc_failed;
1609 
1610     goto copy_meta;
1611   }
1612 
1613   /* no pool, we need to figure out the size of the output buffer first */
1614   if ((bclass-&gt;transform_ip != NULL) &amp;&amp; priv-&gt;always_in_place) {
1615     /* we want to do an in-place alloc */
1616     if (gst_buffer_is_writable (inbuf)) {
1617       GST_DEBUG_OBJECT (trans, &quot;inplace reuse writable input buffer&quot;);
1618       *outbuf = inbuf;
1619     } else {
1620       GST_DEBUG_OBJECT (trans, &quot;making writable buffer copy&quot;);
1621       /* we make a copy of the input buffer */
1622       *outbuf = gst_buffer_copy (inbuf);
1623     }
1624     goto done;
1625   }
1626 
1627   /* else use the transform function to get the size */
1628   incaps = gst_pad_get_current_caps (trans-&gt;sinkpad);
1629   outcaps = gst_pad_get_current_caps (trans-&gt;srcpad);
1630 
1631   /* srcpad might be flushing already if we&#39;re being shut down */
1632   if (outcaps == NULL)
1633     goto no_outcaps;
1634 
1635   GST_DEBUG_OBJECT (trans, &quot;getting output size for alloc&quot;);
1636   /* copy transform, figure out the output size */
1637   insize = gst_buffer_get_size (inbuf);
1638   res = gst_base_transform_transform_size (trans,
1639       GST_PAD_SINK, incaps, insize, outcaps, &amp;outsize);
1640 
1641   gst_caps_unref (incaps);
1642   gst_caps_unref (outcaps);
1643 
1644   if (!res)
1645     goto unknown_size;
1646 
1647   GST_DEBUG_OBJECT (trans, &quot;doing alloc of size %&quot; G_GSIZE_FORMAT, outsize);
1648   *outbuf = gst_buffer_new_allocate (priv-&gt;allocator, outsize, &amp;priv-&gt;params);
1649   if (!*outbuf) {
1650     ret = GST_FLOW_ERROR;
1651     goto alloc_failed;
1652   }
1653 
1654 copy_meta:
1655   /* copy the metadata */
1656   if (bclass-&gt;copy_metadata)
1657     if (!bclass-&gt;copy_metadata (trans, inbuf, *outbuf)) {
1658       /* something failed, post a warning */
1659       GST_ELEMENT_WARNING (trans, STREAM, NOT_IMPLEMENTED,
1660           (&quot;could not copy metadata&quot;), (NULL));
1661     }
1662 
1663 done:
1664   return GST_FLOW_OK;
1665 
1666   /* ERRORS */
1667 activate_failed:
1668   {
1669     GST_ELEMENT_ERROR (trans, RESOURCE, SETTINGS,
1670         (&quot;failed to activate bufferpool&quot;), (&quot;failed to activate bufferpool&quot;));
1671     return GST_FLOW_ERROR;
1672   }
1673 unknown_size:
1674   {
1675     GST_ERROR_OBJECT (trans, &quot;unknown output size&quot;);
1676     return GST_FLOW_ERROR;
1677   }
1678 alloc_failed:
1679   {
1680     GST_DEBUG_OBJECT (trans, &quot;could not allocate buffer from pool&quot;);
1681     return ret;
1682   }
1683 no_outcaps:
1684   {
1685     GST_DEBUG_OBJECT (trans, &quot;no output caps, source pad has been deactivated&quot;);
1686     gst_caps_unref (incaps);
1687     return GST_FLOW_FLUSHING;
1688   }
1689 }
1690 
1691 typedef struct
1692 {
1693   GstBaseTransform *trans;
1694   GstBuffer *outbuf;
1695 } CopyMetaData;
1696 
1697 static gboolean
1698 foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
1699 {
1700   CopyMetaData *data = user_data;
1701   GstBaseTransform *trans = data-&gt;trans;
1702   GstBaseTransformClass *klass;
1703   const GstMetaInfo *info = (*meta)-&gt;info;
1704   GstBuffer *outbuf = data-&gt;outbuf;
1705   gboolean do_copy = FALSE;
1706 
1707   klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1708 
1709   if (gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
1710     /* never call the transform_meta with memory specific metadata */
1711     GST_DEBUG_OBJECT (trans, &quot;not copying memory specific metadata %s&quot;,
1712         g_type_name (info-&gt;api));
1713     do_copy = FALSE;
1714   } else if (klass-&gt;transform_meta) {
1715     do_copy = klass-&gt;transform_meta (trans, outbuf, *meta, inbuf);
1716     GST_DEBUG_OBJECT (trans, &quot;transformed metadata %s: copy: %d&quot;,
1717         g_type_name (info-&gt;api), do_copy);
1718   }
1719 
1720   /* we only copy metadata when the subclass implemented a transform_meta
1721    * function and when it returns %TRUE */
1722   if (do_copy) {
1723     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
1724     /* simply copy then */
1725     if (info-&gt;transform_func) {
1726       GST_DEBUG_OBJECT (trans, &quot;copy metadata %s&quot;, g_type_name (info-&gt;api));
1727       info-&gt;transform_func (outbuf, *meta, inbuf,
1728           _gst_meta_transform_copy, &amp;copy_data);
1729     } else {
1730       GST_DEBUG_OBJECT (trans, &quot;couldn&#39;t copy metadata %s&quot;,
1731           g_type_name (info-&gt;api));
1732     }
1733   }
1734   return TRUE;
1735 }
1736 
1737 static gboolean
1738 default_copy_metadata (GstBaseTransform * trans,
1739     GstBuffer * inbuf, GstBuffer * outbuf)
1740 {
1741   GstBaseTransformPrivate *priv = trans-&gt;priv;
1742   CopyMetaData data;
1743 
1744   /* now copy the metadata */
1745   GST_DEBUG_OBJECT (trans, &quot;copying metadata&quot;);
1746 
1747   /* this should not happen, buffers allocated from a pool or with
1748    * new_allocate should always be writable. */
1749   if (!gst_buffer_is_writable (outbuf))
1750     goto not_writable;
1751 
1752   /* when we get here, the metadata should be writable */
1753   gst_buffer_copy_into (outbuf, inbuf,
1754       GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS, 0, -1);
1755 
1756   /* clear the GAP flag when the subclass does not understand it */
1757   if (!priv-&gt;gap_aware)
1758     GST_BUFFER_FLAG_UNSET (outbuf, GST_BUFFER_FLAG_GAP);
1759 
1760 
1761   data.trans = trans;
1762   data.outbuf = outbuf;
1763 
1764   gst_buffer_foreach_meta (inbuf, foreach_metadata, &amp;data);
1765 
1766   return TRUE;
1767 
1768   /* ERRORS */
1769 not_writable:
1770   {
1771     GST_WARNING_OBJECT (trans, &quot;buffer %p not writable&quot;, outbuf);
1772     return FALSE;
1773   }
1774 }
1775 
1776 /* Given @caps calcultate the size of one unit.
1777  *
1778  * For video caps, this is the size of one frame (and thus one buffer).
1779  * For audio caps, this is the size of one sample.
1780  *
1781  * These values are cached since they do not change and the calculation
1782  * potentially involves parsing caps and other expensive stuff.
1783  *
1784  * We have two cache locations to store the size, one for the source caps
1785  * and one for the sink caps.
1786  *
1787  * this function returns %FALSE if no size could be calculated.
1788  */
1789 static gboolean
1790 gst_base_transform_get_unit_size (GstBaseTransform * trans, GstCaps * caps,
1791     gsize * size)
1792 {
1793   gboolean res = FALSE;
1794   GstBaseTransformClass *bclass;
1795   GstBaseTransformPrivate *priv = trans-&gt;priv;
1796 
1797   /* see if we have the result cached */
1798   if (priv-&gt;cache_caps1 == caps) {
1799     *size = priv-&gt;cache_caps1_size;
1800     GST_DEBUG_OBJECT (trans,
1801         &quot;returned %&quot; G_GSIZE_FORMAT &quot; from first cache&quot;, *size);
1802     return TRUE;
1803   }
1804   if (priv-&gt;cache_caps2 == caps) {
1805     *size = priv-&gt;cache_caps2_size;
1806     GST_DEBUG_OBJECT (trans,
1807         &quot;returned %&quot; G_GSIZE_FORMAT &quot; from second cached&quot;, *size);
1808     return TRUE;
1809   }
1810 
1811   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1812   res = bclass-&gt;get_unit_size (trans, caps, size);
1813   GST_DEBUG_OBJECT (trans,
1814       &quot;caps %&quot; GST_PTR_FORMAT &quot; has unit size %&quot; G_GSIZE_FORMAT &quot;, res %s&quot;,
1815       caps, *size, res ? &quot;TRUE&quot; : &quot;FALSE&quot;);
1816 
1817   if (res) {
1818     /* and cache the values */
1819     if (priv-&gt;cache_caps1 == NULL) {
1820       gst_caps_replace (&amp;priv-&gt;cache_caps1, caps);
1821       priv-&gt;cache_caps1_size = *size;
1822       GST_DEBUG_OBJECT (trans,
1823           &quot;caching %&quot; G_GSIZE_FORMAT &quot; in first cache&quot;, *size);
1824     } else if (priv-&gt;cache_caps2 == NULL) {
1825       gst_caps_replace (&amp;priv-&gt;cache_caps2, caps);
1826       priv-&gt;cache_caps2_size = *size;
1827       GST_DEBUG_OBJECT (trans,
1828           &quot;caching %&quot; G_GSIZE_FORMAT &quot; in second cache&quot;, *size);
1829     } else {
1830       GST_DEBUG_OBJECT (trans, &quot;no free spot to cache unit_size&quot;);
1831     }
1832   }
1833   return res;
1834 }
1835 
1836 static gboolean
1837 gst_base_transform_sink_event (GstPad * pad, GstObject * parent,
1838     GstEvent * event)
1839 {
1840   GstBaseTransform *trans;
1841   GstBaseTransformClass *bclass;
1842   gboolean ret = TRUE;
1843 
1844   trans = GST_BASE_TRANSFORM_CAST (parent);
1845   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1846 
1847   if (bclass-&gt;sink_event)
1848     ret = bclass-&gt;sink_event (trans, event);
1849   else
1850     gst_event_unref (event);
1851 
1852   return ret;
1853 }
1854 
1855 static gboolean
1856 gst_base_transform_sink_eventfunc (GstBaseTransform * trans, GstEvent * event)
1857 {
1858   gboolean ret = TRUE, forward = TRUE;
1859   GstBaseTransformPrivate *priv = trans-&gt;priv;
1860 
1861   switch (GST_EVENT_TYPE (event)) {
1862     case GST_EVENT_FLUSH_START:
1863       break;
1864     case GST_EVENT_FLUSH_STOP:
1865       GST_OBJECT_LOCK (trans);
1866       /* reset QoS parameters */
1867       priv-&gt;proportion = 1.0;
1868       priv-&gt;earliest_time = -1;
1869       priv-&gt;discont = FALSE;
1870       priv-&gt;processed = 0;
1871       priv-&gt;dropped = 0;
1872       GST_OBJECT_UNLOCK (trans);
1873       /* we need new segment info after the flush. */
1874       trans-&gt;have_segment = FALSE;
1875       gst_segment_init (&amp;trans-&gt;segment, GST_FORMAT_UNDEFINED);
1876       priv-&gt;position_out = GST_CLOCK_TIME_NONE;
1877       break;
1878     case GST_EVENT_EOS:
1879       break;
1880     case GST_EVENT_TAG:
1881       break;
1882     case GST_EVENT_CAPS:
1883     {
1884       GstCaps *caps;
1885 
1886       gst_event_parse_caps (event, &amp;caps);
1887       /* clear any pending reconfigure flag */
1888       gst_pad_check_reconfigure (trans-&gt;srcpad);
1889       ret = gst_base_transform_setcaps (trans, trans-&gt;sinkpad, caps);
1890       if (!ret)
1891         gst_pad_mark_reconfigure (trans-&gt;srcpad);
1892 
1893       forward = FALSE;
1894       break;
1895     }
1896     case GST_EVENT_SEGMENT:
1897     {
1898       gst_event_copy_segment (event, &amp;trans-&gt;segment);
1899       trans-&gt;have_segment = TRUE;
1900 
1901       GST_DEBUG_OBJECT (trans, &quot;received SEGMENT %&quot; GST_SEGMENT_FORMAT,
1902           &amp;trans-&gt;segment);
1903       break;
1904     }
1905     default:
1906       break;
1907   }
1908 
1909   if (ret &amp;&amp; forward)
1910     ret = gst_pad_push_event (trans-&gt;srcpad, event);
1911   else
1912     gst_event_unref (event);
1913 
1914   return ret;
1915 }
1916 
1917 static gboolean
1918 gst_base_transform_src_event (GstPad * pad, GstObject * parent,
1919     GstEvent * event)
1920 {
1921   GstBaseTransform *trans;
1922   GstBaseTransformClass *bclass;
1923   gboolean ret = TRUE;
1924 
1925   trans = GST_BASE_TRANSFORM_CAST (parent);
1926   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1927 
1928   if (bclass-&gt;src_event)
1929     ret = bclass-&gt;src_event (trans, event);
1930   else
1931     gst_event_unref (event);
1932 
1933   return ret;
1934 }
1935 
1936 static gboolean
1937 gst_base_transform_src_eventfunc (GstBaseTransform * trans, GstEvent * event)
1938 {
1939   gboolean ret;
1940 
1941   GST_DEBUG_OBJECT (trans, &quot;handling event %p %&quot; GST_PTR_FORMAT, event, event);
1942 
1943   switch (GST_EVENT_TYPE (event)) {
1944     case GST_EVENT_SEEK:
1945       break;
1946     case GST_EVENT_NAVIGATION:
1947       break;
1948     case GST_EVENT_QOS:
1949     {
1950       gdouble proportion;
1951       GstClockTimeDiff diff;
1952       GstClockTime timestamp;
1953 
1954       gst_event_parse_qos (event, NULL, &amp;proportion, &amp;diff, &amp;timestamp);
1955       gst_base_transform_update_qos (trans, proportion, diff, timestamp);
1956       break;
1957     }
1958     default:
1959       break;
1960   }
1961 
1962   ret = gst_pad_push_event (trans-&gt;sinkpad, event);
1963 
1964   return ret;
1965 }
1966 
1967 /* Takes the input buffer */
1968 static GstFlowReturn
1969 default_submit_input_buffer (GstBaseTransform * trans, gboolean is_discont,
1970     GstBuffer * inbuf)
1971 {
1972   GstBaseTransformClass *bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
1973   GstBaseTransformPrivate *priv = trans-&gt;priv;
1974   GstFlowReturn ret = GST_FLOW_OK;
1975   GstClockTime running_time;
1976   GstClockTime timestamp;
1977 
1978   if (G_UNLIKELY (!gst_base_transform_reconfigure (trans)))
1979     goto not_negotiated;
1980 
1981   if (GST_BUFFER_OFFSET_IS_VALID (inbuf))
1982     GST_DEBUG_OBJECT (trans,
1983         &quot;handling buffer %p of size %&quot; G_GSIZE_FORMAT &quot;, PTS %&quot; GST_TIME_FORMAT
1984         &quot; and offset %&quot; G_GUINT64_FORMAT, inbuf, gst_buffer_get_size (inbuf),
1985         GST_TIME_ARGS (GST_BUFFER_PTS (inbuf)), GST_BUFFER_OFFSET (inbuf));
1986   else
1987     GST_DEBUG_OBJECT (trans,
1988         &quot;handling buffer %p of size %&quot; G_GSIZE_FORMAT &quot;, PTS %&quot; GST_TIME_FORMAT
1989         &quot; and offset NONE&quot;, inbuf, gst_buffer_get_size (inbuf),
1990         GST_TIME_ARGS (GST_BUFFER_PTS (inbuf)));
1991 
1992   /* Don&#39;t allow buffer handling before negotiation, except in passthrough mode
1993    * or if the class doesn&#39;t implement a set_caps function (in which case it doesn&#39;t
1994    * care about caps)
1995    */
1996   if (!priv-&gt;negotiated &amp;&amp; !priv-&gt;passthrough &amp;&amp; (bclass-&gt;set_caps != NULL))
1997     goto not_negotiated;
1998 
1999   /* can only do QoS if the segment is in TIME */
2000   if (trans-&gt;segment.format != GST_FORMAT_TIME)
2001     goto no_qos;
2002 
2003   /* QOS is done on the running time of the buffer, get it now */
2004   timestamp = GST_BUFFER_TIMESTAMP (inbuf);
2005   running_time = gst_segment_to_running_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
2006       timestamp);
2007 
2008   if (running_time != -1) {
2009     gboolean need_skip;
2010     GstClockTime earliest_time;
2011     gdouble proportion;
2012 
2013     /* lock for getting the QoS parameters that are set (in a different thread)
2014      * with the QOS events */
2015     GST_OBJECT_LOCK (trans);
2016     earliest_time = priv-&gt;earliest_time;
2017     proportion = priv-&gt;proportion;
2018     /* check for QoS, don&#39;t perform conversion for buffers
2019      * that are known to be late. */
2020     need_skip = priv-&gt;qos_enabled &amp;&amp;
2021         earliest_time != -1 &amp;&amp; running_time &lt;= earliest_time;
2022     GST_OBJECT_UNLOCK (trans);
2023 
2024     if (need_skip) {
2025       GstMessage *qos_msg;
2026       GstClockTime duration;
2027       guint64 stream_time;
2028       gint64 jitter;
2029 
2030       GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, trans, &quot;skipping transform: qostime %&quot;
2031           GST_TIME_FORMAT &quot; &lt;= %&quot; GST_TIME_FORMAT,
2032           GST_TIME_ARGS (running_time), GST_TIME_ARGS (earliest_time));
2033 
2034       priv-&gt;dropped++;
2035 
2036       duration = GST_BUFFER_DURATION (inbuf);
2037       stream_time =
2038           gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
2039           timestamp);
2040       jitter = GST_CLOCK_DIFF (running_time, earliest_time);
2041 
2042       qos_msg =
2043           gst_message_new_qos (GST_OBJECT_CAST (trans), FALSE, running_time,
2044           stream_time, timestamp, duration);
2045       gst_message_set_qos_values (qos_msg, jitter, proportion, 1000000);
2046       gst_message_set_qos_stats (qos_msg, GST_FORMAT_BUFFERS,
2047           priv-&gt;processed, priv-&gt;dropped);
2048       gst_element_post_message (GST_ELEMENT_CAST (trans), qos_msg);
2049 
2050       /* mark discont for next buffer */
2051       priv-&gt;discont = TRUE;
2052       ret = GST_BASE_TRANSFORM_FLOW_DROPPED;
2053       goto skip;
2054     }
2055   }
2056 
2057 no_qos:
2058   /* Stash input buffer where the default generate_output
2059    * function can find it */
2060   if (trans-&gt;queued_buf)
2061     gst_buffer_unref (trans-&gt;queued_buf);
2062   trans-&gt;queued_buf = inbuf;
2063   return ret;
2064 skip:
2065   gst_buffer_unref (inbuf);
2066   return ret;
2067 
2068 not_negotiated:
2069   {
2070     gst_buffer_unref (inbuf);
2071     if (GST_PAD_IS_FLUSHING (trans-&gt;srcpad))
2072       return GST_FLOW_FLUSHING;
2073     return GST_FLOW_NOT_NEGOTIATED;
2074   }
2075 }
2076 
2077 static GstFlowReturn
2078 default_generate_output (GstBaseTransform * trans, GstBuffer ** outbuf)
2079 {
2080   GstBaseTransformClass *bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
2081   GstBaseTransformPrivate *priv = trans-&gt;priv;
2082   GstFlowReturn ret = GST_FLOW_OK;
2083   GstBuffer *inbuf;
2084   gboolean want_in_place;
2085 
2086   /* Retrieve stashed input buffer, if the default submit_input_buffer
2087    * was run. Takes ownership back from there */
2088   inbuf = trans-&gt;queued_buf;
2089   trans-&gt;queued_buf = NULL;
2090 
2091   /* This default processing method needs one input buffer to feed to
2092    * the transform functions, we can&#39;t do anything without it */
2093   if (inbuf == NULL)
2094     return GST_FLOW_OK;
2095 
2096   /* first try to allocate an output buffer based on the currently negotiated
2097    * format. outbuf will contain a buffer suitable for doing the configured
2098    * transform after this function. */
2099   if (bclass-&gt;prepare_output_buffer == NULL)
2100     goto no_prepare;
2101 
2102   GST_DEBUG_OBJECT (trans, &quot;calling prepare buffer&quot;);
2103   ret = bclass-&gt;prepare_output_buffer (trans, inbuf, outbuf);
2104 
2105   if (ret != GST_FLOW_OK || *outbuf == NULL)
2106     goto no_buffer;
2107 
2108   GST_DEBUG_OBJECT (trans, &quot;using allocated buffer in %p, out %p&quot;, inbuf,
2109       *outbuf);
2110 
2111   /* now perform the needed transform */
2112   if (priv-&gt;passthrough) {
2113     /* In passthrough mode, give transform_ip a look at the
2114      * buffer, without making it writable, or just push the
2115      * data through */
2116     if (bclass-&gt;transform_ip_on_passthrough &amp;&amp; bclass-&gt;transform_ip) {
2117       GST_DEBUG_OBJECT (trans, &quot;doing passthrough transform_ip&quot;);
2118       ret = bclass-&gt;transform_ip (trans, *outbuf);
2119     } else {
2120       GST_DEBUG_OBJECT (trans, &quot;element is in passthrough&quot;);
2121     }
2122   } else {
2123     want_in_place = (bclass-&gt;transform_ip != NULL) &amp;&amp; priv-&gt;always_in_place;
2124 
2125     if (want_in_place) {
2126       GST_DEBUG_OBJECT (trans, &quot;doing inplace transform&quot;);
2127       ret = bclass-&gt;transform_ip (trans, *outbuf);
2128     } else {
2129       GST_DEBUG_OBJECT (trans, &quot;doing non-inplace transform&quot;);
2130 
2131       if (bclass-&gt;transform)
2132         ret = bclass-&gt;transform (trans, inbuf, *outbuf);
2133       else
2134         ret = GST_FLOW_NOT_SUPPORTED;
2135     }
2136   }
2137 
2138   /* only unref input buffer if we allocated a new outbuf buffer. If we reused
2139    * the input buffer, no refcount is changed to keep the input buffer writable
2140    * when needed. */
2141   if (*outbuf != inbuf)
2142     gst_buffer_unref (inbuf);
2143 
2144   return ret;
2145 
2146   /* ERRORS */
2147 no_prepare:
2148   {
2149     gst_buffer_unref (inbuf);
2150     GST_ELEMENT_ERROR (trans, STREAM, NOT_IMPLEMENTED,
2151         (&quot;Sub-class has no prepare_output_buffer implementation&quot;), (NULL));
2152     return GST_FLOW_NOT_SUPPORTED;
2153   }
2154 no_buffer:
2155   {
2156     gst_buffer_unref (inbuf);
2157     *outbuf = NULL;
2158     GST_WARNING_OBJECT (trans, &quot;could not get buffer from pool: %s&quot;,
2159         gst_flow_get_name (ret));
2160     return ret;
2161   }
2162 }
2163 
2164 /* FIXME, getrange is broken, need to pull range from the other
2165  * end based on the transform_size result.
2166  */
2167 static GstFlowReturn
2168 gst_base_transform_getrange (GstPad * pad, GstObject * parent, guint64 offset,
2169     guint length, GstBuffer ** buffer)
2170 {
2171   GstBaseTransformClass *klass = GST_BASE_TRANSFORM_GET_CLASS (parent);
2172   GstBaseTransform *trans = GST_BASE_TRANSFORM_CAST (parent);
2173   GstBaseTransformPrivate *priv = trans-&gt;priv;
2174   GstFlowReturn ret;
2175   GstBuffer *inbuf = NULL;
2176   GstBuffer *outbuf = NULL;
2177 
2178   /* Try and generate a buffer, if the sub-class wants more data,
2179    * pull some and repeat until a buffer (or error) is produced */
2180   do {
2181     ret = klass-&gt;generate_output (trans, &amp;outbuf);
2182 
2183     /* Consume the DROPPED return value and go get more data */
2184     if (ret == GST_BASE_TRANSFORM_FLOW_DROPPED)
2185       ret = GST_FLOW_OK;
2186 
2187     if (ret != GST_FLOW_OK || outbuf != NULL)
2188       break;
2189 
2190     /* No buffer generated, try and pull data */
2191     ret = gst_pad_pull_range (trans-&gt;sinkpad, offset, length, &amp;inbuf);
2192     if (G_UNLIKELY (ret != GST_FLOW_OK))
2193       goto pull_error;
2194 
2195     if (klass-&gt;before_transform)
2196       klass-&gt;before_transform (trans, inbuf);
2197 
2198     /* Set discont flag so we can mark the next outgoing buffer */
2199     if (GST_BUFFER_IS_DISCONT (inbuf)) {
2200       GST_DEBUG_OBJECT (trans, &quot;got DISCONT buffer %p&quot;, inbuf);
2201       priv-&gt;discont = TRUE;
2202     }
2203 
2204     /* FIXME: Input offsets and lengths need to be translated, as per
2205      * the FIXME above. For now, just advance somewhat */
2206     offset += gst_buffer_get_size (inbuf);
2207 
2208     ret = klass-&gt;submit_input_buffer (trans, priv-&gt;discont, inbuf);
2209     if (ret != GST_FLOW_OK) {
2210       if (ret == GST_BASE_TRANSFORM_FLOW_DROPPED)
2211         ret = GST_FLOW_OK;
2212       goto done;
2213     }
2214   } while (ret == GST_FLOW_OK &amp;&amp; outbuf == NULL);
2215 
2216   *buffer = outbuf;
2217   if (outbuf) {
2218     /* apply DISCONT flag if the buffer is not yet marked as such */
2219     if (priv-&gt;discont) {
2220       GST_DEBUG_OBJECT (trans, &quot;we have a pending DISCONT&quot;);
2221       if (!GST_BUFFER_IS_DISCONT (outbuf)) {
2222         GST_DEBUG_OBJECT (trans, &quot;marking DISCONT on output buffer&quot;);
2223         outbuf = gst_buffer_make_writable (outbuf);
2224         GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
2225       }
2226       priv-&gt;discont = FALSE;
2227     }
2228     priv-&gt;processed++;
2229   }
2230 done:
2231   return ret;
2232 
2233   /* ERRORS */
2234 pull_error:
2235   {
2236     GST_DEBUG_OBJECT (trans, &quot;failed to pull a buffer: %s&quot;,
2237         gst_flow_get_name (ret));
2238     goto done;
2239   }
2240 }
2241 
2242 /* The flow of the chain function is the reverse of the
2243  * getrange() function - we have data, feed it to the sub-class
2244  * and then iterate, pushing buffers it generates until it either
2245  * wants more data or returns an error */
2246 static GstFlowReturn
2247 gst_base_transform_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
2248 {
2249   GstBaseTransform *trans = GST_BASE_TRANSFORM_CAST (parent);
2250   GstBaseTransformClass *klass = GST_BASE_TRANSFORM_GET_CLASS (trans);
2251   GstBaseTransformPrivate *priv = trans-&gt;priv;
2252   GstFlowReturn ret;
2253   GstClockTime position = GST_CLOCK_TIME_NONE;
2254   GstClockTime timestamp, duration;
2255   GstBuffer *outbuf = NULL;
2256 
2257   timestamp = GST_BUFFER_TIMESTAMP (buffer);
2258   duration = GST_BUFFER_DURATION (buffer);
2259 
2260   /* calculate end position of the incoming buffer */
2261   if (timestamp != GST_CLOCK_TIME_NONE) {
2262     if (duration != GST_CLOCK_TIME_NONE)
2263       position = timestamp + duration;
2264     else
2265       position = timestamp;
2266   }
2267 
2268   if (klass-&gt;before_transform)
2269     klass-&gt;before_transform (trans, buffer);
2270 
2271   /* Set discont flag so we can mark the outgoing buffer */
2272   if (GST_BUFFER_IS_DISCONT (buffer)) {
2273     GST_DEBUG_OBJECT (trans, &quot;got DISCONT buffer %p&quot;, buffer);
2274     priv-&gt;discont = TRUE;
2275   }
2276 
2277   /* Takes ownership of input buffer */
2278   ret = klass-&gt;submit_input_buffer (trans, priv-&gt;discont, buffer);
2279   if (ret != GST_FLOW_OK)
2280     goto done;
2281 
2282   do {
2283     outbuf = NULL;
2284 
2285     ret = klass-&gt;generate_output (trans, &amp;outbuf);
2286 
2287     /* outbuf can be NULL, this means a dropped buffer, if we have a buffer but
2288      * GST_BASE_TRANSFORM_FLOW_DROPPED we will not push either. */
2289     if (outbuf != NULL) {
2290       if (ret == GST_FLOW_OK) {
2291         GstClockTime position_out = GST_CLOCK_TIME_NONE;
2292 
2293         /* Remember last stop position */
2294         if (position != GST_CLOCK_TIME_NONE &amp;&amp;
2295             trans-&gt;segment.format == GST_FORMAT_TIME)
2296           trans-&gt;segment.position = position;
2297 
2298         if (GST_BUFFER_TIMESTAMP_IS_VALID (outbuf)) {
2299           position_out = GST_BUFFER_TIMESTAMP (outbuf);
2300           if (GST_BUFFER_DURATION_IS_VALID (outbuf))
2301             position_out += GST_BUFFER_DURATION (outbuf);
2302         } else if (position != GST_CLOCK_TIME_NONE) {
2303           position_out = position;
2304         }
2305         if (position_out != GST_CLOCK_TIME_NONE
2306             &amp;&amp; trans-&gt;segment.format == GST_FORMAT_TIME)
2307           priv-&gt;position_out = position_out;
2308 
2309         /* apply DISCONT flag if the buffer is not yet marked as such */
2310         if (trans-&gt;priv-&gt;discont) {
2311           GST_DEBUG_OBJECT (trans, &quot;we have a pending DISCONT&quot;);
2312           if (!GST_BUFFER_IS_DISCONT (outbuf)) {
2313             GST_DEBUG_OBJECT (trans, &quot;marking DISCONT on output buffer&quot;);
2314             outbuf = gst_buffer_make_writable (outbuf);
2315             GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
2316           }
2317           priv-&gt;discont = FALSE;
2318         }
2319         priv-&gt;processed++;
2320 
2321         ret = gst_pad_push (trans-&gt;srcpad, outbuf);
2322       } else {
2323         GST_DEBUG_OBJECT (trans, &quot;we got return %s&quot;, gst_flow_get_name (ret));
2324         gst_buffer_unref (outbuf);
2325       }
2326     }
2327   } while (ret == GST_FLOW_OK &amp;&amp; outbuf != NULL);
2328 
2329 done:
2330   /* convert internal flow to OK and mark discont for the next buffer. */
2331   if (ret == GST_BASE_TRANSFORM_FLOW_DROPPED) {
2332     GST_DEBUG_OBJECT (trans, &quot;dropped a buffer, marking DISCONT&quot;);
2333     priv-&gt;discont = TRUE;
2334     ret = GST_FLOW_OK;
2335   }
2336 
2337   return ret;
2338 }
2339 
2340 static void
2341 gst_base_transform_set_property (GObject * object, guint prop_id,
2342     const GValue * value, GParamSpec * pspec)
2343 {
2344   GstBaseTransform *trans;
2345 
2346   trans = GST_BASE_TRANSFORM_CAST (object);
2347 
2348   switch (prop_id) {
2349     case PROP_QOS:
2350       gst_base_transform_set_qos_enabled (trans, g_value_get_boolean (value));
2351       break;
2352     default:
2353       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2354       break;
2355   }
2356 }
2357 
2358 static void
2359 gst_base_transform_get_property (GObject * object, guint prop_id,
2360     GValue * value, GParamSpec * pspec)
2361 {
2362   GstBaseTransform *trans;
2363 
2364   trans = GST_BASE_TRANSFORM_CAST (object);
2365 
2366   switch (prop_id) {
2367     case PROP_QOS:
2368       g_value_set_boolean (value, gst_base_transform_is_qos_enabled (trans));
2369       break;
2370     default:
2371       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2372       break;
2373   }
2374 }
2375 
2376 /* not a vmethod of anything, just an internal method */
2377 static gboolean
2378 gst_base_transform_activate (GstBaseTransform * trans, gboolean active)
2379 {
2380   GstBaseTransformClass *bclass;
2381   GstBaseTransformPrivate *priv = trans-&gt;priv;
2382   gboolean result = TRUE;
2383 
2384   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
2385 
2386   if (active) {
2387     GstCaps *incaps, *outcaps;
2388 
2389     if (priv-&gt;pad_mode == GST_PAD_MODE_NONE &amp;&amp; bclass-&gt;start)
2390       result &amp;= bclass-&gt;start (trans);
2391 
2392     incaps = gst_pad_get_current_caps (trans-&gt;sinkpad);
2393     outcaps = gst_pad_get_current_caps (trans-&gt;srcpad);
2394 
2395     GST_OBJECT_LOCK (trans);
2396     if (incaps &amp;&amp; outcaps)
2397       priv-&gt;have_same_caps =
2398           gst_caps_is_equal (incaps, outcaps) || priv-&gt;passthrough;
2399     else
2400       priv-&gt;have_same_caps = priv-&gt;passthrough;
2401     GST_DEBUG_OBJECT (trans, &quot;have_same_caps %d&quot;, priv-&gt;have_same_caps);
2402     priv-&gt;negotiated = FALSE;
2403     trans-&gt;have_segment = FALSE;
2404     gst_segment_init (&amp;trans-&gt;segment, GST_FORMAT_UNDEFINED);
2405     priv-&gt;position_out = GST_CLOCK_TIME_NONE;
2406     priv-&gt;proportion = 1.0;
2407     priv-&gt;earliest_time = -1;
2408     priv-&gt;discont = FALSE;
2409     priv-&gt;processed = 0;
2410     priv-&gt;dropped = 0;
2411     GST_OBJECT_UNLOCK (trans);
2412 
2413     if (incaps)
2414       gst_caps_unref (incaps);
2415     if (outcaps)
2416       gst_caps_unref (outcaps);
2417   } else {
2418     /* We must make sure streaming has finished before resetting things
2419      * and calling the ::stop vfunc */
2420     GST_PAD_STREAM_LOCK (trans-&gt;sinkpad);
2421     GST_PAD_STREAM_UNLOCK (trans-&gt;sinkpad);
2422 
2423     priv-&gt;have_same_caps = FALSE;
2424     /* We can only reset the passthrough mode if the instance told us to
2425        handle it in configure_caps */
2426     if (bclass-&gt;passthrough_on_same_caps) {
2427       gst_base_transform_set_passthrough (trans, FALSE);
2428     }
2429     gst_caps_replace (&amp;priv-&gt;cache_caps1, NULL);
2430     gst_caps_replace (&amp;priv-&gt;cache_caps2, NULL);
2431 
2432     /* Make sure any left over buffer is freed */
2433     gst_buffer_replace (&amp;trans-&gt;queued_buf, NULL);
2434 
2435     if (priv-&gt;pad_mode != GST_PAD_MODE_NONE &amp;&amp; bclass-&gt;stop)
2436       result &amp;= bclass-&gt;stop (trans);
2437 
2438     gst_base_transform_set_allocation (trans, NULL, NULL, NULL, NULL);
2439   }
2440 
2441   return result;
2442 }
2443 
2444 static gboolean
2445 gst_base_transform_sink_activate_mode (GstPad * pad, GstObject * parent,
2446     GstPadMode mode, gboolean active)
2447 {
2448   gboolean result = FALSE;
2449   GstBaseTransform *trans;
2450 
2451   trans = GST_BASE_TRANSFORM_CAST (parent);
2452 
2453   switch (mode) {
2454     case GST_PAD_MODE_PUSH:
2455     {
2456       result = gst_base_transform_activate (trans, active);
2457 
2458       if (result)
2459         trans-&gt;priv-&gt;pad_mode = active ? GST_PAD_MODE_PUSH : GST_PAD_MODE_NONE;
2460 
2461       break;
2462     }
2463     default:
2464       result = TRUE;
2465       break;
2466   }
2467   return result;
2468 }
2469 
2470 static gboolean
2471 gst_base_transform_src_activate_mode (GstPad * pad, GstObject * parent,
2472     GstPadMode mode, gboolean active)
2473 {
2474   gboolean result = FALSE;
2475   GstBaseTransform *trans;
2476 
2477   trans = GST_BASE_TRANSFORM_CAST (parent);
2478 
2479   switch (mode) {
2480     case GST_PAD_MODE_PULL:
2481     {
2482       result =
2483           gst_pad_activate_mode (trans-&gt;sinkpad, GST_PAD_MODE_PULL, active);
2484 
2485       if (result)
2486         result &amp;= gst_base_transform_activate (trans, active);
2487 
2488       if (result)
2489         trans-&gt;priv-&gt;pad_mode = active ? mode : GST_PAD_MODE_NONE;
2490       break;
2491     }
2492     default:
2493       result = TRUE;
2494       break;
2495   }
2496 
2497   return result;
2498 }
2499 
2500 /**
2501  * gst_base_transform_set_passthrough:
2502  * @trans: the #GstBaseTransform to set
2503  * @passthrough: boolean indicating passthrough mode.
2504  *
2505  * Set passthrough mode for this filter by default. This is mostly
2506  * useful for filters that do not care about negotiation.
2507  *
2508  * Always %TRUE for filters which don&#39;t implement either a transform
2509  * or transform_ip method.
2510  *
2511  * MT safe.
2512  */
2513 void
2514 gst_base_transform_set_passthrough (GstBaseTransform * trans,
2515     gboolean passthrough)
2516 {
2517   GstBaseTransformClass *bclass;
2518 
2519   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2520 
2521   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
2522 
2523   GST_OBJECT_LOCK (trans);
2524   if (!passthrough) {
2525     if (bclass-&gt;transform_ip || bclass-&gt;transform)
2526       trans-&gt;priv-&gt;passthrough = FALSE;
2527   } else {
2528     trans-&gt;priv-&gt;passthrough = TRUE;
2529   }
2530 
2531   GST_DEBUG_OBJECT (trans, &quot;set passthrough %d&quot;, trans-&gt;priv-&gt;passthrough);
2532   GST_OBJECT_UNLOCK (trans);
2533 }
2534 
2535 /**
2536  * gst_base_transform_is_passthrough:
2537  * @trans: the #GstBaseTransform to query
2538  *
2539  * See if @trans is configured as a passthrough transform.
2540  *
2541  * Returns: %TRUE is the transform is configured in passthrough mode.
2542  *
2543  * MT safe.
2544  */
2545 gboolean
2546 gst_base_transform_is_passthrough (GstBaseTransform * trans)
2547 {
2548   gboolean result;
2549 
2550   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2551 
2552   GST_OBJECT_LOCK (trans);
2553   result = trans-&gt;priv-&gt;passthrough;
2554   GST_OBJECT_UNLOCK (trans);
2555 
2556   return result;
2557 }
2558 
2559 /**
2560  * gst_base_transform_set_in_place:
2561  * @trans: the #GstBaseTransform to modify
2562  * @in_place: Boolean value indicating that we would like to operate
2563  * on in_place buffers.
2564  *
2565  * Determines whether a non-writable buffer will be copied before passing
2566  * to the transform_ip function.
2567  *
2568  *   * Always %TRUE if no transform function is implemented.
2569  *   * Always %FALSE if ONLY transform function is implemented.
2570  *
2571  * MT safe.
2572  */
2573 void
2574 gst_base_transform_set_in_place (GstBaseTransform * trans, gboolean in_place)
2575 {
2576   GstBaseTransformClass *bclass;
2577 
2578   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2579 
2580   bclass = GST_BASE_TRANSFORM_GET_CLASS (trans);
2581 
2582   GST_OBJECT_LOCK (trans);
2583 
2584   if (in_place) {
2585     if (bclass-&gt;transform_ip) {
2586       GST_DEBUG_OBJECT (trans, &quot;setting in_place TRUE&quot;);
2587       trans-&gt;priv-&gt;always_in_place = TRUE;
2588     }
2589   } else {
2590     if (bclass-&gt;transform) {
2591       GST_DEBUG_OBJECT (trans, &quot;setting in_place FALSE&quot;);
2592       trans-&gt;priv-&gt;always_in_place = FALSE;
2593     }
2594   }
2595 
2596   GST_OBJECT_UNLOCK (trans);
2597 }
2598 
2599 /**
2600  * gst_base_transform_is_in_place:
2601  * @trans: the #GstBaseTransform to query
2602  *
2603  * See if @trans is configured as a in_place transform.
2604  *
2605  * Returns: %TRUE is the transform is configured in in_place mode.
2606  *
2607  * MT safe.
2608  */
2609 gboolean
2610 gst_base_transform_is_in_place (GstBaseTransform * trans)
2611 {
2612   gboolean result;
2613 
2614   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2615 
2616   GST_OBJECT_LOCK (trans);
2617   result = trans-&gt;priv-&gt;always_in_place;
2618   GST_OBJECT_UNLOCK (trans);
2619 
2620   return result;
2621 }
2622 
2623 /**
2624  * gst_base_transform_update_qos:
2625  * @trans: a #GstBaseTransform
2626  * @proportion: the proportion
2627  * @diff: the diff against the clock
2628  * @timestamp: the timestamp of the buffer generating the QoS expressed in
2629  * running_time.
2630  *
2631  * Set the QoS parameters in the transform. This function is called internally
2632  * when a QOS event is received but subclasses can provide custom information
2633  * when needed.
2634  *
2635  * MT safe.
2636  */
2637 void
2638 gst_base_transform_update_qos (GstBaseTransform * trans,
2639     gdouble proportion, GstClockTimeDiff diff, GstClockTime timestamp)
2640 {
2641   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2642 
2643   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, trans,
2644       &quot;qos: proportion: %lf, diff %&quot; G_GINT64_FORMAT &quot;, timestamp %&quot;
2645       GST_TIME_FORMAT, proportion, diff, GST_TIME_ARGS (timestamp));
2646 
2647   GST_OBJECT_LOCK (trans);
2648   trans-&gt;priv-&gt;proportion = proportion;
2649   trans-&gt;priv-&gt;earliest_time = timestamp + diff;
2650   GST_OBJECT_UNLOCK (trans);
2651 }
2652 
2653 /**
2654  * gst_base_transform_set_qos_enabled:
2655  * @trans: a #GstBaseTransform
2656  * @enabled: new state
2657  *
2658  * Enable or disable QoS handling in the transform.
2659  *
2660  * MT safe.
2661  */
2662 void
2663 gst_base_transform_set_qos_enabled (GstBaseTransform * trans, gboolean enabled)
2664 {
2665   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2666 
2667   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, trans, &quot;enabled: %d&quot;, enabled);
2668 
2669   GST_OBJECT_LOCK (trans);
2670   trans-&gt;priv-&gt;qos_enabled = enabled;
2671   GST_OBJECT_UNLOCK (trans);
2672 }
2673 
2674 /**
2675  * gst_base_transform_is_qos_enabled:
2676  * @trans: a #GstBaseTransform
2677  *
2678  * Queries if the transform will handle QoS.
2679  *
2680  * Returns: %TRUE if QoS is enabled.
2681  *
2682  * MT safe.
2683  */
2684 gboolean
2685 gst_base_transform_is_qos_enabled (GstBaseTransform * trans)
2686 {
2687   gboolean result;
2688 
2689   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2690 
2691   GST_OBJECT_LOCK (trans);
2692   result = trans-&gt;priv-&gt;qos_enabled;
2693   GST_OBJECT_UNLOCK (trans);
2694 
2695   return result;
2696 }
2697 
2698 /**
2699  * gst_base_transform_set_gap_aware:
2700  * @trans: a #GstBaseTransform
2701  * @gap_aware: New state
2702  *
2703  * If @gap_aware is %FALSE (the default), output buffers will have the
2704  * %GST_BUFFER_FLAG_GAP flag unset.
2705  *
2706  * If set to %TRUE, the element must handle output buffers with this flag set
2707  * correctly, i.e. it can assume that the buffer contains neutral data but must
2708  * unset the flag if the output is no neutral data.
2709  *
2710  * MT safe.
2711  */
2712 void
2713 gst_base_transform_set_gap_aware (GstBaseTransform * trans, gboolean gap_aware)
2714 {
2715   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2716 
2717   GST_OBJECT_LOCK (trans);
2718   trans-&gt;priv-&gt;gap_aware = gap_aware;
2719   GST_DEBUG_OBJECT (trans, &quot;set gap aware %d&quot;, trans-&gt;priv-&gt;gap_aware);
2720   GST_OBJECT_UNLOCK (trans);
2721 }
2722 
2723 /**
2724  * gst_base_transform_set_prefer_passthrough:
2725  * @trans: a #GstBaseTransform
2726  * @prefer_passthrough: New state
2727  *
2728  * If @prefer_passthrough is %TRUE (the default), @trans will check and
2729  * prefer passthrough caps from the list of caps returned by the
2730  * transform_caps vmethod.
2731  *
2732  * If set to %FALSE, the element must order the caps returned from the
2733  * transform_caps function in such a way that the preferred format is
2734  * first in the list. This can be interesting for transforms that can do
2735  * passthrough transforms but prefer to do something else, like a
2736  * capsfilter.
2737  *
2738  * MT safe.
2739  *
2740  * Since: 1.0.1
2741  */
2742 void
2743 gst_base_transform_set_prefer_passthrough (GstBaseTransform * trans,
2744     gboolean prefer_passthrough)
2745 {
2746   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2747 
2748   GST_OBJECT_LOCK (trans);
2749   trans-&gt;priv-&gt;prefer_passthrough = prefer_passthrough;
2750   GST_DEBUG_OBJECT (trans, &quot;prefer passthrough %d&quot;, prefer_passthrough);
2751   GST_OBJECT_UNLOCK (trans);
2752 }
2753 
2754 /**
2755  * gst_base_transform_reconfigure_sink:
2756  * @trans: a #GstBaseTransform
2757  *
2758  * Instructs @trans to request renegotiation upstream. This function is
2759  * typically called after properties on the transform were set that
2760  * influence the input format.
2761  */
2762 void
2763 gst_base_transform_reconfigure_sink (GstBaseTransform * trans)
2764 {
2765   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2766 
2767   /* push the renegotiate event */
2768   if (!gst_pad_push_event (GST_BASE_TRANSFORM_SINK_PAD (trans),
2769           gst_event_new_reconfigure ()))
2770     GST_DEBUG_OBJECT (trans, &quot;Renegotiate event wasn&#39;t handled&quot;);
2771 }
2772 
2773 /**
2774  * gst_base_transform_reconfigure_src:
2775  * @trans: a #GstBaseTransform
2776  *
2777  * Instructs @trans to renegotiate a new downstream transform on the next
2778  * buffer. This function is typically called after properties on the transform
2779  * were set that influence the output format.
2780  */
2781 void
2782 gst_base_transform_reconfigure_src (GstBaseTransform * trans)
2783 {
2784   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2785 
2786   gst_pad_mark_reconfigure (trans-&gt;srcpad);
2787 }
2788 
2789 /**
2790  * gst_base_transform_get_buffer_pool:
2791  * @trans: a #GstBaseTransform
2792  *
2793  * Returns: (transfer full): the instance of the #GstBufferPool used
2794  * by @trans; free it after use it
2795  */
2796 GstBufferPool *
2797 gst_base_transform_get_buffer_pool (GstBaseTransform * trans)
2798 {
2799   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), NULL);
2800 
2801   if (trans-&gt;priv-&gt;pool)
2802     return gst_object_ref (trans-&gt;priv-&gt;pool);
2803 
2804   return NULL;
2805 }
2806 
2807 /**
2808  * gst_base_transform_get_allocator:
2809  * @trans: a #GstBaseTransform
2810  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
2811  * used
2812  * @params: (out) (allow-none) (transfer full): the
2813  * #GstAllocationParams of @allocator
2814  *
2815  * Lets #GstBaseTransform sub-classes to know the memory @allocator
2816  * used by the base class and its @params.
2817  *
2818  * Unref the @allocator after use it.
2819  */
2820 void
2821 gst_base_transform_get_allocator (GstBaseTransform * trans,
2822     GstAllocator ** allocator, GstAllocationParams * params)
2823 {
2824   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2825 
2826   if (allocator)
2827     *allocator = trans-&gt;priv-&gt;allocator ?
2828         gst_object_ref (trans-&gt;priv-&gt;allocator) : NULL;
2829 
2830   if (params)
2831     *params = trans-&gt;priv-&gt;params;
2832 }
2833 
2834 /**
2835  * gst_base_transform_update_src_caps:
2836  * @trans: a #GstBaseTransform
2837  * @updated_caps: An updated version of the srcpad caps to be pushed
2838  * downstream
2839  *
2840  * Updates the srcpad caps and send the caps downstream. This function
2841  * can be used by subclasses when they have already negotiated their caps
2842  * but found a change in them (or computed new informations). This way,
2843  * they can notify downstream about that change without loosing any
2844  * buffer.
2845  *
2846  * Returns: %TRUE if the caps could be send downstream %FALSE otherwise
2847  *
2848  * Since: 1.6
2849  */
2850 gboolean
2851 gst_base_transform_update_src_caps (GstBaseTransform * trans,
2852     GstCaps * updated_caps)
2853 {
2854   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2855 
2856   if (gst_pad_push_event (GST_BASE_TRANSFORM_SRC_PAD (trans),
2857           gst_event_new_caps (updated_caps))) {
2858     gst_pad_mark_reconfigure (trans-&gt;srcpad);
2859 
2860     return TRUE;
2861   }
2862 
2863   return FALSE;
2864 }
    </pre>
  </body>
</html>