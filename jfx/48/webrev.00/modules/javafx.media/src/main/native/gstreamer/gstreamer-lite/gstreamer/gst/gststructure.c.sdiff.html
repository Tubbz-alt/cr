<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gststructure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gststreams.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gststructure.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gststructure.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 379   g_return_if_fail (structure != NULL);
 380   g_return_if_fail (GST_STRUCTURE_REFCOUNT (structure) == NULL);
 381 
 382   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 383   for (i = 0; i &lt; len; i++) {
 384     field = GST_STRUCTURE_FIELD (structure, i);
 385 
 386     if (G_IS_VALUE (&amp;field-&gt;value)) {
 387       g_value_unset (&amp;field-&gt;value);
 388     }
 389   }
 390   g_array_free (GST_STRUCTURE_FIELDS (structure), TRUE);
 391 #ifdef USE_POISONING
 392   memset (structure, 0xff, sizeof (GstStructure));
 393 #endif
 394   GST_TRACE (&quot;free structure %p&quot;, structure);
 395 
 396   g_slice_free1 (sizeof (GstStructureImpl), structure);
 397 }
 398 
























 399 /**
 400  * gst_structure_get_name:
 401  * @structure: a #GstStructure
 402  *
 403  * Get the name of @structure as a string.
 404  *
 405  * Returns: the name of the structure.
 406  */
 407 const gchar *
 408 gst_structure_get_name (const GstStructure * structure)
 409 {
 410   g_return_val_if_fail (structure != NULL, NULL);
 411 
 412   return g_quark_to_string (structure-&gt;name);
 413 }
 414 
 415 /**
 416  * gst_structure_has_name:
 417  * @structure: a #GstStructure
 418  * @name: structure name to check for
</pre>
<hr />
<pre>
 592       g_quark_from_string (fieldname), value);
 593 }
 594 
 595 static void
 596 gst_structure_set_valist_internal (GstStructure * structure,
 597     const gchar * fieldname, va_list varargs)
 598 {
 599   gchar *err = NULL;
 600   GType type;
 601 
 602   while (fieldname) {
 603     GstStructureField field = { 0 };
 604 
 605     field.name = g_quark_from_string (fieldname);
 606 
 607     type = va_arg (varargs, GType);
 608 
 609     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 610     if (G_UNLIKELY (err)) {
 611       g_critical (&quot;%s&quot;, err);

 612       return;
 613     }
 614     gst_structure_set_field (structure, &amp;field);
 615 
 616     fieldname = va_arg (varargs, gchar *);
 617   }
 618 }
 619 
 620 /**
 621  * gst_structure_set:
 622  * @structure: a #GstStructure
 623  * @fieldname: the name of the field to set
 624  * @...: variable arguments
 625  *
 626  * Parses the variable arguments and sets fields accordingly. Fields that
 627  * weren&#39;t already part of the structure are added as needed.
 628  * Variable arguments should be in the form field name, field type
 629  * (as a GType), value(s).  The last variable argument should be %NULL.
 630  */
 631 void
</pre>
<hr />
<pre>
 658 
 659   gst_structure_set_valist_internal (structure, fieldname, varargs);
 660 }
 661 
 662 static void
 663 gst_structure_id_set_valist_internal (GstStructure * structure,
 664     GQuark fieldname, va_list varargs)
 665 {
 666   gchar *err = NULL;
 667   GType type;
 668 
 669   while (fieldname) {
 670     GstStructureField field = { 0 };
 671 
 672     field.name = fieldname;
 673     type = va_arg (varargs, GType);
 674 
 675     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 676     if (G_UNLIKELY (err)) {
 677       g_critical (&quot;%s&quot;, err);

 678       return;
 679     }
 680     gst_structure_set_field (structure, &amp;field);
 681 
 682     fieldname = va_arg (varargs, GQuark);
 683   }
 684 }
 685 
 686 /**
 687  * gst_structure_id_set:
 688  * @structure: a #GstStructure
 689  * @fieldname: the GQuark for the name of the field to set
 690  * @...: variable arguments
 691  *
 692  * Identical to gst_structure_set, except that field names are
 693  * passed using the GQuark for the field name. This allows more efficient
 694  * setting of the structure if the caller already knows the associated
 695  * quark values.
 696  * The last variable argument must be %NULL.
 697  */
</pre>
<hr />
<pre>
1745 gboolean
1746 gst_structure_get_flagset (const GstStructure * structure,
1747     const gchar * fieldname, guint * value_flags, guint * value_mask)
1748 {
1749   GstStructureField *field;
1750 
1751   g_return_val_if_fail (structure != NULL, FALSE);
1752   g_return_val_if_fail (fieldname != NULL, FALSE);
1753 
1754   field = gst_structure_get_field (structure, fieldname);
1755 
1756   if (field == NULL || !GST_VALUE_HOLDS_FLAG_SET (&amp;field-&gt;value))
1757     return FALSE;
1758 
1759   if (value_flags)
1760     *value_flags = gst_value_get_flagset_flags (&amp;field-&gt;value);
1761   if (value_mask)
1762     *value_mask = gst_value_get_flagset_mask (&amp;field-&gt;value);
1763 
1764   return TRUE;
<span class="line-modified">1765     }</span>
1766 
1767 static GType
1768 gst_structure_value_get_generic_type (const GValue * val)
1769 {
1770   if (G_VALUE_TYPE (val) == GST_TYPE_LIST
1771       || G_VALUE_TYPE (val) == GST_TYPE_ARRAY) {
1772     GArray *array = g_value_peek_pointer (val);
1773 
1774     if (array-&gt;len &gt; 0) {
1775       GValue *value = &amp;g_array_index (array, GValue, 0);
1776 
1777       return gst_structure_value_get_generic_type (value);
1778     } else {
1779       return G_TYPE_INT;
1780     }
1781   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT_RANGE) {
1782     return G_TYPE_INT;
1783   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT64_RANGE) {
1784     return G_TYPE_INT64;
1785   } else if (G_VALUE_TYPE (val) == GST_TYPE_DOUBLE_RANGE) {
</pre>
<hr />
<pre>
1794 priv_gst_structure_append_to_gstring (const GstStructure * structure,
1795     GString * s)
1796 {
1797   GstStructureField *field;
1798   guint i, len;
1799 
1800   g_return_val_if_fail (s != NULL, FALSE);
1801 
1802   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1803   for (i = 0; i &lt; len; i++) {
1804     char *t;
1805     GType type;
1806 
1807     field = GST_STRUCTURE_FIELD (structure, i);
1808 
1809     if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_ARRAY) {
1810       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;&lt; &quot;, &quot; &gt;&quot;, FALSE);
1811     } else if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_LIST) {
1812       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;{ &quot;, &quot; }&quot;, FALSE);
1813     } else {
<span class="line-modified">1814     t = gst_value_serialize (&amp;field-&gt;value);</span>
1815     }
1816 
1817     type = gst_structure_value_get_generic_type (&amp;field-&gt;value);
1818 
1819     g_string_append_len (s, &quot;, &quot;, 2);
1820     /* FIXME: do we need to escape fieldnames? */
1821     g_string_append (s, g_quark_to_string (field-&gt;name));
1822     g_string_append_len (s, &quot;=(&quot;, 2);
1823     g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1824     g_string_append_c (s, &#39;)&#39;);
1825     if (t) {
1826       g_string_append (s, t);
<span class="line-modified">1827     g_free (t);</span>







1828     } else {
<span class="line-modified">1829       if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_STRING) &amp;&amp;</span>
<span class="line-removed">1830           !(G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_POINTER) &amp;&amp;</span>
<span class="line-removed">1831               g_value_get_pointer (&amp;field-&gt;value) == NULL))</span>
1832         GST_WARNING (&quot;No value transform to serialize field &#39;%s&#39; of type &#39;%s&#39;&quot;,
1833             g_quark_to_string (field-&gt;name),
1834             _priv_gst_value_gtype_to_abbr (type));
1835       /* TODO(ensonic): don&#39;t print NULL if field-&gt;value is not empty */
1836       g_string_append (s, &quot;NULL&quot;);
<span class="line-modified">1837   }</span>
1838   }
1839 
1840   g_string_append_c (s, &#39;;&#39;);
1841   return TRUE;
1842 }
1843 
1844 gboolean
1845 priv__gst_structure_append_template_to_gstring (GQuark field_id,
1846     const GValue * value, gpointer user_data)
1847 {
1848   GType type = gst_structure_value_get_generic_type (value);
1849   GString *s = (GString *) user_data;
1850 
1851   g_string_append_len (s, &quot;, &quot;, 2);
1852   /* FIXME: do we need to escape fieldnames? */
1853   g_string_append (s, g_quark_to_string (field_id));
1854   g_string_append_len (s, &quot;=(&quot;, 2);
1855   g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1856   g_string_append_c (s, &#39;)&#39;);
1857 
</pre>
<hr />
<pre>
2167 gboolean
2168 gst_structure_fixate_field_nearest_int (GstStructure * structure,
2169     const char *field_name, int target)
2170 {
2171   const GValue *value;
2172 
2173   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2174   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2175 
2176   value = gst_structure_get_value (structure, field_name);
2177 #ifdef GSTREAMER_LITE
2178   if (value == NULL) {
2179     return FALSE;
2180   }
2181 #endif // GSTREAMER_LITE
2182 
2183   if (G_VALUE_TYPE (value) == G_TYPE_INT) {
2184     /* already fixed */
2185     return FALSE;
2186   } else if (G_VALUE_TYPE (value) == GST_TYPE_INT_RANGE) {
<span class="line-modified">2187     int x;</span>












2188 
<span class="line-removed">2189     x = gst_value_get_int_range_min (value);</span>
<span class="line-removed">2190     if (target &lt; x)</span>
<span class="line-removed">2191       target = x;</span>
<span class="line-removed">2192     x = gst_value_get_int_range_max (value);</span>
<span class="line-removed">2193     if (target &gt; x)</span>
<span class="line-removed">2194       target = x;</span>
2195     gst_structure_set (structure, field_name, G_TYPE_INT, target, NULL);
2196     return TRUE;
2197   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2198     const GValue *list_value;
2199     int i, n;
2200     int best = 0;
2201     int best_index = -1;
2202 
2203     n = gst_value_list_get_size (value);
2204     for (i = 0; i &lt; n; i++) {
2205       list_value = gst_value_list_get_value (value, i);
2206       if (G_VALUE_TYPE (list_value) == G_TYPE_INT) {
2207         int x = gst_g_value_get_int_unchecked (list_value);
2208 
2209         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2210           best_index = i;
2211           best = x;
2212         }
2213       }
2214     }
</pre>
<hr />
<pre>
3043     return FALSE;
3044 
3045   g_value_init (&amp;val, G_TYPE_VALUE_ARRAY);
3046 
3047   if (g_value_transform (&amp;field-&gt;value, &amp;val)) {
3048     *array = g_value_get_boxed (&amp;val);
3049     return TRUE;
3050   }
3051 
3052   g_value_unset (&amp;val);
3053   return FALSE;
3054 }
3055 
3056 /**
3057  * gst_structure_get_array:
3058  * @structure: a #GstStructure
3059  * @fieldname: the name of a field
3060  * @array: (out): a pointer to a #GValueArray
3061  *
3062  * This is useful in language bindings where unknown #GValue types are not
<span class="line-modified">3063  * supported. This function will convert the %GST_TYPE_ARRAY and</span>
<span class="line-modified">3064  * %GST_TYPE_LIST into a newly allocated #GValueArray and return it through</span>
<span class="line-modified">3065  * @array. Be aware that this is slower then getting the #GValue directly.</span>
3066  *
3067  * Returns: %TRUE if the value could be set correctly. If there was no field
<span class="line-modified">3068  * with @fieldname or the existing field did not contain an int, this function</span>
<span class="line-modified">3069  * returns %FALSE.</span>
3070  */
3071 gboolean
3072 gst_structure_get_array (GstStructure * structure, const gchar * fieldname,
3073     GValueArray ** array)
3074 {
3075   return _gst_structure_get_any_list (structure, GST_TYPE_ARRAY, fieldname,
3076       array);
3077 }
3078 
3079 /**
3080  * gst_structure_get_list:
3081  * @structure: a #GstStructure
3082  * @fieldname: the name of a field
3083  * @array: (out): a pointer to a #GValueArray
3084  *
3085  * This is useful in language bindings where unknown #GValue types are not
<span class="line-modified">3086  * supported. This function will convert the %GST_TYPE_ARRAY and</span>
<span class="line-modified">3087  * %GST_TYPE_LIST into a newly allocated GValueArray and return it through</span>
<span class="line-modified">3088  * @array. Be aware that this is slower then getting the #GValue directly.</span>
3089  *
3090  * Returns: %TRUE if the value could be set correctly. If there was no field
<span class="line-modified">3091  * with @fieldname or the existing field did not contain an int, this function</span>
<span class="line-modified">3092  * returns %FALSE.</span>
3093  *
<span class="line-modified">3094  * Since 1.12</span>
3095  */
3096 gboolean
3097 gst_structure_get_list (GstStructure * structure, const gchar * fieldname,
3098     GValueArray ** array)
3099 {
3100   return _gst_structure_get_any_list (structure, GST_TYPE_LIST, fieldname,
3101       array);
3102 }
3103 
3104 static void
3105 _gst_structure_set_any_list (GstStructure * structure, GType type,
3106     const gchar * fieldname, const GValueArray * array)
3107 {
3108   GValue arval = G_VALUE_INIT;
3109   GValue value = G_VALUE_INIT;
3110 
3111   g_return_if_fail (structure != NULL);
3112   g_return_if_fail (fieldname != NULL);
3113   g_return_if_fail (array != NULL);
3114   g_return_if_fail (IS_MUTABLE (structure));
</pre>
<hr />
<pre>
3122         g_quark_from_string (fieldname), &amp;value);
3123   } else {
3124     g_warning (&quot;Failed to convert a GValueArray&quot;);
3125   }
3126 
3127   g_value_unset (&amp;arval);
3128   g_value_unset (&amp;value);
3129 }
3130 
3131 /**
3132  * gst_structure_set_array:
3133  * @structure: a #GstStructure
3134  * @fieldname: the name of a field
3135  * @array: a pointer to a #GValueArray
3136  *
3137  * This is useful in language bindings where unknown GValue types are not
3138  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set
3139  * the field specified by @fieldname.  Be aware that this is slower then using
3140  * %GST_TYPE_ARRAY in a #GValue directly.
3141  *
<span class="line-modified">3142  * Since 1.12</span>
3143  */
3144 void
3145 gst_structure_set_array (GstStructure * structure, const gchar * fieldname,
3146     const GValueArray * array)
3147 {
3148   _gst_structure_set_any_list (structure, GST_TYPE_ARRAY, fieldname, array);
3149 }
3150 
3151 /**
3152  * gst_structure_set_list:
3153  * @structure: a #GstStructure
3154  * @fieldname: the name of a field
3155  * @array: a pointer to a #GValueArray
3156  *
3157  * This is useful in language bindings where unknown GValue types are not
<span class="line-modified">3158  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set</span>
3159  * the field specified by @fieldname. Be aware that this is slower then using
<span class="line-modified">3160  * %GST_TYPE_ARRAY in a #GValue directly.</span>
3161  *
<span class="line-modified">3162  * Since 1.12</span>
3163  */
3164 void
3165 gst_structure_set_list (GstStructure * structure, const gchar * fieldname,
3166     const GValueArray * array)
3167 {
3168   _gst_structure_set_any_list (structure, GST_TYPE_LIST, fieldname, array);
3169 }
</pre>
</td>
<td>
<hr />
<pre>
 379   g_return_if_fail (structure != NULL);
 380   g_return_if_fail (GST_STRUCTURE_REFCOUNT (structure) == NULL);
 381 
 382   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 383   for (i = 0; i &lt; len; i++) {
 384     field = GST_STRUCTURE_FIELD (structure, i);
 385 
 386     if (G_IS_VALUE (&amp;field-&gt;value)) {
 387       g_value_unset (&amp;field-&gt;value);
 388     }
 389   }
 390   g_array_free (GST_STRUCTURE_FIELDS (structure), TRUE);
 391 #ifdef USE_POISONING
 392   memset (structure, 0xff, sizeof (GstStructure));
 393 #endif
 394   GST_TRACE (&quot;free structure %p&quot;, structure);
 395 
 396   g_slice_free1 (sizeof (GstStructureImpl), structure);
 397 }
 398 
<span class="line-added"> 399 /**</span>
<span class="line-added"> 400  * gst_clear_structure: (skip)</span>
<span class="line-added"> 401  * @structure_ptr: a pointer to a #GstStructure reference</span>
<span class="line-added"> 402  *</span>
<span class="line-added"> 403  * Clears a reference to a #GstStructure.</span>
<span class="line-added"> 404  *</span>
<span class="line-added"> 405  * @structure_ptr must not be %NULL.</span>
<span class="line-added"> 406  *</span>
<span class="line-added"> 407  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added"> 408  * Otherwise, the structure is free&#39;d using gst_structure_free() and the</span>
<span class="line-added"> 409  * pointer is set to %NULL.</span>
<span class="line-added"> 410  *</span>
<span class="line-added"> 411  * A macro is also included that allows this function to be used without</span>
<span class="line-added"> 412  * pointer casts.</span>
<span class="line-added"> 413  *</span>
<span class="line-added"> 414  * Since: 1.16</span>
<span class="line-added"> 415  **/</span>
<span class="line-added"> 416 #undef gst_clear_structure</span>
<span class="line-added"> 417 void</span>
<span class="line-added"> 418 gst_clear_structure (GstStructure ** structure_ptr)</span>
<span class="line-added"> 419 {</span>
<span class="line-added"> 420   g_clear_pointer (structure_ptr, gst_structure_free);</span>
<span class="line-added"> 421 }</span>
<span class="line-added"> 422 </span>
 423 /**
 424  * gst_structure_get_name:
 425  * @structure: a #GstStructure
 426  *
 427  * Get the name of @structure as a string.
 428  *
 429  * Returns: the name of the structure.
 430  */
 431 const gchar *
 432 gst_structure_get_name (const GstStructure * structure)
 433 {
 434   g_return_val_if_fail (structure != NULL, NULL);
 435 
 436   return g_quark_to_string (structure-&gt;name);
 437 }
 438 
 439 /**
 440  * gst_structure_has_name:
 441  * @structure: a #GstStructure
 442  * @name: structure name to check for
</pre>
<hr />
<pre>
 616       g_quark_from_string (fieldname), value);
 617 }
 618 
 619 static void
 620 gst_structure_set_valist_internal (GstStructure * structure,
 621     const gchar * fieldname, va_list varargs)
 622 {
 623   gchar *err = NULL;
 624   GType type;
 625 
 626   while (fieldname) {
 627     GstStructureField field = { 0 };
 628 
 629     field.name = g_quark_from_string (fieldname);
 630 
 631     type = va_arg (varargs, GType);
 632 
 633     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 634     if (G_UNLIKELY (err)) {
 635       g_critical (&quot;%s&quot;, err);
<span class="line-added"> 636       g_free (err);</span>
 637       return;
 638     }
 639     gst_structure_set_field (structure, &amp;field);
 640 
 641     fieldname = va_arg (varargs, gchar *);
 642   }
 643 }
 644 
 645 /**
 646  * gst_structure_set:
 647  * @structure: a #GstStructure
 648  * @fieldname: the name of the field to set
 649  * @...: variable arguments
 650  *
 651  * Parses the variable arguments and sets fields accordingly. Fields that
 652  * weren&#39;t already part of the structure are added as needed.
 653  * Variable arguments should be in the form field name, field type
 654  * (as a GType), value(s).  The last variable argument should be %NULL.
 655  */
 656 void
</pre>
<hr />
<pre>
 683 
 684   gst_structure_set_valist_internal (structure, fieldname, varargs);
 685 }
 686 
 687 static void
 688 gst_structure_id_set_valist_internal (GstStructure * structure,
 689     GQuark fieldname, va_list varargs)
 690 {
 691   gchar *err = NULL;
 692   GType type;
 693 
 694   while (fieldname) {
 695     GstStructureField field = { 0 };
 696 
 697     field.name = fieldname;
 698     type = va_arg (varargs, GType);
 699 
 700     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 701     if (G_UNLIKELY (err)) {
 702       g_critical (&quot;%s&quot;, err);
<span class="line-added"> 703       g_free (err);</span>
 704       return;
 705     }
 706     gst_structure_set_field (structure, &amp;field);
 707 
 708     fieldname = va_arg (varargs, GQuark);
 709   }
 710 }
 711 
 712 /**
 713  * gst_structure_id_set:
 714  * @structure: a #GstStructure
 715  * @fieldname: the GQuark for the name of the field to set
 716  * @...: variable arguments
 717  *
 718  * Identical to gst_structure_set, except that field names are
 719  * passed using the GQuark for the field name. This allows more efficient
 720  * setting of the structure if the caller already knows the associated
 721  * quark values.
 722  * The last variable argument must be %NULL.
 723  */
</pre>
<hr />
<pre>
1771 gboolean
1772 gst_structure_get_flagset (const GstStructure * structure,
1773     const gchar * fieldname, guint * value_flags, guint * value_mask)
1774 {
1775   GstStructureField *field;
1776 
1777   g_return_val_if_fail (structure != NULL, FALSE);
1778   g_return_val_if_fail (fieldname != NULL, FALSE);
1779 
1780   field = gst_structure_get_field (structure, fieldname);
1781 
1782   if (field == NULL || !GST_VALUE_HOLDS_FLAG_SET (&amp;field-&gt;value))
1783     return FALSE;
1784 
1785   if (value_flags)
1786     *value_flags = gst_value_get_flagset_flags (&amp;field-&gt;value);
1787   if (value_mask)
1788     *value_mask = gst_value_get_flagset_mask (&amp;field-&gt;value);
1789 
1790   return TRUE;
<span class="line-modified">1791 }</span>
1792 
1793 static GType
1794 gst_structure_value_get_generic_type (const GValue * val)
1795 {
1796   if (G_VALUE_TYPE (val) == GST_TYPE_LIST
1797       || G_VALUE_TYPE (val) == GST_TYPE_ARRAY) {
1798     GArray *array = g_value_peek_pointer (val);
1799 
1800     if (array-&gt;len &gt; 0) {
1801       GValue *value = &amp;g_array_index (array, GValue, 0);
1802 
1803       return gst_structure_value_get_generic_type (value);
1804     } else {
1805       return G_TYPE_INT;
1806     }
1807   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT_RANGE) {
1808     return G_TYPE_INT;
1809   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT64_RANGE) {
1810     return G_TYPE_INT64;
1811   } else if (G_VALUE_TYPE (val) == GST_TYPE_DOUBLE_RANGE) {
</pre>
<hr />
<pre>
1820 priv_gst_structure_append_to_gstring (const GstStructure * structure,
1821     GString * s)
1822 {
1823   GstStructureField *field;
1824   guint i, len;
1825 
1826   g_return_val_if_fail (s != NULL, FALSE);
1827 
1828   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1829   for (i = 0; i &lt; len; i++) {
1830     char *t;
1831     GType type;
1832 
1833     field = GST_STRUCTURE_FIELD (structure, i);
1834 
1835     if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_ARRAY) {
1836       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;&lt; &quot;, &quot; &gt;&quot;, FALSE);
1837     } else if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_LIST) {
1838       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;{ &quot;, &quot; }&quot;, FALSE);
1839     } else {
<span class="line-modified">1840       t = gst_value_serialize (&amp;field-&gt;value);</span>
1841     }
1842 
1843     type = gst_structure_value_get_generic_type (&amp;field-&gt;value);
1844 
1845     g_string_append_len (s, &quot;, &quot;, 2);
1846     /* FIXME: do we need to escape fieldnames? */
1847     g_string_append (s, g_quark_to_string (field-&gt;name));
1848     g_string_append_len (s, &quot;=(&quot;, 2);
1849     g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1850     g_string_append_c (s, &#39;)&#39;);
1851     if (t) {
1852       g_string_append (s, t);
<span class="line-modified">1853       g_free (t);</span>
<span class="line-added">1854     } else if (G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_POINTER)) {</span>
<span class="line-added">1855       gpointer ptr = g_value_get_pointer (&amp;field-&gt;value);</span>
<span class="line-added">1856 </span>
<span class="line-added">1857       if (!ptr)</span>
<span class="line-added">1858         g_string_append (s, &quot;NULL&quot;);</span>
<span class="line-added">1859       else</span>
<span class="line-added">1860         g_string_append_printf (s, &quot;%p&quot;, ptr);</span>
1861     } else {
<span class="line-modified">1862       if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_STRING))</span>


1863         GST_WARNING (&quot;No value transform to serialize field &#39;%s&#39; of type &#39;%s&#39;&quot;,
1864             g_quark_to_string (field-&gt;name),
1865             _priv_gst_value_gtype_to_abbr (type));
1866       /* TODO(ensonic): don&#39;t print NULL if field-&gt;value is not empty */
1867       g_string_append (s, &quot;NULL&quot;);
<span class="line-modified">1868     }</span>
1869   }
1870 
1871   g_string_append_c (s, &#39;;&#39;);
1872   return TRUE;
1873 }
1874 
1875 gboolean
1876 priv__gst_structure_append_template_to_gstring (GQuark field_id,
1877     const GValue * value, gpointer user_data)
1878 {
1879   GType type = gst_structure_value_get_generic_type (value);
1880   GString *s = (GString *) user_data;
1881 
1882   g_string_append_len (s, &quot;, &quot;, 2);
1883   /* FIXME: do we need to escape fieldnames? */
1884   g_string_append (s, g_quark_to_string (field_id));
1885   g_string_append_len (s, &quot;=(&quot;, 2);
1886   g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1887   g_string_append_c (s, &#39;)&#39;);
1888 
</pre>
<hr />
<pre>
2198 gboolean
2199 gst_structure_fixate_field_nearest_int (GstStructure * structure,
2200     const char *field_name, int target)
2201 {
2202   const GValue *value;
2203 
2204   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2205   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2206 
2207   value = gst_structure_get_value (structure, field_name);
2208 #ifdef GSTREAMER_LITE
2209   if (value == NULL) {
2210     return FALSE;
2211   }
2212 #endif // GSTREAMER_LITE
2213 
2214   if (G_VALUE_TYPE (value) == G_TYPE_INT) {
2215     /* already fixed */
2216     return FALSE;
2217   } else if (G_VALUE_TYPE (value) == GST_TYPE_INT_RANGE) {
<span class="line-modified">2218     int min, max, step;</span>
<span class="line-added">2219 </span>
<span class="line-added">2220     min = gst_value_get_int_range_min (value);</span>
<span class="line-added">2221     max = gst_value_get_int_range_max (value);</span>
<span class="line-added">2222     step = gst_value_get_int_range_step (value);</span>
<span class="line-added">2223 </span>
<span class="line-added">2224     target = CLAMP (target, min, max);</span>
<span class="line-added">2225     if (G_UNLIKELY (step != 1)) {</span>
<span class="line-added">2226       gint rem = target % step;</span>
<span class="line-added">2227       target -= rem;</span>
<span class="line-added">2228       if (rem &gt; step / 2)</span>
<span class="line-added">2229         target += step;</span>
<span class="line-added">2230     }</span>
2231 






2232     gst_structure_set (structure, field_name, G_TYPE_INT, target, NULL);
2233     return TRUE;
2234   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2235     const GValue *list_value;
2236     int i, n;
2237     int best = 0;
2238     int best_index = -1;
2239 
2240     n = gst_value_list_get_size (value);
2241     for (i = 0; i &lt; n; i++) {
2242       list_value = gst_value_list_get_value (value, i);
2243       if (G_VALUE_TYPE (list_value) == G_TYPE_INT) {
2244         int x = gst_g_value_get_int_unchecked (list_value);
2245 
2246         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2247           best_index = i;
2248           best = x;
2249         }
2250       }
2251     }
</pre>
<hr />
<pre>
3080     return FALSE;
3081 
3082   g_value_init (&amp;val, G_TYPE_VALUE_ARRAY);
3083 
3084   if (g_value_transform (&amp;field-&gt;value, &amp;val)) {
3085     *array = g_value_get_boxed (&amp;val);
3086     return TRUE;
3087   }
3088 
3089   g_value_unset (&amp;val);
3090   return FALSE;
3091 }
3092 
3093 /**
3094  * gst_structure_get_array:
3095  * @structure: a #GstStructure
3096  * @fieldname: the name of a field
3097  * @array: (out): a pointer to a #GValueArray
3098  *
3099  * This is useful in language bindings where unknown #GValue types are not
<span class="line-modified">3100  * supported. This function will convert the %GST_TYPE_ARRAY into a newly</span>
<span class="line-modified">3101  * allocated #GValueArray and return it through @array. Be aware that this is</span>
<span class="line-modified">3102  * slower then getting the #GValue directly.</span>
3103  *
3104  * Returns: %TRUE if the value could be set correctly. If there was no field
<span class="line-modified">3105  * with @fieldname or the existing field did not contain a %GST_TYPE_ARRAY,</span>
<span class="line-modified">3106  * this function returns %FALSE.</span>
3107  */
3108 gboolean
3109 gst_structure_get_array (GstStructure * structure, const gchar * fieldname,
3110     GValueArray ** array)
3111 {
3112   return _gst_structure_get_any_list (structure, GST_TYPE_ARRAY, fieldname,
3113       array);
3114 }
3115 
3116 /**
3117  * gst_structure_get_list:
3118  * @structure: a #GstStructure
3119  * @fieldname: the name of a field
3120  * @array: (out): a pointer to a #GValueArray
3121  *
3122  * This is useful in language bindings where unknown #GValue types are not
<span class="line-modified">3123  * supported. This function will convert the %GST_TYPE_LIST into a newly</span>
<span class="line-modified">3124  * allocated GValueArray and return it through @array. Be aware that this is</span>
<span class="line-modified">3125  * slower then getting the #GValue directly.</span>
3126  *
3127  * Returns: %TRUE if the value could be set correctly. If there was no field
<span class="line-modified">3128  * with @fieldname or the existing field did not contain a %GST_TYPE_LIST, this</span>
<span class="line-modified">3129  * function returns %FALSE.</span>
3130  *
<span class="line-modified">3131  * Since: 1.12</span>
3132  */
3133 gboolean
3134 gst_structure_get_list (GstStructure * structure, const gchar * fieldname,
3135     GValueArray ** array)
3136 {
3137   return _gst_structure_get_any_list (structure, GST_TYPE_LIST, fieldname,
3138       array);
3139 }
3140 
3141 static void
3142 _gst_structure_set_any_list (GstStructure * structure, GType type,
3143     const gchar * fieldname, const GValueArray * array)
3144 {
3145   GValue arval = G_VALUE_INIT;
3146   GValue value = G_VALUE_INIT;
3147 
3148   g_return_if_fail (structure != NULL);
3149   g_return_if_fail (fieldname != NULL);
3150   g_return_if_fail (array != NULL);
3151   g_return_if_fail (IS_MUTABLE (structure));
</pre>
<hr />
<pre>
3159         g_quark_from_string (fieldname), &amp;value);
3160   } else {
3161     g_warning (&quot;Failed to convert a GValueArray&quot;);
3162   }
3163 
3164   g_value_unset (&amp;arval);
3165   g_value_unset (&amp;value);
3166 }
3167 
3168 /**
3169  * gst_structure_set_array:
3170  * @structure: a #GstStructure
3171  * @fieldname: the name of a field
3172  * @array: a pointer to a #GValueArray
3173  *
3174  * This is useful in language bindings where unknown GValue types are not
3175  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set
3176  * the field specified by @fieldname.  Be aware that this is slower then using
3177  * %GST_TYPE_ARRAY in a #GValue directly.
3178  *
<span class="line-modified">3179  * Since: 1.12</span>
3180  */
3181 void
3182 gst_structure_set_array (GstStructure * structure, const gchar * fieldname,
3183     const GValueArray * array)
3184 {
3185   _gst_structure_set_any_list (structure, GST_TYPE_ARRAY, fieldname, array);
3186 }
3187 
3188 /**
3189  * gst_structure_set_list:
3190  * @structure: a #GstStructure
3191  * @fieldname: the name of a field
3192  * @array: a pointer to a #GValueArray
3193  *
3194  * This is useful in language bindings where unknown GValue types are not
<span class="line-modified">3195  * supported. This function will convert a @array to %GST_TYPE_LIST and set</span>
3196  * the field specified by @fieldname. Be aware that this is slower then using
<span class="line-modified">3197  * %GST_TYPE_LIST in a #GValue directly.</span>
3198  *
<span class="line-modified">3199  * Since: 1.12</span>
3200  */
3201 void
3202 gst_structure_set_list (GstStructure * structure, const gchar * fieldname,
3203     const GValueArray * array)
3204 {
3205   _gst_structure_set_any_list (structure, GST_TYPE_LIST, fieldname, array);
3206 }
</pre>
</td>
</tr>
</table>
<center><a href="gststreams.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gststructure.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>