<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gfileutils.c - File utility functions
   2  *
   3  *  Copyright 2000 Red Hat, Inc.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
  22 #include &lt;sys/stat.h&gt;
  23 #include &lt;stdio.h&gt;
  24 #include &lt;stdlib.h&gt;
  25 #include &lt;stdarg.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;sys/types.h&gt;
  29 #include &lt;sys/stat.h&gt;
  30 #include &lt;fcntl.h&gt;
  31 #include &lt;stdlib.h&gt;
  32 
  33 #ifdef G_OS_UNIX
  34 #include &lt;unistd.h&gt;
  35 #endif
  36 #ifdef G_OS_WIN32
  37 #include &lt;windows.h&gt;
  38 #include &lt;io.h&gt;
  39 #endif /* G_OS_WIN32 */
  40 
  41 #ifndef S_ISLNK
  42 #define S_ISLNK(x) 0
  43 #endif
  44 
  45 #ifndef O_BINARY
  46 #define O_BINARY 0
  47 #endif
  48 
  49 #include &quot;gfileutils.h&quot;
  50 
  51 #include &quot;gstdio.h&quot;
  52 #include &quot;gstdioprivate.h&quot;
  53 #include &quot;glibintl.h&quot;
  54 
  55 #ifdef HAVE_LINUX_MAGIC_H /* for btrfs check */
  56 #include &lt;linux/magic.h&gt;
  57 #include &lt;sys/vfs.h&gt;
  58 #endif
  59 
  60 
  61 /**
  62  * SECTION:fileutils
  63  * @title: File Utilities
  64  * @short_description: various file-related functions
  65  *
  66  * Do not use these APIs unless you are porting a POSIX application to Windows.
  67  * A more high-level file access API is provided as GIO see the documentation
  68  * for #GFile.
  69  *
  70  * There is a group of functions which wrap the common POSIX functions
  71  * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
  72  * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
  73  * wrappers is to make it possible to handle file names with any Unicode
  74  * characters in them on Windows without having to use ifdefs and the
  75  * wide character API in the application code.
  76  *
  77  * On some Unix systems, these APIs may be defined as identical to their POSIX
  78  * counterparts. For this reason, you must check for and include the necessary
  79  * header files (such as `fcntl.h`) before using functions like g_creat(). You
  80  * must also define the relevant feature test macros.
  81  *
  82  * The pathname argument should be in the GLib file name encoding.
  83  * On POSIX this is the actual on-disk encoding which might correspond
  84  * to the locale settings of the process (or the `G_FILENAME_ENCODING`
  85  * environment variable), or not.
  86  *
  87  * On Windows the GLib file name encoding is UTF-8. Note that the
  88  * Microsoft C library does not use UTF-8, but has separate APIs for
  89  * current system code page and wide characters (UTF-16). The GLib
  90  * wrappers call the wide character API if present (on modern Windows
  91  * systems), otherwise convert to/from the system code page.
  92  *
  93  * Another group of functions allows to open and read directories
  94  * in the GLib file name encoding. These are g_dir_open(),
  95  * g_dir_read_name(), g_dir_rewind(), g_dir_close().
  96  */
  97 
  98 /**
  99  * GFileError:
 100  * @G_FILE_ERROR_EXIST: Operation not permitted; only the owner of
 101  *     the file (or other resource) or processes with special privileges
 102  *     can perform the operation.
 103  * @G_FILE_ERROR_ISDIR: File is a directory; you cannot open a directory
 104  *     for writing, or create or remove hard links to it.
 105  * @G_FILE_ERROR_ACCES: Permission denied; the file permissions do not
 106  *     allow the attempted operation.
 107  * @G_FILE_ERROR_NAMETOOLONG: Filename too long.
 108  * @G_FILE_ERROR_NOENT: No such file or directory. This is a &quot;file
 109  *     doesn&#39;t exist&quot; error for ordinary files that are referenced in
 110  *     contexts where they are expected to already exist.
 111  * @G_FILE_ERROR_NOTDIR: A file that isn&#39;t a directory was specified when
 112  *     a directory is required.
 113  * @G_FILE_ERROR_NXIO: No such device or address. The system tried to
 114  *     use the device represented by a file you specified, and it
 115  *     couldn&#39;t find the device. This can mean that the device file was
 116  *     installed incorrectly, or that the physical device is missing or
 117  *     not correctly attached to the computer.
 118  * @G_FILE_ERROR_NODEV: The underlying file system of the specified file
 119  *     does not support memory mapping.
 120  * @G_FILE_ERROR_ROFS: The directory containing the new link can&#39;t be
 121  *     modified because it&#39;s on a read-only file system.
 122  * @G_FILE_ERROR_TXTBSY: Text file busy.
 123  * @G_FILE_ERROR_FAULT: You passed in a pointer to bad memory.
 124  *     (GLib won&#39;t reliably return this, don&#39;t pass in pointers to bad
 125  *     memory.)
 126  * @G_FILE_ERROR_LOOP: Too many levels of symbolic links were encountered
 127  *     in looking up a file name. This often indicates a cycle of symbolic
 128  *     links.
 129  * @G_FILE_ERROR_NOSPC: No space left on device; write operation on a
 130  *     file failed because the disk is full.
 131  * @G_FILE_ERROR_NOMEM: No memory available. The system cannot allocate
 132  *     more virtual memory because its capacity is full.
 133  * @G_FILE_ERROR_MFILE: The current process has too many files open and
 134  *     can&#39;t open any more. Duplicate descriptors do count toward this
 135  *     limit.
 136  * @G_FILE_ERROR_NFILE: There are too many distinct file openings in the
 137  *     entire system.
 138  * @G_FILE_ERROR_BADF: Bad file descriptor; for example, I/O on a
 139  *     descriptor that has been closed or reading from a descriptor open
 140  *     only for writing (or vice versa).
 141  * @G_FILE_ERROR_INVAL: Invalid argument. This is used to indicate
 142  *     various kinds of problems with passing the wrong argument to a
 143  *     library function.
 144  * @G_FILE_ERROR_PIPE: Broken pipe; there is no process reading from the
 145  *     other end of a pipe. Every library function that returns this
 146  *     error code also generates a &#39;SIGPIPE&#39; signal; this signal
 147  *     terminates the program if not handled or blocked. Thus, your
 148  *     program will never actually see this code unless it has handled
 149  *     or blocked &#39;SIGPIPE&#39;.
 150  * @G_FILE_ERROR_AGAIN: Resource temporarily unavailable; the call might
 151  *     work if you try again later.
 152  * @G_FILE_ERROR_INTR: Interrupted function call; an asynchronous signal
 153  *     occurred and prevented completion of the call. When this
 154  *     happens, you should try the call again.
 155  * @G_FILE_ERROR_IO: Input/output error; usually used for physical read
 156  *    or write errors. i.e. the disk or other physical device hardware
 157  *    is returning errors.
 158  * @G_FILE_ERROR_PERM: Operation not permitted; only the owner of the
 159  *    file (or other resource) or processes with special privileges can
 160  *    perform the operation.
 161  * @G_FILE_ERROR_NOSYS: Function not implemented; this indicates that
 162  *    the system is missing some functionality.
 163  * @G_FILE_ERROR_FAILED: Does not correspond to a UNIX error code; this
 164  *    is the standard &quot;failed for unspecified reason&quot; error code present
 165  *    in all #GError error code enumerations. Returned if no specific
 166  *    code applies.
 167  *
 168  * Values corresponding to @errno codes returned from file operations
 169  * on UNIX. Unlike @errno codes, GFileError values are available on
 170  * all systems, even Windows. The exact meaning of each code depends
 171  * on what sort of file operation you were performing; the UNIX
 172  * documentation gives more details. The following error code descriptions
 173  * come from the GNU C Library manual, and are under the copyright
 174  * of that manual.
 175  *
 176  * It&#39;s not very portable to make detailed assumptions about exactly
 177  * which errors will be returned from a given operation. Some errors
 178  * don&#39;t occur on some systems, etc., sometimes there are subtle
 179  * differences in when a system will report a given error, etc.
 180  */
 181 
 182 /**
 183  * G_FILE_ERROR:
 184  *
 185  * Error domain for file operations. Errors in this domain will
 186  * be from the #GFileError enumeration. See #GError for information
 187  * on error domains.
 188  */
 189 
 190 /**
 191  * GFileTest:
 192  * @G_FILE_TEST_IS_REGULAR: %TRUE if the file is a regular file
 193  *     (not a directory). Note that this test will also return %TRUE
 194  *     if the tested file is a symlink to a regular file.
 195  * @G_FILE_TEST_IS_SYMLINK: %TRUE if the file is a symlink.
 196  * @G_FILE_TEST_IS_DIR: %TRUE if the file is a directory.
 197  * @G_FILE_TEST_IS_EXECUTABLE: %TRUE if the file is executable.
 198  * @G_FILE_TEST_EXISTS: %TRUE if the file exists. It may or may not
 199  *     be a regular file.
 200  *
 201  * A test to perform on a file using g_file_test().
 202  */
 203 
 204 /**
 205  * g_mkdir_with_parents:
 206  * @pathname: (type filename): a pathname in the GLib file name encoding
 207  * @mode: permissions to use for newly created directories
 208  *
 209  * Create a directory if it doesn&#39;t already exist. Create intermediate
 210  * parent directories as needed, too.
 211  *
 212  * Returns: 0 if the directory already exists, or was successfully
 213  * created. Returns -1 if an error occurred, with errno set.
 214  *
 215  * Since: 2.8
 216  */
 217 int
 218 g_mkdir_with_parents (const gchar *pathname,
 219               int          mode)
 220 {
 221   gchar *fn, *p;
 222 
 223   if (pathname == NULL || *pathname == &#39;\0&#39;)
 224     {
 225       errno = EINVAL;
 226       return -1;
 227     }
 228 
 229   fn = g_strdup (pathname);
 230 
 231   if (g_path_is_absolute (fn))
 232     p = (gchar *) g_path_skip_root (fn);
 233   else
 234     p = fn;
 235 
 236   do
 237     {
 238       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
 239     p++;
 240 
 241       if (!*p)
 242     p = NULL;
 243       else
 244     *p = &#39;\0&#39;;
 245 
 246       if (!g_file_test (fn, G_FILE_TEST_EXISTS))
 247     {
 248       if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)
 249         {
 250           int errno_save = errno;
 251           g_free (fn);
 252           errno = errno_save;
 253           return -1;
 254         }
 255     }
 256       else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
 257     {
 258       g_free (fn);
 259       errno = ENOTDIR;
 260       return -1;
 261     }
 262       if (p)
 263     {
 264       *p++ = G_DIR_SEPARATOR;
 265       while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))
 266         p++;
 267     }
 268     }
 269   while (p);
 270 
 271   g_free (fn);
 272 
 273   return 0;
 274 }
 275 
 276 /**
 277  * g_file_test:
 278  * @filename: (type filename): a filename to test in the
 279  *     GLib file name encoding
 280  * @test: bitfield of #GFileTest flags
 281  *
 282  * Returns %TRUE if any of the tests in the bitfield @test are
 283  * %TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
 284  * will return %TRUE if the file exists; the check whether it&#39;s a
 285  * directory doesn&#39;t matter since the existence test is %TRUE. With
 286  * the current set of available tests, there&#39;s no point passing in
 287  * more than one test at a time.
 288  *
 289  * Apart from %G_FILE_TEST_IS_SYMLINK all tests follow symbolic links,
 290  * so for a symbolic link to a regular file g_file_test() will return
 291  * %TRUE for both %G_FILE_TEST_IS_SYMLINK and %G_FILE_TEST_IS_REGULAR.
 292  *
 293  * Note, that for a dangling symbolic link g_file_test() will return
 294  * %TRUE for %G_FILE_TEST_IS_SYMLINK and %FALSE for all other flags.
 295  *
 296  * You should never use g_file_test() to test whether it is safe
 297  * to perform an operation, because there is always the possibility
 298  * of the condition changing before you actually perform the operation.
 299  * For example, you might think you could use %G_FILE_TEST_IS_SYMLINK
 300  * to know whether it is safe to write to a file without being
 301  * tricked into writing into a different location. It doesn&#39;t work!
 302  * |[&lt;!-- language=&quot;C&quot; --&gt;
 303  *  // DON&#39;T DO THIS
 304  *  if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
 305  *    {
 306  *      fd = g_open (filename, O_WRONLY);
 307  *      // write to fd
 308  *    }
 309  * ]|
 310  *
 311  * Another thing to note is that %G_FILE_TEST_EXISTS and
 312  * %G_FILE_TEST_IS_EXECUTABLE are implemented using the access()
 313  * system call. This usually doesn&#39;t matter, but if your program
 314  * is setuid or setgid it means that these tests will give you
 315  * the answer for the real user ID and group ID, rather than the
 316  * effective user ID and group ID.
 317  *
 318  * On Windows, there are no symlinks, so testing for
 319  * %G_FILE_TEST_IS_SYMLINK will always return %FALSE. Testing for
 320  * %G_FILE_TEST_IS_EXECUTABLE will just check that the file exists and
 321  * its name indicates that it is executable, checking for well-known
 322  * extensions and those listed in the `PATHEXT` environment variable.
 323  *
 324  * Returns: whether a test was %TRUE
 325  **/
 326 gboolean
 327 g_file_test (const gchar *filename,
 328              GFileTest    test)
 329 {
 330 #ifdef G_OS_WIN32
 331   int attributes;
 332   wchar_t *wfilename;
 333 #endif
 334 
 335   g_return_val_if_fail (filename != NULL, FALSE);
 336 
 337 #ifdef G_OS_WIN32
 338 /* stuff missing in std vc6 api */
 339 #  ifndef INVALID_FILE_ATTRIBUTES
 340 #    define INVALID_FILE_ATTRIBUTES -1
 341 #  endif
 342 #  ifndef FILE_ATTRIBUTE_DEVICE
 343 #    define FILE_ATTRIBUTE_DEVICE 64
 344 #  endif
 345   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 346 
 347   if (wfilename == NULL)
 348     return FALSE;
 349 
 350   attributes = GetFileAttributesW (wfilename);
 351 
 352   g_free (wfilename);
 353 
 354   if (attributes == INVALID_FILE_ATTRIBUTES)
 355     return FALSE;
 356 
 357   if (test &amp; G_FILE_TEST_EXISTS)
 358     return TRUE;
 359 
 360   if (test &amp; G_FILE_TEST_IS_REGULAR)
 361     {
 362       if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
 363     return TRUE;
 364     }
 365 
 366   if (test &amp; G_FILE_TEST_IS_DIR)
 367     {
 368       if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
 369     return TRUE;
 370     }
 371 
 372   /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
 373   while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
 374     {
 375       const gchar *lastdot = strrchr (filename, &#39;.&#39;);
 376       const gchar *pathext = NULL, *p;
 377       int extlen;
 378 
 379       if (lastdot == NULL)
 380         break;
 381 
 382       if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
 383       _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||
 384       _stricmp (lastdot, &quot;.bat&quot;) == 0 ||
 385       _stricmp (lastdot, &quot;.com&quot;) == 0)
 386     return TRUE;
 387 
 388       /* Check if it is one of the types listed in %PATHEXT% */
 389 
 390       pathext = g_getenv (&quot;PATHEXT&quot;);
 391       if (pathext == NULL)
 392         break;
 393 
 394       pathext = g_utf8_casefold (pathext, -1);
 395 
 396       lastdot = g_utf8_casefold (lastdot, -1);
 397       extlen = strlen (lastdot);
 398 
 399       p = pathext;
 400       while (TRUE)
 401     {
 402       const gchar *q = strchr (p, &#39;;&#39;);
 403       if (q == NULL)
 404         q = p + strlen (p);
 405       if (extlen == q - p &amp;&amp;
 406           memcmp (lastdot, p, extlen) == 0)
 407         {
 408           g_free ((gchar *) pathext);
 409           g_free ((gchar *) lastdot);
 410           return TRUE;
 411         }
 412       if (*q)
 413         p = q + 1;
 414       else
 415         break;
 416     }
 417 
 418       g_free ((gchar *) pathext);
 419       g_free ((gchar *) lastdot);
 420       break;
 421     }
 422 
 423   return FALSE;
 424 #else
 425   if ((test &amp; G_FILE_TEST_EXISTS) &amp;&amp; (access (filename, F_OK) == 0))
 426     return TRUE;
 427 
 428   if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
 429     {
 430       if (getuid () != 0)
 431     return TRUE;
 432 
 433       /* For root, on some POSIX systems, access (filename, X_OK)
 434        * will succeed even if no executable bits are set on the
 435        * file. We fall through to a stat test to avoid that.
 436        */
 437     }
 438   else
 439     test &amp;= ~G_FILE_TEST_IS_EXECUTABLE;
 440 
 441   if (test &amp; G_FILE_TEST_IS_SYMLINK)
 442     {
 443       struct stat s;
 444 
 445       if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
 446         return TRUE;
 447     }
 448 
 449   if (test &amp; (G_FILE_TEST_IS_REGULAR |
 450           G_FILE_TEST_IS_DIR |
 451           G_FILE_TEST_IS_EXECUTABLE))
 452     {
 453       struct stat s;
 454 
 455       if (stat (filename, &amp;s) == 0)
 456     {
 457       if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))
 458         return TRUE;
 459 
 460       if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))
 461         return TRUE;
 462 
 463       /* The extra test for root when access (file, X_OK) succeeds.
 464        */
 465       if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
 466           ((s.st_mode &amp; S_IXOTH) ||
 467            (s.st_mode &amp; S_IXUSR) ||
 468            (s.st_mode &amp; S_IXGRP)))
 469         return TRUE;
 470     }
 471     }
 472 
 473   return FALSE;
 474 #endif
 475 }
 476 
 477 G_DEFINE_QUARK (g-file-error-quark, g_file_error)
 478 
 479 /**
 480  * g_file_error_from_errno:
 481  * @err_no: an &quot;errno&quot; value
 482  *
 483  * Gets a #GFileError constant based on the passed-in @err_no.
 484  * For example, if you pass in `EEXIST` this function returns
 485  * #G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
 486  * assume that all #GFileError values will exist.
 487  *
 488  * Normally a #GFileError value goes into a #GError returned
 489  * from a function that manipulates files. So you would use
 490  * g_file_error_from_errno() when constructing a #GError.
 491  *
 492  * Returns: #GFileError corresponding to the given @errno
 493  **/
 494 GFileError
 495 g_file_error_from_errno (gint err_no)
 496 {
 497   switch (err_no)
 498     {
 499 #ifdef EEXIST
 500     case EEXIST:
 501       return G_FILE_ERROR_EXIST;
 502 #endif
 503 
 504 #ifdef EISDIR
 505     case EISDIR:
 506       return G_FILE_ERROR_ISDIR;
 507 #endif
 508 
 509 #ifdef EACCES
 510     case EACCES:
 511       return G_FILE_ERROR_ACCES;
 512 #endif
 513 
 514 #ifdef ENAMETOOLONG
 515     case ENAMETOOLONG:
 516       return G_FILE_ERROR_NAMETOOLONG;
 517 #endif
 518 
 519 #ifdef ENOENT
 520     case ENOENT:
 521       return G_FILE_ERROR_NOENT;
 522 #endif
 523 
 524 #ifdef ENOTDIR
 525     case ENOTDIR:
 526       return G_FILE_ERROR_NOTDIR;
 527 #endif
 528 
 529 #ifdef ENXIO
 530     case ENXIO:
 531       return G_FILE_ERROR_NXIO;
 532 #endif
 533 
 534 #ifdef ENODEV
 535     case ENODEV:
 536       return G_FILE_ERROR_NODEV;
 537 #endif
 538 
 539 #ifdef EROFS
 540     case EROFS:
 541       return G_FILE_ERROR_ROFS;
 542 #endif
 543 
 544 #ifdef ETXTBSY
 545     case ETXTBSY:
 546       return G_FILE_ERROR_TXTBSY;
 547 #endif
 548 
 549 #ifdef EFAULT
 550     case EFAULT:
 551       return G_FILE_ERROR_FAULT;
 552 #endif
 553 
 554 #ifdef ELOOP
 555     case ELOOP:
 556       return G_FILE_ERROR_LOOP;
 557 #endif
 558 
 559 #ifdef ENOSPC
 560     case ENOSPC:
 561       return G_FILE_ERROR_NOSPC;
 562 #endif
 563 
 564 #ifdef ENOMEM
 565     case ENOMEM:
 566       return G_FILE_ERROR_NOMEM;
 567 #endif
 568 
 569 #ifdef EMFILE
 570     case EMFILE:
 571       return G_FILE_ERROR_MFILE;
 572 #endif
 573 
 574 #ifdef ENFILE
 575     case ENFILE:
 576       return G_FILE_ERROR_NFILE;
 577 #endif
 578 
 579 #ifdef EBADF
 580     case EBADF:
 581       return G_FILE_ERROR_BADF;
 582 #endif
 583 
 584 #ifdef EINVAL
 585     case EINVAL:
 586       return G_FILE_ERROR_INVAL;
 587 #endif
 588 
 589 #ifdef EPIPE
 590     case EPIPE:
 591       return G_FILE_ERROR_PIPE;
 592 #endif
 593 
 594 #ifdef EAGAIN
 595     case EAGAIN:
 596       return G_FILE_ERROR_AGAIN;
 597 #endif
 598 
 599 #ifdef EINTR
 600     case EINTR:
 601       return G_FILE_ERROR_INTR;
 602 #endif
 603 
 604 #ifdef EIO
 605     case EIO:
 606       return G_FILE_ERROR_IO;
 607 #endif
 608 
 609 #ifdef EPERM
 610     case EPERM:
 611       return G_FILE_ERROR_PERM;
 612 #endif
 613 
 614 #ifdef ENOSYS
 615     case ENOSYS:
 616       return G_FILE_ERROR_NOSYS;
 617 #endif
 618 
 619     default:
 620       return G_FILE_ERROR_FAILED;
 621     }
 622 }
 623 
 624 static char *
 625 format_error_message (const gchar  *filename,
 626                       const gchar  *format_string,
 627                       int           saved_errno) G_GNUC_FORMAT(2);
 628 
 629 #ifdef GSTREAMER_LITE
 630 #ifndef G_OS_WIN32
 631 #pragma GCC diagnostic push
 632 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 633 #endif // G_OS_WIN32
 634 #else // GSTREAMER_LITE
 635 #pragma GCC diagnostic push
 636 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 637 #endif // GSTREAMER_LITE
 638 
 639 static char *
 640 format_error_message (const gchar  *filename,
 641                       const gchar  *format_string,
 642                       int           saved_errno)
 643 {
 644   gchar *display_name;
 645   gchar *msg;
 646 
 647   display_name = g_filename_display_name (filename);
 648   msg = g_strdup_printf (format_string, display_name, g_strerror (saved_errno));
 649   g_free (display_name);
 650 
 651   return msg;
 652 }
 653 
 654 #ifdef GSTREAMER_LITE
 655 #ifndef G_OS_WIN32
 656 #pragma GCC diagnostic pop
 657 #endif // G_OS_WIN32
 658 #else // GSTREAMER_LITE
 659 #pragma GCC diagnostic pop
 660 #endif // GSTREAMER_LITE
 661 
 662 /* format string must have two &#39;%s&#39;:
 663  *
 664  *   - the place for the filename
 665  *   - the place for the strerror
 666  */
 667 static void
 668 set_file_error (GError      **error,
 669                 const gchar  *filename,
 670                 const gchar  *format_string,
 671                 int           saved_errno)
 672 {
 673   char *msg = format_error_message (filename, format_string, saved_errno);
 674 
 675   g_set_error_literal (error, G_FILE_ERROR, g_file_error_from_errno (saved_errno),
 676                        msg);
 677   g_free (msg);
 678 }
 679 
 680 static gboolean
 681 get_contents_stdio (const gchar  *filename,
 682                     FILE         *f,
 683                     gchar       **contents,
 684                     gsize        *length,
 685                     GError      **error)
 686 {
 687   gchar buf[4096];
 688   gsize bytes;  /* always &lt;= sizeof(buf) */
 689   gchar *str = NULL;
 690   gsize total_bytes = 0;
 691   gsize total_allocated = 0;
 692   gchar *tmp;
 693   gchar *display_filename;
 694 
 695   g_assert (f != NULL);
 696 
 697   while (!feof (f))
 698     {
 699       gint save_errno;
 700 
 701       bytes = fread (buf, 1, sizeof (buf), f);
 702       save_errno = errno;
 703 
 704       if (total_bytes &gt; G_MAXSIZE - bytes)
 705           goto file_too_large;
 706 
 707       /* Possibility of overflow eliminated above. */
 708       while (total_bytes + bytes &gt;= total_allocated)
 709         {
 710           if (str)
 711             {
 712               if (total_allocated &gt; G_MAXSIZE / 2)
 713                   goto file_too_large;
 714               total_allocated *= 2;
 715             }
 716           else
 717             {
 718               total_allocated = MIN (bytes + 1, sizeof (buf));
 719             }
 720 
 721           tmp = g_try_realloc (str, total_allocated);
 722 
 723           if (tmp == NULL)
 724             {
 725               display_filename = g_filename_display_name (filename);
 726               g_set_error (error,
 727                            G_FILE_ERROR,
 728                            G_FILE_ERROR_NOMEM,
 729                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
 730                            (gulong) total_allocated,
 731                display_filename);
 732               g_free (display_filename);
 733 
 734               goto error;
 735             }
 736 
 737       str = tmp;
 738         }
 739 
 740       if (ferror (f))
 741         {
 742           display_filename = g_filename_display_name (filename);
 743           g_set_error (error,
 744                        G_FILE_ERROR,
 745                        g_file_error_from_errno (save_errno),
 746                        _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
 747                        display_filename,
 748                g_strerror (save_errno));
 749           g_free (display_filename);
 750 
 751           goto error;
 752         }
 753 
 754       g_assert (str != NULL);
 755       memcpy (str + total_bytes, buf, bytes);
 756 
 757       total_bytes += bytes;
 758     }
 759 
 760   fclose (f);
 761 
 762   if (total_allocated == 0)
 763     {
 764       str = g_new (gchar, 1);
 765       total_bytes = 0;
 766     }
 767 
 768   str[total_bytes] = &#39;\0&#39;;
 769 
 770   if (length)
 771     *length = total_bytes;
 772 
 773   *contents = str;
 774 
 775   return TRUE;
 776 
 777  file_too_large:
 778   display_filename = g_filename_display_name (filename);
 779   g_set_error (error,
 780                G_FILE_ERROR,
 781                G_FILE_ERROR_FAILED,
 782                _(&quot;File &#39;%s&#39; is too large&quot;),
 783                display_filename);
 784   g_free (display_filename);
 785 
 786  error:
 787 
 788   g_free (str);
 789   fclose (f);
 790 
 791   return FALSE;
 792 }
 793 
 794 #ifndef G_OS_WIN32
 795 
 796 static gboolean
 797 get_contents_regfile (const gchar  *filename,
 798                       struct stat  *stat_buf,
 799                       gint          fd,
 800                       gchar       **contents,
 801                       gsize        *length,
 802                       GError      **error)
 803 {
 804   gchar *buf;
 805   gsize bytes_read;
 806   gsize size;
 807   gsize alloc_size;
 808   gchar *display_filename;
 809 
 810   size = stat_buf-&gt;st_size;
 811 
 812   alloc_size = size + 1;
 813   buf = g_try_malloc (alloc_size);
 814 
 815   if (buf == NULL)
 816     {
 817       display_filename = g_filename_display_name (filename);
 818       g_set_error (error,
 819                    G_FILE_ERROR,
 820                    G_FILE_ERROR_NOMEM,
 821                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
 822                    (gulong) alloc_size,
 823            display_filename);
 824       g_free (display_filename);
 825       goto error;
 826     }
 827 
 828   bytes_read = 0;
 829   while (bytes_read &lt; size)
 830     {
 831       gssize rc;
 832 
 833       rc = read (fd, buf + bytes_read, size - bytes_read);
 834 
 835       if (rc &lt; 0)
 836         {
 837           if (errno != EINTR)
 838             {
 839           int save_errno = errno;
 840 
 841               g_free (buf);
 842               display_filename = g_filename_display_name (filename);
 843               g_set_error (error,
 844                            G_FILE_ERROR,
 845                            g_file_error_from_errno (save_errno),
 846                            _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
 847                            display_filename,
 848                g_strerror (save_errno));
 849               g_free (display_filename);
 850           goto error;
 851             }
 852         }
 853       else if (rc == 0)
 854         break;
 855       else
 856         bytes_read += rc;
 857     }
 858 
 859   buf[bytes_read] = &#39;\0&#39;;
 860 
 861   if (length)
 862     *length = bytes_read;
 863 
 864   *contents = buf;
 865 
 866   close (fd);
 867 
 868   return TRUE;
 869 
 870  error:
 871 
 872   close (fd);
 873 
 874   return FALSE;
 875 }
 876 
 877 static gboolean
 878 get_contents_posix (const gchar  *filename,
 879                     gchar       **contents,
 880                     gsize        *length,
 881                     GError      **error)
 882 {
 883   struct stat stat_buf;
 884   gint fd;
 885 
 886   /* O_BINARY useful on Cygwin */
 887   fd = open (filename, O_RDONLY|O_BINARY);
 888 
 889   if (fd &lt; 0)
 890     {
 891       int saved_errno = errno;
 892       set_file_error (error,
 893                       filename,
 894                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 895                       saved_errno);
 896 
 897       return FALSE;
 898     }
 899 
 900   /* I don&#39;t think this will ever fail, aside from ENOMEM, but. */
 901   if (fstat (fd, &amp;stat_buf) &lt; 0)
 902     {
 903       int saved_errno = errno;
 904       set_file_error (error,
 905                       filename,
 906                       _(&quot;Failed to get attributes of file &#39;%s&#39;: fstat() failed: %s&quot;),
 907                       saved_errno);
 908       close (fd);
 909 
 910       return FALSE;
 911     }
 912 
 913   if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
 914     {
 915       gboolean retval = get_contents_regfile (filename,
 916                           &amp;stat_buf,
 917                           fd,
 918                           contents,
 919                           length,
 920                           error);
 921 
 922       return retval;
 923     }
 924   else
 925     {
 926       FILE *f;
 927       gboolean retval;
 928 
 929       f = fdopen (fd, &quot;r&quot;);
 930 
 931       if (f == NULL)
 932         {
 933           int saved_errno = errno;
 934           set_file_error (error,
 935                           filename,
 936                           _(&quot;Failed to open file &#39;%s&#39;: fdopen() failed: %s&quot;),
 937                           saved_errno);
 938 
 939           return FALSE;
 940         }
 941 
 942       retval = get_contents_stdio (filename, f, contents, length, error);
 943 
 944       return retval;
 945     }
 946 }
 947 
 948 #else  /* G_OS_WIN32 */
 949 
 950 static gboolean
 951 get_contents_win32 (const gchar  *filename,
 952             gchar       **contents,
 953             gsize        *length,
 954             GError      **error)
 955 {
 956   FILE *f;
 957   gboolean retval;
 958 
 959   f = g_fopen (filename, &quot;rb&quot;);
 960 
 961   if (f == NULL)
 962     {
 963       int saved_errno = errno;
 964       set_file_error (error,
 965                       filename,
 966                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 967                       saved_errno);
 968 
 969       return FALSE;
 970     }
 971 
 972   retval = get_contents_stdio (filename, f, contents, length, error);
 973 
 974   return retval;
 975 }
 976 
 977 #endif
 978 
 979 /**
 980  * g_file_get_contents:
 981  * @filename: (type filename): name of a file to read contents from, in the GLib file name encoding
 982  * @contents: (out) (array length=length) (element-type guint8): location to store an allocated string, use g_free() to free
 983  *     the returned string
 984  * @length: (nullable): location to store length in bytes of the contents, or %NULL
 985  * @error: return location for a #GError, or %NULL
 986  *
 987  * Reads an entire file into allocated memory, with good error
 988  * checking.
 989  *
 990  * If the call was successful, it returns %TRUE and sets @contents to the file
 991  * contents and @length to the length of the file contents in bytes. The string
 992  * stored in @contents will be nul-terminated, so for text files you can pass
 993  * %NULL for the @length argument. If the call was not successful, it returns
 994  * %FALSE and sets @error. The error domain is #G_FILE_ERROR. Possible error
 995  * codes are those in the #GFileError enumeration. In the error case,
 996  * @contents is set to %NULL and @length is set to zero.
 997  *
 998  * Returns: %TRUE on success, %FALSE if an error occurred
 999  **/
1000 gboolean
1001 g_file_get_contents (const gchar  *filename,
1002                      gchar       **contents,
1003                      gsize        *length,
1004                      GError      **error)
1005 {
1006   g_return_val_if_fail (filename != NULL, FALSE);
1007   g_return_val_if_fail (contents != NULL, FALSE);
1008 
1009   *contents = NULL;
1010   if (length)
1011     *length = 0;
1012 
1013 #ifdef G_OS_WIN32
1014   return get_contents_win32 (filename, contents, length, error);
1015 #else
1016   return get_contents_posix (filename, contents, length, error);
1017 #endif
1018 }
1019 
1020 static gboolean
1021 rename_file (const char  *old_name,
1022          const char  *new_name,
1023          GError     **err)
1024 {
1025   errno = 0;
1026   if (g_rename (old_name, new_name) == -1)
1027     {
1028       int save_errno = errno;
1029       gchar *display_old_name = g_filename_display_name (old_name);
1030       gchar *display_new_name = g_filename_display_name (new_name);
1031 
1032       g_set_error (err,
1033            G_FILE_ERROR,
1034            g_file_error_from_errno (save_errno),
1035            _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),
1036            display_old_name,
1037            display_new_name,
1038            g_strerror (save_errno));
1039 
1040       g_free (display_old_name);
1041       g_free (display_new_name);
1042 
1043       return FALSE;
1044     }
1045 
1046   return TRUE;
1047 }
1048 
1049 static gchar *
1050 write_to_temp_file (const gchar  *contents,
1051             gssize        length,
1052             const gchar  *dest_file,
1053             GError      **err)
1054 {
1055   gchar *tmp_name;
1056   gchar *retval;
1057   gint fd;
1058 
1059   retval = NULL;
1060 
1061   tmp_name = g_strdup_printf (&quot;%s.XXXXXX&quot;, dest_file);
1062 
1063   errno = 0;
1064   fd = g_mkstemp_full (tmp_name, O_RDWR | O_BINARY, 0666);
1065 
1066   if (fd == -1)
1067     {
1068       int saved_errno = errno;
1069       set_file_error (err,
1070                       tmp_name, _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1071                       saved_errno);
1072       goto out;
1073     }
1074 
1075 #ifdef HAVE_FALLOCATE
1076   if (length &gt; 0)
1077     {
1078       /* We do this on a &#39;best effort&#39; basis... It may not be supported
1079        * on the underlying filesystem.
1080        */
1081       (void) fallocate (fd, 0, 0, length);
1082     }
1083 #endif
1084   while (length &gt; 0)
1085     {
1086       gssize s;
1087 
1088       s = write (fd, contents, length);
1089 
1090       if (s &lt; 0)
1091         {
1092           int saved_errno = errno;
1093           if (saved_errno == EINTR)
1094             continue;
1095 
1096           set_file_error (err,
1097                           tmp_name, _(&quot;Failed to write file &#39;%s&#39;: write() failed: %s&quot;),
1098                           saved_errno);
1099           close (fd);
1100           g_unlink (tmp_name);
1101 
1102           goto out;
1103         }
1104 
1105       g_assert (s &lt;= length);
1106 
1107       contents += s;
1108       length -= s;
1109     }
1110 
1111 #ifdef BTRFS_SUPER_MAGIC
1112   {
1113     struct statfs buf;
1114 
1115     /* On Linux, on btrfs, skip the fsync since rename-over-existing is
1116      * guaranteed to be atomic and this is the only case in which we
1117      * would fsync() anyway.
1118      */
1119 
1120     if (fstatfs (fd, &amp;buf) == 0 &amp;&amp; buf.f_type == BTRFS_SUPER_MAGIC)
1121       goto no_fsync;
1122   }
1123 #endif
1124 
1125 #ifdef HAVE_FSYNC
1126   {
1127     struct stat statbuf;
1128 
1129     errno = 0;
1130     /* If the final destination exists and is &gt; 0 bytes, we want to sync the
1131      * newly written file to ensure the data is on disk when we rename over
1132      * the destination. Otherwise if we get a system crash we can lose both
1133      * the new and the old file on some filesystems. (I.E. those that don&#39;t
1134      * guarantee the data is written to the disk before the metadata.)
1135      */
1136     if (g_lstat (dest_file, &amp;statbuf) == 0 &amp;&amp; statbuf.st_size &gt; 0 &amp;&amp; fsync (fd) != 0)
1137       {
1138         int saved_errno = errno;
1139         set_file_error (err,
1140                         tmp_name, _(&quot;Failed to write file &#39;%s&#39;: fsync() failed: %s&quot;),
1141                         saved_errno);
1142         close (fd);
1143         g_unlink (tmp_name);
1144 
1145         goto out;
1146       }
1147   }
1148 #endif
1149 
1150 #ifdef BTRFS_SUPER_MAGIC
1151  no_fsync:
1152 #endif
1153 
1154   errno = 0;
1155   if (!g_close (fd, err))
1156     {
1157       g_unlink (tmp_name);
1158 
1159       goto out;
1160     }
1161 
1162   retval = g_strdup (tmp_name);
1163 
1164  out:
1165   g_free (tmp_name);
1166 
1167   return retval;
1168 }
1169 
1170 /**
1171  * g_file_set_contents:
1172  * @filename: (type filename): name of a file to write @contents to, in the GLib file name
1173  *   encoding
1174  * @contents: (array length=length) (element-type guint8): string to write to the file
1175  * @length: length of @contents, or -1 if @contents is a nul-terminated string
1176  * @error: return location for a #GError, or %NULL
1177  *
1178  * Writes all of @contents to a file named @filename, with good error checking.
1179  * If a file called @filename already exists it will be overwritten.
1180  *
1181  * This write is atomic in the sense that it is first written to a temporary
1182  * file which is then renamed to the final name. Notes:
1183  *
1184  * - On UNIX, if @filename already exists hard links to @filename will break.
1185  *   Also since the file is recreated, existing permissions, access control
1186  *   lists, metadata etc. may be lost. If @filename is a symbolic link,
1187  *   the link itself will be replaced, not the linked file.
1188  *
1189  * - On UNIX, if @filename already exists and is non-empty, and if the system
1190  *   supports it (via a journalling filesystem or equivalent), the fsync()
1191  *   call (or equivalent) will be used to ensure atomic replacement: @filename
1192  *   will contain either its old contents or @contents, even in the face of
1193  *   system power loss, the disk being unsafely removed, etc.
1194  *
1195  * - On UNIX, if @filename does not already exist or is empty, there is a
1196  *   possibility that system power loss etc. after calling this function will
1197  *   leave @filename empty or full of NUL bytes, depending on the underlying
1198  *   filesystem.
1199  *
1200  * - On Windows renaming a file will not remove an existing file with the
1201  *   new name, so on Windows there is a race condition between the existing
1202  *   file being removed and the temporary file being renamed.
1203  *
1204  * - On Windows there is no way to remove a file that is open to some
1205  *   process, or mapped into memory. Thus, this function will fail if
1206  *   @filename already exists and is open.
1207  *
1208  * If the call was successful, it returns %TRUE. If the call was not successful,
1209  * it returns %FALSE and sets @error. The error domain is #G_FILE_ERROR.
1210  * Possible error codes are those in the #GFileError enumeration.
1211  *
1212  * Note that the name for the temporary file is constructed by appending up
1213  * to 7 characters to @filename.
1214  *
1215  * Returns: %TRUE on success, %FALSE if an error occurred
1216  *
1217  * Since: 2.8
1218  */
1219 gboolean
1220 g_file_set_contents (const gchar  *filename,
1221                      const gchar  *contents,
1222              gssize    length,
1223              GError  **error)
1224 {
1225   gchar *tmp_filename;
1226   gboolean retval;
1227   GError *rename_error = NULL;
1228 
1229   g_return_val_if_fail (filename != NULL, FALSE);
1230   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
1231   g_return_val_if_fail (contents != NULL || length == 0, FALSE);
1232   g_return_val_if_fail (length &gt;= -1, FALSE);
1233 
1234   if (length == -1)
1235     length = strlen (contents);
1236 
1237   tmp_filename = write_to_temp_file (contents, length, filename, error);
1238 
1239   if (!tmp_filename)
1240     {
1241       retval = FALSE;
1242       goto out;
1243     }
1244 
1245   if (!rename_file (tmp_filename, filename, &amp;rename_error))
1246     {
1247 #ifndef G_OS_WIN32
1248 
1249       g_unlink (tmp_filename);
1250       g_propagate_error (error, rename_error);
1251       retval = FALSE;
1252       goto out;
1253 
1254 #else /* G_OS_WIN32 */
1255 
1256       /* Renaming failed, but on Windows this may just mean
1257        * the file already exists. So if the target file
1258        * exists, try deleting it and do the rename again.
1259        */
1260       if (!g_file_test (filename, G_FILE_TEST_EXISTS))
1261     {
1262       g_unlink (tmp_filename);
1263       g_propagate_error (error, rename_error);
1264       retval = FALSE;
1265       goto out;
1266     }
1267 
1268       g_error_free (rename_error);
1269 
1270       if (g_unlink (filename) == -1)
1271     {
1272           int saved_errno = errno;
1273           set_file_error (error,
1274                           filename,
1275                   _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),
1276                           saved_errno);
1277       g_unlink (tmp_filename);
1278       retval = FALSE;
1279       goto out;
1280     }
1281 
1282       if (!rename_file (tmp_filename, filename, error))
1283     {
1284       g_unlink (tmp_filename);
1285       retval = FALSE;
1286       goto out;
1287     }
1288 
1289 #endif
1290     }
1291 
1292   retval = TRUE;
1293 
1294  out:
1295   g_free (tmp_filename);
1296   return retval;
1297 }
1298 
1299 /*
1300  * get_tmp_file based on the mkstemp implementation from the GNU C library.
1301  * Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
1302  */
1303 typedef gint (*GTmpFileCallback) (const gchar *, gint, gint);
1304 
1305 static gint
1306 get_tmp_file (gchar            *tmpl,
1307               GTmpFileCallback  f,
1308               int               flags,
1309               int               mode)
1310 {
1311   char *XXXXXX;
1312   int count, fd;
1313   static const char letters[] =
1314     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
1315   static const int NLETTERS = sizeof (letters) - 1;
1316   glong value;
1317   GTimeVal tv;
1318   static int counter = 0;
1319 
1320   g_return_val_if_fail (tmpl != NULL, -1);
1321 
1322   /* find the last occurrence of &quot;XXXXXX&quot; */
1323   XXXXXX = g_strrstr (tmpl, &quot;XXXXXX&quot;);
1324 
1325   if (!XXXXXX || strncmp (XXXXXX, &quot;XXXXXX&quot;, 6))
1326     {
1327       errno = EINVAL;
1328       return -1;
1329     }
1330 
1331   /* Get some more or less random data.  */
1332   g_get_current_time (&amp;tv);
1333   value = (tv.tv_usec ^ tv.tv_sec) + counter++;
1334 
1335   for (count = 0; count &lt; 100; value += 7777, ++count)
1336     {
1337       glong v = value;
1338 
1339       /* Fill in the random bits.  */
1340       XXXXXX[0] = letters[v % NLETTERS];
1341       v /= NLETTERS;
1342       XXXXXX[1] = letters[v % NLETTERS];
1343       v /= NLETTERS;
1344       XXXXXX[2] = letters[v % NLETTERS];
1345       v /= NLETTERS;
1346       XXXXXX[3] = letters[v % NLETTERS];
1347       v /= NLETTERS;
1348       XXXXXX[4] = letters[v % NLETTERS];
1349       v /= NLETTERS;
1350       XXXXXX[5] = letters[v % NLETTERS];
1351 
1352       fd = f (tmpl, flags, mode);
1353 
1354       if (fd &gt;= 0)
1355         return fd;
1356       else if (errno != EEXIST)
1357         /* Any other error will apply also to other names we might
1358          *  try, and there are 2^32 or so of them, so give up now.
1359          */
1360         return -1;
1361     }
1362 
1363   /* We got out of the loop because we ran out of combinations to try.  */
1364   errno = EEXIST;
1365   return -1;
1366 }
1367 
1368 /* Some GTmpFileCallback implementations.
1369  *
1370  * Note: we cannot use open() or g_open() directly because even though
1371  * they appear compatible, they may be vararg functions and calling
1372  * varargs functions through a non-varargs type is undefined.
1373  */
1374 static gint
1375 wrap_g_mkdir (const gchar *filename,
1376               int          flags G_GNUC_UNUSED,
1377               int          mode)
1378 {
1379   /* tmpl is in UTF-8 on Windows, thus use g_mkdir() */
1380   return g_mkdir (filename, mode);
1381 }
1382 
1383 static gint
1384 wrap_g_open (const gchar *filename,
1385                 int          flags,
1386                 int          mode)
1387 {
1388   return g_open (filename, flags, mode);
1389 }
1390 
1391 /**
1392  * g_mkdtemp_full: (skip)
1393  * @tmpl: (type filename): template directory name
1394  * @mode: permissions to create the temporary directory with
1395  *
1396  * Creates a temporary directory. See the mkdtemp() documentation
1397  * on most UNIX-like systems.
1398  *
1399  * The parameter is a string that should follow the rules for
1400  * mkdtemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1401  * g_mkdtemp_full() is slightly more flexible than mkdtemp() in that the
1402  * sequence does not have to occur at the very end of the template
1403  * and you can pass a @mode. The X string will be modified to form
1404  * the name of a directory that didn&#39;t exist. The string should be
1405  * in the GLib file name encoding. Most importantly, on Windows it
1406  * should be in UTF-8.
1407  *
1408  * If you are going to be creating a temporary directory inside the
1409  * directory returned by g_get_tmp_dir(), you might want to use
1410  * g_dir_make_tmp() instead.
1411  *
1412  * Returns: (nullable) (type filename): A pointer to @tmpl, which has been
1413  *     modified to hold the directory name. In case of errors, %NULL is
1414  *     returned, and %errno will be set.
1415  *
1416  * Since: 2.30
1417  */
1418 gchar *
1419 g_mkdtemp_full (gchar *tmpl,
1420                 gint   mode)
1421 {
1422   if (get_tmp_file (tmpl, wrap_g_mkdir, 0, mode) == -1)
1423     return NULL;
1424   else
1425     return tmpl;
1426 }
1427 
1428 /**
1429  * g_mkdtemp: (skip)
1430  * @tmpl: (type filename): template directory name
1431  *
1432  * Creates a temporary directory. See the mkdtemp() documentation
1433  * on most UNIX-like systems.
1434  *
1435  * The parameter is a string that should follow the rules for
1436  * mkdtemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1437  * g_mkdtemp() is slightly more flexible than mkdtemp() in that the
1438  * sequence does not have to occur at the very end of the template.
1439  * The X string will be modified to form the name of a directory that
1440  * didn&#39;t exist.
1441  * The string should be in the GLib file name encoding. Most importantly,
1442  * on Windows it should be in UTF-8.
1443  *
1444  * If you are going to be creating a temporary directory inside the
1445  * directory returned by g_get_tmp_dir(), you might want to use
1446  * g_dir_make_tmp() instead.
1447  *
1448  * Returns: (nullable) (type filename): A pointer to @tmpl, which has been
1449  *     modified to hold the directory name.  In case of errors, %NULL is
1450  *     returned and %errno will be set.
1451  *
1452  * Since: 2.30
1453  */
1454 gchar *
1455 g_mkdtemp (gchar *tmpl)
1456 {
1457   return g_mkdtemp_full (tmpl, 0700);
1458 }
1459 
1460 /**
1461  * g_mkstemp_full: (skip)
1462  * @tmpl: (type filename): template filename
1463  * @flags: flags to pass to an open() call in addition to O_EXCL
1464  *     and O_CREAT, which are passed automatically
1465  * @mode: permissions to create the temporary file with
1466  *
1467  * Opens a temporary file. See the mkstemp() documentation
1468  * on most UNIX-like systems.
1469  *
1470  * The parameter is a string that should follow the rules for
1471  * mkstemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1472  * g_mkstemp_full() is slightly more flexible than mkstemp()
1473  * in that the sequence does not have to occur at the very end of the
1474  * template and you can pass a @mode and additional @flags. The X
1475  * string will be modified to form the name of a file that didn&#39;t exist.
1476  * The string should be in the GLib file name encoding. Most importantly,
1477  * on Windows it should be in UTF-8.
1478  *
1479  * Returns: A file handle (as from open()) to the file
1480  *     opened for reading and writing. The file handle should be
1481  *     closed with close(). In case of errors, -1 is returned
1482  *     and %errno will be set.
1483  *
1484  * Since: 2.22
1485  */
1486 gint
1487 g_mkstemp_full (gchar *tmpl,
1488                 gint   flags,
1489                 gint   mode)
1490 {
1491   /* tmpl is in UTF-8 on Windows, thus use g_open() */
1492   return get_tmp_file (tmpl, wrap_g_open,
1493                        flags | O_CREAT | O_EXCL, mode);
1494 }
1495 
1496 /**
1497  * g_mkstemp: (skip)
1498  * @tmpl: (type filename): template filename
1499  *
1500  * Opens a temporary file. See the mkstemp() documentation
1501  * on most UNIX-like systems.
1502  *
1503  * The parameter is a string that should follow the rules for
1504  * mkstemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1505  * g_mkstemp() is slightly more flexible than mkstemp() in that the
1506  * sequence does not have to occur at the very end of the template.
1507  * The X string will be modified to form the name of a file that
1508  * didn&#39;t exist. The string should be in the GLib file name encoding.
1509  * Most importantly, on Windows it should be in UTF-8.
1510  *
1511  * Returns: A file handle (as from open()) to the file
1512  *     opened for reading and writing. The file is opened in binary
1513  *     mode on platforms where there is a difference. The file handle
1514  *     should be closed with close(). In case of errors, -1 is
1515  *     returned and %errno will be set.
1516  */
1517 gint
1518 g_mkstemp (gchar *tmpl)
1519 {
1520   return g_mkstemp_full (tmpl, O_RDWR | O_BINARY, 0600);
1521 }
1522 
1523 static gint
1524 g_get_tmp_name (const gchar      *tmpl,
1525                 gchar           **name_used,
1526                 GTmpFileCallback  f,
1527                 gint              flags,
1528                 gint              mode,
1529                 GError          **error)
1530 {
1531   int retval;
1532   const char *tmpdir;
1533   const char *sep;
1534   char *fulltemplate;
1535   const char *slash;
1536 
1537   if (tmpl == NULL)
1538     tmpl = &quot;.XXXXXX&quot;;
1539 
1540   if ((slash = strchr (tmpl, G_DIR_SEPARATOR)) != NULL
1541 #ifdef G_OS_WIN32
1542       || (strchr (tmpl, &#39;/&#39;) != NULL &amp;&amp; (slash = &quot;/&quot;))
1543 #endif
1544       )
1545     {
1546       gchar *display_tmpl = g_filename_display_name (tmpl);
1547       char c[2];
1548       c[0] = *slash;
1549       c[1] = &#39;\0&#39;;
1550 
1551       g_set_error (error,
1552                    G_FILE_ERROR,
1553                    G_FILE_ERROR_FAILED,
1554                    _(&quot;Template &#39;%s&#39; invalid, should not contain a &#39;%s&#39;&quot;),
1555                    display_tmpl, c);
1556       g_free (display_tmpl);
1557 
1558       return -1;
1559     }
1560 
1561   if (strstr (tmpl, &quot;XXXXXX&quot;) == NULL)
1562     {
1563       gchar *display_tmpl = g_filename_display_name (tmpl);
1564       g_set_error (error,
1565                    G_FILE_ERROR,
1566                    G_FILE_ERROR_FAILED,
1567                    _(&quot;Template &#39;%s&#39; doesn&#39;t contain XXXXXX&quot;),
1568                    display_tmpl);
1569       g_free (display_tmpl);
1570       return -1;
1571     }
1572 
1573   tmpdir = g_get_tmp_dir ();
1574 
1575   if (G_IS_DIR_SEPARATOR (tmpdir [strlen (tmpdir) - 1]))
1576     sep = &quot;&quot;;
1577   else
1578     sep = G_DIR_SEPARATOR_S;
1579 
1580   fulltemplate = g_strconcat (tmpdir, sep, tmpl, NULL);
1581 
1582   retval = get_tmp_file (fulltemplate, f, flags, mode);
1583   if (retval == -1)
1584     {
1585       int saved_errno = errno;
1586       set_file_error (error,
1587                       fulltemplate,
1588                       _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1589                       saved_errno);
1590       g_free (fulltemplate);
1591       return -1;
1592     }
1593 
1594   *name_used = fulltemplate;
1595 
1596   return retval;
1597 }
1598 
1599 /**
1600  * g_file_open_tmp:
1601  * @tmpl: (type filename) (nullable): Template for file name, as in
1602  *     g_mkstemp(), basename only, or %NULL for a default template
1603  * @name_used: (out) (type filename): location to store actual name used,
1604  *     or %NULL
1605  * @error: return location for a #GError
1606  *
1607  * Opens a file for writing in the preferred directory for temporary
1608  * files (as returned by g_get_tmp_dir()).
1609  *
1610  * @tmpl should be a string in the GLib file name encoding containing
1611  * a sequence of six &#39;X&#39; characters, as the parameter to g_mkstemp().
1612  * However, unlike these functions, the template should only be a
1613  * basename, no directory components are allowed. If template is
1614  * %NULL, a default template is used.
1615  *
1616  * Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not
1617  * modified, and might thus be a read-only literal string.
1618  *
1619  * Upon success, and if @name_used is non-%NULL, the actual name used
1620  * is returned in @name_used. This string should be freed with g_free()
1621  * when not needed any longer. The returned name is in the GLib file
1622  * name encoding.
1623  *
1624  * Returns: A file handle (as from open()) to the file opened for
1625  *     reading and writing. The file is opened in binary mode on platforms
1626  *     where there is a difference. The file handle should be closed with
1627  *     close(). In case of errors, -1 is returned and @error will be set.
1628  */
1629 gint
1630 g_file_open_tmp (const gchar  *tmpl,
1631                  gchar       **name_used,
1632                  GError      **error)
1633 {
1634   gchar *fulltemplate;
1635   gint result;
1636 
1637   g_return_val_if_fail (error == NULL || *error == NULL, -1);
1638 
1639   result = g_get_tmp_name (tmpl, &amp;fulltemplate,
1640                            wrap_g_open,
1641                            O_CREAT | O_EXCL | O_RDWR | O_BINARY,
1642                            0600,
1643                            error);
1644   if (result != -1)
1645     {
1646       if (name_used)
1647         *name_used = fulltemplate;
1648       else
1649         g_free (fulltemplate);
1650     }
1651 
1652   return result;
1653 }
1654 
1655 /**
1656  * g_dir_make_tmp:
1657  * @tmpl: (type filename) (nullable): Template for directory name,
1658  *     as in g_mkdtemp(), basename only, or %NULL for a default template
1659  * @error: return location for a #GError
1660  *
1661  * Creates a subdirectory in the preferred directory for temporary
1662  * files (as returned by g_get_tmp_dir()).
1663  *
1664  * @tmpl should be a string in the GLib file name encoding containing
1665  * a sequence of six &#39;X&#39; characters, as the parameter to g_mkstemp().
1666  * However, unlike these functions, the template should only be a
1667  * basename, no directory components are allowed. If template is
1668  * %NULL, a default template is used.
1669  *
1670  * Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not
1671  * modified, and might thus be a read-only literal string.
1672  *
1673  * Returns: (type filename): The actual name used. This string
1674  *     should be freed with g_free() when not needed any longer and is
1675  *     is in the GLib file name encoding. In case of errors, %NULL is
1676  *     returned and @error will be set.
1677  *
1678  * Since: 2.30
1679  */
1680 gchar *
1681 g_dir_make_tmp (const gchar  *tmpl,
1682                 GError      **error)
1683 {
1684   gchar *fulltemplate;
1685 
1686   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
1687 
1688   if (g_get_tmp_name (tmpl, &amp;fulltemplate, wrap_g_mkdir, 0, 0700, error) == -1)
1689     return NULL;
1690   else
1691     return fulltemplate;
1692 }
1693 
1694 static gchar *
1695 g_build_path_va (const gchar  *separator,
1696          const gchar  *first_element,
1697          va_list      *args,
1698          gchar       **str_array)
1699 {
1700   GString *result;
1701   gint separator_len = strlen (separator);
1702   gboolean is_first = TRUE;
1703   gboolean have_leading = FALSE;
1704   const gchar *single_element = NULL;
1705   const gchar *next_element;
1706   const gchar *last_trailing = NULL;
1707   gint i = 0;
1708 
1709   result = g_string_new (NULL);
1710 
1711   if (str_array)
1712     next_element = str_array[i++];
1713   else
1714     next_element = first_element;
1715 
1716   while (TRUE)
1717     {
1718       const gchar *element;
1719       const gchar *start;
1720       const gchar *end;
1721 
1722       if (next_element)
1723     {
1724       element = next_element;
1725       if (str_array)
1726         next_element = str_array[i++];
1727       else
1728         next_element = va_arg (*args, gchar *);
1729     }
1730       else
1731     break;
1732 
1733       /* Ignore empty elements */
1734       if (!*element)
1735     continue;
1736 
1737       start = element;
1738 
1739       if (separator_len)
1740     {
1741       while (strncmp (start, separator, separator_len) == 0)
1742         start += separator_len;
1743         }
1744 
1745       end = start + strlen (start);
1746 
1747       if (separator_len)
1748     {
1749       while (end &gt;= start + separator_len &amp;&amp;
1750          strncmp (end - separator_len, separator, separator_len) == 0)
1751         end -= separator_len;
1752 
1753       last_trailing = end;
1754       while (last_trailing &gt;= element + separator_len &amp;&amp;
1755          strncmp (last_trailing - separator_len, separator, separator_len) == 0)
1756         last_trailing -= separator_len;
1757 
1758       if (!have_leading)
1759         {
1760           /* If the leading and trailing separator strings are in the
1761            * same element and overlap, the result is exactly that element
1762            */
1763           if (last_trailing &lt;= start)
1764         single_element = element;
1765 
1766           g_string_append_len (result, element, start - element);
1767           have_leading = TRUE;
1768         }
1769       else
1770         single_element = NULL;
1771     }
1772 
1773       if (end == start)
1774     continue;
1775 
1776       if (!is_first)
1777     g_string_append (result, separator);
1778 
1779       g_string_append_len (result, start, end - start);
1780       is_first = FALSE;
1781     }
1782 
1783   if (single_element)
1784     {
1785       g_string_free (result, TRUE);
1786       return g_strdup (single_element);
1787     }
1788   else
1789     {
1790       if (last_trailing)
1791     g_string_append (result, last_trailing);
1792 
1793       return g_string_free (result, FALSE);
1794     }
1795 }
1796 
1797 /**
1798  * g_build_pathv:
1799  * @separator: a string used to separator the elements of the path.
1800  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
1801  *     array of strings containing the path elements.
1802  *
1803  * Behaves exactly like g_build_path(), but takes the path elements
1804  * as a string array, instead of varargs. This function is mainly
1805  * meant for language bindings.
1806  *
1807  * Returns: (type filename): a newly-allocated string that must be freed
1808  *     with g_free().
1809  *
1810  * Since: 2.8
1811  */
1812 gchar *
1813 g_build_pathv (const gchar  *separator,
1814            gchar       **args)
1815 {
1816   if (!args)
1817     return NULL;
1818 
1819   return g_build_path_va (separator, NULL, NULL, args);
1820 }
1821 
1822 
1823 /**
1824  * g_build_path:
1825  * @separator: (type filename): a string used to separator the elements of the path.
1826  * @first_element: (type filename): the first element in the path
1827  * @...: remaining elements in path, terminated by %NULL
1828  *
1829  * Creates a path from a series of elements using @separator as the
1830  * separator between elements. At the boundary between two elements,
1831  * any trailing occurrences of separator in the first element, or
1832  * leading occurrences of separator in the second element are removed
1833  * and exactly one copy of the separator is inserted.
1834  *
1835  * Empty elements are ignored.
1836  *
1837  * The number of leading copies of the separator on the result is
1838  * the same as the number of leading copies of the separator on
1839  * the first non-empty element.
1840  *
1841  * The number of trailing copies of the separator on the result is
1842  * the same as the number of trailing copies of the separator on
1843  * the last non-empty element. (Determination of the number of
1844  * trailing copies is done without stripping leading copies, so
1845  * if the separator is `ABA`, then `ABABA` has 1 trailing copy.)
1846  *
1847  * However, if there is only a single non-empty element, and there
1848  * are no characters in that element not part of the leading or
1849  * trailing separators, then the result is exactly the original value
1850  * of that element.
1851  *
1852  * Other than for determination of the number of leading and trailing
1853  * copies of the separator, elements consisting only of copies
1854  * of the separator are ignored.
1855  *
1856  * Returns: (type filename): a newly-allocated string that must be freed with
1857  *     g_free().
1858  **/
1859 gchar *
1860 g_build_path (const gchar *separator,
1861           const gchar *first_element,
1862           ...)
1863 {
1864   gchar *str;
1865   va_list args;
1866 
1867   g_return_val_if_fail (separator != NULL, NULL);
1868 
1869   va_start (args, first_element);
1870   str = g_build_path_va (separator, first_element, &amp;args, NULL);
1871   va_end (args);
1872 
1873   return str;
1874 }
1875 
1876 #ifdef G_OS_WIN32
1877 
1878 static gchar *
1879 g_build_pathname_va (const gchar  *first_element,
1880              va_list      *args,
1881              gchar       **str_array)
1882 {
1883   /* Code copied from g_build_pathv(), and modified to use two
1884    * alternative single-character separators.
1885    */
1886   GString *result;
1887   gboolean is_first = TRUE;
1888   gboolean have_leading = FALSE;
1889   const gchar *single_element = NULL;
1890   const gchar *next_element;
1891   const gchar *last_trailing = NULL;
1892   gchar current_separator = &#39;\\&#39;;
1893   gint i = 0;
1894 
1895   result = g_string_new (NULL);
1896 
1897   if (str_array)
1898     next_element = str_array[i++];
1899   else
1900     next_element = first_element;
1901 
1902   while (TRUE)
1903     {
1904       const gchar *element;
1905       const gchar *start;
1906       const gchar *end;
1907 
1908       if (next_element)
1909     {
1910       element = next_element;
1911       if (str_array)
1912         next_element = str_array[i++];
1913       else
1914         next_element = va_arg (*args, gchar *);
1915     }
1916       else
1917     break;
1918 
1919       /* Ignore empty elements */
1920       if (!*element)
1921     continue;
1922 
1923       start = element;
1924 
1925       if (TRUE)
1926     {
1927       while (start &amp;&amp;
1928          (*start == &#39;\\&#39; || *start == &#39;/&#39;))
1929         {
1930           current_separator = *start;
1931           start++;
1932         }
1933     }
1934 
1935       end = start + strlen (start);
1936 
1937       if (TRUE)
1938     {
1939       while (end &gt;= start + 1 &amp;&amp;
1940          (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))
1941         {
1942           current_separator = end[-1];
1943           end--;
1944         }
1945 
1946       last_trailing = end;
1947       while (last_trailing &gt;= element + 1 &amp;&amp;
1948          (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))
1949         last_trailing--;
1950 
1951       if (!have_leading)
1952         {
1953           /* If the leading and trailing separator strings are in the
1954            * same element and overlap, the result is exactly that element
1955            */
1956           if (last_trailing &lt;= start)
1957         single_element = element;
1958 
1959           g_string_append_len (result, element, start - element);
1960           have_leading = TRUE;
1961         }
1962       else
1963         single_element = NULL;
1964     }
1965 
1966       if (end == start)
1967     continue;
1968 
1969       if (!is_first)
1970     g_string_append_len (result, &amp;current_separator, 1);
1971 
1972       g_string_append_len (result, start, end - start);
1973       is_first = FALSE;
1974     }
1975 
1976   if (single_element)
1977     {
1978       g_string_free (result, TRUE);
1979       return g_strdup (single_element);
1980     }
1981   else
1982     {
1983       if (last_trailing)
1984     g_string_append (result, last_trailing);
1985 
1986       return g_string_free (result, FALSE);
1987     }
1988 }
1989 
1990 #endif
1991 
1992 static gchar *
1993 g_build_filename_va (const gchar  *first_argument,
1994                      va_list      *args,
1995                      gchar       **str_array)
1996 {
1997   gchar *str;
1998 
1999 #ifndef G_OS_WIN32
2000   str = g_build_path_va (G_DIR_SEPARATOR_S, first_argument, args, str_array);
2001 #else
2002   str = g_build_pathname_va (first_argument, args, str_array);
2003 #endif
2004 
2005   return str;
2006 }
2007 
2008 /**
2009  * g_build_filename_valist:
2010  * @first_element: (type filename): the first element in the path
2011  * @args: va_list of remaining elements in path
2012  *
2013  * Behaves exactly like g_build_filename(), but takes the path elements
2014  * as a va_list. This function is mainly meant for language bindings.
2015  *
2016  * Returns: (type filename): a newly-allocated string that must be freed
2017  *     with g_free().
2018  *
2019  * Since: 2.56
2020  */
2021 gchar *
2022 g_build_filename_valist (const gchar  *first_element,
2023                          va_list      *args)
2024 {
2025   g_return_val_if_fail (first_element != NULL, NULL);
2026 
2027   return g_build_filename_va (first_element, args, NULL);
2028 }
2029 
2030 /**
2031  * g_build_filenamev:
2032  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
2033  *     array of strings containing the path elements.
2034  *
2035  * Behaves exactly like g_build_filename(), but takes the path elements
2036  * as a string array, instead of varargs. This function is mainly
2037  * meant for language bindings.
2038  *
2039  * Returns: (type filename): a newly-allocated string that must be freed
2040  *     with g_free().
2041  *
2042  * Since: 2.8
2043  */
2044 gchar *
2045 g_build_filenamev (gchar **args)
2046 {
2047   return g_build_filename_va (NULL, NULL, args);
2048 }
2049 
2050 /**
2051  * g_build_filename:
2052  * @first_element: (type filename): the first element in the path
2053  * @...: remaining elements in path, terminated by %NULL
2054  *
2055  * Creates a filename from a series of elements using the correct
2056  * separator for filenames.
2057  *
2058  * On Unix, this function behaves identically to `g_build_path
2059  * (G_DIR_SEPARATOR_S, first_element, ....)`.
2060  *
2061  * On Windows, it takes into account that either the backslash
2062  * (`\` or slash (`/`) can be used as separator in filenames, but
2063  * otherwise behaves as on UNIX. When file pathname separators need
2064  * to be inserted, the one that last previously occurred in the
2065  * parameters (reading from left to right) is used.
2066  *
2067  * No attempt is made to force the resulting filename to be an absolute
2068  * path. If the first element is a relative path, the result will
2069  * be a relative path.
2070  *
2071  * Returns: (type filename): a newly-allocated string that must be freed with
2072  *     g_free().
2073  **/
2074 gchar *
2075 g_build_filename (const gchar *first_element,
2076           ...)
2077 {
2078   gchar *str;
2079   va_list args;
2080 
2081   va_start (args, first_element);
2082   str = g_build_filename_va (first_element, &amp;args, NULL);
2083   va_end (args);
2084 
2085   return str;
2086 }
2087 
2088 /**
2089  * g_file_read_link:
2090  * @filename: (type filename): the symbolic link
2091  * @error: return location for a #GError
2092  *
2093  * Reads the contents of the symbolic link @filename like the POSIX
2094  * readlink() function.  The returned string is in the encoding used
2095  * for filenames. Use g_filename_to_utf8() to convert it to UTF-8.
2096  *
2097  * Returns: (type filename): A newly-allocated string with the contents of
2098  *     the symbolic link, or %NULL if an error occurred.
2099  *
2100  * Since: 2.4
2101  */
2102 gchar *
2103 g_file_read_link (const gchar  *filename,
2104               GError      **error)
2105 {
2106 #if defined (HAVE_READLINK) || defined (G_OS_WIN32)
2107   gchar *buffer;
2108   size_t size;
2109   gssize read_size;
2110 
2111   g_return_val_if_fail (filename != NULL, NULL);
2112   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2113 
2114   size = 256;
2115   buffer = g_malloc (size);
2116 
2117   while (TRUE)
2118     {
2119 #ifndef G_OS_WIN32
2120       read_size = readlink (filename, buffer, size);
2121 #else
2122       read_size = g_win32_readlink_utf8 (filename, buffer, size);
2123 #endif
2124       if (read_size &lt; 0)
2125         {
2126           int saved_errno = errno;
2127           set_file_error (error,
2128                           filename,
2129                           _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),
2130                           saved_errno);
2131           g_free (buffer);
2132           return NULL;
2133         }
2134 
2135       if ((size_t) read_size &lt; size)
2136         {
2137           buffer[read_size] = 0;
2138           return buffer;
2139         }
2140 
2141       size *= 2;
2142       buffer = g_realloc (buffer, size);
2143     }
2144 #else
2145   g_return_val_if_fail (filename != NULL, NULL);
2146   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2147 
2148   g_set_error_literal (error,
2149                        G_FILE_ERROR,
2150                        G_FILE_ERROR_INVAL,
2151                        _(&quot;Symbolic links not supported&quot;));
2152 
2153   return NULL;
2154 #endif
2155 }
2156 
2157 /**
2158  * g_path_is_absolute:
2159  * @file_name: (type filename): a file name
2160  *
2161  * Returns %TRUE if the given @file_name is an absolute file name.
2162  * Note that this is a somewhat vague concept on Windows.
2163  *
2164  * On POSIX systems, an absolute file name is well-defined. It always
2165  * starts from the single root directory. For example &quot;/usr/local&quot;.
2166  *
2167  * On Windows, the concepts of current drive and drive-specific
2168  * current directory introduce vagueness. This function interprets as
2169  * an absolute file name one that either begins with a directory
2170  * separator such as &quot;\Users\tml&quot; or begins with the root on a drive,
2171  * for example &quot;C:\Windows&quot;. The first case also includes UNC paths
2172  * such as &quot;\\\\myserver\docs\foo&quot;. In all cases, either slashes or
2173  * backslashes are accepted.
2174  *
2175  * Note that a file name relative to the current drive root does not
2176  * truly specify a file uniquely over time and across processes, as
2177  * the current drive is a per-process value and can be changed.
2178  *
2179  * File names relative the current directory on some specific drive,
2180  * such as &quot;D:foo/bar&quot;, are not interpreted as absolute by this
2181  * function, but they obviously are not relative to the normal current
2182  * directory as returned by getcwd() or g_get_current_dir()
2183  * either. Such paths should be avoided, or need to be handled using
2184  * Windows-specific code.
2185  *
2186  * Returns: %TRUE if @file_name is absolute
2187  */
2188 gboolean
2189 g_path_is_absolute (const gchar *file_name)
2190 {
2191   g_return_val_if_fail (file_name != NULL, FALSE);
2192 
2193   if (G_IS_DIR_SEPARATOR (file_name[0]))
2194     return TRUE;
2195 
2196 #ifdef G_OS_WIN32
2197   /* Recognize drive letter on native Windows */
2198   if (g_ascii_isalpha (file_name[0]) &amp;&amp;
2199       file_name[1] == &#39;:&#39; &amp;&amp; G_IS_DIR_SEPARATOR (file_name[2]))
2200     return TRUE;
2201 #endif
2202 
2203   return FALSE;
2204 }
2205 
2206 /**
2207  * g_path_skip_root:
2208  * @file_name: (type filename): a file name
2209  *
2210  * Returns a pointer into @file_name after the root component,
2211  * i.e. after the &quot;/&quot; in UNIX or &quot;C:\&quot; under Windows. If @file_name
2212  * is not an absolute path it returns %NULL.
2213  *
2214  * Returns: (type filename) (nullable): a pointer into @file_name after the
2215  *     root component
2216  */
2217 const gchar *
2218 g_path_skip_root (const gchar *file_name)
2219 {
2220   g_return_val_if_fail (file_name != NULL, NULL);
2221 
2222 #ifdef G_PLATFORM_WIN32
2223   /* Skip \\server\share or //server/share */
2224   if (G_IS_DIR_SEPARATOR (file_name[0]) &amp;&amp;
2225       G_IS_DIR_SEPARATOR (file_name[1]) &amp;&amp;
2226       file_name[2] &amp;&amp;
2227       !G_IS_DIR_SEPARATOR (file_name[2]))
2228     {
2229       gchar *p;
2230       p = strchr (file_name + 2, G_DIR_SEPARATOR);
2231 
2232 #ifdef G_OS_WIN32
2233       {
2234         gchar *q;
2235 
2236         q = strchr (file_name + 2, &#39;/&#39;);
2237         if (p == NULL || (q != NULL &amp;&amp; q &lt; p))
2238         p = q;
2239       }
2240 #endif
2241 
2242       if (p &amp;&amp; p &gt; file_name + 2 &amp;&amp; p[1])
2243         {
2244           file_name = p + 1;
2245 
2246           while (file_name[0] &amp;&amp; !G_IS_DIR_SEPARATOR (file_name[0]))
2247             file_name++;
2248 
2249           /* Possibly skip a backslash after the share name */
2250           if (G_IS_DIR_SEPARATOR (file_name[0]))
2251             file_name++;
2252 
2253           return (gchar *)file_name;
2254         }
2255     }
2256 #endif
2257 
2258   /* Skip initial slashes */
2259   if (G_IS_DIR_SEPARATOR (file_name[0]))
2260     {
2261       while (G_IS_DIR_SEPARATOR (file_name[0]))
2262         file_name++;
2263       return (gchar *)file_name;
2264     }
2265 
2266 #ifdef G_OS_WIN32
2267   /* Skip X:\ */
2268   if (g_ascii_isalpha (file_name[0]) &amp;&amp;
2269       file_name[1] == &#39;:&#39; &amp;&amp;
2270       G_IS_DIR_SEPARATOR (file_name[2]))
2271     return (gchar *)file_name + 3;
2272 #endif
2273 
2274   return NULL;
2275 }
2276 
2277 /**
2278  * g_basename:
2279  * @file_name: (type filename): the name of the file
2280  *
2281  * Gets the name of the file without any leading directory
2282  * components. It returns a pointer into the given file name
2283  * string.
2284  *
2285  * Returns: (type filename): the name of the file without any leading
2286  *     directory components
2287  *
2288  * Deprecated:2.2: Use g_path_get_basename() instead, but notice
2289  *     that g_path_get_basename() allocates new memory for the
2290  *     returned string, unlike this function which returns a pointer
2291  *     into the argument.
2292  */
2293 const gchar *
2294 g_basename (const gchar *file_name)
2295 {
2296   gchar *base;
2297 
2298   g_return_val_if_fail (file_name != NULL, NULL);
2299 
2300   base = strrchr (file_name, G_DIR_SEPARATOR);
2301 
2302 #ifdef G_OS_WIN32
2303   {
2304     gchar *q;
2305     q = strrchr (file_name, &#39;/&#39;);
2306     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
2307       base = q;
2308   }
2309 #endif
2310 
2311   if (base)
2312     return base + 1;
2313 
2314 #ifdef G_OS_WIN32
2315   if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
2316     return (gchar*) file_name + 2;
2317 #endif
2318 
2319   return (gchar*) file_name;
2320 }
2321 
2322 /**
2323  * g_path_get_basename:
2324  * @file_name: (type filename): the name of the file
2325  *
2326  * Gets the last component of the filename.
2327  *
2328  * If @file_name ends with a directory separator it gets the component
2329  * before the last slash. If @file_name consists only of directory
2330  * separators (and on Windows, possibly a drive letter), a single
2331  * separator is returned. If @file_name is empty, it gets &quot;.&quot;.
2332  *
2333  * Returns: (type filename): a newly allocated string containing the last
2334  *    component of the filename
2335  */
2336 gchar *
2337 g_path_get_basename (const gchar *file_name)
2338 {
2339   gssize base;
2340   gssize last_nonslash;
2341   gsize len;
2342   gchar *retval;
2343 
2344   g_return_val_if_fail (file_name != NULL, NULL);
2345 
2346   if (file_name[0] == &#39;\0&#39;)
2347     return g_strdup (&quot;.&quot;);
2348 
2349   last_nonslash = strlen (file_name) - 1;
2350 
2351   while (last_nonslash &gt;= 0 &amp;&amp; G_IS_DIR_SEPARATOR (file_name [last_nonslash]))
2352     last_nonslash--;
2353 
2354   if (last_nonslash == -1)
2355     /* string only containing slashes */
2356     return g_strdup (G_DIR_SEPARATOR_S);
2357 
2358 #ifdef G_OS_WIN32
2359   if (last_nonslash == 1 &amp;&amp;
2360       g_ascii_isalpha (file_name[0]) &amp;&amp;
2361       file_name[1] == &#39;:&#39;)
2362     /* string only containing slashes and a drive */
2363     return g_strdup (G_DIR_SEPARATOR_S);
2364 #endif
2365   base = last_nonslash;
2366 
2367   while (base &gt;=0 &amp;&amp; !G_IS_DIR_SEPARATOR (file_name [base]))
2368     base--;
2369 
2370 #ifdef G_OS_WIN32
2371   if (base == -1 &amp;&amp;
2372       g_ascii_isalpha (file_name[0]) &amp;&amp;
2373       file_name[1] == &#39;:&#39;)
2374     base = 1;
2375 #endif /* G_OS_WIN32 */
2376 
2377   len = last_nonslash - base;
2378   retval = g_malloc (len + 1);
2379   memcpy (retval, file_name + base + 1, len);
2380   retval [len] = &#39;\0&#39;;
2381 
2382   return retval;
2383 }
2384 
2385 /**
2386  * g_dirname:
2387  * @file_name: (type filename): the name of the file
2388  *
2389  * Gets the directory components of a file name.
2390  *
2391  * If the file name has no directory components &quot;.&quot; is returned.
2392  * The returned string should be freed when no longer needed.
2393  *
2394  * Returns: (type filename): the directory components of the file
2395  *
2396  * Deprecated: use g_path_get_dirname() instead
2397  */
2398 
2399 /**
2400  * g_path_get_dirname:
2401  * @file_name: (type filename): the name of the file
2402  *
2403  * Gets the directory components of a file name.
2404  *
2405  * If the file name has no directory components &quot;.&quot; is returned.
2406  * The returned string should be freed when no longer needed.
2407  *
2408  * Returns: (type filename): the directory components of the file
2409  */
2410 gchar *
2411 g_path_get_dirname (const gchar *file_name)
2412 {
2413   gchar *base;
2414   gsize len;
2415 
2416   g_return_val_if_fail (file_name != NULL, NULL);
2417 
2418   base = strrchr (file_name, G_DIR_SEPARATOR);
2419 
2420 #ifdef G_OS_WIN32
2421   {
2422     gchar *q;
2423     q = strrchr (file_name, &#39;/&#39;);
2424     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
2425       base = q;
2426   }
2427 #endif
2428 
2429   if (!base)
2430     {
2431 #ifdef G_OS_WIN32
2432       if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
2433         {
2434           gchar drive_colon_dot[4];
2435 
2436           drive_colon_dot[0] = file_name[0];
2437           drive_colon_dot[1] = &#39;:&#39;;
2438           drive_colon_dot[2] = &#39;.&#39;;
2439           drive_colon_dot[3] = &#39;\0&#39;;
2440 
2441           return g_strdup (drive_colon_dot);
2442         }
2443 #endif
2444     return g_strdup (&quot;.&quot;);
2445     }
2446 
2447   while (base &gt; file_name &amp;&amp; G_IS_DIR_SEPARATOR (*base))
2448     base--;
2449 
2450 #ifdef G_OS_WIN32
2451   /* base points to the char before the last slash.
2452    *
2453    * In case file_name is the root of a drive (X:\) or a child of the
2454    * root of a drive (X:\foo), include the slash.
2455    *
2456    * In case file_name is the root share of an UNC path
2457    * (\\server\share), add a slash, returning \\server\share\ .
2458    *
2459    * In case file_name is a direct child of a share in an UNC path
2460    * (\\server\share\foo), include the slash after the share name,
2461    * returning \\server\share\ .
2462    */
2463   if (base == file_name + 1 &amp;&amp;
2464       g_ascii_isalpha (file_name[0]) &amp;&amp;
2465       file_name[1] == &#39;:&#39;)
2466     base++;
2467   else if (G_IS_DIR_SEPARATOR (file_name[0]) &amp;&amp;
2468            G_IS_DIR_SEPARATOR (file_name[1]) &amp;&amp;
2469            file_name[2] &amp;&amp;
2470            !G_IS_DIR_SEPARATOR (file_name[2]) &amp;&amp;
2471            base &gt;= file_name + 2)
2472     {
2473       const gchar *p = file_name + 2;
2474       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2475         p++;
2476       if (p == base + 1)
2477         {
2478           len = (guint) strlen (file_name) + 1;
2479           base = g_new (gchar, len + 1);
2480           strcpy (base, file_name);
2481           base[len-1] = G_DIR_SEPARATOR;
2482           base[len] = 0;
2483           return base;
2484         }
2485       if (G_IS_DIR_SEPARATOR (*p))
2486         {
2487           p++;
2488           while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2489             p++;
2490           if (p == base + 1)
2491             base++;
2492         }
2493     }
2494 #endif
2495 
2496   len = (guint) 1 + base - file_name;
2497   base = g_new (gchar, len + 1);
2498   memmove (base, file_name, len);
2499   base[len] = 0;
2500 
2501   return base;
2502 }
2503 
2504 /**
2505  * g_canonicalize_filename:
2506  * @filename: (type filename): the name of the file
2507  * @relative_to: (type filename) (nullable): the relative directory, or %NULL
2508  * to use the current working directory
2509  *
2510  * Gets the canonical file name from @filename. All triple slashes are turned into
2511  * single slashes, and all `..` and `.`s resolved against @relative_to.
2512  *
2513  * Symlinks are not followed, and the returned path is guaranteed to be absolute.
2514  *
2515  * If @filename is an absolute path, @relative_to is ignored. Otherwise,
2516  * @relative_to will be prepended to @filename to make it absolute. @relative_to
2517  * must be an absolute path, or %NULL. If @relative_to is %NULL, it&#39;ll fallback
2518  * to g_get_current_dir().
2519  *
2520  * This function never fails, and will canonicalize file paths even if they don&#39;t
2521  * exist.
2522  *
2523  * No file system I/O is done.
2524  *
2525  * Returns: (type filename) (transfer full): a newly allocated string with the
2526  * canonical file path
2527  * Since: 2.58
2528  */
2529 gchar *
2530 g_canonicalize_filename (const gchar *filename,
2531                          const gchar *relative_to)
2532 {
2533   gchar *canon, *start, *p, *q;
2534   guint i;
2535 
2536   g_return_val_if_fail (relative_to == NULL || g_path_is_absolute (relative_to), NULL);
2537 
2538   if (!g_path_is_absolute (filename))
2539     {
2540       gchar *cwd_allocated = NULL;
2541       const gchar  *cwd;
2542 
2543       if (relative_to != NULL)
2544         cwd = relative_to;
2545       else
2546         cwd = cwd_allocated = g_get_current_dir ();
2547 
2548       canon = g_build_filename (cwd, filename, NULL);
2549       g_free (cwd_allocated);
2550     }
2551   else
2552     {
2553       canon = g_strdup (filename);
2554     }
2555 
2556   start = (char *)g_path_skip_root (canon);
2557 
2558   if (start == NULL)
2559     {
2560       /* This shouldn&#39;t really happen, as g_get_current_dir() should
2561          return an absolute pathname, but bug 573843 shows this is
2562          not always happening */
2563       g_free (canon);
2564       return g_build_filename (G_DIR_SEPARATOR_S, filename, NULL);
2565     }
2566 
2567   /* POSIX allows double slashes at the start to
2568    * mean something special (as does windows too).
2569    * So, &quot;//&quot; != &quot;/&quot;, but more than two slashes
2570    * is treated as &quot;/&quot;.
2571    */
2572   i = 0;
2573   for (p = start - 1;
2574        (p &gt;= canon) &amp;&amp;
2575          G_IS_DIR_SEPARATOR (*p);
2576        p--)
2577     i++;
2578   if (i &gt; 2)
2579     {
2580       i -= 1;
2581       start -= i;
2582       memmove (start, start+i, strlen (start+i) + 1);
2583     }
2584 
2585   /* Make sure we&#39;re using the canonical dir separator */
2586   p++;
2587   while (p &lt; start &amp;&amp; G_IS_DIR_SEPARATOR (*p))
2588     *p++ = G_DIR_SEPARATOR;
2589 
2590   p = start;
2591   while (*p != 0)
2592     {
2593       if (p[0] == &#39;.&#39; &amp;&amp; (p[1] == 0 || G_IS_DIR_SEPARATOR (p[1])))
2594         {
2595           memmove (p, p+1, strlen (p+1)+1);
2596         }
2597       else if (p[0] == &#39;.&#39; &amp;&amp; p[1] == &#39;.&#39; &amp;&amp; (p[2] == 0 || G_IS_DIR_SEPARATOR (p[2])))
2598         {
2599           q = p + 2;
2600           /* Skip previous separator */
2601           p = p - 2;
2602           if (p &lt; start)
2603             p = start;
2604           while (p &gt; start &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2605             p--;
2606           if (G_IS_DIR_SEPARATOR (*p))
2607             *p++ = G_DIR_SEPARATOR;
2608           memmove (p, q, strlen (q)+1);
2609         }
2610       else
2611         {
2612           /* Skip until next separator */
2613           while (*p != 0 &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2614             p++;
2615 
2616           if (*p != 0)
2617             {
2618               /* Canonicalize one separator */
2619               *p++ = G_DIR_SEPARATOR;
2620             }
2621         }
2622 
2623       /* Remove additional separators */
2624       q = p;
2625       while (*q &amp;&amp; G_IS_DIR_SEPARATOR (*q))
2626         q++;
2627 
2628       if (p != q)
2629         memmove (p, q, strlen (q) + 1);
2630     }
2631 
2632   /* Remove trailing slashes */
2633   if (p &gt; start &amp;&amp; G_IS_DIR_SEPARATOR (*(p-1)))
2634     *(p-1) = 0;
2635 
2636   return canon;
2637 }
2638 
2639 #if defined(MAXPATHLEN)
2640 #define G_PATH_LENGTH MAXPATHLEN
2641 #elif defined(PATH_MAX)
2642 #define G_PATH_LENGTH PATH_MAX
2643 #elif defined(_PC_PATH_MAX)
2644 #define G_PATH_LENGTH sysconf(_PC_PATH_MAX)
2645 #else
2646 #define G_PATH_LENGTH 2048
2647 #endif
2648 
2649 /**
2650  * g_get_current_dir:
2651  *
2652  * Gets the current directory.
2653  *
2654  * The returned string should be freed when no longer needed.
2655  * The encoding of the returned string is system defined.
2656  * On Windows, it is always UTF-8.
2657  *
2658  * Since GLib 2.40, this function will return the value of the &quot;PWD&quot;
2659  * environment variable if it is set and it happens to be the same as
2660  * the current directory.  This can make a difference in the case that
2661  * the current directory is the target of a symbolic link.
2662  *
2663  * Returns: (type filename): the current directory
2664  */
2665 gchar *
2666 g_get_current_dir (void)
2667 {
2668 #ifdef G_OS_WIN32
2669 
2670   gchar *dir = NULL;
2671   wchar_t dummy[2], *wdir;
2672   int len;
2673 
2674   len = GetCurrentDirectoryW (2, dummy);
2675   wdir = g_new (wchar_t, len);
2676 
2677   if (GetCurrentDirectoryW (len, wdir) == len - 1)
2678     dir = g_utf16_to_utf8 (wdir, -1, NULL, NULL, NULL);
2679 
2680   g_free (wdir);
2681 
2682   if (dir == NULL)
2683     dir = g_strdup (&quot;\\&quot;);
2684 
2685   return dir;
2686 
2687 #else
2688   const gchar *pwd;
2689   gchar *buffer = NULL;
2690   gchar *dir = NULL;
2691   static gulong max_len = 0;
2692   struct stat pwdbuf, dotbuf;
2693 
2694   pwd = g_getenv (&quot;PWD&quot;);
2695   if (pwd != NULL &amp;&amp;
2696       g_stat (&quot;.&quot;, &amp;dotbuf) == 0 &amp;&amp; g_stat (pwd, &amp;pwdbuf) == 0 &amp;&amp;
2697       dotbuf.st_dev == pwdbuf.st_dev &amp;&amp; dotbuf.st_ino == pwdbuf.st_ino)
2698     return g_strdup (pwd);
2699 
2700   if (max_len == 0)
2701     max_len = (G_PATH_LENGTH == -1) ? 2048 : G_PATH_LENGTH;
2702 
2703   while (max_len &lt; G_MAXULONG / 2)
2704     {
2705       g_free (buffer);
2706       buffer = g_new (gchar, max_len + 1);
2707       *buffer = 0;
2708       dir = getcwd (buffer, max_len);
2709 
2710       if (dir || errno != ERANGE)
2711         break;
2712 
2713       max_len *= 2;
2714     }
2715 
2716   if (!dir || !*buffer)
2717     {
2718       /* hm, should we g_error() out here?
2719        * this can happen if e.g. &quot;./&quot; has mode \0000
2720        */
2721       buffer[0] = G_DIR_SEPARATOR;
2722       buffer[1] = 0;
2723     }
2724 
2725   dir = g_strdup (buffer);
2726   g_free (buffer);
2727 
2728   return dir;
2729 
2730 #endif /* !G_OS_WIN32 */
2731 }
2732 
2733 #ifndef GSTREAMER_LITE
2734 #ifdef G_OS_WIN32
2735 
2736 /* Binary compatibility versions. Not for newly compiled code. */
2737 
2738 _GLIB_EXTERN gboolean g_file_test_utf8         (const gchar  *filename,
2739                                                 GFileTest     test);
2740 _GLIB_EXTERN gboolean g_file_get_contents_utf8 (const gchar  *filename,
2741                                                 gchar       **contents,
2742                                                 gsize        *length,
2743                                                 GError      **error);
2744 _GLIB_EXTERN gint     g_mkstemp_utf8           (gchar        *tmpl);
2745 _GLIB_EXTERN gint     g_file_open_tmp_utf8     (const gchar  *tmpl,
2746                                                 gchar       **name_used,
2747                                                 GError      **error);
2748 _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
2749 
2750 
2751 gboolean
2752 g_file_test_utf8 (const gchar *filename,
2753              GFileTest    test)
2754 {
2755   return g_file_test (filename, test);
2756 }
2757 
2758 gboolean
2759 g_file_get_contents_utf8 (const gchar  *filename,
2760                      gchar       **contents,
2761                      gsize        *length,
2762                      GError      **error)
2763 {
2764   return g_file_get_contents (filename, contents, length, error);
2765 }
2766 
2767 gint
2768 g_mkstemp_utf8 (gchar *tmpl)
2769 {
2770   return g_mkstemp (tmpl);
2771 }
2772 
2773 gint
2774 g_file_open_tmp_utf8 (const gchar  *tmpl,
2775          gchar       **name_used,
2776          GError      **error)
2777 {
2778   return g_file_open_tmp (tmpl, name_used, error);
2779 }
2780 
2781 gchar *
2782 g_get_current_dir_utf8 (void)
2783 {
2784   return g_get_current_dir ();
2785 }
2786 
2787 #endif
2788 #endif // GSTREAMER_LITE
    </pre>
  </body>
</html>