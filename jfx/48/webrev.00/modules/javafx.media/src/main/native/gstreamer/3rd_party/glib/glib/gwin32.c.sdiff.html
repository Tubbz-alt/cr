<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gwin32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gwakeup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gwin32.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gwin32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * file for a list of people on the GLib Team.  See the ChangeLog
  22  * files for a list of changes.  These files are distributed with
  23  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  24  */
  25 
  26 /*
  27  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 
  32 #include &quot;glibconfig.h&quot;
  33 
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;stdio.h&gt;
  36 #include &lt;string.h&gt;
  37 #include &lt;wchar.h&gt;
  38 #include &lt;errno.h&gt;
  39 #include &lt;fcntl.h&gt;
  40 
<span class="line-modified">  41 #define STRICT          /* Strict typing, please */</span>
  42 #include &lt;windows.h&gt;
  43 #undef STRICT
  44 #ifndef G_WITH_CYGWIN
  45 #include &lt;direct.h&gt;
  46 #endif
  47 #include &lt;errno.h&gt;
  48 #include &lt;ctype.h&gt;
  49 #if defined(_MSC_VER) || defined(__DMC__)
  50 #  include &lt;io.h&gt;
  51 #endif /* _MSC_VER || __DMC__ */
  52 
  53 #define MODERN_API_FAMILY 2
  54 
  55 #if WINAPI_FAMILY == MODERN_API_FAMILY
  56 /* This is for modern UI Builds, where we can&#39;t use LoadLibraryW()/GetProcAddress() */
  57 /* ntddk.h is found in the WDK, and MinGW */
  58 #include &lt;ntddk.h&gt;
  59 
  60 #ifdef _MSC_VER
  61 #pragma comment (lib, &quot;ntoskrnl.lib&quot;)
  62 #endif
  63 #elif defined(__MINGW32__) &amp;&amp; !defined(__MINGW64_VERSION_MAJOR)
  64 /* mingw-w64 must use winternl.h, but not MinGW */
  65 #include &lt;ntdef.h&gt;
  66 #else
  67 #include &lt;winternl.h&gt;
  68 #endif
  69 
  70 #include &quot;glib.h&quot;
  71 #include &quot;gthreadprivate.h&quot;
  72 #include &quot;glib-init.h&quot;
  73 
  74 #ifdef G_WITH_CYGWIN
  75 #include &lt;sys/cygwin.h&gt;
  76 #endif
  77 
  78 #ifndef G_WITH_CYGWIN
  79 
  80 gint
  81 g_win32_ftruncate (gint  fd,
<span class="line-modified">  82            guint size)</span>
  83 {
  84   return _chsize (fd, size);
  85 }
  86 
  87 #endif
  88 
  89 /**
  90  * g_win32_getlocale:
  91  *
  92  * The setlocale() function in the Microsoft C library uses locale
  93  * names of the form &quot;English_United States.1252&quot; etc. We want the
  94  * UNIXish standard form &quot;en_US&quot;, &quot;zh_TW&quot; etc. This function gets the
  95  * current thread locale from Windows - without any encoding info -
  96  * and returns it as a string of the above form for use in forming
  97  * file names etc. The returned string should be deallocated with
  98  * g_free().
  99  *
 100  * Returns: newly-allocated locale name.
 101  **/
 102 
</pre>
<hr />
<pre>
 126     return g_strdup (ev);
 127 
 128   lcid = GetThreadLocale ();
 129 
 130   if (!GetLocaleInfo (lcid, LOCALE_SISO639LANGNAME, iso639, sizeof (iso639)) ||
 131       !GetLocaleInfo (lcid, LOCALE_SISO3166CTRYNAME, iso3166, sizeof (iso3166)))
 132     return g_strdup (&quot;C&quot;);
 133 
 134   /* Strip off the sorting rules, keep only the language part.  */
 135   langid = LANGIDFROMLCID (lcid);
 136 
 137   /* Split into language and territory part.  */
 138   primary = PRIMARYLANGID (langid);
 139   sub = SUBLANGID (langid);
 140 
 141   /* Handle special cases */
 142   switch (primary)
 143     {
 144     case LANG_AZERI:
 145       switch (sub)
<span class="line-modified"> 146     {</span>
<span class="line-modified"> 147     case SUBLANG_AZERI_LATIN:</span>
<span class="line-modified"> 148       script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 149       break;</span>
<span class="line-modified"> 150     case SUBLANG_AZERI_CYRILLIC:</span>
<span class="line-modified"> 151       script = &quot;@Cyrl&quot;;</span>
<span class="line-modified"> 152       break;</span>
<span class="line-modified"> 153     }</span>
 154       break;
<span class="line-modified"> 155     case LANG_SERBIAN:      /* LANG_CROATIAN == LANG_SERBIAN */</span>
 156       switch (sub)
<span class="line-modified"> 157     {</span>
<span class="line-modified"> 158     case SUBLANG_SERBIAN_LATIN:</span>
<span class="line-modified"> 159     case 0x06: /* Serbian (Latin) - Bosnia and Herzegovina */</span>
<span class="line-modified"> 160       script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 161       break;</span>
<span class="line-modified"> 162     }</span>
 163       break;
 164     case LANG_UZBEK:
 165       switch (sub)
<span class="line-modified"> 166     {</span>
<span class="line-modified"> 167     case SUBLANG_UZBEK_LATIN:</span>
<span class="line-modified"> 168       script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 169       break;</span>
<span class="line-modified"> 170     case SUBLANG_UZBEK_CYRILLIC:</span>
<span class="line-modified"> 171       script = &quot;@Cyrl&quot;;</span>
<span class="line-modified"> 172       break;</span>
<span class="line-modified"> 173     }</span>
 174       break;
 175     }
 176   return g_strconcat (iso639, &quot;_&quot;, iso3166, script, NULL);
 177 }
 178 
 179 /**
 180  * g_win32_error_message:
 181  * @error: error code.
 182  *
 183  * Translate a Win32 error code (as returned by GetLastError() or
 184  * WSAGetLastError()) into the corresponding message. The message is
 185  * either language neutral, or in the thread&#39;s language, or the user&#39;s
 186  * language, the system&#39;s language, or US English (see docs for
 187  * FormatMessage()). The returned string is in UTF-8. It should be
 188  * deallocated with g_free().
 189  *
 190  * Returns: newly-allocated error message
 191  **/
 192 gchar *
 193 g_win32_error_message (gint error)
 194 {
 195   gchar *retval;
 196   wchar_t *msg = NULL;
 197   size_t nchars;
 198 
 199   FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER
<span class="line-modified"> 200           |FORMAT_MESSAGE_IGNORE_INSERTS</span>
<span class="line-modified"> 201           |FORMAT_MESSAGE_FROM_SYSTEM,</span>
<span class="line-modified"> 202           NULL, error, 0,</span>
<span class="line-modified"> 203           (LPWSTR) &amp;msg, 0, NULL);</span>
 204   if (msg != NULL)
 205     {
 206       nchars = wcslen (msg);
 207 
 208       if (nchars &gt;= 2 &amp;&amp; msg[nchars-1] == L&#39;\n&#39; &amp;&amp; msg[nchars-2] == L&#39;\r&#39;)
 209         msg[nchars-2] = L&#39;\0&#39;;
 210 
 211       retval = g_utf16_to_utf8 (msg, -1, NULL, NULL, NULL);
 212 
 213       LocalFree (msg);
 214     }
 215   else
 216     retval = g_strdup (&quot;&quot;);
 217 
 218   return retval;
 219 }
 220 
 221 /**
 222  * g_win32_get_package_installation_directory_of_module:
 223  * @hmodule: (nullable): The Win32 handle for a DLL loaded into the current process, or %NULL
</pre>
<hr />
<pre>
 320   G_LOCK (module_dirs);
 321 
 322   if (module_dirs == NULL)
 323     module_dirs = g_hash_table_new (g_str_hash, g_str_equal);
 324 
 325   fn = g_hash_table_lookup (module_dirs, module_name ? module_name : &quot;&quot;);
 326 
 327   if (fn)
 328     {
 329       G_UNLOCK (module_dirs);
 330       return g_strdup (fn);
 331     }
 332 
 333   if (module_name)
 334     {
 335       wchar_t *wc_module_name = g_utf8_to_utf16 (module_name, -1, NULL, NULL, NULL);
 336       hmodule = GetModuleHandleW (wc_module_name);
 337       g_free (wc_module_name);
 338 
 339       if (!hmodule)
<span class="line-modified"> 340     {</span>
<span class="line-modified"> 341       G_UNLOCK (module_dirs);</span>
<span class="line-modified"> 342       return NULL;</span>
<span class="line-modified"> 343     }</span>
 344     }
 345 
 346   fn = g_win32_get_package_installation_directory_of_module (hmodule);
 347 
 348   if (fn == NULL)
 349     {
 350       G_UNLOCK (module_dirs);
 351       return NULL;
 352     }
 353 
 354   g_hash_table_insert (module_dirs, module_name ? g_strdup (module_name) : &quot;&quot;, fn);
 355 
 356   G_UNLOCK (module_dirs);
 357 
 358   return g_strdup (fn);
 359 }
 360 
 361 /**
 362  * g_win32_get_package_installation_directory:
 363  * @package: (nullable): You should pass %NULL for this.
</pre>
<hr />
<pre>
1001         _close (backup_fd);
1002 
1003       /* Sadly, there&#39;s no way to check that preferred_fd
1004        * is currently valid, so we can&#39;t back it up.
1005        * Doing operations on invalid FDs invokes invalid
1006        * parameter handler, which is bad for us.
1007        */
1008       if (old_fd != preferred_fd)
1009         /* This extra code will also try to ensure that
1010          * the expected file descriptors 0, 1 and 2 are
1011          * associated with the appropriate standard
1012          * handles.
1013          */
1014         if (_dup2 (new_fd, preferred_fd) &lt; 0)
1015           g_warning (&quot;Failed to dup fd %d into fd %d&quot;, new_fd, preferred_fd);
1016 
1017       _close (new_fd);
1018     }
1019 }
1020 























































































































































































































1021 #endif
</pre>
</td>
<td>
<hr />
<pre>
  21  * file for a list of people on the GLib Team.  See the ChangeLog
  22  * files for a list of changes.  These files are distributed with
  23  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  24  */
  25 
  26 /*
  27  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 
  32 #include &quot;glibconfig.h&quot;
  33 
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;stdio.h&gt;
  36 #include &lt;string.h&gt;
  37 #include &lt;wchar.h&gt;
  38 #include &lt;errno.h&gt;
  39 #include &lt;fcntl.h&gt;
  40 
<span class="line-modified">  41 #define STRICT      /* Strict typing, please */</span>
  42 #include &lt;windows.h&gt;
  43 #undef STRICT
  44 #ifndef G_WITH_CYGWIN
  45 #include &lt;direct.h&gt;
  46 #endif
  47 #include &lt;errno.h&gt;
  48 #include &lt;ctype.h&gt;
  49 #if defined(_MSC_VER) || defined(__DMC__)
  50 #  include &lt;io.h&gt;
  51 #endif /* _MSC_VER || __DMC__ */
  52 
  53 #define MODERN_API_FAMILY 2
  54 
  55 #if WINAPI_FAMILY == MODERN_API_FAMILY
  56 /* This is for modern UI Builds, where we can&#39;t use LoadLibraryW()/GetProcAddress() */
  57 /* ntddk.h is found in the WDK, and MinGW */
  58 #include &lt;ntddk.h&gt;
  59 
  60 #ifdef _MSC_VER
  61 #pragma comment (lib, &quot;ntoskrnl.lib&quot;)
  62 #endif
  63 #elif defined(__MINGW32__) &amp;&amp; !defined(__MINGW64_VERSION_MAJOR)
  64 /* mingw-w64 must use winternl.h, but not MinGW */
  65 #include &lt;ntdef.h&gt;
  66 #else
  67 #include &lt;winternl.h&gt;
  68 #endif
  69 
  70 #include &quot;glib.h&quot;
  71 #include &quot;gthreadprivate.h&quot;
  72 #include &quot;glib-init.h&quot;
  73 
  74 #ifdef G_WITH_CYGWIN
  75 #include &lt;sys/cygwin.h&gt;
  76 #endif
  77 
  78 #ifndef G_WITH_CYGWIN
  79 
  80 gint
  81 g_win32_ftruncate (gint  fd,
<span class="line-modified">  82        guint size)</span>
  83 {
  84   return _chsize (fd, size);
  85 }
  86 
  87 #endif
  88 
  89 /**
  90  * g_win32_getlocale:
  91  *
  92  * The setlocale() function in the Microsoft C library uses locale
  93  * names of the form &quot;English_United States.1252&quot; etc. We want the
  94  * UNIXish standard form &quot;en_US&quot;, &quot;zh_TW&quot; etc. This function gets the
  95  * current thread locale from Windows - without any encoding info -
  96  * and returns it as a string of the above form for use in forming
  97  * file names etc. The returned string should be deallocated with
  98  * g_free().
  99  *
 100  * Returns: newly-allocated locale name.
 101  **/
 102 
</pre>
<hr />
<pre>
 126     return g_strdup (ev);
 127 
 128   lcid = GetThreadLocale ();
 129 
 130   if (!GetLocaleInfo (lcid, LOCALE_SISO639LANGNAME, iso639, sizeof (iso639)) ||
 131       !GetLocaleInfo (lcid, LOCALE_SISO3166CTRYNAME, iso3166, sizeof (iso3166)))
 132     return g_strdup (&quot;C&quot;);
 133 
 134   /* Strip off the sorting rules, keep only the language part.  */
 135   langid = LANGIDFROMLCID (lcid);
 136 
 137   /* Split into language and territory part.  */
 138   primary = PRIMARYLANGID (langid);
 139   sub = SUBLANGID (langid);
 140 
 141   /* Handle special cases */
 142   switch (primary)
 143     {
 144     case LANG_AZERI:
 145       switch (sub)
<span class="line-modified"> 146   {</span>
<span class="line-modified"> 147   case SUBLANG_AZERI_LATIN:</span>
<span class="line-modified"> 148     script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 149     break;</span>
<span class="line-modified"> 150   case SUBLANG_AZERI_CYRILLIC:</span>
<span class="line-modified"> 151     script = &quot;@Cyrl&quot;;</span>
<span class="line-modified"> 152     break;</span>
<span class="line-modified"> 153   }</span>
 154       break;
<span class="line-modified"> 155     case LANG_SERBIAN:    /* LANG_CROATIAN == LANG_SERBIAN */</span>
 156       switch (sub)
<span class="line-modified"> 157   {</span>
<span class="line-modified"> 158   case SUBLANG_SERBIAN_LATIN:</span>
<span class="line-modified"> 159   case 0x06: /* Serbian (Latin) - Bosnia and Herzegovina */</span>
<span class="line-modified"> 160     script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 161     break;</span>
<span class="line-modified"> 162   }</span>
 163       break;
 164     case LANG_UZBEK:
 165       switch (sub)
<span class="line-modified"> 166   {</span>
<span class="line-modified"> 167   case SUBLANG_UZBEK_LATIN:</span>
<span class="line-modified"> 168     script = &quot;@Latn&quot;;</span>
<span class="line-modified"> 169     break;</span>
<span class="line-modified"> 170   case SUBLANG_UZBEK_CYRILLIC:</span>
<span class="line-modified"> 171     script = &quot;@Cyrl&quot;;</span>
<span class="line-modified"> 172     break;</span>
<span class="line-modified"> 173   }</span>
 174       break;
 175     }
 176   return g_strconcat (iso639, &quot;_&quot;, iso3166, script, NULL);
 177 }
 178 
 179 /**
 180  * g_win32_error_message:
 181  * @error: error code.
 182  *
 183  * Translate a Win32 error code (as returned by GetLastError() or
 184  * WSAGetLastError()) into the corresponding message. The message is
 185  * either language neutral, or in the thread&#39;s language, or the user&#39;s
 186  * language, the system&#39;s language, or US English (see docs for
 187  * FormatMessage()). The returned string is in UTF-8. It should be
 188  * deallocated with g_free().
 189  *
 190  * Returns: newly-allocated error message
 191  **/
 192 gchar *
 193 g_win32_error_message (gint error)
 194 {
 195   gchar *retval;
 196   wchar_t *msg = NULL;
 197   size_t nchars;
 198 
 199   FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER
<span class="line-modified"> 200       |FORMAT_MESSAGE_IGNORE_INSERTS</span>
<span class="line-modified"> 201       |FORMAT_MESSAGE_FROM_SYSTEM,</span>
<span class="line-modified"> 202       NULL, error, 0,</span>
<span class="line-modified"> 203       (LPWSTR) &amp;msg, 0, NULL);</span>
 204   if (msg != NULL)
 205     {
 206       nchars = wcslen (msg);
 207 
 208       if (nchars &gt;= 2 &amp;&amp; msg[nchars-1] == L&#39;\n&#39; &amp;&amp; msg[nchars-2] == L&#39;\r&#39;)
 209         msg[nchars-2] = L&#39;\0&#39;;
 210 
 211       retval = g_utf16_to_utf8 (msg, -1, NULL, NULL, NULL);
 212 
 213       LocalFree (msg);
 214     }
 215   else
 216     retval = g_strdup (&quot;&quot;);
 217 
 218   return retval;
 219 }
 220 
 221 /**
 222  * g_win32_get_package_installation_directory_of_module:
 223  * @hmodule: (nullable): The Win32 handle for a DLL loaded into the current process, or %NULL
</pre>
<hr />
<pre>
 320   G_LOCK (module_dirs);
 321 
 322   if (module_dirs == NULL)
 323     module_dirs = g_hash_table_new (g_str_hash, g_str_equal);
 324 
 325   fn = g_hash_table_lookup (module_dirs, module_name ? module_name : &quot;&quot;);
 326 
 327   if (fn)
 328     {
 329       G_UNLOCK (module_dirs);
 330       return g_strdup (fn);
 331     }
 332 
 333   if (module_name)
 334     {
 335       wchar_t *wc_module_name = g_utf8_to_utf16 (module_name, -1, NULL, NULL, NULL);
 336       hmodule = GetModuleHandleW (wc_module_name);
 337       g_free (wc_module_name);
 338 
 339       if (!hmodule)
<span class="line-modified"> 340   {</span>
<span class="line-modified"> 341     G_UNLOCK (module_dirs);</span>
<span class="line-modified"> 342     return NULL;</span>
<span class="line-modified"> 343   }</span>
 344     }
 345 
 346   fn = g_win32_get_package_installation_directory_of_module (hmodule);
 347 
 348   if (fn == NULL)
 349     {
 350       G_UNLOCK (module_dirs);
 351       return NULL;
 352     }
 353 
 354   g_hash_table_insert (module_dirs, module_name ? g_strdup (module_name) : &quot;&quot;, fn);
 355 
 356   G_UNLOCK (module_dirs);
 357 
 358   return g_strdup (fn);
 359 }
 360 
 361 /**
 362  * g_win32_get_package_installation_directory:
 363  * @package: (nullable): You should pass %NULL for this.
</pre>
<hr />
<pre>
1001         _close (backup_fd);
1002 
1003       /* Sadly, there&#39;s no way to check that preferred_fd
1004        * is currently valid, so we can&#39;t back it up.
1005        * Doing operations on invalid FDs invokes invalid
1006        * parameter handler, which is bad for us.
1007        */
1008       if (old_fd != preferred_fd)
1009         /* This extra code will also try to ensure that
1010          * the expected file descriptors 0, 1 and 2 are
1011          * associated with the appropriate standard
1012          * handles.
1013          */
1014         if (_dup2 (new_fd, preferred_fd) &lt; 0)
1015           g_warning (&quot;Failed to dup fd %d into fd %d&quot;, new_fd, preferred_fd);
1016 
1017       _close (new_fd);
1018     }
1019 }
1020 
<span class="line-added">1021 #ifndef GSTREAMER_LITE</span>
<span class="line-added">1022 /* This is a handle to the Vectored Exception Handler that</span>
<span class="line-added">1023  * we install on library initialization. If installed correctly,</span>
<span class="line-added">1024  * it will be non-NULL. Only used to later de-install the handler</span>
<span class="line-added">1025  * on library de-initialization.</span>
<span class="line-added">1026  */</span>
<span class="line-added">1027 static void *WinVEH_handle = NULL;</span>
<span class="line-added">1028 </span>
<span class="line-added">1029 #include &quot;gwin32-private.c&quot;</span>
<span class="line-added">1030 </span>
<span class="line-added">1031 /* Handles exceptions (useful for debugging).</span>
<span class="line-added">1032  * Issues a DebugBreak() call if the process is being debugged (not really</span>
<span class="line-added">1033  * useful - if the process is being debugged, this handler won&#39;t be invoked</span>
<span class="line-added">1034  * anyway). If it is not, runs a debugger from G_DEBUGGER env var,</span>
<span class="line-added">1035  * substituting first %p in it for PID, and the first %e for the event handle -</span>
<span class="line-added">1036  * that event should be set once the debugger attaches itself (otherwise the</span>
<span class="line-added">1037  * only way out of WaitForSingleObject() is to time out after 1 minute).</span>
<span class="line-added">1038  * For example, G_DEBUGGER can be set to the following command:</span>
<span class="line-added">1039  * ```</span>
<span class="line-added">1040  * gdb.exe -ex &quot;attach %p&quot; -ex &quot;signal-event %e&quot; -ex &quot;bt&quot; -ex &quot;c&quot;</span>
<span class="line-added">1041  * ```</span>
<span class="line-added">1042  * This will make GDB attach to the process, signal the event (GDB must be</span>
<span class="line-added">1043  * recent enough for the signal-event command to be available),</span>
<span class="line-added">1044  * show the backtrace and resume execution, which should make it catch</span>
<span class="line-added">1045  * the exception when Windows re-raises it again.</span>
<span class="line-added">1046  * The command line can&#39;t be longer than MAX_PATH (260 characters).</span>
<span class="line-added">1047  *</span>
<span class="line-added">1048  * This function will only stop (and run a debugger) on the following exceptions:</span>
<span class="line-added">1049  * * EXCEPTION_ACCESS_VIOLATION</span>
<span class="line-added">1050  * * EXCEPTION_STACK_OVERFLOW</span>
<span class="line-added">1051  * * EXCEPTION_ILLEGAL_INSTRUCTION</span>
<span class="line-added">1052  * To make it stop at other exceptions one should set the G_VEH_CATCH</span>
<span class="line-added">1053  * environment variable to a list of comma-separated hexademical numbers,</span>
<span class="line-added">1054  * where each number is the code of an exception that should be caught.</span>
<span class="line-added">1055  * This is done to prevent GLib from breaking when Windows uses</span>
<span class="line-added">1056  * exceptions to shuttle information (SetThreadName(), OutputDebugString())</span>
<span class="line-added">1057  * or for control flow.</span>
<span class="line-added">1058  *</span>
<span class="line-added">1059  * This function deliberately avoids calling any GLib code.</span>
<span class="line-added">1060  */</span>
<span class="line-added">1061 static LONG __stdcall</span>
<span class="line-added">1062 g_win32_veh_handler (PEXCEPTION_POINTERS ExceptionInfo)</span>
<span class="line-added">1063 {</span>
<span class="line-added">1064   EXCEPTION_RECORD    *er;</span>
<span class="line-added">1065   char                 debugger[MAX_PATH + 1];</span>
<span class="line-added">1066   const char          *debugger_env = NULL;</span>
<span class="line-added">1067   const char          *catch_list;</span>
<span class="line-added">1068   gboolean             catch = FALSE;</span>
<span class="line-added">1069   STARTUPINFO          si;</span>
<span class="line-added">1070   PROCESS_INFORMATION  pi;</span>
<span class="line-added">1071   HANDLE               event;</span>
<span class="line-added">1072   SECURITY_ATTRIBUTES  sa;</span>
<span class="line-added">1073 </span>
<span class="line-added">1074   if (ExceptionInfo == NULL ||</span>
<span class="line-added">1075       ExceptionInfo-&gt;ExceptionRecord == NULL)</span>
<span class="line-added">1076     return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-added">1077 </span>
<span class="line-added">1078   er = ExceptionInfo-&gt;ExceptionRecord;</span>
<span class="line-added">1079 </span>
<span class="line-added">1080   switch (er-&gt;ExceptionCode)</span>
<span class="line-added">1081     {</span>
<span class="line-added">1082     case EXCEPTION_ACCESS_VIOLATION:</span>
<span class="line-added">1083     case EXCEPTION_STACK_OVERFLOW:</span>
<span class="line-added">1084     case EXCEPTION_ILLEGAL_INSTRUCTION:</span>
<span class="line-added">1085     case EXCEPTION_BREAKPOINT: /* DebugBreak() raises this */</span>
<span class="line-added">1086       break;</span>
<span class="line-added">1087     default:</span>
<span class="line-added">1088       catch_list = getenv (&quot;G_VEH_CATCH&quot;);</span>
<span class="line-added">1089 </span>
<span class="line-added">1090       while (!catch &amp;&amp;</span>
<span class="line-added">1091              catch_list != NULL &amp;&amp;</span>
<span class="line-added">1092              catch_list[0] != 0)</span>
<span class="line-added">1093         {</span>
<span class="line-added">1094           unsigned long  catch_code;</span>
<span class="line-added">1095           char          *end;</span>
<span class="line-added">1096           errno = 0;</span>
<span class="line-added">1097           catch_code = strtoul (catch_list, &amp;end, 16);</span>
<span class="line-added">1098           if (errno != NO_ERROR)</span>
<span class="line-added">1099             break;</span>
<span class="line-added">1100           catch_list = end;</span>
<span class="line-added">1101           if (catch_list != NULL &amp;&amp; catch_list[0] == &#39;,&#39;)</span>
<span class="line-added">1102             catch_list++;</span>
<span class="line-added">1103           if (catch_code == er-&gt;ExceptionCode)</span>
<span class="line-added">1104             catch = TRUE;</span>
<span class="line-added">1105         }</span>
<span class="line-added">1106 </span>
<span class="line-added">1107       if (catch)</span>
<span class="line-added">1108         break;</span>
<span class="line-added">1109 </span>
<span class="line-added">1110       return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-added">1111     }</span>
<span class="line-added">1112 </span>
<span class="line-added">1113   if (IsDebuggerPresent ())</span>
<span class="line-added">1114     {</span>
<span class="line-added">1115       /* This shouldn&#39;t happen, but still try to</span>
<span class="line-added">1116        * avoid recursion with EXCEPTION_BREAKPOINT and</span>
<span class="line-added">1117        * DebugBreak().</span>
<span class="line-added">1118        */</span>
<span class="line-added">1119       if (er-&gt;ExceptionCode != EXCEPTION_BREAKPOINT)</span>
<span class="line-added">1120         DebugBreak ();</span>
<span class="line-added">1121       return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="line-added">1122     }</span>
<span class="line-added">1123 </span>
<span class="line-added">1124   fprintf_s (stderr,</span>
<span class="line-added">1125              &quot;Exception code=0x%lx flags=0x%lx at 0x%p&quot;,</span>
<span class="line-added">1126              er-&gt;ExceptionCode,</span>
<span class="line-added">1127              er-&gt;ExceptionFlags,</span>
<span class="line-added">1128              er-&gt;ExceptionAddress);</span>
<span class="line-added">1129 </span>
<span class="line-added">1130   switch (er-&gt;ExceptionCode)</span>
<span class="line-added">1131     {</span>
<span class="line-added">1132     case EXCEPTION_ACCESS_VIOLATION:</span>
<span class="line-added">1133       fprintf_s (stderr,</span>
<span class="line-added">1134                  &quot;. Access violation - attempting to %s at address 0x%p\n&quot;,</span>
<span class="line-added">1135                  er-&gt;ExceptionInformation[0] == 0 ? &quot;read data&quot; :</span>
<span class="line-added">1136                  er-&gt;ExceptionInformation[0] == 1 ? &quot;write data&quot; :</span>
<span class="line-added">1137                  er-&gt;ExceptionInformation[0] == 8 ? &quot;execute data&quot; :</span>
<span class="line-added">1138                  &quot;do something bad&quot;,</span>
<span class="line-added">1139                  (void *) er-&gt;ExceptionInformation[1]);</span>
<span class="line-added">1140       break;</span>
<span class="line-added">1141     case EXCEPTION_IN_PAGE_ERROR:</span>
<span class="line-added">1142       fprintf_s (stderr,</span>
<span class="line-added">1143                  &quot;. Page access violation - attempting to %s at address 0x%p with status %Ix\n&quot;,</span>
<span class="line-added">1144                  er-&gt;ExceptionInformation[0] == 0 ? &quot;read from an inaccessible page&quot; :</span>
<span class="line-added">1145                  er-&gt;ExceptionInformation[0] == 1 ? &quot;write to an inaccessible page&quot; :</span>
<span class="line-added">1146                  er-&gt;ExceptionInformation[0] == 8 ? &quot;execute data in page&quot; :</span>
<span class="line-added">1147                  &quot;do something bad with a page&quot;,</span>
<span class="line-added">1148                  (void *) er-&gt;ExceptionInformation[1],</span>
<span class="line-added">1149                  er-&gt;ExceptionInformation[2]);</span>
<span class="line-added">1150       break;</span>
<span class="line-added">1151     default:</span>
<span class="line-added">1152       fprintf_s (stderr, &quot;\n&quot;);</span>
<span class="line-added">1153       break;</span>
<span class="line-added">1154     }</span>
<span class="line-added">1155 </span>
<span class="line-added">1156   fflush (stderr);</span>
<span class="line-added">1157 </span>
<span class="line-added">1158   debugger_env = getenv (&quot;G_DEBUGGER&quot;);</span>
<span class="line-added">1159 </span>
<span class="line-added">1160   if (debugger_env == NULL)</span>
<span class="line-added">1161     return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-added">1162 </span>
<span class="line-added">1163   /* Create an inheritable event */</span>
<span class="line-added">1164   memset (&amp;si, 0, sizeof (si));</span>
<span class="line-added">1165   memset (&amp;pi, 0, sizeof (pi));</span>
<span class="line-added">1166   memset (&amp;sa, 0, sizeof (sa));</span>
<span class="line-added">1167   si.cb = sizeof (si);</span>
<span class="line-added">1168   sa.nLength = sizeof (sa);</span>
<span class="line-added">1169   sa.bInheritHandle = TRUE;</span>
<span class="line-added">1170   event = CreateEvent (&amp;sa, FALSE, FALSE, NULL);</span>
<span class="line-added">1171 </span>
<span class="line-added">1172   /* Put process ID and event handle into debugger commandline */</span>
<span class="line-added">1173   if (!_g_win32_subst_pid_and_event (debugger, G_N_ELEMENTS (debugger),</span>
<span class="line-added">1174                                      debugger_env, GetCurrentProcessId (),</span>
<span class="line-added">1175                                      (guintptr) event))</span>
<span class="line-added">1176     {</span>
<span class="line-added">1177       CloseHandle (event);</span>
<span class="line-added">1178       return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-added">1179     }</span>
<span class="line-added">1180 </span>
<span class="line-added">1181   /* Run the debugger */</span>
<span class="line-added">1182   debugger[MAX_PATH] = &#39;\0&#39;;</span>
<span class="line-added">1183   if (0 != CreateProcessA (NULL,</span>
<span class="line-added">1184                            debugger,</span>
<span class="line-added">1185                            NULL,</span>
<span class="line-added">1186                            NULL,</span>
<span class="line-added">1187                            TRUE,</span>
<span class="line-added">1188                            getenv (&quot;G_DEBUGGER_OLD_CONSOLE&quot;) != NULL ? 0 : CREATE_NEW_CONSOLE,</span>
<span class="line-added">1189                            NULL,</span>
<span class="line-added">1190                            NULL,</span>
<span class="line-added">1191                            &amp;si,</span>
<span class="line-added">1192                            &amp;pi))</span>
<span class="line-added">1193     {</span>
<span class="line-added">1194       CloseHandle (pi.hProcess);</span>
<span class="line-added">1195       CloseHandle (pi.hThread);</span>
<span class="line-added">1196       /* If successful, wait for 60 seconds on the event</span>
<span class="line-added">1197        * we passed. The debugger should signal that event.</span>
<span class="line-added">1198        * 60 second limit is here to prevent us from hanging</span>
<span class="line-added">1199        * up forever in case the debugger does not support</span>
<span class="line-added">1200        * event signalling.</span>
<span class="line-added">1201        */</span>
<span class="line-added">1202       WaitForSingleObject (event, 60000);</span>
<span class="line-added">1203     }</span>
<span class="line-added">1204 </span>
<span class="line-added">1205   CloseHandle (event);</span>
<span class="line-added">1206 </span>
<span class="line-added">1207   /* Now the debugger is present, and we can try</span>
<span class="line-added">1208    * resuming execution, re-triggering the exception,</span>
<span class="line-added">1209    * which will be caught by debugger this time around.</span>
<span class="line-added">1210    */</span>
<span class="line-added">1211   if (IsDebuggerPresent ())</span>
<span class="line-added">1212     return EXCEPTION_CONTINUE_EXECUTION;</span>
<span class="line-added">1213 </span>
<span class="line-added">1214   return EXCEPTION_CONTINUE_SEARCH;</span>
<span class="line-added">1215 }</span>
<span class="line-added">1216 </span>
<span class="line-added">1217 void</span>
<span class="line-added">1218 g_crash_handler_win32_init (void)</span>
<span class="line-added">1219 {</span>
<span class="line-added">1220   if (WinVEH_handle != NULL)</span>
<span class="line-added">1221     return;</span>
<span class="line-added">1222 </span>
<span class="line-added">1223   WinVEH_handle = AddVectoredExceptionHandler (0, &amp;g_win32_veh_handler);</span>
<span class="line-added">1224 }</span>
<span class="line-added">1225 </span>
<span class="line-added">1226 void</span>
<span class="line-added">1227 g_crash_handler_win32_deinit (void)</span>
<span class="line-added">1228 {</span>
<span class="line-added">1229   if (WinVEH_handle != NULL)</span>
<span class="line-added">1230     RemoveVectoredExceptionHandler (WinVEH_handle);</span>
<span class="line-added">1231 </span>
<span class="line-added">1232   WinVEH_handle = NULL;</span>
<span class="line-added">1233 }</span>
<span class="line-added">1234 #endif // GSTREAMER_LITE</span>
<span class="line-added">1235 </span>
1236 #endif
</pre>
</td>
</tr>
</table>
<center><a href="gwakeup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gwin32.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>