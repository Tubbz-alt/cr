<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsturi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsttypefindfactory.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsturi.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsturi.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 940   uri = g_filename_to_uri (abs_clean, NULL, error);
 941   g_free (abs_clean);
 942 
 943 beach:
 944 
 945   g_free (abs_location);
 946   GST_DEBUG (&quot;&#39;%s&#39; -&gt; &#39;%s&#39;&quot;, filename, uri);
 947   return uri;
 948 }
 949 
 950 /****************************************************************************
 951  * GstUri - GstMiniObject to parse and merge URIs according to IETF RFC 3986
 952  ****************************************************************************/
 953 
 954 /**
 955  * SECTION:gsturi
 956  * @title: GstUri
 957  * @short_description: URI parsing and manipulation.
 958  *
 959  * A #GstUri object can be used to parse and split a URI string into its
<span class="line-modified"> 960  * constituant parts. Two #GstUri objects can be joined to make a new #GstUri</span>
 961  * using the algorithm described in RFC3986.
 962  */
 963 
 964 /* Definition for GstUri object */
 965 struct _GstUri
 966 {
 967   /*&lt; private &gt; */
 968   GstMiniObject mini_object;
 969   gchar *scheme;
 970   gchar *userinfo;
 971   gchar *host;
 972   guint port;
 973   GList *path;
 974   GHashTable *query;
 975   gchar *fragment;
 976 };
 977 
 978 GST_DEFINE_MINI_OBJECT_TYPE (GstUri, gst_uri);
 979 
 980 static GstUri *_gst_uri_copy (const GstUri * uri);
</pre>
<hr />
<pre>
 997     gst_mini_object_init (GST_MINI_OBJECT_CAST (uri), 0, gst_uri_get_type (),
 998         (GstMiniObjectCopyFunction) _gst_uri_copy, NULL,
 999         (GstMiniObjectFreeFunction) _gst_uri_free);
1000 
1001   return uri;
1002 }
1003 
1004 static void
1005 _gst_uri_free (GstUri * uri)
1006 {
1007   g_return_if_fail (GST_IS_URI (uri));
1008 
1009   g_free (uri-&gt;scheme);
1010   g_free (uri-&gt;userinfo);
1011   g_free (uri-&gt;host);
1012   g_list_free_full (uri-&gt;path, g_free);
1013   if (uri-&gt;query)
1014     g_hash_table_unref (uri-&gt;query);
1015   g_free (uri-&gt;fragment);
1016 




1017   g_slice_free1 (sizeof (*uri), uri);
1018 }
1019 
1020 static GHashTable *
1021 _gst_uri_copy_query_table (GHashTable * orig)
1022 {
1023   GHashTable *new = NULL;
1024 
1025   if (orig != NULL) {
1026     GHashTableIter iter;
1027     gpointer key, value;
1028     new = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
1029     g_hash_table_iter_init (&amp;iter, orig);
1030     while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value)) {
1031       g_hash_table_insert (new, g_strdup (key), g_strdup (value));
1032     }
1033   }
1034 
1035   return new;
1036 }
</pre>
<hr />
<pre>
2226  * Since: 1.6
2227  */
2228 gboolean
2229 gst_uri_set_port (GstUri * uri, guint port)
2230 {
2231   if (!uri)
2232     return port == GST_URI_NO_PORT;
2233   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2234 
2235   uri-&gt;port = port;
2236 
2237   return TRUE;
2238 }
2239 
2240 /**
2241  * gst_uri_get_path:
2242  * @uri: The #GstUri to get the path from.
2243  *
2244  * Extract the path string from the URI object.
2245  *
<span class="line-modified">2246  * Returns: (transfer full): (nullable): The path from the URI. Once finished</span>
<span class="line-modified">2247  *                                       with the string should be g_free()&#39;d.</span>
2248  *
2249  * Since: 1.6
2250  */
2251 gchar *
2252 gst_uri_get_path (const GstUri * uri)
2253 {
2254   GList *path_segment;
2255   const gchar *sep = &quot;&quot;;
2256   GString *ret;
2257 
2258   if (!uri)
2259     return NULL;
2260   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2261   if (!uri-&gt;path)
2262     return NULL;
2263 
2264   ret = g_string_new (NULL);
2265 
2266   for (path_segment = uri-&gt;path; path_segment;
2267       path_segment = path_segment-&gt;next) {
</pre>
<hr />
<pre>
2579 {
2580   if (!uri)
2581     return NULL;
2582   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2583   if (!uri-&gt;query)
2584     return NULL;
2585 
2586   return g_hash_table_ref (uri-&gt;query);
2587 }
2588 
2589 /**
2590  * gst_uri_set_query_table:
2591  * @uri: (transfer none)(nullable): The #GstUri to modify.
2592  * @query_table: (transfer none)(nullable)(element-type gchar* gchar*): The new
2593  *               query table to use.
2594  *
2595  * Set the query table to use in the URI. The old table is unreferenced and a
2596  * reference to the new one is used instead. A value if %NULL for @query_table
2597  * will remove the query string from the URI.
2598  *
<span class="line-modified">2599  * Returns: %TRUE if the new table was sucessfully used for the query table.</span>
2600  *
2601  * Since: 1.6
2602  */
2603 gboolean
2604 gst_uri_set_query_table (GstUri * uri, GHashTable * query_table)
2605 {
2606   GHashTable *old_table = NULL;
2607 
2608   if (!uri)
2609     return query_table == NULL;
2610   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2611 
2612   old_table = uri-&gt;query;
2613   if (query_table)
2614     uri-&gt;query = g_hash_table_ref (query_table);
2615   else
2616     uri-&gt;query = NULL;
2617   if (old_table)
2618     g_hash_table_unref (old_table);
2619 
2620   return TRUE;
2621 }
2622 
2623 /**
2624  * gst_uri_set_query_value:
2625  * @uri: (transfer none)(nullable): The #GstUri to modify.
2626  * @query_key: (transfer none): The key for the query entry.
2627  * @query_value: (transfer none)(nullable): The value for the key.
2628  *
2629  * This inserts or replaces a key in the query table. A @query_value of %NULL
2630  * indicates that the key has no associated value, but will still be present in
2631  * the query string.
2632  *
<span class="line-modified">2633  * Returns: %TRUE if the query table was sucessfully updated.</span>
2634  *
2635  * Since: 1.6
2636  */
2637 gboolean
2638 gst_uri_set_query_value (GstUri * uri, const gchar * query_key,
2639     const gchar * query_value)
2640 {
2641   if (!uri)
2642     return FALSE;
2643   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2644 
2645   if (!uri-&gt;query) {
2646     uri-&gt;query = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
2647         g_free);
2648   }
2649   g_hash_table_insert (uri-&gt;query, g_strdup (query_key),
2650       g_strdup (query_value));
2651 
2652   return TRUE;
2653 }
</pre>
<hr />
<pre>
2788  */
2789 gboolean
2790 gst_uri_set_fragment (GstUri * uri, const gchar * fragment)
2791 {
2792   if (!uri)
2793     return fragment == NULL;
2794   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2795 
2796   g_free (uri-&gt;fragment);
2797   uri-&gt;fragment = g_strdup (fragment);
2798   return TRUE;
2799 }
2800 
2801 /**
2802  * gst_uri_get_media_fragment_table:
2803  * @uri: (nullable): The #GstUri to get the fragment table from.
2804  *
2805  * Get the media fragment table from the URI, as defined by &quot;Media Fragments URI 1.0&quot;.
2806  * Hash table returned by this API is a list of &quot;key-value&quot; pairs, and the each
2807  * pair is generated by splitting &quot;URI fragment&quot; per &quot;&amp;&quot; sub-delims, then &quot;key&quot;
<span class="line-modified">2808  * and &quot;value&quot; are splitted by &quot;=&quot; sub-delims. The &quot;key&quot; returned by this API may</span>
2809  * be undefined keyword by standard.
2810  * A value may be %NULL to indicate that the key should appear in the fragment
2811  * string in the URI, but does not have a value. Free the returned #GHashTable
2812  * with #g_hash_table_unref() when it is no longer required.
2813  * Modifying this hash table does not affect the fragment in the URI.
2814  *
2815  * See more about Media Fragments URI 1.0 (W3C) at https://www.w3.org/TR/media-frags/
2816  *
2817  * Returns: (transfer full) (element-type gchar* gchar*) (nullable): The
2818  *          fragment hash table from the URI.
2819  *
2820  * Since: 1.12
2821  */
2822 GHashTable *
2823 gst_uri_get_media_fragment_table (const GstUri * uri)
2824 {
2825   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2826 
2827   if (!uri-&gt;fragment)
2828     return NULL;
</pre>
</td>
<td>
<hr />
<pre>
 940   uri = g_filename_to_uri (abs_clean, NULL, error);
 941   g_free (abs_clean);
 942 
 943 beach:
 944 
 945   g_free (abs_location);
 946   GST_DEBUG (&quot;&#39;%s&#39; -&gt; &#39;%s&#39;&quot;, filename, uri);
 947   return uri;
 948 }
 949 
 950 /****************************************************************************
 951  * GstUri - GstMiniObject to parse and merge URIs according to IETF RFC 3986
 952  ****************************************************************************/
 953 
 954 /**
 955  * SECTION:gsturi
 956  * @title: GstUri
 957  * @short_description: URI parsing and manipulation.
 958  *
 959  * A #GstUri object can be used to parse and split a URI string into its
<span class="line-modified"> 960  * constituent parts. Two #GstUri objects can be joined to make a new #GstUri</span>
 961  * using the algorithm described in RFC3986.
 962  */
 963 
 964 /* Definition for GstUri object */
 965 struct _GstUri
 966 {
 967   /*&lt; private &gt; */
 968   GstMiniObject mini_object;
 969   gchar *scheme;
 970   gchar *userinfo;
 971   gchar *host;
 972   guint port;
 973   GList *path;
 974   GHashTable *query;
 975   gchar *fragment;
 976 };
 977 
 978 GST_DEFINE_MINI_OBJECT_TYPE (GstUri, gst_uri);
 979 
 980 static GstUri *_gst_uri_copy (const GstUri * uri);
</pre>
<hr />
<pre>
 997     gst_mini_object_init (GST_MINI_OBJECT_CAST (uri), 0, gst_uri_get_type (),
 998         (GstMiniObjectCopyFunction) _gst_uri_copy, NULL,
 999         (GstMiniObjectFreeFunction) _gst_uri_free);
1000 
1001   return uri;
1002 }
1003 
1004 static void
1005 _gst_uri_free (GstUri * uri)
1006 {
1007   g_return_if_fail (GST_IS_URI (uri));
1008 
1009   g_free (uri-&gt;scheme);
1010   g_free (uri-&gt;userinfo);
1011   g_free (uri-&gt;host);
1012   g_list_free_full (uri-&gt;path, g_free);
1013   if (uri-&gt;query)
1014     g_hash_table_unref (uri-&gt;query);
1015   g_free (uri-&gt;fragment);
1016 
<span class="line-added">1017 #ifdef USE_POISONING</span>
<span class="line-added">1018   memset (uri, 0xff, sizeof (*uri));</span>
<span class="line-added">1019 #endif</span>
<span class="line-added">1020 </span>
1021   g_slice_free1 (sizeof (*uri), uri);
1022 }
1023 
1024 static GHashTable *
1025 _gst_uri_copy_query_table (GHashTable * orig)
1026 {
1027   GHashTable *new = NULL;
1028 
1029   if (orig != NULL) {
1030     GHashTableIter iter;
1031     gpointer key, value;
1032     new = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
1033     g_hash_table_iter_init (&amp;iter, orig);
1034     while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value)) {
1035       g_hash_table_insert (new, g_strdup (key), g_strdup (value));
1036     }
1037   }
1038 
1039   return new;
1040 }
</pre>
<hr />
<pre>
2230  * Since: 1.6
2231  */
2232 gboolean
2233 gst_uri_set_port (GstUri * uri, guint port)
2234 {
2235   if (!uri)
2236     return port == GST_URI_NO_PORT;
2237   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2238 
2239   uri-&gt;port = port;
2240 
2241   return TRUE;
2242 }
2243 
2244 /**
2245  * gst_uri_get_path:
2246  * @uri: The #GstUri to get the path from.
2247  *
2248  * Extract the path string from the URI object.
2249  *
<span class="line-modified">2250  * Returns: (transfer full) (nullable): The path from the URI. Once finished</span>
<span class="line-modified">2251  *                                      with the string should be g_free()&#39;d.</span>
2252  *
2253  * Since: 1.6
2254  */
2255 gchar *
2256 gst_uri_get_path (const GstUri * uri)
2257 {
2258   GList *path_segment;
2259   const gchar *sep = &quot;&quot;;
2260   GString *ret;
2261 
2262   if (!uri)
2263     return NULL;
2264   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2265   if (!uri-&gt;path)
2266     return NULL;
2267 
2268   ret = g_string_new (NULL);
2269 
2270   for (path_segment = uri-&gt;path; path_segment;
2271       path_segment = path_segment-&gt;next) {
</pre>
<hr />
<pre>
2583 {
2584   if (!uri)
2585     return NULL;
2586   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2587   if (!uri-&gt;query)
2588     return NULL;
2589 
2590   return g_hash_table_ref (uri-&gt;query);
2591 }
2592 
2593 /**
2594  * gst_uri_set_query_table:
2595  * @uri: (transfer none)(nullable): The #GstUri to modify.
2596  * @query_table: (transfer none)(nullable)(element-type gchar* gchar*): The new
2597  *               query table to use.
2598  *
2599  * Set the query table to use in the URI. The old table is unreferenced and a
2600  * reference to the new one is used instead. A value if %NULL for @query_table
2601  * will remove the query string from the URI.
2602  *
<span class="line-modified">2603  * Returns: %TRUE if the new table was successfully used for the query table.</span>
2604  *
2605  * Since: 1.6
2606  */
2607 gboolean
2608 gst_uri_set_query_table (GstUri * uri, GHashTable * query_table)
2609 {
2610   GHashTable *old_table = NULL;
2611 
2612   if (!uri)
2613     return query_table == NULL;
2614   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2615 
2616   old_table = uri-&gt;query;
2617   if (query_table)
2618     uri-&gt;query = g_hash_table_ref (query_table);
2619   else
2620     uri-&gt;query = NULL;
2621   if (old_table)
2622     g_hash_table_unref (old_table);
2623 
2624   return TRUE;
2625 }
2626 
2627 /**
2628  * gst_uri_set_query_value:
2629  * @uri: (transfer none)(nullable): The #GstUri to modify.
2630  * @query_key: (transfer none): The key for the query entry.
2631  * @query_value: (transfer none)(nullable): The value for the key.
2632  *
2633  * This inserts or replaces a key in the query table. A @query_value of %NULL
2634  * indicates that the key has no associated value, but will still be present in
2635  * the query string.
2636  *
<span class="line-modified">2637  * Returns: %TRUE if the query table was successfully updated.</span>
2638  *
2639  * Since: 1.6
2640  */
2641 gboolean
2642 gst_uri_set_query_value (GstUri * uri, const gchar * query_key,
2643     const gchar * query_value)
2644 {
2645   if (!uri)
2646     return FALSE;
2647   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2648 
2649   if (!uri-&gt;query) {
2650     uri-&gt;query = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
2651         g_free);
2652   }
2653   g_hash_table_insert (uri-&gt;query, g_strdup (query_key),
2654       g_strdup (query_value));
2655 
2656   return TRUE;
2657 }
</pre>
<hr />
<pre>
2792  */
2793 gboolean
2794 gst_uri_set_fragment (GstUri * uri, const gchar * fragment)
2795 {
2796   if (!uri)
2797     return fragment == NULL;
2798   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2799 
2800   g_free (uri-&gt;fragment);
2801   uri-&gt;fragment = g_strdup (fragment);
2802   return TRUE;
2803 }
2804 
2805 /**
2806  * gst_uri_get_media_fragment_table:
2807  * @uri: (nullable): The #GstUri to get the fragment table from.
2808  *
2809  * Get the media fragment table from the URI, as defined by &quot;Media Fragments URI 1.0&quot;.
2810  * Hash table returned by this API is a list of &quot;key-value&quot; pairs, and the each
2811  * pair is generated by splitting &quot;URI fragment&quot; per &quot;&amp;&quot; sub-delims, then &quot;key&quot;
<span class="line-modified">2812  * and &quot;value&quot; are split by &quot;=&quot; sub-delims. The &quot;key&quot; returned by this API may</span>
2813  * be undefined keyword by standard.
2814  * A value may be %NULL to indicate that the key should appear in the fragment
2815  * string in the URI, but does not have a value. Free the returned #GHashTable
2816  * with #g_hash_table_unref() when it is no longer required.
2817  * Modifying this hash table does not affect the fragment in the URI.
2818  *
2819  * See more about Media Fragments URI 1.0 (W3C) at https://www.w3.org/TR/media-frags/
2820  *
2821  * Returns: (transfer full) (element-type gchar* gchar*) (nullable): The
2822  *          fragment hash table from the URI.
2823  *
2824  * Since: 1.12
2825  */
2826 GHashTable *
2827 gst_uri_get_media_fragment_table (const GstUri * uri)
2828 {
2829   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2830 
2831   if (!uri-&gt;fragment)
2832     return NULL;
</pre>
</td>
</tr>
</table>
<center><a href="gsttypefindfactory.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsturi.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>