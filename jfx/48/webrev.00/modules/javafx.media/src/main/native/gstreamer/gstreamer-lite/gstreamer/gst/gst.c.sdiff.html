<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gst.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../gst-plugins-good/sys/osxaudio/gstosxcoreaudio.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gst.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gst.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 638 
 639   return TRUE;
 640 }
 641 
 642 static gboolean
 643 gst_register_core_elements (GstPlugin * plugin)
 644 {
 645   /* register some standard builtin types */
 646   if (!gst_element_register (plugin, &quot;bin&quot;, GST_RANK_PRIMARY,
 647           GST_TYPE_BIN) ||
 648       !gst_element_register (plugin, &quot;pipeline&quot;, GST_RANK_PRIMARY,
 649           GST_TYPE_PIPELINE)
 650       )
 651     g_assert_not_reached ();
 652 
 653   return TRUE;
 654 }
 655 
 656 /*
 657  * this bit handles:
<span class="line-modified"> 658  * - initalization of threads if we use them</span>
 659  * - log handler
 660  * - initial output
 661  * - initializes gst_format
 662  * - registers a bunch of types for gst_objects
 663  *
 664  * - we don&#39;t have cases yet where this fails, but in the future
 665  *   we might and then it&#39;s nice to be able to return that
 666  */
 667 static gboolean
 668 init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
 669     GError ** error)
 670 {
 671   GLogLevelFlags llf;
 672 
 673   if (gst_initialized) {
 674     GST_DEBUG (&quot;already initialized&quot;);
 675     return TRUE;
 676   }
 677 
 678   llf = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL;
</pre>
<hr />
<pre>
 889      * registered. FIXME: If debug categories were a plugin feature,
 890      * this would be unneeded */
 891     orig_features = features =
 892         gst_registry_get_feature_list_by_plugin (gst_registry_get (),
 893         gst_plugin_get_name (plugin));
 894     while (features) {
 895       GstPluginFeature *feature;
 896 
 897       if (G_UNLIKELY (features-&gt;data == NULL))
 898         goto next;
 899 
 900       feature = GST_PLUGIN_FEATURE (features-&gt;data);
 901       if (GST_IS_ELEMENT_FACTORY (feature)) {
 902         GstElementFactory *factory;
 903         GstElement *e;
 904 
 905         factory = GST_ELEMENT_FACTORY (feature);
 906         e = gst_element_factory_create (factory, NULL);
 907         if (e)
 908           gst_object_unref (e);
<span class="line-modified"> 909   }</span>
 910 
 911     next:
 912       features = g_list_next (features);
 913     }
 914 
 915     gst_plugin_feature_list_free (orig_features);
 916   }
 917   g_list_free (list2);
 918 
 919   list = gst_debug_get_all_categories ();
 920   walk = list = g_slist_sort (list, sort_by_category_name);
 921 
 922   g_print (&quot;\n&quot;);
 923   g_print (&quot;name                  level    description\n&quot;);
 924   g_print (&quot;---------------------+--------+--------------------------------\n&quot;);
 925 
 926   while (walk) {
 927     gboolean on_unix;
 928     GstDebugCategory *cat = (GstDebugCategory *) walk-&gt;data;
 929     GstDebugColorMode coloring = gst_debug_get_color_mode ();
</pre>
<hr />
<pre>
1003       gst_debug_set_threshold_from_string (arg, FALSE);
1004       break;
1005     case ARG_DEBUG_NO_COLOR:
1006       gst_debug_set_colored (FALSE);
1007       break;
1008     case ARG_DEBUG_COLOR_MODE:
1009       gst_debug_set_color_mode_from_string (arg);
1010       break;
1011     case ARG_DEBUG_DISABLE:
1012       gst_debug_set_active (FALSE);
1013       break;
1014     case ARG_DEBUG_HELP:
1015       gst_debug_help ();
1016       exit (0);
1017 #endif
1018     case ARG_PLUGIN_SPEW:
1019       break;
1020     case ARG_PLUGIN_PATH:
1021 #ifndef GST_DISABLE_REGISTRY
1022       if (!_priv_gst_disable_registry)
<span class="line-modified">1023       split_and_iterate (arg, G_SEARCHPATH_SEPARATOR_S, add_path_func, NULL);</span>
1024 #endif /* GST_DISABLE_REGISTRY */
1025       break;
1026     case ARG_PLUGIN_LOAD:
1027       split_and_iterate (arg, &quot;,&quot;, prepare_for_load_plugin_func, NULL);
1028       break;
1029     case ARG_SEGTRAP_DISABLE:
1030       _gst_disable_segtrap = TRUE;
1031       break;
1032     case ARG_REGISTRY_UPDATE_DISABLE:
1033 #ifndef GST_DISABLE_REGISTRY
1034       if (!_priv_gst_disable_registry)
<span class="line-modified">1035       _priv_gst_disable_registry_update = TRUE;</span>
1036 #endif
1037       break;
1038     case ARG_REGISTRY_FORK_DISABLE:
1039       gst_registry_fork_set_enabled (FALSE);
1040       break;
1041     default:
1042       g_set_error (err, G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
1043           _(&quot;Unknown option&quot;));
1044       return FALSE;
1045   }
1046 
1047   return TRUE;
1048 }
1049 
1050 static gboolean
1051 parse_goption_arg (const gchar * opt,
1052     const gchar * arg, gpointer data, GError ** err)
1053 {
1054   static const struct
1055   {
</pre>
<hr />
<pre>
1139     g_free (_gst_executable_path);
1140     _gst_executable_path = NULL;
1141   }
1142 
1143   clock = gst_system_clock_obtain ();
1144   gst_object_unref (clock);
1145   gst_object_unref (clock);
1146 
1147   _priv_gst_registry_cleanup ();
1148   _priv_gst_allocator_cleanup ();
1149 
1150   /* We want to destroy tracers as late as possible for the leaks tracer
1151    * but still need to keep the caps system alive as it may have to use
1152    * gst_caps_to_string() to display leaked caps. */
1153 #ifndef GST_DISABLE_GST_DEBUG
1154   _priv_gst_tracing_deinit ();
1155 #endif
1156 
1157   _priv_gst_caps_features_cleanup ();
1158   _priv_gst_caps_cleanup ();

1159 
1160   g_type_class_unref (g_type_class_peek (gst_object_get_type ()));
1161   g_type_class_unref (g_type_class_peek (gst_pad_get_type ()));
1162   g_type_class_unref (g_type_class_peek (gst_element_factory_get_type ()));
1163   g_type_class_unref (g_type_class_peek (gst_element_get_type ()));
1164   g_type_class_unref (g_type_class_peek (gst_tracer_factory_get_type ()));
1165   g_type_class_unref (g_type_class_peek (gst_type_find_factory_get_type ()));
1166   g_type_class_unref (g_type_class_peek (gst_bin_get_type ()));
1167   g_type_class_unref (g_type_class_peek (gst_bus_get_type ()));
1168   g_type_class_unref (g_type_class_peek (gst_task_get_type ()));
1169   g_type_class_unref (g_type_class_peek (gst_object_flags_get_type ()));
1170   g_type_class_unref (g_type_class_peek (gst_bin_flags_get_type ()));
1171   g_type_class_unref (g_type_class_peek (gst_buffer_flags_get_type ()));
1172   g_type_class_unref (g_type_class_peek (gst_buffer_copy_flags_get_type ()));
1173   g_type_class_unref (g_type_class_peek (gst_bus_flags_get_type ()));
1174   g_type_class_unref (g_type_class_peek (gst_bus_sync_reply_get_type ()));
1175   g_type_class_unref (g_type_class_peek (gst_caps_flags_get_type ()));
1176   g_type_class_unref (g_type_class_peek (gst_clock_type_get_type ()));
1177   g_type_class_unref (g_type_class_peek (gst_clock_return_get_type ()));
1178   g_type_class_unref (g_type_class_peek (gst_clock_entry_type_get_type ()));
</pre>
</td>
<td>
<hr />
<pre>
 638 
 639   return TRUE;
 640 }
 641 
 642 static gboolean
 643 gst_register_core_elements (GstPlugin * plugin)
 644 {
 645   /* register some standard builtin types */
 646   if (!gst_element_register (plugin, &quot;bin&quot;, GST_RANK_PRIMARY,
 647           GST_TYPE_BIN) ||
 648       !gst_element_register (plugin, &quot;pipeline&quot;, GST_RANK_PRIMARY,
 649           GST_TYPE_PIPELINE)
 650       )
 651     g_assert_not_reached ();
 652 
 653   return TRUE;
 654 }
 655 
 656 /*
 657  * this bit handles:
<span class="line-modified"> 658  * - initialization of threads if we use them</span>
 659  * - log handler
 660  * - initial output
 661  * - initializes gst_format
 662  * - registers a bunch of types for gst_objects
 663  *
 664  * - we don&#39;t have cases yet where this fails, but in the future
 665  *   we might and then it&#39;s nice to be able to return that
 666  */
 667 static gboolean
 668 init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
 669     GError ** error)
 670 {
 671   GLogLevelFlags llf;
 672 
 673   if (gst_initialized) {
 674     GST_DEBUG (&quot;already initialized&quot;);
 675     return TRUE;
 676   }
 677 
 678   llf = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL;
</pre>
<hr />
<pre>
 889      * registered. FIXME: If debug categories were a plugin feature,
 890      * this would be unneeded */
 891     orig_features = features =
 892         gst_registry_get_feature_list_by_plugin (gst_registry_get (),
 893         gst_plugin_get_name (plugin));
 894     while (features) {
 895       GstPluginFeature *feature;
 896 
 897       if (G_UNLIKELY (features-&gt;data == NULL))
 898         goto next;
 899 
 900       feature = GST_PLUGIN_FEATURE (features-&gt;data);
 901       if (GST_IS_ELEMENT_FACTORY (feature)) {
 902         GstElementFactory *factory;
 903         GstElement *e;
 904 
 905         factory = GST_ELEMENT_FACTORY (feature);
 906         e = gst_element_factory_create (factory, NULL);
 907         if (e)
 908           gst_object_unref (e);
<span class="line-modified"> 909       }</span>
 910 
 911     next:
 912       features = g_list_next (features);
 913     }
 914 
 915     gst_plugin_feature_list_free (orig_features);
 916   }
 917   g_list_free (list2);
 918 
 919   list = gst_debug_get_all_categories ();
 920   walk = list = g_slist_sort (list, sort_by_category_name);
 921 
 922   g_print (&quot;\n&quot;);
 923   g_print (&quot;name                  level    description\n&quot;);
 924   g_print (&quot;---------------------+--------+--------------------------------\n&quot;);
 925 
 926   while (walk) {
 927     gboolean on_unix;
 928     GstDebugCategory *cat = (GstDebugCategory *) walk-&gt;data;
 929     GstDebugColorMode coloring = gst_debug_get_color_mode ();
</pre>
<hr />
<pre>
1003       gst_debug_set_threshold_from_string (arg, FALSE);
1004       break;
1005     case ARG_DEBUG_NO_COLOR:
1006       gst_debug_set_colored (FALSE);
1007       break;
1008     case ARG_DEBUG_COLOR_MODE:
1009       gst_debug_set_color_mode_from_string (arg);
1010       break;
1011     case ARG_DEBUG_DISABLE:
1012       gst_debug_set_active (FALSE);
1013       break;
1014     case ARG_DEBUG_HELP:
1015       gst_debug_help ();
1016       exit (0);
1017 #endif
1018     case ARG_PLUGIN_SPEW:
1019       break;
1020     case ARG_PLUGIN_PATH:
1021 #ifndef GST_DISABLE_REGISTRY
1022       if (!_priv_gst_disable_registry)
<span class="line-modified">1023         split_and_iterate (arg, G_SEARCHPATH_SEPARATOR_S, add_path_func, NULL);</span>
1024 #endif /* GST_DISABLE_REGISTRY */
1025       break;
1026     case ARG_PLUGIN_LOAD:
1027       split_and_iterate (arg, &quot;,&quot;, prepare_for_load_plugin_func, NULL);
1028       break;
1029     case ARG_SEGTRAP_DISABLE:
1030       _gst_disable_segtrap = TRUE;
1031       break;
1032     case ARG_REGISTRY_UPDATE_DISABLE:
1033 #ifndef GST_DISABLE_REGISTRY
1034       if (!_priv_gst_disable_registry)
<span class="line-modified">1035         _priv_gst_disable_registry_update = TRUE;</span>
1036 #endif
1037       break;
1038     case ARG_REGISTRY_FORK_DISABLE:
1039       gst_registry_fork_set_enabled (FALSE);
1040       break;
1041     default:
1042       g_set_error (err, G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
1043           _(&quot;Unknown option&quot;));
1044       return FALSE;
1045   }
1046 
1047   return TRUE;
1048 }
1049 
1050 static gboolean
1051 parse_goption_arg (const gchar * opt,
1052     const gchar * arg, gpointer data, GError ** err)
1053 {
1054   static const struct
1055   {
</pre>
<hr />
<pre>
1139     g_free (_gst_executable_path);
1140     _gst_executable_path = NULL;
1141   }
1142 
1143   clock = gst_system_clock_obtain ();
1144   gst_object_unref (clock);
1145   gst_object_unref (clock);
1146 
1147   _priv_gst_registry_cleanup ();
1148   _priv_gst_allocator_cleanup ();
1149 
1150   /* We want to destroy tracers as late as possible for the leaks tracer
1151    * but still need to keep the caps system alive as it may have to use
1152    * gst_caps_to_string() to display leaked caps. */
1153 #ifndef GST_DISABLE_GST_DEBUG
1154   _priv_gst_tracing_deinit ();
1155 #endif
1156 
1157   _priv_gst_caps_features_cleanup ();
1158   _priv_gst_caps_cleanup ();
<span class="line-added">1159   _priv_gst_debug_cleanup ();</span>
1160 
1161   g_type_class_unref (g_type_class_peek (gst_object_get_type ()));
1162   g_type_class_unref (g_type_class_peek (gst_pad_get_type ()));
1163   g_type_class_unref (g_type_class_peek (gst_element_factory_get_type ()));
1164   g_type_class_unref (g_type_class_peek (gst_element_get_type ()));
1165   g_type_class_unref (g_type_class_peek (gst_tracer_factory_get_type ()));
1166   g_type_class_unref (g_type_class_peek (gst_type_find_factory_get_type ()));
1167   g_type_class_unref (g_type_class_peek (gst_bin_get_type ()));
1168   g_type_class_unref (g_type_class_peek (gst_bus_get_type ()));
1169   g_type_class_unref (g_type_class_peek (gst_task_get_type ()));
1170   g_type_class_unref (g_type_class_peek (gst_object_flags_get_type ()));
1171   g_type_class_unref (g_type_class_peek (gst_bin_flags_get_type ()));
1172   g_type_class_unref (g_type_class_peek (gst_buffer_flags_get_type ()));
1173   g_type_class_unref (g_type_class_peek (gst_buffer_copy_flags_get_type ()));
1174   g_type_class_unref (g_type_class_peek (gst_bus_flags_get_type ()));
1175   g_type_class_unref (g_type_class_peek (gst_bus_sync_reply_get_type ()));
1176   g_type_class_unref (g_type_class_peek (gst_caps_flags_get_type ()));
1177   g_type_class_unref (g_type_class_peek (gst_clock_type_get_type ()));
1178   g_type_class_unref (g_type_class_peek (gst_clock_return_get_type ()));
1179   g_type_class_unref (g_type_class_peek (gst_clock_entry_type_get_type ()));
</pre>
</td>
</tr>
</table>
<center><a href="../../gst-plugins-good/sys/osxaudio/gstosxcoreaudio.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gst.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>