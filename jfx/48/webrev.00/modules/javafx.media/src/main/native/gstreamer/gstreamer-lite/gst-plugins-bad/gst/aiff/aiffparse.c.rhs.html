<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-bad/gst/aiff/aiffparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* -*- Mode: C; tab-width: 2; indent-tabs-mode: t; c-basic-offset: 2 -*- */
   2 /* GStreamer AIFF parser
   3  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   4  *               &lt;2006&gt; Nokia Corporation, Stefan Kost &lt;stefan.kost@nokia.com&gt;.
   5  *               &lt;2008&gt; Pioneers of the Inevitable &lt;songbird@songbirdnest.com&gt;
   6  *
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:element-aiffparse
  26  * @title: aiffparse
  27  *
  28  * Parse a .aiff file into raw or compressed audio.
  29  *
  30  * The aiffparse element supports both push and pull mode operations, making it
  31  * possible to stream from a network source.
  32  *
  33  * ## Example launch line
  34  *
  35  * |[
  36  * gst-launch-1.0 filesrc location=sine.aiff ! aiffparse ! audioconvert ! alsasink
  37  * ]|
  38  * Read a aiff file and output to the soundcard using the ALSA element. The
  39  * aiff file is assumed to contain raw uncompressed samples.
  40  *
  41  * |[
  42  * gst-launch-1.0 souphttpsrc location=http://www.example.org/sine.aiff ! queue ! aiffparse ! audioconvert ! alsasink
  43  * ]|
  44  * Stream data from a network url.
  45  *
  46  */
  47 
  48 #ifdef HAVE_CONFIG_H
  49 #include &quot;config.h&quot;
  50 #endif
  51 
  52 #include &lt;string.h&gt;
  53 #include &lt;math.h&gt;
  54 
  55 #include &quot;aiffparse.h&quot;
  56 #include &lt;gst/audio/audio.h&gt;
  57 #include &lt;gst/tag/tag.h&gt;
  58 #include &lt;gst/pbutils/descriptions.h&gt;
  59 #include &lt;gst/gst-i18n-plugin.h&gt;
  60 
  61 GST_DEBUG_CATEGORY (aiffparse_debug);
  62 #define GST_CAT_DEFAULT (aiffparse_debug)
  63 
  64 static void gst_aiff_parse_dispose (GObject * object);
  65 
  66 static gboolean gst_aiff_parse_sink_activate (GstPad * sinkpad,
  67     GstObject * parent);
  68 static gboolean gst_aiff_parse_sink_activate_mode (GstPad * sinkpad,
  69     GstObject * parent, GstPadMode mode, gboolean active);
  70 static gboolean gst_aiff_parse_sink_event (GstPad * pad, GstObject * parent,
  71     GstEvent * buf);
  72 static gboolean gst_aiff_parse_send_event (GstElement * element,
  73     GstEvent * event);
  74 static GstStateChangeReturn gst_aiff_parse_change_state (GstElement * element,
  75     GstStateChange transition);
  76 
  77 static gboolean gst_aiff_parse_pad_query (GstPad * pad, GstObject * parent,
  78     GstQuery * query);
  79 static gboolean gst_aiff_parse_pad_convert (GstPad * pad,
  80     GstFormat src_format,
  81     gint64 src_value, GstFormat * dest_format, gint64 * dest_value);
  82 
  83 static GstFlowReturn gst_aiff_parse_chain (GstPad * pad, GstObject * parent,
  84     GstBuffer * buf);
  85 static void gst_aiff_parse_loop (GstPad * pad);
  86 static gboolean gst_aiff_parse_srcpad_event (GstPad * pad, GstObject * parent,
  87     GstEvent * event);
  88 
  89 static GstStaticPadTemplate sink_template_factory =
  90 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  91     GST_PAD_SINK,
  92     GST_PAD_ALWAYS,
  93     GST_STATIC_CAPS (&quot;audio/x-aiff&quot;)
  94     );
  95 
  96 static GstStaticPadTemplate src_template_factory =
  97 GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
  98     GST_PAD_SRC,
  99     GST_PAD_ALWAYS,
 100     GST_STATIC_CAPS (GST_AUDIO_CAPS_MAKE (&quot;{ S8, S16BE, S16LE, S24BE, S24LE, &quot;
 101             &quot;S32LE, S32BE, F32BE, F64BE }&quot;))
 102     );
 103 
 104 #define MAX_BUFFER_SIZE 4096
 105 
 106 #define gst_aiff_parse_parent_class parent_class
 107 G_DEFINE_TYPE (GstAiffParse, gst_aiff_parse, GST_TYPE_ELEMENT);
 108 
 109 static void
 110 gst_aiff_parse_class_init (GstAiffParseClass * klass)
 111 {
 112   GstElementClass *gstelement_class;
 113   GObjectClass *object_class;
 114 
 115   gstelement_class = (GstElementClass *) klass;
 116   object_class = (GObjectClass *) klass;
 117 
 118   object_class-&gt;dispose = gst_aiff_parse_dispose;
 119 
 120   gst_element_class_add_static_pad_template (gstelement_class,
 121       &amp;sink_template_factory);
 122   gst_element_class_add_static_pad_template (gstelement_class,
 123       &amp;src_template_factory);
 124 
 125   gst_element_class_set_static_metadata (gstelement_class,
 126       &quot;AIFF audio demuxer&quot;, &quot;Codec/Demuxer/Audio&quot;,
 127       &quot;Parse a .aiff file into raw audio&quot;,
 128       &quot;Pioneers of the Inevitable &lt;songbird@songbirdnest.com&gt;&quot;);
 129 
 130   gstelement_class-&gt;change_state =
 131       GST_DEBUG_FUNCPTR (gst_aiff_parse_change_state);
 132   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_aiff_parse_send_event);
 133 }
 134 
 135 static void
 136 gst_aiff_parse_reset (GstAiffParse * aiff)
 137 {
 138   aiff-&gt;state = AIFF_PARSE_START;
 139 
 140   /* These will all be set correctly in the fmt chunk */
 141   aiff-&gt;rate = 0;
 142   aiff-&gt;width = 0;
 143   aiff-&gt;depth = 0;
 144   aiff-&gt;channels = 0;
 145   aiff-&gt;bps = 0;
 146   aiff-&gt;offset = 0;
 147   aiff-&gt;end_offset = 0;
 148   aiff-&gt;dataleft = 0;
 149   aiff-&gt;datasize = 0;
 150   aiff-&gt;datastart = 0;
 151   aiff-&gt;duration = 0;
 152   aiff-&gt;got_comm = FALSE;
 153 
 154   if (aiff-&gt;seek_event)
 155     gst_event_unref (aiff-&gt;seek_event);
 156   aiff-&gt;seek_event = NULL;
 157   if (aiff-&gt;adapter) {
 158     gst_adapter_clear (aiff-&gt;adapter);
 159     aiff-&gt;adapter = NULL;
 160   }
 161 
 162   if (aiff-&gt;tags != NULL) {
 163     gst_tag_list_unref (aiff-&gt;tags);
 164     aiff-&gt;tags = NULL;
 165   }
 166 }
 167 
 168 static void
 169 gst_aiff_parse_dispose (GObject * object)
 170 {
 171   GstAiffParse *aiff = GST_AIFF_PARSE (object);
 172 
 173   GST_DEBUG_OBJECT (aiff, &quot;AIFF: Dispose&quot;);
 174   gst_aiff_parse_reset (aiff);
 175 
 176   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 177 }
 178 
 179 static void
 180 gst_aiff_parse_init (GstAiffParse * aiffparse)
 181 {
 182   gst_aiff_parse_reset (aiffparse);
 183 
 184   /* sink */
 185   aiffparse-&gt;sinkpad =
 186       gst_pad_new_from_static_template (&amp;sink_template_factory, &quot;sink&quot;);
 187   gst_pad_set_activate_function (aiffparse-&gt;sinkpad,
 188       GST_DEBUG_FUNCPTR (gst_aiff_parse_sink_activate));
 189   gst_pad_set_activatemode_function (aiffparse-&gt;sinkpad,
 190       GST_DEBUG_FUNCPTR (gst_aiff_parse_sink_activate_mode));
 191   gst_pad_set_event_function (aiffparse-&gt;sinkpad,
 192       GST_DEBUG_FUNCPTR (gst_aiff_parse_sink_event));
 193   gst_pad_set_chain_function (aiffparse-&gt;sinkpad,
 194       GST_DEBUG_FUNCPTR (gst_aiff_parse_chain));
 195   gst_element_add_pad (GST_ELEMENT_CAST (aiffparse), aiffparse-&gt;sinkpad);
 196 
 197   /* source */
 198   aiffparse-&gt;srcpad =
 199       gst_pad_new_from_static_template (&amp;src_template_factory, &quot;src&quot;);
 200   gst_pad_use_fixed_caps (aiffparse-&gt;srcpad);
 201   gst_pad_set_query_function (aiffparse-&gt;srcpad,
 202       GST_DEBUG_FUNCPTR (gst_aiff_parse_pad_query));
 203   gst_pad_set_event_function (aiffparse-&gt;srcpad,
 204       GST_DEBUG_FUNCPTR (gst_aiff_parse_srcpad_event));
 205   gst_element_add_pad (GST_ELEMENT_CAST (aiffparse), aiffparse-&gt;srcpad);
 206 }
 207 
 208 static gboolean
 209 gst_aiff_parse_parse_file_header (GstAiffParse * aiff, GstBuffer * buf)
 210 {
 211   guint32 header, type = 0;
 212   GstMapInfo info;
 213 
 214   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ)) {
 215     GST_WARNING_OBJECT (aiff, &quot;Could not map buffer&quot;);
 216     goto not_aiff;
 217   }
 218 
 219   if (info.size &lt; 12) {
 220     GST_WARNING_OBJECT (aiff, &quot;Buffer too short&quot;);
 221     gst_buffer_unmap (buf, &amp;info);
 222     goto not_aiff;
 223   }
 224 
 225   header = GST_READ_UINT32_LE (info.data);
 226   type = GST_READ_UINT32_LE (info.data + 8);
 227   gst_buffer_unmap (buf, &amp;info);
 228 
 229   if (header != GST_MAKE_FOURCC (&#39;F&#39;, &#39;O&#39;, &#39;R&#39;, &#39;M&#39;))
 230     goto not_aiff;
 231 
 232   if (type == GST_MAKE_FOURCC (&#39;A&#39;, &#39;I&#39;, &#39;F&#39;, &#39;F&#39;))
 233     aiff-&gt;is_aifc = FALSE;
 234   else if (type == GST_MAKE_FOURCC (&#39;A&#39;, &#39;I&#39;, &#39;F&#39;, &#39;C&#39;))
 235     aiff-&gt;is_aifc = TRUE;
 236   else
 237     goto not_aiff;
 238 
 239   gst_buffer_unref (buf);
 240   return TRUE;
 241 
 242   /* ERRORS */
 243 not_aiff:
 244   {
 245     GST_ELEMENT_ERROR (aiff, STREAM, WRONG_TYPE, (NULL),
 246         (&quot;File is not an AIFF file: 0x%&quot; G_GINT32_MODIFIER &quot;x&quot;, type));
 247     gst_buffer_unref (buf);
 248     return FALSE;
 249   }
 250 }
 251 
 252 static GstFlowReturn
 253 gst_aiff_parse_stream_init (GstAiffParse * aiff)
 254 {
 255   GstFlowReturn res;
 256   GstBuffer *buf = NULL;
 257 
 258   if ((res = gst_pad_pull_range (aiff-&gt;sinkpad,
 259               aiff-&gt;offset, 12, &amp;buf)) != GST_FLOW_OK)
 260     return res;
 261   else if (!gst_aiff_parse_parse_file_header (aiff, buf))
 262     return GST_FLOW_ERROR;
 263 
 264   aiff-&gt;offset += 12;
 265 
 266   return GST_FLOW_OK;
 267 }
 268 
 269 static gboolean
 270 gst_aiff_parse_time_to_bytepos (GstAiffParse * aiff, gint64 ts,
 271     gint64 * bytepos)
 272 {
 273   /* -1 always maps to -1 */
 274   if (ts == -1) {
 275     *bytepos = -1;
 276     return TRUE;
 277   }
 278 
 279   /* 0 always maps to 0 */
 280   if (ts == 0) {
 281     *bytepos = 0;
 282     return TRUE;
 283   }
 284 
 285   if (aiff-&gt;bps &gt; 0) {
 286     *bytepos = gst_util_uint64_scale_ceil (ts, (guint64) aiff-&gt;bps, GST_SECOND);
 287     return TRUE;
 288   }
 289 
 290   GST_WARNING_OBJECT (aiff, &quot;No valid bps to convert position&quot;);
 291 
 292   return FALSE;
 293 }
 294 
 295 /* This function is used to perform seeks on the element in
 296  * pull mode.
 297  *
 298  * It also works when event is NULL, in which case it will just
 299  * start from the last configured segment. This technique is
 300  * used when activating the element and to perform the seek in
 301  * READY.
 302  */
 303 static gboolean
 304 gst_aiff_parse_perform_seek (GstAiffParse * aiff, GstEvent * event,
 305     gboolean starting)
 306 {
 307   gboolean res;
 308   gdouble rate;
 309   GstFormat format;
 310   GstSeekFlags flags;
 311   GstSeekType start_type = GST_SEEK_TYPE_NONE, stop_type;
 312   gint64 start, stop, upstream_size;
 313   gboolean flush;
 314   gboolean update;
 315   GstSegment seeksegment = { 0, };
 316   gint64 position;
 317 
 318   if (event) {
 319     GST_DEBUG_OBJECT (aiff, &quot;doing seek with event&quot;);
 320 
 321     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 322         &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
 323 
 324     /* no negative rates yet */
 325     if (rate &lt; 0.0)
 326       goto negative_rate;
 327 
 328     if (format != aiff-&gt;segment.format) {
 329       GST_INFO_OBJECT (aiff, &quot;converting seek-event from %s to %s&quot;,
 330           gst_format_get_name (format),
 331           gst_format_get_name (aiff-&gt;segment.format));
 332       res = TRUE;
 333       if (start_type != GST_SEEK_TYPE_NONE)
 334         res =
 335             gst_pad_query_convert (aiff-&gt;srcpad, format, start,
 336             aiff-&gt;segment.format, &amp;start);
 337       if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE)
 338         res =
 339             gst_pad_query_convert (aiff-&gt;srcpad, format, stop,
 340             aiff-&gt;segment.format, &amp;stop);
 341       if (!res)
 342         goto no_format;
 343 
 344       format = aiff-&gt;segment.format;
 345     }
 346   } else {
 347     GST_DEBUG_OBJECT (aiff, &quot;doing seek without event&quot;);
 348     flags = 0;
 349     rate = 1.0;
 350     start = 0;
 351     start_type = GST_SEEK_TYPE_SET;
 352     stop = -1;
 353     stop_type = GST_SEEK_TYPE_SET;
 354   }
 355 
 356   /* get flush flag */
 357   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 358 
 359   if (aiff-&gt;streaming &amp;&amp; !starting) {
 360     GstEvent *new_event;
 361 
 362     /* streaming seek */
 363     if ((start_type != GST_SEEK_TYPE_NONE)) {
 364       /* bring offset to bytes, if the bps is 0, we have the segment in BYTES and
 365        * we can just copy the position. If not, we use the bps to convert TIME to
 366        * bytes. */
 367       if (aiff-&gt;bps &gt; 0)
 368         start =
 369             gst_util_uint64_scale_ceil (start, (guint64) aiff-&gt;bps, GST_SECOND);
 370       start -= (start % aiff-&gt;bytes_per_sample);
 371       start += aiff-&gt;datastart;
 372     }
 373 
 374     if (stop_type != GST_SEEK_TYPE_NONE) {
 375       if (aiff-&gt;bps &gt; 0)
 376         stop =
 377             gst_util_uint64_scale_ceil (stop, (guint64) aiff-&gt;bps, GST_SECOND);
 378       stop -= (stop % aiff-&gt;bytes_per_sample);
 379       stop += aiff-&gt;datastart;
 380     }
 381 
 382     /* make sure filesize is not exceeded due to rounding errors or so,
 383      * same precaution as in _stream_headers */
 384     if (gst_pad_peer_query_duration (aiff-&gt;sinkpad, GST_FORMAT_BYTES,
 385             &amp;upstream_size))
 386       stop = MIN (stop, upstream_size);
 387 
 388     if (stop &gt;= 0 &amp;&amp; stop &lt;= start)
 389       stop = start;
 390 
 391     new_event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags,
 392         start_type, start, stop_type, stop);
 393 
 394     res = gst_pad_push_event (aiff-&gt;sinkpad, new_event);
 395   } else {
 396     /* now we need to make sure the streaming thread is stopped. We do this by
 397      * either sending a FLUSH_START event downstream which will cause the
 398      * streaming thread to stop with a FLUSHING.
 399      * For a non-flushing seek we simply pause the task, which will happen as soon
 400      * as it completes one iteration (and thus might block when the sink is
 401      * blocking in preroll). */
 402     if (flush) {
 403       GST_DEBUG_OBJECT (aiff, &quot;sending flush start&quot;);
 404       gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_flush_start ());
 405     } else {
 406       gst_pad_pause_task (aiff-&gt;sinkpad);
 407     }
 408 
 409     /* we should now be able to grab the streaming thread because we stopped it
 410      * with the above flush/pause code */
 411     GST_PAD_STREAM_LOCK (aiff-&gt;sinkpad);
 412 
 413     /* save current position */
 414     position = aiff-&gt;segment.position;
 415 
 416     GST_DEBUG_OBJECT (aiff, &quot;stopped streaming at %&quot; G_GINT64_FORMAT, position);
 417 
 418     /* copy segment, we need this because we still need the old
 419      * segment when we close the current segment. */
 420     memcpy (&amp;seeksegment, &amp;aiff-&gt;segment, sizeof (GstSegment));
 421 
 422     /* configure the seek parameters in the seeksegment. We will then have the
 423      * right values in the segment to perform the seek */
 424     if (event) {
 425       GST_DEBUG_OBJECT (aiff, &quot;configuring seek&quot;);
 426       gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 427           start_type, start, stop_type, stop, &amp;update);
 428     }
 429 
 430     /* figure out the last position we need to play. If it&#39;s configured (stop !=
 431      * -1), use that, else we play until the total duration of the file */
 432     if ((stop = seeksegment.stop) == -1)
 433       stop = seeksegment.duration;
 434 
 435     GST_DEBUG_OBJECT (aiff, &quot;start_type =%d&quot;, start_type);
 436     if ((start_type != GST_SEEK_TYPE_NONE)) {
 437       /* bring offset to bytes, if the bps is 0, we have the segment in BYTES and
 438        * we can just copy the position. If not, we use the bps to convert TIME to
 439        * bytes. */
 440       if (aiff-&gt;bps &gt; 0)
 441         aiff-&gt;offset =
 442             gst_util_uint64_scale_ceil (seeksegment.position,
 443             (guint64) aiff-&gt;bps, GST_SECOND);
 444       else
 445         aiff-&gt;offset = seeksegment.position;
 446       GST_LOG_OBJECT (aiff, &quot;offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;offset);
 447       aiff-&gt;offset -= (aiff-&gt;offset % aiff-&gt;bytes_per_sample);
 448       GST_LOG_OBJECT (aiff, &quot;offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;offset);
 449       aiff-&gt;offset += aiff-&gt;datastart;
 450       GST_LOG_OBJECT (aiff, &quot;offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;offset);
 451     } else {
 452       GST_LOG_OBJECT (aiff, &quot;continue from offset=%&quot; G_GUINT64_FORMAT,
 453           aiff-&gt;offset);
 454     }
 455 
 456     if (stop_type != GST_SEEK_TYPE_NONE) {
 457       if (aiff-&gt;bps &gt; 0)
 458         aiff-&gt;end_offset =
 459             gst_util_uint64_scale_ceil (stop, (guint64) aiff-&gt;bps, GST_SECOND);
 460       else
 461         aiff-&gt;end_offset = stop;
 462       GST_LOG_OBJECT (aiff, &quot;end_offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;end_offset);
 463       aiff-&gt;end_offset -= (aiff-&gt;end_offset % aiff-&gt;bytes_per_sample);
 464       GST_LOG_OBJECT (aiff, &quot;end_offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;end_offset);
 465       aiff-&gt;end_offset += aiff-&gt;datastart;
 466       GST_LOG_OBJECT (aiff, &quot;end_offset=%&quot; G_GUINT64_FORMAT, aiff-&gt;end_offset);
 467     } else {
 468       GST_LOG_OBJECT (aiff, &quot;continue to end_offset=%&quot; G_GUINT64_FORMAT,
 469           aiff-&gt;end_offset);
 470     }
 471 
 472     /* make sure filesize is not exceeded due to rounding errors or so,
 473      * same precaution as in _stream_headers */
 474     if (gst_pad_peer_query_duration (aiff-&gt;sinkpad, GST_FORMAT_BYTES,
 475             &amp;upstream_size))
 476       aiff-&gt;end_offset = MIN (aiff-&gt;end_offset, upstream_size);
 477 
 478     /* this is the range of bytes we will use for playback */
 479     aiff-&gt;offset = MIN (aiff-&gt;offset, aiff-&gt;end_offset);
 480     aiff-&gt;dataleft = aiff-&gt;end_offset - aiff-&gt;offset;
 481 
 482     GST_DEBUG_OBJECT (aiff,
 483         &quot;seek: rate %lf, offset %&quot; G_GUINT64_FORMAT &quot;, end %&quot; G_GUINT64_FORMAT
 484         &quot;, segment %&quot; GST_TIME_FORMAT &quot; -- %&quot; GST_TIME_FORMAT, rate,
 485         aiff-&gt;offset, aiff-&gt;end_offset, GST_TIME_ARGS (seeksegment.start),
 486         GST_TIME_ARGS (stop));
 487 
 488     /* prepare for streaming again */
 489     if (flush) {
 490       /* if we sent a FLUSH_START, we now send a FLUSH_STOP */
 491       GST_DEBUG_OBJECT (aiff, &quot;sending flush stop&quot;);
 492       gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_flush_stop (TRUE));
 493     }
 494 
 495     /* now we did the seek and can activate the new segment values */
 496     memcpy (&amp;aiff-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 497 
 498     /* if we&#39;re doing a segment seek, post a SEGMENT_START message */
 499     if (aiff-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 500       gst_element_post_message (GST_ELEMENT_CAST (aiff),
 501           gst_message_new_segment_start (GST_OBJECT_CAST (aiff),
 502               aiff-&gt;segment.format, aiff-&gt;segment.position));
 503     }
 504 
 505     /* now create the segment */
 506     GST_DEBUG_OBJECT (aiff, &quot;Creating segment from %&quot; G_GINT64_FORMAT
 507         &quot; to %&quot; G_GINT64_FORMAT, aiff-&gt;segment.position, stop);
 508 
 509     /* store the segment event so it can be sent from the streaming thread. */
 510     if (aiff-&gt;start_segment)
 511       gst_event_unref (aiff-&gt;start_segment);
 512     aiff-&gt;start_segment = gst_event_new_segment (&amp;aiff-&gt;segment);
 513 
 514     /* mark discont if we are going to stream from another position. */
 515     if (position != aiff-&gt;segment.position) {
 516       GST_DEBUG_OBJECT (aiff,
 517           &quot;mark DISCONT, we did a seek to another position&quot;);
 518       aiff-&gt;discont = TRUE;
 519     }
 520 
 521     /* and start the streaming task again */
 522     aiff-&gt;segment_running = TRUE;
 523     if (!aiff-&gt;streaming) {
 524       gst_pad_start_task (aiff-&gt;sinkpad, (GstTaskFunction) gst_aiff_parse_loop,
 525           aiff-&gt;sinkpad, NULL);
 526     }
 527 
 528     GST_PAD_STREAM_UNLOCK (aiff-&gt;sinkpad);
 529 
 530     res = TRUE;
 531   }
 532 
 533   return res;
 534 
 535   /* ERRORS */
 536 negative_rate:
 537   {
 538     GST_DEBUG_OBJECT (aiff, &quot;negative playback rates are not supported yet.&quot;);
 539     return FALSE;
 540   }
 541 no_format:
 542   {
 543     GST_DEBUG_OBJECT (aiff, &quot;unsupported format given, seek aborted.&quot;);
 544     return FALSE;
 545   }
 546 }
 547 
 548 /*
 549  * gst_aiff_parse_peek_chunk_info:
 550  * @aiff AIFFparse object
 551  * @tag holder for tag
 552  * @size holder for tag size
 553  *
 554  * Peek next chunk info (tag and size)
 555  *
 556  * Returns: %TRUE when the chunk info (header) is available
 557  */
 558 static gboolean
 559 gst_aiff_parse_peek_chunk_info (GstAiffParse * aiff, guint32 * tag,
 560     guint32 * size)
 561 {
 562   const guint8 *data = NULL;
 563 
 564   if (gst_adapter_available (aiff-&gt;adapter) &lt; 8)
 565     return FALSE;
 566 
 567   data = gst_adapter_map (aiff-&gt;adapter, 8);
 568   *tag = GST_READ_UINT32_LE (data);
 569   *size = GST_READ_UINT32_BE (data + 4);
 570   gst_adapter_unmap (aiff-&gt;adapter);
 571 
 572   GST_DEBUG_OBJECT (aiff,
 573       &quot;Next chunk size is %d bytes, type %&quot; GST_FOURCC_FORMAT, *size,
 574       GST_FOURCC_ARGS (*tag));
 575 
 576   return TRUE;
 577 }
 578 
 579 /*
 580  * gst_aiff_parse_peek_chunk:
 581  * @aiff AIFFparse object
 582  * @tag holder for tag
 583  * @size holder for tag size
 584  *
 585  * Peek enough data for one full chunk
 586  *
 587  * Returns: %TRUE when the full chunk is available
 588  */
 589 static gboolean
 590 gst_aiff_parse_peek_chunk (GstAiffParse * aiff, guint32 * tag, guint32 * size)
 591 {
 592   guint32 peek_size = 0;
 593   guint available;
 594 
 595   if (!gst_aiff_parse_peek_chunk_info (aiff, tag, size))
 596     return FALSE;
 597 
 598   GST_DEBUG_OBJECT (aiff, &quot;Need to peek chunk of %d bytes&quot;, *size);
 599   peek_size = (*size + 1) &amp; ~1;
 600 
 601   available = gst_adapter_available (aiff-&gt;adapter);
 602   if (available &gt;= (8 + peek_size)) {
 603     return TRUE;
 604   } else {
 605     GST_LOG_OBJECT (aiff, &quot;but only %u bytes available now&quot;, available);
 606     return FALSE;
 607   }
 608 }
 609 
 610 static gboolean
 611 gst_aiff_parse_peek_data (GstAiffParse * aiff, guint32 size,
 612     const guint8 ** data)
 613 {
 614   if (gst_adapter_available (aiff-&gt;adapter) &lt; size)
 615     return FALSE;
 616 
 617   *data = gst_adapter_map (aiff-&gt;adapter, size);
 618   return TRUE;
 619 }
 620 
 621 /*
 622  * gst_aiff_parse_calculate_duration:
 623  * @aiff: aiffparse object
 624  *
 625  * Calculate duration on demand and store in @aiff.
 626  *
 627  * Returns: %TRUE if duration is available.
 628  */
 629 static gboolean
 630 gst_aiff_parse_calculate_duration (GstAiffParse * aiff)
 631 {
 632   if (aiff-&gt;duration &gt; 0)
 633     return TRUE;
 634 
 635   if (aiff-&gt;datasize &gt; 0 &amp;&amp; aiff-&gt;bps &gt; 0) {
 636     aiff-&gt;duration =
 637         gst_util_uint64_scale_ceil (aiff-&gt;datasize, GST_SECOND,
 638         (guint64) aiff-&gt;bps);
 639     GST_INFO_OBJECT (aiff, &quot;Got duration %&quot; GST_TIME_FORMAT,
 640         GST_TIME_ARGS (aiff-&gt;duration));
 641     return TRUE;
 642   }
 643   return FALSE;
 644 }
 645 
<a name="1" id="anc1"></a><span class="line-modified"> 646 static gboolean</span>
 647 gst_aiff_parse_ignore_chunk (GstAiffParse * aiff, guint32 tag, guint32 size)
 648 {
 649 #ifdef GSTREAMER_LITE
 650     guint64 flush;
 651 #else
 652     guint flush;
 653 #endif
 654 
 655   if (aiff-&gt;streaming) {
<a name="2" id="anc2"></a><span class="line-modified"> 656     if (!gst_aiff_parse_peek_chunk (aiff, &amp;tag, &amp;size)) {</span>
<span class="line-modified"> 657       GST_LOG_OBJECT (aiff, &quot;Not enough data to skip tag %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added"> 658           GST_FOURCC_ARGS (tag));</span>
<span class="line-added"> 659       return FALSE;</span>
<span class="line-added"> 660     }</span>
 661   }
 662   GST_WARNING_OBJECT (aiff, &quot;Ignoring tag %&quot; GST_FOURCC_FORMAT,
 663       GST_FOURCC_ARGS (tag));
 664 #ifdef GSTREAMER_LITE
 665   flush = 8 + (((guint64)size + 1) &amp; ~1);
 666 #else
 667   flush = 8 + ((size + 1) &amp; ~1);
 668 #endif
 669   aiff-&gt;offset += flush;
 670   if (aiff-&gt;streaming) {
 671     gst_adapter_flush (aiff-&gt;adapter, flush);
 672   }
<a name="3" id="anc3"></a><span class="line-added"> 673   return TRUE;</span>
 674 }
 675 
 676 static double
 677 gst_aiff_parse_read_IEEE80 (guint8 * buf)
 678 {
 679   int s = buf[0] &amp; 0xff;
 680   int e = ((buf[0] &amp; 0x7f) &lt;&lt; 8) | (buf[1] &amp; 0xff);
 681   double f = ((unsigned long) (buf[2] &amp; 0xff) &lt;&lt; 24) |
 682       ((buf[3] &amp; 0xff) &lt;&lt; 16) | ((buf[4] &amp; 0xff) &lt;&lt; 8) | (buf[5] &amp; 0xff);
 683 
 684   if (e == 32767) {
 685     if (buf[2] &amp; 0x80)
 686       return HUGE_VAL;          /* Really NaN, but this won&#39;t happen in reality */
 687     else {
 688       if (s)
 689         return -HUGE_VAL;
 690       else
 691         return HUGE_VAL;
 692     }
 693   }
 694 
 695   f = ldexp (f, 32);
 696   f += ((buf[6] &amp; 0xff) &lt;&lt; 24) |
 697       ((buf[7] &amp; 0xff) &lt;&lt; 16) | ((buf[8] &amp; 0xff) &lt;&lt; 8) | (buf[9] &amp; 0xff);
 698 
 699   return ldexp (f, e - 16446);
 700 }
 701 
 702 static gboolean
 703 gst_aiff_parse_parse_comm (GstAiffParse * aiff, GstBuffer * buf)
 704 {
 705   int size;
 706   GstMapInfo info;
 707   guint32 fourcc;
 708 
 709   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ)) {
 710     GST_WARNING_OBJECT (aiff, &quot;Can&#39;t map buffer&quot;);
 711     gst_buffer_unref (buf);
 712     return FALSE;
 713   }
 714 
 715   if (aiff-&gt;is_aifc)
 716     size = 22;
 717   else
 718     size = 18;
 719 
 720   if (info.size &lt; size)
 721     goto too_small;
 722 
 723   aiff-&gt;channels = GST_READ_UINT16_BE (info.data);
 724   aiff-&gt;total_frames = GST_READ_UINT32_BE (info.data + 2);
 725   aiff-&gt;depth = GST_READ_UINT16_BE (info.data + 6);
 726   aiff-&gt;width = GST_ROUND_UP_8 (aiff-&gt;depth);
 727   aiff-&gt;rate = (int) gst_aiff_parse_read_IEEE80 (info.data + 8);
 728 
 729   aiff-&gt;floating_point = FALSE;
 730 
 731   if (aiff-&gt;is_aifc) {
 732     fourcc = GST_READ_UINT32_LE (info.data + 18);
 733 
 734     /* We only support the &#39;trivial&#39; uncompressed AIFC, but it can be
 735      * either big or little endian */
 736     switch (fourcc) {
 737       case GST_MAKE_FOURCC (&#39;N&#39;, &#39;O&#39;, &#39;N&#39;, &#39;E&#39;):
 738         aiff-&gt;endianness = G_BIG_ENDIAN;
 739         break;
 740       case GST_MAKE_FOURCC (&#39;s&#39;, &#39;o&#39;, &#39;w&#39;, &#39;t&#39;):
 741         aiff-&gt;endianness = G_LITTLE_ENDIAN;
 742         break;
 743       case GST_MAKE_FOURCC (&#39;F&#39;, &#39;L&#39;, &#39;3&#39;, &#39;2&#39;):
 744       case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;):
 745         aiff-&gt;floating_point = TRUE;
 746         aiff-&gt;width = aiff-&gt;depth = 32;
 747         aiff-&gt;endianness = G_BIG_ENDIAN;
 748         break;
 749       case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;6&#39;, &#39;4&#39;):
 750         aiff-&gt;floating_point = TRUE;
 751         aiff-&gt;width = aiff-&gt;depth = 64;
 752         aiff-&gt;endianness = G_BIG_ENDIAN;
 753         break;
 754       default:
 755         goto unknown_compression;
 756     }
 757   } else
 758     aiff-&gt;endianness = G_BIG_ENDIAN;
 759 
 760   gst_buffer_unmap (buf, &amp;info);
 761   gst_buffer_unref (buf);
 762 
 763   return TRUE;
 764 
 765   /* ERRORS */
 766 too_small:
 767   {
 768     GST_WARNING_OBJECT (aiff, &quot;COMM chunk too short, cannot parse header&quot;);
 769     gst_buffer_unmap (buf, &amp;info);
 770     gst_buffer_unref (buf);
 771     return FALSE;
 772   }
 773 unknown_compression:
 774   {
 775     GST_WARNING_OBJECT (aiff, &quot;Unsupported compression in AIFC &quot;
 776         &quot;file: %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
 777     gst_buffer_unmap (buf, &amp;info);
 778     gst_buffer_unref (buf);
 779     return FALSE;
 780   }
 781 }
 782 
 783 static GstFlowReturn
 784 gst_aiff_parse_read_chunk (GstAiffParse * aiff, guint64 * offset, guint32 * tag,
 785     GstBuffer ** data)
 786 {
 787   guint size;
 788   GstFlowReturn res;
 789   GstBuffer *buf = NULL;
 790   GstMapInfo info;
 791 
 792   if ((res =
 793           gst_pad_pull_range (aiff-&gt;sinkpad, *offset, 8, &amp;buf)) != GST_FLOW_OK)
 794     return res;
 795 
 796   gst_buffer_map (buf, &amp;info, GST_MAP_READ);
 797   *tag = GST_READ_UINT32_LE (info.data);
 798   size = GST_READ_UINT32_BE (info.data + 4);
 799   gst_buffer_unmap (buf, &amp;info);
 800   gst_buffer_unref (buf);
 801   buf = NULL;
 802 
 803   if ((res =
 804           gst_pad_pull_range (aiff-&gt;sinkpad, (*offset) + 8, size,
 805               &amp;buf)) != GST_FLOW_OK)
 806     return res;
 807   else if (gst_buffer_get_size (buf) &lt; size)
 808     goto too_small;
 809 
 810   *data = buf;
 811   *offset += 8 + GST_ROUND_UP_2 (size);
 812 
 813   return GST_FLOW_OK;
 814 
 815   /* ERRORS */
 816 too_small:
 817   {
 818     /* short read, we return EOS to mark the EOS case */
 819     GST_DEBUG_OBJECT (aiff,
 820         &quot;not enough data (available=%&quot; G_GSIZE_FORMAT &quot;, needed=%u)&quot;,
 821         gst_buffer_get_size (buf), size);
 822     gst_buffer_unref (buf);
 823     return GST_FLOW_EOS;
 824   }
 825 
 826 }
 827 
 828 #define _P(pos) (G_GUINT64_CONSTANT (1) &lt;&lt; GST_AUDIO_CHANNEL_POSITION_ ##pos)
 829 
 830 static GstCaps *
 831 gst_aiff_parse_create_caps (GstAiffParse * aiff)
 832 {
 833   GstCaps *caps = NULL;
 834   const gchar *format = NULL;
 835   guint64 channel_mask;
 836 
 837   if (aiff-&gt;floating_point) {
 838     if (aiff-&gt;endianness == G_BIG_ENDIAN) {
 839       if (aiff-&gt;width == 32)
 840         format = &quot;F32BE&quot;;
 841       else if (aiff-&gt;width == 64)
 842         format = &quot;F64BE&quot;;
 843     }
 844   } else {
 845     if (aiff-&gt;endianness == G_BIG_ENDIAN) {
 846       if (aiff-&gt;width == 8)
 847         format = &quot;S8&quot;;
 848       else if (aiff-&gt;width == 16)
 849         format = &quot;S16BE&quot;;
 850       else if (aiff-&gt;width == 24)
 851         format = &quot;S24BE&quot;;
 852       else if (aiff-&gt;width == 32)
 853         format = &quot;S32BE&quot;;
 854     } else {
 855       if (aiff-&gt;width == 8)
 856         format = &quot;S8&quot;;
 857       else if (aiff-&gt;width == 16)
 858         format = &quot;S16LE&quot;;
 859       else if (aiff-&gt;width == 24)
 860         format = &quot;S24LE&quot;;
 861       else if (aiff-&gt;width == 32)
 862         format = &quot;S32LE&quot;;
 863     }
 864   }
 865   if (format) {
 866     caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
 867         &quot;format&quot;, G_TYPE_STRING, format,
 868         &quot;channels&quot;, G_TYPE_INT, aiff-&gt;channels,
 869         &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
 870         &quot;rate&quot;, G_TYPE_INT, aiff-&gt;rate, NULL);
 871   }
 872 
 873   if (aiff-&gt;channels &gt; 2) {
 874     GST_FIXME_OBJECT (aiff, &quot;using fallback channel layout for %d channels&quot;,
 875         aiff-&gt;channels);
 876 
 877     /* based on AIFF-1.3.pdf */
 878     switch (aiff-&gt;channels) {
 879       case 1:
 880         channel_mask = 0;
 881         break;
 882       case 2:
 883         channel_mask = _P (FRONT_LEFT) | _P (FRONT_RIGHT);
 884         break;
 885       case 3:
 886         channel_mask = _P (FRONT_LEFT) | _P (FRONT_RIGHT) | _P (FRONT_CENTER);
 887         break;
 888       case 4:
 889         /* lists both this and &#39;quad&#39; but doesn&#39;t say how to distinguish the two */
 890         channel_mask =
 891             _P (FRONT_LEFT) | _P (FRONT_RIGHT) | _P (REAR_LEFT) |
 892             _P (REAR_RIGHT);
 893         break;
 894       case 6:
 895         channel_mask =
 896             _P (FRONT_LEFT) | _P (FRONT_LEFT_OF_CENTER) | _P (FRONT_CENTER) |
 897             _P (FRONT_RIGHT) | _P (FRONT_RIGHT_OF_CENTER) | _P (LFE1);
 898         break;
 899       default:
 900         channel_mask = gst_audio_channel_get_fallback_mask (aiff-&gt;channels);
 901         break;
 902     }
 903 
 904 
 905     if (channel_mask != 0) {
 906       gst_caps_set_simple (caps, &quot;channel-mask&quot;, GST_TYPE_BITMASK, channel_mask,
 907           NULL);
 908     }
 909   }
 910 
 911   GST_DEBUG_OBJECT (aiff, &quot;Created caps: %&quot; GST_PTR_FORMAT, caps);
 912 
 913   return caps;
 914 }
 915 
 916 static GstFlowReturn
 917 gst_aiff_parse_stream_headers (GstAiffParse * aiff)
 918 {
 919   GstFlowReturn res;
 920   GstBuffer *buf = NULL;
 921   guint32 tag, size;
 922   gboolean gotdata = FALSE;
 923   gboolean done = FALSE;
 924   GstEvent **event_p;
 925   gint64 upstream_size = 0;
 926 
 927   gst_pad_peer_query_duration (aiff-&gt;sinkpad, GST_FORMAT_BYTES, &amp;upstream_size);
 928   GST_DEBUG_OBJECT (aiff, &quot;upstream size %&quot; G_GUINT64_FORMAT, upstream_size);
 929 
 930   /* loop headers until we get data */
 931   while (!done) {
 932     if (aiff-&gt;streaming) {
 933       if (!gst_aiff_parse_peek_chunk_info (aiff, &amp;tag, &amp;size))
 934         return GST_FLOW_OK;
 935     } else {
 936       GstMapInfo info;
 937 
 938       if ((res =
 939               gst_pad_pull_range (aiff-&gt;sinkpad, aiff-&gt;offset, 8,
 940                   &amp;buf)) != GST_FLOW_OK)
 941         goto header_read_error;
 942 
 943       gst_buffer_map (buf, &amp;info, GST_MAP_READ);
 944       tag = GST_READ_UINT32_LE (info.data);
 945       size = GST_READ_UINT32_BE (info.data + 4);
 946       gst_buffer_unmap (buf, &amp;info);
 947       gst_buffer_unref (buf);
 948       buf = NULL;
 949     }
 950 
 951     GST_INFO_OBJECT (aiff,
 952         &quot;Got TAG: %&quot; GST_FOURCC_FORMAT &quot;, offset %&quot; G_GUINT64_FORMAT,
 953         GST_FOURCC_ARGS (tag), aiff-&gt;offset);
 954 
 955     /* We just keep reading chunks until we find the one we&#39;re interested in.
 956      */
 957     switch (tag) {
 958       case GST_MAKE_FOURCC (&#39;C&#39;, &#39;O&#39;, &#39;M&#39;, &#39;M&#39;):{
 959         GstCaps *caps;
 960         GstEvent *event;
 961         gchar *stream_id;
 962 
 963         if (aiff-&gt;streaming) {
 964           if (!gst_aiff_parse_peek_chunk (aiff, &amp;tag, &amp;size))
 965             return GST_FLOW_OK;
 966 
 967           gst_adapter_flush (aiff-&gt;adapter, 8);
 968           aiff-&gt;offset += 8;
 969 
 970           buf = gst_adapter_take_buffer (aiff-&gt;adapter, size);
 971           aiff-&gt;offset += size;
 972         } else {
 973           if ((res = gst_aiff_parse_read_chunk (aiff,
 974                       &amp;aiff-&gt;offset, &amp;tag, &amp;buf)) != GST_FLOW_OK)
 975             return res;
 976         }
 977 
 978         if (!gst_aiff_parse_parse_comm (aiff, buf))
 979           goto parse_header_error;
 980 
 981         /* do sanity checks of header fields */
 982         if (aiff-&gt;channels == 0)
 983           goto no_channels;
 984         if (aiff-&gt;rate == 0)
 985           goto no_rate;
 986 
 987         stream_id =
 988             gst_pad_create_stream_id (aiff-&gt;srcpad, GST_ELEMENT_CAST (aiff),
 989             NULL);
 990         event = gst_event_new_stream_start (stream_id);
 991         gst_event_set_group_id (event, gst_util_group_id_next ());
 992         gst_pad_push_event (aiff-&gt;srcpad, event);
 993         g_free (stream_id);
 994 
 995         GST_DEBUG_OBJECT (aiff, &quot;creating the caps&quot;);
 996 
 997         caps = gst_aiff_parse_create_caps (aiff);
 998         if (caps == NULL)
 999           goto unknown_format;
1000 
1001         gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_caps (caps));
1002         gst_caps_unref (caps);
1003 
1004         aiff-&gt;bytes_per_sample = aiff-&gt;channels * aiff-&gt;width / 8;
1005         aiff-&gt;bps = aiff-&gt;bytes_per_sample * aiff-&gt;rate;
1006 
1007         if (!aiff-&gt;tags)
1008           aiff-&gt;tags = gst_tag_list_new_empty ();
1009 
1010         {
1011           GstCaps *templ_caps = gst_pad_get_pad_template_caps (aiff-&gt;sinkpad);
1012           gst_pb_utils_add_codec_description_to_tag_list (aiff-&gt;tags,
1013               GST_TAG_CONTAINER_FORMAT, templ_caps);
1014           gst_caps_unref (templ_caps);
1015         }
1016 
1017         if (aiff-&gt;bps) {
1018           guint bitrate = aiff-&gt;bps * 8;
1019 
1020           GST_DEBUG_OBJECT (aiff, &quot;adding bitrate of %u bps to tag list&quot;,
1021               bitrate);
1022 
1023           /* At the moment, aiffparse only supports uncompressed PCM data.
1024            * Therefore, nominal, actual, minimum, maximum bitrate are the same.
1025            * XXX: If AIFF-C support is extended to include compression,
1026            * make sure that aiff-&gt;bps is set properly. */
1027           gst_tag_list_add (aiff-&gt;tags, GST_TAG_MERGE_REPLACE,
1028               GST_TAG_BITRATE, bitrate, GST_TAG_NOMINAL_BITRATE, bitrate,
1029               GST_TAG_MINIMUM_BITRATE, bitrate, GST_TAG_MAXIMUM_BITRATE,
1030               bitrate, NULL);
1031         }
1032 
1033         if (aiff-&gt;bytes_per_sample &lt;= 0)
1034           goto no_bytes_per_sample;
1035 
1036         aiff-&gt;got_comm = TRUE;
1037         break;
1038       }
1039       case GST_MAKE_FOURCC (&#39;S&#39;, &#39;S&#39;, &#39;N&#39;, &#39;D&#39;):{
1040         guint32 datasize;
1041 
1042         GST_DEBUG_OBJECT (aiff, &quot;Got &#39;SSND&#39; TAG, size : %d&quot;, size);
1043 
1044         /* Now, read the 8-byte header in the SSND chunk */
1045         if (aiff-&gt;streaming) {
1046           const guint8 *ssnddata = NULL;
1047 
1048           if (!gst_aiff_parse_peek_data (aiff, 16, &amp;ssnddata))
1049             return GST_FLOW_OK;
1050 
1051           aiff-&gt;ssnd_offset = GST_READ_UINT32_BE (ssnddata + 8);
1052           aiff-&gt;ssnd_blocksize = GST_READ_UINT32_BE (ssnddata + 12);
1053           gst_adapter_unmap (aiff-&gt;adapter);
1054           gst_adapter_flush (aiff-&gt;adapter, 16);
1055         } else {
1056           GstBuffer *ssndbuf = NULL;
1057           GstMapInfo info;
1058 
1059           if ((res =
1060                   gst_pad_pull_range (aiff-&gt;sinkpad, aiff-&gt;offset, 16,
1061                       &amp;ssndbuf)) != GST_FLOW_OK)
1062             goto header_read_error;
1063 
1064           gst_buffer_map (ssndbuf, &amp;info, GST_MAP_READ);
1065           aiff-&gt;ssnd_offset = GST_READ_UINT32_BE (info.data + 8);
1066           aiff-&gt;ssnd_blocksize = GST_READ_UINT32_BE (info.data + 12);
1067           gst_buffer_unmap (ssndbuf, &amp;info);
1068           gst_buffer_unref (ssndbuf);
1069         }
1070 
1071         gotdata = TRUE;
1072 
1073         /* 8 byte chunk header, 8 byte SSND header */
1074         aiff-&gt;offset += 16;
1075         datasize = size - 8;
1076 
1077         aiff-&gt;datastart = aiff-&gt;offset + aiff-&gt;ssnd_offset;
1078         /* file might be truncated */
1079         if (upstream_size) {
1080           size = MIN (datasize, (upstream_size - aiff-&gt;datastart));
1081         }
1082         aiff-&gt;datasize = (guint64) datasize;
1083         aiff-&gt;dataleft = (guint64) datasize;
1084         aiff-&gt;end_offset = datasize + aiff-&gt;datastart;
1085         if (!aiff-&gt;streaming) {
1086           /* We will continue looking at chunks until the end - to read tags,
1087            * etc. */
1088           aiff-&gt;offset += datasize;
1089         }
1090         GST_DEBUG_OBJECT (aiff, &quot;datasize = %d&quot;, datasize);
1091         if (aiff-&gt;streaming) {
1092           done = TRUE;
1093         }
1094         break;
1095       }
1096       case GST_MAKE_FOURCC (&#39;I&#39;, &#39;D&#39;, &#39;3&#39;, &#39; &#39;):{
1097         GstTagList *tags;
1098 
1099         if (aiff-&gt;streaming) {
1100           if (!gst_aiff_parse_peek_chunk (aiff, &amp;tag, &amp;size))
1101             return GST_FLOW_OK;
1102 
1103           gst_adapter_flush (aiff-&gt;adapter, 8);
1104           aiff-&gt;offset += 8;
1105 
1106           buf = gst_adapter_take_buffer (aiff-&gt;adapter, size);
1107         } else {
1108           if ((res = gst_aiff_parse_read_chunk (aiff,
1109                       &amp;aiff-&gt;offset, &amp;tag, &amp;buf)) != GST_FLOW_OK)
1110             return res;
1111         }
1112 
1113         GST_LOG_OBJECT (aiff, &quot;ID3 chunk of size %&quot; G_GSIZE_FORMAT,
1114             gst_buffer_get_size (buf));
1115 
1116         tags = gst_tag_list_from_id3v2_tag (buf);
1117         gst_buffer_unref (buf);
1118 
1119         GST_INFO_OBJECT (aiff, &quot;ID3 tags: %&quot; GST_PTR_FORMAT, tags);
1120 
1121         if (aiff-&gt;tags == NULL) {
1122           aiff-&gt;tags = tags;
1123         } else {
1124           gst_tag_list_insert (aiff-&gt;tags, tags, GST_TAG_MERGE_APPEND);
1125           gst_tag_list_unref (tags);
1126         }
1127         break;
1128       }
1129       case GST_MAKE_FOURCC (&#39;C&#39;, &#39;H&#39;, &#39;A&#39;, &#39;N&#39;):{
1130         GST_FIXME_OBJECT (aiff, &quot;Handle CHAN chunk with channel layouts&quot;);
<a name="4" id="anc4"></a><span class="line-modified">1131         if (!gst_aiff_parse_ignore_chunk (aiff, tag, size)) {</span>
<span class="line-added">1132           return GST_FLOW_OK;</span>
<span class="line-added">1133         }</span>
1134         break;
1135       }
1136       default:
<a name="5" id="anc5"></a><span class="line-modified">1137         if (!gst_aiff_parse_ignore_chunk (aiff, tag, size)) {</span>
<span class="line-added">1138           return GST_FLOW_OK;</span>
<span class="line-added">1139         }</span>
1140     }
1141 
1142     buf = NULL;
1143 
1144     if (upstream_size &amp;&amp; (aiff-&gt;offset &gt;= upstream_size)) {
1145       /* Now we have gone through the whole file */
1146       done = TRUE;
1147     }
1148   }
1149 
1150   /* We read all the chunks (in pull mode) or reached the SSND chunk
1151    * (in push mode). We must have both COMM and SSND now; error out
1152    * otherwise.
1153    */
1154   if (!aiff-&gt;got_comm) {
1155     GST_WARNING_OBJECT (aiff, &quot;Failed to find COMM chunk&quot;);
1156     goto no_header;
1157   }
1158   if (!gotdata) {
1159     GST_WARNING_OBJECT (aiff, &quot;Failed to find SSND chunk&quot;);
1160     goto no_data;
1161   }
1162 
1163   GST_DEBUG_OBJECT (aiff, &quot;Finished parsing headers&quot;);
1164 
1165   if (gst_aiff_parse_calculate_duration (aiff)) {
1166     gst_segment_init (&amp;aiff-&gt;segment, GST_FORMAT_TIME);
1167     aiff-&gt;segment.duration = aiff-&gt;duration;
1168   } else {
1169     /* no bitrate, let downstream peer do the math, we&#39;ll feed it bytes. */
1170     gst_segment_init (&amp;aiff-&gt;segment, GST_FORMAT_BYTES);
1171     aiff-&gt;segment.duration = aiff-&gt;datasize;
1172   }
1173 
1174   /* now we have all the info to perform a pending seek if any, if no
1175    * event, this will still do the right thing and it will also send
1176    * the right segment event downstream. */
1177   gst_aiff_parse_perform_seek (aiff, aiff-&gt;seek_event, TRUE);
1178   /* remove pending event */
1179   event_p = &amp;aiff-&gt;seek_event;
1180   gst_event_replace (event_p, NULL);
1181 
1182   /* we just started, we are discont */
1183   aiff-&gt;discont = TRUE;
1184 
1185   aiff-&gt;state = AIFF_PARSE_DATA;
1186 
1187   /* determine reasonable max buffer size,
1188    * that is, buffers not too small either size or time wise
1189    * so we do not end up with too many of them */
1190   /* var abuse */
1191   upstream_size = 0;
1192   gst_aiff_parse_time_to_bytepos (aiff, 40 * GST_MSECOND, &amp;upstream_size);
1193   aiff-&gt;max_buf_size = upstream_size;
1194   aiff-&gt;max_buf_size = MAX (aiff-&gt;max_buf_size, MAX_BUFFER_SIZE);
1195   if (aiff-&gt;bytes_per_sample &gt; 0)
1196     aiff-&gt;max_buf_size -= (aiff-&gt;max_buf_size % aiff-&gt;bytes_per_sample);
1197 
1198   GST_DEBUG_OBJECT (aiff, &quot;max buffer size %u&quot;, aiff-&gt;max_buf_size);
1199 
1200   return GST_FLOW_OK;
1201 
1202   /* ERROR */
1203 no_header:
1204   {
1205     GST_ELEMENT_ERROR (aiff, STREAM, TYPE_NOT_FOUND, (NULL),
1206         (&quot;Invalid AIFF header (no COMM found)&quot;));
1207     return GST_FLOW_ERROR;
1208   }
1209 no_data:
1210   {
1211     GST_ELEMENT_ERROR (aiff, STREAM, TYPE_NOT_FOUND, (NULL),
1212         (&quot;Invalid AIFF: no SSND found&quot;));
1213     return GST_FLOW_ERROR;
1214   }
1215 parse_header_error:
1216   {
1217     GST_ELEMENT_ERROR (aiff, STREAM, DEMUX, (NULL),
1218         (&quot;Couldn&#39;t parse audio header&quot;));
1219     return GST_FLOW_ERROR;
1220   }
1221 no_channels:
1222   {
1223     GST_ELEMENT_ERROR (aiff, STREAM, FAILED, (NULL),
1224         (&quot;Stream claims to contain no channels - invalid data&quot;));
1225     return GST_FLOW_ERROR;
1226   }
1227 no_rate:
1228   {
1229     GST_ELEMENT_ERROR (aiff, STREAM, FAILED, (NULL),
1230         (&quot;Stream with sample_rate == 0 - invalid data&quot;));
1231     return GST_FLOW_ERROR;
1232   }
1233 no_bytes_per_sample:
1234   {
1235     GST_ELEMENT_ERROR (aiff, STREAM, FAILED, (NULL),
1236         (&quot;Could not calculate bytes per sample - invalid data&quot;));
1237     return GST_FLOW_ERROR;
1238   }
1239 unknown_format:
1240   {
1241     GST_ELEMENT_ERROR (aiff, STREAM, TYPE_NOT_FOUND, (NULL),
1242         (&quot;No caps found for format 0x%x, %d channels, %d Hz&quot;,
1243             aiff-&gt;format, aiff-&gt;channels, aiff-&gt;rate));
1244     return GST_FLOW_ERROR;
1245   }
1246 header_read_error:
1247   {
1248     GST_ELEMENT_ERROR (aiff, STREAM, DEMUX, (NULL),
1249         (&quot;Couldn&#39;t read in header&quot;));
1250     return GST_FLOW_ERROR;
1251   }
1252 }
1253 
1254 /*
1255  * Read AIFF file tag when streaming
1256  */
1257 static GstFlowReturn
1258 gst_aiff_parse_parse_stream_init (GstAiffParse * aiff)
1259 {
1260   if (gst_adapter_available (aiff-&gt;adapter) &gt;= 12) {
1261     GstBuffer *tmp;
1262 
1263     /* _take flushes the data */
1264     tmp = gst_adapter_take_buffer (aiff-&gt;adapter, 12);
1265 
1266     GST_DEBUG_OBJECT (aiff, &quot;Parsing aiff header&quot;);
1267     if (!gst_aiff_parse_parse_file_header (aiff, tmp))
1268       return GST_FLOW_ERROR;
1269 
1270     aiff-&gt;offset += 12;
1271     /* Go to next state */
1272     aiff-&gt;state = AIFF_PARSE_HEADER;
1273   }
1274   return GST_FLOW_OK;
1275 }
1276 
1277 /* handle an event sent directly to the element.
1278  *
1279  * This event can be sent either in the READY state or the
1280  * &gt;READY state. The only event of interest really is the seek
1281  * event.
1282  *
1283  * In the READY state we can only store the event and try to
1284  * respect it when going to PAUSED. We assume we are in the
1285  * READY state when our parsing state != AIFF_PARSE_DATA.
1286  *
1287  * When we are steaming, we can simply perform the seek right
1288  * away.
1289  */
1290 static gboolean
1291 gst_aiff_parse_send_event (GstElement * element, GstEvent * event)
1292 {
1293   GstAiffParse *aiff = GST_AIFF_PARSE (element);
1294   gboolean res = FALSE;
1295   GstEvent **event_p;
1296 
1297   GST_DEBUG_OBJECT (aiff, &quot;received event %s&quot;, GST_EVENT_TYPE_NAME (event));
1298 
1299   switch (GST_EVENT_TYPE (event)) {
1300     case GST_EVENT_SEEK:
1301       if (aiff-&gt;state == AIFF_PARSE_DATA) {
1302         /* we can handle the seek directly when streaming data */
1303         res = gst_aiff_parse_perform_seek (aiff, event, FALSE);
1304       } else {
1305         GST_DEBUG_OBJECT (aiff, &quot;queuing seek for later&quot;);
1306 
1307         event_p = &amp;aiff-&gt;seek_event;
1308         gst_event_replace (event_p, event);
1309 
1310         /* we always return true */
1311         res = TRUE;
1312       }
1313       break;
1314     default:
1315       break;
1316   }
1317   gst_event_unref (event);
1318   return res;
1319 }
1320 
1321 static GstFlowReturn
1322 gst_aiff_parse_stream_data (GstAiffParse * aiff)
1323 {
1324   GstBuffer *buf = NULL;
1325   GstFlowReturn res = GST_FLOW_OK;
1326   guint64 desired, obtained;
1327   GstClockTime timestamp, next_timestamp, duration;
1328   guint64 pos, nextpos;
1329 
1330   if (aiff-&gt;bytes_per_sample &lt;= 0) {
1331     GST_ELEMENT_ERROR (aiff, STREAM, WRONG_TYPE, (NULL),
1332         (&quot;File is not a valid AIFF file (invalid bytes per sample)&quot;));
1333     return GST_FLOW_ERROR;
1334   }
1335 
1336 iterate_adapter:
1337   GST_LOG_OBJECT (aiff,
1338       &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT &quot; , dataleft: %&quot;
1339       G_GINT64_FORMAT, aiff-&gt;offset, aiff-&gt;end_offset, aiff-&gt;dataleft);
1340 
1341   /* Get the next n bytes and output them */
1342   if (aiff-&gt;dataleft == 0 || aiff-&gt;dataleft &lt; aiff-&gt;bytes_per_sample)
1343     goto found_eos;
1344 
1345   /* scale the amount of data by the segment rate so we get equal
1346    * amounts of data regardless of the playback rate */
1347   desired =
1348       MIN (gst_guint64_to_gdouble (aiff-&gt;dataleft),
1349       aiff-&gt;max_buf_size * ABS (aiff-&gt;segment.rate));
1350 
1351   if (desired &gt;= aiff-&gt;bytes_per_sample)
1352     desired -= (desired % aiff-&gt;bytes_per_sample);
1353 
1354 #ifdef GSTREAMER_LITE
1355   if (desired == 0) {
1356     GST_ELEMENT_ERROR (aiff, STREAM, DEMUX, (NULL),
1357               (&quot;Invalid stream&quot;));
1358     return GST_FLOW_ERROR;
1359   }
1360 #endif // GSTREAMER_LITE
1361 
1362   GST_LOG_OBJECT (aiff, &quot;Fetching %&quot; G_GINT64_FORMAT &quot; bytes of data &quot;
1363       &quot;from the sinkpad&quot;, desired);
1364 
1365   if (aiff-&gt;streaming) {
1366     guint avail = gst_adapter_available (aiff-&gt;adapter);
1367 
1368     if (avail &lt; desired) {
1369       GST_LOG_OBJECT (aiff, &quot;Got only %d bytes of data from the sinkpad&quot;,
1370           avail);
1371       return GST_FLOW_OK;
1372     }
1373 
1374     buf = gst_adapter_take_buffer (aiff-&gt;adapter, desired);
1375   } else {
1376     if ((res = gst_pad_pull_range (aiff-&gt;sinkpad, aiff-&gt;offset,
1377                 desired, &amp;buf)) != GST_FLOW_OK)
1378       goto pull_error;
1379   }
1380 
1381   /* If we have a pending close/start segment, send it now. */
1382   if (G_UNLIKELY (aiff-&gt;close_segment != NULL)) {
1383     gst_pad_push_event (aiff-&gt;srcpad, aiff-&gt;close_segment);
1384     aiff-&gt;close_segment = NULL;
1385   }
1386   if (G_UNLIKELY (aiff-&gt;start_segment != NULL)) {
1387     gst_pad_push_event (aiff-&gt;srcpad, aiff-&gt;start_segment);
1388     aiff-&gt;start_segment = NULL;
1389   }
1390   if (G_UNLIKELY (aiff-&gt;tags != NULL)) {
1391     gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_tag (aiff-&gt;tags));
1392     aiff-&gt;tags = NULL;
1393   }
1394 
1395   obtained = gst_buffer_get_size (buf);
1396 
1397   /* our positions in bytes */
1398   pos = aiff-&gt;offset - aiff-&gt;datastart;
1399   nextpos = pos + obtained;
1400 
1401   /* update offsets, does not overflow. */
1402   GST_BUFFER_OFFSET (buf) = pos / aiff-&gt;bytes_per_sample;
1403   GST_BUFFER_OFFSET_END (buf) = nextpos / aiff-&gt;bytes_per_sample;
1404 
1405   if (aiff-&gt;bps &gt; 0) {
1406     /* and timestamps if we have a bitrate, be careful for overflows */
1407     timestamp =
1408         gst_util_uint64_scale_ceil (pos, GST_SECOND, (guint64) aiff-&gt;bps);
1409     next_timestamp =
1410         gst_util_uint64_scale_ceil (nextpos, GST_SECOND, (guint64) aiff-&gt;bps);
1411     duration = next_timestamp - timestamp;
1412 
1413     /* update current running segment position */
1414     aiff-&gt;segment.position = next_timestamp;
1415   } else {
1416     /* no bitrate, all we know is that the first sample has timestamp 0, all
1417      * other positions and durations have unknown timestamp. */
1418     if (pos == 0)
1419       timestamp = 0;
1420     else
1421       timestamp = GST_CLOCK_TIME_NONE;
1422     duration = GST_CLOCK_TIME_NONE;
1423     /* update current running segment position with byte offset */
1424     aiff-&gt;segment.position = nextpos;
1425   }
1426   if (aiff-&gt;discont) {
1427     GST_DEBUG_OBJECT (aiff, &quot;marking DISCONT&quot;);
1428     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
1429     aiff-&gt;discont = FALSE;
1430   }
1431 
1432   GST_BUFFER_TIMESTAMP (buf) = timestamp;
1433   GST_BUFFER_DURATION (buf) = duration;
1434 
1435   GST_LOG_OBJECT (aiff,
1436       &quot;Got buffer. timestamp:%&quot; GST_TIME_FORMAT &quot; , duration:%&quot; GST_TIME_FORMAT
1437       &quot;, size:%&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (timestamp),
1438       GST_TIME_ARGS (duration), obtained);
1439 
1440   if ((res = gst_pad_push (aiff-&gt;srcpad, buf)) != GST_FLOW_OK)
1441     goto push_error;
1442 
1443   if (obtained &lt; aiff-&gt;dataleft) {
1444     aiff-&gt;offset += obtained;
1445     aiff-&gt;dataleft -= obtained;
1446   } else {
1447     aiff-&gt;offset += aiff-&gt;dataleft;
1448     aiff-&gt;dataleft = 0;
1449   }
1450 
1451   /* Iterate until need more data, so adapter size won&#39;t grow */
1452   if (aiff-&gt;streaming) {
1453     GST_LOG_OBJECT (aiff,
1454         &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT, aiff-&gt;offset,
1455         aiff-&gt;end_offset);
1456     goto iterate_adapter;
1457   }
1458   return res;
1459 
1460   /* ERROR */
1461 found_eos:
1462   {
1463     GST_DEBUG_OBJECT (aiff, &quot;found EOS&quot;);
1464     return GST_FLOW_EOS;
1465   }
1466 pull_error:
1467   {
1468     /* check if we got EOS */
1469     if (res == GST_FLOW_EOS)
1470       goto found_eos;
1471 
1472     GST_WARNING_OBJECT (aiff,
1473         &quot;Error getting %&quot; G_GINT64_FORMAT &quot; bytes from the &quot;
1474         &quot;sinkpad (dataleft = %&quot; G_GINT64_FORMAT &quot;)&quot;, desired, aiff-&gt;dataleft);
1475     return res;
1476   }
1477 push_error:
1478   {
1479     GST_INFO_OBJECT (aiff,
1480         &quot;Error pushing on srcpad %s:%s, reason %s, is linked? = %d&quot;,
1481         GST_DEBUG_PAD_NAME (aiff-&gt;srcpad), gst_flow_get_name (res),
1482         gst_pad_is_linked (aiff-&gt;srcpad));
1483     return res;
1484   }
1485 }
1486 
1487 static void
1488 gst_aiff_parse_loop (GstPad * pad)
1489 {
1490   GstFlowReturn ret;
1491   GstAiffParse *aiff = GST_AIFF_PARSE (GST_PAD_PARENT (pad));
1492 
1493   GST_LOG_OBJECT (aiff, &quot;process data&quot;);
1494 
1495   switch (aiff-&gt;state) {
1496     case AIFF_PARSE_START:
1497       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_START&quot;);
1498       if ((ret = gst_aiff_parse_stream_init (aiff)) != GST_FLOW_OK)
1499         goto pause;
1500 
1501       aiff-&gt;state = AIFF_PARSE_HEADER;
1502       /* fall-through */
1503 
1504     case AIFF_PARSE_HEADER:
1505       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_HEADER&quot;);
1506       if ((ret = gst_aiff_parse_stream_headers (aiff)) != GST_FLOW_OK)
1507         goto pause;
1508 
1509       aiff-&gt;state = AIFF_PARSE_DATA;
1510       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_DATA&quot;);
1511       /* fall-through */
1512 
1513     case AIFF_PARSE_DATA:
1514       if ((ret = gst_aiff_parse_stream_data (aiff)) != GST_FLOW_OK)
1515         goto pause;
1516       break;
1517     default:
1518       g_assert_not_reached ();
1519   }
1520   return;
1521 
1522   /* ERRORS */
1523 pause:
1524   {
1525     const gchar *reason = gst_flow_get_name (ret);
1526 
1527     GST_DEBUG_OBJECT (aiff, &quot;pausing task, reason %s&quot;, reason);
1528     aiff-&gt;segment_running = FALSE;
1529     gst_pad_pause_task (pad);
1530 
1531     if (ret == GST_FLOW_EOS) {
1532       /* perform EOS logic */
1533       if (aiff-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
1534         GstClockTime stop;
1535 
1536         if ((stop = aiff-&gt;segment.stop) == -1)
1537           stop = aiff-&gt;segment.duration;
1538 
1539         gst_element_post_message (GST_ELEMENT_CAST (aiff),
1540             gst_message_new_segment_done (GST_OBJECT_CAST (aiff),
1541                 aiff-&gt;segment.format, stop));
1542         gst_pad_push_event (aiff-&gt;srcpad,
1543             gst_event_new_segment_done (aiff-&gt;segment.format, stop));
1544       } else {
1545         gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_eos ());
1546       }
1547     } else if (ret &lt; GST_FLOW_EOS || ret == GST_FLOW_NOT_LINKED) {
1548       /* for fatal errors we post an error message, post the error
1549        * first so the app knows about the error first. */
1550       GST_ELEMENT_FLOW_ERROR (aiff, ret);
1551       gst_pad_push_event (aiff-&gt;srcpad, gst_event_new_eos ());
1552     }
1553     return;
1554   }
1555 }
1556 
1557 static GstFlowReturn
1558 gst_aiff_parse_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
1559 {
1560   GstFlowReturn ret;
1561   GstAiffParse *aiff = GST_AIFF_PARSE (parent);
1562 
1563   GST_LOG_OBJECT (aiff, &quot;adapter_push %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
1564       gst_buffer_get_size (buf));
1565 
1566   gst_adapter_push (aiff-&gt;adapter, buf);
1567 
1568   switch (aiff-&gt;state) {
1569     case AIFF_PARSE_START:
1570       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_START&quot;);
1571       if ((ret = gst_aiff_parse_parse_stream_init (aiff)) != GST_FLOW_OK)
1572         goto done;
1573 
1574       if (aiff-&gt;state != AIFF_PARSE_HEADER)
1575         break;
1576 
1577       /* otherwise fall-through */
1578     case AIFF_PARSE_HEADER:
1579       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_HEADER&quot;);
1580       if ((ret = gst_aiff_parse_stream_headers (aiff)) != GST_FLOW_OK)
1581         goto done;
1582 
1583       if (!aiff-&gt;got_comm || aiff-&gt;datastart == 0)
1584         break;
1585 
1586       aiff-&gt;state = AIFF_PARSE_DATA;
1587       GST_INFO_OBJECT (aiff, &quot;AIFF_PARSE_DATA&quot;);
1588 
1589       /* fall-through */
1590     case AIFF_PARSE_DATA:
1591       if ((ret = gst_aiff_parse_stream_data (aiff)) != GST_FLOW_OK)
1592         goto done;
1593       break;
1594     default:
1595       g_return_val_if_reached (GST_FLOW_ERROR);
1596   }
1597 done:
1598   return ret;
1599 }
1600 
1601 static gboolean
1602 gst_aiff_parse_pad_convert (GstPad * pad,
1603     GstFormat src_format, gint64 src_value,
1604     GstFormat * dest_format, gint64 * dest_value)
1605 {
1606   GstAiffParse *aiffparse;
1607   gboolean res = TRUE;
1608 
1609   aiffparse = GST_AIFF_PARSE (GST_PAD_PARENT (pad));
1610 
1611   if (*dest_format == src_format) {
1612     *dest_value = src_value;
1613     return TRUE;
1614   }
1615 
1616   if (aiffparse-&gt;bytes_per_sample &lt;= 0)
1617     return FALSE;
1618 
1619   GST_INFO_OBJECT (aiffparse, &quot;converting value from %s to %s&quot;,
1620       gst_format_get_name (src_format), gst_format_get_name (*dest_format));
1621 
1622   switch (src_format) {
1623     case GST_FORMAT_BYTES:
1624       switch (*dest_format) {
1625         case GST_FORMAT_DEFAULT:
1626           *dest_value = src_value / aiffparse-&gt;bytes_per_sample;
1627           break;
1628         case GST_FORMAT_TIME:
1629           if (aiffparse-&gt;bps &gt; 0) {
1630             *dest_value = gst_util_uint64_scale_ceil (src_value, GST_SECOND,
1631                 (guint64) aiffparse-&gt;bps);
1632             break;
1633           }
1634           /* Else fallthrough */
1635         default:
1636           res = FALSE;
1637           goto done;
1638       }
1639       break;
1640 
1641     case GST_FORMAT_DEFAULT:
1642       switch (*dest_format) {
1643         case GST_FORMAT_BYTES:
1644           *dest_value = src_value * aiffparse-&gt;bytes_per_sample;
1645           break;
1646         case GST_FORMAT_TIME:
1647           *dest_value = gst_util_uint64_scale (src_value, GST_SECOND,
1648               (guint64) aiffparse-&gt;rate);
1649           break;
1650         default:
1651           res = FALSE;
1652           goto done;
1653       }
1654       break;
1655 
1656     case GST_FORMAT_TIME:
1657       switch (*dest_format) {
1658         case GST_FORMAT_BYTES:
1659           if (aiffparse-&gt;bps &gt; 0) {
1660             *dest_value = gst_util_uint64_scale (src_value,
1661                 (guint64) aiffparse-&gt;bps, GST_SECOND);
1662             break;
1663           }
1664           /* Else fallthrough */
1665           break;
1666         case GST_FORMAT_DEFAULT:
1667           *dest_value = gst_util_uint64_scale (src_value,
1668               (guint64) aiffparse-&gt;rate, GST_SECOND);
1669           break;
1670         default:
1671           res = FALSE;
1672           goto done;
1673       }
1674       break;
1675 
1676     default:
1677       res = FALSE;
1678       goto done;
1679   }
1680 
1681 done:
1682   return res;
1683 
1684 }
1685 
1686 /* handle queries for location and length in requested format */
1687 static gboolean
1688 gst_aiff_parse_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
1689 {
1690   gboolean res = FALSE;
1691   GstAiffParse *aiff = GST_AIFF_PARSE (parent);
1692 
1693   switch (GST_QUERY_TYPE (query)) {
1694     case GST_QUERY_DURATION:
1695     {
1696       gint64 duration = 0;
1697       GstFormat format;
1698 
1699       /* only if we know */
1700       if (aiff-&gt;state != AIFF_PARSE_DATA)
1701         break;
1702 
1703       gst_query_parse_duration (query, &amp;format, NULL);
1704 
1705       switch (format) {
1706         case GST_FORMAT_TIME:{
1707           if ((res = gst_aiff_parse_calculate_duration (aiff))) {
1708             duration = aiff-&gt;duration;
1709           }
1710           break;
1711         }
1712         default:
1713           format = GST_FORMAT_BYTES;
1714           duration = aiff-&gt;datasize;
1715           break;
1716       }
1717       gst_query_set_duration (query, format, duration);
1718       break;
1719     }
1720     case GST_QUERY_CONVERT:
1721     {
1722       gint64 srcvalue, dstvalue;
1723       GstFormat srcformat, dstformat;
1724 
1725       /* only if we know */
1726       if (aiff-&gt;state != AIFF_PARSE_DATA)
1727         break;
1728 
1729       gst_query_parse_convert (query, &amp;srcformat, &amp;srcvalue,
1730           &amp;dstformat, &amp;dstvalue);
1731       res = gst_aiff_parse_pad_convert (pad, srcformat, srcvalue,
1732           &amp;dstformat, &amp;dstvalue);
1733       if (res)
1734         gst_query_set_convert (query, srcformat, srcvalue, dstformat, dstvalue);
1735       break;
1736     }
1737     case GST_QUERY_SEEKING:{
1738       GstFormat fmt;
1739 
1740       /* only if we know */
1741       if (aiff-&gt;state != AIFF_PARSE_DATA)
1742         break;
1743 
1744       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
1745       if (fmt == GST_FORMAT_TIME) {
1746         gboolean seekable = TRUE;
1747 
1748         if (!gst_aiff_parse_calculate_duration (aiff)) {
1749           seekable = FALSE;
1750         }
1751         gst_query_set_seeking (query, GST_FORMAT_TIME, seekable,
1752             0, aiff-&gt;duration);
1753         res = TRUE;
1754       }
1755       break;
1756     }
1757     default:
1758       res = gst_pad_query_default (pad, parent, query);
1759       break;
1760   }
1761   return res;
1762 }
1763 
1764 static gboolean
1765 gst_aiff_parse_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
1766 {
1767   GstAiffParse *aiffparse = GST_AIFF_PARSE (parent);
1768   gboolean res = FALSE;
1769 
1770   GST_DEBUG_OBJECT (aiffparse, &quot;%s event&quot;, GST_EVENT_TYPE_NAME (event));
1771 
1772   switch (GST_EVENT_TYPE (event)) {
1773     case GST_EVENT_SEEK:
1774       /* can only handle events when we are in the data state */
1775       if (aiffparse-&gt;state == AIFF_PARSE_DATA) {
1776         res = gst_aiff_parse_perform_seek (aiffparse, event, FALSE);
1777       }
1778       gst_event_unref (event);
1779       break;
1780     default:
1781       res = gst_pad_push_event (aiffparse-&gt;sinkpad, event);
1782       break;
1783   }
1784   return res;
1785 }
1786 
1787 static gboolean
1788 gst_aiff_parse_sink_activate (GstPad * sinkpad, GstObject * parent)
1789 {
1790   GstQuery *query;
1791   gboolean pull_mode;
1792 
1793   query = gst_query_new_scheduling ();
1794 
1795   if (!gst_pad_peer_query (sinkpad, query)) {
1796     gst_query_unref (query);
1797     goto activate_push;
1798   }
1799 
1800   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
1801       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
1802   gst_query_unref (query);
1803 
1804   if (!pull_mode)
1805     goto activate_push;
1806 
1807   GST_DEBUG_OBJECT (sinkpad, &quot;going to pull mode&quot;);
1808   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
1809 
1810 activate_push:
1811   {
1812     GST_DEBUG_OBJECT (sinkpad, &quot;going to push (streaming) mode&quot;);
1813     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
1814   }
1815 }
1816 
1817 
1818 static gboolean
1819 gst_aiff_parse_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
1820     GstPadMode mode, gboolean active)
1821 {
1822   gboolean res;
1823   GstAiffParse *aiff = GST_AIFF_PARSE (parent);
1824 
1825   if (aiff-&gt;adapter) {
1826     g_object_unref (aiff-&gt;adapter);
1827     aiff-&gt;adapter = NULL;
1828   }
1829 
1830   switch (mode) {
1831     case GST_PAD_MODE_PUSH:
1832       if (active) {
1833         aiff-&gt;streaming = TRUE;
1834         aiff-&gt;adapter = gst_adapter_new ();
1835       }
1836       res = TRUE;
1837       break;
1838     case GST_PAD_MODE_PULL:
1839       if (active) {
1840         aiff-&gt;streaming = FALSE;
1841         aiff-&gt;adapter = NULL;
1842         aiff-&gt;segment_running = TRUE;
1843         res =
1844             gst_pad_start_task (sinkpad, (GstTaskFunction) gst_aiff_parse_loop,
1845             sinkpad, NULL);
1846       } else {
1847         aiff-&gt;segment_running = FALSE;
1848         res = gst_pad_stop_task (sinkpad);
1849       }
1850       break;
1851     default:
1852       res = FALSE;
1853       break;
1854   }
1855   return res;
1856 };
1857 
1858 static GstFlowReturn
1859 gst_aiff_parse_flush_data (GstAiffParse * aiff)
1860 {
1861   GstFlowReturn ret = GST_FLOW_OK;
1862   guint av;
1863 
1864   if ((av = gst_adapter_available (aiff-&gt;adapter)) &gt; 0) {
1865     aiff-&gt;dataleft = av;
1866     aiff-&gt;end_offset = aiff-&gt;offset + av;
1867     ret = gst_aiff_parse_stream_data (aiff);
1868   }
1869 
1870   return ret;
1871 }
1872 
1873 
1874 static gboolean
1875 gst_aiff_parse_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
1876 {
1877   GstAiffParse *aiff = GST_AIFF_PARSE (parent);
1878   gboolean ret = TRUE;
1879 
1880   GST_DEBUG_OBJECT (aiff, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
1881 
1882   switch (GST_EVENT_TYPE (event)) {
1883     case GST_EVENT_CAPS:
1884     {
1885       /* discard, we&#39;ll come up with proper src caps */
1886       gst_event_unref (event);
1887       break;
1888     }
1889     case GST_EVENT_SEGMENT:
1890     {
1891       gint64 start, stop, offset = 0, end_offset = -1;
1892       GstSegment segment;
1893 
1894       /* some debug output */
1895       gst_event_copy_segment (event, &amp;segment);
1896       GST_DEBUG_OBJECT (aiff, &quot;received segment %&quot; GST_SEGMENT_FORMAT,
1897           &amp;segment);
1898 
1899       /* now we are either committed to TIME or BYTE format,
1900        * and we only expect a BYTE segment, e.g. following a seek */
1901       if (segment.format == GST_FORMAT_BYTES) {
1902         /* handle (un)signed issues */
1903         start = segment.start;
1904         stop = segment.stop;
1905         if (start &gt; 0) {
1906           offset = start;
1907           start -= aiff-&gt;datastart;
1908           start = MAX (start, 0);
1909         }
1910         if (stop &gt; 0) {
1911           end_offset = stop;
1912           stop -= aiff-&gt;datastart;
1913           stop = MAX (stop, 0);
1914         }
1915         if (aiff-&gt;state == AIFF_PARSE_DATA &amp;&amp;
1916             aiff-&gt;segment.format == GST_FORMAT_TIME) {
1917           /* operating in format TIME, so we can convert */
1918           if (aiff-&gt;bps) {
1919             if (start &gt;= 0)
1920               start =
1921                   gst_util_uint64_scale_ceil (start, GST_SECOND,
1922                   (guint64) aiff-&gt;bps);
1923             if (stop &gt;= 0)
1924               stop =
1925                   gst_util_uint64_scale_ceil (stop, GST_SECOND,
1926                   (guint64) aiff-&gt;bps);
1927           } else {
1928             GST_DEBUG_OBJECT (aiff, &quot;unable to compute segment start/stop&quot;);
1929             goto exit;
1930           }
1931         }
1932       } else {
1933         GST_DEBUG_OBJECT (aiff, &quot;unsupported segment format, ignoring&quot;);
1934         goto exit;
1935       }
1936 
1937       segment.start = start;
1938       segment.stop = stop;
1939 
1940       /* accept upstream&#39;s notion of segment and distribute along */
1941       if (aiff-&gt;state == AIFF_PARSE_DATA) {
1942         segment.format = aiff-&gt;segment.format;
1943         segment.time = segment.position = segment.start;
1944         segment.duration = aiff-&gt;segment.duration;
1945       }
1946 
1947       gst_segment_copy_into (&amp;segment, &amp;aiff-&gt;segment);
1948 
1949       if (aiff-&gt;start_segment)
1950         gst_event_unref (aiff-&gt;start_segment);
1951 
1952       aiff-&gt;start_segment = gst_event_new_segment (&amp;segment);
1953 
1954       /* If the seek is within the same SSND chunk and there is no new
1955        * end_offset defined keep the previous end_offset. This will avoid noise
1956        * at the end of playback if e.g. a metadata chunk is located at the end
1957        * of the file. */
1958       if (aiff-&gt;end_offset &gt; 0 &amp;&amp; offset &lt; aiff-&gt;end_offset &amp;&amp;
1959           offset &gt;= aiff-&gt;datastart &amp;&amp; end_offset == -1) {
1960         end_offset = aiff-&gt;end_offset;
1961       }
1962 
1963       /* stream leftover data in current segment */
1964       if (aiff-&gt;state == AIFF_PARSE_DATA)
1965         gst_aiff_parse_flush_data (aiff);
1966       /* and set up streaming thread for next one */
1967       aiff-&gt;offset = offset;
1968       aiff-&gt;end_offset = end_offset;
1969       if (aiff-&gt;end_offset &gt; 0) {
1970         aiff-&gt;dataleft = aiff-&gt;end_offset - aiff-&gt;offset;
1971       } else {
1972         /* infinity; upstream will EOS when done */
1973         aiff-&gt;dataleft = G_MAXUINT64;
1974       }
1975     exit:
1976       gst_event_unref (event);
1977       break;
1978     }
1979     case GST_EVENT_FLUSH_START:
1980       ret = gst_pad_push_event (aiff-&gt;srcpad, event);
1981       break;
1982     case GST_EVENT_FLUSH_STOP:
1983       ret = gst_pad_push_event (aiff-&gt;srcpad, event);
1984       gst_adapter_clear (aiff-&gt;adapter);
1985       break;
1986     default:
1987       ret = gst_pad_event_default (aiff-&gt;sinkpad, parent, event);
1988       break;
1989   }
1990 
1991   return ret;
1992 }
1993 
1994 static GstStateChangeReturn
1995 gst_aiff_parse_change_state (GstElement * element, GstStateChange transition)
1996 {
1997   GstStateChangeReturn ret;
1998   GstAiffParse *aiff = GST_AIFF_PARSE (element);
1999 
2000   switch (transition) {
2001     case GST_STATE_CHANGE_NULL_TO_READY:
2002       break;
2003     case GST_STATE_CHANGE_READY_TO_PAUSED:
2004       gst_aiff_parse_reset (aiff);
2005       break;
2006     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
2007       break;
2008     default:
2009       break;
2010   }
2011 
2012   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
2013 
2014   switch (transition) {
2015     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2016       break;
2017     case GST_STATE_CHANGE_PAUSED_TO_READY:
2018       gst_aiff_parse_reset (aiff);
2019       break;
2020     case GST_STATE_CHANGE_READY_TO_NULL:
2021       break;
2022     default:
2023       break;
2024   }
2025   return ret;
2026 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>