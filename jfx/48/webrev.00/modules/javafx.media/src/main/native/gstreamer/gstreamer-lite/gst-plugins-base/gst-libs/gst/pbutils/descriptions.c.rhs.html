<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/descriptions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer Plugins Base utils library source/sink/codec description support
   2  * Copyright (C) 2006 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstpbutilsdescriptions
  22  * @title: Descriptions
  23  * @short_description: Provides human-readable descriptions for caps/codecs
  24  * and encoder, decoder, URI source and URI sink elements
  25  *
  26  * The above functions provide human-readable strings for media formats
  27  * and decoder/demuxer/depayloader/encoder/muxer/payloader elements for use
  28  * in error dialogs or other messages shown to users.
  29  *
  30  * gst_pb_utils_add_codec_description_to_tag_list() is a utility function
  31  * for demuxer and decoder elements to add audio/video codec tags from a
  32  * given (fixed) #GstCaps.
  33  *
  34  */
  35 
  36 #ifdef HAVE_CONFIG_H
  37 # include &quot;config.h&quot;
  38 #endif
  39 
  40 #include &quot;gst/gst-i18n-plugin.h&quot;
  41 
  42 #include &lt;gst/audio/audio.h&gt;
  43 #include &lt;gst/video/video.h&gt;
  44 
  45 #include &quot;pbutils.h&quot;
  46 #include &quot;pbutils-private.h&quot;
  47 
  48 #include &lt;string.h&gt;
  49 
  50 typedef enum
  51 {
  52   FLAG_SYSTEMSTREAM = (1 &lt;&lt; 0), /* match record only if caps have systemstream=true   */
  53   FLAG_CONTAINER = (1 &lt;&lt; 1),    /* format is a container format (muxed)               */
  54   FLAG_AUDIO = (1 &lt;&lt; 2),        /* format is an audio format, or audio container/tag  */
  55   FLAG_VIDEO = (1 &lt;&lt; 3),        /* format is a video format, or video container/tag   */
  56   FLAG_IMAGE = (1 &lt;&lt; 4),        /* format is an image format, or image container/tag  */
  57   FLAG_SUB = (1 &lt;&lt; 5),          /* format is a subtitle format, or subtitle container */
  58   FLAG_TAG = (1 &lt;&lt; 6),          /* format is a tag/container                          */
  59   FLAG_GENERIC = (1 &lt;&lt; 7)       /* format is a generic container (e.g. multipart)     */
  60 } FormatFlags;
  61 
  62 typedef struct
  63 {
  64   const gchar *type;
  65   const gchar *desc;
  66   FormatFlags flags:24;
  67   gchar ext[5];                 /* file extension */
  68 } FormatInfo;
  69 
  70 #define AV_CONTAINER    (FLAG_CONTAINER | FLAG_AUDIO | FLAG_VIDEO)
  71 #define AVS_CONTAINER   (AV_CONTAINER | FLAG_SUB)
  72 #define AVI_CONTAINER   (AV_CONTAINER | FLAG_IMAGE)
  73 #define AVIS_CONTAINER  (AV_CONTAINER | FLAG_IMAGE | FLAG_SUB)
  74 #define AUDIO_CONTAINER (FLAG_CONTAINER | FLAG_AUDIO)
  75 #define VIDEO_CONTAINER (FLAG_CONTAINER | FLAG_VIDEO)
  76 #define AUDIO_TAG       (AUDIO_CONTAINER | FLAG_TAG)
  77 
  78 #ifndef GSTREAMER_LITE
  79 static const FormatInfo formats[] = {
  80   /* container/tag formats with static descriptions */
  81   /* FIXME: does anyone use oga in practice? */
  82   {&quot;audio/ogg&quot;, &quot;Ogg&quot;, AUDIO_CONTAINER, &quot;ogg&quot;},
  83   {&quot;audio/webm&quot;, &quot;WebM&quot;, AUDIO_CONTAINER, &quot;webm&quot;},
  84   {&quot;audio/x-matroska&quot;, &quot;Matroska&quot;, AUDIO_CONTAINER, &quot;mka&quot;},
  85   {&quot;application/gxf&quot;, &quot;General Exchange Format (GXF)&quot;, AVI_CONTAINER, &quot;gxf&quot;},
  86   {&quot;application/ogg&quot;, &quot;Ogg&quot;, AVIS_CONTAINER, &quot;ogg&quot;},
  87   {&quot;application/kate&quot;, &quot;Ogg&quot;, FLAG_CONTAINER | FLAG_SUB, &quot;ogg&quot;},
  88   {&quot;application/mxf&quot;, &quot;Material eXchange Format (MXF)&quot;, AVIS_CONTAINER, &quot;mxf&quot;},
  89   {&quot;application/vnd.rn-realmedia&quot;, &quot;Realmedia&quot;, AV_CONTAINER, &quot;rm&quot;},
  90   {&quot;application/x-id3&quot;, N_(&quot;ID3 tag&quot;), AUDIO_TAG, &quot;&quot;},
  91   {&quot;application/x-ape&quot;, N_(&quot;APE tag&quot;), AUDIO_TAG, &quot;&quot;},
  92   {&quot;application/x-apetag&quot;, N_(&quot;APE tag&quot;), AUDIO_TAG, &quot;&quot;},
  93   {&quot;application/x-icy&quot;, N_(&quot;ICY internet radio&quot;), AUDIO_TAG, &quot;&quot;},
  94   {&quot;application/x-3gp&quot;, &quot;3GP&quot;, AV_CONTAINER, &quot;3gp&quot;},
  95   {&quot;application/x-pn-realaudio&quot;, &quot;RealAudio&quot;, AUDIO_CONTAINER, &quot;ra&quot;},
  96   {&quot;application/x-yuv4mpeg&quot;, &quot;Y4M&quot;, VIDEO_CONTAINER, &quot;y4m&quot;},
  97   {&quot;multipart/x-mixed-replace&quot;, &quot;Multipart&quot;, FLAG_CONTAINER | FLAG_GENERIC, &quot;&quot;},
  98   {&quot;video/ogg&quot;, &quot;Ogg&quot;, AVIS_CONTAINER, &quot;ogv&quot;},
  99   {&quot;video/x-fli&quot;, &quot;FLI/FLC/FLX Animation&quot;, VIDEO_CONTAINER, &quot;fli&quot;},
 100   {&quot;video/x-flv&quot;, &quot;Flash&quot;, AV_CONTAINER, &quot;flv&quot;},
 101   {&quot;video/x-matroska&quot;, &quot;Matroska&quot;, AVIS_CONTAINER, &quot;mkv&quot;},
 102   /* FIXME: does anyone use .mk3d in practice, rather than .mkv? */
 103   {&quot;video/x-matroska-3d&quot;, &quot;Matroska&quot;, AVIS_CONTAINER, &quot;mk3d&quot;},
 104   {&quot;video/webm&quot;, &quot;WebM&quot;, AVS_CONTAINER, &quot;webm&quot;},
 105   {&quot;video/x-ms-asf&quot;, &quot;Advanced Streaming Format (ASF)&quot;, AVIS_CONTAINER, &quot;asf&quot;},
 106   {&quot;video/x-msvideo&quot;, &quot;Audio Video Interleave (AVI)&quot;, AVIS_CONTAINER, &quot;avi&quot;},
 107   {&quot;video/x-quicktime&quot;, &quot;Quicktime&quot;, AVIS_CONTAINER, &quot;mov&quot;},
 108   {&quot;video/quicktime&quot;, &quot;Quicktime&quot;, AVIS_CONTAINER, &quot;mov&quot;},
 109   {&quot;video/mj2&quot;, &quot;Motion JPEG 2000&quot;, AVIS_CONTAINER, &quot;mj2&quot;},
 110 
 111   /* audio formats with static descriptions */
 112   {&quot;audio/x-ac3&quot;, &quot;AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 113   {&quot;audio/ac3&quot;, &quot;AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 114   {&quot;audio/x-private-ac3&quot;, &quot;DVD AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 115   {&quot;audio/x-private1-ac3&quot;, &quot;DVD AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 116   {&quot;audio/x-alaw&quot;, &quot;A-Law&quot;, FLAG_AUDIO, &quot;&quot;},
 117   {&quot;audio/amr&quot;, &quot;Adaptive Multi Rate (AMR)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 118   {&quot;audio/AMR&quot;, &quot;Adaptive Multi Rate (AMR)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 119   {&quot;audio/AMR-WB&quot;, &quot;Adaptive Multi Rate WideBand (AMR-WB)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 120   {&quot;audio/iLBC-sh&quot;, &quot;Internet Low Bitrate Codec (iLBC)&quot;, AUDIO_CONTAINER,
 121       &quot;ilbc&quot;},
 122   {&quot;audio/ms-gsm&quot;, &quot;MS GSM&quot;, FLAG_AUDIO, &quot;gsm&quot;},
 123   {&quot;audio/qcelp&quot;, &quot;QCELP&quot;, FLAG_AUDIO, &quot;&quot;},
 124   {&quot;audio/aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, AUDIO_CONTAINER,
 125       &quot;aiff&quot;},
 126   {&quot;audio/x-aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, AUDIO_CONTAINER,
 127       &quot;aiff&quot;},
 128   {&quot;audio/x-alac&quot;, N_(&quot;Apple Lossless Audio (ALAC)&quot;), FLAG_AUDIO, &quot;&quot;},
 129   {&quot;audio/x-amr-nb-sh&quot;, &quot;Adaptive Multi Rate NarrowBand (AMR-NB)&quot;,
 130       AUDIO_CONTAINER, &quot;amr&quot;},
 131   {&quot;audio/x-amr-wb-sh&quot;, &quot;Adaptive Multi Rate WideBand (AMR-WB)&quot;,
 132       AUDIO_CONTAINER, &quot;amr&quot;},
 133   {&quot;audio/x-au&quot;, &quot;Sun .au&quot;, AUDIO_CONTAINER, &quot;au&quot;},
 134   {&quot;audio/x-audible&quot;, &quot;Audible Audio&quot;, AUDIO_CONTAINER, &quot;aa&quot;},
 135   {&quot;audio/x-caf&quot;, &quot;Apple Core Audio Format&quot;, AUDIO_CONTAINER, &quot;caf&quot;},
 136   {&quot;audio/x-celt&quot;, &quot;Constrained Energy Lapped Transform (CELT)&quot;, FLAG_AUDIO,
 137       &quot;&quot;},
 138   {&quot;audio/x-cinepak&quot;, &quot;Cinepak Audio&quot;, FLAG_AUDIO, &quot;&quot;},
 139   {&quot;audio/x-dpcm&quot;, &quot;DPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 140   {&quot;audio/x-dts&quot;, &quot;DTS&quot;, FLAG_AUDIO, &quot;dts&quot;},
 141   {&quot;audio/x-private1-dts&quot;, &quot;DTS&quot;, FLAG_AUDIO, &quot;dts&quot;},
 142   {&quot;audio/x-dv&quot;, &quot;DV Audio&quot;, FLAG_AUDIO, &quot;&quot;},
 143   {&quot;audio/x-eac3&quot;, &quot;E-AC-3 (ATSC A/52B)&quot;, FLAG_AUDIO, &quot;eac3&quot;},
 144   {&quot;audio/x-flac&quot;, N_(&quot;Free Lossless Audio Codec (FLAC)&quot;), FLAG_AUDIO, &quot;flac&quot;},
 145   {&quot;audio/x-gsm&quot;, &quot;GSM&quot;, FLAG_AUDIO, &quot;gsm&quot;},
 146   {&quot;audio/x-iec958&quot;, &quot;S/PDIF IEC958&quot;, 0, &quot;&quot;},   /* TODO: check description */
 147   {&quot;audio/x-iLBC&quot;, &quot;Internet Low Bitrate Codec (iLBC)&quot;, FLAG_AUDIO, &quot;ilbc&quot;},
 148   {&quot;audio/x-ircam&quot;, &quot;Berkeley/IRCAM/CARL&quot;, FLAG_AUDIO, &quot;&quot;},
 149   {&quot;audio/x-lpcm&quot;, &quot;LPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 150   {&quot;audio/x-private1-lpcm&quot;, &quot;DVD LPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 151   {&quot;audio/x-m4a&quot;, &quot;MPEG-4 AAC&quot;, FLAG_CONTAINER, &quot;m4a&quot;},
 152   {&quot;audio/x-mod&quot;, &quot;Module Music Format (MOD)&quot;, FLAG_AUDIO, &quot;mod&quot;},
 153   {&quot;audio/x-mulaw&quot;, &quot;Mu-Law&quot;, FLAG_AUDIO, &quot;&quot;},
 154   {&quot;audio/x-musepack&quot;, &quot;Musepack (MPC)&quot;, FLAG_AUDIO, &quot;mpc&quot;},
 155   {&quot;audio/x-nellymoser&quot;, &quot;Nellymoser Asao&quot;, FLAG_AUDIO, &quot;&quot;},
 156   {&quot;audio/x-nist&quot;, &quot;Sphere NIST&quot;, FLAG_AUDIO, &quot;&quot;},
 157   {&quot;audio/x-nsf&quot;, &quot;Nintendo NSF&quot;, FLAG_AUDIO, &quot;&quot;},
 158   {&quot;audio/x-opus&quot;, &quot;Opus&quot;, FLAG_AUDIO, &quot;&quot;},
 159   {&quot;audio/x-paris&quot;, &quot;Ensoniq PARIS&quot;, FLAG_AUDIO, &quot;&quot;},
 160   {&quot;audio/x-qdm&quot;, &quot;QDesign Music (QDM)&quot;, FLAG_AUDIO, &quot;&quot;},
 161   {&quot;audio/x-qdm2&quot;, &quot;QDesign Music (QDM) 2&quot;, FLAG_AUDIO, &quot;&quot;},
 162   {&quot;audio/x-ralf-mpeg4-generic&quot;, &quot;Real Audio Lossless (RALF)&quot;, FLAG_AUDIO, &quot;&quot;},
 163   {&quot;audio/x-rf64&quot;, &quot;Broadcast Wave Format&quot;, AUDIO_CONTAINER, &quot;rf64&quot;},
 164   {&quot;audio/x-sbc&quot;, &quot;Low Complexity Subband Coding&quot;, FLAG_AUDIO, &quot;sbc&quot;},
 165   {&quot;audio/x-sds&quot;, &quot;Midi Sample Dump Standard&quot;, FLAG_AUDIO, &quot;&quot;},
 166   {&quot;audio/x-shorten&quot;, &quot;Shorten Lossless&quot;, FLAG_AUDIO, &quot;shn&quot;},
 167   {&quot;audio/x-sid&quot;, &quot;Sid&quot;, FLAG_AUDIO, &quot;sid&quot;},
 168   {&quot;audio/x-sipro&quot;, &quot;Sipro/ACELP.NET Voice&quot;, FLAG_AUDIO, &quot;&quot;},
 169   {&quot;audio/x-siren&quot;, &quot;Siren&quot;, FLAG_AUDIO, &quot;&quot;},
 170   {&quot;audio/x-spc&quot;, &quot;SNES-SPC700 Sound File Data&quot;, FLAG_AUDIO, &quot;spc&quot;},
 171   {&quot;audio/x-speex&quot;, &quot;Speex&quot;, FLAG_AUDIO, &quot;&quot;},
 172   {&quot;audio/x-svx&quot;, &quot;Amiga IFF / SVX8 / SV16&quot;, FLAG_AUDIO, &quot;&quot;},
 173   {&quot;audio/x-true-hd&quot;, &quot;Dolby TrueHD&quot;, FLAG_AUDIO, &quot;&quot;},
 174   {&quot;audio/x-tta&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 175   {&quot;audio/x-ttafile&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 176   {&quot;audio/x-vnd.sony.atrac3&quot;, &quot;Sony ATRAC3&quot;, FLAG_AUDIO, &quot;&quot;},
 177   {&quot;audio/x-vorbis&quot;, &quot;Vorbis&quot;, FLAG_AUDIO, &quot;&quot;},
 178   {&quot;audio/x-voc&quot;, &quot;SoundBlaster VOC&quot;, FLAG_AUDIO, &quot;&quot;},
 179   {&quot;audio/x-w64&quot;, &quot;Sonic Foundry Wave64&quot;, AUDIO_CONTAINER, &quot;w64&quot;},
 180   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, AUDIO_CONTAINER, &quot;wav&quot;},
 181   {&quot;audio/x-wavpack&quot;, &quot;Wavpack&quot;, FLAG_AUDIO, &quot;wp&quot;},
 182   {&quot;audio/x-wavpack-correction&quot;, &quot;Wavpack&quot;, 0, &quot;wpc&quot;},
 183   {&quot;audio/x-wms&quot;, N_(&quot;Windows Media Speech&quot;), FLAG_AUDIO, &quot;&quot;},
 184   {&quot;audio/x-voxware&quot;, &quot;Voxware&quot;, FLAG_AUDIO, &quot;&quot;},
 185   {&quot;audio/x-xi&quot;, &quot;Fasttracker 2 Extended Instrument&quot;, FLAG_AUDIO, &quot;xi&quot;},
 186 
 187 
 188   /* video formats with static descriptions */
 189   {&quot;video/sp5x&quot;, &quot;Sunplus JPEG 5.x&quot;, FLAG_VIDEO, &quot;&quot;},
 190   {&quot;video/vivo&quot;, &quot;Vivo&quot;, FLAG_VIDEO, &quot;&quot;},
 191   {&quot;video/x-4xm&quot;, &quot;4X Technologies Video&quot;, FLAG_VIDEO, &quot;&quot;},
 192   {&quot;video/x-apple-video&quot;, &quot;Apple video&quot;, FLAG_VIDEO, &quot;&quot;},
 193   {&quot;video/x-aasc&quot;, &quot;Autodesk Animator&quot;, FLAG_VIDEO, &quot;&quot;},
<a name="1" id="anc1"></a><span class="line-added"> 194   {&quot;video/x-av1&quot;, &quot;AV1&quot;, FLAG_VIDEO, &quot;&quot;},</span>
 195   {&quot;video/x-camtasia&quot;, &quot;TechSmith Camtasia&quot;, FLAG_VIDEO, &quot;&quot;},
 196   {&quot;video/x-cavs&quot;, &quot;Chinese AVS (CAVS)&quot;, FLAG_VIDEO, &quot;&quot;},
 197   {&quot;video/x-cdxa&quot;, &quot;RIFF/CDXA (VCD)&quot;, AV_CONTAINER, &quot;&quot;},
 198   {&quot;video/x-cinepak&quot;, &quot;Cinepak Video&quot;, FLAG_VIDEO, &quot;&quot;},
 199   {&quot;video/x-cirrus-logic-accupak&quot;, &quot;Cirrus Logipak AccuPak&quot;, FLAG_VIDEO, &quot;&quot;},
 200   {&quot;video/x-compressed-yuv&quot;, N_(&quot;CYUV Lossless&quot;), FLAG_VIDEO, &quot;&quot;},
 201   {&quot;video/x-dnxhd&quot;, &quot;Digital Nonlinear Extensible High Definition (DNxHD)&quot;,
 202       FLAG_VIDEO, &quot;&quot;},
 203   {&quot;subpicture/x-dvd&quot;, &quot;DVD subpicture&quot;, FLAG_VIDEO, &quot;&quot;},
 204   {&quot;video/x-ffv&quot;, N_(&quot;FFMpeg v1&quot;), FLAG_VIDEO, &quot;&quot;},
 205   {&quot;video/x-flash-screen&quot;, &quot;Flash Screen Video&quot;, FLAG_VIDEO, &quot;&quot;},
 206   {&quot;video/x-flash-video&quot;, &quot;Sorenson Spark Video&quot;, FLAG_VIDEO, &quot;&quot;},
 207   {&quot;video/x-h261&quot;, &quot;H.261&quot;, FLAG_VIDEO, &quot;&quot;},
 208   {&quot;video/x-huffyuv&quot;, &quot;Huffyuv&quot;, FLAG_VIDEO, &quot;&quot;},
 209   {&quot;video/x-intel-h263&quot;, &quot;Intel H.263&quot;, FLAG_VIDEO, &quot;&quot;},
 210   {&quot;video/x-jpeg&quot;, &quot;Motion JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 211   /* { &quot;video/x-jpeg-b&quot;, &quot;&quot;, 0 }, does this actually exist? */
 212   {&quot;video/x-loco&quot;, &quot;LOCO Lossless&quot;, FLAG_VIDEO, &quot;&quot;},
 213   {&quot;video/x-mimic&quot;, &quot;MIMIC&quot;, FLAG_VIDEO, &quot;&quot;},
 214   {&quot;video/x-mjpeg&quot;, &quot;Motion-JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 215   {&quot;video/x-mjpeg-b&quot;, &quot;Motion-JPEG format B&quot;, FLAG_VIDEO, &quot;&quot;},
 216   {&quot;video/mpegts&quot;, &quot;MPEG-2 Transport Stream&quot;, AVS_CONTAINER, &quot;ts&quot;},
 217   {&quot;video/x-mng&quot;, &quot;Multiple Image Network Graphics (MNG)&quot;, FLAG_VIDEO, &quot;&quot;},
 218   {&quot;video/x-mszh&quot;, N_(&quot;Lossless MSZH&quot;), FLAG_VIDEO, &quot;&quot;},
 219   {&quot;video/x-msvideocodec&quot;, &quot;Microsoft Video 1&quot;, FLAG_VIDEO, &quot;&quot;},
 220   {&quot;video/x-mve&quot;, &quot;Interplay MVE&quot;, AV_CONTAINER, &quot;mve&quot;},
 221   {&quot;video/x-nut&quot;, &quot;NUT&quot;, AV_CONTAINER, &quot;nut&quot;},
 222   {&quot;video/x-nuv&quot;, &quot;MythTV NuppelVideo (NUV)&quot;, AV_CONTAINER, &quot;nuv&quot;},
 223   {&quot;video/x-prores&quot;, &quot;Apple ProRes&quot;, FLAG_VIDEO, &quot;&quot;},
 224   {&quot;video/x-qdrw&quot;, &quot;Apple QuickDraw&quot;, FLAG_VIDEO, &quot;&quot;},
 225   {&quot;video/x-smc&quot;, &quot;Apple SMC&quot;, FLAG_VIDEO, &quot;&quot;},
 226   {&quot;video/x-smoke&quot;, &quot;Smoke&quot;, FLAG_VIDEO, &quot;&quot;},
 227   {&quot;video/x-tarkin&quot;, &quot;Tarkin&quot;, FLAG_VIDEO, &quot;&quot;},
 228   {&quot;video/x-theora&quot;, &quot;Theora&quot;, FLAG_VIDEO, &quot;&quot;},
 229   {&quot;video/x-rle&quot;, N_(&quot;Run-length encoding&quot;), FLAG_VIDEO, &quot;&quot;},
 230   {&quot;video/x-ultimotion&quot;, &quot;IBM UltiMotion&quot;, FLAG_VIDEO, &quot;&quot;},
 231   {&quot;video/x-vcd&quot;, &quot;VideoCD (VCD)&quot;, 0},
 232   {&quot;video/x-vmnc&quot;, &quot;VMWare NC&quot;, FLAG_VIDEO, &quot;&quot;},
 233   {&quot;video/x-vp3&quot;, &quot;On2 VP3&quot;, FLAG_VIDEO, &quot;&quot;},
 234   {&quot;video/x-vp5&quot;, &quot;On2 VP5&quot;, FLAG_VIDEO, &quot;&quot;},
 235   {&quot;video/x-vp6&quot;, &quot;On2 VP6&quot;, FLAG_VIDEO, &quot;&quot;},
 236   {&quot;video/x-vp6-flash&quot;, &quot;On2 VP6/Flash&quot;, FLAG_VIDEO, &quot;&quot;},
 237   {&quot;video/x-vp6-alpha&quot;, &quot;On2 VP6 with alpha&quot;, FLAG_VIDEO, &quot;&quot;},
 238   {&quot;video/x-vp7&quot;, &quot;On2 VP7&quot;, FLAG_VIDEO, &quot;&quot;},
 239   {&quot;video/x-vp8&quot;, &quot;VP8&quot;, FLAG_VIDEO, &quot;&quot;},
 240   {&quot;video/x-vp9&quot;, &quot;VP9&quot;, FLAG_VIDEO, &quot;&quot;},
 241   {&quot;video/x-zlib&quot;, &quot;Lossless zlib video&quot;, FLAG_VIDEO, &quot;&quot;},
 242   {&quot;video/x-zmbv&quot;, &quot;Zip Motion Block video&quot;, FLAG_VIDEO, &quot;&quot;},
 243 
 244   /* image formats with static descriptions */
 245   {&quot;image/bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 246   {&quot;image/x-bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 247   {&quot;image/x-MS-bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 248   {&quot;image/gif&quot;, &quot;GIF&quot;, FLAG_IMAGE, &quot;gif&quot;},
 249   {&quot;image/jpeg&quot;, &quot;JPEG&quot;, FLAG_IMAGE | FLAG_VIDEO, &quot;jpg&quot;},
 250   {&quot;image/jng&quot;, &quot;JPEG Network Graphics (JNG)&quot;, FLAG_IMAGE, &quot;&quot;},
 251   {&quot;image/png&quot;, &quot;PNG&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;png&quot;},
 252   {&quot;image/pbm&quot;, &quot;Portable BitMap (PBM)&quot;, FLAG_IMAGE, &quot;pbm&quot;},
 253   {&quot;image/ppm&quot;, &quot;Portable PixMap (PPM)&quot;, FLAG_IMAGE, &quot;ppm&quot;},
 254   {&quot;image/svg+xml&quot;, &quot;Scalable Vector Graphics (SVG)&quot;, FLAG_IMAGE, &quot;svg&quot;},
 255   {&quot;image/tiff&quot;, &quot;TIFF&quot;, FLAG_IMAGE, &quot;tiff&quot;},
 256   {&quot;image/x-cmu-raster&quot;, &quot;CMU Raster Format&quot;, FLAG_IMAGE, &quot;&quot;},
 257   {&quot;image/x-degas&quot;, &quot;DEGAS&quot;, FLAG_IMAGE, &quot;&quot;},
 258   {&quot;image/x-icon&quot;, &quot;ICO&quot;, FLAG_IMAGE, &quot;ico&quot;},
 259   {&quot;image/x-j2c&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 260   {&quot;image/x-jpc&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 261   {&quot;image/jp2&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 262   {&quot;image/x-pcx&quot;, &quot;PCX&quot;, FLAG_IMAGE, &quot;&quot;},
 263   {&quot;image/x-xcf&quot;, &quot;XFC&quot;, FLAG_IMAGE, &quot;&quot;},
 264   {&quot;image/x-pixmap&quot;, &quot;XPM&quot;, FLAG_IMAGE, &quot;xpm&quot;},
 265   {&quot;image/x-portable-anymap&quot;, &quot;Portable AnyMap (PNM)&quot;, FLAG_IMAGE, &quot;pnm&quot;},
 266   {&quot;image/x-portable-graymap&quot;, &quot;Portable GrayMap (PGM)&quot;, FLAG_IMAGE, &quot;pgm&quot;},
 267   {&quot;image/x-xpixmap&quot;, &quot;XPM&quot;, FLAG_IMAGE, &quot;xpm&quot;},
 268   {&quot;image/x-quicktime&quot;, &quot;QuickTime Image Format (QTIF)&quot;,
 269       FLAG_IMAGE | FLAG_CONTAINER, &quot;.mov&quot;},
 270   {&quot;image/x-sun-raster&quot;, &quot;Sun Raster Format (RAS)&quot;, FLAG_IMAGE, &quot;&quot;},
 271   {&quot;image/x-tga&quot;, &quot;TGA&quot;, FLAG_IMAGE, &quot;tga&quot;},
 272   {&quot;image/vnd.wap.wbmp&quot;, &quot;Wireless Bitmap&quot;, FLAG_IMAGE, &quot;wbmp&quot;},
 273 
 274   /* subtitle formats with static descriptions */
 275   {&quot;text/x-raw&quot;, N_(&quot;Timed Text&quot;), FLAG_SUB, &quot;&quot;},
 276   {&quot;application/x-ssa&quot;, &quot;SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 277   {&quot;application/x-ass&quot;, &quot;Advanced SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 278   /* FIXME: add variant field to typefinder? */
 279   {&quot;application/x-subtitle&quot;, N_(&quot;Subtitle&quot;), FLAG_SUB, &quot;&quot;},
 280   {&quot;application/x-subtitle-mpl2&quot;, N_(&quot;MPL2 subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 281   {&quot;application/x-subtitle-dks&quot;, N_(&quot;DKS subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 282   {&quot;application/x-subtitle-qttext&quot;, N_(&quot;QTtext subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 283   {&quot;application/x-subtitle-sami&quot;, N_(&quot;Sami subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 284   {&quot;application/x-subtitle-tmplayer&quot;, N_(&quot;TMPlayer subtitle format&quot;), FLAG_SUB,
 285       &quot;&quot;},
 286   {&quot;application/x-teletext&quot;, &quot;Teletext&quot;, 0, &quot;&quot;},
 287   {&quot;application/x-kate&quot;, &quot;Kate&quot;, 0, &quot;&quot;},
<a name="2" id="anc2"></a><span class="line-added"> 288   {&quot;closedcaption/x-cea-608&quot;, N_(&quot;CEA 608 Closed Caption&quot;), FLAG_SUB, &quot;&quot;},</span>
<span class="line-added"> 289   {&quot;closedcaption/x-cea-708&quot;, N_(&quot;CEA 708 Closed Caption&quot;), FLAG_SUB, &quot;&quot;},</span>
 290   {&quot;subtitle/x-kate&quot;, N_(&quot;Kate subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 291   {&quot;application/x-subtitle-vtt&quot;, N_(&quot;WebVTT subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 292   {&quot;subpicture/x-dvb&quot;, &quot;DVB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 293   {&quot;subpicture/x-pgs&quot;, &quot;PGS subtitles&quot;, FLAG_SUB, &quot;&quot;},
 294   {&quot;subpicture/x-xsub&quot;, &quot;XSUB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 295 
 296   /* non-audio/video/container formats */
 297   {&quot;hdv/aux-v&quot;, &quot;HDV AUX-V&quot;, 0, &quot;&quot;},
 298   {&quot;hdv/aux-a&quot;, &quot;HDV AUX-A&quot;, 0, &quot;&quot;},
 299 
 300   /* formats with dynamic descriptions */
 301   {&quot;audio/mpeg&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 302   {&quot;audio/x-adpcm&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 303   {&quot;audio/x-mace&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 304   {&quot;audio/x-pn-realaudio&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 305   {&quot;audio/x-raw&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 306   {&quot;audio/x-wma&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 307   {&quot;video/mpeg&quot;, NULL, AVS_CONTAINER | FLAG_SYSTEMSTREAM, &quot;mpg&quot;},
 308   {&quot;video/mpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 309   {&quot;video/x-asus&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 310   {&quot;video/x-ati-vcr&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 311   {&quot;video/x-dirac&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 312   {&quot;video/x-divx&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 313   {&quot;video/x-dv&quot;, &quot;Digital Video (DV) System Stream&quot;,
 314       FLAG_CONTAINER | FLAG_SYSTEMSTREAM, &quot;dv&quot;},
 315   {&quot;video/x-dv&quot;, &quot;Digital Video (DV)&quot;, FLAG_VIDEO, &quot;&quot;},
 316   {&quot;video/x-h263&quot;, NULL, FLAG_VIDEO, &quot;h263&quot;},
 317   {&quot;video/x-h264&quot;, NULL, FLAG_VIDEO, &quot;h264&quot;},
 318   {&quot;video/x-h265&quot;, NULL, FLAG_VIDEO, &quot;h265&quot;},
 319   {&quot;video/x-indeo&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 320   {&quot;video/x-msmpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 321   {&quot;video/x-pn-realvideo&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 322 #if 0
 323   /* do these exist? are they used anywhere? */
 324   {&quot;video/x-pn-multirate-realvideo&quot;, NULL, 0},
 325   {&quot;audio/x-pn-multirate-realaudio&quot;, NULL, 0},
 326   {&quot;audio/x-pn-multirate-realaudio-live&quot;, NULL, 0},
 327 #endif
 328   {&quot;video/x-truemotion&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 329   {&quot;video/x-raw&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 330   {&quot;video/x-svq&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 331   {&quot;video/x-wmv&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 332   {&quot;video/x-xan&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 333   {&quot;video/x-tscc&quot;, NULL, FLAG_VIDEO, &quot;&quot;}
 334 };
 335 #else // GSTREAMER_LITE
 336 static const FormatInfo formats[] = {
 337   /* container/tag formats with static descriptions */
 338   {&quot;application/x-id3&quot;, N_(&quot;ID3 tag&quot;), FLAG_CONTAINER},
 339   {&quot;video/x-flv&quot;, &quot;Flash&quot;, FLAG_CONTAINER},
 340 
 341   /* audio formats with static descriptions */
 342   {&quot;audio/aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, 0},
 343   {&quot;audio/x-aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, 0},
 344   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, 0},
 345 
 346   /* video formats with static descriptions */
 347   {&quot;video/x-vp6&quot;, &quot;On2 VP6&quot;, 0},
 348 
 349   /* image formats with static descriptions */
 350 
 351   /* subtitle formats with static descriptions */
 352 
 353   /* non-audio/video/container formats */
 354 
 355   /* formats with dynamic descriptions */
 356   {&quot;audio/mpeg&quot;, NULL, 0},
 357   {&quot;audio/x-raw-int&quot;, NULL, 0},
 358   {&quot;audio/x-raw-float&quot;, NULL, 0}
 359 };
 360 #endif // GSTREAMER_LITE
 361 
 362 static const gchar *
 363 pbutils_desc_get_profile_name_from_nick (const gchar * map, gsize map_len,
 364     const gchar * nick)
 365 {
 366   const gchar *end = map + map_len;
 367   const gchar *p;
 368 
 369   p = map;
 370   while (*p != &#39;\0&#39; &amp;&amp; p &lt; end) {
 371     guint len = strlen (p);
 372 
 373     if (strcmp (p, nick) == 0)
 374       return p + len + 1;
 375     p += len + 1;
 376     p += strlen (p) + 1;
 377   }
 378   return NULL;
 379 }
 380 
 381 static const gchar *
 382 pbutils_desc_get_mpeg2v_profile_name_from_nick (const gchar * nick)
 383 {
 384   static const gchar map[] =
 385       &quot;simple\000Simple\000main\000Main\000high\000High\000&quot;;
 386 
 387   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 388 }
 389 
 390 static const gchar *
 391 pbutils_desc_get_mpeg4v_profile_name_from_nick (const gchar * nick)
 392 {
 393   static const gchar map[] = &quot;simple\000Simple\000&quot;
 394       &quot;simple-scalable\000Simple Scalable\000&quot;
 395       &quot;core\000Core\000&quot;
 396       &quot;main\000Main\000&quot;
 397       &quot;n-bit\000N-bit\000&quot;
 398       &quot;scalable\000Scalable\000&quot;
 399       &quot;hybrid\000Hybrid\000&quot;
 400       &quot;advanced-real-time-simple\000Advanced Real-Time Simple\000&quot;
 401       &quot;core-scalable\000Core-Scalable\000&quot;
 402       &quot;advanced-coding-efficiency\000Advanced Coding Efficiency\000&quot;
 403       &quot;advanced-core\000Advanced Core\000&quot;
 404       &quot;advanced-scalable-texture\000Advanced Scalable Texture\000&quot;
 405       &quot;simple-face\000Simple Face Animation\000&quot;
 406       &quot;simple-fba\000Simple FBA\000&quot;
 407       &quot;simple-studio\000Simple Studio\000&quot;
 408       &quot;core-studio\000Core Studio\000&quot;
 409       &quot;advanced-simple\000Advanced Simple\000&quot;
 410       &quot;fine-granularity-scalable\000Fine Granularity Scalable\000&quot;
 411       &quot;basic-animated-texture\000Basic Animated Texture\000&quot;
 412       &quot;baseline\000Baseline Profile\000&quot;;
 413 
 414   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 415 }
 416 
 417 static const gchar *
 418 pbutils_desc_get_h264_profile_name_from_nick (const gchar * nick)
 419 {
 420   static const gchar map[] = &quot;baseline\000Baseline\000&quot;
 421       &quot;constrained-baseline\000Constrained Baseline\000&quot;
 422       &quot;main\000Main\000&quot;
 423       &quot;extended\000Extended\000&quot;
 424       &quot;high\000High\000&quot;
 425       &quot;high-10-intra\000High 10 Intra\000&quot;
 426       &quot;high-10\000High 10\000&quot;
 427       &quot;high-4:2:2-intra\000High 4:2:2 Intra\000&quot;
 428       &quot;high-4:2:2\000High 4:2:2\000&quot;
 429       &quot;high-4:4:4-intra\000High 4:4:4 Intra\000&quot;
 430       &quot;high-4:4:4\000High 4:4:4\000&quot;
 431       &quot;cavlc-4:4:4-intra\000CAVLC 4:4:4 Intra\000&quot;
 432       &quot;multiview-high\000Multiview High\000&quot;
 433       &quot;stereo-high\000Stereo High\000&quot;
 434       &quot;scalable-constrained-baseline\000Scalable Constrained Baseline\000&quot;
 435       &quot;scalable-baseline\000Scalable Baseline\000&quot;
 436       &quot;scalable-high\000Scalable High\000&quot;;
 437 
 438   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 439 }
 440 
 441 static const gchar *
 442 pbutils_desc_get_h265_profile_name_from_nick (const gchar * nick)
 443 {
 444   static const gchar map[] = &quot;main\000Main\000&quot;
 445       &quot;main-10\000Main 10\000&quot;
 446       &quot;main-12\000Main 12\000&quot;
 447       &quot;main-4:2:2-10\000Main 4:2:2 10\000&quot;
 448       &quot;main-4:2:2-12\000Main 4:2:2 12\000&quot;
 449       &quot;main-4:4:4\000Main 4:4:4\000&quot;
 450       &quot;main-4:4:4-10\000Main 4:4:4 10\000&quot;
 451       &quot;main-4:4:4-12\000Main 4:4:4 12\000&quot;
 452       &quot;main-4:4:4-16-intra\000Main 4:4:4 16 Intra\000&quot;
 453       &quot;main-still-picture\000Main Still Picture\000&quot;;
 454 
 455   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 456 }
 457 
 458 /* returns static descriptions and dynamic ones (such as video/x-raw),
 459  * or NULL if caps aren&#39;t known at all */
 460 static gchar *
 461 format_info_get_desc (const FormatInfo * info, const GstCaps * caps)
 462 {
 463   const GstStructure *s;
 464 
 465   g_assert (info != NULL);
 466 
 467   gst_pb_utils_init_locale_text_domain ();
 468 
 469   if (info-&gt;desc != NULL)
 470     return g_strdup (_(info-&gt;desc));
 471 
 472   s = gst_caps_get_structure (caps, 0);
 473 
 474   if (strcmp (info-&gt;type, &quot;video/x-raw&quot;) == 0) {
 475     gchar *ret = NULL;
 476     const gchar *str = 0;
 477     GstVideoFormat format;
 478     const GstVideoFormatInfo *finfo;
 479 
 480     str = gst_structure_get_string (s, &quot;format&quot;);
 481     if (str == NULL)
 482       return g_strdup (_(&quot;Uncompressed video&quot;));
 483     format = gst_video_format_from_string (str);
 484     if (format == GST_VIDEO_FORMAT_UNKNOWN)
 485       return g_strdup (_(&quot;Uncompressed video&quot;));
 486 
 487     finfo = gst_video_format_get_info (format);
 488 
 489     if (GST_VIDEO_FORMAT_INFO_IS_GRAY (finfo)) {
 490       ret = g_strdup (_(&quot;Uncompressed gray&quot;));
 491     } else if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {
 492       const gchar *subs;
 493       gint w_sub, h_sub, n_semi;
 494 
 495       w_sub = GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);
 496       h_sub = GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);
 497 
 498       if (w_sub == 1 &amp;&amp; h_sub == 1) {
 499         subs = &quot;4:4:4&quot;;
 500       } else if (w_sub == 2 &amp;&amp; h_sub == 1) {
 501         subs = &quot;4:2:2&quot;;
 502       } else if (w_sub == 2 &amp;&amp; h_sub == 2) {
 503         subs = &quot;4:2:0&quot;;
 504       } else if (w_sub == 4 &amp;&amp; h_sub == 1) {
 505         subs = &quot;4:1:1&quot;;
 506       } else {
 507         subs = &quot;&quot;;
<a name="3" id="anc3"></a><span class="line-modified"> 508       }</span>
 509 
 510       n_semi = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo) ? 3 : 2;
 511 
 512       if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == 1) {
 513         ret = g_strdup_printf (_(&quot;Uncompressed packed YUV %s&quot;), subs);
 514       } else if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == n_semi) {
 515         ret = g_strdup_printf (_(&quot;Uncompressed semi-planar YUV %s&quot;), subs);
<a name="4" id="anc4"></a><span class="line-modified"> 516       } else {</span>
 517         ret = g_strdup_printf (_(&quot;Uncompressed planar YUV %s&quot;), subs);
<a name="5" id="anc5"></a><span class="line-modified"> 518       }</span>
 519     } else if (GST_VIDEO_FORMAT_INFO_IS_RGB (finfo)) {
 520       gboolean alpha, palette;
 521       gint bits;
 522 
 523       alpha = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo);
 524       palette = GST_VIDEO_FORMAT_INFO_HAS_PALETTE (finfo);
 525       bits = GST_VIDEO_FORMAT_INFO_BITS (finfo);
 526 
 527       if (palette) {
 528         ret = g_strdup_printf (_(&quot;Uncompressed palettized %d-bit %s&quot;),
 529             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 530       } else {
 531         ret = g_strdup_printf (_(&quot;Uncompressed %d-bit %s&quot;),
 532             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 533       }
 534     } else {
 535       ret = g_strdup (_(&quot;Uncompressed video&quot;));
 536     }
 537     return ret;
 538   } else if (strcmp (info-&gt;type, &quot;video/x-h263&quot;) == 0) {
 539     const gchar *variant, *ret;
 540 
 541     variant = gst_structure_get_string (s, &quot;variant&quot;);
 542     if (variant == NULL)
 543       ret = &quot;H.263&quot;;
 544     else if (strcmp (variant, &quot;itu&quot;) == 0)
 545       ret = &quot;ITU H.26n&quot;;        /* why not ITU H.263? (tpm) */
 546     else if (strcmp (variant, &quot;lead&quot;) == 0)
 547       ret = &quot;Lead H.263&quot;;
 548     else if (strcmp (variant, &quot;microsoft&quot;) == 0)
 549       ret = &quot;Microsoft H.263&quot;;
 550     else if (strcmp (variant, &quot;vdolive&quot;) == 0)
 551       ret = &quot;VDOLive&quot;;
 552     else if (strcmp (variant, &quot;vivo&quot;) == 0)
 553       ret = &quot;Vivo H.263&quot;;
 554     else if (strcmp (variant, &quot;xirlink&quot;) == 0)
 555       ret = &quot;Xirlink H.263&quot;;
 556     else {
 557       GST_WARNING (&quot;Unknown H263 variant &#39;%s&#39;&quot;, variant);
 558       ret = &quot;H.263&quot;;
 559     }
 560     return g_strdup (ret);
 561   } else if (strcmp (info-&gt;type, &quot;video/x-h264&quot;) == 0) {
 562     const gchar *variant, *ret;
 563     const gchar *profile;
 564 
 565     variant = gst_structure_get_string (s, &quot;variant&quot;);
 566     if (variant == NULL)
 567       ret = &quot;H.264&quot;;
 568     else if (strcmp (variant, &quot;itu&quot;) == 0)
 569       ret = &quot;ITU H.264&quot;;
 570     else if (strcmp (variant, &quot;videosoft&quot;) == 0)
 571       ret = &quot;Videosoft H.264&quot;;
 572     else if (strcmp (variant, &quot;lead&quot;) == 0)
 573       ret = &quot;Lead H.264&quot;;
 574     else {
 575       GST_WARNING (&quot;Unknown H264 variant &#39;%s&#39;&quot;, variant);
 576       ret = &quot;H.264&quot;;
 577     }
 578     /* profile */
 579     profile = gst_structure_get_string (s, &quot;profile&quot;);
 580     if (profile != NULL)
 581       profile = pbutils_desc_get_h264_profile_name_from_nick (profile);
 582     if (profile == NULL)
<a name="6" id="anc6"></a><span class="line-modified"> 583       return g_strdup (ret);</span>
 584     return g_strdup_printf (&quot;%s (%s Profile)&quot;, ret, profile);
 585   } else if (strcmp (info-&gt;type, &quot;video/x-h265&quot;) == 0) {
 586     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 587 
 588     if (profile != NULL)
 589       profile = pbutils_desc_get_h265_profile_name_from_nick (profile);
 590     if (profile != NULL)
 591       return g_strdup_printf (&quot;H.265 (%s Profile)&quot;, profile);
 592 
 593     return g_strdup (&quot;H.265&quot;);
 594   } else if (strcmp (info-&gt;type, &quot;video/x-dirac&quot;) == 0) {
 595     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 596     if (profile == NULL)
 597       return g_strdup (&quot;Dirac&quot;);
 598     if (strcmp (profile, &quot;vc2-low-delay&quot;) == 0)
 599       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Low Delay Profile&quot;);
 600     else if (strcmp (profile, &quot;vc2-simple&quot;) == 0)
 601       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Simple Profile&quot;);
 602     else if (strcmp (profile, &quot;vc2-main&quot;) == 0)
 603       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Main Profile&quot;);
 604     else
 605       return g_strdup (&quot;Dirac&quot;);
 606   } else if (strcmp (info-&gt;type, &quot;video/x-divx&quot;) == 0) {
 607     gint ver = 0;
 608 
 609     if (!gst_structure_get_int (s, &quot;divxversion&quot;, &amp;ver) || ver &lt;= 2) {
 610       GST_WARNING (&quot;Unexpected DivX version in %&quot; GST_PTR_FORMAT, caps);
 611       return g_strdup (&quot;DivX MPEG-4&quot;);
 612     }
 613     return g_strdup_printf (_(&quot;DivX MPEG-4 Version %d&quot;), ver);
 614   } else if (strcmp (info-&gt;type, &quot;video/x-msmpeg&quot;) == 0) {
 615     gint ver = 0;
 616 
 617     if (!gst_structure_get_int (s, &quot;msmpegversion&quot;, &amp;ver) ||
 618         ver &lt; 40 || ver &gt; 49) {
 619       GST_WARNING (&quot;Unexpected msmpegversion in %&quot; GST_PTR_FORMAT, caps);
 620       return g_strdup (&quot;Microsoft MPEG-4 4.x&quot;);
 621     }
 622     return g_strdup_printf (&quot;Microsoft MPEG-4 4.%d&quot;, ver % 10);
 623   } else if (strcmp (info-&gt;type, &quot;video/x-truemotion&quot;) == 0) {
 624     gint ver = 0;
 625 
 626     gst_structure_get_int (s, &quot;trueversion&quot;, &amp;ver);
 627     switch (ver) {
 628       case 1:
 629         return g_strdup_printf (&quot;Duck TrueMotion 1&quot;);
 630       case 2:
 631         return g_strdup_printf (&quot;TrueMotion 2.0&quot;);
 632       default:
 633         GST_WARNING (&quot;Unexpected trueversion in %&quot; GST_PTR_FORMAT, caps);
 634         break;
 635     }
 636     return g_strdup_printf (&quot;TrueMotion&quot;);
 637   } else if (strcmp (info-&gt;type, &quot;video/x-xan&quot;) == 0) {
 638     gint ver = 0;
 639 
 640     if (!gst_structure_get_int (s, &quot;wcversion&quot;, &amp;ver) || ver &lt; 1) {
 641       GST_WARNING (&quot;Unexpected wcversion in %&quot; GST_PTR_FORMAT, caps);
 642       return g_strdup (&quot;Xan Wing Commander&quot;);
 643     }
 644     return g_strdup_printf (&quot;Xan Wing Commander %u&quot;, ver);
 645   } else if (strcmp (info-&gt;type, &quot;video/x-indeo&quot;) == 0) {
 646     gint ver = 0;
 647 
 648     if (!gst_structure_get_int (s, &quot;indeoversion&quot;, &amp;ver) || ver &lt; 2) {
 649       GST_WARNING (&quot;Unexpected indeoversion in %&quot; GST_PTR_FORMAT, caps);
 650       return g_strdup (&quot;Intel Indeo&quot;);
 651     }
 652     return g_strdup_printf (&quot;Intel Indeo %u&quot;, ver);
 653   } else if (strcmp (info-&gt;type, &quot;audio/x-wma&quot;) == 0) {
 654     gint ver = 0;
 655 
 656     gst_structure_get_int (s, &quot;wmaversion&quot;, &amp;ver);
 657     switch (ver) {
 658       case 1:
 659       case 2:
 660       case 3:
 661         return g_strdup_printf (&quot;Windows Media Audio %d&quot;, ver + 6);
 662       default:
 663         break;
 664     }
 665     GST_WARNING (&quot;Unexpected wmaversion in %&quot; GST_PTR_FORMAT, caps);
 666     return g_strdup (&quot;Windows Media Audio&quot;);
 667   } else if (strcmp (info-&gt;type, &quot;video/x-wmv&quot;) == 0) {
 668     gint ver = 0;
 669     const gchar *str;
 670 
 671     gst_structure_get_int (s, &quot;wmvversion&quot;, &amp;ver);
 672     str = gst_structure_get_string (s, &quot;format&quot;);
 673 
 674     switch (ver) {
 675       case 1:
 676       case 2:
 677       case 3:
 678         if (str &amp;&amp; strncmp (str, &quot;MSS&quot;, 3)) {
 679           return g_strdup_printf (&quot;Windows Media Video %d Screen&quot;, ver + 6);
 680         } else {
 681           return g_strdup_printf (&quot;Windows Media Video %d&quot;, ver + 6);
 682         }
 683       default:
 684         break;
 685     }
 686     GST_WARNING (&quot;Unexpected wmvversion in %&quot; GST_PTR_FORMAT, caps);
 687     return g_strdup (&quot;Windows Media Video&quot;);
 688   } else if (strcmp (info-&gt;type, &quot;audio/x-mace&quot;) == 0) {
 689     gint ver = 0;
 690 
 691     gst_structure_get_int (s, &quot;maceversion&quot;, &amp;ver);
 692     if (ver == 3 || ver == 6) {
 693       return g_strdup_printf (&quot;MACE-%d&quot;, ver);
 694     } else {
 695       GST_WARNING (&quot;Unexpected maceversion in %&quot; GST_PTR_FORMAT, caps);
 696       return g_strdup (&quot;MACE&quot;);
 697     }
 698   } else if (strcmp (info-&gt;type, &quot;video/x-svq&quot;) == 0) {
 699     gint ver = 0;
 700 
 701     gst_structure_get_int (s, &quot;svqversion&quot;, &amp;ver);
 702     if (ver == 1 || ver == 3) {
 703       return g_strdup_printf (&quot;Sorensen Video %d&quot;, ver);
 704     } else {
 705       GST_WARNING (&quot;Unexpected svqversion in %&quot; GST_PTR_FORMAT, caps);
 706       return g_strdup (&quot;Sorensen Video&quot;);
 707     }
 708   } else if (strcmp (info-&gt;type, &quot;video/x-asus&quot;) == 0) {
 709     gint ver = 0;
 710 
 711     gst_structure_get_int (s, &quot;asusversion&quot;, &amp;ver);
 712     if (ver == 1 || ver == 2) {
 713       return g_strdup_printf (&quot;Asus Video %d&quot;, ver);
 714     } else {
 715       GST_WARNING (&quot;Unexpected asusversion in %&quot; GST_PTR_FORMAT, caps);
 716       return g_strdup (&quot;Asus Video&quot;);
 717     }
 718   } else if (strcmp (info-&gt;type, &quot;video/x-ati-vcr&quot;) == 0) {
 719     gint ver = 0;
 720 
 721     gst_structure_get_int (s, &quot;vcrversion&quot;, &amp;ver);
 722     if (ver == 1 || ver == 2) {
 723       return g_strdup_printf (&quot;ATI VCR %d&quot;, ver);
 724     } else {
 725       GST_WARNING (&quot;Unexpected acrversion in %&quot; GST_PTR_FORMAT, caps);
 726       return g_strdup (&quot;ATI VCR&quot;);
 727     }
 728   } else if (strcmp (info-&gt;type, &quot;audio/x-adpcm&quot;) == 0) {
 729     const GValue *layout_val;
 730 
 731     layout_val = gst_structure_get_value (s, &quot;layout&quot;);
 732     if (layout_val != NULL &amp;&amp; G_VALUE_HOLDS_STRING (layout_val)) {
 733       const gchar *layout;
 734 
 735       if ((layout = g_value_get_string (layout_val))) {
 736         gchar *layout_upper, *ret;
 737 
 738         if (strcmp (layout, &quot;swf&quot;) == 0)
 739           return g_strdup (&quot;Shockwave ADPCM&quot;);
 740         if (strcmp (layout, &quot;microsoft&quot;) == 0)
 741           return g_strdup (&quot;Microsoft ADPCM&quot;);
 742         if (strcmp (layout, &quot;quicktime&quot;) == 0)
 743           return g_strdup (&quot;Quicktime ADPCM&quot;);
 744         if (strcmp (layout, &quot;westwood&quot;) == 0)
 745           return g_strdup (&quot;Westwood ADPCM&quot;);
 746         if (strcmp (layout, &quot;yamaha&quot;) == 0)
 747           return g_strdup (&quot;Yamaha ADPCM&quot;);
 748         /* FIXME: other layouts: sbpro2, sbpro3, sbpro4, ct, g726, ea,
 749          * adx, xa, 4xm, smjpeg, dk4, dk3, dvi */
 750         layout_upper = g_ascii_strup (layout, -1);
 751         ret = g_strdup_printf (&quot;%s ADPCM&quot;, layout_upper);
 752         g_free (layout_upper);
 753         return ret;
 754       }
 755     }
 756     return g_strdup (&quot;ADPCM&quot;);
 757   } else if (strcmp (info-&gt;type, &quot;audio/mpeg&quot;) == 0) {
 758     gint ver = 0, layer = 0;
 759 
 760     gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver);
 761 
 762     switch (ver) {
 763       case 1:
 764         gst_structure_get_int (s, &quot;layer&quot;, &amp;layer);
 765         switch (layer) {
 766           case 1:
 767           case 2:
 768           case 3:
 769             return g_strdup_printf (&quot;MPEG-1 Layer %d (MP%d)&quot;, layer, layer);
 770           default:
 771             break;
 772         }
 773         GST_WARNING (&quot;Unexpected MPEG-1 layer in %&quot; GST_PTR_FORMAT, caps);
 774         return g_strdup (&quot;MPEG-1 Audio&quot;);
 775       case 2:
 776         return g_strdup (&quot;MPEG-2 AAC&quot;);
 777       case 4:
 778         return g_strdup (&quot;MPEG-4 AAC&quot;);
 779       default:
 780         break;
 781     }
 782     GST_WARNING (&quot;Unexpected audio mpegversion in %&quot; GST_PTR_FORMAT, caps);
 783     return g_strdup (&quot;MPEG Audio&quot;);
 784   } else if (strcmp (info-&gt;type, &quot;audio/x-pn-realaudio&quot;) == 0) {
 785     gint ver = 0;
 786 
 787     gst_structure_get_int (s, &quot;raversion&quot;, &amp;ver);
 788     switch (ver) {
 789       case 1:
 790         return g_strdup (&quot;RealAudio 14k4bps&quot;);
 791       case 2:
 792         return g_strdup (&quot;RealAudio 28k8bps&quot;);
 793       case 8:
 794         return g_strdup (&quot;RealAudio G2 (Cook)&quot;);
 795       default:
 796         break;
 797     }
 798     GST_WARNING (&quot;Unexpected raversion in %&quot; GST_PTR_FORMAT, caps);
 799     return g_strdup (&quot;RealAudio&quot;);
 800   } else if (strcmp (info-&gt;type, &quot;video/x-pn-realvideo&quot;) == 0) {
 801     gint ver = 0;
 802 
 803     gst_structure_get_int (s, &quot;rmversion&quot;, &amp;ver);
 804     switch (ver) {
 805       case 1:
 806         return g_strdup (&quot;RealVideo 1.0&quot;);
 807       case 2:
 808         return g_strdup (&quot;RealVideo 2.0&quot;);
 809       case 3:
 810         return g_strdup (&quot;RealVideo 3.0&quot;);
 811       case 4:
 812         return g_strdup (&quot;RealVideo 4.0&quot;);
 813       default:
 814         break;
 815     }
 816     GST_WARNING (&quot;Unexpected rmversion in %&quot; GST_PTR_FORMAT, caps);
 817     return g_strdup (&quot;RealVideo&quot;);
 818   } else if (strcmp (info-&gt;type, &quot;video/mpeg&quot;) == 0) {
 819     gboolean sysstream;
 820     gint ver = 0;
 821 
 822     if (!gst_structure_get_boolean (s, &quot;systemstream&quot;, &amp;sysstream)) {
 823       GST_WARNING (&quot;Missing systemstream field in mpeg video caps &quot;
 824           &quot;%&quot; GST_PTR_FORMAT, caps);
 825       sysstream = FALSE;
 826     }
 827 
 828     if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver) &amp;&amp; ver &gt; 0 &amp;&amp; ver &lt;= 4) {
 829       if (sysstream) {
 830         return g_strdup_printf (&quot;MPEG-%d System Stream&quot;, ver);
 831       } else {
 832         const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 833         if (profile != NULL) {
 834           if (ver == 4)
 835             profile = pbutils_desc_get_mpeg4v_profile_name_from_nick (profile);
 836           else if (ver == 2)
 837             profile = pbutils_desc_get_mpeg2v_profile_name_from_nick (profile);
 838           else
 839             profile = NULL;
 840         }
 841         if (profile != NULL)
 842           return g_strdup_printf (&quot;MPEG-%d Video (%s Profile)&quot;, ver, profile);
 843         else
<a name="7" id="anc7"></a><span class="line-modified"> 844           return g_strdup_printf (&quot;MPEG-%d Video&quot;, ver);</span>
 845       }
 846     }
 847     GST_WARNING (&quot;Missing mpegversion field in mpeg video caps &quot;
 848         &quot;%&quot; GST_PTR_FORMAT, caps);
 849     return g_strdup (&quot;MPEG Video&quot;);
 850   } else if (strcmp (info-&gt;type, &quot;audio/x-raw&quot;) == 0) {
 851     gint depth = 0;
 852     gboolean is_float;
 853     const gchar *str;
 854     GstAudioFormat format = GST_AUDIO_FORMAT_UNKNOWN;
 855     const GstAudioFormatInfo *finfo;
 856 
 857     str = gst_structure_get_string (s, &quot;format&quot;);
 858     if (str)
 859       format = gst_audio_format_from_string (str);
 860     if (format == GST_AUDIO_FORMAT_UNKNOWN)
 861       return g_strdup (_(&quot;Uncompressed audio&quot;));
 862 
 863     finfo = gst_audio_format_get_info (format);
 864     depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 865     is_float = GST_AUDIO_FORMAT_INFO_IS_FLOAT (finfo);
 866 
 867     return g_strdup_printf (_(&quot;Raw %d-bit %s audio&quot;), depth,
 868         is_float ? &quot;floating-point&quot; : &quot;PCM&quot;);
 869   } else if (strcmp (info-&gt;type, &quot;video/x-tscc&quot;) == 0) {
 870     gint version;
 871     gst_structure_get_int (s, &quot;tsccversion&quot;, &amp;version);
 872     switch (version) {
 873       case 1:
 874         return g_strdup (&quot;TechSmith Screen Capture 1&quot;);
 875       case 2:
 876         return g_strdup (&quot;TechSmith Screen Capture 2&quot;);
 877       default:
 878         break;
<a name="8" id="anc8"></a><span class="line-modified"> 879     }</span>
 880     GST_WARNING (&quot;Unexpected version in %&quot; GST_PTR_FORMAT, caps);
 881     return g_strdup (&quot;TechSmith Screen Capture&quot;);
 882   }
 883   return NULL;
 884 }
 885 
 886 /* returns format info structure, will return NULL for dynamic media types! */
 887 static const FormatInfo *
 888 find_format_info (const GstCaps * caps)
 889 {
 890   const GstStructure *s;
 891   const gchar *media_type;
 892   guint i;
 893 
 894   s = gst_caps_get_structure (caps, 0);
 895   media_type = gst_structure_get_name (s);
 896 
 897   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
 898     if (strcmp (media_type, formats[i].type) == 0) {
 899       gboolean is_sys = FALSE;
 900 
 901       if ((formats[i].flags &amp; FLAG_SYSTEMSTREAM) == 0)
 902         return &amp;formats[i];
 903 
 904       /* this record should only be matched if the systemstream field is set */
 905       if (gst_structure_get_boolean (s, &quot;systemstream&quot;, &amp;is_sys) &amp;&amp; is_sys)
 906         return &amp;formats[i];
 907     }
 908   }
 909 
 910   return NULL;
 911 }
 912 
 913 static gboolean
 914 caps_are_rtp_caps (const GstCaps * caps, const gchar * media, gchar ** format)
 915 {
 916   const GstStructure *s;
 917   const gchar *str;
 918 
 919   g_assert (media != NULL &amp;&amp; format != NULL);
 920 
 921   s = gst_caps_get_structure (caps, 0);
 922   if (!gst_structure_has_name (s, &quot;application/x-rtp&quot;))
 923     return FALSE;
 924   if (!gst_structure_has_field_typed (s, &quot;media&quot;, G_TYPE_STRING))
 925     return FALSE;
 926   str = gst_structure_get_string (s, &quot;media&quot;);
 927   if (str == NULL || !g_str_equal (str, media))
 928     return FALSE;
 929   str = gst_structure_get_string (s, &quot;encoding-name&quot;);
 930   if (str == NULL || *str == &#39;\0&#39;)
 931     return FALSE;
 932 
 933   if (strcmp (str, &quot;X-ASF-PF&quot;) == 0) {
 934     *format = g_strdup (&quot;Windows Media&quot;);
 935   } else if (g_str_has_prefix (str, &quot;X-&quot;)) {
 936     *format = g_strdup (str + 2);
 937   } else {
 938     *format = g_strdup (str);
 939   }
 940 
 941   return TRUE;
 942 }
 943 
 944 /**
 945  * gst_pb_utils_get_source_description:
 946  * @protocol: the protocol the source element needs to handle, e.g. &quot;http&quot;
 947  *
 948  * Returns a localised string describing a source element handling the protocol
 949  * specified in @protocol, for use in error dialogs or other messages to be
 950  * seen by the user. Should never return NULL unless @protocol is invalid.
 951  *
 952  * This function is mainly for internal use, applications would typically
 953  * use gst_missing_plugin_message_get_description() to get a description of
 954  * a missing feature from a missing-plugin message.
 955  *
 956  * Returns: a newly-allocated description string, or NULL on error. Free
 957  *          string with g_free() when not needed any longer.
 958  */
 959 gchar *
 960 gst_pb_utils_get_source_description (const gchar * protocol)
 961 {
 962   gchar *proto_uc, *ret;
 963 
 964   g_return_val_if_fail (protocol != NULL, NULL);
 965 
 966   gst_pb_utils_init_locale_text_domain ();
 967 
 968   if (strcmp (protocol, &quot;cdda&quot;) == 0)
 969     return g_strdup (_(&quot;Audio CD source&quot;));
 970 
 971   if (strcmp (protocol, &quot;dvd&quot;) == 0)
 972     return g_strdup (_(&quot;DVD source&quot;));
 973 
 974   if (strcmp (protocol, &quot;rtsp&quot;) == 0)
 975     return g_strdup (_(&quot;Real Time Streaming Protocol (RTSP) source&quot;));
 976 
 977   /* TODO: what about mmst, mmsu, mmsh? */
 978   if (strcmp (protocol, &quot;mms&quot;) == 0)
 979     return g_strdup (_(&quot;Microsoft Media Server (MMS) protocol source&quot;));
 980 
 981   /* make protocol uppercase */
 982   proto_uc = g_ascii_strup (protocol, -1);
 983 
 984   /* TODO: find out how to add a comment for translators to the source code
 985    * (and tell them to make the first letter uppercase below if they move
 986    * the protocol to the middle or end of the string) */
 987   ret = g_strdup_printf (_(&quot;%s protocol source&quot;), proto_uc);
 988 
 989   g_free (proto_uc);
 990 
 991   return ret;
 992 }
 993 
 994 /**
 995  * gst_pb_utils_get_sink_description:
 996  * @protocol: the protocol the sink element needs to handle, e.g. &quot;http&quot;
 997  *
 998  * Returns a localised string describing a sink element handling the protocol
 999  * specified in @protocol, for use in error dialogs or other messages to be
1000  * seen by the user. Should never return NULL unless @protocol is invalid.
1001  *
1002  * This function is mainly for internal use, applications would typically
1003  * use gst_missing_plugin_message_get_description() to get a description of
1004  * a missing feature from a missing-plugin message.
1005  *
1006  * Returns: a newly-allocated description string, or NULL on error. Free
1007  *          string with g_free() when not needed any longer.
1008  */
1009 gchar *
1010 gst_pb_utils_get_sink_description (const gchar * protocol)
1011 {
1012   gchar *proto_uc, *ret;
1013 
1014   g_return_val_if_fail (protocol != NULL, NULL);
1015 
1016   /* make protocol uppercase */
1017   proto_uc = g_ascii_strup (protocol, -1);
1018 
1019   /* TODO: find out how to add a comment for translators to the source code
1020    * (and tell them to make the first letter uppercase below if they move
1021    * the protocol to the middle or end of the string) */
1022   ret = g_strdup_printf (&quot;%s protocol sink&quot;, proto_uc);
1023 
1024   g_free (proto_uc);
1025 
1026   return ret;
1027 }
1028 
1029 /**
1030  * gst_pb_utils_get_decoder_description:
1031  * @caps: the (fixed) #GstCaps for which an decoder description is needed
1032  *
1033  * Returns a localised string describing an decoder for the format specified
1034  * in @caps, for use in error dialogs or other messages to be seen by the user.
1035  * Should never return NULL unless @factory_name or @caps are invalid.
1036  *
1037  * This function is mainly for internal use, applications would typically
1038  * use gst_missing_plugin_message_get_description() to get a description of
1039  * a missing feature from a missing-plugin message.
1040  *
1041  * Returns: a newly-allocated description string, or NULL on error. Free
1042  *          string with g_free() when not needed any longer.
1043  */
1044 gchar *
1045 gst_pb_utils_get_decoder_description (const GstCaps * caps)
1046 {
1047   gchar *str, *ret;
1048   GstCaps *tmp;
1049 
1050   g_return_val_if_fail (caps != NULL, NULL);
1051   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1052 
1053   tmp = copy_and_clean_caps (caps);
1054 
1055   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1056 
1057   gst_pb_utils_init_locale_text_domain ();
1058 
1059   /* special-case RTP caps */
1060   if (caps_are_rtp_caps (tmp, &quot;video&quot;, &amp;str)) {
1061     ret = g_strdup_printf (_(&quot;%s video RTP depayloader&quot;), str);
1062   } else if (caps_are_rtp_caps (tmp, &quot;audio&quot;, &amp;str)) {
1063     ret = g_strdup_printf (_(&quot;%s audio RTP depayloader&quot;), str);
1064   } else if (caps_are_rtp_caps (tmp, &quot;application&quot;, &amp;str)) {
1065     ret = g_strdup_printf (_(&quot;%s RTP depayloader&quot;), str);
1066   } else {
1067     const FormatInfo *info;
1068 
1069     str = gst_pb_utils_get_codec_description (tmp);
1070     info = find_format_info (tmp);
1071     if (info != NULL &amp;&amp; (info-&gt;flags &amp; FLAG_CONTAINER) != 0) {
1072       ret = g_strdup_printf (_(&quot;%s demuxer&quot;), str);
1073     } else {
1074       ret = g_strdup_printf (_(&quot;%s decoder&quot;), str);
1075     }
1076   }
1077 
1078   g_free (str);
1079   gst_caps_unref (tmp);
1080 
1081   return ret;
1082 }
1083 
1084 /**
1085  * gst_pb_utils_get_encoder_description:
1086  * @caps: the (fixed) #GstCaps for which an encoder description is needed
1087  *
1088  * Returns a localised string describing an encoder for the format specified
1089  * in @caps, for use in error dialogs or other messages to be seen by the user.
1090  * Should never return NULL unless @factory_name or @caps are invalid.
1091  *
1092  * This function is mainly for internal use, applications would typically
1093  * use gst_missing_plugin_message_get_description() to get a description of
1094  * a missing feature from a missing-plugin message.
1095  *
1096  * Returns: a newly-allocated description string, or NULL on error. Free
1097  *          string with g_free() when not needed any longer.
1098  */
1099 gchar *
1100 gst_pb_utils_get_encoder_description (const GstCaps * caps)
1101 {
1102   gchar *str, *ret;
1103   GstCaps *tmp;
1104 
1105   g_return_val_if_fail (caps != NULL, NULL);
1106   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1107   tmp = copy_and_clean_caps (caps);
1108   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1109   gst_pb_utils_init_locale_text_domain ();
1110 
1111   /* special-case RTP caps */
1112   if (caps_are_rtp_caps (tmp, &quot;video&quot;, &amp;str)) {
1113     ret = g_strdup_printf (_(&quot;%s video RTP payloader&quot;), str);
1114   } else if (caps_are_rtp_caps (tmp, &quot;audio&quot;, &amp;str)) {
1115     ret = g_strdup_printf (_(&quot;%s audio RTP payloader&quot;), str);
1116   } else if (caps_are_rtp_caps (tmp, &quot;application&quot;, &amp;str)) {
1117     ret = g_strdup_printf (_(&quot;%s RTP payloader&quot;), str);
1118   } else {
1119     const FormatInfo *info;
1120 
1121     str = gst_pb_utils_get_codec_description (tmp);
1122     info = find_format_info (tmp);
1123     if (info != NULL &amp;&amp; (info-&gt;flags &amp; FLAG_CONTAINER) != 0) {
1124       ret = g_strdup_printf (_(&quot;%s muxer&quot;), str);
1125     } else {
1126       ret = g_strdup_printf (_(&quot;%s encoder&quot;), str);
1127     }
1128   }
1129 
1130   g_free (str);
1131   gst_caps_unref (tmp);
1132 
1133   return ret;
1134 }
1135 
1136 /**
1137  * gst_pb_utils_get_element_description:
1138  * @factory_name: the name of the element, e.g. &quot;giosrc&quot;
1139  *
1140  * Returns a localised string describing the given element, for use in
1141  * error dialogs or other messages to be seen by the user. Should never
1142  * return NULL unless @factory_name is invalid.
1143  *
1144  * This function is mainly for internal use, applications would typically
1145  * use gst_missing_plugin_message_get_description() to get a description of
1146  * a missing feature from a missing-plugin message.
1147  *
1148  * Returns: a newly-allocated description string, or NULL on error. Free
1149  *          string with g_free() when not needed any longer.
1150  */
1151 gchar *
1152 gst_pb_utils_get_element_description (const gchar * factory_name)
1153 {
1154   gchar *ret;
1155 
1156   g_return_val_if_fail (factory_name != NULL, NULL);
1157 
1158   gst_pb_utils_init_locale_text_domain ();
1159 
1160   ret = g_strdup_printf (_(&quot;GStreamer element %s&quot;), factory_name);
1161   if (ret &amp;&amp; g_str_has_prefix (ret, factory_name))
1162     *ret = g_ascii_toupper (*ret);
1163 
1164   return ret;
1165 }
1166 
1167 /**
1168  * gst_pb_utils_add_codec_description_to_tag_list:
1169  * @taglist: a #GstTagList
1170  * @codec_tag: (allow-none): a GStreamer codec tag such as #GST_TAG_AUDIO_CODEC,
1171  *             #GST_TAG_VIDEO_CODEC or #GST_TAG_CODEC. If none is specified,
1172  *             the function will attempt to detect the appropriate category.
1173  * @caps: the (fixed) #GstCaps for which a codec tag should be added.
1174  *
1175  * Adds a codec tag describing the format specified by @caps to @taglist.
1176  *
1177  * Returns: TRUE if a codec tag was added, FALSE otherwise.
1178  */
1179 gboolean
1180 gst_pb_utils_add_codec_description_to_tag_list (GstTagList * taglist,
1181     const gchar * codec_tag, const GstCaps * caps)
1182 {
1183   const FormatInfo *info;
1184   gchar *desc;
1185 
1186   g_return_val_if_fail (taglist != NULL, FALSE);
1187   g_return_val_if_fail (GST_IS_TAG_LIST (taglist), FALSE);
1188   g_return_val_if_fail (codec_tag == NULL || (gst_tag_exists (codec_tag)
1189           &amp;&amp; gst_tag_get_type (codec_tag) == G_TYPE_STRING), FALSE);
1190   g_return_val_if_fail (caps != NULL, FALSE);
1191   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1192 
1193   info = find_format_info (caps);
1194   if (info == NULL)
1195     return FALSE;
1196 
1197   /* Attempt to find tag classification */
1198   if (codec_tag == NULL) {
1199     if (info-&gt;flags &amp; FLAG_CONTAINER)
1200       codec_tag = GST_TAG_CONTAINER_FORMAT;
1201     else if (info-&gt;flags &amp; FLAG_AUDIO)
1202       codec_tag = GST_TAG_AUDIO_CODEC;
1203     else if (info-&gt;flags &amp; FLAG_VIDEO)
1204       codec_tag = GST_TAG_VIDEO_CODEC;
1205     else if (info-&gt;flags &amp; FLAG_SUB)
1206       codec_tag = GST_TAG_SUBTITLE_CODEC;
1207     else
1208       codec_tag = GST_TAG_CODEC;
1209   }
1210 
1211   desc = format_info_get_desc (info, caps);
1212   gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, codec_tag, desc, NULL);
1213   g_free (desc);
1214 
1215   return TRUE;
1216 }
1217 
1218 /**
1219  * gst_pb_utils_get_codec_description:
1220  * @caps: the (fixed) #GstCaps for which an format description is needed
1221  *
1222  * Returns a localised (as far as this is possible) string describing the
1223  * media format specified in @caps, for use in error dialogs or other messages
1224  * to be seen by the user. Should never return NULL unless @caps is invalid.
1225  *
1226  * Also see the convenience function
1227  * gst_pb_utils_add_codec_description_to_tag_list().
1228  *
1229  * Returns: a newly-allocated description string, or NULL on error. Free
1230  *          string with g_free() when not needed any longer.
1231  */
1232 gchar *
1233 gst_pb_utils_get_codec_description (const GstCaps * caps)
1234 {
1235   const FormatInfo *info;
1236   gchar *str, *comma;
1237   GstCaps *tmp;
1238 
1239   g_return_val_if_fail (caps != NULL, NULL);
1240   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1241   tmp = copy_and_clean_caps (caps);
1242   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1243 
1244   info = find_format_info (tmp);
1245 
1246   if (info) {
1247     str = format_info_get_desc (info, tmp);
1248   } else {
1249     str = gst_caps_to_string (tmp);
1250 
1251     /* cut off everything after the media type, if there is anything */
1252     if ((comma = strchr (str, &#39;,&#39;))) {
1253       *comma = &#39;\0&#39;;
1254       g_strchomp (str);
1255       /* we could do something more elaborate here, like taking into account
1256        * audio/, video/, image/ and application/ prefixes etc. */
1257     }
1258 
1259     GST_WARNING (&quot;No description available for media type: %s&quot;, str);
1260   }
1261   gst_caps_unref (tmp);
1262 
1263   return str;
1264 }
1265 
1266 /* internal helper functions for gst_encoding_profile_get_file_extension() */
1267 const gchar *pb_utils_get_file_extension_from_caps (const GstCaps * caps);
1268 gboolean pb_utils_is_tag (const GstCaps * caps);
1269 
1270 const gchar *
1271 pb_utils_get_file_extension_from_caps (const GstCaps * caps)
1272 {
1273   const FormatInfo *info;
1274   const gchar *ext = NULL;
1275   GstCaps *stripped_caps;
1276 
1277   g_assert (GST_IS_CAPS (caps));
1278 
1279   stripped_caps = copy_and_clean_caps (caps);
1280 
1281   g_assert (gst_caps_is_fixed (stripped_caps));
1282 
1283   info = find_format_info (stripped_caps);
1284 
1285   if (info &amp;&amp; info-&gt;ext[0] != &#39;\0&#39;) {
1286     ext = info-&gt;ext;
1287   } else if (info &amp;&amp; info-&gt;desc == NULL) {
1288     const GstStructure *s;
1289 
1290     s = gst_caps_get_structure (stripped_caps, 0);
1291 
1292     /* cases where we have to evaluate the caps more closely */
1293     if (strcmp (info-&gt;type, &quot;audio/mpeg&quot;) == 0) {
1294       int version = 0, layer = 3;
1295 
1296       if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;version)) {
1297         if (version == 2 || version == 4) {
1298           ext = &quot;aac&quot;;
1299         } else if (version == 1) {
1300           gst_structure_get_int (s, &quot;layer&quot;, &amp;layer);
1301           if (layer == 1)
1302             ext = &quot;mp1&quot;;
1303           else if (layer == 2)
1304             ext = &quot;mp2&quot;;
1305           else
1306             ext = &quot;mp3&quot;;
1307         }
1308       }
1309     }
1310   }
1311 
1312   gst_caps_unref (stripped_caps);
1313   return ext;
1314 }
1315 
1316 gboolean
1317 pb_utils_is_tag (const GstCaps * caps)
1318 {
1319   const FormatInfo *info;
1320   GstCaps *stripped_caps;
1321   gboolean is_tag = FALSE;
1322 
1323   g_assert (GST_IS_CAPS (caps));
1324 
1325   stripped_caps = copy_and_clean_caps (caps);
1326 
1327   g_assert (gst_caps_is_fixed (stripped_caps));
1328 
1329   info = find_format_info (stripped_caps);
1330 
1331   if (info) {
1332     is_tag = (info-&gt;flags &amp; FLAG_TAG) != 0;
1333   }
1334   gst_caps_unref (stripped_caps);
1335 
1336   return is_tag;
1337 }
1338 
1339 #if 0
1340 void
1341 gst_pb_utils_list_all (void)
1342 {
1343   gint i;
1344 
1345   g_print (&quot;static const gchar *caps_strings[] = { &quot;);
1346 
1347   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
1348     if (formats[i].desc != NULL)
1349       g_print (&quot;  \&quot;%s\&quot;, &quot;, formats[i].type);
1350   }
1351   g_print (&quot;\n#if 0\n&quot;);
1352   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
1353     if (formats[i].desc == NULL)
1354       g_print (&quot;  \&quot;%s\&quot;, \n&quot;, formats[i].type);
1355   }
1356   g_print (&quot;\n#endif\n&quot;);
1357 }
1358 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>