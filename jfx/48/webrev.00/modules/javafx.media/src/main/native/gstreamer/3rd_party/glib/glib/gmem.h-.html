<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 #ifndef __G_MEM_H__
 26 #define __G_MEM_H__
 27 
 28 #if !defined (__GLIB_H_INSIDE__) &amp;&amp; !defined (GLIB_COMPILATION)
 29 #error &quot;Only &lt;glib.h&gt; can be included directly.&quot;
 30 #endif
 31 
 32 #include &lt;glib/gutils.h&gt;
 33 
 34 G_BEGIN_DECLS
 35 
 36 /**
 37  * GMemVTable:
 38  * @malloc: function to use for allocating memory.
 39  * @realloc: function to use for reallocating memory.
 40  * @free: function to use to free memory.
 41  * @calloc: function to use for allocating zero-filled memory.
 42  * @try_malloc: function to use for allocating memory without a default error handler.
 43  * @try_realloc: function to use for reallocating memory without a default error handler.
 44  *
 45  * A set of functions used to perform memory allocation. The same #GMemVTable must
 46  * be used for all allocations in the same program; a call to g_mem_set_vtable(),
 47  * if it exists, should be prior to any use of GLib.
 48  *
 49  * This functions related to this has been deprecated in 2.46, and no longer work.
 50  */
 51 typedef struct _GMemVTable GMemVTable;
 52 
 53 
 54 #if GLIB_SIZEOF_VOID_P &gt; GLIB_SIZEOF_LONG
 55 /**
 56  * G_MEM_ALIGN:
 57  *
 58  * Indicates the number of bytes to which memory will be aligned on the
 59  * current platform.
 60  */
 61 #  define G_MEM_ALIGN   GLIB_SIZEOF_VOID_P
 62 #else   /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
 63 #  define G_MEM_ALIGN   GLIB_SIZEOF_LONG
 64 #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
 65 
 66 
 67 /* Memory allocation functions
 68  */
 69 
 70 GLIB_AVAILABLE_IN_ALL
 71 void     g_free           (gpointer  mem);
 72 
 73 GLIB_AVAILABLE_IN_2_34
 74 void     g_clear_pointer  (gpointer      *pp,
 75                            GDestroyNotify destroy);
 76 
 77 GLIB_AVAILABLE_IN_ALL
 78 gpointer g_malloc         (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 79 GLIB_AVAILABLE_IN_ALL
 80 gpointer g_malloc0        (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 81 GLIB_AVAILABLE_IN_ALL
 82 gpointer g_realloc        (gpointer  mem,
 83                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;
 84 GLIB_AVAILABLE_IN_ALL
 85 gpointer g_try_malloc     (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 86 GLIB_AVAILABLE_IN_ALL
 87 gpointer g_try_malloc0    (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 88 GLIB_AVAILABLE_IN_ALL
 89 gpointer g_try_realloc    (gpointer  mem,
 90                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;
 91 
 92 GLIB_AVAILABLE_IN_ALL
 93 gpointer g_malloc_n       (gsize     n_blocks,
 94                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 95 GLIB_AVAILABLE_IN_ALL
 96 gpointer g_malloc0_n      (gsize     n_blocks,
 97                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 98 GLIB_AVAILABLE_IN_ALL
 99 gpointer g_realloc_n      (gpointer  mem,
100                gsize     n_blocks,
101                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
102 GLIB_AVAILABLE_IN_ALL
103 gpointer g_try_malloc_n   (gsize     n_blocks,
104                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
105 GLIB_AVAILABLE_IN_ALL
106 gpointer g_try_malloc0_n  (gsize     n_blocks,
107                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
108 GLIB_AVAILABLE_IN_ALL
109 gpointer g_try_realloc_n  (gpointer  mem,
110                gsize     n_blocks,
111                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
112 
113 #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
114 #define g_clear_pointer(pp, destroy)                                           \
115   G_STMT_START {                                                               \
116     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
117     __typeof__((pp)) _pp = (pp);                                               \
118     __typeof__(*(pp)) _ptr = *_pp;                                             \
119     *_pp = NULL;                                                               \
120     if (_ptr)                                                                  \
121       (destroy) (_ptr);                                                        \
122   } G_STMT_END
123 #else /* __GNUC__ */
124 #define g_clear_pointer(pp, destroy) \
125   G_STMT_START {                                                               \
126     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
127     /* Only one access, please; work around type aliasing */                   \
128     union { char *in; gpointer *out; } _pp;                                    \
129     gpointer _p;                                                               \
130     /* This assignment is needed to avoid a gcc warning */                     \
131     GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
132                                                                                \
133     _pp.in = (char *) (pp);                                                    \
134     _p = *_pp.out;                                                             \
135     if (_p)                                        \
136       {                                        \
137         *_pp.out = NULL;                                                       \
138         _destroy (_p);                                                         \
139       }                                                                        \
140   } G_STMT_END
141 #endif /* __GNUC__ */
142 
143 /**
144  * g_steal_pointer:
145  * @pp: (not nullable): a pointer to a pointer
146  *
147  * Sets @pp to %NULL, returning the value that was there before.
148  *
149  * Conceptually, this transfers the ownership of the pointer from the
150  * referenced variable to the &quot;caller&quot; of the macro (ie: &quot;steals&quot; the
151  * reference).
152  *
153  * The return value will be properly typed, according to the type of
154  * @pp.
155  *
156  * This can be very useful when combined with g_autoptr() to prevent the
157  * return value of a function from being automatically freed.  Consider
158  * the following example (which only works on GCC and clang):
159  *
160  * |[
161  * GObject *
162  * create_object (void)
163  * {
164  *   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);
165  *
166  *   if (early_error_case)
167  *     return NULL;
168  *
169  *   return g_steal_pointer (&amp;obj);
170  * }
171  * ]|
172  *
173  * It can also be used in similar ways for &#39;out&#39; parameters and is
174  * particularly useful for dealing with optional out parameters:
175  *
176  * |[
177  * gboolean
178  * get_object (GObject **obj_out)
179  * {
180  *   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);
181  *
182  *   if (early_error_case)
183  *     return FALSE;
184  *
185  *   if (obj_out)
186  *     *obj_out = g_steal_pointer (&amp;obj);
187  *
188  *   return TRUE;
189  * }
190  * ]|
191  *
192  * In the above example, the object will be automatically freed in the
193  * early error case and also in the case that %NULL was given for
194  * @obj_out.
195  *
196  * Since: 2.44
197  */
198 static inline gpointer
199 g_steal_pointer (gpointer pp)
200 {
201   gpointer *ptr = (gpointer *) pp;
202   gpointer ref;
203 
204   ref = *ptr;
205   *ptr = NULL;
206 
207   return ref;
208 }
209 
210 /* type safety */
211 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 8)) &amp;&amp; !defined(__cplusplus) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
212 #define g_steal_pointer(pp) ((__typeof__(*pp)) (g_steal_pointer) (pp))
213 #else  /* __GNUC__ */
214 /* This version does not depend on gcc extensions, but gcc does not warn
215  * about incompatible-pointer-types: */
216 #define g_steal_pointer(pp) \
217   (0 ? (*(pp)) : (g_steal_pointer) (pp))
218 #endif /* __GNUC__ */
219 
220 /* Optimise: avoid the call to the (slower) _n function if we can
221  * determine at compile-time that no overflow happens.
222  */
223 #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
224 #  define _G_NEW(struct_type, n_structs, func) \
225     (struct_type *) (G_GNUC_EXTENSION ({            \
226       gsize __n = (gsize) (n_structs);          \
227       gsize __s = sizeof (struct_type);         \
228       gpointer __p;                     \
229       if (__s == 1)                     \
230         __p = g_##func (__n);               \
231       else if (__builtin_constant_p (__n) &amp;&amp;        \
232                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \
233         __p = g_##func (__n * __s);             \
234       else                          \
235         __p = g_##func##_n (__n, __s);          \
236       __p;                          \
237     }))
238 #  define _G_RENEW(struct_type, mem, n_structs, func) \
239     (struct_type *) (G_GNUC_EXTENSION ({            \
240       gsize __n = (gsize) (n_structs);          \
241       gsize __s = sizeof (struct_type);         \
242       gpointer __p = (gpointer) (mem);          \
243       if (__s == 1)                     \
244         __p = g_##func (__p, __n);              \
245       else if (__builtin_constant_p (__n) &amp;&amp;        \
246                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \
247         __p = g_##func (__p, __n * __s);            \
248       else                          \
249         __p = g_##func##_n (__p, __n, __s);         \
250       __p;                          \
251     }))
252 
253 #else
254 
255 /* Unoptimised version: always call the _n() function. */
256 
257 #define _G_NEW(struct_type, n_structs, func) \
258         ((struct_type *) g_##func##_n ((n_structs), sizeof (struct_type)))
259 #define _G_RENEW(struct_type, mem, n_structs, func) \
260         ((struct_type *) g_##func##_n (mem, (n_structs), sizeof (struct_type)))
261 
262 #endif
263 
264 /**
265  * g_new:
266  * @struct_type: the type of the elements to allocate
267  * @n_structs: the number of elements to allocate
268  *
269  * Allocates @n_structs elements of type @struct_type.
270  * The returned pointer is cast to a pointer to the given type.
271  * If @n_structs is 0 it returns %NULL.
272  * Care is taken to avoid overflow when calculating the size of the allocated block.
273  *
274  * Since the returned pointer is already casted to the right type,
275  * it is normally unnecessary to cast it explicitly, and doing
276  * so might hide memory allocation errors.
277  *
278  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
279  */
280 #define g_new(struct_type, n_structs)           _G_NEW (struct_type, n_structs, malloc)
281 /**
282  * g_new0:
283  * @struct_type: the type of the elements to allocate.
284  * @n_structs: the number of elements to allocate.
285  *
286  * Allocates @n_structs elements of type @struct_type, initialized to 0&#39;s.
287  * The returned pointer is cast to a pointer to the given type.
288  * If @n_structs is 0 it returns %NULL.
289  * Care is taken to avoid overflow when calculating the size of the allocated block.
290  *
291  * Since the returned pointer is already casted to the right type,
292  * it is normally unnecessary to cast it explicitly, and doing
293  * so might hide memory allocation errors.
294  *
295  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
296  */
297 #define g_new0(struct_type, n_structs)          _G_NEW (struct_type, n_structs, malloc0)
298 /**
299  * g_renew:
300  * @struct_type: the type of the elements to allocate
301  * @mem: the currently allocated memory
302  * @n_structs: the number of elements to allocate
303  *
304  * Reallocates the memory pointed to by @mem, so that it now has space for
305  * @n_structs elements of type @struct_type. It returns the new address of
306  * the memory, which may have been moved.
307  * Care is taken to avoid overflow when calculating the size of the allocated block.
308  *
309  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
310  */
311 #define g_renew(struct_type, mem, n_structs)        _G_RENEW (struct_type, mem, n_structs, realloc)
312 /**
313  * g_try_new:
314  * @struct_type: the type of the elements to allocate
315  * @n_structs: the number of elements to allocate
316  *
317  * Attempts to allocate @n_structs elements of type @struct_type, and returns
318  * %NULL on failure. Contrast with g_new(), which aborts the program on failure.
319  * The returned pointer is cast to a pointer to the given type.
320  * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
321  *
322  * Since: 2.8
323  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
324  */
325 #define g_try_new(struct_type, n_structs)       _G_NEW (struct_type, n_structs, try_malloc)
326 /**
327  * g_try_new0:
328  * @struct_type: the type of the elements to allocate
329  * @n_structs: the number of elements to allocate
330  *
331  * Attempts to allocate @n_structs elements of type @struct_type, initialized
332  * to 0&#39;s, and returns %NULL on failure. Contrast with g_new0(), which aborts
333  * the program on failure.
334  * The returned pointer is cast to a pointer to the given type.
335  * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
336  *
337  * Since: 2.8
338  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
339  */
340 #define g_try_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, try_malloc0)
341 /**
342  * g_try_renew:
343  * @struct_type: the type of the elements to allocate
344  * @mem: the currently allocated memory
345  * @n_structs: the number of elements to allocate
346  *
347  * Attempts to reallocate the memory pointed to by @mem, so that it now has
348  * space for @n_structs elements of type @struct_type, and returns %NULL on
349  * failure. Contrast with g_renew(), which aborts the program on failure.
350  * It returns the new address of the memory, which may have been moved.
351  * The function returns %NULL if an overflow occurs.
352  *
353  * Since: 2.8
354  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
355  */
356 #define g_try_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, try_realloc)
357 
358 
359 /* Memory allocation virtualization for debugging purposes
360  * g_mem_set_vtable() has to be the very first GLib function called
361  * if being used
362  */
363 struct _GMemVTable {
364   gpointer (*malloc)      (gsize    n_bytes);
365   gpointer (*realloc)     (gpointer mem,
366                gsize    n_bytes);
367   void     (*free)        (gpointer mem);
368   /* optional; set to NULL if not used ! */
369   gpointer (*calloc)      (gsize    n_blocks,
370                gsize    n_block_bytes);
371   gpointer (*try_malloc)  (gsize    n_bytes);
372   gpointer (*try_realloc) (gpointer mem,
373                gsize    n_bytes);
374 };
375 GLIB_DEPRECATED_IN_2_46
376 void     g_mem_set_vtable (GMemVTable   *vtable);
377 GLIB_DEPRECATED_IN_2_46
378 gboolean g_mem_is_system_malloc (void);
379 
380 GLIB_VAR gboolean g_mem_gc_friendly;
381 
382 /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
383  */
384 GLIB_VAR GMemVTable *glib_mem_profiler_table;
385 GLIB_DEPRECATED_IN_2_46
386 void    g_mem_profile   (void);
387 
388 G_END_DECLS
389 
390 #endif /* __G_MEM_H__ */
    </pre>
  </body>
</html>