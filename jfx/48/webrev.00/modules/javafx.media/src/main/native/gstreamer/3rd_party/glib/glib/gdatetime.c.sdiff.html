<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdatetime.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gdate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdatetime.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdatetime.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /* gdatetime.c
   2  *
   3  * Copyright (C) 2009-2010 Christian Hergert &lt;chris@dronelabs.com&gt;
   4  * Copyright (C) 2010 Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
   5  * Copyright (C) 2010 Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
<span class="line-modified">   6  * Copyright � 2010 Codethink Limited</span>
<span class="line-modified">   7  * Copyright � 2018 Tomasz Mi?sko</span>
   8  *
   9  * This library is free software; you can redistribute it and/or modify
  10  * it under the terms of the GNU Lesser General Public License as
  11  * published by the Free Software Foundation; either version 2.1 of the
  12  * licence, or (at your option) any later version.
  13  *
  14  * This is distributed in the hope that it will be useful, but WITHOUT
  15  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  16  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
  17  * License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public License
  20  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  21  *
  22  * Authors: Christian Hergert &lt;chris@dronelabs.com&gt;
  23  *          Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
  24  *          Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
  25  *          Ryan Lortie &lt;desrt@desrt.ca&gt;
  26  *          Robert Ancell &lt;robert.ancell@canonical.com&gt;
  27  */
</pre>
<hr />
<pre>
 117 struct _GDateTime
 118 {
 119   /* Microsecond timekeeping within Day */
 120   guint64 usec;
 121 
 122   /* TimeZone information */
 123   GTimeZone *tz;
 124   gint interval;
 125 
 126   /* 1 is 0001-01-01 in Proleptic Gregorian */
 127   gint32 days;
 128 
 129   volatile gint ref_count;
 130 };
 131 
 132 /* Time conversion {{{1 */
 133 
 134 #define UNIX_EPOCH_START     719163
 135 #define INSTANT_TO_UNIX(instant) \
 136   ((instant)/USEC_PER_SECOND - UNIX_EPOCH_START * SEC_PER_DAY)


 137 #define UNIX_TO_INSTANT(unix) \
 138   (((gint64) (unix) + UNIX_EPOCH_START * SEC_PER_DAY) * USEC_PER_SECOND)


 139 #define UNIX_TO_INSTANT_IS_VALID(unix) \
 140   ((gint64) (unix) &lt;= INSTANT_TO_UNIX (G_MAXINT64))


 141 
 142 #define DAYS_IN_4YEARS    1461    /* days in 4 years */
 143 #define DAYS_IN_100YEARS  36524   /* days in 100 years */
 144 #define DAYS_IN_400YEARS  146097  /* days in 400 years  */
 145 
 146 #define USEC_PER_SECOND      (G_GINT64_CONSTANT (1000000))
 147 #define USEC_PER_MINUTE      (G_GINT64_CONSTANT (60000000))
 148 #define USEC_PER_HOUR        (G_GINT64_CONSTANT (3600000000))
 149 #define USEC_PER_MILLISECOND (G_GINT64_CONSTANT (1000))
 150 #define USEC_PER_DAY         (G_GINT64_CONSTANT (86400000000))
 151 #define SEC_PER_DAY          (G_GINT64_CONSTANT (86400))
 152 
 153 #define SECS_PER_MINUTE (60)
 154 #define SECS_PER_HOUR   (60 * SECS_PER_MINUTE)
 155 #define SECS_PER_DAY    (24 * SECS_PER_HOUR)
 156 #define SECS_PER_YEAR   (365 * SECS_PER_DAY)
 157 #define SECS_PER_JULIAN (DAYS_PER_PERIOD * SECS_PER_DAY)
 158 
 159 #define GREGORIAN_LEAP(y)    ((((y) % 4) == 0) &amp;&amp; (!((((y) % 100) == 0) &amp;&amp; (((y) % 400) != 0))))
 160 #define JULIAN_YEAR(d)       ((d)-&gt;julian / 365.25)
</pre>
<hr />
<pre>
 724  * microsecond in time, taking time zone considerations into account.
 725  * (ie: &quot;03:00 -0400&quot; is the same instant as &quot;02:00 -0500&quot;).
 726  *
 727  * An instant is always positive but we use a signed return value to
 728  * avoid troubles with C.
 729  */
 730 static gint64
 731 g_date_time_to_instant (GDateTime *datetime)
 732 {
 733   gint64 offset;
 734 
 735   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 736   offset *= USEC_PER_SECOND;
 737 
 738   return datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec - offset;
 739 }
 740 
 741 /*&lt; internal &gt;
 742  * g_date_time_from_instant:
 743  * @tz: a #GTimeZone
<span class="line-modified"> 744  * @instant: a instant in time</span>
 745  *
 746  * Creates a #GDateTime from a time zone and an instant.
 747  *
 748  * This might fail if the time ends up being out of range.
 749  */
 750 static GDateTime *
 751 g_date_time_from_instant (GTimeZone *tz,
 752                           gint64     instant)
 753 {
 754   GDateTime *datetime;
 755   gint64 offset;
 756 
 757   if (instant &lt; 0 || instant &gt; G_GINT64_CONSTANT (1000000000000000000))
 758     return NULL;
 759 
 760   datetime = g_date_time_alloc (tz);
 761   datetime-&gt;interval = g_time_zone_find_interval (tz,
 762                                                   G_TIME_TYPE_UNIVERSAL,
 763                                                   INSTANT_TO_UNIX (instant));
 764   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
</pre>
<hr />
<pre>
 837                           gint       days)
 838 {
 839   GDateTime *new;
 840 
 841   new = g_date_time_alloc (datetime-&gt;tz);
 842   new-&gt;interval = datetime-&gt;interval;
 843   new-&gt;usec = datetime-&gt;usec;
 844   new-&gt;days = days;
 845 
 846   if (!g_date_time_deal_with_date_change (new))
 847     {
 848       g_date_time_unref (new);
 849       new = NULL;
 850     }
 851 
 852   return new;
 853 }
 854 
 855 /* now/unix/timeval Constructors {{{1 */
 856 

 857 /*&lt; internal &gt;
 858  * g_date_time_new_from_timeval:
 859  * @tz: a #GTimeZone
 860  * @tv: a #GTimeVal
 861  *
 862  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
 863  * given time zone @tz.
 864  *
 865  * The time contained in a #GTimeVal is always stored in the form of
 866  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
 867  * given time zone.
 868  *
 869  * This call can fail (returning %NULL) if @tv represents a time outside
 870  * of the supported range of #GDateTime.
 871  *
 872  * You should release the return value by calling g_date_time_unref()
 873  * when you are done with it.
 874  *
 875  * Returns: a new #GDateTime, or %NULL
 876  *
 877  * Since: 2.26
 878  **/
 879 static GDateTime *
 880 g_date_time_new_from_timeval (GTimeZone      *tz,
 881                               const GTimeVal *tv)
 882 {
 883   if ((gint64) tv-&gt;tv_sec &gt; G_MAXINT64 - 1 ||
 884       !UNIX_TO_INSTANT_IS_VALID ((gint64) tv-&gt;tv_sec + 1))
 885     return NULL;
 886 
 887   return g_date_time_from_instant (tz, tv-&gt;tv_usec +
 888                                    UNIX_TO_INSTANT (tv-&gt;tv_sec));
 889 }

 890 
 891 /*&lt; internal &gt;
 892  * g_date_time_new_from_unix:
 893  * @tz: a #GTimeZone
<span class="line-modified"> 894  * @t: the Unix time</span>
 895  *
<span class="line-modified"> 896  * Creates a #GDateTime corresponding to the given Unix time @t in the</span>
 897  * given time zone @tz.
 898  *
 899  * Unix time is the number of seconds that have elapsed since 1970-01-01
 900  * 00:00:00 UTC, regardless of the time zone given.
 901  *
 902  * This call can fail (returning %NULL) if @t represents a time outside
 903  * of the supported range of #GDateTime.
 904  *
 905  * You should release the return value by calling g_date_time_unref()
 906  * when you are done with it.
 907  *
 908  * Returns: a new #GDateTime, or %NULL
 909  *
 910  * Since: 2.26
 911  **/
 912 static GDateTime *
 913 g_date_time_new_from_unix (GTimeZone *tz,
<span class="line-modified"> 914                            gint64     secs)</span>
 915 {
<span class="line-modified"> 916   if (!UNIX_TO_INSTANT_IS_VALID (secs))</span>
 917     return NULL;
 918 
<span class="line-modified"> 919   return g_date_time_from_instant (tz, UNIX_TO_INSTANT (secs));</span>
 920 }
 921 
 922 /**
 923  * g_date_time_new_now:
 924  * @tz: a #GTimeZone
 925  *
 926  * Creates a #GDateTime corresponding to this exact instant in the given
 927  * time zone @tz.  The time is as accurate as the system allows, to a
 928  * maximum accuracy of 1 microsecond.
 929  *
 930  * This function will always succeed unless the system clock is set to
 931  * truly insane values (or unless GLib is still being used after the
 932  * year 9999).
 933  *
 934  * You should release the return value by calling g_date_time_unref()
 935  * when you are done with it.
 936  *
 937  * Returns: a new #GDateTime, or %NULL
 938  *
 939  * Since: 2.26
 940  **/
 941 GDateTime *
 942 g_date_time_new_now (GTimeZone *tz)
 943 {
<span class="line-modified"> 944   GTimeVal tv;</span>
 945 
<span class="line-modified"> 946   g_get_current_time (&amp;tv);</span>
 947 
<span class="line-modified"> 948   return g_date_time_new_from_timeval (tz, &amp;tv);</span>
 949 }
 950 
 951 /**
 952  * g_date_time_new_now_local:
 953  *
 954  * Creates a #GDateTime corresponding to this exact instant in the local
 955  * time zone.
 956  *
 957  * This is equivalent to calling g_date_time_new_now() with the time
 958  * zone returned by g_time_zone_new_local().
 959  *
 960  * Returns: a new #GDateTime, or %NULL
 961  *
 962  * Since: 2.26
 963  **/
 964 GDateTime *
 965 g_date_time_new_now_local (void)
 966 {
 967   GDateTime *datetime;
 968   GTimeZone *local;
</pre>
<hr />
<pre>
1008  *
1009  * Unix time is the number of seconds that have elapsed since 1970-01-01
1010  * 00:00:00 UTC, regardless of the local time offset.
1011  *
1012  * This call can fail (returning %NULL) if @t represents a time outside
1013  * of the supported range of #GDateTime.
1014  *
1015  * You should release the return value by calling g_date_time_unref()
1016  * when you are done with it.
1017  *
1018  * Returns: a new #GDateTime, or %NULL
1019  *
1020  * Since: 2.26
1021  **/
1022 GDateTime *
1023 g_date_time_new_from_unix_local (gint64 t)
1024 {
1025   GDateTime *datetime;
1026   GTimeZone *local;
1027 



1028   local = g_time_zone_new_local ();
<span class="line-modified">1029   datetime = g_date_time_new_from_unix (local, t);</span>
1030   g_time_zone_unref (local);
1031 
1032   return datetime;
1033 }
1034 
1035 /**
1036  * g_date_time_new_from_unix_utc:
1037  * @t: the Unix time
1038  *
1039  * Creates a #GDateTime corresponding to the given Unix time @t in UTC.
1040  *
1041  * Unix time is the number of seconds that have elapsed since 1970-01-01
1042  * 00:00:00 UTC.
1043  *
1044  * This call can fail (returning %NULL) if @t represents a time outside
1045  * of the supported range of #GDateTime.
1046  *
1047  * You should release the return value by calling g_date_time_unref()
1048  * when you are done with it.
1049  *
1050  * Returns: a new #GDateTime, or %NULL
1051  *
1052  * Since: 2.26
1053  **/
1054 GDateTime *
1055 g_date_time_new_from_unix_utc (gint64 t)
1056 {
1057   GDateTime *datetime;
1058   GTimeZone *utc;
1059 



1060   utc = g_time_zone_new_utc ();
<span class="line-modified">1061   datetime = g_date_time_new_from_unix (utc, t);</span>
1062   g_time_zone_unref (utc);
1063 
1064   return datetime;
1065 }
1066 
1067 /**
1068  * g_date_time_new_from_timeval_local:
1069  * @tv: a #GTimeVal
1070  *
1071  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
1072  * local time zone.
1073  *
1074  * The time contained in a #GTimeVal is always stored in the form of
1075  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
1076  * local time offset.
1077  *
1078  * This call can fail (returning %NULL) if @tv represents a time outside
1079  * of the supported range of #GDateTime.
1080  *
1081  * You should release the return value by calling g_date_time_unref()
1082  * when you are done with it.
1083  *
1084  * Returns: a new #GDateTime, or %NULL
1085  *
1086  * Since: 2.26


1087  **/

1088 GDateTime *
1089 g_date_time_new_from_timeval_local (const GTimeVal *tv)
1090 {
1091   GDateTime *datetime;
1092   GTimeZone *local;
1093 
1094   local = g_time_zone_new_local ();
1095   datetime = g_date_time_new_from_timeval (local, tv);
1096   g_time_zone_unref (local);
1097 
1098   return datetime;
1099 }

1100 
1101 /**
1102  * g_date_time_new_from_timeval_utc:
1103  * @tv: a #GTimeVal
1104  *
1105  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
1106  *
1107  * The time contained in a #GTimeVal is always stored in the form of
1108  * seconds elapsed since 1970-01-01 00:00:00 UTC.
1109  *
1110  * This call can fail (returning %NULL) if @tv represents a time outside
1111  * of the supported range of #GDateTime.
1112  *
1113  * You should release the return value by calling g_date_time_unref()
1114  * when you are done with it.
1115  *
1116  * Returns: a new #GDateTime, or %NULL
1117  *
1118  * Since: 2.26


1119  **/

1120 GDateTime *
1121 g_date_time_new_from_timeval_utc (const GTimeVal *tv)
1122 {
1123   GDateTime *datetime;
1124   GTimeZone *utc;
1125 
1126   utc = g_time_zone_new_utc ();
1127   datetime = g_date_time_new_from_timeval (utc, tv);
1128   g_time_zone_unref (utc);
1129 
1130   return datetime;
1131 }

1132 
1133 /* Parse integers in the form d (week days), dd (hours etc), ddd (ordinal days) or dddd (years) */
1134 static gboolean
1135 get_iso8601_int (const gchar *text, gsize length, gint *value)
1136 {
<span class="line-modified">1137   gint i, v = 0;</span>

1138 
1139   if (length &lt; 1 || length &gt; 4)
1140     return FALSE;
1141 
1142   for (i = 0; i &lt; length; i++)
1143     {
1144       const gchar c = text[i];
1145       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1146         return FALSE;
1147       v = v * 10 + (c - &#39;0&#39;);
1148     }
1149 
1150   *value = v;
1151   return TRUE;
1152 }
1153 
1154 /* Parse seconds in the form ss or ss.sss (variable length decimal) */
1155 static gboolean
1156 get_iso8601_seconds (const gchar *text, gsize length, gdouble *value)
1157 {
<span class="line-modified">1158   gint i;</span>
1159   gdouble divisor = 1, v = 0;
1160 
1161   if (length &lt; 2)
1162     return FALSE;
1163 
1164   for (i = 0; i &lt; 2; i++)
1165     {
1166       const gchar c = text[i];
1167       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1168         return FALSE;
1169       v = v * 10 + (c - &#39;0&#39;);
1170     }
1171 
1172   if (length &gt; 2 &amp;&amp; !(text[i] == &#39;.&#39; || text[i] == &#39;,&#39;))
1173     return FALSE;
1174   i++;
1175   if (i == length)
1176     return FALSE;
1177 
1178   for (; i &lt; length; i++)
</pre>
<hr />
<pre>
1180       const gchar c = text[i];
1181       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1182         return FALSE;
1183       v = v * 10 + (c - &#39;0&#39;);
1184       divisor *= 10;
1185     }
1186 
1187   *value = v / divisor;
1188   return TRUE;
1189 }
1190 
1191 static GDateTime *
1192 g_date_time_new_ordinal (GTimeZone *tz, gint year, gint ordinal_day, gint hour, gint minute, gdouble seconds)
1193 {
1194   GDateTime *dt;
1195 
1196   if (ordinal_day &lt; 1 || ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1197     return NULL;
1198 
1199   dt = g_date_time_new (tz, year, 1, 1, hour, minute, seconds);
<span class="line-modified">1200 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">1201   if (dt == NULL) {</span>
1202     return NULL;
<span class="line-removed">1203   }</span>
<span class="line-removed">1204 #endif // GSTREAMER_LITE</span>
1205   dt-&gt;days += ordinal_day - 1;
1206 
1207   return dt;
1208 }
1209 
1210 static GDateTime *
1211 g_date_time_new_week (GTimeZone *tz, gint year, gint week, gint week_day, gint hour, gint minute, gdouble seconds)
1212 {
1213   gint64 p;
1214   gint max_week, jan4_week_day, ordinal_day;
1215   GDateTime *dt;
1216 
1217   p = (year * 365 + (year / 4) - (year / 100) + (year / 400)) % 7;
1218   max_week = p == 4 ? 53 : 52;
1219 
1220   if (week &lt; 1 || week &gt; max_week || week_day &lt; 1 || week_day &gt; 7)
1221     return NULL;
1222 
1223   dt = g_date_time_new (tz, year, 1, 4, 0, 0, 0);


1224   g_date_time_get_week_number (dt, NULL, &amp;jan4_week_day, NULL);
1225   g_date_time_unref (dt);
1226 
1227   ordinal_day = (week * 7) + week_day - (jan4_week_day + 3);
1228   if (ordinal_day &lt; 0)
1229     {
1230       year--;
1231       ordinal_day += GREGORIAN_LEAP (year) ? 366 : 365;
1232     }
1233   else if (ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1234     {
1235       ordinal_day -= (GREGORIAN_LEAP (year) ? 366 : 365);
1236       year++;
1237     }
1238 
1239   return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1240 }
1241 
1242 static GDateTime *
1243 parse_iso8601_date (const gchar *text, gsize length,
</pre>
<hr />
<pre>
1291           !get_iso8601_int (text + 6, 2, &amp;day))
1292         return NULL;
1293       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1294     }
1295   /* YYYYDDD */
1296   else if (length == 7)
1297     {
1298       gint year, ordinal_day;
1299       if (!get_iso8601_int (text, 4, &amp;year) ||
1300           !get_iso8601_int (text + 4, 3, &amp;ordinal_day))
1301         return NULL;
1302       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1303     }
1304   else
1305     return FALSE;
1306 }
1307 
1308 static GTimeZone *
1309 parse_iso8601_timezone (const gchar *text, gsize length, gssize *tz_offset)
1310 {
<span class="line-modified">1311   gint i, tz_length, offset_sign = 1, offset_hours, offset_minutes;</span>

1312   GTimeZone *tz;
1313 
1314   /* UTC uses Z suffix  */
1315   if (length &gt; 0 &amp;&amp; text[length - 1] == &#39;Z&#39;)
1316     {
1317       *tz_offset = length - 1;
1318       return g_time_zone_new_utc ();
1319     }
1320 
1321   /* Look for &#39;+&#39; or &#39;-&#39; of offset */
1322   for (i = length - 1; i &gt;= 0; i--)
1323     if (text[i] == &#39;+&#39; || text[i] == &#39;-&#39;)
1324       {
1325         offset_sign = text[i] == &#39;-&#39; ? -1 : 1;
1326         break;
1327       }
1328   if (i &lt; 0)
1329     return NULL;
1330   tz_length = length - i;
1331 
</pre>
<hr />
<pre>
1340   else if (tz_length == 5)
1341     {
1342       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1343           !get_iso8601_int (text + i + 3, 2, &amp;offset_minutes))
1344         return NULL;
1345     }
1346   /* +hh or -hh */
1347   else if (tz_length == 3)
1348     {
1349       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours))
1350         return NULL;
1351       offset_minutes = 0;
1352     }
1353   else
1354     return NULL;
1355 
1356   *tz_offset = i;
1357   tz = g_time_zone_new (text + i);
1358 
1359   /* Double-check that the GTimeZone matches our interpretation of the timezone.
<span class="line-modified">1360    * Failure would indicate a bug either here of in the GTimeZone code. */</span>
<span class="line-modified">1361   g_assert (g_time_zone_get_offset (tz, 0) == offset_sign * (offset_hours * 3600 + offset_minutes * 60));</span>






1362 
1363   return tz;
1364 }
1365 
1366 static gboolean
1367 parse_iso8601_time (const gchar *text, gsize length,
1368                     gint *hour, gint *minute, gdouble *seconds, GTimeZone **tz)
1369 {
1370   gssize tz_offset = -1;
1371 
1372   /* Check for timezone suffix */
1373   *tz = parse_iso8601_timezone (text, length, &amp;tz_offset);
1374   if (tz_offset &gt;= 0)
1375     length = tz_offset;
1376 
1377   /* hh:mm:ss(.sss) */
1378   if (length &gt;= 8 &amp;&amp; text[2] == &#39;:&#39; &amp;&amp; text[5] == &#39;:&#39;)
1379     {
1380       return get_iso8601_int (text, 2, hour) &amp;&amp;
1381              get_iso8601_int (text + 3, 2, minute) &amp;&amp;
</pre>
<hr />
<pre>
2520  * @datetime: a #GDateTime
2521  * @tv: a #GTimeVal to modify
2522  *
2523  * Stores the instant in time that @datetime represents into @tv.
2524  *
2525  * The time contained in a #GTimeVal is always stored in the form of
2526  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
2527  * zone associated with @datetime.
2528  *
2529  * On systems where &#39;long&#39; is 32bit (ie: all 32bit systems and all
2530  * Windows systems), a #GTimeVal is incapable of storing the entire
2531  * range of values that #GDateTime is capable of expressing.  On those
2532  * systems, this function returns %FALSE to indicate that the time is
2533  * out of range.
2534  *
2535  * On systems where &#39;long&#39; is 64bit, this function never fails.
2536  *
2537  * Returns: %TRUE if successful, else %FALSE
2538  *
2539  * Since: 2.26


2540  **/

2541 gboolean
2542 g_date_time_to_timeval (GDateTime *datetime,
2543                         GTimeVal  *tv)
2544 {
2545   tv-&gt;tv_sec = INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2546   tv-&gt;tv_usec = datetime-&gt;usec % USEC_PER_SECOND;
2547 
2548   return TRUE;
2549 }

2550 
2551 /* Timezone queries {{{1 */
2552 /**
2553  * g_date_time_get_utc_offset:
2554  * @datetime: a #GDateTime
2555  *
2556  * Determines the offset to UTC in effect at the time and in the time
2557  * zone of @datetime.
2558  *
2559  * The offset is the number of microseconds that you add to UTC time to
2560  * arrive at local time for the time zone (ie: negative numbers for time
2561  * zones west of GMT, positive numbers for east).
2562  *
2563  * If @datetime represents UTC time, then the offset is always zero.
2564  *
2565  * Returns: the number of microseconds that should be added to UTC to
2566  *          get the local time
2567  *
2568  * Since: 2.26
2569  **/
</pre>
<hr />
<pre>
2766     case 3:
2767       g_string_append_printf (outstr, &quot;%c%02d&quot;, sign, hours);
2768 
2769       if (minutes != 0 || seconds != 0)
2770         {
2771           g_string_append_printf (outstr, &quot;:%02d&quot;, minutes);
2772 
2773           if (seconds != 0)
2774             g_string_append_printf (outstr, &quot;:%02d&quot;, seconds);
2775         }
2776       break;
2777 
2778     default:
2779       return FALSE;
2780     }
2781 
2782   return TRUE;
2783 }
2784 
2785 #ifdef HAVE_LANGINFO_OUTDIGIT
<span class="line-modified">2786 /** Initializes the array with UTF-8 encoded alternate digits suibtable for use</span>
2787  * in current locale. Returns NULL when current locale does not use alternate
2788  * digits or there was an error converting them to UTF-8.
2789  */
2790 static const gchar * const *
2791 initialize_alt_digits (void)
2792 {
2793   guint i;
2794   gsize digit_len;
2795   gchar *digit;
2796   const gchar *locale_digit;
2797 #define N_DIGITS 10
2798 #define MAX_UTF8_ENCODING_LEN 4
2799   static gchar buffer[N_DIGITS * (MAX_UTF8_ENCODING_LEN + 1 /* null separator */)];
2800 #undef N_DIGITS
2801 #undef MAX_UTF8_ENCODING_LEN
2802   gchar *buffer_end = buffer;
2803   static const gchar *alt_digits[10];
2804 
2805   for (i = 0; i != 10; ++i)
2806     {
2807       locale_digit = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB + i);
2808 
2809       if (g_strcmp0 (locale_digit, &quot;&quot;) == 0)
2810         return NULL;
2811 
2812       digit = g_locale_to_utf8 (locale_digit, -1, NULL, &amp;digit_len, NULL);
2813       if (digit == NULL)
2814         return NULL;
2815 
<span class="line-modified">2816       g_assert (digit_len &lt; buffer + sizeof (buffer) - buffer_end);</span>
2817 
2818       alt_digits[i] = buffer_end;
2819       buffer_end = g_stpcpy (buffer_end, digit);
2820       /* skip trailing null byte */
2821       buffer_end += 1;
2822 
2823       g_free (digit);
2824     }
2825 
2826   return alt_digits;
2827 }
2828 #endif /* HAVE_LANGINFO_OUTDIGIT */
2829 
2830 static void
2831 format_number (GString     *str,
2832                gboolean     use_alt_digits,
2833                const gchar *pad,
2834                gint         width,
2835                guint32      number)
2836 {
</pre>
<hr />
<pre>
2888 {
2889   const gchar *ampm;
2890   gchar       *tmp = NULL, *ampm_dup;
2891 
2892   ampm = GET_AMPM (datetime);
2893 
2894   if (!ampm || ampm[0] == &#39;\0&#39;)
2895     ampm = get_fallback_ampm (g_date_time_get_hour (datetime));
2896 
2897   if (!locale_is_utf8 &amp;&amp; GET_AMPM_IS_LOCALE)
2898     {
2899       /* This assumes that locale encoding can&#39;t have embedded NULs */
2900       ampm = tmp = g_locale_to_utf8 (ampm, -1, NULL, NULL, NULL);
2901       if (tmp == NULL)
2902         return FALSE;
2903     }
2904   if (uppercase)
2905     ampm_dup = g_utf8_strup (ampm, -1);
2906   else
2907     ampm_dup = g_utf8_strdown (ampm, -1);
<span class="line-modified">2908       g_free (tmp);</span>
2909 
2910   g_string_append (outstr, ampm_dup);
<span class="line-modified">2911       g_free (ampm_dup);</span>
2912 
2913   return TRUE;
2914 }
2915 
2916 static gboolean g_date_time_format_utf8 (GDateTime   *datetime,
<span class="line-modified">2917                        const gchar *format,</span>
<span class="line-modified">2918                        GString     *outstr,</span>
<span class="line-modified">2919                        gboolean     locale_is_utf8);</span>
2920 
2921 /* g_date_time_format() subroutine that takes a locale-encoded format
2922  * string and produces a UTF-8 encoded date/time string.
2923  */
2924 static gboolean
2925 g_date_time_format_locale (GDateTime   *datetime,
<span class="line-modified">2926                const gchar *locale_format,</span>
<span class="line-modified">2927                            GString     *outstr,</span>
<span class="line-modified">2928                            gboolean     locale_is_utf8)</span>
2929 {
2930   gchar *utf8_format;
2931   gboolean success;
2932 
2933   if (locale_is_utf8)
2934     return g_date_time_format_utf8 (datetime, locale_format, outstr, locale_is_utf8);
2935 
2936   utf8_format = g_locale_to_utf8 (locale_format, -1, NULL, NULL, NULL);
2937   if (utf8_format == NULL)
2938     return FALSE;
2939 
2940   success = g_date_time_format_utf8 (datetime, utf8_format, outstr,
<span class="line-modified">2941                        locale_is_utf8);</span>
2942   g_free (utf8_format);
2943   return success;
2944 }
2945 
2946 static inline gboolean
2947 string_append (GString     *string,
2948                const gchar *s,
2949                gboolean     s_is_utf8)
2950 {
2951   gchar *utf8;
2952   gsize  utf8_len;
2953 
2954   if (s_is_utf8)
2955     {
2956       g_string_append (string, s);
2957     }
2958   else
2959     {
2960       utf8 = g_locale_to_utf8 (s, -1, NULL, &amp;utf8_len, NULL);
2961       if (utf8 == NULL)
2962         return FALSE;
2963       g_string_append_len (string, utf8, utf8_len);
2964       g_free (utf8);
2965     }
2966 
2967   return TRUE;
2968 }
2969 
2970 /* g_date_time_format() subroutine that takes a UTF-8 encoded format
2971  * string and produces a UTF-8 encoded date/time string.
2972  */
2973 static gboolean
2974 g_date_time_format_utf8 (GDateTime   *datetime,
<span class="line-modified">2975              const gchar *utf8_format,</span>
<span class="line-modified">2976              GString     *outstr,</span>
<span class="line-modified">2977              gboolean     locale_is_utf8)</span>
2978 {
2979   guint     len;
2980   guint     colons;
2981   gunichar  c;
2982   gboolean  alt_digits = FALSE;
2983   gboolean  pad_set = FALSE;
2984   gboolean  name_is_utf8;
2985   const gchar *pad = &quot;&quot;;
2986   const gchar *name;
2987   const gchar *tz;
2988 
2989   while (*utf8_format)
2990     {
2991       len = strcspn (utf8_format, &quot;%&quot;);
2992       if (len)
2993         g_string_append_len (outstr, utf8_format, len);
2994 
2995       utf8_format += len;
2996       if (!*utf8_format)
<span class="line-modified">2997     break;</span>
2998 
2999       g_assert (*utf8_format == &#39;%&#39;);
3000       utf8_format++;
3001       if (!*utf8_format)
<span class="line-modified">3002     break;</span>
3003 
3004       colons = 0;
3005       alt_digits = FALSE;
3006       pad_set = FALSE;
3007 
3008     next_mod:
3009       c = g_utf8_get_char (utf8_format);
3010       utf8_format = g_utf8_next_char (utf8_format);
3011       switch (c)
<span class="line-modified">3012     {</span>
<span class="line-modified">3013     case &#39;a&#39;:</span>
<span class="line-modified">3014       name = WEEKDAY_ABBR (datetime);</span>
3015           if (g_strcmp0 (name, &quot;&quot;) == 0)
3016             return FALSE;
3017 
3018           name_is_utf8 = locale_is_utf8 || !WEEKDAY_ABBR_IS_LOCALE;
3019 
3020           if (!string_append (outstr, name, name_is_utf8))
3021             return FALSE;
3022 
<span class="line-modified">3023       break;</span>
<span class="line-modified">3024     case &#39;A&#39;:</span>
<span class="line-modified">3025       name = WEEKDAY_FULL (datetime);</span>
3026           if (g_strcmp0 (name, &quot;&quot;) == 0)
3027             return FALSE;
3028 
3029           name_is_utf8 = locale_is_utf8 || !WEEKDAY_FULL_IS_LOCALE;
3030 
3031           if (!string_append (outstr, name, name_is_utf8))
3032             return FALSE;
3033 
<span class="line-modified">3034       break;</span>
<span class="line-modified">3035     case &#39;b&#39;:</span>
<span class="line-modified">3036       name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)</span>
<span class="line-modified">3037                 : MONTH_ABBR_WITH_DAY (datetime);</span>
3038           if (g_strcmp0 (name, &quot;&quot;) == 0)
3039             return FALSE;
3040 
3041           name_is_utf8 = locale_is_utf8 ||
3042             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3043              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3044 
3045           if (!string_append (outstr, name, name_is_utf8))
3046             return FALSE;
3047 
<span class="line-modified">3048       break;</span>
<span class="line-modified">3049     case &#39;B&#39;:</span>
<span class="line-modified">3050       name = alt_digits ? MONTH_FULL_STANDALONE (datetime)</span>
<span class="line-modified">3051                 : MONTH_FULL_WITH_DAY (datetime);</span>
3052           if (g_strcmp0 (name, &quot;&quot;) == 0)
3053             return FALSE;
3054 
3055           name_is_utf8 = locale_is_utf8 ||
3056             ((alt_digits &amp;&amp; !MONTH_FULL_STANDALONE_IS_LOCALE) ||
3057              (!alt_digits &amp;&amp; !MONTH_FULL_WITH_DAY_IS_LOCALE));
3058 
3059           if (!string_append (outstr, name, name_is_utf8))
3060               return FALSE;
3061 
<span class="line-modified">3062       break;</span>
<span class="line-modified">3063     case &#39;c&#39;:</span>
<span class="line-modified">3064       {</span>
3065             if (g_strcmp0 (PREFERRED_DATE_TIME_FMT, &quot;&quot;) == 0)
3066               return FALSE;
3067             if (!g_date_time_format_locale (datetime, PREFERRED_DATE_TIME_FMT,
3068                                             outstr, locale_is_utf8))
3069               return FALSE;
<span class="line-modified">3070       }</span>
<span class="line-modified">3071       break;</span>
<span class="line-modified">3072     case &#39;C&#39;:</span>
<span class="line-modified">3073       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3074              g_date_time_get_year (datetime) / 100);</span>
<span class="line-modified">3075       break;</span>
<span class="line-modified">3076     case &#39;d&#39;:</span>
<span class="line-modified">3077       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3078              g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3079       break;</span>
<span class="line-modified">3080     case &#39;e&#39;:</span>
<span class="line-modified">3081       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3082              g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3083       break;</span>
<span class="line-modified">3084     case &#39;F&#39;:</span>
<span class="line-modified">3085       g_string_append_printf (outstr, &quot;%d-%02d-%02d&quot;,</span>
<span class="line-modified">3086                   g_date_time_get_year (datetime),</span>
<span class="line-modified">3087                   g_date_time_get_month (datetime),</span>
<span class="line-modified">3088                   g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3089       break;</span>
<span class="line-modified">3090     case &#39;g&#39;:</span>
<span class="line-modified">3091       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3092              g_date_time_get_week_numbering_year (datetime) % 100);</span>
<span class="line-modified">3093       break;</span>
<span class="line-modified">3094     case &#39;G&#39;:</span>
<span class="line-modified">3095       format_number (outstr, alt_digits, pad_set ? pad : 0, 0,</span>
<span class="line-modified">3096              g_date_time_get_week_numbering_year (datetime));</span>
<span class="line-modified">3097       break;</span>
<span class="line-modified">3098     case &#39;h&#39;:</span>
<span class="line-modified">3099       name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)</span>
<span class="line-modified">3100                 : MONTH_ABBR_WITH_DAY (datetime);</span>
3101           if (g_strcmp0 (name, &quot;&quot;) == 0)
3102             return FALSE;
3103 
3104           name_is_utf8 = locale_is_utf8 ||
3105             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3106              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3107 
3108           if (!string_append (outstr, name, name_is_utf8))
3109             return FALSE;
3110 
<span class="line-modified">3111       break;</span>
<span class="line-modified">3112     case &#39;H&#39;:</span>
<span class="line-modified">3113       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3114              g_date_time_get_hour (datetime));</span>
<span class="line-modified">3115       break;</span>
<span class="line-modified">3116     case &#39;I&#39;:</span>
<span class="line-modified">3117       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3118              (g_date_time_get_hour (datetime) + 11) % 12 + 1);</span>
<span class="line-modified">3119       break;</span>
<span class="line-modified">3120     case &#39;j&#39;:</span>
<span class="line-modified">3121       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 3,</span>
<span class="line-modified">3122              g_date_time_get_day_of_year (datetime));</span>
<span class="line-modified">3123       break;</span>
<span class="line-modified">3124     case &#39;k&#39;:</span>
<span class="line-modified">3125       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3126              g_date_time_get_hour (datetime));</span>
<span class="line-modified">3127       break;</span>
<span class="line-modified">3128     case &#39;l&#39;:</span>
<span class="line-modified">3129       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3130              (g_date_time_get_hour (datetime) + 11) % 12 + 1);</span>
<span class="line-modified">3131       break;</span>
<span class="line-modified">3132     case &#39;n&#39;:</span>
<span class="line-modified">3133       g_string_append_c (outstr, &#39;\n&#39;);</span>
<span class="line-modified">3134       break;</span>
<span class="line-modified">3135     case &#39;m&#39;:</span>
<span class="line-modified">3136       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3137              g_date_time_get_month (datetime));</span>
<span class="line-modified">3138       break;</span>
<span class="line-modified">3139     case &#39;M&#39;:</span>
<span class="line-modified">3140       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3141              g_date_time_get_minute (datetime));</span>
<span class="line-modified">3142       break;</span>
<span class="line-modified">3143     case &#39;O&#39;:</span>
<span class="line-modified">3144       alt_digits = TRUE;</span>
<span class="line-modified">3145       goto next_mod;</span>
<span class="line-modified">3146     case &#39;p&#39;:</span>
3147           if (!format_ampm (datetime, outstr, locale_is_utf8, TRUE))
3148             return FALSE;
3149           break;
<span class="line-modified">3150     case &#39;P&#39;:</span>
3151           if (!format_ampm (datetime, outstr, locale_is_utf8, FALSE))
3152             return FALSE;
<span class="line-modified">3153       break;</span>
<span class="line-modified">3154     case &#39;r&#39;:</span>
<span class="line-modified">3155       {</span>
3156             if (g_strcmp0 (PREFERRED_12HR_TIME_FMT, &quot;&quot;) == 0)
3157               return FALSE;
<span class="line-modified">3158         if (!g_date_time_format_locale (datetime, PREFERRED_12HR_TIME_FMT,</span>
<span class="line-modified">3159                         outstr, locale_is_utf8))</span>
<span class="line-modified">3160           return FALSE;</span>
<span class="line-modified">3161       }</span>
<span class="line-modified">3162       break;</span>
<span class="line-modified">3163     case &#39;R&#39;:</span>
<span class="line-modified">3164       g_string_append_printf (outstr, &quot;%02d:%02d&quot;,</span>
<span class="line-modified">3165                   g_date_time_get_hour (datetime),</span>
<span class="line-modified">3166                   g_date_time_get_minute (datetime));</span>
<span class="line-modified">3167       break;</span>
<span class="line-modified">3168     case &#39;s&#39;:</span>
<span class="line-modified">3169       g_string_append_printf (outstr, &quot;%&quot; G_GINT64_FORMAT, g_date_time_to_unix (datetime));</span>
<span class="line-modified">3170       break;</span>
<span class="line-modified">3171     case &#39;S&#39;:</span>
<span class="line-modified">3172       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3173              g_date_time_get_second (datetime));</span>
<span class="line-modified">3174       break;</span>
<span class="line-modified">3175     case &#39;t&#39;:</span>
<span class="line-modified">3176       g_string_append_c (outstr, &#39;\t&#39;);</span>
<span class="line-modified">3177       break;</span>
<span class="line-modified">3178     case &#39;T&#39;:</span>
<span class="line-modified">3179       g_string_append_printf (outstr, &quot;%02d:%02d:%02d&quot;,</span>
<span class="line-modified">3180                   g_date_time_get_hour (datetime),</span>
<span class="line-modified">3181                   g_date_time_get_minute (datetime),</span>
<span class="line-modified">3182                   g_date_time_get_second (datetime));</span>
<span class="line-modified">3183       break;</span>
<span class="line-modified">3184     case &#39;u&#39;:</span>
<span class="line-modified">3185       format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-modified">3186              g_date_time_get_day_of_week (datetime));</span>
<span class="line-modified">3187       break;</span>
<span class="line-modified">3188     case &#39;V&#39;:</span>
<span class="line-modified">3189       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3190              g_date_time_get_week_of_year (datetime));</span>
<span class="line-modified">3191       break;</span>
<span class="line-modified">3192     case &#39;w&#39;:</span>
<span class="line-modified">3193       format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-modified">3194              g_date_time_get_day_of_week (datetime) % 7);</span>
<span class="line-modified">3195       break;</span>
<span class="line-modified">3196     case &#39;x&#39;:</span>
<span class="line-modified">3197       {</span>
3198             if (g_strcmp0 (PREFERRED_DATE_FMT, &quot;&quot;) == 0)
3199               return FALSE;
<span class="line-modified">3200         if (!g_date_time_format_locale (datetime, PREFERRED_DATE_FMT,</span>
<span class="line-modified">3201                         outstr, locale_is_utf8))</span>
<span class="line-modified">3202           return FALSE;</span>
<span class="line-modified">3203       }</span>
<span class="line-modified">3204       break;</span>
<span class="line-modified">3205     case &#39;X&#39;:</span>
<span class="line-modified">3206       {</span>
3207             if (g_strcmp0 (PREFERRED_TIME_FMT, &quot;&quot;) == 0)
3208               return FALSE;
<span class="line-modified">3209         if (!g_date_time_format_locale (datetime, PREFERRED_TIME_FMT,</span>
<span class="line-modified">3210                         outstr, locale_is_utf8))</span>
<span class="line-removed">3211           return FALSE;</span>
<span class="line-removed">3212       }</span>
<span class="line-removed">3213       break;</span>
<span class="line-removed">3214     case &#39;y&#39;:</span>
<span class="line-removed">3215       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-removed">3216              g_date_time_get_year (datetime) % 100);</span>
<span class="line-removed">3217       break;</span>
<span class="line-removed">3218     case &#39;Y&#39;:</span>
<span class="line-removed">3219       format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-removed">3220              g_date_time_get_year (datetime));</span>
<span class="line-removed">3221       break;</span>
<span class="line-removed">3222     case &#39;z&#39;:</span>
<span class="line-removed">3223       {</span>
<span class="line-removed">3224         gint64 offset;</span>
<span class="line-removed">3225         offset = g_date_time_get_utc_offset (datetime) / USEC_PER_SECOND;</span>
<span class="line-removed">3226         if (!format_z (outstr, (int) offset, colons))</span>
<span class="line-removed">3227           return FALSE;</span>
<span class="line-removed">3228       }</span>
<span class="line-removed">3229       break;</span>
<span class="line-removed">3230     case &#39;Z&#39;:</span>
<span class="line-removed">3231       tz = g_date_time_get_timezone_abbreviation (datetime);</span>
<span class="line-removed">3232           g_string_append (outstr, tz);</span>
<span class="line-removed">3233       break;</span>
<span class="line-removed">3234     case &#39;%&#39;:</span>
<span class="line-removed">3235       g_string_append_c (outstr, &#39;%&#39;);</span>
<span class="line-removed">3236       break;</span>
<span class="line-removed">3237     case &#39;-&#39;:</span>
<span class="line-removed">3238       pad_set = TRUE;</span>
<span class="line-removed">3239       pad = &quot;&quot;;</span>
<span class="line-removed">3240       goto next_mod;</span>
<span class="line-removed">3241     case &#39;_&#39;:</span>
<span class="line-removed">3242       pad_set = TRUE;</span>
<span class="line-removed">3243       pad = &quot; &quot;;</span>
<span class="line-removed">3244       goto next_mod;</span>
<span class="line-removed">3245     case &#39;0&#39;:</span>
<span class="line-removed">3246       pad_set = TRUE;</span>
<span class="line-removed">3247       pad = &quot;0&quot;;</span>
<span class="line-removed">3248       goto next_mod;</span>
<span class="line-removed">3249     case &#39;:&#39;:</span>
<span class="line-removed">3250       /* Colons are only allowed before &#39;z&#39; */</span>
<span class="line-removed">3251       if (*utf8_format &amp;&amp; *utf8_format != &#39;z&#39; &amp;&amp; *utf8_format != &#39;:&#39;)</span>
3252         return FALSE;
<span class="line-removed">3253       colons++;</span>
<span class="line-removed">3254       goto next_mod;</span>
<span class="line-removed">3255     default:</span>
<span class="line-removed">3256       return FALSE;</span>
3257     }













































3258     }
3259 
3260   return TRUE;
3261 }
3262 
3263 /**
3264  * g_date_time_format:
3265  * @datetime: A #GDateTime
3266  * @format: a valid UTF-8 string, containing the format for the
3267  *          #GDateTime
3268  *
3269  * Creates a newly allocated string representing the requested @format.
3270  *
3271  * The format strings understood by this function are a subset of the
3272  * strftime() format language as specified by C99.  The \%D, \%U and \%W
3273  * conversions are not supported, nor is the &#39;E&#39; modifier.  The GNU
3274  * extensions \%k, \%l, \%s and \%P are supported, however, as are the
3275  * &#39;0&#39;, &#39;_&#39; and &#39;-&#39; modifiers.
3276  *
3277  * In contrast to strftime(), this function always produces a UTF-8
</pre>
<hr />
<pre>
3377   /* Avoid conversions from locale charset to UTF-8 if charset is compatible
3378    * with UTF-8 already. Check for UTF-8 and synonymous canonical names of
3379    * ASCII. */
3380   gboolean locale_is_utf8_compatible = g_get_charset (&amp;charset) ||
3381     g_strcmp0 (&quot;ASCII&quot;, charset) == 0 ||
3382     g_strcmp0 (&quot;ANSI_X3.4-1968&quot;, charset) == 0;
3383 
3384   g_return_val_if_fail (datetime != NULL, NULL);
3385   g_return_val_if_fail (format != NULL, NULL);
3386   g_return_val_if_fail (g_utf8_validate (format, -1, NULL), NULL);
3387 
3388   outstr = g_string_sized_new (strlen (format) * 2);
3389 
3390   if (!g_date_time_format_utf8 (datetime, format, outstr,
3391                                 locale_is_utf8_compatible))
3392     {
3393       g_string_free (outstr, TRUE);
3394       return NULL;
3395     }
3396 
<span class="line-modified">3397     return g_string_free (outstr, FALSE);</span>











































3398 }
3399 
3400 
3401 /* Epilogue {{{1 */
3402 /* vim:set foldmethod=marker: */
</pre>
</td>
<td>
<hr />
<pre>
   1 /* gdatetime.c
   2  *
   3  * Copyright (C) 2009-2010 Christian Hergert &lt;chris@dronelabs.com&gt;
   4  * Copyright (C) 2010 Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
   5  * Copyright (C) 2010 Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
<span class="line-modified">   6  * Copyright (C) 2010 Codethink Limited</span>
<span class="line-modified">   7  * Copyright (C) 2018 Tomasz Miasko</span>
   8  *
   9  * This library is free software; you can redistribute it and/or modify
  10  * it under the terms of the GNU Lesser General Public License as
  11  * published by the Free Software Foundation; either version 2.1 of the
  12  * licence, or (at your option) any later version.
  13  *
  14  * This is distributed in the hope that it will be useful, but WITHOUT
  15  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  16  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
  17  * License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public License
  20  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  21  *
  22  * Authors: Christian Hergert &lt;chris@dronelabs.com&gt;
  23  *          Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
  24  *          Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
  25  *          Ryan Lortie &lt;desrt@desrt.ca&gt;
  26  *          Robert Ancell &lt;robert.ancell@canonical.com&gt;
  27  */
</pre>
<hr />
<pre>
 117 struct _GDateTime
 118 {
 119   /* Microsecond timekeeping within Day */
 120   guint64 usec;
 121 
 122   /* TimeZone information */
 123   GTimeZone *tz;
 124   gint interval;
 125 
 126   /* 1 is 0001-01-01 in Proleptic Gregorian */
 127   gint32 days;
 128 
 129   volatile gint ref_count;
 130 };
 131 
 132 /* Time conversion {{{1 */
 133 
 134 #define UNIX_EPOCH_START     719163
 135 #define INSTANT_TO_UNIX(instant) \
 136   ((instant)/USEC_PER_SECOND - UNIX_EPOCH_START * SEC_PER_DAY)
<span class="line-added"> 137 #define INSTANT_TO_UNIX_USECS(instant) \</span>
<span class="line-added"> 138   ((instant) - UNIX_EPOCH_START * SEC_PER_DAY * USEC_PER_SECOND)</span>
 139 #define UNIX_TO_INSTANT(unix) \
 140   (((gint64) (unix) + UNIX_EPOCH_START * SEC_PER_DAY) * USEC_PER_SECOND)
<span class="line-added"> 141 #define UNIX_USECS_TO_INSTANT(unix_usecs) \</span>
<span class="line-added"> 142   ((gint64) (unix_usecs) + UNIX_EPOCH_START * SEC_PER_DAY * USEC_PER_SECOND)</span>
 143 #define UNIX_TO_INSTANT_IS_VALID(unix) \
 144   ((gint64) (unix) &lt;= INSTANT_TO_UNIX (G_MAXINT64))
<span class="line-added"> 145 #define UNIX_USECS_TO_INSTANT_IS_VALID(unix_usecs) \</span>
<span class="line-added"> 146   ((gint64) (unix_usecs) &lt;= INSTANT_TO_UNIX_USECS (G_MAXINT64))</span>
 147 
 148 #define DAYS_IN_4YEARS    1461    /* days in 4 years */
 149 #define DAYS_IN_100YEARS  36524   /* days in 100 years */
 150 #define DAYS_IN_400YEARS  146097  /* days in 400 years  */
 151 
 152 #define USEC_PER_SECOND      (G_GINT64_CONSTANT (1000000))
 153 #define USEC_PER_MINUTE      (G_GINT64_CONSTANT (60000000))
 154 #define USEC_PER_HOUR        (G_GINT64_CONSTANT (3600000000))
 155 #define USEC_PER_MILLISECOND (G_GINT64_CONSTANT (1000))
 156 #define USEC_PER_DAY         (G_GINT64_CONSTANT (86400000000))
 157 #define SEC_PER_DAY          (G_GINT64_CONSTANT (86400))
 158 
 159 #define SECS_PER_MINUTE (60)
 160 #define SECS_PER_HOUR   (60 * SECS_PER_MINUTE)
 161 #define SECS_PER_DAY    (24 * SECS_PER_HOUR)
 162 #define SECS_PER_YEAR   (365 * SECS_PER_DAY)
 163 #define SECS_PER_JULIAN (DAYS_PER_PERIOD * SECS_PER_DAY)
 164 
 165 #define GREGORIAN_LEAP(y)    ((((y) % 4) == 0) &amp;&amp; (!((((y) % 100) == 0) &amp;&amp; (((y) % 400) != 0))))
 166 #define JULIAN_YEAR(d)       ((d)-&gt;julian / 365.25)
</pre>
<hr />
<pre>
 730  * microsecond in time, taking time zone considerations into account.
 731  * (ie: &quot;03:00 -0400&quot; is the same instant as &quot;02:00 -0500&quot;).
 732  *
 733  * An instant is always positive but we use a signed return value to
 734  * avoid troubles with C.
 735  */
 736 static gint64
 737 g_date_time_to_instant (GDateTime *datetime)
 738 {
 739   gint64 offset;
 740 
 741   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 742   offset *= USEC_PER_SECOND;
 743 
 744   return datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec - offset;
 745 }
 746 
 747 /*&lt; internal &gt;
 748  * g_date_time_from_instant:
 749  * @tz: a #GTimeZone
<span class="line-modified"> 750  * @instant: an instant in time</span>
 751  *
 752  * Creates a #GDateTime from a time zone and an instant.
 753  *
 754  * This might fail if the time ends up being out of range.
 755  */
 756 static GDateTime *
 757 g_date_time_from_instant (GTimeZone *tz,
 758                           gint64     instant)
 759 {
 760   GDateTime *datetime;
 761   gint64 offset;
 762 
 763   if (instant &lt; 0 || instant &gt; G_GINT64_CONSTANT (1000000000000000000))
 764     return NULL;
 765 
 766   datetime = g_date_time_alloc (tz);
 767   datetime-&gt;interval = g_time_zone_find_interval (tz,
 768                                                   G_TIME_TYPE_UNIVERSAL,
 769                                                   INSTANT_TO_UNIX (instant));
 770   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
</pre>
<hr />
<pre>
 843                           gint       days)
 844 {
 845   GDateTime *new;
 846 
 847   new = g_date_time_alloc (datetime-&gt;tz);
 848   new-&gt;interval = datetime-&gt;interval;
 849   new-&gt;usec = datetime-&gt;usec;
 850   new-&gt;days = days;
 851 
 852   if (!g_date_time_deal_with_date_change (new))
 853     {
 854       g_date_time_unref (new);
 855       new = NULL;
 856     }
 857 
 858   return new;
 859 }
 860 
 861 /* now/unix/timeval Constructors {{{1 */
 862 
<span class="line-added"> 863 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
 864 /*&lt; internal &gt;
 865  * g_date_time_new_from_timeval:
 866  * @tz: a #GTimeZone
 867  * @tv: a #GTimeVal
 868  *
 869  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
 870  * given time zone @tz.
 871  *
 872  * The time contained in a #GTimeVal is always stored in the form of
 873  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
 874  * given time zone.
 875  *
 876  * This call can fail (returning %NULL) if @tv represents a time outside
 877  * of the supported range of #GDateTime.
 878  *
 879  * You should release the return value by calling g_date_time_unref()
 880  * when you are done with it.
 881  *
 882  * Returns: a new #GDateTime, or %NULL
 883  *
 884  * Since: 2.26
 885  **/
 886 static GDateTime *
 887 g_date_time_new_from_timeval (GTimeZone      *tz,
 888                               const GTimeVal *tv)
 889 {
 890   if ((gint64) tv-&gt;tv_sec &gt; G_MAXINT64 - 1 ||
 891       !UNIX_TO_INSTANT_IS_VALID ((gint64) tv-&gt;tv_sec + 1))
 892     return NULL;
 893 
 894   return g_date_time_from_instant (tz, tv-&gt;tv_usec +
 895                                    UNIX_TO_INSTANT (tv-&gt;tv_sec));
 896 }
<span class="line-added"> 897 G_GNUC_END_IGNORE_DEPRECATIONS</span>
 898 
 899 /*&lt; internal &gt;
 900  * g_date_time_new_from_unix:
 901  * @tz: a #GTimeZone
<span class="line-modified"> 902  * @usecs: the Unix time, in microseconds since the epoch</span>
 903  *
<span class="line-modified"> 904  * Creates a #GDateTime corresponding to the given Unix time @t_us in the</span>
 905  * given time zone @tz.
 906  *
 907  * Unix time is the number of seconds that have elapsed since 1970-01-01
 908  * 00:00:00 UTC, regardless of the time zone given.
 909  *
 910  * This call can fail (returning %NULL) if @t represents a time outside
 911  * of the supported range of #GDateTime.
 912  *
 913  * You should release the return value by calling g_date_time_unref()
 914  * when you are done with it.
 915  *
 916  * Returns: a new #GDateTime, or %NULL
 917  *
 918  * Since: 2.26
 919  **/
 920 static GDateTime *
 921 g_date_time_new_from_unix (GTimeZone *tz,
<span class="line-modified"> 922                            gint64     usecs)</span>
 923 {
<span class="line-modified"> 924   if (!UNIX_USECS_TO_INSTANT_IS_VALID (usecs))</span>
 925     return NULL;
 926 
<span class="line-modified"> 927   return g_date_time_from_instant (tz, UNIX_USECS_TO_INSTANT (usecs));</span>
 928 }
 929 
 930 /**
 931  * g_date_time_new_now:
 932  * @tz: a #GTimeZone
 933  *
 934  * Creates a #GDateTime corresponding to this exact instant in the given
 935  * time zone @tz.  The time is as accurate as the system allows, to a
 936  * maximum accuracy of 1 microsecond.
 937  *
 938  * This function will always succeed unless the system clock is set to
 939  * truly insane values (or unless GLib is still being used after the
 940  * year 9999).
 941  *
 942  * You should release the return value by calling g_date_time_unref()
 943  * when you are done with it.
 944  *
 945  * Returns: a new #GDateTime, or %NULL
 946  *
 947  * Since: 2.26
 948  **/
 949 GDateTime *
 950 g_date_time_new_now (GTimeZone *tz)
 951 {
<span class="line-modified"> 952   gint64 now_us;</span>
 953 
<span class="line-modified"> 954   now_us = g_get_real_time ();</span>
 955 
<span class="line-modified"> 956   return g_date_time_new_from_unix (tz, now_us);</span>
 957 }
 958 
 959 /**
 960  * g_date_time_new_now_local:
 961  *
 962  * Creates a #GDateTime corresponding to this exact instant in the local
 963  * time zone.
 964  *
 965  * This is equivalent to calling g_date_time_new_now() with the time
 966  * zone returned by g_time_zone_new_local().
 967  *
 968  * Returns: a new #GDateTime, or %NULL
 969  *
 970  * Since: 2.26
 971  **/
 972 GDateTime *
 973 g_date_time_new_now_local (void)
 974 {
 975   GDateTime *datetime;
 976   GTimeZone *local;
</pre>
<hr />
<pre>
1016  *
1017  * Unix time is the number of seconds that have elapsed since 1970-01-01
1018  * 00:00:00 UTC, regardless of the local time offset.
1019  *
1020  * This call can fail (returning %NULL) if @t represents a time outside
1021  * of the supported range of #GDateTime.
1022  *
1023  * You should release the return value by calling g_date_time_unref()
1024  * when you are done with it.
1025  *
1026  * Returns: a new #GDateTime, or %NULL
1027  *
1028  * Since: 2.26
1029  **/
1030 GDateTime *
1031 g_date_time_new_from_unix_local (gint64 t)
1032 {
1033   GDateTime *datetime;
1034   GTimeZone *local;
1035 
<span class="line-added">1036   if (t &gt; G_MAXINT64 / USEC_PER_SECOND)</span>
<span class="line-added">1037     return NULL;</span>
<span class="line-added">1038 </span>
1039   local = g_time_zone_new_local ();
<span class="line-modified">1040   datetime = g_date_time_new_from_unix (local, t * USEC_PER_SECOND);</span>
1041   g_time_zone_unref (local);
1042 
1043   return datetime;
1044 }
1045 
1046 /**
1047  * g_date_time_new_from_unix_utc:
1048  * @t: the Unix time
1049  *
1050  * Creates a #GDateTime corresponding to the given Unix time @t in UTC.
1051  *
1052  * Unix time is the number of seconds that have elapsed since 1970-01-01
1053  * 00:00:00 UTC.
1054  *
1055  * This call can fail (returning %NULL) if @t represents a time outside
1056  * of the supported range of #GDateTime.
1057  *
1058  * You should release the return value by calling g_date_time_unref()
1059  * when you are done with it.
1060  *
1061  * Returns: a new #GDateTime, or %NULL
1062  *
1063  * Since: 2.26
1064  **/
1065 GDateTime *
1066 g_date_time_new_from_unix_utc (gint64 t)
1067 {
1068   GDateTime *datetime;
1069   GTimeZone *utc;
1070 
<span class="line-added">1071   if (t &gt; G_MAXINT64 / USEC_PER_SECOND)</span>
<span class="line-added">1072     return NULL;</span>
<span class="line-added">1073 </span>
1074   utc = g_time_zone_new_utc ();
<span class="line-modified">1075   datetime = g_date_time_new_from_unix (utc, t * USEC_PER_SECOND);</span>
1076   g_time_zone_unref (utc);
1077 
1078   return datetime;
1079 }
1080 
1081 /**
1082  * g_date_time_new_from_timeval_local:
1083  * @tv: a #GTimeVal
1084  *
1085  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
1086  * local time zone.
1087  *
1088  * The time contained in a #GTimeVal is always stored in the form of
1089  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
1090  * local time offset.
1091  *
1092  * This call can fail (returning %NULL) if @tv represents a time outside
1093  * of the supported range of #GDateTime.
1094  *
1095  * You should release the return value by calling g_date_time_unref()
1096  * when you are done with it.
1097  *
1098  * Returns: a new #GDateTime, or %NULL
1099  *
1100  * Since: 2.26
<span class="line-added">1101  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use</span>
<span class="line-added">1102  *    g_date_time_new_from_unix_local() instead.</span>
1103  **/
<span class="line-added">1104 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1105 GDateTime *
1106 g_date_time_new_from_timeval_local (const GTimeVal *tv)
1107 {
1108   GDateTime *datetime;
1109   GTimeZone *local;
1110 
1111   local = g_time_zone_new_local ();
1112   datetime = g_date_time_new_from_timeval (local, tv);
1113   g_time_zone_unref (local);
1114 
1115   return datetime;
1116 }
<span class="line-added">1117 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1118 
1119 /**
1120  * g_date_time_new_from_timeval_utc:
1121  * @tv: a #GTimeVal
1122  *
1123  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
1124  *
1125  * The time contained in a #GTimeVal is always stored in the form of
1126  * seconds elapsed since 1970-01-01 00:00:00 UTC.
1127  *
1128  * This call can fail (returning %NULL) if @tv represents a time outside
1129  * of the supported range of #GDateTime.
1130  *
1131  * You should release the return value by calling g_date_time_unref()
1132  * when you are done with it.
1133  *
1134  * Returns: a new #GDateTime, or %NULL
1135  *
1136  * Since: 2.26
<span class="line-added">1137  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use</span>
<span class="line-added">1138  *    g_date_time_new_from_unix_utc() instead.</span>
1139  **/
<span class="line-added">1140 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1141 GDateTime *
1142 g_date_time_new_from_timeval_utc (const GTimeVal *tv)
1143 {
1144   GDateTime *datetime;
1145   GTimeZone *utc;
1146 
1147   utc = g_time_zone_new_utc ();
1148   datetime = g_date_time_new_from_timeval (utc, tv);
1149   g_time_zone_unref (utc);
1150 
1151   return datetime;
1152 }
<span class="line-added">1153 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1154 
1155 /* Parse integers in the form d (week days), dd (hours etc), ddd (ordinal days) or dddd (years) */
1156 static gboolean
1157 get_iso8601_int (const gchar *text, gsize length, gint *value)
1158 {
<span class="line-modified">1159   gsize i;</span>
<span class="line-added">1160   guint v = 0;</span>
1161 
1162   if (length &lt; 1 || length &gt; 4)
1163     return FALSE;
1164 
1165   for (i = 0; i &lt; length; i++)
1166     {
1167       const gchar c = text[i];
1168       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1169         return FALSE;
1170       v = v * 10 + (c - &#39;0&#39;);
1171     }
1172 
1173   *value = v;
1174   return TRUE;
1175 }
1176 
1177 /* Parse seconds in the form ss or ss.sss (variable length decimal) */
1178 static gboolean
1179 get_iso8601_seconds (const gchar *text, gsize length, gdouble *value)
1180 {
<span class="line-modified">1181   gsize i;</span>
1182   gdouble divisor = 1, v = 0;
1183 
1184   if (length &lt; 2)
1185     return FALSE;
1186 
1187   for (i = 0; i &lt; 2; i++)
1188     {
1189       const gchar c = text[i];
1190       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1191         return FALSE;
1192       v = v * 10 + (c - &#39;0&#39;);
1193     }
1194 
1195   if (length &gt; 2 &amp;&amp; !(text[i] == &#39;.&#39; || text[i] == &#39;,&#39;))
1196     return FALSE;
1197   i++;
1198   if (i == length)
1199     return FALSE;
1200 
1201   for (; i &lt; length; i++)
</pre>
<hr />
<pre>
1203       const gchar c = text[i];
1204       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1205         return FALSE;
1206       v = v * 10 + (c - &#39;0&#39;);
1207       divisor *= 10;
1208     }
1209 
1210   *value = v / divisor;
1211   return TRUE;
1212 }
1213 
1214 static GDateTime *
1215 g_date_time_new_ordinal (GTimeZone *tz, gint year, gint ordinal_day, gint hour, gint minute, gdouble seconds)
1216 {
1217   GDateTime *dt;
1218 
1219   if (ordinal_day &lt; 1 || ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1220     return NULL;
1221 
1222   dt = g_date_time_new (tz, year, 1, 1, hour, minute, seconds);
<span class="line-modified">1223   if (dt == NULL)</span>

1224     return NULL;


1225   dt-&gt;days += ordinal_day - 1;
1226 
1227   return dt;
1228 }
1229 
1230 static GDateTime *
1231 g_date_time_new_week (GTimeZone *tz, gint year, gint week, gint week_day, gint hour, gint minute, gdouble seconds)
1232 {
1233   gint64 p;
1234   gint max_week, jan4_week_day, ordinal_day;
1235   GDateTime *dt;
1236 
1237   p = (year * 365 + (year / 4) - (year / 100) + (year / 400)) % 7;
1238   max_week = p == 4 ? 53 : 52;
1239 
1240   if (week &lt; 1 || week &gt; max_week || week_day &lt; 1 || week_day &gt; 7)
1241     return NULL;
1242 
1243   dt = g_date_time_new (tz, year, 1, 4, 0, 0, 0);
<span class="line-added">1244   if (dt == NULL)</span>
<span class="line-added">1245     return NULL;</span>
1246   g_date_time_get_week_number (dt, NULL, &amp;jan4_week_day, NULL);
1247   g_date_time_unref (dt);
1248 
1249   ordinal_day = (week * 7) + week_day - (jan4_week_day + 3);
1250   if (ordinal_day &lt; 0)
1251     {
1252       year--;
1253       ordinal_day += GREGORIAN_LEAP (year) ? 366 : 365;
1254     }
1255   else if (ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1256     {
1257       ordinal_day -= (GREGORIAN_LEAP (year) ? 366 : 365);
1258       year++;
1259     }
1260 
1261   return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1262 }
1263 
1264 static GDateTime *
1265 parse_iso8601_date (const gchar *text, gsize length,
</pre>
<hr />
<pre>
1313           !get_iso8601_int (text + 6, 2, &amp;day))
1314         return NULL;
1315       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1316     }
1317   /* YYYYDDD */
1318   else if (length == 7)
1319     {
1320       gint year, ordinal_day;
1321       if (!get_iso8601_int (text, 4, &amp;year) ||
1322           !get_iso8601_int (text + 4, 3, &amp;ordinal_day))
1323         return NULL;
1324       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1325     }
1326   else
1327     return FALSE;
1328 }
1329 
1330 static GTimeZone *
1331 parse_iso8601_timezone (const gchar *text, gsize length, gssize *tz_offset)
1332 {
<span class="line-modified">1333   gint i, tz_length, offset_hours, offset_minutes;</span>
<span class="line-added">1334   gint offset_sign = 1;</span>
1335   GTimeZone *tz;
1336 
1337   /* UTC uses Z suffix  */
1338   if (length &gt; 0 &amp;&amp; text[length - 1] == &#39;Z&#39;)
1339     {
1340       *tz_offset = length - 1;
1341       return g_time_zone_new_utc ();
1342     }
1343 
1344   /* Look for &#39;+&#39; or &#39;-&#39; of offset */
1345   for (i = length - 1; i &gt;= 0; i--)
1346     if (text[i] == &#39;+&#39; || text[i] == &#39;-&#39;)
1347       {
1348         offset_sign = text[i] == &#39;-&#39; ? -1 : 1;
1349         break;
1350       }
1351   if (i &lt; 0)
1352     return NULL;
1353   tz_length = length - i;
1354 
</pre>
<hr />
<pre>
1363   else if (tz_length == 5)
1364     {
1365       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1366           !get_iso8601_int (text + i + 3, 2, &amp;offset_minutes))
1367         return NULL;
1368     }
1369   /* +hh or -hh */
1370   else if (tz_length == 3)
1371     {
1372       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours))
1373         return NULL;
1374       offset_minutes = 0;
1375     }
1376   else
1377     return NULL;
1378 
1379   *tz_offset = i;
1380   tz = g_time_zone_new (text + i);
1381 
1382   /* Double-check that the GTimeZone matches our interpretation of the timezone.
<span class="line-modified">1383    * This can fail because our interpretation is less strict than (for example)</span>
<span class="line-modified">1384    * parse_time() in gtimezone.c, which restricts the range of the parsed</span>
<span class="line-added">1385    * integers. */</span>
<span class="line-added">1386   if (g_time_zone_get_offset (tz, 0) != offset_sign * (offset_hours * 3600 + offset_minutes * 60))</span>
<span class="line-added">1387     {</span>
<span class="line-added">1388       g_time_zone_unref (tz);</span>
<span class="line-added">1389       return NULL;</span>
<span class="line-added">1390     }</span>
1391 
1392   return tz;
1393 }
1394 
1395 static gboolean
1396 parse_iso8601_time (const gchar *text, gsize length,
1397                     gint *hour, gint *minute, gdouble *seconds, GTimeZone **tz)
1398 {
1399   gssize tz_offset = -1;
1400 
1401   /* Check for timezone suffix */
1402   *tz = parse_iso8601_timezone (text, length, &amp;tz_offset);
1403   if (tz_offset &gt;= 0)
1404     length = tz_offset;
1405 
1406   /* hh:mm:ss(.sss) */
1407   if (length &gt;= 8 &amp;&amp; text[2] == &#39;:&#39; &amp;&amp; text[5] == &#39;:&#39;)
1408     {
1409       return get_iso8601_int (text, 2, hour) &amp;&amp;
1410              get_iso8601_int (text + 3, 2, minute) &amp;&amp;
</pre>
<hr />
<pre>
2549  * @datetime: a #GDateTime
2550  * @tv: a #GTimeVal to modify
2551  *
2552  * Stores the instant in time that @datetime represents into @tv.
2553  *
2554  * The time contained in a #GTimeVal is always stored in the form of
2555  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
2556  * zone associated with @datetime.
2557  *
2558  * On systems where &#39;long&#39; is 32bit (ie: all 32bit systems and all
2559  * Windows systems), a #GTimeVal is incapable of storing the entire
2560  * range of values that #GDateTime is capable of expressing.  On those
2561  * systems, this function returns %FALSE to indicate that the time is
2562  * out of range.
2563  *
2564  * On systems where &#39;long&#39; is 64bit, this function never fails.
2565  *
2566  * Returns: %TRUE if successful, else %FALSE
2567  *
2568  * Since: 2.26
<span class="line-added">2569  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use</span>
<span class="line-added">2570  *    g_date_time_to_unix() instead.</span>
2571  **/
<span class="line-added">2572 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
2573 gboolean
2574 g_date_time_to_timeval (GDateTime *datetime,
2575                         GTimeVal  *tv)
2576 {
2577   tv-&gt;tv_sec = INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2578   tv-&gt;tv_usec = datetime-&gt;usec % USEC_PER_SECOND;
2579 
2580   return TRUE;
2581 }
<span class="line-added">2582 G_GNUC_END_IGNORE_DEPRECATIONS</span>
2583 
2584 /* Timezone queries {{{1 */
2585 /**
2586  * g_date_time_get_utc_offset:
2587  * @datetime: a #GDateTime
2588  *
2589  * Determines the offset to UTC in effect at the time and in the time
2590  * zone of @datetime.
2591  *
2592  * The offset is the number of microseconds that you add to UTC time to
2593  * arrive at local time for the time zone (ie: negative numbers for time
2594  * zones west of GMT, positive numbers for east).
2595  *
2596  * If @datetime represents UTC time, then the offset is always zero.
2597  *
2598  * Returns: the number of microseconds that should be added to UTC to
2599  *          get the local time
2600  *
2601  * Since: 2.26
2602  **/
</pre>
<hr />
<pre>
2799     case 3:
2800       g_string_append_printf (outstr, &quot;%c%02d&quot;, sign, hours);
2801 
2802       if (minutes != 0 || seconds != 0)
2803         {
2804           g_string_append_printf (outstr, &quot;:%02d&quot;, minutes);
2805 
2806           if (seconds != 0)
2807             g_string_append_printf (outstr, &quot;:%02d&quot;, seconds);
2808         }
2809       break;
2810 
2811     default:
2812       return FALSE;
2813     }
2814 
2815   return TRUE;
2816 }
2817 
2818 #ifdef HAVE_LANGINFO_OUTDIGIT
<span class="line-modified">2819 /* Initializes the array with UTF-8 encoded alternate digits suitable for use</span>
2820  * in current locale. Returns NULL when current locale does not use alternate
2821  * digits or there was an error converting them to UTF-8.
2822  */
2823 static const gchar * const *
2824 initialize_alt_digits (void)
2825 {
2826   guint i;
2827   gsize digit_len;
2828   gchar *digit;
2829   const gchar *locale_digit;
2830 #define N_DIGITS 10
2831 #define MAX_UTF8_ENCODING_LEN 4
2832   static gchar buffer[N_DIGITS * (MAX_UTF8_ENCODING_LEN + 1 /* null separator */)];
2833 #undef N_DIGITS
2834 #undef MAX_UTF8_ENCODING_LEN
2835   gchar *buffer_end = buffer;
2836   static const gchar *alt_digits[10];
2837 
2838   for (i = 0; i != 10; ++i)
2839     {
2840       locale_digit = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB + i);
2841 
2842       if (g_strcmp0 (locale_digit, &quot;&quot;) == 0)
2843         return NULL;
2844 
2845       digit = g_locale_to_utf8 (locale_digit, -1, NULL, &amp;digit_len, NULL);
2846       if (digit == NULL)
2847         return NULL;
2848 
<span class="line-modified">2849       g_assert (digit_len &lt; (gsize) (buffer + sizeof (buffer) - buffer_end));</span>
2850 
2851       alt_digits[i] = buffer_end;
2852       buffer_end = g_stpcpy (buffer_end, digit);
2853       /* skip trailing null byte */
2854       buffer_end += 1;
2855 
2856       g_free (digit);
2857     }
2858 
2859   return alt_digits;
2860 }
2861 #endif /* HAVE_LANGINFO_OUTDIGIT */
2862 
2863 static void
2864 format_number (GString     *str,
2865                gboolean     use_alt_digits,
2866                const gchar *pad,
2867                gint         width,
2868                guint32      number)
2869 {
</pre>
<hr />
<pre>
2921 {
2922   const gchar *ampm;
2923   gchar       *tmp = NULL, *ampm_dup;
2924 
2925   ampm = GET_AMPM (datetime);
2926 
2927   if (!ampm || ampm[0] == &#39;\0&#39;)
2928     ampm = get_fallback_ampm (g_date_time_get_hour (datetime));
2929 
2930   if (!locale_is_utf8 &amp;&amp; GET_AMPM_IS_LOCALE)
2931     {
2932       /* This assumes that locale encoding can&#39;t have embedded NULs */
2933       ampm = tmp = g_locale_to_utf8 (ampm, -1, NULL, NULL, NULL);
2934       if (tmp == NULL)
2935         return FALSE;
2936     }
2937   if (uppercase)
2938     ampm_dup = g_utf8_strup (ampm, -1);
2939   else
2940     ampm_dup = g_utf8_strdown (ampm, -1);
<span class="line-modified">2941   g_free (tmp);</span>
2942 
2943   g_string_append (outstr, ampm_dup);
<span class="line-modified">2944   g_free (ampm_dup);</span>
2945 
2946   return TRUE;
2947 }
2948 
2949 static gboolean g_date_time_format_utf8 (GDateTime   *datetime,
<span class="line-modified">2950            const gchar *format,</span>
<span class="line-modified">2951            GString     *outstr,</span>
<span class="line-modified">2952            gboolean     locale_is_utf8);</span>
2953 
2954 /* g_date_time_format() subroutine that takes a locale-encoded format
2955  * string and produces a UTF-8 encoded date/time string.
2956  */
2957 static gboolean
2958 g_date_time_format_locale (GDateTime   *datetime,
<span class="line-modified">2959          const gchar *locale_format,</span>
<span class="line-modified">2960          GString     *outstr,</span>
<span class="line-modified">2961          gboolean     locale_is_utf8)</span>
2962 {
2963   gchar *utf8_format;
2964   gboolean success;
2965 
2966   if (locale_is_utf8)
2967     return g_date_time_format_utf8 (datetime, locale_format, outstr, locale_is_utf8);
2968 
2969   utf8_format = g_locale_to_utf8 (locale_format, -1, NULL, NULL, NULL);
2970   if (utf8_format == NULL)
2971     return FALSE;
2972 
2973   success = g_date_time_format_utf8 (datetime, utf8_format, outstr,
<span class="line-modified">2974                                      locale_is_utf8);</span>
2975   g_free (utf8_format);
2976   return success;
2977 }
2978 
2979 static inline gboolean
2980 string_append (GString     *string,
2981                const gchar *s,
2982                gboolean     s_is_utf8)
2983 {
2984   gchar *utf8;
2985   gsize  utf8_len;
2986 
2987   if (s_is_utf8)
2988     {
2989       g_string_append (string, s);
2990     }
2991   else
2992     {
2993       utf8 = g_locale_to_utf8 (s, -1, NULL, &amp;utf8_len, NULL);
2994       if (utf8 == NULL)
2995         return FALSE;
2996       g_string_append_len (string, utf8, utf8_len);
2997       g_free (utf8);
2998     }
2999 
3000   return TRUE;
3001 }
3002 
3003 /* g_date_time_format() subroutine that takes a UTF-8 encoded format
3004  * string and produces a UTF-8 encoded date/time string.
3005  */
3006 static gboolean
3007 g_date_time_format_utf8 (GDateTime   *datetime,
<span class="line-modified">3008        const gchar *utf8_format,</span>
<span class="line-modified">3009        GString     *outstr,</span>
<span class="line-modified">3010        gboolean     locale_is_utf8)</span>
3011 {
3012   guint     len;
3013   guint     colons;
3014   gunichar  c;
3015   gboolean  alt_digits = FALSE;
3016   gboolean  pad_set = FALSE;
3017   gboolean  name_is_utf8;
3018   const gchar *pad = &quot;&quot;;
3019   const gchar *name;
3020   const gchar *tz;
3021 
3022   while (*utf8_format)
3023     {
3024       len = strcspn (utf8_format, &quot;%&quot;);
3025       if (len)
3026         g_string_append_len (outstr, utf8_format, len);
3027 
3028       utf8_format += len;
3029       if (!*utf8_format)
<span class="line-modified">3030   break;</span>
3031 
3032       g_assert (*utf8_format == &#39;%&#39;);
3033       utf8_format++;
3034       if (!*utf8_format)
<span class="line-modified">3035   break;</span>
3036 
3037       colons = 0;
3038       alt_digits = FALSE;
3039       pad_set = FALSE;
3040 
3041     next_mod:
3042       c = g_utf8_get_char (utf8_format);
3043       utf8_format = g_utf8_next_char (utf8_format);
3044       switch (c)
<span class="line-modified">3045   {</span>
<span class="line-modified">3046   case &#39;a&#39;:</span>
<span class="line-modified">3047     name = WEEKDAY_ABBR (datetime);</span>
3048           if (g_strcmp0 (name, &quot;&quot;) == 0)
3049             return FALSE;
3050 
3051           name_is_utf8 = locale_is_utf8 || !WEEKDAY_ABBR_IS_LOCALE;
3052 
3053           if (!string_append (outstr, name, name_is_utf8))
3054             return FALSE;
3055 
<span class="line-modified">3056     break;</span>
<span class="line-modified">3057   case &#39;A&#39;:</span>
<span class="line-modified">3058     name = WEEKDAY_FULL (datetime);</span>
3059           if (g_strcmp0 (name, &quot;&quot;) == 0)
3060             return FALSE;
3061 
3062           name_is_utf8 = locale_is_utf8 || !WEEKDAY_FULL_IS_LOCALE;
3063 
3064           if (!string_append (outstr, name, name_is_utf8))
3065             return FALSE;
3066 
<span class="line-modified">3067     break;</span>
<span class="line-modified">3068   case &#39;b&#39;:</span>
<span class="line-modified">3069     name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)</span>
<span class="line-modified">3070           : MONTH_ABBR_WITH_DAY (datetime);</span>
3071           if (g_strcmp0 (name, &quot;&quot;) == 0)
3072             return FALSE;
3073 
3074           name_is_utf8 = locale_is_utf8 ||
3075             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3076              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3077 
3078           if (!string_append (outstr, name, name_is_utf8))
3079             return FALSE;
3080 
<span class="line-modified">3081     break;</span>
<span class="line-modified">3082   case &#39;B&#39;:</span>
<span class="line-modified">3083     name = alt_digits ? MONTH_FULL_STANDALONE (datetime)</span>
<span class="line-modified">3084           : MONTH_FULL_WITH_DAY (datetime);</span>
3085           if (g_strcmp0 (name, &quot;&quot;) == 0)
3086             return FALSE;
3087 
3088           name_is_utf8 = locale_is_utf8 ||
3089             ((alt_digits &amp;&amp; !MONTH_FULL_STANDALONE_IS_LOCALE) ||
3090              (!alt_digits &amp;&amp; !MONTH_FULL_WITH_DAY_IS_LOCALE));
3091 
3092           if (!string_append (outstr, name, name_is_utf8))
3093               return FALSE;
3094 
<span class="line-modified">3095     break;</span>
<span class="line-modified">3096   case &#39;c&#39;:</span>
<span class="line-modified">3097     {</span>
3098             if (g_strcmp0 (PREFERRED_DATE_TIME_FMT, &quot;&quot;) == 0)
3099               return FALSE;
3100             if (!g_date_time_format_locale (datetime, PREFERRED_DATE_TIME_FMT,
3101                                             outstr, locale_is_utf8))
3102               return FALSE;
<span class="line-modified">3103     }</span>
<span class="line-modified">3104     break;</span>
<span class="line-modified">3105   case &#39;C&#39;:</span>
<span class="line-modified">3106     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3107        g_date_time_get_year (datetime) / 100);</span>
<span class="line-modified">3108     break;</span>
<span class="line-modified">3109   case &#39;d&#39;:</span>
<span class="line-modified">3110     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3111        g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3112     break;</span>
<span class="line-modified">3113   case &#39;e&#39;:</span>
<span class="line-modified">3114     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3115        g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3116     break;</span>
<span class="line-modified">3117   case &#39;F&#39;:</span>
<span class="line-modified">3118     g_string_append_printf (outstr, &quot;%d-%02d-%02d&quot;,</span>
<span class="line-modified">3119           g_date_time_get_year (datetime),</span>
<span class="line-modified">3120           g_date_time_get_month (datetime),</span>
<span class="line-modified">3121           g_date_time_get_day_of_month (datetime));</span>
<span class="line-modified">3122     break;</span>
<span class="line-modified">3123   case &#39;g&#39;:</span>
<span class="line-modified">3124     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3125        g_date_time_get_week_numbering_year (datetime) % 100);</span>
<span class="line-modified">3126     break;</span>
<span class="line-modified">3127   case &#39;G&#39;:</span>
<span class="line-modified">3128     format_number (outstr, alt_digits, pad_set ? pad : 0, 0,</span>
<span class="line-modified">3129        g_date_time_get_week_numbering_year (datetime));</span>
<span class="line-modified">3130     break;</span>
<span class="line-modified">3131   case &#39;h&#39;:</span>
<span class="line-modified">3132     name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)</span>
<span class="line-modified">3133           : MONTH_ABBR_WITH_DAY (datetime);</span>
3134           if (g_strcmp0 (name, &quot;&quot;) == 0)
3135             return FALSE;
3136 
3137           name_is_utf8 = locale_is_utf8 ||
3138             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3139              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3140 
3141           if (!string_append (outstr, name, name_is_utf8))
3142             return FALSE;
3143 
<span class="line-modified">3144     break;</span>
<span class="line-modified">3145   case &#39;H&#39;:</span>
<span class="line-modified">3146     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3147        g_date_time_get_hour (datetime));</span>
<span class="line-modified">3148     break;</span>
<span class="line-modified">3149   case &#39;I&#39;:</span>
<span class="line-modified">3150     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3151        (g_date_time_get_hour (datetime) + 11) % 12 + 1);</span>
<span class="line-modified">3152     break;</span>
<span class="line-modified">3153   case &#39;j&#39;:</span>
<span class="line-modified">3154     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 3,</span>
<span class="line-modified">3155        g_date_time_get_day_of_year (datetime));</span>
<span class="line-modified">3156     break;</span>
<span class="line-modified">3157   case &#39;k&#39;:</span>
<span class="line-modified">3158     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3159        g_date_time_get_hour (datetime));</span>
<span class="line-modified">3160     break;</span>
<span class="line-modified">3161   case &#39;l&#39;:</span>
<span class="line-modified">3162     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,</span>
<span class="line-modified">3163        (g_date_time_get_hour (datetime) + 11) % 12 + 1);</span>
<span class="line-modified">3164     break;</span>
<span class="line-modified">3165   case &#39;n&#39;:</span>
<span class="line-modified">3166     g_string_append_c (outstr, &#39;\n&#39;);</span>
<span class="line-modified">3167     break;</span>
<span class="line-modified">3168   case &#39;m&#39;:</span>
<span class="line-modified">3169     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3170        g_date_time_get_month (datetime));</span>
<span class="line-modified">3171     break;</span>
<span class="line-modified">3172   case &#39;M&#39;:</span>
<span class="line-modified">3173     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3174        g_date_time_get_minute (datetime));</span>
<span class="line-modified">3175     break;</span>
<span class="line-modified">3176   case &#39;O&#39;:</span>
<span class="line-modified">3177     alt_digits = TRUE;</span>
<span class="line-modified">3178     goto next_mod;</span>
<span class="line-modified">3179   case &#39;p&#39;:</span>
3180           if (!format_ampm (datetime, outstr, locale_is_utf8, TRUE))
3181             return FALSE;
3182           break;
<span class="line-modified">3183   case &#39;P&#39;:</span>
3184           if (!format_ampm (datetime, outstr, locale_is_utf8, FALSE))
3185             return FALSE;
<span class="line-modified">3186     break;</span>
<span class="line-modified">3187   case &#39;r&#39;:</span>
<span class="line-modified">3188     {</span>
3189             if (g_strcmp0 (PREFERRED_12HR_TIME_FMT, &quot;&quot;) == 0)
3190               return FALSE;
<span class="line-modified">3191       if (!g_date_time_format_locale (datetime, PREFERRED_12HR_TIME_FMT,</span>
<span class="line-modified">3192               outstr, locale_is_utf8))</span>
<span class="line-modified">3193         return FALSE;</span>
<span class="line-modified">3194     }</span>
<span class="line-modified">3195     break;</span>
<span class="line-modified">3196   case &#39;R&#39;:</span>
<span class="line-modified">3197     g_string_append_printf (outstr, &quot;%02d:%02d&quot;,</span>
<span class="line-modified">3198           g_date_time_get_hour (datetime),</span>
<span class="line-modified">3199           g_date_time_get_minute (datetime));</span>
<span class="line-modified">3200     break;</span>
<span class="line-modified">3201   case &#39;s&#39;:</span>
<span class="line-modified">3202     g_string_append_printf (outstr, &quot;%&quot; G_GINT64_FORMAT, g_date_time_to_unix (datetime));</span>
<span class="line-modified">3203     break;</span>
<span class="line-modified">3204   case &#39;S&#39;:</span>
<span class="line-modified">3205     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3206        g_date_time_get_second (datetime));</span>
<span class="line-modified">3207     break;</span>
<span class="line-modified">3208   case &#39;t&#39;:</span>
<span class="line-modified">3209     g_string_append_c (outstr, &#39;\t&#39;);</span>
<span class="line-modified">3210     break;</span>
<span class="line-modified">3211   case &#39;T&#39;:</span>
<span class="line-modified">3212     g_string_append_printf (outstr, &quot;%02d:%02d:%02d&quot;,</span>
<span class="line-modified">3213           g_date_time_get_hour (datetime),</span>
<span class="line-modified">3214           g_date_time_get_minute (datetime),</span>
<span class="line-modified">3215           g_date_time_get_second (datetime));</span>
<span class="line-modified">3216     break;</span>
<span class="line-modified">3217   case &#39;u&#39;:</span>
<span class="line-modified">3218     format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-modified">3219        g_date_time_get_day_of_week (datetime));</span>
<span class="line-modified">3220     break;</span>
<span class="line-modified">3221   case &#39;V&#39;:</span>
<span class="line-modified">3222     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-modified">3223        g_date_time_get_week_of_year (datetime));</span>
<span class="line-modified">3224     break;</span>
<span class="line-modified">3225   case &#39;w&#39;:</span>
<span class="line-modified">3226     format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-modified">3227        g_date_time_get_day_of_week (datetime) % 7);</span>
<span class="line-modified">3228     break;</span>
<span class="line-modified">3229   case &#39;x&#39;:</span>
<span class="line-modified">3230     {</span>
3231             if (g_strcmp0 (PREFERRED_DATE_FMT, &quot;&quot;) == 0)
3232               return FALSE;
<span class="line-modified">3233       if (!g_date_time_format_locale (datetime, PREFERRED_DATE_FMT,</span>
<span class="line-modified">3234               outstr, locale_is_utf8))</span>
<span class="line-modified">3235         return FALSE;</span>
<span class="line-modified">3236     }</span>
<span class="line-modified">3237     break;</span>
<span class="line-modified">3238   case &#39;X&#39;:</span>
<span class="line-modified">3239     {</span>
3240             if (g_strcmp0 (PREFERRED_TIME_FMT, &quot;&quot;) == 0)
3241               return FALSE;
<span class="line-modified">3242       if (!g_date_time_format_locale (datetime, PREFERRED_TIME_FMT,</span>
<span class="line-modified">3243               outstr, locale_is_utf8))</span>









































3244         return FALSE;




3245     }
<span class="line-added">3246     break;</span>
<span class="line-added">3247   case &#39;y&#39;:</span>
<span class="line-added">3248     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,</span>
<span class="line-added">3249        g_date_time_get_year (datetime) % 100);</span>
<span class="line-added">3250     break;</span>
<span class="line-added">3251   case &#39;Y&#39;:</span>
<span class="line-added">3252     format_number (outstr, alt_digits, 0, 0,</span>
<span class="line-added">3253        g_date_time_get_year (datetime));</span>
<span class="line-added">3254     break;</span>
<span class="line-added">3255   case &#39;z&#39;:</span>
<span class="line-added">3256     {</span>
<span class="line-added">3257       gint64 offset;</span>
<span class="line-added">3258       offset = g_date_time_get_utc_offset (datetime) / USEC_PER_SECOND;</span>
<span class="line-added">3259       if (!format_z (outstr, (int) offset, colons))</span>
<span class="line-added">3260         return FALSE;</span>
<span class="line-added">3261     }</span>
<span class="line-added">3262     break;</span>
<span class="line-added">3263   case &#39;Z&#39;:</span>
<span class="line-added">3264     tz = g_date_time_get_timezone_abbreviation (datetime);</span>
<span class="line-added">3265           g_string_append (outstr, tz);</span>
<span class="line-added">3266     break;</span>
<span class="line-added">3267   case &#39;%&#39;:</span>
<span class="line-added">3268     g_string_append_c (outstr, &#39;%&#39;);</span>
<span class="line-added">3269     break;</span>
<span class="line-added">3270   case &#39;-&#39;:</span>
<span class="line-added">3271     pad_set = TRUE;</span>
<span class="line-added">3272     pad = &quot;&quot;;</span>
<span class="line-added">3273     goto next_mod;</span>
<span class="line-added">3274   case &#39;_&#39;:</span>
<span class="line-added">3275     pad_set = TRUE;</span>
<span class="line-added">3276     pad = &quot; &quot;;</span>
<span class="line-added">3277     goto next_mod;</span>
<span class="line-added">3278   case &#39;0&#39;:</span>
<span class="line-added">3279     pad_set = TRUE;</span>
<span class="line-added">3280     pad = &quot;0&quot;;</span>
<span class="line-added">3281     goto next_mod;</span>
<span class="line-added">3282   case &#39;:&#39;:</span>
<span class="line-added">3283     /* Colons are only allowed before &#39;z&#39; */</span>
<span class="line-added">3284     if (*utf8_format &amp;&amp; *utf8_format != &#39;z&#39; &amp;&amp; *utf8_format != &#39;:&#39;)</span>
<span class="line-added">3285       return FALSE;</span>
<span class="line-added">3286     colons++;</span>
<span class="line-added">3287     goto next_mod;</span>
<span class="line-added">3288   default:</span>
<span class="line-added">3289     return FALSE;</span>
<span class="line-added">3290   }</span>
3291     }
3292 
3293   return TRUE;
3294 }
3295 
3296 /**
3297  * g_date_time_format:
3298  * @datetime: A #GDateTime
3299  * @format: a valid UTF-8 string, containing the format for the
3300  *          #GDateTime
3301  *
3302  * Creates a newly allocated string representing the requested @format.
3303  *
3304  * The format strings understood by this function are a subset of the
3305  * strftime() format language as specified by C99.  The \%D, \%U and \%W
3306  * conversions are not supported, nor is the &#39;E&#39; modifier.  The GNU
3307  * extensions \%k, \%l, \%s and \%P are supported, however, as are the
3308  * &#39;0&#39;, &#39;_&#39; and &#39;-&#39; modifiers.
3309  *
3310  * In contrast to strftime(), this function always produces a UTF-8
</pre>
<hr />
<pre>
3410   /* Avoid conversions from locale charset to UTF-8 if charset is compatible
3411    * with UTF-8 already. Check for UTF-8 and synonymous canonical names of
3412    * ASCII. */
3413   gboolean locale_is_utf8_compatible = g_get_charset (&amp;charset) ||
3414     g_strcmp0 (&quot;ASCII&quot;, charset) == 0 ||
3415     g_strcmp0 (&quot;ANSI_X3.4-1968&quot;, charset) == 0;
3416 
3417   g_return_val_if_fail (datetime != NULL, NULL);
3418   g_return_val_if_fail (format != NULL, NULL);
3419   g_return_val_if_fail (g_utf8_validate (format, -1, NULL), NULL);
3420 
3421   outstr = g_string_sized_new (strlen (format) * 2);
3422 
3423   if (!g_date_time_format_utf8 (datetime, format, outstr,
3424                                 locale_is_utf8_compatible))
3425     {
3426       g_string_free (outstr, TRUE);
3427       return NULL;
3428     }
3429 
<span class="line-modified">3430   return g_string_free (outstr, FALSE);</span>
<span class="line-added">3431 }</span>
<span class="line-added">3432 </span>
<span class="line-added">3433 /**</span>
<span class="line-added">3434  * g_date_time_format_iso8601:</span>
<span class="line-added">3435  * @datetime: A #GDateTime</span>
<span class="line-added">3436  *</span>
<span class="line-added">3437  * Format @datetime in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601),</span>
<span class="line-added">3438  * including the date, time and time zone, and return that as a UTF-8 encoded</span>
<span class="line-added">3439  * string.</span>
<span class="line-added">3440  *</span>
<span class="line-added">3441  * Returns: a newly allocated string formatted in ISO 8601 format</span>
<span class="line-added">3442  *     or %NULL in the case that there was an error. The string</span>
<span class="line-added">3443  *     should be freed with g_free().</span>
<span class="line-added">3444  * Since: 2.62</span>
<span class="line-added">3445  */</span>
<span class="line-added">3446 gchar *</span>
<span class="line-added">3447 g_date_time_format_iso8601 (GDateTime *datetime)</span>
<span class="line-added">3448 {</span>
<span class="line-added">3449   GString *outstr = NULL;</span>
<span class="line-added">3450   gchar *main_date = NULL;</span>
<span class="line-added">3451   gint64 offset;</span>
<span class="line-added">3452 </span>
<span class="line-added">3453   /* Main date and time. */</span>
<span class="line-added">3454   main_date = g_date_time_format (datetime, &quot;%Y-%m-%dT%H:%M:%S&quot;);</span>
<span class="line-added">3455   outstr = g_string_new (main_date);</span>
<span class="line-added">3456   g_free (main_date);</span>
<span class="line-added">3457 </span>
<span class="line-added">3458   /* Timezone. Format it as `%:::z` unless the offset is zero, in which case</span>
<span class="line-added">3459    * we can simply use `Z`. */</span>
<span class="line-added">3460   offset = g_date_time_get_utc_offset (datetime);</span>
<span class="line-added">3461 </span>
<span class="line-added">3462   if (offset == 0)</span>
<span class="line-added">3463     {</span>
<span class="line-added">3464       g_string_append_c (outstr, &#39;Z&#39;);</span>
<span class="line-added">3465     }</span>
<span class="line-added">3466   else</span>
<span class="line-added">3467     {</span>
<span class="line-added">3468       gchar *time_zone = g_date_time_format (datetime, &quot;%:::z&quot;);</span>
<span class="line-added">3469       g_string_append (outstr, time_zone);</span>
<span class="line-added">3470       g_free (time_zone);</span>
<span class="line-added">3471     }</span>
<span class="line-added">3472 </span>
<span class="line-added">3473   return g_string_free (outstr, FALSE);</span>
3474 }
3475 
3476 
3477 /* Epilogue {{{1 */
3478 /* vim:set foldmethod=marker: */
</pre>
</td>
</tr>
</table>
<center><a href="gdate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdatetime.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>