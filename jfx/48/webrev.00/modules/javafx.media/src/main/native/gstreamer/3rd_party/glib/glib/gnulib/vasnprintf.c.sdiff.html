<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gnulib/vasnprintf.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="printf.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="vasnprintf.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gnulib/vasnprintf.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /* vsprintf with automatic memory allocation.
<span class="line-modified">   2    Copyright (C) 1999, 2002-2016 Free Software Foundation, Inc.</span>
   3 
   4    This program is free software; you can redistribute it and/or modify
   5    it under the terms of the GNU Lesser General Public License as published by
   6    the Free Software Foundation; either version 2.1, or (at your option)
   7    any later version.
   8 
   9    This program is distributed in the hope that it will be useful,
  10    but WITHOUT ANY WARRANTY; without even the implied warranty of
  11    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12    GNU Lesser General Public License for more details.
  13 
  14    You should have received a copy of the GNU Lesser General Public License along
<span class="line-modified">  15    with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
  16 
  17 /* This file can be parametrized with the following macros:
  18      VASNPRINTF         The name of the function being defined.
  19      FCHAR_T            The element type of the format string.
  20      DCHAR_T            The element type of the destination (result) string.
  21      FCHAR_T_ONLY_ASCII Set to 1 to enable verification that all characters
  22                         in the format string are ASCII. MUST be set if
  23                         FCHAR_T and DCHAR_T are not the same type.
  24      DIRECTIVE          Structure denoting a format directive.
  25                         Depends on FCHAR_T.
  26      DIRECTIVES         Structure denoting the set of format directives of a
  27                         format string.  Depends on FCHAR_T.
  28      PRINTF_PARSE       Function that parses a format string.
  29                         Depends on FCHAR_T.
  30      DCHAR_CPY          memcpy like function for DCHAR_T[] arrays.
  31      DCHAR_SET          memset like function for DCHAR_T[] arrays.
  32      DCHAR_MBSNLEN      mbsnlen like function for DCHAR_T[] arrays.
  33      SNPRINTF           The system&#39;s snprintf (or similar) function.
  34                         This may be either snprintf or swprintf.
  35      TCHAR_T            The element type of the argument and result string
</pre>
<hr />
<pre>
  38                         sizeof (TCHAR_T) | sizeof (DCHAR_T) and
  39                         alignof (TCHAR_T) &lt;= alignof (DCHAR_T).
  40      DCHAR_IS_TCHAR     Set to 1 if DCHAR_T and TCHAR_T are the same type.
  41      DCHAR_CONV_FROM_ENCODING A function to convert from char[] to DCHAR[].
  42      DCHAR_IS_UINT8_T   Set to 1 if DCHAR_T is uint8_t.
  43      DCHAR_IS_UINT16_T  Set to 1 if DCHAR_T is uint16_t.
  44      DCHAR_IS_UINT32_T  Set to 1 if DCHAR_T is uint32_t.  */
  45 
  46 #ifndef _WIN32
  47 /* Tell glibc&#39;s &lt;stdio.h&gt; to provide a prototype for snprintf().
  48    This must come before &lt;config.h&gt; because &lt;config.h&gt; may include
  49    &lt;features.h&gt;, and once &lt;features.h&gt; has been included, it&#39;s too late.  */
  50 #ifndef _GNU_SOURCE
  51 # define _GNU_SOURCE    1
  52 #endif
  53 #endif
  54 
  55 #ifndef VASNPRINTF
  56 # include &lt;config.h&gt;
  57 #endif
<span class="line-removed">  58 /* galloca.h also defines alloca and HAVE_ALLOCA makes the code below use it */</span>
  59 #include &quot;glib/galloca.h&quot;
<span class="line-removed">  60 #define HAVE_ALLOCA 1</span>
  61 
  62 #include &quot;g-gnulib.h&quot;
  63 
  64 /* Specification.  */
<span class="line-modified">  65 #include &quot;vasnprintf.h&quot;</span>






  66 
  67 #include &lt;locale.h&gt;     /* localeconv() */
  68 #include &lt;stdio.h&gt;      /* snprintf(), sprintf() */
  69 #include &lt;stdlib.h&gt;     /* abort(), malloc(), realloc(), free() */
  70 #include &lt;string.h&gt;     /* memcpy(), strlen() */
  71 #include &lt;errno.h&gt;      /* errno */
  72 #include &lt;limits.h&gt;     /* CHAR_BIT */
  73 #include &lt;float.h&gt;      /* DBL_MAX_EXP, LDBL_MAX_EXP */







  74 #  include &quot;printf-parse.h&quot;


  75 

  76 #include &quot;xsize.h&quot;
  77 
  78 #include &quot;verify.h&quot;
  79 
  80 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified">  81 # include &lt;math.h&gt;</span>
  82 # include &quot;float+.h&quot;
  83 #endif
  84 
  85 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified">  86 # include &lt;math.h&gt;</span>
  87 # include &quot;isnand-nolibm.h&quot;
  88 #endif
  89 
  90 #if (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified">  91 # include &lt;math.h&gt;</span>
  92 # include &quot;isnanl-nolibm.h&quot;
  93 # include &quot;fpucw.h&quot;
  94 #endif
  95 
  96 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified">  97 # include &lt;math.h&gt;</span>
  98 # include &quot;isnand-nolibm.h&quot;
  99 # include &quot;printf-frexp.h&quot;
 100 #endif
 101 
 102 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified"> 103 # include &lt;math.h&gt;</span>
 104 # include &quot;isnanl-nolibm.h&quot;
 105 # include &quot;printf-frexpl.h&quot;
 106 # include &quot;fpucw.h&quot;
 107 #endif
 108 








 109 /* Default parameters.  */
 110 #ifndef VASNPRINTF
 111 # if WIDE_CHAR_VERSION
 112 #  define VASNPRINTF vasnwprintf
 113 #  define FCHAR_T wchar_t
 114 #  define DCHAR_T wchar_t
 115 #  define TCHAR_T wchar_t
 116 #  define DCHAR_IS_TCHAR 1
 117 #  define DIRECTIVE wchar_t_directive
 118 #  define DIRECTIVES wchar_t_directives
 119 #  define PRINTF_PARSE wprintf_parse
 120 #  define DCHAR_CPY wmemcpy
 121 #  define DCHAR_SET wmemset
 122 # else
 123 #  define VASNPRINTF vasnprintf
 124 #  define FCHAR_T char
 125 #  define DCHAR_T char
 126 #  define TCHAR_T char
 127 #  define DCHAR_IS_TCHAR 1
 128 #  define DIRECTIVE char_directive
 129 #  define DIRECTIVES char_directives
 130 #  define PRINTF_PARSE printf_parse
 131 #  define DCHAR_CPY memcpy
 132 #  define DCHAR_SET memset
 133 # endif
 134 #endif
 135 #if WIDE_CHAR_VERSION
 136   /* TCHAR_T is wchar_t.  */
 137 # define USE_SNPRINTF 1
 138 # if HAVE_DECL__SNWPRINTF
 139    /* On Windows, the function swprintf() has a different signature than
 140       on Unix; we use the function _snwprintf() or - on mingw - snwprintf()
 141       instead.  The mingw function snwprintf() has fewer bugs than the
 142       MSVCRT function _snwprintf(), so prefer that.  */
 143 #  if defined __MINGW32__
 144 #   define SNPRINTF snwprintf
 145 #  else
 146 #   define SNPRINTF _snwprintf

 147 #  endif
 148 # else
 149    /* Unix.  */
 150 #  define SNPRINTF swprintf
 151 # endif
 152 #else
 153   /* TCHAR_T is char.  */
 154   /* Use snprintf if it exists under the name &#39;snprintf&#39; or &#39;_snprintf&#39;.
 155      But don&#39;t use it on BeOS, since BeOS snprintf produces no output if the
 156      size argument is &gt;= 0x3000000.
 157      Also don&#39;t use it on Linux libc5, since there snprintf with size = 1
 158      writes any output without bounds, like sprintf.  */
 159 # if (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF) &amp;&amp; !defined __BEOS__ &amp;&amp; !(__GNU_LIBRARY__ == 1)
 160 #  define USE_SNPRINTF 1
 161 # else
 162 #  define USE_SNPRINTF 0
 163 # endif
 164 # if HAVE_DECL__SNPRINTF
 165    /* Windows.  The mingw function snprintf() has fewer bugs than the MSVCRT
 166       function _snprintf(), so prefer that.  */
 167 #  if defined __MINGW32__
 168 #   define SNPRINTF snprintf
 169     /* Here we need to call the native snprintf, not rpl_snprintf.  */
 170 #   undef snprintf
 171 #  else

 172 #   define SNPRINTF _snprintf

 173 #  endif
 174 # else
 175    /* Unix.  */
 176 #  define SNPRINTF snprintf
 177    /* Here we need to call the native snprintf, not rpl_snprintf.  */
 178 #  undef snprintf
 179 # endif
 180 #endif
 181 /* Here we need to call the native sprintf, not rpl_sprintf.  */
 182 #undef sprintf
 183 
 184 /* GCC &gt;= 4.0 with -Wall emits unjustified &quot;... may be used uninitialized&quot;
 185    warnings in this file.  Use -Dlint to suppress them.  */
<span class="line-modified"> 186 #ifdef lint</span>
 187 # define IF_LINT(Code) Code
 188 #else
 189 # define IF_LINT(Code) /* empty */
 190 #endif
 191 
 192 /* Avoid some warnings from &quot;gcc -Wshadow&quot;.
 193    This file doesn&#39;t use the exp() and remainder() functions.  */
 194 #undef exp
 195 #define exp expo
 196 #undef remainder
 197 #define remainder rem
 198 
<span class="line-modified"> 199 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; !WIDE_CHAR_VERSION</span>
 200 # if (HAVE_STRNLEN &amp;&amp; !defined _AIX)
 201 #  define local_strnlen strnlen
 202 # else
 203 #  ifndef local_strnlen_defined
 204 #   define local_strnlen_defined 1
 205 static size_t
 206 local_strnlen (const char *string, size_t maxlen)
 207 {
 208   const char *end = memchr (string, &#39;\0&#39;, maxlen);
 209   return end ? (size_t) (end - string) : maxlen;
 210 }
 211 #  endif
 212 # endif
 213 #endif
 214 
<span class="line-modified"> 215 #if (((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; WIDE_CHAR_VERSION) || ((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; !WIDE_CHAR_VERSION &amp;&amp; DCHAR_IS_TCHAR)) &amp;&amp; HAVE_WCHAR_T</span>
 216 # if HAVE_WCSLEN
 217 #  define local_wcslen wcslen
 218 # else
 219    /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
 220       a dependency towards this library, here is a local substitute.
 221       Define this substitute only once, even if this file is included
 222       twice in the same compilation unit.  */
 223 #  ifndef local_wcslen_defined
 224 #   define local_wcslen_defined 1
 225 static size_t
 226 local_wcslen (const wchar_t *s)
 227 {
 228   const wchar_t *ptr;
 229 
 230   for (ptr = s; *ptr != (wchar_t) 0; ptr++)
 231     ;
 232   return ptr - s;
 233 }
 234 #  endif
 235 # endif
 236 #endif
 237 
<span class="line-modified"> 238 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; HAVE_WCHAR_T &amp;&amp; WIDE_CHAR_VERSION</span>
 239 # if HAVE_WCSNLEN
 240 #  define local_wcsnlen wcsnlen
 241 # else
 242 #  ifndef local_wcsnlen_defined
 243 #   define local_wcsnlen_defined 1
 244 static size_t
 245 local_wcsnlen (const wchar_t *s, size_t maxlen)
 246 {
 247   const wchar_t *ptr;
 248 
 249   for (ptr = s; maxlen &gt; 0 &amp;&amp; *ptr != (wchar_t) 0; ptr++, maxlen--)
 250     ;
 251   return ptr - s;
 252 }
 253 #  endif
 254 # endif
 255 #endif
 256 
 257 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
 258 /* Determine the decimal-point character according to the current locale.  */
</pre>
<hr />
<pre>
 820   if (tmp_roomptr != NULL)
 821     free (tmp_roomptr);
 822   q-&gt;limbs = q_ptr;
 823   q-&gt;nlimbs = q_len;
 824   return roomptr;
 825 }
 826 
 827 /* Convert a bignum a &gt;= 0, multiplied with 10^extra_zeroes, to decimal
 828    representation.
 829    Destroys the contents of a.
 830    Return the allocated memory - containing the decimal digits in low-to-high
 831    order, terminated with a NUL character - in case of success, NULL in case
 832    of memory allocation failure.  */
 833 static char *
 834 convert_to_decimal (mpn_t a, size_t extra_zeroes)
 835 {
 836   mp_limb_t *a_ptr = a.limbs;
 837   size_t a_len = a.nlimbs;
 838   /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */
 839   size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);
<span class="line-modified"> 840   char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));</span>


 841   if (c_ptr != NULL)
 842     {
 843       char *d_ptr = c_ptr;
 844       for (; extra_zeroes &gt; 0; extra_zeroes--)
 845         *d_ptr++ = &#39;0&#39;;
 846       while (a_len &gt; 0)
 847         {
 848           /* Divide a by 10^9, in-place.  */
 849           mp_limb_t remainder = 0;
 850           mp_limb_t *ptr = a_ptr + a_len;
 851           size_t count;
 852           for (count = a_len; count &gt; 0; count--)
 853             {
 854               mp_twolimb_t num =
 855                 ((mp_twolimb_t) remainder &lt;&lt; GMP_LIMB_BITS) | *--ptr;
 856               *ptr = num / 1000000000;
 857               remainder = num % 1000000000;
 858             }
 859           /* Store the remainder as 9 decimal digits.  */
 860           for (count = 9; count &gt; 0; count--)
</pre>
<hr />
<pre>
1488 }
1489 
1490 # endif
1491 
1492 /* Tests whether a string of digits consists of exactly PRECISION zeroes and
1493    a single &#39;1&#39; digit.  */
1494 static int
1495 is_borderline (const char *digits, size_t precision)
1496 {
1497   for (; precision &gt; 0; precision--, digits++)
1498     if (*digits != &#39;0&#39;)
1499       return 0;
1500   if (*digits != &#39;1&#39;)
1501     return 0;
1502   digits++;
1503   return *digits == &#39;\0&#39;;
1504 }
1505 
1506 #endif
1507 
<span class="line-modified">1508 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99</span>
1509 
1510 /* Use a different function name, to make it possible that the &#39;wchar_t&#39;
1511    parametrization and the &#39;char&#39; parametrization get compiled in the same
1512    translation unit.  */
1513 # if WIDE_CHAR_VERSION
1514 #  define MAX_ROOM_NEEDED wmax_room_needed
1515 # else
1516 #  define MAX_ROOM_NEEDED max_room_needed
1517 # endif
1518 
1519 /* Returns the number of TCHAR_T units needed as temporary space for the result
1520    of sprintf or SNPRINTF of a single conversion directive.  */
1521 static size_t
1522 MAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,
1523                  arg_type type, int flags, size_t width, int has_precision,
1524                  size_t precision, int pad_ourselves)
1525 {
1526   size_t tmp_length;
1527 
1528   switch (conversion)
</pre>
<hr />
<pre>
2363                           }
2364                         length += converted_len;
2365                       }
2366 # endif
2367 
2368                       if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2369                         {
2370                           size_t n = width - characters;
2371                           ENSURE_ALLOCATION (xsum (length, n));
2372                           DCHAR_SET (result + length, &#39; &#39;, n);
2373                           length += n;
2374                         }
2375                     }
2376                     break;
2377 
2378                   default:
2379                     abort ();
2380                   }
2381               }
2382 #endif
<span class="line-modified">2383 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; HAVE_WCHAR_T</span>
2384             else if (dp-&gt;conversion == &#39;s&#39;
2385 # if WIDE_CHAR_VERSION
2386                      &amp;&amp; a.arg[dp-&gt;arg_index].type != TYPE_WIDE_STRING
2387 # else
2388                      &amp;&amp; a.arg[dp-&gt;arg_index].type == TYPE_WIDE_STRING
2389 # endif
2390                     )
2391               {
2392                 /* The normal handling of the &#39;s&#39; directive below requires
2393                    allocating a temporary buffer.  The determination of its
2394                    length (tmp_length), in the case when a precision is
2395                    specified, below requires a conversion between a char[]
2396                    string and a wchar_t[] wide string.  It could be done, but
2397                    we have no guarantee that the implementation of sprintf will
2398                    use the exactly same algorithm.  Without this guarantee, it
2399                    is possible to have buffer overrun bugs.  In order to avoid
2400                    such bugs, we implement the entire processing of the &#39;s&#39;
2401                    directive ourselves.  */
2402                 int flags = dp-&gt;flags;
2403                 int has_width;
</pre>
<hr />
<pre>
2654 
2655                           if (*arg_end == 0)
2656                             /* Found the terminating null wide character.  */
2657                             break;
2658 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2659                           count = wcrtomb (cbuf, *arg_end, &amp;state);
2660 #  else
2661                           count = wctomb (cbuf, *arg_end);
2662 #  endif
2663                           if (count &lt; 0)
2664                             {
2665                               /* Cannot convert.  */
2666                               if (!(result == resultbuf || result == NULL))
2667                                 free (result);
2668                               if (buf_malloced != NULL)
2669                                 free (buf_malloced);
2670                               CLEANUP ();
2671                               errno = EILSEQ;
2672                               return NULL;
2673                             }
<span class="line-modified">2674                           if (precision &lt; count)</span>
2675                             break;
2676                           arg_end++;
2677                           characters += count;
2678                           precision -= count;
2679                         }
2680                     }
2681 #  if DCHAR_IS_TCHAR
2682                   else if (has_width)
2683 #  else
2684                   else
2685 #  endif
2686                     {
2687                       /* Use the entire string, and count the number of
2688                          bytes.  */
2689 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2690                       mbstate_t state;
2691                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2692 #  endif
2693                       arg_end = arg;
2694                       characters = 0;
</pre>
<hr />
<pre>
4203                                     *p++ = digits[--ndigits];
4204                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4205                                       {
4206                                         *p++ = decimal_point_char ();
4207                                         while (ndigits &gt; 0)
4208                                           {
4209                                             --ndigits;
4210                                             *p++ = digits[ndigits];
4211                                           }
4212                                       }
4213 
4214                                     free (digits);
4215                                   }
4216 
4217                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4218 #   if WIDE_CHAR_VERSION
4219                                 {
4220                                   static const wchar_t decimal_format[] =
4221                                     /* Produce the same number of exponent digits
4222                                        as the native printf implementation.  */
<span class="line-modified">4223 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4224                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4225 #    else
4226                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4227 #    endif
4228                                   SNPRINTF (p, 6 + 1, decimal_format, exponent);
4229                                 }
4230                                 while (*p != &#39;\0&#39;)
4231                                   p++;
4232 #   else
4233                                 {
4234                                   static const char decimal_format[] =
4235                                     /* Produce the same number of exponent digits
4236                                        as the native printf implementation.  */
<span class="line-modified">4237 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4238                                     &quot;%+.3d&quot;;
4239 #    else
4240                                     &quot;%+.2d&quot;;
4241 #    endif
4242                                   if (sizeof (DCHAR_T) == 1)
4243                                     {
4244                                       sprintf ((char *) p, decimal_format, exponent);
4245                                       while (*p != &#39;\0&#39;)
4246                                         p++;
4247                                     }
4248                                   else
4249                                     {
4250                                       char expbuf[6 + 1];
4251                                       const char *ep;
4252                                       sprintf (expbuf, decimal_format, exponent);
4253                                       for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4254                                         p++;
4255                                     }
4256                                 }
4257 #   endif
</pre>
<hr />
<pre>
4396                                       }
4397                                     else
4398                                       {
4399                                         /* Exponential notation.  */
4400                                         *p++ = digits[--ndigits];
4401                                         if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
4402                                           {
4403                                             *p++ = decimal_point_char ();
4404                                             while (ndigits &gt; nzeroes)
4405                                               {
4406                                                 --ndigits;
4407                                                 *p++ = digits[ndigits];
4408                                               }
4409                                           }
4410                                         *p++ = dp-&gt;conversion - &#39;G&#39; + &#39;E&#39;; /* &#39;e&#39; or &#39;E&#39; */
4411 #   if WIDE_CHAR_VERSION
4412                                         {
4413                                           static const wchar_t decimal_format[] =
4414                                             /* Produce the same number of exponent digits
4415                                                as the native printf implementation.  */
<span class="line-modified">4416 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4417                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4418 #    else
4419                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4420 #    endif
4421                                           SNPRINTF (p, 6 + 1, decimal_format, exponent);
4422                                         }
4423                                         while (*p != &#39;\0&#39;)
4424                                           p++;
4425 #   else
4426                                         {
4427                                           static const char decimal_format[] =
4428                                             /* Produce the same number of exponent digits
4429                                                as the native printf implementation.  */
<span class="line-modified">4430 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4431                                             &quot;%+.3d&quot;;
4432 #    else
4433                                             &quot;%+.2d&quot;;
4434 #    endif
4435                                           if (sizeof (DCHAR_T) == 1)
4436                                             {
4437                                               sprintf ((char *) p, decimal_format, exponent);
4438                                               while (*p != &#39;\0&#39;)
4439                                                 p++;
4440                                             }
4441                                           else
4442                                             {
4443                                               char expbuf[6 + 1];
4444                                               const char *ep;
4445                                               sprintf (expbuf, decimal_format, exponent);
4446                                               for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4447                                                 p++;
4448                                             }
4449                                         }
4450 #   endif
</pre>
<hr />
<pre>
4468                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4469                                   {
4470                                     *p++ = decimal_point_char ();
4471                                     for (; precision &gt; 0; precision--)
4472                                       *p++ = &#39;0&#39;;
4473                                   }
4474                               }
4475                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
4476                               {
4477                                 *p++ = &#39;0&#39;;
4478                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4479                                   {
4480                                     *p++ = decimal_point_char ();
4481                                     for (; precision &gt; 0; precision--)
4482                                       *p++ = &#39;0&#39;;
4483                                   }
4484                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4485                                 *p++ = &#39;+&#39;;
4486                                 /* Produce the same number of exponent digits as
4487                                    the native printf implementation.  */
<span class="line-modified">4488 #   if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4489                                 *p++ = &#39;0&#39;;
4490 #   endif
4491                                 *p++ = &#39;0&#39;;
4492                                 *p++ = &#39;0&#39;;
4493                               }
4494                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
4495                               {
4496                                 *p++ = &#39;0&#39;;
4497                                 if (flags &amp; FLAG_ALT)
4498                                   {
4499                                     size_t ndigits =
4500                                       (precision &gt; 0 ? precision - 1 : 0);
4501                                     *p++ = decimal_point_char ();
4502                                     for (; ndigits &gt; 0; --ndigits)
4503                                       *p++ = &#39;0&#39;;
4504                                   }
4505                               }
4506                             else
4507                               abort ();
4508 #  endif
</pre>
<hr />
<pre>
4562                   {
4563                     size_t n = xsum (length, count);
4564 
4565                     ENSURE_ALLOCATION (n);
4566                   }
4567 
4568                 /* Append the result.  */
4569                 memcpy (result + length, tmp, count * sizeof (DCHAR_T));
4570                 if (tmp != tmpbuf)
4571                   free (tmp);
4572                 length += count;
4573               }
4574 #endif
4575             else
4576               {
4577                 arg_type type = a.arg[dp-&gt;arg_index].type;
4578                 int flags = dp-&gt;flags;
4579 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4580                 int has_width;
4581 #endif
<span class="line-modified">4582 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4583                 size_t width;
4584 #endif
<span class="line-modified">4585 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4586                 int has_precision;
4587                 size_t precision;
4588 #endif
4589 #if NEED_PRINTF_UNBOUNDED_PRECISION
4590                 int prec_ourselves;
4591 #else
4592 #               define prec_ourselves 0
4593 #endif
4594 #if NEED_PRINTF_FLAG_LEFTADJUST
4595 #               define pad_ourselves 1
4596 #elif !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4597                 int pad_ourselves;
4598 #else
4599 #               define pad_ourselves 0
4600 #endif
4601                 TCHAR_T *fbp;
4602                 unsigned int prefix_count;
4603                 int prefixes[2] IF_LINT (= { 0 });
4604                 int orig_errno;
4605 #if !USE_SNPRINTF
4606                 size_t tmp_length;
4607                 TCHAR_T tmpbuf[700];
4608                 TCHAR_T *tmp;
4609 #endif
4610 
4611 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4612                 has_width = 0;
4613 #endif
<span class="line-modified">4614 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4615                 width = 0;
4616                 if (dp-&gt;width_start != dp-&gt;width_end)
4617                   {
4618                     if (dp-&gt;width_arg_index != ARG_NONE)
4619                       {
4620                         int arg;
4621 
4622                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4623                           abort ();
4624                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
4625                         width = arg;
4626                         if (arg &lt; 0)
4627                           {
4628                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
4629                                 followed by a positive field width.&quot;  */
4630                             flags |= FLAG_LEFT;
4631                             width = -width;
4632                           }
4633                       }
4634                     else
4635                       {
4636                         const FCHAR_T *digitp = dp-&gt;width_start;
4637 
4638                         do
4639                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
4640                         while (digitp != dp-&gt;width_end);
4641                       }
4642 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4643                     has_width = 1;
4644 #endif
4645                   }
4646 #endif
4647 
<span class="line-modified">4648 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4649                 has_precision = 0;
4650                 precision = 6;
4651                 if (dp-&gt;precision_start != dp-&gt;precision_end)
4652                   {
4653                     if (dp-&gt;precision_arg_index != ARG_NONE)
4654                       {
4655                         int arg;
4656 
4657                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4658                           abort ();
4659                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
4660                         /* &quot;A negative precision is taken as if the precision
4661                             were omitted.&quot;  */
4662                         if (arg &gt;= 0)
4663                           {
4664                             precision = arg;
4665                             has_precision = 1;
4666                           }
4667                       }
4668                     else
</pre>
<hr />
<pre>
4796                         if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
4797                           {
4798                             memcpy (fbp, dp-&gt;precision_start, n * sizeof (TCHAR_T));
4799                             fbp += n;
4800                           }
4801                         else
4802                           {
4803                             const FCHAR_T *mp = dp-&gt;precision_start;
4804                             do
4805                               *fbp++ = *mp++;
4806                             while (--n &gt; 0);
4807                           }
4808                       }
4809                   }
4810 
4811                 switch (type)
4812                   {
4813 #if HAVE_LONG_LONG
4814                   case TYPE_LONGLONGINT:
4815                   case TYPE_ULONGLONGINT:
<span class="line-modified">4816 # if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__</span>
4817                     *fbp++ = &#39;I&#39;;
4818                     *fbp++ = &#39;6&#39;;
4819                     *fbp++ = &#39;4&#39;;
4820                     break;
4821 # else
4822                     *fbp++ = &#39;l&#39;;
<span class="line-removed">4823                     /*FALLTHROUGH*/</span>
4824 # endif
4825 #endif

4826                   case TYPE_LONGINT:
4827                   case TYPE_ULONGINT:
4828 #if HAVE_WINT_T
4829                   case TYPE_WIDE_CHAR:
4830 #endif
4831 #if HAVE_WCHAR_T
4832                   case TYPE_WIDE_STRING:
4833 #endif
4834                     *fbp++ = &#39;l&#39;;
4835                     break;
4836                   case TYPE_LONGDOUBLE:
4837                     *fbp++ = &#39;L&#39;;
4838                     break;
4839                   default:
4840                     break;
4841                   }
4842 #if NEED_PRINTF_DIRECTIVE_F
4843                 if (dp-&gt;conversion == &#39;F&#39;)
4844                   *fbp = &#39;f&#39;;
4845                 else
4846 #endif
4847                   *fbp = dp-&gt;conversion;
4848 #if USE_SNPRINTF
<span class="line-modified">4849 # if !(((__GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 3)) &amp;&amp; !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__))</span>




4850                 fbp[1] = &#39;%&#39;;
4851                 fbp[2] = &#39;n&#39;;
4852                 fbp[3] = &#39;\0&#39;;
4853 # else
4854                 /* On glibc2 systems from glibc &gt;= 2.3 - probably also older
4855                    ones - we know that snprintf&#39;s return value conforms to
4856                    ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and
4857                    gl_SNPRINTF_TRUNCATION_C99 pass.
4858                    Therefore we can avoid using %n in this situation.
4859                    On glibc2 systems from 2004-10-18 or newer, the use of %n
4860                    in format strings in writable memory may crash the program
4861                    (if compiled with _FORTIFY_SOURCE=2), so we should avoid it
4862                    in this situation.  */















4863                 /* On native Windows systems (such as mingw), we can avoid using
4864                    %n because:
4865                      - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,
4866                        snprintf does not write more than the specified number
4867                        of bytes. (snprintf (buf, 3, &quot;%d %d&quot;, 4567, 89) writes
4868                        &#39;4&#39;, &#39;5&#39;, &#39;6&#39; into buf, not &#39;4&#39;, &#39;5&#39;, &#39;\0&#39;.)
4869                      - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf
4870                        allows us to recognize the case of an insufficient
4871                        buffer size: it returns -1 in this case.
4872                    On native Windows systems (such as mingw) where the OS is
4873                    Windows Vista, the use of %n in format strings by default
4874                    crashes the program. See
<span class="line-modified">4875                      &lt;http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html&gt; and</span>
<span class="line-modified">4876                      &lt;http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx&gt;</span>
4877                    So we should avoid %n in this situation.  */
4878                 fbp[1] = &#39;\0&#39;;
4879 # endif
4880 #else
4881                 fbp[1] = &#39;\0&#39;;
4882 #endif
4883 
4884                 /* Construct the arguments for calling snprintf or sprintf.  */
4885                 prefix_count = 0;
4886                 if (!pad_ourselves &amp;&amp; dp-&gt;width_arg_index != ARG_NONE)
4887                   {
4888                     if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4889                       abort ();
4890                     prefixes[prefix_count++] = a.arg[dp-&gt;width_arg_index].a.a_int;
4891                   }
4892                 if (!prec_ourselves &amp;&amp; dp-&gt;precision_arg_index != ARG_NONE)
4893                   {
4894                     if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4895                       abort ();
4896                     prefixes[prefix_count++] = a.arg[dp-&gt;precision_arg_index].a.a_int;
</pre>
<hr />
<pre>
5075 #endif
5076                       case TYPE_POINTER:
5077                         {
5078                           void *arg = a.arg[dp-&gt;arg_index].a.a_pointer;
5079                           SNPRINTF_BUF (arg);
5080                         }
5081                         break;
5082                       default:
5083                         abort ();
5084                       }
5085 
5086 #if USE_SNPRINTF
5087                     /* Portability: Not all implementations of snprintf()
5088                        are ISO C 99 compliant.  Determine the number of
5089                        bytes that snprintf() has produced or would have
5090                        produced.  */
5091                     if (count &gt;= 0)
5092                       {
5093                         /* Verify that snprintf() has NUL-terminated its
5094                            result.  */
<span class="line-modified">5095                         if (count &lt; maxlen</span>
5096                             &amp;&amp; ((TCHAR_T *) (result + length)) [count] != &#39;\0&#39;)
5097                           abort ();
5098                         /* Portability hack.  */
5099                         if (retcount &gt; count)
5100                           count = retcount;
5101                       }
5102                     else
5103                       {
5104                         /* snprintf() doesn&#39;t understand the &#39;%n&#39;
5105                            directive.  */
5106                         if (fbp[1] != &#39;\0&#39;)
5107                           {
5108                             /* Don&#39;t use the &#39;%n&#39; directive; instead, look
5109                                at the snprintf() return value.  */
5110                             fbp[1] = &#39;\0&#39;;
5111                             continue;
5112                           }
5113                         else
5114                           {
5115                             /* Look at the snprintf() return value.  */
5116                             if (retcount &lt; 0)
5117                               {
<span class="line-modified">5118 # if !HAVE_SNPRINTF_RETVAL_C99</span>
5119                                 /* HP-UX 10.20 snprintf() is doubly deficient:
5120                                    It doesn&#39;t understand the &#39;%n&#39; directive,
5121                                    *and* it returns -1 (rather than the length
5122                                    that would have been required) when the
5123                                    buffer is too small.
5124                                    But a failure at this point can also come
5125                                    from other reasons than a too small buffer,
5126                                    such as an invalid wide string argument to
5127                                    the %ls directive, or possibly an invalid
5128                                    floating-point argument.  */
5129                                 size_t tmp_length =
5130                                   MAX_ROOM_NEEDED (&amp;a, dp-&gt;arg_index,
5131                                                    dp-&gt;conversion, type, flags,
5132                                                    width,
5133                                                    has_precision,
5134                                                    precision, pad_ourselves);
5135 
5136                                 if (maxlen &lt; tmp_length)
5137                                   {
5138                                     /* Make more room.  But try to do through
</pre>
</td>
<td>
<hr />
<pre>
   1 /* vsprintf with automatic memory allocation.
<span class="line-modified">   2    Copyright (C) 1999, 2002-2019 Free Software Foundation, Inc.</span>
   3 
   4    This program is free software; you can redistribute it and/or modify
   5    it under the terms of the GNU Lesser General Public License as published by
   6    the Free Software Foundation; either version 2.1, or (at your option)
   7    any later version.
   8 
   9    This program is distributed in the hope that it will be useful,
  10    but WITHOUT ANY WARRANTY; without even the implied warranty of
  11    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12    GNU Lesser General Public License for more details.
  13 
  14    You should have received a copy of the GNU Lesser General Public License along
<span class="line-modified">  15    with this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.  */</span>
  16 
  17 /* This file can be parametrized with the following macros:
  18      VASNPRINTF         The name of the function being defined.
  19      FCHAR_T            The element type of the format string.
  20      DCHAR_T            The element type of the destination (result) string.
  21      FCHAR_T_ONLY_ASCII Set to 1 to enable verification that all characters
  22                         in the format string are ASCII. MUST be set if
  23                         FCHAR_T and DCHAR_T are not the same type.
  24      DIRECTIVE          Structure denoting a format directive.
  25                         Depends on FCHAR_T.
  26      DIRECTIVES         Structure denoting the set of format directives of a
  27                         format string.  Depends on FCHAR_T.
  28      PRINTF_PARSE       Function that parses a format string.
  29                         Depends on FCHAR_T.
  30      DCHAR_CPY          memcpy like function for DCHAR_T[] arrays.
  31      DCHAR_SET          memset like function for DCHAR_T[] arrays.
  32      DCHAR_MBSNLEN      mbsnlen like function for DCHAR_T[] arrays.
  33      SNPRINTF           The system&#39;s snprintf (or similar) function.
  34                         This may be either snprintf or swprintf.
  35      TCHAR_T            The element type of the argument and result string
</pre>
<hr />
<pre>
  38                         sizeof (TCHAR_T) | sizeof (DCHAR_T) and
  39                         alignof (TCHAR_T) &lt;= alignof (DCHAR_T).
  40      DCHAR_IS_TCHAR     Set to 1 if DCHAR_T and TCHAR_T are the same type.
  41      DCHAR_CONV_FROM_ENCODING A function to convert from char[] to DCHAR[].
  42      DCHAR_IS_UINT8_T   Set to 1 if DCHAR_T is uint8_t.
  43      DCHAR_IS_UINT16_T  Set to 1 if DCHAR_T is uint16_t.
  44      DCHAR_IS_UINT32_T  Set to 1 if DCHAR_T is uint32_t.  */
  45 
  46 #ifndef _WIN32
  47 /* Tell glibc&#39;s &lt;stdio.h&gt; to provide a prototype for snprintf().
  48    This must come before &lt;config.h&gt; because &lt;config.h&gt; may include
  49    &lt;features.h&gt;, and once &lt;features.h&gt; has been included, it&#39;s too late.  */
  50 #ifndef _GNU_SOURCE
  51 # define _GNU_SOURCE    1
  52 #endif
  53 #endif
  54 
  55 #ifndef VASNPRINTF
  56 # include &lt;config.h&gt;
  57 #endif

  58 #include &quot;glib/galloca.h&quot;

  59 
  60 #include &quot;g-gnulib.h&quot;
  61 
  62 /* Specification.  */
<span class="line-modified">  63 #ifndef VASNPRINTF</span>
<span class="line-added">  64 # if WIDE_CHAR_VERSION</span>
<span class="line-added">  65 #  include &quot;vasnwprintf.h&quot;</span>
<span class="line-added">  66 # else</span>
<span class="line-added">  67 #  include &quot;vasnprintf.h&quot;</span>
<span class="line-added">  68 # endif</span>
<span class="line-added">  69 #endif</span>
  70 
  71 #include &lt;locale.h&gt;     /* localeconv() */
  72 #include &lt;stdio.h&gt;      /* snprintf(), sprintf() */
  73 #include &lt;stdlib.h&gt;     /* abort(), malloc(), realloc(), free() */
  74 #include &lt;string.h&gt;     /* memcpy(), strlen() */
  75 #include &lt;errno.h&gt;      /* errno */
  76 #include &lt;limits.h&gt;     /* CHAR_BIT */
  77 #include &lt;float.h&gt;      /* DBL_MAX_EXP, LDBL_MAX_EXP */
<span class="line-added">  78 #if HAVE_NL_LANGINFO</span>
<span class="line-added">  79 # include &lt;langinfo.h&gt;</span>
<span class="line-added">  80 #endif</span>
<span class="line-added">  81 #ifndef VASNPRINTF</span>
<span class="line-added">  82 # if WIDE_CHAR_VERSION</span>
<span class="line-added">  83 #  include &quot;wprintf-parse.h&quot;</span>
<span class="line-added">  84 # else</span>
  85 #  include &quot;printf-parse.h&quot;
<span class="line-added">  86 # endif</span>
<span class="line-added">  87 #endif</span>
  88 
<span class="line-added">  89 /* Checked size_t computations.  */</span>
  90 #include &quot;xsize.h&quot;
  91 
  92 #include &quot;verify.h&quot;
  93 
  94 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified">  95 # include &lt;gnulib_math.h&gt;</span>
  96 # include &quot;float+.h&quot;
  97 #endif
  98 
  99 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified"> 100 # include &lt;gnulib_math.h&gt;</span>
 101 # include &quot;isnand-nolibm.h&quot;
 102 #endif
 103 
 104 #if (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified"> 105 # include &lt;gnulib_math.h&gt;</span>
 106 # include &quot;isnanl-nolibm.h&quot;
 107 # include &quot;fpucw.h&quot;
 108 #endif
 109 
 110 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified"> 111 # include &lt;gnulib_math.h&gt;</span>
 112 # include &quot;isnand-nolibm.h&quot;
 113 # include &quot;printf-frexp.h&quot;
 114 #endif
 115 
 116 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
<span class="line-modified"> 117 # include &lt;gnulib_math.h&gt;</span>
 118 # include &quot;isnanl-nolibm.h&quot;
 119 # include &quot;printf-frexpl.h&quot;
 120 # include &quot;fpucw.h&quot;
 121 #endif
 122 
<span class="line-added"> 123 #ifndef FALLTHROUGH</span>
<span class="line-added"> 124 # if __GNUC__ &lt; 7</span>
<span class="line-added"> 125 #  define FALLTHROUGH ((void) 0)</span>
<span class="line-added"> 126 # else</span>
<span class="line-added"> 127 #  define FALLTHROUGH __attribute__ ((__fallthrough__))</span>
<span class="line-added"> 128 # endif</span>
<span class="line-added"> 129 #endif</span>
<span class="line-added"> 130 </span>
 131 /* Default parameters.  */
 132 #ifndef VASNPRINTF
 133 # if WIDE_CHAR_VERSION
 134 #  define VASNPRINTF vasnwprintf
 135 #  define FCHAR_T wchar_t
 136 #  define DCHAR_T wchar_t
 137 #  define TCHAR_T wchar_t
 138 #  define DCHAR_IS_TCHAR 1
 139 #  define DIRECTIVE wchar_t_directive
 140 #  define DIRECTIVES wchar_t_directives
 141 #  define PRINTF_PARSE wprintf_parse
 142 #  define DCHAR_CPY wmemcpy
 143 #  define DCHAR_SET wmemset
 144 # else
 145 #  define VASNPRINTF vasnprintf
 146 #  define FCHAR_T char
 147 #  define DCHAR_T char
 148 #  define TCHAR_T char
 149 #  define DCHAR_IS_TCHAR 1
 150 #  define DIRECTIVE char_directive
 151 #  define DIRECTIVES char_directives
 152 #  define PRINTF_PARSE printf_parse
 153 #  define DCHAR_CPY memcpy
 154 #  define DCHAR_SET memset
 155 # endif
 156 #endif
 157 #if WIDE_CHAR_VERSION
 158   /* TCHAR_T is wchar_t.  */
 159 # define USE_SNPRINTF 1
 160 # if HAVE_DECL__SNWPRINTF
 161    /* On Windows, the function swprintf() has a different signature than
 162       on Unix; we use the function _snwprintf() or - on mingw - snwprintf()
 163       instead.  The mingw function snwprintf() has fewer bugs than the
 164       MSVCRT function _snwprintf(), so prefer that.  */
 165 #  if defined __MINGW32__
 166 #   define SNPRINTF snwprintf
 167 #  else
 168 #   define SNPRINTF _snwprintf
<span class="line-added"> 169 #   define USE_MSVC__SNPRINTF 1</span>
 170 #  endif
 171 # else
 172    /* Unix.  */
 173 #  define SNPRINTF swprintf
 174 # endif
 175 #else
 176   /* TCHAR_T is char.  */
 177   /* Use snprintf if it exists under the name &#39;snprintf&#39; or &#39;_snprintf&#39;.
 178      But don&#39;t use it on BeOS, since BeOS snprintf produces no output if the
 179      size argument is &gt;= 0x3000000.
 180      Also don&#39;t use it on Linux libc5, since there snprintf with size = 1
 181      writes any output without bounds, like sprintf.  */
 182 # if (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF) &amp;&amp; !defined __BEOS__ &amp;&amp; !(__GNU_LIBRARY__ == 1)
 183 #  define USE_SNPRINTF 1
 184 # else
 185 #  define USE_SNPRINTF 0
 186 # endif
 187 # if HAVE_DECL__SNPRINTF
 188    /* Windows.  The mingw function snprintf() has fewer bugs than the MSVCRT
 189       function _snprintf(), so prefer that.  */
 190 #  if defined __MINGW32__
 191 #   define SNPRINTF snprintf
 192     /* Here we need to call the native snprintf, not rpl_snprintf.  */
 193 #   undef snprintf
 194 #  else
<span class="line-added"> 195     /* MSVC versions &lt; 14 did not have snprintf, only _snprintf.  */</span>
 196 #   define SNPRINTF _snprintf
<span class="line-added"> 197 #   define USE_MSVC__SNPRINTF 1</span>
 198 #  endif
 199 # else
 200    /* Unix.  */
 201 #  define SNPRINTF snprintf
 202    /* Here we need to call the native snprintf, not rpl_snprintf.  */
 203 #  undef snprintf
 204 # endif
 205 #endif
 206 /* Here we need to call the native sprintf, not rpl_sprintf.  */
 207 #undef sprintf
 208 
 209 /* GCC &gt;= 4.0 with -Wall emits unjustified &quot;... may be used uninitialized&quot;
 210    warnings in this file.  Use -Dlint to suppress them.  */
<span class="line-modified"> 211 #if defined GCC_LINT || defined lint</span>
 212 # define IF_LINT(Code) Code
 213 #else
 214 # define IF_LINT(Code) /* empty */
 215 #endif
 216 
 217 /* Avoid some warnings from &quot;gcc -Wshadow&quot;.
 218    This file doesn&#39;t use the exp() and remainder() functions.  */
 219 #undef exp
 220 #define exp expo
 221 #undef remainder
 222 #define remainder rem
 223 
<span class="line-modified"> 224 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF) &amp;&amp; !WIDE_CHAR_VERSION</span>
 225 # if (HAVE_STRNLEN &amp;&amp; !defined _AIX)
 226 #  define local_strnlen strnlen
 227 # else
 228 #  ifndef local_strnlen_defined
 229 #   define local_strnlen_defined 1
 230 static size_t
 231 local_strnlen (const char *string, size_t maxlen)
 232 {
 233   const char *end = memchr (string, &#39;\0&#39;, maxlen);
 234   return end ? (size_t) (end - string) : maxlen;
 235 }
 236 #  endif
 237 # endif
 238 #endif
 239 
<span class="line-modified"> 240 #if (((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF) &amp;&amp; WIDE_CHAR_VERSION) || ((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; !WIDE_CHAR_VERSION &amp;&amp; DCHAR_IS_TCHAR)) &amp;&amp; HAVE_WCHAR_T</span>
 241 # if HAVE_WCSLEN
 242 #  define local_wcslen wcslen
 243 # else
 244    /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
 245       a dependency towards this library, here is a local substitute.
 246       Define this substitute only once, even if this file is included
 247       twice in the same compilation unit.  */
 248 #  ifndef local_wcslen_defined
 249 #   define local_wcslen_defined 1
 250 static size_t
 251 local_wcslen (const wchar_t *s)
 252 {
 253   const wchar_t *ptr;
 254 
 255   for (ptr = s; *ptr != (wchar_t) 0; ptr++)
 256     ;
 257   return ptr - s;
 258 }
 259 #  endif
 260 # endif
 261 #endif
 262 
<span class="line-modified"> 263 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF) &amp;&amp; HAVE_WCHAR_T &amp;&amp; WIDE_CHAR_VERSION</span>
 264 # if HAVE_WCSNLEN
 265 #  define local_wcsnlen wcsnlen
 266 # else
 267 #  ifndef local_wcsnlen_defined
 268 #   define local_wcsnlen_defined 1
 269 static size_t
 270 local_wcsnlen (const wchar_t *s, size_t maxlen)
 271 {
 272   const wchar_t *ptr;
 273 
 274   for (ptr = s; maxlen &gt; 0 &amp;&amp; *ptr != (wchar_t) 0; ptr++, maxlen--)
 275     ;
 276   return ptr - s;
 277 }
 278 #  endif
 279 # endif
 280 #endif
 281 
 282 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
 283 /* Determine the decimal-point character according to the current locale.  */
</pre>
<hr />
<pre>
 845   if (tmp_roomptr != NULL)
 846     free (tmp_roomptr);
 847   q-&gt;limbs = q_ptr;
 848   q-&gt;nlimbs = q_len;
 849   return roomptr;
 850 }
 851 
 852 /* Convert a bignum a &gt;= 0, multiplied with 10^extra_zeroes, to decimal
 853    representation.
 854    Destroys the contents of a.
 855    Return the allocated memory - containing the decimal digits in low-to-high
 856    order, terminated with a NUL character - in case of success, NULL in case
 857    of memory allocation failure.  */
 858 static char *
 859 convert_to_decimal (mpn_t a, size_t extra_zeroes)
 860 {
 861   mp_limb_t *a_ptr = a.limbs;
 862   size_t a_len = a.nlimbs;
 863   /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */
 864   size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);
<span class="line-modified"> 865   /* We need extra_zeroes bytes for zeroes, followed by c_len bytes for the</span>
<span class="line-added"> 866      digits of a, followed by 1 byte for the terminating NUL.  */</span>
<span class="line-added"> 867   char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));</span>
 868   if (c_ptr != NULL)
 869     {
 870       char *d_ptr = c_ptr;
 871       for (; extra_zeroes &gt; 0; extra_zeroes--)
 872         *d_ptr++ = &#39;0&#39;;
 873       while (a_len &gt; 0)
 874         {
 875           /* Divide a by 10^9, in-place.  */
 876           mp_limb_t remainder = 0;
 877           mp_limb_t *ptr = a_ptr + a_len;
 878           size_t count;
 879           for (count = a_len; count &gt; 0; count--)
 880             {
 881               mp_twolimb_t num =
 882                 ((mp_twolimb_t) remainder &lt;&lt; GMP_LIMB_BITS) | *--ptr;
 883               *ptr = num / 1000000000;
 884               remainder = num % 1000000000;
 885             }
 886           /* Store the remainder as 9 decimal digits.  */
 887           for (count = 9; count &gt; 0; count--)
</pre>
<hr />
<pre>
1515 }
1516 
1517 # endif
1518 
1519 /* Tests whether a string of digits consists of exactly PRECISION zeroes and
1520    a single &#39;1&#39; digit.  */
1521 static int
1522 is_borderline (const char *digits, size_t precision)
1523 {
1524   for (; precision &gt; 0; precision--, digits++)
1525     if (*digits != &#39;0&#39;)
1526       return 0;
1527   if (*digits != &#39;1&#39;)
1528     return 0;
1529   digits++;
1530   return *digits == &#39;\0&#39;;
1531 }
1532 
1533 #endif
1534 
<span class="line-modified">1535 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF</span>
1536 
1537 /* Use a different function name, to make it possible that the &#39;wchar_t&#39;
1538    parametrization and the &#39;char&#39; parametrization get compiled in the same
1539    translation unit.  */
1540 # if WIDE_CHAR_VERSION
1541 #  define MAX_ROOM_NEEDED wmax_room_needed
1542 # else
1543 #  define MAX_ROOM_NEEDED max_room_needed
1544 # endif
1545 
1546 /* Returns the number of TCHAR_T units needed as temporary space for the result
1547    of sprintf or SNPRINTF of a single conversion directive.  */
1548 static size_t
1549 MAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,
1550                  arg_type type, int flags, size_t width, int has_precision,
1551                  size_t precision, int pad_ourselves)
1552 {
1553   size_t tmp_length;
1554 
1555   switch (conversion)
</pre>
<hr />
<pre>
2390                           }
2391                         length += converted_len;
2392                       }
2393 # endif
2394 
2395                       if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2396                         {
2397                           size_t n = width - characters;
2398                           ENSURE_ALLOCATION (xsum (length, n));
2399                           DCHAR_SET (result + length, &#39; &#39;, n);
2400                           length += n;
2401                         }
2402                     }
2403                     break;
2404 
2405                   default:
2406                     abort ();
2407                   }
2408               }
2409 #endif
<span class="line-modified">2410 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; HAVE_WCHAR_T</span>
2411             else if (dp-&gt;conversion == &#39;s&#39;
2412 # if WIDE_CHAR_VERSION
2413                      &amp;&amp; a.arg[dp-&gt;arg_index].type != TYPE_WIDE_STRING
2414 # else
2415                      &amp;&amp; a.arg[dp-&gt;arg_index].type == TYPE_WIDE_STRING
2416 # endif
2417                     )
2418               {
2419                 /* The normal handling of the &#39;s&#39; directive below requires
2420                    allocating a temporary buffer.  The determination of its
2421                    length (tmp_length), in the case when a precision is
2422                    specified, below requires a conversion between a char[]
2423                    string and a wchar_t[] wide string.  It could be done, but
2424                    we have no guarantee that the implementation of sprintf will
2425                    use the exactly same algorithm.  Without this guarantee, it
2426                    is possible to have buffer overrun bugs.  In order to avoid
2427                    such bugs, we implement the entire processing of the &#39;s&#39;
2428                    directive ourselves.  */
2429                 int flags = dp-&gt;flags;
2430                 int has_width;
</pre>
<hr />
<pre>
2681 
2682                           if (*arg_end == 0)
2683                             /* Found the terminating null wide character.  */
2684                             break;
2685 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2686                           count = wcrtomb (cbuf, *arg_end, &amp;state);
2687 #  else
2688                           count = wctomb (cbuf, *arg_end);
2689 #  endif
2690                           if (count &lt; 0)
2691                             {
2692                               /* Cannot convert.  */
2693                               if (!(result == resultbuf || result == NULL))
2694                                 free (result);
2695                               if (buf_malloced != NULL)
2696                                 free (buf_malloced);
2697                               CLEANUP ();
2698                               errno = EILSEQ;
2699                               return NULL;
2700                             }
<span class="line-modified">2701                           if (precision &lt; (unsigned int) count)</span>
2702                             break;
2703                           arg_end++;
2704                           characters += count;
2705                           precision -= count;
2706                         }
2707                     }
2708 #  if DCHAR_IS_TCHAR
2709                   else if (has_width)
2710 #  else
2711                   else
2712 #  endif
2713                     {
2714                       /* Use the entire string, and count the number of
2715                          bytes.  */
2716 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2717                       mbstate_t state;
2718                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2719 #  endif
2720                       arg_end = arg;
2721                       characters = 0;
</pre>
<hr />
<pre>
4230                                     *p++ = digits[--ndigits];
4231                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4232                                       {
4233                                         *p++ = decimal_point_char ();
4234                                         while (ndigits &gt; 0)
4235                                           {
4236                                             --ndigits;
4237                                             *p++ = digits[ndigits];
4238                                           }
4239                                       }
4240 
4241                                     free (digits);
4242                                   }
4243 
4244                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4245 #   if WIDE_CHAR_VERSION
4246                                 {
4247                                   static const wchar_t decimal_format[] =
4248                                     /* Produce the same number of exponent digits
4249                                        as the native printf implementation.  */
<span class="line-modified">4250 #    if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4251                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4252 #    else
4253                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4254 #    endif
4255                                   SNPRINTF (p, 6 + 1, decimal_format, exponent);
4256                                 }
4257                                 while (*p != &#39;\0&#39;)
4258                                   p++;
4259 #   else
4260                                 {
4261                                   static const char decimal_format[] =
4262                                     /* Produce the same number of exponent digits
4263                                        as the native printf implementation.  */
<span class="line-modified">4264 #    if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4265                                     &quot;%+.3d&quot;;
4266 #    else
4267                                     &quot;%+.2d&quot;;
4268 #    endif
4269                                   if (sizeof (DCHAR_T) == 1)
4270                                     {
4271                                       sprintf ((char *) p, decimal_format, exponent);
4272                                       while (*p != &#39;\0&#39;)
4273                                         p++;
4274                                     }
4275                                   else
4276                                     {
4277                                       char expbuf[6 + 1];
4278                                       const char *ep;
4279                                       sprintf (expbuf, decimal_format, exponent);
4280                                       for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4281                                         p++;
4282                                     }
4283                                 }
4284 #   endif
</pre>
<hr />
<pre>
4423                                       }
4424                                     else
4425                                       {
4426                                         /* Exponential notation.  */
4427                                         *p++ = digits[--ndigits];
4428                                         if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
4429                                           {
4430                                             *p++ = decimal_point_char ();
4431                                             while (ndigits &gt; nzeroes)
4432                                               {
4433                                                 --ndigits;
4434                                                 *p++ = digits[ndigits];
4435                                               }
4436                                           }
4437                                         *p++ = dp-&gt;conversion - &#39;G&#39; + &#39;E&#39;; /* &#39;e&#39; or &#39;E&#39; */
4438 #   if WIDE_CHAR_VERSION
4439                                         {
4440                                           static const wchar_t decimal_format[] =
4441                                             /* Produce the same number of exponent digits
4442                                                as the native printf implementation.  */
<span class="line-modified">4443 #    if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4444                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4445 #    else
4446                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4447 #    endif
4448                                           SNPRINTF (p, 6 + 1, decimal_format, exponent);
4449                                         }
4450                                         while (*p != &#39;\0&#39;)
4451                                           p++;
4452 #   else
4453                                         {
4454                                           static const char decimal_format[] =
4455                                             /* Produce the same number of exponent digits
4456                                                as the native printf implementation.  */
<span class="line-modified">4457 #    if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4458                                             &quot;%+.3d&quot;;
4459 #    else
4460                                             &quot;%+.2d&quot;;
4461 #    endif
4462                                           if (sizeof (DCHAR_T) == 1)
4463                                             {
4464                                               sprintf ((char *) p, decimal_format, exponent);
4465                                               while (*p != &#39;\0&#39;)
4466                                                 p++;
4467                                             }
4468                                           else
4469                                             {
4470                                               char expbuf[6 + 1];
4471                                               const char *ep;
4472                                               sprintf (expbuf, decimal_format, exponent);
4473                                               for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4474                                                 p++;
4475                                             }
4476                                         }
4477 #   endif
</pre>
<hr />
<pre>
4495                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4496                                   {
4497                                     *p++ = decimal_point_char ();
4498                                     for (; precision &gt; 0; precision--)
4499                                       *p++ = &#39;0&#39;;
4500                                   }
4501                               }
4502                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
4503                               {
4504                                 *p++ = &#39;0&#39;;
4505                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4506                                   {
4507                                     *p++ = decimal_point_char ();
4508                                     for (; precision &gt; 0; precision--)
4509                                       *p++ = &#39;0&#39;;
4510                                   }
4511                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4512                                 *p++ = &#39;+&#39;;
4513                                 /* Produce the same number of exponent digits as
4514                                    the native printf implementation.  */
<span class="line-modified">4515 #   if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4516                                 *p++ = &#39;0&#39;;
4517 #   endif
4518                                 *p++ = &#39;0&#39;;
4519                                 *p++ = &#39;0&#39;;
4520                               }
4521                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
4522                               {
4523                                 *p++ = &#39;0&#39;;
4524                                 if (flags &amp; FLAG_ALT)
4525                                   {
4526                                     size_t ndigits =
4527                                       (precision &gt; 0 ? precision - 1 : 0);
4528                                     *p++ = decimal_point_char ();
4529                                     for (; ndigits &gt; 0; --ndigits)
4530                                       *p++ = &#39;0&#39;;
4531                                   }
4532                               }
4533                             else
4534                               abort ();
4535 #  endif
</pre>
<hr />
<pre>
4589                   {
4590                     size_t n = xsum (length, count);
4591 
4592                     ENSURE_ALLOCATION (n);
4593                   }
4594 
4595                 /* Append the result.  */
4596                 memcpy (result + length, tmp, count * sizeof (DCHAR_T));
4597                 if (tmp != tmpbuf)
4598                   free (tmp);
4599                 length += count;
4600               }
4601 #endif
4602             else
4603               {
4604                 arg_type type = a.arg[dp-&gt;arg_index].type;
4605                 int flags = dp-&gt;flags;
4606 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4607                 int has_width;
4608 #endif
<span class="line-modified">4609 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4610                 size_t width;
4611 #endif
<span class="line-modified">4612 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4613                 int has_precision;
4614                 size_t precision;
4615 #endif
4616 #if NEED_PRINTF_UNBOUNDED_PRECISION
4617                 int prec_ourselves;
4618 #else
4619 #               define prec_ourselves 0
4620 #endif
4621 #if NEED_PRINTF_FLAG_LEFTADJUST
4622 #               define pad_ourselves 1
4623 #elif !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4624                 int pad_ourselves;
4625 #else
4626 #               define pad_ourselves 0
4627 #endif
4628                 TCHAR_T *fbp;
4629                 unsigned int prefix_count;
4630                 int prefixes[2] IF_LINT (= { 0 });
4631                 int orig_errno;
4632 #if !USE_SNPRINTF
4633                 size_t tmp_length;
4634                 TCHAR_T tmpbuf[700];
4635                 TCHAR_T *tmp;
4636 #endif
4637 
4638 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4639                 has_width = 0;
4640 #endif
<span class="line-modified">4641 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4642                 width = 0;
4643                 if (dp-&gt;width_start != dp-&gt;width_end)
4644                   {
4645                     if (dp-&gt;width_arg_index != ARG_NONE)
4646                       {
4647                         int arg;
4648 
4649                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4650                           abort ();
4651                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
4652                         width = arg;
4653                         if (arg &lt; 0)
4654                           {
4655                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
4656                                 followed by a positive field width.&quot;  */
4657                             flags |= FLAG_LEFT;
4658                             width = -width;
4659                           }
4660                       }
4661                     else
4662                       {
4663                         const FCHAR_T *digitp = dp-&gt;width_start;
4664 
4665                         do
4666                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
4667                         while (digitp != dp-&gt;width_end);
4668                       }
4669 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4670                     has_width = 1;
4671 #endif
4672                   }
4673 #endif
4674 
<span class="line-modified">4675 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_UNBOUNDED_PRECISION</span>
4676                 has_precision = 0;
4677                 precision = 6;
4678                 if (dp-&gt;precision_start != dp-&gt;precision_end)
4679                   {
4680                     if (dp-&gt;precision_arg_index != ARG_NONE)
4681                       {
4682                         int arg;
4683 
4684                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4685                           abort ();
4686                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
4687                         /* &quot;A negative precision is taken as if the precision
4688                             were omitted.&quot;  */
4689                         if (arg &gt;= 0)
4690                           {
4691                             precision = arg;
4692                             has_precision = 1;
4693                           }
4694                       }
4695                     else
</pre>
<hr />
<pre>
4823                         if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
4824                           {
4825                             memcpy (fbp, dp-&gt;precision_start, n * sizeof (TCHAR_T));
4826                             fbp += n;
4827                           }
4828                         else
4829                           {
4830                             const FCHAR_T *mp = dp-&gt;precision_start;
4831                             do
4832                               *fbp++ = *mp++;
4833                             while (--n &gt; 0);
4834                           }
4835                       }
4836                   }
4837 
4838                 switch (type)
4839                   {
4840 #if HAVE_LONG_LONG
4841                   case TYPE_LONGLONGINT:
4842                   case TYPE_ULONGLONGINT:
<span class="line-modified">4843 # if (defined _WIN32 &amp;&amp; FALSE) &amp;&amp; ! defined __CYGWIN__</span>
4844                     *fbp++ = &#39;I&#39;;
4845                     *fbp++ = &#39;6&#39;;
4846                     *fbp++ = &#39;4&#39;;
4847                     break;
4848 # else
4849                     *fbp++ = &#39;l&#39;;

4850 # endif
4851 #endif
<span class="line-added">4852                     FALLTHROUGH;</span>
4853                   case TYPE_LONGINT:
4854                   case TYPE_ULONGINT:
4855 #if HAVE_WINT_T
4856                   case TYPE_WIDE_CHAR:
4857 #endif
4858 #if HAVE_WCHAR_T
4859                   case TYPE_WIDE_STRING:
4860 #endif
4861                     *fbp++ = &#39;l&#39;;
4862                     break;
4863                   case TYPE_LONGDOUBLE:
4864                     *fbp++ = &#39;L&#39;;
4865                     break;
4866                   default:
4867                     break;
4868                   }
4869 #if NEED_PRINTF_DIRECTIVE_F
4870                 if (dp-&gt;conversion == &#39;F&#39;)
4871                   *fbp = &#39;f&#39;;
4872                 else
4873 #endif
4874                   *fbp = dp-&gt;conversion;
4875 #if USE_SNPRINTF
<span class="line-modified">4876 # if ! (((__GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 3))        \</span>
<span class="line-added">4877          &amp;&amp; !defined __UCLIBC__)                                            \</span>
<span class="line-added">4878         || (defined __APPLE__ &amp;&amp; defined __MACH__)                          \</span>
<span class="line-added">4879         || defined __ANDROID__                                              \</span>
<span class="line-added">4880         || (defined _WIN32 &amp;&amp; ! defined __CYGWIN__))</span>
4881                 fbp[1] = &#39;%&#39;;
4882                 fbp[2] = &#39;n&#39;;
4883                 fbp[3] = &#39;\0&#39;;
4884 # else
4885                 /* On glibc2 systems from glibc &gt;= 2.3 - probably also older
4886                    ones - we know that snprintf&#39;s return value conforms to
4887                    ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and
4888                    gl_SNPRINTF_TRUNCATION_C99 pass.
4889                    Therefore we can avoid using %n in this situation.
4890                    On glibc2 systems from 2004-10-18 or newer, the use of %n
4891                    in format strings in writable memory may crash the program
4892                    (if compiled with _FORTIFY_SOURCE=2), so we should avoid it
4893                    in this situation.  */
<span class="line-added">4894                 /* On Mac OS X 10.3 or newer, we know that snprintf&#39;s return</span>
<span class="line-added">4895                    value conforms to ISO C 99: the tests gl_SNPRINTF_RETVAL_C99</span>
<span class="line-added">4896                    and gl_SNPRINTF_TRUNCATION_C99 pass.</span>
<span class="line-added">4897                    Therefore we can avoid using %n in this situation.</span>
<span class="line-added">4898                    On Mac OS X 10.13 or newer, the use of %n in format strings</span>
<span class="line-added">4899                    in writable memory by default crashes the program, so we</span>
<span class="line-added">4900                    should avoid it in this situation.  */</span>
<span class="line-added">4901                 /* On Android, we know that snprintf&#39;s return value conforms to</span>
<span class="line-added">4902                    ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and</span>
<span class="line-added">4903                    gl_SNPRINTF_TRUNCATION_C99 pass.</span>
<span class="line-added">4904                    Therefore we can avoid using %n in this situation.</span>
<span class="line-added">4905                    Starting on 2018-03-07, the use of %n in format strings</span>
<span class="line-added">4906                    produces a fatal error (see</span>
<span class="line-added">4907                    &lt;https://android.googlesource.com/platform/bionic/+/41398d03b7e8e0dfb951660ae713e682e9fc0336&gt;),</span>
<span class="line-added">4908                    so we should avoid it.  */</span>
4909                 /* On native Windows systems (such as mingw), we can avoid using
4910                    %n because:
4911                      - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,
4912                        snprintf does not write more than the specified number
4913                        of bytes. (snprintf (buf, 3, &quot;%d %d&quot;, 4567, 89) writes
4914                        &#39;4&#39;, &#39;5&#39;, &#39;6&#39; into buf, not &#39;4&#39;, &#39;5&#39;, &#39;\0&#39;.)
4915                      - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf
4916                        allows us to recognize the case of an insufficient
4917                        buffer size: it returns -1 in this case.
4918                    On native Windows systems (such as mingw) where the OS is
4919                    Windows Vista, the use of %n in format strings by default
4920                    crashes the program. See
<span class="line-modified">4921                      &lt;https://gcc.gnu.org/ml/gcc/2007-06/msg00122.html&gt; and</span>
<span class="line-modified">4922                      &lt;https://msdn.microsoft.com/en-us/library/ms175782.aspx&gt;</span>
4923                    So we should avoid %n in this situation.  */
4924                 fbp[1] = &#39;\0&#39;;
4925 # endif
4926 #else
4927                 fbp[1] = &#39;\0&#39;;
4928 #endif
4929 
4930                 /* Construct the arguments for calling snprintf or sprintf.  */
4931                 prefix_count = 0;
4932                 if (!pad_ourselves &amp;&amp; dp-&gt;width_arg_index != ARG_NONE)
4933                   {
4934                     if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4935                       abort ();
4936                     prefixes[prefix_count++] = a.arg[dp-&gt;width_arg_index].a.a_int;
4937                   }
4938                 if (!prec_ourselves &amp;&amp; dp-&gt;precision_arg_index != ARG_NONE)
4939                   {
4940                     if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4941                       abort ();
4942                     prefixes[prefix_count++] = a.arg[dp-&gt;precision_arg_index].a.a_int;
</pre>
<hr />
<pre>
5121 #endif
5122                       case TYPE_POINTER:
5123                         {
5124                           void *arg = a.arg[dp-&gt;arg_index].a.a_pointer;
5125                           SNPRINTF_BUF (arg);
5126                         }
5127                         break;
5128                       default:
5129                         abort ();
5130                       }
5131 
5132 #if USE_SNPRINTF
5133                     /* Portability: Not all implementations of snprintf()
5134                        are ISO C 99 compliant.  Determine the number of
5135                        bytes that snprintf() has produced or would have
5136                        produced.  */
5137                     if (count &gt;= 0)
5138                       {
5139                         /* Verify that snprintf() has NUL-terminated its
5140                            result.  */
<span class="line-modified">5141                         if ((unsigned int) count &lt; maxlen</span>
5142                             &amp;&amp; ((TCHAR_T *) (result + length)) [count] != &#39;\0&#39;)
5143                           abort ();
5144                         /* Portability hack.  */
5145                         if (retcount &gt; count)
5146                           count = retcount;
5147                       }
5148                     else
5149                       {
5150                         /* snprintf() doesn&#39;t understand the &#39;%n&#39;
5151                            directive.  */
5152                         if (fbp[1] != &#39;\0&#39;)
5153                           {
5154                             /* Don&#39;t use the &#39;%n&#39; directive; instead, look
5155                                at the snprintf() return value.  */
5156                             fbp[1] = &#39;\0&#39;;
5157                             continue;
5158                           }
5159                         else
5160                           {
5161                             /* Look at the snprintf() return value.  */
5162                             if (retcount &lt; 0)
5163                               {
<span class="line-modified">5164 # if !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF</span>
5165                                 /* HP-UX 10.20 snprintf() is doubly deficient:
5166                                    It doesn&#39;t understand the &#39;%n&#39; directive,
5167                                    *and* it returns -1 (rather than the length
5168                                    that would have been required) when the
5169                                    buffer is too small.
5170                                    But a failure at this point can also come
5171                                    from other reasons than a too small buffer,
5172                                    such as an invalid wide string argument to
5173                                    the %ls directive, or possibly an invalid
5174                                    floating-point argument.  */
5175                                 size_t tmp_length =
5176                                   MAX_ROOM_NEEDED (&amp;a, dp-&gt;arg_index,
5177                                                    dp-&gt;conversion, type, flags,
5178                                                    width,
5179                                                    has_precision,
5180                                                    precision, pad_ourselves);
5181 
5182                                 if (maxlen &lt; tmp_length)
5183                                   {
5184                                     /* Make more room.  But try to do through
</pre>
</td>
</tr>
</table>
<center><a href="printf.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="vasnprintf.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>