<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstrfuncs.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;stdio.h&gt;
  33 #include &lt;stdlib.h&gt;
  34 #include &lt;locale.h&gt;
  35 #include &lt;string.h&gt;
  36 #include &lt;locale.h&gt;
  37 #include &lt;errno.h&gt;
  38 #include &lt;ctype.h&gt;              /* For tolower() */
  39 
  40 #ifdef HAVE_XLOCALE_H
  41 /* Needed on BSD/OS X for e.g. strtod_l */
  42 #include &lt;xlocale.h&gt;
  43 #endif
  44 
  45 #ifdef G_OS_WIN32
  46 #include &lt;windows.h&gt;
  47 #endif
  48 
  49 /* do not include &lt;unistd.h&gt; here, it may interfere with g_strsignal() */
  50 
  51 #include &quot;gstrfuncs.h&quot;
  52 
  53 #include &quot;gprintf.h&quot;
  54 #include &quot;gprintfint.h&quot;
  55 #include &quot;glibintl.h&quot;
  56 
  57 
  58 /**
  59  * SECTION:string_utils
  60  * @title: String Utility Functions
  61  * @short_description: various string-related functions
  62  *
  63  * This section describes a number of utility functions for creating,
  64  * duplicating, and manipulating strings.
  65  *
  66  * Note that the functions g_printf(), g_fprintf(), g_sprintf(),
  67  * g_vprintf(), g_vfprintf(), g_vsprintf() and g_vasprintf()
  68  * are declared in the header `gprintf.h` which is not included in `glib.h`
  69  * (otherwise using `glib.h` would drag in `stdio.h`), so you&#39;ll have to
  70  * explicitly include `&lt;glib/gprintf.h&gt;` in order to use the GLib
  71  * printf() functions.
  72  *
  73  * ## String precision pitfalls # {#string-precision}
  74  *
  75  * While you may use the printf() functions to format UTF-8 strings,
  76  * notice that the precision of a \%Ns parameter is interpreted
  77  * as the number of bytes, not characters to print. On top of that,
  78  * the GNU libc implementation of the printf() functions has the
  79  * &quot;feature&quot; that it checks that the string given for the \%Ns
  80  * parameter consists of a whole number of characters in the current
  81  * encoding. So, unless you are sure you are always going to be in an
  82  * UTF-8 locale or your know your text is restricted to ASCII, avoid
  83  * using \%Ns. If your intention is to format strings for a
  84  * certain number of columns, then \%Ns is not a correct solution
  85  * anyway, since it fails to take wide characters (see g_unichar_iswide())
  86  * into account.
  87  *
  88  * Note also that there are various printf() parameters which are platform
  89  * dependent. GLib provides platform independent macros for these parameters
  90  * which should be used instead. A common example is %G_GUINT64_FORMAT, which
  91  * should be used instead of `%llu` or similar parameters for formatting
  92  * 64-bit integers. These macros are all named `G_*_FORMAT`; see
  93  * [Basic Types][glib-Basic-Types].
  94  */
  95 
  96 /**
  97  * g_ascii_isalnum:
  98  * @c: any character
  99  *
 100  * Determines whether a character is alphanumeric.
 101  *
 102  * Unlike the standard C library isalnum() function, this only
 103  * recognizes standard ASCII letters and ignores the locale,
 104  * returning %FALSE for all non-ASCII characters. Also, unlike
 105  * the standard library function, this takes a char, not an int,
 106  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 107  * passing a possibly non-ASCII character in.
 108  *
 109  * Returns: %TRUE if @c is an ASCII alphanumeric character
 110  */
 111 
 112 /**
 113  * g_ascii_isalpha:
 114  * @c: any character
 115  *
 116  * Determines whether a character is alphabetic (i.e. a letter).
 117  *
 118  * Unlike the standard C library isalpha() function, this only
 119  * recognizes standard ASCII letters and ignores the locale,
 120  * returning %FALSE for all non-ASCII characters. Also, unlike
 121  * the standard library function, this takes a char, not an int,
 122  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 123  * passing a possibly non-ASCII character in.
 124  *
 125  * Returns: %TRUE if @c is an ASCII alphabetic character
 126  */
 127 
 128 /**
 129  * g_ascii_iscntrl:
 130  * @c: any character
 131  *
 132  * Determines whether a character is a control character.
 133  *
 134  * Unlike the standard C library iscntrl() function, this only
 135  * recognizes standard ASCII control characters and ignores the
 136  * locale, returning %FALSE for all non-ASCII characters. Also,
 137  * unlike the standard library function, this takes a char, not
 138  * an int, so don&#39;t call it on %EOF, but no need to cast to #guchar
 139  * before passing a possibly non-ASCII character in.
 140  *
 141  * Returns: %TRUE if @c is an ASCII control character.
 142  */
 143 
 144 /**
 145  * g_ascii_isdigit:
 146  * @c: any character
 147  *
 148  * Determines whether a character is digit (0-9).
 149  *
 150  * Unlike the standard C library isdigit() function, this takes
 151  * a char, not an int, so don&#39;t call it  on %EOF, but no need to
 152  * cast to #guchar before passing a possibly non-ASCII character in.
 153  *
 154  * Returns: %TRUE if @c is an ASCII digit.
 155  */
 156 
 157 /**
 158  * g_ascii_isgraph:
 159  * @c: any character
 160  *
 161  * Determines whether a character is a printing character and not a space.
 162  *
 163  * Unlike the standard C library isgraph() function, this only
 164  * recognizes standard ASCII characters and ignores the locale,
 165  * returning %FALSE for all non-ASCII characters. Also, unlike
 166  * the standard library function, this takes a char, not an int,
 167  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 168  * passing a possibly non-ASCII character in.
 169  *
 170  * Returns: %TRUE if @c is an ASCII printing character other than space.
 171  */
 172 
 173 /**
 174  * g_ascii_islower:
 175  * @c: any character
 176  *
 177  * Determines whether a character is an ASCII lower case letter.
 178  *
 179  * Unlike the standard C library islower() function, this only
 180  * recognizes standard ASCII letters and ignores the locale,
 181  * returning %FALSE for all non-ASCII characters. Also, unlike
 182  * the standard library function, this takes a char, not an int,
 183  * so don&#39;t call it on %EOF, but no need to worry about casting
 184  * to #guchar before passing a possibly non-ASCII character in.
 185  *
 186  * Returns: %TRUE if @c is an ASCII lower case letter
 187  */
 188 
 189 /**
 190  * g_ascii_isprint:
 191  * @c: any character
 192  *
 193  * Determines whether a character is a printing character.
 194  *
 195  * Unlike the standard C library isprint() function, this only
 196  * recognizes standard ASCII characters and ignores the locale,
 197  * returning %FALSE for all non-ASCII characters. Also, unlike
 198  * the standard library function, this takes a char, not an int,
 199  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 200  * passing a possibly non-ASCII character in.
 201  *
 202  * Returns: %TRUE if @c is an ASCII printing character.
 203  */
 204 
 205 /**
 206  * g_ascii_ispunct:
 207  * @c: any character
 208  *
 209  * Determines whether a character is a punctuation character.
 210  *
 211  * Unlike the standard C library ispunct() function, this only
 212  * recognizes standard ASCII letters and ignores the locale,
 213  * returning %FALSE for all non-ASCII characters. Also, unlike
 214  * the standard library function, this takes a char, not an int,
 215  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 216  * passing a possibly non-ASCII character in.
 217  *
 218  * Returns: %TRUE if @c is an ASCII punctuation character.
 219  */
 220 
 221 /**
 222  * g_ascii_isspace:
 223  * @c: any character
 224  *
 225  * Determines whether a character is a white-space character.
 226  *
 227  * Unlike the standard C library isspace() function, this only
 228  * recognizes standard ASCII white-space and ignores the locale,
 229  * returning %FALSE for all non-ASCII characters. Also, unlike
 230  * the standard library function, this takes a char, not an int,
 231  * so don&#39;t call it on %EOF, but no need to cast to #guchar before
 232  * passing a possibly non-ASCII character in.
 233  *
 234  * Returns: %TRUE if @c is an ASCII white-space character
 235  */
 236 
 237 /**
 238  * g_ascii_isupper:
 239  * @c: any character
 240  *
 241  * Determines whether a character is an ASCII upper case letter.
 242  *
 243  * Unlike the standard C library isupper() function, this only
 244  * recognizes standard ASCII letters and ignores the locale,
 245  * returning %FALSE for all non-ASCII characters. Also, unlike
 246  * the standard library function, this takes a char, not an int,
 247  * so don&#39;t call it on %EOF, but no need to worry about casting
 248  * to #guchar before passing a possibly non-ASCII character in.
 249  *
 250  * Returns: %TRUE if @c is an ASCII upper case letter
 251  */
 252 
 253 /**
 254  * g_ascii_isxdigit:
 255  * @c: any character
 256  *
 257  * Determines whether a character is a hexadecimal-digit character.
 258  *
 259  * Unlike the standard C library isxdigit() function, this takes
 260  * a char, not an int, so don&#39;t call it on %EOF, but no need to
 261  * cast to #guchar before passing a possibly non-ASCII character in.
 262  *
 263  * Returns: %TRUE if @c is an ASCII hexadecimal-digit character.
 264  */
 265 
 266 /**
 267  * G_ASCII_DTOSTR_BUF_SIZE:
 268  *
 269  * A good size for a buffer to be passed into g_ascii_dtostr().
 270  * It is guaranteed to be enough for all output of that function
 271  * on systems with 64bit IEEE-compatible doubles.
 272  *
 273  * The typical usage would be something like:
 274  * |[&lt;!-- language=&quot;C&quot; --&gt;
 275  *   char buf[G_ASCII_DTOSTR_BUF_SIZE];
 276  *
 277  *   fprintf (out, &quot;value=%s\n&quot;, g_ascii_dtostr (buf, sizeof (buf), value));
 278  * ]|
 279  */
 280 
 281 /**
 282  * g_strstrip:
 283  * @string: a string to remove the leading and trailing whitespace from
 284  *
 285  * Removes leading and trailing whitespace from a string.
 286  * See g_strchomp() and g_strchug().
 287  *
 288  * Returns: @string
 289  */
 290 
 291 /**
 292  * G_STR_DELIMITERS:
 293  *
 294  * The standard delimiters, used in g_strdelimit().
 295  */
 296 
 297 static const guint16 ascii_table_data[256] = {
 298   0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004,
 299   0x004, 0x104, 0x104, 0x004, 0x104, 0x104, 0x004, 0x004,
 300   0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004,
 301   0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004, 0x004,
 302   0x140, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0,
 303   0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0,
 304   0x459, 0x459, 0x459, 0x459, 0x459, 0x459, 0x459, 0x459,
 305   0x459, 0x459, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0,
 306   0x0d0, 0x653, 0x653, 0x653, 0x653, 0x653, 0x653, 0x253,
 307   0x253, 0x253, 0x253, 0x253, 0x253, 0x253, 0x253, 0x253,
 308   0x253, 0x253, 0x253, 0x253, 0x253, 0x253, 0x253, 0x253,
 309   0x253, 0x253, 0x253, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x0d0,
 310   0x0d0, 0x473, 0x473, 0x473, 0x473, 0x473, 0x473, 0x073,
 311   0x073, 0x073, 0x073, 0x073, 0x073, 0x073, 0x073, 0x073,
 312   0x073, 0x073, 0x073, 0x073, 0x073, 0x073, 0x073, 0x073,
 313   0x073, 0x073, 0x073, 0x0d0, 0x0d0, 0x0d0, 0x0d0, 0x004
 314   /* the upper 128 are all zeroes */
 315 };
 316 
 317 const guint16 * const g_ascii_table = ascii_table_data;
 318 
 319 #if defined (HAVE_NEWLOCALE) &amp;&amp; \
 320     defined (HAVE_USELOCALE) &amp;&amp; \
 321     defined (HAVE_STRTOD_L) &amp;&amp; \
 322     defined (HAVE_STRTOULL_L) &amp;&amp; \
 323     defined (HAVE_STRTOLL_L)
 324 #define USE_XLOCALE 1
 325 #endif
 326 
 327 #ifdef USE_XLOCALE
 328 static locale_t
 329 get_C_locale (void)
 330 {
 331   static gsize initialized = FALSE;
 332   static locale_t C_locale = NULL;
 333 
 334   if (g_once_init_enter (&amp;initialized))
 335     {
 336       C_locale = newlocale (LC_ALL_MASK, &quot;C&quot;, NULL);
 337       g_once_init_leave (&amp;initialized, TRUE);
 338     }
 339 
 340   return C_locale;
 341 }
 342 #endif
 343 
 344 /**
 345  * g_strdup:
 346  * @str: (nullable): the string to duplicate
 347  *
 348  * Duplicates a string. If @str is %NULL it returns %NULL.
 349  * The returned string should be freed with g_free()
 350  * when no longer needed.
 351  *
 352  * Returns: a newly-allocated copy of @str
 353  */
 354 gchar*
 355 g_strdup (const gchar *str)
 356 {
 357   gchar *new_str;
 358   gsize length;
 359 
 360   if (str)
 361     {
 362       length = strlen (str) + 1;
 363       new_str = g_new (char, length);
 364       memcpy (new_str, str, length);
 365     }
 366   else
 367     new_str = NULL;
 368 
 369   return new_str;
 370 }
 371 
 372 /**
 373  * g_memdup:
 374  * @mem: the memory to copy.
 375  * @byte_size: the number of bytes to copy.
 376  *
 377  * Allocates @byte_size bytes of memory, and copies @byte_size bytes into it
 378  * from @mem. If @mem is %NULL it returns %NULL.
 379  *
 380  * Returns: a pointer to the newly-allocated copy of the memory, or %NULL if @mem
 381  *  is %NULL.
 382  */
 383 gpointer
 384 g_memdup (gconstpointer mem,
 385           guint         byte_size)
 386 {
 387   gpointer new_mem;
 388 
 389   if (mem &amp;&amp; byte_size != 0)
 390     {
 391       new_mem = g_malloc (byte_size);
 392       memcpy (new_mem, mem, byte_size);
 393     }
 394   else
 395     new_mem = NULL;
 396 
 397   return new_mem;
 398 }
 399 
 400 /**
 401  * g_strndup:
 402  * @str: the string to duplicate
 403  * @n: the maximum number of bytes to copy from @str
 404  *
 405  * Duplicates the first @n bytes of a string, returning a newly-allocated
 406  * buffer @n + 1 bytes long which will always be nul-terminated. If @str
 407  * is less than @n bytes long the buffer is padded with nuls. If @str is
 408  * %NULL it returns %NULL. The returned value should be freed when no longer
 409  * needed.
 410  *
 411  * To copy a number of characters from a UTF-8 encoded string,
 412  * use g_utf8_strncpy() instead.
 413  *
 414  * Returns: a newly-allocated buffer containing the first @n bytes
 415  *     of @str, nul-terminated
 416  */
 417 gchar*
 418 g_strndup (const gchar *str,
 419            gsize        n)
 420 {
 421   gchar *new_str;
 422 
 423   if (str)
 424     {
 425       new_str = g_new (gchar, n + 1);
 426       strncpy (new_str, str, n);
 427       new_str[n] = &#39;\0&#39;;
 428     }
 429   else
 430     new_str = NULL;
 431 
 432   return new_str;
 433 }
 434 
 435 /**
 436  * g_strnfill:
 437  * @length: the length of the new string
 438  * @fill_char: the byte to fill the string with
 439  *
 440  * Creates a new string @length bytes long filled with @fill_char.
 441  * The returned string should be freed when no longer needed.
 442  *
 443  * Returns: a newly-allocated string filled the @fill_char
 444  */
 445 gchar*
 446 g_strnfill (gsize length,
 447             gchar fill_char)
 448 {
 449   gchar *str;
 450 
 451   str = g_new (gchar, length + 1);
 452   memset (str, (guchar)fill_char, length);
 453   str[length] = &#39;\0&#39;;
 454 
 455   return str;
 456 }
 457 
 458 /**
 459  * g_stpcpy:
 460  * @dest: destination buffer.
 461  * @src: source string.
 462  *
 463  * Copies a nul-terminated string into the dest buffer, include the
 464  * trailing nul, and return a pointer to the trailing nul byte.
 465  * This is useful for concatenating multiple strings together
 466  * without having to repeatedly scan for the end.
 467  *
 468  * Returns: a pointer to trailing nul byte.
 469  **/
 470 gchar *
 471 g_stpcpy (gchar       *dest,
 472           const gchar *src)
 473 {
 474 #ifdef HAVE_STPCPY
 475   g_return_val_if_fail (dest != NULL, NULL);
 476   g_return_val_if_fail (src != NULL, NULL);
 477   return stpcpy (dest, src);
 478 #else
 479   gchar *d = dest;
 480   const gchar *s = src;
 481 
 482   g_return_val_if_fail (dest != NULL, NULL);
 483   g_return_val_if_fail (src != NULL, NULL);
 484   do
 485     *d++ = *s;
 486   while (*s++ != &#39;\0&#39;);
 487 
 488   return d - 1;
 489 #endif
 490 }
 491 
 492 /**
 493  * g_strdup_vprintf:
 494  * @format: a standard printf() format string, but notice
 495  *     [string precision pitfalls][string-precision]
 496  * @args: the list of parameters to insert into the format string
 497  *
 498  * Similar to the standard C vsprintf() function but safer, since it
 499  * calculates the maximum space required and allocates memory to hold
 500  * the result. The returned string should be freed with g_free() when
 501  * no longer needed.
 502  *
 503  * See also g_vasprintf(), which offers the same functionality, but
 504  * additionally returns the length of the allocated string.
 505  *
 506  * Returns: a newly-allocated string holding the result
 507  */
 508 gchar*
 509 g_strdup_vprintf (const gchar *format,
 510                   va_list      args)
 511 {
 512   gchar *string = NULL;
 513 
 514   g_vasprintf (&amp;string, format, args);
 515 
 516   return string;
 517 }
 518 
 519 /**
 520  * g_strdup_printf:
 521  * @format: a standard printf() format string, but notice
 522  *     [string precision pitfalls][string-precision]
 523  * @...: the parameters to insert into the format string
 524  *
 525  * Similar to the standard C sprintf() function but safer, since it
 526  * calculates the maximum space required and allocates memory to hold
 527  * the result. The returned string should be freed with g_free() when no
 528  * longer needed.
 529  *
 530  * Returns: a newly-allocated string holding the result
 531  */
 532 gchar*
 533 g_strdup_printf (const gchar *format,
 534                  ...)
 535 {
 536   gchar *buffer;
 537   va_list args;
 538 
 539   va_start (args, format);
 540   buffer = g_strdup_vprintf (format, args);
 541   va_end (args);
 542 
 543   return buffer;
 544 }
 545 
 546 /**
 547  * g_strconcat:
 548  * @string1: the first string to add, which must not be %NULL
 549  * @...: a %NULL-terminated list of strings to append to the string
 550  *
 551  * Concatenates all of the given strings into one long string. The
 552  * returned string should be freed with g_free() when no longer needed.
 553  *
 554  * The variable argument list must end with %NULL. If you forget the %NULL,
 555  * g_strconcat() will start appending random memory junk to your string.
 556  *
 557  * Note that this function is usually not the right function to use to
 558  * assemble a translated message from pieces, since proper translation
 559  * often requires the pieces to be reordered.
 560  *
 561  * Returns: a newly-allocated string containing all the string arguments
 562  */
 563 gchar*
 564 g_strconcat (const gchar *string1, ...)
 565 {
 566   gsize   l;
 567   va_list args;
 568   gchar   *s;
 569   gchar   *concat;
 570   gchar   *ptr;
 571 
 572   if (!string1)
 573     return NULL;
 574 
 575   l = 1 + strlen (string1);
 576   va_start (args, string1);
 577   s = va_arg (args, gchar*);
 578   while (s)
 579     {
 580       l += strlen (s);
 581       s = va_arg (args, gchar*);
 582     }
 583   va_end (args);
 584 
 585   concat = g_new (gchar, l);
 586   ptr = concat;
 587 
 588   ptr = g_stpcpy (ptr, string1);
 589   va_start (args, string1);
 590   s = va_arg (args, gchar*);
 591   while (s)
 592     {
 593       ptr = g_stpcpy (ptr, s);
 594       s = va_arg (args, gchar*);
 595     }
 596   va_end (args);
 597 
 598   return concat;
 599 }
 600 
 601 /**
 602  * g_strtod:
 603  * @nptr:    the string to convert to a numeric value.
 604  * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the
 605  *           character after the last character used in the conversion.
 606  *
 607  * Converts a string to a #gdouble value.
 608  * It calls the standard strtod() function to handle the conversion, but
 609  * if the string is not completely converted it attempts the conversion
 610  * again with g_ascii_strtod(), and returns the best match.
 611  *
 612  * This function should seldom be used. The normal situation when reading
 613  * numbers not for human consumption is to use g_ascii_strtod(). Only when
 614  * you know that you must expect both locale formatted and C formatted numbers
 615  * should you use this. Make sure that you don&#39;t pass strings such as comma
 616  * separated lists of values, since the commas may be interpreted as a decimal
 617  * point in some locales, causing unexpected results.
 618  *
 619  * Returns: the #gdouble value.
 620  **/
 621 gdouble
 622 g_strtod (const gchar *nptr,
 623           gchar      **endptr)
 624 {
 625   gchar *fail_pos_1;
 626   gchar *fail_pos_2;
 627   gdouble val_1;
 628   gdouble val_2 = 0;
 629 
 630   g_return_val_if_fail (nptr != NULL, 0);
 631 
 632   fail_pos_1 = NULL;
 633   fail_pos_2 = NULL;
 634 
 635   val_1 = strtod (nptr, &amp;fail_pos_1);
 636 
 637   if (fail_pos_1 &amp;&amp; fail_pos_1[0] != 0)
 638     val_2 = g_ascii_strtod (nptr, &amp;fail_pos_2);
 639 
 640   if (!fail_pos_1 || fail_pos_1[0] == 0 || fail_pos_1 &gt;= fail_pos_2)
 641     {
 642       if (endptr)
 643         *endptr = fail_pos_1;
 644       return val_1;
 645     }
 646   else
 647     {
 648       if (endptr)
 649         *endptr = fail_pos_2;
 650       return val_2;
 651     }
 652 }
 653 
 654 /**
 655  * g_ascii_strtod:
 656  * @nptr:    the string to convert to a numeric value.
 657  * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the
 658  *           character after the last character used in the conversion.
 659  *
 660  * Converts a string to a #gdouble value.
 661  *
 662  * This function behaves like the standard strtod() function
 663  * does in the C locale. It does this without actually changing
 664  * the current locale, since that would not be thread-safe.
 665  * A limitation of the implementation is that this function
 666  * will still accept localized versions of infinities and NANs.
 667  *
 668  * This function is typically used when reading configuration
 669  * files or other non-user input that should be locale independent.
 670  * To handle input from the user you should normally use the
 671  * locale-sensitive system strtod() function.
 672  *
 673  * To convert from a #gdouble to a string in a locale-insensitive
 674  * way, use g_ascii_dtostr().
 675  *
 676  * If the correct value would cause overflow, plus or minus %HUGE_VAL
 677  * is returned (according to the sign of the value), and %ERANGE is
 678  * stored in %errno. If the correct value would cause underflow,
 679  * zero is returned and %ERANGE is stored in %errno.
 680  *
 681  * This function resets %errno before calling strtod() so that
 682  * you can reliably detect overflow and underflow.
 683  *
 684  * Returns: the #gdouble value.
 685  */
 686 gdouble
 687 g_ascii_strtod (const gchar *nptr,
 688                 gchar      **endptr)
 689 {
 690 #ifdef USE_XLOCALE
 691 
 692   g_return_val_if_fail (nptr != NULL, 0);
 693 
 694   errno = 0;
 695 
 696   return strtod_l (nptr, endptr, get_C_locale ());
 697 
 698 #else
 699 
 700   gchar *fail_pos;
 701   gdouble val;
 702 #ifndef __BIONIC__
 703   struct lconv *locale_data;
 704 #endif
 705   const char *decimal_point;
 706   gsize decimal_point_len;
 707   const char *p, *decimal_point_pos;
 708   const char *end = NULL; /* Silence gcc */
 709   int strtod_errno;
 710 
 711   g_return_val_if_fail (nptr != NULL, 0);
 712 
 713   fail_pos = NULL;
 714 
 715 #ifndef __BIONIC__
 716   locale_data = localeconv ();
 717   decimal_point = locale_data-&gt;decimal_point;
 718   decimal_point_len = strlen (decimal_point);
 719 #else
 720   decimal_point = &quot;.&quot;;
 721   decimal_point_len = 1;
 722 #endif
 723 
 724   g_assert (decimal_point_len != 0);
 725 
 726   decimal_point_pos = NULL;
 727   end = NULL;
 728 
 729   if (decimal_point[0] != &#39;.&#39; ||
 730       decimal_point[1] != 0)
 731     {
 732       p = nptr;
 733       /* Skip leading space */
 734       while (g_ascii_isspace (*p))
 735         p++;
 736 
 737       /* Skip leading optional sign */
 738       if (*p == &#39;+&#39; || *p == &#39;-&#39;)
 739         p++;
 740 
 741       if (p[0] == &#39;0&#39; &amp;&amp;
 742           (p[1] == &#39;x&#39; || p[1] == &#39;X&#39;))
 743         {
 744           p += 2;
 745           /* HEX - find the (optional) decimal point */
 746 
 747           while (g_ascii_isxdigit (*p))
 748             p++;
 749 
 750           if (*p == &#39;.&#39;)
 751             decimal_point_pos = p++;
 752 
 753           while (g_ascii_isxdigit (*p))
 754             p++;
 755 
 756           if (*p == &#39;p&#39; || *p == &#39;P&#39;)
 757             p++;
 758           if (*p == &#39;+&#39; || *p == &#39;-&#39;)
 759             p++;
 760           while (g_ascii_isdigit (*p))
 761             p++;
 762 
 763           end = p;
 764         }
 765       else if (g_ascii_isdigit (*p) || *p == &#39;.&#39;)
 766         {
 767           while (g_ascii_isdigit (*p))
 768             p++;
 769 
 770           if (*p == &#39;.&#39;)
 771             decimal_point_pos = p++;
 772 
 773           while (g_ascii_isdigit (*p))
 774             p++;
 775 
 776           if (*p == &#39;e&#39; || *p == &#39;E&#39;)
 777             p++;
 778           if (*p == &#39;+&#39; || *p == &#39;-&#39;)
 779             p++;
 780           while (g_ascii_isdigit (*p))
 781             p++;
 782 
 783           end = p;
 784         }
 785       /* For the other cases, we need not convert the decimal point */
 786     }
 787 
 788   if (decimal_point_pos)
 789     {
 790       char *copy, *c;
 791 
 792       /* We need to convert the &#39;.&#39; to the locale specific decimal point */
 793       copy = g_malloc (end - nptr + 1 + decimal_point_len);
 794 #ifdef GSTREAMER_LITE
 795       if (copy == NULL)
 796           return 0;
 797 #endif // GSTREAMER_LITE
 798 
 799       c = copy;
 800       memcpy (c, nptr, decimal_point_pos - nptr);
 801       c += decimal_point_pos - nptr;
 802       memcpy (c, decimal_point, decimal_point_len);
 803       c += decimal_point_len;
 804       memcpy (c, decimal_point_pos + 1, end - (decimal_point_pos + 1));
 805       c += end - (decimal_point_pos + 1);
 806       *c = 0;
 807 
 808       errno = 0;
 809       val = strtod (copy, &amp;fail_pos);
 810       strtod_errno = errno;
 811 
 812       if (fail_pos)
 813         {
 814           if (fail_pos - copy &gt; decimal_point_pos - nptr)
 815             fail_pos = (char *)nptr + (fail_pos - copy) - (decimal_point_len - 1);
 816           else
 817             fail_pos = (char *)nptr + (fail_pos - copy);
 818         }
 819 
 820       g_free (copy);
 821 
 822     }
 823   else if (end)
 824     {
 825       char *copy;
 826 
 827       copy = g_malloc (end - (char *)nptr + 1);
 828 #ifdef GSTREAMER_LITE
 829       if (copy == NULL)
 830         return 0;
 831 #endif
 832       memcpy (copy, nptr, end - nptr);
 833       *(copy + (end - (char *)nptr)) = 0;
 834 
 835       errno = 0;
 836       val = strtod (copy, &amp;fail_pos);
 837       strtod_errno = errno;
 838 
 839       if (fail_pos)
 840         {
 841           fail_pos = (char *)nptr + (fail_pos - copy);
 842         }
 843 
 844       g_free (copy);
 845     }
 846   else
 847     {
 848       errno = 0;
 849       val = strtod (nptr, &amp;fail_pos);
 850       strtod_errno = errno;
 851     }
 852 
 853   if (endptr)
 854     *endptr = fail_pos;
 855 
 856   errno = strtod_errno;
 857 
 858   return val;
 859 #endif
 860 }
 861 
 862 
 863 /**
 864  * g_ascii_dtostr:
 865  * @buffer: A buffer to place the resulting string in
 866  * @buf_len: The length of the buffer.
 867  * @d: The #gdouble to convert
 868  *
 869  * Converts a #gdouble to a string, using the &#39;.&#39; as
 870  * decimal point.
 871  *
 872  * This function generates enough precision that converting
 873  * the string back using g_ascii_strtod() gives the same machine-number
 874  * (on machines with IEEE compatible 64bit doubles). It is
 875  * guaranteed that the size of the resulting string will never
 876  * be larger than @G_ASCII_DTOSTR_BUF_SIZE bytes, including the terminating
 877  * nul character, which is always added.
 878  *
 879  * Returns: The pointer to the buffer with the converted string.
 880  **/
 881 gchar *
 882 g_ascii_dtostr (gchar       *buffer,
 883                 gint         buf_len,
 884                 gdouble      d)
 885 {
 886   return g_ascii_formatd (buffer, buf_len, &quot;%.17g&quot;, d);
 887 }
 888 
 889 #ifdef GSTREAMER_LITE
 890 #ifndef G_OS_WIN32
 891 #pragma GCC diagnostic push
 892 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 893 #endif // G_OS_WIN32
 894 #else // GSTREAMER_LITE
 895 #pragma GCC diagnostic push
 896 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 897 #endif // GSTREAMER_LITE
 898 
 899 /**
 900  * g_ascii_formatd:
 901  * @buffer: A buffer to place the resulting string in
 902  * @buf_len: The length of the buffer.
 903  * @format: The printf()-style format to use for the
 904  *          code to use for converting.
 905  * @d: The #gdouble to convert
 906  *
 907  * Converts a #gdouble to a string, using the &#39;.&#39; as
 908  * decimal point. To format the number you pass in
 909  * a printf()-style format string. Allowed conversion
 910  * specifiers are &#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;F&#39;, &#39;g&#39; and &#39;G&#39;.
 911  *
 912  * The returned buffer is guaranteed to be nul-terminated.
 913  *
 914  * If you just want to want to serialize the value into a
 915  * string, use g_ascii_dtostr().
 916  *
 917  * Returns: The pointer to the buffer with the converted string.
 918  */
 919 gchar *
 920 g_ascii_formatd (gchar       *buffer,
 921                  gint         buf_len,
 922                  const gchar *format,
 923                  gdouble      d)
 924 {
 925 #ifdef USE_XLOCALE
 926   locale_t old_locale;
 927 
 928   old_locale = uselocale (get_C_locale ());
 929    _g_snprintf (buffer, buf_len, format, d);
 930   uselocale (old_locale);
 931 
 932   return buffer;
 933 #else
 934 #ifndef __BIONIC__
 935   struct lconv *locale_data;
 936 #endif
 937   const char *decimal_point;
 938   gsize decimal_point_len;
 939   gchar *p;
 940   int rest_len;
 941   gchar format_char;
 942 
 943   g_return_val_if_fail (buffer != NULL, NULL);
 944   g_return_val_if_fail (format[0] == &#39;%&#39;, NULL);
 945   g_return_val_if_fail (strpbrk (format + 1, &quot;&#39;l%&quot;) == NULL, NULL);
 946 
 947   format_char = format[strlen (format) - 1];
 948 
 949   g_return_val_if_fail (format_char == &#39;e&#39; || format_char == &#39;E&#39; ||
 950                         format_char == &#39;f&#39; || format_char == &#39;F&#39; ||
 951                         format_char == &#39;g&#39; || format_char == &#39;G&#39;,
 952                         NULL);
 953 
 954   if (format[0] != &#39;%&#39;)
 955     return NULL;
 956 
 957   if (strpbrk (format + 1, &quot;&#39;l%&quot;))
 958     return NULL;
 959 
 960   if (!(format_char == &#39;e&#39; || format_char == &#39;E&#39; ||
 961         format_char == &#39;f&#39; || format_char == &#39;F&#39; ||
 962         format_char == &#39;g&#39; || format_char == &#39;G&#39;))
 963     return NULL;
 964 
 965   _g_snprintf (buffer, buf_len, format, d);
 966 
 967 #ifndef __BIONIC__
 968   locale_data = localeconv ();
 969   decimal_point = locale_data-&gt;decimal_point;
 970   decimal_point_len = strlen (decimal_point);
 971 #else
 972   decimal_point = &quot;.&quot;;
 973   decimal_point_len = 1;
 974 #endif
 975 
 976   g_assert (decimal_point_len != 0);
 977 
 978   if (decimal_point[0] != &#39;.&#39; ||
 979       decimal_point[1] != 0)
 980     {
 981       p = buffer;
 982 
 983       while (g_ascii_isspace (*p))
 984         p++;
 985 
 986       if (*p == &#39;+&#39; || *p == &#39;-&#39;)
 987         p++;
 988 
 989       while (isdigit ((guchar)*p))
 990         p++;
 991 
 992       if (strncmp (p, decimal_point, decimal_point_len) == 0)
 993         {
 994           *p = &#39;.&#39;;
 995           p++;
 996           if (decimal_point_len &gt; 1)
 997             {
 998               rest_len = strlen (p + (decimal_point_len - 1));
 999               memmove (p, p + (decimal_point_len - 1), rest_len);
1000               p[rest_len] = 0;
1001             }
1002         }
1003     }
1004 
1005   return buffer;
1006 #endif
1007 }
1008 
1009 #ifdef GSTREAMER_LITE
1010 #ifndef G_OS_WIN32
1011 #pragma GCC diagnostic pop
1012 #endif // G_OS_WIN32
1013 #else // GSTREAMER_LITE
1014 #pragma GCC diagnostic pop
1015 #endif // GSTREAMER_LITE
1016 
1017 #define ISSPACE(c)              ((c) == &#39; &#39; || (c) == &#39;\f&#39; || (c) == &#39;\n&#39; || \
1018                                  (c) == &#39;\r&#39; || (c) == &#39;\t&#39; || (c) == &#39;\v&#39;)
1019 #define ISUPPER(c)              ((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;)
1020 #define ISLOWER(c)              ((c) &gt;= &#39;a&#39; &amp;&amp; (c) &lt;= &#39;z&#39;)
1021 #define ISALPHA(c)              (ISUPPER (c) || ISLOWER (c))
1022 #define TOUPPER(c)              (ISLOWER (c) ? (c) - &#39;a&#39; + &#39;A&#39; : (c))
1023 #define TOLOWER(c)              (ISUPPER (c) ? (c) - &#39;A&#39; + &#39;a&#39; : (c))
1024 
1025 #ifndef USE_XLOCALE
1026 
1027 static guint64
1028 g_parse_long_long (const gchar  *nptr,
1029                    const gchar **endptr,
1030                    guint         base,
1031                    gboolean     *negative)
1032 {
1033   /* this code is based on on the strtol(3) code from GNU libc released under
1034    * the GNU Lesser General Public License.
1035    *
1036    * Copyright (C) 1991,92,94,95,96,97,98,99,2000,01,02
1037    *        Free Software Foundation, Inc.
1038    */
1039   gboolean overflow;
1040   guint64 cutoff;
1041   guint64 cutlim;
1042   guint64 ui64;
1043   const gchar *s, *save;
1044   guchar c;
1045 
1046   g_return_val_if_fail (nptr != NULL, 0);
1047 
1048   *negative = FALSE;
1049   if (base == 1 || base &gt; 36)
1050     {
1051       errno = EINVAL;
1052       if (endptr)
1053         *endptr = nptr;
1054       return 0;
1055     }
1056 
1057   save = s = nptr;
1058 
1059   /* Skip white space.  */
1060   while (ISSPACE (*s))
1061     ++s;
1062 
1063   if (G_UNLIKELY (!*s))
1064     goto noconv;
1065 
1066   /* Check for a sign.  */
1067   if (*s == &#39;-&#39;)
1068     {
1069       *negative = TRUE;
1070       ++s;
1071     }
1072   else if (*s == &#39;+&#39;)
1073     ++s;
1074 
1075   /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
1076   if (*s == &#39;0&#39;)
1077     {
1078       if ((base == 0 || base == 16) &amp;&amp; TOUPPER (s[1]) == &#39;X&#39;)
1079         {
1080           s += 2;
1081           base = 16;
1082         }
1083       else if (base == 0)
1084         base = 8;
1085     }
1086   else if (base == 0)
1087     base = 10;
1088 
1089   /* Save the pointer so we can check later if anything happened.  */
1090   save = s;
1091   cutoff = G_MAXUINT64 / base;
1092   cutlim = G_MAXUINT64 % base;
1093 
1094   overflow = FALSE;
1095   ui64 = 0;
1096   c = *s;
1097   for (; c; c = *++s)
1098     {
1099       if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
1100         c -= &#39;0&#39;;
1101       else if (ISALPHA (c))
1102         c = TOUPPER (c) - &#39;A&#39; + 10;
1103       else
1104         break;
1105       if (c &gt;= base)
1106         break;
1107       /* Check for overflow.  */
1108       if (ui64 &gt; cutoff || (ui64 == cutoff &amp;&amp; c &gt; cutlim))
1109         overflow = TRUE;
1110       else
1111         {
1112           ui64 *= base;
1113           ui64 += c;
1114         }
1115     }
1116 
1117   /* Check if anything actually happened.  */
1118   if (s == save)
1119     goto noconv;
1120 
1121   /* Store in ENDPTR the address of one character
1122      past the last character we converted.  */
1123   if (endptr)
1124     *endptr = s;
1125 
1126   if (G_UNLIKELY (overflow))
1127     {
1128       errno = ERANGE;
1129       return G_MAXUINT64;
1130     }
1131 
1132   return ui64;
1133 
1134  noconv:
1135   /* We must handle a special case here: the base is 0 or 16 and the
1136      first two characters are &#39;0&#39; and &#39;x&#39;, but the rest are no
1137      hexadecimal digits.  This is no error case.  We return 0 and
1138      ENDPTR points to the `x`.  */
1139   if (endptr)
1140     {
1141       if (save - nptr &gt;= 2 &amp;&amp; TOUPPER (save[-1]) == &#39;X&#39;
1142           &amp;&amp; save[-2] == &#39;0&#39;)
1143         *endptr = &amp;save[-1];
1144       else
1145         /*  There was no number to convert.  */
1146         *endptr = nptr;
1147     }
1148   return 0;
1149 }
1150 #endif /* !USE_XLOCALE */
1151 
1152 /**
1153  * g_ascii_strtoull:
1154  * @nptr:    the string to convert to a numeric value.
1155  * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the
1156  *           character after the last character used in the conversion.
1157  * @base:    to be used for the conversion, 2..36 or 0
1158  *
1159  * Converts a string to a #guint64 value.
1160  * This function behaves like the standard strtoull() function
1161  * does in the C locale. It does this without actually
1162  * changing the current locale, since that would not be
1163  * thread-safe.
1164  *
<a name="1" id="anc1"></a><span class="line-added">1165  * Note that input with a leading minus sign (`-`) is accepted, and will return</span>
<span class="line-added">1166  * the negation of the parsed number, unless that would overflow a #guint64.</span>
<span class="line-added">1167  * Critically, this means you cannot assume that a short fixed length input will</span>
<span class="line-added">1168  * never result in a low return value, as the input could have a leading `-`.</span>
<span class="line-added">1169  *</span>
1170  * This function is typically used when reading configuration
1171  * files or other non-user input that should be locale independent.
1172  * To handle input from the user you should normally use the
1173  * locale-sensitive system strtoull() function.
1174  *
1175  * If the correct value would cause overflow, %G_MAXUINT64
1176  * is returned, and `ERANGE` is stored in `errno`.
1177  * If the base is outside the valid range, zero is returned, and
1178  * `EINVAL` is stored in `errno`.
1179  * If the string conversion fails, zero is returned, and @endptr returns
1180  * @nptr (if @endptr is non-%NULL).
1181  *
1182  * Returns: the #guint64 value or zero on error.
1183  *
1184  * Since: 2.2
1185  */
1186 guint64
1187 g_ascii_strtoull (const gchar *nptr,
1188                   gchar      **endptr,
1189                   guint        base)
1190 {
1191 #ifdef USE_XLOCALE
1192   return strtoull_l (nptr, endptr, base, get_C_locale ());
1193 #else
1194   gboolean negative;
1195   guint64 result;
1196 
1197   result = g_parse_long_long (nptr, (const gchar **) endptr, base, &amp;negative);
1198 
1199   /* Return the result of the appropriate sign.  */
1200   return negative ? -result : result;
1201 #endif
1202 }
1203 
1204 /**
1205  * g_ascii_strtoll:
1206  * @nptr:    the string to convert to a numeric value.
1207  * @endptr:  (out) (transfer none) (optional): if non-%NULL, it returns the
1208  *           character after the last character used in the conversion.
1209  * @base:    to be used for the conversion, 2..36 or 0
1210  *
1211  * Converts a string to a #gint64 value.
1212  * This function behaves like the standard strtoll() function
1213  * does in the C locale. It does this without actually
1214  * changing the current locale, since that would not be
1215  * thread-safe.
1216  *
1217  * This function is typically used when reading configuration
1218  * files or other non-user input that should be locale independent.
1219  * To handle input from the user you should normally use the
1220  * locale-sensitive system strtoll() function.
1221  *
1222  * If the correct value would cause overflow, %G_MAXINT64 or %G_MININT64
1223  * is returned, and `ERANGE` is stored in `errno`.
1224  * If the base is outside the valid range, zero is returned, and
1225  * `EINVAL` is stored in `errno`. If the
1226  * string conversion fails, zero is returned, and @endptr returns @nptr
1227  * (if @endptr is non-%NULL).
1228  *
1229  * Returns: the #gint64 value or zero on error.
1230  *
1231  * Since: 2.12
1232  */
1233 gint64
1234 g_ascii_strtoll (const gchar *nptr,
1235                  gchar      **endptr,
1236                  guint        base)
1237 {
1238 #ifdef USE_XLOCALE
1239   return strtoll_l (nptr, endptr, base, get_C_locale ());
1240 #else
1241   gboolean negative;
1242   guint64 result;
1243 
1244   result = g_parse_long_long (nptr, (const gchar **) endptr, base, &amp;negative);
1245 
1246   if (negative &amp;&amp; result &gt; (guint64) G_MININT64)
1247     {
1248       errno = ERANGE;
1249       return G_MININT64;
1250     }
1251   else if (!negative &amp;&amp; result &gt; (guint64) G_MAXINT64)
1252     {
1253       errno = ERANGE;
1254       return G_MAXINT64;
1255     }
1256   else if (negative)
1257     return - (gint64) result;
1258   else
1259     return (gint64) result;
1260 #endif
1261 }
1262 
1263 /**
1264  * g_strerror:
1265  * @errnum: the system error number. See the standard C %errno
1266  *     documentation
1267  *
1268  * Returns a string corresponding to the given error code, e.g. &quot;no
1269  * such process&quot;. Unlike strerror(), this always returns a string in
1270  * UTF-8 encoding, and the pointer is guaranteed to remain valid for
1271  * the lifetime of the process.
1272  *
1273  * Note that the string may be translated according to the current locale.
1274  *
1275  * The value of %errno will not be changed by this function. However, it may
1276  * be changed by intermediate function calls, so you should save its value
1277  * as soon as the call returns:
1278  * |[
1279  *   int saved_errno;
1280  *
1281  *   ret = read (blah);
1282  *   saved_errno = errno;
1283  *
1284  *   g_strerror (saved_errno);
1285  * ]|
1286  *
1287  * Returns: a UTF-8 string describing the error code. If the error code
1288  *     is unknown, it returns a string like &quot;unknown error (&lt;code&gt;)&quot;.
1289  */
1290 const gchar *
1291 g_strerror (gint errnum)
1292 {
1293   static GHashTable *errors;
1294   G_LOCK_DEFINE_STATIC (errors);
1295   const gchar *msg;
1296   gint saved_errno = errno;
1297 
1298   G_LOCK (errors);
1299   if (errors)
1300     msg = g_hash_table_lookup (errors, GINT_TO_POINTER (errnum));
1301   else
1302     {
1303       errors = g_hash_table_new (NULL, NULL);
1304       msg = NULL;
1305     }
1306 
1307   if (!msg)
1308     {
1309       gchar buf[1024];
1310       GError *error = NULL;
1311 
1312 #if defined(G_OS_WIN32)
1313       strerror_s (buf, sizeof (buf), errnum);
1314       msg = buf;
1315 #elif defined(HAVE_STRERROR_R)
1316       /* Match the condition in strerror_r(3) for glibc */
1317 #  if defined(STRERROR_R_CHAR_P)
1318       msg = strerror_r (errnum, buf, sizeof (buf));
1319 #  else
1320       (void) strerror_r (errnum, buf, sizeof (buf));
1321       msg = buf;
1322 #  endif /* HAVE_STRERROR_R */
1323 #else
1324       g_strlcpy (buf, strerror (errnum), sizeof (buf));
1325       msg = buf;
1326 #endif
<a name="2" id="anc2"></a><span class="line-modified">1327       if (!g_get_console_charset (NULL))</span>
1328         {
1329           msg = g_locale_to_utf8 (msg, -1, NULL, NULL, &amp;error);
1330           if (error)
1331             g_print (&quot;%s\n&quot;, error-&gt;message);
1332         }
1333       else if (msg == (const gchar *)buf)
1334         msg = g_strdup (buf);
1335 
1336       g_hash_table_insert (errors, GINT_TO_POINTER (errnum), (char *) msg);
1337     }
1338   G_UNLOCK (errors);
1339 
1340   errno = saved_errno;
1341   return msg;
1342 }
1343 
1344 /**
1345  * g_strsignal:
1346  * @signum: the signal number. See the `signal` documentation
1347  *
1348  * Returns a string describing the given signal, e.g. &quot;Segmentation fault&quot;.
1349  * You should use this function in preference to strsignal(), because it
1350  * returns a string in UTF-8 encoding, and since not all platforms support
1351  * the strsignal() function.
1352  *
1353  * Returns: a UTF-8 string describing the signal. If the signal is unknown,
1354  *     it returns &quot;unknown signal (&lt;signum&gt;)&quot;.
1355  */
1356 const gchar *
1357 g_strsignal (gint signum)
1358 {
1359   gchar *msg;
1360   gchar *tofree;
1361   const gchar *ret;
1362 
1363   msg = tofree = NULL;
1364 
1365 #ifdef HAVE_STRSIGNAL
1366   msg = strsignal (signum);
<a name="3" id="anc3"></a><span class="line-modified">1367   if (!g_get_console_charset (NULL))</span>
1368     msg = tofree = g_locale_to_utf8 (msg, -1, NULL, NULL, NULL);
1369 #endif
1370 
1371   if (!msg)
1372     msg = tofree = g_strdup_printf (&quot;unknown signal (%d)&quot;, signum);
1373   ret = g_intern_string (msg);
1374   g_free (tofree);
1375 
1376   return ret;
1377 }
1378 
1379 /* Functions g_strlcpy and g_strlcat were originally developed by
1380  * Todd C. Miller &lt;Todd.Miller@courtesan.com&gt; to simplify writing secure code.
1381  * See http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy
1382  * for more information.
1383  */
1384 
1385 #ifdef HAVE_STRLCPY
1386 /* Use the native ones, if available; they might be implemented in assembly */
1387 gsize
1388 g_strlcpy (gchar       *dest,
1389            const gchar *src,
1390            gsize        dest_size)
1391 {
1392   g_return_val_if_fail (dest != NULL, 0);
1393   g_return_val_if_fail (src  != NULL, 0);
1394 
1395   return strlcpy (dest, src, dest_size);
1396 }
1397 
1398 gsize
1399 g_strlcat (gchar       *dest,
1400            const gchar *src,
1401            gsize        dest_size)
1402 {
1403   g_return_val_if_fail (dest != NULL, 0);
1404   g_return_val_if_fail (src  != NULL, 0);
1405 
1406   return strlcat (dest, src, dest_size);
1407 }
1408 
1409 #else /* ! HAVE_STRLCPY */
1410 /**
1411  * g_strlcpy:
1412  * @dest: destination buffer
1413  * @src: source buffer
1414  * @dest_size: length of @dest in bytes
1415  *
1416  * Portability wrapper that calls strlcpy() on systems which have it,
1417  * and emulates strlcpy() otherwise. Copies @src to @dest; @dest is
1418  * guaranteed to be nul-terminated; @src must be nul-terminated;
1419  * @dest_size is the buffer size, not the number of bytes to copy.
1420  *
1421  * At most @dest_size - 1 characters will be copied. Always nul-terminates
1422  * (unless @dest_size is 0). This function does not allocate memory. Unlike
1423  * strncpy(), this function doesn&#39;t pad @dest (so it&#39;s often faster). It
1424  * returns the size of the attempted result, strlen (src), so if
1425  * @retval &gt;= @dest_size, truncation occurred.
1426  *
1427  * Caveat: strlcpy() is supposedly more secure than strcpy() or strncpy(),
1428  * but if you really want to avoid screwups, g_strdup() is an even better
1429  * idea.
1430  *
1431  * Returns: length of @src
1432  */
1433 gsize
1434 g_strlcpy (gchar       *dest,
1435            const gchar *src,
1436            gsize        dest_size)
1437 {
1438   gchar *d = dest;
1439   const gchar *s = src;
1440   gsize n = dest_size;
1441 
1442   g_return_val_if_fail (dest != NULL, 0);
1443   g_return_val_if_fail (src  != NULL, 0);
1444 
1445   /* Copy as many bytes as will fit */
1446   if (n != 0 &amp;&amp; --n != 0)
1447     do
1448       {
1449         gchar c = *s++;
1450 
1451         *d++ = c;
1452         if (c == 0)
1453           break;
1454       }
1455     while (--n != 0);
1456 
1457   /* If not enough room in dest, add NUL and traverse rest of src */
1458   if (n == 0)
1459     {
1460       if (dest_size != 0)
1461         *d = 0;
1462       while (*s++)
1463         ;
1464     }
1465 
1466   return s - src - 1;  /* count does not include NUL */
1467 }
1468 
1469 /**
1470  * g_strlcat:
1471  * @dest: destination buffer, already containing one nul-terminated string
1472  * @src: source buffer
1473  * @dest_size: length of @dest buffer in bytes (not length of existing string
1474  *     inside @dest)
1475  *
1476  * Portability wrapper that calls strlcat() on systems which have it,
1477  * and emulates it otherwise. Appends nul-terminated @src string to @dest,
1478  * guaranteeing nul-termination for @dest. The total size of @dest won&#39;t
1479  * exceed @dest_size.
1480  *
1481  * At most @dest_size - 1 characters will be copied. Unlike strncat(),
1482  * @dest_size is the full size of dest, not the space left over. This
1483  * function does not allocate memory. It always nul-terminates (unless
1484  * @dest_size == 0 or there were no nul characters in the @dest_size
1485  * characters of dest to start with).
1486  *
1487  * Caveat: this is supposedly a more secure alternative to strcat() or
1488  * strncat(), but for real security g_strconcat() is harder to mess up.
1489  *
1490  * Returns: size of attempted result, which is MIN (dest_size, strlen
1491  *     (original dest)) + strlen (src), so if retval &gt;= dest_size,
1492  *     truncation occurred.
1493  */
1494 gsize
1495 g_strlcat (gchar       *dest,
1496            const gchar *src,
1497            gsize        dest_size)
1498 {
1499   gchar *d = dest;
1500   const gchar *s = src;
1501   gsize bytes_left = dest_size;
1502   gsize dlength;  /* Logically, MIN (strlen (d), dest_size) */
1503 
1504   g_return_val_if_fail (dest != NULL, 0);
1505   g_return_val_if_fail (src  != NULL, 0);
1506 
1507   /* Find the end of dst and adjust bytes left but don&#39;t go past end */
1508   while (*d != 0 &amp;&amp; bytes_left-- != 0)
1509     d++;
1510   dlength = d - dest;
1511   bytes_left = dest_size - dlength;
1512 
1513   if (bytes_left == 0)
1514     return dlength + strlen (s);
1515 
1516   while (*s != 0)
1517     {
1518       if (bytes_left != 1)
1519         {
1520           *d++ = *s;
1521           bytes_left--;
1522         }
1523       s++;
1524     }
1525   *d = 0;
1526 
1527   return dlength + (s - src);  /* count does not include NUL */
1528 }
1529 #endif /* ! HAVE_STRLCPY */
1530 
1531 /**
1532  * g_ascii_strdown:
1533  * @str: a string
1534  * @len: length of @str in bytes, or -1 if @str is nul-terminated
1535  *
1536  * Converts all upper case ASCII letters to lower case ASCII letters.
1537  *
1538  * Returns: a newly-allocated string, with all the upper case
1539  *     characters in @str converted to lower case, with semantics that
1540  *     exactly match g_ascii_tolower(). (Note that this is unlike the
1541  *     old g_strdown(), which modified the string in place.)
1542  */
1543 gchar*
1544 g_ascii_strdown (const gchar *str,
1545                  gssize       len)
1546 {
1547   gchar *result, *s;
1548 
1549   g_return_val_if_fail (str != NULL, NULL);
1550 
1551   if (len &lt; 0)
1552     len = (gssize) strlen (str);
1553 
1554   result = g_strndup (str, (gsize) len);
1555   for (s = result; *s; s++)
1556     *s = g_ascii_tolower (*s);
1557 
1558   return result;
1559 }
1560 
1561 /**
1562  * g_ascii_strup:
1563  * @str: a string
1564  * @len: length of @str in bytes, or -1 if @str is nul-terminated
1565  *
1566  * Converts all lower case ASCII letters to upper case ASCII letters.
1567  *
1568  * Returns: a newly allocated string, with all the lower case
1569  *     characters in @str converted to upper case, with semantics that
1570  *     exactly match g_ascii_toupper(). (Note that this is unlike the
1571  *     old g_strup(), which modified the string in place.)
1572  */
1573 gchar*
1574 g_ascii_strup (const gchar *str,
1575                gssize       len)
1576 {
1577   gchar *result, *s;
1578 
1579   g_return_val_if_fail (str != NULL, NULL);
1580 
1581   if (len &lt; 0)
1582     len = (gssize) strlen (str);
1583 
1584   result = g_strndup (str, (gsize) len);
1585   for (s = result; *s; s++)
1586     *s = g_ascii_toupper (*s);
1587 
1588   return result;
1589 }
1590 
1591 /**
1592  * g_str_is_ascii:
1593  * @str: a string
1594  *
1595  * Determines if a string is pure ASCII. A string is pure ASCII if it
1596  * contains no bytes with the high bit set.
1597  *
1598  * Returns: %TRUE if @str is ASCII
1599  *
1600  * Since: 2.40
1601  */
1602 gboolean
1603 g_str_is_ascii (const gchar *str)
1604 {
1605   gint i;
1606 
1607   for (i = 0; str[i]; i++)
1608     if (str[i] &amp; 0x80)
1609       return FALSE;
1610 
1611   return TRUE;
1612 }
1613 
1614 /**
1615  * g_strdown:
1616  * @string: the string to convert.
1617  *
1618  * Converts a string to lower case.
1619  *
1620  * Returns: the string
1621  *
1622  * Deprecated:2.2: This function is totally broken for the reasons discussed
1623  * in the g_strncasecmp() docs - use g_ascii_strdown() or g_utf8_strdown()
1624  * instead.
1625  **/
1626 gchar*
1627 g_strdown (gchar *string)
1628 {
1629   guchar *s;
1630 
1631   g_return_val_if_fail (string != NULL, NULL);
1632 
1633   s = (guchar *) string;
1634 
1635   while (*s)
1636     {
1637       if (isupper (*s))
1638         *s = tolower (*s);
1639       s++;
1640     }
1641 
1642   return (gchar *) string;
1643 }
1644 
1645 /**
1646  * g_strup:
1647  * @string: the string to convert
1648  *
1649  * Converts a string to upper case.
1650  *
1651  * Returns: the string
1652  *
1653  * Deprecated:2.2: This function is totally broken for the reasons
1654  *     discussed in the g_strncasecmp() docs - use g_ascii_strup()
1655  *     or g_utf8_strup() instead.
1656  */
1657 gchar*
1658 g_strup (gchar *string)
1659 {
1660   guchar *s;
1661 
1662   g_return_val_if_fail (string != NULL, NULL);
1663 
1664   s = (guchar *) string;
1665 
1666   while (*s)
1667     {
1668       if (islower (*s))
1669         *s = toupper (*s);
1670       s++;
1671     }
1672 
1673   return (gchar *) string;
1674 }
1675 
1676 /**
1677  * g_strreverse:
1678  * @string: the string to reverse
1679  *
1680  * Reverses all of the bytes in a string. For example,
1681  * `g_strreverse (&quot;abcdef&quot;)` will result in &quot;fedcba&quot;.
1682  *
1683  * Note that g_strreverse() doesn&#39;t work on UTF-8 strings
1684  * containing multibyte characters. For that purpose, use
1685  * g_utf8_strreverse().
1686  *
1687  * Returns: the same pointer passed in as @string
1688  */
1689 gchar*
1690 g_strreverse (gchar *string)
1691 {
1692   g_return_val_if_fail (string != NULL, NULL);
1693 
1694   if (*string)
1695     {
1696       gchar *h, *t;
1697 
1698       h = string;
1699       t = string + strlen (string) - 1;
1700 
1701       while (h &lt; t)
1702         {
1703           gchar c;
1704 
1705           c = *h;
1706           *h = *t;
1707           h++;
1708           *t = c;
1709           t--;
1710         }
1711     }
1712 
1713   return string;
1714 }
1715 
1716 /**
1717  * g_ascii_tolower:
1718  * @c: any character
1719  *
1720  * Convert a character to ASCII lower case.
1721  *
1722  * Unlike the standard C library tolower() function, this only
1723  * recognizes standard ASCII letters and ignores the locale, returning
1724  * all non-ASCII characters unchanged, even if they are lower case
1725  * letters in a particular character set. Also unlike the standard
1726  * library function, this takes and returns a char, not an int, so
1727  * don&#39;t call it on %EOF but no need to worry about casting to #guchar
1728  * before passing a possibly non-ASCII character in.
1729  *
1730  * Returns: the result of converting @c to lower case. If @c is
1731  *     not an ASCII upper case letter, @c is returned unchanged.
1732  */
1733 gchar
1734 g_ascii_tolower (gchar c)
1735 {
1736   return g_ascii_isupper (c) ? c - &#39;A&#39; + &#39;a&#39; : c;
1737 }
1738 
1739 /**
1740  * g_ascii_toupper:
1741  * @c: any character
1742  *
1743  * Convert a character to ASCII upper case.
1744  *
1745  * Unlike the standard C library toupper() function, this only
1746  * recognizes standard ASCII letters and ignores the locale, returning
1747  * all non-ASCII characters unchanged, even if they are upper case
1748  * letters in a particular character set. Also unlike the standard
1749  * library function, this takes and returns a char, not an int, so
1750  * don&#39;t call it on %EOF but no need to worry about casting to #guchar
1751  * before passing a possibly non-ASCII character in.
1752  *
1753  * Returns: the result of converting @c to upper case. If @c is not
1754  *    an ASCII lower case letter, @c is returned unchanged.
1755  */
1756 gchar
1757 g_ascii_toupper (gchar c)
1758 {
1759   return g_ascii_islower (c) ? c - &#39;a&#39; + &#39;A&#39; : c;
1760 }
1761 
1762 /**
1763  * g_ascii_digit_value:
1764  * @c: an ASCII character
1765  *
1766  * Determines the numeric value of a character as a decimal digit.
1767  * Differs from g_unichar_digit_value() because it takes a char, so
1768  * there&#39;s no worry about sign extension if characters are signed.
1769  *
1770  * Returns: If @c is a decimal digit (according to g_ascii_isdigit()),
1771  *    its numeric value. Otherwise, -1.
1772  */
1773 int
1774 g_ascii_digit_value (gchar c)
1775 {
1776   if (g_ascii_isdigit (c))
1777     return c - &#39;0&#39;;
1778   return -1;
1779 }
1780 
1781 /**
1782  * g_ascii_xdigit_value:
1783  * @c: an ASCII character.
1784  *
1785  * Determines the numeric value of a character as a hexidecimal
1786  * digit. Differs from g_unichar_xdigit_value() because it takes
1787  * a char, so there&#39;s no worry about sign extension if characters
1788  * are signed.
1789  *
1790  * Returns: If @c is a hex digit (according to g_ascii_isxdigit()),
1791  *     its numeric value. Otherwise, -1.
1792  */
1793 int
1794 g_ascii_xdigit_value (gchar c)
1795 {
1796   if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
1797     return c - &#39;A&#39; + 10;
1798   if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
1799     return c - &#39;a&#39; + 10;
1800   return g_ascii_digit_value (c);
1801 }
1802 
1803 /**
1804  * g_ascii_strcasecmp:
1805  * @s1: string to compare with @s2
1806  * @s2: string to compare with @s1
1807  *
1808  * Compare two strings, ignoring the case of ASCII characters.
1809  *
1810  * Unlike the BSD strcasecmp() function, this only recognizes standard
1811  * ASCII letters and ignores the locale, treating all non-ASCII
1812  * bytes as if they are not letters.
1813  *
1814  * This function should be used only on strings that are known to be
1815  * in encodings where the bytes corresponding to ASCII letters always
1816  * represent themselves. This includes UTF-8 and the ISO-8859-*
1817  * charsets, but not for instance double-byte encodings like the
1818  * Windows Codepage 932, where the trailing bytes of double-byte
1819  * characters include all ASCII letters. If you compare two CP932
1820  * strings using this function, you will get false matches.
1821  *
1822  * Both @s1 and @s2 must be non-%NULL.
1823  *
1824  * Returns: 0 if the strings match, a negative value if @s1 &lt; @s2,
1825  *     or a positive value if @s1 &gt; @s2.
1826  */
1827 gint
1828 g_ascii_strcasecmp (const gchar *s1,
1829                     const gchar *s2)
1830 {
1831   gint c1, c2;
1832 
1833   g_return_val_if_fail (s1 != NULL, 0);
1834   g_return_val_if_fail (s2 != NULL, 0);
1835 
1836   while (*s1 &amp;&amp; *s2)
1837     {
1838       c1 = (gint)(guchar) TOLOWER (*s1);
1839       c2 = (gint)(guchar) TOLOWER (*s2);
1840       if (c1 != c2)
1841         return (c1 - c2);
1842       s1++; s2++;
1843     }
1844 
1845   return (((gint)(guchar) *s1) - ((gint)(guchar) *s2));
1846 }
1847 
1848 /**
1849  * g_ascii_strncasecmp:
1850  * @s1: string to compare with @s2
1851  * @s2: string to compare with @s1
1852  * @n: number of characters to compare
1853  *
1854  * Compare @s1 and @s2, ignoring the case of ASCII characters and any
1855  * characters after the first @n in each string.
1856  *
1857  * Unlike the BSD strcasecmp() function, this only recognizes standard
1858  * ASCII letters and ignores the locale, treating all non-ASCII
1859  * characters as if they are not letters.
1860  *
1861  * The same warning as in g_ascii_strcasecmp() applies: Use this
1862  * function only on strings known to be in encodings where bytes
1863  * corresponding to ASCII letters always represent themselves.
1864  *
1865  * Returns: 0 if the strings match, a negative value if @s1 &lt; @s2,
1866  *     or a positive value if @s1 &gt; @s2.
1867  */
1868 gint
1869 g_ascii_strncasecmp (const gchar *s1,
1870                      const gchar *s2,
1871                      gsize        n)
1872 {
1873   gint c1, c2;
1874 
1875   g_return_val_if_fail (s1 != NULL, 0);
1876   g_return_val_if_fail (s2 != NULL, 0);
1877 
1878   while (n &amp;&amp; *s1 &amp;&amp; *s2)
1879     {
1880       n -= 1;
1881       c1 = (gint)(guchar) TOLOWER (*s1);
1882       c2 = (gint)(guchar) TOLOWER (*s2);
1883       if (c1 != c2)
1884         return (c1 - c2);
1885       s1++; s2++;
1886     }
1887 
1888   if (n)
1889     return (((gint) (guchar) *s1) - ((gint) (guchar) *s2));
1890   else
1891     return 0;
1892 }
1893 
1894 /**
1895  * g_strcasecmp:
1896  * @s1: a string
1897  * @s2: a string to compare with @s1
1898  *
1899  * A case-insensitive string comparison, corresponding to the standard
1900  * strcasecmp() function on platforms which support it.
1901  *
1902  * Returns: 0 if the strings match, a negative value if @s1 &lt; @s2,
1903  *     or a positive value if @s1 &gt; @s2.
1904  *
1905  * Deprecated:2.2: See g_strncasecmp() for a discussion of why this
1906  *     function is deprecated and how to replace it.
1907  */
1908 gint
1909 g_strcasecmp (const gchar *s1,
1910               const gchar *s2)
1911 {
1912 #ifdef HAVE_STRCASECMP
1913   g_return_val_if_fail (s1 != NULL, 0);
1914   g_return_val_if_fail (s2 != NULL, 0);
1915 
1916   return strcasecmp (s1, s2);
1917 #else
1918   gint c1, c2;
1919 
1920   g_return_val_if_fail (s1 != NULL, 0);
1921   g_return_val_if_fail (s2 != NULL, 0);
1922 
1923   while (*s1 &amp;&amp; *s2)
1924     {
1925       /* According to A. Cox, some platforms have islower&#39;s that
1926        * don&#39;t work right on non-uppercase
1927        */
1928       c1 = isupper ((guchar)*s1) ? tolower ((guchar)*s1) : *s1;
1929       c2 = isupper ((guchar)*s2) ? tolower ((guchar)*s2) : *s2;
1930       if (c1 != c2)
1931         return (c1 - c2);
1932       s1++; s2++;
1933     }
1934 
1935   return (((gint)(guchar) *s1) - ((gint)(guchar) *s2));
1936 #endif
1937 }
1938 
1939 /**
1940  * g_strncasecmp:
1941  * @s1: a string
1942  * @s2: a string to compare with @s1
1943  * @n: the maximum number of characters to compare
1944  *
1945  * A case-insensitive string comparison, corresponding to the standard
1946  * strncasecmp() function on platforms which support it. It is similar
1947  * to g_strcasecmp() except it only compares the first @n characters of
1948  * the strings.
1949  *
1950  * Returns: 0 if the strings match, a negative value if @s1 &lt; @s2,
1951  *     or a positive value if @s1 &gt; @s2.
1952  *
1953  * Deprecated:2.2: The problem with g_strncasecmp() is that it does
1954  *     the comparison by calling toupper()/tolower(). These functions
1955  *     are locale-specific and operate on single bytes. However, it is
1956  *     impossible to handle things correctly from an internationalization
1957  *     standpoint by operating on bytes, since characters may be multibyte.
1958  *     Thus g_strncasecmp() is broken if your string is guaranteed to be
1959  *     ASCII, since it is locale-sensitive, and it&#39;s broken if your string
1960  *     is localized, since it doesn&#39;t work on many encodings at all,
1961  *     including UTF-8, EUC-JP, etc.
1962  *
1963  *     There are therefore two replacement techniques: g_ascii_strncasecmp(),
1964  *     which only works on ASCII and is not locale-sensitive, and
1965  *     g_utf8_casefold() followed by strcmp() on the resulting strings,
1966  *     which is good for case-insensitive sorting of UTF-8.
1967  */
1968 gint
1969 g_strncasecmp (const gchar *s1,
1970                const gchar *s2,
1971                guint n)
1972 {
1973 #ifdef HAVE_STRNCASECMP
1974   return strncasecmp (s1, s2, n);
1975 #else
1976   gint c1, c2;
1977 
1978   g_return_val_if_fail (s1 != NULL, 0);
1979   g_return_val_if_fail (s2 != NULL, 0);
1980 
1981   while (n &amp;&amp; *s1 &amp;&amp; *s2)
1982     {
1983       n -= 1;
1984       /* According to A. Cox, some platforms have islower&#39;s that
1985        * don&#39;t work right on non-uppercase
1986        */
1987       c1 = isupper ((guchar)*s1) ? tolower ((guchar)*s1) : *s1;
1988       c2 = isupper ((guchar)*s2) ? tolower ((guchar)*s2) : *s2;
1989       if (c1 != c2)
1990         return (c1 - c2);
1991       s1++; s2++;
1992     }
1993 
1994   if (n)
1995     return (((gint) (guchar) *s1) - ((gint) (guchar) *s2));
1996   else
1997     return 0;
1998 #endif
1999 }
2000 
2001 /**
2002  * g_strdelimit:
2003  * @string: the string to convert
2004  * @delimiters: (nullable): a string containing the current delimiters,
2005  *     or %NULL to use the standard delimiters defined in #G_STR_DELIMITERS
2006  * @new_delimiter: the new delimiter character
2007  *
2008  * Converts any delimiter characters in @string to @new_delimiter.
2009  * Any characters in @string which are found in @delimiters are
2010  * changed to the @new_delimiter character. Modifies @string in place,
2011  * and returns @string itself, not a copy. The return value is to
2012  * allow nesting such as
2013  * |[&lt;!-- language=&quot;C&quot; --&gt;
2014  *   g_ascii_strup (g_strdelimit (str, &quot;abc&quot;, &#39;?&#39;))
2015  * ]|
2016  *
<a name="4" id="anc4"></a><span class="line-added">2017  * In order to modify a copy, you may use `g_strdup()`:</span>
<span class="line-added">2018  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added">2019  *   reformatted = g_strdelimit (g_strdup (const_str), &quot;abc&quot;, &#39;?&#39;);</span>
<span class="line-added">2020  *   ...</span>
<span class="line-added">2021  *   g_free (reformatted);</span>
<span class="line-added">2022  * ]|</span>
<span class="line-added">2023  *</span>
2024  * Returns: @string
2025  */
2026 gchar *
2027 g_strdelimit (gchar       *string,
2028               const gchar *delimiters,
2029               gchar        new_delim)
2030 {
2031   gchar *c;
2032 
2033   g_return_val_if_fail (string != NULL, NULL);
2034 
2035   if (!delimiters)
2036     delimiters = G_STR_DELIMITERS;
2037 
2038   for (c = string; *c; c++)
2039     {
2040       if (strchr (delimiters, *c))
2041         *c = new_delim;
2042     }
2043 
2044   return string;
2045 }
2046 
2047 /**
2048  * g_strcanon:
2049  * @string: a nul-terminated array of bytes
2050  * @valid_chars: bytes permitted in @string
2051  * @substitutor: replacement character for disallowed bytes
2052  *
2053  * For each character in @string, if the character is not in @valid_chars,
2054  * replaces the character with @substitutor. Modifies @string in place,
2055  * and return @string itself, not a copy. The return value is to allow
2056  * nesting such as
2057  * |[&lt;!-- language=&quot;C&quot; --&gt;
2058  *   g_ascii_strup (g_strcanon (str, &quot;abc&quot;, &#39;?&#39;))
2059  * ]|
2060  *
<a name="5" id="anc5"></a><span class="line-added">2061  * In order to modify a copy, you may use `g_strdup()`:</span>
<span class="line-added">2062  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added">2063  *   reformatted = g_strcanon (g_strdup (const_str), &quot;abc&quot;, &#39;?&#39;);</span>
<span class="line-added">2064  *   ...</span>
<span class="line-added">2065  *   g_free (reformatted);</span>
<span class="line-added">2066  * ]|</span>
<span class="line-added">2067  *</span>
2068  * Returns: @string
2069  */
2070 gchar *
2071 g_strcanon (gchar       *string,
2072             const gchar *valid_chars,
2073             gchar        substitutor)
2074 {
2075   gchar *c;
2076 
2077   g_return_val_if_fail (string != NULL, NULL);
2078   g_return_val_if_fail (valid_chars != NULL, NULL);
2079 
2080   for (c = string; *c; c++)
2081     {
2082       if (!strchr (valid_chars, *c))
2083         *c = substitutor;
2084     }
2085 
2086   return string;
2087 }
2088 
2089 /**
2090  * g_strcompress:
2091  * @source: a string to compress
2092  *
2093  * Replaces all escaped characters with their one byte equivalent.
2094  *
2095  * This function does the reverse conversion of g_strescape().
2096  *
2097  * Returns: a newly-allocated copy of @source with all escaped
2098  *     character compressed
2099  */
2100 gchar *
2101 g_strcompress (const gchar *source)
2102 {
2103   const gchar *p = source, *octal;
2104   gchar *dest;
2105   gchar *q;
2106 
2107   g_return_val_if_fail (source != NULL, NULL);
2108 
2109   dest = g_malloc (strlen (source) + 1);
2110   q = dest;
2111 
2112   while (*p)
2113     {
2114       if (*p == &#39;\\&#39;)
2115         {
2116           p++;
2117           switch (*p)
2118             {
2119             case &#39;\0&#39;:
2120               g_warning (&quot;g_strcompress: trailing \\&quot;);
2121               goto out;
2122             case &#39;0&#39;:  case &#39;1&#39;:  case &#39;2&#39;:  case &#39;3&#39;:  case &#39;4&#39;:
2123             case &#39;5&#39;:  case &#39;6&#39;:  case &#39;7&#39;:
2124               *q = 0;
2125               octal = p;
2126               while ((p &lt; octal + 3) &amp;&amp; (*p &gt;= &#39;0&#39;) &amp;&amp; (*p &lt;= &#39;7&#39;))
2127                 {
2128                   *q = (*q * 8) + (*p - &#39;0&#39;);
2129                   p++;
2130                 }
2131               q++;
2132               p--;
2133               break;
2134             case &#39;b&#39;:
2135               *q++ = &#39;\b&#39;;
2136               break;
2137             case &#39;f&#39;:
2138               *q++ = &#39;\f&#39;;
2139               break;
2140             case &#39;n&#39;:
2141               *q++ = &#39;\n&#39;;
2142               break;
2143             case &#39;r&#39;:
2144               *q++ = &#39;\r&#39;;
2145               break;
2146             case &#39;t&#39;:
2147               *q++ = &#39;\t&#39;;
2148               break;
2149             case &#39;v&#39;:
2150               *q++ = &#39;\v&#39;;
2151               break;
2152             default:            /* Also handles \&quot; and \\ */
2153               *q++ = *p;
2154               break;
2155             }
2156         }
2157       else
2158         *q++ = *p;
2159       p++;
2160     }
2161 out:
2162   *q = 0;
2163 
2164   return dest;
2165 }
2166 
2167 /**
2168  * g_strescape:
2169  * @source: a string to escape
2170  * @exceptions: (nullable): a string of characters not to escape in @source
2171  *
2172  * Escapes the special characters &#39;\b&#39;, &#39;\f&#39;, &#39;\n&#39;, &#39;\r&#39;, &#39;\t&#39;, &#39;\v&#39;, &#39;\&#39;
2173  * and &#39;&quot;&#39; in the string @source by inserting a &#39;\&#39; before
2174  * them. Additionally all characters in the range 0x01-0x1F (everything
2175  * below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are
2176  * replaced with a &#39;\&#39; followed by their octal representation.
2177  * Characters supplied in @exceptions are not escaped.
2178  *
2179  * g_strcompress() does the reverse conversion.
2180  *
2181  * Returns: a newly-allocated copy of @source with certain
2182  *     characters escaped. See above.
2183  */
2184 gchar *
2185 g_strescape (const gchar *source,
2186              const gchar *exceptions)
2187 {
2188   const guchar *p;
2189   gchar *dest;
2190   gchar *q;
2191   guchar excmap[256];
2192 
2193   g_return_val_if_fail (source != NULL, NULL);
2194 
2195   p = (guchar *) source;
2196   /* Each source byte needs maximally four destination chars (\777) */
2197   q = dest = g_malloc (strlen (source) * 4 + 1);
2198 
2199   memset (excmap, 0, 256);
2200   if (exceptions)
2201     {
2202       guchar *e = (guchar *) exceptions;
2203 
2204       while (*e)
2205         {
2206           excmap[*e] = 1;
2207           e++;
2208         }
2209     }
2210 
2211   while (*p)
2212     {
2213       if (excmap[*p])
2214         *q++ = *p;
2215       else
2216         {
2217           switch (*p)
2218             {
2219             case &#39;\b&#39;:
2220               *q++ = &#39;\\&#39;;
2221               *q++ = &#39;b&#39;;
2222               break;
2223             case &#39;\f&#39;:
2224               *q++ = &#39;\\&#39;;
2225               *q++ = &#39;f&#39;;
2226               break;
2227             case &#39;\n&#39;:
2228               *q++ = &#39;\\&#39;;
2229               *q++ = &#39;n&#39;;
2230               break;
2231             case &#39;\r&#39;:
2232               *q++ = &#39;\\&#39;;
2233               *q++ = &#39;r&#39;;
2234               break;
2235             case &#39;\t&#39;:
2236               *q++ = &#39;\\&#39;;
2237               *q++ = &#39;t&#39;;
2238               break;
2239             case &#39;\v&#39;:
2240               *q++ = &#39;\\&#39;;
2241               *q++ = &#39;v&#39;;
2242               break;
2243             case &#39;\\&#39;:
2244               *q++ = &#39;\\&#39;;
2245               *q++ = &#39;\\&#39;;
2246               break;
2247             case &#39;&quot;&#39;:
2248               *q++ = &#39;\\&#39;;
2249               *q++ = &#39;&quot;&#39;;
2250               break;
2251             default:
2252               if ((*p &lt; &#39; &#39;) || (*p &gt;= 0177))
2253                 {
2254                   *q++ = &#39;\\&#39;;
2255                   *q++ = &#39;0&#39; + (((*p) &gt;&gt; 6) &amp; 07);
2256                   *q++ = &#39;0&#39; + (((*p) &gt;&gt; 3) &amp; 07);
2257                   *q++ = &#39;0&#39; + ((*p) &amp; 07);
2258                 }
2259               else
2260                 *q++ = *p;
2261               break;
2262             }
2263         }
2264       p++;
2265     }
2266   *q = 0;
2267   return dest;
2268 }
2269 
2270 /**
2271  * g_strchug:
2272  * @string: a string to remove the leading whitespace from
2273  *
2274  * Removes leading whitespace from a string, by moving the rest
2275  * of the characters forward.
2276  *
2277  * This function doesn&#39;t allocate or reallocate any memory;
2278  * it modifies @string in place. Therefore, it cannot be used on
2279  * statically allocated strings.
2280  *
2281  * The pointer to @string is returned to allow the nesting of functions.
2282  *
2283  * Also see g_strchomp() and g_strstrip().
2284  *
2285  * Returns: @string
2286  */
2287 gchar *
2288 g_strchug (gchar *string)
2289 {
2290   guchar *start;
2291 
2292   g_return_val_if_fail (string != NULL, NULL);
2293 
2294   for (start = (guchar*) string; *start &amp;&amp; g_ascii_isspace (*start); start++)
2295     ;
2296 
2297   memmove (string, start, strlen ((gchar *) start) + 1);
2298 
2299   return string;
2300 }
2301 
2302 /**
2303  * g_strchomp:
2304  * @string: a string to remove the trailing whitespace from
2305  *
2306  * Removes trailing whitespace from a string.
2307  *
2308  * This function doesn&#39;t allocate or reallocate any memory;
2309  * it modifies @string in place. Therefore, it cannot be used
2310  * on statically allocated strings.
2311  *
2312  * The pointer to @string is returned to allow the nesting of functions.
2313  *
2314  * Also see g_strchug() and g_strstrip().
2315  *
2316  * Returns: @string
2317  */
2318 gchar *
2319 g_strchomp (gchar *string)
2320 {
2321   gsize len;
2322 
2323   g_return_val_if_fail (string != NULL, NULL);
2324 
2325   len = strlen (string);
2326   while (len--)
2327     {
2328       if (g_ascii_isspace ((guchar) string[len]))
2329         string[len] = &#39;\0&#39;;
2330       else
2331         break;
2332     }
2333 
2334   return string;
2335 }
2336 
2337 /**
2338  * g_strsplit:
2339  * @string: a string to split
2340  * @delimiter: a string which specifies the places at which to split
2341  *     the string. The delimiter is not included in any of the resulting
2342  *     strings, unless @max_tokens is reached.
2343  * @max_tokens: the maximum number of pieces to split @string into.
2344  *     If this is less than 1, the string is split completely.
2345  *
2346  * Splits a string into a maximum of @max_tokens pieces, using the given
2347  * @delimiter. If @max_tokens is reached, the remainder of @string is
2348  * appended to the last token.
2349  *
2350  * As an example, the result of g_strsplit (&quot;:a:bc::d:&quot;, &quot;:&quot;, -1) is a
2351  * %NULL-terminated vector containing the six strings &quot;&quot;, &quot;a&quot;, &quot;bc&quot;, &quot;&quot;, &quot;d&quot;
2352  * and &quot;&quot;.
2353  *
2354  * As a special case, the result of splitting the empty string &quot;&quot; is an empty
2355  * vector, not a vector containing a single string. The reason for this
<a name="6" id="anc6"></a><span class="line-modified">2356  * special case is that being able to represent an empty vector is typically</span>
2357  * more useful than consistent handling of empty elements. If you do need
2358  * to represent empty elements, you&#39;ll need to check for the empty string
2359  * before calling g_strsplit().
2360  *
2361  * Returns: a newly-allocated %NULL-terminated array of strings. Use
2362  *    g_strfreev() to free it.
2363  */
2364 gchar**
2365 g_strsplit (const gchar *string,
2366             const gchar *delimiter,
2367             gint         max_tokens)
2368 {
2369   GSList *string_list = NULL, *slist;
2370   gchar **str_array, *s;
2371   guint n = 0;
2372   const gchar *remainder;
2373 
2374   g_return_val_if_fail (string != NULL, NULL);
2375   g_return_val_if_fail (delimiter != NULL, NULL);
2376   g_return_val_if_fail (delimiter[0] != &#39;\0&#39;, NULL);
2377 
2378   if (max_tokens &lt; 1)
2379     max_tokens = G_MAXINT;
2380 
2381   remainder = string;
2382   s = strstr (remainder, delimiter);
2383   if (s)
2384     {
2385       gsize delimiter_len = strlen (delimiter);
2386 
2387       while (--max_tokens &amp;&amp; s)
2388         {
2389           gsize len;
2390 
2391           len = s - remainder;
2392           string_list = g_slist_prepend (string_list,
2393                                          g_strndup (remainder, len));
2394           n++;
2395           remainder = s + delimiter_len;
2396           s = strstr (remainder, delimiter);
2397         }
2398     }
2399   if (*string)
2400     {
2401       n++;
2402       string_list = g_slist_prepend (string_list, g_strdup (remainder));
2403     }
2404 
2405   str_array = g_new (gchar*, n + 1);
2406 
2407   str_array[n--] = NULL;
2408   for (slist = string_list; slist; slist = slist-&gt;next)
2409     str_array[n--] = slist-&gt;data;
2410 
2411   g_slist_free (string_list);
2412 
2413   return str_array;
2414 }
2415 
2416 /**
2417  * g_strsplit_set:
2418  * @string: The string to be tokenized
2419  * @delimiters: A nul-terminated string containing bytes that are used
2420  *     to split the string.
2421  * @max_tokens: The maximum number of tokens to split @string into.
2422  *     If this is less than 1, the string is split completely
2423  *
2424  * Splits @string into a number of tokens not containing any of the characters
2425  * in @delimiter. A token is the (possibly empty) longest string that does not
2426  * contain any of the characters in @delimiters. If @max_tokens is reached, the
2427  * remainder is appended to the last token.
2428  *
2429  * For example the result of g_strsplit_set (&quot;abc:def/ghi&quot;, &quot;:/&quot;, -1) is a
2430  * %NULL-terminated vector containing the three strings &quot;abc&quot;, &quot;def&quot;,
2431  * and &quot;ghi&quot;.
2432  *
2433  * The result of g_strsplit_set (&quot;:def/ghi:&quot;, &quot;:/&quot;, -1) is a %NULL-terminated
2434  * vector containing the four strings &quot;&quot;, &quot;def&quot;, &quot;ghi&quot;, and &quot;&quot;.
2435  *
2436  * As a special case, the result of splitting the empty string &quot;&quot; is an empty
2437  * vector, not a vector containing a single string. The reason for this
<a name="7" id="anc7"></a><span class="line-modified">2438  * special case is that being able to represent an empty vector is typically</span>
2439  * more useful than consistent handling of empty elements. If you do need
2440  * to represent empty elements, you&#39;ll need to check for the empty string
2441  * before calling g_strsplit_set().
2442  *
2443  * Note that this function works on bytes not characters, so it can&#39;t be used
2444  * to delimit UTF-8 strings for anything but ASCII characters.
2445  *
2446  * Returns: a newly-allocated %NULL-terminated array of strings. Use
2447  *    g_strfreev() to free it.
2448  *
2449  * Since: 2.4
2450  **/
2451 gchar **
2452 g_strsplit_set (const gchar *string,
2453                 const gchar *delimiters,
2454                 gint         max_tokens)
2455 {
2456   gboolean delim_table[256];
2457   GSList *tokens, *list;
2458   gint n_tokens;
2459   const gchar *s;
2460   const gchar *current;
2461   gchar *token;
2462   gchar **result;
2463 
2464   g_return_val_if_fail (string != NULL, NULL);
2465   g_return_val_if_fail (delimiters != NULL, NULL);
2466 
2467   if (max_tokens &lt; 1)
2468     max_tokens = G_MAXINT;
2469 
2470   if (*string == &#39;\0&#39;)
2471     {
2472       result = g_new (char *, 1);
2473       result[0] = NULL;
2474       return result;
2475     }
2476 
2477   memset (delim_table, FALSE, sizeof (delim_table));
2478   for (s = delimiters; *s != &#39;\0&#39;; ++s)
2479     delim_table[*(guchar *)s] = TRUE;
2480 
2481   tokens = NULL;
2482   n_tokens = 0;
2483 
2484   s = current = string;
2485   while (*s != &#39;\0&#39;)
2486     {
2487       if (delim_table[*(guchar *)s] &amp;&amp; n_tokens + 1 &lt; max_tokens)
2488         {
2489           token = g_strndup (current, s - current);
2490           tokens = g_slist_prepend (tokens, token);
2491           ++n_tokens;
2492 
2493           current = s + 1;
2494         }
2495 
2496       ++s;
2497     }
2498 
2499   token = g_strndup (current, s - current);
2500   tokens = g_slist_prepend (tokens, token);
2501   ++n_tokens;
2502 
2503   result = g_new (gchar *, n_tokens + 1);
2504 
2505   result[n_tokens] = NULL;
2506   for (list = tokens; list != NULL; list = list-&gt;next)
2507     result[--n_tokens] = list-&gt;data;
2508 
2509   g_slist_free (tokens);
2510 
2511   return result;
2512 }
2513 
2514 /**
2515  * GStrv:
2516  *
2517  * A typedef alias for gchar**. This is mostly useful when used together with
2518  * g_auto().
2519  */
2520 
2521 /**
2522  * g_strfreev:
2523  * @str_array: (nullable): a %NULL-terminated array of strings to free
2524  *
2525  * Frees a %NULL-terminated array of strings, as well as each
2526  * string it contains.
2527  *
2528  * If @str_array is %NULL, this function simply returns.
2529  */
2530 void
2531 g_strfreev (gchar **str_array)
2532 {
2533   if (str_array)
2534     {
2535       int i;
2536 
2537       for (i = 0; str_array[i] != NULL; i++)
2538         g_free (str_array[i]);
2539 
2540       g_free (str_array);
2541     }
2542 }
2543 
2544 /**
2545  * g_strdupv:
2546  * @str_array: (nullable): a %NULL-terminated array of strings
2547  *
2548  * Copies %NULL-terminated array of strings. The copy is a deep copy;
2549  * the new array should be freed by first freeing each string, then
2550  * the array itself. g_strfreev() does this for you. If called
2551  * on a %NULL value, g_strdupv() simply returns %NULL.
2552  *
2553  * Returns: (nullable): a new %NULL-terminated array of strings.
2554  */
2555 gchar**
2556 g_strdupv (gchar **str_array)
2557 {
2558   if (str_array)
2559     {
2560       gint i;
2561       gchar **retval;
2562 
2563       i = 0;
2564       while (str_array[i])
2565         ++i;
2566 
2567       retval = g_new (gchar*, i + 1);
2568 
2569       i = 0;
2570       while (str_array[i])
2571         {
2572           retval[i] = g_strdup (str_array[i]);
2573           ++i;
2574         }
2575       retval[i] = NULL;
2576 
2577       return retval;
2578     }
2579   else
2580     return NULL;
2581 }
2582 
2583 /**
2584  * g_strjoinv:
2585  * @separator: (nullable): a string to insert between each of the
2586  *     strings, or %NULL
2587  * @str_array: a %NULL-terminated array of strings to join
2588  *
2589  * Joins a number of strings together to form one long string, with the
2590  * optional @separator inserted between each of them. The returned string
2591  * should be freed with g_free().
2592  *
2593  * If @str_array has no items, the return value will be an
2594  * empty string. If @str_array contains a single item, @separator will not
2595  * appear in the resulting string.
2596  *
2597  * Returns: a newly-allocated string containing all of the strings joined
2598  *     together, with @separator between them
2599  */
2600 gchar*
2601 g_strjoinv (const gchar  *separator,
2602             gchar       **str_array)
2603 {
2604   gchar *string;
2605   gchar *ptr;
2606 
2607   g_return_val_if_fail (str_array != NULL, NULL);
2608 
2609   if (separator == NULL)
2610     separator = &quot;&quot;;
2611 
2612   if (*str_array)
2613     {
2614       gint i;
2615       gsize len;
2616       gsize separator_len;
2617 
2618       separator_len = strlen (separator);
2619       /* First part, getting length */
2620       len = 1 + strlen (str_array[0]);
2621       for (i = 1; str_array[i] != NULL; i++)
2622         len += strlen (str_array[i]);
2623       len += separator_len * (i - 1);
2624 
2625       /* Second part, building string */
2626       string = g_new (gchar, len);
2627       ptr = g_stpcpy (string, *str_array);
2628       for (i = 1; str_array[i] != NULL; i++)
2629         {
2630           ptr = g_stpcpy (ptr, separator);
2631           ptr = g_stpcpy (ptr, str_array[i]);
2632         }
2633       }
2634   else
2635     string = g_strdup (&quot;&quot;);
2636 
2637   return string;
2638 }
2639 
2640 /**
2641  * g_strjoin:
2642  * @separator: (nullable): a string to insert between each of the
2643  *     strings, or %NULL
2644  * @...: a %NULL-terminated list of strings to join
2645  *
2646  * Joins a number of strings together to form one long string, with the
2647  * optional @separator inserted between each of them. The returned string
2648  * should be freed with g_free().
2649  *
2650  * Returns: a newly-allocated string containing all of the strings joined
2651  *     together, with @separator between them
2652  */
2653 gchar*
2654 g_strjoin (const gchar *separator,
2655            ...)
2656 {
2657   gchar *string, *s;
2658   va_list args;
2659   gsize len;
2660   gsize separator_len;
2661   gchar *ptr;
2662 
2663   if (separator == NULL)
2664     separator = &quot;&quot;;
2665 
2666   separator_len = strlen (separator);
2667 
2668   va_start (args, separator);
2669 
2670   s = va_arg (args, gchar*);
2671 
2672   if (s)
2673     {
2674       /* First part, getting length */
2675       len = 1 + strlen (s);
2676 
2677       s = va_arg (args, gchar*);
2678       while (s)
2679         {
2680           len += separator_len + strlen (s);
2681           s = va_arg (args, gchar*);
2682         }
2683       va_end (args);
2684 
2685       /* Second part, building string */
2686       string = g_new (gchar, len);
2687 
2688       va_start (args, separator);
2689 
2690       s = va_arg (args, gchar*);
2691       ptr = g_stpcpy (string, s);
2692 
2693       s = va_arg (args, gchar*);
2694       while (s)
2695         {
2696           ptr = g_stpcpy (ptr, separator);
2697           ptr = g_stpcpy (ptr, s);
2698           s = va_arg (args, gchar*);
2699         }
2700     }
2701   else
2702     string = g_strdup (&quot;&quot;);
2703 
2704   va_end (args);
2705 
2706   return string;
2707 }
2708 
2709 
2710 /**
2711  * g_strstr_len:
2712  * @haystack: a string
2713  * @haystack_len: the maximum length of @haystack. Note that -1 is
2714  *     a valid length, if @haystack is nul-terminated, meaning it will
2715  *     search through the whole string.
2716  * @needle: the string to search for
2717  *
2718  * Searches the string @haystack for the first occurrence
2719  * of the string @needle, limiting the length of the search
2720  * to @haystack_len.
2721  *
2722  * Returns: a pointer to the found occurrence, or
2723  *    %NULL if not found.
2724  */
2725 gchar *
2726 g_strstr_len (const gchar *haystack,
2727               gssize       haystack_len,
2728               const gchar *needle)
2729 {
2730   g_return_val_if_fail (haystack != NULL, NULL);
2731   g_return_val_if_fail (needle != NULL, NULL);
2732 
2733   if (haystack_len &lt; 0)
2734     return strstr (haystack, needle);
2735   else
2736     {
2737       const gchar *p = haystack;
2738       gsize needle_len = strlen (needle);
<a name="8" id="anc8"></a><span class="line-added">2739       gsize haystack_len_unsigned = haystack_len;</span>
2740       const gchar *end;
2741       gsize i;
2742 
2743       if (needle_len == 0)
2744         return (gchar *)haystack;
2745 
<a name="9" id="anc9"></a><span class="line-modified">2746       if (haystack_len_unsigned &lt; needle_len)</span>
2747         return NULL;
2748 
2749       end = haystack + haystack_len - needle_len;
2750 
2751       while (p &lt;= end &amp;&amp; *p)
2752         {
2753           for (i = 0; i &lt; needle_len; i++)
2754             if (p[i] != needle[i])
2755               goto next;
2756 
2757           return (gchar *)p;
2758 
2759         next:
2760           p++;
2761         }
2762 
2763       return NULL;
2764     }
2765 }
2766 
2767 /**
2768  * g_strrstr:
2769  * @haystack: a nul-terminated string
2770  * @needle: the nul-terminated string to search for
2771  *
2772  * Searches the string @haystack for the last occurrence
2773  * of the string @needle.
2774  *
2775  * Returns: a pointer to the found occurrence, or
2776  *    %NULL if not found.
2777  */
2778 gchar *
2779 g_strrstr (const gchar *haystack,
2780            const gchar *needle)
2781 {
2782   gsize i;
2783   gsize needle_len;
2784   gsize haystack_len;
2785   const gchar *p;
2786 
2787   g_return_val_if_fail (haystack != NULL, NULL);
2788   g_return_val_if_fail (needle != NULL, NULL);
2789 
2790   needle_len = strlen (needle);
2791   haystack_len = strlen (haystack);
2792 
2793   if (needle_len == 0)
2794     return (gchar *)haystack;
2795 
2796   if (haystack_len &lt; needle_len)
2797     return NULL;
2798 
2799   p = haystack + haystack_len - needle_len;
2800 
2801   while (p &gt;= haystack)
2802     {
2803       for (i = 0; i &lt; needle_len; i++)
2804         if (p[i] != needle[i])
2805           goto next;
2806 
2807       return (gchar *)p;
2808 
2809     next:
2810       p--;
2811     }
2812 
2813   return NULL;
2814 }
2815 
2816 /**
2817  * g_strrstr_len:
2818  * @haystack: a nul-terminated string
2819  * @haystack_len: the maximum length of @haystack
2820  * @needle: the nul-terminated string to search for
2821  *
2822  * Searches the string @haystack for the last occurrence
2823  * of the string @needle, limiting the length of the search
2824  * to @haystack_len.
2825  *
2826  * Returns: a pointer to the found occurrence, or
2827  *    %NULL if not found.
2828  */
2829 gchar *
2830 g_strrstr_len (const gchar *haystack,
2831                gssize        haystack_len,
2832                const gchar *needle)
2833 {
2834   g_return_val_if_fail (haystack != NULL, NULL);
2835   g_return_val_if_fail (needle != NULL, NULL);
2836 
2837   if (haystack_len &lt; 0)
2838     return g_strrstr (haystack, needle);
2839   else
2840     {
2841       gsize needle_len = strlen (needle);
2842       const gchar *haystack_max = haystack + haystack_len;
2843       const gchar *p = haystack;
2844       gsize i;
2845 
2846       while (p &lt; haystack_max &amp;&amp; *p)
2847         p++;
2848 
2849       if (p &lt; haystack + needle_len)
2850         return NULL;
2851 
2852       p -= needle_len;
2853 
2854       while (p &gt;= haystack)
2855         {
2856           for (i = 0; i &lt; needle_len; i++)
2857             if (p[i] != needle[i])
2858               goto next;
2859 
2860           return (gchar *)p;
2861 
2862         next:
2863           p--;
2864         }
2865 
2866       return NULL;
2867     }
2868 }
2869 
2870 
2871 /**
2872  * g_str_has_suffix:
2873  * @str: a nul-terminated string
2874  * @suffix: the nul-terminated suffix to look for
2875  *
2876  * Looks whether the string @str ends with @suffix.
2877  *
2878  * Returns: %TRUE if @str end with @suffix, %FALSE otherwise.
2879  *
2880  * Since: 2.2
2881  */
2882 gboolean
2883 g_str_has_suffix (const gchar *str,
2884                   const gchar *suffix)
2885 {
2886   gsize str_len;
2887   gsize suffix_len;
2888 
2889   g_return_val_if_fail (str != NULL, FALSE);
2890   g_return_val_if_fail (suffix != NULL, FALSE);
2891 
2892   str_len = strlen (str);
2893   suffix_len = strlen (suffix);
2894 
2895   if (str_len &lt; suffix_len)
2896     return FALSE;
2897 
2898   return strcmp (str + str_len - suffix_len, suffix) == 0;
2899 }
2900 
2901 /**
2902  * g_str_has_prefix:
2903  * @str: a nul-terminated string
2904  * @prefix: the nul-terminated prefix to look for
2905  *
2906  * Looks whether the string @str begins with @prefix.
2907  *
2908  * Returns: %TRUE if @str begins with @prefix, %FALSE otherwise.
2909  *
2910  * Since: 2.2
2911  */
2912 gboolean
2913 g_str_has_prefix (const gchar *str,
2914                   const gchar *prefix)
2915 {
2916   g_return_val_if_fail (str != NULL, FALSE);
2917   g_return_val_if_fail (prefix != NULL, FALSE);
2918 
2919   return strncmp (str, prefix, strlen (prefix)) == 0;
2920 }
2921 
2922 /**
2923  * g_strv_length:
2924  * @str_array: a %NULL-terminated array of strings
2925  *
2926  * Returns the length of the given %NULL-terminated
2927  * string array @str_array. @str_array must not be %NULL.
2928  *
2929  * Returns: length of @str_array.
2930  *
2931  * Since: 2.6
2932  */
2933 guint
2934 g_strv_length (gchar **str_array)
2935 {
2936   guint i = 0;
2937 
2938   g_return_val_if_fail (str_array != NULL, 0);
2939 
2940   while (str_array[i])
2941     ++i;
2942 
2943   return i;
2944 }
2945 
2946 static void
2947 index_add_folded (GPtrArray   *array,
2948                   const gchar *start,
2949                   const gchar *end)
2950 {
2951   gchar *normal;
2952 
2953   normal = g_utf8_normalize (start, end - start, G_NORMALIZE_ALL_COMPOSE);
2954 
2955   /* TODO: Invent time machine.  Converse with Mustafa Ataturk... */
2956   if (strstr (normal, &quot;i&quot;) || strstr (normal, &quot;I&quot;))
2957     {
2958       gchar *s = normal;
2959       GString *tmp;
2960 
2961       tmp = g_string_new (NULL);
2962 
2963       while (*s)
2964         {
2965           gchar *i, *I, *e;
2966 
2967           i = strstr (s, &quot;i&quot;);
2968           I = strstr (s, &quot;I&quot;);
2969 
2970           if (!i &amp;&amp; !I)
2971             break;
2972           else if (i &amp;&amp; !I)
2973             e = i;
2974           else if (I &amp;&amp; !i)
2975             e = I;
2976           else if (i &lt; I)
2977             e = i;
2978           else
2979             e = I;
2980 
2981           g_string_append_len (tmp, s, e - s);
2982           g_string_append_c (tmp, &#39;i&#39;);
2983           s = g_utf8_next_char (e);
2984         }
2985 
2986       g_string_append (tmp, s);
2987       g_free (normal);
2988       normal = g_string_free (tmp, FALSE);
2989     }
2990 
2991   g_ptr_array_add (array, g_utf8_casefold (normal, -1));
2992   g_free (normal);
2993 }
2994 
2995 static gchar **
2996 split_words (const gchar *value)
2997 {
2998   const gchar *start = NULL;
2999   GPtrArray *result;
3000   const gchar *s;
3001 
3002   result = g_ptr_array_new ();
3003 
3004   for (s = value; *s; s = g_utf8_next_char (s))
3005     {
3006       gunichar c = g_utf8_get_char (s);
3007 
3008       if (start == NULL)
3009         {
3010           if (g_unichar_isalnum (c) || g_unichar_ismark (c))
3011             start = s;
3012         }
3013       else
3014         {
3015           if (!g_unichar_isalnum (c) &amp;&amp; !g_unichar_ismark (c))
3016             {
3017               index_add_folded (result, start, s);
3018               start = NULL;
3019             }
3020         }
3021     }
3022 
3023   if (start)
3024     index_add_folded (result, start, s);
3025 
3026   g_ptr_array_add (result, NULL);
3027 
3028   return (gchar **) g_ptr_array_free (result, FALSE);
3029 }
3030 
3031 /**
3032  * g_str_tokenize_and_fold:
3033  * @string: a string
3034  * @translit_locale: (nullable): the language code (like &#39;de&#39; or
3035  *   &#39;en_GB&#39;) from which @string originates
3036  * @ascii_alternates: (out) (transfer full) (array zero-terminated=1): a
3037  *   return location for ASCII alternates
3038  *
3039  * Tokenises @string and performs folding on each token.
3040  *
3041  * A token is a non-empty sequence of alphanumeric characters in the
3042  * source string, separated by non-alphanumeric characters.  An
3043  * &quot;alphanumeric&quot; character for this purpose is one that matches
3044  * g_unichar_isalnum() or g_unichar_ismark().
3045  *
3046  * Each token is then (Unicode) normalised and case-folded.  If
3047  * @ascii_alternates is non-%NULL and some of the returned tokens
3048  * contain non-ASCII characters, ASCII alternatives will be generated.
3049  *
3050  * The number of ASCII alternatives that are generated and the method
3051  * for doing so is unspecified, but @translit_locale (if specified) may
3052  * improve the transliteration if the language of the source string is
3053  * known.
3054  *
3055  * Returns: (transfer full) (array zero-terminated=1): the folded tokens
3056  *
3057  * Since: 2.40
3058  **/
3059 gchar **
3060 g_str_tokenize_and_fold (const gchar   *string,
3061                          const gchar   *translit_locale,
3062                          gchar       ***ascii_alternates)
3063 {
3064   gchar **result;
3065 
3066   g_return_val_if_fail (string != NULL, NULL);
3067 
3068   if (ascii_alternates &amp;&amp; g_str_is_ascii (string))
3069     {
3070       *ascii_alternates = g_new0 (gchar *, 0 + 1);
3071       ascii_alternates = NULL;
3072     }
3073 
3074   result = split_words (string);
3075 
3076   if (ascii_alternates)
3077     {
3078       gint i, j, n;
3079 
3080       n = g_strv_length (result);
3081       *ascii_alternates = g_new (gchar *, n + 1);
3082       j = 0;
3083 
3084       for (i = 0; i &lt; n; i++)
3085         {
3086           if (!g_str_is_ascii (result[i]))
3087             {
3088               gchar *composed;
3089               gchar *ascii;
3090               gint k;
3091 
3092               composed = g_utf8_normalize (result[i], -1, G_NORMALIZE_ALL_COMPOSE);
3093 
3094               ascii = g_str_to_ascii (composed, translit_locale);
3095 
3096               /* Only accept strings that are now entirely alnums */
3097               for (k = 0; ascii[k]; k++)
3098                 if (!g_ascii_isalnum (ascii[k]))
3099                   break;
3100 
3101               if (ascii[k] == &#39;\0&#39;)
3102                 /* Made it to the end... */
3103                 (*ascii_alternates)[j++] = ascii;
3104               else
3105                 g_free (ascii);
3106 
3107               g_free (composed);
3108             }
3109         }
3110 
3111       (*ascii_alternates)[j] = NULL;
3112     }
3113 
3114   return result;
3115 }
3116 
3117 /**
3118  * g_str_match_string:
3119  * @search_term: the search term from the user
3120  * @potential_hit: the text that may be a hit
3121  * @accept_alternates: %TRUE to accept ASCII alternates
3122  *
3123  * Checks if a search conducted for @search_term should match
3124  * @potential_hit.
3125  *
3126  * This function calls g_str_tokenize_and_fold() on both
3127  * @search_term and @potential_hit.  ASCII alternates are never taken
3128  * for @search_term but will be taken for @potential_hit according to
3129  * the value of @accept_alternates.
3130  *
3131  * A hit occurs when each folded token in @search_term is a prefix of a
3132  * folded token from @potential_hit.
3133  *
3134  * Depending on how you&#39;re performing the search, it will typically be
3135  * faster to call g_str_tokenize_and_fold() on each string in
3136  * your corpus and build an index on the returned folded tokens, then
3137  * call g_str_tokenize_and_fold() on the search term and
3138  * perform lookups into that index.
3139  *
3140  * As some examples, searching for &quot;fred&quot; would match the potential hit
3141  * &quot;Smith, Fred&quot; and also &quot;Frederic&quot;.  Searching for &quot;Fred&quot; would match
3142  * &quot;Frederic&quot; but not &quot;Frederic&quot; (due to the one-directional nature of
3143  * accent matching).  Searching &quot;fo&quot; would match &quot;Foo&quot; and &quot;Bar Foo
3144  * Baz&quot;, but not &quot;SFO&quot; (because no word as &quot;fo&quot; as a prefix).
3145  *
3146  * Returns: %TRUE if @potential_hit is a hit
3147  *
3148  * Since: 2.40
3149  **/
3150 gboolean
3151 g_str_match_string (const gchar *search_term,
3152                     const gchar *potential_hit,
3153                     gboolean     accept_alternates)
3154 {
3155   gchar **alternates = NULL;
3156   gchar **term_tokens;
3157   gchar **hit_tokens;
3158   gboolean matched;
3159   gint i, j;
3160 
3161   g_return_val_if_fail (search_term != NULL, FALSE);
3162   g_return_val_if_fail (potential_hit != NULL, FALSE);
3163 
3164   term_tokens = g_str_tokenize_and_fold (search_term, NULL, NULL);
3165   hit_tokens = g_str_tokenize_and_fold (potential_hit, NULL, accept_alternates ? &amp;alternates : NULL);
3166 
3167   matched = TRUE;
3168 
3169   for (i = 0; term_tokens[i]; i++)
3170     {
3171       for (j = 0; hit_tokens[j]; j++)
3172         if (g_str_has_prefix (hit_tokens[j], term_tokens[i]))
3173           goto one_matched;
3174 
3175       if (accept_alternates)
3176         for (j = 0; alternates[j]; j++)
3177           if (g_str_has_prefix (alternates[j], term_tokens[i]))
3178             goto one_matched;
3179 
3180       matched = FALSE;
3181       break;
3182 
3183 one_matched:
3184       continue;
3185     }
3186 
3187   g_strfreev (term_tokens);
3188   g_strfreev (hit_tokens);
3189   g_strfreev (alternates);
3190 
3191   return matched;
3192 }
3193 
3194 /**
3195  * g_strv_contains:
3196  * @strv: a %NULL-terminated array of strings
3197  * @str: a string
3198  *
3199  * Checks if @strv contains @str. @strv must not be %NULL.
3200  *
3201  * Returns: %TRUE if @str is an element of @strv, according to g_str_equal().
3202  *
3203  * Since: 2.44
3204  */
3205 gboolean
3206 g_strv_contains (const gchar * const *strv,
3207                  const gchar         *str)
3208 {
3209   g_return_val_if_fail (strv != NULL, FALSE);
3210   g_return_val_if_fail (str != NULL, FALSE);
3211 
3212   for (; *strv != NULL; strv++)
3213     {
3214       if (g_str_equal (str, *strv))
3215         return TRUE;
3216     }
3217 
3218   return FALSE;
3219 }
3220 
<a name="10" id="anc10"></a><span class="line-added">3221 /**</span>
<span class="line-added">3222  * g_strv_equal:</span>
<span class="line-added">3223  * @strv1: a %NULL-terminated array of strings</span>
<span class="line-added">3224  * @strv2: another %NULL-terminated array of strings</span>
<span class="line-added">3225  *</span>
<span class="line-added">3226  * Checks if @strv1 and @strv2 contain exactly the same elements in exactly the</span>
<span class="line-added">3227  * same order. Elements are compared using g_str_equal(). To match independently</span>
<span class="line-added">3228  * of order, sort the arrays first (using g_qsort_with_data() or similar).</span>
<span class="line-added">3229  *</span>
<span class="line-added">3230  * Two empty arrays are considered equal. Neither @strv1 not @strv2 may be</span>
<span class="line-added">3231  * %NULL.</span>
<span class="line-added">3232  *</span>
<span class="line-added">3233  * Returns: %TRUE if @strv1 and @strv2 are equal</span>
<span class="line-added">3234  * Since: 2.60</span>
<span class="line-added">3235  */</span>
<span class="line-added">3236 gboolean</span>
<span class="line-added">3237 g_strv_equal (const gchar * const *strv1,</span>
<span class="line-added">3238               const gchar * const *strv2)</span>
<span class="line-added">3239 {</span>
<span class="line-added">3240   g_return_val_if_fail (strv1 != NULL, FALSE);</span>
<span class="line-added">3241   g_return_val_if_fail (strv2 != NULL, FALSE);</span>
<span class="line-added">3242 </span>
<span class="line-added">3243   if (strv1 == strv2)</span>
<span class="line-added">3244     return TRUE;</span>
<span class="line-added">3245 </span>
<span class="line-added">3246   for (; *strv1 != NULL &amp;&amp; *strv2 != NULL; strv1++, strv2++)</span>
<span class="line-added">3247     {</span>
<span class="line-added">3248       if (!g_str_equal (*strv1, *strv2))</span>
<span class="line-added">3249         return FALSE;</span>
<span class="line-added">3250     }</span>
<span class="line-added">3251 </span>
<span class="line-added">3252   return (*strv1 == NULL &amp;&amp; *strv2 == NULL);</span>
<span class="line-added">3253 }</span>
<span class="line-added">3254 </span>
3255 static gboolean
3256 str_has_sign (const gchar *str)
3257 {
3258   return str[0] == &#39;-&#39; || str[0] == &#39;+&#39;;
3259 }
3260 
3261 static gboolean
3262 str_has_hex_prefix (const gchar *str)
3263 {
3264   return str[0] == &#39;0&#39; &amp;&amp; g_ascii_tolower (str[1]) == &#39;x&#39;;
3265 }
3266 
3267 /**
3268  * g_ascii_string_to_signed:
3269  * @str: a string
3270  * @base: base of a parsed number
3271  * @min: a lower bound (inclusive)
3272  * @max: an upper bound (inclusive)
3273  * @out_num: (out) (optional): a return location for a number
3274  * @error: a return location for #GError
3275  *
3276  * A convenience function for converting a string to a signed number.
3277  *
3278  * This function assumes that @str contains only a number of the given
3279  * @base that is within inclusive bounds limited by @min and @max. If
3280  * this is true, then the converted number is stored in @out_num. An
3281  * empty string is not a valid input. A string with leading or
3282  * trailing whitespace is also an invalid input.
3283  *
3284  * @base can be between 2 and 36 inclusive. Hexadecimal numbers must
3285  * not be prefixed with &quot;0x&quot; or &quot;0X&quot;. Such a problem does not exist
3286  * for octal numbers, since they were usually prefixed with a zero
3287  * which does not change the value of the parsed number.
3288  *
3289  * Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR
3290  * domain. If the input is invalid, the error code will be
3291  * %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of
3292  * bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
3293  *
3294  * See g_ascii_strtoll() if you have more complex needs such as
3295  * parsing a string which starts with a number, but then has other
3296  * characters.
3297  *
3298  * Returns: %TRUE if @str was a number, otherwise %FALSE.
3299  *
3300  * Since: 2.54
3301  */
3302 gboolean
3303 g_ascii_string_to_signed (const gchar  *str,
3304                           guint         base,
3305                           gint64        min,
3306                           gint64        max,
3307                           gint64       *out_num,
3308                           GError      **error)
3309 {
3310   gint64 number;
3311   const gchar *end_ptr = NULL;
3312   gint saved_errno = 0;
3313 
3314   g_return_val_if_fail (str != NULL, FALSE);
3315   g_return_val_if_fail (base &gt;= 2 &amp;&amp; base &lt;= 36, FALSE);
3316   g_return_val_if_fail (min &lt;= max, FALSE);
3317   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
3318 
3319   if (str[0] == &#39;\0&#39;)
3320     {
3321       g_set_error_literal (error,
3322                            G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_INVALID,
3323                            _(&quot;Empty string is not a number&quot;));
3324       return FALSE;
3325     }
3326 
3327   errno = 0;
3328   number = g_ascii_strtoll (str, (gchar **)&amp;end_ptr, base);
3329   saved_errno = errno;
3330 
3331   if (/* We do not allow leading whitespace, but g_ascii_strtoll
3332        * accepts it and just skips it, so we need to check for it
3333        * ourselves.
3334        */
3335       g_ascii_isspace (str[0]) ||
3336       /* We don&#39;t support hexadecimal numbers prefixed with 0x or
3337        * 0X.
3338        */
3339       (base == 16 &amp;&amp;
3340        (str_has_sign (str) ? str_has_hex_prefix (str + 1) : str_has_hex_prefix (str))) ||
3341       (saved_errno != 0 &amp;&amp; saved_errno != ERANGE) ||
3342       end_ptr == NULL ||
3343       *end_ptr != &#39;\0&#39;)
3344     {
3345       g_set_error (error,
3346                    G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_INVALID,
3347                    _(&quot;&#39;%s&#39; is not a signed number&quot;), str);
3348       return FALSE;
3349     }
3350   if (saved_errno == ERANGE || number &lt; min || number &gt; max)
3351     {
3352       gchar *min_str = g_strdup_printf (&quot;%&quot; G_GINT64_FORMAT, min);
3353       gchar *max_str = g_strdup_printf (&quot;%&quot; G_GINT64_FORMAT, max);
3354 
3355       g_set_error (error,
3356                    G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS,
3357                    _(&quot;Number &#39;%s&#39; is out of bounds [%s, %s]&quot;),
3358                    str, min_str, max_str);
3359       g_free (min_str);
3360       g_free (max_str);
3361       return FALSE;
3362     }
3363   if (out_num != NULL)
3364     *out_num = number;
3365   return TRUE;
3366 }
3367 
3368 /**
3369  * g_ascii_string_to_unsigned:
3370  * @str: a string
3371  * @base: base of a parsed number
3372  * @min: a lower bound (inclusive)
3373  * @max: an upper bound (inclusive)
3374  * @out_num: (out) (optional): a return location for a number
3375  * @error: a return location for #GError
3376  *
3377  * A convenience function for converting a string to an unsigned number.
3378  *
3379  * This function assumes that @str contains only a number of the given
3380  * @base that is within inclusive bounds limited by @min and @max. If
3381  * this is true, then the converted number is stored in @out_num. An
3382  * empty string is not a valid input. A string with leading or
<a name="11" id="anc11"></a><span class="line-modified">3383  * trailing whitespace is also an invalid input. A string with a leading sign</span>
<span class="line-added">3384  * (`-` or `+`) is not a valid input for the unsigned parser.</span>
3385  *
3386  * @base can be between 2 and 36 inclusive. Hexadecimal numbers must
3387  * not be prefixed with &quot;0x&quot; or &quot;0X&quot;. Such a problem does not exist
3388  * for octal numbers, since they were usually prefixed with a zero
3389  * which does not change the value of the parsed number.
3390  *
3391  * Parsing failures result in an error with the %G_NUMBER_PARSER_ERROR
3392  * domain. If the input is invalid, the error code will be
3393  * %G_NUMBER_PARSER_ERROR_INVALID. If the parsed number is out of
3394  * bounds - %G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS.
3395  *
3396  * See g_ascii_strtoull() if you have more complex needs such as
3397  * parsing a string which starts with a number, but then has other
3398  * characters.
3399  *
3400  * Returns: %TRUE if @str was a number, otherwise %FALSE.
3401  *
3402  * Since: 2.54
3403  */
3404 gboolean
3405 g_ascii_string_to_unsigned (const gchar  *str,
3406                             guint         base,
3407                             guint64       min,
3408                             guint64       max,
3409                             guint64      *out_num,
3410                             GError      **error)
3411 {
3412   guint64 number;
3413   const gchar *end_ptr = NULL;
3414   gint saved_errno = 0;
3415 
3416   g_return_val_if_fail (str != NULL, FALSE);
3417   g_return_val_if_fail (base &gt;= 2 &amp;&amp; base &lt;= 36, FALSE);
3418   g_return_val_if_fail (min &lt;= max, FALSE);
3419   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
3420 
3421   if (str[0] == &#39;\0&#39;)
3422     {
3423       g_set_error_literal (error,
3424                            G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_INVALID,
3425                            _(&quot;Empty string is not a number&quot;));
3426       return FALSE;
3427     }
3428 
3429   errno = 0;
3430   number = g_ascii_strtoull (str, (gchar **)&amp;end_ptr, base);
3431   saved_errno = errno;
3432 
3433   if (/* We do not allow leading whitespace, but g_ascii_strtoull
3434        * accepts it and just skips it, so we need to check for it
3435        * ourselves.
3436        */
3437       g_ascii_isspace (str[0]) ||
3438       /* Unsigned number should have no sign.
3439        */
3440       str_has_sign (str) ||
3441       /* We don&#39;t support hexadecimal numbers prefixed with 0x or
3442        * 0X.
3443        */
3444       (base == 16 &amp;&amp; str_has_hex_prefix (str)) ||
3445       (saved_errno != 0 &amp;&amp; saved_errno != ERANGE) ||
3446       end_ptr == NULL ||
3447       *end_ptr != &#39;\0&#39;)
3448     {
3449       g_set_error (error,
3450                    G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_INVALID,
3451                    _(&quot;&#39;%s&#39; is not an unsigned number&quot;), str);
3452       return FALSE;
3453     }
3454   if (saved_errno == ERANGE || number &lt; min || number &gt; max)
3455     {
3456       gchar *min_str = g_strdup_printf (&quot;%&quot; G_GUINT64_FORMAT, min);
3457       gchar *max_str = g_strdup_printf (&quot;%&quot; G_GUINT64_FORMAT, max);
3458 
3459       g_set_error (error,
3460                    G_NUMBER_PARSER_ERROR, G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS,
3461                    _(&quot;Number &#39;%s&#39; is out of bounds [%s, %s]&quot;),
3462                    str, min_str, max_str);
3463       g_free (min_str);
3464       g_free (max_str);
3465       return FALSE;
3466     }
3467   if (out_num != NULL)
3468     *out_num = number;
3469   return TRUE;
3470 }
3471 
3472 G_DEFINE_QUARK (g-number-parser-error-quark, g_number_parser_error)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>