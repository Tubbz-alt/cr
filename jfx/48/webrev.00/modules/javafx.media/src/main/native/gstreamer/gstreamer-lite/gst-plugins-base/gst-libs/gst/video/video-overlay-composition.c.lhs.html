<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer Video Overlay Composition
   2  * Copyright (C) 2011 Intel Corporation
   3  * Copyright (C) 2011 Collabora Ltd.
   4  * Copyright (C) 2011 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstvideooverlaycomposition
  24  * @title: GstVideoOverlayRectangle
  25  * @short_description: Video Buffer Overlay Compositions (Subtitles, Logos)
  26  *
  27  * Functions to create and handle overlay compositions on video buffers.
  28  *
  29  * An overlay composition describes one or more overlay rectangles to be
  30  * blended on top of a video buffer.
  31  *
  32  * This API serves two main purposes:
  33  *
  34  * * it can be used to attach overlay information (subtitles or logos)
  35  *   to non-raw video buffers such as GL/VAAPI/VDPAU surfaces. The actual
  36  *   blending of the overlay can then be done by e.g. the video sink that
  37  *   processes these non-raw buffers.
  38  *
  39  * * it can also be used to blend overlay rectangles on top of raw video
  40  *   buffers, thus consolidating blending functionality for raw video in
  41  *   one place.
  42  *
  43  * Together, this allows existing overlay elements to easily handle raw
  44  * and non-raw video as input in without major changes (once the overlays
<a name="1" id="anc1"></a><span class="line-modified">  45  * have been put into a #GstOverlayComposition object anyway) - for raw</span>
  46  * video the overlay can just use the blending function to blend the data
  47  * on top of the video, and for surface buffers it can just attach them to
  48  * the buffer and let the sink render the overlays.
  49  *
  50  */
  51 
  52 /* TODO:
  53  *  - provide accessors for seq_num and other fields (as needed)
  54  *  - allow overlay to set/get original pango markup string on/from rectangle
  55  */
  56 
  57 #ifdef HAVE_CONFIG_H
  58 #include &quot;config.h&quot;
  59 #endif
  60 
  61 #include &quot;video-overlay-composition.h&quot;
  62 #include &quot;video-blend.h&quot;
  63 #include &quot;gstvideometa.h&quot;
  64 #include &lt;string.h&gt;
  65 
  66 struct _GstVideoOverlayComposition
  67 {
  68   GstMiniObject parent;
  69 
  70   guint num_rectangles;
  71   GstVideoOverlayRectangle **rectangles;
  72 
  73   /* lowest rectangle sequence number still used by the upstream
  74    * overlay element. This way a renderer maintaining some kind of
  75    * rectangles &lt;-&gt; surface cache can know when to free cached
  76    * surfaces/rectangles. */
  77   guint min_seq_num_used;
  78 
  79   /* sequence number for the composition (same series as rectangles) */
  80   guint seq_num;
  81 };
  82 
  83 struct _GstVideoOverlayRectangle
  84 {
  85   GstMiniObject parent;
  86 
  87   /* Position on video frame and dimension of output rectangle in
  88    * output frame terms (already adjusted for the PAR of the output
  89    * frame). x/y can be negative (overlay will be clipped then) */
  90   gint x, y;
  91   guint render_width, render_height;
  92 
  93   /* Info on overlay pixels (format, width, height) */
  94   GstVideoInfo info;
  95 
  96   /* The flags associated to this rectangle */
  97   GstVideoOverlayFormatFlags flags;
  98 
  99   /* Refcounted blob of memory, no caps or timestamps */
 100   GstBuffer *pixels;
 101 
 102   /* FIXME: how to express source like text or pango markup?
 103    *        (just add source type enum + source buffer with data)
 104    *
 105    * FOR 0.10: always send pixel blobs, but attach source data in
 106    * addition (reason: if downstream changes, we can&#39;t renegotiate
 107    * that properly, if we just do a query of supported formats from
 108    * the start). Sink will just ignore pixels and use pango markup
 109    * from source data if it supports that.
 110    *
 111    * FOR 0.11: overlay should query formats (pango markup, pixels)
 112    * supported by downstream and then only send that. We can
 113    * renegotiate via the reconfigure event.
 114    */
 115 
 116   /* sequence number: useful for backends/renderers/sinks that want
 117    * to maintain a cache of rectangles &lt;-&gt; surfaces. The value of
 118    * the min_seq_num_used in the composition tells the renderer which
 119    * rectangles have expired. */
 120   guint seq_num;
 121 
 122   /* global alpha: global alpha value of the rectangle. Each each per-pixel
 123    * alpha value of image-data will be multiplied with the global alpha value
 124    * during blending.
 125    * Can be used for efficient fading in/out of overlay rectangles.
 126    * GstElements that render OverlayCompositions and don&#39;t support global alpha
 127    * should simply ignore it.*/
 128   gfloat global_alpha;
 129 
 130   /* track alpha-values already applied: */
 131   gfloat applied_global_alpha;
 132   /* store initial per-pixel alpha values: */
 133   guint8 *initial_alpha;
 134 
 135   /* FIXME: we may also need a (private) way to cache converted/scaled
 136    * pixel blobs */
 137   GMutex lock;
 138 
 139   GList *scaled_rectangles;
 140 };
 141 
 142 #define GST_RECTANGLE_LOCK(rect)   g_mutex_lock(&amp;rect-&gt;lock)
 143 #define GST_RECTANGLE_UNLOCK(rect) g_mutex_unlock(&amp;rect-&gt;lock)
 144 
 145 /* --------------------------- utility functions --------------------------- */
 146 
 147 #ifndef GST_DISABLE_GST_DEBUG
 148 
 149 #define GST_CAT_DEFAULT ensure_debug_category()
 150 
 151 static GstDebugCategory *
 152 ensure_debug_category (void)
 153 {
 154   static gsize cat_gonce = 0;
 155 
 156   if (g_once_init_enter (&amp;cat_gonce)) {
 157     gsize cat_done;
 158 
 159     cat_done = (gsize) _gst_debug_category_new (&quot;video-composition&quot;, 0,
 160         &quot;video overlay composition&quot;);
 161 
 162     g_once_init_leave (&amp;cat_gonce, cat_done);
 163   }
 164 
 165   return (GstDebugCategory *) cat_gonce;
 166 }
 167 
 168 #else
 169 
 170 #define ensure_debug_category() /* NOOP */
 171 
 172 #endif /* GST_DISABLE_GST_DEBUG */
 173 
 174 static guint
 175 gst_video_overlay_get_seqnum (void)
 176 {
 177   static gint seqnum;           /* 0 */
 178 
 179   return (guint) g_atomic_int_add (&amp;seqnum, 1);
 180 }
 181 
 182 static gboolean
 183 gst_video_overlay_composition_meta_init (GstMeta * meta, gpointer params,
 184     GstBuffer * buf)
 185 {
 186   GstVideoOverlayCompositionMeta *ometa;
 187 
 188   ometa = (GstVideoOverlayCompositionMeta *) meta;
 189 
 190   ometa-&gt;overlay = NULL;
 191 
 192   return TRUE;
 193 }
 194 
 195 static void
 196 gst_video_overlay_composition_meta_free (GstMeta * meta, GstBuffer * buf)
 197 {
 198   GstVideoOverlayCompositionMeta *ometa;
 199 
 200   ometa = (GstVideoOverlayCompositionMeta *) meta;
 201 
 202   if (ometa-&gt;overlay)
 203     gst_video_overlay_composition_unref (ometa-&gt;overlay);
 204 }
 205 
 206 static gboolean
 207 gst_video_overlay_composition_meta_transform (GstBuffer * dest, GstMeta * meta,
 208     GstBuffer * buffer, GQuark type, gpointer data)
 209 {
 210   GstVideoOverlayCompositionMeta *dmeta, *smeta;
 211 
 212   smeta = (GstVideoOverlayCompositionMeta *) meta;
 213 
 214   if (GST_META_TRANSFORM_IS_COPY (type)) {
 215     GstMetaTransformCopy *copy = data;
 216 
 217     if (!copy-&gt;region) {
 218       GST_DEBUG (&quot;copy video overlay composition metadata&quot;);
 219 
 220       /* only copy if the complete data is copied as well */
 221       dmeta =
 222           (GstVideoOverlayCompositionMeta *) gst_buffer_add_meta (dest,
 223           GST_VIDEO_OVERLAY_COMPOSITION_META_INFO, NULL);
 224       if (!dmeta)
 225         return FALSE;
 226 
 227       dmeta-&gt;overlay = gst_video_overlay_composition_ref (smeta-&gt;overlay);
 228     }
 229   } else {
 230     /* return FALSE, if transform type is not supported */
 231     return FALSE;
 232   }
 233   return TRUE;
 234 }
 235 
 236 GType
 237 gst_video_overlay_composition_meta_api_get_type (void)
 238 {
 239   static volatile GType type = 0;
 240   static const gchar *tags[] = { NULL };
 241 
 242   if (g_once_init_enter (&amp;type)) {
 243     GType _type =
 244         gst_meta_api_type_register (&quot;GstVideoOverlayCompositionMetaAPI&quot;, tags);
 245     g_once_init_leave (&amp;type, _type);
 246   }
 247   return type;
 248 }
 249 
 250 /* video overlay composition metadata */
 251 const GstMetaInfo *
 252 gst_video_overlay_composition_meta_get_info (void)
 253 {
 254   static const GstMetaInfo *video_overlay_composition_meta_info = NULL;
 255 
 256   if (g_once_init_enter ((GstMetaInfo **) &amp;
 257           video_overlay_composition_meta_info)) {
 258     const GstMetaInfo *meta =
 259         gst_meta_register (GST_VIDEO_OVERLAY_COMPOSITION_META_API_TYPE,
 260         &quot;GstVideoOverlayCompositionMeta&quot;,
 261         sizeof (GstVideoOverlayCompositionMeta),
 262         (GstMetaInitFunction) gst_video_overlay_composition_meta_init,
 263         (GstMetaFreeFunction) gst_video_overlay_composition_meta_free,
 264         (GstMetaTransformFunction)
 265         gst_video_overlay_composition_meta_transform);
 266     g_once_init_leave ((GstMetaInfo **) &amp; video_overlay_composition_meta_info,
 267         (GstMetaInfo *) meta);
 268   }
 269   return video_overlay_composition_meta_info;
 270 }
 271 
 272 /**
 273  * gst_buffer_add_video_overlay_composition_meta:
 274  * @buf: a #GstBuffer
 275  * @comp: (allow-none): a #GstVideoOverlayComposition
 276  *
 277  * Sets an overlay composition on a buffer. The buffer will obtain its own
 278  * reference to the composition, meaning this function does not take ownership
 279  * of @comp.
 280  *
 281  * Returns: (transfer none): a #GstVideoOverlayCompositionMeta
 282  */
 283 GstVideoOverlayCompositionMeta *
 284 gst_buffer_add_video_overlay_composition_meta (GstBuffer * buf,
 285     GstVideoOverlayComposition * comp)
 286 {
 287   GstVideoOverlayCompositionMeta *ometa;
 288 
 289   g_return_val_if_fail (gst_buffer_is_writable (buf), NULL);
 290 
 291   ometa = (GstVideoOverlayCompositionMeta *)
 292       gst_buffer_add_meta (buf, GST_VIDEO_OVERLAY_COMPOSITION_META_INFO, NULL);
 293 
 294   ometa-&gt;overlay = gst_video_overlay_composition_ref (comp);
 295 
 296   return ometa;
 297 }
 298 
 299 /* ------------------------------ composition ------------------------------ */
 300 
 301 #define RECTANGLE_ARRAY_STEP 4  /* premature optimization */
 302 
 303 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayComposition,
 304     gst_video_overlay_composition);
 305 
 306 static void
 307 gst_video_overlay_composition_free (GstMiniObject * mini_obj)
 308 {
 309   GstVideoOverlayComposition *comp = (GstVideoOverlayComposition *) mini_obj;
 310   guint num;
 311 
 312   num = comp-&gt;num_rectangles;
 313 
 314   while (num &gt; 0) {
<a name="2" id="anc2"></a>

 315     gst_video_overlay_rectangle_unref (comp-&gt;rectangles[num - 1]);
 316     --num;
 317   }
 318 
 319   g_free (comp-&gt;rectangles);
 320   comp-&gt;rectangles = NULL;
 321   comp-&gt;num_rectangles = 0;
 322 
 323   g_slice_free (GstVideoOverlayComposition, comp);
 324 }
 325 
 326 /**
 327  * gst_video_overlay_composition_new:
 328  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 329  *     composition
 330  *
 331  * Creates a new video overlay composition object to hold one or more
 332  * overlay rectangles.
 333  *
 334  * Returns: (transfer full): a new #GstVideoOverlayComposition. Unref with
 335  *     gst_video_overlay_composition_unref() when no longer needed.
 336  */
 337 GstVideoOverlayComposition *
 338 gst_video_overlay_composition_new (GstVideoOverlayRectangle * rectangle)
 339 {
 340   GstVideoOverlayComposition *comp;
 341 
 342 
 343   /* FIXME: should we allow empty compositions? Could also be expressed as
 344    * buffer without a composition on it. Maybe there are cases where doing
 345    * an empty new + _add() in a loop is easier? */
 346   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
 347 
 348   comp = g_slice_new0 (GstVideoOverlayComposition);
 349 
 350   gst_mini_object_init (GST_MINI_OBJECT_CAST (comp), 0,
 351       GST_TYPE_VIDEO_OVERLAY_COMPOSITION,
 352       (GstMiniObjectCopyFunction) gst_video_overlay_composition_copy,
 353       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_composition_free);
 354 
 355   comp-&gt;rectangles = g_new0 (GstVideoOverlayRectangle *, RECTANGLE_ARRAY_STEP);
 356   comp-&gt;rectangles[0] = gst_video_overlay_rectangle_ref (rectangle);
<a name="3" id="anc3"></a>

 357   comp-&gt;num_rectangles = 1;
 358 
 359   comp-&gt;seq_num = gst_video_overlay_get_seqnum ();
 360 
 361   /* since the rectangle was created earlier, its seqnum is smaller than ours */
 362   comp-&gt;min_seq_num_used = rectangle-&gt;seq_num;
 363 
 364   GST_LOG (&quot;new composition %p: seq_num %u with rectangle %p&quot;, comp,
 365       comp-&gt;seq_num, rectangle);
 366 
 367   return comp;
 368 }
 369 
 370 /**
 371  * gst_video_overlay_composition_add_rectangle:
 372  * @comp: a #GstVideoOverlayComposition
 373  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 374  *     composition
 375  *
 376  * Adds an overlay rectangle to an existing overlay composition object. This
 377  * must be done right after creating the overlay composition.
 378  */
 379 void
 380 gst_video_overlay_composition_add_rectangle (GstVideoOverlayComposition * comp,
 381     GstVideoOverlayRectangle * rectangle)
 382 {
 383   g_return_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp));
 384   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<a name="4" id="anc4"></a><span class="line-modified"> 385   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1);</span>
 386 
 387   if (comp-&gt;num_rectangles % RECTANGLE_ARRAY_STEP == 0) {
 388     comp-&gt;rectangles =
 389         g_renew (GstVideoOverlayRectangle *, comp-&gt;rectangles,
 390         comp-&gt;num_rectangles + RECTANGLE_ARRAY_STEP);
 391   }
 392 
 393   comp-&gt;rectangles[comp-&gt;num_rectangles] =
 394       gst_video_overlay_rectangle_ref (rectangle);
<a name="5" id="anc5"></a>

 395   comp-&gt;num_rectangles += 1;
 396 
 397   comp-&gt;min_seq_num_used = MIN (comp-&gt;min_seq_num_used, rectangle-&gt;seq_num);
 398 
 399   GST_LOG (&quot;composition %p: added rectangle %p&quot;, comp, rectangle);
 400 }
 401 
 402 /**
 403  * gst_video_overlay_composition_n_rectangles:
 404  * @comp: a #GstVideoOverlayComposition
 405  *
 406  * Returns the number of #GstVideoOverlayRectangle&lt;!-- --&gt;s contained in @comp.
 407  *
 408  * Returns: the number of rectangles
 409  */
 410 guint
 411 gst_video_overlay_composition_n_rectangles (GstVideoOverlayComposition * comp)
 412 {
 413   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 414 
 415   return comp-&gt;num_rectangles;
 416 }
 417 
 418 /**
 419  * gst_video_overlay_composition_get_rectangle:
 420  * @comp: a #GstVideoOverlayComposition
 421  * @n: number of the rectangle to get
 422  *
 423  * Returns the @n-th #GstVideoOverlayRectangle contained in @comp.
 424  *
 425  * Returns: (transfer none): the @n-th rectangle, or NULL if @n is out of
 426  *     bounds. Will not return a new reference, the caller will need to
 427  *     obtain her own reference using gst_video_overlay_rectangle_ref()
 428  *     if needed.
 429  */
 430 GstVideoOverlayRectangle *
 431 gst_video_overlay_composition_get_rectangle (GstVideoOverlayComposition * comp,
 432     guint n)
 433 {
 434   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 435 
 436   if (n &gt;= comp-&gt;num_rectangles)
 437     return NULL;
 438 
 439   return comp-&gt;rectangles[n];
 440 }
 441 
 442 static gboolean
 443 gst_video_overlay_rectangle_needs_scaling (GstVideoOverlayRectangle * r)
 444 {
 445   return (GST_VIDEO_INFO_WIDTH (&amp;r-&gt;info) != r-&gt;render_width ||
 446       GST_VIDEO_INFO_HEIGHT (&amp;r-&gt;info) != r-&gt;render_height);
 447 }
 448 
 449 /**
 450  * gst_video_overlay_composition_blend:
 451  * @comp: a #GstVideoOverlayComposition
 452  * @video_buf: a #GstVideoFrame containing raw video data in a
 453  *             supported format. It should be mapped using GST_MAP_READWRITE
 454  *
 455  * Blends the overlay rectangles in @comp on top of the raw video data
 456  * contained in @video_buf. The data in @video_buf must be writable and
 457  * mapped appropriately.
 458  *
 459  * Since @video_buf data is read and will be modified, it ought be
 460  * mapped with flag GST_MAP_READWRITE.
 461  */
 462 /* FIXME: formats with more than 8 bit per component which get unpacked into
 463  * ARGB64 or AYUV64 (such as v210, v216, UYVP, GRAY16_LE and GRAY16_BE)
 464  * are not supported yet by the code in video-blend.c.
 465  */
 466 gboolean
 467 gst_video_overlay_composition_blend (GstVideoOverlayComposition * comp,
 468     GstVideoFrame * video_buf)
 469 {
 470   GstVideoInfo scaled_info;
 471   GstVideoInfo *vinfo;
 472   GstVideoFrame rectangle_frame;
 473   GstVideoFormat fmt;
 474   GstBuffer *pixels = NULL;
 475   gboolean ret = TRUE;
 476   guint n, num;
 477   int w, h;
 478 
 479   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), FALSE);
 480   g_return_val_if_fail (video_buf != NULL, FALSE);
 481 
 482   w = GST_VIDEO_FRAME_WIDTH (video_buf);
 483   h = GST_VIDEO_FRAME_HEIGHT (video_buf);
 484   fmt = GST_VIDEO_FRAME_FORMAT (video_buf);
 485 
 486   num = comp-&gt;num_rectangles;
 487   GST_LOG (&quot;Blending composition %p with %u rectangles onto video buffer %p &quot;
 488       &quot;(%ux%u, format %u)&quot;, comp, num, video_buf, w, h, fmt);
 489 
 490   for (n = 0; n &lt; num; ++n) {
 491     GstVideoOverlayRectangle *rect;
 492     gboolean needs_scaling;
 493 
 494     rect = comp-&gt;rectangles[n];
 495 
 496     GST_LOG (&quot; rectangle %u %p: %ux%u, format %u&quot;, n, rect,
 497         GST_VIDEO_INFO_WIDTH (&amp;rect-&gt;info), GST_VIDEO_INFO_HEIGHT (&amp;rect-&gt;info),
 498         GST_VIDEO_INFO_FORMAT (&amp;rect-&gt;info));
 499 
 500     needs_scaling = gst_video_overlay_rectangle_needs_scaling (rect);
 501     if (needs_scaling) {
 502       gst_video_blend_scale_linear_RGBA (&amp;rect-&gt;info, rect-&gt;pixels,
 503           rect-&gt;render_height, rect-&gt;render_width, &amp;scaled_info, &amp;pixels);
 504       vinfo = &amp;scaled_info;
 505     } else {
 506       pixels = gst_buffer_ref (rect-&gt;pixels);
 507       vinfo = &amp;rect-&gt;info;
 508     }
 509 
 510     gst_video_frame_map (&amp;rectangle_frame, vinfo, pixels, GST_MAP_READ);
 511 
 512     ret = gst_video_blend (video_buf, &amp;rectangle_frame, rect-&gt;x, rect-&gt;y,
 513         rect-&gt;global_alpha);
 514     gst_video_frame_unmap (&amp;rectangle_frame);
 515     if (!ret) {
 516       GST_WARNING (&quot;Could not blend overlay rectangle onto video buffer&quot;);
 517     }
 518 
 519     /* FIXME: should cache scaled pixels in the rectangle struct */
 520     gst_buffer_unref (pixels);
 521   }
 522 
 523   return ret;
 524 }
 525 
 526 /**
 527  * gst_video_overlay_composition_copy:
 528  * @comp: (transfer none): a #GstVideoOverlayComposition to copy
 529  *
 530  * Makes a copy of @comp and all contained rectangles, so that it is possible
 531  * to modify the composition and contained rectangles (e.g. add additional
 532  * rectangles or change the render co-ordinates or render dimension). The
 533  * actual overlay pixel data buffers contained in the rectangles are not
 534  * copied.
 535  *
 536  * Returns: (transfer full): a new #GstVideoOverlayComposition equivalent
 537  *     to @comp.
 538  */
 539 GstVideoOverlayComposition *
 540 gst_video_overlay_composition_copy (GstVideoOverlayComposition * comp)
 541 {
 542   GstVideoOverlayComposition *copy;
 543   GstVideoOverlayRectangle *rect;
 544   guint n;
 545 
 546   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 547 
 548   if (G_LIKELY (comp-&gt;num_rectangles == 0))
 549     return gst_video_overlay_composition_new (NULL);
 550 
 551   rect = gst_video_overlay_rectangle_copy (comp-&gt;rectangles[0]);
 552   copy = gst_video_overlay_composition_new (rect);
 553   gst_video_overlay_rectangle_unref (rect);
 554 
 555   for (n = 1; n &lt; comp-&gt;num_rectangles; ++n) {
 556     rect = gst_video_overlay_rectangle_copy (comp-&gt;rectangles[n]);
 557     gst_video_overlay_composition_add_rectangle (copy, rect);
 558     gst_video_overlay_rectangle_unref (rect);
 559   }
 560 
 561   return copy;
 562 }
 563 
 564 /**
 565  * gst_video_overlay_composition_make_writable:
 566  * @comp: (transfer full): a #GstVideoOverlayComposition to copy
 567  *
 568  * Takes ownership of @comp and returns a version of @comp that is writable
 569  * (i.e. can be modified). Will either return @comp right away, or create a
 570  * new writable copy of @comp and unref @comp itself. All the contained
 571  * rectangles will also be copied, but the actual overlay pixel data buffers
 572  * contained in the rectangles are not copied.
 573  *
 574  * Returns: (transfer full): a writable #GstVideoOverlayComposition
 575  *     equivalent to @comp.
 576  */
 577 GstVideoOverlayComposition *
 578 gst_video_overlay_composition_make_writable (GstVideoOverlayComposition * comp)
 579 {
 580   GstVideoOverlayComposition *writable_comp;
 581 
 582   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 583 
<a name="6" id="anc6"></a><span class="line-modified"> 584   if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1) {</span>
 585     guint n;
 586 
 587     for (n = 0; n &lt; comp-&gt;num_rectangles; ++n) {
<a name="7" id="anc7"></a><span class="line-modified"> 588       if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp-&gt;rectangles[n]) != 1)</span>

 589         goto copy;
 590     }
 591     return comp;
 592   }
 593 
 594 copy:
 595 
 596   writable_comp = gst_video_overlay_composition_copy (comp);
 597   gst_video_overlay_composition_unref (comp);
 598 
 599   return writable_comp;
 600 }
 601 
 602 /**
 603  * gst_video_overlay_composition_get_seqnum:
 604  * @comp: a #GstVideoOverlayComposition
 605  *
 606  * Returns the sequence number of this composition. Sequence numbers are
 607  * monotonically increasing and unique for overlay compositions and rectangles
 608  * (meaning there will never be a rectangle with the same sequence number as
 609  * a composition).
 610  *
 611  * Returns: the sequence number of @comp
 612  */
 613 guint
 614 gst_video_overlay_composition_get_seqnum (GstVideoOverlayComposition * comp)
 615 {
 616   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 617 
 618   return comp-&gt;seq_num;
 619 }
 620 
 621 /* ------------------------------ rectangles ------------------------------ -*/
 622 
 623 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayRectangle,
 624     gst_video_overlay_rectangle);
 625 
 626 static void
 627 gst_video_overlay_rectangle_free (GstMiniObject * mini_obj)
 628 {
 629   GstVideoOverlayRectangle *rect = (GstVideoOverlayRectangle *) mini_obj;
 630 
<a name="8" id="anc8"></a>

 631   gst_buffer_replace (&amp;rect-&gt;pixels, NULL);
 632 
 633   while (rect-&gt;scaled_rectangles != NULL) {
 634     GstVideoOverlayRectangle *scaled_rect = rect-&gt;scaled_rectangles-&gt;data;
 635 
 636     gst_video_overlay_rectangle_unref (scaled_rect);
 637 
 638     rect-&gt;scaled_rectangles =
 639         g_list_delete_link (rect-&gt;scaled_rectangles, rect-&gt;scaled_rectangles);
 640   }
 641 
 642   g_free (rect-&gt;initial_alpha);
 643   g_mutex_clear (&amp;rect-&gt;lock);
 644 
 645   g_slice_free (GstVideoOverlayRectangle, rect);
 646 }
 647 
 648 static inline gboolean
 649 gst_video_overlay_rectangle_check_flags (GstVideoOverlayFormatFlags flags)
 650 {
 651   /* Check flags only contains flags we know about */
 652   return (flags &amp; ~(GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA |
 653           GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)) == 0;
 654 }
 655 
 656 static gboolean
 657 gst_video_overlay_rectangle_is_same_alpha_type (GstVideoOverlayFormatFlags
 658     flags1, GstVideoOverlayFormatFlags flags2)
 659 {
 660   return ((flags1 ^ flags2) &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)
 661       == 0;
 662 }
 663 
 664 
 665 /**
 666  * gst_video_overlay_rectangle_new_raw:
 667  * @pixels: (transfer none): a #GstBuffer pointing to the pixel memory
 668  * @render_x: the X co-ordinate on the video where the top-left corner of this
 669  *     overlay rectangle should be rendered to
 670  * @render_y: the Y co-ordinate on the video where the top-left corner of this
 671  *     overlay rectangle should be rendered to
 672  * @render_width: the render width of this rectangle on the video
 673  * @render_height: the render height of this rectangle on the video
 674  * @flags: flags
 675  *
 676  * Creates a new video overlay rectangle with ARGB or AYUV pixel data.
 677  * The layout in case of ARGB of the components in memory is B-G-R-A
 678  * on little-endian platforms
 679  * (corresponding to #GST_VIDEO_FORMAT_BGRA) and A-R-G-B on big-endian
 680  * platforms (corresponding to #GST_VIDEO_FORMAT_ARGB). In other words,
 681  * pixels are treated as 32-bit words and the lowest 8 bits then contain
 682  * the blue component value and the highest 8 bits contain the alpha
 683  * component value. Unless specified in the flags, the RGB values are
 684  * non-premultiplied. This is the format that is used by most hardware,
 685  * and also many rendering libraries such as Cairo, for example.
 686  * The pixel data buffer must have #GstVideoMeta set.
 687  *
 688  * Returns: (transfer full): a new #GstVideoOverlayRectangle. Unref with
 689  *     gst_video_overlay_rectangle_unref() when no longer needed.
 690  */
 691 GstVideoOverlayRectangle *
 692 gst_video_overlay_rectangle_new_raw (GstBuffer * pixels,
 693     gint render_x, gint render_y, guint render_width, guint render_height,
 694     GstVideoOverlayFormatFlags flags)
 695 {
 696   GstVideoOverlayRectangle *rect;
 697   GstVideoMeta *vmeta;
 698   GstVideoFormat format;
 699   guint width, height;
 700 
 701   g_return_val_if_fail (GST_IS_BUFFER (pixels), NULL);
 702   g_return_val_if_fail (render_height &gt; 0 &amp;&amp; render_width &gt; 0, NULL);
 703   g_return_val_if_fail (gst_video_overlay_rectangle_check_flags (flags), NULL);
 704 
 705   /* buffer must have video meta with some expected settings */
 706   vmeta = gst_buffer_get_video_meta (pixels);
 707   g_return_val_if_fail (vmeta, NULL);
 708   g_return_val_if_fail (vmeta-&gt;format ==
 709       GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_RGB ||
 710       vmeta-&gt;format == GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_YUV, NULL);
 711   g_return_val_if_fail (vmeta-&gt;flags == GST_VIDEO_FRAME_FLAG_NONE, NULL);
 712 
 713   format = vmeta-&gt;format;
 714   width = vmeta-&gt;width;
 715   height = vmeta-&gt;height;
 716 
 717   /* technically ((height-1)*stride)+width might be okay too */
 718   g_return_val_if_fail (gst_buffer_get_size (pixels) &gt;= height * width * 4,
 719       NULL);
 720   g_return_val_if_fail (height &gt; 0 &amp;&amp; width &gt; 0, NULL);
 721 
 722   rect = g_slice_new0 (GstVideoOverlayRectangle);
 723 
 724   gst_mini_object_init (GST_MINI_OBJECT_CAST (rect), 0,
 725       GST_TYPE_VIDEO_OVERLAY_RECTANGLE,
 726       (GstMiniObjectCopyFunction) gst_video_overlay_rectangle_copy,
 727       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_rectangle_free);
 728 
 729   g_mutex_init (&amp;rect-&gt;lock);
 730 
 731   rect-&gt;pixels = gst_buffer_ref (pixels);
<a name="9" id="anc9"></a>

 732   rect-&gt;scaled_rectangles = NULL;
 733 
 734   gst_video_info_init (&amp;rect-&gt;info);
 735   if (!gst_video_info_set_format (&amp;rect-&gt;info, format, width, height)) {
 736     gst_mini_object_unref (GST_MINI_OBJECT_CAST (rect));
 737     return NULL;
 738   }
 739   if (flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)
 740     rect-&gt;info.flags |= GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA;
 741 
 742   rect-&gt;x = render_x;
 743   rect-&gt;y = render_y;
 744   rect-&gt;render_width = render_width;
 745   rect-&gt;render_height = render_height;
 746 
 747   rect-&gt;global_alpha = 1.0;
 748   rect-&gt;applied_global_alpha = 1.0;
 749   rect-&gt;initial_alpha = NULL;
 750 
 751   rect-&gt;flags = flags;
 752 
 753   rect-&gt;seq_num = gst_video_overlay_get_seqnum ();
 754 
 755   GST_LOG (&quot;new rectangle %p: %ux%u =&gt; %ux%u @ %u,%u, seq_num %u, format %u, &quot;
 756       &quot;flags %x, pixels %p, global_alpha=%f&quot;, rect, width, height, render_width,
 757       render_height, render_x, render_y, rect-&gt;seq_num, format,
 758       rect-&gt;flags, pixels, rect-&gt;global_alpha);
 759 
 760   return rect;
 761 }
 762 
 763 /**
 764  * gst_video_overlay_rectangle_get_render_rectangle:
 765  * @rectangle: a #GstVideoOverlayRectangle
 766  * @render_x: (out) (allow-none): address where to store the X render offset
 767  * @render_y: (out) (allow-none): address where to store the Y render offset
 768  * @render_width: (out) (allow-none): address where to store the render width
 769  * @render_height: (out) (allow-none): address where to store the render height
 770  *
 771  * Retrieves the render position and render dimension of the overlay
 772  * rectangle on the video.
 773  *
 774  * Returns: TRUE if valid render dimensions were retrieved.
 775  */
 776 gboolean
 777 gst_video_overlay_rectangle_get_render_rectangle (GstVideoOverlayRectangle *
 778     rectangle, gint * render_x, gint * render_y, guint * render_width,
 779     guint * render_height)
 780 {
 781   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), FALSE);
 782 
 783   if (render_x)
 784     *render_x = rectangle-&gt;x;
 785   if (render_y)
 786     *render_y = rectangle-&gt;y;
 787   if (render_width)
 788     *render_width = rectangle-&gt;render_width;
 789   if (render_height)
 790     *render_height = rectangle-&gt;render_height;
 791 
 792   return TRUE;
 793 }
 794 
 795 /**
 796  * gst_video_overlay_rectangle_set_render_rectangle:
 797  * @rectangle: a #GstVideoOverlayRectangle
 798  * @render_x: render X position of rectangle on video
 799  * @render_y: render Y position of rectangle on video
 800  * @render_width: render width of rectangle
 801  * @render_height: render height of rectangle
 802  *
 803  * Sets the render position and dimensions of the rectangle on the video.
 804  * This function is mainly for elements that modify the size of the video
 805  * in some way (e.g. through scaling or cropping) and need to adjust the
 806  * details of any overlays to match the operation that changed the size.
 807  *
 808  * @rectangle must be writable, meaning its refcount must be 1. You can
 809  * make the rectangles inside a #GstVideoOverlayComposition writable using
 810  * gst_video_overlay_composition_make_writable() or
 811  * gst_video_overlay_composition_copy().
 812  */
 813 void
 814 gst_video_overlay_rectangle_set_render_rectangle (GstVideoOverlayRectangle *
 815     rectangle, gint render_x, gint render_y, guint render_width,
 816     guint render_height)
 817 {
 818   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<a name="10" id="anc10"></a><span class="line-modified"> 819   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (rectangle) == 1);</span>

 820 
 821   rectangle-&gt;x = render_x;
 822   rectangle-&gt;y = render_y;
 823   rectangle-&gt;render_width = render_width;
 824   rectangle-&gt;render_height = render_height;
 825 }
 826 
 827 /* FIXME: orc-ify */
 828 static void
 829 gst_video_overlay_rectangle_premultiply_0 (GstVideoFrame * frame)
 830 {
 831   int i, j;
<a name="11" id="anc11"></a><span class="line-modified"> 832   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 833     guint8 *line;
 834 
<a name="12" id="anc12"></a><span class="line-modified"> 835     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 836     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 837     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 838       int a = line[0];
 839       line[1] = line[1] * a / 255;
 840       line[2] = line[2] * a / 255;
 841       line[3] = line[3] * a / 255;
 842       line += 4;
 843     }
 844   }
 845 }
 846 
 847 static void
 848 gst_video_overlay_rectangle_premultiply_3 (GstVideoFrame * frame)
 849 {
 850   int i, j;
<a name="13" id="anc13"></a><span class="line-modified"> 851   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 852     guint8 *line;
 853 
<a name="14" id="anc14"></a><span class="line-modified"> 854     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 855     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 856     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 857       int a = line[3];
 858       line[0] = line[0] * a / 255;
 859       line[1] = line[1] * a / 255;
 860       line[2] = line[2] * a / 255;
 861       line += 4;
 862     }
 863   }
 864 }
 865 
 866 static void
 867 gst_video_overlay_rectangle_premultiply (GstVideoFrame * frame)
 868 {
 869   gint alpha_offset;
 870 
 871   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 872   switch (alpha_offset) {
 873     case 0:
 874       gst_video_overlay_rectangle_premultiply_0 (frame);
 875       break;
 876     case 3:
 877       gst_video_overlay_rectangle_premultiply_3 (frame);
 878       break;
 879     default:
 880       g_assert_not_reached ();
 881       break;
 882   }
 883 }
 884 
 885 /* FIXME: orc-ify */
 886 static void
 887 gst_video_overlay_rectangle_unpremultiply_0 (GstVideoFrame * frame)
 888 {
 889   int i, j;
<a name="15" id="anc15"></a><span class="line-modified"> 890   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 891     guint8 *line;
 892 
<a name="16" id="anc16"></a><span class="line-modified"> 893     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 894     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 895     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 896       int a = line[0];
 897       if (a) {
 898         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 899         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 900         line[3] = MIN ((line[3] * 255 + a / 2) / a, 255);
 901       }
 902       line += 4;
 903     }
 904   }
 905 }
 906 
 907 static void
 908 gst_video_overlay_rectangle_unpremultiply_3 (GstVideoFrame * frame)
 909 {
 910   int i, j;
<a name="17" id="anc17"></a><span class="line-modified"> 911   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 912     guint8 *line;
 913 
<a name="18" id="anc18"></a><span class="line-modified"> 914     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 915     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 916     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 917       int a = line[3];
 918       if (a) {
 919         line[0] = MIN ((line[0] * 255 + a / 2) / a, 255);
 920         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 921         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 922       }
 923       line += 4;
 924     }
 925   }
 926 }
 927 
 928 static void
 929 gst_video_overlay_rectangle_unpremultiply (GstVideoFrame * frame)
 930 {
 931   gint alpha_offset;
 932 
 933   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 934   switch (alpha_offset) {
 935     case 0:
 936       gst_video_overlay_rectangle_unpremultiply_0 (frame);
 937       break;
 938     case 3:
 939       gst_video_overlay_rectangle_unpremultiply_3 (frame);
 940       break;
 941     default:
 942       g_assert_not_reached ();
 943       break;
 944   }
 945 }
 946 
 947 
 948 static void
 949 gst_video_overlay_rectangle_extract_alpha (GstVideoOverlayRectangle * rect)
 950 {
 951   guint8 *src, *dst;
 952   GstVideoFrame frame;
 953   gint i, j, w, h, stride, alpha_offset;
 954 
 955   alpha_offset = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
 956   g_return_if_fail (alpha_offset == 0 || alpha_offset == 3);
 957 
 958   gst_video_frame_map (&amp;frame, &amp;rect-&gt;info, rect-&gt;pixels, GST_MAP_READ);
 959   src = GST_VIDEO_FRAME_PLANE_DATA (&amp;frame, 0);
 960   w = GST_VIDEO_INFO_WIDTH (&amp;rect-&gt;info);
 961   h = GST_VIDEO_INFO_HEIGHT (&amp;rect-&gt;info);
 962   stride = GST_VIDEO_INFO_PLANE_STRIDE (&amp;rect-&gt;info, 0);
 963 
 964   g_free (rect-&gt;initial_alpha);
 965   rect-&gt;initial_alpha = g_malloc (w * h);
 966   dst = rect-&gt;initial_alpha;
 967 
 968   for (i = 0; i &lt; h; i++) {
 969     for (j = 0; j &lt; w; j++) {
 970       *dst = src[alpha_offset];
 971       dst++;
 972       src += 4;
 973     }
 974     src += stride - 4 * w;
 975   }
 976   gst_video_frame_unmap (&amp;frame);
 977 }
 978 
 979 
 980 static void
 981 gst_video_overlay_rectangle_apply_global_alpha (GstVideoOverlayRectangle * rect,
 982     float global_alpha)
 983 {
 984   guint8 *src, *dst;
 985   GstVideoFrame frame;
 986   gint i, j, w, h, stride;
 987   gint argb_a, argb_r, argb_g, argb_b;
 988   gint alpha_offset;
 989 
 990   g_assert (!(rect-&gt;applied_global_alpha != 1.0
 991           &amp;&amp; rect-&gt;initial_alpha == NULL));
 992 
 993   alpha_offset = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
 994   g_return_if_fail (alpha_offset == 0 || alpha_offset == 3);
 995 
 996   if (global_alpha == rect-&gt;applied_global_alpha)
 997     return;
 998 
 999   if (rect-&gt;initial_alpha == NULL)
1000     gst_video_overlay_rectangle_extract_alpha (rect);
1001 
1002   src = rect-&gt;initial_alpha;
<a name="19" id="anc19"></a><span class="line-modified">1003   rect-&gt;pixels = gst_buffer_make_writable (rect-&gt;pixels);</span>






1004 
1005   gst_video_frame_map (&amp;frame, &amp;rect-&gt;info, rect-&gt;pixels, GST_MAP_READ);
1006   dst = GST_VIDEO_FRAME_PLANE_DATA (&amp;frame, 0);
1007   w = GST_VIDEO_INFO_WIDTH (&amp;rect-&gt;info);
1008   h = GST_VIDEO_INFO_HEIGHT (&amp;rect-&gt;info);
1009   stride = GST_VIDEO_INFO_PLANE_STRIDE (&amp;rect-&gt;info, 0);
1010 
1011   argb_a = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
1012   argb_r = (argb_a + 1) % 4;
1013   argb_g = (argb_a + 2) % 4;
1014   argb_b = (argb_a + 3) % 4;
1015 
1016   for (i = 0; i &lt; h; i++) {
1017     for (j = 0; j &lt; w; j++) {
1018       guint8 na = (guint8) (*src * global_alpha);
1019 
1020       if (! !(rect-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {
1021         dst[argb_r] =
1022             (guint8) ((double) (dst[argb_r] * 255) / (double) dst[argb_a]) *
1023             na / 255;
1024         dst[argb_g] =
1025             (guint8) ((double) (dst[argb_g] * 255) / (double) dst[argb_a]) *
1026             na / 255;
1027         dst[argb_b] =
1028             (guint8) ((double) (dst[argb_b] * 255) / (double) dst[argb_a]) *
1029             na / 255;
1030       }
1031       dst[argb_a] = na;
1032       src++;
1033       dst += 4;
1034     }
1035     dst += stride - 4 * w;
1036   }
1037   gst_video_frame_unmap (&amp;frame);
1038 
1039   rect-&gt;applied_global_alpha = global_alpha;
1040 }
1041 
1042 static void
1043 gst_video_overlay_rectangle_convert (GstVideoInfo * src, GstBuffer * src_buffer,
1044     GstVideoFormat dest_format, GstVideoInfo * dest, GstBuffer ** dest_buffer)
1045 {
1046   gint width, height, stride;
1047   GstVideoFrame src_frame, dest_frame;
1048   GstVideoFormat format;
1049   gint k, l;
1050   guint8 *sdata, *ddata;
1051 
1052   format = GST_VIDEO_INFO_FORMAT (src);
1053 
1054   width = GST_VIDEO_INFO_WIDTH (src);
1055   height = GST_VIDEO_INFO_HEIGHT (src);
1056 
1057   gst_video_info_init (dest);
1058   if (!gst_video_info_set_format (dest, dest_format, width, height)) {
1059     g_warn_if_reached ();
1060     return;
1061   }
1062 
1063   *dest_buffer = gst_buffer_new_and_alloc (GST_VIDEO_INFO_SIZE (dest));
1064 
1065   gst_video_frame_map (&amp;src_frame, src, src_buffer, GST_MAP_READ);
1066   gst_video_frame_map (&amp;dest_frame, dest, *dest_buffer, GST_MAP_WRITE);
1067 
1068   sdata = GST_VIDEO_FRAME_PLANE_DATA (&amp;src_frame, 0);
1069   ddata = GST_VIDEO_FRAME_PLANE_DATA (&amp;dest_frame, 0);
1070   stride = GST_VIDEO_FRAME_PLANE_STRIDE (&amp;src_frame, 0);
1071 
1072   if (format == GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_YUV &amp;&amp;
1073       dest_format == GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_RGB) {
1074     gint ayuv;
1075     gint a, y, u, v, r, g, b;
1076 
1077     for (k = 0; k &lt; height; k++) {
1078       for (l = 0; l &lt; width; l++) {
1079         ayuv = GST_READ_UINT32_BE (sdata);
1080         a = ayuv &gt;&gt; 24;
1081         y = (ayuv &gt;&gt; 16) &amp; 0xff;
1082         u = (ayuv &gt;&gt; 8) &amp; 0xff;
1083         v = (ayuv &amp; 0xff);
1084 
1085         r = (298 * y + 459 * v - 63514) &gt;&gt; 8;
1086         g = (298 * y - 55 * u - 136 * v + 19681) &gt;&gt; 8;
1087         b = (298 * y + 541 * u - 73988) &gt;&gt; 8;
1088 
1089         r = CLAMP (r, 0, 255);
1090         g = CLAMP (g, 0, 255);
1091         b = CLAMP (b, 0, 255);
1092 
1093         /* native endian ARGB */
1094         *(guint32 *) ddata = ((a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b);
1095 
1096         sdata += 4;
1097         ddata += 4;
1098       }
1099       sdata += stride - 4 * width;
1100     }
1101   } else if (format == GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_RGB &amp;&amp;
1102       dest_format == GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_YUV) {
1103     gint argb;
1104     gint a, y, u, v, r, g, b;
1105 
1106     for (k = 0; k &lt; height; k++) {
1107       for (l = 0; l &lt; width; l++) {
1108         /* native endian ARGB */
1109         argb = *(guint32 *) sdata;
1110         a = argb &gt;&gt; 24;
1111         r = (argb &gt;&gt; 16) &amp; 0xff;
1112         g = (argb &gt;&gt; 8) &amp; 0xff;
1113         b = (argb &amp; 0xff);
1114 
1115         y = (47 * r + 157 * g + 16 * b + 4096) &gt;&gt; 8;
1116         u = (-26 * r - 87 * g + 112 * b + 32768) &gt;&gt; 8;
1117         v = (112 * r - 102 * g - 10 * b + 32768) &gt;&gt; 8;
1118 
1119         y = CLAMP (y, 0, 255);
1120         u = CLAMP (u, 0, 255);
1121         v = CLAMP (v, 0, 255);
1122 
1123         GST_WRITE_UINT32_BE (ddata, ((a &lt;&lt; 24) | (y &lt;&lt; 16) | (u &lt;&lt; 8) | v));
1124 
1125         sdata += 4;
1126         ddata += 4;
1127       }
1128       sdata += stride - 4 * width;
1129     }
1130   } else {
1131     GST_ERROR (&quot;unsupported conversion&quot;);
1132     g_assert_not_reached ();
1133   }
1134 
1135   gst_video_frame_unmap (&amp;src_frame);
1136   gst_video_frame_unmap (&amp;dest_frame);
1137 }
1138 
1139 static GstBuffer *
1140 gst_video_overlay_rectangle_get_pixels_raw_internal (GstVideoOverlayRectangle *
1141     rectangle, GstVideoOverlayFormatFlags flags, gboolean unscaled,
1142     GstVideoFormat wanted_format)
1143 {
1144   GstVideoOverlayFormatFlags new_flags;
1145   GstVideoOverlayRectangle *scaled_rect = NULL, *conv_rect = NULL;
1146   GstVideoInfo info;
1147   GstVideoFrame frame;
1148   GstBuffer *buf;
1149   GList *l;
1150   guint width, height;
1151   guint wanted_width;
1152   guint wanted_height;
1153   gboolean apply_global_alpha;
1154   gboolean revert_global_alpha;
1155   GstVideoFormat format;
1156 
1157   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
1158   g_return_val_if_fail (gst_video_overlay_rectangle_check_flags (flags), NULL);
1159 
1160   width = GST_VIDEO_INFO_WIDTH (&amp;rectangle-&gt;info);
1161   height = GST_VIDEO_INFO_HEIGHT (&amp;rectangle-&gt;info);
1162   wanted_width = unscaled ? width : rectangle-&gt;render_width;
1163   wanted_height = unscaled ? height : rectangle-&gt;render_height;
1164   format = GST_VIDEO_INFO_FORMAT (&amp;rectangle-&gt;info);
1165 
1166   apply_global_alpha =
1167       (! !(rectangle-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)
1168       &amp;&amp; !(flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));
1169   revert_global_alpha =
1170       (! !(rectangle-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA)
1171       &amp;&amp; ! !(flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA));
1172 
1173   /* This assumes we don&#39;t need to adjust the format */
1174   if (wanted_width == width &amp;&amp;
1175       wanted_height == height &amp;&amp;
1176       wanted_format == format &amp;&amp;
1177       gst_video_overlay_rectangle_is_same_alpha_type (rectangle-&gt;flags,
1178           flags)) {
1179     /* don&#39;t need to apply/revert global-alpha either: */
1180     if ((!apply_global_alpha
1181             || rectangle-&gt;applied_global_alpha == rectangle-&gt;global_alpha)
1182         &amp;&amp; (!revert_global_alpha || rectangle-&gt;applied_global_alpha == 1.0)) {
1183       return rectangle-&gt;pixels;
1184     } else {
1185       /* only apply/revert global-alpha */
1186       scaled_rect = rectangle;
1187       goto done;
1188     }
1189   }
1190 
1191   /* see if we&#39;ve got one cached already */
1192   GST_RECTANGLE_LOCK (rectangle);
1193   for (l = rectangle-&gt;scaled_rectangles; l != NULL; l = l-&gt;next) {
1194     GstVideoOverlayRectangle *r = l-&gt;data;
1195 
1196     if (GST_VIDEO_INFO_WIDTH (&amp;r-&gt;info) == wanted_width &amp;&amp;
1197         GST_VIDEO_INFO_HEIGHT (&amp;r-&gt;info) == wanted_height &amp;&amp;
1198         GST_VIDEO_INFO_FORMAT (&amp;r-&gt;info) == wanted_format &amp;&amp;
1199         gst_video_overlay_rectangle_is_same_alpha_type (r-&gt;flags, flags)) {
1200       /* we&#39;ll keep these rectangles around until finalize, so it&#39;s ok not
1201        * to take our own ref here */
1202       scaled_rect = r;
1203       break;
1204     }
1205   }
1206   GST_RECTANGLE_UNLOCK (rectangle);
1207 
1208   if (scaled_rect != NULL)
1209     goto done;
1210 
1211   /* maybe have one in the right format though */
1212   if (format != wanted_format) {
1213     GST_RECTANGLE_LOCK (rectangle);
1214     for (l = rectangle-&gt;scaled_rectangles; l != NULL; l = l-&gt;next) {
1215       GstVideoOverlayRectangle *r = l-&gt;data;
1216 
1217       if (GST_VIDEO_INFO_FORMAT (&amp;r-&gt;info) == wanted_format &amp;&amp;
1218           gst_video_overlay_rectangle_is_same_alpha_type (r-&gt;flags, flags)) {
1219         /* we&#39;ll keep these rectangles around until finalize, so it&#39;s ok not
1220          * to take our own ref here */
1221         conv_rect = r;
1222         break;
1223       }
1224     }
1225     GST_RECTANGLE_UNLOCK (rectangle);
1226   } else {
1227     conv_rect = rectangle;
1228   }
1229 
1230   if (conv_rect == NULL) {
1231     GstVideoInfo conv_info;
1232 
1233     gst_video_overlay_rectangle_convert (&amp;rectangle-&gt;info, rectangle-&gt;pixels,
1234         wanted_format, &amp;conv_info, &amp;buf);
1235     gst_buffer_add_video_meta (buf, GST_VIDEO_FRAME_FLAG_NONE,
1236         GST_VIDEO_INFO_FORMAT (&amp;conv_info), width, height);
1237     conv_rect = gst_video_overlay_rectangle_new_raw (buf,
1238         0, 0, width, height, rectangle-&gt;flags);
1239     if (rectangle-&gt;global_alpha != 1.0)
1240       gst_video_overlay_rectangle_set_global_alpha (scaled_rect,
1241           rectangle-&gt;global_alpha);
1242     gst_buffer_unref (buf);
1243     /* keep this converted one around as well in any case */
1244     GST_RECTANGLE_LOCK (rectangle);
1245     rectangle-&gt;scaled_rectangles =
1246         g_list_prepend (rectangle-&gt;scaled_rectangles, conv_rect);
1247     GST_RECTANGLE_UNLOCK (rectangle);
1248   }
1249 
1250   /* now we continue from conv_rect */
1251   width = GST_VIDEO_INFO_WIDTH (&amp;conv_rect-&gt;info);
1252   height = GST_VIDEO_INFO_HEIGHT (&amp;conv_rect-&gt;info);
1253   format = GST_VIDEO_INFO_FORMAT (&amp;conv_rect-&gt;info);
1254 
1255   /* not cached yet, do the preprocessing and put the result into our cache */
1256   if (wanted_width != width || wanted_height != height) {
1257     GstVideoInfo scaled_info;
1258 
1259     /* we could check the cache for a scaled rect with global_alpha == 1 here */
1260     gst_video_blend_scale_linear_RGBA (&amp;conv_rect-&gt;info, conv_rect-&gt;pixels,
1261         wanted_height, wanted_width, &amp;scaled_info, &amp;buf);
1262     info = scaled_info;
1263     gst_buffer_add_video_meta (buf, GST_VIDEO_FRAME_FLAG_NONE,
1264         GST_VIDEO_INFO_FORMAT (&amp;conv_rect-&gt;info), wanted_width, wanted_height);
1265   } else if (!gst_video_overlay_rectangle_is_same_alpha_type (conv_rect-&gt;flags,
1266           flags)) {
1267     /* if we don&#39;t have to scale, we have to modify the alpha values, so we
1268      * need to make a copy of the pixel memory (and we take ownership below) */
1269     buf = gst_buffer_copy (conv_rect-&gt;pixels);
1270     info = conv_rect-&gt;info;
1271   } else {
1272     /* do not need to scale or modify alpha values, almost done then */
1273     scaled_rect = conv_rect;
1274     goto done;
1275   }
1276 
1277   new_flags = conv_rect-&gt;flags;
1278   gst_video_frame_map (&amp;frame, &amp;info, buf, GST_MAP_READWRITE);
1279   if (!gst_video_overlay_rectangle_is_same_alpha_type (conv_rect-&gt;flags, flags)) {
1280     if (rectangle-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA) {
1281       gst_video_overlay_rectangle_unpremultiply (&amp;frame);
1282       new_flags &amp;= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA;
1283     } else {
1284       gst_video_overlay_rectangle_premultiply (&amp;frame);
1285       new_flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA;
1286     }
1287   }
1288   gst_video_frame_unmap (&amp;frame);
1289 
1290   scaled_rect = gst_video_overlay_rectangle_new_raw (buf,
1291       0, 0, wanted_width, wanted_height, new_flags);
1292   if (conv_rect-&gt;global_alpha != 1.0)
1293     gst_video_overlay_rectangle_set_global_alpha (scaled_rect,
1294         conv_rect-&gt;global_alpha);
1295   gst_buffer_unref (buf);
1296 
1297   GST_RECTANGLE_LOCK (rectangle);
1298   rectangle-&gt;scaled_rectangles =
1299       g_list_prepend (rectangle-&gt;scaled_rectangles, scaled_rect);
1300   GST_RECTANGLE_UNLOCK (rectangle);
1301 
1302 done:
1303 
1304   GST_RECTANGLE_LOCK (rectangle);
1305   if (apply_global_alpha
1306       &amp;&amp; scaled_rect-&gt;applied_global_alpha != rectangle-&gt;global_alpha) {
1307     gst_video_overlay_rectangle_apply_global_alpha (scaled_rect,
1308         rectangle-&gt;global_alpha);
1309     gst_video_overlay_rectangle_set_global_alpha (scaled_rect,
1310         rectangle-&gt;global_alpha);
1311   } else if (revert_global_alpha &amp;&amp; scaled_rect-&gt;applied_global_alpha != 1.0) {
1312     gst_video_overlay_rectangle_apply_global_alpha (scaled_rect, 1.0);
1313   }
1314   GST_RECTANGLE_UNLOCK (rectangle);
1315 
1316   return scaled_rect-&gt;pixels;
1317 }
1318 
1319 
1320 /**
1321  * gst_video_overlay_rectangle_get_pixels_raw:
1322  * @rectangle: a #GstVideoOverlayRectangle
1323  * @flags: flags
1324  *    If a global_alpha value != 1 is set for the rectangle, the caller
1325  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1326  *    if he wants to apply global-alpha himself. If the flag is not set
1327  *    global_alpha is applied internally before returning the pixel-data.
1328  *
1329  * Returns: (transfer none): a #GstBuffer holding the pixel data with
1330  *    format as originally provided and specified in video meta with
1331  *    width and height of the render dimensions as per
1332  *    gst_video_overlay_rectangle_get_render_rectangle(). This function does
1333  *    not return a reference, the caller should obtain a reference of her own
1334  *    with gst_buffer_ref() if needed.
1335  */
1336 GstBuffer *
1337 gst_video_overlay_rectangle_get_pixels_raw (GstVideoOverlayRectangle *
1338     rectangle, GstVideoOverlayFormatFlags flags)
1339 {
1340   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1341       flags, FALSE, GST_VIDEO_INFO_FORMAT (&amp;rectangle-&gt;info));
1342 }
1343 
1344 /**
1345  * gst_video_overlay_rectangle_get_pixels_argb:
1346  * @rectangle: a #GstVideoOverlayRectangle
1347  * @flags: flags
1348  *    If a global_alpha value != 1 is set for the rectangle, the caller
1349  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1350  *    if he wants to apply global-alpha himself. If the flag is not set
1351  *    global_alpha is applied internally before returning the pixel-data.
1352  *
1353  * Returns: (transfer none): a #GstBuffer holding the ARGB pixel data with
1354  *    width and height of the render dimensions as per
1355  *    gst_video_overlay_rectangle_get_render_rectangle(). This function does
1356  *    not return a reference, the caller should obtain a reference of her own
1357  *    with gst_buffer_ref() if needed.
1358  */
1359 GstBuffer *
1360 gst_video_overlay_rectangle_get_pixels_argb (GstVideoOverlayRectangle *
1361     rectangle, GstVideoOverlayFormatFlags flags)
1362 {
1363   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1364       flags, FALSE, GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_RGB);
1365 }
1366 
1367 /**
1368  * gst_video_overlay_rectangle_get_pixels_ayuv:
1369  * @rectangle: a #GstVideoOverlayRectangle
1370  * @flags: flags
1371  *    If a global_alpha value != 1 is set for the rectangle, the caller
1372  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1373  *    if he wants to apply global-alpha himself. If the flag is not set
1374  *    global_alpha is applied internally before returning the pixel-data.
1375  *
1376  * Returns: (transfer none): a #GstBuffer holding the AYUV pixel data with
1377  *    width and height of the render dimensions as per
1378  *    gst_video_overlay_rectangle_get_render_rectangle(). This function does
1379  *    not return a reference, the caller should obtain a reference of her own
1380  *    with gst_buffer_ref() if needed.
1381  */
1382 GstBuffer *
1383 gst_video_overlay_rectangle_get_pixels_ayuv (GstVideoOverlayRectangle *
1384     rectangle, GstVideoOverlayFormatFlags flags)
1385 {
1386   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1387       flags, FALSE, GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_YUV);
1388 }
1389 
1390 /**
1391  * gst_video_overlay_rectangle_get_pixels_unscaled_raw:
1392  * @rectangle: a #GstVideoOverlayRectangle
1393  * @flags: flags.
1394  *    If a global_alpha value != 1 is set for the rectangle, the caller
1395  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1396  *    if he wants to apply global-alpha himself. If the flag is not set
1397  *    global_alpha is applied internally before returning the pixel-data.
1398  *
1399  * Retrieves the pixel data as it is. This is useful if the caller can
1400  * do the scaling itself when handling the overlaying. The rectangle will
1401  * need to be scaled to the render dimensions, which can be retrieved using
1402  * gst_video_overlay_rectangle_get_render_rectangle().
1403  *
1404  * Returns: (transfer none): a #GstBuffer holding the pixel data with
1405  *    #GstVideoMeta set. This function does not return a reference, the caller
1406  *    should obtain a reference of her own with gst_buffer_ref() if needed.
1407  */
1408 GstBuffer *
1409 gst_video_overlay_rectangle_get_pixels_unscaled_raw (GstVideoOverlayRectangle *
1410     rectangle, GstVideoOverlayFormatFlags flags)
1411 {
1412   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
1413 
1414   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1415       flags, TRUE, GST_VIDEO_INFO_FORMAT (&amp;rectangle-&gt;info));
1416 }
1417 
1418 /**
1419  * gst_video_overlay_rectangle_get_pixels_unscaled_argb:
1420  * @rectangle: a #GstVideoOverlayRectangle
1421  * @flags: flags.
1422  *    If a global_alpha value != 1 is set for the rectangle, the caller
1423  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1424  *    if he wants to apply global-alpha himself. If the flag is not set
1425  *    global_alpha is applied internally before returning the pixel-data.
1426  *
1427  * Retrieves the pixel data as it is. This is useful if the caller can
1428  * do the scaling itself when handling the overlaying. The rectangle will
1429  * need to be scaled to the render dimensions, which can be retrieved using
1430  * gst_video_overlay_rectangle_get_render_rectangle().
1431  *
1432  * Returns: (transfer none): a #GstBuffer holding the ARGB pixel data with
1433  *    #GstVideoMeta set. This function does not return a reference, the caller
1434  *    should obtain a reference of her own with gst_buffer_ref() if needed.
1435  */
1436 GstBuffer *
1437 gst_video_overlay_rectangle_get_pixels_unscaled_argb (GstVideoOverlayRectangle *
1438     rectangle, GstVideoOverlayFormatFlags flags)
1439 {
1440   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
1441 
1442   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1443       flags, TRUE, GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_RGB);
1444 }
1445 
1446 /**
1447  * gst_video_overlay_rectangle_get_pixels_unscaled_ayuv:
1448  * @rectangle: a #GstVideoOverlayRectangle
1449  * @flags: flags.
1450  *    If a global_alpha value != 1 is set for the rectangle, the caller
1451  *    should set the #GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA flag
1452  *    if he wants to apply global-alpha himself. If the flag is not set
1453  *    global_alpha is applied internally before returning the pixel-data.
1454  *
1455  * Retrieves the pixel data as it is. This is useful if the caller can
1456  * do the scaling itself when handling the overlaying. The rectangle will
1457  * need to be scaled to the render dimensions, which can be retrieved using
1458  * gst_video_overlay_rectangle_get_render_rectangle().
1459  *
1460  * Returns: (transfer none): a #GstBuffer holding the AYUV pixel data with
1461  *    #GstVideoMeta set. This function does not return a reference, the caller
1462  *    should obtain a reference of her own with gst_buffer_ref() if needed.
1463  */
1464 GstBuffer *
1465 gst_video_overlay_rectangle_get_pixels_unscaled_ayuv (GstVideoOverlayRectangle *
1466     rectangle, GstVideoOverlayFormatFlags flags)
1467 {
1468   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
1469 
1470   return gst_video_overlay_rectangle_get_pixels_raw_internal (rectangle,
1471       flags, TRUE, GST_VIDEO_OVERLAY_COMPOSITION_FORMAT_YUV);
1472 }
1473 
1474 /**
1475  * gst_video_overlay_rectangle_get_flags:
1476  * @rectangle: a #GstVideoOverlayRectangle
1477  *
1478  * Retrieves the flags associated with a #GstVideoOverlayRectangle.
1479  * This is useful if the caller can handle both premultiplied alpha and
1480  * non premultiplied alpha, for example. By knowing whether the rectangle
1481  * uses premultiplied or not, it can request the pixel data in the format
1482  * it is stored in, to avoid unnecessary conversion.
1483  *
1484  * Returns: the #GstVideoOverlayFormatFlags associated with the rectangle.
1485  */
1486 GstVideoOverlayFormatFlags
1487 gst_video_overlay_rectangle_get_flags (GstVideoOverlayRectangle * rectangle)
1488 {
1489   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle),
1490       GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE);
1491 
1492   return rectangle-&gt;flags;
1493 }
1494 
1495 /**
1496  * gst_video_overlay_rectangle_get_global_alpha:
1497  * @rectangle: a #GstVideoOverlayRectangle
1498  *
1499  * Retrieves the global-alpha value associated with a #GstVideoOverlayRectangle.
1500  *
1501  * Returns: the global-alpha value associated with the rectangle.
1502  */
1503 gfloat
1504 gst_video_overlay_rectangle_get_global_alpha (GstVideoOverlayRectangle *
1505     rectangle)
1506 {
1507   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), -1);
1508 
1509   return rectangle-&gt;global_alpha;
1510 }
1511 
1512 /**
1513  * gst_video_overlay_rectangle_set_global_alpha:
1514  * @rectangle: a #GstVideoOverlayRectangle
1515  * @global_alpha: Global alpha value (0 to 1.0)
1516  *
1517  * Sets the global alpha value associated with a #GstVideoOverlayRectangle. Per-
1518  * pixel alpha values are multiplied with this value. Valid
1519  * values: 0 &lt;= global_alpha &lt;= 1; 1 to deactivate.
1520  *
1521  * @rectangle must be writable, meaning its refcount must be 1. You can
1522  * make the rectangles inside a #GstVideoOverlayComposition writable using
1523  * gst_video_overlay_composition_make_writable() or
1524  * gst_video_overlay_composition_copy().
1525  */
1526 void
1527 gst_video_overlay_rectangle_set_global_alpha (GstVideoOverlayRectangle *
1528     rectangle, gfloat global_alpha)
1529 {
1530   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<a name="20" id="anc20"></a>

1531   g_return_if_fail (global_alpha &gt;= 0 &amp;&amp; global_alpha &lt;= 1);
1532 
1533   if (rectangle-&gt;global_alpha != global_alpha) {
1534     rectangle-&gt;global_alpha = global_alpha;
1535     if (global_alpha != 1)
1536       rectangle-&gt;flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1537     else
1538       rectangle-&gt;flags &amp;= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1539     /* update seq_num automatically to signal the consumer, that data has changed
1540      * note, that this might mislead renderers, that can handle global-alpha
1541      * themselves, because what they want to know is whether the actual pixel data
1542      * has changed. */
1543     rectangle-&gt;seq_num = gst_video_overlay_get_seqnum ();
1544   }
1545 }
1546 
1547 /**
1548  * gst_video_overlay_rectangle_copy:
1549  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to copy
1550  *
1551  * Makes a copy of @rectangle, so that it is possible to modify it
1552  * (e.g. to change the render co-ordinates or render dimension). The
1553  * actual overlay pixel data buffers contained in the rectangle are not
1554  * copied.
1555  *
1556  * Returns: (transfer full): a new #GstVideoOverlayRectangle equivalent
1557  *     to @rectangle.
1558  */
1559 GstVideoOverlayRectangle *
1560 gst_video_overlay_rectangle_copy (GstVideoOverlayRectangle * rectangle)
1561 {
1562   GstVideoOverlayRectangle *copy;
1563 
1564   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
1565 
1566   copy = gst_video_overlay_rectangle_new_raw (rectangle-&gt;pixels,
1567       rectangle-&gt;x, rectangle-&gt;y,
1568       rectangle-&gt;render_width, rectangle-&gt;render_height, rectangle-&gt;flags);
1569   if (rectangle-&gt;global_alpha != 1)
1570     gst_video_overlay_rectangle_set_global_alpha (copy,
1571         rectangle-&gt;global_alpha);
1572 
1573   return copy;
1574 }
1575 
1576 /**
1577  * gst_video_overlay_rectangle_get_seqnum:
1578  * @rectangle: a #GstVideoOverlayRectangle
1579  *
1580  * Returns the sequence number of this rectangle. Sequence numbers are
1581  * monotonically increasing and unique for overlay compositions and rectangles
1582  * (meaning there will never be a rectangle with the same sequence number as
1583  * a composition).
1584  *
1585  * Using the sequence number of a rectangle as an indicator for changed
1586  * pixel-data of a rectangle is dangereous. Some API calls, like e.g.
1587  * gst_video_overlay_rectangle_set_global_alpha(), automatically update
1588  * the per rectangle sequence number, which is misleading for renderers/
1589  * consumers, that handle global-alpha themselves. For them  the
1590  * pixel-data returned by gst_video_overlay_rectangle_get_pixels_*()
1591  * wont be different for different global-alpha values. In this case a
1592  * renderer could also use the GstBuffer pointers as a hint for changed
1593  * pixel-data.
1594  *
1595  * Returns: the sequence number of @rectangle
1596  */
1597 guint
1598 gst_video_overlay_rectangle_get_seqnum (GstVideoOverlayRectangle * rectangle)
1599 {
1600   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), 0);
1601 
1602   return rectangle-&gt;seq_num;
1603 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>