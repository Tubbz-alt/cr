diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c
@@ -1,7 +1,7 @@
 /*
- * Copyright � 2010 Codethink Limited
+ * Copyright (C) 2010 Codethink Limited
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
@@ -37,12 +37,14 @@
 #include "gslice.h"
 #include "gdatetime.h"
 #include "gdate.h"
 
 #ifdef G_OS_WIN32
+
 #define STRICT
 #include <windows.h>
+#include <wchar.h>
 #endif
 
 /**
  * SECTION:timezone
  * @title: GTimeZone
@@ -50,21 +52,21 @@
  * @see_also: #GDateTime
  *
  * #GTimeZone is a structure that represents a time zone, at no
  * particular point in time.  It is refcounted and immutable.
  *
- * Each time zone has an identifier (for example, �Europe/London�) which is
+ * Each time zone has an identifier (for example, 'Europe/London') which is
  * platform dependent. See g_time_zone_new() for information on the identifier
  * formats. The identifier of a time zone can be retrieved using
  * g_time_zone_get_identifier().
  *
  * A time zone contains a number of intervals.  Each interval has
- * an abbreviation to describe it (for example, �PDT�), an offet to UTC and a
+ * an abbreviation to describe it (for example, 'PDT'), an offet to UTC and a
  * flag indicating if the daylight savings time is in effect during that
- * interval.  A time zone always has at least one interval � interval 0. Note
+ * interval.  A time zone always has at least one interval - interval 0. Note
  * that interval abbreviations are not the same as time zone identifiers
- * (apart from �UTC�), and cannot be passed to g_time_zone_new().
+ * (apart from 'UTC'), and cannot be passed to g_time_zone_new().
  *
  * Every UTC time is contained within exactly one interval, but a given
  * local time may be contained within zero, one or two intervals (due to
  * incontinuities associated with daylight savings time).
  *
@@ -235,11 +237,11 @@
           G_UNLOCK(time_zones);
         }
 
       if (tz->t_info != NULL)
         {
-          gint idx;
+          guint idx;
           for (idx = 0; idx < tz->t_info->len; idx++)
             {
               TransitionInfo *info = &g_array_index (tz->t_info, TransitionInfo, idx);
               g_free (info->abbrev);
             }
@@ -370,10 +372,12 @@
       if (parse_time (name, offset))
         {
           *offset = -*offset;
           return TRUE;
         }
+      else
+        return FALSE;
 
     default:
       return FALSE;
     }
 }
@@ -434,11 +438,11 @@
     {
       gsize prefix_len = 0;
       gchar *canonical_path = NULL;
       GError *read_link_err = NULL;
 
-    filename = g_strdup ("/etc/localtime");
+      filename = g_strdup ("/etc/localtime");
 
       /* Resolve the actual timezone pointed to by /etc/localtime. */
       resolved_identifier = g_file_read_link (filename, &read_link_err);
       if (resolved_identifier == NULL)
         {
@@ -571,11 +575,11 @@
         trans.time = gint64_from_be (((gint64_be*)tz_transitions)[index]);
       else
         trans.time = gint32_from_be (((gint32_be*)tz_transitions)[index]);
       trans.info_index = tz_type_index[index];
       g_assert (trans.info_index >= 0);
-      g_assert (trans.info_index < gtz->t_info->len);
+      g_assert ((guint) trans.info_index < gtz->t_info->len);
       g_array_append_val (gtz->transitions, trans);
     }
 }
 
 #elif defined (G_OS_WIN32)
@@ -598,55 +602,77 @@
   else
     tzdate->week = s_time->wDay;
 }
 
 /* UTC = local time + bias while local time = UTC + offset */
-static void
+static gboolean
 rule_from_windows_time_zone_info (TimeZoneRule *rule,
                                   TIME_ZONE_INFORMATION *tzi)
 {
+  gchar *std_name, *dlt_name;
+
+  std_name = g_utf16_to_utf8 ((gunichar2 *)tzi->StandardName, -1, NULL, NULL, NULL);
+  if (std_name == NULL)
+    return FALSE;
+
+  dlt_name = g_utf16_to_utf8 ((gunichar2 *)tzi->DaylightName, -1, NULL, NULL, NULL);
+  if (dlt_name == NULL)
+    {
+      g_free (std_name);
+      return FALSE;
+    }
+
   /* Set offset */
   if (tzi->StandardDate.wMonth)
     {
       rule->std_offset = -(tzi->Bias + tzi->StandardBias) * 60;
       rule->dlt_offset = -(tzi->Bias + tzi->DaylightBias) * 60;
       copy_windows_systemtime (&(tzi->DaylightDate), &(rule->dlt_start));
 
       copy_windows_systemtime (&(tzi->StandardDate), &(rule->dlt_end));
-
     }
 
   else
     {
       rule->std_offset = -tzi->Bias * 60;
       rule->dlt_start.mon = 0;
     }
-  strncpy (rule->std_name, (gchar*)tzi->StandardName, NAME_SIZE - 1);
-  strncpy (rule->dlt_name, (gchar*)tzi->DaylightName, NAME_SIZE - 1);
+  strncpy (rule->std_name, std_name, NAME_SIZE - 1);
+  strncpy (rule->dlt_name, dlt_name, NAME_SIZE - 1);
+
+  g_free (std_name);
+  g_free (dlt_name);
+
+  return TRUE;
 }
 
 static gchar*
 windows_default_tzname (void)
 {
-  const gchar *subkey =
-    "SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation";
+  const gunichar2 *subkey =
+    L"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation";
   HKEY key;
   gchar *key_name = NULL;
-  if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
+  gunichar2 *key_name_w = NULL;
+  if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey, 0,
                      KEY_QUERY_VALUE, &key) == ERROR_SUCCESS)
     {
       DWORD size = 0;
-      if (RegQueryValueExA (key, "TimeZoneKeyName", NULL, NULL,
+      if (RegQueryValueExW (key, L"TimeZoneKeyName", NULL, NULL,
                             NULL, &size) == ERROR_SUCCESS)
         {
-          key_name = g_malloc ((gint)size);
-          if (RegQueryValueExA (key, "TimeZoneKeyName", NULL, NULL,
-                                (LPBYTE)key_name, &size) != ERROR_SUCCESS)
+          key_name_w = g_malloc ((gint)size);
+
+          if (key_name_w == NULL ||
+              RegQueryValueExW (key, L"TimeZoneKeyName", NULL, NULL,
+                                (LPBYTE)key_name_w, &size) != ERROR_SUCCESS)
             {
-              g_free (key_name);
+              g_free (key_name_w);
               key_name = NULL;
             }
+          else
+            key_name = g_utf16_to_utf8 (key_name_w, -1, NULL, NULL, NULL);
         }
       RegCloseKey (key);
     }
   return key_name;
 }
@@ -686,29 +712,38 @@
   tzi->StandardBias = reg->StandardBias;
   system_time_copy (&(reg->DaylightDate), &(tzi->DaylightDate));
   tzi->DaylightBias = reg->DaylightBias;
 }
 
-static gint
+static guint
 rules_from_windows_time_zone (const gchar   *identifier,
                               gchar        **out_identifier,
-                              TimeZoneRule **rules)
+                              TimeZoneRule **rules,
+                              gboolean       copy_identifier)
 {
   HKEY key;
-  gchar *subkey, *subkey_dynamic;
+  gchar *subkey = NULL;
+  gchar *subkey_dynamic = NULL;
   gchar *key_name = NULL;
   const gchar *reg_key =
     "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\";
   TIME_ZONE_INFORMATION tzi;
   DWORD size;
-  gint rules_num = 0;
+  guint rules_num = 0;
   RegTZI regtzi, regtzi_prev;
+  WCHAR winsyspath[MAX_PATH];
+  gunichar2 *subkey_w, *subkey_dynamic_w;
 
-  g_assert (out_identifier != NULL);
+  if (GetSystemDirectoryW (winsyspath, MAX_PATH) == 0)
+    return 0;
+
+  g_assert (copy_identifier == FALSE || out_identifier != NULL);
   g_assert (rules != NULL);
 
-  *out_identifier = NULL;
+  if (copy_identifier)
+    *out_identifier = NULL;
+
   *rules = NULL;
   key_name = NULL;
 
   if (!identifier)
     key_name = windows_default_tzname ();
@@ -717,120 +752,166 @@
 
   if (!key_name)
     return 0;
 
   subkey = g_strconcat (reg_key, key_name, NULL);
+  subkey_w = g_utf8_to_utf16 (subkey, -1, NULL, NULL, NULL);
+  if (subkey_w == NULL)
+    goto utf16_conv_failed;
+
   subkey_dynamic = g_strconcat (subkey, "\\Dynamic DST", NULL);
+  subkey_dynamic_w = g_utf8_to_utf16 (subkey_dynamic, -1, NULL, NULL, NULL);
+  if (subkey_dynamic_w == NULL)
+    goto utf16_conv_failed;
 
-  if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
+  if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,
                      KEY_QUERY_VALUE, &key) != ERROR_SUCCESS)
-      return 0;
+      goto utf16_conv_failed;
+
   size = sizeof tzi.StandardName;
-  if (RegQueryValueExA (key, "Std", NULL, NULL,
-                        (LPBYTE)&(tzi.StandardName), &size) != ERROR_SUCCESS)
-    goto failed;
+
+  /* use RegLoadMUIStringW() to query MUI_Std from the registry if possible, otherwise
+     fallback to querying Std */
+  if (RegLoadMUIStringW (key, L"MUI_Std", tzi.StandardName,
+                         size, &size, 0, winsyspath) != ERROR_SUCCESS)
+    {
+      size = sizeof tzi.StandardName;
+      if (RegQueryValueExW (key, L"Std", NULL, NULL,
+                            (LPBYTE)&(tzi.StandardName), &size) != ERROR_SUCCESS)
+        goto registry_failed;
+    }
 
   size = sizeof tzi.DaylightName;
 
-  if (RegQueryValueExA (key, "Dlt", NULL, NULL,
-                        (LPBYTE)&(tzi.DaylightName), &size) != ERROR_SUCCESS)
-    goto failed;
+  /* use RegLoadMUIStringW() to query MUI_Dlt from the registry if possible, otherwise
+     fallback to querying Dlt */
+  if (RegLoadMUIStringW (key, L"MUI_Dlt", tzi.DaylightName,
+                         size, &size, 0, winsyspath) != ERROR_SUCCESS)
+    {
+      size = sizeof tzi.DaylightName;
+      if (RegQueryValueExW (key, L"Dlt", NULL, NULL,
+                            (LPBYTE)&(tzi.DaylightName), &size) != ERROR_SUCCESS)
+        goto registry_failed;
+    }
 
   RegCloseKey (key);
-  if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey_dynamic, 0,
+  if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_dynamic_w, 0,
                      KEY_QUERY_VALUE, &key) == ERROR_SUCCESS)
     {
       DWORD first, last;
       int year, i;
-      gchar *s;
+      wchar_t s[12];
 
       size = sizeof first;
-      if (RegQueryValueExA (key, "FirstEntry", NULL, NULL,
+      if (RegQueryValueExW (key, L"FirstEntry", NULL, NULL,
                             (LPBYTE) &first, &size) != ERROR_SUCCESS)
-        goto failed;
+        goto registry_failed;
 
       size = sizeof last;
-      if (RegQueryValueExA (key, "LastEntry", NULL, NULL,
+      if (RegQueryValueExW (key, L"LastEntry", NULL, NULL,
                             (LPBYTE) &last, &size) != ERROR_SUCCESS)
-        goto failed;
+        goto registry_failed;
 
       rules_num = last - first + 2;
       *rules = g_new0 (TimeZoneRule, rules_num);
 
-      for (year = first, i = 0; year <= last; year++)
+      for (year = first, i = 0; *rules != NULL && year <= last; year++)
         {
-          s = g_strdup_printf ("%d", year);
+          gboolean failed = FALSE;
+          swprintf_s (s, 11, L"%d", year);
+
+          if (!failed)
+            {
+              size = sizeof regtzi;
+              if (RegQueryValueExW (key, s, NULL, NULL,
+                                    (LPBYTE) &regtzi, &size) != ERROR_SUCCESS)
+                failed = TRUE;
+            }
 
-          size = sizeof regtzi;
-          if (RegQueryValueExA (key, s, NULL, NULL,
-                            (LPBYTE) &regtzi, &size) != ERROR_SUCCESS)
+          if (failed)
             {
               g_free (*rules);
               *rules = NULL;
               break;
             }
 
-          g_free (s);
-
           if (year > first && memcmp (&regtzi_prev, &regtzi, sizeof regtzi) == 0)
               continue;
           else
             memcpy (&regtzi_prev, &regtzi, sizeof regtzi);
 
           register_tzi_to_tzi (&regtzi, &tzi);
-          rule_from_windows_time_zone_info (&(*rules)[i], &tzi);
+
+          if (!rule_from_windows_time_zone_info (&(*rules)[i], &tzi))
+            {
+              g_free (*rules);
+              *rules = NULL;
+              break;
+            }
+
           (*rules)[i++].start_year = year;
         }
 
       rules_num = i + 1;
 
-failed:
+registry_failed:
       RegCloseKey (key);
     }
-  else if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
+  else if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,
                           KEY_QUERY_VALUE, &key) == ERROR_SUCCESS)
     {
       size = sizeof regtzi;
-      if (RegQueryValueExA (key, "TZI", NULL, NULL,
+      if (RegQueryValueExW (key, L"TZI", NULL, NULL,
                             (LPBYTE) &regtzi, &size) == ERROR_SUCCESS)
         {
           rules_num = 2;
           *rules = g_new0 (TimeZoneRule, 2);
           register_tzi_to_tzi (&regtzi, &tzi);
-          rule_from_windows_time_zone_info (&(*rules)[0], &tzi);
+
+          if (!rule_from_windows_time_zone_info (&(*rules)[0], &tzi))
+            {
+              g_free (*rules);
+              *rules = NULL;
+            }
         }
 
       RegCloseKey (key);
     }
 
+utf16_conv_failed:
+  g_free (subkey_dynamic_w);
   g_free (subkey_dynamic);
+  g_free (subkey_w);
   g_free (subkey);
 
   if (*rules)
     {
       (*rules)[0].start_year = MIN_TZYEAR;
       if ((*rules)[rules_num - 2].start_year < MAX_TZYEAR)
         (*rules)[rules_num - 1].start_year = MAX_TZYEAR;
       else
         (*rules)[rules_num - 1].start_year = (*rules)[rules_num - 2].start_year + 1;
 
-      *out_identifier = g_steal_pointer (&key_name);
+      if (copy_identifier)
+        *out_identifier = g_steal_pointer (&key_name);
+      else
+        g_free (key_name);
 
       return rules_num;
     }
 
   g_free (key_name);
 
-    return 0;
+  return 0;
 }
 
 #endif
 
 static void
 find_relative_date (TimeZoneDate *buffer)
 {
-  gint wday;
+  guint wday;
   GDate date;
   g_date_clear (&date, 1);
   wday = buffer->wday;
 
   /* Get last day if last is needed, first day otherwise */
@@ -923,11 +1004,11 @@
 }
 
 static void
 init_zone_from_rules (GTimeZone    *gtz,
                       TimeZoneRule *rules,
-                      gint          rules_num,
+                      guint         rules_num,
                       gchar        *identifier  /* (transfer full) */)
 {
   guint type_count = 0, trans_count = 0, info_index = 0;
   guint ri; /* rule index */
   gboolean skip_first_std_trans = TRUE;
@@ -1214,11 +1295,11 @@
 
       return *pos == '\0';
     }
 }
 
-static gint
+static guint
 create_ruleset_from_rule (TimeZoneRule **rules, TimeZoneRule *rule)
 {
   *rules = g_new0 (TimeZoneRule, 2);
 
   (*rules)[0].start_year = MIN_TZYEAR;
@@ -1306,11 +1387,11 @@
 
 /*
  * Creates an array of TimeZoneRule from a TZ environment variable
  * type of identifier.  Should free rules afterwards
  */
-static gint
+static guint
 rules_from_identifier (const gchar   *identifier,
                        gchar        **out_identifier,
                        TimeZoneRule **rules)
 {
   gchar *pos;
@@ -1352,13 +1433,19 @@
       int i;
       guint rules_num = 0;
 
       /* Use US rules, Windows' default is Pacific Standard Time */
       if ((rules_num = rules_from_windows_time_zone ("Pacific Standard Time",
-                                                     out_identifier,
-                                                     rules)))
+                                                     NULL,
+                                                     rules,
+                                                     FALSE)))
         {
+          /* We don't want to hardcode our identifier here as
+           * "Pacific Standard Time", use what was passed in
+           */
+          *out_identifier = g_strdup (identifier);
+
           for (i = 0; i < rules_num - 1; i++)
             {
               (*rules)[i].std_offset = - tzr.std_offset;
               (*rules)[i].dlt_offset = - tzr.dlt_offset;
               strcpy ((*rules)[i].std_name, tzr.std_name);
@@ -1435,11 +1522,11 @@
  * from year 1900 to 2037.  If the maximum year for the rules is
  * available and it is greater than 2037, then it will followed
  * instead.
  *
  * See
- * [RFC3339 �5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
+ * [RFC3339 5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
  * for a precise definition of valid RFC3339 time offsets
  * (the `time-offset` expansion) and ISO 8601 for the
  * full list of valid time offsets.  See
  * [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
  * for an explanation of the possible
@@ -1499,11 +1586,12 @@
           g_bytes_unref (zoneinfo);
         }
 #elif defined (G_OS_WIN32)
       if ((rules_num = rules_from_windows_time_zone (identifier,
                                                      &resolved_identifier,
-                                                     &rules)))
+                                                     &rules,
+                                                     TRUE)))
         {
           init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&resolved_identifier));
           g_free (rules);
         }
 #endif
@@ -1518,19 +1606,20 @@
 
           if (GetTimeZoneInformation (&tzi) != TIME_ZONE_ID_INVALID)
             {
               rules = g_new0 (TimeZoneRule, 2);
 
-              rule_from_windows_time_zone_info (&rules[0], &tzi);
-
-              memset (rules[0].std_name, 0, NAME_SIZE);
-              memset (rules[0].dlt_name, 0, NAME_SIZE);
+              if (rule_from_windows_time_zone_info (&rules[0], &tzi))
+                {
+                  memset (rules[0].std_name, 0, NAME_SIZE);
+                  memset (rules[0].dlt_name, 0, NAME_SIZE);
 
-              rules[0].start_year = MIN_TZYEAR;
-              rules[1].start_year = MAX_TZYEAR;
+                  rules[0].start_year = MIN_TZYEAR;
+                  rules[1].start_year = MAX_TZYEAR;
 
-              init_zone_from_rules (tz, rules, 2, windows_default_tzname ());
+                  init_zone_from_rules (tz, rules, 2, windows_default_tzname ());
+                }
 
               g_free (rules);
             }
         }
     }
@@ -1779,12 +1868,12 @@
 gint
 g_time_zone_adjust_time (GTimeZone *tz,
                          GTimeType  type,
                          gint64    *time_)
 {
-  gint i;
-  guint intervals;
+  guint i, intervals;
+  gboolean interval_is_dst;
 
   if (tz->transitions == NULL)
     return 0;
 
   intervals = tz->transitions->len;
@@ -1822,20 +1911,25 @@
           if (*time_ < interval_local_start (tz, i))
             /* it doesn't exist.  fast-forward it. */
             *time_ = interval_local_start (tz, i);
         }
 
-      else if (interval_isdst (tz, i) != type)
-        /* it's in this interval, but dst flag doesn't match.
-         * check neighbours for a better fit. */
+      else
         {
-          if (i && *time_ <= interval_local_end (tz, i - 1))
-            i--;
-
-          else if (i < intervals &&
-                   *time_ >= interval_local_start (tz, i + 1))
-            i++;
+          interval_is_dst = interval_isdst (tz, i);
+          if ((interval_is_dst && type != G_TIME_TYPE_DAYLIGHT) ||
+              (!interval_is_dst && type == G_TIME_TYPE_DAYLIGHT))
+            {
+              /* it's in this interval, but dst flag doesn't match.
+               * check neighbours for a better fit. */
+              if (i && *time_ <= interval_local_end (tz, i - 1))
+                i--;
+
+              else if (i < intervals &&
+                       *time_ >= interval_local_start (tz, i + 1))
+                i++;
+            }
         }
     }
 
   return i;
 }
@@ -1844,11 +1938,11 @@
  * g_time_zone_find_interval:
  * @tz: a #GTimeZone
  * @type: the #GTimeType of @time_
  * @time_: a number of seconds since January 1, 1970
  *
- * Finds an the interval within @tz that corresponds to the given @time_.
+ * Finds an interval within @tz that corresponds to the given @time_.
  * The meaning of @time_ depends on @type.
  *
  * If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
  * succeed (since universal time is monotonic and continuous).
  *
@@ -1872,12 +1966,12 @@
 gint
 g_time_zone_find_interval (GTimeZone *tz,
                            GTimeType  type,
                            gint64     time_)
 {
-  gint i;
-  guint intervals;
+  guint i, intervals;
+  gboolean interval_is_dst;
 
   if (tz->transitions == NULL)
     return 0;
   intervals = tz->transitions->len;
   for (i = 0; i <= intervals; i++)
@@ -1897,17 +1991,22 @@
     {
       if (time_ < interval_local_start (tz, ++i))
         return -1;
     }
 
-  else if (interval_isdst (tz, i) != type)
+  else
     {
-      if (i && time_ <= interval_local_end (tz, i - 1))
-        i--;
+      interval_is_dst = interval_isdst (tz, i);
+      if  ((interval_is_dst && type != G_TIME_TYPE_DAYLIGHT) ||
+           (!interval_is_dst && type == G_TIME_TYPE_DAYLIGHT))
+        {
+          if (i && time_ <= interval_local_end (tz, i - 1))
+            i--;
 
-      else if (i < intervals && time_ >= interval_local_start (tz, i + 1))
-        i++;
+          else if (i < intervals && time_ >= interval_local_start (tz, i + 1))
+            i++;
+        }
     }
 
   return i;
 }
 
