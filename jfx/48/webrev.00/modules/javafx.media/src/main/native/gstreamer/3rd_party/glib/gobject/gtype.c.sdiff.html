<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtype-private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;../glib/gvalgrind.h&quot;
  25 #include &lt;string.h&gt;
  26 
  27 #include &quot;gtype.h&quot;
  28 #include &quot;gtype-private.h&quot;
  29 #include &quot;gtypeplugin.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gatomicarray.h&quot;
  32 #include &quot;gobject_trace.h&quot;
  33 
  34 #include &quot;glib-private.h&quot;
  35 #include &quot;gconstructor.h&quot;
  36 
  37 #ifdef G_OS_WIN32
  38 #include &lt;windows.h&gt;
  39 #endif
  40 
  41 #ifdef  G_ENABLE_DEBUG
<span class="line-modified">  42 #define IF_DEBUG(debug_type)    if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
  43 #endif
  44 
  45 /**
  46  * SECTION:gtype
  47  * @short_description: The GLib Runtime type identification and
  48  *     management system
  49  * @title:Type Information
  50  *
  51  * The GType API is the foundation of the GObject system.  It provides the
  52  * facilities for registering and managing all fundamental data types,
  53  * user-defined object and interface types.
  54  *
  55  * For type creation and registration purposes, all types fall into one of
  56  * two categories: static or dynamic.  Static types are never loaded or
  57  * unloaded at run-time as dynamic types may be.  Static types are created
  58  * with g_type_register_static() that gets type specific information passed
  59  * in via a #GTypeInfo structure.
  60  *
  61  * Dynamic types are created with g_type_register_dynamic() which takes a
  62  * #GTypePlugin structure instead. The remaining type information (the
</pre>
<hr />
<pre>
  83  *
  84  * As mentioned in the [GType conventions][gtype-conventions], type names must
  85  * be at least three characters long. There is no upper length limit. The first
  86  * character must be a letter (a or A) or an underscore (). Subsequent
  87  * characters can be letters, numbers or any of .
  88  */
  89 
  90 
  91 /* NOTE: some functions (some internal variants and exported ones)
  92  * invalidate data portions of the TypeNodes. if external functions/callbacks
  93  * are called, pointers to memory maintained by TypeNodes have to be looked up
  94  * again. this affects most of the struct TypeNode fields, e.g. -&gt;children or
  95  * CLASSED_NODE_IFACES_ENTRIES() respectively IFACE_NODE_PREREQUISITES() (but
  96  * not -&gt;supers[]), as all those memory portions can get realloc()ed during
  97  * callback invocation.
  98  *
  99  * LOCKING:
 100  * lock handling issues when calling static functions are indicated by
 101  * uppercase letter postfixes, all static functions have to have
 102  * one of the below postfixes:
<span class="line-modified"> 103  * - _I:    [Indifferent about locking]</span>
 104  *   function doesn&#39;t care about locks at all
<span class="line-modified"> 105  * - _U:    [Unlocked invocation]</span>
 106  *   no read or write lock has to be held across function invocation
 107  *   (locks may be acquired and released during invocation though)
<span class="line-modified"> 108  * - _L:    [Locked invocation]</span>
 109  *   a write lock or more than 0 read locks have to be held across
 110  *   function invocation
<span class="line-modified"> 111  * - _W:    [Write-locked invocation]</span>
 112  *   a write lock has to be held across function invocation
<span class="line-modified"> 113  * - _Wm:   [Write-locked invocation, mutatable]</span>
 114  *   like _W, but the write lock might be released and reacquired
 115  *   during invocation, watch your pointers
 116  * - _WmREC:    [Write-locked invocation, mutatable, recursive]
 117  *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
 118  */
 119 
 120 #ifdef LOCK_DEBUG
 121 #define G_READ_LOCK(rw_lock)    do { g_printerr (G_STRLOC &quot;: readL++\n&quot;); g_rw_lock_reader_lock (rw_lock); } while (0)
 122 #define G_READ_UNLOCK(rw_lock)  do { g_printerr (G_STRLOC &quot;: readL--\n&quot;); g_rw_lock_reader_unlock (rw_lock); } while (0)
 123 #define G_WRITE_LOCK(rw_lock)   do { g_printerr (G_STRLOC &quot;: writeL++\n&quot;); g_rw_lock_writer_lock (rw_lock); } while (0)
 124 #define G_WRITE_UNLOCK(rw_lock) do { g_printerr (G_STRLOC &quot;: writeL--\n&quot;); g_rw_lock_writer_unlock (rw_lock); } while (0)
 125 #else
 126 #define G_READ_LOCK(rw_lock)    g_rw_lock_reader_lock (rw_lock)
 127 #define G_READ_UNLOCK(rw_lock)  g_rw_lock_reader_unlock (rw_lock)
 128 #define G_WRITE_LOCK(rw_lock)   g_rw_lock_writer_lock (rw_lock)
 129 #define G_WRITE_UNLOCK(rw_lock) g_rw_lock_writer_unlock (rw_lock)
 130 #endif
 131 #define INVALID_RECURSION(func, arg, type_name) G_STMT_START{ \
 132     static const gchar _action[] = &quot; invalidly modified type &quot;;  \
 133     gpointer _arg = (gpointer) (arg); const gchar *_tname = (type_name), *_fname = (func); \
 134     if (_arg) \
 135       g_error (&quot;%s(%p)%s&#39;%s&#39;&quot;, _fname, _arg, _action, _tname); \
 136     else \
 137       g_error (&quot;%s()%s&#39;%s&#39;&quot;, _fname, _action, _tname); \
 138 }G_STMT_END
 139 #define g_assert_type_system_initialized() \
 140   g_assert (static_quark_type_flags)
 141 
 142 #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
<span class="line-modified"> 143                     G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="line-modified"> 144                     G_TYPE_FLAG_DERIVABLE | \</span>
<span class="line-modified"> 145                     G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="line-modified"> 146 #define TYPE_FLAG_MASK         (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
 147 #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
<span class="line-modified"> 148                                sizeof (gpointer)), \</span>
 149                                                   sizeof (glong)))
 150 
 151 /* The 2*sizeof(size_t) alignment here is borrowed from
 152  * GNU libc, so it should be good most everywhere.
 153  * It is more conservative than is needed on some 64-bit
 154  * platforms, but ia64 does require a 16-byte alignment.
 155  * The SIMD extensions for x86 and ppc32 would want a
 156  * larger alignment than this, but we don&#39;t need to
 157  * do better than malloc.
 158  */
 159 #define STRUCT_ALIGNMENT (2 * sizeof (gsize))
 160 #define ALIGN_STRUCT(offset) \
 161       ((offset + (STRUCT_ALIGNMENT - 1)) &amp; -STRUCT_ALIGNMENT)
 162 
 163 
 164 /* --- typedefs --- */
 165 typedef struct _TypeNode        TypeNode;
 166 typedef struct _CommonData      CommonData;
 167 typedef struct _BoxedData       BoxedData;
 168 typedef struct _IFaceData       IFaceData;
 169 typedef struct _ClassData       ClassData;
 170 typedef struct _InstanceData    InstanceData;
 171 typedef union  _TypeData        TypeData;
 172 typedef struct _IFaceEntries    IFaceEntries;
 173 typedef struct _IFaceEntry      IFaceEntry;
 174 typedef struct _IFaceHolder IFaceHolder;
 175 
 176 
 177 /* --- prototypes --- */
<span class="line-modified"> 178 static inline GTypeFundamentalInfo* type_node_fundamental_info_I    (TypeNode       *node);</span>
<span class="line-modified"> 179 static        void          type_add_flags_W        (TypeNode       *node,</span>
<span class="line-modified"> 180                                      GTypeFlags      flags);</span>
<span class="line-modified"> 181 static        void          type_data_make_W        (TypeNode       *node,</span>
<span class="line-modified"> 182                                      const GTypeInfo    *info,</span>
<span class="line-modified"> 183                                      const GTypeValueTable  *value_table);</span>
<span class="line-modified"> 184 static inline void          type_data_ref_Wm        (TypeNode       *node);</span>
<span class="line-modified"> 185 static inline void          type_data_unref_U               (TypeNode       *node,</span>
<span class="line-modified"> 186                                      gboolean        uncached);</span>
<span class="line-modified"> 187 static void             type_data_last_unref_Wm     (TypeNode *              node,</span>
<span class="line-modified"> 188                                      gboolean        uncached);</span>
<span class="line-modified"> 189 static inline gpointer          type_get_qdata_L        (TypeNode       *node,</span>
<span class="line-modified"> 190                                      GQuark          quark);</span>
<span class="line-modified"> 191 static inline void          type_set_qdata_W        (TypeNode       *node,</span>
<span class="line-modified"> 192                                      GQuark          quark,</span>
<span class="line-modified"> 193                                      gpointer        data);</span>
<span class="line-modified"> 194 static IFaceHolder*         type_iface_peek_holder_L    (TypeNode       *iface,</span>
<span class="line-modified"> 195                                      GType           instance_type);</span>
 196 static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
 197                                                                          TypeNode               *node);
 198 static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
 199                                                                          TypeNode               *node);
<span class="line-modified"> 200 static gboolean             type_node_is_a_L        (TypeNode       *node,</span>
<span class="line-modified"> 201                                      TypeNode       *iface_node);</span>
 202 
 203 
 204 /* --- enumeration --- */
 205 
 206 /* The InitState enumeration is used to track the progress of initializing
 207  * both classes and interface vtables. Keeping the state of initialization
 208  * is necessary to handle new interfaces being added while we are initializing
 209  * the class or other interfaces.
 210  */
 211 typedef enum
 212 {
 213   UNINITIALIZED,
 214   BASE_CLASS_INIT,
 215   BASE_IFACE_INIT,
 216   CLASS_INIT,
 217   IFACE_INIT,
 218   INITIALIZED
 219 } InitState;
 220 
 221 /* --- structures --- */
 222 struct _TypeNode
 223 {
 224   guint volatile ref_count;
 225 #ifdef G_ENABLE_DEBUG
 226   guint volatile instance_count;
 227 #endif
 228   GTypePlugin *plugin;
 229   guint        n_children; /* writable with lock */
 230   guint        n_supers : 8;
 231   guint        n_prerequisites : 9;
 232   guint        is_classed : 1;
 233   guint        is_instantiatable : 1;
<span class="line-modified"> 234   guint        mutatable_check_cache : 1;   /* combines some common path checks */</span>
 235   GType       *children; /* writable with lock */
 236   TypeData * volatile data;
 237   GQuark       qname;
 238   GData       *global_gdata;
 239   union {
<span class="line-modified"> 240     GAtomicArray iface_entries;     /* for !iface types */</span>
 241     GAtomicArray offsets;
 242   } _prot;
 243   GType       *prerequisites;
 244   GType        supers[1]; /* flexible array */
 245 };
 246 
<span class="line-modified"> 247 #define SIZEOF_BASE_TYPE_NODE()         (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="line-modified"> 248 #define MAX_N_SUPERS                (255)</span>
<span class="line-modified"> 249 #define MAX_N_CHILDREN              (G_MAXUINT)</span>
<span class="line-modified"> 250 #define MAX_N_INTERFACES            (255) /* Limited by offsets being 8 bits */</span>
<span class="line-modified"> 251 #define MAX_N_PREREQUISITES         (511)</span>
<span class="line-modified"> 252 #define NODE_TYPE(node)             (node-&gt;supers[0])</span>
<span class="line-modified"> 253 #define NODE_PARENT_TYPE(node)          (node-&gt;supers[1])</span>
<span class="line-modified"> 254 #define NODE_FUNDAMENTAL_TYPE(node)     (node-&gt;supers[node-&gt;n_supers])</span>
<span class="line-modified"> 255 #define NODE_NAME(node)             (g_quark_to_string (node-&gt;qname))</span>
 256 #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
<span class="line-modified"> 257 #define NODE_IS_BOXED(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="line-modified"> 258 #define NODE_IS_IFACE(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="line-modified"> 259 #define CLASSED_NODE_IFACES_ENTRIES(node)   (&amp;(node)-&gt;_prot.iface_entries)</span>
 260 #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
<span class="line-modified"> 261 #define IFACE_NODE_N_PREREQUISITES(node)    ((node)-&gt;n_prerequisites)</span>
<span class="line-modified"> 262 #define IFACE_NODE_PREREQUISITES(node)      ((node)-&gt;prerequisites)</span>
<span class="line-modified"> 263 #define iface_node_get_holders_L(node)      ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
 264 #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
<span class="line-modified"> 265 #define iface_node_get_dependants_array_L(n)    ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
 266 #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
<span class="line-modified"> 267 #define TYPE_ID_MASK                ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
 268 
 269 #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
 270         ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
<span class="line-modified"> 271      (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
 272 
 273 struct _IFaceHolder
 274 {
 275   GType           instance_type;
 276   GInterfaceInfo *info;
 277   GTypePlugin    *plugin;
 278   IFaceHolder    *next;
 279 };
 280 
 281 struct _IFaceEntry
 282 {
 283   GType           iface_type;
 284   GTypeInterface *vtable;
 285   InitState       init_state;
 286 };
 287 
 288 struct _IFaceEntries {
 289   guint offset_index;
 290   IFaceEntry entry[1];
 291 };
</pre>
<hr />
<pre>
 363   GTypeClassCacheFunc cache_func;
 364 } ClassCacheFunc;
 365 
 366 typedef struct {
 367   gpointer                check_data;
 368   GTypeInterfaceCheckFunc check_func;
 369 } IFaceCheckFunc;
 370 
 371 
 372 /* --- variables --- */
 373 static GRWLock         type_rw_lock;
 374 static GRecMutex       class_init_rec_mutex;
 375 static guint           static_n_class_cache_funcs = 0;
 376 static ClassCacheFunc *static_class_cache_funcs = NULL;
 377 static guint           static_n_iface_check_funcs = 0;
 378 static IFaceCheckFunc *static_iface_check_funcs = NULL;
 379 static GQuark          static_quark_type_flags = 0;
 380 static GQuark          static_quark_iface_holder = 0;
 381 static GQuark          static_quark_dependants_array = 0;
 382 static guint           type_registration_serial = 0;


 383 GTypeDebugFlags        _g_type_debug_flags = 0;

 384 
 385 /* --- type nodes --- */
 386 static GHashTable       *static_type_nodes_ht = NULL;
<span class="line-modified"> 387 static TypeNode     *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="line-modified"> 388 static GType         static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
 389 
 390 static inline TypeNode*
 391 lookup_type_node_I (GType utype)
 392 {
 393   if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
 394     return (TypeNode*) (utype &amp; ~TYPE_ID_MASK);
 395   else
 396     return static_fundamental_type_nodes[utype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT];
 397 }
 398 
 399 /**
 400  * g_type_get_type_registration_serial:
 401  *
 402  * Returns an opaque serial number that represents the state of the set
 403  * of registered types. Any time a type is registered this serial changes,
 404  * which means you can cache information based on type lookups (such as
 405  * g_type_from_name()) and know if the cache is still valid at a later
 406  * time by comparing the current serial with the one at the type lookup.
 407  *
 408  * Since: 2.36
 409  *
 410  * Returns: An unsigned int, representing the state of type registrations
 411  */
 412 guint
 413 g_type_get_type_registration_serial (void)
 414 {
 415   return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
 416 }
 417 
 418 static TypeNode*
 419 type_node_any_new_W (TypeNode             *pnode,
<span class="line-modified"> 420              GType                 ftype,</span>
<span class="line-modified"> 421              const gchar          *name,</span>
<span class="line-modified"> 422              GTypePlugin          *plugin,</span>
<span class="line-modified"> 423              GTypeFundamentalFlags type_flags)</span>
 424 {
 425   guint n_supers;
 426   GType type;
 427   TypeNode *node;
 428   guint i, node_size = 0;
 429 
 430   n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
 431 
 432   if (!pnode)
<span class="line-modified"> 433     node_size += SIZEOF_FUNDAMENTAL_INFO;         /* fundamental type info */</span>
<span class="line-modified"> 434   node_size += SIZEOF_BASE_TYPE_NODE ();          /* TypeNode structure */</span>
 435   node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
 436   node = g_malloc0 (node_size);
<span class="line-modified"> 437   if (!pnode)                         /* offset fundamental types */</span>
 438     {
 439       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
 440       static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
 441       type = ftype;
 442     }
 443   else
 444     type = (GType) node;
 445 
 446   g_assert ((type &amp; TYPE_ID_MASK) == 0);
 447 
 448   node-&gt;n_supers = n_supers;
 449   if (!pnode)
 450     {
 451       node-&gt;supers[0] = type;
 452       node-&gt;supers[1] = 0;
 453 
 454       node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
 455       node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
 456 
 457       if (NODE_IS_IFACE (node))
<span class="line-modified"> 458     {</span>
 459           IFACE_NODE_N_PREREQUISITES (node) = 0;
<span class="line-modified"> 460       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified"> 461     }</span>
 462       else
<span class="line-modified"> 463     _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
 464     }
 465   else
 466     {
 467       node-&gt;supers[0] = type;
 468       memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
 469 
 470       node-&gt;is_classed = pnode-&gt;is_classed;
 471       node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
 472 
 473       if (NODE_IS_IFACE (node))
<span class="line-modified"> 474     {</span>
<span class="line-modified"> 475       IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="line-modified"> 476       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified"> 477     }</span>
 478       else










 479     {
<span class="line-modified"> 480       guint j;</span>
<span class="line-modified"> 481       IFaceEntries *entries;</span>
<span class="line-removed"> 482 </span>
<span class="line-removed"> 483       entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="line-removed"> 484                       IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-removed"> 485                       0);</span>
<span class="line-removed"> 486       if (entries)</span>
<span class="line-removed"> 487         {</span>
<span class="line-removed"> 488           for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
<span class="line-removed"> 489         {</span>
<span class="line-removed"> 490           entries-&gt;entry[j].vtable = NULL;</span>
<span class="line-removed"> 491           entries-&gt;entry[j].init_state = UNINITIALIZED;</span>
<span class="line-removed"> 492         }</span>
<span class="line-removed"> 493           _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="line-removed"> 494                       entries);</span>
<span class="line-removed"> 495         }</span>
 496     }




 497 
 498       i = pnode-&gt;n_children++;
 499       pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
 500       pnode-&gt;children[i] = type;
 501     }
 502 
 503   TRACE(GOBJECT_TYPE_NEW(name, node-&gt;supers[1], type));
 504 
 505   node-&gt;plugin = plugin;
 506   node-&gt;n_children = 0;
 507   node-&gt;children = NULL;
 508   node-&gt;data = NULL;
 509   node-&gt;qname = g_quark_from_string (name);
 510   node-&gt;global_gdata = NULL;
 511   g_hash_table_insert (static_type_nodes_ht,
<span class="line-modified"> 512                (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="line-modified"> 513                (gpointer) type);</span>
 514 
 515   g_atomic_int_inc ((gint *)&amp;type_registration_serial);
 516 
 517   return node;
 518 }
 519 
 520 static inline GTypeFundamentalInfo*
 521 type_node_fundamental_info_I (TypeNode *node)
 522 {
 523   GType ftype = NODE_FUNDAMENTAL_TYPE (node);
 524 
 525   if (ftype != NODE_TYPE (node))
 526     node = lookup_type_node_I (ftype);
 527 
 528   return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
 529 }
 530 
 531 static TypeNode*
 532 type_node_fundamental_new_W (GType                 ftype,
<span class="line-modified"> 533                  const gchar          *name,</span>
<span class="line-modified"> 534                  GTypeFundamentalFlags type_flags)</span>
 535 {
 536   GTypeFundamentalInfo *finfo;
 537   TypeNode *node;
 538 
 539   g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
 540   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX);
 541 
 542   if (ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
 543     static_fundamental_next++;
 544 
 545   type_flags &amp;= TYPE_FUNDAMENTAL_FLAG_MASK;
 546 
 547   node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
 548 
 549   finfo = type_node_fundamental_info_I (node);
 550   finfo-&gt;type_flags = type_flags;
 551 
 552   return node;
 553 }
 554 
 555 static TypeNode*
 556 type_node_new_W (TypeNode    *pnode,
<span class="line-modified"> 557          const gchar *name,</span>
<span class="line-modified"> 558          GTypePlugin *plugin)</span>
 559 
 560 {
 561   g_assert (pnode);
 562   g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
 563   g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
 564 
 565   return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
 566 }
 567 
 568 static inline IFaceEntry*
 569 lookup_iface_entry_I (volatile IFaceEntries *entries,
<span class="line-modified"> 570               TypeNode *iface_node)</span>
 571 {
 572   guint8 *offsets;
 573   guint offset_index;
 574   IFaceEntry *check;
 575   int index;
 576   IFaceEntry *entry;
 577 
 578   if (entries == NULL)
 579     return NULL;
 580 
 581   G_ATOMIC_ARRAY_DO_TRANSACTION
 582     (&amp;iface_node-&gt;_prot.offsets, guint8,
 583 
 584      entry = NULL;
 585      offsets = transaction_data;
 586      offset_index = entries-&gt;offset_index;
 587      if (offsets != NULL &amp;&amp;
<span class="line-modified"> 588      offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>
<span class="line-removed"> 589        {</span>
<span class="line-removed"> 590      index = offsets[offset_index];</span>
<span class="line-removed"> 591      if (index &gt; 0)</span>
 592        {
<span class="line-modified"> 593          /* zero means unset, subtract one to get real index */</span>
<span class="line-modified"> 594          index -= 1;</span>
<span class="line-modified"> 595 </span>
<span class="line-modified"> 596          if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="line-modified"> 597            {</span>
<span class="line-modified"> 598          check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="line-modified"> 599          if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="line-modified"> 600            entry = check;</span>
<span class="line-modified"> 601            }</span>
<span class="line-modified"> 602        }</span>



 603        }
 604      );
 605 
 606  return entry;
 607 }
 608 
 609 static inline IFaceEntry*
 610 type_lookup_iface_entry_L (TypeNode *node,
<span class="line-modified"> 611                TypeNode *iface_node)</span>
 612 {
 613   if (!NODE_IS_IFACE (iface_node))
 614     return NULL;
 615 
 616   return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
<span class="line-modified"> 617                    iface_node);</span>
 618 }
 619 
 620 
 621 static inline gboolean
 622 type_lookup_iface_vtable_I (TypeNode *node,
<span class="line-modified"> 623                 TypeNode *iface_node,</span>
<span class="line-modified"> 624                 gpointer *vtable_ptr)</span>
 625 {
 626   IFaceEntry *entry;
 627   gboolean res;
 628 
 629   if (!NODE_IS_IFACE (iface_node))
 630     {
 631       if (vtable_ptr)
<span class="line-modified"> 632     *vtable_ptr = NULL;</span>
 633       return FALSE;
 634     }
 635 
 636   G_ATOMIC_ARRAY_DO_TRANSACTION
 637     (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
 638 
 639      entry = lookup_iface_entry_I (transaction_data, iface_node);
 640      res = entry != NULL;
 641      if (vtable_ptr)
 642        {
<span class="line-modified"> 643      if (entry)</span>
<span class="line-modified"> 644        *vtable_ptr = entry-&gt;vtable;</span>
<span class="line-modified"> 645      else</span>
<span class="line-modified"> 646        *vtable_ptr = NULL;</span>
 647        }
 648      );
 649 
 650   return res;
 651 }
 652 
 653 static inline gboolean
 654 type_lookup_prerequisite_L (TypeNode *iface,
<span class="line-modified"> 655                 GType     prerequisite_type)</span>
 656 {
 657   if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
 658     {
 659       GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
 660       guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
 661 
 662       do
<span class="line-modified"> 663     {</span>
<span class="line-modified"> 664       guint i;</span>
<span class="line-modified"> 665       GType *check;</span>
 666 
<span class="line-modified"> 667       i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="line-modified"> 668       check = prerequisites + i;</span>
<span class="line-modified"> 669       if (prerequisite_type == *check)</span>
<span class="line-modified"> 670         return TRUE;</span>
<span class="line-modified"> 671       else if (prerequisite_type &gt; *check)</span>
<span class="line-modified"> 672         {</span>
<span class="line-modified"> 673           n_prerequisites -= i;</span>
<span class="line-modified"> 674           prerequisites = check;</span>
<span class="line-modified"> 675         }</span>
<span class="line-modified"> 676       else /* if (prerequisite_type &lt; *check) */</span>
<span class="line-modified"> 677         n_prerequisites = i - 1;</span>
<span class="line-modified"> 678     }</span>
 679       while (n_prerequisites);
 680     }
 681   return FALSE;
 682 }
 683 
 684 static const gchar*
 685 type_descriptive_name_I (GType type)
 686 {
 687   if (type)
 688     {
 689       TypeNode *node = lookup_type_node_I (type);
 690 
 691       return node ? NODE_NAME (node) : &quot;&lt;unknown&gt;&quot;;
 692     }
 693   else
 694     return &quot;&lt;invalid&gt;&quot;;
 695 }
 696 
 697 
 698 /* --- type consistency checks --- */
 699 static gboolean
 700 check_plugin_U (GTypePlugin *plugin,
<span class="line-modified"> 701         gboolean     need_complete_type_info,</span>
<span class="line-modified"> 702         gboolean     need_complete_interface_info,</span>
<span class="line-modified"> 703         const gchar *type_name)</span>
 704 {
 705   /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
 706    */
 707   if (!plugin)
 708     {
 709       g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
<span class="line-modified"> 710          type_name);</span>
 711       return FALSE;
 712     }
 713   if (!G_IS_TYPE_PLUGIN (plugin))
 714     {
 715       g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
<span class="line-modified"> 716          plugin, type_name);</span>
 717       return FALSE;
 718     }
 719   if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
 720     {
 721       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
<span class="line-modified"> 722          type_name);</span>
 723       return FALSE;
 724     }
 725   if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
 726     {
 727       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
<span class="line-modified"> 728          type_name);</span>
 729       return FALSE;
 730     }
 731   return TRUE;
 732 }
 733 
 734 static gboolean
 735 check_type_name_I (const gchar *type_name)
 736 {
 737   static const gchar extra_chars[] = &quot;-_+&quot;;
 738   const gchar *p = type_name;
 739   gboolean name_valid;
 740 
 741   if (!type_name[0] || !type_name[1] || !type_name[2])
 742     {
 743       g_warning (&quot;type name &#39;%s&#39; is too short&quot;, type_name);
 744       return FALSE;
 745     }
 746   /* check the first letter */
 747   name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
 748   for (p = type_name + 1; *p; p++)
 749     name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
<span class="line-modified"> 750            (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="line-modified"> 751            (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="line-modified"> 752            strchr (extra_chars, p[0]));</span>
 753   if (!name_valid)
 754     {
 755       g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
 756       return FALSE;
 757     }
 758   if (g_type_from_name (type_name))
 759     {
 760       g_warning (&quot;cannot register existing type &#39;%s&#39;&quot;, type_name);
 761       return FALSE;
 762     }
 763 
 764   return TRUE;
 765 }
 766 
 767 static gboolean
 768 check_derivation_I (GType        parent_type,
<span class="line-modified"> 769             const gchar *type_name)</span>
 770 {
 771   TypeNode *pnode;
 772   GTypeFundamentalInfo* finfo;
 773 
 774   pnode = lookup_type_node_I (parent_type);
 775   if (!pnode)
 776     {
 777       g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 778          type_name,</span>
<span class="line-modified"> 779          type_descriptive_name_I (parent_type));</span>
 780       return FALSE;
 781     }
 782   finfo = type_node_fundamental_info_I (pnode);
 783   /* ensure flat derivability */
 784   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
 785     {
 786       g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 787          type_name,</span>
<span class="line-modified"> 788          NODE_NAME (pnode));</span>
 789       return FALSE;
 790     }
 791   /* ensure deep derivability */
 792   if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
 793       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
 794     {
 795       g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 796          type_name,</span>
<span class="line-modified"> 797          NODE_NAME (pnode));</span>
 798       return FALSE;
 799     }
 800 
 801   return TRUE;
 802 }
 803 
 804 static gboolean
 805 check_collect_format_I (const gchar *collect_format)
 806 {
 807   const gchar *p = collect_format;
 808   gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
<span class="line-modified"> 809                G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="line-modified"> 810                G_VALUE_COLLECT_POINTER, 0 };</span>
 811 
 812   while (*p)
 813     if (!strchr (valid_format, *p++))
 814       return FALSE;
 815   return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
 816 }
 817 
 818 static gboolean
 819 check_value_table_I (const gchar           *type_name,
<span class="line-modified"> 820              const GTypeValueTable *value_table)</span>
 821 {
 822   if (!value_table)
 823     return FALSE;
 824   else if (value_table-&gt;value_init == NULL)
 825     {
 826       if (value_table-&gt;value_free || value_table-&gt;value_copy ||
<span class="line-modified"> 827       value_table-&gt;value_peek_pointer ||</span>
<span class="line-modified"> 828       value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="line-modified"> 829       value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="line-modified"> 830     g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 831            type_name);</span>
 832       return FALSE;
 833     }
 834   else /* value_table-&gt;value_init != NULL */
 835     {
 836       if (!value_table-&gt;value_free)
<span class="line-modified"> 837     {</span>
<span class="line-modified"> 838       /* +++ optional +++</span>
<span class="line-modified"> 839        * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified"> 840        * return FALSE;</span>
<span class="line-modified"> 841        */</span>
<span class="line-modified"> 842     }</span>
 843       if (!value_table-&gt;value_copy)
<span class="line-modified"> 844     {</span>
<span class="line-modified"> 845       g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified"> 846       return FALSE;</span>
<span class="line-modified"> 847     }</span>
 848       if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
<span class="line-modified"> 849       (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="line-modified"> 850     {</span>
<span class="line-modified"> 851       g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 852              type_name);</span>
<span class="line-modified"> 853       return FALSE;</span>
<span class="line-modified"> 854     }</span>
 855       if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
<span class="line-modified"> 856     {</span>
<span class="line-modified"> 857       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified"> 858              &quot;collect_format&quot;,</span>
<span class="line-modified"> 859              type_name);</span>
<span class="line-modified"> 860       return FALSE;</span>
<span class="line-modified"> 861     }</span>
 862       if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
<span class="line-modified"> 863       (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="line-modified"> 864     {</span>
<span class="line-modified"> 865       g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 866              type_name);</span>
<span class="line-modified"> 867       return FALSE;</span>
<span class="line-modified"> 868     }</span>
 869       if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
<span class="line-modified"> 870     {</span>
<span class="line-modified"> 871       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified"> 872              &quot;lcopy_format&quot;,</span>
<span class="line-modified"> 873              type_name);</span>
<span class="line-modified"> 874       return FALSE;</span>
<span class="line-modified"> 875     }</span>
 876     }
 877   return TRUE;
 878 }
 879 
 880 static gboolean
 881 check_type_info_I (TypeNode        *pnode,
<span class="line-modified"> 882            GType            ftype,</span>
<span class="line-modified"> 883            const gchar     *type_name,</span>
<span class="line-modified"> 884            const GTypeInfo *info)</span>
 885 {
 886   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
 887   gboolean is_interface = ftype == G_TYPE_INTERFACE;
 888 
 889   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
 890 
 891   /* check instance members */
 892   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
 893       (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
 894     {
 895       if (pnode)
<span class="line-modified"> 896     g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 897            type_name,</span>
<span class="line-modified"> 898            NODE_NAME (pnode));</span>
 899       else
<span class="line-modified"> 900     g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="line-modified"> 901            type_name);</span>
 902       return FALSE;
 903     }
 904   /* check class &amp; interface members */
 905   if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
 906       (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
 907        info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
 908     {
 909       if (pnode)
<span class="line-modified"> 910     g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 911            type_name,</span>
 912                    NODE_NAME (pnode));
 913       else
<span class="line-modified"> 914     g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="line-modified"> 915            type_name);</span>
 916       return FALSE;
 917     }
 918   /* check interface size */
 919   if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
 920     {
 921       g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
<span class="line-modified"> 922          type_name);</span>
 923       return FALSE;
 924     }
 925   /* check class size */
 926   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
 927     {
 928       if (info-&gt;class_size &lt; sizeof (GTypeClass))
<span class="line-modified"> 929     {</span>
<span class="line-modified"> 930       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="line-modified"> 931              type_name);</span>
<span class="line-modified"> 932       return FALSE;</span>
<span class="line-modified"> 933     }</span>
 934       if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
<span class="line-modified"> 935     {</span>
<span class="line-modified"> 936       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified"> 937              &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="line-modified"> 938              type_name,</span>
<span class="line-modified"> 939              NODE_NAME (pnode));</span>
<span class="line-modified"> 940       return FALSE;</span>
<span class="line-modified"> 941     }</span>
 942     }
 943   /* check instance size */
 944   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
 945     {
 946       if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
<span class="line-modified"> 947     {</span>
<span class="line-modified"> 948       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="line-modified"> 949              type_name);</span>
<span class="line-modified"> 950       return FALSE;</span>
<span class="line-modified"> 951     }</span>
 952       if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
<span class="line-modified"> 953     {</span>
<span class="line-modified"> 954       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified"> 955              &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="line-modified"> 956              type_name,</span>
<span class="line-modified"> 957              NODE_NAME (pnode));</span>
<span class="line-modified"> 958       return FALSE;</span>
<span class="line-modified"> 959     }</span>
 960     }
 961 
 962   return TRUE;
 963 }
 964 
 965 static TypeNode*
 966 find_conforming_child_type_L (TypeNode *pnode,
<span class="line-modified"> 967                   TypeNode *iface)</span>
 968 {
 969   TypeNode *node = NULL;
 970   guint i;
 971 
 972   if (type_lookup_iface_entry_L (pnode, iface))
 973     return pnode;
 974 
 975   for (i = 0; i &lt; pnode-&gt;n_children &amp;&amp; !node; i++)
 976     node = find_conforming_child_type_L (lookup_type_node_I (pnode-&gt;children[i]), iface);
 977 
 978   return node;
 979 }
 980 
 981 static gboolean
 982 check_add_interface_L (GType instance_type,
<span class="line-modified"> 983                GType iface_type)</span>
 984 {
 985   TypeNode *node = lookup_type_node_I (instance_type);
 986   TypeNode *iface = lookup_type_node_I (iface_type);
 987   IFaceEntry *entry;
 988   TypeNode *tnode;
 989   GType *prerequisites;
 990   guint i;
 991 
 992 
 993   if (!node || !node-&gt;is_instantiatable)
 994     {
 995       g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified"> 996          type_descriptive_name_I (instance_type));</span>
 997       return FALSE;
 998     }
 999   if (!iface || !NODE_IS_IFACE (iface))
1000     {
1001       g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
<span class="line-modified">1002          type_descriptive_name_I (iface_type),</span>
<span class="line-modified">1003          NODE_NAME (node));</span>
1004       return FALSE;
1005     }
1006   if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
1007     {
1008       g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
1009                  NODE_NAME (iface), NODE_NAME (node));
1010       return FALSE;
1011     }
1012   tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
1013   if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
1014     {
1015       /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
1016       g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
<span class="line-modified">1017          NODE_NAME (iface),</span>
<span class="line-modified">1018          NODE_NAME (node),</span>
<span class="line-modified">1019          NODE_NAME (tnode));</span>
1020       return FALSE;
1021     }
1022   /* allow overriding of interface type introduced for parent type */
1023   entry = type_lookup_iface_entry_L (node, iface);
1024   if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
1025     {
1026       /* ok, we do conform to this interface already, but the interface vtable was not
1027        * yet intialized, and we just conform to the interface because it got added to
1028        * one of our parents. so we allow overriding of holder info here.
1029        */
1030       return TRUE;
1031     }
1032   /* check whether one of our children already conforms (or whether the interface
1033    * got added to this node already)
1034    */
1035   tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
1036   if (tnode)
1037     {
1038       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
<span class="line-modified">1039          NODE_NAME (iface),</span>
<span class="line-modified">1040          NODE_NAME (node),</span>
<span class="line-modified">1041          NODE_NAME (tnode));</span>
1042       return FALSE;
1043     }
1044   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1045   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1046     {
1047       tnode = lookup_type_node_I (prerequisites[i]);
1048       if (!type_node_is_a_L (node, tnode))
<span class="line-modified">1049     {</span>
<span class="line-modified">1050       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">1051              NODE_NAME (iface),</span>
<span class="line-modified">1052              NODE_NAME (node),</span>
<span class="line-modified">1053              NODE_NAME (tnode));</span>
<span class="line-modified">1054       return FALSE;</span>
<span class="line-modified">1055     }</span>
1056     }
1057   return TRUE;
1058 }
1059 
1060 static gboolean
1061 check_interface_info_I (TypeNode             *iface,
<span class="line-modified">1062             GType                 instance_type,</span>
<span class="line-modified">1063             const GInterfaceInfo *info)</span>
1064 {
1065   if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
1066     {
1067       g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
<span class="line-modified">1068          NODE_NAME (iface),</span>
<span class="line-modified">1069          type_descriptive_name_I (instance_type));</span>
1070       return FALSE;
1071     }
1072 
1073   return TRUE;
1074 }
1075 
1076 /* --- type info (type node data) --- */
1077 static void
1078 type_data_make_W (TypeNode              *node,
<span class="line-modified">1079           const GTypeInfo       *info,</span>
<span class="line-modified">1080           const GTypeValueTable *value_table)</span>
1081 {
1082   TypeData *data;
1083   GTypeValueTable *vtable = NULL;
1084   guint vtable_size = 0;
1085 
1086   g_assert (node-&gt;data == NULL &amp;&amp; info != NULL);
1087 
1088   if (!value_table)
1089     {
1090       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1091 
1092       if (pnode)
<span class="line-modified">1093     vtable = pnode-&gt;data-&gt;common.value_table;</span>
1094       else
<span class="line-modified">1095     {</span>
<span class="line-modified">1096       static const GTypeValueTable zero_vtable = { NULL, };</span>
1097 
<span class="line-modified">1098       value_table = &amp;zero_vtable;</span>
<span class="line-modified">1099     }</span>
1100     }
1101   if (value_table)
1102     {
1103       /* need to setup vtable_size since we have to allocate it with data in one chunk */
1104       vtable_size = sizeof (GTypeValueTable);
1105       if (value_table-&gt;collect_format)
<span class="line-modified">1106     vtable_size += strlen (value_table-&gt;collect_format);</span>
1107       if (value_table-&gt;lcopy_format)
<span class="line-modified">1108     vtable_size += strlen (value_table-&gt;lcopy_format);</span>
1109       vtable_size += 2;
1110     }
1111 
1112   if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
1113     {
1114       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1115 
1116       data = g_malloc0 (sizeof (InstanceData) + vtable_size);
1117 #ifdef GSTREAMER_LITE
1118       if (data == NULL)
1119           return;
1120 #endif // GSTREAMER_LITE
1121       if (vtable_size)
<span class="line-modified">1122     vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
1123       data-&gt;instance.class_size = info-&gt;class_size;
1124       data-&gt;instance.class_init_base = info-&gt;base_init;
1125       data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
1126       data-&gt;instance.class_init = info-&gt;class_init;
1127       data-&gt;instance.class_finalize = info-&gt;class_finalize;
1128       data-&gt;instance.class_data = info-&gt;class_data;
1129       data-&gt;instance.class = NULL;
1130       data-&gt;instance.init_state = UNINITIALIZED;
1131       data-&gt;instance.instance_size = info-&gt;instance_size;
1132       /* We&#39;ll set the final value for data-&gt;instance.private size
1133        * after the parent class has been initialized
1134        */
1135       data-&gt;instance.private_size = 0;
1136       data-&gt;instance.class_private_size = 0;
1137       if (pnode)
1138         data-&gt;instance.class_private_size = pnode-&gt;data-&gt;instance.class_private_size;
1139       data-&gt;instance.n_preallocs = MIN (info-&gt;n_preallocs, 1024);
1140       data-&gt;instance.instance_init = info-&gt;instance_init;
1141     }
1142   else if (node-&gt;is_classed) /* only classed */
1143     {
1144       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1145 
1146       data = g_malloc0 (sizeof (ClassData) + vtable_size);
1147       if (vtable_size)
<span class="line-modified">1148     vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
1149       data-&gt;class.class_size = info-&gt;class_size;
1150       data-&gt;class.class_init_base = info-&gt;base_init;
1151       data-&gt;class.class_finalize_base = info-&gt;base_finalize;
1152       data-&gt;class.class_init = info-&gt;class_init;
1153       data-&gt;class.class_finalize = info-&gt;class_finalize;
1154       data-&gt;class.class_data = info-&gt;class_data;
1155       data-&gt;class.class = NULL;
1156       data-&gt;class.class_private_size = 0;
1157       if (pnode)
1158         data-&gt;class.class_private_size = pnode-&gt;data-&gt;class.class_private_size;
1159       data-&gt;class.init_state = UNINITIALIZED;
1160     }
1161   else if (NODE_IS_IFACE (node))
1162     {
1163       data = g_malloc0 (sizeof (IFaceData) + vtable_size);
1164       if (vtable_size)
<span class="line-modified">1165     vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
1166       data-&gt;iface.vtable_size = info-&gt;class_size;
1167       data-&gt;iface.vtable_init_base = info-&gt;base_init;
1168       data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
1169       data-&gt;iface.dflt_init = info-&gt;class_init;
1170       data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
1171       data-&gt;iface.dflt_data = info-&gt;class_data;
1172       data-&gt;iface.dflt_vtable = NULL;
1173     }
1174   else if (NODE_IS_BOXED (node))
1175     {
1176       data = g_malloc0 (sizeof (BoxedData) + vtable_size);
1177       if (vtable_size)
<span class="line-modified">1178     vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
1179     }
1180   else
1181     {
1182       data = g_malloc0 (sizeof (CommonData) + vtable_size);
1183       if (vtable_size)
<span class="line-modified">1184     vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
1185     }
1186 
1187   node-&gt;data = data;
1188 
1189   if (vtable_size)
1190     {
1191       gchar *p;
1192 
1193       /* we allocate the vtable and its strings together with the type data, so
1194        * children can take over their parent&#39;s vtable pointer, and we don&#39;t
1195        * need to worry freeing it or not when the child data is destroyed
1196        */
1197       *vtable = *value_table;
1198       p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
1199       p[0] = 0;
1200       vtable-&gt;collect_format = p;
1201       if (value_table-&gt;collect_format)
<span class="line-modified">1202     {</span>
<span class="line-modified">1203       strcat (p, value_table-&gt;collect_format);</span>
<span class="line-modified">1204       p += strlen (value_table-&gt;collect_format);</span>
<span class="line-modified">1205     }</span>
1206       p++;
1207       p[0] = 0;
1208       vtable-&gt;lcopy_format = p;
1209       if (value_table-&gt;lcopy_format)
<span class="line-modified">1210     strcat  (p, value_table-&gt;lcopy_format);</span>
1211     }
1212   node-&gt;data-&gt;common.value_table = vtable;
1213   node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
<span class="line-modified">1214                  !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="line-modified">1215                    GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
1216 
1217   g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
1218 
1219   g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
1220 }
1221 
1222 static inline void
1223 type_data_ref_Wm (TypeNode *node)
1224 {
1225   if (!node-&gt;data)
1226     {
1227       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1228       GTypeInfo tmp_info;
1229       GTypeValueTable tmp_value_table;
1230 
1231       g_assert (node-&gt;plugin != NULL);
1232 
1233       if (pnode)
<span class="line-modified">1234     {</span>
<span class="line-modified">1235       type_data_ref_Wm (pnode);</span>
<span class="line-modified">1236       if (node-&gt;data)</span>
<span class="line-modified">1237         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="line-modified">1238     }</span>
1239 
1240       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1241       memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
1242 
1243       G_WRITE_UNLOCK (&amp;type_rw_lock);
1244       g_type_plugin_use (node-&gt;plugin);
1245       g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
1246       G_WRITE_LOCK (&amp;type_rw_lock);
1247       if (node-&gt;data)
<span class="line-modified">1248     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
1249 
1250       check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
1251       type_data_make_W (node, &amp;tmp_info,
<span class="line-modified">1252             check_value_table_I (NODE_NAME (node),</span>
<span class="line-modified">1253                          &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
1254     }
1255   else
1256     {
1257       g_assert (NODE_REFCOUNT (node) &gt; 0);
1258 
1259       g_atomic_int_inc ((int *) &amp;node-&gt;ref_count);
1260     }
1261 }
1262 
1263 static inline gboolean
1264 type_data_ref_U (TypeNode *node)
1265 {
1266   guint current;
1267 
1268   do {
1269     current = NODE_REFCOUNT (node);
1270 
1271     if (current &lt; 1)
1272       return FALSE;
1273   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current + 1));
1274 
1275   return TRUE;
1276 }
1277 
1278 static gboolean
1279 iface_node_has_available_offset_L (TypeNode *iface_node,
<span class="line-modified">1280                    int offset,</span>
<span class="line-modified">1281                    int for_index)</span>
1282 {
1283   guint8 *offsets;
1284 
1285   offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1286   if (offsets == NULL)
1287     return TRUE;
1288 
1289   if (G_ATOMIC_ARRAY_DATA_SIZE (offsets) &lt;= offset)
1290     return TRUE;
1291 
1292   if (offsets[offset] == 0 ||
1293       offsets[offset] == for_index+1)
1294     return TRUE;
1295 
1296   return FALSE;
1297 }
1298 
1299 static int
1300 find_free_iface_offset_L (IFaceEntries *entries)
1301 {
1302   IFaceEntry *entry;
1303   TypeNode *iface_node;
1304   int offset;
1305   int i;
1306   int n_entries;
1307 
1308   n_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1309   offset = -1;
1310   do
1311     {
1312       offset++;
1313       for (i = 0; i &lt; n_entries; i++)
<span class="line-modified">1314     {</span>
<span class="line-modified">1315       entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">1316       iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
1317 
<span class="line-modified">1318       if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="line-modified">1319         break;</span>
<span class="line-modified">1320     }</span>
1321     }
1322   while (i != n_entries);
1323 
1324   return offset;
1325 }
1326 
1327 static void
1328 iface_node_set_offset_L (TypeNode *iface_node,
<span class="line-modified">1329              int offset,</span>
<span class="line-modified">1330              int index)</span>
1331 {
1332   guint8 *offsets, *old_offsets;
1333   int new_size, old_size;
1334   int i;
1335 
1336   old_offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1337   if (old_offsets == NULL)
1338     old_size = 0;
1339   else
1340     {
1341       old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
1342       if (offset &lt; old_size &amp;&amp;
<span class="line-modified">1343       old_offsets[offset] == index + 1)</span>
<span class="line-modified">1344     return; /* Already set to this index, return */</span>
1345     }
1346   new_size = MAX (old_size, offset + 1);
1347 
1348   offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
<span class="line-modified">1349                   0, new_size - old_size);</span>
1350 
1351   /* Mark new area as unused */
1352   for (i = old_size; i &lt; new_size; i++)
1353     offsets[i] = 0;
1354 
1355   offsets[offset] = index + 1;
1356 
1357   _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
1358 }
1359 
1360 static void
1361 type_node_add_iface_entry_W (TypeNode   *node,
<span class="line-modified">1362                  GType       iface_type,</span>
1363                              IFaceEntry *parent_entry)
1364 {
1365   IFaceEntries *entries;
1366   IFaceEntry *entry;
1367   TypeNode *iface_node;
1368   guint i, j;
1369   int num_entries;
1370 
1371   g_assert (node-&gt;is_instantiatable);
1372 
1373   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
1374   if (entries != NULL)
1375     {
1376       num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1377 
1378       g_assert (num_entries &lt; MAX_N_INTERFACES);
1379 
1380       for (i = 0; i &lt; num_entries; i++)
<span class="line-modified">1381     {</span>
<span class="line-modified">1382       entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">1383       if (entry-&gt;iface_type == iface_type)</span>
<span class="line-modified">1384         {</span>
<span class="line-modified">1385           /* this can happen in two cases:</span>
<span class="line-modified">1386            * - our parent type already conformed to iface_type and node</span>
<span class="line-modified">1387            *   got its own holder info. here, our children already have</span>
<span class="line-modified">1388            *   entries and NULL vtables, since this will only work for</span>
<span class="line-modified">1389            *   uninitialized classes.</span>
<span class="line-modified">1390            * - an interface type is added to an ancestor after it was</span>
<span class="line-modified">1391            *   added to a child type.</span>
<span class="line-modified">1392            */</span>
<span class="line-modified">1393           if (!parent_entry)</span>
<span class="line-modified">1394         g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="line-modified">1395           else</span>
<span class="line-modified">1396         {</span>
<span class="line-modified">1397           /* sick, interface is added to ancestor *after* child type;</span>
<span class="line-modified">1398            * nothing todo, the entry and our children were already setup correctly</span>
<span class="line-modified">1399            */</span>
<span class="line-removed">1400         }</span>
<span class="line-removed">1401           return;</span>
<span class="line-removed">1402         }</span>
1403     }



1404     }
1405 
1406   entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
<span class="line-modified">1407                   IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-modified">1408                   sizeof (IFaceEntry));</span>
1409   num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1410   i = num_entries - 1;
1411   if (i == 0)
1412     entries-&gt;offset_index = 0;
1413   entries-&gt;entry[i].iface_type = iface_type;
1414   entries-&gt;entry[i].vtable = NULL;
1415   entries-&gt;entry[i].init_state = UNINITIALIZED;
1416 
1417   if (parent_entry)
1418     {
1419       if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.init_state &gt;= BASE_IFACE_INIT)
1420         {
1421           entries-&gt;entry[i].init_state = INITIALIZED;
1422           entries-&gt;entry[i].vtable = parent_entry-&gt;vtable;
1423         }
1424     }
1425 
1426   /* Update offsets in iface */
1427   iface_node = lookup_type_node_I (iface_type);
1428 
1429   if (iface_node_has_available_offset_L (iface_node,
<span class="line-modified">1430                      entries-&gt;offset_index,</span>
<span class="line-modified">1431                      i))</span>
1432     {
1433       iface_node_set_offset_L (iface_node,
<span class="line-modified">1434                    entries-&gt;offset_index, i);</span>
1435     }
1436   else
1437    {
1438       entries-&gt;offset_index =
<span class="line-modified">1439     find_free_iface_offset_L (entries);</span>
1440       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
<span class="line-modified">1441     {</span>
<span class="line-modified">1442       entry = &amp;entries-&gt;entry[j];</span>
<span class="line-modified">1443       iface_node =</span>
<span class="line-modified">1444         lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="line-modified">1445       iface_node_set_offset_L (iface_node,</span>
<span class="line-modified">1446                    entries-&gt;offset_index, j);</span>
<span class="line-modified">1447     }</span>
1448     }
1449 
1450   _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
1451 
1452   if (parent_entry)
1453     {
1454       for (i = 0; i &lt; node-&gt;n_children; i++)
1455         type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), iface_type, &amp;entries-&gt;entry[i]);
1456     }
1457 }
1458 
1459 static void
1460 type_add_interface_Wm (TypeNode             *node,
1461                        TypeNode             *iface,
1462                        const GInterfaceInfo *info,
1463                        GTypePlugin          *plugin)
1464 {
1465   IFaceHolder *iholder = g_new0 (IFaceHolder, 1);
1466   IFaceEntry *entry;
1467   guint i;
</pre>
<hr />
<pre>
1482    */
1483   if (node-&gt;data)
1484     {
1485       InitState class_state = node-&gt;data-&gt;class.init_state;
1486 
1487       if (class_state &gt;= BASE_IFACE_INIT)
1488         type_iface_vtable_base_init_Wm (iface, node);
1489 
1490       if (class_state &gt;= IFACE_INIT)
1491         type_iface_vtable_iface_init_Wm (iface, node);
1492     }
1493 
1494   /* create iface entries for children of this type */
1495   entry = type_lookup_iface_entry_L (node, iface);
1496   for (i = 0; i &lt; node-&gt;n_children; i++)
1497     type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
1498 }
1499 
1500 static void
1501 type_iface_add_prerequisite_W (TypeNode *iface,
<span class="line-modified">1502                    TypeNode *prerequisite_node)</span>
1503 {
1504   GType prerequisite_type = NODE_TYPE (prerequisite_node);
1505   GType *prerequisites, *dependants;
1506   guint n_dependants, i;
1507 
1508   g_assert (NODE_IS_IFACE (iface) &amp;&amp;
<span class="line-modified">1509         IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="line-modified">1510         (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
1511 
1512   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1513   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1514     if (prerequisites[i] == prerequisite_type)
<span class="line-modified">1515       return;           /* we already have that prerequisiste */</span>
1516     else if (prerequisites[i] &gt; prerequisite_type)
1517       break;
1518   IFACE_NODE_N_PREREQUISITES (iface) += 1;
1519   IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
<span class="line-modified">1520                           IFACE_NODE_PREREQUISITES (iface),</span>
<span class="line-modified">1521                           IFACE_NODE_N_PREREQUISITES (iface));</span>
1522   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1523   memmove (prerequisites + i + 1, prerequisites + i,
1524            sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
1525   prerequisites[i] = prerequisite_type;
1526 
1527   /* we want to get notified when prerequisites get added to prerequisite_node */
1528   if (NODE_IS_IFACE (prerequisite_node))
1529     {
1530       dependants = iface_node_get_dependants_array_L (prerequisite_node);
1531       n_dependants = dependants ? dependants[0] : 0;
1532       n_dependants += 1;
1533       dependants = g_renew (GType, dependants, n_dependants + 1);
1534       dependants[n_dependants] = NODE_TYPE (iface);
1535       dependants[0] = n_dependants;
1536       iface_node_set_dependants_array_W (prerequisite_node, dependants);
1537     }
1538 
1539   /* we need to notify all dependants */
1540   dependants = iface_node_get_dependants_array_L (iface);
1541   n_dependants = dependants ? dependants[0] : 0;
1542   for (i = 1; i &lt;= n_dependants; i++)
1543     type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
1544 }
1545 
1546 /**
1547  * g_type_interface_add_prerequisite:
1548  * @interface_type: #GType value of an interface type
1549  * @prerequisite_type: #GType value of an interface or instantiatable type
1550  *
1551  * Adds @prerequisite_type to the list of prerequisites of @interface_type.
1552  * This means that any type implementing @interface_type must also implement
1553  * @prerequisite_type. Prerequisites can be thought of as an alternative to
1554  * interface derivation (which GType doesn&#39;t support). An interface can have
1555  * at most one instantiatable prerequisite type.
1556  */
1557 void
1558 g_type_interface_add_prerequisite (GType interface_type,
<span class="line-modified">1559                    GType prerequisite_type)</span>
1560 {
1561   TypeNode *iface, *prerequisite_node;
1562   IFaceHolder *holders;
1563 
1564   g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
1565   g_return_if_fail (!g_type_is_a (interface_type, prerequisite_type));
1566   g_return_if_fail (!g_type_is_a (prerequisite_type, interface_type));
1567 
1568   iface = lookup_type_node_I (interface_type);
1569   prerequisite_node = lookup_type_node_I (prerequisite_type);
1570   if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
1571     {
1572       g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
<span class="line-modified">1573          type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1574          type_descriptive_name_I (prerequisite_type));</span>
1575       return;
1576     }
1577   G_WRITE_LOCK (&amp;type_rw_lock);
1578   holders = iface_node_get_holders_L (iface);
1579   if (holders)
1580     {
1581       G_WRITE_UNLOCK (&amp;type_rw_lock);
1582       g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
<span class="line-modified">1583          type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1584          type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1585          type_descriptive_name_I (holders-&gt;instance_type));</span>
1586       return;
1587     }
1588   if (prerequisite_node-&gt;is_instantiatable)
1589     {
1590       guint i;
1591 
1592       /* can have at most one publicly installable instantiatable prerequisite */
1593       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">1594     {</span>
<span class="line-modified">1595       TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
1596 
<span class="line-modified">1597       if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">1598         {</span>
<span class="line-modified">1599           G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">1600           g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">1601              type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1602              type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1603              type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="line-modified">1604           return;</span>
<span class="line-modified">1605         }</span>
<span class="line-modified">1606     }</span>
1607 
1608       for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
<span class="line-modified">1609     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
1610       G_WRITE_UNLOCK (&amp;type_rw_lock);
1611     }
1612   else if (NODE_IS_IFACE (prerequisite_node))
1613     {
1614       GType *prerequisites;
1615       guint i;
1616 
1617       prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
1618       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
<span class="line-modified">1619     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
1620       type_iface_add_prerequisite_W (iface, prerequisite_node);
1621       G_WRITE_UNLOCK (&amp;type_rw_lock);
1622     }
1623   else
1624     {
1625       G_WRITE_UNLOCK (&amp;type_rw_lock);
1626       g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
<span class="line-modified">1627          type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1628          type_descriptive_name_I (interface_type));</span>
1629     }
1630 }
1631 
1632 /**
1633  * g_type_interface_prerequisites:
1634  * @interface_type: an interface type
1635  * @n_prerequisites: (out) (optional): location to return the number
1636  *     of prerequisites, or %NULL
1637  *
1638  * Returns the prerequisites of an interfaces type.
1639  *
1640  * Since: 2.2
1641  *
1642  * Returns: (array length=n_prerequisites) (transfer full): a
1643  *     newly-allocated zero-terminated array of #GType containing
1644  *     the prerequisites of @interface_type
1645  */
1646 GType*
1647 g_type_interface_prerequisites (GType  interface_type,
<span class="line-modified">1648                 guint *n_prerequisites)</span>
1649 {
1650   TypeNode *iface;
1651 
1652   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
1653 
1654   iface = lookup_type_node_I (interface_type);
1655   if (iface)
1656     {
1657       GType *types;
1658       TypeNode *inode = NULL;
1659       guint i, n = 0;
1660 
1661       G_READ_LOCK (&amp;type_rw_lock);
1662       types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
1663       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">1664     {</span>
<span class="line-modified">1665       GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="line-modified">1666       TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="line-modified">1667       if (node-&gt;is_instantiatable)</span>
1668             {
1669               if (!inode || type_node_is_a_L (node, inode))
<span class="line-modified">1670             inode = node;</span>
1671             }
<span class="line-modified">1672       else</span>
<span class="line-modified">1673         types[n++] = NODE_TYPE (node);</span>
<span class="line-modified">1674     }</span>
1675       if (inode)
<span class="line-modified">1676     types[n++] = NODE_TYPE (inode);</span>
1677 
1678       if (n_prerequisites)
<span class="line-modified">1679     *n_prerequisites = n;</span>
1680       G_READ_UNLOCK (&amp;type_rw_lock);
1681 
1682       return types;
1683     }
1684   else
1685     {
1686       if (n_prerequisites)
<span class="line-modified">1687     *n_prerequisites = 0;</span>
1688 
1689       return NULL;
1690     }
1691 }
1692 
1693 
1694 static IFaceHolder*
1695 type_iface_peek_holder_L (TypeNode *iface,
<span class="line-modified">1696               GType     instance_type)</span>
1697 {
1698   IFaceHolder *iholder;
1699 
1700   g_assert (NODE_IS_IFACE (iface));
1701 
1702   iholder = iface_node_get_holders_L (iface);
1703   while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
1704     iholder = iholder-&gt;next;
1705   return iholder;
1706 }
1707 
1708 static IFaceHolder*
1709 type_iface_retrieve_holder_info_Wm (TypeNode *iface,
<span class="line-modified">1710                     GType     instance_type,</span>
<span class="line-modified">1711                     gboolean  need_info)</span>
1712 {
1713   IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
1714 
1715   if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
1716     {
1717       GInterfaceInfo tmp_info;
1718 
1719       g_assert (iholder-&gt;plugin != NULL);
1720 
1721       type_data_ref_Wm (iface);
1722       if (iholder-&gt;info)
<span class="line-modified">1723     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
1724 
1725       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1726 
1727       G_WRITE_UNLOCK (&amp;type_rw_lock);
1728       g_type_plugin_use (iholder-&gt;plugin);
1729       g_type_plugin_complete_interface_info (iholder-&gt;plugin, instance_type, NODE_TYPE (iface), &amp;tmp_info);
1730       G_WRITE_LOCK (&amp;type_rw_lock);
1731       if (iholder-&gt;info)
1732         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iholder-&gt;plugin, NODE_NAME (iface));
1733 
1734       check_interface_info_I (iface, instance_type, &amp;tmp_info);
1735       iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
1736     }
1737 
<span class="line-modified">1738   return iholder;   /* we don&#39;t modify write lock upon returning NULL */</span>
1739 }
1740 
1741 static void
1742 type_iface_blow_holder_info_Wm (TypeNode *iface,
<span class="line-modified">1743                 GType     instance_type)</span>
1744 {
1745   IFaceHolder *iholder = iface_node_get_holders_L (iface);
1746 
1747   g_assert (NODE_IS_IFACE (iface));
1748 
1749 #ifdef GSTREAMER_LITE
1750   if (iholder == NULL)
1751       return;
1752 #endif // GSTREAMER_LITE
1753 
1754   while (iholder-&gt;instance_type != instance_type)
1755     iholder = iholder-&gt;next;
1756 
1757   if (iholder-&gt;info &amp;&amp; iholder-&gt;plugin)
1758     {
1759       g_free (iholder-&gt;info);
1760       iholder-&gt;info = NULL;
1761 
1762       G_WRITE_UNLOCK (&amp;type_rw_lock);
1763       g_type_plugin_unuse (iholder-&gt;plugin);
</pre>
<hr />
<pre>
1788  * function, but g_object_new() instead.
1789  *
1790  * Returns: an allocated and initialized instance, subject to further
1791  *     treatment by the fundamental type implementation
1792  */
1793 GTypeInstance*
1794 g_type_create_instance (GType type)
1795 {
1796   TypeNode *node;
1797   GTypeInstance *instance;
1798   GTypeClass *class;
1799   gchar *allocated;
1800   gint private_size;
1801   gint ivar_size;
1802   guint i;
1803 
1804   node = lookup_type_node_I (type);
1805   if (!node || !node-&gt;is_instantiatable)
1806     {
1807       g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1808          type_descriptive_name_I (type));</span>
1809     }
1810   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1811   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
1812     {
1813       g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1814          type_descriptive_name_I (type));</span>
1815     }
1816 
1817   class = g_type_class_ref (type);
1818 
1819   /* We allocate the &#39;private&#39; areas before the normal instance data, in
1820    * reverse order.  This allows the private area of a particular class
1821    * to always be at a constant relative address to the instance data.
1822    * If we stored the private data after the instance data this would
1823    * not be the case (since a subclass that added more instance
1824    * variables would push the private data further along).
1825    *
1826    * This presents problems for valgrindability, of course, so we do a
1827    * workaround for that case.  We identify the start of the object to
1828    * valgrind as an allocated block (so that pointers to objects show up
1829    * as &#39;reachable&#39; instead of &#39;possibly lost&#39;).  We then add an extra
1830    * pointer at the end of the object, after all instance data, back to
1831    * the start of the private area so that it is also recorded as
1832    * reachable.  We also add extra private space at the start because
1833    * valgrind doesn&#39;t seem to like us claiming to have allocated an
1834    * address that it saw allocated by malloc().
</pre>
<hr />
<pre>
1845       allocated = g_slice_alloc0 (private_size + ivar_size + sizeof (gpointer));
1846       /* ... and point it back to the start of the private data. */
1847       *(gpointer *) (allocated + private_size + ivar_size) = allocated + ALIGN_STRUCT (1);
1848 
1849       /* Tell valgrind that it should treat the object itself as such */
1850       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, ivar_size + sizeof (gpointer), 0, TRUE);
1851       VALGRIND_MALLOCLIKE_BLOCK (allocated + ALIGN_STRUCT (1), private_size - ALIGN_STRUCT (1), 0, TRUE);
1852     }
1853   else
1854 #endif
1855     allocated = g_slice_alloc0 (private_size + ivar_size);
1856 
1857   instance = (GTypeInstance *) (allocated + private_size);
1858 
1859   for (i = node-&gt;n_supers; i &gt; 0; i--)
1860     {
1861       TypeNode *pnode;
1862 
1863       pnode = lookup_type_node_I (node-&gt;supers[i]);
1864       if (pnode-&gt;data-&gt;instance.instance_init)
<span class="line-modified">1865     {</span>
<span class="line-modified">1866       instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="line-modified">1867       pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="line-modified">1868     }</span>
1869     }
1870 
1871   instance-&gt;g_class = class;
1872   if (node-&gt;data-&gt;instance.instance_init)
1873     node-&gt;data-&gt;instance.instance_init (instance, class);
1874 
1875 #ifdef  G_ENABLE_DEBUG
1876   IF_DEBUG (INSTANCE_COUNT)
1877     {
1878       g_atomic_int_inc ((int *) &amp;node-&gt;instance_count);
1879     }
1880 #endif
1881 
1882   TRACE(GOBJECT_OBJECT_NEW(instance, type));
1883 
1884   return instance;
1885 }
1886 
1887 /**
1888  * g_type_free_instance:
</pre>
<hr />
<pre>
1893  *
1894  * Like g_type_create_instance(), this function is reserved for
1895  * implementors of fundamental types.
1896  */
1897 void
1898 g_type_free_instance (GTypeInstance *instance)
1899 {
1900   TypeNode *node;
1901   GTypeClass *class;
1902   gchar *allocated;
1903   gint private_size;
1904   gint ivar_size;
1905 
1906   g_return_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL);
1907 
1908   class = instance-&gt;g_class;
1909   node = lookup_type_node_I (class-&gt;g_type);
1910   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
1911     {
1912       g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1913          type_descriptive_name_I (class-&gt;g_type));</span>
1914       return;
1915     }
1916   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1917   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
1918     {
1919       g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1920          NODE_NAME (node));</span>
1921       return;
1922     }
1923 
1924   instance-&gt;g_class = NULL;
1925   private_size = node-&gt;data-&gt;instance.private_size;
1926   ivar_size = node-&gt;data-&gt;instance.instance_size;
1927   allocated = ((gchar *) instance) - private_size;
1928 
1929 #ifdef G_ENABLE_DEBUG
1930   memset (allocated, 0xaa, ivar_size + private_size);
1931 #endif
1932 
1933 #ifdef ENABLE_VALGRIND
1934   /* See comment in g_type_create_instance() about what&#39;s going on here.
1935    * We&#39;re basically unwinding what we put into motion there.
1936    */
1937   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1938     {
1939       private_size += ALIGN_STRUCT (1);
1940       allocated -= ALIGN_STRUCT (1);
</pre>
<hr />
<pre>
1983           if (iface-&gt;data-&gt;iface.vtable_init_base)
1984             iface-&gt;data-&gt;iface.vtable_init_base (vtable);
1985           if (iface-&gt;data-&gt;iface.dflt_init)
1986             iface-&gt;data-&gt;iface.dflt_init (vtable, (gpointer) iface-&gt;data-&gt;iface.dflt_data);
1987           G_WRITE_LOCK (&amp;type_rw_lock);
1988         }
1989     }
1990 }
1991 
1992 
1993 /* This is called to allocate and do the first part of initializing
1994  * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.
1995  *
1996  * A FALSE return indicates that we didn&#39;t find an init function for
1997  * this type/iface pair, so the vtable from the parent type should
1998  * be used. Note that the write lock is not modified upon a FALSE
1999  * return.
2000  */
2001 static gboolean
2002 type_iface_vtable_base_init_Wm (TypeNode *iface,
<span class="line-modified">2003                 TypeNode *node)</span>
2004 {
2005   IFaceEntry *entry;
2006   IFaceHolder *iholder;
2007   GTypeInterface *vtable = NULL;
2008   TypeNode *pnode;
2009 
2010   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2011   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
2012   if (!iholder)
<span class="line-modified">2013     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
2014 
2015   type_iface_ensure_dflt_vtable_Wm (iface);
2016 
2017   entry = type_lookup_iface_entry_L (node, iface);
2018 #ifdef GSTREAMER_LITE
2019   if (entry == NULL)
2020     return FALSE;
2021 #endif // GSTREAMER_LITE
2022 
2023   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2024 
2025   entry-&gt;init_state = IFACE_INIT;
2026 
2027   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
<span class="line-modified">2028   if (pnode)    /* want to copy over parent iface contents */</span>
2029     {
2030       IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
2031 
2032       if (pentry)
<span class="line-modified">2033     vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
2034     }
2035   if (!vtable)
2036     vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
2037   entry-&gt;vtable = vtable;
2038   vtable-&gt;g_type = NODE_TYPE (iface);
2039   vtable-&gt;g_instance_type = NODE_TYPE (node);
2040 
2041   if (iface-&gt;data-&gt;iface.vtable_init_base)
2042     {
2043       G_WRITE_UNLOCK (&amp;type_rw_lock);
2044       iface-&gt;data-&gt;iface.vtable_init_base (vtable);
2045       G_WRITE_LOCK (&amp;type_rw_lock);
2046     }
2047   return TRUE;  /* initialized the vtable */
2048 }
2049 
2050 /* Finishes what type_iface_vtable_base_init_Wm started by
2051  * calling the interface init function.
2052  * this function may only be called for types with their
2053  * own interface holder info, i.e. types for which
2054  * g_type_add_interface*() was called and not children thereof.
2055  */
2056 static void
2057 type_iface_vtable_iface_init_Wm (TypeNode *iface,
<span class="line-modified">2058                  TypeNode *node)</span>
2059 {
2060   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2061   IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
2062   GTypeInterface *vtable = NULL;
2063   guint i;
2064 
2065   /* iholder-&gt;info should have been filled in by type_iface_vtable_base_init_Wm() */
2066   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2067   g_assert (entry-&gt;init_state == IFACE_INIT); /* assert prior base_init() */
2068 #ifdef GSTREAMER_LITE
2069   if (entry == NULL)
2070     return;
2071 #endif // GSTREAMER_LITE
2072 
2073   entry-&gt;init_state = INITIALIZED;
2074 
2075   vtable = entry-&gt;vtable;
2076 
2077   if (iholder-&gt;info-&gt;interface_init)
2078     {
2079       G_WRITE_UNLOCK (&amp;type_rw_lock);
2080       if (iholder-&gt;info-&gt;interface_init)
<span class="line-modified">2081     iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
2082       G_WRITE_LOCK (&amp;type_rw_lock);
2083     }
2084 
2085   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2086     {
2087       GTypeInterfaceCheckFunc check_func = static_iface_check_funcs[i].check_func;
2088       gpointer check_data = static_iface_check_funcs[i].check_data;
2089 
2090       G_WRITE_UNLOCK (&amp;type_rw_lock);
2091       check_func (check_data, (gpointer)vtable);
2092       G_WRITE_LOCK (&amp;type_rw_lock);
2093     }
2094 }
2095 
2096 static gboolean
2097 type_iface_vtable_finalize_Wm (TypeNode       *iface,
<span class="line-modified">2098                    TypeNode       *node,</span>
<span class="line-modified">2099                    GTypeInterface *vtable)</span>
2100 {
2101   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2102   IFaceHolder *iholder;
2103 
2104   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2105   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
2106   if (!iholder)
<span class="line-modified">2107     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
2108 
2109   g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
2110 
2111   entry-&gt;vtable = NULL;
2112   entry-&gt;init_state = UNINITIALIZED;
2113   if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
2114     {
2115       G_WRITE_UNLOCK (&amp;type_rw_lock);
2116       if (iholder-&gt;info-&gt;interface_finalize)
<span class="line-modified">2117     iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
2118       if (iface-&gt;data-&gt;iface.vtable_finalize_base)
<span class="line-modified">2119     iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
2120       G_WRITE_LOCK (&amp;type_rw_lock);
2121     }
2122   vtable-&gt;g_type = 0;
2123   vtable-&gt;g_instance_type = 0;
2124   g_free (vtable);
2125 
2126   type_iface_blow_holder_info_Wm (iface, NODE_TYPE (node));
2127 
2128   return TRUE;  /* write lock modified */
2129 }
2130 
2131 static void
2132 type_class_init_Wm (TypeNode   *node,
<span class="line-modified">2133             GTypeClass *pclass)</span>
2134 {
2135   GSList *slist, *init_slist = NULL;
2136   GTypeClass *class;
2137   IFaceEntries *entries;
2138   IFaceEntry *entry;
2139   TypeNode *bnode, *pnode;
2140   guint i;
2141 
2142   /* Accessing data-&gt;class will work for instantiable types
2143    * too because ClassData is a subset of InstanceData
2144    */
2145   g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
<span class="line-modified">2146         node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="line-modified">2147         !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="line-modified">2148         node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
2149   if (node-&gt;data-&gt;class.class_private_size)
2150     class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
2151   else
2152     class = g_malloc0 (node-&gt;data-&gt;class.class_size);
2153   node-&gt;data-&gt;class.class = class;
2154   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_CLASS_INIT);
2155 
2156   if (pclass)
2157     {
2158       TypeNode *pnode = lookup_type_node_I (pclass-&gt;g_type);
2159 
2160       memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
2161       memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
2162 
2163       if (node-&gt;is_instantiatable)
<span class="line-modified">2164     {</span>
<span class="line-modified">2165       /* We need to initialize the private_size here rather than in</span>
<span class="line-modified">2166        * type_data_make_W() since the class init for the parent</span>
<span class="line-modified">2167        * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="line-modified">2168        */</span>
<span class="line-modified">2169       node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="line-modified">2170     }</span>
2171     }
2172   class-&gt;g_type = NODE_TYPE (node);
2173 
2174   G_WRITE_UNLOCK (&amp;type_rw_lock);
2175 
2176   /* stack all base class initialization functions, so we
2177    * call them in ascending order.
2178    */
2179   for (bnode = node; bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2180     if (bnode-&gt;data-&gt;class.class_init_base)
2181       init_slist = g_slist_prepend (init_slist, (gpointer) bnode-&gt;data-&gt;class.class_init_base);
2182   for (slist = init_slist; slist; slist = slist-&gt;next)
2183     {
2184       GBaseInitFunc class_init_base = (GBaseInitFunc) slist-&gt;data;
2185 
2186       class_init_base (class);
2187     }
2188   g_slist_free (init_slist);
2189 
2190   G_WRITE_LOCK (&amp;type_rw_lock);
2191 
2192   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_IFACE_INIT);
2193 
2194   /* Before we initialize the class, base initialize all interfaces, either
2195    * from parent, or through our holder info
2196    */
2197   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2198 
2199   i = 0;
2200   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
<span class="line-modified">2201       i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
2202     {
2203       entry = &amp;entries-&gt;entry[i];
2204       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">2205          entry-&gt;init_state == IFACE_INIT)</span>
<span class="line-modified">2206     {</span>
<span class="line-modified">2207       entry++;</span>
<span class="line-modified">2208       i++;</span>
<span class="line-modified">2209     }</span>
2210 
2211       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">2212     break;</span>
2213 
2214       if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
<span class="line-modified">2215     {</span>
<span class="line-modified">2216       guint j;</span>
<span class="line-modified">2217       IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
2218 
<span class="line-modified">2219       /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="line-modified">2220        * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="line-modified">2221        */</span>
<span class="line-modified">2222       g_assert (pnode != NULL);</span>
2223 
<span class="line-modified">2224       if (pentries)</span>
<span class="line-modified">2225         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="line-modified">2226           {</span>
<span class="line-modified">2227         IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
2228 
<span class="line-modified">2229         if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="line-modified">2230           {</span>
<span class="line-modified">2231             entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="line-modified">2232             entry-&gt;init_state = INITIALIZED;</span>
<span class="line-modified">2233             break;</span>
<span class="line-modified">2234           }</span>
<span class="line-modified">2235           }</span>
<span class="line-modified">2236       g_assert (entry-&gt;vtable != NULL);</span>
<span class="line-modified">2237     }</span>
2238 
2239       /* If the write lock was released, additional interface entries might
2240        * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
2241        * be base-initialized when inserted, so we don&#39;t have to worry that
2242        * we might miss them. Uninitialized entries can only be moved higher
2243        * when new ones are inserted.
2244        */
2245       i++;
2246     }
2247 
2248   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, CLASS_INIT);
2249 
2250   G_WRITE_UNLOCK (&amp;type_rw_lock);
2251 
2252   if (node-&gt;data-&gt;class.class_init)
2253     node-&gt;data-&gt;class.class_init (class, (gpointer) node-&gt;data-&gt;class.class_data);
2254 
2255   G_WRITE_LOCK (&amp;type_rw_lock);
2256 
2257   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, IFACE_INIT);
2258 
2259   /* finish initializing the interfaces through our holder info.
2260    * inherited interfaces are already init_state == INITIALIZED, because
2261    * they either got setup in the above base_init loop, or during
2262    * class_init from within type_add_interface_Wm() for this or
2263    * an anchestor type.
2264    */
2265   i = 0;
2266   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
2267     {
2268       entry = &amp;entries-&gt;entry[i];
2269       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">2270          entry-&gt;init_state == INITIALIZED)</span>
<span class="line-modified">2271     {</span>
<span class="line-modified">2272       entry++;</span>
<span class="line-modified">2273       i++;</span>
<span class="line-modified">2274     }</span>
2275 
2276       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">2277     break;</span>
2278 
2279       type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
2280 
2281       /* As in the loop above, additional initialized entries might be inserted
2282        * if the write lock is released, but that&#39;s harmless because the entries
2283        * we need to initialize only move higher in the list.
2284        */
2285       i++;
2286     }
2287 
2288   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, INITIALIZED);
2289 }
2290 
2291 static void
2292 type_data_finalize_class_ifaces_Wm (TypeNode *node)
2293 {
2294   guint i;
2295   IFaceEntries *entries;
2296 
2297   g_assert (node-&gt;is_instantiatable &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; NODE_REFCOUNT (node) == 0);
2298 
2299  reiterate:
2300   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
2301   for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
2302     {
2303       IFaceEntry *entry = &amp;entries-&gt;entry[i];
2304       if (entry-&gt;vtable)
<span class="line-modified">2305     {</span>
2306           if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
2307             {
2308               /* refetch entries, IFACES_ENTRIES might be modified */
2309               goto reiterate;
2310             }
2311           else
2312             {
2313               /* type_iface_vtable_finalize_Wm() doesn&#39;t modify write lock upon FALSE,
2314                * iface vtable came from parent
2315                */
2316               entry-&gt;vtable = NULL;
2317               entry-&gt;init_state = UNINITIALIZED;
2318             }
<span class="line-modified">2319     }</span>
2320     }
2321 }
2322 
2323 static void
2324 type_data_finalize_class_U (TypeNode  *node,
<span class="line-modified">2325                 ClassData *cdata)</span>
2326 {
2327   GTypeClass *class = cdata-&gt;class;
2328   TypeNode *bnode;
2329 
2330   g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
2331 
2332   if (cdata-&gt;class_finalize)
2333     cdata-&gt;class_finalize (class, (gpointer) cdata-&gt;class_data);
2334 
2335   /* call all base class destruction functions in descending order
2336    */
2337   if (cdata-&gt;class_finalize_base)
2338     cdata-&gt;class_finalize_base (class);
2339   for (bnode = lookup_type_node_I (NODE_PARENT_TYPE (node)); bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2340     if (bnode-&gt;data-&gt;class.class_finalize_base)
2341       bnode-&gt;data-&gt;class.class_finalize_base (class);
2342 
2343   g_free (cdata-&gt;class);
2344 }
2345 
2346 static void
2347 type_data_last_unref_Wm (TypeNode *node,
<span class="line-modified">2348              gboolean  uncached)</span>
2349 {
2350   g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
2351 
2352   if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2353     {
2354       g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
<span class="line-modified">2355          NODE_NAME (node));</span>
2356       return;
2357     }
2358 
2359   /* call class cache hooks */
2360   if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
2361     {
2362       guint i;
2363 
2364       G_WRITE_UNLOCK (&amp;type_rw_lock);
2365       G_READ_LOCK (&amp;type_rw_lock);
2366       for (i = 0; i &lt; static_n_class_cache_funcs; i++)
<span class="line-modified">2367     {</span>
<span class="line-modified">2368       GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="line-modified">2369       gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="line-modified">2370       gboolean need_break;</span>
2371 
<span class="line-modified">2372       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2373       need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="line-modified">2374       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2375       if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="line-modified">2376         INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="line-modified">2377       if (need_break)</span>
<span class="line-modified">2378         break;</span>
<span class="line-modified">2379     }</span>
2380       G_READ_UNLOCK (&amp;type_rw_lock);
2381       G_WRITE_LOCK (&amp;type_rw_lock);
2382     }
2383 
2384   /* may have been re-referenced meanwhile */
2385   if (g_atomic_int_dec_and_test ((int *) &amp;node-&gt;ref_count))
2386     {
2387       GType ptype = NODE_PARENT_TYPE (node);
2388       TypeData *tdata;
2389 
2390       if (node-&gt;is_instantiatable)
<span class="line-modified">2391     {</span>
<span class="line-modified">2392       /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="line-modified">2393     }</span>
2394 
2395       tdata = node-&gt;data;
2396       if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
<span class="line-modified">2397     {</span>
<span class="line-modified">2398       if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="line-modified">2399         type_data_finalize_class_ifaces_Wm (node);</span>
<span class="line-modified">2400       node-&gt;mutatable_check_cache = FALSE;</span>
<span class="line-modified">2401       node-&gt;data = NULL;</span>
<span class="line-modified">2402       G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2403       type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="line-modified">2404       G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2405     }</span>
2406       else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
2407         {
2408           node-&gt;mutatable_check_cache = FALSE;
2409           node-&gt;data = NULL;
2410           if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
2411             {
2412               G_WRITE_UNLOCK (&amp;type_rw_lock);
2413               if (tdata-&gt;iface.dflt_finalize)
2414                 tdata-&gt;iface.dflt_finalize (tdata-&gt;iface.dflt_vtable, (gpointer) tdata-&gt;iface.dflt_data);
2415               if (tdata-&gt;iface.vtable_finalize_base)
2416                 tdata-&gt;iface.vtable_finalize_base (tdata-&gt;iface.dflt_vtable);
2417               G_WRITE_LOCK (&amp;type_rw_lock);
2418             }
2419           g_free (tdata-&gt;iface.dflt_vtable);
2420         }
2421       else
2422         {
2423           node-&gt;mutatable_check_cache = FALSE;
2424           node-&gt;data = NULL;
2425         }
2426 
2427       /* freeing tdata-&gt;common.value_table and its contents is taken care of
2428        * by allocating it in one chunk with tdata
2429        */
2430       g_free (tdata);
2431 
2432       G_WRITE_UNLOCK (&amp;type_rw_lock);
2433       g_type_plugin_unuse (node-&gt;plugin);
2434       if (ptype)
<span class="line-modified">2435     type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
2436       G_WRITE_LOCK (&amp;type_rw_lock);
2437     }
2438 }
2439 
2440 static inline void
2441 type_data_unref_U (TypeNode *node,
2442                    gboolean  uncached)
2443 {
2444   guint current;
2445 
2446   do {
2447     current = NODE_REFCOUNT (node);
2448 
2449     if (current &lt;= 1)
2450     {
2451       if (!node-&gt;plugin)
<span class="line-modified">2452     {</span>
<span class="line-modified">2453       g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="line-modified">2454              NODE_NAME (node));</span>
<span class="line-modified">2455       return;</span>
<span class="line-modified">2456     }</span>
2457       else
2458         {
2459           /* This is the last reference of a type from a plugin.  We are
2460            * experimentally disabling support for unloading type
2461            * plugins, so don&#39;t allow the last ref to drop.
2462            */
2463           return;
2464         }
2465 
2466       g_assert (current &gt; 0);
2467 
2468       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2469       G_WRITE_LOCK (&amp;type_rw_lock);
2470       type_data_last_unref_Wm (node, uncached);
2471       G_WRITE_UNLOCK (&amp;type_rw_lock);
2472       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2473       return;
2474     }
2475   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current - 1));
2476 }
2477 
2478 /**
2479  * g_type_add_class_cache_func: (skip)
2480  * @cache_data: data to be passed to @cache_func
2481  * @cache_func: a #GTypeClassCacheFunc
2482  *
2483  * Adds a #GTypeClassCacheFunc to be called before the reference count of a
2484  * class goes from one to zero. This can be used to prevent premature class
2485  * destruction. All installed #GTypeClassCacheFunc functions will be chained
2486  * until one of them returns %TRUE. The functions have to check the class id
2487  * passed in to figure whether they actually want to cache the class of this
2488  * type, since all classes are routed through the same #GTypeClassCacheFunc
2489  * chain.
2490  */
2491 void
2492 g_type_add_class_cache_func (gpointer            cache_data,
<span class="line-modified">2493                  GTypeClassCacheFunc cache_func)</span>
2494 {
2495   guint i;
2496 
2497   g_return_if_fail (cache_func != NULL);
2498 
2499   G_WRITE_LOCK (&amp;type_rw_lock);
2500   i = static_n_class_cache_funcs++;
2501   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2502   static_class_cache_funcs[i].cache_data = cache_data;
2503   static_class_cache_funcs[i].cache_func = cache_func;
2504   G_WRITE_UNLOCK (&amp;type_rw_lock);
2505 }
2506 
2507 /**
2508  * g_type_remove_class_cache_func: (skip)
2509  * @cache_data: data that was given when adding @cache_func
2510  * @cache_func: a #GTypeClassCacheFunc
2511  *
2512  * Removes a previously installed #GTypeClassCacheFunc. The cache
2513  * maintained by @cache_func has to be empty when calling
2514  * g_type_remove_class_cache_func() to avoid leaks.
2515  */
2516 void
2517 g_type_remove_class_cache_func (gpointer            cache_data,
<span class="line-modified">2518                 GTypeClassCacheFunc cache_func)</span>
2519 {
2520   gboolean found_it = FALSE;
2521   guint i;
2522 
2523   g_return_if_fail (cache_func != NULL);
2524 
2525   G_WRITE_LOCK (&amp;type_rw_lock);
2526   for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2527     if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
<span class="line-modified">2528     static_class_cache_funcs[i].cache_func == cache_func)</span>
2529       {
<span class="line-modified">2530     static_n_class_cache_funcs--;</span>
<span class="line-modified">2531     memmove (static_class_cache_funcs + i,</span>
2532                  static_class_cache_funcs + i + 1,
2533                  sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
<span class="line-modified">2534     static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="line-modified">2535     found_it = TRUE;</span>
<span class="line-modified">2536     break;</span>
2537       }
2538   G_WRITE_UNLOCK (&amp;type_rw_lock);
2539 
2540   if (!found_it)
2541     g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
<span class="line-modified">2542            cache_func, cache_data);</span>
2543 }
2544 
2545 
2546 /**
2547  * g_type_add_interface_check: (skip)
2548  * @check_data: data to pass to @check_func
2549  * @check_func: function to be called after each interface
2550  *     is initialized
2551  *
2552  * Adds a function to be called after an interface vtable is
2553  * initialized for any class (i.e. after the @interface_init
2554  * member of #GInterfaceInfo has been called).
2555  *
2556  * This function is useful when you want to check an invariant
2557  * that depends on the interfaces of a class. For instance, the
2558  * implementation of #GObject uses this facility to check that an
2559  * object implements all of the properties that are defined on its
2560  * interfaces.
2561  *
2562  * Since: 2.4
2563  */
2564 void
<span class="line-modified">2565 g_type_add_interface_check (gpointer                check_data,</span>
<span class="line-modified">2566                             GTypeInterfaceCheckFunc check_func)</span>
2567 {
2568   guint i;
2569 
2570   g_return_if_fail (check_func != NULL);
2571 
2572   G_WRITE_LOCK (&amp;type_rw_lock);
2573   i = static_n_iface_check_funcs++;
2574   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2575   static_iface_check_funcs[i].check_data = check_data;
2576   static_iface_check_funcs[i].check_func = check_func;
2577   G_WRITE_UNLOCK (&amp;type_rw_lock);
2578 }
2579 
2580 /**
2581  * g_type_remove_interface_check: (skip)
2582  * @check_data: callback data passed to g_type_add_interface_check()
2583  * @check_func: callback function passed to g_type_add_interface_check()
2584  *
2585  * Removes an interface check function added with
2586  * g_type_add_interface_check().
2587  *
2588  * Since: 2.4
2589  */
2590 void
2591 g_type_remove_interface_check (gpointer                check_data,
<span class="line-modified">2592                                GTypeInterfaceCheckFunc check_func)</span>
2593 {
2594   gboolean found_it = FALSE;
2595   guint i;
2596 
2597   g_return_if_fail (check_func != NULL);
2598 
2599   G_WRITE_LOCK (&amp;type_rw_lock);
2600   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2601     if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
<span class="line-modified">2602     static_iface_check_funcs[i].check_func == check_func)</span>
2603       {
<span class="line-modified">2604     static_n_iface_check_funcs--;</span>
<span class="line-modified">2605     memmove (static_iface_check_funcs + i,</span>
2606                  static_iface_check_funcs + i + 1,
2607                  sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
<span class="line-modified">2608     static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="line-modified">2609     found_it = TRUE;</span>
<span class="line-modified">2610     break;</span>
2611       }
2612   G_WRITE_UNLOCK (&amp;type_rw_lock);
2613 
2614   if (!found_it)
2615     g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
<span class="line-modified">2616            check_func, check_data);</span>
2617 }
2618 
2619 /* --- type registration --- */
2620 /**
2621  * g_type_register_fundamental:
2622  * @type_id: a predefined type identifier
2623  * @type_name: 0-terminated string used as the name of the new type
2624  * @info: #GTypeInfo structure for this type
2625  * @finfo: #GTypeFundamentalInfo structure for this type
2626  * @flags: bitwise combination of #GTypeFlags values
2627  *
2628  * Registers @type_id as the predefined identifier and @type_name as the
2629  * name of a fundamental type. If @type_id is already registered, or a
2630  * type named @type_name is already registered, the behaviour is undefined.
2631  * The type system uses the information contained in the #GTypeInfo structure
2632  * pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
2633  * @finfo to manage the type and its instances. The value of @flags determines
2634  * additional characteristics of the fundamental type.
2635  *
2636  * Returns: the predefined type identifier
2637  */
2638 GType
2639 g_type_register_fundamental (GType                       type_id,
<span class="line-modified">2640                              const gchar                *type_name,</span>
<span class="line-modified">2641                              const GTypeInfo            *info,</span>
<span class="line-modified">2642                              const GTypeFundamentalInfo *finfo,</span>
<span class="line-modified">2643                  GTypeFlags          flags)</span>
2644 {
2645   TypeNode *node;
2646 
2647   g_assert_type_system_initialized ();
2648   g_return_val_if_fail (type_id &gt; 0, 0);
2649   g_return_val_if_fail (type_name != NULL, 0);
2650   g_return_val_if_fail (info != NULL, 0);
2651   g_return_val_if_fail (finfo != NULL, 0);
2652 
2653   if (!check_type_name_I (type_name))
2654     return 0;
2655   if ((type_id &amp; TYPE_ID_MASK) ||
2656       type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
2657     {
2658       g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
<span class="line-modified">2659          type_name,</span>
<span class="line-modified">2660          type_id);</span>
2661       return 0;
2662     }
2663   if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
2664       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
2665     {
2666       g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
<span class="line-modified">2667          type_name);</span>
2668       return 0;
2669     }
2670   if (lookup_type_node_I (type_id))
2671     {
2672       g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
<span class="line-modified">2673          type_descriptive_name_I (type_id),</span>
<span class="line-modified">2674          type_name);</span>
2675       return 0;
2676     }
2677 
2678   G_WRITE_LOCK (&amp;type_rw_lock);
2679   node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
2680   type_add_flags_W (node, flags);
2681 
2682   if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
2683     type_data_make_W (node, info,
<span class="line-modified">2684               check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
2685   G_WRITE_UNLOCK (&amp;type_rw_lock);
2686 
2687   return NODE_TYPE (node);
2688 }
2689 
2690 /**
2691  * g_type_register_static_simple: (skip)
2692  * @parent_type: type from which this type will be derived
2693  * @type_name: 0-terminated string used as the name of the new type
2694  * @class_size: size of the class structure (see #GTypeInfo)
2695  * @class_init: location of the class initialization function (see #GTypeInfo)
2696  * @instance_size: size of the instance structure (see #GTypeInfo)
2697  * @instance_init: location of the instance initialization function (see #GTypeInfo)
2698  * @flags: bitwise combination of #GTypeFlags values
2699  *
2700  * Registers @type_name as the name of a new static type derived from
2701  * @parent_type.  The value of @flags determines the nature (e.g.
2702  * abstract or not) of the type. It works by filling a #GTypeInfo
2703  * struct and calling g_type_register_static().
2704  *
2705  * Since: 2.12
2706  *
2707  * Returns: the new type identifier
2708  */
2709 GType
2710 g_type_register_static_simple (GType             parent_type,
<span class="line-modified">2711                                const gchar      *type_name,</span>
<span class="line-modified">2712                                guint             class_size,</span>
<span class="line-modified">2713                                GClassInitFunc    class_init,</span>
<span class="line-modified">2714                                guint             instance_size,</span>
<span class="line-modified">2715                                GInstanceInitFunc instance_init,</span>
<span class="line-modified">2716                    GTypeFlags    flags)</span>
2717 {
2718   GTypeInfo info;
2719 
2720   /* Instances are not allowed to be larger than this. If you have a big
2721    * fixed-length array or something, point to it instead.
2722    */
2723   g_return_val_if_fail (class_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2724   g_return_val_if_fail (instance_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2725 
2726   info.class_size = class_size;
2727   info.base_init = NULL;
2728   info.base_finalize = NULL;
2729   info.class_init = class_init;
2730   info.class_finalize = NULL;
2731   info.class_data = NULL;
2732   info.instance_size = instance_size;
2733   info.n_preallocs = 0;
2734   info.instance_init = instance_init;
2735   info.value_table = NULL;
2736 
2737   return g_type_register_static (parent_type, type_name, &amp;info, flags);
2738 }
2739 
2740 /**
2741  * g_type_register_static:
2742  * @parent_type: type from which this type will be derived
2743  * @type_name: 0-terminated string used as the name of the new type
2744  * @info: #GTypeInfo structure for this type
2745  * @flags: bitwise combination of #GTypeFlags values
2746  *
2747  * Registers @type_name as the name of a new static type derived from
2748  * @parent_type. The type system uses the information contained in the
2749  * #GTypeInfo structure pointed to by @info to manage the type and its
2750  * instances (if not abstract). The value of @flags determines the nature
2751  * (e.g. abstract or not) of the type.
2752  *
2753  * Returns: the new type identifier
2754  */
2755 GType
2756 g_type_register_static (GType            parent_type,
<span class="line-modified">2757                         const gchar     *type_name,</span>
<span class="line-modified">2758                         const GTypeInfo *info,</span>
<span class="line-modified">2759             GTypeFlags   flags)</span>
2760 {
2761   TypeNode *pnode, *node;
2762   GType type = 0;
2763 
2764   g_assert_type_system_initialized ();
2765   g_return_val_if_fail (parent_type &gt; 0, 0);
2766   g_return_val_if_fail (type_name != NULL, 0);
2767   g_return_val_if_fail (info != NULL, 0);
2768 
2769   if (!check_type_name_I (type_name) ||
2770       !check_derivation_I (parent_type, type_name))
2771     return 0;
2772   if (info-&gt;class_finalize)
2773     {
2774       g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
<span class="line-modified">2775          type_name);</span>
2776       return 0;
2777     }
2778 
2779   pnode = lookup_type_node_I (parent_type);
2780   G_WRITE_LOCK (&amp;type_rw_lock);
2781   type_data_ref_Wm (pnode);
2782   if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (pnode), type_name, info))
2783     {
2784       node = type_node_new_W (pnode, type_name, NULL);
2785       type_add_flags_W (node, flags);
2786       type = NODE_TYPE (node);
2787       type_data_make_W (node, info,
<span class="line-modified">2788             check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
2789     }
2790   G_WRITE_UNLOCK (&amp;type_rw_lock);
2791 
2792   return type;
2793 }
2794 
2795 /**
2796  * g_type_register_dynamic:
2797  * @parent_type: type from which this type will be derived
2798  * @type_name: 0-terminated string used as the name of the new type
2799  * @plugin: #GTypePlugin structure to retrieve the #GTypeInfo from
2800  * @flags: bitwise combination of #GTypeFlags values
2801  *
2802  * Registers @type_name as the name of a new dynamic type derived from
2803  * @parent_type.  The type system uses the information contained in the
2804  * #GTypePlugin structure pointed to by @plugin to manage the type and its
2805  * instances (if not abstract).  The value of @flags determines the nature
2806  * (e.g. abstract or not) of the type.
2807  *
2808  * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
2809  */
2810 GType
2811 g_type_register_dynamic (GType        parent_type,
<span class="line-modified">2812              const gchar *type_name,</span>
<span class="line-modified">2813              GTypePlugin *plugin,</span>
<span class="line-modified">2814              GTypeFlags   flags)</span>
2815 {
2816   TypeNode *pnode, *node;
2817   GType type;
2818 
2819   g_assert_type_system_initialized ();
2820   g_return_val_if_fail (parent_type &gt; 0, 0);
2821   g_return_val_if_fail (type_name != NULL, 0);
2822   g_return_val_if_fail (plugin != NULL, 0);
2823 
2824   if (!check_type_name_I (type_name) ||
2825       !check_derivation_I (parent_type, type_name) ||
2826       !check_plugin_U (plugin, TRUE, FALSE, type_name))
2827     return 0;
2828 
2829   G_WRITE_LOCK (&amp;type_rw_lock);
2830   pnode = lookup_type_node_I (parent_type);
2831   node = type_node_new_W (pnode, type_name, plugin);
2832   type_add_flags_W (node, flags);
2833   type = NODE_TYPE (node);
2834   G_WRITE_UNLOCK (&amp;type_rw_lock);
2835 
2836   return type;
2837 }
2838 
2839 /**
2840  * g_type_add_interface_static:
2841  * @instance_type: #GType value of an instantiable type
2842  * @interface_type: #GType value of an interface type
2843  * @info: #GInterfaceInfo structure for this
2844  *        (@instance_type, @interface_type) combination
2845  *
2846  * Adds the static @interface_type to @instantiable_type.
2847  * The information contained in the #GInterfaceInfo structure
2848  * pointed to by @info is used to manage the relationship.
2849  */
2850 void
2851 g_type_add_interface_static (GType                 instance_type,
<span class="line-modified">2852                  GType                 interface_type,</span>
<span class="line-modified">2853                  const GInterfaceInfo *info)</span>
2854 {
2855   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2856   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2857   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2858 
2859   /* we only need to lock class_init_rec_mutex if instance_type already has its
2860    * class initialized, however this function is rarely enough called to take
2861    * the simple route and always acquire class_init_rec_mutex.
2862    */
2863   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2864   G_WRITE_LOCK (&amp;type_rw_lock);
2865   if (check_add_interface_L (instance_type, interface_type))
2866     {
2867       TypeNode *node = lookup_type_node_I (instance_type);
2868       TypeNode *iface = lookup_type_node_I (interface_type);
2869       if (check_interface_info_I (iface, NODE_TYPE (node), info))
2870         type_add_interface_Wm (node, iface, info, NULL);
2871     }
2872   G_WRITE_UNLOCK (&amp;type_rw_lock);
2873   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2874 }
2875 
2876 /**
2877  * g_type_add_interface_dynamic:
2878  * @instance_type: #GType value of an instantiable type
2879  * @interface_type: #GType value of an interface type
2880  * @plugin: #GTypePlugin structure to retrieve the #GInterfaceInfo from
2881  *
2882  * Adds the dynamic @interface_type to @instantiable_type. The information
2883  * contained in the #GTypePlugin structure pointed to by @plugin
2884  * is used to manage the relationship.
2885  */
2886 void
2887 g_type_add_interface_dynamic (GType        instance_type,
<span class="line-modified">2888                   GType        interface_type,</span>
<span class="line-modified">2889                   GTypePlugin *plugin)</span>
2890 {
2891   TypeNode *node;
2892   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2893   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2894   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2895 
2896   node = lookup_type_node_I (instance_type);
2897   if (!check_plugin_U (plugin, FALSE, TRUE, NODE_NAME (node)))
2898     return;
2899 
2900   /* see comment in g_type_add_interface_static() about class_init_rec_mutex */
2901   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2902   G_WRITE_LOCK (&amp;type_rw_lock);
2903   if (check_add_interface_L (instance_type, interface_type))
2904     {
2905       TypeNode *iface = lookup_type_node_I (interface_type);
2906       type_add_interface_Wm (node, iface, NULL, plugin);
2907     }
2908   G_WRITE_UNLOCK (&amp;type_rw_lock);
2909   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
</pre>
<hr />
<pre>
2918  * Increments the reference count of the class structure belonging to
2919  * @type. This function will demand-create the class if it doesn&#39;t
2920  * exist already.
2921  *
2922  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
2923  *     structure for the given type ID
2924  */
2925 gpointer
2926 g_type_class_ref (GType type)
2927 {
2928   TypeNode *node;
2929   GType ptype;
2930   gboolean holds_ref;
2931   GTypeClass *pclass;
2932 
2933   /* optimize for common code path */
2934   node = lookup_type_node_I (type);
2935   if (!node || !node-&gt;is_classed)
2936     {
2937       g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">2938          type_descriptive_name_I (type));</span>
2939       return NULL;
2940     }
2941 
2942   if (G_LIKELY (type_data_ref_U (node)))
2943     {
2944       if (G_LIKELY (g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED))
2945         return node-&gt;data-&gt;class.class;
2946       holds_ref = TRUE;
2947     }
2948   else
2949     holds_ref = FALSE;
2950 
2951   /* here, we either have node-&gt;data-&gt;class.class == NULL, or a recursive
2952    * call to g_type_class_ref() with a partly initialized class, or
2953    * node-&gt;data-&gt;class.init_state == INITIALIZED, because any
2954    * concurrently running initialization was guarded by class_init_rec_mutex.
2955    */
2956   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2957 
2958   /* we need an initialized parent class for initializing derived classes */
</pre>
<hr />
<pre>
2982  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
2983  *
2984  * Decrements the reference count of the class structure being passed in.
2985  * Once the last reference count of a class has been released, classes
2986  * may be finalized by the type system, so further dereferencing of a
2987  * class pointer after g_type_class_unref() are invalid.
2988  */
2989 void
2990 g_type_class_unref (gpointer g_class)
2991 {
2992   TypeNode *node;
2993   GTypeClass *class = g_class;
2994 
2995   g_return_if_fail (g_class != NULL);
2996 
2997   node = lookup_type_node_I (class-&gt;g_type);
2998   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
2999     type_data_unref_U (node, FALSE);
3000   else
3001     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">3002            type_descriptive_name_I (class-&gt;g_type));</span>
3003 }
3004 
3005 /**
3006  * g_type_class_unref_uncached: (skip)
3007  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
3008  *
3009  * A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
3010  * implementations. It unreferences a class without consulting the chain
3011  * of #GTypeClassCacheFuncs, avoiding the recursion which would occur
3012  * otherwise.
3013  */
3014 void
3015 g_type_class_unref_uncached (gpointer g_class)
3016 {
3017   TypeNode *node;
3018   GTypeClass *class = g_class;
3019 
3020   g_return_if_fail (g_class != NULL);
3021 
3022   node = lookup_type_node_I (class-&gt;g_type);
3023   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3024     type_data_unref_U (node, TRUE);
3025   else
3026     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">3027            type_descriptive_name_I (class-&gt;g_type));</span>
3028 }
3029 
3030 /**
3031  * g_type_class_peek:
3032  * @type: type ID of a classed type
3033  *
3034  * This function is essentially the same as g_type_class_ref(),
3035  * except that the classes reference count isn&#39;t incremented.
3036  * As a consequence, this function may return %NULL if the class
3037  * of the type passed in does not currently exist (hasn&#39;t been
3038  * referenced before).
3039  *
3040  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3041  *     structure for the given type ID or %NULL if the class does not
3042  *     currently exist
3043  */
3044 gpointer
3045 g_type_class_peek (GType type)
3046 {
3047   TypeNode *node;
</pre>
<hr />
<pre>
3127   else if (NODE_PARENT_TYPE (node))
3128     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, g_class);
3129 
3130   return class;
3131 }
3132 
3133 /**
3134  * g_type_interface_peek:
3135  * @instance_class: (type GObject.TypeClass): a #GTypeClass structure
3136  * @iface_type: an interface ID which this class conforms to
3137  *
3138  * Returns the #GTypeInterface structure of an interface to which the
3139  * passed in class conforms.
3140  *
3141  * Returns: (type GObject.TypeInterface) (transfer none): the #GTypeInterface
3142  *     structure of @iface_type if implemented by @instance_class, %NULL
3143  *     otherwise
3144  */
3145 gpointer
3146 g_type_interface_peek (gpointer instance_class,
<span class="line-modified">3147                GType    iface_type)</span>
3148 {
3149   TypeNode *node;
3150   TypeNode *iface;
3151   gpointer vtable = NULL;
3152   GTypeClass *class = instance_class;
3153 
3154   g_return_val_if_fail (instance_class != NULL, NULL);
3155 
3156   node = lookup_type_node_I (class-&gt;g_type);
3157   iface = lookup_type_node_I (iface_type);
3158   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3159     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3160   else
3161     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, class);
3162 
3163   return vtable;
3164 }
3165 
3166 /**
3167  * g_type_interface_peek_parent:
</pre>
<hr />
<pre>
3217  * Since: 2.4
3218  *
3219  * Returns: (type GObject.TypeInterface) (transfer none): the default
3220  *     vtable for the interface; call g_type_default_interface_unref()
3221  *     when you are done using the interface.
3222  */
3223 gpointer
3224 g_type_default_interface_ref (GType g_type)
3225 {
3226   TypeNode *node;
3227   gpointer dflt_vtable;
3228 
3229   G_WRITE_LOCK (&amp;type_rw_lock);
3230 
3231   node = lookup_type_node_I (g_type);
3232   if (!node || !NODE_IS_IFACE (node) ||
3233       (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
3234     {
3235       G_WRITE_UNLOCK (&amp;type_rw_lock);
3236       g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
<span class="line-modified">3237          type_descriptive_name_I (g_type));</span>
3238       return NULL;
3239     }
3240 
3241   if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
3242     {
3243       G_WRITE_UNLOCK (&amp;type_rw_lock);
3244       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
3245       G_WRITE_LOCK (&amp;type_rw_lock);
3246       node = lookup_type_node_I (g_type);
3247       type_data_ref_Wm (node);
3248       type_iface_ensure_dflt_vtable_Wm (node);
3249       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
3250     }
3251   else
3252     type_data_ref_Wm (node); /* ref_count &gt;= 1 already */
3253 
3254   dflt_vtable = node-&gt;data-&gt;iface.dflt_vtable;
3255   G_WRITE_UNLOCK (&amp;type_rw_lock);
3256 
3257   return dflt_vtable;
</pre>
<hr />
<pre>
3271  *     in use
3272  */
3273 gpointer
3274 g_type_default_interface_peek (GType g_type)
3275 {
3276   TypeNode *node;
3277   gpointer vtable;
3278 
3279   node = lookup_type_node_I (g_type);
3280   if (node &amp;&amp; NODE_IS_IFACE (node) &amp;&amp; NODE_REFCOUNT (node))
3281     vtable = node-&gt;data-&gt;iface.dflt_vtable;
3282   else
3283     vtable = NULL;
3284 
3285   return vtable;
3286 }
3287 
3288 /**
3289  * g_type_default_interface_unref:
3290  * @g_iface: (type GObject.TypeInterface): the default vtable
<span class="line-modified">3291  *     structure for a interface, as returned by g_type_default_interface_ref()</span>
3292  *
3293  * Decrements the reference count for the type corresponding to the
3294  * interface default vtable @g_iface. If the type is dynamic, then
3295  * when no one is using the interface and all references have
3296  * been released, the finalize function for the interface&#39;s default
3297  * vtable (the @class_finalize member of #GTypeInfo) will be called.
3298  *
3299  * Since: 2.4
3300  */
3301 void
3302 g_type_default_interface_unref (gpointer g_iface)
3303 {
3304   TypeNode *node;
3305   GTypeInterface *vtable = g_iface;
3306 
3307   g_return_if_fail (g_iface != NULL);
3308 
3309   node = lookup_type_node_I (vtable-&gt;g_type);
3310   if (node &amp;&amp; NODE_IS_IFACE (node))
3311     type_data_unref_U (node, FALSE);
3312   else
3313     g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
<span class="line-modified">3314            type_descriptive_name_I (vtable-&gt;g_type));</span>
3315 }
3316 
3317 /**
3318  * g_type_name:
3319  * @type: type to return name for
3320  *
3321  * Get the unique name that is assigned to a type ID.  Note that this
3322  * function (like all other GType API) cannot cope with invalid type
3323  * IDs. %G_TYPE_INVALID may be passed to this function, as may be any
3324  * other validly registered type ID, but randomized type IDs should
3325  * not be passed in and will most likely lead to a crash.
3326  *
3327  * Returns: static type name or %NULL
3328  */
3329 const gchar *
3330 g_type_name (GType type)
3331 {
3332   TypeNode *node;
3333 
3334   g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
3341 /**
3342  * g_type_qname:
3343  * @type: type to return quark of type name for
3344  *
3345  * Get the corresponding quark of the type IDs name.
3346  *
3347  * Returns: the type names quark or 0
3348  */
3349 GQuark
3350 g_type_qname (GType type)
3351 {
3352   TypeNode *node;
3353 
3354   node = lookup_type_node_I (type);
3355 
3356   return node ? node-&gt;qname : 0;
3357 }
3358 
3359 /**
3360  * g_type_from_name:
<span class="line-modified">3361  * @name: type name to lookup</span>
3362  *
<span class="line-modified">3363  * Lookup the type ID from a given type name, returning 0 if no type</span>
3364  * has been registered under this name (this is the preferred method
3365  * to find out by name whether a specific type has been registered
3366  * yet).
3367  *
3368  * Returns: corresponding type ID or 0
3369  */
3370 GType
3371 g_type_from_name (const gchar *name)
3372 {
3373   GType type = 0;
3374 
3375   g_return_val_if_fail (name != NULL, 0);
3376 
3377   G_READ_LOCK (&amp;type_rw_lock);
3378   type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);
3379   G_READ_UNLOCK (&amp;type_rw_lock);
3380 
3381   return type;
3382 }
3383 
</pre>
<hr />
<pre>
3419   return node ? node-&gt;n_supers + 1 : 0;
3420 }
3421 
3422 /**
3423  * g_type_next_base:
3424  * @leaf_type: descendant of @root_type and the type to be returned
3425  * @root_type: immediate parent of the returned type
3426  *
3427  * Given a @leaf_type and a @root_type which is contained in its
3428  * anchestry, return the type that @root_type is the immediate parent
3429  * of. In other words, this function determines the type that is
3430  * derived directly from @root_type which is also a base class of
3431  * @leaf_type.  Given a root type and a leaf type, this function can
3432  * be used to determine the types and order in which the leaf type is
3433  * descended from the root type.
3434  *
3435  * Returns: immediate child of @root_type and anchestor of @leaf_type
3436  */
3437 GType
3438 g_type_next_base (GType type,
<span class="line-modified">3439           GType base_type)</span>
3440 {
3441   GType atype = 0;
3442   TypeNode *node;
3443 
3444   node = lookup_type_node_I (type);
3445   if (node)
3446     {
3447       TypeNode *base_node = lookup_type_node_I (base_type);
3448 
3449       if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
<span class="line-modified">3450     {</span>
<span class="line-modified">3451       guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
3452 
<span class="line-modified">3453       if (node-&gt;supers[n] == base_type)</span>
<span class="line-modified">3454         atype = node-&gt;supers[n - 1];</span>
<span class="line-modified">3455     }</span>
3456     }
3457 
3458   return atype;
3459 }
3460 
3461 static inline gboolean
3462 type_node_check_conformities_UorL (TypeNode *node,
<span class="line-modified">3463                    TypeNode *iface_node,</span>
<span class="line-modified">3464                    /*        support_inheritance */</span>
<span class="line-modified">3465                    gboolean  support_interfaces,</span>
<span class="line-modified">3466                    gboolean  support_prerequisites,</span>
<span class="line-modified">3467                    gboolean  have_lock)</span>
3468 {
3469   gboolean match;
3470 
3471   if (/* support_inheritance &amp;&amp; */
3472       NODE_IS_ANCESTOR (iface_node, node))
3473     return TRUE;
3474 
3475   support_interfaces = support_interfaces &amp;&amp; node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface_node);
3476   support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
3477   match = FALSE;
3478   if (support_interfaces)
3479     {
3480       if (have_lock)
<span class="line-modified">3481     {</span>
<span class="line-modified">3482       if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="line-modified">3483         match = TRUE;</span>
<span class="line-modified">3484     }</span>
3485       else
<span class="line-modified">3486     {</span>
<span class="line-modified">3487       if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="line-modified">3488         match = TRUE;</span>
<span class="line-modified">3489     }</span>
3490     }
3491   if (!match &amp;&amp;
3492       support_prerequisites)
3493     {
3494       if (!have_lock)
<span class="line-modified">3495     G_READ_LOCK (&amp;type_rw_lock);</span>
3496       if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
<span class="line-modified">3497     match = TRUE;</span>
3498       if (!have_lock)
<span class="line-modified">3499     G_READ_UNLOCK (&amp;type_rw_lock);</span>
3500     }
3501   return match;
3502 }
3503 
3504 static gboolean
3505 type_node_is_a_L (TypeNode *node,
<span class="line-modified">3506           TypeNode *iface_node)</span>
3507 {
3508   return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
3509 }
3510 
3511 static inline gboolean
3512 type_node_conforms_to_U (TypeNode *node,
<span class="line-modified">3513              TypeNode *iface_node,</span>
<span class="line-modified">3514              gboolean  support_interfaces,</span>
<span class="line-modified">3515              gboolean  support_prerequisites)</span>
3516 {
3517   return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
3518 }
3519 
3520 /**
3521  * g_type_is_a:
3522  * @type: type to check anchestry for
3523  * @is_a_type: possible anchestor of @type or interface that @type
3524  *     could conform to
3525  *
3526  * If @is_a_type is a derivable type, check whether @type is a
3527  * descendant of @is_a_type. If @is_a_type is an interface, check
3528  * whether @type conforms to it.
3529  *
3530  * Returns: %TRUE if @type is a @is_a_type
3531  */
3532 gboolean
3533 g_type_is_a (GType type,
<span class="line-modified">3534          GType iface_type)</span>
3535 {
3536   TypeNode *node, *iface_node;
3537   gboolean is_a;
3538 
3539   if (type == iface_type)
3540     return TRUE;
3541 
3542   node = lookup_type_node_I (type);
3543   iface_node = lookup_type_node_I (iface_type);
3544   is_a = node &amp;&amp; iface_node &amp;&amp; type_node_conforms_to_U (node, iface_node, TRUE, TRUE);
3545 
3546   return is_a;
3547 }
3548 
3549 /**
3550  * g_type_children:
3551  * @type: the parent type
3552  * @n_children: (out) (optional): location to store the length of
3553  *     the returned array, or %NULL
3554  *
3555  * Return a newly allocated and 0-terminated array of type IDs, listing
3556  * the child types of @type.
3557  *
3558  * Returns: (array length=n_children) (transfer full): Newly allocated
3559  *     and 0-terminated array of child types, free with g_free()
3560  */
3561 GType*
3562 g_type_children (GType  type,
<span class="line-modified">3563          guint *n_children)</span>
3564 {
3565   TypeNode *node;
3566 
3567   node = lookup_type_node_I (type);
3568   if (node)
3569     {
3570       GType *children;
3571 
3572       G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
3573       children = g_new (GType, node-&gt;n_children + 1);
3574       if (node-&gt;n_children != 0)
<span class="line-modified">3575       memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
3576       children[node-&gt;n_children] = 0;
3577 
3578       if (n_children)
<span class="line-modified">3579     *n_children = node-&gt;n_children;</span>
3580       G_READ_UNLOCK (&amp;type_rw_lock);
3581 
3582       return children;
3583     }
3584   else
3585     {
3586       if (n_children)
<span class="line-modified">3587     *n_children = 0;</span>
3588 
3589       return NULL;
3590     }
3591 }
3592 
3593 /**
3594  * g_type_interfaces:
3595  * @type: the type to list interface types for
3596  * @n_interfaces: (out) (optional): location to store the length of
3597  *     the returned array, or %NULL
3598  *
3599  * Return a newly allocated and 0-terminated array of type IDs, listing
3600  * the interface types that @type conforms to.
3601  *
3602  * Returns: (array length=n_interfaces) (transfer full): Newly allocated
3603  *     and 0-terminated array of interface types, free with g_free()
3604  */
3605 GType*
3606 g_type_interfaces (GType  type,
<span class="line-modified">3607            guint *n_interfaces)</span>
3608 {
3609   TypeNode *node;
3610 
3611   node = lookup_type_node_I (type);
3612   if (node &amp;&amp; node-&gt;is_instantiatable)
3613     {
3614       IFaceEntries *entries;
3615       GType *ifaces;
3616       guint i;
3617 
3618       G_READ_LOCK (&amp;type_rw_lock);
3619       entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
3620       if (entries)
<span class="line-modified">3621     {</span>
<span class="line-modified">3622       ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="line-modified">3623       for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="line-modified">3624         ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="line-modified">3625     }</span>
3626       else
<span class="line-modified">3627     {</span>
<span class="line-modified">3628       ifaces = g_new (GType, 1);</span>
<span class="line-modified">3629       i = 0;</span>
<span class="line-modified">3630     }</span>
3631       ifaces[i] = 0;
3632 
3633       if (n_interfaces)
<span class="line-modified">3634     *n_interfaces = i;</span>
3635       G_READ_UNLOCK (&amp;type_rw_lock);
3636 
3637       return ifaces;
3638     }
3639   else
3640     {
3641       if (n_interfaces)
<span class="line-modified">3642     *n_interfaces = 0;</span>
3643 
3644       return NULL;
3645     }
3646 }
3647 
3648 typedef struct _QData QData;
3649 struct _GData
3650 {
3651   guint  n_qdatas;
3652   QData *qdatas;
3653 };
3654 struct _QData
3655 {
3656   GQuark   quark;
3657   gpointer data;
3658 };
3659 
3660 static inline gpointer
3661 type_get_qdata_L (TypeNode *node,
<span class="line-modified">3662           GQuark    quark)</span>
3663 {
3664   GData *gdata = node-&gt;global_gdata;
3665 
3666   if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
3667     {
3668       QData *qdatas = gdata-&gt;qdatas - 1;
3669       guint n_qdatas = gdata-&gt;n_qdatas;
3670 
3671       do
<span class="line-modified">3672     {</span>
<span class="line-modified">3673       guint i;</span>
<span class="line-modified">3674       QData *check;</span>
<span class="line-modified">3675 </span>
<span class="line-modified">3676       i = (n_qdatas + 1) / 2;</span>
<span class="line-modified">3677       check = qdatas + i;</span>
<span class="line-modified">3678       if (quark == check-&gt;quark)</span>
<span class="line-modified">3679         return check-&gt;data;</span>
<span class="line-modified">3680       else if (quark &gt; check-&gt;quark)</span>
<span class="line-modified">3681         {</span>
<span class="line-modified">3682           n_qdatas -= i;</span>
<span class="line-modified">3683           qdatas = check;</span>
<span class="line-modified">3684         }</span>
<span class="line-modified">3685       else /* if (quark &lt; check-&gt;quark) */</span>
<span class="line-modified">3686         n_qdatas = i - 1;</span>
<span class="line-modified">3687     }</span>
3688       while (n_qdatas);
3689     }
3690   return NULL;
3691 }
3692 
3693 /**
3694  * g_type_get_qdata:
3695  * @type: a #GType
3696  * @quark: a #GQuark id to identify the data
3697  *
3698  * Obtains data which has previously been attached to @type
3699  * with g_type_set_qdata().
3700  *
3701  * Note that this does not take subtyping into account; data
3702  * attached to one type with g_type_set_qdata() cannot
3703  * be retrieved from a subtype using g_type_get_qdata().
3704  *
3705  * Returns: (transfer none): the data, or %NULL if no data was found
3706  */
3707 gpointer
3708 g_type_get_qdata (GType  type,
<span class="line-modified">3709           GQuark quark)</span>
3710 {
3711   TypeNode *node;
3712   gpointer data;
3713 
3714   node = lookup_type_node_I (type);
3715   if (node)
3716     {
3717       G_READ_LOCK (&amp;type_rw_lock);
3718       data = type_get_qdata_L (node, quark);
3719       G_READ_UNLOCK (&amp;type_rw_lock);
3720     }
3721   else
3722     {
3723       g_return_val_if_fail (node != NULL, NULL);
3724       data = NULL;
3725     }
3726   return data;
3727 }
3728 
3729 static inline void
3730 type_set_qdata_W (TypeNode *node,
<span class="line-modified">3731           GQuark    quark,</span>
<span class="line-modified">3732           gpointer  data)</span>
3733 {
3734   GData *gdata;
3735   QData *qdata;
3736   guint i;
3737 
3738   /* setup qdata list if necessary */
3739   if (!node-&gt;global_gdata)
3740     node-&gt;global_gdata = g_new0 (GData, 1);
3741   gdata = node-&gt;global_gdata;
3742 
3743   /* try resetting old data */
3744   qdata = gdata-&gt;qdatas;
3745   for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
3746     if (qdata[i].quark == quark)
3747       {
<span class="line-modified">3748     qdata[i].data = data;</span>
<span class="line-modified">3749     return;</span>
3750       }
3751 
3752   /* add new entry */
3753   gdata-&gt;n_qdatas++;
3754   gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
3755   qdata = gdata-&gt;qdatas;
3756   for (i = 0; i &lt; gdata-&gt;n_qdatas - 1; i++)
3757     if (qdata[i].quark &gt; quark)
3758       break;
3759   memmove (qdata + i + 1, qdata + i, sizeof (qdata[0]) * (gdata-&gt;n_qdatas - i - 1));
3760   qdata[i].quark = quark;
3761   qdata[i].data = data;
3762 }
3763 
3764 /**
3765  * g_type_set_qdata:
3766  * @type: a #GType
3767  * @quark: a #GQuark id to identify the data
3768  * @data: the data
3769  *
3770  * Attaches arbitrary data to a type.
3771  */
3772 void
3773 g_type_set_qdata (GType    type,
<span class="line-modified">3774           GQuark   quark,</span>
<span class="line-modified">3775           gpointer data)</span>
3776 {
3777   TypeNode *node;
3778 
3779   g_return_if_fail (quark != 0);
3780 
3781   node = lookup_type_node_I (type);
3782   if (node)
3783     {
3784       G_WRITE_LOCK (&amp;type_rw_lock);
3785       type_set_qdata_W (node, quark, data);
3786       G_WRITE_UNLOCK (&amp;type_rw_lock);
3787     }
3788   else
3789     g_return_if_fail (node != NULL);
3790 }
3791 
3792 static void
3793 type_add_flags_W (TypeNode  *node,
<span class="line-modified">3794           GTypeFlags flags)</span>
3795 {
3796   guint dflags;
3797 
3798   g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
3799   g_return_if_fail (node != NULL);
3800 
3801   if ((flags &amp; TYPE_FLAG_MASK) &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
3802     g_warning (&quot;tagging type &#39;%s&#39; as abstract after class initialization&quot;, NODE_NAME (node));
3803   dflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
3804   dflags |= flags;
3805   type_set_qdata_W (node, static_quark_type_flags, GUINT_TO_POINTER (dflags));
3806 }
3807 
3808 /**
3809  * g_type_query:
3810  * @type: #GType of a static, classed type
3811  * @query: (out caller-allocates): a user provided structure that is
3812  *     filled in with constant values upon success
3813  *
3814  * Queries the type system for information about a specific type.
3815  * This function will fill in a user-provided structure to hold
3816  * type-specific information. If an invalid #GType is passed in, the
3817  * @type member of the #GTypeQuery is 0. All members filled into the
3818  * #GTypeQuery structure should be considered constant and have to be
3819  * left untouched.
3820  */
3821 void
3822 g_type_query (GType       type,
<span class="line-modified">3823           GTypeQuery *query)</span>
3824 {
3825   TypeNode *node;
3826 
3827   g_return_if_fail (query != NULL);
3828 
3829   /* if node is not static and classed, we won&#39;t allow query */
3830   query-&gt;type = 0;
3831   node = lookup_type_node_I (type);
3832   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
3833     {
3834       /* type is classed and probably even instantiatable */
3835       G_READ_LOCK (&amp;type_rw_lock);
<span class="line-modified">3836       if (node-&gt;data)   /* type is static or referenced */</span>
<span class="line-modified">3837     {</span>
<span class="line-modified">3838       query-&gt;type = NODE_TYPE (node);</span>
<span class="line-modified">3839       query-&gt;type_name = NODE_NAME (node);</span>
<span class="line-modified">3840       query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="line-modified">3841       query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="line-modified">3842     }</span>
3843       G_READ_UNLOCK (&amp;type_rw_lock);
3844     }
3845 }
3846 
3847 /**
3848  * g_type_get_instance_count:
3849  * @type: a #GType
3850  *
3851  * Returns the number of instances allocated of the particular type;
3852  * this is only available if GLib is built with debugging support and
3853  * the instance_count debug flag is set (by setting the GOBJECT_DEBUG
3854  * variable to include instance-count).
3855  *
3856  * Returns: the number of instances allocated of the given type;
3857  *   if instance counts are not available, returns 0.
3858  *
3859  * Since: 2.44
3860  */
3861 int
3862 g_type_get_instance_count (GType type)
3863 {
3864 #ifdef G_ENABLE_DEBUG
3865   TypeNode *node;
3866 
3867   node = lookup_type_node_I (type);
3868   g_return_val_if_fail (node != NULL, 0);
3869 
3870   return g_atomic_int_get (&amp;node-&gt;instance_count);
3871 #else
3872   return 0;
3873 #endif
3874 }
3875 
3876 /* --- implementation details --- */
3877 gboolean
3878 g_type_test_flags (GType type,
<span class="line-modified">3879            guint flags)</span>
3880 {
3881   TypeNode *node;
3882   gboolean result = FALSE;
3883 
3884   node = lookup_type_node_I (type);
3885   if (node)
3886     {
3887       guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
3888       guint tflags = flags &amp; TYPE_FLAG_MASK;
3889 
3890       if (fflags)
<span class="line-modified">3891     {</span>
<span class="line-modified">3892       GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
3893 
<span class="line-modified">3894       fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="line-modified">3895     }</span>
3896       else
<span class="line-modified">3897     fflags = TRUE;</span>
3898 
3899       if (tflags)
<span class="line-modified">3900     {</span>
<span class="line-modified">3901       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">3902       tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="line-modified">3903       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">3904     }</span>
3905       else
<span class="line-modified">3906     tflags = TRUE;</span>
3907 
3908       result = tflags &amp;&amp; fflags;
3909     }
3910 
3911   return result;
3912 }
3913 
3914 /**
3915  * g_type_get_plugin:
3916  * @type: #GType to retrieve the plugin for
3917  *
3918  * Returns the #GTypePlugin structure for @type.
3919  *
3920  * Returns: (transfer none): the corresponding plugin
3921  *     if @type is a dynamic type, %NULL otherwise
3922  */
3923 GTypePlugin*
3924 g_type_get_plugin (GType type)
3925 {
3926   TypeNode *node;
</pre>
<hr />
<pre>
3928   node = lookup_type_node_I (type);
3929 
3930   return node ? node-&gt;plugin : NULL;
3931 }
3932 
3933 /**
3934  * g_type_interface_get_plugin:
3935  * @instance_type: #GType of an instantiatable type
3936  * @interface_type: #GType of an interface type
3937  *
3938  * Returns the #GTypePlugin structure for the dynamic interface
3939  * @interface_type which has been added to @instance_type, or %NULL
3940  * if @interface_type has not been added to @instance_type or does
3941  * not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
3942  *
3943  * Returns: (transfer none): the #GTypePlugin for the dynamic
3944  *     interface @interface_type of @instance_type
3945  */
3946 GTypePlugin*
3947 g_type_interface_get_plugin (GType instance_type,
<span class="line-modified">3948                  GType interface_type)</span>
3949 {
3950   TypeNode *node;
3951   TypeNode *iface;
3952 
<span class="line-modified">3953   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);    /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
3954 
3955   node = lookup_type_node_I (instance_type);
3956   iface = lookup_type_node_I (interface_type);
3957   if (node &amp;&amp; iface)
3958     {
3959       IFaceHolder *iholder;
3960       GTypePlugin *plugin;
3961 
3962       G_READ_LOCK (&amp;type_rw_lock);
3963 
3964       iholder = iface_node_get_holders_L (iface);
3965       while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
<span class="line-modified">3966     iholder = iholder-&gt;next;</span>
3967       plugin = iholder ? iholder-&gt;plugin : NULL;
3968 
3969       G_READ_UNLOCK (&amp;type_rw_lock);
3970 
3971       return plugin;
3972     }
3973 
3974   g_return_val_if_fail (node == NULL, NULL);
3975   g_return_val_if_fail (iface == NULL, NULL);
3976 
3977   g_warning (G_STRLOC &quot;: attempt to look up plugin for invalid instance/interface type pair.&quot;);
3978 
3979   return NULL;
3980 }
3981 
3982 /**
3983  * g_type_fundamental_next:
3984  *
3985  * Returns the next free fundamental type id which can be used to
3986  * register a new fundamental type with g_type_register_fundamental().
</pre>
<hr />
<pre>
4004 
4005 /**
4006  * g_type_fundamental:
4007  * @type_id: valid type ID
4008  *
4009  * Internal function, used to extract the fundamental type ID portion.
4010  * Use G_TYPE_FUNDAMENTAL() instead.
4011  *
4012  * Returns: fundamental type ID
4013  */
4014 GType
4015 g_type_fundamental (GType type_id)
4016 {
4017   TypeNode *node = lookup_type_node_I (type_id);
4018 
4019   return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
4020 }
4021 
4022 gboolean
4023 g_type_check_instance_is_a (GTypeInstance *type_instance,
<span class="line-modified">4024                 GType          iface_type)</span>
4025 {
4026   TypeNode *node, *iface;
4027   gboolean check;
4028 
4029   if (!type_instance || !type_instance-&gt;g_class)
4030     return FALSE;
4031 
4032   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4033   iface = lookup_type_node_I (iface_type);
4034   check = node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4035 
4036   return check;
4037 }
4038 
4039 gboolean
4040 g_type_check_instance_is_fundamentally_a (GTypeInstance *type_instance,
4041                                           GType          fundamental_type)
4042 {
4043   TypeNode *node;
4044   if (!type_instance || !type_instance-&gt;g_class)
4045     return FALSE;
4046   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4047   return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
4048 }
4049 
4050 gboolean
4051 g_type_check_class_is_a (GTypeClass *type_class,
<span class="line-modified">4052              GType       is_a_type)</span>
4053 {
4054   TypeNode *node, *iface;
4055   gboolean check;
4056 
4057   if (!type_class)
4058     return FALSE;
4059 
4060   node = lookup_type_node_I (type_class-&gt;g_type);
4061   iface = lookup_type_node_I (is_a_type);
4062   check = node &amp;&amp; node-&gt;is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4063 
4064   return check;
4065 }
4066 
4067 GTypeInstance*
4068 g_type_check_instance_cast (GTypeInstance *type_instance,
<span class="line-modified">4069                 GType          iface_type)</span>
4070 {
4071   if (type_instance)
4072     {
4073       if (type_instance-&gt;g_class)
<span class="line-modified">4074     {</span>
<span class="line-modified">4075       TypeNode *node, *iface;</span>
<span class="line-modified">4076       gboolean is_instantiatable, check;</span>
<span class="line-modified">4077 </span>
<span class="line-modified">4078       node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="line-modified">4079       is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="line-modified">4080       iface = lookup_type_node_I (iface_type);</span>
<span class="line-modified">4081       check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="line-modified">4082       if (check)</span>
<span class="line-modified">4083         return type_instance;</span>
<span class="line-modified">4084 </span>
<span class="line-modified">4085       if (is_instantiatable)</span>
<span class="line-modified">4086         g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4087                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-removed">4088                type_descriptive_name_I (iface_type));</span>
<span class="line-removed">4089       else</span>
<span class="line-removed">4090         g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="line-removed">4091                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-removed">4092                type_descriptive_name_I (iface_type));</span>
<span class="line-removed">4093     }</span>
<span class="line-removed">4094       else</span>
<span class="line-removed">4095     g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
4096            type_descriptive_name_I (iface_type));








4097     }
4098 
4099   return type_instance;
4100 }
4101 
4102 GTypeClass*
4103 g_type_check_class_cast (GTypeClass *type_class,
<span class="line-modified">4104              GType       is_a_type)</span>
4105 {
4106   if (type_class)
4107     {
4108       TypeNode *node, *iface;
4109       gboolean is_classed, check;
4110 
4111       node = lookup_type_node_I (type_class-&gt;g_type);
4112       is_classed = node &amp;&amp; node-&gt;is_classed;
4113       iface = lookup_type_node_I (is_a_type);
4114       check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4115       if (check)
<span class="line-modified">4116     return type_class;</span>
4117 
4118       if (is_classed)
<span class="line-modified">4119     g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4120            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">4121            type_descriptive_name_I (is_a_type));</span>
4122       else
<span class="line-modified">4123     g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4124            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">4125            type_descriptive_name_I (is_a_type));</span>
4126     }
4127   else
4128     g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
<span class="line-modified">4129            type_descriptive_name_I (is_a_type));</span>
4130   return type_class;
4131 }
4132 
4133 /**
4134  * g_type_check_instance:
4135  * @instance: a valid #GTypeInstance structure
4136  *
4137  * Private helper function to aid implementation of the
4138  * G_TYPE_CHECK_INSTANCE() macro.
4139  *
4140  * Returns: %TRUE if @instance is valid, %FALSE otherwise
4141  */
4142 gboolean
4143 g_type_check_instance (GTypeInstance *type_instance)
4144 {
4145   /* this function is just here to make the signal system
4146    * conveniently elaborated on instance checks
4147    */
4148   if (type_instance)
4149     {
4150       if (type_instance-&gt;g_class)
<span class="line-modified">4151     {</span>
<span class="line-modified">4152       TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
4153 
<span class="line-modified">4154       if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="line-modified">4155         return TRUE;</span>
4156 
<span class="line-modified">4157       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">4158              type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="line-modified">4159     }</span>
4160       else
<span class="line-modified">4161     g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
4162     }
4163   else
4164     g_warning (&quot;invalid (NULL) pointer instance&quot;);
4165 
4166   return FALSE;
4167 }
4168 
4169 static inline gboolean
4170 type_check_is_value_type_U (GType type)
4171 {
4172   GTypeFlags tflags = G_TYPE_FLAG_VALUE_ABSTRACT;
4173   TypeNode *node;
4174 
4175   /* common path speed up */
4176   node = lookup_type_node_I (type);
4177   if (node &amp;&amp; node-&gt;mutatable_check_cache)
4178     return TRUE;
4179 
4180   G_READ_LOCK (&amp;type_rw_lock);
4181  restart_check:
4182   if (node)
4183     {
4184       if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
<span class="line-modified">4185       node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="line-modified">4186     tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
4187       else if (NODE_IS_IFACE (node))
<span class="line-modified">4188     {</span>
<span class="line-modified">4189       guint i;</span>
4190 
<span class="line-modified">4191       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">4192         {</span>
<span class="line-modified">4193           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">4194           TypeNode *prnode = lookup_type_node_I (prtype);</span>
4195 
<span class="line-modified">4196           if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">4197         {</span>
<span class="line-modified">4198           type = prtype;</span>
<span class="line-modified">4199           node = lookup_type_node_I (type);</span>
<span class="line-modified">4200           goto restart_check;</span>
<span class="line-removed">4201         }</span>
<span class="line-removed">4202         }</span>
4203     }


4204     }
4205   G_READ_UNLOCK (&amp;type_rw_lock);
4206 
4207   return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
4208 }
4209 
4210 gboolean
4211 g_type_check_is_value_type (GType type)
4212 {
4213   return type_check_is_value_type_U (type);
4214 }
4215 
4216 gboolean
4217 g_type_check_value (const GValue *value)
4218 {
4219   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
4220 }
4221 
4222 gboolean
4223 g_type_check_value_holds (const GValue *value,
<span class="line-modified">4224               GType         type)</span>
4225 {
4226   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
4227 }
4228 
4229 /**
4230  * g_type_value_table_peek: (skip)
4231  * @type: a #GType
4232  *
4233  * Returns the location of the #GTypeValueTable associated with @type.
4234  *
4235  * Note that this function should only be used from source code
4236  * that implements or has internal knowledge of the implementation of
4237  * @type.
4238  *
4239  * Returns: location of the #GTypeValueTable associated with @type or
4240  *     %NULL if there is no #GTypeValueTable associated with @type
4241  */
4242 GTypeValueTable*
4243 g_type_value_table_peek (GType type)
4244 {
4245   GTypeValueTable *vtable = NULL;
4246   TypeNode *node = lookup_type_node_I (type);
4247   gboolean has_refed_data, has_table;
4248 
4249   if (node &amp;&amp; NODE_REFCOUNT (node) &amp;&amp; node-&gt;mutatable_check_cache)
4250     return node-&gt;data-&gt;common.value_table;
4251 
4252   G_READ_LOCK (&amp;type_rw_lock);
4253 
4254  restart_table_peek:
4255   has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
4256   has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
4257   if (has_refed_data)
4258     {
4259       if (has_table)
<span class="line-modified">4260     vtable = node-&gt;data-&gt;common.value_table;</span>
4261       else if (NODE_IS_IFACE (node))
<span class="line-modified">4262     {</span>
<span class="line-modified">4263       guint i;</span>
4264 
<span class="line-modified">4265       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">4266         {</span>
<span class="line-modified">4267           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">4268           TypeNode *prnode = lookup_type_node_I (prtype);</span>
4269 
<span class="line-modified">4270           if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">4271         {</span>
<span class="line-modified">4272           type = prtype;</span>
<span class="line-modified">4273           node = lookup_type_node_I (type);</span>
<span class="line-modified">4274           goto restart_table_peek;</span>
<span class="line-removed">4275         }</span>
<span class="line-removed">4276         }</span>
4277     }


4278     }
4279 
4280   G_READ_UNLOCK (&amp;type_rw_lock);
4281 
4282   if (vtable)
4283     return vtable;
4284 
4285   if (!node)
4286     g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
4287   if (!has_refed_data)
4288     g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
<span class="line-modified">4289            type_descriptive_name_I (type));</span>
4290 
4291   return NULL;
4292 }
4293 
4294 const gchar *
4295 g_type_name_from_instance (GTypeInstance *instance)
4296 {
4297   if (!instance)
4298     return &quot;&lt;NULL-instance&gt;&quot;;
4299   else
4300     return g_type_name_from_class (instance-&gt;g_class);
4301 }
4302 
4303 const gchar *
4304 g_type_name_from_class (GTypeClass *g_class)
4305 {
4306   if (!g_class)
4307     return &quot;&lt;NULL-class&gt;&quot;;
4308   else
4309     return g_type_name (g_class-&gt;g_type);
</pre>
<hr />
<pre>
4336 
4337   node-&gt;data-&gt;boxed.copy_func = copy_func;
4338   node-&gt;data-&gt;boxed.free_func = free_func;
4339 }
4340 
4341 /* --- initialization --- */
4342 /**
4343  * g_type_init_with_debug_flags:
4344  * @debug_flags: bitwise combination of #GTypeDebugFlags values for
4345  *     debugging purposes
4346  *
4347  * This function used to initialise the type system with debugging
4348  * flags.  Since GLib 2.36, the type system is initialised automatically
4349  * and this function does nothing.
4350  *
4351  * If you need to enable debugging features, use the GOBJECT_DEBUG
4352  * environment variable.
4353  *
4354  * Deprecated: 2.36: the type system is now initialised automatically
4355  */

4356 void
4357 g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
4358 {
4359   g_assert_type_system_initialized ();
4360 
4361   if (debug_flags)
4362     g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
4363 }

4364 
4365 /**
4366  * g_type_init:
4367  *
4368  * This function used to initialise the type system.  Since GLib 2.36,
4369  * the type system is initialised automatically and this function does
4370  * nothing.
4371  *
4372  * Deprecated: 2.36: the type system is now initialised automatically
4373  */
4374 #if !(defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32))
4375 void
4376 g_type_init (void)
4377 {
4378   g_assert_type_system_initialized ();
4379 }
4380 #endif // GSTREAMER_LITE
4381 
4382 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
4383 // We cannot due static initialization, since it will crash due to
4384 // threading system is not initialized yet.
4385 static void gobject_init (void);
4386 void
4387 g_type_init (void)
4388 {
4389   gobject_init ();
4390 }
4391 #endif // GSTREAMER_LITE
4392 
4393 static void
4394 gobject_init (void)
4395 {
4396   const gchar *env_string;
4397   GTypeInfo info;
4398   TypeNode *node;
<span class="line-modified">4399   GType type;</span>
4400 
4401   /* Ensure GLib is initialized first, see
4402    * https://bugzilla.gnome.org/show_bug.cgi?id=756139
4403    */
4404   GLIB_PRIVATE_CALL (glib_init) ();
4405 
4406   G_WRITE_LOCK (&amp;type_rw_lock);
4407 
4408   /* setup GObject library wide debugging flags */
4409   env_string = g_getenv (&quot;GOBJECT_DEBUG&quot;);
4410   if (env_string != NULL)
4411     {
4412       GDebugKey debug_keys[] = {
4413         { &quot;objects&quot;, G_TYPE_DEBUG_OBJECTS },
4414         { &quot;instance-count&quot;, G_TYPE_DEBUG_INSTANCE_COUNT },
4415         { &quot;signals&quot;, G_TYPE_DEBUG_SIGNALS },
4416       };
4417 
4418       _g_type_debug_flags = g_parse_debug_string (env_string, debug_keys, G_N_ELEMENTS (debug_keys));
4419     }
</pre>
<hr />
<pre>
4586  *
4587  * static int
4588  * my_object_get_some_field (MyObject *my_object)
4589  * {
4590  *   MyObjectPrivate *priv;
4591  *
4592  *   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
4593  *
4594  *   priv = my_object-&gt;priv;
4595  *
4596  *   return priv-&gt;some_field;
4597  * }
4598  * ]|
4599  *
4600  * Since: 2.4
4601  * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
4602  *   family of macros to add instance private data to a type
4603  */
4604 void
4605 g_type_class_add_private (gpointer g_class,
<span class="line-modified">4606               gsize    private_size)</span>
4607 {
4608   GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
4609   TypeNode *node = lookup_type_node_I (instance_type);
4610 
4611   g_return_if_fail (private_size &gt; 0);
4612   g_return_if_fail (private_size &lt;= 0xffff);
4613 
4614   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
4615     {
4616       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4617          type_descriptive_name_I (instance_type));</span>
4618       return;
4619     }
4620 
4621   if (NODE_PARENT_TYPE (node))
4622     {
4623       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4624       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">4625     {</span>
<span class="line-modified">4626       g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">4627       return;</span>
<span class="line-modified">4628     }</span>
4629     }
4630 
4631   G_WRITE_LOCK (&amp;type_rw_lock);
4632 
4633   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
4634   g_assert (private_size &lt;= 0xffff);
4635   node-&gt;data-&gt;instance.private_size = private_size;
4636 
4637   G_WRITE_UNLOCK (&amp;type_rw_lock);
4638 }
4639 
4640 /* semi-private, called only by the G_ADD_PRIVATE macro */
4641 gint
4642 g_type_add_instance_private (GType class_gtype,
4643                              gsize private_size)
4644 {
4645   TypeNode *node = lookup_type_node_I (class_gtype);
4646 
4647   g_return_val_if_fail (private_size &gt; 0, 0);
4648   g_return_val_if_fail (private_size &lt;= 0xffff, 0);
4649 
4650   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4651     {
4652       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4653          type_descriptive_name_I (class_gtype));</span>
4654       return 0;
4655     }
4656 
4657   if (node-&gt;plugin != NULL)
4658     {
4659       g_warning (&quot;cannot use g_type_add_instance_private() with dynamic type &#39;%s&#39;&quot;,
4660                  type_descriptive_name_I (class_gtype));
4661       return 0;
4662     }
4663 
4664   /* in the future, we want to register the private data size of a type
4665    * directly from the get_type() implementation so that we can take full
4666    * advantage of the type definition macros that we already have.
4667    *
4668    * unfortunately, this does not behave correctly if a class in the middle
4669    * of the type hierarchy uses the &quot;old style&quot; of private data registration
4670    * from the class_init() implementation, as the private data offset is not
4671    * going to be known until the full class hierarchy is initialized.
4672    *
4673    * in order to transition our code to the Glorious New Future(TM), we proceed
</pre>
<hr />
<pre>
4700                                     gint     *private_size_or_offset)
4701 {
4702   GType class_gtype = ((GTypeClass *) g_class)-&gt;g_type;
4703   TypeNode *node = lookup_type_node_I (class_gtype);
4704   gssize private_size;
4705 
4706   g_return_if_fail (private_size_or_offset != NULL);
4707 
4708   /* if we have been passed the offset instead of the private data size,
4709    * then we consider this as a no-op, and just return the value. see the
4710    * comment in g_type_add_instance_private() for the full explanation.
4711    */
4712   if (*private_size_or_offset &gt; 0)
4713     g_return_if_fail (*private_size_or_offset &lt;= 0xffff);
4714   else
4715     return;
4716 
4717   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4718     {
4719       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4720          type_descriptive_name_I (class_gtype));</span>
4721       *private_size_or_offset = 0;
4722       return;
4723     }
4724 
4725   if (NODE_PARENT_TYPE (node))
4726     {
4727       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4728       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">4729     {</span>
<span class="line-modified">4730       g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
4731           *private_size_or_offset = 0;
<span class="line-modified">4732       return;</span>
<span class="line-modified">4733     }</span>
4734     }
4735 
4736   G_WRITE_LOCK (&amp;type_rw_lock);
4737 
4738   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
4739   g_assert (private_size &lt;= 0xffff);
4740   node-&gt;data-&gt;instance.private_size = private_size;
4741 
4742   *private_size_or_offset = -(gint) node-&gt;data-&gt;instance.private_size;
4743 
4744   G_WRITE_UNLOCK (&amp;type_rw_lock);
4745 }
4746 
4747 gpointer
4748 g_type_instance_get_private (GTypeInstance *instance,
<span class="line-modified">4749                  GType          private_type)</span>
4750 {
4751   TypeNode *node;
4752 
4753   g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
4754 
4755   node = lookup_type_node_I (private_type);
4756   if (G_UNLIKELY (!node || !node-&gt;is_instantiatable))
4757     {
4758       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4759                  type_descriptive_name_I (instance-&gt;g_class-&gt;g_type));
4760       return NULL;
4761     }
4762 
4763   return ((gchar *) instance) - node-&gt;data-&gt;instance.private_size;
4764 }
4765 
4766 /**
4767  * g_type_class_get_instance_private_offset: (skip)
4768  * @g_class: (type GObject.TypeClass): a #GTypeClass
4769  *
</pre>
<hr />
<pre>
4796   g_assert (node-&gt;is_instantiatable);
4797 
4798   if (NODE_PARENT_TYPE (node))
4799     {
4800       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4801 
4802       parent_size = pnode-&gt;data-&gt;instance.private_size;
4803     }
4804   else
4805     parent_size = 0;
4806 
4807   if (node-&gt;data-&gt;instance.private_size == parent_size)
4808     g_error (&quot;g_type_class_get_instance_private_offset() called on class %s but it has no private data&quot;,
4809              g_type_name (instance_type));
4810 
4811   return -(gint) node-&gt;data-&gt;instance.private_size;
4812 }
4813 
4814 /**
4815  * g_type_add_class_private:
<span class="line-modified">4816  * @class_type: GType of an classed type</span>
4817  * @private_size: size of private structure
4818  *
4819  * Registers a private class structure for a classed type;
4820  * when the class is allocated, the private structures for
4821  * the class and all of its parent types are allocated
4822  * sequentially in the same memory block as the public
4823  * structures, and are zero-filled.
4824  *
4825  * This function should be called in the
4826  * type&#39;s get_type() function after the type is registered.
4827  * The private structure can be retrieved using the
4828  * G_TYPE_CLASS_GET_PRIVATE() macro.
4829  *
4830  * Since: 2.24
4831  */
4832 void
4833 g_type_add_class_private (GType    class_type,
<span class="line-modified">4834               gsize    private_size)</span>
4835 {
4836   TypeNode *node = lookup_type_node_I (class_type);
4837   gsize offset;
4838 
4839   g_return_if_fail (private_size &gt; 0);
4840 
4841   if (!node || !node-&gt;is_classed || !node-&gt;data)
4842     {
4843       g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4844          type_descriptive_name_I (class_type));</span>
4845       return;
4846     }
4847 
4848   if (NODE_PARENT_TYPE (node))
4849     {
4850       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4851       if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
<span class="line-modified">4852     {</span>
<span class="line-modified">4853       g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">4854       return;</span>
<span class="line-modified">4855     }</span>
4856     }
4857 
4858   G_WRITE_LOCK (&amp;type_rw_lock);
4859 
4860   offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
4861   node-&gt;data-&gt;class.class_private_size = offset + private_size;
4862 
4863   G_WRITE_UNLOCK (&amp;type_rw_lock);
4864 }
4865 
4866 gpointer
4867 g_type_class_get_private (GTypeClass *klass,
<span class="line-modified">4868               GType       private_type)</span>
4869 {
4870   TypeNode *class_node;
4871   TypeNode *private_node;
4872   TypeNode *parent_node;
4873   gsize offset;
4874 
4875   g_return_val_if_fail (klass != NULL, NULL);
4876 
4877   class_node = lookup_type_node_I (klass-&gt;g_type);
4878   if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
4879     {
4880       g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4881          type_descriptive_name_I (klass-&gt;g_type));</span>
4882       return NULL;
4883     }
4884 
4885   private_node = lookup_type_node_I (private_type);
4886   if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
4887     {
4888       g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4889          type_descriptive_name_I (private_type));</span>
4890       return NULL;
4891     }
4892 
4893   offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
4894 
4895   if (NODE_PARENT_TYPE (private_node))
4896     {
4897       parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
4898       g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
4899 
4900       if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
<span class="line-modified">4901     {</span>
<span class="line-modified">4902       g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="line-modified">4903       return NULL;</span>
<span class="line-modified">4904     }</span>
4905 
4906       offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
4907     }
4908 
4909   return G_STRUCT_MEMBER_P (klass, offset);
4910 }
4911 
4912 /**
4913  * g_type_ensure:
4914  * @type: a #GType
4915  *
4916  * Ensures that the indicated @type has been registered with the
4917  * type system, and its _class_init() method has been run.
4918  *
4919  * In theory, simply calling the type&#39;s _get_type() method (or using
4920  * the corresponding macro) is supposed take care of this. However,
4921  * _get_type() methods are often marked %G_GNUC_CONST for performance
4922  * reasons, even though this is technically incorrect (since
4923  * %G_GNUC_CONST requires that the function not have side effects,
4924  * which _get_type() methods do on the first call). As a result, if
</pre>
</td>
<td>
<hr />
<pre>
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;../glib/gvalgrind.h&quot;
  25 #include &lt;string.h&gt;
  26 
  27 #include &quot;gtype.h&quot;
  28 #include &quot;gtype-private.h&quot;
  29 #include &quot;gtypeplugin.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gatomicarray.h&quot;
  32 #include &quot;gobject_trace.h&quot;
  33 
  34 #include &quot;glib-private.h&quot;
  35 #include &quot;gconstructor.h&quot;
  36 
  37 #ifdef G_OS_WIN32
  38 #include &lt;windows.h&gt;
  39 #endif
  40 
  41 #ifdef  G_ENABLE_DEBUG
<span class="line-modified">  42 #define IF_DEBUG(debug_type)  if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
  43 #endif
  44 
  45 /**
  46  * SECTION:gtype
  47  * @short_description: The GLib Runtime type identification and
  48  *     management system
  49  * @title:Type Information
  50  *
  51  * The GType API is the foundation of the GObject system.  It provides the
  52  * facilities for registering and managing all fundamental data types,
  53  * user-defined object and interface types.
  54  *
  55  * For type creation and registration purposes, all types fall into one of
  56  * two categories: static or dynamic.  Static types are never loaded or
  57  * unloaded at run-time as dynamic types may be.  Static types are created
  58  * with g_type_register_static() that gets type specific information passed
  59  * in via a #GTypeInfo structure.
  60  *
  61  * Dynamic types are created with g_type_register_dynamic() which takes a
  62  * #GTypePlugin structure instead. The remaining type information (the
</pre>
<hr />
<pre>
  83  *
  84  * As mentioned in the [GType conventions][gtype-conventions], type names must
  85  * be at least three characters long. There is no upper length limit. The first
  86  * character must be a letter (a or A) or an underscore (). Subsequent
  87  * characters can be letters, numbers or any of .
  88  */
  89 
  90 
  91 /* NOTE: some functions (some internal variants and exported ones)
  92  * invalidate data portions of the TypeNodes. if external functions/callbacks
  93  * are called, pointers to memory maintained by TypeNodes have to be looked up
  94  * again. this affects most of the struct TypeNode fields, e.g. -&gt;children or
  95  * CLASSED_NODE_IFACES_ENTRIES() respectively IFACE_NODE_PREREQUISITES() (but
  96  * not -&gt;supers[]), as all those memory portions can get realloc()ed during
  97  * callback invocation.
  98  *
  99  * LOCKING:
 100  * lock handling issues when calling static functions are indicated by
 101  * uppercase letter postfixes, all static functions have to have
 102  * one of the below postfixes:
<span class="line-modified"> 103  * - _I:  [Indifferent about locking]</span>
 104  *   function doesn&#39;t care about locks at all
<span class="line-modified"> 105  * - _U:  [Unlocked invocation]</span>
 106  *   no read or write lock has to be held across function invocation
 107  *   (locks may be acquired and released during invocation though)
<span class="line-modified"> 108  * - _L:  [Locked invocation]</span>
 109  *   a write lock or more than 0 read locks have to be held across
 110  *   function invocation
<span class="line-modified"> 111  * - _W:  [Write-locked invocation]</span>
 112  *   a write lock has to be held across function invocation
<span class="line-modified"> 113  * - _Wm: [Write-locked invocation, mutatable]</span>
 114  *   like _W, but the write lock might be released and reacquired
 115  *   during invocation, watch your pointers
 116  * - _WmREC:    [Write-locked invocation, mutatable, recursive]
 117  *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
 118  */
 119 
 120 #ifdef LOCK_DEBUG
 121 #define G_READ_LOCK(rw_lock)    do { g_printerr (G_STRLOC &quot;: readL++\n&quot;); g_rw_lock_reader_lock (rw_lock); } while (0)
 122 #define G_READ_UNLOCK(rw_lock)  do { g_printerr (G_STRLOC &quot;: readL--\n&quot;); g_rw_lock_reader_unlock (rw_lock); } while (0)
 123 #define G_WRITE_LOCK(rw_lock)   do { g_printerr (G_STRLOC &quot;: writeL++\n&quot;); g_rw_lock_writer_lock (rw_lock); } while (0)
 124 #define G_WRITE_UNLOCK(rw_lock) do { g_printerr (G_STRLOC &quot;: writeL--\n&quot;); g_rw_lock_writer_unlock (rw_lock); } while (0)
 125 #else
 126 #define G_READ_LOCK(rw_lock)    g_rw_lock_reader_lock (rw_lock)
 127 #define G_READ_UNLOCK(rw_lock)  g_rw_lock_reader_unlock (rw_lock)
 128 #define G_WRITE_LOCK(rw_lock)   g_rw_lock_writer_lock (rw_lock)
 129 #define G_WRITE_UNLOCK(rw_lock) g_rw_lock_writer_unlock (rw_lock)
 130 #endif
 131 #define INVALID_RECURSION(func, arg, type_name) G_STMT_START{ \
 132     static const gchar _action[] = &quot; invalidly modified type &quot;;  \
 133     gpointer _arg = (gpointer) (arg); const gchar *_tname = (type_name), *_fname = (func); \
 134     if (_arg) \
 135       g_error (&quot;%s(%p)%s&#39;%s&#39;&quot;, _fname, _arg, _action, _tname); \
 136     else \
 137       g_error (&quot;%s()%s&#39;%s&#39;&quot;, _fname, _action, _tname); \
 138 }G_STMT_END
 139 #define g_assert_type_system_initialized() \
 140   g_assert (static_quark_type_flags)
 141 
 142 #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
<span class="line-modified"> 143             G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="line-modified"> 144             G_TYPE_FLAG_DERIVABLE | \</span>
<span class="line-modified"> 145             G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="line-modified"> 146 #define TYPE_FLAG_MASK       (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
 147 #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
<span class="line-modified"> 148                    sizeof (gpointer)), \</span>
 149                                                   sizeof (glong)))
 150 
 151 /* The 2*sizeof(size_t) alignment here is borrowed from
 152  * GNU libc, so it should be good most everywhere.
 153  * It is more conservative than is needed on some 64-bit
 154  * platforms, but ia64 does require a 16-byte alignment.
 155  * The SIMD extensions for x86 and ppc32 would want a
 156  * larger alignment than this, but we don&#39;t need to
 157  * do better than malloc.
 158  */
 159 #define STRUCT_ALIGNMENT (2 * sizeof (gsize))
 160 #define ALIGN_STRUCT(offset) \
 161       ((offset + (STRUCT_ALIGNMENT - 1)) &amp; -STRUCT_ALIGNMENT)
 162 
 163 
 164 /* --- typedefs --- */
 165 typedef struct _TypeNode        TypeNode;
 166 typedef struct _CommonData      CommonData;
 167 typedef struct _BoxedData       BoxedData;
 168 typedef struct _IFaceData       IFaceData;
 169 typedef struct _ClassData       ClassData;
 170 typedef struct _InstanceData    InstanceData;
 171 typedef union  _TypeData        TypeData;
 172 typedef struct _IFaceEntries    IFaceEntries;
 173 typedef struct _IFaceEntry      IFaceEntry;
 174 typedef struct _IFaceHolder IFaceHolder;
 175 
 176 
 177 /* --- prototypes --- */
<span class="line-modified"> 178 static inline GTypeFundamentalInfo* type_node_fundamental_info_I  (TypeNode   *node);</span>
<span class="line-modified"> 179 static        void      type_add_flags_W    (TypeNode   *node,</span>
<span class="line-modified"> 180                    GTypeFlags    flags);</span>
<span class="line-modified"> 181 static        void      type_data_make_W    (TypeNode   *node,</span>
<span class="line-modified"> 182                    const GTypeInfo  *info,</span>
<span class="line-modified"> 183                    const GTypeValueTable  *value_table);</span>
<span class="line-modified"> 184 static inline void      type_data_ref_Wm    (TypeNode   *node);</span>
<span class="line-modified"> 185 static inline void      type_data_unref_U               (TypeNode   *node,</span>
<span class="line-modified"> 186                    gboolean    uncached);</span>
<span class="line-modified"> 187 static void       type_data_last_unref_Wm   (TypeNode *              node,</span>
<span class="line-modified"> 188                    gboolean    uncached);</span>
<span class="line-modified"> 189 static inline gpointer      type_get_qdata_L    (TypeNode   *node,</span>
<span class="line-modified"> 190                    GQuark      quark);</span>
<span class="line-modified"> 191 static inline void      type_set_qdata_W    (TypeNode   *node,</span>
<span class="line-modified"> 192                    GQuark      quark,</span>
<span class="line-modified"> 193                    gpointer    data);</span>
<span class="line-modified"> 194 static IFaceHolder*     type_iface_peek_holder_L  (TypeNode   *iface,</span>
<span class="line-modified"> 195                    GType       instance_type);</span>
 196 static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
 197                                                                          TypeNode               *node);
 198 static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
 199                                                                          TypeNode               *node);
<span class="line-modified"> 200 static gboolean       type_node_is_a_L    (TypeNode   *node,</span>
<span class="line-modified"> 201                    TypeNode   *iface_node);</span>
 202 
 203 
 204 /* --- enumeration --- */
 205 
 206 /* The InitState enumeration is used to track the progress of initializing
 207  * both classes and interface vtables. Keeping the state of initialization
 208  * is necessary to handle new interfaces being added while we are initializing
 209  * the class or other interfaces.
 210  */
 211 typedef enum
 212 {
 213   UNINITIALIZED,
 214   BASE_CLASS_INIT,
 215   BASE_IFACE_INIT,
 216   CLASS_INIT,
 217   IFACE_INIT,
 218   INITIALIZED
 219 } InitState;
 220 
 221 /* --- structures --- */
 222 struct _TypeNode
 223 {
 224   guint volatile ref_count;
 225 #ifdef G_ENABLE_DEBUG
 226   guint volatile instance_count;
 227 #endif
 228   GTypePlugin *plugin;
 229   guint        n_children; /* writable with lock */
 230   guint        n_supers : 8;
 231   guint        n_prerequisites : 9;
 232   guint        is_classed : 1;
 233   guint        is_instantiatable : 1;
<span class="line-modified"> 234   guint        mutatable_check_cache : 1; /* combines some common path checks */</span>
 235   GType       *children; /* writable with lock */
 236   TypeData * volatile data;
 237   GQuark       qname;
 238   GData       *global_gdata;
 239   union {
<span class="line-modified"> 240     GAtomicArray iface_entries;   /* for !iface types */</span>
 241     GAtomicArray offsets;
 242   } _prot;
 243   GType       *prerequisites;
 244   GType        supers[1]; /* flexible array */
 245 };
 246 
<span class="line-modified"> 247 #define SIZEOF_BASE_TYPE_NODE()     (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="line-modified"> 248 #define MAX_N_SUPERS        (255)</span>
<span class="line-modified"> 249 #define MAX_N_CHILDREN        (G_MAXUINT)</span>
<span class="line-modified"> 250 #define MAX_N_INTERFACES      (255) /* Limited by offsets being 8 bits */</span>
<span class="line-modified"> 251 #define MAX_N_PREREQUISITES     (511)</span>
<span class="line-modified"> 252 #define NODE_TYPE(node)       (node-&gt;supers[0])</span>
<span class="line-modified"> 253 #define NODE_PARENT_TYPE(node)      (node-&gt;supers[1])</span>
<span class="line-modified"> 254 #define NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])</span>
<span class="line-modified"> 255 #define NODE_NAME(node)       (g_quark_to_string (node-&gt;qname))</span>
 256 #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
<span class="line-modified"> 257 #define NODE_IS_BOXED(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="line-modified"> 258 #define NODE_IS_IFACE(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="line-modified"> 259 #define CLASSED_NODE_IFACES_ENTRIES(node) (&amp;(node)-&gt;_prot.iface_entries)</span>
 260 #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
<span class="line-modified"> 261 #define IFACE_NODE_N_PREREQUISITES(node)  ((node)-&gt;n_prerequisites)</span>
<span class="line-modified"> 262 #define IFACE_NODE_PREREQUISITES(node)    ((node)-&gt;prerequisites)</span>
<span class="line-modified"> 263 #define iface_node_get_holders_L(node)    ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
 264 #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
<span class="line-modified"> 265 #define iface_node_get_dependants_array_L(n)  ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
 266 #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
<span class="line-modified"> 267 #define TYPE_ID_MASK        ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
 268 
 269 #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
 270         ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
<span class="line-modified"> 271    (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
 272 
 273 struct _IFaceHolder
 274 {
 275   GType           instance_type;
 276   GInterfaceInfo *info;
 277   GTypePlugin    *plugin;
 278   IFaceHolder    *next;
 279 };
 280 
 281 struct _IFaceEntry
 282 {
 283   GType           iface_type;
 284   GTypeInterface *vtable;
 285   InitState       init_state;
 286 };
 287 
 288 struct _IFaceEntries {
 289   guint offset_index;
 290   IFaceEntry entry[1];
 291 };
</pre>
<hr />
<pre>
 363   GTypeClassCacheFunc cache_func;
 364 } ClassCacheFunc;
 365 
 366 typedef struct {
 367   gpointer                check_data;
 368   GTypeInterfaceCheckFunc check_func;
 369 } IFaceCheckFunc;
 370 
 371 
 372 /* --- variables --- */
 373 static GRWLock         type_rw_lock;
 374 static GRecMutex       class_init_rec_mutex;
 375 static guint           static_n_class_cache_funcs = 0;
 376 static ClassCacheFunc *static_class_cache_funcs = NULL;
 377 static guint           static_n_iface_check_funcs = 0;
 378 static IFaceCheckFunc *static_iface_check_funcs = NULL;
 379 static GQuark          static_quark_type_flags = 0;
 380 static GQuark          static_quark_iface_holder = 0;
 381 static GQuark          static_quark_dependants_array = 0;
 382 static guint           type_registration_serial = 0;
<span class="line-added"> 383 </span>
<span class="line-added"> 384 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
 385 GTypeDebugFlags        _g_type_debug_flags = 0;
<span class="line-added"> 386 G_GNUC_END_IGNORE_DEPRECATIONS</span>
 387 
 388 /* --- type nodes --- */
 389 static GHashTable       *static_type_nodes_ht = NULL;
<span class="line-modified"> 390 static TypeNode   *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="line-modified"> 391 static GType     static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
 392 
 393 static inline TypeNode*
 394 lookup_type_node_I (GType utype)
 395 {
 396   if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
 397     return (TypeNode*) (utype &amp; ~TYPE_ID_MASK);
 398   else
 399     return static_fundamental_type_nodes[utype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT];
 400 }
 401 
 402 /**
 403  * g_type_get_type_registration_serial:
 404  *
 405  * Returns an opaque serial number that represents the state of the set
 406  * of registered types. Any time a type is registered this serial changes,
 407  * which means you can cache information based on type lookups (such as
 408  * g_type_from_name()) and know if the cache is still valid at a later
 409  * time by comparing the current serial with the one at the type lookup.
 410  *
 411  * Since: 2.36
 412  *
 413  * Returns: An unsigned int, representing the state of type registrations
 414  */
 415 guint
 416 g_type_get_type_registration_serial (void)
 417 {
 418   return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
 419 }
 420 
 421 static TypeNode*
 422 type_node_any_new_W (TypeNode             *pnode,
<span class="line-modified"> 423          GType                 ftype,</span>
<span class="line-modified"> 424          const gchar          *name,</span>
<span class="line-modified"> 425          GTypePlugin          *plugin,</span>
<span class="line-modified"> 426          GTypeFundamentalFlags type_flags)</span>
 427 {
 428   guint n_supers;
 429   GType type;
 430   TypeNode *node;
 431   guint i, node_size = 0;
 432 
 433   n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
 434 
 435   if (!pnode)
<span class="line-modified"> 436     node_size += SIZEOF_FUNDAMENTAL_INFO;       /* fundamental type info */</span>
<span class="line-modified"> 437   node_size += SIZEOF_BASE_TYPE_NODE ();        /* TypeNode structure */</span>
 438   node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
 439   node = g_malloc0 (node_size);
<span class="line-modified"> 440   if (!pnode)               /* offset fundamental types */</span>
 441     {
 442       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
 443       static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
 444       type = ftype;
 445     }
 446   else
 447     type = (GType) node;
 448 
 449   g_assert ((type &amp; TYPE_ID_MASK) == 0);
 450 
 451   node-&gt;n_supers = n_supers;
 452   if (!pnode)
 453     {
 454       node-&gt;supers[0] = type;
 455       node-&gt;supers[1] = 0;
 456 
 457       node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
 458       node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
 459 
 460       if (NODE_IS_IFACE (node))
<span class="line-modified"> 461   {</span>
 462           IFACE_NODE_N_PREREQUISITES (node) = 0;
<span class="line-modified"> 463     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified"> 464   }</span>
 465       else
<span class="line-modified"> 466   _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
 467     }
 468   else
 469     {
 470       node-&gt;supers[0] = type;
 471       memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
 472 
 473       node-&gt;is_classed = pnode-&gt;is_classed;
 474       node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
 475 
 476       if (NODE_IS_IFACE (node))
<span class="line-modified"> 477   {</span>
<span class="line-modified"> 478     IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="line-modified"> 479     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified"> 480   }</span>
 481       else
<span class="line-added"> 482   {</span>
<span class="line-added"> 483     guint j;</span>
<span class="line-added"> 484     IFaceEntries *entries;</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486     entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="line-added"> 487             IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-added"> 488             0);</span>
<span class="line-added"> 489     if (entries)</span>
<span class="line-added"> 490       {</span>
<span class="line-added"> 491         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
 492     {
<span class="line-modified"> 493       entries-&gt;entry[j].vtable = NULL;</span>
<span class="line-modified"> 494       entries-&gt;entry[j].init_state = UNINITIALIZED;</span>














 495     }
<span class="line-added"> 496         _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="line-added"> 497               entries);</span>
<span class="line-added"> 498       }</span>
<span class="line-added"> 499   }</span>
 500 
 501       i = pnode-&gt;n_children++;
 502       pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
 503       pnode-&gt;children[i] = type;
 504     }
 505 
 506   TRACE(GOBJECT_TYPE_NEW(name, node-&gt;supers[1], type));
 507 
 508   node-&gt;plugin = plugin;
 509   node-&gt;n_children = 0;
 510   node-&gt;children = NULL;
 511   node-&gt;data = NULL;
 512   node-&gt;qname = g_quark_from_string (name);
 513   node-&gt;global_gdata = NULL;
 514   g_hash_table_insert (static_type_nodes_ht,
<span class="line-modified"> 515            (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="line-modified"> 516            (gpointer) type);</span>
 517 
 518   g_atomic_int_inc ((gint *)&amp;type_registration_serial);
 519 
 520   return node;
 521 }
 522 
 523 static inline GTypeFundamentalInfo*
 524 type_node_fundamental_info_I (TypeNode *node)
 525 {
 526   GType ftype = NODE_FUNDAMENTAL_TYPE (node);
 527 
 528   if (ftype != NODE_TYPE (node))
 529     node = lookup_type_node_I (ftype);
 530 
 531   return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
 532 }
 533 
 534 static TypeNode*
 535 type_node_fundamental_new_W (GType                 ftype,
<span class="line-modified"> 536            const gchar          *name,</span>
<span class="line-modified"> 537            GTypeFundamentalFlags type_flags)</span>
 538 {
 539   GTypeFundamentalInfo *finfo;
 540   TypeNode *node;
 541 
 542   g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
 543   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX);
 544 
 545   if (ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
 546     static_fundamental_next++;
 547 
 548   type_flags &amp;= TYPE_FUNDAMENTAL_FLAG_MASK;
 549 
 550   node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
 551 
 552   finfo = type_node_fundamental_info_I (node);
 553   finfo-&gt;type_flags = type_flags;
 554 
 555   return node;
 556 }
 557 
 558 static TypeNode*
 559 type_node_new_W (TypeNode    *pnode,
<span class="line-modified"> 560      const gchar *name,</span>
<span class="line-modified"> 561      GTypePlugin *plugin)</span>
 562 
 563 {
 564   g_assert (pnode);
 565   g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
 566   g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
 567 
 568   return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
 569 }
 570 
 571 static inline IFaceEntry*
 572 lookup_iface_entry_I (volatile IFaceEntries *entries,
<span class="line-modified"> 573           TypeNode *iface_node)</span>
 574 {
 575   guint8 *offsets;
 576   guint offset_index;
 577   IFaceEntry *check;
 578   int index;
 579   IFaceEntry *entry;
 580 
 581   if (entries == NULL)
 582     return NULL;
 583 
 584   G_ATOMIC_ARRAY_DO_TRANSACTION
 585     (&amp;iface_node-&gt;_prot.offsets, guint8,
 586 
 587      entry = NULL;
 588      offsets = transaction_data;
 589      offset_index = entries-&gt;offset_index;
 590      if (offsets != NULL &amp;&amp;
<span class="line-modified"> 591    offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>



 592        {
<span class="line-modified"> 593    index = offsets[offset_index];</span>
<span class="line-modified"> 594    if (index &gt; 0)</span>
<span class="line-modified"> 595      {</span>
<span class="line-modified"> 596        /* zero means unset, subtract one to get real index */</span>
<span class="line-modified"> 597        index -= 1;</span>
<span class="line-modified"> 598 </span>
<span class="line-modified"> 599        if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="line-modified"> 600          {</span>
<span class="line-modified"> 601      check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="line-modified"> 602      if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="line-added"> 603        entry = check;</span>
<span class="line-added"> 604          }</span>
<span class="line-added"> 605      }</span>
 606        }
 607      );
 608 
 609  return entry;
 610 }
 611 
 612 static inline IFaceEntry*
 613 type_lookup_iface_entry_L (TypeNode *node,
<span class="line-modified"> 614          TypeNode *iface_node)</span>
 615 {
 616   if (!NODE_IS_IFACE (iface_node))
 617     return NULL;
 618 
 619   return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
<span class="line-modified"> 620              iface_node);</span>
 621 }
 622 
 623 
 624 static inline gboolean
 625 type_lookup_iface_vtable_I (TypeNode *node,
<span class="line-modified"> 626           TypeNode *iface_node,</span>
<span class="line-modified"> 627           gpointer *vtable_ptr)</span>
 628 {
 629   IFaceEntry *entry;
 630   gboolean res;
 631 
 632   if (!NODE_IS_IFACE (iface_node))
 633     {
 634       if (vtable_ptr)
<span class="line-modified"> 635   *vtable_ptr = NULL;</span>
 636       return FALSE;
 637     }
 638 
 639   G_ATOMIC_ARRAY_DO_TRANSACTION
 640     (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
 641 
 642      entry = lookup_iface_entry_I (transaction_data, iface_node);
 643      res = entry != NULL;
 644      if (vtable_ptr)
 645        {
<span class="line-modified"> 646    if (entry)</span>
<span class="line-modified"> 647      *vtable_ptr = entry-&gt;vtable;</span>
<span class="line-modified"> 648    else</span>
<span class="line-modified"> 649      *vtable_ptr = NULL;</span>
 650        }
 651      );
 652 
 653   return res;
 654 }
 655 
 656 static inline gboolean
 657 type_lookup_prerequisite_L (TypeNode *iface,
<span class="line-modified"> 658           GType     prerequisite_type)</span>
 659 {
 660   if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
 661     {
 662       GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
 663       guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
 664 
 665       do
<span class="line-modified"> 666   {</span>
<span class="line-modified"> 667     guint i;</span>
<span class="line-modified"> 668     GType *check;</span>
 669 
<span class="line-modified"> 670     i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="line-modified"> 671     check = prerequisites + i;</span>
<span class="line-modified"> 672     if (prerequisite_type == *check)</span>
<span class="line-modified"> 673       return TRUE;</span>
<span class="line-modified"> 674     else if (prerequisite_type &gt; *check)</span>
<span class="line-modified"> 675       {</span>
<span class="line-modified"> 676         n_prerequisites -= i;</span>
<span class="line-modified"> 677         prerequisites = check;</span>
<span class="line-modified"> 678       }</span>
<span class="line-modified"> 679     else /* if (prerequisite_type &lt; *check) */</span>
<span class="line-modified"> 680       n_prerequisites = i - 1;</span>
<span class="line-modified"> 681   }</span>
 682       while (n_prerequisites);
 683     }
 684   return FALSE;
 685 }
 686 
 687 static const gchar*
 688 type_descriptive_name_I (GType type)
 689 {
 690   if (type)
 691     {
 692       TypeNode *node = lookup_type_node_I (type);
 693 
 694       return node ? NODE_NAME (node) : &quot;&lt;unknown&gt;&quot;;
 695     }
 696   else
 697     return &quot;&lt;invalid&gt;&quot;;
 698 }
 699 
 700 
 701 /* --- type consistency checks --- */
 702 static gboolean
 703 check_plugin_U (GTypePlugin *plugin,
<span class="line-modified"> 704     gboolean     need_complete_type_info,</span>
<span class="line-modified"> 705     gboolean     need_complete_interface_info,</span>
<span class="line-modified"> 706     const gchar *type_name)</span>
 707 {
 708   /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
 709    */
 710   if (!plugin)
 711     {
 712       g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
<span class="line-modified"> 713      type_name);</span>
 714       return FALSE;
 715     }
 716   if (!G_IS_TYPE_PLUGIN (plugin))
 717     {
 718       g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
<span class="line-modified"> 719      plugin, type_name);</span>
 720       return FALSE;
 721     }
 722   if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
 723     {
 724       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
<span class="line-modified"> 725      type_name);</span>
 726       return FALSE;
 727     }
 728   if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
 729     {
 730       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
<span class="line-modified"> 731      type_name);</span>
 732       return FALSE;
 733     }
 734   return TRUE;
 735 }
 736 
 737 static gboolean
 738 check_type_name_I (const gchar *type_name)
 739 {
 740   static const gchar extra_chars[] = &quot;-_+&quot;;
 741   const gchar *p = type_name;
 742   gboolean name_valid;
 743 
 744   if (!type_name[0] || !type_name[1] || !type_name[2])
 745     {
 746       g_warning (&quot;type name &#39;%s&#39; is too short&quot;, type_name);
 747       return FALSE;
 748     }
 749   /* check the first letter */
 750   name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
 751   for (p = type_name + 1; *p; p++)
 752     name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
<span class="line-modified"> 753        (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="line-modified"> 754        (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="line-modified"> 755        strchr (extra_chars, p[0]));</span>
 756   if (!name_valid)
 757     {
 758       g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
 759       return FALSE;
 760     }
 761   if (g_type_from_name (type_name))
 762     {
 763       g_warning (&quot;cannot register existing type &#39;%s&#39;&quot;, type_name);
 764       return FALSE;
 765     }
 766 
 767   return TRUE;
 768 }
 769 
 770 static gboolean
 771 check_derivation_I (GType        parent_type,
<span class="line-modified"> 772         const gchar *type_name)</span>
 773 {
 774   TypeNode *pnode;
 775   GTypeFundamentalInfo* finfo;
 776 
 777   pnode = lookup_type_node_I (parent_type);
 778   if (!pnode)
 779     {
 780       g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 781      type_name,</span>
<span class="line-modified"> 782      type_descriptive_name_I (parent_type));</span>
 783       return FALSE;
 784     }
 785   finfo = type_node_fundamental_info_I (pnode);
 786   /* ensure flat derivability */
 787   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
 788     {
 789       g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 790      type_name,</span>
<span class="line-modified"> 791      NODE_NAME (pnode));</span>
 792       return FALSE;
 793     }
 794   /* ensure deep derivability */
 795   if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
 796       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
 797     {
 798       g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
<span class="line-modified"> 799      type_name,</span>
<span class="line-modified"> 800      NODE_NAME (pnode));</span>
 801       return FALSE;
 802     }
 803 
 804   return TRUE;
 805 }
 806 
 807 static gboolean
 808 check_collect_format_I (const gchar *collect_format)
 809 {
 810   const gchar *p = collect_format;
 811   gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
<span class="line-modified"> 812          G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="line-modified"> 813          G_VALUE_COLLECT_POINTER, 0 };</span>
 814 
 815   while (*p)
 816     if (!strchr (valid_format, *p++))
 817       return FALSE;
 818   return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
 819 }
 820 
 821 static gboolean
 822 check_value_table_I (const gchar           *type_name,
<span class="line-modified"> 823          const GTypeValueTable *value_table)</span>
 824 {
 825   if (!value_table)
 826     return FALSE;
 827   else if (value_table-&gt;value_init == NULL)
 828     {
 829       if (value_table-&gt;value_free || value_table-&gt;value_copy ||
<span class="line-modified"> 830     value_table-&gt;value_peek_pointer ||</span>
<span class="line-modified"> 831     value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="line-modified"> 832     value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="line-modified"> 833   g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 834        type_name);</span>
 835       return FALSE;
 836     }
 837   else /* value_table-&gt;value_init != NULL */
 838     {
 839       if (!value_table-&gt;value_free)
<span class="line-modified"> 840   {</span>
<span class="line-modified"> 841     /* +++ optional +++</span>
<span class="line-modified"> 842      * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified"> 843      * return FALSE;</span>
<span class="line-modified"> 844      */</span>
<span class="line-modified"> 845   }</span>
 846       if (!value_table-&gt;value_copy)
<span class="line-modified"> 847   {</span>
<span class="line-modified"> 848     g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified"> 849     return FALSE;</span>
<span class="line-modified"> 850   }</span>
 851       if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
<span class="line-modified"> 852     (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="line-modified"> 853   {</span>
<span class="line-modified"> 854     g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 855          type_name);</span>
<span class="line-modified"> 856     return FALSE;</span>
<span class="line-modified"> 857   }</span>
 858       if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
<span class="line-modified"> 859   {</span>
<span class="line-modified"> 860     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified"> 861          &quot;collect_format&quot;,</span>
<span class="line-modified"> 862          type_name);</span>
<span class="line-modified"> 863     return FALSE;</span>
<span class="line-modified"> 864   }</span>
 865       if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
<span class="line-modified"> 866     (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="line-modified"> 867   {</span>
<span class="line-modified"> 868     g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 869          type_name);</span>
<span class="line-modified"> 870     return FALSE;</span>
<span class="line-modified"> 871   }</span>
 872       if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
<span class="line-modified"> 873   {</span>
<span class="line-modified"> 874     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified"> 875          &quot;lcopy_format&quot;,</span>
<span class="line-modified"> 876          type_name);</span>
<span class="line-modified"> 877     return FALSE;</span>
<span class="line-modified"> 878   }</span>
 879     }
 880   return TRUE;
 881 }
 882 
 883 static gboolean
 884 check_type_info_I (TypeNode        *pnode,
<span class="line-modified"> 885        GType            ftype,</span>
<span class="line-modified"> 886        const gchar     *type_name,</span>
<span class="line-modified"> 887        const GTypeInfo *info)</span>
 888 {
 889   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
 890   gboolean is_interface = ftype == G_TYPE_INTERFACE;
 891 
 892   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
 893 
 894   /* check instance members */
 895   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
 896       (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
 897     {
 898       if (pnode)
<span class="line-modified"> 899   g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 900        type_name,</span>
<span class="line-modified"> 901        NODE_NAME (pnode));</span>
 902       else
<span class="line-modified"> 903   g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="line-modified"> 904        type_name);</span>
 905       return FALSE;
 906     }
 907   /* check class &amp; interface members */
 908   if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
 909       (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
 910        info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
 911     {
 912       if (pnode)
<span class="line-modified"> 913   g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified"> 914        type_name,</span>
 915                    NODE_NAME (pnode));
 916       else
<span class="line-modified"> 917   g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="line-modified"> 918        type_name);</span>
 919       return FALSE;
 920     }
 921   /* check interface size */
 922   if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
 923     {
 924       g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
<span class="line-modified"> 925      type_name);</span>
 926       return FALSE;
 927     }
 928   /* check class size */
 929   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
 930     {
 931       if (info-&gt;class_size &lt; sizeof (GTypeClass))
<span class="line-modified"> 932   {</span>
<span class="line-modified"> 933     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="line-modified"> 934          type_name);</span>
<span class="line-modified"> 935     return FALSE;</span>
<span class="line-modified"> 936   }</span>
 937       if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
<span class="line-modified"> 938   {</span>
<span class="line-modified"> 939     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified"> 940          &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="line-modified"> 941          type_name,</span>
<span class="line-modified"> 942          NODE_NAME (pnode));</span>
<span class="line-modified"> 943     return FALSE;</span>
<span class="line-modified"> 944   }</span>
 945     }
 946   /* check instance size */
 947   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
 948     {
 949       if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
<span class="line-modified"> 950   {</span>
<span class="line-modified"> 951     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="line-modified"> 952          type_name);</span>
<span class="line-modified"> 953     return FALSE;</span>
<span class="line-modified"> 954   }</span>
 955       if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
<span class="line-modified"> 956   {</span>
<span class="line-modified"> 957     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified"> 958          &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="line-modified"> 959          type_name,</span>
<span class="line-modified"> 960          NODE_NAME (pnode));</span>
<span class="line-modified"> 961     return FALSE;</span>
<span class="line-modified"> 962   }</span>
 963     }
 964 
 965   return TRUE;
 966 }
 967 
 968 static TypeNode*
 969 find_conforming_child_type_L (TypeNode *pnode,
<span class="line-modified"> 970             TypeNode *iface)</span>
 971 {
 972   TypeNode *node = NULL;
 973   guint i;
 974 
 975   if (type_lookup_iface_entry_L (pnode, iface))
 976     return pnode;
 977 
 978   for (i = 0; i &lt; pnode-&gt;n_children &amp;&amp; !node; i++)
 979     node = find_conforming_child_type_L (lookup_type_node_I (pnode-&gt;children[i]), iface);
 980 
 981   return node;
 982 }
 983 
 984 static gboolean
 985 check_add_interface_L (GType instance_type,
<span class="line-modified"> 986            GType iface_type)</span>
 987 {
 988   TypeNode *node = lookup_type_node_I (instance_type);
 989   TypeNode *iface = lookup_type_node_I (iface_type);
 990   IFaceEntry *entry;
 991   TypeNode *tnode;
 992   GType *prerequisites;
 993   guint i;
 994 
 995 
 996   if (!node || !node-&gt;is_instantiatable)
 997     {
 998       g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified"> 999      type_descriptive_name_I (instance_type));</span>
1000       return FALSE;
1001     }
1002   if (!iface || !NODE_IS_IFACE (iface))
1003     {
1004       g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
<span class="line-modified">1005      type_descriptive_name_I (iface_type),</span>
<span class="line-modified">1006      NODE_NAME (node));</span>
1007       return FALSE;
1008     }
1009   if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
1010     {
1011       g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
1012                  NODE_NAME (iface), NODE_NAME (node));
1013       return FALSE;
1014     }
1015   tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
1016   if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
1017     {
1018       /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
1019       g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
<span class="line-modified">1020      NODE_NAME (iface),</span>
<span class="line-modified">1021      NODE_NAME (node),</span>
<span class="line-modified">1022      NODE_NAME (tnode));</span>
1023       return FALSE;
1024     }
1025   /* allow overriding of interface type introduced for parent type */
1026   entry = type_lookup_iface_entry_L (node, iface);
1027   if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
1028     {
1029       /* ok, we do conform to this interface already, but the interface vtable was not
1030        * yet intialized, and we just conform to the interface because it got added to
1031        * one of our parents. so we allow overriding of holder info here.
1032        */
1033       return TRUE;
1034     }
1035   /* check whether one of our children already conforms (or whether the interface
1036    * got added to this node already)
1037    */
1038   tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
1039   if (tnode)
1040     {
1041       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
<span class="line-modified">1042      NODE_NAME (iface),</span>
<span class="line-modified">1043      NODE_NAME (node),</span>
<span class="line-modified">1044      NODE_NAME (tnode));</span>
1045       return FALSE;
1046     }
1047   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1048   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1049     {
1050       tnode = lookup_type_node_I (prerequisites[i]);
1051       if (!type_node_is_a_L (node, tnode))
<span class="line-modified">1052   {</span>
<span class="line-modified">1053     g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">1054          NODE_NAME (iface),</span>
<span class="line-modified">1055          NODE_NAME (node),</span>
<span class="line-modified">1056          NODE_NAME (tnode));</span>
<span class="line-modified">1057     return FALSE;</span>
<span class="line-modified">1058   }</span>
1059     }
1060   return TRUE;
1061 }
1062 
1063 static gboolean
1064 check_interface_info_I (TypeNode             *iface,
<span class="line-modified">1065       GType                 instance_type,</span>
<span class="line-modified">1066       const GInterfaceInfo *info)</span>
1067 {
1068   if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
1069     {
1070       g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
<span class="line-modified">1071      NODE_NAME (iface),</span>
<span class="line-modified">1072      type_descriptive_name_I (instance_type));</span>
1073       return FALSE;
1074     }
1075 
1076   return TRUE;
1077 }
1078 
1079 /* --- type info (type node data) --- */
1080 static void
1081 type_data_make_W (TypeNode              *node,
<span class="line-modified">1082       const GTypeInfo       *info,</span>
<span class="line-modified">1083       const GTypeValueTable *value_table)</span>
1084 {
1085   TypeData *data;
1086   GTypeValueTable *vtable = NULL;
1087   guint vtable_size = 0;
1088 
1089   g_assert (node-&gt;data == NULL &amp;&amp; info != NULL);
1090 
1091   if (!value_table)
1092     {
1093       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1094 
1095       if (pnode)
<span class="line-modified">1096   vtable = pnode-&gt;data-&gt;common.value_table;</span>
1097       else
<span class="line-modified">1098   {</span>
<span class="line-modified">1099     static const GTypeValueTable zero_vtable = { NULL, };</span>
1100 
<span class="line-modified">1101     value_table = &amp;zero_vtable;</span>
<span class="line-modified">1102   }</span>
1103     }
1104   if (value_table)
1105     {
1106       /* need to setup vtable_size since we have to allocate it with data in one chunk */
1107       vtable_size = sizeof (GTypeValueTable);
1108       if (value_table-&gt;collect_format)
<span class="line-modified">1109   vtable_size += strlen (value_table-&gt;collect_format);</span>
1110       if (value_table-&gt;lcopy_format)
<span class="line-modified">1111   vtable_size += strlen (value_table-&gt;lcopy_format);</span>
1112       vtable_size += 2;
1113     }
1114 
1115   if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
1116     {
1117       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1118 
1119       data = g_malloc0 (sizeof (InstanceData) + vtable_size);
1120 #ifdef GSTREAMER_LITE
1121       if (data == NULL)
1122           return;
1123 #endif // GSTREAMER_LITE
1124       if (vtable_size)
<span class="line-modified">1125   vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
1126       data-&gt;instance.class_size = info-&gt;class_size;
1127       data-&gt;instance.class_init_base = info-&gt;base_init;
1128       data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
1129       data-&gt;instance.class_init = info-&gt;class_init;
1130       data-&gt;instance.class_finalize = info-&gt;class_finalize;
1131       data-&gt;instance.class_data = info-&gt;class_data;
1132       data-&gt;instance.class = NULL;
1133       data-&gt;instance.init_state = UNINITIALIZED;
1134       data-&gt;instance.instance_size = info-&gt;instance_size;
1135       /* We&#39;ll set the final value for data-&gt;instance.private size
1136        * after the parent class has been initialized
1137        */
1138       data-&gt;instance.private_size = 0;
1139       data-&gt;instance.class_private_size = 0;
1140       if (pnode)
1141         data-&gt;instance.class_private_size = pnode-&gt;data-&gt;instance.class_private_size;
1142       data-&gt;instance.n_preallocs = MIN (info-&gt;n_preallocs, 1024);
1143       data-&gt;instance.instance_init = info-&gt;instance_init;
1144     }
1145   else if (node-&gt;is_classed) /* only classed */
1146     {
1147       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1148 
1149       data = g_malloc0 (sizeof (ClassData) + vtable_size);
1150       if (vtable_size)
<span class="line-modified">1151   vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
1152       data-&gt;class.class_size = info-&gt;class_size;
1153       data-&gt;class.class_init_base = info-&gt;base_init;
1154       data-&gt;class.class_finalize_base = info-&gt;base_finalize;
1155       data-&gt;class.class_init = info-&gt;class_init;
1156       data-&gt;class.class_finalize = info-&gt;class_finalize;
1157       data-&gt;class.class_data = info-&gt;class_data;
1158       data-&gt;class.class = NULL;
1159       data-&gt;class.class_private_size = 0;
1160       if (pnode)
1161         data-&gt;class.class_private_size = pnode-&gt;data-&gt;class.class_private_size;
1162       data-&gt;class.init_state = UNINITIALIZED;
1163     }
1164   else if (NODE_IS_IFACE (node))
1165     {
1166       data = g_malloc0 (sizeof (IFaceData) + vtable_size);
1167       if (vtable_size)
<span class="line-modified">1168   vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
1169       data-&gt;iface.vtable_size = info-&gt;class_size;
1170       data-&gt;iface.vtable_init_base = info-&gt;base_init;
1171       data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
1172       data-&gt;iface.dflt_init = info-&gt;class_init;
1173       data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
1174       data-&gt;iface.dflt_data = info-&gt;class_data;
1175       data-&gt;iface.dflt_vtable = NULL;
1176     }
1177   else if (NODE_IS_BOXED (node))
1178     {
1179       data = g_malloc0 (sizeof (BoxedData) + vtable_size);
1180       if (vtable_size)
<span class="line-modified">1181   vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
1182     }
1183   else
1184     {
1185       data = g_malloc0 (sizeof (CommonData) + vtable_size);
1186       if (vtable_size)
<span class="line-modified">1187   vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
1188     }
1189 
1190   node-&gt;data = data;
1191 
1192   if (vtable_size)
1193     {
1194       gchar *p;
1195 
1196       /* we allocate the vtable and its strings together with the type data, so
1197        * children can take over their parent&#39;s vtable pointer, and we don&#39;t
1198        * need to worry freeing it or not when the child data is destroyed
1199        */
1200       *vtable = *value_table;
1201       p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
1202       p[0] = 0;
1203       vtable-&gt;collect_format = p;
1204       if (value_table-&gt;collect_format)
<span class="line-modified">1205   {</span>
<span class="line-modified">1206     strcat (p, value_table-&gt;collect_format);</span>
<span class="line-modified">1207     p += strlen (value_table-&gt;collect_format);</span>
<span class="line-modified">1208   }</span>
1209       p++;
1210       p[0] = 0;
1211       vtable-&gt;lcopy_format = p;
1212       if (value_table-&gt;lcopy_format)
<span class="line-modified">1213   strcat  (p, value_table-&gt;lcopy_format);</span>
1214     }
1215   node-&gt;data-&gt;common.value_table = vtable;
1216   node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
<span class="line-modified">1217          !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="line-modified">1218            GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
1219 
1220   g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
1221 
1222   g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
1223 }
1224 
1225 static inline void
1226 type_data_ref_Wm (TypeNode *node)
1227 {
1228   if (!node-&gt;data)
1229     {
1230       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1231       GTypeInfo tmp_info;
1232       GTypeValueTable tmp_value_table;
1233 
1234       g_assert (node-&gt;plugin != NULL);
1235 
1236       if (pnode)
<span class="line-modified">1237   {</span>
<span class="line-modified">1238     type_data_ref_Wm (pnode);</span>
<span class="line-modified">1239     if (node-&gt;data)</span>
<span class="line-modified">1240       INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="line-modified">1241   }</span>
1242 
1243       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1244       memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
1245 
1246       G_WRITE_UNLOCK (&amp;type_rw_lock);
1247       g_type_plugin_use (node-&gt;plugin);
1248       g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
1249       G_WRITE_LOCK (&amp;type_rw_lock);
1250       if (node-&gt;data)
<span class="line-modified">1251   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
1252 
1253       check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
1254       type_data_make_W (node, &amp;tmp_info,
<span class="line-modified">1255       check_value_table_I (NODE_NAME (node),</span>
<span class="line-modified">1256                &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
1257     }
1258   else
1259     {
1260       g_assert (NODE_REFCOUNT (node) &gt; 0);
1261 
1262       g_atomic_int_inc ((int *) &amp;node-&gt;ref_count);
1263     }
1264 }
1265 
1266 static inline gboolean
1267 type_data_ref_U (TypeNode *node)
1268 {
1269   guint current;
1270 
1271   do {
1272     current = NODE_REFCOUNT (node);
1273 
1274     if (current &lt; 1)
1275       return FALSE;
1276   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current + 1));
1277 
1278   return TRUE;
1279 }
1280 
1281 static gboolean
1282 iface_node_has_available_offset_L (TypeNode *iface_node,
<span class="line-modified">1283            int offset,</span>
<span class="line-modified">1284            int for_index)</span>
1285 {
1286   guint8 *offsets;
1287 
1288   offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1289   if (offsets == NULL)
1290     return TRUE;
1291 
1292   if (G_ATOMIC_ARRAY_DATA_SIZE (offsets) &lt;= offset)
1293     return TRUE;
1294 
1295   if (offsets[offset] == 0 ||
1296       offsets[offset] == for_index+1)
1297     return TRUE;
1298 
1299   return FALSE;
1300 }
1301 
1302 static int
1303 find_free_iface_offset_L (IFaceEntries *entries)
1304 {
1305   IFaceEntry *entry;
1306   TypeNode *iface_node;
1307   int offset;
1308   int i;
1309   int n_entries;
1310 
1311   n_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1312   offset = -1;
1313   do
1314     {
1315       offset++;
1316       for (i = 0; i &lt; n_entries; i++)
<span class="line-modified">1317   {</span>
<span class="line-modified">1318     entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">1319     iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
1320 
<span class="line-modified">1321     if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="line-modified">1322       break;</span>
<span class="line-modified">1323   }</span>
1324     }
1325   while (i != n_entries);
1326 
1327   return offset;
1328 }
1329 
1330 static void
1331 iface_node_set_offset_L (TypeNode *iface_node,
<span class="line-modified">1332        int offset,</span>
<span class="line-modified">1333        int index)</span>
1334 {
1335   guint8 *offsets, *old_offsets;
1336   int new_size, old_size;
1337   int i;
1338 
1339   old_offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1340   if (old_offsets == NULL)
1341     old_size = 0;
1342   else
1343     {
1344       old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
1345       if (offset &lt; old_size &amp;&amp;
<span class="line-modified">1346     old_offsets[offset] == index + 1)</span>
<span class="line-modified">1347   return; /* Already set to this index, return */</span>
1348     }
1349   new_size = MAX (old_size, offset + 1);
1350 
1351   offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
<span class="line-modified">1352           0, new_size - old_size);</span>
1353 
1354   /* Mark new area as unused */
1355   for (i = old_size; i &lt; new_size; i++)
1356     offsets[i] = 0;
1357 
1358   offsets[offset] = index + 1;
1359 
1360   _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
1361 }
1362 
1363 static void
1364 type_node_add_iface_entry_W (TypeNode   *node,
<span class="line-modified">1365            GType       iface_type,</span>
1366                              IFaceEntry *parent_entry)
1367 {
1368   IFaceEntries *entries;
1369   IFaceEntry *entry;
1370   TypeNode *iface_node;
1371   guint i, j;
1372   int num_entries;
1373 
1374   g_assert (node-&gt;is_instantiatable);
1375 
1376   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
1377   if (entries != NULL)
1378     {
1379       num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1380 
1381       g_assert (num_entries &lt; MAX_N_INTERFACES);
1382 
1383       for (i = 0; i &lt; num_entries; i++)
<span class="line-modified">1384   {</span>
<span class="line-modified">1385     entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">1386     if (entry-&gt;iface_type == iface_type)</span>
<span class="line-modified">1387       {</span>
<span class="line-modified">1388         /* this can happen in two cases:</span>
<span class="line-modified">1389          * - our parent type already conformed to iface_type and node</span>
<span class="line-modified">1390          *   got its own holder info. here, our children already have</span>
<span class="line-modified">1391          *   entries and NULL vtables, since this will only work for</span>
<span class="line-modified">1392          *   uninitialized classes.</span>
<span class="line-modified">1393          * - an interface type is added to an ancestor after it was</span>
<span class="line-modified">1394          *   added to a child type.</span>
<span class="line-modified">1395          */</span>
<span class="line-modified">1396         if (!parent_entry)</span>
<span class="line-modified">1397     g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="line-modified">1398         else</span>
<span class="line-modified">1399     {</span>
<span class="line-modified">1400       /* sick, interface is added to ancestor *after* child type;</span>
<span class="line-modified">1401        * nothing todo, the entry and our children were already setup correctly</span>
<span class="line-modified">1402        */</span>



1403     }
<span class="line-added">1404         return;</span>
<span class="line-added">1405       }</span>
<span class="line-added">1406   }</span>
1407     }
1408 
1409   entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
<span class="line-modified">1410           IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-modified">1411           sizeof (IFaceEntry));</span>
1412   num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1413   i = num_entries - 1;
1414   if (i == 0)
1415     entries-&gt;offset_index = 0;
1416   entries-&gt;entry[i].iface_type = iface_type;
1417   entries-&gt;entry[i].vtable = NULL;
1418   entries-&gt;entry[i].init_state = UNINITIALIZED;
1419 
1420   if (parent_entry)
1421     {
1422       if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.init_state &gt;= BASE_IFACE_INIT)
1423         {
1424           entries-&gt;entry[i].init_state = INITIALIZED;
1425           entries-&gt;entry[i].vtable = parent_entry-&gt;vtable;
1426         }
1427     }
1428 
1429   /* Update offsets in iface */
1430   iface_node = lookup_type_node_I (iface_type);
1431 
1432   if (iface_node_has_available_offset_L (iface_node,
<span class="line-modified">1433            entries-&gt;offset_index,</span>
<span class="line-modified">1434            i))</span>
1435     {
1436       iface_node_set_offset_L (iface_node,
<span class="line-modified">1437              entries-&gt;offset_index, i);</span>
1438     }
1439   else
1440    {
1441       entries-&gt;offset_index =
<span class="line-modified">1442   find_free_iface_offset_L (entries);</span>
1443       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
<span class="line-modified">1444   {</span>
<span class="line-modified">1445     entry = &amp;entries-&gt;entry[j];</span>
<span class="line-modified">1446     iface_node =</span>
<span class="line-modified">1447       lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="line-modified">1448     iface_node_set_offset_L (iface_node,</span>
<span class="line-modified">1449            entries-&gt;offset_index, j);</span>
<span class="line-modified">1450   }</span>
1451     }
1452 
1453   _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
1454 
1455   if (parent_entry)
1456     {
1457       for (i = 0; i &lt; node-&gt;n_children; i++)
1458         type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), iface_type, &amp;entries-&gt;entry[i]);
1459     }
1460 }
1461 
1462 static void
1463 type_add_interface_Wm (TypeNode             *node,
1464                        TypeNode             *iface,
1465                        const GInterfaceInfo *info,
1466                        GTypePlugin          *plugin)
1467 {
1468   IFaceHolder *iholder = g_new0 (IFaceHolder, 1);
1469   IFaceEntry *entry;
1470   guint i;
</pre>
<hr />
<pre>
1485    */
1486   if (node-&gt;data)
1487     {
1488       InitState class_state = node-&gt;data-&gt;class.init_state;
1489 
1490       if (class_state &gt;= BASE_IFACE_INIT)
1491         type_iface_vtable_base_init_Wm (iface, node);
1492 
1493       if (class_state &gt;= IFACE_INIT)
1494         type_iface_vtable_iface_init_Wm (iface, node);
1495     }
1496 
1497   /* create iface entries for children of this type */
1498   entry = type_lookup_iface_entry_L (node, iface);
1499   for (i = 0; i &lt; node-&gt;n_children; i++)
1500     type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
1501 }
1502 
1503 static void
1504 type_iface_add_prerequisite_W (TypeNode *iface,
<span class="line-modified">1505              TypeNode *prerequisite_node)</span>
1506 {
1507   GType prerequisite_type = NODE_TYPE (prerequisite_node);
1508   GType *prerequisites, *dependants;
1509   guint n_dependants, i;
1510 
1511   g_assert (NODE_IS_IFACE (iface) &amp;&amp;
<span class="line-modified">1512       IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="line-modified">1513       (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
1514 
1515   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1516   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1517     if (prerequisites[i] == prerequisite_type)
<span class="line-modified">1518       return;     /* we already have that prerequisiste */</span>
1519     else if (prerequisites[i] &gt; prerequisite_type)
1520       break;
1521   IFACE_NODE_N_PREREQUISITES (iface) += 1;
1522   IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
<span class="line-modified">1523                 IFACE_NODE_PREREQUISITES (iface),</span>
<span class="line-modified">1524                 IFACE_NODE_N_PREREQUISITES (iface));</span>
1525   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1526   memmove (prerequisites + i + 1, prerequisites + i,
1527            sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
1528   prerequisites[i] = prerequisite_type;
1529 
1530   /* we want to get notified when prerequisites get added to prerequisite_node */
1531   if (NODE_IS_IFACE (prerequisite_node))
1532     {
1533       dependants = iface_node_get_dependants_array_L (prerequisite_node);
1534       n_dependants = dependants ? dependants[0] : 0;
1535       n_dependants += 1;
1536       dependants = g_renew (GType, dependants, n_dependants + 1);
1537       dependants[n_dependants] = NODE_TYPE (iface);
1538       dependants[0] = n_dependants;
1539       iface_node_set_dependants_array_W (prerequisite_node, dependants);
1540     }
1541 
1542   /* we need to notify all dependants */
1543   dependants = iface_node_get_dependants_array_L (iface);
1544   n_dependants = dependants ? dependants[0] : 0;
1545   for (i = 1; i &lt;= n_dependants; i++)
1546     type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
1547 }
1548 
1549 /**
1550  * g_type_interface_add_prerequisite:
1551  * @interface_type: #GType value of an interface type
1552  * @prerequisite_type: #GType value of an interface or instantiatable type
1553  *
1554  * Adds @prerequisite_type to the list of prerequisites of @interface_type.
1555  * This means that any type implementing @interface_type must also implement
1556  * @prerequisite_type. Prerequisites can be thought of as an alternative to
1557  * interface derivation (which GType doesn&#39;t support). An interface can have
1558  * at most one instantiatable prerequisite type.
1559  */
1560 void
1561 g_type_interface_add_prerequisite (GType interface_type,
<span class="line-modified">1562            GType prerequisite_type)</span>
1563 {
1564   TypeNode *iface, *prerequisite_node;
1565   IFaceHolder *holders;
1566 
1567   g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
1568   g_return_if_fail (!g_type_is_a (interface_type, prerequisite_type));
1569   g_return_if_fail (!g_type_is_a (prerequisite_type, interface_type));
1570 
1571   iface = lookup_type_node_I (interface_type);
1572   prerequisite_node = lookup_type_node_I (prerequisite_type);
1573   if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
1574     {
1575       g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
<span class="line-modified">1576      type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1577      type_descriptive_name_I (prerequisite_type));</span>
1578       return;
1579     }
1580   G_WRITE_LOCK (&amp;type_rw_lock);
1581   holders = iface_node_get_holders_L (iface);
1582   if (holders)
1583     {
1584       G_WRITE_UNLOCK (&amp;type_rw_lock);
1585       g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
<span class="line-modified">1586      type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1587      type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1588      type_descriptive_name_I (holders-&gt;instance_type));</span>
1589       return;
1590     }
1591   if (prerequisite_node-&gt;is_instantiatable)
1592     {
1593       guint i;
1594 
1595       /* can have at most one publicly installable instantiatable prerequisite */
1596       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">1597   {</span>
<span class="line-modified">1598     TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
1599 
<span class="line-modified">1600     if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">1601       {</span>
<span class="line-modified">1602         G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">1603         g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">1604        type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1605        type_descriptive_name_I (interface_type),</span>
<span class="line-modified">1606        type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="line-modified">1607         return;</span>
<span class="line-modified">1608       }</span>
<span class="line-modified">1609   }</span>
1610 
1611       for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
<span class="line-modified">1612   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
1613       G_WRITE_UNLOCK (&amp;type_rw_lock);
1614     }
1615   else if (NODE_IS_IFACE (prerequisite_node))
1616     {
1617       GType *prerequisites;
1618       guint i;
1619 
1620       prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
1621       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
<span class="line-modified">1622   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
1623       type_iface_add_prerequisite_W (iface, prerequisite_node);
1624       G_WRITE_UNLOCK (&amp;type_rw_lock);
1625     }
1626   else
1627     {
1628       G_WRITE_UNLOCK (&amp;type_rw_lock);
1629       g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
<span class="line-modified">1630      type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">1631      type_descriptive_name_I (interface_type));</span>
1632     }
1633 }
1634 
1635 /**
1636  * g_type_interface_prerequisites:
1637  * @interface_type: an interface type
1638  * @n_prerequisites: (out) (optional): location to return the number
1639  *     of prerequisites, or %NULL
1640  *
1641  * Returns the prerequisites of an interfaces type.
1642  *
1643  * Since: 2.2
1644  *
1645  * Returns: (array length=n_prerequisites) (transfer full): a
1646  *     newly-allocated zero-terminated array of #GType containing
1647  *     the prerequisites of @interface_type
1648  */
1649 GType*
1650 g_type_interface_prerequisites (GType  interface_type,
<span class="line-modified">1651         guint *n_prerequisites)</span>
1652 {
1653   TypeNode *iface;
1654 
1655   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
1656 
1657   iface = lookup_type_node_I (interface_type);
1658   if (iface)
1659     {
1660       GType *types;
1661       TypeNode *inode = NULL;
1662       guint i, n = 0;
1663 
1664       G_READ_LOCK (&amp;type_rw_lock);
1665       types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
1666       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">1667   {</span>
<span class="line-modified">1668     GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="line-modified">1669     TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="line-modified">1670     if (node-&gt;is_instantiatable)</span>
1671             {
1672               if (!inode || type_node_is_a_L (node, inode))
<span class="line-modified">1673           inode = node;</span>
1674             }
<span class="line-modified">1675     else</span>
<span class="line-modified">1676       types[n++] = NODE_TYPE (node);</span>
<span class="line-modified">1677   }</span>
1678       if (inode)
<span class="line-modified">1679   types[n++] = NODE_TYPE (inode);</span>
1680 
1681       if (n_prerequisites)
<span class="line-modified">1682   *n_prerequisites = n;</span>
1683       G_READ_UNLOCK (&amp;type_rw_lock);
1684 
1685       return types;
1686     }
1687   else
1688     {
1689       if (n_prerequisites)
<span class="line-modified">1690   *n_prerequisites = 0;</span>
1691 
1692       return NULL;
1693     }
1694 }
1695 
1696 
1697 static IFaceHolder*
1698 type_iface_peek_holder_L (TypeNode *iface,
<span class="line-modified">1699         GType     instance_type)</span>
1700 {
1701   IFaceHolder *iholder;
1702 
1703   g_assert (NODE_IS_IFACE (iface));
1704 
1705   iholder = iface_node_get_holders_L (iface);
1706   while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
1707     iholder = iholder-&gt;next;
1708   return iholder;
1709 }
1710 
1711 static IFaceHolder*
1712 type_iface_retrieve_holder_info_Wm (TypeNode *iface,
<span class="line-modified">1713             GType     instance_type,</span>
<span class="line-modified">1714             gboolean  need_info)</span>
1715 {
1716   IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
1717 
1718   if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
1719     {
1720       GInterfaceInfo tmp_info;
1721 
1722       g_assert (iholder-&gt;plugin != NULL);
1723 
1724       type_data_ref_Wm (iface);
1725       if (iholder-&gt;info)
<span class="line-modified">1726   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
1727 
1728       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1729 
1730       G_WRITE_UNLOCK (&amp;type_rw_lock);
1731       g_type_plugin_use (iholder-&gt;plugin);
1732       g_type_plugin_complete_interface_info (iholder-&gt;plugin, instance_type, NODE_TYPE (iface), &amp;tmp_info);
1733       G_WRITE_LOCK (&amp;type_rw_lock);
1734       if (iholder-&gt;info)
1735         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iholder-&gt;plugin, NODE_NAME (iface));
1736 
1737       check_interface_info_I (iface, instance_type, &amp;tmp_info);
1738       iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
1739     }
1740 
<span class="line-modified">1741   return iholder; /* we don&#39;t modify write lock upon returning NULL */</span>
1742 }
1743 
1744 static void
1745 type_iface_blow_holder_info_Wm (TypeNode *iface,
<span class="line-modified">1746         GType     instance_type)</span>
1747 {
1748   IFaceHolder *iholder = iface_node_get_holders_L (iface);
1749 
1750   g_assert (NODE_IS_IFACE (iface));
1751 
1752 #ifdef GSTREAMER_LITE
1753   if (iholder == NULL)
1754       return;
1755 #endif // GSTREAMER_LITE
1756 
1757   while (iholder-&gt;instance_type != instance_type)
1758     iholder = iholder-&gt;next;
1759 
1760   if (iholder-&gt;info &amp;&amp; iholder-&gt;plugin)
1761     {
1762       g_free (iholder-&gt;info);
1763       iholder-&gt;info = NULL;
1764 
1765       G_WRITE_UNLOCK (&amp;type_rw_lock);
1766       g_type_plugin_unuse (iholder-&gt;plugin);
</pre>
<hr />
<pre>
1791  * function, but g_object_new() instead.
1792  *
1793  * Returns: an allocated and initialized instance, subject to further
1794  *     treatment by the fundamental type implementation
1795  */
1796 GTypeInstance*
1797 g_type_create_instance (GType type)
1798 {
1799   TypeNode *node;
1800   GTypeInstance *instance;
1801   GTypeClass *class;
1802   gchar *allocated;
1803   gint private_size;
1804   gint ivar_size;
1805   guint i;
1806 
1807   node = lookup_type_node_I (type);
1808   if (!node || !node-&gt;is_instantiatable)
1809     {
1810       g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1811      type_descriptive_name_I (type));</span>
1812     }
1813   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1814   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
1815     {
1816       g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1817      type_descriptive_name_I (type));</span>
1818     }
1819 
1820   class = g_type_class_ref (type);
1821 
1822   /* We allocate the &#39;private&#39; areas before the normal instance data, in
1823    * reverse order.  This allows the private area of a particular class
1824    * to always be at a constant relative address to the instance data.
1825    * If we stored the private data after the instance data this would
1826    * not be the case (since a subclass that added more instance
1827    * variables would push the private data further along).
1828    *
1829    * This presents problems for valgrindability, of course, so we do a
1830    * workaround for that case.  We identify the start of the object to
1831    * valgrind as an allocated block (so that pointers to objects show up
1832    * as &#39;reachable&#39; instead of &#39;possibly lost&#39;).  We then add an extra
1833    * pointer at the end of the object, after all instance data, back to
1834    * the start of the private area so that it is also recorded as
1835    * reachable.  We also add extra private space at the start because
1836    * valgrind doesn&#39;t seem to like us claiming to have allocated an
1837    * address that it saw allocated by malloc().
</pre>
<hr />
<pre>
1848       allocated = g_slice_alloc0 (private_size + ivar_size + sizeof (gpointer));
1849       /* ... and point it back to the start of the private data. */
1850       *(gpointer *) (allocated + private_size + ivar_size) = allocated + ALIGN_STRUCT (1);
1851 
1852       /* Tell valgrind that it should treat the object itself as such */
1853       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, ivar_size + sizeof (gpointer), 0, TRUE);
1854       VALGRIND_MALLOCLIKE_BLOCK (allocated + ALIGN_STRUCT (1), private_size - ALIGN_STRUCT (1), 0, TRUE);
1855     }
1856   else
1857 #endif
1858     allocated = g_slice_alloc0 (private_size + ivar_size);
1859 
1860   instance = (GTypeInstance *) (allocated + private_size);
1861 
1862   for (i = node-&gt;n_supers; i &gt; 0; i--)
1863     {
1864       TypeNode *pnode;
1865 
1866       pnode = lookup_type_node_I (node-&gt;supers[i]);
1867       if (pnode-&gt;data-&gt;instance.instance_init)
<span class="line-modified">1868   {</span>
<span class="line-modified">1869     instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="line-modified">1870     pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="line-modified">1871   }</span>
1872     }
1873 
1874   instance-&gt;g_class = class;
1875   if (node-&gt;data-&gt;instance.instance_init)
1876     node-&gt;data-&gt;instance.instance_init (instance, class);
1877 
1878 #ifdef  G_ENABLE_DEBUG
1879   IF_DEBUG (INSTANCE_COUNT)
1880     {
1881       g_atomic_int_inc ((int *) &amp;node-&gt;instance_count);
1882     }
1883 #endif
1884 
1885   TRACE(GOBJECT_OBJECT_NEW(instance, type));
1886 
1887   return instance;
1888 }
1889 
1890 /**
1891  * g_type_free_instance:
</pre>
<hr />
<pre>
1896  *
1897  * Like g_type_create_instance(), this function is reserved for
1898  * implementors of fundamental types.
1899  */
1900 void
1901 g_type_free_instance (GTypeInstance *instance)
1902 {
1903   TypeNode *node;
1904   GTypeClass *class;
1905   gchar *allocated;
1906   gint private_size;
1907   gint ivar_size;
1908 
1909   g_return_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL);
1910 
1911   class = instance-&gt;g_class;
1912   node = lookup_type_node_I (class-&gt;g_type);
1913   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
1914     {
1915       g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1916      type_descriptive_name_I (class-&gt;g_type));</span>
1917       return;
1918     }
1919   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1920   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
1921     {
1922       g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">1923      NODE_NAME (node));</span>
1924       return;
1925     }
1926 
1927   instance-&gt;g_class = NULL;
1928   private_size = node-&gt;data-&gt;instance.private_size;
1929   ivar_size = node-&gt;data-&gt;instance.instance_size;
1930   allocated = ((gchar *) instance) - private_size;
1931 
1932 #ifdef G_ENABLE_DEBUG
1933   memset (allocated, 0xaa, ivar_size + private_size);
1934 #endif
1935 
1936 #ifdef ENABLE_VALGRIND
1937   /* See comment in g_type_create_instance() about what&#39;s going on here.
1938    * We&#39;re basically unwinding what we put into motion there.
1939    */
1940   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1941     {
1942       private_size += ALIGN_STRUCT (1);
1943       allocated -= ALIGN_STRUCT (1);
</pre>
<hr />
<pre>
1986           if (iface-&gt;data-&gt;iface.vtable_init_base)
1987             iface-&gt;data-&gt;iface.vtable_init_base (vtable);
1988           if (iface-&gt;data-&gt;iface.dflt_init)
1989             iface-&gt;data-&gt;iface.dflt_init (vtable, (gpointer) iface-&gt;data-&gt;iface.dflt_data);
1990           G_WRITE_LOCK (&amp;type_rw_lock);
1991         }
1992     }
1993 }
1994 
1995 
1996 /* This is called to allocate and do the first part of initializing
1997  * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.
1998  *
1999  * A FALSE return indicates that we didn&#39;t find an init function for
2000  * this type/iface pair, so the vtable from the parent type should
2001  * be used. Note that the write lock is not modified upon a FALSE
2002  * return.
2003  */
2004 static gboolean
2005 type_iface_vtable_base_init_Wm (TypeNode *iface,
<span class="line-modified">2006         TypeNode *node)</span>
2007 {
2008   IFaceEntry *entry;
2009   IFaceHolder *iholder;
2010   GTypeInterface *vtable = NULL;
2011   TypeNode *pnode;
2012 
2013   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2014   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
2015   if (!iholder)
<span class="line-modified">2016     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
2017 
2018   type_iface_ensure_dflt_vtable_Wm (iface);
2019 
2020   entry = type_lookup_iface_entry_L (node, iface);
2021 #ifdef GSTREAMER_LITE
2022   if (entry == NULL)
2023     return FALSE;
2024 #endif // GSTREAMER_LITE
2025 
2026   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2027 
2028   entry-&gt;init_state = IFACE_INIT;
2029 
2030   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
<span class="line-modified">2031   if (pnode)  /* want to copy over parent iface contents */</span>
2032     {
2033       IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
2034 
2035       if (pentry)
<span class="line-modified">2036   vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
2037     }
2038   if (!vtable)
2039     vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
2040   entry-&gt;vtable = vtable;
2041   vtable-&gt;g_type = NODE_TYPE (iface);
2042   vtable-&gt;g_instance_type = NODE_TYPE (node);
2043 
2044   if (iface-&gt;data-&gt;iface.vtable_init_base)
2045     {
2046       G_WRITE_UNLOCK (&amp;type_rw_lock);
2047       iface-&gt;data-&gt;iface.vtable_init_base (vtable);
2048       G_WRITE_LOCK (&amp;type_rw_lock);
2049     }
2050   return TRUE;  /* initialized the vtable */
2051 }
2052 
2053 /* Finishes what type_iface_vtable_base_init_Wm started by
2054  * calling the interface init function.
2055  * this function may only be called for types with their
2056  * own interface holder info, i.e. types for which
2057  * g_type_add_interface*() was called and not children thereof.
2058  */
2059 static void
2060 type_iface_vtable_iface_init_Wm (TypeNode *iface,
<span class="line-modified">2061          TypeNode *node)</span>
2062 {
2063   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2064   IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
2065   GTypeInterface *vtable = NULL;
2066   guint i;
2067 
2068   /* iholder-&gt;info should have been filled in by type_iface_vtable_base_init_Wm() */
2069   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2070   g_assert (entry-&gt;init_state == IFACE_INIT); /* assert prior base_init() */
2071 #ifdef GSTREAMER_LITE
2072   if (entry == NULL)
2073     return;
2074 #endif // GSTREAMER_LITE
2075 
2076   entry-&gt;init_state = INITIALIZED;
2077 
2078   vtable = entry-&gt;vtable;
2079 
2080   if (iholder-&gt;info-&gt;interface_init)
2081     {
2082       G_WRITE_UNLOCK (&amp;type_rw_lock);
2083       if (iholder-&gt;info-&gt;interface_init)
<span class="line-modified">2084   iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
2085       G_WRITE_LOCK (&amp;type_rw_lock);
2086     }
2087 
2088   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2089     {
2090       GTypeInterfaceCheckFunc check_func = static_iface_check_funcs[i].check_func;
2091       gpointer check_data = static_iface_check_funcs[i].check_data;
2092 
2093       G_WRITE_UNLOCK (&amp;type_rw_lock);
2094       check_func (check_data, (gpointer)vtable);
2095       G_WRITE_LOCK (&amp;type_rw_lock);
2096     }
2097 }
2098 
2099 static gboolean
2100 type_iface_vtable_finalize_Wm (TypeNode       *iface,
<span class="line-modified">2101              TypeNode       *node,</span>
<span class="line-modified">2102              GTypeInterface *vtable)</span>
2103 {
2104   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2105   IFaceHolder *iholder;
2106 
2107   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2108   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
2109   if (!iholder)
<span class="line-modified">2110     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
2111 
2112   g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
2113 
2114   entry-&gt;vtable = NULL;
2115   entry-&gt;init_state = UNINITIALIZED;
2116   if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
2117     {
2118       G_WRITE_UNLOCK (&amp;type_rw_lock);
2119       if (iholder-&gt;info-&gt;interface_finalize)
<span class="line-modified">2120   iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
2121       if (iface-&gt;data-&gt;iface.vtable_finalize_base)
<span class="line-modified">2122   iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
2123       G_WRITE_LOCK (&amp;type_rw_lock);
2124     }
2125   vtable-&gt;g_type = 0;
2126   vtable-&gt;g_instance_type = 0;
2127   g_free (vtable);
2128 
2129   type_iface_blow_holder_info_Wm (iface, NODE_TYPE (node));
2130 
2131   return TRUE;  /* write lock modified */
2132 }
2133 
2134 static void
2135 type_class_init_Wm (TypeNode   *node,
<span class="line-modified">2136         GTypeClass *pclass)</span>
2137 {
2138   GSList *slist, *init_slist = NULL;
2139   GTypeClass *class;
2140   IFaceEntries *entries;
2141   IFaceEntry *entry;
2142   TypeNode *bnode, *pnode;
2143   guint i;
2144 
2145   /* Accessing data-&gt;class will work for instantiable types
2146    * too because ClassData is a subset of InstanceData
2147    */
2148   g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
<span class="line-modified">2149       node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="line-modified">2150       !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="line-modified">2151       node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
2152   if (node-&gt;data-&gt;class.class_private_size)
2153     class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
2154   else
2155     class = g_malloc0 (node-&gt;data-&gt;class.class_size);
2156   node-&gt;data-&gt;class.class = class;
2157   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_CLASS_INIT);
2158 
2159   if (pclass)
2160     {
2161       TypeNode *pnode = lookup_type_node_I (pclass-&gt;g_type);
2162 
2163       memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
2164       memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
2165 
2166       if (node-&gt;is_instantiatable)
<span class="line-modified">2167   {</span>
<span class="line-modified">2168     /* We need to initialize the private_size here rather than in</span>
<span class="line-modified">2169      * type_data_make_W() since the class init for the parent</span>
<span class="line-modified">2170      * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="line-modified">2171      */</span>
<span class="line-modified">2172     node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="line-modified">2173   }</span>
2174     }
2175   class-&gt;g_type = NODE_TYPE (node);
2176 
2177   G_WRITE_UNLOCK (&amp;type_rw_lock);
2178 
2179   /* stack all base class initialization functions, so we
2180    * call them in ascending order.
2181    */
2182   for (bnode = node; bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2183     if (bnode-&gt;data-&gt;class.class_init_base)
2184       init_slist = g_slist_prepend (init_slist, (gpointer) bnode-&gt;data-&gt;class.class_init_base);
2185   for (slist = init_slist; slist; slist = slist-&gt;next)
2186     {
2187       GBaseInitFunc class_init_base = (GBaseInitFunc) slist-&gt;data;
2188 
2189       class_init_base (class);
2190     }
2191   g_slist_free (init_slist);
2192 
2193   G_WRITE_LOCK (&amp;type_rw_lock);
2194 
2195   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_IFACE_INIT);
2196 
2197   /* Before we initialize the class, base initialize all interfaces, either
2198    * from parent, or through our holder info
2199    */
2200   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2201 
2202   i = 0;
2203   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
<span class="line-modified">2204     i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
2205     {
2206       entry = &amp;entries-&gt;entry[i];
2207       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">2208        entry-&gt;init_state == IFACE_INIT)</span>
<span class="line-modified">2209   {</span>
<span class="line-modified">2210     entry++;</span>
<span class="line-modified">2211     i++;</span>
<span class="line-modified">2212   }</span>
2213 
2214       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">2215   break;</span>
2216 
2217       if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
<span class="line-modified">2218   {</span>
<span class="line-modified">2219     guint j;</span>
<span class="line-modified">2220     IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
2221 
<span class="line-modified">2222     /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="line-modified">2223      * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="line-modified">2224      */</span>
<span class="line-modified">2225     g_assert (pnode != NULL);</span>
2226 
<span class="line-modified">2227     if (pentries)</span>
<span class="line-modified">2228       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="line-modified">2229         {</span>
<span class="line-modified">2230     IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
2231 
<span class="line-modified">2232     if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="line-modified">2233       {</span>
<span class="line-modified">2234         entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="line-modified">2235         entry-&gt;init_state = INITIALIZED;</span>
<span class="line-modified">2236         break;</span>
<span class="line-modified">2237       }</span>
<span class="line-modified">2238         }</span>
<span class="line-modified">2239     g_assert (entry-&gt;vtable != NULL);</span>
<span class="line-modified">2240   }</span>
2241 
2242       /* If the write lock was released, additional interface entries might
2243        * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
2244        * be base-initialized when inserted, so we don&#39;t have to worry that
2245        * we might miss them. Uninitialized entries can only be moved higher
2246        * when new ones are inserted.
2247        */
2248       i++;
2249     }
2250 
2251   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, CLASS_INIT);
2252 
2253   G_WRITE_UNLOCK (&amp;type_rw_lock);
2254 
2255   if (node-&gt;data-&gt;class.class_init)
2256     node-&gt;data-&gt;class.class_init (class, (gpointer) node-&gt;data-&gt;class.class_data);
2257 
2258   G_WRITE_LOCK (&amp;type_rw_lock);
2259 
2260   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, IFACE_INIT);
2261 
2262   /* finish initializing the interfaces through our holder info.
2263    * inherited interfaces are already init_state == INITIALIZED, because
2264    * they either got setup in the above base_init loop, or during
2265    * class_init from within type_add_interface_Wm() for this or
2266    * an anchestor type.
2267    */
2268   i = 0;
2269   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
2270     {
2271       entry = &amp;entries-&gt;entry[i];
2272       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">2273        entry-&gt;init_state == INITIALIZED)</span>
<span class="line-modified">2274   {</span>
<span class="line-modified">2275     entry++;</span>
<span class="line-modified">2276     i++;</span>
<span class="line-modified">2277   }</span>
2278 
2279       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">2280   break;</span>
2281 
2282       type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
2283 
2284       /* As in the loop above, additional initialized entries might be inserted
2285        * if the write lock is released, but that&#39;s harmless because the entries
2286        * we need to initialize only move higher in the list.
2287        */
2288       i++;
2289     }
2290 
2291   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, INITIALIZED);
2292 }
2293 
2294 static void
2295 type_data_finalize_class_ifaces_Wm (TypeNode *node)
2296 {
2297   guint i;
2298   IFaceEntries *entries;
2299 
2300   g_assert (node-&gt;is_instantiatable &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; NODE_REFCOUNT (node) == 0);
2301 
2302  reiterate:
2303   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
2304   for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
2305     {
2306       IFaceEntry *entry = &amp;entries-&gt;entry[i];
2307       if (entry-&gt;vtable)
<span class="line-modified">2308   {</span>
2309           if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
2310             {
2311               /* refetch entries, IFACES_ENTRIES might be modified */
2312               goto reiterate;
2313             }
2314           else
2315             {
2316               /* type_iface_vtable_finalize_Wm() doesn&#39;t modify write lock upon FALSE,
2317                * iface vtable came from parent
2318                */
2319               entry-&gt;vtable = NULL;
2320               entry-&gt;init_state = UNINITIALIZED;
2321             }
<span class="line-modified">2322   }</span>
2323     }
2324 }
2325 
2326 static void
2327 type_data_finalize_class_U (TypeNode  *node,
<span class="line-modified">2328           ClassData *cdata)</span>
2329 {
2330   GTypeClass *class = cdata-&gt;class;
2331   TypeNode *bnode;
2332 
2333   g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
2334 
2335   if (cdata-&gt;class_finalize)
2336     cdata-&gt;class_finalize (class, (gpointer) cdata-&gt;class_data);
2337 
2338   /* call all base class destruction functions in descending order
2339    */
2340   if (cdata-&gt;class_finalize_base)
2341     cdata-&gt;class_finalize_base (class);
2342   for (bnode = lookup_type_node_I (NODE_PARENT_TYPE (node)); bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2343     if (bnode-&gt;data-&gt;class.class_finalize_base)
2344       bnode-&gt;data-&gt;class.class_finalize_base (class);
2345 
2346   g_free (cdata-&gt;class);
2347 }
2348 
2349 static void
2350 type_data_last_unref_Wm (TypeNode *node,
<span class="line-modified">2351        gboolean  uncached)</span>
2352 {
2353   g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
2354 
2355   if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2356     {
2357       g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
<span class="line-modified">2358      NODE_NAME (node));</span>
2359       return;
2360     }
2361 
2362   /* call class cache hooks */
2363   if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
2364     {
2365       guint i;
2366 
2367       G_WRITE_UNLOCK (&amp;type_rw_lock);
2368       G_READ_LOCK (&amp;type_rw_lock);
2369       for (i = 0; i &lt; static_n_class_cache_funcs; i++)
<span class="line-modified">2370   {</span>
<span class="line-modified">2371     GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="line-modified">2372     gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="line-modified">2373     gboolean need_break;</span>
2374 
<span class="line-modified">2375     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2376     need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="line-modified">2377     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2378     if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="line-modified">2379       INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="line-modified">2380     if (need_break)</span>
<span class="line-modified">2381       break;</span>
<span class="line-modified">2382   }</span>
2383       G_READ_UNLOCK (&amp;type_rw_lock);
2384       G_WRITE_LOCK (&amp;type_rw_lock);
2385     }
2386 
2387   /* may have been re-referenced meanwhile */
2388   if (g_atomic_int_dec_and_test ((int *) &amp;node-&gt;ref_count))
2389     {
2390       GType ptype = NODE_PARENT_TYPE (node);
2391       TypeData *tdata;
2392 
2393       if (node-&gt;is_instantiatable)
<span class="line-modified">2394   {</span>
<span class="line-modified">2395     /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="line-modified">2396   }</span>
2397 
2398       tdata = node-&gt;data;
2399       if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
<span class="line-modified">2400   {</span>
<span class="line-modified">2401     if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="line-modified">2402       type_data_finalize_class_ifaces_Wm (node);</span>
<span class="line-modified">2403     node-&gt;mutatable_check_cache = FALSE;</span>
<span class="line-modified">2404     node-&gt;data = NULL;</span>
<span class="line-modified">2405     G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2406     type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="line-modified">2407     G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">2408   }</span>
2409       else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
2410         {
2411           node-&gt;mutatable_check_cache = FALSE;
2412           node-&gt;data = NULL;
2413           if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
2414             {
2415               G_WRITE_UNLOCK (&amp;type_rw_lock);
2416               if (tdata-&gt;iface.dflt_finalize)
2417                 tdata-&gt;iface.dflt_finalize (tdata-&gt;iface.dflt_vtable, (gpointer) tdata-&gt;iface.dflt_data);
2418               if (tdata-&gt;iface.vtable_finalize_base)
2419                 tdata-&gt;iface.vtable_finalize_base (tdata-&gt;iface.dflt_vtable);
2420               G_WRITE_LOCK (&amp;type_rw_lock);
2421             }
2422           g_free (tdata-&gt;iface.dflt_vtable);
2423         }
2424       else
2425         {
2426           node-&gt;mutatable_check_cache = FALSE;
2427           node-&gt;data = NULL;
2428         }
2429 
2430       /* freeing tdata-&gt;common.value_table and its contents is taken care of
2431        * by allocating it in one chunk with tdata
2432        */
2433       g_free (tdata);
2434 
2435       G_WRITE_UNLOCK (&amp;type_rw_lock);
2436       g_type_plugin_unuse (node-&gt;plugin);
2437       if (ptype)
<span class="line-modified">2438   type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
2439       G_WRITE_LOCK (&amp;type_rw_lock);
2440     }
2441 }
2442 
2443 static inline void
2444 type_data_unref_U (TypeNode *node,
2445                    gboolean  uncached)
2446 {
2447   guint current;
2448 
2449   do {
2450     current = NODE_REFCOUNT (node);
2451 
2452     if (current &lt;= 1)
2453     {
2454       if (!node-&gt;plugin)
<span class="line-modified">2455   {</span>
<span class="line-modified">2456     g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="line-modified">2457          NODE_NAME (node));</span>
<span class="line-modified">2458     return;</span>
<span class="line-modified">2459   }</span>
2460       else
2461         {
2462           /* This is the last reference of a type from a plugin.  We are
2463            * experimentally disabling support for unloading type
2464            * plugins, so don&#39;t allow the last ref to drop.
2465            */
2466           return;
2467         }
2468 
2469       g_assert (current &gt; 0);
2470 
2471       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2472       G_WRITE_LOCK (&amp;type_rw_lock);
2473       type_data_last_unref_Wm (node, uncached);
2474       G_WRITE_UNLOCK (&amp;type_rw_lock);
2475       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2476       return;
2477     }
2478   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current - 1));
2479 }
2480 
2481 /**
2482  * g_type_add_class_cache_func: (skip)
2483  * @cache_data: data to be passed to @cache_func
2484  * @cache_func: a #GTypeClassCacheFunc
2485  *
2486  * Adds a #GTypeClassCacheFunc to be called before the reference count of a
2487  * class goes from one to zero. This can be used to prevent premature class
2488  * destruction. All installed #GTypeClassCacheFunc functions will be chained
2489  * until one of them returns %TRUE. The functions have to check the class id
2490  * passed in to figure whether they actually want to cache the class of this
2491  * type, since all classes are routed through the same #GTypeClassCacheFunc
2492  * chain.
2493  */
2494 void
2495 g_type_add_class_cache_func (gpointer            cache_data,
<span class="line-modified">2496            GTypeClassCacheFunc cache_func)</span>
2497 {
2498   guint i;
2499 
2500   g_return_if_fail (cache_func != NULL);
2501 
2502   G_WRITE_LOCK (&amp;type_rw_lock);
2503   i = static_n_class_cache_funcs++;
2504   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2505   static_class_cache_funcs[i].cache_data = cache_data;
2506   static_class_cache_funcs[i].cache_func = cache_func;
2507   G_WRITE_UNLOCK (&amp;type_rw_lock);
2508 }
2509 
2510 /**
2511  * g_type_remove_class_cache_func: (skip)
2512  * @cache_data: data that was given when adding @cache_func
2513  * @cache_func: a #GTypeClassCacheFunc
2514  *
2515  * Removes a previously installed #GTypeClassCacheFunc. The cache
2516  * maintained by @cache_func has to be empty when calling
2517  * g_type_remove_class_cache_func() to avoid leaks.
2518  */
2519 void
2520 g_type_remove_class_cache_func (gpointer            cache_data,
<span class="line-modified">2521         GTypeClassCacheFunc cache_func)</span>
2522 {
2523   gboolean found_it = FALSE;
2524   guint i;
2525 
2526   g_return_if_fail (cache_func != NULL);
2527 
2528   G_WRITE_LOCK (&amp;type_rw_lock);
2529   for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2530     if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
<span class="line-modified">2531   static_class_cache_funcs[i].cache_func == cache_func)</span>
2532       {
<span class="line-modified">2533   static_n_class_cache_funcs--;</span>
<span class="line-modified">2534   memmove (static_class_cache_funcs + i,</span>
2535                  static_class_cache_funcs + i + 1,
2536                  sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
<span class="line-modified">2537   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="line-modified">2538   found_it = TRUE;</span>
<span class="line-modified">2539   break;</span>
2540       }
2541   G_WRITE_UNLOCK (&amp;type_rw_lock);
2542 
2543   if (!found_it)
2544     g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
<span class="line-modified">2545          cache_func, cache_data);</span>
2546 }
2547 
2548 
2549 /**
2550  * g_type_add_interface_check: (skip)
2551  * @check_data: data to pass to @check_func
2552  * @check_func: function to be called after each interface
2553  *     is initialized
2554  *
2555  * Adds a function to be called after an interface vtable is
2556  * initialized for any class (i.e. after the @interface_init
2557  * member of #GInterfaceInfo has been called).
2558  *
2559  * This function is useful when you want to check an invariant
2560  * that depends on the interfaces of a class. For instance, the
2561  * implementation of #GObject uses this facility to check that an
2562  * object implements all of the properties that are defined on its
2563  * interfaces.
2564  *
2565  * Since: 2.4
2566  */
2567 void
<span class="line-modified">2568 g_type_add_interface_check (gpointer              check_data,</span>
<span class="line-modified">2569           GTypeInterfaceCheckFunc check_func)</span>
2570 {
2571   guint i;
2572 
2573   g_return_if_fail (check_func != NULL);
2574 
2575   G_WRITE_LOCK (&amp;type_rw_lock);
2576   i = static_n_iface_check_funcs++;
2577   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2578   static_iface_check_funcs[i].check_data = check_data;
2579   static_iface_check_funcs[i].check_func = check_func;
2580   G_WRITE_UNLOCK (&amp;type_rw_lock);
2581 }
2582 
2583 /**
2584  * g_type_remove_interface_check: (skip)
2585  * @check_data: callback data passed to g_type_add_interface_check()
2586  * @check_func: callback function passed to g_type_add_interface_check()
2587  *
2588  * Removes an interface check function added with
2589  * g_type_add_interface_check().
2590  *
2591  * Since: 2.4
2592  */
2593 void
2594 g_type_remove_interface_check (gpointer                check_data,
<span class="line-modified">2595              GTypeInterfaceCheckFunc check_func)</span>
2596 {
2597   gboolean found_it = FALSE;
2598   guint i;
2599 
2600   g_return_if_fail (check_func != NULL);
2601 
2602   G_WRITE_LOCK (&amp;type_rw_lock);
2603   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2604     if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
<span class="line-modified">2605   static_iface_check_funcs[i].check_func == check_func)</span>
2606       {
<span class="line-modified">2607   static_n_iface_check_funcs--;</span>
<span class="line-modified">2608   memmove (static_iface_check_funcs + i,</span>
2609                  static_iface_check_funcs + i + 1,
2610                  sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
<span class="line-modified">2611   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="line-modified">2612   found_it = TRUE;</span>
<span class="line-modified">2613   break;</span>
2614       }
2615   G_WRITE_UNLOCK (&amp;type_rw_lock);
2616 
2617   if (!found_it)
2618     g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
<span class="line-modified">2619          check_func, check_data);</span>
2620 }
2621 
2622 /* --- type registration --- */
2623 /**
2624  * g_type_register_fundamental:
2625  * @type_id: a predefined type identifier
2626  * @type_name: 0-terminated string used as the name of the new type
2627  * @info: #GTypeInfo structure for this type
2628  * @finfo: #GTypeFundamentalInfo structure for this type
2629  * @flags: bitwise combination of #GTypeFlags values
2630  *
2631  * Registers @type_id as the predefined identifier and @type_name as the
2632  * name of a fundamental type. If @type_id is already registered, or a
2633  * type named @type_name is already registered, the behaviour is undefined.
2634  * The type system uses the information contained in the #GTypeInfo structure
2635  * pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
2636  * @finfo to manage the type and its instances. The value of @flags determines
2637  * additional characteristics of the fundamental type.
2638  *
2639  * Returns: the predefined type identifier
2640  */
2641 GType
2642 g_type_register_fundamental (GType                       type_id,
<span class="line-modified">2643            const gchar                *type_name,</span>
<span class="line-modified">2644            const GTypeInfo            *info,</span>
<span class="line-modified">2645            const GTypeFundamentalInfo *finfo,</span>
<span class="line-modified">2646            GTypeFlags      flags)</span>
2647 {
2648   TypeNode *node;
2649 
2650   g_assert_type_system_initialized ();
2651   g_return_val_if_fail (type_id &gt; 0, 0);
2652   g_return_val_if_fail (type_name != NULL, 0);
2653   g_return_val_if_fail (info != NULL, 0);
2654   g_return_val_if_fail (finfo != NULL, 0);
2655 
2656   if (!check_type_name_I (type_name))
2657     return 0;
2658   if ((type_id &amp; TYPE_ID_MASK) ||
2659       type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
2660     {
2661       g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
<span class="line-modified">2662      type_name,</span>
<span class="line-modified">2663      type_id);</span>
2664       return 0;
2665     }
2666   if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
2667       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
2668     {
2669       g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
<span class="line-modified">2670      type_name);</span>
2671       return 0;
2672     }
2673   if (lookup_type_node_I (type_id))
2674     {
2675       g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
<span class="line-modified">2676      type_descriptive_name_I (type_id),</span>
<span class="line-modified">2677      type_name);</span>
2678       return 0;
2679     }
2680 
2681   G_WRITE_LOCK (&amp;type_rw_lock);
2682   node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
2683   type_add_flags_W (node, flags);
2684 
2685   if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
2686     type_data_make_W (node, info,
<span class="line-modified">2687           check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
2688   G_WRITE_UNLOCK (&amp;type_rw_lock);
2689 
2690   return NODE_TYPE (node);
2691 }
2692 
2693 /**
2694  * g_type_register_static_simple: (skip)
2695  * @parent_type: type from which this type will be derived
2696  * @type_name: 0-terminated string used as the name of the new type
2697  * @class_size: size of the class structure (see #GTypeInfo)
2698  * @class_init: location of the class initialization function (see #GTypeInfo)
2699  * @instance_size: size of the instance structure (see #GTypeInfo)
2700  * @instance_init: location of the instance initialization function (see #GTypeInfo)
2701  * @flags: bitwise combination of #GTypeFlags values
2702  *
2703  * Registers @type_name as the name of a new static type derived from
2704  * @parent_type.  The value of @flags determines the nature (e.g.
2705  * abstract or not) of the type. It works by filling a #GTypeInfo
2706  * struct and calling g_type_register_static().
2707  *
2708  * Since: 2.12
2709  *
2710  * Returns: the new type identifier
2711  */
2712 GType
2713 g_type_register_static_simple (GType             parent_type,
<span class="line-modified">2714              const gchar      *type_name,</span>
<span class="line-modified">2715              guint             class_size,</span>
<span class="line-modified">2716              GClassInitFunc    class_init,</span>
<span class="line-modified">2717              guint             instance_size,</span>
<span class="line-modified">2718              GInstanceInitFunc instance_init,</span>
<span class="line-modified">2719              GTypeFlags  flags)</span>
2720 {
2721   GTypeInfo info;
2722 
2723   /* Instances are not allowed to be larger than this. If you have a big
2724    * fixed-length array or something, point to it instead.
2725    */
2726   g_return_val_if_fail (class_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2727   g_return_val_if_fail (instance_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2728 
2729   info.class_size = class_size;
2730   info.base_init = NULL;
2731   info.base_finalize = NULL;
2732   info.class_init = class_init;
2733   info.class_finalize = NULL;
2734   info.class_data = NULL;
2735   info.instance_size = instance_size;
2736   info.n_preallocs = 0;
2737   info.instance_init = instance_init;
2738   info.value_table = NULL;
2739 
2740   return g_type_register_static (parent_type, type_name, &amp;info, flags);
2741 }
2742 
2743 /**
2744  * g_type_register_static:
2745  * @parent_type: type from which this type will be derived
2746  * @type_name: 0-terminated string used as the name of the new type
2747  * @info: #GTypeInfo structure for this type
2748  * @flags: bitwise combination of #GTypeFlags values
2749  *
2750  * Registers @type_name as the name of a new static type derived from
2751  * @parent_type. The type system uses the information contained in the
2752  * #GTypeInfo structure pointed to by @info to manage the type and its
2753  * instances (if not abstract). The value of @flags determines the nature
2754  * (e.g. abstract or not) of the type.
2755  *
2756  * Returns: the new type identifier
2757  */
2758 GType
2759 g_type_register_static (GType            parent_type,
<span class="line-modified">2760       const gchar     *type_name,</span>
<span class="line-modified">2761       const GTypeInfo *info,</span>
<span class="line-modified">2762       GTypeFlags   flags)</span>
2763 {
2764   TypeNode *pnode, *node;
2765   GType type = 0;
2766 
2767   g_assert_type_system_initialized ();
2768   g_return_val_if_fail (parent_type &gt; 0, 0);
2769   g_return_val_if_fail (type_name != NULL, 0);
2770   g_return_val_if_fail (info != NULL, 0);
2771 
2772   if (!check_type_name_I (type_name) ||
2773       !check_derivation_I (parent_type, type_name))
2774     return 0;
2775   if (info-&gt;class_finalize)
2776     {
2777       g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
<span class="line-modified">2778      type_name);</span>
2779       return 0;
2780     }
2781 
2782   pnode = lookup_type_node_I (parent_type);
2783   G_WRITE_LOCK (&amp;type_rw_lock);
2784   type_data_ref_Wm (pnode);
2785   if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (pnode), type_name, info))
2786     {
2787       node = type_node_new_W (pnode, type_name, NULL);
2788       type_add_flags_W (node, flags);
2789       type = NODE_TYPE (node);
2790       type_data_make_W (node, info,
<span class="line-modified">2791       check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
2792     }
2793   G_WRITE_UNLOCK (&amp;type_rw_lock);
2794 
2795   return type;
2796 }
2797 
2798 /**
2799  * g_type_register_dynamic:
2800  * @parent_type: type from which this type will be derived
2801  * @type_name: 0-terminated string used as the name of the new type
2802  * @plugin: #GTypePlugin structure to retrieve the #GTypeInfo from
2803  * @flags: bitwise combination of #GTypeFlags values
2804  *
2805  * Registers @type_name as the name of a new dynamic type derived from
2806  * @parent_type.  The type system uses the information contained in the
2807  * #GTypePlugin structure pointed to by @plugin to manage the type and its
2808  * instances (if not abstract).  The value of @flags determines the nature
2809  * (e.g. abstract or not) of the type.
2810  *
2811  * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
2812  */
2813 GType
2814 g_type_register_dynamic (GType        parent_type,
<span class="line-modified">2815        const gchar *type_name,</span>
<span class="line-modified">2816        GTypePlugin *plugin,</span>
<span class="line-modified">2817        GTypeFlags   flags)</span>
2818 {
2819   TypeNode *pnode, *node;
2820   GType type;
2821 
2822   g_assert_type_system_initialized ();
2823   g_return_val_if_fail (parent_type &gt; 0, 0);
2824   g_return_val_if_fail (type_name != NULL, 0);
2825   g_return_val_if_fail (plugin != NULL, 0);
2826 
2827   if (!check_type_name_I (type_name) ||
2828       !check_derivation_I (parent_type, type_name) ||
2829       !check_plugin_U (plugin, TRUE, FALSE, type_name))
2830     return 0;
2831 
2832   G_WRITE_LOCK (&amp;type_rw_lock);
2833   pnode = lookup_type_node_I (parent_type);
2834   node = type_node_new_W (pnode, type_name, plugin);
2835   type_add_flags_W (node, flags);
2836   type = NODE_TYPE (node);
2837   G_WRITE_UNLOCK (&amp;type_rw_lock);
2838 
2839   return type;
2840 }
2841 
2842 /**
2843  * g_type_add_interface_static:
2844  * @instance_type: #GType value of an instantiable type
2845  * @interface_type: #GType value of an interface type
2846  * @info: #GInterfaceInfo structure for this
2847  *        (@instance_type, @interface_type) combination
2848  *
2849  * Adds the static @interface_type to @instantiable_type.
2850  * The information contained in the #GInterfaceInfo structure
2851  * pointed to by @info is used to manage the relationship.
2852  */
2853 void
2854 g_type_add_interface_static (GType                 instance_type,
<span class="line-modified">2855            GType                 interface_type,</span>
<span class="line-modified">2856            const GInterfaceInfo *info)</span>
2857 {
2858   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2859   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2860   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2861 
2862   /* we only need to lock class_init_rec_mutex if instance_type already has its
2863    * class initialized, however this function is rarely enough called to take
2864    * the simple route and always acquire class_init_rec_mutex.
2865    */
2866   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2867   G_WRITE_LOCK (&amp;type_rw_lock);
2868   if (check_add_interface_L (instance_type, interface_type))
2869     {
2870       TypeNode *node = lookup_type_node_I (instance_type);
2871       TypeNode *iface = lookup_type_node_I (interface_type);
2872       if (check_interface_info_I (iface, NODE_TYPE (node), info))
2873         type_add_interface_Wm (node, iface, info, NULL);
2874     }
2875   G_WRITE_UNLOCK (&amp;type_rw_lock);
2876   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2877 }
2878 
2879 /**
2880  * g_type_add_interface_dynamic:
2881  * @instance_type: #GType value of an instantiable type
2882  * @interface_type: #GType value of an interface type
2883  * @plugin: #GTypePlugin structure to retrieve the #GInterfaceInfo from
2884  *
2885  * Adds the dynamic @interface_type to @instantiable_type. The information
2886  * contained in the #GTypePlugin structure pointed to by @plugin
2887  * is used to manage the relationship.
2888  */
2889 void
2890 g_type_add_interface_dynamic (GType        instance_type,
<span class="line-modified">2891             GType        interface_type,</span>
<span class="line-modified">2892             GTypePlugin *plugin)</span>
2893 {
2894   TypeNode *node;
2895   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2896   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2897   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2898 
2899   node = lookup_type_node_I (instance_type);
2900   if (!check_plugin_U (plugin, FALSE, TRUE, NODE_NAME (node)))
2901     return;
2902 
2903   /* see comment in g_type_add_interface_static() about class_init_rec_mutex */
2904   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2905   G_WRITE_LOCK (&amp;type_rw_lock);
2906   if (check_add_interface_L (instance_type, interface_type))
2907     {
2908       TypeNode *iface = lookup_type_node_I (interface_type);
2909       type_add_interface_Wm (node, iface, NULL, plugin);
2910     }
2911   G_WRITE_UNLOCK (&amp;type_rw_lock);
2912   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
</pre>
<hr />
<pre>
2921  * Increments the reference count of the class structure belonging to
2922  * @type. This function will demand-create the class if it doesn&#39;t
2923  * exist already.
2924  *
2925  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
2926  *     structure for the given type ID
2927  */
2928 gpointer
2929 g_type_class_ref (GType type)
2930 {
2931   TypeNode *node;
2932   GType ptype;
2933   gboolean holds_ref;
2934   GTypeClass *pclass;
2935 
2936   /* optimize for common code path */
2937   node = lookup_type_node_I (type);
2938   if (!node || !node-&gt;is_classed)
2939     {
2940       g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">2941      type_descriptive_name_I (type));</span>
2942       return NULL;
2943     }
2944 
2945   if (G_LIKELY (type_data_ref_U (node)))
2946     {
2947       if (G_LIKELY (g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED))
2948         return node-&gt;data-&gt;class.class;
2949       holds_ref = TRUE;
2950     }
2951   else
2952     holds_ref = FALSE;
2953 
2954   /* here, we either have node-&gt;data-&gt;class.class == NULL, or a recursive
2955    * call to g_type_class_ref() with a partly initialized class, or
2956    * node-&gt;data-&gt;class.init_state == INITIALIZED, because any
2957    * concurrently running initialization was guarded by class_init_rec_mutex.
2958    */
2959   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2960 
2961   /* we need an initialized parent class for initializing derived classes */
</pre>
<hr />
<pre>
2985  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
2986  *
2987  * Decrements the reference count of the class structure being passed in.
2988  * Once the last reference count of a class has been released, classes
2989  * may be finalized by the type system, so further dereferencing of a
2990  * class pointer after g_type_class_unref() are invalid.
2991  */
2992 void
2993 g_type_class_unref (gpointer g_class)
2994 {
2995   TypeNode *node;
2996   GTypeClass *class = g_class;
2997 
2998   g_return_if_fail (g_class != NULL);
2999 
3000   node = lookup_type_node_I (class-&gt;g_type);
3001   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3002     type_data_unref_U (node, FALSE);
3003   else
3004     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">3005          type_descriptive_name_I (class-&gt;g_type));</span>
3006 }
3007 
3008 /**
3009  * g_type_class_unref_uncached: (skip)
3010  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
3011  *
3012  * A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
3013  * implementations. It unreferences a class without consulting the chain
3014  * of #GTypeClassCacheFuncs, avoiding the recursion which would occur
3015  * otherwise.
3016  */
3017 void
3018 g_type_class_unref_uncached (gpointer g_class)
3019 {
3020   TypeNode *node;
3021   GTypeClass *class = g_class;
3022 
3023   g_return_if_fail (g_class != NULL);
3024 
3025   node = lookup_type_node_I (class-&gt;g_type);
3026   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3027     type_data_unref_U (node, TRUE);
3028   else
3029     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">3030          type_descriptive_name_I (class-&gt;g_type));</span>
3031 }
3032 
3033 /**
3034  * g_type_class_peek:
3035  * @type: type ID of a classed type
3036  *
3037  * This function is essentially the same as g_type_class_ref(),
3038  * except that the classes reference count isn&#39;t incremented.
3039  * As a consequence, this function may return %NULL if the class
3040  * of the type passed in does not currently exist (hasn&#39;t been
3041  * referenced before).
3042  *
3043  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3044  *     structure for the given type ID or %NULL if the class does not
3045  *     currently exist
3046  */
3047 gpointer
3048 g_type_class_peek (GType type)
3049 {
3050   TypeNode *node;
</pre>
<hr />
<pre>
3130   else if (NODE_PARENT_TYPE (node))
3131     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, g_class);
3132 
3133   return class;
3134 }
3135 
3136 /**
3137  * g_type_interface_peek:
3138  * @instance_class: (type GObject.TypeClass): a #GTypeClass structure
3139  * @iface_type: an interface ID which this class conforms to
3140  *
3141  * Returns the #GTypeInterface structure of an interface to which the
3142  * passed in class conforms.
3143  *
3144  * Returns: (type GObject.TypeInterface) (transfer none): the #GTypeInterface
3145  *     structure of @iface_type if implemented by @instance_class, %NULL
3146  *     otherwise
3147  */
3148 gpointer
3149 g_type_interface_peek (gpointer instance_class,
<span class="line-modified">3150            GType    iface_type)</span>
3151 {
3152   TypeNode *node;
3153   TypeNode *iface;
3154   gpointer vtable = NULL;
3155   GTypeClass *class = instance_class;
3156 
3157   g_return_val_if_fail (instance_class != NULL, NULL);
3158 
3159   node = lookup_type_node_I (class-&gt;g_type);
3160   iface = lookup_type_node_I (iface_type);
3161   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3162     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3163   else
3164     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, class);
3165 
3166   return vtable;
3167 }
3168 
3169 /**
3170  * g_type_interface_peek_parent:
</pre>
<hr />
<pre>
3220  * Since: 2.4
3221  *
3222  * Returns: (type GObject.TypeInterface) (transfer none): the default
3223  *     vtable for the interface; call g_type_default_interface_unref()
3224  *     when you are done using the interface.
3225  */
3226 gpointer
3227 g_type_default_interface_ref (GType g_type)
3228 {
3229   TypeNode *node;
3230   gpointer dflt_vtable;
3231 
3232   G_WRITE_LOCK (&amp;type_rw_lock);
3233 
3234   node = lookup_type_node_I (g_type);
3235   if (!node || !NODE_IS_IFACE (node) ||
3236       (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
3237     {
3238       G_WRITE_UNLOCK (&amp;type_rw_lock);
3239       g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
<span class="line-modified">3240      type_descriptive_name_I (g_type));</span>
3241       return NULL;
3242     }
3243 
3244   if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
3245     {
3246       G_WRITE_UNLOCK (&amp;type_rw_lock);
3247       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
3248       G_WRITE_LOCK (&amp;type_rw_lock);
3249       node = lookup_type_node_I (g_type);
3250       type_data_ref_Wm (node);
3251       type_iface_ensure_dflt_vtable_Wm (node);
3252       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
3253     }
3254   else
3255     type_data_ref_Wm (node); /* ref_count &gt;= 1 already */
3256 
3257   dflt_vtable = node-&gt;data-&gt;iface.dflt_vtable;
3258   G_WRITE_UNLOCK (&amp;type_rw_lock);
3259 
3260   return dflt_vtable;
</pre>
<hr />
<pre>
3274  *     in use
3275  */
3276 gpointer
3277 g_type_default_interface_peek (GType g_type)
3278 {
3279   TypeNode *node;
3280   gpointer vtable;
3281 
3282   node = lookup_type_node_I (g_type);
3283   if (node &amp;&amp; NODE_IS_IFACE (node) &amp;&amp; NODE_REFCOUNT (node))
3284     vtable = node-&gt;data-&gt;iface.dflt_vtable;
3285   else
3286     vtable = NULL;
3287 
3288   return vtable;
3289 }
3290 
3291 /**
3292  * g_type_default_interface_unref:
3293  * @g_iface: (type GObject.TypeInterface): the default vtable
<span class="line-modified">3294  *     structure for an interface, as returned by g_type_default_interface_ref()</span>
3295  *
3296  * Decrements the reference count for the type corresponding to the
3297  * interface default vtable @g_iface. If the type is dynamic, then
3298  * when no one is using the interface and all references have
3299  * been released, the finalize function for the interface&#39;s default
3300  * vtable (the @class_finalize member of #GTypeInfo) will be called.
3301  *
3302  * Since: 2.4
3303  */
3304 void
3305 g_type_default_interface_unref (gpointer g_iface)
3306 {
3307   TypeNode *node;
3308   GTypeInterface *vtable = g_iface;
3309 
3310   g_return_if_fail (g_iface != NULL);
3311 
3312   node = lookup_type_node_I (vtable-&gt;g_type);
3313   if (node &amp;&amp; NODE_IS_IFACE (node))
3314     type_data_unref_U (node, FALSE);
3315   else
3316     g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
<span class="line-modified">3317          type_descriptive_name_I (vtable-&gt;g_type));</span>
3318 }
3319 
3320 /**
3321  * g_type_name:
3322  * @type: type to return name for
3323  *
3324  * Get the unique name that is assigned to a type ID.  Note that this
3325  * function (like all other GType API) cannot cope with invalid type
3326  * IDs. %G_TYPE_INVALID may be passed to this function, as may be any
3327  * other validly registered type ID, but randomized type IDs should
3328  * not be passed in and will most likely lead to a crash.
3329  *
3330  * Returns: static type name or %NULL
3331  */
3332 const gchar *
3333 g_type_name (GType type)
3334 {
3335   TypeNode *node;
3336 
3337   g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
3344 /**
3345  * g_type_qname:
3346  * @type: type to return quark of type name for
3347  *
3348  * Get the corresponding quark of the type IDs name.
3349  *
3350  * Returns: the type names quark or 0
3351  */
3352 GQuark
3353 g_type_qname (GType type)
3354 {
3355   TypeNode *node;
3356 
3357   node = lookup_type_node_I (type);
3358 
3359   return node ? node-&gt;qname : 0;
3360 }
3361 
3362 /**
3363  * g_type_from_name:
<span class="line-modified">3364  * @name: type name to look up</span>
3365  *
<span class="line-modified">3366  * Look up the type ID from a given type name, returning 0 if no type</span>
3367  * has been registered under this name (this is the preferred method
3368  * to find out by name whether a specific type has been registered
3369  * yet).
3370  *
3371  * Returns: corresponding type ID or 0
3372  */
3373 GType
3374 g_type_from_name (const gchar *name)
3375 {
3376   GType type = 0;
3377 
3378   g_return_val_if_fail (name != NULL, 0);
3379 
3380   G_READ_LOCK (&amp;type_rw_lock);
3381   type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);
3382   G_READ_UNLOCK (&amp;type_rw_lock);
3383 
3384   return type;
3385 }
3386 
</pre>
<hr />
<pre>
3422   return node ? node-&gt;n_supers + 1 : 0;
3423 }
3424 
3425 /**
3426  * g_type_next_base:
3427  * @leaf_type: descendant of @root_type and the type to be returned
3428  * @root_type: immediate parent of the returned type
3429  *
3430  * Given a @leaf_type and a @root_type which is contained in its
3431  * anchestry, return the type that @root_type is the immediate parent
3432  * of. In other words, this function determines the type that is
3433  * derived directly from @root_type which is also a base class of
3434  * @leaf_type.  Given a root type and a leaf type, this function can
3435  * be used to determine the types and order in which the leaf type is
3436  * descended from the root type.
3437  *
3438  * Returns: immediate child of @root_type and anchestor of @leaf_type
3439  */
3440 GType
3441 g_type_next_base (GType type,
<span class="line-modified">3442       GType base_type)</span>
3443 {
3444   GType atype = 0;
3445   TypeNode *node;
3446 
3447   node = lookup_type_node_I (type);
3448   if (node)
3449     {
3450       TypeNode *base_node = lookup_type_node_I (base_type);
3451 
3452       if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
<span class="line-modified">3453   {</span>
<span class="line-modified">3454     guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
3455 
<span class="line-modified">3456     if (node-&gt;supers[n] == base_type)</span>
<span class="line-modified">3457       atype = node-&gt;supers[n - 1];</span>
<span class="line-modified">3458   }</span>
3459     }
3460 
3461   return atype;
3462 }
3463 
3464 static inline gboolean
3465 type_node_check_conformities_UorL (TypeNode *node,
<span class="line-modified">3466            TypeNode *iface_node,</span>
<span class="line-modified">3467            /*        support_inheritance */</span>
<span class="line-modified">3468            gboolean  support_interfaces,</span>
<span class="line-modified">3469            gboolean  support_prerequisites,</span>
<span class="line-modified">3470            gboolean  have_lock)</span>
3471 {
3472   gboolean match;
3473 
3474   if (/* support_inheritance &amp;&amp; */
3475       NODE_IS_ANCESTOR (iface_node, node))
3476     return TRUE;
3477 
3478   support_interfaces = support_interfaces &amp;&amp; node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface_node);
3479   support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
3480   match = FALSE;
3481   if (support_interfaces)
3482     {
3483       if (have_lock)
<span class="line-modified">3484   {</span>
<span class="line-modified">3485     if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="line-modified">3486       match = TRUE;</span>
<span class="line-modified">3487   }</span>
3488       else
<span class="line-modified">3489   {</span>
<span class="line-modified">3490     if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="line-modified">3491       match = TRUE;</span>
<span class="line-modified">3492   }</span>
3493     }
3494   if (!match &amp;&amp;
3495       support_prerequisites)
3496     {
3497       if (!have_lock)
<span class="line-modified">3498   G_READ_LOCK (&amp;type_rw_lock);</span>
3499       if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
<span class="line-modified">3500   match = TRUE;</span>
3501       if (!have_lock)
<span class="line-modified">3502   G_READ_UNLOCK (&amp;type_rw_lock);</span>
3503     }
3504   return match;
3505 }
3506 
3507 static gboolean
3508 type_node_is_a_L (TypeNode *node,
<span class="line-modified">3509       TypeNode *iface_node)</span>
3510 {
3511   return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
3512 }
3513 
3514 static inline gboolean
3515 type_node_conforms_to_U (TypeNode *node,
<span class="line-modified">3516        TypeNode *iface_node,</span>
<span class="line-modified">3517        gboolean  support_interfaces,</span>
<span class="line-modified">3518        gboolean  support_prerequisites)</span>
3519 {
3520   return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
3521 }
3522 
3523 /**
3524  * g_type_is_a:
3525  * @type: type to check anchestry for
3526  * @is_a_type: possible anchestor of @type or interface that @type
3527  *     could conform to
3528  *
3529  * If @is_a_type is a derivable type, check whether @type is a
3530  * descendant of @is_a_type. If @is_a_type is an interface, check
3531  * whether @type conforms to it.
3532  *
3533  * Returns: %TRUE if @type is a @is_a_type
3534  */
3535 gboolean
3536 g_type_is_a (GType type,
<span class="line-modified">3537        GType iface_type)</span>
3538 {
3539   TypeNode *node, *iface_node;
3540   gboolean is_a;
3541 
3542   if (type == iface_type)
3543     return TRUE;
3544 
3545   node = lookup_type_node_I (type);
3546   iface_node = lookup_type_node_I (iface_type);
3547   is_a = node &amp;&amp; iface_node &amp;&amp; type_node_conforms_to_U (node, iface_node, TRUE, TRUE);
3548 
3549   return is_a;
3550 }
3551 
3552 /**
3553  * g_type_children:
3554  * @type: the parent type
3555  * @n_children: (out) (optional): location to store the length of
3556  *     the returned array, or %NULL
3557  *
3558  * Return a newly allocated and 0-terminated array of type IDs, listing
3559  * the child types of @type.
3560  *
3561  * Returns: (array length=n_children) (transfer full): Newly allocated
3562  *     and 0-terminated array of child types, free with g_free()
3563  */
3564 GType*
3565 g_type_children (GType  type,
<span class="line-modified">3566      guint *n_children)</span>
3567 {
3568   TypeNode *node;
3569 
3570   node = lookup_type_node_I (type);
3571   if (node)
3572     {
3573       GType *children;
3574 
3575       G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
3576       children = g_new (GType, node-&gt;n_children + 1);
3577       if (node-&gt;n_children != 0)
<span class="line-modified">3578         memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
3579       children[node-&gt;n_children] = 0;
3580 
3581       if (n_children)
<span class="line-modified">3582   *n_children = node-&gt;n_children;</span>
3583       G_READ_UNLOCK (&amp;type_rw_lock);
3584 
3585       return children;
3586     }
3587   else
3588     {
3589       if (n_children)
<span class="line-modified">3590   *n_children = 0;</span>
3591 
3592       return NULL;
3593     }
3594 }
3595 
3596 /**
3597  * g_type_interfaces:
3598  * @type: the type to list interface types for
3599  * @n_interfaces: (out) (optional): location to store the length of
3600  *     the returned array, or %NULL
3601  *
3602  * Return a newly allocated and 0-terminated array of type IDs, listing
3603  * the interface types that @type conforms to.
3604  *
3605  * Returns: (array length=n_interfaces) (transfer full): Newly allocated
3606  *     and 0-terminated array of interface types, free with g_free()
3607  */
3608 GType*
3609 g_type_interfaces (GType  type,
<span class="line-modified">3610        guint *n_interfaces)</span>
3611 {
3612   TypeNode *node;
3613 
3614   node = lookup_type_node_I (type);
3615   if (node &amp;&amp; node-&gt;is_instantiatable)
3616     {
3617       IFaceEntries *entries;
3618       GType *ifaces;
3619       guint i;
3620 
3621       G_READ_LOCK (&amp;type_rw_lock);
3622       entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
3623       if (entries)
<span class="line-modified">3624   {</span>
<span class="line-modified">3625     ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="line-modified">3626     for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="line-modified">3627       ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="line-modified">3628   }</span>
3629       else
<span class="line-modified">3630   {</span>
<span class="line-modified">3631     ifaces = g_new (GType, 1);</span>
<span class="line-modified">3632     i = 0;</span>
<span class="line-modified">3633   }</span>
3634       ifaces[i] = 0;
3635 
3636       if (n_interfaces)
<span class="line-modified">3637   *n_interfaces = i;</span>
3638       G_READ_UNLOCK (&amp;type_rw_lock);
3639 
3640       return ifaces;
3641     }
3642   else
3643     {
3644       if (n_interfaces)
<span class="line-modified">3645   *n_interfaces = 0;</span>
3646 
3647       return NULL;
3648     }
3649 }
3650 
3651 typedef struct _QData QData;
3652 struct _GData
3653 {
3654   guint  n_qdatas;
3655   QData *qdatas;
3656 };
3657 struct _QData
3658 {
3659   GQuark   quark;
3660   gpointer data;
3661 };
3662 
3663 static inline gpointer
3664 type_get_qdata_L (TypeNode *node,
<span class="line-modified">3665       GQuark    quark)</span>
3666 {
3667   GData *gdata = node-&gt;global_gdata;
3668 
3669   if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
3670     {
3671       QData *qdatas = gdata-&gt;qdatas - 1;
3672       guint n_qdatas = gdata-&gt;n_qdatas;
3673 
3674       do
<span class="line-modified">3675   {</span>
<span class="line-modified">3676     guint i;</span>
<span class="line-modified">3677     QData *check;</span>
<span class="line-modified">3678 </span>
<span class="line-modified">3679     i = (n_qdatas + 1) / 2;</span>
<span class="line-modified">3680     check = qdatas + i;</span>
<span class="line-modified">3681     if (quark == check-&gt;quark)</span>
<span class="line-modified">3682       return check-&gt;data;</span>
<span class="line-modified">3683     else if (quark &gt; check-&gt;quark)</span>
<span class="line-modified">3684       {</span>
<span class="line-modified">3685         n_qdatas -= i;</span>
<span class="line-modified">3686         qdatas = check;</span>
<span class="line-modified">3687       }</span>
<span class="line-modified">3688     else /* if (quark &lt; check-&gt;quark) */</span>
<span class="line-modified">3689       n_qdatas = i - 1;</span>
<span class="line-modified">3690   }</span>
3691       while (n_qdatas);
3692     }
3693   return NULL;
3694 }
3695 
3696 /**
3697  * g_type_get_qdata:
3698  * @type: a #GType
3699  * @quark: a #GQuark id to identify the data
3700  *
3701  * Obtains data which has previously been attached to @type
3702  * with g_type_set_qdata().
3703  *
3704  * Note that this does not take subtyping into account; data
3705  * attached to one type with g_type_set_qdata() cannot
3706  * be retrieved from a subtype using g_type_get_qdata().
3707  *
3708  * Returns: (transfer none): the data, or %NULL if no data was found
3709  */
3710 gpointer
3711 g_type_get_qdata (GType  type,
<span class="line-modified">3712       GQuark quark)</span>
3713 {
3714   TypeNode *node;
3715   gpointer data;
3716 
3717   node = lookup_type_node_I (type);
3718   if (node)
3719     {
3720       G_READ_LOCK (&amp;type_rw_lock);
3721       data = type_get_qdata_L (node, quark);
3722       G_READ_UNLOCK (&amp;type_rw_lock);
3723     }
3724   else
3725     {
3726       g_return_val_if_fail (node != NULL, NULL);
3727       data = NULL;
3728     }
3729   return data;
3730 }
3731 
3732 static inline void
3733 type_set_qdata_W (TypeNode *node,
<span class="line-modified">3734       GQuark    quark,</span>
<span class="line-modified">3735       gpointer  data)</span>
3736 {
3737   GData *gdata;
3738   QData *qdata;
3739   guint i;
3740 
3741   /* setup qdata list if necessary */
3742   if (!node-&gt;global_gdata)
3743     node-&gt;global_gdata = g_new0 (GData, 1);
3744   gdata = node-&gt;global_gdata;
3745 
3746   /* try resetting old data */
3747   qdata = gdata-&gt;qdatas;
3748   for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
3749     if (qdata[i].quark == quark)
3750       {
<span class="line-modified">3751   qdata[i].data = data;</span>
<span class="line-modified">3752   return;</span>
3753       }
3754 
3755   /* add new entry */
3756   gdata-&gt;n_qdatas++;
3757   gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
3758   qdata = gdata-&gt;qdatas;
3759   for (i = 0; i &lt; gdata-&gt;n_qdatas - 1; i++)
3760     if (qdata[i].quark &gt; quark)
3761       break;
3762   memmove (qdata + i + 1, qdata + i, sizeof (qdata[0]) * (gdata-&gt;n_qdatas - i - 1));
3763   qdata[i].quark = quark;
3764   qdata[i].data = data;
3765 }
3766 
3767 /**
3768  * g_type_set_qdata:
3769  * @type: a #GType
3770  * @quark: a #GQuark id to identify the data
3771  * @data: the data
3772  *
3773  * Attaches arbitrary data to a type.
3774  */
3775 void
3776 g_type_set_qdata (GType    type,
<span class="line-modified">3777       GQuark   quark,</span>
<span class="line-modified">3778       gpointer data)</span>
3779 {
3780   TypeNode *node;
3781 
3782   g_return_if_fail (quark != 0);
3783 
3784   node = lookup_type_node_I (type);
3785   if (node)
3786     {
3787       G_WRITE_LOCK (&amp;type_rw_lock);
3788       type_set_qdata_W (node, quark, data);
3789       G_WRITE_UNLOCK (&amp;type_rw_lock);
3790     }
3791   else
3792     g_return_if_fail (node != NULL);
3793 }
3794 
3795 static void
3796 type_add_flags_W (TypeNode  *node,
<span class="line-modified">3797       GTypeFlags flags)</span>
3798 {
3799   guint dflags;
3800 
3801   g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
3802   g_return_if_fail (node != NULL);
3803 
3804   if ((flags &amp; TYPE_FLAG_MASK) &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
3805     g_warning (&quot;tagging type &#39;%s&#39; as abstract after class initialization&quot;, NODE_NAME (node));
3806   dflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
3807   dflags |= flags;
3808   type_set_qdata_W (node, static_quark_type_flags, GUINT_TO_POINTER (dflags));
3809 }
3810 
3811 /**
3812  * g_type_query:
3813  * @type: #GType of a static, classed type
3814  * @query: (out caller-allocates): a user provided structure that is
3815  *     filled in with constant values upon success
3816  *
3817  * Queries the type system for information about a specific type.
3818  * This function will fill in a user-provided structure to hold
3819  * type-specific information. If an invalid #GType is passed in, the
3820  * @type member of the #GTypeQuery is 0. All members filled into the
3821  * #GTypeQuery structure should be considered constant and have to be
3822  * left untouched.
3823  */
3824 void
3825 g_type_query (GType       type,
<span class="line-modified">3826         GTypeQuery *query)</span>
3827 {
3828   TypeNode *node;
3829 
3830   g_return_if_fail (query != NULL);
3831 
3832   /* if node is not static and classed, we won&#39;t allow query */
3833   query-&gt;type = 0;
3834   node = lookup_type_node_I (type);
3835   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
3836     {
3837       /* type is classed and probably even instantiatable */
3838       G_READ_LOCK (&amp;type_rw_lock);
<span class="line-modified">3839       if (node-&gt;data) /* type is static or referenced */</span>
<span class="line-modified">3840   {</span>
<span class="line-modified">3841     query-&gt;type = NODE_TYPE (node);</span>
<span class="line-modified">3842     query-&gt;type_name = NODE_NAME (node);</span>
<span class="line-modified">3843     query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="line-modified">3844     query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="line-modified">3845   }</span>
3846       G_READ_UNLOCK (&amp;type_rw_lock);
3847     }
3848 }
3849 
3850 /**
3851  * g_type_get_instance_count:
3852  * @type: a #GType
3853  *
3854  * Returns the number of instances allocated of the particular type;
3855  * this is only available if GLib is built with debugging support and
3856  * the instance_count debug flag is set (by setting the GOBJECT_DEBUG
3857  * variable to include instance-count).
3858  *
3859  * Returns: the number of instances allocated of the given type;
3860  *   if instance counts are not available, returns 0.
3861  *
3862  * Since: 2.44
3863  */
3864 int
3865 g_type_get_instance_count (GType type)
3866 {
3867 #ifdef G_ENABLE_DEBUG
3868   TypeNode *node;
3869 
3870   node = lookup_type_node_I (type);
3871   g_return_val_if_fail (node != NULL, 0);
3872 
3873   return g_atomic_int_get (&amp;node-&gt;instance_count);
3874 #else
3875   return 0;
3876 #endif
3877 }
3878 
3879 /* --- implementation details --- */
3880 gboolean
3881 g_type_test_flags (GType type,
<span class="line-modified">3882        guint flags)</span>
3883 {
3884   TypeNode *node;
3885   gboolean result = FALSE;
3886 
3887   node = lookup_type_node_I (type);
3888   if (node)
3889     {
3890       guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
3891       guint tflags = flags &amp; TYPE_FLAG_MASK;
3892 
3893       if (fflags)
<span class="line-modified">3894   {</span>
<span class="line-modified">3895     GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
3896 
<span class="line-modified">3897     fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="line-modified">3898   }</span>
3899       else
<span class="line-modified">3900   fflags = TRUE;</span>
3901 
3902       if (tflags)
<span class="line-modified">3903   {</span>
<span class="line-modified">3904     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">3905     tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="line-modified">3906     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">3907   }</span>
3908       else
<span class="line-modified">3909   tflags = TRUE;</span>
3910 
3911       result = tflags &amp;&amp; fflags;
3912     }
3913 
3914   return result;
3915 }
3916 
3917 /**
3918  * g_type_get_plugin:
3919  * @type: #GType to retrieve the plugin for
3920  *
3921  * Returns the #GTypePlugin structure for @type.
3922  *
3923  * Returns: (transfer none): the corresponding plugin
3924  *     if @type is a dynamic type, %NULL otherwise
3925  */
3926 GTypePlugin*
3927 g_type_get_plugin (GType type)
3928 {
3929   TypeNode *node;
</pre>
<hr />
<pre>
3931   node = lookup_type_node_I (type);
3932 
3933   return node ? node-&gt;plugin : NULL;
3934 }
3935 
3936 /**
3937  * g_type_interface_get_plugin:
3938  * @instance_type: #GType of an instantiatable type
3939  * @interface_type: #GType of an interface type
3940  *
3941  * Returns the #GTypePlugin structure for the dynamic interface
3942  * @interface_type which has been added to @instance_type, or %NULL
3943  * if @interface_type has not been added to @instance_type or does
3944  * not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
3945  *
3946  * Returns: (transfer none): the #GTypePlugin for the dynamic
3947  *     interface @interface_type of @instance_type
3948  */
3949 GTypePlugin*
3950 g_type_interface_get_plugin (GType instance_type,
<span class="line-modified">3951            GType interface_type)</span>
3952 {
3953   TypeNode *node;
3954   TypeNode *iface;
3955 
<span class="line-modified">3956   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);  /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
3957 
3958   node = lookup_type_node_I (instance_type);
3959   iface = lookup_type_node_I (interface_type);
3960   if (node &amp;&amp; iface)
3961     {
3962       IFaceHolder *iholder;
3963       GTypePlugin *plugin;
3964 
3965       G_READ_LOCK (&amp;type_rw_lock);
3966 
3967       iholder = iface_node_get_holders_L (iface);
3968       while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
<span class="line-modified">3969   iholder = iholder-&gt;next;</span>
3970       plugin = iholder ? iholder-&gt;plugin : NULL;
3971 
3972       G_READ_UNLOCK (&amp;type_rw_lock);
3973 
3974       return plugin;
3975     }
3976 
3977   g_return_val_if_fail (node == NULL, NULL);
3978   g_return_val_if_fail (iface == NULL, NULL);
3979 
3980   g_warning (G_STRLOC &quot;: attempt to look up plugin for invalid instance/interface type pair.&quot;);
3981 
3982   return NULL;
3983 }
3984 
3985 /**
3986  * g_type_fundamental_next:
3987  *
3988  * Returns the next free fundamental type id which can be used to
3989  * register a new fundamental type with g_type_register_fundamental().
</pre>
<hr />
<pre>
4007 
4008 /**
4009  * g_type_fundamental:
4010  * @type_id: valid type ID
4011  *
4012  * Internal function, used to extract the fundamental type ID portion.
4013  * Use G_TYPE_FUNDAMENTAL() instead.
4014  *
4015  * Returns: fundamental type ID
4016  */
4017 GType
4018 g_type_fundamental (GType type_id)
4019 {
4020   TypeNode *node = lookup_type_node_I (type_id);
4021 
4022   return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
4023 }
4024 
4025 gboolean
4026 g_type_check_instance_is_a (GTypeInstance *type_instance,
<span class="line-modified">4027           GType          iface_type)</span>
4028 {
4029   TypeNode *node, *iface;
4030   gboolean check;
4031 
4032   if (!type_instance || !type_instance-&gt;g_class)
4033     return FALSE;
4034 
4035   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4036   iface = lookup_type_node_I (iface_type);
4037   check = node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4038 
4039   return check;
4040 }
4041 
4042 gboolean
4043 g_type_check_instance_is_fundamentally_a (GTypeInstance *type_instance,
4044                                           GType          fundamental_type)
4045 {
4046   TypeNode *node;
4047   if (!type_instance || !type_instance-&gt;g_class)
4048     return FALSE;
4049   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4050   return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
4051 }
4052 
4053 gboolean
4054 g_type_check_class_is_a (GTypeClass *type_class,
<span class="line-modified">4055        GType       is_a_type)</span>
4056 {
4057   TypeNode *node, *iface;
4058   gboolean check;
4059 
4060   if (!type_class)
4061     return FALSE;
4062 
4063   node = lookup_type_node_I (type_class-&gt;g_type);
4064   iface = lookup_type_node_I (is_a_type);
4065   check = node &amp;&amp; node-&gt;is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4066 
4067   return check;
4068 }
4069 
4070 GTypeInstance*
4071 g_type_check_instance_cast (GTypeInstance *type_instance,
<span class="line-modified">4072           GType          iface_type)</span>
4073 {
4074   if (type_instance)
4075     {
4076       if (type_instance-&gt;g_class)
<span class="line-modified">4077   {</span>
<span class="line-modified">4078     TypeNode *node, *iface;</span>
<span class="line-modified">4079     gboolean is_instantiatable, check;</span>
<span class="line-modified">4080 </span>
<span class="line-modified">4081     node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="line-modified">4082     is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="line-modified">4083     iface = lookup_type_node_I (iface_type);</span>
<span class="line-modified">4084     check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="line-modified">4085     if (check)</span>
<span class="line-modified">4086       return type_instance;</span>
<span class="line-modified">4087 </span>
<span class="line-modified">4088     if (is_instantiatable)</span>
<span class="line-modified">4089       g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4090            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>








4091            type_descriptive_name_I (iface_type));
<span class="line-added">4092     else</span>
<span class="line-added">4093       g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="line-added">4094            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-added">4095            type_descriptive_name_I (iface_type));</span>
<span class="line-added">4096   }</span>
<span class="line-added">4097       else</span>
<span class="line-added">4098   g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
<span class="line-added">4099        type_descriptive_name_I (iface_type));</span>
4100     }
4101 
4102   return type_instance;
4103 }
4104 
4105 GTypeClass*
4106 g_type_check_class_cast (GTypeClass *type_class,
<span class="line-modified">4107        GType       is_a_type)</span>
4108 {
4109   if (type_class)
4110     {
4111       TypeNode *node, *iface;
4112       gboolean is_classed, check;
4113 
4114       node = lookup_type_node_I (type_class-&gt;g_type);
4115       is_classed = node &amp;&amp; node-&gt;is_classed;
4116       iface = lookup_type_node_I (is_a_type);
4117       check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4118       if (check)
<span class="line-modified">4119   return type_class;</span>
4120 
4121       if (is_classed)
<span class="line-modified">4122   g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4123        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">4124        type_descriptive_name_I (is_a_type));</span>
4125       else
<span class="line-modified">4126   g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="line-modified">4127        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">4128        type_descriptive_name_I (is_a_type));</span>
4129     }
4130   else
4131     g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
<span class="line-modified">4132          type_descriptive_name_I (is_a_type));</span>
4133   return type_class;
4134 }
4135 
4136 /**
4137  * g_type_check_instance:
4138  * @instance: a valid #GTypeInstance structure
4139  *
4140  * Private helper function to aid implementation of the
4141  * G_TYPE_CHECK_INSTANCE() macro.
4142  *
4143  * Returns: %TRUE if @instance is valid, %FALSE otherwise
4144  */
4145 gboolean
4146 g_type_check_instance (GTypeInstance *type_instance)
4147 {
4148   /* this function is just here to make the signal system
4149    * conveniently elaborated on instance checks
4150    */
4151   if (type_instance)
4152     {
4153       if (type_instance-&gt;g_class)
<span class="line-modified">4154   {</span>
<span class="line-modified">4155     TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
4156 
<span class="line-modified">4157     if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="line-modified">4158       return TRUE;</span>
4159 
<span class="line-modified">4160     g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">4161          type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="line-modified">4162   }</span>
4163       else
<span class="line-modified">4164   g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
4165     }
4166   else
4167     g_warning (&quot;invalid (NULL) pointer instance&quot;);
4168 
4169   return FALSE;
4170 }
4171 
4172 static inline gboolean
4173 type_check_is_value_type_U (GType type)
4174 {
4175   GTypeFlags tflags = G_TYPE_FLAG_VALUE_ABSTRACT;
4176   TypeNode *node;
4177 
4178   /* common path speed up */
4179   node = lookup_type_node_I (type);
4180   if (node &amp;&amp; node-&gt;mutatable_check_cache)
4181     return TRUE;
4182 
4183   G_READ_LOCK (&amp;type_rw_lock);
4184  restart_check:
4185   if (node)
4186     {
4187       if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
<span class="line-modified">4188     node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="line-modified">4189   tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
4190       else if (NODE_IS_IFACE (node))
<span class="line-modified">4191   {</span>
<span class="line-modified">4192     guint i;</span>
4193 
<span class="line-modified">4194     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">4195       {</span>
<span class="line-modified">4196         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">4197         TypeNode *prnode = lookup_type_node_I (prtype);</span>
4198 
<span class="line-modified">4199         if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">4200     {</span>
<span class="line-modified">4201       type = prtype;</span>
<span class="line-modified">4202       node = lookup_type_node_I (type);</span>
<span class="line-modified">4203       goto restart_check;</span>


4204     }
<span class="line-added">4205       }</span>
<span class="line-added">4206   }</span>
4207     }
4208   G_READ_UNLOCK (&amp;type_rw_lock);
4209 
4210   return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
4211 }
4212 
4213 gboolean
4214 g_type_check_is_value_type (GType type)
4215 {
4216   return type_check_is_value_type_U (type);
4217 }
4218 
4219 gboolean
4220 g_type_check_value (const GValue *value)
4221 {
4222   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
4223 }
4224 
4225 gboolean
4226 g_type_check_value_holds (const GValue *value,
<span class="line-modified">4227         GType         type)</span>
4228 {
4229   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
4230 }
4231 
4232 /**
4233  * g_type_value_table_peek: (skip)
4234  * @type: a #GType
4235  *
4236  * Returns the location of the #GTypeValueTable associated with @type.
4237  *
4238  * Note that this function should only be used from source code
4239  * that implements or has internal knowledge of the implementation of
4240  * @type.
4241  *
4242  * Returns: location of the #GTypeValueTable associated with @type or
4243  *     %NULL if there is no #GTypeValueTable associated with @type
4244  */
4245 GTypeValueTable*
4246 g_type_value_table_peek (GType type)
4247 {
4248   GTypeValueTable *vtable = NULL;
4249   TypeNode *node = lookup_type_node_I (type);
4250   gboolean has_refed_data, has_table;
4251 
4252   if (node &amp;&amp; NODE_REFCOUNT (node) &amp;&amp; node-&gt;mutatable_check_cache)
4253     return node-&gt;data-&gt;common.value_table;
4254 
4255   G_READ_LOCK (&amp;type_rw_lock);
4256 
4257  restart_table_peek:
4258   has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
4259   has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
4260   if (has_refed_data)
4261     {
4262       if (has_table)
<span class="line-modified">4263   vtable = node-&gt;data-&gt;common.value_table;</span>
4264       else if (NODE_IS_IFACE (node))
<span class="line-modified">4265   {</span>
<span class="line-modified">4266     guint i;</span>
4267 
<span class="line-modified">4268     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">4269       {</span>
<span class="line-modified">4270         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">4271         TypeNode *prnode = lookup_type_node_I (prtype);</span>
4272 
<span class="line-modified">4273         if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">4274     {</span>
<span class="line-modified">4275       type = prtype;</span>
<span class="line-modified">4276       node = lookup_type_node_I (type);</span>
<span class="line-modified">4277       goto restart_table_peek;</span>


4278     }
<span class="line-added">4279       }</span>
<span class="line-added">4280   }</span>
4281     }
4282 
4283   G_READ_UNLOCK (&amp;type_rw_lock);
4284 
4285   if (vtable)
4286     return vtable;
4287 
4288   if (!node)
4289     g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
4290   if (!has_refed_data)
4291     g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
<span class="line-modified">4292          type_descriptive_name_I (type));</span>
4293 
4294   return NULL;
4295 }
4296 
4297 const gchar *
4298 g_type_name_from_instance (GTypeInstance *instance)
4299 {
4300   if (!instance)
4301     return &quot;&lt;NULL-instance&gt;&quot;;
4302   else
4303     return g_type_name_from_class (instance-&gt;g_class);
4304 }
4305 
4306 const gchar *
4307 g_type_name_from_class (GTypeClass *g_class)
4308 {
4309   if (!g_class)
4310     return &quot;&lt;NULL-class&gt;&quot;;
4311   else
4312     return g_type_name (g_class-&gt;g_type);
</pre>
<hr />
<pre>
4339 
4340   node-&gt;data-&gt;boxed.copy_func = copy_func;
4341   node-&gt;data-&gt;boxed.free_func = free_func;
4342 }
4343 
4344 /* --- initialization --- */
4345 /**
4346  * g_type_init_with_debug_flags:
4347  * @debug_flags: bitwise combination of #GTypeDebugFlags values for
4348  *     debugging purposes
4349  *
4350  * This function used to initialise the type system with debugging
4351  * flags.  Since GLib 2.36, the type system is initialised automatically
4352  * and this function does nothing.
4353  *
4354  * If you need to enable debugging features, use the GOBJECT_DEBUG
4355  * environment variable.
4356  *
4357  * Deprecated: 2.36: the type system is now initialised automatically
4358  */
<span class="line-added">4359 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
4360 void
4361 g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
4362 {
4363   g_assert_type_system_initialized ();
4364 
4365   if (debug_flags)
4366     g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
4367 }
<span class="line-added">4368 G_GNUC_END_IGNORE_DEPRECATIONS</span>
4369 
4370 /**
4371  * g_type_init:
4372  *
4373  * This function used to initialise the type system.  Since GLib 2.36,
4374  * the type system is initialised automatically and this function does
4375  * nothing.
4376  *
4377  * Deprecated: 2.36: the type system is now initialised automatically
4378  */
4379 #if !(defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32))
4380 void
4381 g_type_init (void)
4382 {
4383   g_assert_type_system_initialized ();
4384 }
4385 #endif // GSTREAMER_LITE
4386 
4387 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
4388 // We cannot due static initialization, since it will crash due to
4389 // threading system is not initialized yet.
4390 static void gobject_init (void);
4391 void
4392 g_type_init (void)
4393 {
4394   gobject_init ();
4395 }
4396 #endif // GSTREAMER_LITE
4397 
4398 static void
4399 gobject_init (void)
4400 {
4401   const gchar *env_string;
4402   GTypeInfo info;
4403   TypeNode *node;
<span class="line-modified">4404   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
4405 
4406   /* Ensure GLib is initialized first, see
4407    * https://bugzilla.gnome.org/show_bug.cgi?id=756139
4408    */
4409   GLIB_PRIVATE_CALL (glib_init) ();
4410 
4411   G_WRITE_LOCK (&amp;type_rw_lock);
4412 
4413   /* setup GObject library wide debugging flags */
4414   env_string = g_getenv (&quot;GOBJECT_DEBUG&quot;);
4415   if (env_string != NULL)
4416     {
4417       GDebugKey debug_keys[] = {
4418         { &quot;objects&quot;, G_TYPE_DEBUG_OBJECTS },
4419         { &quot;instance-count&quot;, G_TYPE_DEBUG_INSTANCE_COUNT },
4420         { &quot;signals&quot;, G_TYPE_DEBUG_SIGNALS },
4421       };
4422 
4423       _g_type_debug_flags = g_parse_debug_string (env_string, debug_keys, G_N_ELEMENTS (debug_keys));
4424     }
</pre>
<hr />
<pre>
4591  *
4592  * static int
4593  * my_object_get_some_field (MyObject *my_object)
4594  * {
4595  *   MyObjectPrivate *priv;
4596  *
4597  *   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
4598  *
4599  *   priv = my_object-&gt;priv;
4600  *
4601  *   return priv-&gt;some_field;
4602  * }
4603  * ]|
4604  *
4605  * Since: 2.4
4606  * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
4607  *   family of macros to add instance private data to a type
4608  */
4609 void
4610 g_type_class_add_private (gpointer g_class,
<span class="line-modified">4611         gsize    private_size)</span>
4612 {
4613   GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
4614   TypeNode *node = lookup_type_node_I (instance_type);
4615 
4616   g_return_if_fail (private_size &gt; 0);
4617   g_return_if_fail (private_size &lt;= 0xffff);
4618 
4619   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
4620     {
4621       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4622      type_descriptive_name_I (instance_type));</span>
4623       return;
4624     }
4625 
4626   if (NODE_PARENT_TYPE (node))
4627     {
4628       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4629       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">4630   {</span>
<span class="line-modified">4631     g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">4632     return;</span>
<span class="line-modified">4633   }</span>
4634     }
4635 
4636   G_WRITE_LOCK (&amp;type_rw_lock);
4637 
4638   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
4639   g_assert (private_size &lt;= 0xffff);
4640   node-&gt;data-&gt;instance.private_size = private_size;
4641 
4642   G_WRITE_UNLOCK (&amp;type_rw_lock);
4643 }
4644 
4645 /* semi-private, called only by the G_ADD_PRIVATE macro */
4646 gint
4647 g_type_add_instance_private (GType class_gtype,
4648                              gsize private_size)
4649 {
4650   TypeNode *node = lookup_type_node_I (class_gtype);
4651 
4652   g_return_val_if_fail (private_size &gt; 0, 0);
4653   g_return_val_if_fail (private_size &lt;= 0xffff, 0);
4654 
4655   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4656     {
4657       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4658      type_descriptive_name_I (class_gtype));</span>
4659       return 0;
4660     }
4661 
4662   if (node-&gt;plugin != NULL)
4663     {
4664       g_warning (&quot;cannot use g_type_add_instance_private() with dynamic type &#39;%s&#39;&quot;,
4665                  type_descriptive_name_I (class_gtype));
4666       return 0;
4667     }
4668 
4669   /* in the future, we want to register the private data size of a type
4670    * directly from the get_type() implementation so that we can take full
4671    * advantage of the type definition macros that we already have.
4672    *
4673    * unfortunately, this does not behave correctly if a class in the middle
4674    * of the type hierarchy uses the &quot;old style&quot; of private data registration
4675    * from the class_init() implementation, as the private data offset is not
4676    * going to be known until the full class hierarchy is initialized.
4677    *
4678    * in order to transition our code to the Glorious New Future(TM), we proceed
</pre>
<hr />
<pre>
4705                                     gint     *private_size_or_offset)
4706 {
4707   GType class_gtype = ((GTypeClass *) g_class)-&gt;g_type;
4708   TypeNode *node = lookup_type_node_I (class_gtype);
4709   gssize private_size;
4710 
4711   g_return_if_fail (private_size_or_offset != NULL);
4712 
4713   /* if we have been passed the offset instead of the private data size,
4714    * then we consider this as a no-op, and just return the value. see the
4715    * comment in g_type_add_instance_private() for the full explanation.
4716    */
4717   if (*private_size_or_offset &gt; 0)
4718     g_return_if_fail (*private_size_or_offset &lt;= 0xffff);
4719   else
4720     return;
4721 
4722   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4723     {
4724       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">4725      type_descriptive_name_I (class_gtype));</span>
4726       *private_size_or_offset = 0;
4727       return;
4728     }
4729 
4730   if (NODE_PARENT_TYPE (node))
4731     {
4732       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4733       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">4734   {</span>
<span class="line-modified">4735     g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
4736           *private_size_or_offset = 0;
<span class="line-modified">4737     return;</span>
<span class="line-modified">4738   }</span>
4739     }
4740 
4741   G_WRITE_LOCK (&amp;type_rw_lock);
4742 
4743   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
4744   g_assert (private_size &lt;= 0xffff);
4745   node-&gt;data-&gt;instance.private_size = private_size;
4746 
4747   *private_size_or_offset = -(gint) node-&gt;data-&gt;instance.private_size;
4748 
4749   G_WRITE_UNLOCK (&amp;type_rw_lock);
4750 }
4751 
4752 gpointer
4753 g_type_instance_get_private (GTypeInstance *instance,
<span class="line-modified">4754            GType          private_type)</span>
4755 {
4756   TypeNode *node;
4757 
4758   g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
4759 
4760   node = lookup_type_node_I (private_type);
4761   if (G_UNLIKELY (!node || !node-&gt;is_instantiatable))
4762     {
4763       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4764                  type_descriptive_name_I (instance-&gt;g_class-&gt;g_type));
4765       return NULL;
4766     }
4767 
4768   return ((gchar *) instance) - node-&gt;data-&gt;instance.private_size;
4769 }
4770 
4771 /**
4772  * g_type_class_get_instance_private_offset: (skip)
4773  * @g_class: (type GObject.TypeClass): a #GTypeClass
4774  *
</pre>
<hr />
<pre>
4801   g_assert (node-&gt;is_instantiatable);
4802 
4803   if (NODE_PARENT_TYPE (node))
4804     {
4805       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4806 
4807       parent_size = pnode-&gt;data-&gt;instance.private_size;
4808     }
4809   else
4810     parent_size = 0;
4811 
4812   if (node-&gt;data-&gt;instance.private_size == parent_size)
4813     g_error (&quot;g_type_class_get_instance_private_offset() called on class %s but it has no private data&quot;,
4814              g_type_name (instance_type));
4815 
4816   return -(gint) node-&gt;data-&gt;instance.private_size;
4817 }
4818 
4819 /**
4820  * g_type_add_class_private:
<span class="line-modified">4821  * @class_type: GType of a classed type</span>
4822  * @private_size: size of private structure
4823  *
4824  * Registers a private class structure for a classed type;
4825  * when the class is allocated, the private structures for
4826  * the class and all of its parent types are allocated
4827  * sequentially in the same memory block as the public
4828  * structures, and are zero-filled.
4829  *
4830  * This function should be called in the
4831  * type&#39;s get_type() function after the type is registered.
4832  * The private structure can be retrieved using the
4833  * G_TYPE_CLASS_GET_PRIVATE() macro.
4834  *
4835  * Since: 2.24
4836  */
4837 void
4838 g_type_add_class_private (GType    class_type,
<span class="line-modified">4839         gsize    private_size)</span>
4840 {
4841   TypeNode *node = lookup_type_node_I (class_type);
4842   gsize offset;
4843 
4844   g_return_if_fail (private_size &gt; 0);
4845 
4846   if (!node || !node-&gt;is_classed || !node-&gt;data)
4847     {
4848       g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4849      type_descriptive_name_I (class_type));</span>
4850       return;
4851     }
4852 
4853   if (NODE_PARENT_TYPE (node))
4854     {
4855       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4856       if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
<span class="line-modified">4857   {</span>
<span class="line-modified">4858     g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">4859     return;</span>
<span class="line-modified">4860   }</span>
4861     }
4862 
4863   G_WRITE_LOCK (&amp;type_rw_lock);
4864 
4865   offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
4866   node-&gt;data-&gt;class.class_private_size = offset + private_size;
4867 
4868   G_WRITE_UNLOCK (&amp;type_rw_lock);
4869 }
4870 
4871 gpointer
4872 g_type_class_get_private (GTypeClass *klass,
<span class="line-modified">4873         GType       private_type)</span>
4874 {
4875   TypeNode *class_node;
4876   TypeNode *private_node;
4877   TypeNode *parent_node;
4878   gsize offset;
4879 
4880   g_return_val_if_fail (klass != NULL, NULL);
4881 
4882   class_node = lookup_type_node_I (klass-&gt;g_type);
4883   if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
4884     {
4885       g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4886      type_descriptive_name_I (klass-&gt;g_type));</span>
4887       return NULL;
4888     }
4889 
4890   private_node = lookup_type_node_I (private_type);
4891   if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
4892     {
4893       g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
<span class="line-modified">4894      type_descriptive_name_I (private_type));</span>
4895       return NULL;
4896     }
4897 
4898   offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
4899 
4900   if (NODE_PARENT_TYPE (private_node))
4901     {
4902       parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
4903       g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
4904 
4905       if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
<span class="line-modified">4906   {</span>
<span class="line-modified">4907     g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="line-modified">4908     return NULL;</span>
<span class="line-modified">4909   }</span>
4910 
4911       offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
4912     }
4913 
4914   return G_STRUCT_MEMBER_P (klass, offset);
4915 }
4916 
4917 /**
4918  * g_type_ensure:
4919  * @type: a #GType
4920  *
4921  * Ensures that the indicated @type has been registered with the
4922  * type system, and its _class_init() method has been run.
4923  *
4924  * In theory, simply calling the type&#39;s _get_type() method (or using
4925  * the corresponding macro) is supposed take care of this. However,
4926  * _get_type() methods are often marked %G_GNUC_CONST for performance
4927  * reasons, even though this is technically incorrect (since
4928  * %G_GNUC_CONST requires that the function not have side effects,
4929  * which _get_type() methods do on the first call). As a result, if
</pre>
</td>
</tr>
</table>
<center><a href="gtype-private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>