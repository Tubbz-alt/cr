<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/guniprop.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* guniprop.c - Unicode character properties.
   2  *
   3  * Copyright (C) 1999 Tom Tromey
   4  * Copyright (C) 2000 Red Hat, Inc.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public
  17  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
  23 #include &lt;stddef.h&gt;
  24 #include &lt;string.h&gt;
  25 #include &lt;locale.h&gt;
  26 
  27 #include &quot;gmem.h&quot;
  28 #include &quot;gstring.h&quot;
  29 #include &quot;gtestutils.h&quot;
  30 #include &quot;gtypes.h&quot;
  31 #include &quot;gunicode.h&quot;
  32 #include &quot;gunichartables.h&quot;
  33 #include &quot;gmirroringtable.h&quot;
  34 #include &quot;gscripttable.h&quot;
  35 #include &quot;gunicodeprivate.h&quot;
  36 #ifdef G_OS_WIN32
  37 #include &quot;gwin32.h&quot;
  38 #endif
  39 
<a name="1" id="anc1"></a><span class="line-added">  40 #define G_UNICHAR_FULLWIDTH_A 0xff21</span>
<span class="line-added">  41 #define G_UNICHAR_FULLWIDTH_I 0xff29</span>
<span class="line-added">  42 #define G_UNICHAR_FULLWIDTH_J 0xff2a</span>
<span class="line-added">  43 #define G_UNICHAR_FULLWIDTH_F 0xff26</span>
<span class="line-added">  44 #define G_UNICHAR_FULLWIDTH_a 0xff41</span>
<span class="line-added">  45 #define G_UNICHAR_FULLWIDTH_f 0xff46</span>
<span class="line-added">  46 </span>
  47 #define ATTR_TABLE(Page) (((Page) &lt;= G_UNICODE_LAST_PAGE_PART1) \
  48                           ? attr_table_part1[Page] \
  49                           : attr_table_part2[(Page) - 0xe00])
  50 
  51 #define ATTTABLE(Page, Char) \
  52   ((ATTR_TABLE(Page) == G_UNICODE_MAX_TABLE_INDEX) ? 0 : (attr_data[ATTR_TABLE(Page)][Char]))
  53 
  54 #define TTYPE_PART1(Page, Char) \
  55   ((type_table_part1[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  56    ? (type_table_part1[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  57    : (type_data[type_table_part1[Page]][Char]))
  58 
  59 #define TTYPE_PART2(Page, Char) \
  60   ((type_table_part2[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  61    ? (type_table_part2[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  62    : (type_data[type_table_part2[Page]][Char]))
  63 
  64 #define TYPE(Char) \
  65   (((Char) &lt;= G_UNICODE_LAST_CHAR_PART1) \
  66    ? TTYPE_PART1 ((Char) &gt;&gt; 8, (Char) &amp; 0xff) \
  67    : (((Char) &gt;= 0xe0000 &amp;&amp; (Char) &lt;= G_UNICODE_LAST_CHAR) \
  68       ? TTYPE_PART2 (((Char) - 0xe0000) &gt;&gt; 8, (Char) &amp; 0xff) \
  69       : G_UNICODE_UNASSIGNED))
  70 
  71 
  72 #define IS(Type, Class) (((guint)1 &lt;&lt; (Type)) &amp; (Class))
  73 #define OR(Type, Rest)  (((guint)1 &lt;&lt; (Type)) | (Rest))
  74 
  75 
  76 
<a name="2" id="anc2"></a><span class="line-modified">  77 #define ISALPHA(Type) IS ((Type),       \</span>
<span class="line-modified">  78           OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  79           OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  80           OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  81           OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  82           OR (G_UNICODE_OTHER_LETTER,   0))))))</span>
  83 
<a name="3" id="anc3"></a><span class="line-modified">  84 #define ISALDIGIT(Type) IS ((Type),       \</span>
<span class="line-modified">  85           OR (G_UNICODE_DECIMAL_NUMBER, \</span>
<span class="line-modified">  86           OR (G_UNICODE_LETTER_NUMBER,  \</span>
<span class="line-modified">  87           OR (G_UNICODE_OTHER_NUMBER,   \</span>
<span class="line-modified">  88           OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  89           OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  90           OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  91           OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  92           OR (G_UNICODE_OTHER_LETTER,   0)))))))))</span>
  93 
<a name="4" id="anc4"></a><span class="line-modified">  94 #define ISMARK(Type)  IS ((Type),       \</span>
<span class="line-modified">  95           OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  96           OR (G_UNICODE_SPACING_MARK, \</span>
<span class="line-modified">  97           OR (G_UNICODE_ENCLOSING_MARK, 0))))</span>
  98 
<a name="5" id="anc5"></a><span class="line-modified">  99 #define ISZEROWIDTHTYPE(Type) IS ((Type),     \</span>
<span class="line-modified"> 100           OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified"> 101           OR (G_UNICODE_ENCLOSING_MARK, \</span>
<span class="line-modified"> 102           OR (G_UNICODE_FORMAT,   0))))</span>
 103 
 104 /**
 105  * g_unichar_isalnum:
 106  * @c: a Unicode character
 107  *
 108  * Determines whether a character is alphanumeric.
 109  * Given some UTF-8 text, obtain a character value
 110  * with g_utf8_get_char().
 111  *
 112  * Returns: %TRUE if @c is an alphanumeric character
 113  **/
 114 gboolean
 115 g_unichar_isalnum (gunichar c)
 116 {
 117   return ISALDIGIT (TYPE (c)) ? TRUE : FALSE;
 118 }
 119 
 120 /**
 121  * g_unichar_isalpha:
 122  * @c: a Unicode character
 123  *
 124  * Determines whether a character is alphabetic (i.e. a letter).
 125  * Given some UTF-8 text, obtain a character value with
 126  * g_utf8_get_char().
 127  *
 128  * Returns: %TRUE if @c is an alphabetic character
 129  **/
 130 gboolean
 131 g_unichar_isalpha (gunichar c)
 132 {
 133   return ISALPHA (TYPE (c)) ? TRUE : FALSE;
 134 }
 135 
 136 
 137 /**
 138  * g_unichar_iscntrl:
 139  * @c: a Unicode character
 140  *
 141  * Determines whether a character is a control character.
 142  * Given some UTF-8 text, obtain a character value with
 143  * g_utf8_get_char().
 144  *
 145  * Returns: %TRUE if @c is a control character
 146  **/
 147 gboolean
 148 g_unichar_iscntrl (gunichar c)
 149 {
 150   return TYPE (c) == G_UNICODE_CONTROL;
 151 }
 152 
 153 /**
 154  * g_unichar_isdigit:
 155  * @c: a Unicode character
 156  *
 157  * Determines whether a character is numeric (i.e. a digit).  This
 158  * covers ASCII 0-9 and also digits in other languages/scripts.  Given
 159  * some UTF-8 text, obtain a character value with g_utf8_get_char().
 160  *
 161  * Returns: %TRUE if @c is a digit
 162  **/
 163 gboolean
 164 g_unichar_isdigit (gunichar c)
 165 {
 166   return TYPE (c) == G_UNICODE_DECIMAL_NUMBER;
 167 }
 168 
 169 
 170 /**
 171  * g_unichar_isgraph:
 172  * @c: a Unicode character
 173  *
 174  * Determines whether a character is printable and not a space
 175  * (returns %FALSE for control characters, format characters, and
 176  * spaces). g_unichar_isprint() is similar, but returns %TRUE for
 177  * spaces. Given some UTF-8 text, obtain a character value with
 178  * g_utf8_get_char().
 179  *
 180  * Returns: %TRUE if @c is printable unless it&#39;s a space
 181  **/
 182 gboolean
 183 g_unichar_isgraph (gunichar c)
 184 {
 185   return !IS (TYPE(c),
<a name="6" id="anc6"></a><span class="line-modified"> 186         OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 187         OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 188         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 189         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 190         OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 191        0))))));</span>
 192 }
 193 
 194 /**
 195  * g_unichar_islower:
 196  * @c: a Unicode character
 197  *
 198  * Determines whether a character is a lowercase letter.
 199  * Given some UTF-8 text, obtain a character value with
 200  * g_utf8_get_char().
 201  *
 202  * Returns: %TRUE if @c is a lowercase letter
 203  **/
 204 gboolean
 205 g_unichar_islower (gunichar c)
 206 {
 207   return TYPE (c) == G_UNICODE_LOWERCASE_LETTER;
 208 }
 209 
 210 
 211 /**
 212  * g_unichar_isprint:
 213  * @c: a Unicode character
 214  *
 215  * Determines whether a character is printable.
 216  * Unlike g_unichar_isgraph(), returns %TRUE for spaces.
 217  * Given some UTF-8 text, obtain a character value with
 218  * g_utf8_get_char().
 219  *
 220  * Returns: %TRUE if @c is printable
 221  **/
 222 gboolean
 223 g_unichar_isprint (gunichar c)
 224 {
 225   return !IS (TYPE(c),
<a name="7" id="anc7"></a><span class="line-modified"> 226         OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 227         OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 228         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 229         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 230        0)))));</span>
 231 }
 232 
 233 /**
 234  * g_unichar_ispunct:
 235  * @c: a Unicode character
 236  *
 237  * Determines whether a character is punctuation or a symbol.
 238  * Given some UTF-8 text, obtain a character value with
 239  * g_utf8_get_char().
 240  *
 241  * Returns: %TRUE if @c is a punctuation or symbol character
 242  **/
 243 gboolean
 244 g_unichar_ispunct (gunichar c)
 245 {
 246   return IS (TYPE(c),
<a name="8" id="anc8"></a><span class="line-modified"> 247        OR (G_UNICODE_CONNECT_PUNCTUATION,</span>
<span class="line-modified"> 248        OR (G_UNICODE_DASH_PUNCTUATION,</span>
<span class="line-modified"> 249        OR (G_UNICODE_CLOSE_PUNCTUATION,</span>
<span class="line-modified"> 250        OR (G_UNICODE_FINAL_PUNCTUATION,</span>
<span class="line-modified"> 251        OR (G_UNICODE_INITIAL_PUNCTUATION,</span>
<span class="line-modified"> 252        OR (G_UNICODE_OTHER_PUNCTUATION,</span>
<span class="line-modified"> 253        OR (G_UNICODE_OPEN_PUNCTUATION,</span>
<span class="line-modified"> 254        OR (G_UNICODE_CURRENCY_SYMBOL,</span>
<span class="line-modified"> 255        OR (G_UNICODE_MODIFIER_SYMBOL,</span>
<span class="line-modified"> 256        OR (G_UNICODE_MATH_SYMBOL,</span>
<span class="line-modified"> 257        OR (G_UNICODE_OTHER_SYMBOL,</span>
<span class="line-modified"> 258       0)))))))))))) ? TRUE : FALSE;</span>
 259 }
 260 
 261 /**
 262  * g_unichar_isspace:
 263  * @c: a Unicode character
 264  *
 265  * Determines whether a character is a space, tab, or line separator
 266  * (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
 267  * character value with g_utf8_get_char().
 268  *
 269  * (Note: don&#39;t use this to do word breaking; you have to use
 270  * Pango or equivalent to get word breaking right, the algorithm
 271  * is fairly complex.)
 272  *
 273  * Returns: %TRUE if @c is a space character
 274  **/
 275 gboolean
 276 g_unichar_isspace (gunichar c)
 277 {
 278   switch (c)
 279     {
 280       /* special-case these since Unicode thinks they are not spaces */
 281     case &#39;\t&#39;:
 282     case &#39;\n&#39;:
 283     case &#39;\r&#39;:
 284     case &#39;\f&#39;:
 285       return TRUE;
 286       break;
 287 
 288     default:
 289       {
<a name="9" id="anc9"></a><span class="line-modified"> 290   return IS (TYPE(c),</span>
<span class="line-modified"> 291              OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 292              OR (G_UNICODE_LINE_SEPARATOR,</span>
 293                    OR (G_UNICODE_PARAGRAPH_SEPARATOR,
<a name="10" id="anc10"></a><span class="line-modified"> 294       0)))) ? TRUE : FALSE;</span>
 295       }
 296       break;
 297     }
 298 }
 299 
 300 /**
 301  * g_unichar_ismark:
 302  * @c: a Unicode character
 303  *
 304  * Determines whether a character is a mark (non-spacing mark,
 305  * combining mark, or enclosing mark in Unicode speak).
 306  * Given some UTF-8 text, obtain a character value
 307  * with g_utf8_get_char().
 308  *
 309  * Note: in most cases where isalpha characters are allowed,
 310  * ismark characters should be allowed to as they are essential
 311  * for writing most European languages as well as many non-Latin
 312  * scripts.
 313  *
 314  * Returns: %TRUE if @c is a mark character
 315  *
 316  * Since: 2.14
 317  **/
 318 gboolean
 319 g_unichar_ismark (gunichar c)
 320 {
 321   return ISMARK (TYPE (c));
 322 }
 323 
 324 /**
 325  * g_unichar_isupper:
 326  * @c: a Unicode character
 327  *
 328  * Determines if a character is uppercase.
 329  *
 330  * Returns: %TRUE if @c is an uppercase character
 331  **/
 332 gboolean
 333 g_unichar_isupper (gunichar c)
 334 {
 335   return TYPE (c) == G_UNICODE_UPPERCASE_LETTER;
 336 }
 337 
 338 /**
 339  * g_unichar_istitle:
 340  * @c: a Unicode character
 341  *
 342  * Determines if a character is titlecase. Some characters in
 343  * Unicode which are composites, such as the DZ digraph
 344  * have three case variants instead of just two. The titlecase
 345  * form is used at the beginning of a word where only the
 346  * first letter is capitalized. The titlecase form of the DZ
 347  * digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
 348  *
 349  * Returns: %TRUE if the character is titlecase
 350  **/
 351 gboolean
 352 g_unichar_istitle (gunichar c)
 353 {
 354   unsigned int i;
 355   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 356     if (title_table[i][0] == c)
 357       return TRUE;
 358   return FALSE;
 359 }
 360 
 361 /**
 362  * g_unichar_isxdigit:
 363  * @c: a Unicode character.
 364  *
 365  * Determines if a character is a hexidecimal digit.
 366  *
 367  * Returns: %TRUE if the character is a hexadecimal digit
 368  **/
 369 gboolean
 370 g_unichar_isxdigit (gunichar c)
 371 {
<a name="11" id="anc11"></a><span class="line-modified"> 372   return ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) ||</span>
<span class="line-modified"> 373           (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) ||</span>
<span class="line-modified"> 374           (c &gt;= G_UNICHAR_FULLWIDTH_a &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_f) ||</span>
<span class="line-added"> 375           (c &gt;= G_UNICHAR_FULLWIDTH_A &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_F) ||</span>
<span class="line-added"> 376           (TYPE (c) == G_UNICODE_DECIMAL_NUMBER));</span>
 377 }
 378 
 379 /**
 380  * g_unichar_isdefined:
 381  * @c: a Unicode character
 382  *
 383  * Determines if a given character is assigned in the Unicode
 384  * standard.
 385  *
 386  * Returns: %TRUE if the character has an assigned value
 387  **/
 388 gboolean
 389 g_unichar_isdefined (gunichar c)
 390 {
 391   return !IS (TYPE(c),
<a name="12" id="anc12"></a><span class="line-modified"> 392         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 393         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 394        0)));</span>
 395 }
 396 
 397 /**
 398  * g_unichar_iszerowidth:
 399  * @c: a Unicode character
 400  *
 401  * Determines if a given character typically takes zero width when rendered.
 402  * The return value is %TRUE for all non-spacing and enclosing marks
 403  * (e.g., combining accents), format characters, zero-width
 404  * space, but not U+00AD SOFT HYPHEN.
 405  *
 406  * A typical use of this function is with one of g_unichar_iswide() or
 407  * g_unichar_iswide_cjk() to determine the number of cells a string occupies
 408  * when displayed on a grid display (terminals).  However, note that not all
 409  * terminals support zero-width rendering of zero-width marks.
 410  *
 411  * Returns: %TRUE if the character has zero width
 412  *
 413  * Since: 2.14
 414  **/
 415 gboolean
 416 g_unichar_iszerowidth (gunichar c)
 417 {
 418   if (G_UNLIKELY (c == 0x00AD))
 419     return FALSE;
 420 
 421   if (G_UNLIKELY (ISZEROWIDTHTYPE (TYPE (c))))
 422     return TRUE;
 423 
 424   if (G_UNLIKELY ((c &gt;= 0x1160 &amp;&amp; c &lt; 0x1200) ||
<a name="13" id="anc13"></a><span class="line-modified"> 425       c == 0x200B))</span>
 426     return TRUE;
 427 
 428   return FALSE;
 429 }
 430 
 431 static int
 432 interval_compare (const void *key, const void *elt)
 433 {
 434   gunichar c = GPOINTER_TO_UINT (key);
 435   struct Interval *interval = (struct Interval *)elt;
 436 
 437   if (c &lt; interval-&gt;start)
 438     return -1;
 439   if (c &gt; interval-&gt;end)
 440     return +1;
 441 
 442   return 0;
 443 }
 444 
 445 #define G_WIDTH_TABLE_MIDPOINT (G_N_ELEMENTS (g_unicode_width_table_wide) / 2)
 446 
 447 static inline gboolean
 448 g_unichar_iswide_bsearch (gunichar ch)
 449 {
 450   int lower = 0;
 451   int upper = G_N_ELEMENTS (g_unicode_width_table_wide) - 1;
 452   static int saved_mid = G_WIDTH_TABLE_MIDPOINT;
 453   int mid = saved_mid;
 454 
 455   do
 456     {
 457       if (ch &lt; g_unicode_width_table_wide[mid].start)
<a name="14" id="anc14"></a><span class="line-modified"> 458   upper = mid - 1;</span>
 459       else if (ch &gt; g_unicode_width_table_wide[mid].end)
<a name="15" id="anc15"></a><span class="line-modified"> 460   lower = mid + 1;</span>
 461       else
<a name="16" id="anc16"></a><span class="line-modified"> 462   return TRUE;</span>
 463 
 464       mid = (lower + upper) / 2;
 465     }
 466   while (lower &lt;= upper);
 467 
 468   return FALSE;
 469 }
 470 
 471 /**
 472  * g_unichar_iswide:
 473  * @c: a Unicode character
 474  *
 475  * Determines if a character is typically rendered in a double-width
 476  * cell.
 477  *
 478  * Returns: %TRUE if the character is wide
 479  **/
 480 gboolean
 481 g_unichar_iswide (gunichar c)
 482 {
 483   if (c &lt; g_unicode_width_table_wide[0].start)
<a name="17" id="anc17"></a><span class="line-modified"> 484     return FALSE;</span>
 485   else
 486     return g_unichar_iswide_bsearch (c);
 487 }
 488 
 489 
 490 /**
 491  * g_unichar_iswide_cjk:
 492  * @c: a Unicode character
 493  *
 494  * Determines if a character is typically rendered in a double-width
 495  * cell under legacy East Asian locales.  If a character is wide according to
 496  * g_unichar_iswide(), then it is also reported wide with this function, but
 497  * the converse is not necessarily true. See the
 498  * [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
 499  * for details.
 500  *
 501  * If a character passes the g_unichar_iswide() test then it will also pass
 502  * this test, but not the other way around.  Note that some characters may
 503  * pass both this test and g_unichar_iszerowidth().
 504  *
 505  * Returns: %TRUE if the character is wide in legacy East Asian locales
 506  *
 507  * Since: 2.12
 508  */
 509 gboolean
 510 g_unichar_iswide_cjk (gunichar c)
 511 {
 512   if (g_unichar_iswide (c))
 513     return TRUE;
 514 
 515   /* bsearch() is declared attribute(nonnull(1)) so we can&#39;t validly search
 516    * for a NULL key */
 517   if (c == 0)
 518     return FALSE;
 519 
 520   if (bsearch (GUINT_TO_POINTER (c),
 521                g_unicode_width_table_ambiguous,
 522                G_N_ELEMENTS (g_unicode_width_table_ambiguous),
 523                sizeof g_unicode_width_table_ambiguous[0],
<a name="18" id="anc18"></a><span class="line-modified"> 524          interval_compare))</span>
 525     return TRUE;
 526 
 527   return FALSE;
 528 }
 529 
 530 
 531 /**
 532  * g_unichar_toupper:
 533  * @c: a Unicode character
 534  *
 535  * Converts a character to uppercase.
 536  *
 537  * Returns: the result of converting @c to uppercase.
<a name="19" id="anc19"></a><span class="line-modified"> 538  *               If @c is not a lowercase or titlecase character,</span>
 539  *               or has no upper case equivalent @c is returned unchanged.
 540  **/
 541 gunichar
 542 g_unichar_toupper (gunichar c)
 543 {
 544   int t = TYPE (c);
 545   if (t == G_UNICODE_LOWERCASE_LETTER)
 546     {
 547       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 548       if (val &gt;= 0x1000000)
<a name="20" id="anc20"></a><span class="line-modified"> 549   {</span>
<span class="line-modified"> 550     const gchar *p = special_case_table + val - 0x1000000;</span>
 551           val = g_utf8_get_char (p);
<a name="21" id="anc21"></a><span class="line-modified"> 552   }</span>
 553       /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,
 554        * do not have an uppercase equivalent, in which case val will be
 555        * zero.
 556        */
 557       return val ? val : c;
 558     }
 559   else if (t == G_UNICODE_TITLECASE_LETTER)
 560     {
 561       unsigned int i;
 562       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<a name="22" id="anc22"></a><span class="line-modified"> 563   {</span>
<span class="line-modified"> 564     if (title_table[i][0] == c)</span>
<span class="line-modified"> 565       return title_table[i][1] ? title_table[i][1] : c;</span>
<span class="line-modified"> 566   }</span>
 567     }
 568   return c;
 569 }
 570 
 571 /**
 572  * g_unichar_tolower:
 573  * @c: a Unicode character.
 574  *
 575  * Converts a character to lower case.
 576  *
 577  * Returns: the result of converting @c to lower case.
 578  *               If @c is not an upperlower or titlecase character,
 579  *               or has no lowercase equivalent @c is returned unchanged.
 580  **/
 581 gunichar
 582 g_unichar_tolower (gunichar c)
 583 {
 584   int t = TYPE (c);
 585   if (t == G_UNICODE_UPPERCASE_LETTER)
 586     {
 587       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 588       if (val &gt;= 0x1000000)
<a name="23" id="anc23"></a><span class="line-modified"> 589   {</span>
<span class="line-modified"> 590     const gchar *p = special_case_table + val - 0x1000000;</span>
<span class="line-modified"> 591     return g_utf8_get_char (p);</span>
<span class="line-modified"> 592   }</span>
 593       else
<a name="24" id="anc24"></a><span class="line-modified"> 594   {</span>
<span class="line-modified"> 595     /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-modified"> 596      * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-modified"> 597     return val ? val : c;</span>
<span class="line-modified"> 598   }</span>
 599     }
 600   else if (t == G_UNICODE_TITLECASE_LETTER)
 601     {
 602       unsigned int i;
 603       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<a name="25" id="anc25"></a><span class="line-modified"> 604   {</span>
<span class="line-modified"> 605     if (title_table[i][0] == c)</span>
<span class="line-modified"> 606       return title_table[i][2];</span>
<span class="line-modified"> 607   }</span>
 608     }
 609   return c;
 610 }
 611 
 612 /**
 613  * g_unichar_totitle:
 614  * @c: a Unicode character
 615  *
 616  * Converts a character to the titlecase.
 617  *
 618  * Returns: the result of converting @c to titlecase.
 619  *               If @c is not an uppercase or lowercase character,
 620  *               @c is returned unchanged.
 621  **/
 622 gunichar
 623 g_unichar_totitle (gunichar c)
 624 {
 625   unsigned int i;
<a name="26" id="anc26"></a><span class="line-added"> 626 </span>
<span class="line-added"> 627   /* We handle U+0000 explicitely because some elements in</span>
<span class="line-added"> 628    * title_table[i][1] may be null. */</span>
<span class="line-added"> 629   if (c == 0)</span>
<span class="line-added"> 630     return c;</span>
<span class="line-added"> 631 </span>
 632   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 633     {
 634       if (title_table[i][0] == c || title_table[i][1] == c
<a name="27" id="anc27"></a><span class="line-modified"> 635     || title_table[i][2] == c)</span>
<span class="line-modified"> 636   return title_table[i][0];</span>
 637     }
 638 
 639   if (TYPE (c) == G_UNICODE_LOWERCASE_LETTER)
 640     return g_unichar_toupper (c);
 641 
 642   return c;
 643 }
 644 
 645 /**
 646  * g_unichar_digit_value:
 647  * @c: a Unicode character
 648  *
 649  * Determines the numeric value of a character as a decimal
 650  * digit.
 651  *
 652  * Returns: If @c is a decimal digit (according to
 653  * g_unichar_isdigit()), its numeric value. Otherwise, -1.
 654  **/
 655 int
 656 g_unichar_digit_value (gunichar c)
 657 {
 658   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 659     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 660   return -1;
 661 }
 662 
 663 /**
 664  * g_unichar_xdigit_value:
 665  * @c: a Unicode character
 666  *
 667  * Determines the numeric value of a character as a hexidecimal
 668  * digit.
 669  *
 670  * Returns: If @c is a hex digit (according to
 671  * g_unichar_isxdigit()), its numeric value. Otherwise, -1.
 672  **/
 673 int
 674 g_unichar_xdigit_value (gunichar c)
 675 {
 676   if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
 677     return c - &#39;A&#39; + 10;
 678   if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
 679     return c - &#39;a&#39; + 10;
<a name="28" id="anc28"></a><span class="line-added"> 680   if (c &gt;= G_UNICHAR_FULLWIDTH_A &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_F)</span>
<span class="line-added"> 681     return c - G_UNICHAR_FULLWIDTH_A + 10;</span>
<span class="line-added"> 682   if (c &gt;= G_UNICHAR_FULLWIDTH_a &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_f)</span>
<span class="line-added"> 683     return c - G_UNICHAR_FULLWIDTH_a + 10;</span>
 684   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 685     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 686   return -1;
 687 }
 688 
 689 /**
 690  * g_unichar_type:
 691  * @c: a Unicode character
 692  *
 693  * Classifies a Unicode character by type.
 694  *
 695  * Returns: the type of the character.
 696  **/
 697 GUnicodeType
 698 g_unichar_type (gunichar c)
 699 {
 700   return TYPE (c);
 701 }
 702 
 703 /*
 704  * Case mapping functions
 705  */
 706 
 707 typedef enum {
 708   LOCALE_NORMAL,
 709   LOCALE_TURKIC,
 710   LOCALE_LITHUANIAN
 711 } LocaleType;
 712 
 713 static LocaleType
 714 get_locale_type (void)
 715 {
 716 #ifdef G_OS_WIN32
 717   char *tem = g_win32_getlocale ();
 718   char locale[2];
 719 
 720   locale[0] = tem[0];
 721   locale[1] = tem[1];
 722   g_free (tem);
 723 #else
 724   const char *locale = setlocale (LC_CTYPE, NULL);
 725 
 726   if (locale == NULL)
 727     return LOCALE_NORMAL;
 728 #endif
 729 
 730   switch (locale[0])
 731     {
 732    case &#39;a&#39;:
 733       if (locale[1] == &#39;z&#39;)
<a name="29" id="anc29"></a><span class="line-modified"> 734   return LOCALE_TURKIC;</span>
 735       break;
 736     case &#39;l&#39;:
 737       if (locale[1] == &#39;t&#39;)
<a name="30" id="anc30"></a><span class="line-modified"> 738   return LOCALE_LITHUANIAN;</span>
 739       break;
 740     case &#39;t&#39;:
 741       if (locale[1] == &#39;r&#39;)
<a name="31" id="anc31"></a><span class="line-modified"> 742   return LOCALE_TURKIC;</span>
 743       break;
 744     }
 745 
 746   return LOCALE_NORMAL;
 747 }
 748 
 749 static gint
 750 output_marks (const char **p_inout,
<a name="32" id="anc32"></a><span class="line-modified"> 751         char        *out_buffer,</span>
<span class="line-modified"> 752         gboolean     remove_dot)</span>
 753 {
 754   const char *p = *p_inout;
 755   gint len = 0;
 756 
 757   while (*p)
 758     {
 759       gunichar c = g_utf8_get_char (p);
 760 
 761       if (ISMARK (TYPE (c)))
<a name="33" id="anc33"></a><span class="line-modified"> 762   {</span>
<span class="line-modified"> 763     if (!remove_dot || c != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-modified"> 764       len += g_unichar_to_utf8 (c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 765     p = g_utf8_next_char (p);</span>
<span class="line-modified"> 766   }</span>
 767       else
<a name="34" id="anc34"></a><span class="line-modified"> 768   break;</span>
 769     }
 770 
 771   *p_inout = p;
 772   return len;
 773 }
 774 
 775 static gint
 776 output_special_case (gchar *out_buffer,
<a name="35" id="anc35"></a><span class="line-modified"> 777          int    offset,</span>
<span class="line-modified"> 778          int    type,</span>
<span class="line-modified"> 779          int    which)</span>
 780 {
 781   const gchar *p = special_case_table + offset;
 782   gint len;
 783 
 784   if (type != G_UNICODE_TITLECASE_LETTER)
 785     p = g_utf8_next_char (p);
 786 
 787   if (which == 1)
 788     p += strlen (p) + 1;
 789 
 790   len = strlen (p);
 791   if (out_buffer)
 792     memcpy (out_buffer, p, len);
 793 
 794   return len;
 795 }
 796 
 797 static gsize
 798 real_toupper (const gchar *str,
<a name="36" id="anc36"></a><span class="line-modified"> 799         gssize       max_len,</span>
<span class="line-modified"> 800         gchar       *out_buffer,</span>
<span class="line-modified"> 801         LocaleType   locale_type)</span>
 802 {
 803   const gchar *p = str;
 804   const char *last = NULL;
 805   gsize len = 0;
 806   gboolean last_was_i = FALSE;
 807 
 808   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 809     {
 810       gunichar c = g_utf8_get_char (p);
 811       int t = TYPE (c);
 812       gunichar val;
 813 
 814       last = p;
 815       p = g_utf8_next_char (p);
 816 
 817       if (locale_type == LOCALE_LITHUANIAN)
<a name="37" id="anc37"></a><span class="line-added"> 818   {</span>
<span class="line-added"> 819     if (c == &#39;i&#39;)</span>
<span class="line-added"> 820       last_was_i = TRUE;</span>
<span class="line-added"> 821     else</span>
<span class="line-added"> 822       {</span>
<span class="line-added"> 823         if (last_was_i)</span>
 824     {
<a name="38" id="anc38"></a><span class="line-modified"> 825       /* Nasty, need to remove any dot above. Though</span>
<span class="line-modified"> 826        * I think only E WITH DOT ABOVE occurs in practice</span>
<span class="line-modified"> 827        * which could simplify this considerably.</span>
<span class="line-modified"> 828        */</span>
<span class="line-modified"> 829       gsize decomp_len, i;</span>
<span class="line-modified"> 830       gunichar decomp[G_UNICHAR_MAX_DECOMPOSITION_LENGTH];</span>















 831 
<a name="39" id="anc39"></a><span class="line-modified"> 832       decomp_len = g_unichar_fully_decompose (c, FALSE, decomp, G_N_ELEMENTS (decomp));</span>
<span class="line-added"> 833       for (i=0; i &lt; decomp_len; i++)</span>
<span class="line-added"> 834         {</span>
<span class="line-added"> 835           if (decomp[i] != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-added"> 836       len += g_unichar_to_utf8 (g_unichar_toupper (decomp[i]), out_buffer ? out_buffer + len : NULL);</span>
 837         }
 838 
<a name="40" id="anc40"></a><span class="line-modified"> 839       len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, TRUE);</span>
<span class="line-modified"> 840 </span>
<span class="line-modified"> 841       continue;</span>
 842     }
 843 
<a name="41" id="anc41"></a><span class="line-added"> 844         if (!ISMARK (t))</span>
<span class="line-added"> 845     last_was_i = FALSE;</span>
<span class="line-added"> 846       }</span>
<span class="line-added"> 847   }</span>
<span class="line-added"> 848 </span>
 849       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;i&#39;)
<a name="42" id="anc42"></a><span class="line-modified"> 850   {</span>
<span class="line-modified"> 851     /* i =&gt; LATIN CAPITAL LETTER I WITH DOT ABOVE */</span>
<span class="line-modified"> 852     len += g_unichar_to_utf8 (0x130, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 853   }</span>
 854       else if (c == 0x0345) /* COMBINING GREEK YPOGEGRAMMENI */
<a name="43" id="anc43"></a><span class="line-modified"> 855   {</span>
<span class="line-modified"> 856     /* Nasty, need to move it after other combining marks .. this would go away if</span>
<span class="line-modified"> 857      * we normalized first.</span>
<span class="line-modified"> 858      */</span>
<span class="line-modified"> 859     len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, FALSE);</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861     /* And output as GREEK CAPITAL LETTER IOTA */</span>
<span class="line-modified"> 862     len += g_unichar_to_utf8 (0x399, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 863   }</span>
 864       else if (IS (t,
<a name="44" id="anc44"></a><span class="line-modified"> 865        OR (G_UNICODE_LOWERCASE_LETTER,</span>
<span class="line-modified"> 866        OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified"> 867       0))))</span>
<span class="line-modified"> 868   {</span>
<span class="line-modified"> 869     val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
 870 
<a name="45" id="anc45"></a><span class="line-modified"> 871     if (val &gt;= 0x1000000)</span>
<span class="line-modified"> 872       {</span>
<span class="line-modified"> 873         len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t,</span>
<span class="line-modified"> 874             t == G_UNICODE_LOWERCASE_LETTER ? 0 : 1);</span>
<span class="line-modified"> 875       }</span>
<span class="line-modified"> 876     else</span>
<span class="line-modified"> 877       {</span>
<span class="line-modified"> 878         if (t == G_UNICODE_TITLECASE_LETTER)</span>
<span class="line-added"> 879     {</span>
<span class="line-added"> 880       unsigned int i;</span>
<span class="line-added"> 881       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
 882         {
<a name="46" id="anc46"></a><span class="line-modified"> 883           if (title_table[i][0] == c)</span>
<span class="line-modified"> 884       {</span>
<span class="line-modified"> 885         val = title_table[i][1];</span>
<span class="line-modified"> 886         break;</span>
<span class="line-modified"> 887       }</span>










 888         }
 889     }
<a name="47" id="anc47"></a><span class="line-added"> 890 </span>
<span class="line-added"> 891         /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,</span>
<span class="line-added"> 892          * do not have an uppercase equivalent, in which case val will be</span>
<span class="line-added"> 893          * zero. */</span>
<span class="line-added"> 894         len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-added"> 895       }</span>
<span class="line-added"> 896   }</span>
 897       else
<a name="48" id="anc48"></a><span class="line-modified"> 898   {</span>
<span class="line-modified"> 899     gsize char_len = g_utf8_skip[*(guchar *)last];</span>
 900 
<a name="49" id="anc49"></a><span class="line-modified"> 901     if (out_buffer)</span>
<span class="line-modified"> 902       memcpy (out_buffer + len, last, char_len);</span>
 903 
<a name="50" id="anc50"></a><span class="line-modified"> 904     len += char_len;</span>
<span class="line-modified"> 905   }</span>
 906 
 907     }
 908 
 909   return len;
 910 }
 911 
 912 /**
 913  * g_utf8_strup:
 914  * @str: a UTF-8 encoded string
 915  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
 916  *
 917  * Converts all Unicode characters in the string that have a case
 918  * to uppercase. The exact manner that this is done depends
 919  * on the current locale, and may result in the number of
 920  * characters in the string increasing. (For instance, the
 921  * German ess-zet will be changed to SS.)
 922  *
 923  * Returns: a newly allocated string, with all characters
 924  *    converted to uppercase.
 925  **/
 926 gchar *
 927 g_utf8_strup (const gchar *str,
<a name="51" id="anc51"></a><span class="line-modified"> 928         gssize       len)</span>
 929 {
 930   gsize result_len;
 931   LocaleType locale_type;
 932   gchar *result;
 933 
 934   g_return_val_if_fail (str != NULL, NULL);
 935 
 936   locale_type = get_locale_type ();
 937 
 938   /*
 939    * We use a two pass approach to keep memory management simple
 940    */
 941   result_len = real_toupper (str, len, NULL, locale_type);
 942 #ifdef GSTREAMER_LITE
 943   if (result_len == 0)
 944     return NULL;
 945 #endif // GSTREAMER_LITE
 946   result = g_malloc (result_len + 1);
 947 #ifdef GSTREAMER_LITE
 948   if (result == NULL)
 949     return NULL;
 950 #endif // GSTREAMER_LITE
 951 #ifdef GSTREAMER_LITE
 952   if (real_toupper (str, len, result, locale_type) == 0)
 953     return NULL;
 954 #else // GSTREAMER_LITE
 955   real_toupper (str, len, result, locale_type);
 956 #endif // GSTREAMER_LITE
 957   result[result_len] = &#39;\0&#39;;
 958 
 959   return result;
 960 }
 961 
 962 /* traverses the string checking for characters with combining class == 230
 963  * until a base character is found */
 964 static gboolean
 965 has_more_above (const gchar *str)
 966 {
 967   const gchar *p = str;
 968   gint combining_class;
 969 
 970   while (*p)
 971     {
 972       combining_class = g_unichar_combining_class (g_utf8_get_char (p));
 973       if (combining_class == 230)
 974         return TRUE;
 975       else if (combining_class == 0)
 976         break;
 977 
 978       p = g_utf8_next_char (p);
 979     }
 980 
 981   return FALSE;
 982 }
 983 
 984 static gsize
 985 real_tolower (const gchar *str,
<a name="52" id="anc52"></a><span class="line-modified"> 986         gssize       max_len,</span>
<span class="line-modified"> 987         gchar       *out_buffer,</span>
<span class="line-modified"> 988         LocaleType   locale_type)</span>
 989 {
 990   const gchar *p = str;
 991   const char *last = NULL;
 992   gsize len = 0;
 993 
 994   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 995     {
 996       gunichar c = g_utf8_get_char (p);
 997       int t = TYPE (c);
 998       gunichar val;
 999 
1000       last = p;
1001       p = g_utf8_next_char (p);
1002 
<a name="53" id="anc53"></a><span class="line-modified">1003       if (locale_type == LOCALE_TURKIC &amp;&amp; (c == &#39;I&#39; ||</span>
<span class="line-modified">1004                                            c == G_UNICHAR_FULLWIDTH_I))</span>
<span class="line-added">1005   {</span>
1006           if (g_utf8_get_char (p) == 0x0307)
1007             {
1008               /* I + COMBINING DOT ABOVE =&gt; i (U+0069) */
1009               len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1010               p = g_utf8_next_char (p);
1011             }
1012           else
1013             {
1014               /* I =&gt; LATIN SMALL LETTER DOTLESS I */
1015               len += g_unichar_to_utf8 (0x131, out_buffer ? out_buffer + len : NULL);
1016             }
1017         }
1018       /* Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
1019        * whenever there are more accents above. [SpecialCasing.txt] */
1020       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
1021                (c == 0x00cc || c == 0x00cd || c == 0x0128))
1022         {
1023           len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1024           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1025 
1026           switch (c)
1027             {
1028             case 0x00cc:
1029               len += g_unichar_to_utf8 (0x0300, out_buffer ? out_buffer + len : NULL);
1030               break;
1031             case 0x00cd:
1032               len += g_unichar_to_utf8 (0x0301, out_buffer ? out_buffer + len : NULL);
1033               break;
1034             case 0x0128:
1035               len += g_unichar_to_utf8 (0x0303, out_buffer ? out_buffer + len : NULL);
1036               break;
1037             }
1038         }
1039       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
<a name="54" id="anc54"></a><span class="line-modified">1040                (c == &#39;I&#39; || c == G_UNICHAR_FULLWIDTH_I ||</span>
<span class="line-added">1041                 c == &#39;J&#39; || c == G_UNICHAR_FULLWIDTH_J || c == 0x012e) &amp;&amp;</span>
1042                has_more_above (p))
1043         {
1044           len += g_unichar_to_utf8 (g_unichar_tolower (c), out_buffer ? out_buffer + len : NULL);
1045           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1046         }
1047       else if (c == 0x03A3) /* GREEK CAPITAL LETTER SIGMA */
<a name="55" id="anc55"></a><span class="line-modified">1048   {</span>
<span class="line-modified">1049     if ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)</span>
<span class="line-modified">1050       {</span>
<span class="line-modified">1051         gunichar next_c = g_utf8_get_char (p);</span>
<span class="line-modified">1052         int next_type = TYPE(next_c);</span>
<span class="line-modified">1053 </span>
<span class="line-modified">1054         /* SIGMA mapps differently depending on whether it is</span>
<span class="line-modified">1055          * final or not. The following simplified test would</span>
<span class="line-modified">1056          * fail in the case of combining marks following the</span>
<span class="line-modified">1057          * sigma, but I don&#39;t think that occurs in real text.</span>
<span class="line-modified">1058          * The test here matches that in ICU.</span>
<span class="line-modified">1059          */</span>
<span class="line-modified">1060         if (ISALPHA (next_type)) /* Lu,Ll,Lt,Lm,Lo */</span>
<span class="line-modified">1061     val = 0x3c3;  /* GREEK SMALL SIGMA */</span>
<span class="line-modified">1062         else</span>
<span class="line-modified">1063     val = 0x3c2;  /* GREEK SMALL FINAL SIGMA */</span>
<span class="line-modified">1064       }</span>
<span class="line-modified">1065     else</span>
<span class="line-modified">1066       val = 0x3c2;  /* GREEK SMALL FINAL SIGMA */</span>
1067 
<a name="56" id="anc56"></a><span class="line-modified">1068     len += g_unichar_to_utf8 (val, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified">1069   }</span>
1070       else if (IS (t,
<a name="57" id="anc57"></a><span class="line-modified">1071        OR (G_UNICODE_UPPERCASE_LETTER,</span>
<span class="line-modified">1072        OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified">1073       0))))</span>
<span class="line-modified">1074   {</span>
<span class="line-modified">1075     val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
1076 
<a name="58" id="anc58"></a><span class="line-modified">1077     if (val &gt;= 0x1000000)</span>
<span class="line-modified">1078       {</span>
<span class="line-modified">1079         len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t, 0);</span>
<span class="line-modified">1080       }</span>
<span class="line-modified">1081     else</span>
<span class="line-modified">1082       {</span>
<span class="line-modified">1083         if (t == G_UNICODE_TITLECASE_LETTER)</span>
<span class="line-added">1084     {</span>
<span class="line-added">1085       unsigned int i;</span>
<span class="line-added">1086       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
1087         {
<a name="59" id="anc59"></a><span class="line-modified">1088           if (title_table[i][0] == c)</span>
<span class="line-modified">1089       {</span>
<span class="line-modified">1090         val = title_table[i][2];</span>
<span class="line-modified">1091         break;</span>
<span class="line-modified">1092       }</span>









1093         }
1094     }
<a name="60" id="anc60"></a><span class="line-added">1095 </span>
<span class="line-added">1096         /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-added">1097          * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-added">1098         len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-added">1099       }</span>
<span class="line-added">1100   }</span>
1101       else
<a name="61" id="anc61"></a><span class="line-modified">1102   {</span>
<span class="line-modified">1103     gsize char_len = g_utf8_skip[*(guchar *)last];</span>
1104 
<a name="62" id="anc62"></a><span class="line-modified">1105     if (out_buffer)</span>
<span class="line-modified">1106       memcpy (out_buffer + len, last, char_len);</span>
1107 
<a name="63" id="anc63"></a><span class="line-modified">1108     len += char_len;</span>
<span class="line-modified">1109   }</span>
1110 
1111     }
1112 
1113   return len;
1114 }
1115 
1116 /**
1117  * g_utf8_strdown:
1118  * @str: a UTF-8 encoded string
1119  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1120  *
1121  * Converts all Unicode characters in the string that have a case
1122  * to lowercase. The exact manner that this is done depends
1123  * on the current locale, and may result in the number of
1124  * characters in the string changing.
1125  *
1126  * Returns: a newly allocated string, with all characters
1127  *    converted to lowercase.
1128  **/
1129 gchar *
1130 g_utf8_strdown (const gchar *str,
<a name="64" id="anc64"></a><span class="line-modified">1131     gssize       len)</span>
1132 {
1133   gsize result_len;
1134   LocaleType locale_type;
1135   gchar *result;
1136 
1137   g_return_val_if_fail (str != NULL, NULL);
1138 
1139   locale_type = get_locale_type ();
1140 
1141   /*
1142    * We use a two pass approach to keep memory management simple
1143    */
1144   result_len = real_tolower (str, len, NULL, locale_type);
1145   result = g_malloc (result_len + 1);
1146 #ifdef GSTREAMER_LITE
1147   if (result == NULL)
1148       return NULL;
1149 #endif // GSTREAMER_LITE
1150   real_tolower (str, len, result, locale_type);
1151   result[result_len] = &#39;\0&#39;;
1152 
1153   return result;
1154 }
1155 
1156 /**
1157  * g_utf8_casefold:
1158  * @str: a UTF-8 encoded string
1159  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1160  *
1161  * Converts a string into a form that is independent of case. The
1162  * result will not correspond to any particular case, but can be
1163  * compared for equality or ordered with the results of calling
1164  * g_utf8_casefold() on other strings.
1165  *
1166  * Note that calling g_utf8_casefold() followed by g_utf8_collate() is
1167  * only an approximation to the correct linguistic case insensitive
1168  * ordering, though it is a fairly good one. Getting this exactly
1169  * right would require a more sophisticated collation function that
1170  * takes case sensitivity into account. GLib does not currently
1171  * provide such a function.
1172  *
1173  * Returns: a newly allocated string, that is a
1174  *   case independent form of @str.
1175  **/
1176 gchar *
1177 g_utf8_casefold (const gchar *str,
<a name="65" id="anc65"></a><span class="line-modified">1178      gssize       len)</span>
1179 {
1180   GString *result;
1181   const char *p;
1182 
1183   g_return_val_if_fail (str != NULL, NULL);
1184 
1185   result = g_string_new (NULL);
1186   p = str;
1187   while ((len &lt; 0 || p &lt; str + len) &amp;&amp; *p)
1188     {
1189       gunichar ch = g_utf8_get_char (p);
1190 
1191       int start = 0;
1192       int end = G_N_ELEMENTS (casefold_table);
1193 
1194       if (ch &gt;= casefold_table[start].ch &amp;&amp;
1195           ch &lt;= casefold_table[end - 1].ch)
<a name="66" id="anc66"></a><span class="line-added">1196   {</span>
<span class="line-added">1197     while (TRUE)</span>
<span class="line-added">1198       {</span>
<span class="line-added">1199         int half = (start + end) / 2;</span>
<span class="line-added">1200         if (ch == casefold_table[half].ch)</span>
1201     {
<a name="67" id="anc67"></a><span class="line-modified">1202       g_string_append (result, casefold_table[half].data);</span>
<span class="line-modified">1203       goto next;</span>













1204     }
<a name="68" id="anc68"></a><span class="line-added">1205         else if (half == start)</span>
<span class="line-added">1206     break;</span>
<span class="line-added">1207         else if (ch &gt; casefold_table[half].ch)</span>
<span class="line-added">1208     start = half;</span>
<span class="line-added">1209         else</span>
<span class="line-added">1210     end = half;</span>
<span class="line-added">1211       }</span>
<span class="line-added">1212   }</span>
1213 
1214       g_string_append_unichar (result, g_unichar_tolower (ch));
1215 
1216     next:
1217       p = g_utf8_next_char (p);
1218     }
1219 
1220   return g_string_free (result, FALSE);
1221 }
1222 
1223 /**
1224  * g_unichar_get_mirror_char:
1225  * @ch: a Unicode character
1226  * @mirrored_ch: location to store the mirrored character
1227  *
1228  * In Unicode, some characters are &quot;mirrored&quot;. This means that their
1229  * images are mirrored horizontally in text that is laid out from right
1230  * to left. For instance, &quot;(&quot; would become its mirror image, &quot;)&quot;, in
1231  * right-to-left text.
1232  *
1233  * If @ch has the Unicode mirrored property and there is another unicode
1234  * character that typically has a glyph that is the mirror image of @ch&#39;s
1235  * glyph and @mirrored_ch is set, it puts that character in the address
1236  * pointed to by @mirrored_ch.  Otherwise the original character is put.
1237  *
1238  * Returns: %TRUE if @ch has a mirrored character, %FALSE otherwise
1239  *
1240  * Since: 2.4
1241  **/
1242 gboolean
1243 g_unichar_get_mirror_char (gunichar ch,
1244                            gunichar *mirrored_ch)
1245 {
1246   gboolean found;
1247   gunichar mirrored;
1248 
1249   mirrored = GLIB_GET_MIRRORING(ch);
1250 
1251   found = ch != mirrored;
1252   if (mirrored_ch)
1253     *mirrored_ch = mirrored;
1254 
1255   return found;
1256 
1257 }
1258 
1259 #define G_SCRIPT_TABLE_MIDPOINT (G_N_ELEMENTS (g_script_table) / 2)
1260 
1261 static inline GUnicodeScript
1262 g_unichar_get_script_bsearch (gunichar ch)
1263 {
1264   int lower = 0;
1265   int upper = G_N_ELEMENTS (g_script_table) - 1;
1266   static int saved_mid = G_SCRIPT_TABLE_MIDPOINT;
1267   int mid = saved_mid;
1268 
1269 
1270   do
1271     {
1272       if (ch &lt; g_script_table[mid].start)
<a name="69" id="anc69"></a><span class="line-modified">1273   upper = mid - 1;</span>
1274       else if (ch &gt;= g_script_table[mid].start + g_script_table[mid].chars)
<a name="70" id="anc70"></a><span class="line-modified">1275   lower = mid + 1;</span>
1276       else
<a name="71" id="anc71"></a><span class="line-modified">1277   return g_script_table[saved_mid = mid].script;</span>
1278 
1279       mid = (lower + upper) / 2;
1280     }
1281   while (lower &lt;= upper);
1282 
1283   return G_UNICODE_SCRIPT_UNKNOWN;
1284 }
1285 
1286 /**
1287  * g_unichar_get_script:
1288  * @ch: a Unicode character
1289  *
1290  * Looks up the #GUnicodeScript for a particular character (as defined
1291  * by Unicode Standard Annex \#24). No check is made for @ch being a
1292  * valid Unicode character; if you pass in invalid character, the
1293  * result is undefined.
1294  *
1295  * This function is equivalent to pango_script_for_unichar() and the
1296  * two are interchangeable.
1297  *
1298  * Returns: the #GUnicodeScript for the character.
1299  *
1300  * Since: 2.14
1301  */
1302 GUnicodeScript
1303 g_unichar_get_script (gunichar ch)
1304 {
1305   if (ch &lt; G_EASY_SCRIPTS_RANGE)
1306     return g_script_easy_table[ch];
1307   else
1308     return g_unichar_get_script_bsearch (ch);
1309 }
1310 
1311 
1312 /* http://unicode.org/iso15924/ */
1313 static const guint32 iso15924_tags[] =
1314 {
1315 #define PACK(a,b,c,d) ((guint32)((((guint8)(a))&lt;&lt;24)|(((guint8)(b))&lt;&lt;16)|(((guint8)(c))&lt;&lt;8)|((guint8)(d))))
1316 
1317     PACK (&#39;Z&#39;,&#39;y&#39;,&#39;y&#39;,&#39;y&#39;), /* G_UNICODE_SCRIPT_COMMON */
1318     PACK (&#39;Z&#39;,&#39;i&#39;,&#39;n&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_INHERITED */
1319     PACK (&#39;A&#39;,&#39;r&#39;,&#39;a&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ARABIC */
1320     PACK (&#39;A&#39;,&#39;r&#39;,&#39;m&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_ARMENIAN */
1321     PACK (&#39;B&#39;,&#39;e&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_BENGALI */
1322     PACK (&#39;B&#39;,&#39;o&#39;,&#39;p&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_BOPOMOFO */
1323     PACK (&#39;C&#39;,&#39;h&#39;,&#39;e&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_CHEROKEE */
1324     PACK (&#39;C&#39;,&#39;o&#39;,&#39;p&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_COPTIC */
1325     PACK (&#39;C&#39;,&#39;y&#39;,&#39;r&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_CYRILLIC */
1326     PACK (&#39;D&#39;,&#39;s&#39;,&#39;r&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_DESERET */
1327     PACK (&#39;D&#39;,&#39;e&#39;,&#39;v&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_DEVANAGARI */
1328     PACK (&#39;E&#39;,&#39;t&#39;,&#39;h&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_ETHIOPIC */
1329     PACK (&#39;G&#39;,&#39;e&#39;,&#39;o&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_GEORGIAN */
1330     PACK (&#39;G&#39;,&#39;o&#39;,&#39;t&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_GOTHIC */
1331     PACK (&#39;G&#39;,&#39;r&#39;,&#39;e&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_GREEK */
1332     PACK (&#39;G&#39;,&#39;u&#39;,&#39;j&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_GUJARATI */
1333     PACK (&#39;G&#39;,&#39;u&#39;,&#39;r&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_GURMUKHI */
1334     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_HAN */
1335     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANGUL */
1336     PACK (&#39;H&#39;,&#39;e&#39;,&#39;b&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HEBREW */
1337     PACK (&#39;H&#39;,&#39;i&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_HIRAGANA */
1338     PACK (&#39;K&#39;,&#39;n&#39;,&#39;d&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_KANNADA */
1339     PACK (&#39;K&#39;,&#39;a&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_KATAKANA */
1340     PACK (&#39;K&#39;,&#39;h&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_KHMER */
1341     PACK (&#39;L&#39;,&#39;a&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_LAO */
1342     PACK (&#39;L&#39;,&#39;a&#39;,&#39;t&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_LATIN */
1343     PACK (&#39;M&#39;,&#39;l&#39;,&#39;y&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MALAYALAM */
1344     PACK (&#39;M&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_MONGOLIAN */
1345     PACK (&#39;M&#39;,&#39;y&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_MYANMAR */
1346     PACK (&#39;O&#39;,&#39;g&#39;,&#39;a&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OGHAM */
1347     PACK (&#39;I&#39;,&#39;t&#39;,&#39;a&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_OLD_ITALIC */
1348     PACK (&#39;O&#39;,&#39;r&#39;,&#39;y&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ORIYA */
1349     PACK (&#39;R&#39;,&#39;u&#39;,&#39;n&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_RUNIC */
1350     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_SINHALA */
1351     PACK (&#39;S&#39;,&#39;y&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_SYRIAC */
1352     PACK (&#39;T&#39;,&#39;a&#39;,&#39;m&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_TAMIL */
1353     PACK (&#39;T&#39;,&#39;e&#39;,&#39;l&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_TELUGU */
1354     PACK (&#39;T&#39;,&#39;h&#39;,&#39;a&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_THAANA */
1355     PACK (&#39;T&#39;,&#39;h&#39;,&#39;a&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_THAI */
1356     PACK (&#39;T&#39;,&#39;i&#39;,&#39;b&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_TIBETAN */
1357     PACK (&#39;C&#39;,&#39;a&#39;,&#39;n&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL */
1358     PACK (&#39;Y&#39;,&#39;i&#39;,&#39;i&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_YI */
1359     PACK (&#39;T&#39;,&#39;g&#39;,&#39;l&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TAGALOG */
1360     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_HANUNOO */
1361     PACK (&#39;B&#39;,&#39;u&#39;,&#39;h&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_BUHID */
1362     PACK (&#39;T&#39;,&#39;a&#39;,&#39;g&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_TAGBANWA */
1363 
1364   /* Unicode-4.0 additions */
1365     PACK (&#39;B&#39;,&#39;r&#39;,&#39;a&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BRAILLE */
1366     PACK (&#39;C&#39;,&#39;p&#39;,&#39;r&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_CYPRIOT */
1367     PACK (&#39;L&#39;,&#39;i&#39;,&#39;m&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_LIMBU */
1368     PACK (&#39;O&#39;,&#39;s&#39;,&#39;m&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_OSMANYA */
1369     PACK (&#39;S&#39;,&#39;h&#39;,&#39;a&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_SHAVIAN */
1370     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_LINEAR_B */
1371     PACK (&#39;T&#39;,&#39;a&#39;,&#39;l&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_TAI_LE */
1372     PACK (&#39;U&#39;,&#39;g&#39;,&#39;a&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_UGARITIC */
1373 
1374   /* Unicode-4.1 additions */
1375     PACK (&#39;T&#39;,&#39;a&#39;,&#39;l&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NEW_TAI_LUE */
1376     PACK (&#39;B&#39;,&#39;u&#39;,&#39;g&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BUGINESE */
1377     PACK (&#39;G&#39;,&#39;l&#39;,&#39;a&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GLAGOLITIC */
1378     PACK (&#39;T&#39;,&#39;f&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TIFINAGH */
1379     PACK (&#39;S&#39;,&#39;y&#39;,&#39;l&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SYLOTI_NAGRI */
1380     PACK (&#39;X&#39;,&#39;p&#39;,&#39;e&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_PERSIAN */
1381     PACK (&#39;K&#39;,&#39;h&#39;,&#39;a&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_KHAROSHTHI */
1382 
1383   /* Unicode-5.0 additions */
1384     PACK (&#39;Z&#39;,&#39;z&#39;,&#39;z&#39;,&#39;z&#39;), /* G_UNICODE_SCRIPT_UNKNOWN */
1385     PACK (&#39;B&#39;,&#39;a&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BALINESE */
1386     PACK (&#39;X&#39;,&#39;s&#39;,&#39;u&#39;,&#39;x&#39;), /* G_UNICODE_SCRIPT_CUNEIFORM */
1387     PACK (&#39;P&#39;,&#39;h&#39;,&#39;n&#39;,&#39;x&#39;), /* G_UNICODE_SCRIPT_PHOENICIAN */
1388     PACK (&#39;P&#39;,&#39;h&#39;,&#39;a&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PHAGS_PA */
1389     PACK (&#39;N&#39;,&#39;k&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_NKO */
1390 
1391   /* Unicode-5.1 additions */
1392     PACK (&#39;K&#39;,&#39;a&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_KAYAH_LI */
1393     PACK (&#39;L&#39;,&#39;e&#39;,&#39;p&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_LEPCHA */
1394     PACK (&#39;R&#39;,&#39;j&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_REJANG */
1395     PACK (&#39;S&#39;,&#39;u&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SUNDANESE */
1396     PACK (&#39;S&#39;,&#39;a&#39;,&#39;u&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_SAURASHTRA */
1397     PACK (&#39;C&#39;,&#39;h&#39;,&#39;a&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAM */
1398     PACK (&#39;O&#39;,&#39;l&#39;,&#39;c&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_OL_CHIKI */
1399     PACK (&#39;V&#39;,&#39;a&#39;,&#39;i&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_VAI */
1400     PACK (&#39;C&#39;,&#39;a&#39;,&#39;r&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_CARIAN */
1401     PACK (&#39;L&#39;,&#39;y&#39;,&#39;c&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_LYCIAN */
1402     PACK (&#39;L&#39;,&#39;y&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_LYDIAN */
1403 
1404   /* Unicode-5.2 additions */
1405     PACK (&#39;A&#39;,&#39;v&#39;,&#39;s&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_AVESTAN */
1406     PACK (&#39;B&#39;,&#39;a&#39;,&#39;m&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_BAMUM */
1407     PACK (&#39;E&#39;,&#39;g&#39;,&#39;y&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS */
1408     PACK (&#39;A&#39;,&#39;r&#39;,&#39;m&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC */
1409     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI */
1410     PACK (&#39;P&#39;,&#39;r&#39;,&#39;t&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN */
1411     PACK (&#39;J&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_JAVANESE */
1412     PACK (&#39;K&#39;,&#39;t&#39;,&#39;h&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_KAITHI */
1413     PACK (&#39;L&#39;,&#39;i&#39;,&#39;s&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_LISU */
1414     PACK (&#39;M&#39;,&#39;t&#39;,&#39;e&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MEETEI_MAYEK */
1415     PACK (&#39;S&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN */
1416     PACK (&#39;O&#39;,&#39;r&#39;,&#39;k&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_OLD_TURKIC */
1417     PACK (&#39;S&#39;,&#39;a&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_SAMARITAN */
1418     PACK (&#39;L&#39;,&#39;a&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_TAI_THAM */
1419     PACK (&#39;T&#39;,&#39;a&#39;,&#39;v&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_TAI_VIET */
1420 
1421   /* Unicode-6.0 additions */
1422     PACK (&#39;B&#39;,&#39;a&#39;,&#39;t&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_BATAK */
1423     PACK (&#39;B&#39;,&#39;r&#39;,&#39;a&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_BRAHMI */
1424     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MANDAIC */
1425 
1426   /* Unicode-6.1 additions */
1427     PACK (&#39;C&#39;,&#39;a&#39;,&#39;k&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAKMA */
1428     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MEROITIC_CURSIVE */
1429     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS */
1430     PACK (&#39;P&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MIAO */
1431     PACK (&#39;S&#39;,&#39;h&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SHARADA */
1432     PACK (&#39;S&#39;,&#39;o&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_SORA_SOMPENG */
1433     PACK (&#39;T&#39;,&#39;a&#39;,&#39;k&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_TAKRI */
1434 
1435   /* Unicode 7.0 additions */
1436     PACK (&#39;B&#39;,&#39;a&#39;,&#39;s&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BASSA_VAH */
1437     PACK (&#39;A&#39;,&#39;g&#39;,&#39;h&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN */
1438     PACK (&#39;D&#39;,&#39;u&#39;,&#39;p&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_DUPLOYAN */
1439     PACK (&#39;E&#39;,&#39;l&#39;,&#39;b&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ELBASAN */
1440     PACK (&#39;G&#39;,&#39;r&#39;,&#39;a&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_GRANTHA */
1441     PACK (&#39;K&#39;,&#39;h&#39;,&#39;o&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_KHOJKI*/
1442     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_KHUDAWADI */
1443     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_LINEAR_A */
1444     PACK (&#39;M&#39;,&#39;a&#39;,&#39;h&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_MAHAJANI */
<a name="72" id="anc72"></a><span class="line-modified">1445     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MANICHAEAN */</span>
1446     PACK (&#39;M&#39;,&#39;e&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MENDE_KIKAKUI */
1447     PACK (&#39;M&#39;,&#39;o&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MODI */
1448     PACK (&#39;M&#39;,&#39;r&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MRO */
1449     PACK (&#39;N&#39;,&#39;b&#39;,&#39;a&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_NABATAEAN */
1450     PACK (&#39;N&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN */
1451     PACK (&#39;P&#39;,&#39;e&#39;,&#39;r&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OLD_PERMIC */
1452     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PAHAWH_HMONG */
1453     PACK (&#39;P&#39;,&#39;a&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_PALMYRENE */
1454     PACK (&#39;P&#39;,&#39;a&#39;,&#39;u&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_PAU_CIN_HAU */
1455     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_PSALTER_PAHLAVI */
1456     PACK (&#39;S&#39;,&#39;i&#39;,&#39;d&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SIDDHAM */
1457     PACK (&#39;T&#39;,&#39;i&#39;,&#39;r&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_TIRHUTA */
1458     PACK (&#39;W&#39;,&#39;a&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_WARANG_CITI */
1459 
1460   /* Unicode 8.0 additions */
1461     PACK (&#39;A&#39;,&#39;h&#39;,&#39;o&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_AHOM */
1462     PACK (&#39;H&#39;,&#39;l&#39;,&#39;u&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS */
1463     PACK (&#39;H&#39;,&#39;a&#39;,&#39;t&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HATRAN */
1464     PACK (&#39;M&#39;,&#39;u&#39;,&#39;l&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_MULTANI */
1465     PACK (&#39;H&#39;,&#39;u&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_OLD_HUNGARIAN */
1466     PACK (&#39;S&#39;,&#39;g&#39;,&#39;n&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_SIGNWRITING */
1467 
1468   /* Unicode 9.0 additions */
1469     PACK (&#39;A&#39;,&#39;d&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_ADLAM */
1470     PACK (&#39;B&#39;,&#39;h&#39;,&#39;k&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BHAIKSUKI */
1471     PACK (&#39;M&#39;,&#39;a&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MARCHEN */
1472     PACK (&#39;N&#39;,&#39;e&#39;,&#39;w&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_NEWA */
1473     PACK (&#39;O&#39;,&#39;s&#39;,&#39;g&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_OSAGE */
1474     PACK (&#39;T&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TANGUT */
1475 
1476   /* Unicode 10.0 additions */
1477     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MASARAM_GONDI */
1478     PACK (&#39;N&#39;,&#39;s&#39;,&#39;h&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NUSHU */
1479     PACK (&#39;S&#39;,&#39;o&#39;,&#39;y&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SOYOMBO */
1480     PACK (&#39;Z&#39;,&#39;a&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ZANABAZAR_SQUARE */
1481 
1482   /* Unicode 11.0 additions */
1483     PACK (&#39;D&#39;,&#39;o&#39;,&#39;g&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_DOGRA */
1484     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GUNJALA_GONDI */
1485     PACK (&#39;R&#39;,&#39;o&#39;,&#39;h&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANIFI_ROHINGYA */
1486     PACK (&#39;M&#39;,&#39;a&#39;,&#39;k&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_MAKASAR */
1487     PACK (&#39;M&#39;,&#39;e&#39;,&#39;d&#39;,&#39;f&#39;), /* G_UNICODE_SCRIPT_MEDEFAIDRIN */
1488     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_SOGDIAN */
1489     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SOGDIAN */
<a name="73" id="anc73"></a><span class="line-added">1490 </span>
<span class="line-added">1491   /* Unicode 12.0 additions */</span>
<span class="line-added">1492     PACK (&#39;E&#39;,&#39;l&#39;,&#39;y&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_ELYMAIC */</span>
<span class="line-added">1493     PACK (&#39;N&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_NANDINAGARI */</span>
<span class="line-added">1494     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG */</span>
<span class="line-added">1495     PACK (&#39;W&#39;,&#39;c&#39;,&#39;h&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_WANCHO */</span>
1496 #undef PACK
1497 };
1498 
1499 /**
1500  * g_unicode_script_to_iso15924:
1501  * @script: a Unicode script
1502  *
1503  * Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
1504  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.  The
1505  * four letter codes are encoded as a @guint32 by this function in a
1506  * big-endian fashion.  That is, the code returned for Arabic is
1507  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1508  *
1509  * See
1510  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1511  * for details.
1512  *
1513  * Returns: the ISO 15924 code for @script, encoded as an integer,
1514  *   of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
1515  *   ISO 15924 code &#39;Zzzz&#39; (script code for UNKNOWN) if @script is not understood.
1516  *
1517  * Since: 2.30
1518  */
1519 guint32
1520 g_unicode_script_to_iso15924 (GUnicodeScript script)
1521 {
1522   if (G_UNLIKELY (script == G_UNICODE_SCRIPT_INVALID_CODE))
1523     return 0;
1524 
1525   if (G_UNLIKELY (script &lt; 0 || script &gt;= (int) G_N_ELEMENTS (iso15924_tags)))
1526     return 0x5A7A7A7A;
1527 
1528   return iso15924_tags[script];
1529 }
1530 
1531 /**
1532  * g_unicode_script_from_iso15924:
1533  * @iso15924: a Unicode script
1534  *
1535  * Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
1536  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.
1537  * This function accepts four letter codes encoded as a @guint32 in a
1538  * big-endian fashion.  That is, the code expected for Arabic is
1539  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1540  *
1541  * See
1542  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1543  * for details.
1544  *
1545  * Returns: the Unicode script for @iso15924, or
1546  *   of %G_UNICODE_SCRIPT_INVALID_CODE if @iso15924 is zero and
1547  *   %G_UNICODE_SCRIPT_UNKNOWN if @iso15924 is unknown.
1548  *
1549  * Since: 2.30
1550  */
1551 GUnicodeScript
1552 g_unicode_script_from_iso15924 (guint32 iso15924)
1553 {
1554   unsigned int i;
1555 
1556    if (!iso15924)
1557      return G_UNICODE_SCRIPT_INVALID_CODE;
1558 
1559   for (i = 0; i &lt; G_N_ELEMENTS (iso15924_tags); i++)
1560     if (iso15924_tags[i] == iso15924)
1561       return (GUnicodeScript) i;
1562 
1563   return G_UNICODE_SCRIPT_UNKNOWN;
1564 }
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>