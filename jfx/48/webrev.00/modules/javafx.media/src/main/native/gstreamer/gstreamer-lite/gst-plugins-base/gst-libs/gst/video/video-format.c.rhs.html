<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-format.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  * Library       &lt;2002&gt; Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;
   4  * Copyright (C) 2007 David A. Schleef &lt;ds@schleef.org&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #ifdef HAVE_CONFIG_H
  23 #  include &quot;config.h&quot;
  24 #endif
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdio.h&gt;
  28 
  29 #include &quot;video-format.h&quot;
  30 #ifndef GSTREAMER_LITE
  31 #include &quot;video-orc.h&quot;
  32 #else // GSTREAMER_LITE
  33 #include &quot;video-orc-dist.h&quot;
  34 #endif // GSTREAMER_LITE
  35 
  36 #ifndef restrict
  37 #if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L
  38 /* restrict should be available */
  39 #elif defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4
  40 #define restrict __restrict__
  41 #elif defined(_MSC_VER) &amp;&amp;  _MSC_VER &gt;= 1500
  42 #define restrict __restrict
  43 #else
  44 #define restrict                /* no op */
  45 #endif
  46 #endif
  47 
  48 /* Line conversion to AYUV */
  49 
  50 #define GET_PLANE_STRIDE(plane) (stride(plane))
  51 #define GET_PLANE_LINE(plane, line) \
  52   (gpointer)(((guint8*)(data[plane])) + stride[plane] * (line))
  53 
  54 #define GET_COMP_STRIDE(comp) \
  55   GST_VIDEO_FORMAT_INFO_STRIDE (info, stride, comp)
  56 #define GET_COMP_DATA(comp) \
  57   GST_VIDEO_FORMAT_INFO_DATA (info, data, comp)
  58 
  59 #define GET_COMP_LINE(comp, line) \
  60   (gpointer)(((guint8*)GET_COMP_DATA (comp)) + \
  61       GET_COMP_STRIDE(comp) * (line))
  62 
  63 #define GET_LINE(line)               GET_PLANE_LINE (0, line)
  64 
  65 #define GET_Y_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_Y, line)
  66 #define GET_U_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_U, line)
  67 #define GET_V_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_V, line)
  68 
  69 #define GET_R_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_R, line)
  70 #define GET_G_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_G, line)
  71 #define GET_B_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_B, line)
  72 
  73 #define GET_A_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_A, line)
  74 
  75 #define GET_UV_420(line, flags)                 \
  76   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  77    ((line &amp; ~3) &gt;&gt; 1) + (line &amp; 1) :            \
  78    line &gt;&gt; 1)
  79 #define GET_UV_410(line, flags)                 \
  80   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  81    ((line &amp; ~7) &gt;&gt; 2) + (line &amp; 1) :            \
  82    line &gt;&gt; 2)
  83 
  84 #define IS_CHROMA_LINE_420(line, flags)         \
  85   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  86    !(line &amp; 2) : !(line &amp; 1))
  87 #define IS_CHROMA_LINE_410(line, flags)         \
  88   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  89    !(line &amp; 6) : !(line &amp; 3))
  90 
  91 #define IS_ALIGNED(x,n) ((((guintptr)(x)&amp;((n)-1))) == 0)
  92 
  93 #define PACK_420 GST_VIDEO_FORMAT_AYUV, unpack_planar_420, 1, pack_planar_420
  94 static void
  95 unpack_planar_420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
  96     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
  97     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
  98 {
  99   gint uv = GET_UV_420 (y, flags);
 100   const guint8 *restrict sy = GET_Y_LINE (y);
 101   const guint8 *restrict su = GET_U_LINE (uv);
 102   const guint8 *restrict sv = GET_V_LINE (uv);
 103   guint8 *restrict d = dest;
 104 
 105   sy += x;
 106   su += x &gt;&gt; 1;
 107   sv += x &gt;&gt; 1;
 108 
 109   if (x &amp; 1) {
 110     d[0] = 0xff;
 111     d[1] = *sy++;
 112     d[2] = *su++;
 113     d[3] = *sv++;
 114     width--;
 115     d += 4;
 116   }
 117   video_orc_unpack_I420 (d, sy, su, sv, width);
 118 }
 119 
 120 static void
 121 pack_planar_420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 122     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 123     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 124     gint y, gint width)
 125 {
 126   gint uv = GET_UV_420 (y, flags);
 127   guint8 *dy = GET_Y_LINE (y);
 128   guint8 *du = GET_U_LINE (uv);
 129   guint8 *dv = GET_V_LINE (uv);
 130   const guint8 *s = src;
 131 
 132   if (IS_CHROMA_LINE_420 (y, flags)) {
 133     if (IS_ALIGNED (s, 8))
 134       video_orc_pack_I420 (dy, du, dv, s, width / 2);
 135     else {
 136       gint i;
 137 
 138       for (i = 0; i &lt; width / 2; i++) {
 139         dy[i * 2 + 0] = s[i * 8 + 1];
 140         dy[i * 2 + 1] = s[i * 8 + 5];
 141         du[i] = s[i * 8 + 2];
 142         dv[i] = s[i * 8 + 3];
 143       }
 144     }
<a name="1" id="anc1"></a><span class="line-modified"> 145     if (width &amp; 1) {</span>
<span class="line-modified"> 146       gint i = width - 1;</span>
 147 
 148       dy[i] = s[i * 4 + 1];
 149       du[i &gt;&gt; 1] = s[i * 4 + 2];
 150       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<a name="2" id="anc2"></a><span class="line-modified"> 151     }</span>
 152   } else
 153     video_orc_pack_Y (dy, s, width);
 154 }
 155 
 156 #define PACK_YUY2 GST_VIDEO_FORMAT_AYUV, unpack_YUY2, 1, pack_YUY2
 157 static void
 158 unpack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 159     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 160     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 161 {
 162   const guint8 *restrict s = GET_LINE (y);
 163   guint8 *restrict d = dest;
 164 
 165   s += (x &amp; ~1) &lt;&lt; 1;
 166   if (x &amp; 1) {
 167     d[0] = 0xff;
 168     d[1] = s[2];
 169     d[2] = s[1];
 170     d[3] = s[3];
 171     s += 4;
 172     d += 4;
 173     width--;
 174   }
 175 
 176   if (IS_ALIGNED (d, 8))
 177     video_orc_unpack_YUY2 (d, s, width / 2);
 178   else {
 179     gint i;
 180 
 181     for (i = 0; i &lt; width / 2; i++) {
 182       d[i * 8 + 0] = 0xff;
 183       d[i * 8 + 1] = s[i * 4 + 0];
 184       d[i * 8 + 2] = s[i * 4 + 1];
 185       d[i * 8 + 3] = s[i * 4 + 3];
 186       d[i * 8 + 4] = 0xff;
 187       d[i * 8 + 5] = s[i * 4 + 2];
 188       d[i * 8 + 6] = s[i * 4 + 1];
 189       d[i * 8 + 7] = s[i * 4 + 3];
 190     }
 191   }
 192 
 193   if (width &amp; 1) {
 194     gint i = width - 1;
 195 
 196     d[i * 4 + 0] = 0xff;
 197     d[i * 4 + 1] = s[i * 2 + 0];
 198     d[i * 4 + 2] = s[i * 2 + 1];
 199     d[i * 4 + 3] = s[i * 2 + 3];
 200   }
 201 }
 202 
 203 static void
 204 pack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 205     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 206     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 207     gint y, gint width)
 208 {
 209   guint8 *restrict d = GET_LINE (y);
 210   const guint8 *restrict s = src;
 211 
 212   if (IS_ALIGNED (s, 8))
 213     video_orc_pack_YUY2 (d, s, width / 2);
 214   else {
 215     gint i;
 216     for (i = 0; i &lt; width / 2; i++) {
 217       d[i * 4 + 0] = s[i * 8 + 1];
 218       d[i * 4 + 1] = s[i * 8 + 2];
 219       d[i * 4 + 2] = s[i * 8 + 5];
 220       d[i * 4 + 3] = s[i * 8 + 3];
 221     }
 222   }
 223 
 224   if (width &amp; 1) {
 225     gint i = width - 1;
 226 
 227     d[i * 2 + 0] = s[i * 4 + 1];
 228     d[i * 2 + 1] = s[i * 4 + 2];
 229     d[i * 2 + 3] = s[i * 4 + 3];
 230   }
 231 }
 232 
 233 #define PACK_UYVY GST_VIDEO_FORMAT_AYUV, unpack_UYVY, 1, pack_UYVY
 234 static void
 235 unpack_UYVY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 236     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 237     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 238 {
 239   const guint8 *s = GET_LINE (y);
 240   guint8 *d = dest;
 241 
 242   s += (x &amp; ~1) &lt;&lt; 1;
 243   if (x &amp; 1) {
 244     d[0] = 0xff;
 245     d[1] = s[3];
 246     d[2] = s[0];
 247     d[3] = s[2];
 248     s += 4;
 249     d += 4;
 250     width--;
 251   }
 252 
 253   if (IS_ALIGNED (d, 8))
 254     video_orc_unpack_UYVY (d, s, width / 2);
 255   else {
 256     gint i;
 257 
 258     for (i = 0; i &lt; width / 2; i++) {
 259       d[i * 8 + 0] = 0xff;
 260       d[i * 8 + 1] = s[i * 4 + 1];
 261       d[i * 8 + 2] = s[i * 4 + 0];
 262       d[i * 8 + 3] = s[i * 4 + 2];
 263       d[i * 8 + 4] = 0xff;
 264       d[i * 8 + 5] = s[i * 4 + 3];
 265       d[i * 8 + 6] = s[i * 4 + 0];
 266       d[i * 8 + 7] = s[i * 4 + 2];
 267     }
 268   }
 269 
 270   if (width &amp; 1) {
 271     gint i = width - 1;
 272 
 273     d[i * 4 + 0] = 0xff;
 274     d[i * 4 + 1] = s[i * 2 + 1];
 275     d[i * 4 + 2] = s[i * 2 + 0];
 276     d[i * 4 + 3] = s[i * 2 + 2];
 277   }
 278 }
 279 
 280 static void
 281 pack_UYVY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 282     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 283     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 284     gint y, gint width)
 285 {
 286   guint8 *restrict d = GET_LINE (y);
 287   const guint8 *restrict s = src;
 288 
 289   if (IS_ALIGNED (s, 8))
 290     video_orc_pack_UYVY (d, s, width / 2);
 291   else {
 292     gint i;
 293     for (i = 0; i &lt; width / 2; i++) {
 294       d[i * 4 + 0] = s[i * 8 + 2];
 295       d[i * 4 + 1] = s[i * 8 + 1];
 296       d[i * 4 + 2] = s[i * 8 + 3];
 297       d[i * 4 + 3] = s[i * 8 + 5];
 298     }
 299   }
 300   if (width &amp; 1) {
 301     gint i = width - 1;
 302 
 303     d[i * 2 + 0] = s[i * 4 + 2];
 304     d[i * 2 + 1] = s[i * 4 + 1];
 305     d[i * 2 + 2] = s[i * 4 + 3];
 306   }
 307 }
 308 
 309 #define PACK_VYUY GST_VIDEO_FORMAT_AYUV, unpack_VYUY, 1, pack_VYUY
 310 static void
 311 unpack_VYUY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 312     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 313     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 314 {
 315   const guint8 *s = GET_LINE (y);
 316   guint8 *d = dest;
 317 
 318   s += (x &amp; ~1) &lt;&lt; 1;
 319   if (x &amp; 1) {
 320     d[0] = 0xff;
 321     d[1] = s[3];
 322     d[2] = s[0];
 323     d[3] = s[2];
 324     s += 4;
 325     d += 4;
 326     width--;
 327   }
 328 
 329   if (IS_ALIGNED (d, 8))
 330     video_orc_unpack_VYUY (d, s, width / 2);
 331   else {
 332     gint i;
 333 
 334     for (i = 0; i &lt; width / 2; i++) {
 335       d[i * 8 + 0] = 0xff;
 336       d[i * 8 + 1] = s[i * 4 + 1];
 337       d[i * 8 + 2] = s[i * 4 + 0];
 338       d[i * 8 + 3] = s[i * 4 + 2];
 339       d[i * 8 + 4] = 0xff;
 340       d[i * 8 + 5] = s[i * 4 + 3];
 341       d[i * 8 + 6] = s[i * 4 + 0];
 342       d[i * 8 + 7] = s[i * 4 + 2];
 343     }
 344   }
 345 
 346   if (width &amp; 1) {
 347     gint i = width - 1;
 348 
 349     d[i * 4 + 0] = 0xff;
 350     d[i * 4 + 1] = s[i * 2 + 1];
 351     d[i * 4 + 2] = s[i * 2 + 0];
 352     d[i * 4 + 3] = s[i * 2 + 2];
 353   }
 354 }
 355 
 356 static void
 357 pack_VYUY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 358     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 359     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 360     gint y, gint width)
 361 {
 362   guint8 *restrict d = GET_LINE (y);
 363   const guint8 *restrict s = src;
 364 
 365   if (IS_ALIGNED (s, 8))
 366     video_orc_pack_VYUY (d, s, width / 2);
 367   else {
 368     gint i;
 369     for (i = 0; i &lt; width / 2; i++) {
 370       d[i * 4 + 0] = s[i * 8 + 2];
 371       d[i * 4 + 1] = s[i * 8 + 1];
 372       d[i * 4 + 2] = s[i * 8 + 3];
 373       d[i * 4 + 3] = s[i * 8 + 5];
 374     }
 375   }
 376   if (width &amp; 1) {
 377     gint i = width - 1;
 378 
 379     d[i * 2 + 0] = s[i * 4 + 2];
 380     d[i * 2 + 1] = s[i * 4 + 1];
 381     d[i * 2 + 2] = s[i * 4 + 3];
 382   }
 383 }
 384 
 385 #define PACK_YVYU GST_VIDEO_FORMAT_AYUV, unpack_YVYU, 1, pack_YVYU
 386 static void
 387 unpack_YVYU (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 388     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 389     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 390 {
 391   const guint8 *restrict s = GET_LINE (y);
 392   guint8 *restrict d = dest;
 393 
 394   s += (x &amp; ~1) &lt;&lt; 1;
 395   if (x &amp; 1) {
 396     d[0] = 0xff;
 397     d[1] = s[2];
 398     d[2] = s[3];
 399     d[3] = s[1];
 400     s += 4;
 401     d += 4;
 402     width--;
 403   }
 404 
 405   if (IS_ALIGNED (d, 8))
 406     video_orc_unpack_YVYU (d, s, width / 2);
 407   else {
 408     gint i;
 409 
 410     for (i = 0; i &lt; width / 2; i++) {
 411       d[i * 8 + 0] = 0xff;
 412       d[i * 8 + 1] = s[i * 4 + 0];
 413       d[i * 8 + 2] = s[i * 4 + 3];
 414       d[i * 8 + 3] = s[i * 4 + 1];
 415       d[i * 8 + 4] = 0xff;
 416       d[i * 8 + 5] = s[i * 4 + 2];
 417       d[i * 8 + 6] = s[i * 4 + 3];
 418       d[i * 8 + 7] = s[i * 4 + 1];
 419     }
 420   }
 421 
 422   if (width &amp; 1) {
 423     gint i = width - 1;
 424 
 425     d[i * 4 + 0] = 0xff;
 426     d[i * 4 + 1] = s[i * 2 + 0];
 427     d[i * 4 + 2] = s[i * 2 + 3];
 428     d[i * 4 + 3] = s[i * 2 + 1];
 429   }
 430 }
 431 
 432 static void
 433 pack_YVYU (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 434     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 435     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 436     gint y, gint width)
 437 {
 438   guint8 *restrict d = GET_LINE (y);
 439   const guint8 *restrict s = src;
 440 
 441   if (IS_ALIGNED (s, 8))
 442     video_orc_pack_YVYU (d, s, width / 2);
 443   else {
 444     gint i;
 445     for (i = 0; i &lt; width / 2; i++) {
 446       d[i * 4 + 0] = s[i * 8 + 1];
 447       d[i * 4 + 1] = s[i * 8 + 3];
 448       d[i * 4 + 2] = s[i * 8 + 5];
 449       d[i * 4 + 3] = s[i * 8 + 2];
 450     }
 451   }
 452 
 453   if (width &amp; 1) {
 454     gint i = width - 1;
 455 
 456     d[i * 2 + 0] = s[i * 4 + 1];
 457     d[i * 2 + 1] = s[i * 4 + 3];
 458     d[i * 2 + 3] = s[i * 4 + 2];
 459   }
 460 }
 461 
 462 #define PACK_v308 GST_VIDEO_FORMAT_AYUV, unpack_v308, 1, pack_v308
 463 static void
 464 unpack_v308 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 465     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 466     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 467 {
 468   int i;
 469   const guint8 *restrict s = GET_LINE (y);
 470   guint8 *restrict d = dest;
 471 
 472   s += x * 3;
 473 
 474   for (i = 0; i &lt; width; i++) {
 475     d[i * 4 + 0] = 0xff;
 476     d[i * 4 + 1] = s[i * 3 + 0];
 477     d[i * 4 + 2] = s[i * 3 + 1];
 478     d[i * 4 + 3] = s[i * 3 + 2];
 479   }
 480 }
 481 
 482 static void
 483 pack_v308 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 484     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 485     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 486     gint y, gint width)
 487 {
 488   int i;
 489   guint8 *restrict d = GET_LINE (y);
 490   const guint8 *restrict s = src;
 491 
 492   for (i = 0; i &lt; width; i++) {
 493     d[i * 3 + 0] = s[i * 4 + 1];
 494     d[i * 3 + 1] = s[i * 4 + 2];
 495     d[i * 3 + 2] = s[i * 4 + 3];
 496   }
 497 }
 498 
 499 #define PACK_IYU2 GST_VIDEO_FORMAT_AYUV, unpack_IYU2, 1, pack_IYU2
 500 static void
 501 unpack_IYU2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 502     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 503     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 504 {
 505   int i;
 506   const guint8 *restrict s = GET_LINE (y);
 507   guint8 *restrict d = dest;
 508 
 509   s += x * 3;
 510 
 511   for (i = 0; i &lt; width; i++) {
 512     d[i * 4 + 0] = 0xff;
 513     d[i * 4 + 1] = s[i * 3 + 1];
 514     d[i * 4 + 2] = s[i * 3 + 0];
 515     d[i * 4 + 3] = s[i * 3 + 2];
 516   }
 517 }
 518 
 519 static void
 520 pack_IYU2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 521     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 522     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 523     gint y, gint width)
 524 {
 525   int i;
 526   guint8 *restrict d = GET_LINE (y);
 527   const guint8 *restrict s = src;
 528 
 529   for (i = 0; i &lt; width; i++) {
 530     d[i * 3 + 0] = s[i * 4 + 2];
 531     d[i * 3 + 1] = s[i * 4 + 1];
 532     d[i * 3 + 2] = s[i * 4 + 3];
 533   }
 534 }
 535 
 536 #define PACK_AYUV GST_VIDEO_FORMAT_AYUV, unpack_copy4, 1, pack_copy4
 537 #define PACK_ARGB GST_VIDEO_FORMAT_ARGB, unpack_copy4, 1, pack_copy4
 538 static void
 539 unpack_copy4 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 540     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 541     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 542 {
 543   const guint8 *restrict s = GET_LINE (y);
 544 
 545   s += x * 4;
 546 
 547   memcpy (dest, s, width * 4);
 548 }
 549 
 550 static void
 551 pack_copy4 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 552     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 553     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 554     gint y, gint width)
 555 {
 556   guint8 *restrict d = GET_LINE (y);
 557 
 558   memcpy (d, src, width * 4);
 559 }
 560 
 561 #define PACK_v210 GST_VIDEO_FORMAT_AYUV64, unpack_v210, 1, pack_v210
 562 static void
 563 unpack_v210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 564     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 565     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 566 {
 567   int i;
 568   const guint8 *restrict s = GET_LINE (y);
 569   guint16 *restrict d = dest;
 570   guint32 a0, a1, a2, a3;
 571   guint16 y0, y1, y2, y3, y4, y5;
 572   guint16 u0, u2, u4;
 573   guint16 v0, v2, v4;
 574 
 575   /* FIXME */
 576   s += x * 2;
 577 
 578   for (i = 0; i &lt; width; i += 6) {
 579     a0 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 0);
 580     a1 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 4);
 581     a2 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 8);
 582     a3 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 12);
 583 
 584     u0 = ((a0 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 585     y0 = ((a0 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 586     v0 = ((a0 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 587     y1 = ((a1 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 588 
 589     u2 = ((a1 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 590     y2 = ((a1 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 591     v2 = ((a2 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 592     y3 = ((a2 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 593 
 594     u4 = ((a2 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 595     y4 = ((a3 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 596     v4 = ((a3 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 597     y5 = ((a3 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 598 
 599     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
 600       y0 |= (y0 &gt;&gt; 10);
 601       y1 |= (y1 &gt;&gt; 10);
 602       u0 |= (u0 &gt;&gt; 10);
 603       v0 |= (v0 &gt;&gt; 10);
 604 
 605       y2 |= (y2 &gt;&gt; 10);
 606       y3 |= (y3 &gt;&gt; 10);
 607       u2 |= (u2 &gt;&gt; 10);
 608       v2 |= (v2 &gt;&gt; 10);
 609 
 610       y4 |= (y4 &gt;&gt; 10);
 611       y5 |= (y5 &gt;&gt; 10);
 612       u4 |= (u4 &gt;&gt; 10);
 613       v4 |= (v4 &gt;&gt; 10);
 614     }
 615 
 616     d[4 * (i + 0) + 0] = 0xffff;
 617     d[4 * (i + 0) + 1] = y0;
 618     d[4 * (i + 0) + 2] = u0;
 619     d[4 * (i + 0) + 3] = v0;
 620 
 621     if (i &lt; width - 1) {
 622       d[4 * (i + 1) + 0] = 0xffff;
 623       d[4 * (i + 1) + 1] = y1;
 624       d[4 * (i + 1) + 2] = u0;
 625       d[4 * (i + 1) + 3] = v0;
 626     }
 627     if (i &lt; width - 2) {
 628       d[4 * (i + 2) + 0] = 0xffff;
 629       d[4 * (i + 2) + 1] = y2;
 630       d[4 * (i + 2) + 2] = u2;
 631       d[4 * (i + 2) + 3] = v2;
 632     }
 633     if (i &lt; width - 3) {
 634       d[4 * (i + 3) + 0] = 0xffff;
 635       d[4 * (i + 3) + 1] = y3;
 636       d[4 * (i + 3) + 2] = u2;
 637       d[4 * (i + 3) + 3] = v2;
 638     }
 639     if (i &lt; width - 4) {
 640       d[4 * (i + 4) + 0] = 0xffff;
 641       d[4 * (i + 4) + 1] = y4;
 642       d[4 * (i + 4) + 2] = u4;
 643       d[4 * (i + 4) + 3] = v4;
 644     }
 645     if (i &lt; width - 5) {
 646       d[4 * (i + 5) + 0] = 0xffff;
 647       d[4 * (i + 5) + 1] = y5;
 648       d[4 * (i + 5) + 2] = u4;
 649       d[4 * (i + 5) + 3] = v4;
 650     }
 651   }
 652 }
 653 
 654 static void
 655 pack_v210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 656     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 657     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 658     gint y, gint width)
 659 {
 660   int i;
 661   guint8 *restrict d = GET_LINE (y);
 662   const guint16 *restrict s = src;
 663   guint32 a0, a1, a2, a3;
 664   guint16 y0, y1, y2, y3, y4, y5;
 665   guint16 u0, u1, u2;
 666   guint16 v0, v1, v2;
 667 
 668   for (i = 0; i &lt; width - 5; i += 6) {
 669     y0 = s[4 * (i + 0) + 1] &gt;&gt; 6;
 670     y1 = s[4 * (i + 1) + 1] &gt;&gt; 6;
 671     y2 = s[4 * (i + 2) + 1] &gt;&gt; 6;
 672     y3 = s[4 * (i + 3) + 1] &gt;&gt; 6;
 673     y4 = s[4 * (i + 4) + 1] &gt;&gt; 6;
 674     y5 = s[4 * (i + 5) + 1] &gt;&gt; 6;
 675 
 676     u0 = s[4 * (i + 0) + 2] &gt;&gt; 6;
 677     u1 = s[4 * (i + 2) + 2] &gt;&gt; 6;
 678     u2 = s[4 * (i + 4) + 2] &gt;&gt; 6;
 679 
 680     v0 = s[4 * (i + 0) + 3] &gt;&gt; 6;
 681     v1 = s[4 * (i + 2) + 3] &gt;&gt; 6;
 682     v2 = s[4 * (i + 4) + 3] &gt;&gt; 6;
 683 
 684     a0 = u0 | (y0 &lt;&lt; 10) | (v0 &lt;&lt; 20);
 685     a1 = y1 | (u1 &lt;&lt; 10) | (y2 &lt;&lt; 20);
 686     a2 = v1 | (y3 &lt;&lt; 10) | (u2 &lt;&lt; 20);
 687     a3 = y4 | (v2 &lt;&lt; 10) | (y5 &lt;&lt; 20);
 688 
 689     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 0, a0);
 690     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 4, a1);
 691     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 8, a2);
 692     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 12, a3);
 693   }
 694   if (i &lt; width) {
 695     y0 = s[4 * (i + 0) + 1] &gt;&gt; 6;
 696     u0 = s[4 * (i + 0) + 2] &gt;&gt; 6;
 697     v0 = s[4 * (i + 0) + 3] &gt;&gt; 6;
 698     if (i &lt; width - 1)
 699       y1 = s[4 * (i + 1) + 1] &gt;&gt; 6;
 700     else
 701       y1 = y0;
 702     if (i &lt; width - 2) {
 703       y2 = s[4 * (i + 2) + 1] &gt;&gt; 6;
 704       u1 = s[4 * (i + 2) + 2] &gt;&gt; 6;
 705       v1 = s[4 * (i + 2) + 3] &gt;&gt; 6;
 706     } else {
 707       y2 = y1;
 708       u1 = u0;
 709       v1 = v0;
 710     }
 711     if (i &lt; width - 3)
 712       y3 = s[4 * (i + 3) + 1] &gt;&gt; 6;
 713     else
 714       y3 = y2;
 715     if (i &lt; width - 4) {
 716       y4 = s[4 * (i + 4) + 1] &gt;&gt; 6;
 717       u2 = s[4 * (i + 4) + 2] &gt;&gt; 6;
 718       v2 = s[4 * (i + 4) + 3] &gt;&gt; 6;
 719     } else {
 720       y4 = y3;
 721       u2 = u1;
 722       v2 = v1;
 723     }
 724     y5 = y4;
 725 
 726     a0 = u0 | (y0 &lt;&lt; 10) | (v0 &lt;&lt; 20);
 727     a1 = y1 | (u1 &lt;&lt; 10) | (y2 &lt;&lt; 20);
 728     a2 = v1 | (y3 &lt;&lt; 10) | (u2 &lt;&lt; 20);
 729     a3 = y4 | (v2 &lt;&lt; 10) | (y5 &lt;&lt; 20);
 730 
 731     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 0, a0);
 732     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 4, a1);
 733     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 8, a2);
 734     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 12, a3);
 735   }
 736 }
 737 
 738 #define PACK_v216 GST_VIDEO_FORMAT_AYUV64, unpack_v216, 1, pack_v216
 739 static void
 740 unpack_v216 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 741     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 742     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 743 {
 744   int i;
 745   const guint8 *restrict s = GET_LINE (y);
 746   guint16 *restrict d = dest;
 747 
 748   s += (x &amp; ~1) &lt;&lt; 2;
 749   if (x &amp; 1) {
 750     d[0] = 0xffff;
 751     d[1] = GST_READ_UINT16_LE (s + 6);
 752     d[2] = GST_READ_UINT16_LE (s + 0);
 753     d[3] = GST_READ_UINT16_LE (s + 4);
 754     s += 8;
 755     d += 4;
 756     width--;
 757   }
 758 
 759   for (i = 0; i &lt; width; i++) {
 760     d[i * 4 + 0] = 0xffff;
 761     d[i * 4 + 1] = GST_READ_UINT16_LE (s + i * 4 + 2);
 762     d[i * 4 + 2] = GST_READ_UINT16_LE (s + (i &gt;&gt; 1) * 8 + 0);
 763     d[i * 4 + 3] = GST_READ_UINT16_LE (s + (i &gt;&gt; 1) * 8 + 4);
 764   }
 765 }
 766 
 767 static void
 768 pack_v216 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 769     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 770     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 771     gint y, gint width)
 772 {
 773   int i;
 774   guint8 *restrict d = GET_LINE (y);
 775   const guint16 *restrict s = src;
 776 
 777   for (i = 0; i &lt; width - 1; i += 2) {
 778     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[(i + 0) * 4 + 2]);
 779     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[(i + 0) * 4 + 1]);
 780     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[(i + 0) * 4 + 3]);
 781     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[(i + 1) * 4 + 1]);
 782   }
 783   if (i == width - 1) {
 784     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[i * 4 + 2]);
 785     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[i * 4 + 1]);
 786     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[i * 4 + 3]);
 787     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[i * 4 + 1]);
 788   }
 789 }
 790 
<a name="3" id="anc3"></a><span class="line-added"> 791 #define PACK_Y210 GST_VIDEO_FORMAT_AYUV64, unpack_Y210, 1, pack_Y210</span>
<span class="line-added"> 792 static void</span>
<span class="line-added"> 793 unpack_Y210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 794     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 795     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added"> 796 {</span>
<span class="line-added"> 797   int i;</span>
<span class="line-added"> 798   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added"> 799   guint16 *restrict d = dest;</span>
<span class="line-added"> 800   guint Y0, Y1, U, V;</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802   s += GST_ROUND_DOWN_2 (x) * 4;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804   if (x &amp; 1) {</span>
<span class="line-added"> 805     Y1 = GST_READ_UINT16_LE (s + 4);</span>
<span class="line-added"> 806     U = GST_READ_UINT16_LE (s + 2);</span>
<span class="line-added"> 807     V = GST_READ_UINT16_LE (s + 6);</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 810       Y1 |= (Y1 &gt;&gt; 10);</span>
<span class="line-added"> 811       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 812       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     d[0] = 0xffff;</span>
<span class="line-added"> 816     d[1] = Y1;</span>
<span class="line-added"> 817     d[2] = U;</span>
<span class="line-added"> 818     d[3] = V;</span>
<span class="line-added"> 819     s += 8;</span>
<span class="line-added"> 820     d += 4;</span>
<span class="line-added"> 821     width--;</span>
<span class="line-added"> 822   }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824   for (i = 0; i &lt; width / 2; i++) {</span>
<span class="line-added"> 825     Y0 = GST_READ_UINT16_LE (s + i * 8 + 0);</span>
<span class="line-added"> 826     U = GST_READ_UINT16_LE (s + i * 8 + 2);</span>
<span class="line-added"> 827     V = GST_READ_UINT16_LE (s + i * 8 + 6);</span>
<span class="line-added"> 828     Y1 = GST_READ_UINT16_LE (s + i * 8 + 4);</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 831       Y0 |= (Y0 &gt;&gt; 10);</span>
<span class="line-added"> 832       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 833       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 834     }</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     d[i * 8 + 0] = 0xffff;</span>
<span class="line-added"> 837     d[i * 8 + 1] = Y0;</span>
<span class="line-added"> 838     d[i * 8 + 2] = U;</span>
<span class="line-added"> 839     d[i * 8 + 3] = V;</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841     d[i * 8 + 4] = 0xffff;</span>
<span class="line-added"> 842     d[i * 8 + 5] = Y1;</span>
<span class="line-added"> 843     d[i * 8 + 6] = U;</span>
<span class="line-added"> 844     d[i * 8 + 7] = V;</span>
<span class="line-added"> 845   }</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847   if (width &amp; 1) {</span>
<span class="line-added"> 848     i = width - 1;</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850     Y0 = GST_READ_UINT16_LE (s + i * 4 + 0);</span>
<span class="line-added"> 851     U = GST_READ_UINT16_LE (s + i * 4 + 2);</span>
<span class="line-added"> 852     V = GST_READ_UINT16_LE (s + i * 4 + 6);</span>
<span class="line-added"> 853 </span>
<span class="line-added"> 854     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 855       Y0 |= (Y0 &gt;&gt; 10);</span>
<span class="line-added"> 856       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 857       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 858     }</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860     d[i * 4 + 0] = 0xffff;</span>
<span class="line-added"> 861     d[i * 4 + 1] = Y0;</span>
<span class="line-added"> 862     d[i * 4 + 2] = U;</span>
<span class="line-added"> 863     d[i * 4 + 3] = V;</span>
<span class="line-added"> 864   }</span>
<span class="line-added"> 865 }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867 static void</span>
<span class="line-added"> 868 pack_Y210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 869     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 870     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added"> 871     gint y, gint width)</span>
<span class="line-added"> 872 {</span>
<span class="line-added"> 873   int i;</span>
<span class="line-added"> 874   guint16 Y0, Y1, U, V;</span>
<span class="line-added"> 875   guint8 *restrict d = GET_LINE (y);</span>
<span class="line-added"> 876   const guint16 *restrict s = src;</span>
<span class="line-added"> 877 </span>
<span class="line-added"> 878   for (i = 0; i &lt; width; i += 2) {</span>
<span class="line-added"> 879     Y0 = s[i * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 880     U = s[i * 4 + 2] &amp; 0xffc0;</span>
<span class="line-added"> 881     V = s[i * 4 + 3] &amp; 0xffc0;</span>
<span class="line-added"> 882     if (i == width - 1)</span>
<span class="line-added"> 883       Y1 = s[i * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 884     else</span>
<span class="line-added"> 885       Y1 = s[(i + 1) * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887     GST_WRITE_UINT16_LE (d + i * 4 + 0, Y0);</span>
<span class="line-added"> 888     GST_WRITE_UINT16_LE (d + i * 4 + 2, U);</span>
<span class="line-added"> 889     GST_WRITE_UINT16_LE (d + i * 4 + 4, Y1);</span>
<span class="line-added"> 890     GST_WRITE_UINT16_LE (d + i * 4 + 6, V);</span>
<span class="line-added"> 891   }</span>
<span class="line-added"> 892 }</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894 #define PACK_Y410 GST_VIDEO_FORMAT_AYUV64, unpack_Y410, 1, pack_Y410</span>
<span class="line-added"> 895 static void</span>
<span class="line-added"> 896 unpack_Y410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 897     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 898     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added"> 899 {</span>
<span class="line-added"> 900   int i;</span>
<span class="line-added"> 901   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added"> 902   guint16 *restrict d = dest;</span>
<span class="line-added"> 903   guint32 AVYU;</span>
<span class="line-added"> 904   guint16 A, Y, U, V;</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906   s += x * 4;</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added"> 909     AVYU = GST_READ_UINT32_LE (s + 4 * i);</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911     U = ((AVYU &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 912     Y = ((AVYU &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 913     V = ((AVYU &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 914     A = ((AVYU &gt;&gt; 30) &amp; 0x03) &lt;&lt; 14;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 917       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 918       Y |= (Y &gt;&gt; 10);</span>
<span class="line-added"> 919       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 920       A |= (A &gt;&gt; 10);</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     d[4 * i + 0] = A;</span>
<span class="line-added"> 924     d[4 * i + 1] = Y;</span>
<span class="line-added"> 925     d[4 * i + 2] = U;</span>
<span class="line-added"> 926     d[4 * i + 3] = V;</span>
<span class="line-added"> 927   }</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930 static void</span>
<span class="line-added"> 931 pack_Y410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 932     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 933     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added"> 934     gint y, gint width)</span>
<span class="line-added"> 935 {</span>
<span class="line-added"> 936   int i;</span>
<span class="line-added"> 937   guint32 *restrict d = GET_LINE (y);</span>
<span class="line-added"> 938   const guint16 *restrict s = src;</span>
<span class="line-added"> 939   guint32 AVYU;</span>
<span class="line-added"> 940   guint16 A, Y, U, V;</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added"> 943     A = s[4 * i] &amp; 0xc000;</span>
<span class="line-added"> 944     Y = s[4 * i + 1] &amp; 0xffc0;</span>
<span class="line-added"> 945     U = s[4 * i + 2] &amp; 0xffc0;</span>
<span class="line-added"> 946     V = s[4 * i + 3] &amp; 0xffc0;</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     AVYU = (U &gt;&gt; 6) | (Y &lt;&lt; 4) | (V &lt;&lt; 14) | (A &lt;&lt; 16);</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     GST_WRITE_UINT32_LE (d + i, AVYU);</span>
<span class="line-added"> 951   }</span>
<span class="line-added"> 952 }</span>
<span class="line-added"> 953 </span>
 954 #define PACK_Y41B GST_VIDEO_FORMAT_AYUV, unpack_Y41B, 1, pack_Y41B
 955 static void
 956 unpack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 957     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 958     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 959 {
 960   const guint8 *restrict sy = GET_Y_LINE (y);
 961   const guint8 *restrict su = GET_U_LINE (y);
 962   const guint8 *restrict sv = GET_V_LINE (y);
 963   guint8 *restrict d = dest;
 964 
 965   sy += x;
 966   su += x &gt;&gt; 2;
 967   sv += x &gt;&gt; 2;
 968 
 969   if (x &amp; 3) {
 970     for (; x &amp; 3; x++) {
 971       d[0] = 0xff;
 972       d[1] = *sy++;
 973       d[2] = *su;
 974       d[3] = *sv;
 975       width--;
 976       d += 4;
 977     }
 978     su++;
 979     sy++;
 980   }
 981 
 982   if (IS_ALIGNED (d, 8))
 983     video_orc_unpack_YUV9 (d, sy, su, sv, width / 2);
 984   else {
 985     gint i;
 986     for (i = 0; i &lt; width / 2; i++) {
 987       d[i * 8 + 0] = 0xff;
 988       d[i * 8 + 1] = sy[i * 2 + 0];
 989       d[i * 8 + 2] = su[i &gt;&gt; 1];
 990       d[i * 8 + 3] = sv[i &gt;&gt; 1];
 991       d[i * 8 + 4] = 0xff;
 992       d[i * 8 + 5] = sy[i * 2 + 1];
 993       d[i * 8 + 6] = su[i &gt;&gt; 1];
 994       d[i * 8 + 7] = sv[i &gt;&gt; 1];
 995     }
 996   }
 997 
 998   if (width &amp; 1) {
 999     gint i = width - 1;
1000 
1001     d[i * 4 + 0] = 0xff;
1002     d[i * 4 + 1] = sy[i];
1003     d[i * 4 + 2] = su[i &gt;&gt; 2];
1004     d[i * 4 + 3] = sv[i &gt;&gt; 2];
1005   }
1006 }
1007 
1008 static void
1009 pack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1010     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1011     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1012     gint y, gint width)
1013 {
1014   int i;
1015   guint8 *restrict dy = GET_Y_LINE (y);
1016   guint8 *restrict du = GET_U_LINE (y);
1017   guint8 *restrict dv = GET_V_LINE (y);
1018   const guint8 *restrict s = src;
1019 
1020   for (i = 0; i &lt; width - 3; i += 4) {
1021     dy[i] = s[i * 4 + 1];
1022     dy[i + 1] = s[i * 4 + 5];
1023     dy[i + 2] = s[i * 4 + 9];
1024     dy[i + 3] = s[i * 4 + 13];
1025 
1026     du[i &gt;&gt; 2] = s[i * 4 + 2];
1027     dv[i &gt;&gt; 2] = s[i * 4 + 3];
1028   }
1029   if (i &lt; width) {
1030     dy[i] = s[i * 4 + 1];
1031     du[i &gt;&gt; 2] = s[i * 4 + 2];
1032     dv[i &gt;&gt; 2] = s[i * 4 + 3];
1033     if (i &lt; width - 1)
1034       dy[i + 1] = s[i * 4 + 5];
1035     if (i &lt; width - 2)
1036       dy[i + 2] = s[i * 4 + 9];
1037   }
1038 }
1039 
1040 #define PACK_Y42B GST_VIDEO_FORMAT_AYUV, unpack_Y42B, 1, pack_Y42B
1041 static void
1042 unpack_Y42B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1043     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1044     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1045 {
1046   const guint8 *restrict sy = GET_Y_LINE (y);
1047   const guint8 *restrict su = GET_U_LINE (y);
1048   const guint8 *restrict sv = GET_V_LINE (y);
1049   guint8 *restrict d = dest;
1050 
1051   sy += x;
1052   su += x &gt;&gt; 1;
1053   sv += x &gt;&gt; 1;
1054 
1055   if (x &amp; 1) {
1056     d[0] = 0xff;
1057     d[1] = *sy++;
1058     d[2] = *su++;
1059     d[3] = *sv++;
1060     width--;
1061     d += 4;
1062   }
1063 
1064   if (IS_ALIGNED (d, 8))
1065     video_orc_unpack_Y42B (d, sy, su, sv, width / 2);
1066   else {
1067     gint i;
1068     for (i = 0; i &lt; width / 2; i++) {
1069       d[i * 8 + 0] = 0xff;
1070       d[i * 8 + 1] = sy[i * 2 + 0];
1071       d[i * 8 + 2] = su[i];
1072       d[i * 8 + 3] = sv[i];
1073       d[i * 8 + 4] = 0xff;
1074       d[i * 8 + 5] = sy[i * 2 + 1];
1075       d[i * 8 + 6] = su[i];
1076       d[i * 8 + 7] = sv[i];
1077     }
1078   }
1079 
1080   if (width &amp; 1) {
1081     gint i = width - 1;
1082 
1083     d[i * 4 + 0] = 0xff;
1084     d[i * 4 + 1] = sy[i];
1085     d[i * 4 + 2] = su[i &gt;&gt; 1];
1086     d[i * 4 + 3] = sv[i &gt;&gt; 1];
1087   }
1088 }
1089 
1090 static void
1091 pack_Y42B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1092     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1093     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1094     gint y, gint width)
1095 {
1096   guint8 *restrict dy = GET_Y_LINE (y);
1097   guint8 *restrict du = GET_U_LINE (y);
1098   guint8 *restrict dv = GET_V_LINE (y);
1099   const guint8 *restrict s = src;
1100 
1101   if (IS_ALIGNED (s, 8))
1102     video_orc_pack_Y42B (dy, du, dv, s, width / 2);
1103   else {
1104     gint i;
1105     for (i = 0; i &lt; width / 2; i++) {
1106       dy[i * 2 + 0] = s[i * 8 + 1];
1107       dy[i * 2 + 1] = s[i * 8 + 5];
1108       du[i] = s[i * 8 + 2];
1109       dv[i] = s[i * 8 + 3];
1110     }
1111   }
1112 
1113   if (width &amp; 1) {
1114     gint i = width - 1;
1115 
1116     dy[i] = s[i * 4 + 1];
1117     du[i &gt;&gt; 1] = s[i * 4 + 2];
1118     dv[i &gt;&gt; 1] = s[i * 4 + 3];
1119   }
1120 }
1121 
1122 #define PACK_Y444 GST_VIDEO_FORMAT_AYUV, unpack_Y444, 1, pack_Y444
1123 static void
1124 unpack_Y444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1125     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1126     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1127 {
1128   const guint8 *restrict sy = GET_Y_LINE (y);
1129   const guint8 *restrict su = GET_U_LINE (y);
1130   const guint8 *restrict sv = GET_V_LINE (y);
1131 
1132   sy += x;
1133   su += x;
1134   sv += x;
1135 
1136   video_orc_unpack_Y444 (dest, sy, su, sv, width);
1137 }
1138 
1139 static void
1140 pack_Y444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1141     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1142     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1143     gint y, gint width)
1144 {
1145   guint8 *restrict dy = GET_Y_LINE (y);
1146   guint8 *restrict du = GET_U_LINE (y);
1147   guint8 *restrict dv = GET_V_LINE (y);
1148 
1149   video_orc_pack_Y444 (dy, du, dv, src, width);
1150 }
1151 
1152 #define PACK_GBR GST_VIDEO_FORMAT_ARGB, unpack_GBR, 1, pack_GBR
1153 static void
1154 unpack_GBR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1155     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1156     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1157 {
1158   const guint8 *restrict sr = GET_R_LINE (y);
1159   const guint8 *restrict sg = GET_G_LINE (y);
1160   const guint8 *restrict sb = GET_B_LINE (y);
1161 
1162   sr += x;
1163   sg += x;
1164   sb += x;
1165 
1166   video_orc_unpack_Y444 (dest, sr, sg, sb, width);
1167 }
1168 
1169 static void
1170 pack_GBR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1171     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1172     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1173     gint y, gint width)
1174 {
1175   guint8 *restrict dr = GET_R_LINE (y);
1176   guint8 *restrict dg = GET_G_LINE (y);
1177   guint8 *restrict db = GET_B_LINE (y);
1178 
1179   video_orc_pack_Y444 (dr, dg, db, src, width);
1180 }
1181 
1182 #define PACK_GBRA GST_VIDEO_FORMAT_ARGB, unpack_GBRA, 1, pack_GBRA
1183 static void
1184 unpack_GBRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1185     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1186     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1187 {
1188   int i;
1189   const guint8 *sg = GET_G_LINE (y);
1190   const guint8 *sb = GET_B_LINE (y);
1191   const guint8 *sr = GET_R_LINE (y);
1192   const guint8 *sa = GET_A_LINE (y);
1193   guint8 *d = dest, G, B, R, A;
1194 
1195   sg += x;
1196   sb += x;
1197   sr += x;
1198   sa += x;
1199 
1200   for (i = 0; i &lt; width; i++) {
1201     G = GST_READ_UINT8 (sg + i);
1202     B = GST_READ_UINT8 (sb + i);
1203     R = GST_READ_UINT8 (sr + i);
1204     A = GST_READ_UINT8 (sa + i);
1205 
1206     d[i * 4 + 0] = A;
1207     d[i * 4 + 1] = R;
1208     d[i * 4 + 2] = G;
1209     d[i * 4 + 3] = B;
1210   }
1211 }
1212 
1213 static void
1214 pack_GBRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1215     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1216     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1217     gint y, gint width)
1218 {
1219   int i;
1220   guint8 *restrict dg = GET_G_LINE (y);
1221   guint8 *restrict db = GET_B_LINE (y);
1222   guint8 *restrict dr = GET_R_LINE (y);
1223   guint8 *restrict da = GET_A_LINE (y);
1224   guint8 G, B, R, A;
1225   const guint8 *restrict s = src;
1226 
1227   for (i = 0; i &lt; width; i++) {
1228     G = (s[i * 4 + 2]);
1229     B = (s[i * 4 + 3]);
1230     R = (s[i * 4 + 1]);
1231     A = (s[i * 4 + 0]);
1232 
1233     GST_WRITE_UINT8 (dg + i, G);
1234     GST_WRITE_UINT8 (db + i, B);
1235     GST_WRITE_UINT8 (dr + i, R);
1236     GST_WRITE_UINT8 (da + i, A);
1237   }
1238 }
1239 
1240 #define PACK_GRAY8 GST_VIDEO_FORMAT_AYUV, unpack_GRAY8, 1, pack_GRAY8
1241 static void
1242 unpack_GRAY8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1243     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1244     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1245 {
1246   const guint8 *restrict s = GET_LINE (y);
1247 
1248   s += x;
1249 
1250   video_orc_unpack_GRAY8 (dest, s, width);
1251 }
1252 
1253 static void
1254 pack_GRAY8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1255     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1256     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1257     gint y, gint width)
1258 {
1259   guint8 *restrict d = GET_LINE (y);
1260 
1261   video_orc_pack_GRAY8 (d, src, width);
1262 }
1263 
1264 #define PACK_GRAY16_BE GST_VIDEO_FORMAT_AYUV64, unpack_GRAY16_BE, 1, pack_GRAY16_BE
1265 static void
1266 unpack_GRAY16_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1267     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1268     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1269 {
1270   int i;
1271   const guint16 *restrict s = GET_LINE (y);
1272   guint16 *restrict d = dest;
1273 
1274   s += x;
1275 
1276   for (i = 0; i &lt; width; i++) {
1277     d[i * 4 + 0] = 0xffff;
1278     d[i * 4 + 1] = GST_READ_UINT16_BE (s + i);
1279     d[i * 4 + 2] = 0x8000;
1280     d[i * 4 + 3] = 0x8000;
1281   }
1282 }
1283 
1284 static void
1285 pack_GRAY16_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1286     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1287     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1288     gint y, gint width)
1289 {
1290   int i;
1291   guint16 *restrict d = GET_LINE (y);
1292   const guint16 *restrict s = src;
1293 
1294   for (i = 0; i &lt; width; i++) {
1295     GST_WRITE_UINT16_BE (d + i, s[i * 4 + 1]);
1296   }
1297 }
1298 
1299 #define PACK_GRAY16_LE GST_VIDEO_FORMAT_AYUV64, unpack_GRAY16_LE, 1, pack_GRAY16_LE
1300 static void
1301 unpack_GRAY16_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1302     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1303     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1304 {
1305   int i;
1306   const guint16 *restrict s = GET_LINE (y);
1307   guint16 *restrict d = dest;
1308 
1309   s += x;
1310 
1311   for (i = 0; i &lt; width; i++) {
1312     d[i * 4 + 0] = 0xffff;
1313     d[i * 4 + 1] = GST_READ_UINT16_LE (s + i);
1314     d[i * 4 + 2] = 0x8000;
1315     d[i * 4 + 3] = 0x8000;
1316   }
1317 }
1318 
1319 static void
1320 pack_GRAY16_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1321     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1322     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1323     gint y, gint width)
1324 {
1325   int i;
1326   guint16 *restrict d = GET_LINE (y);
1327   const guint16 *restrict s = src;
1328 
1329   for (i = 0; i &lt; width; i++) {
1330     GST_WRITE_UINT16_LE (d + i, s[i * 4 + 1]);
1331   }
1332 }
1333 
1334 #define PACK_RGB16 GST_VIDEO_FORMAT_ARGB, unpack_RGB16, 1, pack_RGB16
1335 static void
1336 unpack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1337     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1338     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1339 {
1340   const guint16 *restrict s = GET_LINE (y);
1341 
1342   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1343     video_orc_unpack_RGB16_trunc (dest, s + x, width);
1344   else
1345     video_orc_unpack_RGB16 (dest, s + x, width);
<a name="4" id="anc4"></a><span class="line-modified">1346 }</span>
1347 
1348 static void
1349 pack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1350     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1351     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1352     gint y, gint width)
1353 {
1354   guint16 *restrict d = GET_LINE (y);
1355 
1356 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1357   video_orc_pack_RGB16_le (d, src, width);
1358 #else
1359   video_orc_pack_RGB16_be (d, src, width);
1360 #endif
<a name="5" id="anc5"></a><span class="line-modified">1361 }</span>
1362 
1363 #define PACK_BGR16 GST_VIDEO_FORMAT_ARGB, unpack_BGR16, 1, pack_BGR16
1364 static void
1365 unpack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1366     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1367     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1368 {
1369   const guint16 *restrict s = GET_LINE (y);
1370 
1371   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1372     video_orc_unpack_BGR16_trunc (dest, s + x, width);
1373   else
1374     video_orc_unpack_BGR16 (dest, s + x, width);
<a name="6" id="anc6"></a><span class="line-modified">1375 }</span>
1376 
1377 static void
1378 pack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1379     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1380     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1381     gint y, gint width)
1382 {
1383   guint16 *restrict d = GET_LINE (y);
1384 
1385 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1386   video_orc_pack_BGR16_le (d, src, width);
1387 #else
1388   video_orc_pack_BGR16_be (d, src, width);
1389 #endif
<a name="7" id="anc7"></a><span class="line-modified">1390 }</span>
1391 
1392 #define PACK_RGB15 GST_VIDEO_FORMAT_ARGB, unpack_RGB15, 1, pack_RGB15
1393 static void
1394 unpack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1395     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1396     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1397 {
1398   const guint16 *restrict s = GET_LINE (y);
1399 
1400 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1401   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1402     video_orc_unpack_RGB15_le_trunc (dest, s + x, width);
1403   else
1404     video_orc_unpack_RGB15_le (dest, s + x, width);
1405 #else
1406   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1407     video_orc_unpack_RGB15_be_trunc (dest, s + x, width);
1408   else
1409     video_orc_unpack_RGB15_be (dest, s + x, width);
1410 #endif
<a name="8" id="anc8"></a><span class="line-modified">1411 }</span>
1412 
1413 static void
1414 pack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1415     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1416     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1417     gint y, gint width)
1418 {
1419   guint16 *restrict d = GET_LINE (y);
1420 
1421 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1422   video_orc_pack_RGB15_le (d, src, width);
1423 #else
1424   video_orc_pack_RGB15_be (d, src, width);
1425 #endif
<a name="9" id="anc9"></a><span class="line-modified">1426 }</span>
1427 
1428 #define PACK_BGR15 GST_VIDEO_FORMAT_ARGB, unpack_BGR15, 1, pack_BGR15
1429 static void
1430 unpack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1431     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1432     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1433 {
1434   const guint16 *restrict s = GET_LINE (y);
1435 
1436 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1437   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1438     video_orc_unpack_BGR15_le_trunc (dest, s + x, width);
1439   else
1440     video_orc_unpack_BGR15_le (dest, s + x, width);
1441 #else
1442   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1443     video_orc_unpack_BGR15_be_trunc (dest, s + x, width);
1444   else
1445     video_orc_unpack_BGR15_be (dest, s + x, width);
1446 #endif
<a name="10" id="anc10"></a><span class="line-modified">1447 }</span>
1448 
1449 static void
1450 pack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1451     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1452     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1453     gint y, gint width)
1454 {
1455   guint16 *restrict d = GET_LINE (y);
1456 
1457 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1458   video_orc_pack_BGR15_le (d, src, width);
1459 #else
1460   video_orc_pack_BGR15_be (d, src, width);
1461 #endif
<a name="11" id="anc11"></a><span class="line-modified">1462 }</span>
1463 
1464 #define PACK_BGRA GST_VIDEO_FORMAT_ARGB, unpack_BGRA, 1, pack_BGRA
1465 static void
1466 unpack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1467     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1468     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1469 {
1470   const guint8 *restrict s = GET_LINE (y);
1471 
1472   s += x * 4;
1473 
1474   video_orc_unpack_BGRA (dest, s, width);
1475 }
1476 
1477 static void
1478 pack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1479     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1480     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1481     gint y, gint width)
1482 {
1483   guint8 *restrict d = GET_LINE (y);
1484 
1485   video_orc_pack_BGRA (d, src, width);
1486 }
1487 
1488 #define PACK_ABGR GST_VIDEO_FORMAT_ARGB, unpack_ABGR, 1, pack_ABGR
1489 static void
1490 unpack_ABGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1491     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1492     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1493 {
1494   const guint8 *restrict s = GET_LINE (y);
1495 
1496   s += x * 4;
1497 
1498 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1499   video_orc_unpack_ABGR_le (dest, s, width);
1500 #else
1501   video_orc_unpack_ABGR_be (dest, s, width);
1502 #endif
1503 }
1504 
1505 static void
1506 pack_ABGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1507     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1508     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1509     gint y, gint width)
1510 {
1511   guint8 *restrict d = GET_LINE (y);
1512 
1513 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1514   video_orc_pack_ABGR_le (d, src, width);
1515 #else
1516   video_orc_pack_ABGR_be (d, src, width);
1517 #endif
1518 }
1519 
1520 #define PACK_RGBA GST_VIDEO_FORMAT_ARGB, unpack_RGBA, 1, pack_RGBA
1521 static void
1522 unpack_RGBA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1523     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1524     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1525 {
1526   const guint8 *restrict s = GET_LINE (y);
1527 
1528   s += x * 4;
1529 
1530 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1531   video_orc_unpack_RGBA_le (dest, s, width);
1532 #else
1533   video_orc_unpack_RGBA_be (dest, s, width);
1534 #endif
1535 }
1536 
1537 static void
1538 pack_RGBA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1539     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1540     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1541     gint y, gint width)
1542 {
1543   guint8 *restrict d = GET_LINE (y);
1544 
1545 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1546   video_orc_pack_RGBA_le (d, src, width);
1547 #else
1548   video_orc_pack_RGBA_be (d, src, width);
1549 #endif
1550 }
1551 
1552 #define PACK_RGB GST_VIDEO_FORMAT_ARGB, unpack_RGB, 1, pack_RGB
1553 static void
1554 unpack_RGB (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1555     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1556     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1557 {
1558   int i;
1559   const guint8 *restrict s = GET_LINE (y);
1560   guint8 *restrict d = dest;
1561 
1562   s += x * 3;
1563 
1564   for (i = 0; i &lt; width; i++) {
1565     d[i * 4 + 0] = 0xff;
1566     d[i * 4 + 1] = s[i * 3 + 0];
1567     d[i * 4 + 2] = s[i * 3 + 1];
1568     d[i * 4 + 3] = s[i * 3 + 2];
1569   }
1570 }
1571 
1572 static void
1573 pack_RGB (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1574     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1575     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1576     gint y, gint width)
1577 {
1578   int i;
1579   guint8 *restrict d = GET_LINE (y);
1580   const guint8 *restrict s = src;
1581 
1582   for (i = 0; i &lt; width; i++) {
1583     d[i * 3 + 0] = s[i * 4 + 1];
1584     d[i * 3 + 1] = s[i * 4 + 2];
1585     d[i * 3 + 2] = s[i * 4 + 3];
1586   }
1587 }
1588 
1589 #define PACK_BGR GST_VIDEO_FORMAT_ARGB, unpack_BGR, 1, pack_BGR
1590 static void
1591 unpack_BGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1592     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1593     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1594 {
1595   int i;
1596   const guint8 *restrict s = GET_LINE (y);
1597   guint8 *restrict d = dest;
1598 
1599   s += x * 3;
1600 
1601   for (i = 0; i &lt; width; i++) {
1602     d[i * 4 + 0] = 0xff;
1603     d[i * 4 + 1] = s[i * 3 + 2];
1604     d[i * 4 + 2] = s[i * 3 + 1];
1605     d[i * 4 + 3] = s[i * 3 + 0];
1606   }
1607 }
1608 
1609 static void
1610 pack_BGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1611     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1612     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1613     gint y, gint width)
1614 {
1615   int i;
1616   guint8 *restrict d = GET_LINE (y);
1617   const guint8 *restrict s = src;
1618 
1619   for (i = 0; i &lt; width; i++) {
1620     d[i * 3 + 0] = s[i * 4 + 3];
1621     d[i * 3 + 1] = s[i * 4 + 2];
1622     d[i * 3 + 2] = s[i * 4 + 1];
1623   }
1624 }
1625 
1626 #define PACK_NV12 GST_VIDEO_FORMAT_AYUV, unpack_NV12, 1, pack_NV12
1627 static void
1628 unpack_NV12 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1629     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1630     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1631 {
1632   gint uv = GET_UV_420 (y, flags);
1633   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1634   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1635   guint8 *restrict d = dest;
1636 
1637   sy += x;
1638   suv += (x &amp; ~1);
1639 
1640   if (x &amp; 1) {
1641     d[0] = 0xff;
1642     d[1] = *sy++;
1643     d[2] = suv[0];
1644     d[3] = suv[1];
1645     width--;
1646     d += 4;
1647     suv += 2;
1648   }
1649 
1650   if (IS_ALIGNED (d, 8))
1651     video_orc_unpack_NV12 (d, sy, suv, width / 2);
1652   else {
1653     gint i;
1654     for (i = 0; i &lt; width / 2; i++) {
1655       d[i * 8 + 0] = 0xff;
1656       d[i * 8 + 1] = sy[i * 2 + 0];
1657       d[i * 8 + 2] = suv[i * 2 + 0];
1658       d[i * 8 + 3] = suv[i * 2 + 1];
1659       d[i * 8 + 4] = 0xff;
1660       d[i * 8 + 5] = sy[i * 2 + 1];
1661       d[i * 8 + 6] = suv[i * 2 + 0];
1662       d[i * 8 + 7] = suv[i * 2 + 1];
1663     }
1664   }
1665 
1666   if (width &amp; 1) {
1667     gint i = width - 1;
1668 
1669     d[i * 4 + 0] = 0xff;
1670     d[i * 4 + 1] = sy[i];
1671     d[i * 4 + 2] = suv[i + 0];
1672     d[i * 4 + 3] = suv[i + 1];
1673   }
1674 }
1675 
1676 static void
1677 pack_NV12 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1678     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1679     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1680     gint y, gint width)
1681 {
1682   gint uv = GET_UV_420 (y, flags);
1683   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1684   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1685   const guint8 *restrict s = src;
1686 
1687   if (IS_CHROMA_LINE_420 (y, flags)) {
1688     if (IS_ALIGNED (s, 8))
1689       video_orc_pack_NV12 (dy, duv, s, width / 2);
1690     else {
1691       gint i;
1692       for (i = 0; i &lt; width / 2; i++) {
1693         dy[i * 2 + 0] = s[i * 8 + 1];
1694         dy[i * 2 + 1] = s[i * 8 + 5];
1695         duv[i * 2 + 0] = s[i * 8 + 2];
1696         duv[i * 2 + 1] = s[i * 8 + 3];
1697       }
1698     }
<a name="12" id="anc12"></a><span class="line-modified">1699     if (width &amp; 1) {</span>
<span class="line-modified">1700       gint i = width - 1;</span>
1701 
1702       dy[i] = s[i * 4 + 1];
1703       duv[i + 0] = s[i * 4 + 2];
1704       duv[i + 1] = s[i * 4 + 3];
<a name="13" id="anc13"></a><span class="line-modified">1705     }</span>
1706   } else
1707     video_orc_pack_Y (dy, s, width);
1708 }
1709 
1710 #define PACK_NV21 GST_VIDEO_FORMAT_AYUV, unpack_NV21, 1, pack_NV21
1711 static void
1712 unpack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1713     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1714     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1715 {
1716   gint uv = GET_UV_420 (y, flags);
1717   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1718   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1719   guint8 *restrict d = dest;
1720 
1721   sy += x;
1722   suv += (x &amp; ~1);
1723 
1724   if (x &amp; 1) {
1725     d[0] = 0xff;
1726     d[1] = *sy++;
1727     d[2] = suv[1];
1728     d[3] = suv[0];
1729     width--;
1730     d += 4;
1731     suv += 2;
1732   }
1733 
1734   if (IS_ALIGNED (d, 8))
1735     video_orc_unpack_NV21 (d, sy, suv, width / 2);
1736   else {
1737     gint i;
1738     for (i = 0; i &lt; width / 2; i++) {
1739       d[i * 8 + 0] = 0xff;
1740       d[i * 8 + 1] = sy[i * 2 + 0];
1741       d[i * 8 + 2] = suv[i * 2 + 1];
1742       d[i * 8 + 3] = suv[i * 2 + 0];
1743       d[i * 8 + 4] = 0xff;
1744       d[i * 8 + 5] = sy[i * 2 + 1];
1745       d[i * 8 + 6] = suv[i * 2 + 1];
1746       d[i * 8 + 7] = suv[i * 2 + 0];
1747     }
1748   }
1749 
1750   if (width &amp; 1) {
1751     gint i = width - 1;
1752 
1753     d[i * 4 + 0] = 0xff;
1754     d[i * 4 + 1] = sy[i];
1755     d[i * 4 + 2] = suv[i + 1];
1756     d[i * 4 + 3] = suv[i + 0];
1757   }
1758 }
1759 
1760 static void
1761 pack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1762     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1763     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1764     gint y, gint width)
1765 {
1766   gint uv = GET_UV_420 (y, flags);
1767   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1768   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1769   const guint8 *restrict s = src;
1770 
1771   if (IS_CHROMA_LINE_420 (y, flags)) {
1772     if (IS_ALIGNED (s, 8))
1773       video_orc_pack_NV21 (dy, duv, s, width / 2);
1774     else {
1775       gint i;
1776       for (i = 0; i &lt; width / 2; i++) {
1777         dy[i * 2 + 0] = s[i * 8 + 1];
1778         dy[i * 2 + 1] = s[i * 8 + 5];
1779         duv[i * 2 + 0] = s[i * 8 + 3];
1780         duv[i * 2 + 1] = s[i * 8 + 2];
1781       }
1782     }
<a name="14" id="anc14"></a><span class="line-modified">1783     if (width &amp; 1) {</span>
<span class="line-modified">1784       gint i = width - 1;</span>
1785 
1786       dy[i] = s[i * 4 + 1];
1787       duv[i + 0] = s[i * 4 + 3];
1788       duv[i + 1] = s[i * 4 + 2];
<a name="15" id="anc15"></a><span class="line-modified">1789     }</span>
1790   } else
1791     video_orc_pack_Y (dy, s, width);
1792 }
1793 
1794 #define PACK_NV16 GST_VIDEO_FORMAT_AYUV, unpack_NV16, 1, pack_NV16
1795 static void
1796 unpack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1797     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1798     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1799 {
1800   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1801   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1802   guint8 *restrict d = dest;
1803 
1804   sy += x;
1805   suv += (x &amp; ~1);
1806 
1807   if (x &amp; 1) {
1808     d[0] = 0xff;
1809     d[1] = *sy++;
1810     d[2] = suv[0];
1811     d[3] = suv[1];
1812     width--;
1813     d += 4;
1814     suv += 2;
1815   }
1816 
1817   if (IS_ALIGNED (d, 8))
1818     video_orc_unpack_NV12 (d, sy, suv, width / 2);
1819   else {
1820     gint i;
1821     for (i = 0; i &lt; width / 2; i++) {
1822       d[i * 8 + 0] = 0xff;
1823       d[i * 8 + 1] = sy[i * 2 + 0];
1824       d[i * 8 + 2] = suv[i * 2 + 0];
1825       d[i * 8 + 3] = suv[i * 2 + 1];
1826       d[i * 8 + 4] = 0xff;
1827       d[i * 8 + 5] = sy[i * 2 + 1];
1828       d[i * 8 + 6] = suv[i * 2 + 0];
1829       d[i * 8 + 7] = suv[i * 2 + 1];
1830     }
1831   }
1832 
1833   if (width &amp; 1) {
1834     gint i = width - 1;
1835 
1836     d[i * 4 + 0] = 0xff;
1837     d[i * 4 + 1] = sy[i];
1838     d[i * 4 + 2] = suv[i + 0];
1839     d[i * 4 + 3] = suv[i + 1];
1840   }
1841 }
1842 
1843 static void
1844 pack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1845     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1846     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1847     gint y, gint width)
1848 {
1849   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1850   guint8 *restrict duv = GET_PLANE_LINE (1, y);
1851   const guint8 *restrict s = src;
1852 
1853   if (IS_ALIGNED (s, 8))
1854     video_orc_pack_NV12 (dy, duv, s, width / 2);
1855   else {
1856     gint i;
1857     for (i = 0; i &lt; width / 2; i++) {
1858       dy[i * 2 + 0] = s[i * 8 + 1];
1859       dy[i * 2 + 1] = s[i * 8 + 5];
1860       duv[i * 2 + 0] = s[i * 8 + 2];
1861       duv[i * 2 + 1] = s[i * 8 + 3];
1862     }
1863   }
1864 
1865   if (width &amp; 1) {
1866     gint i = width - 1;
1867 
1868     dy[i] = s[i * 4 + 1];
1869     duv[i + 0] = s[i * 4 + 2];
1870     duv[i + 1] = s[i * 4 + 3];
1871   }
1872 }
1873 
1874 #define PACK_NV61 GST_VIDEO_FORMAT_AYUV, unpack_NV61, 1, pack_NV61
1875 static void
1876 unpack_NV61 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1877     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1878     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1879 {
1880   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1881   const guint8 *restrict svu = GET_PLANE_LINE (1, y);
1882   guint8 *restrict d = dest;
1883 
1884   sy += x;
1885   svu += (x &amp; ~1);
1886 
1887   if (x &amp; 1) {
1888     d[0] = 0xff;
1889     d[1] = *sy++;
1890     d[2] = svu[1];
1891     d[3] = svu[0];
1892     width--;
1893     d += 4;
1894     svu += 2;
1895   }
1896 
1897   if (IS_ALIGNED (d, 8)) {
1898     video_orc_unpack_NV21 (d, sy, svu, width / 2);
1899   } else {
1900     gint i;
1901 
1902     for (i = 0; i &lt; width / 2; i++) {
1903       d[i * 8 + 0] = 0xff;
1904       d[i * 8 + 1] = sy[i * 2 + 0];
1905       d[i * 8 + 2] = svu[i * 2 + 1];
1906       d[i * 8 + 3] = svu[i * 2 + 0];
1907       d[i * 8 + 4] = 0xff;
1908       d[i * 8 + 5] = sy[i * 2 + 1];
1909       d[i * 8 + 6] = svu[i * 2 + 1];
1910       d[i * 8 + 7] = svu[i * 2 + 0];
1911     }
1912   }
1913 
1914   if (width &amp; 1) {
1915     gint i = width - 1;
1916 
1917     d[i * 4 + 0] = 0xff;
1918     d[i * 4 + 1] = sy[i];
1919     d[i * 4 + 2] = svu[i + 1];
1920     d[i * 4 + 3] = svu[i + 0];
1921   }
1922 }
1923 
1924 static void
1925 pack_NV61 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1926     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1927     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1928     gint y, gint width)
1929 {
1930   const guint8 *restrict s = src;
1931   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1932   guint8 *restrict dvu = GET_PLANE_LINE (1, y);
1933 
1934   if (IS_ALIGNED (s, 8)) {
1935     video_orc_pack_NV21 (dy, dvu, s, width / 2);
1936   } else {
1937     gint i;
1938 
1939     for (i = 0; i &lt; width / 2; i++) {
1940       dy[i * 2 + 0] = s[i * 8 + 1];
1941       dy[i * 2 + 1] = s[i * 8 + 5];
1942       dvu[i * 2 + 0] = s[i * 8 + 3];
1943       dvu[i * 2 + 1] = s[i * 8 + 2];
1944     }
1945   }
1946 
1947   if (width &amp; 1) {
1948     gint i = width - 1;
1949 
1950     dy[i] = s[i * 4 + 1];
1951     dvu[i + 0] = s[i * 4 + 2];
1952     dvu[i + 1] = s[i * 4 + 3];
1953   }
1954 }
1955 
1956 #define PACK_NV24 GST_VIDEO_FORMAT_AYUV, unpack_NV24, 1, pack_NV24
1957 static void
1958 unpack_NV24 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1959     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1960     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1961 {
1962   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1963   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1964 
1965   sy += x;
1966   suv += x &lt;&lt; 1;
1967 
1968   video_orc_unpack_NV24 (dest, sy, suv, width);
1969 }
1970 
1971 static void
1972 pack_NV24 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1973     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1974     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1975     gint y, gint width)
1976 {
1977   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1978   guint8 *restrict duv = GET_PLANE_LINE (1, y);
1979 
1980   video_orc_pack_NV24 (dy, duv, src, width);
1981 }
1982 
1983 #define PACK_UYVP GST_VIDEO_FORMAT_AYUV64, unpack_UYVP, 1, pack_UYVP
1984 static void
1985 unpack_UYVP (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1986     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1987     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1988 {
1989   int i;
1990   const guint8 *restrict s = GET_LINE (y);
1991   guint16 *restrict d = dest;
1992 
1993   /* FIXME */
1994   s += x &lt;&lt; 1;
1995 
1996   for (i = 0; i &lt; width; i += 2) {
1997     guint16 y0, y1;
1998     guint16 u0;
1999     guint16 v0;
2000 
2001     u0 = ((s[(i / 2) * 5 + 0] &lt;&lt; 2) | (s[(i / 2) * 5 + 1] &gt;&gt; 6)) &lt;&lt; 6;
2002     y0 = (((s[(i / 2) * 5 + 1] &amp; 0x3f) &lt;&lt; 4) | (s[(i / 2) * 5 + 2] &gt;&gt; 4)) &lt;&lt; 6;
2003     v0 = (((s[(i / 2) * 5 + 2] &amp; 0x0f) &lt;&lt; 6) | (s[(i / 2) * 5 + 3] &gt;&gt; 2)) &lt;&lt; 6;
2004     y1 = (((s[(i / 2) * 5 + 3] &amp; 0x03) &lt;&lt; 8) | s[(i / 2) * 5 + 4]) &lt;&lt; 6;
2005 
2006     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2007       y0 |= (y0 &gt;&gt; 10);
2008       y1 |= (y1 &gt;&gt; 10);
2009       u0 |= (u0 &gt;&gt; 10);
2010       v0 |= (v0 &gt;&gt; 10);
2011     }
2012 
2013     d[i * 4 + 0] = 0xffff;
2014     d[i * 4 + 1] = y0;
2015     d[i * 4 + 2] = u0;
2016     d[i * 4 + 3] = v0;
2017 
2018     if (i &lt; width - 1) {
2019       d[i * 4 + 4] = 0xffff;
2020       d[i * 4 + 5] = y1;
2021       d[i * 4 + 6] = u0;
2022       d[i * 4 + 7] = v0;
2023     }
2024   }
2025 }
2026 
2027 static void
2028 pack_UYVP (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2029     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2030     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2031     gint y, gint width)
2032 {
2033   int i;
2034   guint8 *restrict d = GET_LINE (y);
2035   const guint16 *restrict s = src;
2036 
2037   for (i = 0; i &lt; width; i += 2) {
2038     guint16 y0, y1;
2039     guint16 u0;
2040     guint16 v0;
2041 
2042     y0 = s[4 * (i + 0) + 1];
2043     if (i &lt; width - 1)
2044       y1 = s[4 * (i + 1) + 1];
2045     else
2046       y1 = y0;
2047 
2048     u0 = s[4 * (i + 0) + 2];
2049     v0 = s[4 * (i + 0) + 3];
2050 
2051     d[(i / 2) * 5 + 0] = u0 &gt;&gt; 8;
2052     d[(i / 2) * 5 + 1] = (u0 &amp; 0xc0) | y0 &gt;&gt; 10;
2053     d[(i / 2) * 5 + 2] = ((y0 &amp; 0x3c0) &gt;&gt; 2) | (v0 &gt;&gt; 12);
2054     d[(i / 2) * 5 + 3] = ((v0 &amp; 0xfc0) &gt;&gt; 4) | (y1 &gt;&gt; 14);
2055     d[(i / 2) * 5 + 4] = (y1 &gt;&gt; 6);
2056   }
2057 }
2058 
2059 #define PACK_A420 GST_VIDEO_FORMAT_AYUV, unpack_A420, 1, pack_A420
2060 static void
2061 unpack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2062     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2063     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2064 {
2065   gint uv = GET_UV_420 (y, flags);
2066   const guint8 *restrict sy = GET_Y_LINE (y);
2067   const guint8 *restrict su = GET_U_LINE (uv);
2068   const guint8 *restrict sv = GET_V_LINE (uv);
2069   const guint8 *restrict sa = GET_A_LINE (y);
2070   guint8 *restrict d = dest;
2071 
2072   sy += x;
2073   su += x &gt;&gt; 1;
2074   sv += x &gt;&gt; 1;
2075   sa += x;
2076 
2077   if (x &amp; 1) {
2078     d[0] = *sa++;
2079     d[1] = *sy++;
2080     d[2] = *su++;
2081     d[3] = *sv++;
2082     width--;
2083     d += 4;
<a name="16" id="anc16"></a><span class="line-modified">2084   }</span>
2085   video_orc_unpack_A420 (d, sy, su, sv, sa, width);
2086 }
2087 
2088 static void
2089 pack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2090     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2091     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2092     gint y, gint width)
2093 {
2094   gint uv = GET_UV_420 (y, flags);
2095   guint8 *restrict dy = GET_Y_LINE (y);
2096   guint8 *restrict du = GET_U_LINE (uv);
2097   guint8 *restrict dv = GET_V_LINE (uv);
2098   guint8 *restrict da = GET_A_LINE (y);
2099   const guint8 *restrict s = src;
2100 
2101   if (IS_CHROMA_LINE_420 (y, flags)) {
2102     if (IS_ALIGNED (s, 8))
2103       video_orc_pack_A420 (dy, du, dv, da, s, width / 2);
2104     else {
2105       gint i;
2106       for (i = 0; i &lt; width / 2; i++) {
2107         da[i * 2 + 0] = s[i * 8 + 0];
2108         dy[i * 2 + 0] = s[i * 8 + 1];
2109         da[i * 2 + 1] = s[i * 8 + 4];
2110         dy[i * 2 + 1] = s[i * 8 + 5];
2111         du[i] = s[i * 8 + 2];
2112         dv[i] = s[i * 8 + 3];
2113       }
2114     }
2115 
<a name="17" id="anc17"></a><span class="line-modified">2116     if (width &amp; 1) {</span>
<span class="line-modified">2117       gint i = width - 1;</span>
2118 
2119       da[i] = s[i * 4 + 0];
2120       dy[i] = s[i * 4 + 1];
2121       du[i &gt;&gt; 1] = s[i * 4 + 2];
2122       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<a name="18" id="anc18"></a><span class="line-modified">2123     }</span>
2124   } else
2125     video_orc_pack_AY (dy, da, s, width);
2126 }
2127 
2128 #define PACK_RGB8P GST_VIDEO_FORMAT_ARGB, unpack_RGB8P, 1, pack_RGB8P
2129 static void
2130 unpack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2131     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2132     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2133 {
2134   int i;
2135   const guint8 *restrict s = GET_LINE (y);
2136   const guint32 *restrict p = data[1];
2137   guint8 *restrict d = dest;
2138 
2139   s += x;
2140 
2141   for (i = 0; i &lt; width; i++) {
2142     guint32 v = p[s[i]];
2143     d[i * 4 + 0] = (v &gt;&gt; 24) &amp; 0xff;
2144     d[i * 4 + 1] = (v &gt;&gt; 16) &amp; 0xff;
2145     d[i * 4 + 2] = (v &gt;&gt; 8) &amp; 0xff;
2146     d[i * 4 + 3] = (v) &amp; 0xff;
2147   }
2148 }
2149 
2150 static const guint32 std_palette_RGB8P[] = {
2151   0xff000000, 0xff000033, 0xff000066, 0xff000099, 0xff0000cc, 0xff0000ff,
2152   0xff003300, 0xff003333, 0xff003366, 0xff003399, 0xff0033cc, 0xff0033ff,
2153   0xff006600, 0xff006633, 0xff006666, 0xff006699, 0xff0066cc, 0xff0066ff,
2154   0xff009900, 0xff009933, 0xff009966, 0xff009999, 0xff0099cc, 0xff0099ff,
2155   0xff00cc00, 0xff00cc33, 0xff00cc66, 0xff00cc99, 0xff00cccc, 0xff00ccff,
2156   0xff00ff00, 0xff00ff33, 0xff00ff66, 0xff00ff99, 0xff00ffcc, 0xff00ffff,
2157   0xff330000, 0xff330033, 0xff330066, 0xff330099, 0xff3300cc, 0xff3300ff,
2158   0xff333300, 0xff333333, 0xff333366, 0xff333399, 0xff3333cc, 0xff3333ff,
2159   0xff336600, 0xff336633, 0xff336666, 0xff336699, 0xff3366cc, 0xff3366ff,
2160   0xff339900, 0xff339933, 0xff339966, 0xff339999, 0xff3399cc, 0xff3399ff,
2161   0xff33cc00, 0xff33cc33, 0xff33cc66, 0xff33cc99, 0xff33cccc, 0xff33ccff,
2162   0xff33ff00, 0xff33ff33, 0xff33ff66, 0xff33ff99, 0xff33ffcc, 0xff33ffff,
2163   0xff660000, 0xff660033, 0xff660066, 0xff660099, 0xff6600cc, 0xff6600ff,
2164   0xff663300, 0xff663333, 0xff663366, 0xff663399, 0xff6633cc, 0xff6633ff,
2165   0xff666600, 0xff666633, 0xff666666, 0xff666699, 0xff6666cc, 0xff6666ff,
2166   0xff669900, 0xff669933, 0xff669966, 0xff669999, 0xff6699cc, 0xff6699ff,
2167   0xff66cc00, 0xff66cc33, 0xff66cc66, 0xff66cc99, 0xff66cccc, 0xff66ccff,
2168   0xff66ff00, 0xff66ff33, 0xff66ff66, 0xff66ff99, 0xff66ffcc, 0xff66ffff,
2169   0xff990000, 0xff990033, 0xff990066, 0xff990099, 0xff9900cc, 0xff9900ff,
2170   0xff993300, 0xff993333, 0xff993366, 0xff993399, 0xff9933cc, 0xff9933ff,
2171   0xff996600, 0xff996633, 0xff996666, 0xff996699, 0xff9966cc, 0xff9966ff,
2172   0xff999900, 0xff999933, 0xff999966, 0xff999999, 0xff9999cc, 0xff9999ff,
2173   0xff99cc00, 0xff99cc33, 0xff99cc66, 0xff99cc99, 0xff99cccc, 0xff99ccff,
2174   0xff99ff00, 0xff99ff33, 0xff99ff66, 0xff99ff99, 0xff99ffcc, 0xff99ffff,
2175   0xffcc0000, 0xffcc0033, 0xffcc0066, 0xffcc0099, 0xffcc00cc, 0xffcc00ff,
2176   0xffcc3300, 0xffcc3333, 0xffcc3366, 0xffcc3399, 0xffcc33cc, 0xffcc33ff,
2177   0xffcc6600, 0xffcc6633, 0xffcc6666, 0xffcc6699, 0xffcc66cc, 0xffcc66ff,
2178   0xffcc9900, 0xffcc9933, 0xffcc9966, 0xffcc9999, 0xffcc99cc, 0xffcc99ff,
2179   0xffcccc00, 0xffcccc33, 0xffcccc66, 0xffcccc99, 0xffcccccc, 0xffccccff,
2180   0xffccff00, 0xffccff33, 0xffccff66, 0xffccff99, 0xffccffcc, 0xffccffff,
2181   0xffff0000, 0xffff0033, 0xffff0066, 0xffff0099, 0xffff00cc, 0xffff00ff,
2182   0xffff3300, 0xffff3333, 0xffff3366, 0xffff3399, 0xffff33cc, 0xffff33ff,
2183   0xffff6600, 0xffff6633, 0xffff6666, 0xffff6699, 0xffff66cc, 0xffff66ff,
2184   0xffff9900, 0xffff9933, 0xffff9966, 0xffff9999, 0xffff99cc, 0xffff99ff,
2185   0xffffcc00, 0xffffcc33, 0xffffcc66, 0xffffcc99, 0xffffcccc, 0xffffccff,
2186   0xffffff00, 0xffffff33, 0xffffff66, 0xffffff99, 0xffffffcc, 0xffffffff,
2187   0x00000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2188   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2189   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2190   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2191   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2192   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2193   0xff000000, 0xff000000, 0xff000000, 0xff000000
2194 };
2195 
2196 static void
2197 pack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2198     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2199     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2200     gint y, gint width)
2201 {
2202   int i;
2203   guint8 *restrict d = GET_LINE (y);
2204   const guint8 *restrict s = src;
2205 
2206   /* Use our poor man&#39;s palette, taken from ffmpegcolorspace too */
2207   for (i = 0; i &lt; width; i++) {
2208     /* crude approximation for alpha ! */
2209     if (s[i * 4 + 0] &lt; 0x80)
2210       d[i] = 6 * 6 * 6;
2211     else
2212       d[i] =
2213           ((((s[i * 4 + 1]) / 47) % 6) * 6 * 6 + (((s[i * 4 +
2214                           2]) / 47) % 6) * 6 + (((s[i * 4 + 3]) / 47) % 6));
2215   }
2216 }
2217 
2218 #define PACK_410 GST_VIDEO_FORMAT_AYUV, unpack_410, 1, pack_410
2219 static void
2220 unpack_410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2221     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2222     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2223 {
2224   gint uv = GET_UV_410 (y, flags);
2225   const guint8 *restrict sy = GET_Y_LINE (y);
2226   const guint8 *restrict su = GET_U_LINE (uv);
2227   const guint8 *restrict sv = GET_V_LINE (uv);
2228   guint8 *restrict d = dest;
2229 
2230   sy += x;
2231   su += x &gt;&gt; 2;
2232   sv += x &gt;&gt; 2;
2233 
2234   if (x &amp; 3) {
2235     for (; x &amp; 3; x++) {
2236       d[0] = 0xff;
2237       d[1] = *sy++;
2238       d[2] = *su;
2239       d[3] = *sv;
2240       width--;
2241       d += 4;
2242     }
2243     su++;
2244     sy++;
2245   }
2246 
2247   if (IS_ALIGNED (d, 8))
2248     video_orc_unpack_YUV9 (d, sy, su, sv, width / 2);
2249   else {
2250     gint i;
2251     for (i = 0; i &lt; width / 2; i++) {
2252       d[i * 8 + 0] = 0xff;
2253       d[i * 8 + 1] = sy[i * 2 + 0];
2254       d[i * 8 + 2] = su[i &gt;&gt; 1];
2255       d[i * 8 + 3] = sv[i &gt;&gt; 1];
2256       d[i * 8 + 4] = 0xff;
2257       d[i * 8 + 5] = sy[i * 2 + 1];
2258       d[i * 8 + 6] = su[i &gt;&gt; 1];
2259       d[i * 8 + 7] = sv[i &gt;&gt; 1];
2260     }
2261   }
2262 
2263   if (width &amp; 1) {
2264     gint i = width - 1;
2265 
2266     d[i * 4 + 0] = 0xff;
2267     d[i * 4 + 1] = sy[i];
2268     d[i * 4 + 2] = su[i &gt;&gt; 2];
2269     d[i * 4 + 3] = sv[i &gt;&gt; 2];
2270   }
2271 }
2272 
2273 static void
2274 pack_410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2275     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2276     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2277     gint y, gint width)
2278 {
2279   int i;
2280   gint uv = GET_UV_410 (y, flags);
2281   guint8 *restrict dy = GET_Y_LINE (y);
2282   guint8 *restrict du = GET_U_LINE (uv);
2283   guint8 *restrict dv = GET_V_LINE (uv);
2284   const guint8 *restrict s = src;
2285 
2286   for (i = 0; i &lt; width - 3; i += 4) {
2287     dy[i] = s[i * 4 + 1];
2288     dy[i + 1] = s[i * 4 + 5];
2289     dy[i + 2] = s[i * 4 + 9];
2290     dy[i + 3] = s[i * 4 + 13];
2291     if (IS_CHROMA_LINE_410 (y, flags)) {
2292       du[i &gt;&gt; 2] = s[i * 4 + 2];
2293       dv[i &gt;&gt; 2] = s[i * 4 + 3];
2294     }
2295   }
2296   if (i &lt; width) {
2297     dy[i] = s[i * 4 + 1];
2298     if (IS_CHROMA_LINE_410 (y, flags)) {
2299       du[i &gt;&gt; 2] = s[i * 4 + 2];
2300       dv[i &gt;&gt; 2] = s[i * 4 + 3];
2301     }
2302     if (i &lt; width - 1)
2303       dy[i + 1] = s[i * 4 + 5];
2304     if (i &lt; width - 2)
2305       dy[i + 2] = s[i * 4 + 9];
2306   }
2307 }
2308 
2309 #define PACK_IYU1 GST_VIDEO_FORMAT_AYUV, unpack_IYU1, 1, pack_IYU1
2310 static void
2311 unpack_IYU1 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2312     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2313     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2314 {
2315   int i;
2316   const guint8 *restrict s = GET_LINE (y);
2317   guint8 *restrict d = dest;
2318   guint8 y0, y1, y2, y3;
2319   guint8 u0;
2320   guint8 v0;
2321 
2322   /* FIXME */
2323   s += x * 4;
2324 
2325   for (i = 0; i &lt; width - 3; i += 4) {
2326     y0 = s[(i &gt;&gt; 2) * 6 + 1];
2327     y1 = s[(i &gt;&gt; 2) * 6 + 2];
2328     y2 = s[(i &gt;&gt; 2) * 6 + 4];
2329     y3 = s[(i &gt;&gt; 2) * 6 + 5];
2330 
2331     u0 = s[(i &gt;&gt; 2) * 6 + 0];
2332     v0 = s[(i &gt;&gt; 2) * 6 + 3];
2333 
2334     d[i * 4 + 0] = 0xff;
2335     d[i * 4 + 1] = y0;
2336     d[i * 4 + 2] = u0;
2337     d[i * 4 + 3] = v0;
2338 
2339     d[i * 4 + 4] = 0xff;
2340     d[i * 4 + 5] = y1;
2341     d[i * 4 + 6] = u0;
2342     d[i * 4 + 7] = v0;
2343 
2344     d[i * 4 + 8] = 0xff;
2345     d[i * 4 + 9] = y2;
2346     d[i * 4 + 10] = u0;
2347     d[i * 4 + 11] = v0;
2348 
2349     d[i * 4 + 12] = 0xff;
2350     d[i * 4 + 13] = y3;
2351     d[i * 4 + 14] = u0;
2352     d[i * 4 + 15] = v0;
2353   }
2354   if (i &lt; width) {
2355     u0 = s[(i &gt;&gt; 2) * 6 + 0];
2356     v0 = s[(i &gt;&gt; 2) * 6 + 3];
2357 
2358     d[i * 4 + 0] = 0xff;
2359     d[i * 4 + 1] = s[(i &gt;&gt; 2) * 6 + 1];
2360     d[i * 4 + 2] = u0;
2361     d[i * 4 + 3] = v0;
2362 
2363     if (i &lt; width - 1) {
2364       d[i * 4 + 4] = 0xff;
2365       d[i * 4 + 5] = s[(i &gt;&gt; 2) * 6 + 2];
2366       d[i * 4 + 6] = u0;
2367       d[i * 4 + 7] = v0;
2368     }
2369     if (i &lt; width - 2) {
2370       d[i * 4 + 8] = 0xff;
2371       d[i * 4 + 9] = s[(i &gt;&gt; 2) * 6 + 4];
2372       d[i * 4 + 10] = u0;
2373       d[i * 4 + 11] = v0;
2374     }
2375   }
2376 }
2377 
2378 static void
2379 pack_IYU1 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2380     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2381     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2382     gint y, gint width)
2383 {
2384   int i;
2385   guint8 *restrict d = GET_LINE (y);
2386   const guint8 *restrict s = src;
2387 
2388   for (i = 0; i &lt; width - 3; i += 4) {
2389     d[(i &gt;&gt; 2) * 6 + 0] = s[i * 4 + 2];
2390     d[(i &gt;&gt; 2) * 6 + 1] = s[i * 4 + 1];
2391     d[(i &gt;&gt; 2) * 6 + 2] = s[i * 4 + 5];
2392     d[(i &gt;&gt; 2) * 6 + 3] = s[i * 4 + 3];
2393     d[(i &gt;&gt; 2) * 6 + 4] = s[i * 4 + 9];
2394     d[(i &gt;&gt; 2) * 6 + 5] = s[i * 4 + 13];
2395   }
2396   if (i &lt; width) {
2397     d[(i &gt;&gt; 2) * 6 + 1] = s[i * 4 + 1];
2398     d[(i &gt;&gt; 2) * 6 + 0] = s[i * 4 + 2];
2399     d[(i &gt;&gt; 2) * 6 + 3] = s[i * 4 + 3];
2400     if (i &lt; width - 1)
2401       d[(i &gt;&gt; 2) * 6 + 2] = s[i * 4 + 5];
2402     if (i &lt; width - 2)
2403       d[(i &gt;&gt; 2) * 6 + 4] = s[i * 4 + 9];
2404   }
2405 }
2406 
2407 #define PACK_ARGB64 GST_VIDEO_FORMAT_ARGB64, unpack_copy8, 1, pack_copy8
2408 #define PACK_AYUV64 GST_VIDEO_FORMAT_AYUV64, unpack_copy8, 1, pack_copy8
2409 static void
2410 unpack_copy8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2411     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2412     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2413 {
2414   const guint8 *s = GET_LINE (y);
2415 
2416   s += x * 8;
2417 
2418   memcpy (dest, s, width * 8);
2419 }
2420 
2421 static void
2422 pack_copy8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2423     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2424     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2425     gint y, gint width)
2426 {
2427   guint8 *restrict d = GET_LINE (y);
2428 
2429   memcpy (d, src, width * 8);
2430 }
2431 
2432 #define PACK_r210 GST_VIDEO_FORMAT_ARGB64, unpack_r210, 1, pack_r210
2433 static void
2434 unpack_r210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2435     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2436     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2437 {
2438   int i;
2439   const guint8 *restrict s = GET_LINE (y);
2440   guint16 *restrict d = dest, R, G, B;
2441 
2442   s += x * 4;
2443 
2444   for (i = 0; i &lt; width; i++) {
2445     guint32 x = GST_READ_UINT32_BE (s + i * 4);
2446 
2447     R = ((x &gt;&gt; 14) &amp; 0xffc0);
2448     G = ((x &gt;&gt; 4) &amp; 0xffc0);
2449     B = ((x &lt;&lt; 6) &amp; 0xffc0);
2450 
2451     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2452       R |= (R &gt;&gt; 10);
2453       G |= (G &gt;&gt; 10);
2454       B |= (B &gt;&gt; 10);
2455     }
2456 
2457     d[i * 4 + 0] = 0xffff;
2458     d[i * 4 + 1] = R;
2459     d[i * 4 + 2] = G;
2460     d[i * 4 + 3] = B;
2461   }
2462 }
2463 
2464 static void
2465 pack_r210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2466     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2467     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2468     gint y, gint width)
2469 {
2470   int i;
2471   guint8 *restrict d = GET_LINE (y);
2472   const guint16 *restrict s = src;
2473 
2474   for (i = 0; i &lt; width; i++) {
2475     guint32 x = 0;
2476     x |= (s[i * 4 + 1] &amp; 0xffc0) &lt;&lt; 14;
2477     x |= (s[i * 4 + 2] &amp; 0xffc0) &lt;&lt; 4;
2478     x |= (s[i * 4 + 3] &amp; 0xffc0) &gt;&gt; 6;
2479     GST_WRITE_UINT32_BE (d + i * 4, x);
2480   }
2481 }
2482 
2483 #define PACK_GBR_10LE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_10LE, 1, pack_GBR_10LE
2484 static void
2485 unpack_GBR_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2486     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2487     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2488 {
2489   int i;
2490   const guint16 *sg = GET_G_LINE (y);
2491   const guint16 *sb = GET_B_LINE (y);
2492   const guint16 *sr = GET_R_LINE (y);
2493   guint16 *d = dest, G, B, R;
2494 
2495   sg += x;
2496   sb += x;
2497   sr += x;
2498 
2499   for (i = 0; i &lt; width; i++) {
2500     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 6;
2501     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 6;
2502     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 6;
2503 
2504     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2505       R |= (R &gt;&gt; 10);
2506       G |= (G &gt;&gt; 10);
2507       B |= (B &gt;&gt; 10);
2508     }
2509 
2510     d[i * 4 + 0] = 0xffff;
2511     d[i * 4 + 1] = R;
2512     d[i * 4 + 2] = G;
2513     d[i * 4 + 3] = B;
2514   }
2515 }
2516 
2517 static void
2518 pack_GBR_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2519     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2520     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2521     gint y, gint width)
2522 {
2523   int i;
2524   guint16 *restrict dg = GET_G_LINE (y);
2525   guint16 *restrict db = GET_B_LINE (y);
2526   guint16 *restrict dr = GET_R_LINE (y);
2527   guint16 G, B, R;
2528   const guint16 *restrict s = src;
2529 
2530   for (i = 0; i &lt; width; i++) {
2531     G = (s[i * 4 + 2]) &gt;&gt; 6;
2532     B = (s[i * 4 + 3]) &gt;&gt; 6;
2533     R = (s[i * 4 + 1]) &gt;&gt; 6;
2534 
2535     GST_WRITE_UINT16_LE (dg + i, G);
2536     GST_WRITE_UINT16_LE (db + i, B);
2537     GST_WRITE_UINT16_LE (dr + i, R);
2538   }
2539 }
2540 
2541 #define PACK_GBR_10BE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_10BE, 1, pack_GBR_10BE
2542 static void
2543 unpack_GBR_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2544     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2545     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2546 {
2547   int i;
2548   const guint16 *restrict sg = GET_G_LINE (y);
2549   const guint16 *restrict sb = GET_B_LINE (y);
2550   const guint16 *restrict sr = GET_R_LINE (y);
2551   guint16 *restrict d = dest, G, B, R;
2552 
2553   sg += x;
2554   sb += x;
2555   sr += x;
2556 
2557   for (i = 0; i &lt; width; i++) {
2558     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 6;
2559     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 6;
2560     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 6;
2561 
2562     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2563       R |= (R &gt;&gt; 10);
2564       G |= (G &gt;&gt; 10);
2565       B |= (B &gt;&gt; 10);
2566     }
2567 
2568     d[i * 4 + 0] = 0xffff;
2569     d[i * 4 + 1] = R;
2570     d[i * 4 + 2] = G;
2571     d[i * 4 + 3] = B;
2572   }
2573 }
2574 
2575 static void
2576 pack_GBR_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2577     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2578     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2579     gint y, gint width)
2580 {
2581   int i;
2582   guint16 *restrict dg = GET_G_LINE (y);
2583   guint16 *restrict db = GET_B_LINE (y);
2584   guint16 *restrict dr = GET_R_LINE (y);
2585   guint16 G, B, R;
2586   const guint16 *restrict s = src;
2587 
2588   for (i = 0; i &lt; width; i++) {
2589     G = s[i * 4 + 2] &gt;&gt; 6;
2590     B = s[i * 4 + 3] &gt;&gt; 6;
2591     R = s[i * 4 + 1] &gt;&gt; 6;
2592 
2593     GST_WRITE_UINT16_BE (dg + i, G);
2594     GST_WRITE_UINT16_BE (db + i, B);
2595     GST_WRITE_UINT16_BE (dr + i, R);
2596   }
2597 }
2598 
2599 #define PACK_GBRA_10LE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_10LE, 1, pack_GBRA_10LE
2600 static void
2601 unpack_GBRA_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2602     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2603     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2604 {
2605   int i;
2606   const guint16 *sg = GET_G_LINE (y);
2607   const guint16 *sb = GET_B_LINE (y);
2608   const guint16 *sr = GET_R_LINE (y);
2609   const guint16 *sa = GET_A_LINE (y);
2610   guint16 *d = dest, G, B, R, A;
2611 
2612   sg += x;
2613   sb += x;
2614   sr += x;
2615   sa += x;
2616 
2617   for (i = 0; i &lt; width; i++) {
2618     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 6;
2619     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 6;
2620     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 6;
2621     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
2622 
2623     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2624       R |= (R &gt;&gt; 10);
2625       G |= (G &gt;&gt; 10);
2626       B |= (B &gt;&gt; 10);
2627       A |= (A &gt;&gt; 10);
2628     }
2629 
2630     d[i * 4 + 0] = A;
2631     d[i * 4 + 1] = R;
2632     d[i * 4 + 2] = G;
2633     d[i * 4 + 3] = B;
2634   }
2635 }
2636 
2637 static void
2638 pack_GBRA_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2639     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2640     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2641     gint y, gint width)
2642 {
2643   int i;
2644   guint16 *restrict dg = GET_G_LINE (y);
2645   guint16 *restrict db = GET_B_LINE (y);
2646   guint16 *restrict dr = GET_R_LINE (y);
2647   guint16 *restrict da = GET_A_LINE (y);
2648   guint16 G, B, R, A;
2649   const guint16 *restrict s = src;
2650 
2651   for (i = 0; i &lt; width; i++) {
2652     G = (s[i * 4 + 2]) &gt;&gt; 6;
2653     B = (s[i * 4 + 3]) &gt;&gt; 6;
2654     R = (s[i * 4 + 1]) &gt;&gt; 6;
2655     A = (s[i * 4 + 0]) &gt;&gt; 6;
2656 
2657     GST_WRITE_UINT16_LE (dg + i, G);
2658     GST_WRITE_UINT16_LE (db + i, B);
2659     GST_WRITE_UINT16_LE (dr + i, R);
2660     GST_WRITE_UINT16_LE (da + i, A);
2661   }
2662 }
2663 
2664 #define PACK_GBRA_10BE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_10BE, 1, pack_GBRA_10BE
2665 static void
2666 unpack_GBRA_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2667     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2668     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2669 {
2670   int i;
2671   const guint16 *restrict sg = GET_G_LINE (y);
2672   const guint16 *restrict sb = GET_B_LINE (y);
2673   const guint16 *restrict sr = GET_R_LINE (y);
2674   const guint16 *restrict sa = GET_A_LINE (y);
2675   guint16 *restrict d = dest, G, B, R, A;
2676 
2677   sg += x;
2678   sb += x;
2679   sr += x;
2680   sa += x;
2681 
2682   for (i = 0; i &lt; width; i++) {
2683     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 6;
2684     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 6;
2685     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 6;
2686     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
2687 
2688     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2689       R |= (R &gt;&gt; 10);
2690       G |= (G &gt;&gt; 10);
2691       B |= (B &gt;&gt; 10);
2692       A |= (A &gt;&gt; 10);
2693     }
2694 
2695     d[i * 4 + 0] = A;
2696     d[i * 4 + 1] = R;
2697     d[i * 4 + 2] = G;
2698     d[i * 4 + 3] = B;
2699   }
2700 }
2701 
2702 static void
2703 pack_GBRA_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2704     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2705     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2706     gint y, gint width)
2707 {
2708   int i;
2709   guint16 *restrict dg = GET_G_LINE (y);
2710   guint16 *restrict db = GET_B_LINE (y);
2711   guint16 *restrict dr = GET_R_LINE (y);
2712   guint16 *restrict da = GET_A_LINE (y);
2713   guint16 G, B, R, A;
2714   const guint16 *restrict s = src;
2715 
2716   for (i = 0; i &lt; width; i++) {
2717     G = s[i * 4 + 2] &gt;&gt; 6;
2718     B = s[i * 4 + 3] &gt;&gt; 6;
2719     R = s[i * 4 + 1] &gt;&gt; 6;
2720     A = s[i * 4 + 0] &gt;&gt; 6;
2721 
2722     GST_WRITE_UINT16_BE (dg + i, G);
2723     GST_WRITE_UINT16_BE (db + i, B);
2724     GST_WRITE_UINT16_BE (dr + i, R);
2725     GST_WRITE_UINT16_BE (da + i, A);
2726   }
2727 }
2728 
2729 #define PACK_GBR_12LE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_12LE, 1, pack_GBR_12LE
2730 static void
2731 unpack_GBR_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2732     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2733     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2734 {
2735   int i;
2736   const guint16 *sg = GET_G_LINE (y);
2737   const guint16 *sb = GET_B_LINE (y);
2738   const guint16 *sr = GET_R_LINE (y);
2739   guint16 *d = dest, G, B, R;
2740 
2741   sg += x;
2742   sb += x;
2743   sr += x;
2744 
2745   for (i = 0; i &lt; width; i++) {
2746     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 4;
2747     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 4;
2748     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 4;
2749 
2750     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2751       R |= (R &gt;&gt; 12);
2752       G |= (G &gt;&gt; 12);
2753       B |= (B &gt;&gt; 12);
2754     }
2755 
2756     d[i * 4 + 0] = 0xffff;
2757     d[i * 4 + 1] = R;
2758     d[i * 4 + 2] = G;
2759     d[i * 4 + 3] = B;
2760   }
2761 }
2762 
2763 static void
2764 pack_GBR_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2765     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2766     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2767     gint y, gint width)
2768 {
2769   int i;
2770   guint16 *restrict dg = GET_G_LINE (y);
2771   guint16 *restrict db = GET_B_LINE (y);
2772   guint16 *restrict dr = GET_R_LINE (y);
2773   guint16 G, B, R;
2774   const guint16 *restrict s = src;
2775 
2776   for (i = 0; i &lt; width; i++) {
2777     G = (s[i * 4 + 2]) &gt;&gt; 4;
2778     B = (s[i * 4 + 3]) &gt;&gt; 4;
2779     R = (s[i * 4 + 1]) &gt;&gt; 4;
2780 
2781     GST_WRITE_UINT16_LE (dg + i, G);
2782     GST_WRITE_UINT16_LE (db + i, B);
2783     GST_WRITE_UINT16_LE (dr + i, R);
2784   }
2785 }
2786 
2787 #define PACK_GBR_12BE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_12BE, 1, pack_GBR_12BE
2788 static void
2789 unpack_GBR_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2790     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2791     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2792 {
2793   int i;
2794   const guint16 *restrict sg = GET_G_LINE (y);
2795   const guint16 *restrict sb = GET_B_LINE (y);
2796   const guint16 *restrict sr = GET_R_LINE (y);
2797   guint16 *restrict d = dest, G, B, R;
2798 
2799   sg += x;
2800   sb += x;
2801   sr += x;
2802 
2803   for (i = 0; i &lt; width; i++) {
2804     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 4;
2805     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 4;
2806     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 4;
2807 
2808     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2809       R |= (R &gt;&gt; 12);
2810       G |= (G &gt;&gt; 12);
2811       B |= (B &gt;&gt; 12);
2812     }
2813 
2814     d[i * 4 + 0] = 0xffff;
2815     d[i * 4 + 1] = R;
2816     d[i * 4 + 2] = G;
2817     d[i * 4 + 3] = B;
2818   }
2819 }
2820 
2821 static void
2822 pack_GBR_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2823     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2824     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2825     gint y, gint width)
2826 {
2827   int i;
2828   guint16 *restrict dg = GET_G_LINE (y);
2829   guint16 *restrict db = GET_B_LINE (y);
2830   guint16 *restrict dr = GET_R_LINE (y);
2831   guint16 G, B, R;
2832   const guint16 *restrict s = src;
2833 
2834   for (i = 0; i &lt; width; i++) {
2835     G = s[i * 4 + 2] &gt;&gt; 4;
2836     B = s[i * 4 + 3] &gt;&gt; 4;
2837     R = s[i * 4 + 1] &gt;&gt; 4;
2838 
2839     GST_WRITE_UINT16_BE (dg + i, G);
2840     GST_WRITE_UINT16_BE (db + i, B);
2841     GST_WRITE_UINT16_BE (dr + i, R);
2842   }
2843 }
2844 
2845 #define PACK_GBRA_12LE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_12LE, 1, pack_GBRA_12LE
2846 static void
2847 unpack_GBRA_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2848     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2849     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2850 {
2851   int i;
2852   const guint16 *sg = GET_G_LINE (y);
2853   const guint16 *sb = GET_B_LINE (y);
2854   const guint16 *sr = GET_R_LINE (y);
2855   const guint16 *sa = GET_A_LINE (y);
2856   guint16 *d = dest, G, B, R, A;
2857 
2858   sg += x;
2859   sb += x;
2860   sr += x;
2861   sa += x;
2862 
2863   for (i = 0; i &lt; width; i++) {
2864     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 4;
2865     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 4;
2866     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 4;
2867     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 4;
2868 
2869     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2870       A |= (A &gt;&gt; 12);
2871       R |= (R &gt;&gt; 12);
2872       G |= (G &gt;&gt; 12);
2873       B |= (B &gt;&gt; 12);
2874     }
2875 
2876     d[i * 4 + 0] = A;
2877     d[i * 4 + 1] = R;
2878     d[i * 4 + 2] = G;
2879     d[i * 4 + 3] = B;
2880   }
2881 }
2882 
2883 static void
2884 pack_GBRA_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2885     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2886     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2887     gint y, gint width)
2888 {
2889   int i;
2890   guint16 *restrict dg = GET_G_LINE (y);
2891   guint16 *restrict db = GET_B_LINE (y);
2892   guint16 *restrict dr = GET_R_LINE (y);
2893   guint16 *restrict da = GET_A_LINE (y);
2894   guint16 G, B, R, A;
2895   const guint16 *restrict s = src;
2896 
2897   for (i = 0; i &lt; width; i++) {
2898     G = (s[i * 4 + 2]) &gt;&gt; 4;
2899     B = (s[i * 4 + 3]) &gt;&gt; 4;
2900     R = (s[i * 4 + 1]) &gt;&gt; 4;
2901     A = (s[i * 4 + 0]) &gt;&gt; 4;
2902 
2903     GST_WRITE_UINT16_LE (dg + i, G);
2904     GST_WRITE_UINT16_LE (db + i, B);
2905     GST_WRITE_UINT16_LE (dr + i, R);
2906     GST_WRITE_UINT16_LE (da + i, A);
2907   }
2908 }
2909 
2910 #define PACK_GBRA_12BE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_12BE, 1, pack_GBRA_12BE
2911 static void
2912 unpack_GBRA_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2913     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2914     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2915 {
2916   int i;
2917   const guint16 *restrict sg = GET_G_LINE (y);
2918   const guint16 *restrict sb = GET_B_LINE (y);
2919   const guint16 *restrict sr = GET_R_LINE (y);
2920   const guint16 *restrict sa = GET_A_LINE (y);
2921   guint16 *restrict d = dest, G, B, R, A;
2922 
2923   sg += x;
2924   sb += x;
2925   sr += x;
2926   sa += x;
2927 
2928   for (i = 0; i &lt; width; i++) {
2929     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 4;
2930     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 4;
2931     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 4;
2932     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 4;
2933 
2934     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2935       R |= (R &gt;&gt; 12);
2936       G |= (G &gt;&gt; 12);
2937       B |= (B &gt;&gt; 12);
2938       A |= (A &gt;&gt; 12);
2939     }
2940 
2941     d[i * 4 + 0] = A;
2942     d[i * 4 + 1] = R;
2943     d[i * 4 + 2] = G;
2944     d[i * 4 + 3] = B;
2945   }
2946 }
2947 
2948 static void
2949 pack_GBRA_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2950     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2951     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2952     gint y, gint width)
2953 {
2954   int i;
2955   guint16 *restrict dg = GET_G_LINE (y);
2956   guint16 *restrict db = GET_B_LINE (y);
2957   guint16 *restrict dr = GET_R_LINE (y);
2958   guint16 *restrict da = GET_A_LINE (y);
2959   guint16 G, B, R, A;
2960   const guint16 *restrict s = src;
2961 
2962   for (i = 0; i &lt; width; i++) {
2963     G = s[i * 4 + 2] &gt;&gt; 4;
2964     B = s[i * 4 + 3] &gt;&gt; 4;
2965     R = s[i * 4 + 1] &gt;&gt; 4;
2966     A = s[i * 4 + 0] &gt;&gt; 4;
2967 
2968     GST_WRITE_UINT16_BE (dg + i, G);
2969     GST_WRITE_UINT16_BE (db + i, B);
2970     GST_WRITE_UINT16_BE (dr + i, R);
2971     GST_WRITE_UINT16_BE (da + i, A);
2972   }
2973 }
2974 
2975 #define PACK_Y444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_10LE, 1, pack_Y444_10LE
2976 static void
2977 unpack_Y444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2978     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2979     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2980 {
2981   int i;
2982   guint16 *restrict sy = GET_Y_LINE (y);
2983   guint16 *restrict su = GET_U_LINE (y);
2984   guint16 *restrict sv = GET_V_LINE (y);
2985   guint16 *restrict d = dest, Y, U, V;
2986 
2987   sy += x;
2988   su += x;
2989   sv += x;
2990 
2991   for (i = 0; i &lt; width; i++) {
2992     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
2993     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 6;
2994     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 6;
2995 
2996     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2997       Y |= (Y &gt;&gt; 10);
2998       U |= (U &gt;&gt; 10);
2999       V |= (V &gt;&gt; 10);
3000     }
3001 
3002     d[i * 4 + 0] = 0xffff;
3003     d[i * 4 + 1] = Y;
3004     d[i * 4 + 2] = U;
3005     d[i * 4 + 3] = V;
3006   }
3007 }
3008 
3009 static void
3010 pack_Y444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3011     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3012     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3013     gint y, gint width)
3014 {
3015   int i;
3016   guint16 *restrict dy = GET_Y_LINE (y);
3017   guint16 *restrict du = GET_U_LINE (y);
3018   guint16 *restrict dv = GET_V_LINE (y);
3019   guint16 Y, U, V;
3020   const guint16 *restrict s = src;
3021 
3022   for (i = 0; i &lt; width; i++) {
3023     Y = (s[i * 4 + 1]) &gt;&gt; 6;
3024     U = (s[i * 4 + 2]) &gt;&gt; 6;
3025     V = (s[i * 4 + 3]) &gt;&gt; 6;
3026 
3027     GST_WRITE_UINT16_LE (dy + i, Y);
3028     GST_WRITE_UINT16_LE (du + i, U);
3029     GST_WRITE_UINT16_LE (dv + i, V);
3030   }
3031 }
3032 
3033 #define PACK_Y444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_10BE, 1, pack_Y444_10BE
3034 static void
3035 unpack_Y444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3036     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3037     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3038 {
3039   int i;
3040   const guint16 *restrict sy = GET_Y_LINE (y);
3041   const guint16 *restrict su = GET_U_LINE (y);
3042   const guint16 *restrict sv = GET_V_LINE (y);
3043   guint16 *restrict d = dest, Y, U, V;
3044 
3045   sy += x;
3046   su += x;
3047   sv += x;
3048 
3049   for (i = 0; i &lt; width; i++) {
3050     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3051     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 6;
3052     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 6;
3053 
3054     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3055       Y |= (Y &gt;&gt; 10);
3056       U |= (U &gt;&gt; 10);
3057       V |= (V &gt;&gt; 10);
3058     }
3059 
3060     d[i * 4 + 0] = 0xffff;
3061     d[i * 4 + 1] = Y;
3062     d[i * 4 + 2] = U;
3063     d[i * 4 + 3] = V;
3064   }
3065 }
3066 
3067 static void
3068 pack_Y444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3069     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3070     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3071     gint y, gint width)
3072 {
3073   int i;
3074   guint16 *restrict dy = GET_Y_LINE (y);
3075   guint16 *restrict du = GET_U_LINE (y);
3076   guint16 *restrict dv = GET_V_LINE (y);
3077   guint16 Y, U, V;
3078   const guint16 *restrict s = src;
3079 
3080   for (i = 0; i &lt; width; i++) {
3081     Y = s[i * 4 + 1] &gt;&gt; 6;
3082     U = s[i * 4 + 2] &gt;&gt; 6;
3083     V = s[i * 4 + 3] &gt;&gt; 6;
3084 
3085     GST_WRITE_UINT16_BE (dy + i, Y);
3086     GST_WRITE_UINT16_BE (du + i, U);
3087     GST_WRITE_UINT16_BE (dv + i, V);
3088   }
3089 }
3090 
3091 #define PACK_I420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10LE, 1, pack_I420_10LE
3092 static void
3093 unpack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3094     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3095     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3096 {
3097   int i;
3098   gint uv = GET_UV_420 (y, flags);
3099   const guint16 *restrict sy = GET_Y_LINE (y);
3100   const guint16 *restrict su = GET_U_LINE (uv);
3101   const guint16 *restrict sv = GET_V_LINE (uv);
3102   guint16 *restrict d = dest, Y, U, V;
3103 
3104   sy += x;
3105   su += x &gt;&gt; 1;
3106   sv += x &gt;&gt; 1;
3107 
3108   for (i = 0; i &lt; width; i++) {
3109     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3110     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3111     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3112 
3113     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3114       Y |= (Y &gt;&gt; 10);
3115       U |= (U &gt;&gt; 10);
3116       V |= (V &gt;&gt; 10);
3117     }
3118 
3119     d[i * 4 + 0] = 0xffff;
3120     d[i * 4 + 1] = Y;
3121     d[i * 4 + 2] = U;
3122     d[i * 4 + 3] = V;
3123 
3124     if (x &amp; 1) {
3125       x = 0;
3126       su++;
3127       sv++;
<a name="19" id="anc19"></a><span class="line-added">3128     }</span>
3129   }
3130 }
<a name="20" id="anc20"></a>
3131 
3132 static void
3133 pack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3134     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3135     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3136     gint y, gint width)
3137 {
3138   int i;
3139   gint uv = GET_UV_420 (y, flags);
3140   guint16 *restrict dy = GET_Y_LINE (y);
3141   guint16 *restrict du = GET_U_LINE (uv);
3142   guint16 *restrict dv = GET_V_LINE (uv);
3143   guint16 Y0, Y1, U, V;
3144   const guint16 *restrict s = src;
3145 
3146   if (IS_CHROMA_LINE_420 (y, flags)) {
<a name="21" id="anc21"></a><span class="line-modified">3147     for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3148       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3149       Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3150       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3151       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3152 
3153       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3154       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3155       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3156       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<a name="22" id="anc22"></a><span class="line-modified">3157     }</span>
<span class="line-modified">3158     if (i == width - 1) {</span>
<span class="line-modified">3159       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3160       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3161       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3162 
3163       GST_WRITE_UINT16_LE (dy + i, Y0);
3164       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3165       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<a name="23" id="anc23"></a><span class="line-modified">3166     }</span>
3167   } else {
3168     for (i = 0; i &lt; width; i++) {
3169       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3170       GST_WRITE_UINT16_LE (dy + i, Y0);
<a name="24" id="anc24"></a><span class="line-modified">3171     }</span>
3172   }
3173 }
3174 
3175 #define PACK_I420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10BE, 1, pack_I420_10BE
3176 static void
3177 unpack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3178     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3179     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3180 {
3181   int i;
3182   gint uv = GET_UV_420 (y, flags);
3183   const guint16 *restrict sy = GET_Y_LINE (y);
3184   const guint16 *restrict su = GET_U_LINE (uv);
3185   const guint16 *restrict sv = GET_V_LINE (uv);
3186   guint16 *restrict d = dest, Y, U, V;
3187 
3188   sy += x;
3189   su += x &gt;&gt; 1;
3190   sv += x &gt;&gt; 1;
3191 
3192   for (i = 0; i &lt; width; i++) {
3193     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3194     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3195     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3196 
3197     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3198       Y |= (Y &gt;&gt; 10);
3199       U |= (U &gt;&gt; 10);
3200       V |= (V &gt;&gt; 10);
3201     }
3202 
3203     d[i * 4 + 0] = 0xffff;
3204     d[i * 4 + 1] = Y;
3205     d[i * 4 + 2] = U;
3206     d[i * 4 + 3] = V;
3207 
3208     if (x &amp; 1) {
3209       x = 0;
3210       su++;
3211       sv++;
<a name="25" id="anc25"></a><span class="line-added">3212     }</span>
3213   }
3214 }
<a name="26" id="anc26"></a>
3215 
3216 static void
3217 pack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3218     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3219     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3220     gint y, gint width)
3221 {
3222   int i;
3223   gint uv = GET_UV_420 (y, flags);
3224   guint16 *restrict dy = GET_Y_LINE (y);
3225   guint16 *restrict du = GET_U_LINE (uv);
3226   guint16 *restrict dv = GET_V_LINE (uv);
3227   guint16 Y0, Y1, U, V;
3228   const guint16 *restrict s = src;
3229 
3230   if (IS_CHROMA_LINE_420 (y, flags)) {
<a name="27" id="anc27"></a><span class="line-modified">3231     for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3232       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3233       Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3234       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3235       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3236 
3237       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3238       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3239       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3240       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<a name="28" id="anc28"></a><span class="line-modified">3241     }</span>
<span class="line-modified">3242     if (i == width - 1) {</span>
<span class="line-modified">3243       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3244       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3245       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3246 
3247       GST_WRITE_UINT16_BE (dy + i, Y0);
3248       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3249       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<a name="29" id="anc29"></a><span class="line-modified">3250     }</span>
3251   } else {
3252     for (i = 0; i &lt; width; i++) {
3253       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3254       GST_WRITE_UINT16_BE (dy + i, Y0);
<a name="30" id="anc30"></a><span class="line-modified">3255     }</span>
3256   }
3257 }
3258 
3259 #define PACK_I422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10LE, 1, pack_I422_10LE
3260 static void
3261 unpack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3262     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3263     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3264 {
3265   int i;
3266   const guint16 *restrict sy = GET_Y_LINE (y);
3267   const guint16 *restrict su = GET_U_LINE (y);
3268   const guint16 *restrict sv = GET_V_LINE (y);
3269   guint16 *restrict d = dest, Y, U, V;
3270 
3271   sy += x;
3272   su += x &gt;&gt; 1;
3273   sv += x &gt;&gt; 1;
3274 
3275   for (i = 0; i &lt; width; i++) {
3276     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3277     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3278     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3279 
3280     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3281       Y |= (Y &gt;&gt; 10);
3282       U |= (U &gt;&gt; 10);
3283       V |= (V &gt;&gt; 10);
3284     }
3285 
3286     d[i * 4 + 0] = 0xffff;
3287     d[i * 4 + 1] = Y;
3288     d[i * 4 + 2] = U;
3289     d[i * 4 + 3] = V;
3290 
3291     if (x &amp; 1) {
3292       x = 0;
3293       su++;
3294       sv++;
<a name="31" id="anc31"></a><span class="line-added">3295     }</span>
3296   }
3297 }
<a name="32" id="anc32"></a>
3298 
3299 static void
3300 pack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3301     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3302     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3303     gint y, gint width)
3304 {
3305   int i;
3306   guint16 *restrict dy = GET_Y_LINE (y);
3307   guint16 *restrict du = GET_U_LINE (y);
3308   guint16 *restrict dv = GET_V_LINE (y);
3309   guint16 Y0, Y1, U, V;
3310   const guint16 *restrict s = src;
3311 
3312   for (i = 0; i &lt; width - 1; i += 2) {
3313     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3314     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3315     U = s[i * 4 + 2] &gt;&gt; 6;
3316     V = s[i * 4 + 3] &gt;&gt; 6;
3317 
3318     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3319     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3320     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3321     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3322   }
3323   if (i == width - 1) {
3324     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3325     U = s[i * 4 + 2] &gt;&gt; 6;
3326     V = s[i * 4 + 3] &gt;&gt; 6;
3327 
3328     GST_WRITE_UINT16_LE (dy + i, Y0);
3329     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3330     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3331   }
3332 }
3333 
3334 #define PACK_I422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10BE, 1, pack_I422_10BE
3335 static void
3336 unpack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3337     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3338     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3339 {
3340   int i;
3341   const guint16 *restrict sy = GET_Y_LINE (y);
3342   const guint16 *restrict su = GET_U_LINE (y);
3343   const guint16 *restrict sv = GET_V_LINE (y);
3344   guint16 *restrict d = dest, Y, U, V;
3345 
3346   sy += x;
3347   su += x &gt;&gt; 1;
3348   sv += x &gt;&gt; 1;
3349 
3350   for (i = 0; i &lt; width; i++) {
3351     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3352     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3353     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3354 
3355     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3356       Y |= (Y &gt;&gt; 10);
3357       U |= (U &gt;&gt; 10);
3358       V |= (V &gt;&gt; 10);
3359     }
3360 
3361     d[i * 4 + 0] = 0xffff;
3362     d[i * 4 + 1] = Y;
3363     d[i * 4 + 2] = U;
3364     d[i * 4 + 3] = V;
3365 
3366     if (x &amp; 1) {
3367       x = 0;
3368       su++;
3369       sv++;
<a name="33" id="anc33"></a><span class="line-added">3370     }</span>
3371   }
3372 }
<a name="34" id="anc34"></a>
3373 
3374 static void
3375 pack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3376     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3377     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3378     gint y, gint width)
3379 {
3380   int i;
3381   guint16 *restrict dy = GET_Y_LINE (y);
3382   guint16 *restrict du = GET_U_LINE (y);
3383   guint16 *restrict dv = GET_V_LINE (y);
3384   guint16 Y0, Y1, U, V;
3385   const guint16 *restrict s = src;
3386 
3387   for (i = 0; i &lt; width - 1; i += 2) {
3388     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3389     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3390     U = s[i * 4 + 2] &gt;&gt; 6;
3391     V = s[i * 4 + 3] &gt;&gt; 6;
3392 
3393     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3394     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3395     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3396     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3397   }
3398   if (i == width - 1) {
3399     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3400     U = s[i * 4 + 2] &gt;&gt; 6;
3401     V = s[i * 4 + 3] &gt;&gt; 6;
3402 
3403     GST_WRITE_UINT16_BE (dy + i, Y0);
3404     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3405     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3406   }
3407 }
3408 
3409 #define PACK_Y444_12LE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_12LE, 1, pack_Y444_12LE
3410 static void
3411 unpack_Y444_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3412     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3413     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3414 {
3415   int i;
3416   guint16 *restrict sy = GET_Y_LINE (y);
3417   guint16 *restrict su = GET_U_LINE (y);
3418   guint16 *restrict sv = GET_V_LINE (y);
3419   guint16 *restrict d = dest, Y, U, V;
3420 
3421   sy += x;
3422   su += x;
3423   sv += x;
3424 
3425   for (i = 0; i &lt; width; i++) {
3426     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3427     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 4;
3428     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 4;
3429 
3430     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3431       Y |= (Y &gt;&gt; 12);
3432       U |= (U &gt;&gt; 12);
3433       V |= (V &gt;&gt; 12);
3434     }
3435 
3436     d[i * 4 + 0] = 0xffff;
3437     d[i * 4 + 1] = Y;
3438     d[i * 4 + 2] = U;
3439     d[i * 4 + 3] = V;
3440   }
3441 }
3442 
3443 static void
3444 pack_Y444_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3445     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3446     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3447     gint y, gint width)
3448 {
3449   int i;
3450   guint16 *restrict dy = GET_Y_LINE (y);
3451   guint16 *restrict du = GET_U_LINE (y);
3452   guint16 *restrict dv = GET_V_LINE (y);
3453   guint16 Y, U, V;
3454   const guint16 *restrict s = src;
3455 
3456   for (i = 0; i &lt; width; i++) {
3457     Y = (s[i * 4 + 1]) &gt;&gt; 4;
3458     U = (s[i * 4 + 2]) &gt;&gt; 4;
3459     V = (s[i * 4 + 3]) &gt;&gt; 4;
3460 
3461     GST_WRITE_UINT16_LE (dy + i, Y);
3462     GST_WRITE_UINT16_LE (du + i, U);
3463     GST_WRITE_UINT16_LE (dv + i, V);
3464   }
3465 }
3466 
3467 #define PACK_Y444_12BE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_12BE, 1, pack_Y444_12BE
3468 static void
3469 unpack_Y444_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3470     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3471     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3472 {
3473   int i;
3474   const guint16 *restrict sy = GET_Y_LINE (y);
3475   const guint16 *restrict su = GET_U_LINE (y);
3476   const guint16 *restrict sv = GET_V_LINE (y);
3477   guint16 *restrict d = dest, Y, U, V;
3478 
3479   sy += x;
3480   su += x;
3481   sv += x;
3482 
3483   for (i = 0; i &lt; width; i++) {
3484     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3485     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 4;
3486     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 4;
3487 
3488     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3489       Y |= (Y &gt;&gt; 12);
3490       U |= (U &gt;&gt; 12);
3491       V |= (V &gt;&gt; 12);
3492     }
3493 
3494     d[i * 4 + 0] = 0xffff;
3495     d[i * 4 + 1] = Y;
3496     d[i * 4 + 2] = U;
3497     d[i * 4 + 3] = V;
3498   }
3499 }
3500 
3501 static void
3502 pack_Y444_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3503     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3504     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3505     gint y, gint width)
3506 {
3507   int i;
3508   guint16 *restrict dy = GET_Y_LINE (y);
3509   guint16 *restrict du = GET_U_LINE (y);
3510   guint16 *restrict dv = GET_V_LINE (y);
3511   guint16 Y, U, V;
3512   const guint16 *restrict s = src;
3513 
3514   for (i = 0; i &lt; width; i++) {
3515     Y = s[i * 4 + 1] &gt;&gt; 4;
3516     U = s[i * 4 + 2] &gt;&gt; 4;
3517     V = s[i * 4 + 3] &gt;&gt; 4;
3518 
3519     GST_WRITE_UINT16_BE (dy + i, Y);
3520     GST_WRITE_UINT16_BE (du + i, U);
3521     GST_WRITE_UINT16_BE (dv + i, V);
3522   }
3523 }
3524 
3525 #define PACK_I420_12LE GST_VIDEO_FORMAT_AYUV64, unpack_I420_12LE, 1, pack_I420_12LE
3526 static void
3527 unpack_I420_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3528     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3529     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3530 {
3531   int i;
3532   gint uv = GET_UV_420 (y, flags);
3533   const guint16 *restrict sy = GET_Y_LINE (y);
3534   const guint16 *restrict su = GET_U_LINE (uv);
3535   const guint16 *restrict sv = GET_V_LINE (uv);
3536   guint16 *restrict d = dest, Y, U, V;
3537 
3538   sy += x;
3539   su += x &gt;&gt; 1;
3540   sv += x &gt;&gt; 1;
3541 
3542   for (i = 0; i &lt; width; i++) {
3543     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3544     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3545     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3546 
3547     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3548       Y |= (Y &gt;&gt; 12);
3549       U |= (U &gt;&gt; 12);
3550       V |= (V &gt;&gt; 12);
3551     }
3552 
3553     d[i * 4 + 0] = 0xffff;
3554     d[i * 4 + 1] = Y;
3555     d[i * 4 + 2] = U;
3556     d[i * 4 + 3] = V;
3557 
3558     if (x &amp; 1) {
3559       x = 0;
3560       su++;
3561       sv++;
3562     }
3563   }
3564 }
3565 
3566 static void
3567 pack_I420_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3568     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3569     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3570     gint y, gint width)
3571 {
3572   int i;
3573   gint uv = GET_UV_420 (y, flags);
3574   guint16 *restrict dy = GET_Y_LINE (y);
3575   guint16 *restrict du = GET_U_LINE (uv);
3576   guint16 *restrict dv = GET_V_LINE (uv);
3577   guint16 Y0, Y1, U, V;
3578   const guint16 *restrict s = src;
3579 
3580   if (IS_CHROMA_LINE_420 (y, flags)) {
3581     for (i = 0; i &lt; width - 1; i += 2) {
3582       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3583       Y1 = s[i * 4 + 5] &gt;&gt; 4;
3584       U = s[i * 4 + 2] &gt;&gt; 4;
3585       V = s[i * 4 + 3] &gt;&gt; 4;
3586 
3587       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3588       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3589       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3590       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3591     }
3592     if (i == width - 1) {
3593       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3594       U = s[i * 4 + 2] &gt;&gt; 4;
3595       V = s[i * 4 + 3] &gt;&gt; 4;
3596 
3597       GST_WRITE_UINT16_LE (dy + i, Y0);
3598       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3599       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3600     }
3601   } else {
3602     for (i = 0; i &lt; width; i++) {
3603       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3604       GST_WRITE_UINT16_LE (dy + i, Y0);
3605     }
3606   }
3607 }
3608 
3609 #define PACK_I420_12BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_12BE, 1, pack_I420_12BE
3610 static void
3611 unpack_I420_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3612     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3613     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3614 {
3615   int i;
3616   gint uv = GET_UV_420 (y, flags);
3617   const guint16 *restrict sy = GET_Y_LINE (y);
3618   const guint16 *restrict su = GET_U_LINE (uv);
3619   const guint16 *restrict sv = GET_V_LINE (uv);
3620   guint16 *restrict d = dest, Y, U, V;
3621 
3622   sy += x;
3623   su += x &gt;&gt; 1;
3624   sv += x &gt;&gt; 1;
3625 
3626   for (i = 0; i &lt; width; i++) {
3627     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3628     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3629     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3630 
3631     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3632       Y |= (Y &gt;&gt; 12);
3633       U |= (U &gt;&gt; 12);
3634       V |= (V &gt;&gt; 12);
3635     }
3636 
3637     d[i * 4 + 0] = 0xffff;
3638     d[i * 4 + 1] = Y;
3639     d[i * 4 + 2] = U;
3640     d[i * 4 + 3] = V;
3641 
3642     if (x &amp; 1) {
3643       x = 0;
3644       su++;
3645       sv++;
3646     }
3647   }
3648 }
3649 
3650 static void
3651 pack_I420_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3652     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3653     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3654     gint y, gint width)
3655 {
3656   int i;
3657   gint uv = GET_UV_420 (y, flags);
3658   guint16 *restrict dy = GET_Y_LINE (y);
3659   guint16 *restrict du = GET_U_LINE (uv);
3660   guint16 *restrict dv = GET_V_LINE (uv);
3661   guint16 Y0, Y1, U, V;
3662   const guint16 *restrict s = src;
3663 
3664   if (IS_CHROMA_LINE_420 (y, flags)) {
3665     for (i = 0; i &lt; width - 1; i += 2) {
3666       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3667       Y1 = s[i * 4 + 5] &gt;&gt; 4;
3668       U = s[i * 4 + 2] &gt;&gt; 4;
3669       V = s[i * 4 + 3] &gt;&gt; 4;
3670 
3671       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3672       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3673       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3674       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3675     }
3676     if (i == width - 1) {
3677       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3678       U = s[i * 4 + 2] &gt;&gt; 4;
3679       V = s[i * 4 + 3] &gt;&gt; 4;
3680 
3681       GST_WRITE_UINT16_BE (dy + i, Y0);
3682       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3683       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3684     }
3685   } else {
3686     for (i = 0; i &lt; width; i++) {
3687       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3688       GST_WRITE_UINT16_BE (dy + i, Y0);
3689     }
3690   }
3691 }
3692 
3693 #define PACK_I422_12LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_12LE, 1, pack_I422_12LE
3694 static void
3695 unpack_I422_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3696     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3697     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3698 {
3699   int i;
3700   const guint16 *restrict sy = GET_Y_LINE (y);
3701   const guint16 *restrict su = GET_U_LINE (y);
3702   const guint16 *restrict sv = GET_V_LINE (y);
3703   guint16 *restrict d = dest, Y, U, V;
3704 
3705   sy += x;
3706   su += x &gt;&gt; 1;
3707   sv += x &gt;&gt; 1;
3708 
3709   for (i = 0; i &lt; width; i++) {
3710     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3711     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3712     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3713 
3714     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3715       Y |= (Y &gt;&gt; 12);
3716       U |= (U &gt;&gt; 12);
3717       V |= (V &gt;&gt; 12);
3718     }
3719 
3720     d[i * 4 + 0] = 0xffff;
3721     d[i * 4 + 1] = Y;
3722     d[i * 4 + 2] = U;
3723     d[i * 4 + 3] = V;
3724 
3725     if (x &amp; 1) {
3726       x = 0;
3727       su++;
3728       sv++;
3729     }
3730   }
3731 }
3732 
3733 static void
3734 pack_I422_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3735     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3736     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3737     gint y, gint width)
3738 {
3739   int i;
3740   guint16 *restrict dy = GET_Y_LINE (y);
3741   guint16 *restrict du = GET_U_LINE (y);
3742   guint16 *restrict dv = GET_V_LINE (y);
3743   guint16 Y0, Y1, U, V;
3744   const guint16 *restrict s = src;
3745 
3746   for (i = 0; i &lt; width - 1; i += 2) {
3747     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3748     Y1 = s[i * 4 + 5] &gt;&gt; 4;
3749     U = s[i * 4 + 2] &gt;&gt; 4;
3750     V = s[i * 4 + 3] &gt;&gt; 4;
3751 
3752     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3753     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3754     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3755     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3756   }
3757   if (i == width - 1) {
3758     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3759     U = s[i * 4 + 2] &gt;&gt; 4;
3760     V = s[i * 4 + 3] &gt;&gt; 4;
3761 
3762     GST_WRITE_UINT16_LE (dy + i, Y0);
3763     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3764     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3765   }
3766 }
3767 
3768 #define PACK_I422_12BE GST_VIDEO_FORMAT_AYUV64, unpack_I422_12BE, 1, pack_I422_12BE
3769 static void
3770 unpack_I422_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3771     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3772     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3773 {
3774   int i;
3775   const guint16 *restrict sy = GET_Y_LINE (y);
3776   const guint16 *restrict su = GET_U_LINE (y);
3777   const guint16 *restrict sv = GET_V_LINE (y);
3778   guint16 *restrict d = dest, Y, U, V;
3779 
3780   sy += x;
3781   su += x &gt;&gt; 1;
3782   sv += x &gt;&gt; 1;
3783 
3784   for (i = 0; i &lt; width; i++) {
3785     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3786     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3787     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3788 
3789     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3790       Y |= (Y &gt;&gt; 12);
3791       U |= (U &gt;&gt; 12);
3792       V |= (V &gt;&gt; 12);
3793     }
3794 
3795     d[i * 4 + 0] = 0xffff;
3796     d[i * 4 + 1] = Y;
3797     d[i * 4 + 2] = U;
3798     d[i * 4 + 3] = V;
3799 
3800     if (x &amp; 1) {
3801       x = 0;
3802       su++;
3803       sv++;
3804     }
3805   }
3806 }
3807 
3808 static void
3809 pack_I422_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3810     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3811     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3812     gint y, gint width)
3813 {
3814   int i;
3815   guint16 *restrict dy = GET_Y_LINE (y);
3816   guint16 *restrict du = GET_U_LINE (y);
3817   guint16 *restrict dv = GET_V_LINE (y);
3818   guint16 Y0, Y1, U, V;
3819   const guint16 *restrict s = src;
3820 
3821   for (i = 0; i &lt; width - 1; i += 2) {
3822     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3823     Y1 = s[i * 4 + 5] &gt;&gt; 4;
3824     U = s[i * 4 + 2] &gt;&gt; 4;
3825     V = s[i * 4 + 3] &gt;&gt; 4;
3826 
3827     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3828     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3829     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3830     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3831   }
3832   if (i == width - 1) {
3833     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3834     U = s[i * 4 + 2] &gt;&gt; 4;
3835     V = s[i * 4 + 3] &gt;&gt; 4;
3836 
3837     GST_WRITE_UINT16_BE (dy + i, Y0);
3838     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3839     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3840   }
3841 }
3842 
3843 #define PACK_A444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10LE, 1, pack_A444_10LE
3844 static void
3845 unpack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3846     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3847     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3848 {
3849   int i;
3850   guint16 *restrict sa = GET_A_LINE (y);
3851   guint16 *restrict sy = GET_Y_LINE (y);
3852   guint16 *restrict su = GET_U_LINE (y);
3853   guint16 *restrict sv = GET_V_LINE (y);
3854   guint16 *restrict d = dest, A, Y, U, V;
3855 
3856   sa += x;
3857   sy += x;
3858   su += x;
3859   sv += x;
3860 
3861   for (i = 0; i &lt; width; i++) {
3862     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
3863     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3864     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 6;
3865     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 6;
3866 
3867     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3868       A |= (A &gt;&gt; 10);
3869       Y |= (Y &gt;&gt; 10);
3870       U |= (U &gt;&gt; 10);
3871       V |= (V &gt;&gt; 10);
3872     }
3873 
3874     d[i * 4 + 0] = A;
3875     d[i * 4 + 1] = Y;
3876     d[i * 4 + 2] = U;
3877     d[i * 4 + 3] = V;
3878   }
3879 }
3880 
3881 static void
3882 pack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3883     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3884     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3885     gint y, gint width)
3886 {
3887   int i;
3888   guint16 *restrict da = GET_A_LINE (y);
3889   guint16 *restrict dy = GET_Y_LINE (y);
3890   guint16 *restrict du = GET_U_LINE (y);
3891   guint16 *restrict dv = GET_V_LINE (y);
3892   guint16 A, Y, U, V;
3893   const guint16 *restrict s = src;
3894 
3895   for (i = 0; i &lt; width; i++) {
3896     A = (s[i * 4 + 0]) &gt;&gt; 6;
3897     Y = (s[i * 4 + 1]) &gt;&gt; 6;
3898     U = (s[i * 4 + 2]) &gt;&gt; 6;
3899     V = (s[i * 4 + 3]) &gt;&gt; 6;
3900 
3901     GST_WRITE_UINT16_LE (da + i, A);
3902     GST_WRITE_UINT16_LE (dy + i, Y);
3903     GST_WRITE_UINT16_LE (du + i, U);
3904     GST_WRITE_UINT16_LE (dv + i, V);
3905   }
3906 }
3907 
3908 #define PACK_A444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10BE, 1, pack_A444_10BE
3909 static void
3910 unpack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3911     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3912     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3913 {
3914   int i;
3915   const guint16 *restrict sa = GET_A_LINE (y);
3916   const guint16 *restrict sy = GET_Y_LINE (y);
3917   const guint16 *restrict su = GET_U_LINE (y);
3918   const guint16 *restrict sv = GET_V_LINE (y);
3919   guint16 *restrict d = dest, A, Y, U, V;
3920 
3921   sa += x;
3922   sy += x;
3923   su += x;
3924   sv += x;
3925 
3926   for (i = 0; i &lt; width; i++) {
3927     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
3928     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3929     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 6;
3930     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 6;
3931 
3932     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3933       A |= (A &gt;&gt; 10);
3934       Y |= (Y &gt;&gt; 10);
3935       U |= (U &gt;&gt; 10);
3936       V |= (V &gt;&gt; 10);
3937     }
3938 
3939     d[i * 4 + 0] = A;
3940     d[i * 4 + 1] = Y;
3941     d[i * 4 + 2] = U;
3942     d[i * 4 + 3] = V;
3943   }
3944 }
3945 
3946 static void
3947 pack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3948     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3949     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3950     gint y, gint width)
3951 {
3952   int i;
3953   guint16 *restrict da = GET_A_LINE (y);
3954   guint16 *restrict dy = GET_Y_LINE (y);
3955   guint16 *restrict du = GET_U_LINE (y);
3956   guint16 *restrict dv = GET_V_LINE (y);
3957   guint16 A, Y, U, V;
3958   const guint16 *restrict s = src;
3959 
3960   for (i = 0; i &lt; width; i++) {
3961     A = s[i * 4 + 0] &gt;&gt; 6;
3962     Y = s[i * 4 + 1] &gt;&gt; 6;
3963     U = s[i * 4 + 2] &gt;&gt; 6;
3964     V = s[i * 4 + 3] &gt;&gt; 6;
3965 
3966     GST_WRITE_UINT16_BE (da + i, A);
3967     GST_WRITE_UINT16_BE (dy + i, Y);
3968     GST_WRITE_UINT16_BE (du + i, U);
3969     GST_WRITE_UINT16_BE (dv + i, V);
3970   }
3971 }
3972 
3973 #define PACK_A420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10LE, 1, pack_A420_10LE
3974 static void
3975 unpack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3976     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3977     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3978 {
3979   int i;
3980   gint uv = GET_UV_420 (y, flags);
3981   const guint16 *restrict sa = GET_A_LINE (y);
3982   const guint16 *restrict sy = GET_Y_LINE (y);
3983   const guint16 *restrict su = GET_U_LINE (uv);
3984   const guint16 *restrict sv = GET_V_LINE (uv);
3985   guint16 *restrict d = dest, A, Y, U, V;
3986 
3987   sa += x;
3988   sy += x;
3989   su += x &gt;&gt; 1;
3990   sv += x &gt;&gt; 1;
3991 
3992   for (i = 0; i &lt; width; i++) {
3993     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
3994     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3995     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3996     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3997 
3998     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3999       A |= (A &gt;&gt; 10);
4000       Y |= (Y &gt;&gt; 10);
4001       U |= (U &gt;&gt; 10);
4002       V |= (V &gt;&gt; 10);
4003     }
4004 
4005     d[i * 4 + 0] = A;
4006     d[i * 4 + 1] = Y;
4007     d[i * 4 + 2] = U;
4008     d[i * 4 + 3] = V;
4009 
4010     if (x &amp; 1) {
4011       x = 0;
4012       su++;
4013       sv++;
4014     }
4015   }
4016 }
4017 
4018 static void
4019 pack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4020     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4021     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4022     gint y, gint width)
4023 {
4024   int i;
4025   gint uv = GET_UV_420 (y, flags);
4026   guint16 *restrict da = GET_A_LINE (y);
4027   guint16 *restrict dy = GET_Y_LINE (y);
4028   guint16 *restrict du = GET_U_LINE (uv);
4029   guint16 *restrict dv = GET_V_LINE (uv);
4030   guint16 A0, Y0, A1, Y1, U, V;
4031   const guint16 *restrict s = src;
4032 
4033   if (IS_CHROMA_LINE_420 (y, flags)) {
4034     for (i = 0; i &lt; width - 1; i += 2) {
4035       A0 = s[i * 4 + 0] &gt;&gt; 6;
4036       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4037       A1 = s[i * 4 + 4] &gt;&gt; 6;
4038       Y1 = s[i * 4 + 5] &gt;&gt; 6;
4039       U = s[i * 4 + 2] &gt;&gt; 6;
4040       V = s[i * 4 + 3] &gt;&gt; 6;
4041 
4042       GST_WRITE_UINT16_LE (da + i + 0, A0);
4043       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
4044       GST_WRITE_UINT16_LE (da + i + 1, A1);
4045       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
4046       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4047       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4048     }
4049     if (i == width - 1) {
4050       A0 = s[i * 4 + 0] &gt;&gt; 6;
4051       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4052       U = s[i * 4 + 2] &gt;&gt; 6;
4053       V = s[i * 4 + 3] &gt;&gt; 6;
4054 
4055       GST_WRITE_UINT16_LE (da + i, A0);
4056       GST_WRITE_UINT16_LE (dy + i, Y0);
4057       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4058       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4059     }
4060   } else {
4061     for (i = 0; i &lt; width; i++) {
4062       A0 = s[i * 4 + 0] &gt;&gt; 6;
4063       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4064       GST_WRITE_UINT16_LE (da + i, A0);
4065       GST_WRITE_UINT16_LE (dy + i, Y0);
4066     }
4067   }
4068 }
4069 
4070 #define PACK_A420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10BE, 1, pack_A420_10BE
4071 static void
4072 unpack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4073     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4074     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4075 {
4076   int i;
4077   gint uv = GET_UV_420 (y, flags);
4078   const guint16 *restrict sa = GET_A_LINE (y);
4079   const guint16 *restrict sy = GET_Y_LINE (y);
4080   const guint16 *restrict su = GET_U_LINE (uv);
4081   const guint16 *restrict sv = GET_V_LINE (uv);
4082   guint16 *restrict d = dest, A, Y, U, V;
4083 
4084   sa += x;
4085   sy += x;
4086   su += x &gt;&gt; 1;
4087   sv += x &gt;&gt; 1;
4088 
4089   for (i = 0; i &lt; width; i++) {
4090     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
4091     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
4092     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
4093     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
4094 
4095     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4096       A |= (A &gt;&gt; 10);
4097       Y |= (Y &gt;&gt; 10);
4098       U |= (U &gt;&gt; 10);
4099       V |= (V &gt;&gt; 10);
4100     }
4101 
4102     d[i * 4 + 0] = A;
4103     d[i * 4 + 1] = Y;
4104     d[i * 4 + 2] = U;
4105     d[i * 4 + 3] = V;
4106 
4107     if (x &amp; 1) {
4108       x = 0;
4109       su++;
4110       sv++;
4111     }
4112   }
4113 }
4114 
4115 static void
4116 pack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4117     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4118     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4119     gint y, gint width)
4120 {
4121   int i;
4122   gint uv = GET_UV_420 (y, flags);
4123   guint16 *restrict da = GET_A_LINE (y);
4124   guint16 *restrict dy = GET_Y_LINE (y);
4125   guint16 *restrict du = GET_U_LINE (uv);
4126   guint16 *restrict dv = GET_V_LINE (uv);
4127   guint16 A0, Y0, A1, Y1, U, V;
4128   const guint16 *restrict s = src;
4129 
4130   if (IS_CHROMA_LINE_420 (y, flags)) {
4131     for (i = 0; i &lt; width - 1; i += 2) {
4132       A0 = s[i * 4 + 0] &gt;&gt; 6;
4133       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4134       A1 = s[i * 4 + 4] &gt;&gt; 6;
4135       Y1 = s[i * 4 + 5] &gt;&gt; 6;
4136       U = s[i * 4 + 2] &gt;&gt; 6;
4137       V = s[i * 4 + 3] &gt;&gt; 6;
4138 
4139       GST_WRITE_UINT16_BE (da + i + 0, A0);
4140       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
4141       GST_WRITE_UINT16_BE (da + i + 1, A1);
4142       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
4143       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4144       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4145     }
4146     if (i == width - 1) {
4147       A0 = s[i * 4 + 0] &gt;&gt; 6;
4148       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4149       U = s[i * 4 + 2] &gt;&gt; 6;
4150       V = s[i * 4 + 3] &gt;&gt; 6;
4151 
4152       GST_WRITE_UINT16_BE (da + i, A0);
4153       GST_WRITE_UINT16_BE (dy + i, Y0);
4154       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4155       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4156     }
4157   } else {
4158     for (i = 0; i &lt; width; i++) {
4159       A0 = s[i * 4 + 0] &gt;&gt; 6;
4160       Y0 = s[i * 4 + 1] &gt;&gt; 6;
4161       GST_WRITE_UINT16_BE (da + i, A0);
4162       GST_WRITE_UINT16_BE (dy + i, Y0);
4163     }
4164   }
4165 }
4166 
4167 #define PACK_A422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10LE, 1, pack_A422_10LE
4168 static void
4169 unpack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4170     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4171     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4172 {
4173   int i;
4174   const guint16 *restrict sa = GET_A_LINE (y);
4175   const guint16 *restrict sy = GET_Y_LINE (y);
4176   const guint16 *restrict su = GET_U_LINE (y);
4177   const guint16 *restrict sv = GET_V_LINE (y);
4178   guint16 *restrict d = dest, A, Y, U, V;
4179 
4180   sa += x;
4181   sy += x;
4182   su += x &gt;&gt; 1;
4183   sv += x &gt;&gt; 1;
4184 
4185   for (i = 0; i &lt; width; i++) {
4186     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
4187     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
4188     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
4189     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
4190 
4191     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4192       A |= (A &gt;&gt; 10);
4193       Y |= (Y &gt;&gt; 10);
4194       U |= (U &gt;&gt; 10);
4195       V |= (V &gt;&gt; 10);
4196     }
4197 
4198     d[i * 4 + 0] = A;
4199     d[i * 4 + 1] = Y;
4200     d[i * 4 + 2] = U;
4201     d[i * 4 + 3] = V;
4202 
4203     if (x &amp; 1) {
4204       x = 0;
4205       su++;
4206       sv++;
4207     }
4208   }
4209 }
4210 
4211 static void
4212 pack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4213     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4214     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4215     gint y, gint width)
4216 {
4217   int i;
4218   guint16 *restrict da = GET_A_LINE (y);
4219   guint16 *restrict dy = GET_Y_LINE (y);
4220   guint16 *restrict du = GET_U_LINE (y);
4221   guint16 *restrict dv = GET_V_LINE (y);
4222   guint16 A0, Y0, A1, Y1, U, V;
4223   const guint16 *restrict s = src;
4224 
4225   for (i = 0; i &lt; width - 1; i += 2) {
4226     A0 = s[i * 4 + 0] &gt;&gt; 6;
4227     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4228     A1 = s[i * 4 + 4] &gt;&gt; 6;
4229     Y1 = s[i * 4 + 5] &gt;&gt; 6;
4230     U = s[i * 4 + 2] &gt;&gt; 6;
4231     V = s[i * 4 + 3] &gt;&gt; 6;
4232 
4233     GST_WRITE_UINT16_LE (da + i + 0, A0);
4234     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
4235     GST_WRITE_UINT16_LE (da + i + 1, A1);
4236     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
4237     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4238     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4239   }
4240   if (i == width - 1) {
4241     A0 = s[i * 4 + 0] &gt;&gt; 6;
4242     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4243     U = s[i * 4 + 2] &gt;&gt; 6;
4244     V = s[i * 4 + 3] &gt;&gt; 6;
4245 
4246     GST_WRITE_UINT16_LE (da + i, A0);
4247     GST_WRITE_UINT16_LE (dy + i, Y0);
4248     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4249     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4250   }
4251 }
4252 
4253 #define PACK_A422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10BE, 1, pack_A422_10BE
4254 static void
4255 unpack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4256     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4257     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4258 {
4259   int i;
4260   const guint16 *restrict sa = GET_A_LINE (y);
4261   const guint16 *restrict sy = GET_Y_LINE (y);
4262   const guint16 *restrict su = GET_U_LINE (y);
4263   const guint16 *restrict sv = GET_V_LINE (y);
4264   guint16 *restrict d = dest, A, Y, U, V;
4265 
4266   sa += x;
4267   sy += x;
4268   su += x &gt;&gt; 1;
4269   sv += x &gt;&gt; 1;
4270 
4271   for (i = 0; i &lt; width; i++) {
4272     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
4273     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
4274     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
4275     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
4276 
4277     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4278       A |= (A &gt;&gt; 10);
4279       Y |= (Y &gt;&gt; 10);
4280       U |= (U &gt;&gt; 10);
4281       V |= (V &gt;&gt; 10);
4282     }
4283 
4284     d[i * 4 + 0] = A;
4285     d[i * 4 + 1] = Y;
4286     d[i * 4 + 2] = U;
4287     d[i * 4 + 3] = V;
4288 
4289     if (x &amp; 1) {
4290       x = 0;
4291       su++;
4292       sv++;
4293     }
4294   }
4295 }
4296 
4297 static void
4298 pack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4299     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4300     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4301     gint y, gint width)
4302 {
4303   int i;
4304   guint16 *restrict da = GET_A_LINE (y);
4305   guint16 *restrict dy = GET_Y_LINE (y);
4306   guint16 *restrict du = GET_U_LINE (y);
4307   guint16 *restrict dv = GET_V_LINE (y);
4308   guint16 A0, Y0, A1, Y1, U, V;
4309   const guint16 *restrict s = src;
4310 
4311   for (i = 0; i &lt; width - 1; i += 2) {
4312     A0 = s[i * 4 + 0] &gt;&gt; 6;
4313     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4314     A1 = s[i * 4 + 4] &gt;&gt; 6;
4315     Y1 = s[i * 4 + 5] &gt;&gt; 6;
4316     U = s[i * 4 + 2] &gt;&gt; 6;
4317     V = s[i * 4 + 3] &gt;&gt; 6;
4318 
4319     GST_WRITE_UINT16_BE (da + i + 0, A0);
4320     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
4321     GST_WRITE_UINT16_BE (da + i + 1, A1);
4322     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
4323     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4324     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4325   }
4326   if (i == width - 1) {
4327     A0 = s[i * 4 + 0] &gt;&gt; 6;
4328     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4329     U = s[i * 4 + 2] &gt;&gt; 6;
4330     V = s[i * 4 + 3] &gt;&gt; 6;
4331 
4332     GST_WRITE_UINT16_BE (da + i, A0);
4333     GST_WRITE_UINT16_BE (dy + i, Y0);
4334     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4335     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4336   }
4337 }
4338 
4339 static void
4340 get_tile_NV12 (gint tile_width, gint ts, gint tx, gint ty,
4341     const gpointer data[GST_VIDEO_MAX_PLANES],
4342     const gint stride[GST_VIDEO_MAX_PLANES],
4343     gpointer tile_data[GST_VIDEO_MAX_PLANES],
4344     gint tile_stride[GST_VIDEO_MAX_PLANES])
4345 {
4346   gsize offset;
4347 
4348   /* index of Y tile */
4349   offset = gst_video_tile_get_index (GST_VIDEO_TILE_MODE_ZFLIPZ_2X2,
4350       tx, ty, GST_VIDEO_TILE_X_TILES (stride[0]),
4351       GST_VIDEO_TILE_Y_TILES (stride[0]));
4352   offset &lt;&lt;= ts;
4353   tile_data[0] = ((guint8 *) data[0]) + offset;
4354 
4355   /* index of UV tile */
4356   offset = gst_video_tile_get_index (GST_VIDEO_TILE_MODE_ZFLIPZ_2X2,
4357       tx, ty &gt;&gt; 1, GST_VIDEO_TILE_X_TILES (stride[1]),
4358       GST_VIDEO_TILE_Y_TILES (stride[1]));
4359   offset &lt;&lt;= ts;
4360   /* On odd rows we return the second part of the UV tile */
4361   offset |= (ty &amp; 1) &lt;&lt; (ts - 1);
4362   tile_data[1] = ((guint8 *) data[1]) + offset;
4363 
4364   tile_stride[0] = tile_stride[1] = tile_width;
4365 }
4366 
4367 #define PACK_NV12_64Z32 GST_VIDEO_FORMAT_AYUV, unpack_NV12_64Z32, 1, pack_NV12_64Z32
4368 static void
4369 unpack_NV12_64Z32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4370     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4371     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4372 {
4373   const GstVideoFormatInfo *unpack_info, *finfo;
4374   guint8 *line = dest;
4375   gint ws, hs, ts, tile_width;
4376   gint ntx, tx, ty;
4377   gint unpack_pstride;
4378 
4379   ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
4380   hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
4381   ts = ws + hs;
4382 
4383   tile_width = 1 &lt;&lt; ws;
4384 
4385   /* we reuse these unpack functions */
4386   finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
4387 
4388   /* get pstride of unpacked format */
4389   unpack_info = gst_video_format_get_info (info-&gt;unpack_format);
4390   unpack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (unpack_info, 0);
4391 
4392   /* first x tile to convert */
4393   tx = x &gt;&gt; ws;
4394   /* Last tile to convert */
4395   ntx = ((x + width - 1) &gt;&gt; ws) + 1;
4396   /* The row we are going to convert */
4397   ty = y &gt;&gt; hs;
4398 
4399   /* y position in a tile */
4400   y = y &amp; ((1 &lt;&lt; hs) - 1);
4401   /* x position in a tile */
4402   x = x &amp; (tile_width - 1);
4403 
4404   for (; tx &lt; ntx; tx++) {
4405     gpointer tdata[GST_VIDEO_MAX_PLANES];
4406     gint tstride[GST_VIDEO_MAX_PLANES];
4407     gint unpack_width;
4408 
4409     get_tile_NV12 (tile_width, ts, tx, ty, data, stride, tdata, tstride);
4410 
4411     /* the number of bytes left to unpack */
4412     unpack_width = MIN (width - x, tile_width - x);
4413 
4414     finfo-&gt;unpack_func (finfo, flags, line, tdata, tstride, x, y, unpack_width);
4415 
4416     x = 0;
4417     width -= unpack_width;
4418     line += unpack_width * unpack_pstride;
4419   }
4420 }
4421 
4422 static void
4423 pack_NV12_64Z32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4424     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4425     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4426     gint y, gint width)
4427 {
4428   const GstVideoFormatInfo *pack_info, *finfo;
4429   guint8 *line = src;
4430   gint ws, hs, ts, tile_width;
4431   gint ntx, tx, ty;
4432   gint pack_pstride;
4433 
4434   ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
4435   hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
4436   ts = ws + hs;
4437 
4438   tile_width = 1 &lt;&lt; ws;
4439 
4440   /* we reuse these pack functions */
4441   finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
4442 
4443   /* get pstride of packed format */
4444   pack_info = gst_video_format_get_info (info-&gt;unpack_format);
4445   pack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (pack_info, 0);
4446 
4447   /* Last tile to convert */
4448   ntx = ((width - 1) &gt;&gt; ws) + 1;
4449   /* The row we are going to convert */
4450   ty = y &gt;&gt; hs;
4451 
4452   /* y position in a tile */
4453   y = y &amp; ((1 &lt;&lt; hs) - 1);
4454 
4455   for (tx = 0; tx &lt; ntx; tx++) {
4456     gpointer tdata[GST_VIDEO_MAX_PLANES];
4457     gint tstride[GST_VIDEO_MAX_PLANES];
4458     gint pack_width;
4459 
4460     get_tile_NV12 (tile_width, ts, tx, ty, data, stride, tdata, tstride);
4461 
4462     /* the number of bytes left to pack */
4463     pack_width = MIN (width, tile_width);
4464 
4465     finfo-&gt;pack_func (finfo, flags, line, sstride, tdata, tstride,
4466         chroma_site, y, pack_width);
4467 
4468     width -= pack_width;
4469     line += pack_width * pack_pstride;
4470   }
4471 }
4472 
4473 #define PACK_P010_10BE GST_VIDEO_FORMAT_AYUV64, unpack_P010_10BE, 1, pack_P010_10BE
4474 static void
4475 unpack_P010_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4476     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4477     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4478 {
4479   int i;
4480   gint uv = GET_UV_420 (y, flags);
4481   const guint16 *restrict sy = GET_PLANE_LINE (0, y);
4482   const guint16 *restrict suv = GET_PLANE_LINE (1, uv);
4483   guint16 *restrict d = dest, Y0, Y1, U, V;
4484 
4485   sy += x;
4486   suv += (x &amp; ~1);
4487 
4488   if (x &amp; 1) {
4489     Y0 = GST_READ_UINT16_BE (sy);
4490     U = GST_READ_UINT16_BE (suv);
4491     V = GST_READ_UINT16_BE (suv + 1);
4492 
4493     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4494       Y0 |= (Y0 &gt;&gt; 10);
4495       U |= (U &gt;&gt; 10);
4496       V |= (V &gt;&gt; 10);
4497     }
4498 
4499     d[0] = 0xffff;
4500     d[1] = Y0;
4501     d[2] = U;
4502     d[3] = V;
4503     width--;
4504     d += 4;
4505     sy += 1;
4506     suv += 2;
4507   }
4508 
4509   for (i = 0; i &lt; width / 2; i++) {
4510     Y0 = GST_READ_UINT16_BE (sy + 2 * i);
4511     Y1 = GST_READ_UINT16_BE (sy + 2 * i + 1);
4512     U = GST_READ_UINT16_BE (suv + 2 * i);
4513     V = GST_READ_UINT16_BE (suv + 2 * i + 1);
4514 
4515     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4516       Y0 |= (Y0 &gt;&gt; 10);
4517       Y1 |= (Y1 &gt;&gt; 10);
4518       U |= (U &gt;&gt; 10);
4519       V |= (V &gt;&gt; 10);
4520     }
4521 
4522     d[i * 8 + 0] = 0xffff;
4523     d[i * 8 + 1] = Y0;
4524     d[i * 8 + 2] = U;
4525     d[i * 8 + 3] = V;
4526     d[i * 8 + 4] = 0xffff;
4527     d[i * 8 + 5] = Y1;
4528     d[i * 8 + 6] = U;
4529     d[i * 8 + 7] = V;
4530   }
4531 
4532   if (width &amp; 1) {
4533     gint i = width - 1;
4534 
4535     Y0 = GST_READ_UINT16_BE (sy + i);
4536     U = GST_READ_UINT16_BE (suv + i);
4537     V = GST_READ_UINT16_BE (suv + i + 1);
4538 
4539     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4540       Y0 |= (Y0 &gt;&gt; 10);
4541       U |= (U &gt;&gt; 10);
4542       V |= (V &gt;&gt; 10);
4543     }
4544 
4545     d[i * 4 + 0] = 0xffff;
4546     d[i * 4 + 1] = Y0;
4547     d[i * 4 + 2] = U;
4548     d[i * 4 + 3] = V;
4549   }
4550 }
4551 
4552 static void
4553 pack_P010_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4554     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4555     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4556     gint y, gint width)
4557 {
4558   int i;
4559   gint uv = GET_UV_420 (y, flags);
4560   guint16 *restrict dy = GET_PLANE_LINE (0, y);
4561   guint16 *restrict duv = GET_PLANE_LINE (1, uv);
4562   guint16 Y0, Y1, U, V;
4563   const guint16 *restrict s = src;
4564 
4565   if (IS_CHROMA_LINE_420 (y, flags)) {
4566     for (i = 0; i &lt; width / 2; i++) {
4567       Y0 = s[i * 8 + 1] &amp; 0xffc0;
4568       Y1 = s[i * 8 + 5] &amp; 0xffc0;
4569       U = s[i * 8 + 2] &amp; 0xffc0;
4570       V = s[i * 8 + 3] &amp; 0xffc0;
4571 
4572       GST_WRITE_UINT16_BE (dy + i * 2 + 0, Y0);
4573       GST_WRITE_UINT16_BE (dy + i * 2 + 1, Y1);
4574       GST_WRITE_UINT16_BE (duv + i * 2 + 0, U);
4575       GST_WRITE_UINT16_BE (duv + i * 2 + 1, V);
4576     }
4577     if (width &amp; 1) {
4578       gint i = width - 1;
4579 
4580       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4581       U = s[i * 4 + 2] &amp; 0xffc0;
4582       V = s[i * 4 + 3] &amp; 0xffc0;
4583 
4584       GST_WRITE_UINT16_BE (dy + i, Y0);
4585       GST_WRITE_UINT16_BE (duv + i + 0, U);
4586       GST_WRITE_UINT16_BE (duv + i + 1, V);
4587     }
4588   } else {
4589     for (i = 0; i &lt; width; i++) {
4590       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4591       GST_WRITE_UINT16_BE (dy + i, Y0);
4592     }
4593   }
4594 }
4595 
4596 #define PACK_P010_10LE GST_VIDEO_FORMAT_AYUV64, unpack_P010_10LE, 1, pack_P010_10LE
4597 static void
4598 unpack_P010_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4599     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4600     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4601 {
4602   int i;
4603   gint uv = GET_UV_420 (y, flags);
4604   const guint16 *restrict sy = GET_PLANE_LINE (0, y);
4605   const guint16 *restrict suv = GET_PLANE_LINE (1, uv);
4606   guint16 *restrict d = dest, Y0, Y1, U, V;
4607 
4608   sy += x;
4609   suv += (x &amp; ~1);
4610 
4611   if (x &amp; 1) {
4612     Y0 = GST_READ_UINT16_LE (sy);
4613     U = GST_READ_UINT16_LE (suv);
4614     V = GST_READ_UINT16_LE (suv + 1);
4615 
4616     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4617       Y0 |= (Y0 &gt;&gt; 10);
4618       U |= (U &gt;&gt; 10);
4619       V |= (V &gt;&gt; 10);
4620     }
4621 
4622     d[0] = 0xffff;
4623     d[1] = Y0;
4624     d[2] = U;
4625     d[3] = V;
4626     width--;
4627     d += 4;
4628     sy += 1;
4629     suv += 2;
4630   }
4631 
4632   for (i = 0; i &lt; width / 2; i++) {
4633     Y0 = GST_READ_UINT16_LE (sy + 2 * i);
4634     Y1 = GST_READ_UINT16_LE (sy + 2 * i + 1);
4635     U = GST_READ_UINT16_LE (suv + 2 * i);
4636     V = GST_READ_UINT16_LE (suv + 2 * i + 1);
4637 
4638     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4639       Y0 |= (Y0 &gt;&gt; 10);
4640       Y1 |= (Y1 &gt;&gt; 10);
4641       U |= (U &gt;&gt; 10);
4642       V |= (V &gt;&gt; 10);
4643     }
4644 
4645     d[i * 8 + 0] = 0xffff;
4646     d[i * 8 + 1] = Y0;
4647     d[i * 8 + 2] = U;
4648     d[i * 8 + 3] = V;
4649     d[i * 8 + 4] = 0xffff;
4650     d[i * 8 + 5] = Y1;
4651     d[i * 8 + 6] = U;
4652     d[i * 8 + 7] = V;
4653   }
4654 
4655   if (width &amp; 1) {
4656     gint i = width - 1;
4657 
4658     Y0 = GST_READ_UINT16_LE (sy + i);
4659     U = GST_READ_UINT16_LE (suv + i);
4660     V = GST_READ_UINT16_LE (suv + i + 1);
4661 
4662     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4663       Y0 |= (Y0 &gt;&gt; 10);
4664       U |= (U &gt;&gt; 10);
4665       V |= (V &gt;&gt; 10);
4666     }
4667 
4668     d[i * 4 + 0] = 0xffff;
4669     d[i * 4 + 1] = Y0;
4670     d[i * 4 + 2] = U;
4671     d[i * 4 + 3] = V;
4672   }
4673 }
4674 
4675 static void
4676 pack_P010_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4677     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4678     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4679     gint y, gint width)
4680 {
4681   int i;
4682   gint uv = GET_UV_420 (y, flags);
4683   guint16 *restrict dy = GET_PLANE_LINE (0, y);
4684   guint16 *restrict duv = GET_PLANE_LINE (1, uv);
4685   guint16 Y0, Y1, U, V;
4686   const guint16 *restrict s = src;
4687 
4688   if (IS_CHROMA_LINE_420 (y, flags)) {
4689     for (i = 0; i &lt; width / 2; i++) {
4690       Y0 = s[i * 8 + 1] &amp; 0xffc0;
4691       Y1 = s[i * 8 + 5] &amp; 0xffc0;
4692       U = s[i * 8 + 2] &amp; 0xffc0;
4693       V = s[i * 8 + 3] &amp; 0xffc0;
4694 
4695       GST_WRITE_UINT16_LE (dy + i * 2 + 0, Y0);
4696       GST_WRITE_UINT16_LE (dy + i * 2 + 1, Y1);
4697       GST_WRITE_UINT16_LE (duv + i * 2 + 0, U);
4698       GST_WRITE_UINT16_LE (duv + i * 2 + 1, V);
4699     }
4700     if (width &amp; 1) {
4701       gint i = width - 1;
4702 
4703       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4704       U = s[i * 4 + 2] &amp; 0xffc0;
4705       V = s[i * 4 + 3] &amp; 0xffc0;
4706 
4707       GST_WRITE_UINT16_LE (dy + i, Y0);
4708       GST_WRITE_UINT16_LE (duv + i + 0, U);
4709       GST_WRITE_UINT16_LE (duv + i + 1, V);
4710     }
4711   } else {
4712     for (i = 0; i &lt; width; i++) {
4713       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4714       GST_WRITE_UINT16_LE (dy + i, Y0);
4715     }
4716   }
4717 }
4718 
4719 #define PACK_GRAY10_LE32 GST_VIDEO_FORMAT_AYUV64, unpack_GRAY10_LE32, 1, pack_GRAY10_LE32
4720 static void
4721 unpack_GRAY10_LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4722     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4723     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4724 {
4725   gint i;
4726   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4727   guint16 *restrict d = dest;
4728   gint num_words = (width + 2) / 3;
4729 
4730   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4731    * padding. There is only 1 pattern.
4732    * -&gt; padding | Y1 | Y2 | Y3
4733    */
4734 
4735   for (i = 0; i &lt; num_words; i++) {
4736     gint num_comps = MIN (3, width - i * 3);
4737     guint pix = i * 3;
4738     gsize doff = pix * 4;
4739     gint c;
4740     guint32 Y;
4741 
4742     Y = GST_READ_UINT32_LE (sy + i);
4743 
4744     for (c = 0; c &lt; num_comps; c++) {
4745       guint16 Yn;
4746 
4747       /* For Y, we simply read 10 bit and shift it out */
4748       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4749       Y &gt;&gt;= 10;
4750 
4751       if (G_UNLIKELY (pix + c &lt; x))
4752         continue;
4753 
4754       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE))
4755         Yn |= Yn &gt;&gt; 10;
4756 
4757       d[doff + 0] = 0xffff;
4758       d[doff + 1] = Yn;
4759       d[doff + 2] = 0x8000;
4760       d[doff + 3] = 0x8000;
4761 
4762       doff += 4;
4763     }
4764   }
4765 }
4766 
4767 static void
4768 pack_GRAY10_LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4769     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4770     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4771     gint y, gint width)
4772 {
4773   gint i;
4774   guint32 *restrict dy = GET_PLANE_LINE (0, y);
4775   const guint16 *restrict s = src;
4776   gint num_words = (width + 2) / 3;
4777 
4778   for (i = 0; i &lt; num_words; i++) {
4779     gint num_comps = MIN (3, width - i * 3);
4780     guint pix = i * 3;
4781     gsize soff = pix * 4;
4782     gint c;
4783     guint32 Y = 0;
4784 
4785     for (c = 0; c &lt; num_comps; c++) {
4786       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
4787       soff += 4;
4788     }
4789 
4790     GST_WRITE_UINT32_LE (dy + i, Y);
4791   }
4792 }
4793 
4794 #define PACK_NV12_10LE32 GST_VIDEO_FORMAT_AYUV64, unpack_NV12_10LE32, 1, pack_NV12_10LE32
4795 static void
4796 unpack_NV12_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4797     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4798     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4799 {
4800   gint i;
4801   gint uv = GET_UV_420 (y, flags);
4802   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4803   const guint32 *restrict suv = GET_PLANE_LINE (1, uv);
4804   guint16 *restrict d = dest;
4805   gint num_words = (width + 2) / 3;
4806   guint32 UV = 0;
4807   guint16 Un = 0, Vn = 0;
4808 
4809   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4810    * padding. There is only 1 pattern.
4811    * -&gt; padding | Y1 | Y2 | Y3
4812    *
4813    * UV is packed the same way, though we end up with 2 patterns:
4814    * -&gt; U | V | U | padding
4815    * -&gt; V | U | V | padding
4816    */
4817 
4818   /* FIXME unroll the 6 states ? */
4819 
4820   for (i = 0; i &lt; num_words; i++) {
4821     gint num_comps = MIN (3, width - i * 3);
4822     guint pix = i * 3;
4823     gsize doff = pix * 4;
4824     gint c;
4825     guint32 Y;
4826 
4827     Y = GST_READ_UINT32_LE (sy + i);
4828 
4829     for (c = 0; c &lt; num_comps; c++) {
4830       guint16 Yn;
4831 
4832       /* For Y, we simply read 10 bit and shift it out */
4833       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4834       Y &gt;&gt;= 10;
4835 
4836       /* Unpacking UV has been reduced to a cycle of 6 states. The following
4837        * code is a reduce version of:
4838        * 0: - Read first UV word (UVU)
4839        *      Unpack U and V
4840        * 1: - Resued U/V from 1 (sub-sampling)
4841        * 2: - Unpack remaining U value
4842        *    - Read following UV word (VUV)
4843        *    - Unpack V value
4844        * 3: - Reuse U/V from 2 (sub-sampling)
4845        * 4: - Unpack remaining U
4846        *    - Unpack remaining V
4847        * 5: - Reuse UV/V from 4 (sub-sampling)
4848        */
4849       switch ((pix + c) % 6) {
4850         case 0:
4851           UV = GST_READ_UINT32_LE (suv + i);
4852           /* fallthrough */
4853         case 4:
4854           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4855           UV &gt;&gt;= 10;
4856           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4857           UV &gt;&gt;= 10;
4858           break;
4859         case 2:
4860           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4861           UV = GST_READ_UINT32_LE (suv + i + 1);
4862           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4863           UV &gt;&gt;= 10;
4864           break;
4865         default:
4866           /* keep value */
4867           break;
4868       }
4869 
4870       if (G_UNLIKELY (pix + c &lt; x))
4871         continue;
4872 
4873       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4874         Yn |= Yn &gt;&gt; 10;
4875         Un |= Un &gt;&gt; 10;
4876         Vn |= Vn &gt;&gt; 10;
4877       }
4878 
4879       d[doff + 0] = 0xffff;
4880       d[doff + 1] = Yn;
4881       d[doff + 2] = Un;
4882       d[doff + 3] = Vn;
4883 
4884       doff += 4;
4885     }
4886   }
4887 }
4888 
4889 static void
4890 pack_NV12_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4891     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4892     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4893     gint y, gint width)
4894 {
4895   gint i;
4896   gint uv = GET_UV_420 (y, flags);
4897   guint32 *restrict dy = GET_PLANE_LINE (0, y);
4898   guint32 *restrict duv = GET_PLANE_LINE (1, uv);
4899   const guint16 *restrict s = src;
4900   gint num_words = (width + 2) / 3;
4901   guint32 UV = 0;
4902 
4903   /* FIXME unroll the 6 states ? */
4904 
4905   for (i = 0; i &lt; num_words; i++) {
4906     gint num_comps = MIN (3, width - i * 3);
4907     guint pix = i * 3;
4908     gsize soff = pix * 4;
4909     gint c;
4910     guint32 Y = 0;
4911 
4912     for (c = 0; c &lt; num_comps; c++) {
4913       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
4914 
4915       if (IS_CHROMA_LINE_420 (y, flags)) {
4916         switch ((pix + c) % 6) {
4917           case 0:
4918             UV = s[soff + 2] &gt;&gt; 6;
4919             UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 10;
4920             break;
4921           case 2:
4922             UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 20;
4923             GST_WRITE_UINT32_LE (duv + i, UV);
4924             UV = s[soff + 3] &gt;&gt; 6;
4925             break;
4926           case 4:
4927             UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
4928             UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
4929             GST_WRITE_UINT32_LE (duv + i, UV);
4930             break;
4931           default:
4932             /* keep value */
4933             break;
4934         }
4935       }
4936 
4937       soff += 4;
4938     }
4939 
4940     GST_WRITE_UINT32_LE (dy + i, Y);
4941 
4942     if (IS_CHROMA_LINE_420 (y, flags) &amp;&amp; num_comps &lt; 3)
4943       GST_WRITE_UINT32_LE (duv + i, UV);
4944 
4945   }
4946 }
4947 
4948 #define PACK_NV16_10LE32 GST_VIDEO_FORMAT_AYUV64, unpack_NV16_10LE32, 1, pack_NV16_10LE32
4949 static void
4950 unpack_NV16_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4951     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4952     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4953 {
4954   gint i;
4955   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4956   const guint32 *restrict suv = GET_PLANE_LINE (1, y);
4957   guint16 *restrict d = dest;
4958   gint num_words = (width + 2) / 3;
4959   guint32 UV = 0;
4960   guint16 Un = 0, Vn = 0;
4961 
4962   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4963    * padding. There is only 1 pattern.
4964    * -&gt; padding | Y1 | Y2 | Y3
4965    *
4966    * UV is packed the same way, though we end up with 2 patterns:
4967    * -&gt; U | V | U | padding
4968    * -&gt; V | U | V | padding
4969    */
4970 
4971   /* FIXME unroll the 6 states ? */
4972 
4973   for (i = 0; i &lt; num_words; i++) {
4974     gint num_comps = MIN (3, width - i * 3);
4975     guint pix = i * 3;
4976     gsize doff = pix * 4;
4977     gint c;
4978     guint32 Y;
4979 
4980     Y = GST_READ_UINT32_LE (sy + i);
4981 
4982     for (c = 0; c &lt; num_comps; c++) {
4983       guint16 Yn;
4984 
4985       /* For Y, we simply read 10 bit and shift it out */
4986       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4987       Y &gt;&gt;= 10;
4988 
4989       /* Unpacking UV has been reduced to a cycle of 6 states. The following
4990        * code is a reduce version of:
4991        * 0: - Read first UV word (UVU)
4992        *      Unpack U and V
4993        * 1: - Resued U/V from 1 (sub-sampling)
4994        * 2: - Unpack remaining U value
4995        *    - Read following UV word (VUV)
4996        *    - Unpack V value
4997        * 3: - Reuse U/V from 2 (sub-sampling)
4998        * 4: - Unpack remaining U
4999        *    - Unpack remaining V
5000        * 5: - Reuse UV/V from 4 (sub-sampling)
5001        */
5002       switch ((pix + c) % 6) {
5003         case 0:
5004           UV = GST_READ_UINT32_LE (suv + i);
5005           /* fallthrough */
5006         case 4:
5007           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
5008           UV &gt;&gt;= 10;
5009           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
5010           UV &gt;&gt;= 10;
5011           break;
5012         case 2:
5013           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
5014           UV = GST_READ_UINT32_LE (suv + i + 1);
5015           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
5016           UV &gt;&gt;= 10;
5017           break;
5018         default:
5019           /* keep value */
5020           break;
5021       }
5022 
5023       if (G_UNLIKELY (pix + c &lt; x))
5024         continue;
5025 
5026       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
5027         Yn |= Yn &gt;&gt; 10;
5028         Un |= Un &gt;&gt; 10;
5029         Vn |= Vn &gt;&gt; 10;
5030       }
5031 
5032       d[doff + 0] = 0xffff;
5033       d[doff + 1] = Yn;
5034       d[doff + 2] = Un;
5035       d[doff + 3] = Vn;
5036 
5037       doff += 4;
5038     }
5039   }
5040 }
5041 
5042 static void
5043 pack_NV16_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
5044     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
5045     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
5046     gint y, gint width)
5047 {
5048   gint i;
5049   guint32 *restrict dy = GET_PLANE_LINE (0, y);
5050   guint32 *restrict duv = GET_PLANE_LINE (1, y);
5051   const guint16 *restrict s = src;
5052   gint num_words = (width + 2) / 3;
5053   guint32 UV = 0;
5054 
5055   /* FIXME unroll the 6 states ? */
5056 
5057   for (i = 0; i &lt; num_words; i++) {
5058     gint num_comps = MIN (3, width - i * 3);
5059     guint pix = i * 3;
5060     gsize soff = pix * 4;
5061     gint c;
5062     guint32 Y = 0;
5063 
5064     for (c = 0; c &lt; num_comps; c++) {
5065       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
5066 
5067       switch ((pix + c) % 6) {
5068         case 0:
5069           UV = s[soff + 2] &gt;&gt; 6;
5070           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 10;
5071           break;
5072         case 2:
5073           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 20;
5074           GST_WRITE_UINT32_LE (duv + i, UV);
5075           UV = s[soff + 3] &gt;&gt; 6;
5076           break;
5077         case 4:
5078           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
5079           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
5080           GST_WRITE_UINT32_LE (duv + i, UV);
5081           break;
5082         default:
5083           /* keep value */
5084           break;
5085       }
5086 
5087       soff += 4;
5088     }
5089 
5090     GST_WRITE_UINT32_LE (dy + i, Y);
5091 
5092     if (num_comps &lt; 3)
5093       GST_WRITE_UINT32_LE (duv + i, UV);
5094   }
5095 }
5096 
<a name="35" id="anc35"></a><span class="line-added">5097 #define PACK_NV12_10LE40 GST_VIDEO_FORMAT_AYUV64, unpack_NV12_10LE40, 1, pack_NV12_10LE40</span>
<span class="line-added">5098 static void</span>
<span class="line-added">5099 unpack_NV12_10LE40 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5100     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5101     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5102 {</span>
<span class="line-added">5103   gint i;</span>
<span class="line-added">5104   gint uv = GET_UV_420 (y, flags);</span>
<span class="line-added">5105   guint16 *restrict d = dest;</span>
<span class="line-added">5106   const guint8 *restrict sy = GET_PLANE_LINE (0, y);</span>
<span class="line-added">5107   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);</span>
<span class="line-added">5108   guint16 Y0 = 0, Y1 = 0, Yn = 0, Un = 0, Vn = 0;</span>
<span class="line-added">5109   guint32 UV = 0;</span>
<span class="line-added">5110 </span>
<span class="line-added">5111   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5112     gboolean update_c = FALSE;</span>
<span class="line-added">5113 </span>
<span class="line-added">5114     switch (i &amp; 3) {</span>
<span class="line-added">5115       case 0:</span>
<span class="line-added">5116         Y0 = GST_READ_UINT16_LE (sy);</span>
<span class="line-added">5117         Yn = Y0 &amp; 0x3ff;</span>
<span class="line-added">5118         sy += 2;</span>
<span class="line-added">5119 </span>
<span class="line-added">5120         UV = GST_READ_UINT32_LE (suv);</span>
<span class="line-added">5121         Un = UV &amp; 0x3ff;</span>
<span class="line-added">5122         Vn = (UV &gt;&gt; 10) &amp; 0x3ff;</span>
<span class="line-added">5123         suv += 4;</span>
<span class="line-added">5124 </span>
<span class="line-added">5125         Yn &lt;&lt;= 6;</span>
<span class="line-added">5126         Un &lt;&lt;= 6;</span>
<span class="line-added">5127         Vn &lt;&lt;= 6;</span>
<span class="line-added">5128         update_c = TRUE;</span>
<span class="line-added">5129         break;</span>
<span class="line-added">5130       case 1:</span>
<span class="line-added">5131         Y1 = GST_READ_UINT16_LE (sy);</span>
<span class="line-added">5132         Yn = (Y0 &gt;&gt; 10) | ((Y1 &amp; 0xf) &lt;&lt; 6);</span>
<span class="line-added">5133         sy += 2;</span>
<span class="line-added">5134 </span>
<span class="line-added">5135         Yn &lt;&lt;= 6;</span>
<span class="line-added">5136         break;</span>
<span class="line-added">5137       case 2:</span>
<span class="line-added">5138         Yn = (Y1 &gt;&gt; 4) &amp; 0x3ff;</span>
<span class="line-added">5139 </span>
<span class="line-added">5140         Un = (UV &gt;&gt; 20) &amp; 0x3ff;</span>
<span class="line-added">5141         Vn = (UV &gt;&gt; 30);</span>
<span class="line-added">5142         UV = GST_READ_UINT8 (suv);</span>
<span class="line-added">5143         Vn |= (UV &lt;&lt; 2);</span>
<span class="line-added">5144         suv++;</span>
<span class="line-added">5145 </span>
<span class="line-added">5146         Yn &lt;&lt;= 6;</span>
<span class="line-added">5147         Un &lt;&lt;= 6;</span>
<span class="line-added">5148         Vn &lt;&lt;= 6;</span>
<span class="line-added">5149         update_c = TRUE;</span>
<span class="line-added">5150         break;</span>
<span class="line-added">5151       case 3:</span>
<span class="line-added">5152         Y0 = GST_READ_UINT8 (sy);</span>
<span class="line-added">5153         Yn = (Y1 &gt;&gt; 14) | (Y0 &lt;&lt; 2);</span>
<span class="line-added">5154         sy++;</span>
<span class="line-added">5155 </span>
<span class="line-added">5156         Yn &lt;&lt;= 6;</span>
<span class="line-added">5157         break;</span>
<span class="line-added">5158     }</span>
<span class="line-added">5159 </span>
<span class="line-added">5160     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added">5161       Yn |= Yn &gt;&gt; 10;</span>
<span class="line-added">5162       if (update_c) {</span>
<span class="line-added">5163         Un |= Un &gt;&gt; 10;</span>
<span class="line-added">5164         Vn |= Vn &gt;&gt; 10;</span>
<span class="line-added">5165       }</span>
<span class="line-added">5166     }</span>
<span class="line-added">5167 </span>
<span class="line-added">5168     d[i * 4 + 0] = 0xffff;</span>
<span class="line-added">5169     d[i * 4 + 1] = Yn;</span>
<span class="line-added">5170     d[i * 4 + 2] = Un;</span>
<span class="line-added">5171     d[i * 4 + 3] = Vn;</span>
<span class="line-added">5172   }</span>
<span class="line-added">5173 }</span>
<span class="line-added">5174 </span>
<span class="line-added">5175 static void</span>
<span class="line-added">5176 pack_NV12_10LE40 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5177     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5178     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5179     gint y, gint width)</span>
<span class="line-added">5180 {</span>
<span class="line-added">5181   gint i;</span>
<span class="line-added">5182   gint uv = GET_UV_420 (y, flags);</span>
<span class="line-added">5183   guint8 *restrict dy = GET_PLANE_LINE (0, y);</span>
<span class="line-added">5184   guint8 *restrict duv = GET_PLANE_LINE (1, uv);</span>
<span class="line-added">5185   guint16 Y0 = 0, Y1 = 0, Y2 = 0, Y3 = 0, U0, V0 = 0, U1 = 0, V1 = 0;</span>
<span class="line-added">5186   const guint16 *restrict s = src;</span>
<span class="line-added">5187 </span>
<span class="line-added">5188   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5189     switch (i &amp; 3) {</span>
<span class="line-added">5190       case 0:</span>
<span class="line-added">5191         Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5192         GST_WRITE_UINT8 (dy, Y0 &amp; 0xff);</span>
<span class="line-added">5193         dy++;</span>
<span class="line-added">5194 </span>
<span class="line-added">5195         if (IS_CHROMA_LINE_420 (y, flags)) {</span>
<span class="line-added">5196           U0 = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-added">5197           V0 = s[i * 4 + 3] &gt;&gt; 6;</span>
<span class="line-added">5198 </span>
<span class="line-added">5199           GST_WRITE_UINT8 (duv, U0 &amp; 0xff);</span>
<span class="line-added">5200           duv++;</span>
<span class="line-added">5201 </span>
<span class="line-added">5202           GST_WRITE_UINT8 (duv, (U0 &gt;&gt; 8) | ((V0 &amp; 0x3f) &lt;&lt; 2));</span>
<span class="line-added">5203           duv++;</span>
<span class="line-added">5204         }</span>
<span class="line-added">5205         break;</span>
<span class="line-added">5206       case 1:</span>
<span class="line-added">5207         Y1 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5208         GST_WRITE_UINT8 (dy, (Y0 &gt;&gt; 8) | ((Y1 &amp; 0x3f) &lt;&lt; 2));</span>
<span class="line-added">5209         dy++;</span>
<span class="line-added">5210         break;</span>
<span class="line-added">5211       case 2:</span>
<span class="line-added">5212         Y2 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5213         GST_WRITE_UINT8 (dy, (Y1 &gt;&gt; 6) | ((Y2 &amp; 0xf) &lt;&lt; 4));</span>
<span class="line-added">5214         dy++;</span>
<span class="line-added">5215 </span>
<span class="line-added">5216         if (IS_CHROMA_LINE_420 (y, flags)) {</span>
<span class="line-added">5217           U1 = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-added">5218           V1 = s[i * 4 + 3] &gt;&gt; 6;</span>
<span class="line-added">5219 </span>
<span class="line-added">5220           GST_WRITE_UINT8 (duv, (V0 &gt;&gt; 6) | ((U1 &amp; 0xf) &lt;&lt; 4));</span>
<span class="line-added">5221           duv++;</span>
<span class="line-added">5222 </span>
<span class="line-added">5223           GST_WRITE_UINT8 (duv, (U1 &gt;&gt; 4) | ((V1 &amp; 0x3) &lt;&lt; 6));</span>
<span class="line-added">5224           duv++;</span>
<span class="line-added">5225 </span>
<span class="line-added">5226           GST_WRITE_UINT8 (duv, V1 &gt;&gt; 2);</span>
<span class="line-added">5227           duv++;</span>
<span class="line-added">5228         }</span>
<span class="line-added">5229         break;</span>
<span class="line-added">5230       case 3:</span>
<span class="line-added">5231         Y3 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5232         GST_WRITE_UINT8 (dy, (Y2 &gt;&gt; 4) | ((Y3 &amp; 0x3) &lt;&lt; 6));</span>
<span class="line-added">5233         dy++;</span>
<span class="line-added">5234         GST_WRITE_UINT8 (dy, (Y3 &gt;&gt; 2));</span>
<span class="line-added">5235         dy++;</span>
<span class="line-added">5236         break;</span>
<span class="line-added">5237     }</span>
<span class="line-added">5238   }</span>
<span class="line-added">5239 </span>
<span class="line-added">5240   switch (width &amp; 3) {</span>
<span class="line-added">5241     case 0:</span>
<span class="line-added">5242       break;</span>
<span class="line-added">5243     case 1:</span>
<span class="line-added">5244       GST_WRITE_UINT8 (dy, Y0 &gt;&gt; 8);</span>
<span class="line-added">5245       if (IS_CHROMA_LINE_420 (y, flags))</span>
<span class="line-added">5246         GST_WRITE_UINT8 (duv, V0 &gt;&gt; 6);</span>
<span class="line-added">5247       break;</span>
<span class="line-added">5248     case 2:</span>
<span class="line-added">5249       GST_WRITE_UINT8 (dy, Y1 &gt;&gt; 6);</span>
<span class="line-added">5250       if (IS_CHROMA_LINE_420 (y, flags))</span>
<span class="line-added">5251         GST_WRITE_UINT8 (duv, V0 &gt;&gt; 6);</span>
<span class="line-added">5252       break;</span>
<span class="line-added">5253     case 3:</span>
<span class="line-added">5254       GST_WRITE_UINT8 (dy, Y2 &gt;&gt; 4);</span>
<span class="line-added">5255       break;</span>
<span class="line-added">5256   }</span>
<span class="line-added">5257 }</span>
<span class="line-added">5258 </span>
<span class="line-added">5259 #define PACK_VUYA GST_VIDEO_FORMAT_AYUV, unpack_VUYA, 1, pack_VUYA</span>
<span class="line-added">5260 static void</span>
<span class="line-added">5261 unpack_VUYA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5262     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5263     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5264 {</span>
<span class="line-added">5265   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added">5266   guint8 *restrict d = dest;</span>
<span class="line-added">5267 </span>
<span class="line-added">5268   s += x * 4;</span>
<span class="line-added">5269 </span>
<span class="line-added">5270   video_orc_unpack_VUYA (d, s, width);</span>
<span class="line-added">5271 }</span>
<span class="line-added">5272 </span>
<span class="line-added">5273 static void</span>
<span class="line-added">5274 pack_VUYA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5275     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5276     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5277     gint y, gint width)</span>
<span class="line-added">5278 {</span>
<span class="line-added">5279   const guint8 *restrict s = src;</span>
<span class="line-added">5280   guint8 *restrict d = GET_LINE (y);</span>
<span class="line-added">5281 </span>
<span class="line-added">5282   video_orc_pack_VUYA (d, s, width);</span>
<span class="line-added">5283 }</span>
<span class="line-added">5284 </span>
<span class="line-added">5285 #define PACK_BGR10A2_LE GST_VIDEO_FORMAT_ARGB64, unpack_bgr10a2_le, 1, pack_bgr10a2_le</span>
<span class="line-added">5286 static void</span>
<span class="line-added">5287 unpack_bgr10a2_le (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5288     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5289     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5290 {</span>
<span class="line-added">5291   int i;</span>
<span class="line-added">5292   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added">5293   guint16 *restrict d = dest;</span>
<span class="line-added">5294   guint32 ARGB;</span>
<span class="line-added">5295   guint16 A, R, G, B;</span>
<span class="line-added">5296 </span>
<span class="line-added">5297   s += x * 4;</span>
<span class="line-added">5298 </span>
<span class="line-added">5299   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5300     ARGB = GST_READ_UINT32_LE (s + 4 * i);</span>
<span class="line-added">5301 </span>
<span class="line-added">5302     B = ((ARGB &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5303     G = ((ARGB &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5304     R = ((ARGB &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5305     A = ((ARGB &gt;&gt; 30) &amp; 0x03) &lt;&lt; 14;</span>
<span class="line-added">5306 </span>
<span class="line-added">5307     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added">5308       B |= (B &gt;&gt; 10);</span>
<span class="line-added">5309       G |= (G &gt;&gt; 10);</span>
<span class="line-added">5310       R |= (R &gt;&gt; 10);</span>
<span class="line-added">5311       A |= (A &gt;&gt; 10);</span>
<span class="line-added">5312     }</span>
<span class="line-added">5313 </span>
<span class="line-added">5314     d[4 * i + 0] = A;</span>
<span class="line-added">5315     d[4 * i + 1] = R;</span>
<span class="line-added">5316     d[4 * i + 2] = G;</span>
<span class="line-added">5317     d[4 * i + 3] = B;</span>
<span class="line-added">5318   }</span>
<span class="line-added">5319 }</span>
<span class="line-added">5320 </span>
<span class="line-added">5321 static void</span>
<span class="line-added">5322 pack_bgr10a2_le (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5323     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5324     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5325     gint y, gint width)</span>
<span class="line-added">5326 {</span>
<span class="line-added">5327   int i;</span>
<span class="line-added">5328   guint32 *restrict d = GET_LINE (y);</span>
<span class="line-added">5329   const guint16 *restrict s = src;</span>
<span class="line-added">5330   guint32 ARGB;</span>
<span class="line-added">5331   guint16 A, R, G, B;</span>
<span class="line-added">5332 </span>
<span class="line-added">5333   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5334     A = s[4 * i] &amp; 0xc000;</span>
<span class="line-added">5335     R = s[4 * i + 1] &amp; 0xffc0;</span>
<span class="line-added">5336     G = s[4 * i + 2] &amp; 0xffc0;</span>
<span class="line-added">5337     B = s[4 * i + 3] &amp; 0xffc0;</span>
<span class="line-added">5338 </span>
<span class="line-added">5339     ARGB = (B &gt;&gt; 6) | (G &lt;&lt; 4) | (R &lt;&lt; 14) | (A &lt;&lt; 16);</span>
<span class="line-added">5340 </span>
<span class="line-added">5341     GST_WRITE_UINT32_LE (d + i, ARGB);</span>
<span class="line-added">5342   }</span>
<span class="line-added">5343 }</span>
5344 
5345 typedef struct
5346 {
5347   guint32 fourcc;
5348   GstVideoFormatInfo info;
5349 } VideoFormat;
5350 
5351 /* depths: bits, n_components, shift, depth */
5352 #define DPTH0            0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5353 #define DPTH8            8, 1, { 0, 0, 0, 0 }, { 8, 0, 0, 0 }
5354 #define DPTH8_32         8, 2, { 0, 0, 0, 0 }, { 8, 32, 0, 0 }
5355 #define DPTH888          8, 3, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
5356 #define DPTH8888         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 8 }
5357 #define DPTH8880         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
5358 #define DPTH10           10, 1, { 0, 0, 0, 0 }, { 10, 0, 0, 0 }
5359 #define DPTH10_10_10     10, 3, { 0, 0, 0, 0 }, { 10, 10, 10, 0 }
5360 #define DPTH10_10_10_10  10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 10 }
5361 #define DPTH10_10_10_HI  16, 3, { 6, 6, 6, 0 }, { 10, 10, 10, 0 }
<a name="36" id="anc36"></a><span class="line-added">5362 #define DPTH10_10_10_2   10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 2}</span>
5363 #define DPTH12_12_12     12, 3, { 0, 0, 0, 0 }, { 12, 12, 12, 0 }
5364 #define DPTH12_12_12_12  12, 4, { 0, 0, 0, 0 }, { 12, 12, 12, 12 }
5365 #define DPTH16           16, 1, { 0, 0, 0, 0 }, { 16, 0, 0, 0 }
5366 #define DPTH16_16_16     16, 3, { 0, 0, 0, 0 }, { 16, 16, 16, 0 }
5367 #define DPTH16_16_16_16  16, 4, { 0, 0, 0, 0 }, { 16, 16, 16, 16 }
5368 #define DPTH555          16, 3, { 10, 5, 0, 0 }, { 5, 5, 5, 0 }
5369 #define DPTH565          16, 3, { 11, 5, 0, 0 }, { 5, 6, 5, 0 }
5370 
5371 /* pixel strides */
5372 #define PSTR0             { 0, 0, 0, 0 }
5373 #define PSTR1             { 1, 0, 0, 0 }
5374 #define PSTR14            { 1, 4, 0, 0 }
5375 #define PSTR111           { 1, 1, 1, 0 }
5376 #define PSTR1111          { 1, 1, 1, 1 }
5377 #define PSTR122           { 1, 2, 2, 0 }
5378 #define PSTR2             { 2, 0, 0, 0 }
5379 #define PSTR222           { 2, 2, 2, 0 }
5380 #define PSTR2222          { 2, 2, 2, 2 }
5381 #define PSTR244           { 2, 4, 4, 0 }
5382 #define PSTR444           { 4, 4, 4, 0 }
5383 #define PSTR4444          { 4, 4, 4, 4 }
5384 #define PSTR333           { 3, 3, 3, 0 }
5385 #define PSTR488           { 4, 8, 8, 0 }
5386 #define PSTR8888          { 8, 8, 8, 8 }
5387 
5388 /* planes, in what plane do we find component N */
5389 #define PLANE_NA          0, { 0, 0, 0, 0 }
5390 #define PLANE0            1, { 0, 0, 0, 0 }
5391 #define PLANE01           2, { 0, 1, 0, 0 }
5392 #define PLANE011          2, { 0, 1, 1, 0 }
5393 #define PLANE012          3, { 0, 1, 2, 0 }
5394 #define PLANE0123         4, { 0, 1, 2, 3 }
5395 #define PLANE021          3, { 0, 2, 1, 0 }
5396 #define PLANE201          3, { 2, 0, 1, 0 }
5397 #define PLANE2013         4, { 2, 0, 1, 3 }
5398 
5399 /* offsets */
5400 #define OFFS0             { 0, 0, 0, 0 }
5401 #define OFFS013           { 0, 1, 3, 0 }
5402 #define OFFS102           { 1, 0, 2, 0 }
5403 #define OFFS1230          { 1, 2, 3, 0 }
5404 #define OFFS012           { 0, 1, 2, 0 }
5405 #define OFFS210           { 2, 1, 0, 0 }
5406 #define OFFS123           { 1, 2, 3, 0 }
5407 #define OFFS321           { 3, 2, 1, 0 }
5408 #define OFFS0123          { 0, 1, 2, 3 }
5409 #define OFFS2103          { 2, 1, 0, 3 }
5410 #define OFFS3210          { 3, 2, 1, 0 }
5411 #define OFFS031           { 0, 3, 1, 0 }
5412 #define OFFS204           { 2, 0, 4, 0 }
5413 #define OFFS001           { 0, 0, 1, 0 }
5414 #define OFFS010           { 0, 1, 0, 0 }
5415 #define OFFS104           { 1, 0, 4, 0 }
5416 #define OFFS2460          { 2, 4, 6, 0 }
5417 
5418 /* subsampling, w_sub, h_sub */
5419 #define SUB410            { 0, 2, 2, 0 }, { 0, 2, 2, 0 }
5420 #define SUB411            { 0, 2, 2, 0 }, { 0, 0, 0, 0 }
5421 #define SUB420            { 0, 1, 1, 0 }, { 0, 1, 1, 0 }
5422 #define SUB422            { 0, 1, 1, 0 }, { 0, 0, 0, 0 }
5423 #define SUB4              { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5424 #define SUB44             { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5425 #define SUB444            { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5426 #define SUB4444           { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5427 #define SUB4204           { 0, 1, 1, 0 }, { 0, 1, 1, 0 }
5428 #define SUB4224           { 0, 1, 1, 0 }, { 0, 0, 0, 0 }
5429 
5430 /* tile_mode, tile_width, tile_height */
5431 #define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5
5432 
5433 #define MAKE_YUV_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5434  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV, depth, pstride, plane, offs, sub, pack } }
5435 #define MAKE_YUV_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5436  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5437 #define MAKE_YUVA_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5438  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA, depth, pstride, plane, offs, sub, pack } }
5439 #define MAKE_YUVA_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5440  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5441 #define MAKE_YUVA_PACK_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5442  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK, depth, pstride, plane, offs, sub, pack } }
5443 #define MAKE_YUVA_LE_PACK_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5444  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5445 #define MAKE_YUV_C_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5446  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX, depth, pstride, plane, offs, sub, pack } }
5447 #define MAKE_YUV_C_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5448  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5449 #define MAKE_YUV_T_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack, tile) \
5450  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_TILED, depth, pstride, plane, offs, sub, pack, tile } }
5451 
5452 #define MAKE_RGB_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5453  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB, depth, pstride, plane, offs, sub, pack } }
5454 #define MAKE_RGB_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5455  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5456 #define MAKE_RGBA_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5457  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA, depth, pstride, plane, offs, sub, pack } }
5458 #define MAKE_RGBA_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5459  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5460 #define MAKE_RGBAP_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5461  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_PALETTE, depth, pstride, plane, offs, sub, pack } }
5462 #define MAKE_RGBA_PACK_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5463  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK, depth, pstride, plane, offs, sub, pack } }
5464 #define MAKE_RGBA_LE_PACK_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5465  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5466 
5467 #define MAKE_GRAY_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5468  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY, depth, pstride, plane, offs, sub, pack } }
5469 #define MAKE_GRAY_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5470  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5471 #define MAKE_GRAY_C_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5472  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5473 
5474 static const VideoFormat formats[] = {
5475   {0x00000000, {GST_VIDEO_FORMAT_UNKNOWN, &quot;UNKNOWN&quot;, &quot;unknown video&quot;, 0, DPTH0,
5476           PSTR0, PLANE_NA, OFFS0}},
5477   {0x00000000, {GST_VIDEO_FORMAT_ENCODED, &quot;ENCODED&quot;, &quot;encoded video&quot;,
5478           GST_VIDEO_FORMAT_FLAG_COMPLEX, DPTH0, PSTR0, PLANE_NA, OFFS0}},
5479 
5480   MAKE_YUV_FORMAT (I420, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;),
5481       DPTH888, PSTR111, PLANE012, OFFS0, SUB420, PACK_420),
5482   MAKE_YUV_FORMAT (YV12, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;),
5483       DPTH888, PSTR111, PLANE021, OFFS0, SUB420, PACK_420),
5484   MAKE_YUV_FORMAT (YUY2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;),
5485       DPTH888, PSTR244, PLANE0, OFFS013, SUB422, PACK_YUY2),
5486   MAKE_YUV_FORMAT (UYVY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;),
5487       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_UYVY),
5488   MAKE_YUVA_PACK_FORMAT (AYUV, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;,
5489           &#39;V&#39;), DPTH8888, PSTR4444, PLANE0, OFFS1230, SUB4444, PACK_AYUV),
5490   MAKE_RGB_FORMAT (RGBx, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS012,
5491       SUB444, PACK_RGBA),
5492   MAKE_RGB_FORMAT (BGRx, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS210,
5493       SUB444, PACK_BGRA),
5494   MAKE_RGB_FORMAT (xRGB, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS123,
5495       SUB444, PACK_ARGB),
5496   MAKE_RGB_FORMAT (xBGR, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS321,
5497       SUB444, PACK_ABGR),
5498   MAKE_RGBA_FORMAT (RGBA, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS0123,
5499       SUB4444, PACK_RGBA),
5500   MAKE_RGBA_FORMAT (BGRA, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS2103,
5501       SUB4444, PACK_BGRA),
5502   MAKE_RGBA_PACK_FORMAT (ARGB, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0,
5503       OFFS1230, SUB4444, PACK_ARGB),
5504   MAKE_RGBA_FORMAT (ABGR, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS3210,
5505       SUB4444, PACK_ABGR),
5506   MAKE_RGB_FORMAT (RGB, &quot;raw video&quot;, DPTH888, PSTR333, PLANE0, OFFS012, SUB444,
5507       PACK_RGB),
5508   MAKE_RGB_FORMAT (BGR, &quot;raw video&quot;, DPTH888, PSTR333, PLANE0, OFFS210, SUB444,
5509       PACK_BGR),
5510 
5511   MAKE_YUV_FORMAT (Y41B, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;),
5512       DPTH888, PSTR111, PLANE012, OFFS0, SUB411, PACK_Y41B),
5513   MAKE_YUV_FORMAT (Y42B, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;),
5514       DPTH888, PSTR111, PLANE012, OFFS0, SUB422, PACK_Y42B),
5515   MAKE_YUV_FORMAT (YVYU, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;),
5516       DPTH888, PSTR244, PLANE0, OFFS031, SUB422, PACK_YVYU),
5517   MAKE_YUV_FORMAT (Y444, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;),
5518       DPTH888, PSTR111, PLANE012, OFFS0, SUB444, PACK_Y444),
5519   MAKE_YUV_C_FORMAT (v210, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;),
5520       DPTH10_10_10, PSTR0, PLANE0, OFFS0, SUB422, PACK_v210),
5521   MAKE_YUV_FORMAT (v216, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;),
5522       DPTH16_16_16, PSTR488, PLANE0, OFFS204, SUB422, PACK_v216),
5523   MAKE_YUV_FORMAT (NV12, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;),
5524       DPTH888, PSTR122, PLANE011, OFFS001, SUB420, PACK_NV12),
5525   MAKE_YUV_FORMAT (NV21, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;),
5526       DPTH888, PSTR122, PLANE011, OFFS010, SUB420, PACK_NV21),
5527 
5528   MAKE_GRAY_FORMAT (GRAY8, &quot;raw video&quot;, DPTH8, PSTR1, PLANE0, OFFS0, SUB4,
5529       PACK_GRAY8),
5530   MAKE_GRAY_FORMAT (GRAY16_BE, &quot;raw video&quot;, DPTH16, PSTR2, PLANE0, OFFS0, SUB4,
5531       PACK_GRAY16_BE),
5532   MAKE_GRAY_LE_FORMAT (GRAY16_LE, &quot;raw video&quot;, DPTH16, PSTR2, PLANE0, OFFS0,
5533       SUB4, PACK_GRAY16_LE),
5534 
5535   MAKE_YUV_FORMAT (v308, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;),
5536       DPTH888, PSTR333, PLANE0, OFFS012, SUB444, PACK_v308),
5537 
5538 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5539   MAKE_RGB_LE_FORMAT (RGB16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0,
5540       SUB444, PACK_RGB16),
5541   MAKE_RGB_LE_FORMAT (BGR16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0,
5542       SUB444, PACK_BGR16),
5543   MAKE_RGB_LE_FORMAT (RGB15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0,
5544       SUB444, PACK_RGB15),
5545   MAKE_RGB_LE_FORMAT (BGR15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0,
5546       SUB444, PACK_BGR15),
5547 #else
5548   MAKE_RGB_FORMAT (RGB16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0, SUB444,
5549       PACK_RGB16),
5550   MAKE_RGB_FORMAT (BGR16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0, SUB444,
5551       PACK_BGR16),
5552   MAKE_RGB_FORMAT (RGB15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0, SUB444,
5553       PACK_RGB15),
5554   MAKE_RGB_FORMAT (BGR15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0, SUB444,
5555       PACK_BGR15),
5556 #endif
5557 
5558   MAKE_YUV_C_FORMAT (UYVP, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;),
5559       DPTH10_10_10, PSTR0, PLANE0, OFFS0, SUB422, PACK_UYVP),
5560   MAKE_YUVA_FORMAT (A420, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;),
5561       DPTH8888, PSTR1111, PLANE0123, OFFS0, SUB4204, PACK_A420),
5562   MAKE_RGBAP_FORMAT (RGB8P, &quot;raw video&quot;, DPTH8_32, PSTR14, PLANE01,
5563       OFFS0, SUB44, PACK_RGB8P),
5564   MAKE_YUV_FORMAT (YUV9, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;),
5565       DPTH888, PSTR111, PLANE012, OFFS0, SUB410, PACK_410),
5566   MAKE_YUV_FORMAT (YVU9, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;),
5567       DPTH888, PSTR111, PLANE021, OFFS0, SUB410, PACK_410),
5568   MAKE_YUV_FORMAT (IYU1, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;),
5569       DPTH888, PSTR0, PLANE0, OFFS104, SUB411, PACK_IYU1),
5570 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5571   MAKE_RGBA_LE_PACK_FORMAT (ARGB64, &quot;raw video&quot;, DPTH16_16_16_16, PSTR8888,
5572       PLANE0,
5573       OFFS2460, SUB444, PACK_ARGB64),
5574   MAKE_YUVA_LE_PACK_FORMAT (AYUV64, &quot;raw video&quot;, 0x00000000, DPTH16_16_16_16,
5575       PSTR8888, PLANE0, OFFS2460, SUB444, PACK_AYUV64),
5576 #else
5577   MAKE_RGBA_PACK_FORMAT (ARGB64, &quot;raw video&quot;, DPTH16_16_16_16, PSTR8888, PLANE0,
5578       OFFS2460, SUB444, PACK_ARGB64),
5579   MAKE_YUVA_PACK_FORMAT (AYUV64, &quot;raw video&quot;, 0x00000000, DPTH16_16_16_16,
5580       PSTR8888, PLANE0, OFFS2460, SUB444, PACK_AYUV64),
5581 #endif
5582   MAKE_RGB_FORMAT (r210, &quot;raw video&quot;, DPTH10_10_10, PSTR444, PLANE0, OFFS0,
5583       SUB444, PACK_r210),
5584   MAKE_YUV_FORMAT (I420_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5585       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_10BE),
5586   MAKE_YUV_LE_FORMAT (I420_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5587       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_10LE),
5588   MAKE_YUV_FORMAT (I422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5589       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_10BE),
5590   MAKE_YUV_LE_FORMAT (I422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5591       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_10LE),
5592   MAKE_YUV_FORMAT (Y444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5593       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_10BE),
5594   MAKE_YUV_LE_FORMAT (Y444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5595       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_10LE),
5596   MAKE_RGB_FORMAT (GBR, &quot;raw video&quot;, DPTH888, PSTR111, PLANE201, OFFS0, SUB444,
5597       PACK_GBR),
5598   MAKE_RGB_FORMAT (GBR_10BE, &quot;raw video&quot;, DPTH10_10_10, PSTR222, PLANE201,
5599       OFFS0, SUB444, PACK_GBR_10BE),
5600   MAKE_RGB_LE_FORMAT (GBR_10LE, &quot;raw video&quot;, DPTH10_10_10, PSTR222, PLANE201,
5601       OFFS0, SUB444, PACK_GBR_10LE),
5602   MAKE_YUV_FORMAT (NV16, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;),
5603       DPTH888, PSTR122, PLANE011, OFFS001, SUB422, PACK_NV16),
5604   MAKE_YUV_FORMAT (NV24, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;),
5605       DPTH888, PSTR122, PLANE011, OFFS001, SUB444, PACK_NV24),
5606   MAKE_YUV_T_FORMAT (NV12_64Z32, &quot;raw video&quot;,
5607       GST_MAKE_FOURCC (&#39;T&#39;, &#39;M&#39;, &#39;1&#39;, &#39;2&#39;), DPTH8880, PSTR122, PLANE011,
5608       OFFS001, SUB420, PACK_NV12_64Z32, TILE_64x32 (ZFLIPZ_2X2)),
5609   MAKE_YUVA_FORMAT (A420_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5610       PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_10BE),
5611   MAKE_YUVA_LE_FORMAT (A420_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5612       PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_10LE),
5613   MAKE_YUVA_FORMAT (A422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5614       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10BE),
5615   MAKE_YUVA_LE_FORMAT (A422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5616       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10LE),
5617   MAKE_YUVA_FORMAT (A444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5618       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10BE),
5619   MAKE_YUVA_LE_FORMAT (A444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5620       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10LE),
5621   MAKE_YUV_FORMAT (NV61, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;),
5622       DPTH888, PSTR122, PLANE011, OFFS010, SUB422, PACK_NV61),
5623   MAKE_YUV_FORMAT (P010_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5624       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10BE),
5625   MAKE_YUV_LE_FORMAT (P010_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5626       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10LE),
5627   MAKE_YUV_FORMAT (IYU2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;),
5628       DPTH888, PSTR333, PLANE0, OFFS102, SUB444, PACK_IYU2),
5629   MAKE_YUV_FORMAT (VYUY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;),
5630       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_VYUY),
5631   MAKE_RGBA_FORMAT (GBRA, &quot;raw video&quot;, DPTH8888, PSTR1111, PLANE2013,
5632       OFFS0, SUB4444, PACK_GBRA),
<a name="37" id="anc37"></a><span class="line-modified">5633   MAKE_RGBA_FORMAT (GBRA_10BE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR2222,</span>
<span class="line-modified">5634       PLANE2013, OFFS0, SUB4444, PACK_GBRA_10BE),</span>
<span class="line-modified">5635   MAKE_RGBA_LE_FORMAT (GBRA_10LE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR2222,</span>
<span class="line-modified">5636       PLANE2013, OFFS0, SUB4444, PACK_GBRA_10LE),</span>

5637   MAKE_RGB_FORMAT (GBR_12BE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5638       OFFS0, SUB444, PACK_GBR_12BE),
5639   MAKE_RGB_LE_FORMAT (GBR_12LE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5640       OFFS0, SUB444, PACK_GBR_12LE),
<a name="38" id="anc38"></a><span class="line-modified">5641   MAKE_RGBA_FORMAT (GBRA_12BE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR2222,</span>
<span class="line-modified">5642       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12BE),</span>
<span class="line-modified">5643   MAKE_RGBA_LE_PACK_FORMAT (GBRA_12LE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR2222,</span>
5644       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12LE),
5645   MAKE_YUV_FORMAT (I420_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5646       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12BE),
5647   MAKE_YUV_LE_FORMAT (I420_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5648       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12LE),
5649   MAKE_YUV_FORMAT (I422_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5650       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12BE),
5651   MAKE_YUV_LE_FORMAT (I422_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5652       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12LE),
5653   MAKE_YUV_FORMAT (Y444_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5654       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12BE),
5655   MAKE_YUV_LE_FORMAT (Y444_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5656       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12LE),
5657   MAKE_GRAY_C_LE_FORMAT (GRAY10_LE32, &quot;raw video&quot;, DPTH10, PSTR0, PLANE0, OFFS0,
5658       SUB4, PACK_GRAY10_LE32),
5659   MAKE_YUV_C_LE_FORMAT (NV12_10LE32, &quot;raw video&quot;,
5660       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;), DPTH10_10_10, PSTR0, PLANE011,
5661       OFFS001, SUB420, PACK_NV12_10LE32),
5662   MAKE_YUV_C_LE_FORMAT (NV16_10LE32, &quot;raw video&quot;,
5663       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,
5664       OFFS001, SUB422, PACK_NV16_10LE32),
<a name="39" id="anc39"></a><span class="line-added">5665   MAKE_YUV_C_LE_FORMAT (NV12_10LE40, &quot;raw video&quot;,</span>
<span class="line-added">5666       GST_MAKE_FOURCC (&#39;R&#39;, &#39;K&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,</span>
<span class="line-added">5667       OFFS0, SUB420, PACK_NV12_10LE40),</span>
<span class="line-added">5668   MAKE_YUV_FORMAT (Y210, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;),</span>
<span class="line-added">5669       DPTH10_10_10, PSTR488, PLANE0, OFFS0, SUB422, PACK_Y210),</span>
<span class="line-added">5670   MAKE_YUV_FORMAT (Y410, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;0&#39;),</span>
<span class="line-added">5671       DPTH10_10_10_2, PSTR0, PLANE0, OFFS0, SUB4444, PACK_Y410),</span>
<span class="line-added">5672   MAKE_YUVA_PACK_FORMAT (VUYA, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;U&#39;, &#39;Y&#39;,</span>
<span class="line-added">5673           &#39;A&#39;), DPTH8888, PSTR4444, PLANE0, OFFS2103, SUB4444, PACK_VUYA),</span>
<span class="line-added">5674   MAKE_RGBA_LE_PACK_FORMAT (BGR10A2_LE, &quot;raw video&quot;, DPTH10_10_10_2, PSTR4444,</span>
<span class="line-added">5675       PLANE0,</span>
<span class="line-added">5676       OFFS0, SUB4444, PACK_BGR10A2_LE),</span>
5677 };
5678 
5679 static GstVideoFormat
5680 gst_video_format_from_rgb32_masks (int red_mask, int green_mask, int blue_mask)
5681 {
5682   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5683       blue_mask == 0x0000ff00) {
5684     return GST_VIDEO_FORMAT_RGBx;
5685   }
5686   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5687       blue_mask == 0xff000000) {
5688     return GST_VIDEO_FORMAT_BGRx;
5689   }
5690   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5691       blue_mask == 0x000000ff) {
5692     return GST_VIDEO_FORMAT_xRGB;
5693   }
5694   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5695       blue_mask == 0x00ff0000) {
5696     return GST_VIDEO_FORMAT_xBGR;
5697   }
5698 
5699   return GST_VIDEO_FORMAT_UNKNOWN;
5700 }
5701 
5702 static GstVideoFormat
5703 gst_video_format_from_rgba32_masks (int red_mask, int green_mask,
5704     int blue_mask, int alpha_mask)
5705 {
5706   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5707       blue_mask == 0x0000ff00 &amp;&amp; alpha_mask == 0x000000ff) {
5708     return GST_VIDEO_FORMAT_RGBA;
5709   }
5710   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5711       blue_mask == 0xff000000 &amp;&amp; alpha_mask == 0x000000ff) {
5712     return GST_VIDEO_FORMAT_BGRA;
5713   }
5714   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5715       blue_mask == 0x000000ff &amp;&amp; alpha_mask == 0xff000000) {
5716     return GST_VIDEO_FORMAT_ARGB;
5717   }
5718   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5719       blue_mask == 0x00ff0000 &amp;&amp; alpha_mask == 0xff000000) {
5720     return GST_VIDEO_FORMAT_ABGR;
5721   }
5722   return GST_VIDEO_FORMAT_UNKNOWN;
5723 }
5724 
5725 static GstVideoFormat
5726 gst_video_format_from_rgb24_masks (int red_mask, int green_mask, int blue_mask)
5727 {
5728   if (red_mask == 0xff0000 &amp;&amp; green_mask == 0x00ff00 &amp;&amp; blue_mask == 0x0000ff) {
5729     return GST_VIDEO_FORMAT_RGB;
5730   }
5731   if (red_mask == 0x0000ff &amp;&amp; green_mask == 0x00ff00 &amp;&amp; blue_mask == 0xff0000) {
5732     return GST_VIDEO_FORMAT_BGR;
5733   }
5734 
5735   return GST_VIDEO_FORMAT_UNKNOWN;
5736 }
5737 
5738 #define GST_VIDEO_COMP1_MASK_16_INT 0xf800
5739 #define GST_VIDEO_COMP2_MASK_16_INT 0x07e0
5740 #define GST_VIDEO_COMP3_MASK_16_INT 0x001f
5741 
5742 #define GST_VIDEO_COMP1_MASK_15_INT 0x7c00
5743 #define GST_VIDEO_COMP2_MASK_15_INT 0x03e0
5744 #define GST_VIDEO_COMP3_MASK_15_INT 0x001f
5745 
5746 static GstVideoFormat
5747 gst_video_format_from_rgb16_masks (int red_mask, int green_mask, int blue_mask)
5748 {
5749   if (red_mask == GST_VIDEO_COMP1_MASK_16_INT
5750       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_16_INT
5751       &amp;&amp; blue_mask == GST_VIDEO_COMP3_MASK_16_INT) {
5752     return GST_VIDEO_FORMAT_RGB16;
5753   }
5754   if (red_mask == GST_VIDEO_COMP3_MASK_16_INT
5755       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_16_INT
5756       &amp;&amp; blue_mask == GST_VIDEO_COMP1_MASK_16_INT) {
5757     return GST_VIDEO_FORMAT_BGR16;
5758   }
5759   if (red_mask == GST_VIDEO_COMP1_MASK_15_INT
5760       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_15_INT
5761       &amp;&amp; blue_mask == GST_VIDEO_COMP3_MASK_15_INT) {
5762     return GST_VIDEO_FORMAT_RGB15;
5763   }
5764   if (red_mask == GST_VIDEO_COMP3_MASK_15_INT
5765       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_15_INT
5766       &amp;&amp; blue_mask == GST_VIDEO_COMP1_MASK_15_INT) {
5767     return GST_VIDEO_FORMAT_BGR15;
5768   }
5769   return GST_VIDEO_FORMAT_UNKNOWN;
5770 }
5771 
5772 /**
5773  * gst_video_format_from_masks:
5774  * @depth: the amount of bits used for a pixel
5775  * @bpp: the amount of bits used to store a pixel. This value is bigger than
5776  *   @depth
5777  * @endianness: the endianness of the masks, #G_LITTLE_ENDIAN or #G_BIG_ENDIAN
5778  * @red_mask: the red mask
5779  * @green_mask: the green mask
5780  * @blue_mask: the blue mask
5781  * @alpha_mask: the alpha mask, or 0 if no alpha mask
5782  *
5783  * Find the #GstVideoFormat for the given parameters.
5784  *
5785  * Returns: a #GstVideoFormat or GST_VIDEO_FORMAT_UNKNOWN when the parameters to
5786  * not specify a known format.
5787  */
5788 GstVideoFormat
5789 gst_video_format_from_masks (gint depth, gint bpp, gint endianness,
5790     guint red_mask, guint green_mask, guint blue_mask, guint alpha_mask)
5791 {
5792   GstVideoFormat format;
5793 
5794   /* our caps system handles 24/32bpp RGB as big-endian. */
<a name="40" id="anc40"></a><span class="line-modified">5795   if ((bpp == 24 || bpp == 32) &amp;&amp; endianness == G_LITTLE_ENDIAN &amp;&amp;</span>
<span class="line-added">5796       alpha_mask != 0xc0000000) {</span>
5797     red_mask = GUINT32_TO_BE (red_mask);
5798     green_mask = GUINT32_TO_BE (green_mask);
5799     blue_mask = GUINT32_TO_BE (blue_mask);
5800     alpha_mask = GUINT32_TO_BE (alpha_mask);
5801     endianness = G_BIG_ENDIAN;
5802     if (bpp == 24) {
5803       red_mask &gt;&gt;= 8;
5804       green_mask &gt;&gt;= 8;
5805       blue_mask &gt;&gt;= 8;
5806     }
5807   }
5808 
<a name="41" id="anc41"></a><span class="line-modified">5809   if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask == 0xc0000000 &amp;&amp;</span>
<span class="line-added">5810       endianness == G_LITTLE_ENDIAN) {</span>
<span class="line-added">5811     format = GST_VIDEO_FORMAT_BGR10A2_LE;</span>
<span class="line-added">5812   } else if (depth == 30 &amp;&amp; bpp == 32) {</span>
5813     format = GST_VIDEO_FORMAT_r210;
5814   } else if (depth == 24 &amp;&amp; bpp == 32) {
5815     format = gst_video_format_from_rgb32_masks (red_mask, green_mask,
5816         blue_mask);
5817   } else if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask) {
5818     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5819         blue_mask, alpha_mask);
5820   } else if (depth == 24 &amp;&amp; bpp == 24) {
5821     format = gst_video_format_from_rgb24_masks (red_mask, green_mask,
5822         blue_mask);
5823   } else if ((depth == 15 || depth == 16) &amp;&amp; bpp == 16 &amp;&amp;
5824       endianness == G_BYTE_ORDER) {
5825     format = gst_video_format_from_rgb16_masks (red_mask, green_mask,
5826         blue_mask);
5827   } else if (depth == 8 &amp;&amp; bpp == 8) {
5828     format = GST_VIDEO_FORMAT_RGB8P;
5829   } else if (depth == 64 &amp;&amp; bpp == 64) {
5830     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5831         blue_mask, alpha_mask);
5832     if (format == GST_VIDEO_FORMAT_ARGB) {
5833       format = GST_VIDEO_FORMAT_ARGB64;
5834     } else {
5835       format = GST_VIDEO_FORMAT_UNKNOWN;
5836     }
5837   } else {
5838     format = GST_VIDEO_FORMAT_UNKNOWN;
5839   }
5840   return format;
5841 }
5842 
5843 /**
5844  * gst_video_format_from_fourcc:
5845  * @fourcc: a FOURCC value representing raw YUV video
5846  *
5847  * Converts a FOURCC value into the corresponding #GstVideoFormat.
5848  * If the FOURCC cannot be represented by #GstVideoFormat,
5849  * #GST_VIDEO_FORMAT_UNKNOWN is returned.
5850  *
5851  * Returns: the #GstVideoFormat describing the FOURCC value
5852  */
5853 GstVideoFormat
5854 gst_video_format_from_fourcc (guint32 fourcc)
5855 {
5856   switch (fourcc) {
5857     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5858       return GST_VIDEO_FORMAT_I420;
5859     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5860       return GST_VIDEO_FORMAT_YV12;
5861     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;):
5862       return GST_VIDEO_FORMAT_YUY2;
5863     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;):
5864       return GST_VIDEO_FORMAT_YVYU;
5865     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;):
5866       return GST_VIDEO_FORMAT_UYVY;
5867     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;):
5868       return GST_VIDEO_FORMAT_VYUY;
5869     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;V&#39;):
5870       return GST_VIDEO_FORMAT_AYUV;
5871     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;):
5872       return GST_VIDEO_FORMAT_Y41B;
5873     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;):
5874       return GST_VIDEO_FORMAT_Y42B;
5875     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;):
5876       return GST_VIDEO_FORMAT_Y444;
5877     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):
5878       return GST_VIDEO_FORMAT_v210;
5879     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;):
5880       return GST_VIDEO_FORMAT_v216;
<a name="42" id="anc42"></a><span class="line-added">5881     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):</span>
<span class="line-added">5882       return GST_VIDEO_FORMAT_Y210;</span>
5883     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5884       return GST_VIDEO_FORMAT_NV12;
5885     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;):
5886       return GST_VIDEO_FORMAT_NV21;
5887     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;):
5888       return GST_VIDEO_FORMAT_NV16;
5889     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;):
5890       return GST_VIDEO_FORMAT_NV61;
5891     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;):
5892       return GST_VIDEO_FORMAT_NV24;
5893     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;):
5894       return GST_VIDEO_FORMAT_v308;
5895     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;):
5896       return GST_VIDEO_FORMAT_IYU2;
5897     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39;0&#39;, &#39;0&#39;):
5898     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39; &#39;, &#39; &#39;):
5899     case GST_MAKE_FOURCC (&#39;G&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Y&#39;):
5900       return GST_VIDEO_FORMAT_GRAY8;
5901     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;1&#39;, &#39;6&#39;, &#39; &#39;):
5902       return GST_VIDEO_FORMAT_GRAY16_LE;
5903     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;):
5904       return GST_VIDEO_FORMAT_UYVP;
5905     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5906       return GST_VIDEO_FORMAT_A420;
5907     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;):
5908       return GST_VIDEO_FORMAT_YUV9;
5909     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;):
5910       return GST_VIDEO_FORMAT_YVU9;
5911     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;):
5912       return GST_VIDEO_FORMAT_IYU1;
5913     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;6&#39;, &#39;4&#39;):
5914       return GST_VIDEO_FORMAT_AYUV64;
5915     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;0&#39;):
5916       return GST_VIDEO_FORMAT_GRAY10_LE32;
5917     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;):
5918       return GST_VIDEO_FORMAT_NV12_10LE32;
5919     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;):
5920       return GST_VIDEO_FORMAT_NV16_10LE32;
<a name="43" id="anc43"></a><span class="line-added">5921     case GST_MAKE_FOURCC (&#39;R&#39;, &#39;K&#39;, &#39;2&#39;, &#39;0&#39;):</span>
<span class="line-added">5922       return GST_VIDEO_FORMAT_NV12_10LE40;</span>
<span class="line-added">5923     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;0&#39;):</span>
<span class="line-added">5924       return GST_VIDEO_FORMAT_Y410;</span>
<span class="line-added">5925     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;A&#39;):</span>
<span class="line-added">5926       return GST_VIDEO_FORMAT_VUYA;</span>
<span class="line-added">5927     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;R&#39;, &#39;3&#39;, &#39;0&#39;):</span>
<span class="line-added">5928       return GST_VIDEO_FORMAT_BGR10A2_LE;</span>
<span class="line-added">5929 </span>
5930     default:
5931       return GST_VIDEO_FORMAT_UNKNOWN;
5932   }
5933 }
5934 
5935 /**
5936  * gst_video_format_from_string:
5937  * @format: a format string
5938  *
5939  * Convert the @format string to its #GstVideoFormat.
5940  *
5941  * Returns: the #GstVideoFormat for @format or GST_VIDEO_FORMAT_UNKNOWN when the
5942  * string is not a known format.
5943  */
5944 GstVideoFormat
5945 gst_video_format_from_string (const gchar * format)
5946 {
5947   guint i;
5948 
5949   g_return_val_if_fail (format != NULL, GST_VIDEO_FORMAT_UNKNOWN);
5950 
5951   for (i = 0; i &lt; G_N_ELEMENTS (formats); i++) {
5952     if (strcmp (GST_VIDEO_FORMAT_INFO_NAME (&amp;formats[i].info), format) == 0)
5953       return GST_VIDEO_FORMAT_INFO_FORMAT (&amp;formats[i].info);
5954   }
5955   return GST_VIDEO_FORMAT_UNKNOWN;
5956 }
5957 
5958 
5959 /**
5960  * gst_video_format_to_fourcc:
5961  * @format: a #GstVideoFormat video format
5962  *
5963  * Converts a #GstVideoFormat value into the corresponding FOURCC.  Only
5964  * a few YUV formats have corresponding FOURCC values.  If @format has
5965  * no corresponding FOURCC value, 0 is returned.
5966  *
5967  * Returns: the FOURCC corresponding to @format
5968  */
5969 guint32
5970 gst_video_format_to_fourcc (GstVideoFormat format)
5971 {
5972   g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, 0);
5973 
5974   if ((gint) format &gt;= G_N_ELEMENTS (formats))
5975     return 0;
5976 
5977   return formats[format].fourcc;
5978 }
5979 
5980 /**
5981  * gst_video_format_to_string:
5982  * @format: a #GstVideoFormat video format
5983  *
5984  * Returns a string containing a descriptive name for
5985  * the #GstVideoFormat if there is one, or NULL otherwise.
5986  *
5987  * Returns: the name corresponding to @format
5988  */
5989 const gchar *
5990 gst_video_format_to_string (GstVideoFormat format)
5991 {
5992   g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, NULL);
5993 
5994   if ((gint) format &gt;= G_N_ELEMENTS (formats))
5995     return NULL;
5996 
5997   return GST_VIDEO_FORMAT_INFO_NAME (&amp;formats[format].info);
5998 }
5999 
6000 /**
6001  * gst_video_format_get_info:
6002  * @format: a #GstVideoFormat
6003  *
6004  * Get the #GstVideoFormatInfo for @format
6005  *
6006  * Returns: The #GstVideoFormatInfo for @format.
6007  */
6008 const GstVideoFormatInfo *
6009 gst_video_format_get_info (GstVideoFormat format)
6010 {
6011   g_return_val_if_fail ((gint) format &lt; G_N_ELEMENTS (formats), NULL);
6012 
6013   return &amp;formats[format].info;
6014 }
6015 
6016 /**
6017  * gst_video_format_get_palette:
6018  * @format: a #GstVideoFormat
6019  * @size: (out): size of the palette in bytes
6020  *
6021  * Get the default palette of @format. This the palette used in the pack
6022  * function for paletted formats.
6023  *
6024  * Returns: (transfer none): the default palette of @format or %NULL when
6025  * @format does not have a palette.
6026  *
6027  * Since: 1.2
6028  */
6029 gconstpointer
6030 gst_video_format_get_palette (GstVideoFormat format, gsize * size)
6031 {
6032   g_return_val_if_fail ((gint) format &lt; G_N_ELEMENTS (formats), NULL);
6033   g_return_val_if_fail (size != NULL, NULL);
6034 
6035   switch (format) {
6036     case GST_VIDEO_FORMAT_RGB8P:
6037       *size = sizeof (std_palette_RGB8P);
6038       return std_palette_RGB8P;
6039     default:
6040       return NULL;
6041   }
6042 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>