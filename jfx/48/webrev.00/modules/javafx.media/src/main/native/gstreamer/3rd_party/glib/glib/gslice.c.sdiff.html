<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gslice.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gshell.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gslice.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gslice.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 
  29 #ifdef G_OS_UNIX
  30 #include &lt;unistd.h&gt;             /* sysconf() */
  31 #endif
  32 #ifdef G_OS_WIN32
  33 #include &lt;windows.h&gt;
  34 #include &lt;process.h&gt;
  35 #endif
  36 
  37 #include &lt;stdio.h&gt;              /* fputs */
  38 
  39 #include &quot;gslice.h&quot;
  40 
  41 #include &quot;gmain.h&quot;
  42 #include &quot;gmem.h&quot;               /* gslice.h */
  43 #include &quot;gstrfuncs.h&quot;
  44 #include &quot;gutils.h&quot;
  45 #include &quot;gtrashstack.h&quot;
  46 #include &quot;gtestutils.h&quot;
  47 #include &quot;gthread.h&quot;

  48 #include &quot;glib_trace.h&quot;
  49 #include &quot;gprintf.h&quot;
  50 
  51 #include &quot;gvalgrind.h&quot;
  52 
  53 /**
  54  * SECTION:memory_slices
  55  * @title: Memory Slices
  56  * @short_description: efficient way to allocate groups of equal-sized
  57  *     chunks of memory
  58  *
  59  * Memory slices provide a space-efficient and multi-processing scalable
  60  * way to allocate equal-sized pieces of memory, just like the original
  61  * #GMemChunks (from GLib 2.8), while avoiding their excessive
  62  * memory-waste, scalability and performance problems.
  63  *
  64  * To achieve these goals, the slice allocator uses a sophisticated,
  65  * layered design that has been inspired by Bonwick&#39;s slab allocator
  66  * ([Bonwick94](http://citeseer.ist.psu.edu/bonwick94slab.html)
  67  * Jeff Bonwick, The slab allocator: An object-caching kernel
</pre>
<hr />
<pre>
 503           *contention_counter = MAX (*contention_counter, 1) - 1;
 504         }
 505     }
 506 }
 507 
 508 static inline ThreadMemory*
 509 thread_memory_from_self (void)
 510 {
 511   ThreadMemory *tmem = g_private_get (&amp;private_thread_memory);
 512   if (G_UNLIKELY (!tmem))
 513     {
 514       static GMutex init_mutex;
 515       guint n_magazines;
 516 
 517       g_mutex_lock (&amp;init_mutex);
 518       if G_UNLIKELY (sys_page_size == 0)
 519         g_slice_init_nomessage ();
 520       g_mutex_unlock (&amp;init_mutex);
 521 
 522       n_magazines = MAX_SLAB_INDEX (allocator);
<span class="line-modified"> 523       tmem = g_malloc0 (sizeof (ThreadMemory) + sizeof (Magazine) * 2 * n_magazines);</span>
 524 #ifdef GSTREAMER_LITE
 525       if (tmem == NULL)
<span class="line-modified"> 526           return NULL;</span>
 527 #endif // GSTREAMER_LITE
 528       tmem-&gt;magazine1 = (Magazine*) (tmem + 1);
 529       tmem-&gt;magazine2 = &amp;tmem-&gt;magazine1[n_magazines];
<span class="line-removed"> 530       g_private_set (&amp;private_thread_memory, tmem);</span>
 531     }
 532   return tmem;
 533 }
 534 
 535 static inline ChunkLink*
 536 magazine_chain_pop_head (ChunkLink **magazine_chunks)
 537 {
 538   /* magazine chains are linked via ChunkLink-&gt;next.
 539    * each ChunkLink-&gt;data of the toplevel chain may point to a subchain,
 540    * linked via ChunkLink-&gt;next. ChunkLink-&gt;data of the subchains just
 541    * contains uninitialized junk.
 542    */
 543   ChunkLink *chunk = (*magazine_chunks)-&gt;data;
 544   if (G_UNLIKELY (chunk))
 545     {
 546       /* allocating from freed list */
 547       (*magazine_chunks)-&gt;data = chunk-&gt;next;
 548     }
 549   else
 550     {
</pre>
<hr />
<pre>
 587    * the content of a single magazine doesn&#39;t exceed ca. 16KB.
 588    */
 589   gsize chunk_size = SLAB_CHUNK_SIZE (allocator, ix);
 590   guint threshold = MAX (MIN_MAGAZINE_SIZE, allocator-&gt;max_page_size / MAX (5 * chunk_size, 5 * 32));
 591   guint contention_counter = allocator-&gt;contention_counters[ix];
 592   if (G_UNLIKELY (contention_counter))  /* single CPU bias */
 593     {
 594       /* adapt contention counter thresholds to chunk sizes */
 595       contention_counter = contention_counter * 64 / chunk_size;
 596       threshold = MAX (threshold, contention_counter);
 597     }
 598   return threshold;
 599 }
 600 
 601 /* --- magazine cache --- */
 602 static inline void
 603 magazine_cache_update_stamp (void)
 604 {
 605   if (allocator-&gt;stamp_counter &gt;= MAX_STAMP_COUNTER)
 606     {
<span class="line-modified"> 607       GTimeVal tv;</span>
<span class="line-modified"> 608       g_get_current_time (&amp;tv);</span>
<span class="line-removed"> 609       allocator-&gt;last_stamp = tv.tv_sec * 1000 + tv.tv_usec / 1000; /* milli seconds */</span>
 610       allocator-&gt;stamp_counter = 0;
 611     }
 612   else
 613     allocator-&gt;stamp_counter++;
 614 }
 615 
 616 static inline ChunkLink*
 617 magazine_chain_prepare_fields (ChunkLink *magazine_chunks)
 618 {
 619   ChunkLink *chunk1;
 620   ChunkLink *chunk2;
 621   ChunkLink *chunk3;
 622   ChunkLink *chunk4;
 623   /* checked upon initialization: mem_assert (MIN_MAGAZINE_SIZE &gt;= 4); */
 624   /* ensure a magazine with at least 4 unused data pointers */
 625   chunk1 = magazine_chain_pop_head (&amp;magazine_chunks);
 626   chunk2 = magazine_chain_pop_head (&amp;magazine_chunks);
 627   chunk3 = magazine_chain_pop_head (&amp;magazine_chunks);
 628   chunk4 = magazine_chain_pop_head (&amp;magazine_chunks);
 629   chunk4-&gt;next = magazine_chunks;
</pre>
<hr />
<pre>
 632   chunk1-&gt;next = chunk2;
 633   return chunk1;
 634 }
 635 
 636 /* access the first 3 fields of a specially prepared magazine chain */
 637 #define magazine_chain_prev(mc)         ((mc)-&gt;data)
 638 #define magazine_chain_stamp(mc)        ((mc)-&gt;next-&gt;data)
 639 #define magazine_chain_uint_stamp(mc)   GPOINTER_TO_UINT ((mc)-&gt;next-&gt;data)
 640 #define magazine_chain_next(mc)         ((mc)-&gt;next-&gt;next-&gt;data)
 641 #define magazine_chain_count(mc)        ((mc)-&gt;next-&gt;next-&gt;next-&gt;data)
 642 
 643 static void
 644 magazine_cache_trim (Allocator *allocator,
 645                      guint      ix,
 646                      guint      stamp)
 647 {
 648   /* g_mutex_lock (allocator-&gt;mutex); done by caller */
 649   /* trim magazine cache from tail */
 650   ChunkLink *current = magazine_chain_prev (allocator-&gt;magazines[ix]);
 651   ChunkLink *trash = NULL;
<span class="line-modified"> 652   while (ABS (stamp - magazine_chain_uint_stamp (current)) &gt;= allocator-&gt;config.working_set_msecs)</span>

 653     {
 654       /* unlink */
 655       ChunkLink *prev = magazine_chain_prev (current);
 656       ChunkLink *next = magazine_chain_next (current);
 657       magazine_chain_next (prev) = next;
 658       magazine_chain_prev (next) = prev;
 659       /* clear special fields, put on trash stack */
 660       magazine_chain_next (current) = NULL;
 661       magazine_chain_count (current) = NULL;
 662       magazine_chain_stamp (current) = NULL;
 663       magazine_chain_prev (current) = trash;
 664       trash = current;
 665       /* fixup list head if required */
 666       if (current == allocator-&gt;magazines[ix])
 667         {
 668           allocator-&gt;magazines[ix] = NULL;
 669           break;
 670         }
 671       current = prev;
 672     }
</pre>
<hr />
<pre>
1400       if (allocator-&gt;slab_stack[ix] == sinfo)
1401         allocator-&gt;slab_stack[ix] = next == sinfo ? NULL : next;
1402       /* free slab */
1403       allocator_memfree (page_size, page);
1404     }
1405 }
1406 
1407 /* --- memalign implementation --- */
1408 #ifdef HAVE_MALLOC_H
1409 #include &lt;malloc.h&gt;             /* memalign() */
1410 #endif
1411 
1412 /* from config.h:
1413  * define HAVE_POSIX_MEMALIGN           1 // if free(posix_memalign(3)) works, &lt;stdlib.h&gt;
1414  * define HAVE_MEMALIGN                 1 // if free(memalign(3)) works, &lt;malloc.h&gt;
1415  * define HAVE_VALLOC                   1 // if free(valloc(3)) works, &lt;stdlib.h&gt; or &lt;malloc.h&gt;
1416  * if none is provided, we implement malloc(3)-based alloc-only page alignment
1417  */
1418 
1419 #if !(HAVE_POSIX_MEMALIGN || HAVE_MEMALIGN || HAVE_VALLOC)

1420 static GTrashStack *compat_valloc_trash = NULL;

1421 #endif
1422 
1423 static gpointer
1424 allocator_memalign (gsize alignment,
1425                     gsize memsize)
1426 {
1427   gpointer aligned_memory = NULL;
1428   gint err = ENOMEM;
1429 #if     HAVE_POSIX_MEMALIGN
1430   err = posix_memalign (&amp;aligned_memory, alignment, memsize);
1431 #elif   HAVE_MEMALIGN
1432   errno = 0;
1433   aligned_memory = memalign (alignment, memsize);
1434   err = errno;
1435 #elif   HAVE_VALLOC
1436   errno = 0;
1437   aligned_memory = valloc (memsize);
1438   err = errno;
1439 #else
1440   /* simplistic non-freeing page allocator */
</pre>
</td>
<td>
<hr />
<pre>
  28 
  29 #ifdef G_OS_UNIX
  30 #include &lt;unistd.h&gt;             /* sysconf() */
  31 #endif
  32 #ifdef G_OS_WIN32
  33 #include &lt;windows.h&gt;
  34 #include &lt;process.h&gt;
  35 #endif
  36 
  37 #include &lt;stdio.h&gt;              /* fputs */
  38 
  39 #include &quot;gslice.h&quot;
  40 
  41 #include &quot;gmain.h&quot;
  42 #include &quot;gmem.h&quot;               /* gslice.h */
  43 #include &quot;gstrfuncs.h&quot;
  44 #include &quot;gutils.h&quot;
  45 #include &quot;gtrashstack.h&quot;
  46 #include &quot;gtestutils.h&quot;
  47 #include &quot;gthread.h&quot;
<span class="line-added">  48 #include &quot;gthreadprivate.h&quot;</span>
  49 #include &quot;glib_trace.h&quot;
  50 #include &quot;gprintf.h&quot;
  51 
  52 #include &quot;gvalgrind.h&quot;
  53 
  54 /**
  55  * SECTION:memory_slices
  56  * @title: Memory Slices
  57  * @short_description: efficient way to allocate groups of equal-sized
  58  *     chunks of memory
  59  *
  60  * Memory slices provide a space-efficient and multi-processing scalable
  61  * way to allocate equal-sized pieces of memory, just like the original
  62  * #GMemChunks (from GLib 2.8), while avoiding their excessive
  63  * memory-waste, scalability and performance problems.
  64  *
  65  * To achieve these goals, the slice allocator uses a sophisticated,
  66  * layered design that has been inspired by Bonwick&#39;s slab allocator
  67  * ([Bonwick94](http://citeseer.ist.psu.edu/bonwick94slab.html)
  68  * Jeff Bonwick, The slab allocator: An object-caching kernel
</pre>
<hr />
<pre>
 504           *contention_counter = MAX (*contention_counter, 1) - 1;
 505         }
 506     }
 507 }
 508 
 509 static inline ThreadMemory*
 510 thread_memory_from_self (void)
 511 {
 512   ThreadMemory *tmem = g_private_get (&amp;private_thread_memory);
 513   if (G_UNLIKELY (!tmem))
 514     {
 515       static GMutex init_mutex;
 516       guint n_magazines;
 517 
 518       g_mutex_lock (&amp;init_mutex);
 519       if G_UNLIKELY (sys_page_size == 0)
 520         g_slice_init_nomessage ();
 521       g_mutex_unlock (&amp;init_mutex);
 522 
 523       n_magazines = MAX_SLAB_INDEX (allocator);
<span class="line-modified"> 524       tmem = g_private_set_alloc0 (&amp;private_thread_memory, sizeof (ThreadMemory) + sizeof (Magazine) * 2 * n_magazines);</span>
 525 #ifdef GSTREAMER_LITE
 526       if (tmem == NULL)
<span class="line-modified"> 527         return NULL;</span>
 528 #endif // GSTREAMER_LITE
 529       tmem-&gt;magazine1 = (Magazine*) (tmem + 1);
 530       tmem-&gt;magazine2 = &amp;tmem-&gt;magazine1[n_magazines];

 531     }
 532   return tmem;
 533 }
 534 
 535 static inline ChunkLink*
 536 magazine_chain_pop_head (ChunkLink **magazine_chunks)
 537 {
 538   /* magazine chains are linked via ChunkLink-&gt;next.
 539    * each ChunkLink-&gt;data of the toplevel chain may point to a subchain,
 540    * linked via ChunkLink-&gt;next. ChunkLink-&gt;data of the subchains just
 541    * contains uninitialized junk.
 542    */
 543   ChunkLink *chunk = (*magazine_chunks)-&gt;data;
 544   if (G_UNLIKELY (chunk))
 545     {
 546       /* allocating from freed list */
 547       (*magazine_chunks)-&gt;data = chunk-&gt;next;
 548     }
 549   else
 550     {
</pre>
<hr />
<pre>
 587    * the content of a single magazine doesn&#39;t exceed ca. 16KB.
 588    */
 589   gsize chunk_size = SLAB_CHUNK_SIZE (allocator, ix);
 590   guint threshold = MAX (MIN_MAGAZINE_SIZE, allocator-&gt;max_page_size / MAX (5 * chunk_size, 5 * 32));
 591   guint contention_counter = allocator-&gt;contention_counters[ix];
 592   if (G_UNLIKELY (contention_counter))  /* single CPU bias */
 593     {
 594       /* adapt contention counter thresholds to chunk sizes */
 595       contention_counter = contention_counter * 64 / chunk_size;
 596       threshold = MAX (threshold, contention_counter);
 597     }
 598   return threshold;
 599 }
 600 
 601 /* --- magazine cache --- */
 602 static inline void
 603 magazine_cache_update_stamp (void)
 604 {
 605   if (allocator-&gt;stamp_counter &gt;= MAX_STAMP_COUNTER)
 606     {
<span class="line-modified"> 607       gint64 now_us = g_get_real_time ();</span>
<span class="line-modified"> 608       allocator-&gt;last_stamp = now_us / 1000; /* milli seconds */</span>

 609       allocator-&gt;stamp_counter = 0;
 610     }
 611   else
 612     allocator-&gt;stamp_counter++;
 613 }
 614 
 615 static inline ChunkLink*
 616 magazine_chain_prepare_fields (ChunkLink *magazine_chunks)
 617 {
 618   ChunkLink *chunk1;
 619   ChunkLink *chunk2;
 620   ChunkLink *chunk3;
 621   ChunkLink *chunk4;
 622   /* checked upon initialization: mem_assert (MIN_MAGAZINE_SIZE &gt;= 4); */
 623   /* ensure a magazine with at least 4 unused data pointers */
 624   chunk1 = magazine_chain_pop_head (&amp;magazine_chunks);
 625   chunk2 = magazine_chain_pop_head (&amp;magazine_chunks);
 626   chunk3 = magazine_chain_pop_head (&amp;magazine_chunks);
 627   chunk4 = magazine_chain_pop_head (&amp;magazine_chunks);
 628   chunk4-&gt;next = magazine_chunks;
</pre>
<hr />
<pre>
 631   chunk1-&gt;next = chunk2;
 632   return chunk1;
 633 }
 634 
 635 /* access the first 3 fields of a specially prepared magazine chain */
 636 #define magazine_chain_prev(mc)         ((mc)-&gt;data)
 637 #define magazine_chain_stamp(mc)        ((mc)-&gt;next-&gt;data)
 638 #define magazine_chain_uint_stamp(mc)   GPOINTER_TO_UINT ((mc)-&gt;next-&gt;data)
 639 #define magazine_chain_next(mc)         ((mc)-&gt;next-&gt;next-&gt;data)
 640 #define magazine_chain_count(mc)        ((mc)-&gt;next-&gt;next-&gt;next-&gt;data)
 641 
 642 static void
 643 magazine_cache_trim (Allocator *allocator,
 644                      guint      ix,
 645                      guint      stamp)
 646 {
 647   /* g_mutex_lock (allocator-&gt;mutex); done by caller */
 648   /* trim magazine cache from tail */
 649   ChunkLink *current = magazine_chain_prev (allocator-&gt;magazines[ix]);
 650   ChunkLink *trash = NULL;
<span class="line-modified"> 651   while (!G_APPROX_VALUE(stamp, magazine_chain_uint_stamp (current),</span>
<span class="line-added"> 652                          allocator-&gt;config.working_set_msecs))</span>
 653     {
 654       /* unlink */
 655       ChunkLink *prev = magazine_chain_prev (current);
 656       ChunkLink *next = magazine_chain_next (current);
 657       magazine_chain_next (prev) = next;
 658       magazine_chain_prev (next) = prev;
 659       /* clear special fields, put on trash stack */
 660       magazine_chain_next (current) = NULL;
 661       magazine_chain_count (current) = NULL;
 662       magazine_chain_stamp (current) = NULL;
 663       magazine_chain_prev (current) = trash;
 664       trash = current;
 665       /* fixup list head if required */
 666       if (current == allocator-&gt;magazines[ix])
 667         {
 668           allocator-&gt;magazines[ix] = NULL;
 669           break;
 670         }
 671       current = prev;
 672     }
</pre>
<hr />
<pre>
1400       if (allocator-&gt;slab_stack[ix] == sinfo)
1401         allocator-&gt;slab_stack[ix] = next == sinfo ? NULL : next;
1402       /* free slab */
1403       allocator_memfree (page_size, page);
1404     }
1405 }
1406 
1407 /* --- memalign implementation --- */
1408 #ifdef HAVE_MALLOC_H
1409 #include &lt;malloc.h&gt;             /* memalign() */
1410 #endif
1411 
1412 /* from config.h:
1413  * define HAVE_POSIX_MEMALIGN           1 // if free(posix_memalign(3)) works, &lt;stdlib.h&gt;
1414  * define HAVE_MEMALIGN                 1 // if free(memalign(3)) works, &lt;malloc.h&gt;
1415  * define HAVE_VALLOC                   1 // if free(valloc(3)) works, &lt;stdlib.h&gt; or &lt;malloc.h&gt;
1416  * if none is provided, we implement malloc(3)-based alloc-only page alignment
1417  */
1418 
1419 #if !(HAVE_POSIX_MEMALIGN || HAVE_MEMALIGN || HAVE_VALLOC)
<span class="line-added">1420 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1421 static GTrashStack *compat_valloc_trash = NULL;
<span class="line-added">1422 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1423 #endif
1424 
1425 static gpointer
1426 allocator_memalign (gsize alignment,
1427                     gsize memsize)
1428 {
1429   gpointer aligned_memory = NULL;
1430   gint err = ENOMEM;
1431 #if     HAVE_POSIX_MEMALIGN
1432   err = posix_memalign (&amp;aligned_memory, alignment, memsize);
1433 #elif   HAVE_MEMALIGN
1434   errno = 0;
1435   aligned_memory = memalign (alignment, memsize);
1436   err = errno;
1437 #elif   HAVE_VALLOC
1438   errno = 0;
1439   aligned_memory = valloc (memsize);
1440   err = errno;
1441 #else
1442   /* simplistic non-freeing page allocator */
</pre>
</td>
</tr>
</table>
<center><a href="gshell.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gslice.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>