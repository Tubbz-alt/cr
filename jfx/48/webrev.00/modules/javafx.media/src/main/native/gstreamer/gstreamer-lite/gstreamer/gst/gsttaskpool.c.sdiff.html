<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaskpool.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsttask.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttaskpool.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaskpool.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gsttaskpool
 24  * @title: GstTaskPool
 25  * @short_description: Pool of GStreamer streaming threads
 26  * @see_also: #GstTask, #GstPad
 27  *
 28  * This object provides an abstraction for creating threads. The default
 29  * implementation uses a regular GThreadPool to start tasks.
 30  *
 31  * Subclasses can be made to create custom threads.
 32  */
 33 
 34 #include &quot;gst_private.h&quot;
 35 
 36 #include &quot;gstinfo.h&quot;
 37 #include &quot;gsttaskpool.h&quot;

 38 
 39 GST_DEBUG_CATEGORY_STATIC (taskpool_debug);
 40 #define GST_CAT_DEFAULT (taskpool_debug)
 41 
 42 #ifndef GST_DISABLE_GST_DEBUG
 43 static void gst_task_pool_finalize (GObject * object);
 44 #endif
 45 
 46 #define _do_init \
 47 { \
 48   GST_DEBUG_CATEGORY_INIT (taskpool_debug, &quot;taskpool&quot;, 0, &quot;Thread pool&quot;); \
 49 }
 50 
 51 G_DEFINE_TYPE_WITH_CODE (GstTaskPool, gst_task_pool, GST_TYPE_OBJECT, _do_init);
 52 
 53 typedef struct
 54 {
 55   GstTaskPoolFunction func;
 56   gpointer user_data;
 57 } TaskData;
 58 
 59 static void
 60 default_func (TaskData * tdata, GstTaskPool * pool)
 61 {
 62   GstTaskPoolFunction func;
 63   gpointer user_data;
 64 
 65   func = tdata-&gt;func;
 66   user_data = tdata-&gt;user_data;
 67   g_slice_free (TaskData, tdata);
 68 
 69   func (user_data);
 70 }
 71 
 72 static void
 73 default_prepare (GstTaskPool * pool, GError ** error)
 74 {
 75   GST_OBJECT_LOCK (pool);
<span class="line-modified"> 76   pool-&gt;pool = g_thread_pool_new ((GFunc) default_func, pool, -1, FALSE, NULL);</span>
 77   GST_OBJECT_UNLOCK (pool);
 78 }
 79 
 80 static void
 81 default_cleanup (GstTaskPool * pool)
 82 {


 83   GST_OBJECT_LOCK (pool);
<span class="line-modified"> 84   if (pool-&gt;pool) {</span>




 85     /* Shut down all the threads, we still process the ones scheduled
 86      * because the unref happens in the thread function.
 87      * Also wait for currently running ones to finish. */
<span class="line-modified"> 88     g_thread_pool_free (pool-&gt;pool, FALSE, TRUE);</span>
<span class="line-removed"> 89     pool-&gt;pool = NULL;</span>
 90   }
<span class="line-removed"> 91   GST_OBJECT_UNLOCK (pool);</span>
 92 }
 93 
 94 static gpointer
 95 default_push (GstTaskPool * pool, GstTaskPoolFunction func,
 96     gpointer user_data, GError ** error)
 97 {
 98   TaskData *tdata;
 99 
100   tdata = g_slice_new (TaskData);
101   tdata-&gt;func = func;
102   tdata-&gt;user_data = user_data;
103 
104   GST_OBJECT_LOCK (pool);
105   if (pool-&gt;pool)
106     g_thread_pool_push (pool-&gt;pool, tdata, error);
107   else {
108     g_slice_free (TaskData, tdata);



109   }
110   GST_OBJECT_UNLOCK (pool);
111 
112   return NULL;
113 }
114 
115 static void
116 default_join (GstTaskPool * pool, gpointer id)
117 {
118   /* we do nothing here, we can&#39;t join from the pools */
119 }
120 
121 static void
122 gst_task_pool_class_init (GstTaskPoolClass * klass)
123 {
124   GObjectClass *gobject_class;
125   GstTaskPoolClass *gsttaskpool_class;
126 
127   gobject_class = (GObjectClass *) klass;
128   gsttaskpool_class = (GstTaskPoolClass *) klass;
</pre>
</td>
<td>
<hr />
<pre>
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gsttaskpool
 24  * @title: GstTaskPool
 25  * @short_description: Pool of GStreamer streaming threads
 26  * @see_also: #GstTask, #GstPad
 27  *
 28  * This object provides an abstraction for creating threads. The default
 29  * implementation uses a regular GThreadPool to start tasks.
 30  *
 31  * Subclasses can be made to create custom threads.
 32  */
 33 
 34 #include &quot;gst_private.h&quot;
 35 
 36 #include &quot;gstinfo.h&quot;
 37 #include &quot;gsttaskpool.h&quot;
<span class="line-added"> 38 #include &quot;gsterror.h&quot;</span>
 39 
 40 GST_DEBUG_CATEGORY_STATIC (taskpool_debug);
 41 #define GST_CAT_DEFAULT (taskpool_debug)
 42 
 43 #ifndef GST_DISABLE_GST_DEBUG
 44 static void gst_task_pool_finalize (GObject * object);
 45 #endif
 46 
 47 #define _do_init \
 48 { \
 49   GST_DEBUG_CATEGORY_INIT (taskpool_debug, &quot;taskpool&quot;, 0, &quot;Thread pool&quot;); \
 50 }
 51 
 52 G_DEFINE_TYPE_WITH_CODE (GstTaskPool, gst_task_pool, GST_TYPE_OBJECT, _do_init);
 53 
 54 typedef struct
 55 {
 56   GstTaskPoolFunction func;
 57   gpointer user_data;
 58 } TaskData;
 59 
 60 static void
 61 default_func (TaskData * tdata, GstTaskPool * pool)
 62 {
 63   GstTaskPoolFunction func;
 64   gpointer user_data;
 65 
 66   func = tdata-&gt;func;
 67   user_data = tdata-&gt;user_data;
 68   g_slice_free (TaskData, tdata);
 69 
 70   func (user_data);
 71 }
 72 
 73 static void
 74 default_prepare (GstTaskPool * pool, GError ** error)
 75 {
 76   GST_OBJECT_LOCK (pool);
<span class="line-modified"> 77   pool-&gt;pool = g_thread_pool_new ((GFunc) default_func, pool, -1, FALSE, error);</span>
 78   GST_OBJECT_UNLOCK (pool);
 79 }
 80 
 81 static void
 82 default_cleanup (GstTaskPool * pool)
 83 {
<span class="line-added"> 84   GThreadPool *pool_;</span>
<span class="line-added"> 85 </span>
 86   GST_OBJECT_LOCK (pool);
<span class="line-modified"> 87   pool_ = pool-&gt;pool;</span>
<span class="line-added"> 88   pool-&gt;pool = NULL;</span>
<span class="line-added"> 89   GST_OBJECT_UNLOCK (pool);</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91   if (pool_) {</span>
 92     /* Shut down all the threads, we still process the ones scheduled
 93      * because the unref happens in the thread function.
 94      * Also wait for currently running ones to finish. */
<span class="line-modified"> 95     g_thread_pool_free (pool_, FALSE, TRUE);</span>

 96   }

 97 }
 98 
 99 static gpointer
100 default_push (GstTaskPool * pool, GstTaskPoolFunction func,
101     gpointer user_data, GError ** error)
102 {
103   TaskData *tdata;
104 
105   tdata = g_slice_new (TaskData);
106   tdata-&gt;func = func;
107   tdata-&gt;user_data = user_data;
108 
109   GST_OBJECT_LOCK (pool);
110   if (pool-&gt;pool)
111     g_thread_pool_push (pool-&gt;pool, tdata, error);
112   else {
113     g_slice_free (TaskData, tdata);
<span class="line-added">114     g_set_error_literal (error, GST_CORE_ERROR, GST_CORE_ERROR_FAILED,</span>
<span class="line-added">115         &quot;No thread pool&quot;);</span>
<span class="line-added">116 </span>
117   }
118   GST_OBJECT_UNLOCK (pool);
119 
120   return NULL;
121 }
122 
123 static void
124 default_join (GstTaskPool * pool, gpointer id)
125 {
126   /* we do nothing here, we can&#39;t join from the pools */
127 }
128 
129 static void
130 gst_task_pool_class_init (GstTaskPoolClass * klass)
131 {
132   GObjectClass *gobject_class;
133   GstTaskPoolClass *gsttaskpool_class;
134 
135   gobject_class = (GObjectClass *) klass;
136   gsttaskpool_class = (GstTaskPoolClass *) klass;
</pre>
</td>
</tr>
</table>
<center><a href="gsttask.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttaskpool.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>