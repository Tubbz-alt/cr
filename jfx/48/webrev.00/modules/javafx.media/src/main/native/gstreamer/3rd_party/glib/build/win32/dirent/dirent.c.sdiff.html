<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/build/win32/dirent/dirent.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../osx/glibconfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dirent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/build/win32/dirent/dirent.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * Updated by Jeremy Bettis &lt;jeremy@hksys.com&gt;
 12  * Significantly revised and rewinddir, seekdir and telldir added by Colin
 13  * Peters &lt;colin@fu.is.saga-u.ac.jp&gt;
 14  *
 15  */
 16 
 17 #include &lt;stdlib.h&gt;
 18 #include &lt;errno.h&gt;
 19 #include &lt;string.h&gt;
 20 #include &lt;io.h&gt;
 21 #include &lt;direct.h&gt;
 22 
 23 #include &quot;dirent.h&quot;
 24 
 25 #define WIN32_LEAN_AND_MEAN
 26 #include &lt;windows.h&gt; /* for GetFileAttributes */
 27 
 28 #include &lt;tchar.h&gt;
 29 
 30 #ifdef _UNICODE
<span class="line-modified"> 31 #define _tdirent    _wdirent</span>
<span class="line-modified"> 32 #define _TDIR       _WDIR</span>
<span class="line-modified"> 33 #define _topendir   _wopendir</span>
 34 #define _tclosedir  _wclosedir
<span class="line-modified"> 35 #define _treaddir   _wreaddir</span>
 36 #define _trewinddir _wrewinddir
<span class="line-modified"> 37 #define _ttelldir   _wtelldir</span>
<span class="line-modified"> 38 #define _tseekdir   _wseekdir</span>
 39 #else
<span class="line-modified"> 40 #define _tdirent    dirent</span>
<span class="line-modified"> 41 #define _TDIR       DIR</span>
<span class="line-modified"> 42 #define _topendir   opendir</span>
 43 #define _tclosedir  closedir
<span class="line-modified"> 44 #define _treaddir   readdir</span>
 45 #define _trewinddir rewinddir
<span class="line-modified"> 46 #define _ttelldir   telldir</span>
<span class="line-modified"> 47 #define _tseekdir   seekdir</span>
 48 #endif
 49 
 50 #define SUFFIX  _T(&quot;*&quot;)
<span class="line-modified"> 51 #define SLASH   _T(&quot;\\&quot;)</span>
 52 
 53 
 54 /*
 55  * opendir
 56  *
 57  * Returns a pointer to a DIR structure appropriately filled in to begin
 58  * searching a directory.
 59  */
 60 _TDIR *
 61 _topendir (const _TCHAR *szPath)
 62 {
 63   _TDIR *nd;
 64   unsigned int rc;
 65   _TCHAR szFullPath[MAX_PATH];
 66 
 67   errno = 0;
 68 
 69   if (!szPath)
 70     {
 71       errno = EFAULT;
</pre>
<hr />
<pre>
 82   rc = GetFileAttributes (szPath);
 83   if (rc == (unsigned int)-1)
 84     {
 85       /* call GetLastError for more error info */
 86       errno = ENOENT;
 87       return (_TDIR *) 0;
 88     }
 89   if (!(rc &amp; FILE_ATTRIBUTE_DIRECTORY))
 90     {
 91       /* Error, entry exists but not a directory. */
 92       errno = ENOTDIR;
 93       return (_TDIR *) 0;
 94     }
 95 
 96   /* Make an absolute pathname.  */
 97   _tfullpath (szFullPath, szPath, MAX_PATH);
 98 
 99   /* Allocate enough space to store DIR structure and the complete
100    * directory path given. */
101   nd = (_TDIR *) malloc (sizeof (_TDIR) + (_tcslen(szFullPath) + _tcslen (SLASH) +
<span class="line-modified">102              _tcslen(SUFFIX) + 1) * sizeof(_TCHAR));</span>
103 
104   if (!nd)
105     {
106       /* Error, out of memory. */
107       errno = ENOMEM;
108       return (_TDIR *) 0;
109     }
110 
111   /* Create the search expression. */
112   _tcscpy (nd-&gt;dd_name, szFullPath);
113 
114   /* Add on a slash if the path does not end with one. */
115   if (nd-&gt;dd_name[0] != _T(&#39;\0&#39;) &amp;&amp;
116       nd-&gt;dd_name[_tcslen (nd-&gt;dd_name) - 1] != _T(&#39;/&#39;) &amp;&amp;
117       nd-&gt;dd_name[_tcslen (nd-&gt;dd_name) - 1] != _T(&#39;\\&#39;))
118     {
119       _tcscat (nd-&gt;dd_name, SLASH);
120     }
121 
122   /* Add on the search pattern */
</pre>
<hr />
<pre>
155   /* Check for valid DIR struct. */
156   if (!dirp)
157     {
158       errno = EFAULT;
159       return (struct _tdirent *) 0;
160     }
161 
162   if (dirp-&gt;dd_stat &lt; 0)
163     {
164       /* We have already returned all files in the directory
165        * (or the structure has an invalid dd_stat). */
166       return (struct _tdirent *) 0;
167     }
168   else if (dirp-&gt;dd_stat == 0)
169     {
170       /* We haven&#39;t started the search yet. */
171       /* Start the search */
172       dirp-&gt;dd_handle = _tfindfirst (dirp-&gt;dd_name, &amp;(dirp-&gt;dd_dta));
173 
174       if (dirp-&gt;dd_handle == -1)
<span class="line-modified">175     {</span>
<span class="line-modified">176       /* Whoops! Seems there are no files in that</span>
<span class="line-modified">177        * directory. */</span>
<span class="line-modified">178       dirp-&gt;dd_stat = -1;</span>
<span class="line-modified">179     }</span>
180       else
<span class="line-modified">181     {</span>
<span class="line-modified">182       dirp-&gt;dd_stat = 1;</span>
<span class="line-modified">183     }</span>
184     }
185   else
186     {
187       /* Get the next search entry. */
188       if (_tfindnext (dirp-&gt;dd_handle, &amp;(dirp-&gt;dd_dta)))
<span class="line-modified">189     {</span>
<span class="line-modified">190       /* We are off the end or otherwise error.</span>
<span class="line-modified">191          _findnext sets errno to ENOENT if no more file</span>
<span class="line-modified">192          Undo this. */</span>
<span class="line-modified">193       DWORD winerr = GetLastError();</span>
<span class="line-modified">194       if (winerr == ERROR_NO_MORE_FILES)</span>
<span class="line-modified">195         errno = 0;</span>
<span class="line-modified">196       _findclose (dirp-&gt;dd_handle);</span>
<span class="line-modified">197       dirp-&gt;dd_handle = -1;</span>
<span class="line-modified">198       dirp-&gt;dd_stat = -1;</span>
<span class="line-modified">199     }</span>
200       else
<span class="line-modified">201     {</span>
<span class="line-modified">202       /* Update the status to indicate the correct</span>
<span class="line-modified">203        * number. */</span>
<span class="line-modified">204       dirp-&gt;dd_stat++;</span>
<span class="line-modified">205     }</span>
206     }
207 
208   if (dirp-&gt;dd_stat &gt; 0)
209     {
210       /* Successfully got an entry. Everything about the file is
211        * already appropriately filled in except the length of the
212        * file name. */
213       dirp-&gt;dd_dir.d_namlen = _tcslen (dirp-&gt;dd_dta.name);
214       _tcscpy (dirp-&gt;dd_dir.d_name, dirp-&gt;dd_dta.name);
215       return &amp;dirp-&gt;dd_dir;
216     }
217 
218   return (struct _tdirent *) 0;
219 }
220 
221 
222 /*
223  * closedir
224  *
225  * Frees up resources allocated by opendir.
</pre>
<hr />
<pre>
307 _tseekdir (_TDIR * dirp, long lPos)
308 {
309   errno = 0;
310 
311   if (!dirp)
312     {
313       errno = EFAULT;
314       return;
315     }
316 
317   if (lPos &lt; -1)
318     {
319       /* Seeking to an invalid position. */
320       errno = EINVAL;
321       return;
322     }
323   else if (lPos == -1)
324     {
325       /* Seek past end. */
326       if (dirp-&gt;dd_handle != -1)
<span class="line-modified">327     {</span>
<span class="line-modified">328       _findclose (dirp-&gt;dd_handle);</span>
<span class="line-modified">329     }</span>
330       dirp-&gt;dd_handle = -1;
331       dirp-&gt;dd_stat = -1;
332     }
333   else
334     {
335       /* Rewind and read forward to the appropriate index. */
336       _trewinddir (dirp);
337 
338       while ((dirp-&gt;dd_stat &lt; lPos) &amp;&amp; _treaddir (dirp))
<span class="line-modified">339     ;</span>
340     }
341 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * Updated by Jeremy Bettis &lt;jeremy@hksys.com&gt;
 12  * Significantly revised and rewinddir, seekdir and telldir added by Colin
 13  * Peters &lt;colin@fu.is.saga-u.ac.jp&gt;
 14  *
 15  */
 16 
 17 #include &lt;stdlib.h&gt;
 18 #include &lt;errno.h&gt;
 19 #include &lt;string.h&gt;
 20 #include &lt;io.h&gt;
 21 #include &lt;direct.h&gt;
 22 
 23 #include &quot;dirent.h&quot;
 24 
 25 #define WIN32_LEAN_AND_MEAN
 26 #include &lt;windows.h&gt; /* for GetFileAttributes */
 27 
 28 #include &lt;tchar.h&gt;
 29 
 30 #ifdef _UNICODE
<span class="line-modified"> 31 #define _tdirent  _wdirent</span>
<span class="line-modified"> 32 #define _TDIR     _WDIR</span>
<span class="line-modified"> 33 #define _topendir _wopendir</span>
 34 #define _tclosedir  _wclosedir
<span class="line-modified"> 35 #define _treaddir _wreaddir</span>
 36 #define _trewinddir _wrewinddir
<span class="line-modified"> 37 #define _ttelldir _wtelldir</span>
<span class="line-modified"> 38 #define _tseekdir _wseekdir</span>
 39 #else
<span class="line-modified"> 40 #define _tdirent  dirent</span>
<span class="line-modified"> 41 #define _TDIR     DIR</span>
<span class="line-modified"> 42 #define _topendir opendir</span>
 43 #define _tclosedir  closedir
<span class="line-modified"> 44 #define _treaddir readdir</span>
 45 #define _trewinddir rewinddir
<span class="line-modified"> 46 #define _ttelldir telldir</span>
<span class="line-modified"> 47 #define _tseekdir seekdir</span>
 48 #endif
 49 
 50 #define SUFFIX  _T(&quot;*&quot;)
<span class="line-modified"> 51 #define SLASH _T(&quot;\\&quot;)</span>
 52 
 53 
 54 /*
 55  * opendir
 56  *
 57  * Returns a pointer to a DIR structure appropriately filled in to begin
 58  * searching a directory.
 59  */
 60 _TDIR *
 61 _topendir (const _TCHAR *szPath)
 62 {
 63   _TDIR *nd;
 64   unsigned int rc;
 65   _TCHAR szFullPath[MAX_PATH];
 66 
 67   errno = 0;
 68 
 69   if (!szPath)
 70     {
 71       errno = EFAULT;
</pre>
<hr />
<pre>
 82   rc = GetFileAttributes (szPath);
 83   if (rc == (unsigned int)-1)
 84     {
 85       /* call GetLastError for more error info */
 86       errno = ENOENT;
 87       return (_TDIR *) 0;
 88     }
 89   if (!(rc &amp; FILE_ATTRIBUTE_DIRECTORY))
 90     {
 91       /* Error, entry exists but not a directory. */
 92       errno = ENOTDIR;
 93       return (_TDIR *) 0;
 94     }
 95 
 96   /* Make an absolute pathname.  */
 97   _tfullpath (szFullPath, szPath, MAX_PATH);
 98 
 99   /* Allocate enough space to store DIR structure and the complete
100    * directory path given. */
101   nd = (_TDIR *) malloc (sizeof (_TDIR) + (_tcslen(szFullPath) + _tcslen (SLASH) +
<span class="line-modified">102        _tcslen(SUFFIX) + 1) * sizeof(_TCHAR));</span>
103 
104   if (!nd)
105     {
106       /* Error, out of memory. */
107       errno = ENOMEM;
108       return (_TDIR *) 0;
109     }
110 
111   /* Create the search expression. */
112   _tcscpy (nd-&gt;dd_name, szFullPath);
113 
114   /* Add on a slash if the path does not end with one. */
115   if (nd-&gt;dd_name[0] != _T(&#39;\0&#39;) &amp;&amp;
116       nd-&gt;dd_name[_tcslen (nd-&gt;dd_name) - 1] != _T(&#39;/&#39;) &amp;&amp;
117       nd-&gt;dd_name[_tcslen (nd-&gt;dd_name) - 1] != _T(&#39;\\&#39;))
118     {
119       _tcscat (nd-&gt;dd_name, SLASH);
120     }
121 
122   /* Add on the search pattern */
</pre>
<hr />
<pre>
155   /* Check for valid DIR struct. */
156   if (!dirp)
157     {
158       errno = EFAULT;
159       return (struct _tdirent *) 0;
160     }
161 
162   if (dirp-&gt;dd_stat &lt; 0)
163     {
164       /* We have already returned all files in the directory
165        * (or the structure has an invalid dd_stat). */
166       return (struct _tdirent *) 0;
167     }
168   else if (dirp-&gt;dd_stat == 0)
169     {
170       /* We haven&#39;t started the search yet. */
171       /* Start the search */
172       dirp-&gt;dd_handle = _tfindfirst (dirp-&gt;dd_name, &amp;(dirp-&gt;dd_dta));
173 
174       if (dirp-&gt;dd_handle == -1)
<span class="line-modified">175   {</span>
<span class="line-modified">176     /* Whoops! Seems there are no files in that</span>
<span class="line-modified">177      * directory. */</span>
<span class="line-modified">178     dirp-&gt;dd_stat = -1;</span>
<span class="line-modified">179   }</span>
180       else
<span class="line-modified">181   {</span>
<span class="line-modified">182     dirp-&gt;dd_stat = 1;</span>
<span class="line-modified">183   }</span>
184     }
185   else
186     {
187       /* Get the next search entry. */
188       if (_tfindnext (dirp-&gt;dd_handle, &amp;(dirp-&gt;dd_dta)))
<span class="line-modified">189   {</span>
<span class="line-modified">190     /* We are off the end or otherwise error.</span>
<span class="line-modified">191        _findnext sets errno to ENOENT if no more file</span>
<span class="line-modified">192        Undo this. */</span>
<span class="line-modified">193     DWORD winerr = GetLastError();</span>
<span class="line-modified">194     if (winerr == ERROR_NO_MORE_FILES)</span>
<span class="line-modified">195       errno = 0;</span>
<span class="line-modified">196     _findclose (dirp-&gt;dd_handle);</span>
<span class="line-modified">197     dirp-&gt;dd_handle = -1;</span>
<span class="line-modified">198     dirp-&gt;dd_stat = -1;</span>
<span class="line-modified">199   }</span>
200       else
<span class="line-modified">201   {</span>
<span class="line-modified">202     /* Update the status to indicate the correct</span>
<span class="line-modified">203      * number. */</span>
<span class="line-modified">204     dirp-&gt;dd_stat++;</span>
<span class="line-modified">205   }</span>
206     }
207 
208   if (dirp-&gt;dd_stat &gt; 0)
209     {
210       /* Successfully got an entry. Everything about the file is
211        * already appropriately filled in except the length of the
212        * file name. */
213       dirp-&gt;dd_dir.d_namlen = _tcslen (dirp-&gt;dd_dta.name);
214       _tcscpy (dirp-&gt;dd_dir.d_name, dirp-&gt;dd_dta.name);
215       return &amp;dirp-&gt;dd_dir;
216     }
217 
218   return (struct _tdirent *) 0;
219 }
220 
221 
222 /*
223  * closedir
224  *
225  * Frees up resources allocated by opendir.
</pre>
<hr />
<pre>
307 _tseekdir (_TDIR * dirp, long lPos)
308 {
309   errno = 0;
310 
311   if (!dirp)
312     {
313       errno = EFAULT;
314       return;
315     }
316 
317   if (lPos &lt; -1)
318     {
319       /* Seeking to an invalid position. */
320       errno = EINVAL;
321       return;
322     }
323   else if (lPos == -1)
324     {
325       /* Seek past end. */
326       if (dirp-&gt;dd_handle != -1)
<span class="line-modified">327   {</span>
<span class="line-modified">328     _findclose (dirp-&gt;dd_handle);</span>
<span class="line-modified">329   }</span>
330       dirp-&gt;dd_handle = -1;
331       dirp-&gt;dd_stat = -1;
332     }
333   else
334     {
335       /* Rewind and read forward to the appropriate index. */
336       _trewinddir (dirp);
337 
338       while ((dirp-&gt;dd_stat &lt; lPos) &amp;&amp; _treaddir (dirp))
<span class="line-modified">339   ;</span>
340     }
341 }
</pre>
</td>
</tr>
</table>
<center><a href="../../osx/glibconfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="dirent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>