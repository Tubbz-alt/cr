<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../audioconvert/gstaudioconvert.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../volume/gstvolume.c.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -53,11 +53,11 @@</span>
  
  typedef struct
  {
    guint64 offset;
    const guint8 *data;
<span class="udiff-line-modified-removed">-   gint size;</span>
<span class="udiff-line-modified-added">+   guint size;</span>
  } DataScanCtx;
  
  static inline void
  data_scan_ctx_advance (GstTypeFind * tf, DataScanCtx * c, guint bytes_to_skip)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -70,11 +70,11 @@</span>
      c-&gt;size = 0;
    }
  }
  
  static inline gboolean
<span class="udiff-line-modified-removed">- data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, gint min_len)</span>
<span class="udiff-line-modified-added">+ data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, guint min_len)</span>
  {
    const guint8 *data;
    guint64 len;
    guint chunk_len = MAX (DATA_SCAN_CTX_CHUNK_SIZE, min_len);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,10 +110,13 @@</span>
  
  static inline gboolean
  data_scan_ctx_memcmp (GstTypeFind * tf, DataScanCtx * c, guint offset,
      const gchar * data, guint len)
  {
<span class="udiff-line-added">+   if (G_UNLIKELY (offset + len &gt;= G_MAXUINT32))</span>
<span class="udiff-line-added">+     return FALSE;</span>
<span class="udiff-line-added">+ </span>
    if (!data_scan_ctx_ensure_data (tf, c, offset + len))
      return FALSE;
  
    return (memcmp (c-&gt;data + offset, data, len) == 0);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,12 +280,12 @@</span>
  
  static void
  unicode_type_find (GstTypeFind * tf, const GstUnicodeTester * tester,
      guint n_tester, const char *media_type, gboolean require_bom)
  {
<span class="udiff-line-modified-removed">-   size_t n;</span>
<span class="udiff-line-modified-removed">-   gint len = 4;</span>
<span class="udiff-line-modified-added">+   gsize n;</span>
<span class="udiff-line-modified-added">+   gsize len = 4;</span>
    const guint8 *data = gst_type_find_peek (tf, 0, len);
    int prob = -1;
    const gint max_scan_size = 256 * 1024;
    int endianness = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -678,10 +681,25 @@</span>
        xml_check_first_element (tf, &quot;mpd&quot;, 3, FALSE)) {
      gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DASH_CAPS);
    }
  }
  
<span class="udiff-line-added">+ /*** application/xges ****************************************************/</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static GstStaticCaps xges_caps = GST_STATIC_CAPS (&quot;application/xges&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define XGES_CAPS gst_static_caps_get (&amp;xges_caps)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ xges_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   if (xml_check_first_element (tf, &quot;ges&quot;, 3, FALSE)) {</span>
<span class="udiff-line-added">+     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, XGES_CAPS);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /*** application/sdp *********************************************************/
  
  static GstStaticCaps sdp_caps = GST_STATIC_CAPS (&quot;application/sdp&quot;);
  
  #define SDP_CAPS (gst_static_caps_get(&amp;sdp_caps))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1094,11 +1112,11 @@</span>
  aac_type_find (GstTypeFind * tf, gpointer unused)
  {
    DataScanCtx c = { 0, NULL, 0 };
    GstTypeFindProbability best_probability = GST_TYPE_FIND_NONE;
    GstCaps *best_caps = NULL;
<span class="udiff-line-modified-removed">-   guint best_count = 0;</span>
<span class="udiff-line-modified-added">+   gint best_count = 0;</span>
  
    while (c.offset &lt; AAC_AMOUNT) {
      guint snc, len, offset, i;
  
      /* detect adts header or adif header.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1181,11 +1199,11 @@</span>
          len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
              (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
  
          if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
            GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
<span class="udiff-line-modified-removed">-         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
<span class="udiff-line-modified-added">+           gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
          } else {
            offset += len;
            /* find more aac sync to select correctly */
            /* check if there&#39;s a third/fourth/fifth/sixth ADTS frame, if there is a sixth frame, set probability to maximum:100% */
            for (i = 3; i &lt;= 6; i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1233,11 +1251,11 @@</span>
              &quot;mpegversion&quot;, G_TYPE_INT, 4,
              &quot;stream-format&quot;, G_TYPE_STRING, &quot;loas&quot;, NULL);
          best_count = count;
          best_probability = GST_TYPE_FIND_POSSIBLE - 10 + count * 3;
          if (best_probability &gt;= GST_TYPE_FIND_LIKELY)
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-added">+           break;</span>
        }
      } else if (!memcmp (c.data, &quot;ADIF&quot;, 4)) {
        /* ADIF header */
        gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, &quot;audio/mpeg&quot;,
            &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, &quot;mpegversion&quot;, G_TYPE_INT, 4,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1596,14 +1614,14 @@</span>
  
    /* a valid header right at the start makes it more likely
     * that this is actually plain mpeg-1 audio */
    if (prob &gt; 0) {
      data = gst_type_find_peek (tf, 0, 4);       /* use min. frame size? */
<span class="udiff-line-modified-removed">-   if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="udiff-line-modified-removed">-           &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
<span class="udiff-line-modified-added">+     if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="udiff-line-modified-added">+             &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
        prob = MIN (prob + 10, GST_TYPE_FIND_MAXIMUM);
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+     }</span>
    }
  
    if (prob &gt; 0)
      goto suggest;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2468,11 +2486,11 @@</span>
        size = GST_MPEGTS_TYPEFIND_SYNC_SIZE;
      }
  
      /* Have at least MPEGTS_HDR_SIZE bytes at this point */
      if (IS_MPEGTS_HEADER (data)) {
<span class="udiff-line-modified-removed">-       gint p;</span>
<span class="udiff-line-modified-added">+       gsize p;</span>
  
        GST_LOG (&quot;possible mpeg-ts sync at offset %&quot; G_GUINT64_FORMAT, skipped);
  
        for (p = 0; p &lt; G_N_ELEMENTS (pack_sizes); p++) {
          gint found;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2690,11 +2708,11 @@</span>
          pc_type = data &amp; 0x02;
          pb_mode = c.data[1] &amp; 0x20 &gt;&gt; 4;
          if (!pc_type &amp;&amp; pb_mode)
            bad++;
          else
<span class="udiff-line-modified-removed">-         good++;</span>
<span class="udiff-line-modified-added">+           good++;</span>
        } else
          bad++;
  
        /* FIXME: maybe bail out early if we get mostly bad syncs ? */
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2771,17 +2789,17 @@</span>
          } else if (nut == 14 || nut == 20) {
            /* Sometimes we see NAL 14 or 20 without SSPS
             * if dropped into the middle of a stream -
             * just ignore those (don&#39;t add to bad count) */
            if (seen_ssps)
<span class="udiff-line-modified-removed">-           good++;</span>
<span class="udiff-line-modified-added">+             good++;</span>
          } else {
<span class="udiff-line-modified-removed">-         /* reserved */</span>
<span class="udiff-line-modified-removed">-         /* Theoretically these are good, since if they exist in the</span>
<span class="udiff-line-modified-removed">-            stream it merely means that a newer backwards-compatible</span>
<span class="udiff-line-modified-removed">-            h.264 stream.  But we should be identifying that separately. */</span>
<span class="udiff-line-modified-removed">-         bad++;</span>
<span class="udiff-line-modified-added">+           /* reserved */</span>
<span class="udiff-line-modified-added">+           /* Theoretically these are good, since if they exist in the</span>
<span class="udiff-line-modified-added">+              stream it merely means that a newer backwards-compatible</span>
<span class="udiff-line-modified-added">+              h.264 stream.  But we should be identifying that separately. */</span>
<span class="udiff-line-modified-added">+           bad++;</span>
          }
        } else {
          /* unspecified, application specific */
          /* don&#39;t consider these bad */
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2921,11 +2939,11 @@</span>
    DataScanCtx c = { 0, NULL, 0 };
    gboolean seen_seq_at_0 = FALSE;
    gboolean seen_seq = FALSE;
    gboolean seen_gop = FALSE;
    guint64 last_pic_offset = 0;
<span class="udiff-line-modified-removed">-   guint num_pic_headers = 0;</span>
<span class="udiff-line-modified-added">+   gint num_pic_headers = 0;</span>
    gint found = 0;
  
    while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
      if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
        break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3120,11 +3138,11 @@</span>
  static void
  q3gp_type_find (GstTypeFind * tf, gpointer unused)
  {
    const gchar *profile;
    guint32 ftyp_size = 0;
<span class="udiff-line-modified-removed">-   gint offset = 0;</span>
<span class="udiff-line-modified-added">+   guint32 offset = 0;</span>
    const guint8 *data = NULL;
  
    if ((data = gst_type_find_peek (tf, 0, 12)) == NULL) {
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3147,16 +3165,16 @@</span>
      ftyp_size = GST_READ_UINT32_BE (data);
    }
    if ((data = gst_type_find_peek (tf, 0, ftyp_size)) != NULL) {
      for (offset = 16; offset + 4 &lt; ftyp_size; offset += 4) {
        if ((profile = q3gp_type_find_get_profile (data + offset))) {
<span class="udiff-line-modified-removed">-       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="udiff-line-modified-removed">-           &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-added">+         gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="udiff-line-modified-added">+             &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="udiff-line-modified-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
<span class="udiff-line-removed">-   }</span>
  
    return;
  
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3362,12 +3380,12 @@</span>
      if (size + offset &gt;= G_MAXINT64)
        break;
      /* check compatible brands rather than ever expaning major brands above */
      if ((STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0) &amp;&amp; (size &gt;= 16)) {
        data = gst_type_find_peek (tf, offset, size);
<span class="udiff-line-modified-removed">-         if (data == NULL)</span>
<span class="udiff-line-modified-removed">-           goto done;</span>
<span class="udiff-line-modified-added">+       if (data == NULL)</span>
<span class="udiff-line-modified-added">+         goto done;</span>
        new_offset = 12;
        while (new_offset + 4 &lt;= size) {
          if (STRNCMP (&amp;data[new_offset], &quot;isom&quot;, 4) == 0 ||
              STRNCMP (&amp;data[new_offset], &quot;dash&quot;, 4) == 0 ||
              STRNCMP (&amp;data[new_offset], &quot;avc1&quot;, 4) == 0 ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3599,11 +3617,11 @@</span>
      if ((memcmp (data, &quot;AMF&quot;, 3) == 0) &amp;&amp; (data[3] &gt; 10) &amp;&amp; (data[3] &lt; 14)) {
        mod_type = &quot;dsmi-amf&quot;;
        probability = GST_TYPE_FIND_MAXIMUM;
        goto suggest_audio_mod_caps;
      }
<span class="udiff-line-modified-removed">-         /* IT */</span>
<span class="udiff-line-modified-added">+     /* IT */</span>
      if (memcmp (data, &quot;IMPM&quot;, 4) == 0) {
        mod_type = &quot;it&quot;;
        probability = GST_TYPE_FIND_MAXIMUM;
        goto suggest_audio_mod_caps;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3629,17 +3647,17 @@</span>
      if (memcmp (data, &quot;DDMF&quot;, 4) == 0) {
        mod_type = &quot;dmf&quot;;
        probability = GST_TYPE_FIND_MAXIMUM;
        goto suggest_audio_mod_caps;
      }
<span class="udiff-line-modified-removed">-         /* MED */</span>
<span class="udiff-line-modified-added">+     /* MED */</span>
      if ((memcmp (data, &quot;MMD0&quot;, 4) == 0) || (memcmp (data, &quot;MMD1&quot;, 4) == 0)) {
        mod_type = &quot;med&quot;;
        probability = GST_TYPE_FIND_MAXIMUM;
        goto suggest_audio_mod_caps;
      }
<span class="udiff-line-modified-removed">-         /* MTM */</span>
<span class="udiff-line-modified-added">+     /* MTM */</span>
      if (memcmp (data, &quot;MTM&quot;, 3) == 0) {
        mod_type = &quot;mtm&quot;;
        probability = GST_TYPE_FIND_MAXIMUM;
        goto suggest_audio_mod_caps;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3698,11 +3716,11 @@</span>
      /* UMX */
      if (memcmp (data, &quot;\xC1\x83\x2A\x9E&quot;, 4) == 0) {
        mod_type = &quot;umx&quot;;
        probability = GST_TYPE_FIND_POSSIBLE;
        goto suggest_audio_mod_caps;
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+     }</span>
    }
    /* FAR (Farandole) (secondary detection) */
    if ((data = gst_type_find_peek (tf, 44, 3)) != NULL) {
      if (memcmp (data, &quot;\x0D\x0A\x1A&quot;, 3) == 0) {
        mod_type = &quot;far&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3812,50 +3830,50 @@</span>
      return;
    }
  
    length = gst_type_find_get_length (tf);
  
<span class="udiff-line-modified-removed">-     /* try detecting the charset */</span>
<span class="udiff-line-modified-added">+   /* try detecting the charset */</span>
    data = gst_type_find_peek (tf, 0, 3);
  
<span class="udiff-line-modified-removed">-     if (data == NULL)</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-added">+   if (data == NULL)</span>
<span class="udiff-line-modified-added">+     return;</span>
  
<span class="udiff-line-modified-removed">-     /* look for a possible BOM */</span>
<span class="udiff-line-modified-added">+   /* look for a possible BOM */</span>
    if (data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF)
      utf8_bom_detected = TRUE;
    else if (data[0] == 0xFF &amp;&amp; data[1] == 0xFE)
      data_endianness = G_LITTLE_ENDIAN;
    else if (data[0] == 0xFE &amp;&amp; data[1] == 0xFF)
      data_endianness = G_BIG_ENDIAN;
    else
      return;
  
<span class="udiff-line-modified-removed">-       /* try a default that should be enough */</span>
<span class="udiff-line-modified-removed">-       if (length == 0)</span>
<span class="udiff-line-modified-removed">-         length = 512;</span>
<span class="udiff-line-modified-added">+   /* try a default that should be enough */</span>
<span class="udiff-line-modified-added">+   if (length == 0)</span>
<span class="udiff-line-modified-added">+     length = 512;</span>
    else if (length &lt; 64)
      return;
    else                          /* the first few bytes should be enough */
      length = MIN (1024, length);
  
<span class="udiff-line-modified-removed">-       data = gst_type_find_peek (tf, 0, length);</span>
<span class="udiff-line-modified-added">+   data = gst_type_find_peek (tf, 0, length);</span>
  
    if (data == NULL)
      return;
  
<span class="udiff-line-modified-removed">-         /* skip the BOM */</span>
<span class="udiff-line-modified-removed">-         data += 2;</span>
<span class="udiff-line-modified-removed">-         length -= 2;</span>
<span class="udiff-line-modified-added">+   /* skip the BOM */</span>
<span class="udiff-line-modified-added">+   data += 2;</span>
<span class="udiff-line-modified-added">+   length -= 2;</span>
  
    if (utf8_bom_detected) {
      /* skip last byte of the BOM */
      data++;
      length--;
  
      if (xml_check_first_element_from_data (data, length,
<span class="udiff-line-modified-removed">-                   &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
<span class="udiff-line-modified-added">+             &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
        gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
    } else {
      length = GST_ROUND_DOWN_2 (length);
  
      /* convert to native endian UTF-16 */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3865,14 +3883,14 @@</span>
      utf8 = g_utf16_to_utf8 (utf16_ne, length / 2, &amp;n_read, &amp;size, NULL);
      if (utf8 != NULL &amp;&amp; n_read &gt; 0) {
        if (xml_check_first_element_from_data ((const guint8 *) utf8, size,
                &quot;SmoothStreamingMedia&quot;, 20, TRUE))
          gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     g_free (utf8);</span>
<span class="udiff-line-removed">-       }</span>
      }
<span class="udiff-line-added">+     g_free (utf8);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  /*** image/jpeg ***/
  
  #define JPEG_MARKER_IS_START_OF_FRAME(x) \
      ((x)&gt;=0xc0 &amp;&amp; (x) &lt;= 0xcf &amp;&amp; (x)!=0xc4 &amp;&amp; (x)!=0xc8 &amp;&amp; (x)!=0xcc)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4359,34 +4377,39 @@</span>
  ebml_parse_chunk (GstTypeFind * tf, DataScanCtx * ctx, guint32 chunk_id,
      guint chunk_size, GstMatroskaInfo * info, guint depth)
  {                               /* FIXME: make sure input size is clipped to 32 bit */
    static const gchar SPACES[] = &quot;                &quot;;
    DataScanCtx c = *ctx;
<span class="udiff-line-modified-removed">-   guint64 element_size;</span>
<span class="udiff-line-modified-added">+   guint64 element_size = 0;</span>
    guint32 id, hdr_len;
  
    if (depth &gt;= 8)               /* keep SPACES large enough for depth */
      return FALSE;
  
    while (chunk_size &gt; 0) {
      if (c.offset &gt; EBML_MAX_LEN || !data_scan_ctx_ensure_data (tf, &amp;c, 64))
<span class="udiff-line-modified-removed">-     return FALSE;</span>
<span class="udiff-line-modified-added">+       return FALSE;</span>
  
      hdr_len = ebml_read_chunk_header (tf, &amp;c, chunk_size, &amp;id, &amp;element_size);
      if (hdr_len == 0)
<span class="udiff-line-modified-removed">-     return FALSE;</span>
<span class="udiff-line-modified-added">+       return FALSE;</span>
  
      g_assert (hdr_len &lt;= chunk_size);
      chunk_size -= hdr_len;
  
      if (element_size &gt; chunk_size)
<span class="udiff-line-modified-removed">-     return FALSE;</span>
<span class="udiff-line-modified-added">+       return FALSE;</span>
  
      GST_DEBUG (&quot;%s %08x, size %&quot; G_GUINT64_FORMAT &quot; / %&quot; G_GUINT64_FORMAT,
          SPACES + sizeof (SPACES) - 1 - (2 * depth), id, element_size,
          hdr_len + element_size);
  
<span class="udiff-line-added">+     if (element_size &gt;= G_MAXUINT32) {</span>
<span class="udiff-line-added">+       GST_DEBUG (&quot;Chunk too big for typefinding&quot;);</span>
<span class="udiff-line-added">+       return FALSE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if (!data_scan_ctx_ensure_data (tf, &amp;c, element_size)) {
        GST_DEBUG (&quot;not enough data&quot;);
        return FALSE;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4399,11 +4422,11 @@</span>
          break;
        case MATROSKA_SEGMENT:
          GST_LOG (&quot;parsing segment&quot;);
          ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
          GST_LOG (&quot;parsed segment, done&quot;);
<span class="udiff-line-modified-removed">-   return FALSE;</span>
<span class="udiff-line-modified-added">+         return FALSE;</span>
        case MATROSKA_TRACKS:
          GST_LOG (&quot;parsing tracks&quot;);
          info-&gt;tracks_ok =
              ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
          GST_LOG (&quot;parsed tracks: %s, done (after %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5236,10 +5259,32 @@</span>
        gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DIRAC_CAPS);
      }
    }
  }
  
<span class="udiff-line-added">+ /*** audio/x-tap-tap ***/</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,</span>
<span class="udiff-line-added">+  * as it is only possible to register one typefind factory per &#39;name&#39;</span>
<span class="udiff-line-added">+  * (which is in this case the caps), and the first one would be replaced by</span>
<span class="udiff-line-added">+  * the second one. */</span>
<span class="udiff-line-added">+ static GstStaticCaps tap_caps = GST_STATIC_CAPS (&quot;audio/x-tap-tap&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define TAP_CAPS (gst_static_caps_get(&amp;tap_caps))</span>
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ tap_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   const guint8 *data = gst_type_find_peek (tf, 0, 16);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (data) {</span>
<span class="udiff-line-added">+     if (memcmp (data, &quot;C64-TAPE-RAW&quot;, 12) == 0</span>
<span class="udiff-line-added">+         || memcmp (data, &quot;C16-TAPE-RAW&quot;, 12) == 0) {</span>
<span class="udiff-line-added">+       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TAP_CAPS);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*** video/vivo ***/
  
  static GstStaticCaps vivo_caps = GST_STATIC_CAPS (&quot;video/vivo&quot;);
  
  #define VIVO_CAPS gst_static_caps_get(&amp;vivo_caps)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5613,10 +5658,36 @@</span>
    }
  
    g_free (str);
  }
  
<span class="udiff-line-added">+ /*** application/x-mcc ***/</span>
<span class="udiff-line-added">+ static GstStaticCaps mcc_caps = GST_STATIC_CAPS (&quot;application/x-mcc&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define MCC_CAPS gst_static_caps_get(&amp;mcc_caps)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ mcc_type_find (GstTypeFind * tf, gpointer private)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   const guint8 *data;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   data = gst_type_find_peek (tf, 0, 31);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (data == NULL)</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* MCC files always start with this followed by the version */</span>
<span class="udiff-line-added">+   if (memcmp (data, &quot;File Format=MacCaption_MCC V&quot;, 28) != 0 ||</span>
<span class="udiff-line-added">+       !g_ascii_isdigit (data[28]) || data[29] != &#39;.&#39; ||</span>
<span class="udiff-line-added">+       !g_ascii_isdigit (data[30])) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="udiff-line-added">+       &quot;application/x-mcc&quot;, &quot;version&quot;, G_TYPE_INT, data[28] - &#39;0&#39;, NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*** video/x-pva ***/
  
  static GstStaticCaps pva_caps = GST_STATIC_CAPS (&quot;video/x-pva&quot;);
  
  #define PVA_CAPS gst_static_caps_get(&amp;pva_caps)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5783,10 +5854,15 @@</span>
    TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-vcd&quot;, GST_RANK_PRIMARY,
        &quot;dat&quot;, &quot;\000\377\377\377\377\377\377\377\377\377\377\000&quot;, 12,
        GST_TYPE_FIND_MAXIMUM);
    TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-imelody&quot;, GST_RANK_PRIMARY,
        &quot;imy,ime,imelody&quot;, &quot;BEGIN:IMELODY&quot;, 13, GST_TYPE_FIND_MAXIMUM);
<span class="udiff-line-added">+   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-scc&quot;, GST_RANK_PRIMARY,</span>
<span class="udiff-line-added">+       &quot;scc&quot;, &quot;Scenarist_SCC V1.0&quot;, 18, GST_TYPE_FIND_MAXIMUM);</span>
<span class="udiff-line-added">+   TYPE_FIND_REGISTER (plugin, &quot;application/x-mcc&quot;, GST_RANK_PRIMARY,</span>
<span class="udiff-line-added">+       mcc_type_find, &quot;mcc&quot;, MCC_CAPS, NULL, NULL);</span>
<span class="udiff-line-added">+ </span>
  #if 0
    TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-smoke&quot;, GST_RANK_PRIMARY,
        NULL, &quot;\x80smoke\x00\x01\x00&quot;, 6, GST_TYPE_FIND_MAXIMUM);
  #endif
    TYPE_FIND_REGISTER (plugin, &quot;audio/midi&quot;, GST_RANK_PRIMARY, mid_type_find,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5861,10 +5937,12 @@</span>
    TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-pn-realaudio&quot;,
        GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.ra\375&quot;, 4,
        GST_TYPE_FIND_MAXIMUM);
    TYPE_FIND_REGISTER (plugin, &quot;application/x-shockwave-flash&quot;,
        GST_RANK_SECONDARY, swf_type_find, &quot;swf,swfl&quot;, SWF_CAPS, NULL, NULL);
<span class="udiff-line-added">+   TYPE_FIND_REGISTER (plugin, &quot;application/xges&quot;,</span>
<span class="udiff-line-added">+       GST_RANK_PRIMARY, xges_type_find, &quot;xges&quot;, XGES_CAPS, NULL, NULL);</span>
    TYPE_FIND_REGISTER (plugin, &quot;application/dash+xml&quot;,
        GST_RANK_PRIMARY, dash_mpd_type_find, &quot;mpd,MPD&quot;, DASH_CAPS, NULL, NULL);
    TYPE_FIND_REGISTER (plugin, &quot;application/vnd.ms-sstr+xml&quot;,
        GST_RANK_PRIMARY, mss_manifest_type_find, NULL, MSS_MANIFEST_CAPS, NULL,
        NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6084,15 +6162,20 @@</span>
  
    TYPE_FIND_REGISTER (plugin, &quot;audio/audible&quot;, GST_RANK_MARGINAL,
        aa_type_find, &quot;aa,aax&quot;, AA_CAPS, NULL, NULL);
  #endif // GSTREAMER_LITE
  
<span class="udiff-line-added">+   TYPE_FIND_REGISTER (plugin, &quot;audio/x-tap-tap&quot;, GST_RANK_PRIMARY,</span>
<span class="udiff-line-added">+       tap_type_find, &quot;tap&quot;, TAP_CAPS, NULL, NULL);</span>
<span class="udiff-line-added">+   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-tap-dmp&quot;,</span>
<span class="udiff-line-added">+       GST_RANK_SECONDARY, &quot;dmp&quot;, &quot;DC2N-TAP-RAW&quot;, 12, GST_TYPE_FIND_LIKELY);</span>
<span class="udiff-line-added">+ </span>
    return TRUE;
  }
  
  #ifndef GSTREAMER_LITE
  GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
      GST_VERSION_MINOR,
      typefindfunctions,
      &quot;default typefind functions&quot;,
      plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-added">+ #endif // GSTREAMER_LITE</span>
</pre>
<center><a href="../audioconvert/gstaudioconvert.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../volume/gstvolume.c.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>