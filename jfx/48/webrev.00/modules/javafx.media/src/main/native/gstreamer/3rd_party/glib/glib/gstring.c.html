<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;stdlib.h&gt;
  33 #include &lt;stdio.h&gt;
  34 #include &lt;string.h&gt;
  35 #include &lt;ctype.h&gt;
  36 
  37 #include &quot;gstring.h&quot;
  38 
  39 #include &quot;gprintf.h&quot;
  40 
  41 
  42 /**
  43  * SECTION:strings
  44  * @title: Strings
  45  * @short_description: text buffers which grow automatically
  46  *     as text is added
  47  *
  48  * A #GString is an object that handles the memory management of a C
  49  * string for you.  The emphasis of #GString is on text, typically
  50  * UTF-8.  Crucially, the &quot;str&quot; member of a #GString is guaranteed to
  51  * have a trailing nul character, and it is therefore always safe to
  52  * call functions such as strchr() or g_strdup() on it.
  53  *
  54  * However, a #GString can also hold arbitrary binary data, because it
  55  * has a &quot;len&quot; member, which includes any possible embedded nul
  56  * characters in the data.  Conceptually then, #GString is like a
  57  * #GByteArray with the addition of many convenience methods for text,
  58  * and a guaranteed nul terminator.
  59  */
  60 
  61 /**
  62  * GString:
  63  * @str: points to the character data. It may move as text is added.
  64  *   The @str field is null-terminated and so
  65  *   can be used as an ordinary C string.
  66  * @len: contains the length of the string, not including the
  67  *   terminating nul byte.
  68  * @allocated_len: the number of bytes that can be stored in the
  69  *   string before it needs to be reallocated. May be larger than @len.
  70  *
  71  * The GString struct contains the public fields of a GString.
  72  */
  73 
  74 
  75 #define MY_MAXSIZE ((gsize)-1)
  76 
  77 static inline gsize
  78 nearest_power (gsize base, gsize num)
  79 {
  80   if (num &gt; MY_MAXSIZE / 2)
  81     {
  82       return MY_MAXSIZE;
  83     }
  84   else
  85     {
  86       gsize n = base;
  87 
  88       while (n &lt; num)
  89         n &lt;&lt;= 1;
  90 
  91       return n;
  92     }
  93 }
  94 
  95 static void
  96 g_string_maybe_expand (GString *string,
  97                        gsize    len)
  98 {
  99   if (string-&gt;len + len &gt;= string-&gt;allocated_len)
 100     {
 101       string-&gt;allocated_len = nearest_power (1, string-&gt;len + len + 1);
 102       string-&gt;str = g_realloc (string-&gt;str, string-&gt;allocated_len);
 103     }
 104 }
 105 
 106 /**
 107  * g_string_sized_new:
 108  * @dfl_size: the default size of the space allocated to
 109  *     hold the string
 110  *
 111  * Creates a new #GString, with enough space for @dfl_size
 112  * bytes. This is useful if you are going to add a lot of
 113  * text to the string and don&#39;t want it to be reallocated
 114  * too often.
 115  *
 116  * Returns: the new #GString
 117  */
 118 GString *
 119 g_string_sized_new (gsize dfl_size)
 120 {
 121   GString *string = g_slice_new (GString);
 122 #ifdef GSTREAMER_LITE
 123   if (string == NULL) {
 124     return NULL;
 125   }
 126 #endif // GSTREAMER_LITE
 127 
 128   string-&gt;allocated_len = 0;
 129   string-&gt;len   = 0;
 130   string-&gt;str   = NULL;
 131 
 132   g_string_maybe_expand (string, MAX (dfl_size, 2));
 133   string-&gt;str[0] = 0;
 134 
 135   return string;
 136 }
 137 
 138 /**
 139  * g_string_new:
 140  * @init: (nullable): the initial text to copy into the string, or %NULL to
 141  * start with an empty string
 142  *
 143  * Creates a new #GString, initialized with the given string.
 144  *
 145  * Returns: the new #GString
 146  */
 147 GString *
 148 g_string_new (const gchar *init)
 149 {
 150   GString *string;
 151 
 152   if (init == NULL || *init == &#39;\0&#39;)
 153     string = g_string_sized_new (2);
 154   else
 155     {
 156       gint len;
 157 
 158       len = strlen (init);
 159       string = g_string_sized_new (len + 2);
 160 
 161       g_string_append_len (string, init, len);
 162     }
 163 
 164   return string;
 165 }
 166 
 167 /**
 168  * g_string_new_len:
 169  * @init: initial contents of the string
 170  * @len: length of @init to use
 171  *
 172  * Creates a new #GString with @len bytes of the @init buffer.
 173  * Because a length is provided, @init need not be nul-terminated,
 174  * and can contain embedded nul bytes.
 175  *
 176  * Since this function does not stop at nul bytes, it is the caller&#39;s
 177  * responsibility to ensure that @init has at least @len addressable
 178  * bytes.
 179  *
 180  * Returns: a new #GString
 181  */
 182 GString *
 183 g_string_new_len (const gchar *init,
 184                   gssize       len)
 185 {
 186   GString *string;
 187 
 188   if (len &lt; 0)
 189     return g_string_new (init);
 190   else
 191     {
 192       string = g_string_sized_new (len);
 193 
 194       if (init)
 195         g_string_append_len (string, init, len);
 196 
 197       return string;
 198     }
 199 }
 200 
 201 /**
 202  * g_string_free:
 203  * @string: (transfer full): a #GString
 204  * @free_segment: if %TRUE, the actual character data is freed as well
 205  *
 206  * Frees the memory allocated for the #GString.
 207  * If @free_segment is %TRUE it also frees the character data.  If
 208  * it&#39;s %FALSE, the caller gains ownership of the buffer and must
 209  * free it after use with g_free().
 210  *
 211  * Returns: (nullable): the character data of @string
 212  *          (i.e. %NULL if @free_segment is %TRUE)
 213  */
 214 gchar *
 215 g_string_free (GString  *string,
 216                gboolean  free_segment)
 217 {
 218   gchar *segment;
 219 
 220   g_return_val_if_fail (string != NULL, NULL);
 221 
 222   if (free_segment)
 223     {
 224       g_free (string-&gt;str);
 225       segment = NULL;
 226     }
 227   else
 228     segment = string-&gt;str;
 229 
 230   g_slice_free (GString, string);
 231 
 232   return segment;
 233 }
 234 
 235 /**
 236  * g_string_free_to_bytes:
 237  * @string: (transfer full): a #GString
 238  *
 239  * Transfers ownership of the contents of @string to a newly allocated
 240  * #GBytes.  The #GString structure itself is deallocated, and it is
 241  * therefore invalid to use @string after invoking this function.
 242  *
 243  * Note that while #GString ensures that its buffer always has a
 244  * trailing nul character (not reflected in its &quot;len&quot;), the returned
 245  * #GBytes does not include this extra nul; i.e. it has length exactly
 246  * equal to the &quot;len&quot; member.
 247  *
 248  * Returns: (transfer full): A newly allocated #GBytes containing contents of @string; @string itself is freed
 249  * Since: 2.34
 250  */
 251 GBytes*
 252 g_string_free_to_bytes (GString *string)
 253 {
 254   gsize len;
 255   gchar *buf;
 256 
 257   g_return_val_if_fail (string != NULL, NULL);
 258 
 259   len = string-&gt;len;
 260 
 261   buf = g_string_free (string, FALSE);
 262 
 263   return g_bytes_new_take (buf, len);
 264 }
 265 
 266 /**
 267  * g_string_equal:
 268  * @v: a #GString
 269  * @v2: another #GString
 270  *
 271  * Compares two strings for equality, returning %TRUE if they are equal.
 272  * For use with #GHashTable.
 273  *
 274  * Returns: %TRUE if the strings are the same length and contain the
 275  *     same bytes
 276  */
 277 gboolean
 278 g_string_equal (const GString *v,
 279                 const GString *v2)
 280 {
 281   gchar *p, *q;
 282   GString *string1 = (GString *) v;
 283   GString *string2 = (GString *) v2;
 284   gsize i = string1-&gt;len;
 285 
 286   if (i != string2-&gt;len)
 287     return FALSE;
 288 
 289   p = string1-&gt;str;
 290   q = string2-&gt;str;
 291   while (i)
 292     {
 293       if (*p != *q)
 294         return FALSE;
 295       p++;
 296       q++;
 297       i--;
 298     }
 299   return TRUE;
 300 }
 301 
 302 /**
 303  * g_string_hash:
 304  * @str: a string to hash
 305  *
 306  * Creates a hash code for @str; for use with #GHashTable.
 307  *
 308  * Returns: hash code for @str
 309  */
 310 guint
 311 g_string_hash (const GString *str)
 312 {
 313   const gchar *p = str-&gt;str;
 314   gsize n = str-&gt;len;
 315   guint h = 0;
 316 
 317   /* 31 bit hash function */
 318   while (n--)
 319     {
 320       h = (h &lt;&lt; 5) - h + *p;
 321       p++;
 322     }
 323 
 324   return h;
 325 }
 326 
 327 /**
 328  * g_string_assign:
 329  * @string: the destination #GString. Its current contents
 330  *          are destroyed.
 331  * @rval: the string to copy into @string
 332  *
 333  * Copies the bytes from a string into a #GString,
 334  * destroying any previous contents. It is rather like
 335  * the standard strcpy() function, except that you do not
 336  * have to worry about having enough space to copy the string.
 337  *
 338  * Returns: (transfer none): @string
 339  */
 340 GString *
 341 g_string_assign (GString     *string,
 342                  const gchar *rval)
 343 {
 344   g_return_val_if_fail (string != NULL, NULL);
 345   g_return_val_if_fail (rval != NULL, string);
 346 
 347   /* Make sure assigning to itself doesn&#39;t corrupt the string. */
 348   if (string-&gt;str != rval)
 349     {
 350       /* Assigning from substring should be ok, since
 351        * g_string_truncate() does not reallocate.
 352        */
 353       g_string_truncate (string, 0);
 354       g_string_append (string, rval);
 355     }
 356 
 357   return string;
 358 }
 359 
 360 /**
 361  * g_string_truncate:
 362  * @string: a #GString
 363  * @len: the new size of @string
 364  *
 365  * Cuts off the end of the GString, leaving the first @len bytes.
 366  *
 367  * Returns: (transfer none): @string
 368  */
 369 GString *
 370 g_string_truncate (GString *string,
 371                    gsize    len)
 372 {
 373   g_return_val_if_fail (string != NULL, NULL);
 374 
 375   string-&gt;len = MIN (len, string-&gt;len);
 376   string-&gt;str[string-&gt;len] = 0;
 377 
 378   return string;
 379 }
 380 
 381 /**
 382  * g_string_set_size:
 383  * @string: a #GString
 384  * @len: the new length
 385  *
 386  * Sets the length of a #GString. If the length is less than
 387  * the current length, the string will be truncated. If the
 388  * length is greater than the current length, the contents
 389  * of the newly added area are undefined. (However, as
 390  * always, string-&gt;str[string-&gt;len] will be a nul byte.)
 391  *
 392  * Returns: (transfer none): @string
 393  */
 394 GString *
 395 g_string_set_size (GString *string,
 396                    gsize    len)
 397 {
 398   g_return_val_if_fail (string != NULL, NULL);
 399 
 400   if (len &gt;= string-&gt;allocated_len)
 401     g_string_maybe_expand (string, len - string-&gt;len);
 402 
 403   string-&gt;len = len;
 404   string-&gt;str[len] = 0;
 405 
 406   return string;
 407 }
 408 
 409 /**
 410  * g_string_insert_len:
 411  * @string: a #GString
 412  * @pos: position in @string where insertion should
 413  *       happen, or -1 for at the end
 414  * @val: bytes to insert
 415  * @len: number of bytes of @val to insert, or -1 for all of @val
 416  *
 417  * Inserts @len bytes of @val into @string at @pos.
 418  *
 419  * If @len is positive, @val may contain embedded nuls and need
 420  * not be nul-terminated. It is the caller&#39;s responsibility to
 421  * ensure that @val has at least @len addressable bytes.
 422  *
 423  * If @len is negative, @val must be nul-terminated and @len
 424  * is considered to request the entire string length.
 425  *
 426  * If @pos is -1, bytes are inserted at the end of the string.
 427  *
 428  * Returns: (transfer none): @string
 429  */
 430 GString *
 431 g_string_insert_len (GString     *string,
 432                      gssize       pos,
 433                      const gchar *val,
 434                      gssize       len)
 435 {
 436   gsize len_unsigned, pos_unsigned;
 437 
 438   g_return_val_if_fail (string != NULL, NULL);
 439   g_return_val_if_fail (len == 0 || val != NULL, string);
 440 
 441   if (len == 0)
 442     return string;
 443 
 444   if (len &lt; 0)
 445     len = strlen (val);
 446   len_unsigned = len;
 447 
 448   if (pos &lt; 0)
 449     pos_unsigned = string-&gt;len;
 450   else
 451     {
 452       pos_unsigned = pos;
 453       g_return_val_if_fail (pos_unsigned &lt;= string-&gt;len, string);
 454     }
 455 
 456   /* Check whether val represents a substring of string.
 457    * This test probably violates chapter and verse of the C standards,
 458    * since &quot;&gt;=&quot; and &quot;&lt;=&quot; are only valid when val really is a substring.
 459    * In practice, it will work on modern archs.
 460    */
 461   if (G_UNLIKELY (val &gt;= string-&gt;str &amp;&amp; val &lt;= string-&gt;str + string-&gt;len))
 462     {
 463       gsize offset = val - string-&gt;str;
 464       gsize precount = 0;
 465 
 466       g_string_maybe_expand (string, len_unsigned);
 467       val = string-&gt;str + offset;
 468       /* At this point, val is valid again.  */
 469 
 470       /* Open up space where we are going to insert.  */
 471       if (pos_unsigned &lt; string-&gt;len)
 472         memmove (string-&gt;str + pos_unsigned + len_unsigned,
 473                  string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);
 474 
 475       /* Move the source part before the gap, if any.  */
 476       if (offset &lt; pos_unsigned)
 477         {
 478           precount = MIN (len_unsigned, pos_unsigned - offset);
 479           memcpy (string-&gt;str + pos_unsigned, val, precount);
 480         }
 481 
 482       /* Move the source part after the gap, if any.  */
 483       if (len_unsigned &gt; precount)
 484         memcpy (string-&gt;str + pos_unsigned + precount,
 485                 val + /* Already moved: */ precount +
 486                       /* Space opened up: */ len_unsigned,
 487                 len_unsigned - precount);
 488     }
 489   else
 490     {
 491       g_string_maybe_expand (string, len_unsigned);
 492 
 493       /* If we aren&#39;t appending at the end, move a hunk
 494        * of the old string to the end, opening up space
 495        */
 496       if (pos_unsigned &lt; string-&gt;len)
 497         memmove (string-&gt;str + pos_unsigned + len_unsigned,
 498                  string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);
 499 
 500       /* insert the new string */
 501       if (len_unsigned == 1)
 502         string-&gt;str[pos_unsigned] = *val;
 503       else
 504         memcpy (string-&gt;str + pos_unsigned, val, len_unsigned);
 505     }
 506 
 507   string-&gt;len += len_unsigned;
 508 
 509   string-&gt;str[string-&gt;len] = 0;
 510 
 511   return string;
 512 }
 513 
 514 #define SUB_DELIM_CHARS  &quot;!$&amp;&#39;()*+,;=&quot;
 515 
 516 static gboolean
 517 is_valid (char        c,
 518           const char *reserved_chars_allowed)
 519 {
 520   if (g_ascii_isalnum (c) ||
 521       c == &#39;-&#39; ||
 522       c == &#39;.&#39; ||
 523       c == &#39;_&#39; ||
 524       c == &#39;~&#39;)
 525     return TRUE;
 526 
 527   if (reserved_chars_allowed &amp;&amp;
 528       strchr (reserved_chars_allowed, c) != NULL)
 529     return TRUE;
 530 
 531   return FALSE;
 532 }
 533 
 534 static gboolean
 535 gunichar_ok (gunichar c)
 536 {
 537   return
 538     (c != (gunichar) -2) &amp;&amp;
 539     (c != (gunichar) -1);
 540 }
 541 
 542 /**
 543  * g_string_append_uri_escaped:
 544  * @string: a #GString
 545  * @unescaped: a string
 546  * @reserved_chars_allowed: a string of reserved characters allowed
 547  *     to be used, or %NULL
 548  * @allow_utf8: set %TRUE if the escaped string may include UTF8 characters
 549  *
 550  * Appends @unescaped to @string, escaped any characters that
 551  * are reserved in URIs using URI-style escape sequences.
 552  *
 553  * Returns: (transfer none): @string
 554  *
 555  * Since: 2.16
 556  */
 557 GString *
 558 g_string_append_uri_escaped (GString     *string,
 559                              const gchar *unescaped,
 560                              const gchar *reserved_chars_allowed,
 561                              gboolean     allow_utf8)
 562 {
 563   unsigned char c;
 564   const gchar *end;
 565   static const gchar hex[16] = &quot;0123456789ABCDEF&quot;;
 566 
 567   g_return_val_if_fail (string != NULL, NULL);
 568   g_return_val_if_fail (unescaped != NULL, NULL);
 569 
 570   end = unescaped + strlen (unescaped);
 571 
 572   while ((c = *unescaped) != 0)
 573     {
 574       if (c &gt;= 0x80 &amp;&amp; allow_utf8 &amp;&amp;
 575           gunichar_ok (g_utf8_get_char_validated (unescaped, end - unescaped)))
 576         {
 577           int len = g_utf8_skip [c];
 578           g_string_append_len (string, unescaped, len);
 579           unescaped += len;
 580         }
 581       else if (is_valid (c, reserved_chars_allowed))
 582         {
 583           g_string_append_c (string, c);
 584           unescaped++;
 585         }
 586       else
 587         {
 588           g_string_append_c (string, &#39;%&#39;);
 589           g_string_append_c (string, hex[((guchar)c) &gt;&gt; 4]);
 590           g_string_append_c (string, hex[((guchar)c) &amp; 0xf]);
 591           unescaped++;
 592         }
 593     }
 594 
 595   return string;
 596 }
 597 
 598 /**
 599  * g_string_append:
 600  * @string: a #GString
 601  * @val: the string to append onto the end of @string
 602  *
 603  * Adds a string onto the end of a #GString, expanding
 604  * it if necessary.
 605  *
 606  * Returns: (transfer none): @string
 607  */
 608 GString *
 609 g_string_append (GString     *string,
 610                  const gchar *val)
 611 {
 612   return g_string_insert_len (string, -1, val, -1);
 613 }
 614 
 615 /**
 616  * g_string_append_len:
 617  * @string: a #GString
 618  * @val: bytes to append
 619  * @len: number of bytes of @val to use, or -1 for all of @val
 620  *
 621  * Appends @len bytes of @val to @string.
 622  *
 623  * If @len is positive, @val may contain embedded nuls and need
 624  * not be nul-terminated. It is the caller&#39;s responsibility to
 625  * ensure that @val has at least @len addressable bytes.
 626  *
 627  * If @len is negative, @val must be nul-terminated and @len
 628  * is considered to request the entire string length. This
 629  * makes g_string_append_len() equivalent to g_string_append().
 630  *
 631  * Returns: (transfer none): @string
 632  */
 633 GString *
 634 g_string_append_len (GString     *string,
 635                      const gchar *val,
 636                      gssize       len)
 637 {
 638   return g_string_insert_len (string, -1, val, len);
 639 }
 640 
 641 /**
 642  * g_string_append_c:
 643  * @string: a #GString
 644  * @c: the byte to append onto the end of @string
 645  *
 646  * Adds a byte onto the end of a #GString, expanding
 647  * it if necessary.
 648  *
 649  * Returns: (transfer none): @string
 650  */
 651 #undef g_string_append_c
 652 GString *
 653 g_string_append_c (GString *string,
 654                    gchar    c)
 655 {
 656   g_return_val_if_fail (string != NULL, NULL);
 657 
 658   return g_string_insert_c (string, -1, c);
 659 }
 660 
 661 /**
 662  * g_string_append_unichar:
 663  * @string: a #GString
 664  * @wc: a Unicode character
 665  *
 666  * Converts a Unicode character into UTF-8, and appends it
 667  * to the string.
 668  *
 669  * Returns: (transfer none): @string
 670  */
 671 GString *
 672 g_string_append_unichar (GString  *string,
 673                          gunichar  wc)
 674 {
 675   g_return_val_if_fail (string != NULL, NULL);
 676 
 677   return g_string_insert_unichar (string, -1, wc);
 678 }
 679 
 680 /**
 681  * g_string_prepend:
 682  * @string: a #GString
 683  * @val: the string to prepend on the start of @string
 684  *
 685  * Adds a string on to the start of a #GString,
 686  * expanding it if necessary.
 687  *
 688  * Returns: (transfer none): @string
 689  */
 690 GString *
 691 g_string_prepend (GString     *string,
 692                   const gchar *val)
 693 {
 694   return g_string_insert_len (string, 0, val, -1);
 695 }
 696 
 697 /**
 698  * g_string_prepend_len:
 699  * @string: a #GString
 700  * @val: bytes to prepend
 701  * @len: number of bytes in @val to prepend, or -1 for all of @val
 702  *
 703  * Prepends @len bytes of @val to @string.
 704  *
 705  * If @len is positive, @val may contain embedded nuls and need
 706  * not be nul-terminated. It is the caller&#39;s responsibility to
 707  * ensure that @val has at least @len addressable bytes.
 708  *
 709  * If @len is negative, @val must be nul-terminated and @len
 710  * is considered to request the entire string length. This
 711  * makes g_string_prepend_len() equivalent to g_string_prepend().
 712  *
 713  * Returns: (transfer none): @string
 714  */
 715 GString *
 716 g_string_prepend_len (GString     *string,
 717                       const gchar *val,
 718                       gssize       len)
 719 {
 720   return g_string_insert_len (string, 0, val, len);
 721 }
 722 
 723 /**
 724  * g_string_prepend_c:
 725  * @string: a #GString
 726  * @c: the byte to prepend on the start of the #GString
 727  *
 728  * Adds a byte onto the start of a #GString,
 729  * expanding it if necessary.
 730  *
 731  * Returns: (transfer none): @string
 732  */
 733 GString *
 734 g_string_prepend_c (GString *string,
 735                     gchar    c)
 736 {
 737   g_return_val_if_fail (string != NULL, NULL);
 738 
 739   return g_string_insert_c (string, 0, c);
 740 }
 741 
 742 /**
 743  * g_string_prepend_unichar:
 744  * @string: a #GString
 745  * @wc: a Unicode character
 746  *
 747  * Converts a Unicode character into UTF-8, and prepends it
 748  * to the string.
 749  *
 750  * Returns: (transfer none): @string
 751  */
 752 GString *
 753 g_string_prepend_unichar (GString  *string,
 754                           gunichar  wc)
 755 {
 756   g_return_val_if_fail (string != NULL, NULL);
 757 
 758   return g_string_insert_unichar (string, 0, wc);
 759 }
 760 
 761 /**
 762  * g_string_insert:
 763  * @string: a #GString
 764  * @pos: the position to insert the copy of the string
 765  * @val: the string to insert
 766  *
 767  * Inserts a copy of a string into a #GString,
 768  * expanding it if necessary.
 769  *
 770  * Returns: (transfer none): @string
 771  */
 772 GString *
 773 g_string_insert (GString     *string,
 774                  gssize       pos,
 775                  const gchar *val)
 776 {
 777   return g_string_insert_len (string, pos, val, -1);
 778 }
 779 
 780 /**
 781  * g_string_insert_c:
 782  * @string: a #GString
 783  * @pos: the position to insert the byte
 784  * @c: the byte to insert
 785  *
 786  * Inserts a byte into a #GString, expanding it if necessary.
 787  *
 788  * Returns: (transfer none): @string
 789  */
 790 GString *
 791 g_string_insert_c (GString *string,
 792                    gssize   pos,
 793                    gchar    c)
 794 {
 795   gsize pos_unsigned;
 796 
 797   g_return_val_if_fail (string != NULL, NULL);
 798 
 799   g_string_maybe_expand (string, 1);
 800 
 801   if (pos &lt; 0)
 802     pos = string-&gt;len;
 803   else
 804     g_return_val_if_fail ((gsize) pos &lt;= string-&gt;len, string);
 805   pos_unsigned = pos;
 806 
 807   /* If not just an append, move the old stuff */
 808   if (pos_unsigned &lt; string-&gt;len)
 809     memmove (string-&gt;str + pos_unsigned + 1,
 810              string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);
 811 
 812   string-&gt;str[pos_unsigned] = c;
 813 
 814   string-&gt;len += 1;
 815 
 816   string-&gt;str[string-&gt;len] = 0;
 817 
 818   return string;
 819 }
 820 
 821 /**
 822  * g_string_insert_unichar:
 823  * @string: a #GString
 824  * @pos: the position at which to insert character, or -1
 825  *     to append at the end of the string
 826  * @wc: a Unicode character
 827  *
 828  * Converts a Unicode character into UTF-8, and insert it
 829  * into the string at the given position.
 830  *
 831  * Returns: (transfer none): @string
 832  */
 833 GString *
 834 g_string_insert_unichar (GString  *string,
 835                          gssize    pos,
 836                          gunichar  wc)
 837 {
 838   gint charlen, first, i;
 839   gchar *dest;
 840 
 841   g_return_val_if_fail (string != NULL, NULL);
 842 
 843   /* Code copied from g_unichar_to_utf() */
 844   if (wc &lt; 0x80)
 845     {
 846       first = 0;
 847       charlen = 1;
 848     }
 849   else if (wc &lt; 0x800)
 850     {
 851       first = 0xc0;
 852       charlen = 2;
 853     }
 854   else if (wc &lt; 0x10000)
 855     {
 856       first = 0xe0;
 857       charlen = 3;
 858     }
 859    else if (wc &lt; 0x200000)
 860     {
 861       first = 0xf0;
 862       charlen = 4;
 863     }
 864   else if (wc &lt; 0x4000000)
 865     {
 866       first = 0xf8;
 867       charlen = 5;
 868     }
 869   else
 870     {
 871       first = 0xfc;
 872       charlen = 6;
 873     }
 874   /* End of copied code */
 875 
 876   g_string_maybe_expand (string, charlen);
 877 
 878   if (pos &lt; 0)
 879     pos = string-&gt;len;
 880   else
 881     g_return_val_if_fail ((gsize) pos &lt;= string-&gt;len, string);
 882 
 883   /* If not just an append, move the old stuff */
 884   if ((gsize) pos &lt; string-&gt;len)
 885     memmove (string-&gt;str + pos + charlen, string-&gt;str + pos, string-&gt;len - pos);
 886 
 887   dest = string-&gt;str + pos;
 888   /* Code copied from g_unichar_to_utf() */
 889   for (i = charlen - 1; i &gt; 0; --i)
 890     {
 891       dest[i] = (wc &amp; 0x3f) | 0x80;
 892       wc &gt;&gt;= 6;
 893     }
 894   dest[0] = wc | first;
 895   /* End of copied code */
 896 
 897   string-&gt;len += charlen;
 898 
 899   string-&gt;str[string-&gt;len] = 0;
 900 
 901   return string;
 902 }
 903 
 904 /**
 905  * g_string_overwrite:
 906  * @string: a #GString
 907  * @pos: the position at which to start overwriting
 908  * @val: the string that will overwrite the @string starting at @pos
 909  *
 910  * Overwrites part of a string, lengthening it if necessary.
 911  *
 912  * Returns: (transfer none): @string
 913  *
 914  * Since: 2.14
 915  */
 916 GString *
 917 g_string_overwrite (GString     *string,
 918                     gsize        pos,
 919                     const gchar *val)
 920 {
 921   g_return_val_if_fail (val != NULL, string);
 922   return g_string_overwrite_len (string, pos, val, strlen (val));
 923 }
 924 
 925 /**
 926  * g_string_overwrite_len:
 927  * @string: a #GString
 928  * @pos: the position at which to start overwriting
 929  * @val: the string that will overwrite the @string starting at @pos
 930  * @len: the number of bytes to write from @val
 931  *
 932  * Overwrites part of a string, lengthening it if necessary.
 933  * This function will work with embedded nuls.
 934  *
 935  * Returns: (transfer none): @string
 936  *
 937  * Since: 2.14
 938  */
 939 GString *
 940 g_string_overwrite_len (GString     *string,
 941                         gsize        pos,
 942                         const gchar *val,
 943                         gssize       len)
 944 {
 945   gsize end;
 946 
 947   g_return_val_if_fail (string != NULL, NULL);
 948 
 949   if (!len)
 950     return string;
 951 
 952   g_return_val_if_fail (val != NULL, string);
 953   g_return_val_if_fail (pos &lt;= string-&gt;len, string);
 954 
 955   if (len &lt; 0)
 956     len = strlen (val);
 957 
 958   end = pos + len;
 959 
 960   if (end &gt; string-&gt;len)
 961     g_string_maybe_expand (string, end - string-&gt;len);
 962 
 963   memcpy (string-&gt;str + pos, val, len);
 964 
 965   if (end &gt; string-&gt;len)
 966     {
 967       string-&gt;str[end] = &#39;\0&#39;;
 968       string-&gt;len = end;
 969     }
 970 
 971   return string;
 972 }
 973 
 974 /**
 975  * g_string_erase:
 976  * @string: a #GString
 977  * @pos: the position of the content to remove
 978  * @len: the number of bytes to remove, or -1 to remove all
 979  *       following bytes
 980  *
 981  * Removes @len bytes from a #GString, starting at position @pos.
 982  * The rest of the #GString is shifted down to fill the gap.
 983  *
 984  * Returns: (transfer none): @string
 985  */
 986 GString *
 987 g_string_erase (GString *string,
 988                 gssize   pos,
 989                 gssize   len)
 990 {
 991   gsize len_unsigned, pos_unsigned;
 992 
 993   g_return_val_if_fail (string != NULL, NULL);
 994   g_return_val_if_fail (pos &gt;= 0, string);
 995   pos_unsigned = pos;
 996 
 997   g_return_val_if_fail (pos_unsigned &lt;= string-&gt;len, string);
 998 
 999   if (len &lt; 0)
1000     len_unsigned = string-&gt;len - pos_unsigned;
1001   else
1002     {
1003       len_unsigned = len;
1004       g_return_val_if_fail (pos_unsigned + len_unsigned &lt;= string-&gt;len, string);
1005 
1006       if (pos_unsigned + len_unsigned &lt; string-&gt;len)
1007         memmove (string-&gt;str + pos_unsigned,
1008                  string-&gt;str + pos_unsigned + len_unsigned,
1009                  string-&gt;len - (pos_unsigned + len_unsigned));
1010     }
1011 
1012   string-&gt;len -= len_unsigned;
1013 
1014   string-&gt;str[string-&gt;len] = 0;
1015 
1016   return string;
1017 }
1018 
1019 /**
1020  * g_string_ascii_down:
1021  * @string: a GString
1022  *
1023  * Converts all uppercase ASCII letters to lowercase ASCII letters.
1024  *
1025  * Returns: (transfer none): passed-in @string pointer, with all the
1026  *     uppercase characters converted to lowercase in place,
1027  *     with semantics that exactly match g_ascii_tolower().
1028  */
1029 GString *
1030 g_string_ascii_down (GString *string)
1031 {
1032   gchar *s;
1033   gint n;
1034 
1035   g_return_val_if_fail (string != NULL, NULL);
1036 
1037   n = string-&gt;len;
1038   s = string-&gt;str;
1039 
1040   while (n)
1041     {
1042       *s = g_ascii_tolower (*s);
1043       s++;
1044       n--;
1045     }
1046 
1047   return string;
1048 }
1049 
1050 /**
1051  * g_string_ascii_up:
1052  * @string: a GString
1053  *
1054  * Converts all lowercase ASCII letters to uppercase ASCII letters.
1055  *
1056  * Returns: (transfer none): passed-in @string pointer, with all the
1057  *     lowercase characters converted to uppercase in place,
1058  *     with semantics that exactly match g_ascii_toupper().
1059  */
1060 GString *
1061 g_string_ascii_up (GString *string)
1062 {
1063   gchar *s;
1064   gint n;
1065 
1066   g_return_val_if_fail (string != NULL, NULL);
1067 
1068   n = string-&gt;len;
1069   s = string-&gt;str;
1070 
1071   while (n)
1072     {
1073       *s = g_ascii_toupper (*s);
1074       s++;
1075       n--;
1076     }
1077 
1078   return string;
1079 }
1080 
1081 /**
1082  * g_string_down:
1083  * @string: a #GString
1084  *
1085  * Converts a #GString to lowercase.
1086  *
1087  * Returns: (transfer none): the #GString
1088  *
1089  * Deprecated:2.2: This function uses the locale-specific
1090  *     tolower() function, which is almost never the right thing.
1091  *     Use g_string_ascii_down() or g_utf8_strdown() instead.
1092  */
1093 GString *
1094 g_string_down (GString *string)
1095 {
1096   guchar *s;
1097   glong n;
1098 
1099   g_return_val_if_fail (string != NULL, NULL);
1100 
1101   n = string-&gt;len;
1102   s = (guchar *) string-&gt;str;
1103 
1104   while (n)
1105     {
1106       if (isupper (*s))
1107         *s = tolower (*s);
1108       s++;
1109       n--;
1110     }
1111 
1112   return string;
1113 }
1114 
1115 /**
1116  * g_string_up:
1117  * @string: a #GString
1118  *
1119  * Converts a #GString to uppercase.
1120  *
1121  * Returns: (transfer none): @string
1122  *
1123  * Deprecated:2.2: This function uses the locale-specific
1124  *     toupper() function, which is almost never the right thing.
1125  *     Use g_string_ascii_up() or g_utf8_strup() instead.
1126  */
1127 GString *
1128 g_string_up (GString *string)
1129 {
1130   guchar *s;
1131   glong n;
1132 
1133   g_return_val_if_fail (string != NULL, NULL);
1134 
1135   n = string-&gt;len;
1136   s = (guchar *) string-&gt;str;
1137 
1138   while (n)
1139     {
1140       if (islower (*s))
1141         *s = toupper (*s);
1142       s++;
1143       n--;
1144     }
1145 
1146   return string;
1147 }
1148 
1149 /**
1150  * g_string_append_vprintf:
1151  * @string: a #GString
1152  * @format: the string format. See the printf() documentation
1153  * @args: the list of arguments to insert in the output
1154  *
1155  * Appends a formatted string onto the end of a #GString.
1156  * This function is similar to g_string_append_printf()
1157  * except that the arguments to the format string are passed
1158  * as a va_list.
1159  *
1160  * Since: 2.14
1161  */
1162 void
1163 g_string_append_vprintf (GString     *string,
1164                          const gchar *format,
1165                          va_list      args)
1166 {
1167   gchar *buf;
1168   gint len;
1169 
1170   g_return_if_fail (string != NULL);
1171   g_return_if_fail (format != NULL);
1172 
1173   len = g_vasprintf (&amp;buf, format, args);
1174 
1175   if (len &gt;= 0)
1176     {
1177       g_string_maybe_expand (string, len);
1178       memcpy (string-&gt;str + string-&gt;len, buf, len + 1);
1179       string-&gt;len += len;
1180       g_free (buf);
1181     }
1182 }
1183 
1184 /**
1185  * g_string_vprintf:
1186  * @string: a #GString
1187  * @format: the string format. See the printf() documentation
1188  * @args: the parameters to insert into the format string
1189  *
1190  * Writes a formatted string into a #GString.
1191  * This function is similar to g_string_printf() except that
1192  * the arguments to the format string are passed as a va_list.
1193  *
1194  * Since: 2.14
1195  */
1196 void
1197 g_string_vprintf (GString     *string,
1198                   const gchar *format,
1199                   va_list      args)
1200 {
1201   g_string_truncate (string, 0);
1202   g_string_append_vprintf (string, format, args);
1203 }
1204 
1205 /**
1206  * g_string_sprintf:
1207  * @string: a #GString
1208  * @format: the string format. See the sprintf() documentation
1209  * @...: the parameters to insert into the format string
1210  *
1211  * Writes a formatted string into a #GString.
1212  * This is similar to the standard sprintf() function,
1213  * except that the #GString buffer automatically expands
1214  * to contain the results. The previous contents of the
1215  * #GString are destroyed.
1216  *
1217  * Deprecated: This function has been renamed to g_string_printf().
1218  */
1219 
1220 /**
1221  * g_string_printf:
1222  * @string: a #GString
1223  * @format: the string format. See the printf() documentation
1224  * @...: the parameters to insert into the format string
1225  *
1226  * Writes a formatted string into a #GString.
1227  * This is similar to the standard sprintf() function,
1228  * except that the #GString buffer automatically expands
1229  * to contain the results. The previous contents of the
1230  * #GString are destroyed.
1231  */
1232 void
1233 g_string_printf (GString     *string,
1234                  const gchar *format,
1235                  ...)
1236 {
1237   va_list args;
1238 
1239   g_string_truncate (string, 0);
1240 
1241   va_start (args, format);
1242   g_string_append_vprintf (string, format, args);
1243   va_end (args);
1244 }
1245 
1246 /**
1247  * g_string_sprintfa:
1248  * @string: a #GString
1249  * @format: the string format. See the sprintf() documentation
1250  * @...: the parameters to insert into the format string
1251  *
1252  * Appends a formatted string onto the end of a #GString.
1253  * This function is similar to g_string_sprintf() except that
1254  * the text is appended to the #GString.
1255  *
1256  * Deprecated: This function has been renamed to g_string_append_printf()
1257  */
1258 
1259 /**
1260  * g_string_append_printf:
1261  * @string: a #GString
1262  * @format: the string format. See the printf() documentation
1263  * @...: the parameters to insert into the format string
1264  *
1265  * Appends a formatted string onto the end of a #GString.
1266  * This function is similar to g_string_printf() except
1267  * that the text is appended to the #GString.
1268  */
1269 void
1270 g_string_append_printf (GString     *string,
1271                         const gchar *format,
1272                         ...)
1273 {
1274   va_list args;
1275 
1276   va_start (args, format);
1277   g_string_append_vprintf (string, format, args);
1278   va_end (args);
1279 }
    </pre>
  </body>
</html>