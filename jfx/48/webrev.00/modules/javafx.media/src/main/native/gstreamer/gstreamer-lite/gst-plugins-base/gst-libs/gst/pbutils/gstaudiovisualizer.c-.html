<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstaudiovisualizer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) &lt;2011&gt; Stefan Kost &lt;ensonic@users.sf.net&gt;
   3  * Copyright (C) &lt;2015&gt; Luis de Bethencourt &lt;luis@debethencourt.com&gt;
   4  *
   5  * gstaudiovisualizer.h: base class for audio visualisation elements
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 /**
  23  * SECTION:gstaudiovisualizer
  24  * @title: GstAudioVisualizer
  25  *
  26  * A baseclass for scopes (visualizers). It takes care of re-fitting the
  27  * audio-rate to video-rate and handles renegotiation (downstream video size
  28  * changes).
  29  *
  30  * It also provides several background shading effects. These effects are
  31  * applied to a previous picture before the render() implementation can draw a
  32  * new frame.
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &lt;string.h&gt;
  40 
  41 #include &lt;gst/video/video.h&gt;
  42 #include &lt;gst/video/gstvideometa.h&gt;
  43 #include &lt;gst/video/gstvideopool.h&gt;
  44 
  45 #include &quot;gstaudiovisualizer.h&quot;
  46 #include &quot;pbutils-enumtypes.h&quot;
  47 
  48 GST_DEBUG_CATEGORY_STATIC (audio_visualizer_debug);
  49 #define GST_CAT_DEFAULT (audio_visualizer_debug)
  50 
  51 #define DEFAULT_SHADER GST_AUDIO_VISUALIZER_SHADER_FADE
  52 #define DEFAULT_SHADE_AMOUNT   0x000a0a0a
  53 
  54 enum
  55 {
  56   PROP_0,
  57   PROP_SHADER,
  58   PROP_SHADE_AMOUNT
  59 };
  60 
  61 static GstBaseTransformClass *parent_class = NULL;
  62 
  63 static void gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass);
  64 static void gst_audio_visualizer_init (GstAudioVisualizer * scope,
  65     GstAudioVisualizerClass * g_class);
  66 static void gst_audio_visualizer_set_property (GObject * object,
  67     guint prop_id, const GValue * value, GParamSpec * pspec);
  68 static void gst_audio_visualizer_get_property (GObject * object,
  69     guint prop_id, GValue * value, GParamSpec * pspec);
  70 static void gst_audio_visualizer_dispose (GObject * object);
  71 
  72 static gboolean gst_audio_visualizer_src_negotiate (GstAudioVisualizer * scope);
  73 static gboolean gst_audio_visualizer_src_setcaps (GstAudioVisualizer *
  74     scope, GstCaps * caps);
  75 static gboolean gst_audio_visualizer_sink_setcaps (GstAudioVisualizer *
  76     scope, GstCaps * caps);
  77 
  78 static GstFlowReturn gst_audio_visualizer_chain (GstPad * pad,
  79     GstObject * parent, GstBuffer * buffer);
  80 
  81 static gboolean gst_audio_visualizer_src_event (GstPad * pad,
  82     GstObject * parent, GstEvent * event);
  83 static gboolean gst_audio_visualizer_sink_event (GstPad * pad,
  84     GstObject * parent, GstEvent * event);
  85 
  86 static gboolean gst_audio_visualizer_src_query (GstPad * pad,
  87     GstObject * parent, GstQuery * query);
  88 
  89 static GstStateChangeReturn gst_audio_visualizer_change_state (GstElement *
  90     element, GstStateChange transition);
  91 
  92 static gboolean gst_audio_visualizer_do_bufferpool (GstAudioVisualizer * scope,
  93     GstCaps * outcaps);
  94 
  95 static gboolean
  96 default_decide_allocation (GstAudioVisualizer * scope, GstQuery * query);
  97 
  98 #define GST_AUDIO_VISUALIZER_GET_PRIVATE(obj)  \
  99     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_VISUALIZER, GstAudioVisualizerPrivate))
 100 
 101 struct _GstAudioVisualizerPrivate
 102 {
 103   gboolean negotiated;
 104 
 105   GstBufferPool *pool;
 106   gboolean pool_active;
 107   GstAllocator *allocator;
 108   GstAllocationParams params;
 109   GstQuery *query;
 110 
 111   /* pads */
 112   GstPad *srcpad, *sinkpad;
 113 
 114   GstAudioVisualizerShader shader_type;
 115   GstAudioVisualizerShaderFunc shader;
 116   guint32 shade_amount;
 117 
 118   GstAdapter *adapter;
 119 
 120   GstBuffer *inbuf;
 121   GstBuffer *tempbuf;
 122   GstVideoFrame tempframe;
 123 
 124   guint spf;                    /* samples per video frame */
 125   guint64 frame_duration;
 126 
 127   /* QoS stuff *//* with LOCK */
 128   gdouble proportion;
 129   GstClockTime earliest_time;
 130 
 131   guint dropped;                /* frames dropped / not dropped */
 132   guint processed;
 133 
 134   /* configuration mutex */
 135   GMutex config_lock;
 136 
 137   GstSegment segment;
 138 };
 139 
 140 /* shading functions */
 141 
 142 /* we&#39;re only supporting GST_VIDEO_FORMAT_xRGB right now) */
 143 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 144 
 145 #define SHADE(_d, _s, _i, _r, _g, _b)                     \
 146 G_STMT_START {                                            \
 147     _d[_i * 4 + 0] = (_s[_i * 4 + 0] &gt; _b) ? _s[_i * 4 + 0] - _b : 0; \
 148     _d[_i * 4 + 1] = (_s[_i * 4 + 1] &gt; _g) ? _s[_i * 4 + 1] - _g : 0; \
 149     _d[_i * 4 + 2] = (_s[_i * 4 + 2] &gt; _r) ? _s[_i * 4 + 2] - _r : 0; \
 150     _d[_i * 4 + 3] = 0;                                       \
 151 } G_STMT_END
 152 
 153 #else /* G_BYTE_ORDER == G_LITTLE_ENDIAN */
 154 
 155 #define SHADE(_d, _s, _i, _r, _g, _b)                     \
 156 G_STMT_START {                                            \
 157     _d[_i * 4 + 0] = 0;                                       \
 158     _d[_i * 4 + 1] = (_s[_i * 4 + 1] &gt; _r) ? _s[_i * 4 + 1] - _r : 0; \
 159     _d[_i * 4 + 2] = (_s[_i * 4 + 2] &gt; _g) ? _s[_i * 4 + 2] - _g : 0; \
 160     _d[_i * 4 + 3] = (_s[_i * 4 + 3] &gt; _b) ? _s[_i * 4 + 3] - _b : 0; \
 161 } G_STMT_END
 162 
 163 #endif
 164 
 165 static void
 166 shader_fade (GstAudioVisualizer * scope, const GstVideoFrame * sframe,
 167     GstVideoFrame * dframe)
 168 {
 169   guint i, j;
 170   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 171   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 172   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 173   guint8 *s, *d;
 174   gint ss, ds, width, height;
 175 
 176   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 177   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 178   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 179   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 180 
 181   width = GST_VIDEO_FRAME_WIDTH (sframe);
 182   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 183 
 184   for (j = 0; j &lt; height; j++) {
 185     for (i = 0; i &lt; width; i++) {
 186       SHADE (d, s, i, r, g, b);
 187     }
 188     s += ss;
 189     d += ds;
 190   }
 191 }
 192 
 193 static void
 194 shader_fade_and_move_up (GstAudioVisualizer * scope,
 195     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 196 {
 197   guint i, j;
 198   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 199   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 200   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 201   guint8 *s, *d;
 202   gint ss, ds, width, height;
 203 
 204   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 205   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 206   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 207   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 208 
 209   width = GST_VIDEO_FRAME_WIDTH (sframe);
 210   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 211 
 212   for (j = 1; j &lt; height; j++) {
 213     s += ss;
 214     for (i = 0; i &lt; width; i++) {
 215       SHADE (d, s, i, r, g, b);
 216     }
 217     d += ds;
 218   }
 219 }
 220 
 221 static void
 222 shader_fade_and_move_down (GstAudioVisualizer * scope,
 223     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 224 {
 225   guint i, j;
 226   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 227   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 228   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 229   guint8 *s, *d;
 230   gint ss, ds, width, height;
 231 
 232   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 233   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 234   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 235   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 236 
 237   width = GST_VIDEO_FRAME_WIDTH (sframe);
 238   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 239 
 240   for (j = 1; j &lt; height; j++) {
 241     d += ds;
 242     for (i = 0; i &lt; width; i++) {
 243       SHADE (d, s, i, r, g, b);
 244     }
 245     s += ss;
 246   }
 247 }
 248 
 249 static void
 250 shader_fade_and_move_left (GstAudioVisualizer * scope,
 251     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 252 {
 253   guint i, j;
 254   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 255   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 256   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 257   guint8 *s, *d;
 258   gint ss, ds, width, height;
 259 
 260   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 261   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 262   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 263   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 264 
 265   width = GST_VIDEO_FRAME_WIDTH (sframe);
 266   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 267 
 268   width -= 1;
 269   s += 4;
 270 
 271   /* move to the left */
 272   for (j = 0; j &lt; height; j++) {
 273     for (i = 0; i &lt; width; i++) {
 274       SHADE (d, s, i, r, g, b);
 275     }
 276     d += ds;
 277     s += ss;
 278   }
 279 }
 280 
 281 static void
 282 shader_fade_and_move_right (GstAudioVisualizer * scope,
 283     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 284 {
 285   guint i, j;
 286   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 287   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 288   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 289   guint8 *s, *d;
 290   gint ss, ds, width, height;
 291 
 292   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 293   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 294   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 295   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 296 
 297   width = GST_VIDEO_FRAME_WIDTH (sframe);
 298   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 299 
 300   width -= 1;
 301   d += 4;
 302 
 303   /* move to the right */
 304   for (j = 0; j &lt; height; j++) {
 305     for (i = 0; i &lt; width; i++) {
 306       SHADE (d, s, i, r, g, b);
 307     }
 308     d += ds;
 309     s += ss;
 310   }
 311 }
 312 
 313 static void
 314 shader_fade_and_move_horiz_out (GstAudioVisualizer * scope,
 315     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 316 {
 317   guint i, j;
 318   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 319   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 320   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 321   guint8 *s, *d;
 322   gint ss, ds, width, height;
 323 
 324   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 325   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 326   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 327   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 328 
 329   width = GST_VIDEO_FRAME_WIDTH (sframe);
 330   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 331 
 332   /* move upper half up */
 333   for (j = 0; j &lt; height / 2; j++) {
 334     s += ss;
 335     for (i = 0; i &lt; width; i++) {
 336       SHADE (d, s, i, r, g, b);
 337     }
 338     d += ds;
 339   }
 340   /* move lower half down */
 341   for (j = 0; j &lt; height / 2; j++) {
 342     d += ds;
 343     for (i = 0; i &lt; width; i++) {
 344       SHADE (d, s, i, r, g, b);
 345     }
 346     s += ss;
 347   }
 348 }
 349 
 350 static void
 351 shader_fade_and_move_horiz_in (GstAudioVisualizer * scope,
 352     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 353 {
 354   guint i, j;
 355   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 356   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 357   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 358   guint8 *s, *d;
 359   gint ss, ds, width, height;
 360 
 361   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 362   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 363   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 364   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 365 
 366   width = GST_VIDEO_FRAME_WIDTH (sframe);
 367   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 368 
 369   /* move upper half down */
 370   for (j = 0; j &lt; height / 2; j++) {
 371     d += ds;
 372     for (i = 0; i &lt; width; i++) {
 373       SHADE (d, s, i, r, g, b);
 374     }
 375     s += ss;
 376   }
 377   /* move lower half up */
 378   for (j = 0; j &lt; height / 2; j++) {
 379     s += ss;
 380     for (i = 0; i &lt; width; i++) {
 381       SHADE (d, s, i, r, g, b);
 382     }
 383     d += ds;
 384   }
 385 }
 386 
 387 static void
 388 shader_fade_and_move_vert_out (GstAudioVisualizer * scope,
 389     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 390 {
 391   guint i, j;
 392   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 393   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 394   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 395   guint8 *s, *s1, *d, *d1;
 396   gint ss, ds, width, height;
 397 
 398   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 399   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 400   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 401   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 402 
 403   width = GST_VIDEO_FRAME_WIDTH (sframe);
 404   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 405 
 406   for (j = 0; j &lt; height; j++) {
 407     /* move left half to the left */
 408     s1 = s + 1;
 409     for (i = 0; i &lt; width / 2; i++) {
 410       SHADE (d, s1, i, r, g, b);
 411     }
 412     /* move right half to the right */
 413     d1 = d + 1;
 414     for (; i &lt; width - 1; i++) {
 415       SHADE (d1, s, i, r, g, b);
 416     }
 417     s += ss;
 418     d += ds;
 419   }
 420 }
 421 
 422 static void
 423 shader_fade_and_move_vert_in (GstAudioVisualizer * scope,
 424     const GstVideoFrame * sframe, GstVideoFrame * dframe)
 425 {
 426   guint i, j;
 427   guint r = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 16) &amp; 0xff;
 428   guint g = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 8) &amp; 0xff;
 429   guint b = (scope-&gt;priv-&gt;shade_amount &gt;&gt; 0) &amp; 0xff;
 430   guint8 *s, *s1, *d, *d1;
 431   gint ss, ds, width, height;
 432 
 433   s = GST_VIDEO_FRAME_PLANE_DATA (sframe, 0);
 434   ss = GST_VIDEO_FRAME_PLANE_STRIDE (sframe, 0);
 435   d = GST_VIDEO_FRAME_PLANE_DATA (dframe, 0);
 436   ds = GST_VIDEO_FRAME_PLANE_STRIDE (dframe, 0);
 437 
 438   width = GST_VIDEO_FRAME_WIDTH (sframe);
 439   height = GST_VIDEO_FRAME_HEIGHT (sframe);
 440 
 441   for (j = 0; j &lt; height; j++) {
 442     /* move left half to the right */
 443     d1 = d + 1;
 444     for (i = 0; i &lt; width / 2; i++) {
 445       SHADE (d1, s, i, r, g, b);
 446     }
 447     /* move right half to the left */
 448     s1 = s + 1;
 449     for (; i &lt; width - 1; i++) {
 450       SHADE (d, s1, i, r, g, b);
 451     }
 452     s += ss;
 453     d += ds;
 454   }
 455 }
 456 
 457 static void
 458 gst_audio_visualizer_change_shader (GstAudioVisualizer * scope)
 459 {
 460   switch (scope-&gt;priv-&gt;shader_type) {
 461     case GST_AUDIO_VISUALIZER_SHADER_NONE:
 462       scope-&gt;priv-&gt;shader = NULL;
 463       break;
 464     case GST_AUDIO_VISUALIZER_SHADER_FADE:
 465       scope-&gt;priv-&gt;shader = shader_fade;
 466       break;
 467     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_UP:
 468       scope-&gt;priv-&gt;shader = shader_fade_and_move_up;
 469       break;
 470     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_DOWN:
 471       scope-&gt;priv-&gt;shader = shader_fade_and_move_down;
 472       break;
 473     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_LEFT:
 474       scope-&gt;priv-&gt;shader = shader_fade_and_move_left;
 475       break;
 476     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_RIGHT:
 477       scope-&gt;priv-&gt;shader = shader_fade_and_move_right;
 478       break;
 479     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_HORIZ_OUT:
 480       scope-&gt;priv-&gt;shader = shader_fade_and_move_horiz_out;
 481       break;
 482     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_HORIZ_IN:
 483       scope-&gt;priv-&gt;shader = shader_fade_and_move_horiz_in;
 484       break;
 485     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_VERT_OUT:
 486       scope-&gt;priv-&gt;shader = shader_fade_and_move_vert_out;
 487       break;
 488     case GST_AUDIO_VISUALIZER_SHADER_FADE_AND_MOVE_VERT_IN:
 489       scope-&gt;priv-&gt;shader = shader_fade_and_move_vert_in;
 490       break;
 491     default:
 492       GST_ERROR (&quot;invalid shader function&quot;);
 493       scope-&gt;priv-&gt;shader = NULL;
 494       break;
 495   }
 496 }
 497 
 498 /* base class */
 499 
 500 GType
 501 gst_audio_visualizer_get_type (void)
 502 {
 503   static volatile gsize audio_visualizer_type = 0;
 504 
 505   if (g_once_init_enter (&amp;audio_visualizer_type)) {
 506     static const GTypeInfo audio_visualizer_info = {
 507       sizeof (GstAudioVisualizerClass),
 508       NULL,
 509       NULL,
 510       (GClassInitFunc) gst_audio_visualizer_class_init,
 511       NULL,
 512       NULL,
 513       sizeof (GstAudioVisualizer),
 514       0,
 515       (GInstanceInitFunc) gst_audio_visualizer_init,
 516     };
 517     GType _type;
 518 
 519     /* TODO: rename when exporting it as a library */
 520     _type = g_type_register_static (GST_TYPE_ELEMENT,
 521         &quot;GstAudioVisualizer&quot;, &amp;audio_visualizer_info, G_TYPE_FLAG_ABSTRACT);
 522     g_once_init_leave (&amp;audio_visualizer_type, _type);
 523   }
 524   return (GType) audio_visualizer_type;
 525 }
 526 
 527 static void
 528 gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass)
 529 {
 530   GObjectClass *gobject_class = (GObjectClass *) klass;
 531   GstElementClass *element_class = (GstElementClass *) klass;
 532 
 533   g_type_class_add_private (klass, sizeof (GstAudioVisualizerPrivate));
 534 
 535   parent_class = g_type_class_peek_parent (klass);
 536 
 537   GST_DEBUG_CATEGORY_INIT (audio_visualizer_debug,
 538       &quot;baseaudiovisualizer-libvisual&quot;, 0,
 539       &quot;scope audio visualisation base class&quot;);
 540 
 541   gobject_class-&gt;set_property = gst_audio_visualizer_set_property;
 542   gobject_class-&gt;get_property = gst_audio_visualizer_get_property;
 543   gobject_class-&gt;dispose = gst_audio_visualizer_dispose;
 544 
 545   element_class-&gt;change_state =
 546       GST_DEBUG_FUNCPTR (gst_audio_visualizer_change_state);
 547 
 548   klass-&gt;decide_allocation = GST_DEBUG_FUNCPTR (default_decide_allocation);
 549 
 550   g_object_class_install_property (gobject_class, PROP_SHADER,
 551       g_param_spec_enum (&quot;shader&quot;, &quot;shader type&quot;,
 552           &quot;Shader function to apply on each frame&quot;,
 553           GST_TYPE_AUDIO_VISUALIZER_SHADER, DEFAULT_SHADER,
 554           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 555   g_object_class_install_property (gobject_class, PROP_SHADE_AMOUNT,
 556       g_param_spec_uint (&quot;shade-amount&quot;, &quot;shade amount&quot;,
 557           &quot;Shading color to use (big-endian ARGB)&quot;, 0, G_MAXUINT32,
 558           DEFAULT_SHADE_AMOUNT,
 559           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 560 }
 561 
 562 static void
 563 gst_audio_visualizer_init (GstAudioVisualizer * scope,
 564     GstAudioVisualizerClass * g_class)
 565 {
 566   GstPadTemplate *pad_template;
 567 
 568   scope-&gt;priv = GST_AUDIO_VISUALIZER_GET_PRIVATE (scope);
 569 
 570   /* create the sink and src pads */
 571   pad_template =
 572       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 573   g_return_if_fail (pad_template != NULL);
 574   scope-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 575   gst_pad_set_chain_function (scope-&gt;priv-&gt;sinkpad,
 576       GST_DEBUG_FUNCPTR (gst_audio_visualizer_chain));
 577   gst_pad_set_event_function (scope-&gt;priv-&gt;sinkpad,
 578       GST_DEBUG_FUNCPTR (gst_audio_visualizer_sink_event));
 579   gst_element_add_pad (GST_ELEMENT (scope), scope-&gt;priv-&gt;sinkpad);
 580 
 581   pad_template =
 582       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;src&quot;);
 583   g_return_if_fail (pad_template != NULL);
 584   scope-&gt;priv-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 585   gst_pad_set_event_function (scope-&gt;priv-&gt;srcpad,
 586       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_event));
 587   gst_pad_set_query_function (scope-&gt;priv-&gt;srcpad,
 588       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_query));
 589   gst_element_add_pad (GST_ELEMENT (scope), scope-&gt;priv-&gt;srcpad);
 590 
 591   scope-&gt;priv-&gt;adapter = gst_adapter_new ();
 592   scope-&gt;priv-&gt;inbuf = gst_buffer_new ();
 593 
 594   /* properties */
 595   scope-&gt;priv-&gt;shader_type = DEFAULT_SHADER;
 596   gst_audio_visualizer_change_shader (scope);
 597   scope-&gt;priv-&gt;shade_amount = DEFAULT_SHADE_AMOUNT;
 598 
 599   /* reset the initial video state */
 600   gst_video_info_init (&amp;scope-&gt;vinfo);
 601   scope-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
 602 
 603   /* reset the initial state */
 604   gst_audio_info_init (&amp;scope-&gt;ainfo);
 605   gst_video_info_init (&amp;scope-&gt;vinfo);
 606 
 607   g_mutex_init (&amp;scope-&gt;priv-&gt;config_lock);
 608 }
 609 
 610 static void
 611 gst_audio_visualizer_set_property (GObject * object, guint prop_id,
 612     const GValue * value, GParamSpec * pspec)
 613 {
 614   GstAudioVisualizer *scope = GST_AUDIO_VISUALIZER (object);
 615 
 616   switch (prop_id) {
 617     case PROP_SHADER:
 618       scope-&gt;priv-&gt;shader_type = g_value_get_enum (value);
 619       gst_audio_visualizer_change_shader (scope);
 620       break;
 621     case PROP_SHADE_AMOUNT:
 622       scope-&gt;priv-&gt;shade_amount = g_value_get_uint (value);
 623       break;
 624     default:
 625       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 626       break;
 627   }
 628 }
 629 
 630 static void
 631 gst_audio_visualizer_get_property (GObject * object, guint prop_id,
 632     GValue * value, GParamSpec * pspec)
 633 {
 634   GstAudioVisualizer *scope = GST_AUDIO_VISUALIZER (object);
 635 
 636   switch (prop_id) {
 637     case PROP_SHADER:
 638       g_value_set_enum (value, scope-&gt;priv-&gt;shader_type);
 639       break;
 640     case PROP_SHADE_AMOUNT:
 641       g_value_set_uint (value, scope-&gt;priv-&gt;shade_amount);
 642       break;
 643     default:
 644       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 645       break;
 646   }
 647 }
 648 
 649 static void
 650 gst_audio_visualizer_dispose (GObject * object)
 651 {
 652   GstAudioVisualizer *scope = GST_AUDIO_VISUALIZER (object);
 653 
 654   if (scope-&gt;priv-&gt;adapter) {
 655     g_object_unref (scope-&gt;priv-&gt;adapter);
 656     scope-&gt;priv-&gt;adapter = NULL;
 657   }
 658   if (scope-&gt;priv-&gt;inbuf) {
 659     gst_buffer_unref (scope-&gt;priv-&gt;inbuf);
 660     scope-&gt;priv-&gt;inbuf = NULL;
 661   }
 662   if (scope-&gt;priv-&gt;tempbuf) {
 663     gst_video_frame_unmap (&amp;scope-&gt;priv-&gt;tempframe);
 664     gst_buffer_unref (scope-&gt;priv-&gt;tempbuf);
 665     scope-&gt;priv-&gt;tempbuf = NULL;
 666   }
 667   if (scope-&gt;priv-&gt;config_lock.p) {
 668     g_mutex_clear (&amp;scope-&gt;priv-&gt;config_lock);
 669     scope-&gt;priv-&gt;config_lock.p = NULL;
 670   }
 671   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 672 }
 673 
 674 static void
 675 gst_audio_visualizer_reset (GstAudioVisualizer * scope)
 676 {
 677   gst_adapter_clear (scope-&gt;priv-&gt;adapter);
 678   gst_segment_init (&amp;scope-&gt;priv-&gt;segment, GST_FORMAT_UNDEFINED);
 679 
 680   GST_OBJECT_LOCK (scope);
 681   scope-&gt;priv-&gt;proportion = 1.0;
 682   scope-&gt;priv-&gt;earliest_time = -1;
 683   scope-&gt;priv-&gt;dropped = 0;
 684   scope-&gt;priv-&gt;processed = 0;
 685   GST_OBJECT_UNLOCK (scope);
 686 }
 687 
 688 static gboolean
 689 gst_audio_visualizer_sink_setcaps (GstAudioVisualizer * scope, GstCaps * caps)
 690 {
 691   GstAudioInfo info;
 692 
 693   if (!gst_audio_info_from_caps (&amp;info, caps))
 694     goto wrong_caps;
 695 
 696   scope-&gt;ainfo = info;
 697 
 698   GST_DEBUG_OBJECT (scope, &quot;audio: channels %d, rate %d&quot;,
 699       GST_AUDIO_INFO_CHANNELS (&amp;info), GST_AUDIO_INFO_RATE (&amp;info));
 700 
 701   if (!gst_audio_visualizer_src_negotiate (scope)) {
 702     goto not_negotiated;
 703   }
 704 
 705   return TRUE;
 706 
 707   /* Errors */
 708 wrong_caps:
 709   {
 710     GST_WARNING_OBJECT (scope, &quot;could not parse caps&quot;);
 711     return FALSE;
 712   }
 713 not_negotiated:
 714   {
 715     GST_WARNING_OBJECT (scope, &quot;failed to negotiate&quot;);
 716     return FALSE;
 717   }
 718 }
 719 
 720 static gboolean
 721 gst_audio_visualizer_src_setcaps (GstAudioVisualizer * scope, GstCaps * caps)
 722 {
 723   GstVideoInfo info;
 724   GstAudioVisualizerClass *klass;
 725   gboolean res;
 726 
 727   if (!gst_video_info_from_caps (&amp;info, caps))
 728     goto wrong_caps;
 729 
 730   klass = GST_AUDIO_VISUALIZER_CLASS (G_OBJECT_GET_CLASS (scope));
 731 
 732   scope-&gt;vinfo = info;
 733 
 734   scope-&gt;priv-&gt;frame_duration = gst_util_uint64_scale_int (GST_SECOND,
 735       GST_VIDEO_INFO_FPS_D (&amp;info), GST_VIDEO_INFO_FPS_N (&amp;info));
 736   scope-&gt;priv-&gt;spf =
 737       gst_util_uint64_scale_int (GST_AUDIO_INFO_RATE (&amp;scope-&gt;ainfo),
 738       GST_VIDEO_INFO_FPS_D (&amp;info), GST_VIDEO_INFO_FPS_N (&amp;info));
 739   scope-&gt;req_spf = scope-&gt;priv-&gt;spf;
 740 
 741   if (scope-&gt;priv-&gt;tempbuf) {
 742     gst_video_frame_unmap (&amp;scope-&gt;priv-&gt;tempframe);
 743     gst_buffer_unref (scope-&gt;priv-&gt;tempbuf);
 744   }
 745   scope-&gt;priv-&gt;tempbuf = gst_buffer_new_wrapped (g_malloc0 (scope-&gt;vinfo.size),
 746       scope-&gt;vinfo.size);
 747   gst_video_frame_map (&amp;scope-&gt;priv-&gt;tempframe, &amp;scope-&gt;vinfo,
 748       scope-&gt;priv-&gt;tempbuf, GST_MAP_READWRITE);
 749 
 750   if (klass-&gt;setup &amp;&amp; !klass-&gt;setup (scope))
 751     goto setup_failed;
 752 
 753   GST_DEBUG_OBJECT (scope, &quot;video: dimension %dx%d, framerate %d/%d&quot;,
 754       GST_VIDEO_INFO_WIDTH (&amp;info), GST_VIDEO_INFO_HEIGHT (&amp;info),
 755       GST_VIDEO_INFO_FPS_N (&amp;info), GST_VIDEO_INFO_FPS_D (&amp;info));
 756   GST_DEBUG_OBJECT (scope, &quot;blocks: spf %u, req_spf %u&quot;,
 757       scope-&gt;priv-&gt;spf, scope-&gt;req_spf);
 758 
 759   gst_pad_set_caps (scope-&gt;priv-&gt;srcpad, caps);
 760 
 761   /* find a pool for the negotiated caps now */
 762   res = gst_audio_visualizer_do_bufferpool (scope, caps);
 763   gst_caps_unref (caps);
 764 
 765   return res;
 766 
 767   /* ERRORS */
 768 wrong_caps:
 769   {
 770     gst_caps_unref (caps);
 771     GST_DEBUG_OBJECT (scope, &quot;error parsing caps&quot;);
 772     return FALSE;
 773   }
 774 
 775 setup_failed:
 776   {
 777     GST_WARNING_OBJECT (scope, &quot;failed to set up&quot;);
 778     return FALSE;
 779   }
 780 }
 781 
 782 static gboolean
 783 gst_audio_visualizer_src_negotiate (GstAudioVisualizer * scope)
 784 {
 785   GstCaps *othercaps, *target;
 786   GstStructure *structure;
 787   GstCaps *templ;
 788   gboolean ret;
 789 
 790   templ = gst_pad_get_pad_template_caps (scope-&gt;priv-&gt;srcpad);
 791 
 792   GST_DEBUG_OBJECT (scope, &quot;performing negotiation&quot;);
 793 
 794   /* see what the peer can do */
 795   othercaps = gst_pad_peer_query_caps (scope-&gt;priv-&gt;srcpad, NULL);
 796   if (othercaps) {
 797     target = gst_caps_intersect (othercaps, templ);
 798     gst_caps_unref (othercaps);
 799     gst_caps_unref (templ);
 800 
 801     if (gst_caps_is_empty (target))
 802       goto no_format;
 803 
 804     target = gst_caps_truncate (target);
 805   } else {
 806     target = templ;
 807   }
 808 
 809   target = gst_caps_make_writable (target);
 810   structure = gst_caps_get_structure (target, 0);
 811   gst_structure_fixate_field_nearest_int (structure, &quot;width&quot;, 320);
 812   gst_structure_fixate_field_nearest_int (structure, &quot;height&quot;, 200);
 813   gst_structure_fixate_field_nearest_fraction (structure, &quot;framerate&quot;, 25, 1);
 814   if (gst_structure_has_field (structure, &quot;pixel-aspect-ratio&quot;))
 815     gst_structure_fixate_field_nearest_fraction (structure,
 816         &quot;pixel-aspect-ratio&quot;, 1, 1);
 817 
 818   target = gst_caps_fixate (target);
 819 
 820   GST_DEBUG_OBJECT (scope, &quot;final caps are %&quot; GST_PTR_FORMAT, target);
 821 
 822   ret = gst_audio_visualizer_src_setcaps (scope, target);
 823 
 824   return ret;
 825 
 826 no_format:
 827   {
 828     gst_caps_unref (target);
 829     return FALSE;
 830   }
 831 }
 832 
 833 /* takes ownership of the pool, allocator and query */
 834 static gboolean
 835 gst_audio_visualizer_set_allocation (GstAudioVisualizer * scope,
 836     GstBufferPool * pool, GstAllocator * allocator,
 837     GstAllocationParams * params, GstQuery * query)
 838 {
 839   GstAllocator *oldalloc;
 840   GstBufferPool *oldpool;
 841   GstQuery *oldquery;
 842   GstAudioVisualizerPrivate *priv = scope-&gt;priv;
 843 
 844   GST_OBJECT_LOCK (scope);
 845   oldpool = priv-&gt;pool;
 846   priv-&gt;pool = pool;
 847   priv-&gt;pool_active = FALSE;
 848 
 849   oldalloc = priv-&gt;allocator;
 850   priv-&gt;allocator = allocator;
 851 
 852   oldquery = priv-&gt;query;
 853   priv-&gt;query = query;
 854 
 855   if (params)
 856     priv-&gt;params = *params;
 857   else
 858     gst_allocation_params_init (&amp;priv-&gt;params);
 859   GST_OBJECT_UNLOCK (scope);
 860 
 861   if (oldpool) {
 862     GST_DEBUG_OBJECT (scope, &quot;deactivating old pool %p&quot;, oldpool);
 863     gst_buffer_pool_set_active (oldpool, FALSE);
 864     gst_object_unref (oldpool);
 865   }
 866   if (oldalloc) {
 867     gst_object_unref (oldalloc);
 868   }
 869   if (oldquery) {
 870     gst_query_unref (oldquery);
 871   }
 872   return TRUE;
 873 }
 874 
 875 static gboolean
 876 gst_audio_visualizer_do_bufferpool (GstAudioVisualizer * scope,
 877     GstCaps * outcaps)
 878 {
 879   GstQuery *query;
 880   gboolean result = TRUE;
 881   GstBufferPool *pool = NULL;
 882   GstAudioVisualizerClass *klass;
 883   GstAllocator *allocator;
 884   GstAllocationParams params;
 885 
 886   /* not passthrough, we need to allocate */
 887   /* find a pool for the negotiated caps now */
 888   GST_DEBUG_OBJECT (scope, &quot;doing allocation query&quot;);
 889   query = gst_query_new_allocation (outcaps, TRUE);
 890 
 891   if (!gst_pad_peer_query (scope-&gt;priv-&gt;srcpad, query)) {
 892     /* not a problem, we use the query defaults */
 893     GST_DEBUG_OBJECT (scope, &quot;allocation query failed&quot;);
 894   }
 895 
 896   klass = GST_AUDIO_VISUALIZER_GET_CLASS (scope);
 897 
 898   GST_DEBUG_OBJECT (scope, &quot;calling decide_allocation&quot;);
 899   g_assert (klass-&gt;decide_allocation != NULL);
 900   result = klass-&gt;decide_allocation (scope, query);
 901 
 902   GST_DEBUG_OBJECT (scope, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, result,
 903       query);
 904 
 905   if (!result)
 906     goto no_decide_allocation;
 907 
 908   /* we got configuration from our peer or the decide_allocation method,
 909    * parse them */
 910   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 911     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
 912   } else {
 913     allocator = NULL;
 914     gst_allocation_params_init (&amp;params);
 915   }
 916 
 917   if (gst_query_get_n_allocation_pools (query) &gt; 0)
 918     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, NULL, NULL, NULL);
 919 
 920   /* now store */
 921   result =
 922       gst_audio_visualizer_set_allocation (scope, pool, allocator, &amp;params,
 923       query);
 924 
 925   return result;
 926 
 927   /* Errors */
 928 no_decide_allocation:
 929   {
 930     GST_WARNING_OBJECT (scope, &quot;Subclass failed to decide allocation&quot;);
 931     gst_query_unref (query);
 932 
 933     return result;
 934   }
 935 }
 936 
 937 static gboolean
 938 default_decide_allocation (GstAudioVisualizer * scope, GstQuery * query)
 939 {
 940   GstCaps *outcaps;
 941   GstBufferPool *pool;
 942   guint size, min, max;
 943   GstAllocator *allocator;
 944   GstAllocationParams params;
 945   GstStructure *config;
 946   gboolean update_allocator;
 947   gboolean update_pool;
 948 
 949   gst_query_parse_allocation (query, &amp;outcaps, NULL);
 950 
 951   /* we got configuration from our peer or the decide_allocation method,
 952    * parse them */
 953   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 954     /* try the allocator */
 955     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
 956     update_allocator = TRUE;
 957   } else {
 958     allocator = NULL;
 959     gst_allocation_params_init (&amp;params);
 960     update_allocator = FALSE;
 961   }
 962 
 963   if (gst_query_get_n_allocation_pools (query) &gt; 0) {
 964     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, &amp;size, &amp;min, &amp;max);
 965     update_pool = TRUE;
 966   } else {
 967     pool = NULL;
 968     size = GST_VIDEO_INFO_SIZE (&amp;scope-&gt;vinfo);
 969     min = max = 0;
 970     update_pool = FALSE;
 971   }
 972 
 973   if (pool == NULL) {
 974     /* we did not get a pool, make one ourselves then */
 975     pool = gst_video_buffer_pool_new ();
 976   }
 977 
 978   config = gst_buffer_pool_get_config (pool);
 979   gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 980   gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 981   gst_buffer_pool_config_add_option (config, GST_BUFFER_POOL_OPTION_VIDEO_META);
 982   gst_buffer_pool_set_config (pool, config);
 983 
 984   if (update_allocator)
 985     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
 986   else
 987     gst_query_add_allocation_param (query, allocator, &amp;params);
 988 
 989   if (allocator)
 990     gst_object_unref (allocator);
 991 
 992   if (update_pool)
 993     gst_query_set_nth_allocation_pool (query, 0, pool, size, min, max);
 994   else
 995     gst_query_add_allocation_pool (query, pool, size, min, max);
 996 
 997   if (pool)
 998     gst_object_unref (pool);
 999 
1000   return TRUE;
1001 }
1002 
1003 static GstFlowReturn
1004 default_prepare_output_buffer (GstAudioVisualizer * scope, GstBuffer ** outbuf)
1005 {
1006   GstAudioVisualizerPrivate *priv;
1007 
1008   priv = scope-&gt;priv;
1009 
1010   g_assert (priv-&gt;pool != NULL);
1011 
1012   /* we can&#39;t reuse the input buffer */
1013   if (!priv-&gt;pool_active) {
1014     GST_DEBUG_OBJECT (scope, &quot;setting pool %p active&quot;, priv-&gt;pool);
1015     if (!gst_buffer_pool_set_active (priv-&gt;pool, TRUE))
1016       goto activate_failed;
1017     priv-&gt;pool_active = TRUE;
1018   }
1019   GST_DEBUG_OBJECT (scope, &quot;using pool alloc&quot;);
1020 
1021   return gst_buffer_pool_acquire_buffer (priv-&gt;pool, outbuf, NULL);
1022 
1023   /* ERRORS */
1024 activate_failed:
1025   {
1026     GST_ELEMENT_ERROR (scope, RESOURCE, SETTINGS,
1027         (&quot;failed to activate bufferpool&quot;), (&quot;failed to activate bufferpool&quot;));
1028     return GST_FLOW_ERROR;
1029   }
1030 }
1031 
1032 static GstFlowReturn
1033 gst_audio_visualizer_chain (GstPad * pad, GstObject * parent,
1034     GstBuffer * buffer)
1035 {
1036   GstFlowReturn ret = GST_FLOW_OK;
1037   GstAudioVisualizer *scope;
1038   GstAudioVisualizerClass *klass;
1039   GstBuffer *inbuf;
1040   guint64 dist, ts;
1041   guint avail, sbpf;
1042   gpointer adata;
1043   gint bpf, rate;
1044 
1045   scope = GST_AUDIO_VISUALIZER (parent);
1046   klass = GST_AUDIO_VISUALIZER_CLASS (G_OBJECT_GET_CLASS (scope));
1047 
1048   GST_LOG_OBJECT (scope, &quot;chainfunc called&quot;);
1049 
1050   /* resync on DISCONT */
1051   if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
1052     gst_adapter_clear (scope-&gt;priv-&gt;adapter);
1053   }
1054 
1055   /* Make sure have an output format */
1056   if (gst_pad_check_reconfigure (scope-&gt;priv-&gt;srcpad)) {
1057     if (!gst_audio_visualizer_src_negotiate (scope)) {
1058       gst_pad_mark_reconfigure (scope-&gt;priv-&gt;srcpad);
1059       goto not_negotiated;
1060     }
1061   }
1062 
1063   rate = GST_AUDIO_INFO_RATE (&amp;scope-&gt;ainfo);
1064   bpf = GST_AUDIO_INFO_BPF (&amp;scope-&gt;ainfo);
1065 
1066   if (bpf == 0) {
1067     ret = GST_FLOW_NOT_NEGOTIATED;
1068     goto beach;
1069   }
1070 
1071   gst_adapter_push (scope-&gt;priv-&gt;adapter, buffer);
1072 
1073   g_mutex_lock (&amp;scope-&gt;priv-&gt;config_lock);
1074 
1075   /* this is what we want */
1076   sbpf = scope-&gt;req_spf * bpf;
1077 
1078   inbuf = scope-&gt;priv-&gt;inbuf;
1079   /* FIXME: the timestamp in the adapter would be different */
1080   gst_buffer_copy_into (inbuf, buffer, GST_BUFFER_COPY_METADATA, 0, -1);
1081 
1082   /* this is what we have */
1083   avail = gst_adapter_available (scope-&gt;priv-&gt;adapter);
1084   GST_LOG_OBJECT (scope, &quot;avail: %u, bpf: %u&quot;, avail, sbpf);
1085   while (avail &gt;= sbpf) {
1086     GstBuffer *outbuf;
1087     GstVideoFrame outframe;
1088 
1089     /* get timestamp of the current adapter content */
1090     ts = gst_adapter_prev_pts (scope-&gt;priv-&gt;adapter, &amp;dist);
1091     if (GST_CLOCK_TIME_IS_VALID (ts)) {
1092       /* convert bytes to time */
1093       ts += gst_util_uint64_scale_int (dist, GST_SECOND, rate * bpf);
1094     }
1095 
1096     /* check for QoS, don&#39;t compute buffers that are known to be late */
1097     if (GST_CLOCK_TIME_IS_VALID (ts)) {
1098       GstClockTime earliest_time;
1099       gdouble proportion;
1100       gint64 qostime;
1101 
1102       qostime =
1103           gst_segment_to_running_time (&amp;scope-&gt;priv-&gt;segment,
1104           GST_FORMAT_TIME, ts) + scope-&gt;priv-&gt;frame_duration;
1105 
1106       GST_OBJECT_LOCK (scope);
1107       earliest_time = scope-&gt;priv-&gt;earliest_time;
1108       proportion = scope-&gt;priv-&gt;proportion;
1109       GST_OBJECT_UNLOCK (scope);
1110 
1111       if (GST_CLOCK_TIME_IS_VALID (earliest_time) &amp;&amp; qostime &lt;= earliest_time) {
1112         GstClockTime stream_time, jitter;
1113         GstMessage *qos_msg;
1114 
1115         GST_DEBUG_OBJECT (scope,
1116             &quot;QoS: skip ts: %&quot; GST_TIME_FORMAT &quot;, earliest: %&quot; GST_TIME_FORMAT,
1117             GST_TIME_ARGS (qostime), GST_TIME_ARGS (earliest_time));
1118 
1119         ++scope-&gt;priv-&gt;dropped;
1120         stream_time = gst_segment_to_stream_time (&amp;scope-&gt;priv-&gt;segment,
1121             GST_FORMAT_TIME, ts);
1122         jitter = GST_CLOCK_DIFF (qostime, earliest_time);
1123         qos_msg = gst_message_new_qos (GST_OBJECT (scope), FALSE, qostime,
1124             stream_time, ts, GST_BUFFER_DURATION (buffer));
1125         gst_message_set_qos_values (qos_msg, jitter, proportion, 1000000);
1126         gst_message_set_qos_stats (qos_msg, GST_FORMAT_BUFFERS,
1127             scope-&gt;priv-&gt;processed, scope-&gt;priv-&gt;dropped);
1128         gst_element_post_message (GST_ELEMENT (scope), qos_msg);
1129 
1130         goto skip;
1131       }
1132     }
1133 
1134     ++scope-&gt;priv-&gt;processed;
1135 
1136     g_mutex_unlock (&amp;scope-&gt;priv-&gt;config_lock);
1137     ret = default_prepare_output_buffer (scope, &amp;outbuf);
1138     g_mutex_lock (&amp;scope-&gt;priv-&gt;config_lock);
1139     /* recheck as the value could have changed */
1140     sbpf = scope-&gt;req_spf * bpf;
1141 
1142     /* no buffer allocated, we don&#39;t care why. */
1143     if (ret != GST_FLOW_OK)
1144       break;
1145 
1146     /* sync controlled properties */
1147     if (GST_CLOCK_TIME_IS_VALID (ts))
1148       gst_object_sync_values (GST_OBJECT (scope), ts);
1149 
1150     GST_BUFFER_PTS (outbuf) = ts;
1151     GST_BUFFER_DURATION (outbuf) = scope-&gt;priv-&gt;frame_duration;
1152 
1153     /* this can fail as the data size we need could have changed */
1154     if (!(adata = (gpointer) gst_adapter_map (scope-&gt;priv-&gt;adapter, sbpf)))
1155       break;
1156 
1157     gst_video_frame_map (&amp;outframe, &amp;scope-&gt;vinfo, outbuf, GST_MAP_READWRITE);
1158 
1159     if (scope-&gt;priv-&gt;shader) {
1160       gst_video_frame_copy (&amp;outframe, &amp;scope-&gt;priv-&gt;tempframe);
1161     } else {
1162       /* gst_video_frame_clear() or is output frame already cleared */
1163       gint i;
1164 
1165       for (i = 0; i &lt; scope-&gt;vinfo.finfo-&gt;n_planes; i++) {
1166         memset (outframe.data[i], 0, outframe.map[i].size);
1167       }
1168     }
1169 
1170     gst_buffer_replace_all_memory (inbuf,
1171         gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY, adata, sbpf, 0,
1172             sbpf, NULL, NULL));
1173 
1174     /* call class-&gt;render() vmethod */
1175     if (klass-&gt;render) {
1176       if (!klass-&gt;render (scope, inbuf, &amp;outframe)) {
1177         ret = GST_FLOW_ERROR;
1178         gst_video_frame_unmap (&amp;outframe);
1179         goto beach;
1180       } else {
1181         /* run various post processing (shading and geometric transformation) */
1182         /* FIXME: SHADER assumes 32bpp */
1183         if (scope-&gt;priv-&gt;shader &amp;&amp;
1184             GST_VIDEO_INFO_COMP_PSTRIDE (&amp;scope-&gt;vinfo, 0) == 4) {
1185           scope-&gt;priv-&gt;shader (scope, &amp;outframe, &amp;scope-&gt;priv-&gt;tempframe);
1186         }
1187       }
1188     }
1189     gst_video_frame_unmap (&amp;outframe);
1190 
1191     g_mutex_unlock (&amp;scope-&gt;priv-&gt;config_lock);
1192     ret = gst_pad_push (scope-&gt;priv-&gt;srcpad, outbuf);
1193     outbuf = NULL;
1194     g_mutex_lock (&amp;scope-&gt;priv-&gt;config_lock);
1195 
1196   skip:
1197     /* recheck as the value could have changed */
1198     sbpf = scope-&gt;req_spf * bpf;
1199     GST_LOG_OBJECT (scope, &quot;avail: %u, bpf: %u&quot;, avail, sbpf);
1200     /* we want to take less or more, depending on spf : req_spf */
1201     if (avail - sbpf &gt;= sbpf) {
1202       gst_adapter_flush (scope-&gt;priv-&gt;adapter, sbpf);
1203       gst_adapter_unmap (scope-&gt;priv-&gt;adapter);
1204     } else if (avail &gt;= sbpf) {
1205       /* just flush a bit and stop */
1206       gst_adapter_flush (scope-&gt;priv-&gt;adapter, (avail - sbpf));
1207       gst_adapter_unmap (scope-&gt;priv-&gt;adapter);
1208       break;
1209     }
1210     avail = gst_adapter_available (scope-&gt;priv-&gt;adapter);
1211 
1212     if (ret != GST_FLOW_OK)
1213       break;
1214   }
1215 
1216   g_mutex_unlock (&amp;scope-&gt;priv-&gt;config_lock);
1217 
1218 beach:
1219   return ret;
1220 
1221   /* ERRORS */
1222 not_negotiated:
1223   {
1224     GST_DEBUG_OBJECT (scope, &quot;Failed to renegotiate&quot;);
1225     return GST_FLOW_NOT_NEGOTIATED;
1226   }
1227 }
1228 
1229 static gboolean
1230 gst_audio_visualizer_src_event (GstPad * pad, GstObject * parent,
1231     GstEvent * event)
1232 {
1233   gboolean res;
1234   GstAudioVisualizer *scope;
1235 
1236   scope = GST_AUDIO_VISUALIZER (parent);
1237 
1238   switch (GST_EVENT_TYPE (event)) {
1239     case GST_EVENT_QOS:
1240     {
1241       gdouble proportion;
1242       GstClockTimeDiff diff;
1243       GstClockTime timestamp;
1244 
1245       gst_event_parse_qos (event, NULL, &amp;proportion, &amp;diff, &amp;timestamp);
1246 
1247       /* save stuff for the _chain() function */
1248       GST_OBJECT_LOCK (scope);
1249       scope-&gt;priv-&gt;proportion = proportion;
1250       if (diff &gt;= 0)
1251         /* we&#39;re late, this is a good estimate for next displayable
1252          * frame (see part-qos.txt) */
1253         scope-&gt;priv-&gt;earliest_time = timestamp + 2 * diff +
1254             scope-&gt;priv-&gt;frame_duration;
1255       else
1256         scope-&gt;priv-&gt;earliest_time = timestamp + diff;
1257       GST_OBJECT_UNLOCK (scope);
1258 
1259       res = gst_pad_push_event (scope-&gt;priv-&gt;sinkpad, event);
1260       break;
1261     }
1262     case GST_EVENT_RECONFIGURE:
1263       /* dont&#39;t forward */
1264       gst_event_unref (event);
1265       res = TRUE;
1266       break;
1267     default:
1268       res = gst_pad_event_default (pad, parent, event);
1269       break;
1270   }
1271 
1272   return res;
1273 }
1274 
1275 static gboolean
1276 gst_audio_visualizer_sink_event (GstPad * pad, GstObject * parent,
1277     GstEvent * event)
1278 {
1279   gboolean res;
1280   GstAudioVisualizer *scope;
1281 
1282   scope = GST_AUDIO_VISUALIZER (parent);
1283 
1284   switch (GST_EVENT_TYPE (event)) {
1285     case GST_EVENT_CAPS:
1286     {
1287       GstCaps *caps;
1288 
1289       gst_event_parse_caps (event, &amp;caps);
1290       res = gst_audio_visualizer_sink_setcaps (scope, caps);
1291       gst_event_unref (event);
1292       break;
1293     }
1294     case GST_EVENT_FLUSH_STOP:
1295       gst_audio_visualizer_reset (scope);
1296       res = gst_pad_push_event (scope-&gt;priv-&gt;srcpad, event);
1297       break;
1298     case GST_EVENT_SEGMENT:
1299     {
1300       /* the newsegment values are used to clip the input samples
1301        * and to convert the incomming timestamps to running time so
1302        * we can do QoS */
1303       gst_event_copy_segment (event, &amp;scope-&gt;priv-&gt;segment);
1304 
1305       res = gst_pad_push_event (scope-&gt;priv-&gt;srcpad, event);
1306       break;
1307     }
1308     default:
1309       res = gst_pad_event_default (pad, parent, event);
1310       break;
1311   }
1312 
1313   return res;
1314 }
1315 
1316 static gboolean
1317 gst_audio_visualizer_src_query (GstPad * pad, GstObject * parent,
1318     GstQuery * query)
1319 {
1320   gboolean res = FALSE;
1321   GstAudioVisualizer *scope;
1322 
1323   scope = GST_AUDIO_VISUALIZER (parent);
1324 
1325   switch (GST_QUERY_TYPE (query)) {
1326     case GST_QUERY_LATENCY:
1327     {
1328       /* We need to send the query upstream and add the returned latency to our
1329        * own */
1330       GstClockTime min_latency, max_latency;
1331       gboolean us_live;
1332       GstClockTime our_latency;
1333       guint max_samples;
1334       gint rate = GST_AUDIO_INFO_RATE (&amp;scope-&gt;ainfo);
1335 
1336       if (rate == 0)
1337         break;
1338 
1339       if ((res = gst_pad_peer_query (scope-&gt;priv-&gt;sinkpad, query))) {
1340         gst_query_parse_latency (query, &amp;us_live, &amp;min_latency, &amp;max_latency);
1341 
1342         GST_DEBUG_OBJECT (scope, &quot;Peer latency: min %&quot;
1343             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT,
1344             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1345 
1346         /* the max samples we must buffer buffer */
1347         max_samples = MAX (scope-&gt;req_spf, scope-&gt;priv-&gt;spf);
1348         our_latency = gst_util_uint64_scale_int (max_samples, GST_SECOND, rate);
1349 
1350         GST_DEBUG_OBJECT (scope, &quot;Our latency: %&quot; GST_TIME_FORMAT,
1351             GST_TIME_ARGS (our_latency));
1352 
1353         /* we add some latency but only if we need to buffer more than what
1354          * upstream gives us */
1355         min_latency += our_latency;
1356         if (max_latency != -1)
1357           max_latency += our_latency;
1358 
1359         GST_DEBUG_OBJECT (scope, &quot;Calculated total latency : min %&quot;
1360             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT,
1361             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1362 
1363         gst_query_set_latency (query, TRUE, min_latency, max_latency);
1364       }
1365       break;
1366     }
1367     default:
1368       res = gst_pad_query_default (pad, parent, query);
1369       break;
1370   }
1371 
1372   return res;
1373 }
1374 
1375 static GstStateChangeReturn
1376 gst_audio_visualizer_change_state (GstElement * element,
1377     GstStateChange transition)
1378 {
1379   GstStateChangeReturn ret;
1380   GstAudioVisualizer *scope;
1381 
1382   scope = GST_AUDIO_VISUALIZER (element);
1383 
1384   switch (transition) {
1385     case GST_STATE_CHANGE_READY_TO_PAUSED:
1386       gst_audio_visualizer_reset (scope);
1387       break;
1388     default:
1389       break;
1390   }
1391 
1392   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1393 
1394   switch (transition) {
1395     case GST_STATE_CHANGE_PAUSED_TO_READY:
1396       gst_audio_visualizer_set_allocation (scope, NULL, NULL, NULL, NULL);
1397       break;
1398     case GST_STATE_CHANGE_READY_TO_NULL:
1399       break;
1400     default:
1401       break;
1402   }
1403 
1404   return ret;
1405 }
    </pre>
  </body>
</html>