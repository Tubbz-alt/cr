<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioringbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstaudiometa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudioringbuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioringbuffer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstaudioringbuffer
  22  * @title: GstAudioRingBuffer
  23  * @short_description: Base class for audio ringbuffer implementations
  24  * @see_also: #GstAudioBaseSink, #GstAudioSink
  25  *
  26  * This object is the base class for audio ringbuffers used by the base
  27  * audio source and sink classes.
  28  *
  29  * The ringbuffer abstracts a circular buffer of data. One reader and
  30  * one writer can operate on the data from different threads in a lockfree
  31  * manner. The base class is sufficiently flexible to be used as an
  32  * abstraction for DMA based ringbuffers as well as a pure software
  33  * implementations.
  34  *
  35  */



  36 
  37 #include &lt;string.h&gt;
  38 
  39 #include &lt;gst/audio/audio.h&gt;
  40 #include &quot;gstaudioringbuffer.h&quot;
  41 
  42 GST_DEBUG_CATEGORY_STATIC (gst_audio_ring_buffer_debug);
  43 #define GST_CAT_DEFAULT gst_audio_ring_buffer_debug
  44 
  45 static void gst_audio_ring_buffer_dispose (GObject * object);
  46 static void gst_audio_ring_buffer_finalize (GObject * object);
  47 
  48 static gboolean gst_audio_ring_buffer_pause_unlocked (GstAudioRingBuffer * buf);
  49 static void default_clear_all (GstAudioRingBuffer * buf);
  50 static guint default_commit (GstAudioRingBuffer * buf, guint64 * sample,
  51     guint8 * data, gint in_samples, gint out_samples, gint * accum);
  52 
  53 /* ringbuffer abstract base class */
  54 G_DEFINE_ABSTRACT_TYPE (GstAudioRingBuffer, gst_audio_ring_buffer,
  55     GST_TYPE_OBJECT);
</pre>
<hr />
<pre>
 278     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 279       goto parse_error;
 280 
 281     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 282     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG;
 283     info.bpf = 1;
 284   } else if (g_str_equal (mimetype, &quot;audio/mpeg&quot;) &amp;&amp;
 285       gst_structure_get_int (structure, &quot;mpegversion&quot;, &amp;i) &amp;&amp;
 286       (i == 2 || i == 4) &amp;&amp;
 287       (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 288               &quot;adts&quot;)
 289           || !g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 290               &quot;raw&quot;))) {
 291     /* MPEG-2 AAC or MPEG-4 AAC */
 292     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 293       goto parse_error;
 294 
 295     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 296     if (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 297             &quot;adts&quot;))
<span class="line-modified"> 298     spec-&gt;type = (i == 2) ? GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC :</span>
<span class="line-modified"> 299         GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC;</span>
 300     else
 301       spec-&gt;type = (i == 2) ?
 302           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW :
 303           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW;
 304     info.bpf = 1;
 305   } else if (g_str_equal (mimetype, &quot;audio/x-flac&quot;)) {
 306     /* extract the needed information from the cap */
 307     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 308       goto parse_error;
 309 
 310     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 311     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC;
 312     info.bpf = 1;
 313   } else {
 314     goto parse_error;
 315   }
 316 
 317   gst_caps_replace (&amp;spec-&gt;caps, caps);
 318 
 319   g_return_val_if_fail (spec-&gt;latency_time != 0, FALSE);
</pre>
<hr />
<pre>
 409 void
 410 gst_audio_ring_buffer_set_callback_full (GstAudioRingBuffer * buf,
 411     GstAudioRingBufferCallback cb, gpointer user_data, GDestroyNotify notify)
 412 {
 413   gpointer old_data = NULL;
 414   GDestroyNotify old_notify;
 415 
 416   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
 417 
 418   GST_OBJECT_LOCK (buf);
 419   old_notify = buf-&gt;cb_data_notify;
 420   old_data = buf-&gt;cb_data;
 421 
 422   buf-&gt;callback = cb;
 423   buf-&gt;cb_data = user_data;
 424   buf-&gt;cb_data_notify = notify;
 425   GST_OBJECT_UNLOCK (buf);
 426 
 427   if (old_notify) {
 428     old_notify (old_data);
<span class="line-modified"> 429 }</span>
 430 }
 431 
 432 
 433 /**
 434  * gst_audio_ring_buffer_open_device:
 435  * @buf: the #GstAudioRingBuffer
 436  *
 437  * Open the audio device associated with the ring buffer. Does not perform any
 438  * setup on the device. You must open the device before acquiring the ring
 439  * buffer.
 440  *
 441  * Returns: TRUE if the device could be opened, FALSE on error.
 442  *
 443  * MT safe.
 444  */
 445 gboolean
 446 gst_audio_ring_buffer_open_device (GstAudioRingBuffer * buf)
 447 {
 448   gboolean res = TRUE;
 449   GstAudioRingBufferClass *rclass;
</pre>
<hr />
<pre>
1401 
1402 #define REORDER_SAMPLE(d, s, l)                 \
1403 G_STMT_START {                                  \
1404   gint i;                                       \
1405   for (i = 0; i &lt; channels; i++) {              \
1406     memcpy (d + reorder_map[i] * bps, s + i * bps, bps); \
1407   }                                             \
1408 } G_STMT_END
1409 
1410 #define REORDER_SAMPLES(d, s, len)              \
1411 G_STMT_START {                                  \
1412   gint i, len_ = len / bpf;                     \
1413   guint8 *d_ = d, *s_ = s;                      \
1414   for (i = 0; i &lt; len_; i++) {                  \
1415     REORDER_SAMPLE(d_, s_, bpf);                \
1416     d_ += bpf;                                  \
1417     s_ += bpf;                                  \
1418   }                                             \
1419 } G_STMT_END
1420 
<span class="line-modified">1421 #define FWD_SAMPLES(s,se,d,de,F)            \</span>
<span class="line-modified">1422 G_STMT_START {                  \</span>
<span class="line-modified">1423   /* no rate conversion */          \</span>
<span class="line-modified">1424   guint towrite = MIN (se + bpf - s, de - d);   \</span>
<span class="line-modified">1425   /* simple copy */             \</span>
<span class="line-modified">1426   if (!skip)                    \</span>
<span class="line-modified">1427     F (d, s, towrite);                  \</span>
<span class="line-modified">1428   in_samples -= towrite / bpf;          \</span>
<span class="line-modified">1429   out_samples -= towrite / bpf;         \</span>
<span class="line-modified">1430   s += towrite;                 \</span>
<span class="line-modified">1431   GST_DEBUG (&quot;copy %u bytes&quot;, towrite);     \</span>
1432 } G_STMT_END
1433 
1434 /* in_samples &gt;= out_samples, rate &gt; 1.0 */
<span class="line-modified">1435 #define FWD_UP_SAMPLES(s,se,d,de,F)         \</span>
<span class="line-modified">1436 G_STMT_START {                  \</span>
<span class="line-modified">1437   guint8 *sb = s, *db = d;          \</span>
<span class="line-modified">1438   while (s &lt;= se &amp;&amp; d &lt; de) {           \</span>
<span class="line-modified">1439     if (!skip)                  \</span>
<span class="line-modified">1440       F (d, s, bpf);                        \</span>
<span class="line-modified">1441     s += bpf;                   \</span>
<span class="line-modified">1442     *accum += outr;             \</span>
<span class="line-modified">1443     if ((*accum &lt;&lt; 1) &gt;= inr) {         \</span>
<span class="line-modified">1444       *accum -= inr;                \</span>
<span class="line-modified">1445       d += bpf;                 \</span>
<span class="line-modified">1446     }                       \</span>
<span class="line-modified">1447   }                     \</span>
<span class="line-modified">1448   in_samples -= (s - sb)/bpf;           \</span>
<span class="line-modified">1449   out_samples -= (d - db)/bpf;          \</span>
1450   GST_DEBUG (&quot;fwd_up end %d/%d&quot;,*accum,*toprocess); \
1451 } G_STMT_END
1452 
1453 /* out_samples &gt; in_samples, for rates smaller than 1.0 */
<span class="line-modified">1454 #define FWD_DOWN_SAMPLES(s,se,d,de,F)       \</span>
<span class="line-modified">1455 G_STMT_START {                  \</span>
<span class="line-modified">1456   guint8 *sb = s, *db = d;          \</span>
<span class="line-modified">1457   while (s &lt;= se &amp;&amp; d &lt; de) {           \</span>
<span class="line-modified">1458     if (!skip)                  \</span>
<span class="line-modified">1459       F (d, s, bpf);                        \</span>
<span class="line-modified">1460     d += bpf;                   \</span>
<span class="line-modified">1461     *accum += inr;              \</span>
<span class="line-modified">1462     if ((*accum &lt;&lt; 1) &gt;= outr) {        \</span>
<span class="line-modified">1463       *accum -= outr;               \</span>
<span class="line-modified">1464       s += bpf;                 \</span>
<span class="line-modified">1465     }                       \</span>
<span class="line-modified">1466   }                     \</span>
<span class="line-modified">1467   in_samples -= (s - sb)/bpf;           \</span>
<span class="line-modified">1468   out_samples -= (d - db)/bpf;          \</span>
<span class="line-modified">1469   GST_DEBUG (&quot;fwd_down end %d/%d&quot;,*accum,*toprocess);   \</span>
1470 } G_STMT_END
1471 
<span class="line-modified">1472 #define REV_UP_SAMPLES(s,se,d,de,F)         \</span>
<span class="line-modified">1473 G_STMT_START {                  \</span>
<span class="line-modified">1474   guint8 *sb = se, *db = d;         \</span>
<span class="line-modified">1475   while (s &lt;= se &amp;&amp; d &lt; de) {           \</span>
<span class="line-modified">1476     if (!skip)                  \</span>
<span class="line-modified">1477       F (d, se, bpf);                       \</span>
<span class="line-modified">1478     se -= bpf;                  \</span>
<span class="line-modified">1479     *accum += outr;             \</span>
<span class="line-modified">1480     while (d &lt; de &amp;&amp; (*accum &lt;&lt; 1) &gt;= inr) {    \</span>
<span class="line-modified">1481       *accum -= inr;                \</span>
<span class="line-modified">1482       d += bpf;                 \</span>
<span class="line-modified">1483     }                       \</span>
<span class="line-modified">1484   }                     \</span>
<span class="line-modified">1485   in_samples -= (sb - se)/bpf;          \</span>
<span class="line-modified">1486   out_samples -= (d - db)/bpf;          \</span>
1487   GST_DEBUG (&quot;rev_up end %d/%d&quot;,*accum,*toprocess); \
1488 } G_STMT_END
1489 
<span class="line-modified">1490 #define REV_DOWN_SAMPLES(s,se,d,de,F)       \</span>
<span class="line-modified">1491 G_STMT_START {                  \</span>
<span class="line-modified">1492   guint8 *sb = se, *db = d;         \</span>
<span class="line-modified">1493   while (s &lt;= se &amp;&amp; d &lt; de) {           \</span>
<span class="line-modified">1494     if (!skip)                  \</span>
<span class="line-modified">1495       F (d, se, bpf);                   \</span>
<span class="line-modified">1496     d += bpf;                   \</span>
<span class="line-modified">1497     *accum += inr;              \</span>
1498     while (s &lt;= se &amp;&amp; (*accum &lt;&lt; 1) &gt;= outr) {  \
<span class="line-modified">1499       *accum -= outr;               \</span>
<span class="line-modified">1500       se -= bpf;                \</span>
<span class="line-modified">1501     }                       \</span>
<span class="line-modified">1502   }                     \</span>
<span class="line-modified">1503   in_samples -= (sb - se)/bpf;          \</span>
<span class="line-modified">1504   out_samples -= (d - db)/bpf;          \</span>
<span class="line-modified">1505   GST_DEBUG (&quot;rev_down end %d/%d&quot;,*accum,*toprocess);   \</span>
1506 } G_STMT_END
1507 
1508 static guint
1509 default_commit (GstAudioRingBuffer * buf, guint64 * sample,
1510     guint8 * data, gint in_samples, gint out_samples, gint * accum)
1511 {
1512   gint segdone;
1513   gint segsize, segtotal, channels, bps, bpf, sps;
1514   guint8 *dest, *data_end;
1515   gint writeseg, sampleoff;
1516   gint *toprocess;
1517   gint inr, outr;
1518   gboolean reverse;
1519   gboolean need_reorder;
1520 
1521   g_return_val_if_fail (buf-&gt;memory != NULL, -1);
1522   g_return_val_if_fail (data != NULL, -1);
1523 
1524   need_reorder = buf-&gt;need_reorder;
1525 
</pre>
<hr />
<pre>
1806       /* else we need to wait for the segment to become readable. */
1807       if (!wait_segment (buf))
1808         goto not_started;
1809     }
1810 
1811     /* we can read now */
1812     readseg = readseg % segtotal;
1813     sampleslen = MIN (sps - sampleoff, to_read);
1814 
1815     GST_DEBUG_OBJECT (buf, &quot;read @%p seg %d, off %d, sampleslen %d&quot;,
1816         dest + readseg * segsize, readseg, sampleoff, sampleslen);
1817 
1818     if (need_reorder) {
1819       guint8 *ptr = dest + (readseg * segsize) + (sampleoff * bpf);
1820       gint i, j;
1821       gint *reorder_map = buf-&gt;channel_reorder_map;
1822 
1823       /* Reorder from device order to GStreamer order */
1824       for (i = 0; i &lt; sampleslen; i++) {
1825         for (j = 0; j &lt; channels; j++) {
<span class="line-modified">1826           memcpy (data + reorder_map[j] * bps, ptr + j * bps, bps);</span>
1827         }
1828         ptr += bpf;
1829       }
1830     } else {
1831       memcpy (data, dest + (readseg * segsize) + (sampleoff * bpf),
1832           (sampleslen * bpf));
1833     }
1834 
1835   next:
1836     to_read -= sampleslen;
1837     sample += sampleslen;
1838     data += sampleslen * bpf;
1839   }
1840 
1841   if (buf-&gt;timestamps &amp;&amp; timestamp) {
1842     *timestamp = buf-&gt;timestamps[readseg % segtotal];
1843     GST_DEBUG_OBJECT (buf, &quot;Retrieved timestamp %&quot; GST_TIME_FORMAT
1844         &quot; @ %d&quot;, GST_TIME_ARGS (*timestamp), readseg % segtotal);
1845   }
1846 
</pre>
</td>
<td>
<hr />
<pre>
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstaudioringbuffer
  22  * @title: GstAudioRingBuffer
  23  * @short_description: Base class for audio ringbuffer implementations
  24  * @see_also: #GstAudioBaseSink, #GstAudioSink
  25  *
  26  * This object is the base class for audio ringbuffers used by the base
  27  * audio source and sink classes.
  28  *
  29  * The ringbuffer abstracts a circular buffer of data. One reader and
  30  * one writer can operate on the data from different threads in a lockfree
  31  * manner. The base class is sufficiently flexible to be used as an
  32  * abstraction for DMA based ringbuffers as well as a pure software
  33  * implementations.
  34  *
  35  */
<span class="line-added">  36 #ifdef HAVE_CONFIG_H</span>
<span class="line-added">  37 #include &quot;config.h&quot;</span>
<span class="line-added">  38 #endif</span>
  39 
  40 #include &lt;string.h&gt;
  41 
  42 #include &lt;gst/audio/audio.h&gt;
  43 #include &quot;gstaudioringbuffer.h&quot;
  44 
  45 GST_DEBUG_CATEGORY_STATIC (gst_audio_ring_buffer_debug);
  46 #define GST_CAT_DEFAULT gst_audio_ring_buffer_debug
  47 
  48 static void gst_audio_ring_buffer_dispose (GObject * object);
  49 static void gst_audio_ring_buffer_finalize (GObject * object);
  50 
  51 static gboolean gst_audio_ring_buffer_pause_unlocked (GstAudioRingBuffer * buf);
  52 static void default_clear_all (GstAudioRingBuffer * buf);
  53 static guint default_commit (GstAudioRingBuffer * buf, guint64 * sample,
  54     guint8 * data, gint in_samples, gint out_samples, gint * accum);
  55 
  56 /* ringbuffer abstract base class */
  57 G_DEFINE_ABSTRACT_TYPE (GstAudioRingBuffer, gst_audio_ring_buffer,
  58     GST_TYPE_OBJECT);
</pre>
<hr />
<pre>
 281     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 282       goto parse_error;
 283 
 284     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 285     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG;
 286     info.bpf = 1;
 287   } else if (g_str_equal (mimetype, &quot;audio/mpeg&quot;) &amp;&amp;
 288       gst_structure_get_int (structure, &quot;mpegversion&quot;, &amp;i) &amp;&amp;
 289       (i == 2 || i == 4) &amp;&amp;
 290       (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 291               &quot;adts&quot;)
 292           || !g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 293               &quot;raw&quot;))) {
 294     /* MPEG-2 AAC or MPEG-4 AAC */
 295     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 296       goto parse_error;
 297 
 298     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 299     if (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 300             &quot;adts&quot;))
<span class="line-modified"> 301       spec-&gt;type = (i == 2) ? GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC :</span>
<span class="line-modified"> 302           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC;</span>
 303     else
 304       spec-&gt;type = (i == 2) ?
 305           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW :
 306           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW;
 307     info.bpf = 1;
 308   } else if (g_str_equal (mimetype, &quot;audio/x-flac&quot;)) {
 309     /* extract the needed information from the cap */
 310     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 311       goto parse_error;
 312 
 313     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 314     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC;
 315     info.bpf = 1;
 316   } else {
 317     goto parse_error;
 318   }
 319 
 320   gst_caps_replace (&amp;spec-&gt;caps, caps);
 321 
 322   g_return_val_if_fail (spec-&gt;latency_time != 0, FALSE);
</pre>
<hr />
<pre>
 412 void
 413 gst_audio_ring_buffer_set_callback_full (GstAudioRingBuffer * buf,
 414     GstAudioRingBufferCallback cb, gpointer user_data, GDestroyNotify notify)
 415 {
 416   gpointer old_data = NULL;
 417   GDestroyNotify old_notify;
 418 
 419   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
 420 
 421   GST_OBJECT_LOCK (buf);
 422   old_notify = buf-&gt;cb_data_notify;
 423   old_data = buf-&gt;cb_data;
 424 
 425   buf-&gt;callback = cb;
 426   buf-&gt;cb_data = user_data;
 427   buf-&gt;cb_data_notify = notify;
 428   GST_OBJECT_UNLOCK (buf);
 429 
 430   if (old_notify) {
 431     old_notify (old_data);
<span class="line-modified"> 432   }</span>
 433 }
 434 
 435 
 436 /**
 437  * gst_audio_ring_buffer_open_device:
 438  * @buf: the #GstAudioRingBuffer
 439  *
 440  * Open the audio device associated with the ring buffer. Does not perform any
 441  * setup on the device. You must open the device before acquiring the ring
 442  * buffer.
 443  *
 444  * Returns: TRUE if the device could be opened, FALSE on error.
 445  *
 446  * MT safe.
 447  */
 448 gboolean
 449 gst_audio_ring_buffer_open_device (GstAudioRingBuffer * buf)
 450 {
 451   gboolean res = TRUE;
 452   GstAudioRingBufferClass *rclass;
</pre>
<hr />
<pre>
1404 
1405 #define REORDER_SAMPLE(d, s, l)                 \
1406 G_STMT_START {                                  \
1407   gint i;                                       \
1408   for (i = 0; i &lt; channels; i++) {              \
1409     memcpy (d + reorder_map[i] * bps, s + i * bps, bps); \
1410   }                                             \
1411 } G_STMT_END
1412 
1413 #define REORDER_SAMPLES(d, s, len)              \
1414 G_STMT_START {                                  \
1415   gint i, len_ = len / bpf;                     \
1416   guint8 *d_ = d, *s_ = s;                      \
1417   for (i = 0; i &lt; len_; i++) {                  \
1418     REORDER_SAMPLE(d_, s_, bpf);                \
1419     d_ += bpf;                                  \
1420     s_ += bpf;                                  \
1421   }                                             \
1422 } G_STMT_END
1423 
<span class="line-modified">1424 #define FWD_SAMPLES(s,se,d,de,F)          \</span>
<span class="line-modified">1425 G_STMT_START {          \</span>
<span class="line-modified">1426   /* no rate conversion */      \</span>
<span class="line-modified">1427   guint towrite = MIN (se + bpf - s, de - d); \</span>
<span class="line-modified">1428   /* simple copy */       \</span>
<span class="line-modified">1429   if (!skip)          \</span>
<span class="line-modified">1430     F (d, s, towrite);              \</span>
<span class="line-modified">1431   in_samples -= towrite / bpf;      \</span>
<span class="line-modified">1432   out_samples -= towrite / bpf;     \</span>
<span class="line-modified">1433   s += towrite;         \</span>
<span class="line-modified">1434   GST_DEBUG (&quot;copy %u bytes&quot;, towrite);   \</span>
1435 } G_STMT_END
1436 
1437 /* in_samples &gt;= out_samples, rate &gt; 1.0 */
<span class="line-modified">1438 #define FWD_UP_SAMPLES(s,se,d,de,F)     \</span>
<span class="line-modified">1439 G_STMT_START {          \</span>
<span class="line-modified">1440   guint8 *sb = s, *db = d;      \</span>
<span class="line-modified">1441   while (s &lt;= se &amp;&amp; d &lt; de) {     \</span>
<span class="line-modified">1442     if (!skip)          \</span>
<span class="line-modified">1443       F (d, s, bpf);                    \</span>
<span class="line-modified">1444     s += bpf;         \</span>
<span class="line-modified">1445     *accum += outr;       \</span>
<span class="line-modified">1446     if ((*accum &lt;&lt; 1) &gt;= inr) {     \</span>
<span class="line-modified">1447       *accum -= inr;        \</span>
<span class="line-modified">1448       d += bpf;         \</span>
<span class="line-modified">1449     }           \</span>
<span class="line-modified">1450   }           \</span>
<span class="line-modified">1451   in_samples -= (s - sb)/bpf;     \</span>
<span class="line-modified">1452   out_samples -= (d - db)/bpf;      \</span>
1453   GST_DEBUG (&quot;fwd_up end %d/%d&quot;,*accum,*toprocess); \
1454 } G_STMT_END
1455 
1456 /* out_samples &gt; in_samples, for rates smaller than 1.0 */
<span class="line-modified">1457 #define FWD_DOWN_SAMPLES(s,se,d,de,F)     \</span>
<span class="line-modified">1458 G_STMT_START {          \</span>
<span class="line-modified">1459   guint8 *sb = s, *db = d;      \</span>
<span class="line-modified">1460   while (s &lt;= se &amp;&amp; d &lt; de) {     \</span>
<span class="line-modified">1461     if (!skip)          \</span>
<span class="line-modified">1462       F (d, s, bpf);                    \</span>
<span class="line-modified">1463     d += bpf;         \</span>
<span class="line-modified">1464     *accum += inr;        \</span>
<span class="line-modified">1465     if ((*accum &lt;&lt; 1) &gt;= outr) {    \</span>
<span class="line-modified">1466       *accum -= outr;       \</span>
<span class="line-modified">1467       s += bpf;         \</span>
<span class="line-modified">1468     }           \</span>
<span class="line-modified">1469   }           \</span>
<span class="line-modified">1470   in_samples -= (s - sb)/bpf;     \</span>
<span class="line-modified">1471   out_samples -= (d - db)/bpf;      \</span>
<span class="line-modified">1472   GST_DEBUG (&quot;fwd_down end %d/%d&quot;,*accum,*toprocess); \</span>
1473 } G_STMT_END
1474 
<span class="line-modified">1475 #define REV_UP_SAMPLES(s,se,d,de,F)     \</span>
<span class="line-modified">1476 G_STMT_START {          \</span>
<span class="line-modified">1477   guint8 *sb = se, *db = d;     \</span>
<span class="line-modified">1478   while (s &lt;= se &amp;&amp; d &lt; de) {     \</span>
<span class="line-modified">1479     if (!skip)          \</span>
<span class="line-modified">1480       F (d, se, bpf);                     \</span>
<span class="line-modified">1481     se -= bpf;          \</span>
<span class="line-modified">1482     *accum += outr;       \</span>
<span class="line-modified">1483     while (d &lt; de &amp;&amp; (*accum &lt;&lt; 1) &gt;= inr) {  \</span>
<span class="line-modified">1484       *accum -= inr;        \</span>
<span class="line-modified">1485       d += bpf;         \</span>
<span class="line-modified">1486     }           \</span>
<span class="line-modified">1487   }           \</span>
<span class="line-modified">1488   in_samples -= (sb - se)/bpf;      \</span>
<span class="line-modified">1489   out_samples -= (d - db)/bpf;      \</span>
1490   GST_DEBUG (&quot;rev_up end %d/%d&quot;,*accum,*toprocess); \
1491 } G_STMT_END
1492 
<span class="line-modified">1493 #define REV_DOWN_SAMPLES(s,se,d,de,F)     \</span>
<span class="line-modified">1494 G_STMT_START {          \</span>
<span class="line-modified">1495   guint8 *sb = se, *db = d;     \</span>
<span class="line-modified">1496   while (s &lt;= se &amp;&amp; d &lt; de) {     \</span>
<span class="line-modified">1497     if (!skip)          \</span>
<span class="line-modified">1498       F (d, se, bpf);             \</span>
<span class="line-modified">1499     d += bpf;         \</span>
<span class="line-modified">1500     *accum += inr;        \</span>
1501     while (s &lt;= se &amp;&amp; (*accum &lt;&lt; 1) &gt;= outr) {  \
<span class="line-modified">1502       *accum -= outr;       \</span>
<span class="line-modified">1503       se -= bpf;        \</span>
<span class="line-modified">1504     }           \</span>
<span class="line-modified">1505   }           \</span>
<span class="line-modified">1506   in_samples -= (sb - se)/bpf;      \</span>
<span class="line-modified">1507   out_samples -= (d - db)/bpf;      \</span>
<span class="line-modified">1508   GST_DEBUG (&quot;rev_down end %d/%d&quot;,*accum,*toprocess); \</span>
1509 } G_STMT_END
1510 
1511 static guint
1512 default_commit (GstAudioRingBuffer * buf, guint64 * sample,
1513     guint8 * data, gint in_samples, gint out_samples, gint * accum)
1514 {
1515   gint segdone;
1516   gint segsize, segtotal, channels, bps, bpf, sps;
1517   guint8 *dest, *data_end;
1518   gint writeseg, sampleoff;
1519   gint *toprocess;
1520   gint inr, outr;
1521   gboolean reverse;
1522   gboolean need_reorder;
1523 
1524   g_return_val_if_fail (buf-&gt;memory != NULL, -1);
1525   g_return_val_if_fail (data != NULL, -1);
1526 
1527   need_reorder = buf-&gt;need_reorder;
1528 
</pre>
<hr />
<pre>
1809       /* else we need to wait for the segment to become readable. */
1810       if (!wait_segment (buf))
1811         goto not_started;
1812     }
1813 
1814     /* we can read now */
1815     readseg = readseg % segtotal;
1816     sampleslen = MIN (sps - sampleoff, to_read);
1817 
1818     GST_DEBUG_OBJECT (buf, &quot;read @%p seg %d, off %d, sampleslen %d&quot;,
1819         dest + readseg * segsize, readseg, sampleoff, sampleslen);
1820 
1821     if (need_reorder) {
1822       guint8 *ptr = dest + (readseg * segsize) + (sampleoff * bpf);
1823       gint i, j;
1824       gint *reorder_map = buf-&gt;channel_reorder_map;
1825 
1826       /* Reorder from device order to GStreamer order */
1827       for (i = 0; i &lt; sampleslen; i++) {
1828         for (j = 0; j &lt; channels; j++) {
<span class="line-modified">1829           memcpy (data + i * bpf + reorder_map[j] * bps, ptr + j * bps, bps);</span>
1830         }
1831         ptr += bpf;
1832       }
1833     } else {
1834       memcpy (data, dest + (readseg * segsize) + (sampleoff * bpf),
1835           (sampleslen * bpf));
1836     }
1837 
1838   next:
1839     to_read -= sampleslen;
1840     sample += sampleslen;
1841     data += sampleslen * bpf;
1842   }
1843 
1844   if (buf-&gt;timestamps &amp;&amp; timestamp) {
1845     *timestamp = buf-&gt;timestamps[readseg % segtotal];
1846     GST_DEBUG_OBJECT (buf, &quot;Retrieved timestamp %&quot; GST_TIME_FORMAT
1847         &quot; @ %d&quot;, GST_TIME_ARGS (*timestamp), readseg % segtotal);
1848   }
1849 
</pre>
</td>
</tr>
</table>
<center><a href="gstaudiometa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudioringbuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>