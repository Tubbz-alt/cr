diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c
@@ -105,10 +105,12 @@
   gboolean buffer_lists_supported;
 
   GstAppSinkCallbacks callbacks;
   gpointer user_data;
   GDestroyNotify notify;
+
+  GstSample *sample;
 };
 
 GST_DEBUG_CATEGORY_STATIC (app_sink_debug);
 #define GST_CAT_DEFAULT app_sink_debug
 
@@ -126,16 +128,16 @@
   SIGNAL_TRY_PULL_SAMPLE,
 
   LAST_SIGNAL
 };
 
-#define DEFAULT_PROP_EOS        TRUE
-#define DEFAULT_PROP_EMIT_SIGNALS   FALSE
-#define DEFAULT_PROP_MAX_BUFFERS    0
-#define DEFAULT_PROP_DROP       FALSE
-#define DEFAULT_PROP_WAIT_ON_EOS    TRUE
-#define DEFAULT_PROP_BUFFER_LIST    FALSE
+#define DEFAULT_PROP_EOS    TRUE
+#define DEFAULT_PROP_EMIT_SIGNALS FALSE
+#define DEFAULT_PROP_MAX_BUFFERS  0
+#define DEFAULT_PROP_DROP   FALSE
+#define DEFAULT_PROP_WAIT_ON_EOS  TRUE
+#define DEFAULT_PROP_BUFFER_LIST  FALSE
 
 enum
 {
   PROP_0,
   PROP_CAPS,
@@ -184,10 +186,11 @@
 
 static guint gst_app_sink_signals[LAST_SIGNAL] = { 0 };
 
 #define gst_app_sink_parent_class parent_class
 G_DEFINE_TYPE_WITH_CODE (GstAppSink, gst_app_sink, GST_TYPE_BASE_SINK,
+    G_ADD_PRIVATE (GstAppSink)
     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
         gst_app_sink_uri_handler_init));
 
 static void
 gst_app_sink_class_init (GstAppSinkClass * klass)
@@ -282,11 +285,11 @@
       g_signal_new ("new-preroll", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
       G_STRUCT_OFFSET (GstAppSinkClass, new_preroll),
       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
   /**
    * GstAppSink::new-sample:
-   * @appsink: the appsink element that emited the signal
+   * @appsink: the appsink element that emitted the signal
    *
    * Signal that a new sample is available.
    *
    * This signal is emitted from the streaming thread and only when the
    * "emit-signals" property is %TRUE.
@@ -443,26 +446,23 @@
 
   klass->pull_preroll = gst_app_sink_pull_preroll;
   klass->pull_sample = gst_app_sink_pull_sample;
   klass->try_pull_preroll = gst_app_sink_try_pull_preroll;
   klass->try_pull_sample = gst_app_sink_try_pull_sample;
-
-  g_type_class_add_private (klass, sizeof (GstAppSinkPrivate));
 }
 
 static void
 gst_app_sink_init (GstAppSink * appsink)
 {
   GstAppSinkPrivate *priv;
 
-  priv = appsink->priv =
-      G_TYPE_INSTANCE_GET_PRIVATE (appsink, GST_TYPE_APP_SINK,
-      GstAppSinkPrivate);
+  priv = appsink->priv = gst_app_sink_get_instance_private (appsink);
 
   g_mutex_init (&priv->mutex);
   g_cond_init (&priv->cond);
   priv->queue = gst_queue_array_new (16);
+  priv->sample = gst_sample_new (NULL, NULL, NULL, NULL);
 
   priv->emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
   priv->max_buffers = DEFAULT_PROP_MAX_BUFFERS;
   priv->drop = DEFAULT_PROP_DROP;
   priv->wait_on_eos = DEFAULT_PROP_WAIT_ON_EOS;
@@ -494,10 +494,14 @@
   while ((queue_obj = gst_queue_array_pop_head (priv->queue)))
     gst_mini_object_unref (queue_obj);
   gst_buffer_replace (&priv->preroll_buffer, NULL);
   gst_caps_replace (&priv->preroll_caps, NULL);
   gst_caps_replace (&priv->last_caps, NULL);
+  if (priv->sample) {
+    gst_sample_unref (priv->sample);
+    priv->sample = NULL;
+  }
   g_mutex_unlock (&priv->mutex);
 
   G_OBJECT_CLASS (parent_class)->dispose (obj);
 }
 
@@ -664,10 +668,15 @@
   priv->wait_status = NOONE_WAITING;
   priv->flushing = FALSE;
   priv->started = TRUE;
   gst_segment_init (&priv->preroll_segment, GST_FORMAT_TIME);
   gst_segment_init (&priv->last_segment, GST_FORMAT_TIME);
+  priv->sample = gst_sample_make_writable (priv->sample);
+  gst_sample_set_buffer (priv->sample, NULL);
+  gst_sample_set_buffer_list (priv->sample, NULL);
+  gst_sample_set_caps (priv->sample, NULL);
+  gst_sample_set_segment (priv->sample, NULL);
   g_mutex_unlock (&priv->mutex);
 
   return TRUE;
 }
 
@@ -701,11 +710,11 @@
 
   g_mutex_lock (&priv->mutex);
   GST_DEBUG_OBJECT (appsink, "receiving CAPS");
   gst_queue_array_push_tail (priv->queue, gst_event_new_caps (caps));
   if (!priv->preroll_buffer)
-  gst_caps_replace (&priv->preroll_caps, caps);
+    gst_caps_replace (&priv->preroll_caps, caps);
   g_mutex_unlock (&priv->mutex);
 
   return TRUE;
 }
 
@@ -760,15 +769,15 @@
       if (priv->flushing)
         emit = FALSE;
       g_mutex_unlock (&priv->mutex);
 
       if (emit) {
-      /* emit EOS now */
-      if (priv->callbacks.eos)
-        priv->callbacks.eos (appsink, priv->user_data);
-      else
-        g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);
+        /* emit EOS now */
+        if (priv->callbacks.eos)
+          priv->callbacks.eos (appsink, priv->user_data);
+        else
+          g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);
       }
 
       break;
     }
     case GST_EVENT_FLUSH_START:
@@ -802,11 +811,11 @@
 
   GST_DEBUG_OBJECT (appsink, "setting preroll buffer %p", buffer);
   gst_buffer_replace (&priv->preroll_buffer, buffer);
 
   if ((priv->wait_status & APP_WAITING))
-  g_cond_signal (&priv->cond);
+    g_cond_signal (&priv->cond);
 
   emit = priv->emit_signals;
   g_mutex_unlock (&priv->mutex);
 
   if (priv->callbacks.new_preroll) {
@@ -850,14 +859,18 @@
           GstCaps *caps;
 
           gst_event_parse_caps (event, &caps);
           GST_DEBUG_OBJECT (appsink, "activating caps %" GST_PTR_FORMAT, caps);
           gst_caps_replace (&priv->last_caps, caps);
+          priv->sample = gst_sample_make_writable (priv->sample);
+          gst_sample_set_caps (priv->sample, priv->last_caps);
           break;
         }
         case GST_EVENT_SEGMENT:
           gst_event_copy_segment (event, &priv->last_segment);
+          priv->sample = gst_sample_make_writable (priv->sample);
+          gst_sample_set_segment (priv->sample, &priv->last_segment);
           GST_DEBUG_OBJECT (appsink, "activated segment %" GST_SEGMENT_FORMAT,
               &priv->last_segment);
           break;
         default:
           break;
@@ -886,10 +899,11 @@
   /* queue holding caps event might have been FLUSHed,
    * but caps state still present in pad caps */
   if (G_UNLIKELY (!priv->last_caps &&
           gst_pad_has_current_caps (GST_BASE_SINK_PAD (psink)))) {
     priv->last_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (psink));
+    gst_sample_set_caps (priv->sample, priv->last_caps);
     GST_DEBUG_OBJECT (appsink, "activating pad caps %" GST_PTR_FORMAT,
         priv->last_caps);
   }
 
   GST_DEBUG_OBJECT (appsink, "pushing render buffer/list %p on queue (%d)",
@@ -930,11 +944,11 @@
   /* we need to ref the buffer/list when pushing it in the queue */
   gst_queue_array_push_tail (priv->queue, gst_mini_object_ref (data));
   priv->num_buffers++;
 
   if ((priv->wait_status & APP_WAITING))
-  g_cond_signal (&priv->cond);
+    g_cond_signal (&priv->cond);
 
   emit = priv->emit_signals;
   g_mutex_unlock (&priv->mutex);
 
   if (priv->callbacks.new_sample) {
@@ -1564,12 +1578,12 @@
     priv->wait_status |= APP_WAITING;
     if (timeout_valid) {
       if (!g_cond_wait_until (&priv->cond, &priv->mutex, end_time))
         goto expired;
     } else {
-    g_cond_wait (&priv->cond, &priv->mutex);
-  }
+      g_cond_wait (&priv->cond, &priv->mutex);
+    }
     priv->wait_status &= ~APP_WAITING;
   }
   sample =
       gst_sample_new (priv->preroll_buffer, priv->preroll_caps,
       &priv->preroll_segment, NULL);
@@ -1662,29 +1676,33 @@
     priv->wait_status |= APP_WAITING;
     if (timeout_valid) {
       if (!g_cond_wait_until (&priv->cond, &priv->mutex, end_time))
         goto expired;
     } else {
-    g_cond_wait (&priv->cond, &priv->mutex);
-  }
+      g_cond_wait (&priv->cond, &priv->mutex);
+    }
     priv->wait_status &= ~APP_WAITING;
   }
 
   obj = dequeue_buffer (appsink);
   if (GST_IS_BUFFER (obj)) {
     GST_DEBUG_OBJECT (appsink, "we have a buffer %p", obj);
-    sample = gst_sample_new (GST_BUFFER_CAST (obj), priv->last_caps,
-        &priv->last_segment, NULL);
+    priv->sample = gst_sample_make_writable (priv->sample);
+    gst_sample_set_buffer_list (priv->sample, NULL);
+    gst_sample_set_buffer (priv->sample, GST_BUFFER_CAST (obj));
+    sample = gst_sample_ref (priv->sample);
   } else {
     GST_DEBUG_OBJECT (appsink, "we have a list %p", obj);
-    sample = gst_sample_new (NULL, priv->last_caps, &priv->last_segment, NULL);
-    gst_sample_set_buffer_list (sample, GST_BUFFER_LIST_CAST (obj));
+    priv->sample = gst_sample_make_writable (priv->sample);
+    gst_sample_set_buffer (priv->sample, NULL);
+    gst_sample_set_buffer_list (priv->sample, GST_BUFFER_LIST_CAST (obj));
+    sample = gst_sample_ref (priv->sample);
   }
   gst_mini_object_unref (obj);
 
   if ((priv->wait_status & STREAM_WAITING))
-  g_cond_signal (&priv->cond);
+    g_cond_signal (&priv->cond);
 
   g_mutex_unlock (&priv->mutex);
 
   return sample;
 
