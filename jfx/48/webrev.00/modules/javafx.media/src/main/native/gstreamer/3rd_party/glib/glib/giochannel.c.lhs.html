<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giochannel.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * giochannel.c: IO Channel abstraction
   5  * Copyright 1998 Owen Taylor
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 
  34 #include &lt;string.h&gt;
  35 #include &lt;errno.h&gt;
  36 
  37 #include &quot;giochannel.h&quot;
  38 
  39 #include &quot;gstrfuncs.h&quot;
  40 #include &quot;gtestutils.h&quot;
  41 #include &quot;glibintl.h&quot;
<a name="1" id="anc1"></a><span class="line-removed">  42 #include &quot;gunicodeprivate.h&quot;</span>
  43 
  44 
  45 /**
  46  * SECTION:iochannels
  47  * @title: IO Channels
  48  * @short_description: portable support for using files, pipes and sockets
  49  * @see_also: g_io_add_watch(), g_io_add_watch_full(), g_source_remove(),
  50  *     #GMainLoop
  51  *
  52  * The #GIOChannel data type aims to provide a portable method for
  53  * using file descriptors, pipes, and sockets, and integrating them
  54  * into the [main event loop][glib-The-Main-Event-Loop]. Currently,
  55  * full support is available on UNIX platforms, support for Windows
  56  * is only partially complete.
  57  *
  58  * To create a new #GIOChannel on UNIX systems use
  59  * g_io_channel_unix_new(). This works for plain file descriptors,
  60  * pipes and sockets. Alternatively, a channel can be created for a
  61  * file in a system independent manner using g_io_channel_new_file().
  62  *
  63  * Once a #GIOChannel has been created, it can be used in a generic
  64  * manner with the functions g_io_channel_read_chars(),
  65  * g_io_channel_write_chars(), g_io_channel_seek_position(), and
  66  * g_io_channel_shutdown().
  67  *
  68  * To add a #GIOChannel to the [main event loop][glib-The-Main-Event-Loop],
  69  * use g_io_add_watch() or g_io_add_watch_full(). Here you specify which
  70  * events you are interested in on the #GIOChannel, and provide a
  71  * function to be called whenever these events occur.
  72  *
  73  * #GIOChannel instances are created with an initial reference count of 1.
  74  * g_io_channel_ref() and g_io_channel_unref() can be used to
  75  * increment or decrement the reference count respectively. When the
  76  * reference count falls to 0, the #GIOChannel is freed. (Though it
  77  * isn&#39;t closed automatically, unless it was created using
  78  * g_io_channel_new_file().) Using g_io_add_watch() or
  79  * g_io_add_watch_full() increments a channel&#39;s reference count.
  80  *
  81  * The new functions g_io_channel_read_chars(),
  82  * g_io_channel_read_line(), g_io_channel_read_line_string(),
  83  * g_io_channel_read_to_end(), g_io_channel_write_chars(),
  84  * g_io_channel_seek_position(), and g_io_channel_flush() should not be
  85  * mixed with the deprecated functions g_io_channel_read(),
  86  * g_io_channel_write(), and g_io_channel_seek() on the same channel.
  87  **/
  88 
  89 /**
  90  * GIOChannel:
  91  *
  92  * A data structure representing an IO Channel. The fields should be
  93  * considered private and should only be accessed with the following
  94  * functions.
  95  **/
  96 
  97 /**
  98  * GIOFuncs:
  99  * @io_read: reads raw bytes from the channel.  This is called from
 100  *           various functions such as g_io_channel_read_chars() to
 101  *           read raw bytes from the channel.  Encoding and buffering
 102  *           issues are dealt with at a higher level.
 103  * @io_write: writes raw bytes to the channel.  This is called from
 104  *            various functions such as g_io_channel_write_chars() to
 105  *            write raw bytes to the channel.  Encoding and buffering
 106  *            issues are dealt with at a higher level.
 107  * @io_seek: (optional) seeks the channel.  This is called from
 108  *           g_io_channel_seek() on channels that support it.
 109  * @io_close: closes the channel.  This is called from
 110  *            g_io_channel_close() after flushing the buffers.
 111  * @io_create_watch: creates a watch on the channel.  This call
 112  *                   corresponds directly to g_io_create_watch().
 113  * @io_free: called from g_io_channel_unref() when the channel needs to
 114  *           be freed.  This function must free the memory associated
 115  *           with the channel, including freeing the #GIOChannel
 116  *           structure itself.  The channel buffers have been flushed
 117  *           and possibly @io_close has been called by the time this
 118  *           function is called.
 119  * @io_set_flags: sets the #GIOFlags on the channel.  This is called
 120  *                from g_io_channel_set_flags() with all flags except
 121  *                for %G_IO_FLAG_APPEND and %G_IO_FLAG_NONBLOCK masked
 122  *                out.
 123  * @io_get_flags: gets the #GIOFlags for the channel.  This function
 124  *                need only return the %G_IO_FLAG_APPEND and
 125  *                %G_IO_FLAG_NONBLOCK flags; g_io_channel_get_flags()
 126  *                automatically adds the others as appropriate.
 127  *
 128  * A table of functions used to handle different types of #GIOChannel
 129  * in a generic way.
 130  **/
 131 
 132 /**
 133  * GIOStatus:
 134  * @G_IO_STATUS_ERROR: An error occurred.
 135  * @G_IO_STATUS_NORMAL: Success.
 136  * @G_IO_STATUS_EOF: End of file.
 137  * @G_IO_STATUS_AGAIN: Resource temporarily unavailable.
 138  *
 139  * Stati returned by most of the #GIOFuncs functions.
 140  **/
 141 
 142 /**
 143  * GIOError:
 144  * @G_IO_ERROR_NONE: no error
 145  * @G_IO_ERROR_AGAIN: an EAGAIN error occurred
 146  * @G_IO_ERROR_INVAL: an EINVAL error occurred
 147  * @G_IO_ERROR_UNKNOWN: another error occurred
 148  *
 149  * #GIOError is only used by the deprecated functions
 150  * g_io_channel_read(), g_io_channel_write(), and g_io_channel_seek().
 151  **/
 152 
 153 #define G_IO_NICE_BUF_SIZE  1024
 154 
 155 /* This needs to be as wide as the largest character in any possible encoding */
<a name="2" id="anc2"></a><span class="line-modified"> 156 #define MAX_CHAR_SIZE       10</span>
 157 
 158 /* Some simplifying macros, which reduce the need to worry whether the
 159  * buffers have been allocated. These also make USE_BUF () an lvalue,
 160  * which is used in g_io_channel_read_to_end ().
 161  */
<a name="3" id="anc3"></a><span class="line-modified"> 162 #define USE_BUF(channel)    ((channel)-&gt;encoding ? (channel)-&gt;encoded_read_buf \</span>
<span class="line-modified"> 163                  : (channel)-&gt;read_buf)</span>
<span class="line-modified"> 164 #define BUF_LEN(string)     ((string) ? (string)-&gt;len : 0)</span>
<span class="line-modified"> 165 </span>
<span class="line-modified"> 166 static GIOError     g_io_error_get_from_g_error (GIOStatus    status,</span>
<span class="line-modified"> 167                              GError      *err);</span>
<span class="line-modified"> 168 static void     g_io_channel_purge      (GIOChannel  *channel);</span>
<span class="line-modified"> 169 static GIOStatus    g_io_channel_fill_buffer    (GIOChannel  *channel,</span>
<span class="line-modified"> 170                              GError     **err);</span>
<span class="line-modified"> 171 static GIOStatus    g_io_channel_read_line_backend  (GIOChannel  *channel,</span>
<span class="line-modified"> 172                              gsize       *length,</span>
<span class="line-modified"> 173                              gsize       *terminator_pos,</span>
<span class="line-modified"> 174                              GError     **error);</span>
 175 
 176 /**
 177  * g_io_channel_init:
 178  * @channel: a #GIOChannel
 179  *
 180  * Initializes a #GIOChannel struct.
 181  *
 182  * This is called by each of the above functions when creating a
 183  * #GIOChannel, and so is not often needed by the application
 184  * programmer (unless you are creating a new type of #GIOChannel).
 185  */
 186 void
 187 g_io_channel_init (GIOChannel *channel)
 188 {
 189   channel-&gt;ref_count = 1;
 190   channel-&gt;encoding = g_strdup (&quot;UTF-8&quot;);
 191   channel-&gt;line_term = NULL;
 192   channel-&gt;line_term_len = 0;
 193   channel-&gt;buf_size = G_IO_NICE_BUF_SIZE;
 194   channel-&gt;read_cd = (GIConv) -1;
 195   channel-&gt;write_cd = (GIConv) -1;
 196   channel-&gt;read_buf = NULL; /* Lazy allocate buffers */
 197   channel-&gt;encoded_read_buf = NULL;
 198   channel-&gt;write_buf = NULL;
 199   channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
 200   channel-&gt;use_buffer = TRUE;
 201   channel-&gt;do_encode = FALSE;
 202   channel-&gt;close_on_unref = FALSE;
 203 }
 204 
 205 /**
 206  * g_io_channel_ref:
 207  * @channel: a #GIOChannel
 208  *
 209  * Increments the reference count of a #GIOChannel.
 210  *
 211  * Returns: the @channel that was passed in (since 2.6)
 212  */
 213 GIOChannel *
 214 g_io_channel_ref (GIOChannel *channel)
 215 {
 216   g_return_val_if_fail (channel != NULL, NULL);
 217 
 218   g_atomic_int_inc (&amp;channel-&gt;ref_count);
 219 
 220   return channel;
 221 }
 222 
 223 /**
 224  * g_io_channel_unref:
 225  * @channel: a #GIOChannel
 226  *
 227  * Decrements the reference count of a #GIOChannel.
 228  */
 229 void
 230 g_io_channel_unref (GIOChannel *channel)
 231 {
 232   gboolean is_zero;
 233 
 234   g_return_if_fail (channel != NULL);
 235 
 236   is_zero = g_atomic_int_dec_and_test (&amp;channel-&gt;ref_count);
 237 
 238   if (G_UNLIKELY (is_zero))
 239     {
 240       if (channel-&gt;close_on_unref)
 241         g_io_channel_shutdown (channel, TRUE, NULL);
 242       else
 243         g_io_channel_purge (channel);
 244       g_free (channel-&gt;encoding);
 245       if (channel-&gt;read_cd != (GIConv) -1)
 246         g_iconv_close (channel-&gt;read_cd);
 247       if (channel-&gt;write_cd != (GIConv) -1)
 248         g_iconv_close (channel-&gt;write_cd);
 249       g_free (channel-&gt;line_term);
 250       if (channel-&gt;read_buf)
 251         g_string_free (channel-&gt;read_buf, TRUE);
 252       if (channel-&gt;write_buf)
 253         g_string_free (channel-&gt;write_buf, TRUE);
 254       if (channel-&gt;encoded_read_buf)
 255         g_string_free (channel-&gt;encoded_read_buf, TRUE);
 256       channel-&gt;funcs-&gt;io_free (channel);
 257     }
 258 }
 259 
 260 static GIOError
 261 g_io_error_get_from_g_error (GIOStatus  status,
<a name="4" id="anc4"></a><span class="line-modified"> 262                  GError    *err)</span>
 263 {
 264   switch (status)
 265     {
 266       case G_IO_STATUS_NORMAL:
 267       case G_IO_STATUS_EOF:
 268         return G_IO_ERROR_NONE;
 269       case G_IO_STATUS_AGAIN:
 270         return G_IO_ERROR_AGAIN;
 271       case G_IO_STATUS_ERROR:
<a name="5" id="anc5"></a><span class="line-modified"> 272     g_return_val_if_fail (err != NULL, G_IO_ERROR_UNKNOWN);</span>
 273 
 274         if (err-&gt;domain != G_IO_CHANNEL_ERROR)
 275           return G_IO_ERROR_UNKNOWN;
 276         switch (err-&gt;code)
 277           {
 278             case G_IO_CHANNEL_ERROR_INVAL:
 279               return G_IO_ERROR_INVAL;
 280             default:
 281               return G_IO_ERROR_UNKNOWN;
 282           }
 283       default:
 284         g_assert_not_reached ();
 285     }
 286 }
 287 
 288 /**
 289  * g_io_channel_read:
 290  * @channel: a #GIOChannel
 291  * @buf: a buffer to read the data into (which should be at least
 292  *       count bytes long)
 293  * @count: the number of bytes to read from the #GIOChannel
 294  * @bytes_read: returns the number of bytes actually read
 295  *
 296  * Reads data from a #GIOChannel.
 297  *
 298  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 299  *
 300  * Deprecated:2.2: Use g_io_channel_read_chars() instead.
 301  **/
 302 GIOError
 303 g_io_channel_read (GIOChannel *channel,
<a name="6" id="anc6"></a><span class="line-modified"> 304            gchar      *buf,</span>
<span class="line-modified"> 305            gsize       count,</span>
<span class="line-modified"> 306            gsize      *bytes_read)</span>
 307 {
 308   GError *err = NULL;
 309   GIOError error;
 310   GIOStatus status;
 311 
 312   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 313   g_return_val_if_fail (bytes_read != NULL, G_IO_ERROR_UNKNOWN);
 314 
 315   if (count == 0)
 316     {
 317       if (bytes_read)
 318         *bytes_read = 0;
 319       return G_IO_ERROR_NONE;
 320     }
 321 
 322   g_return_val_if_fail (buf != NULL, G_IO_ERROR_UNKNOWN);
 323 
 324   status = channel-&gt;funcs-&gt;io_read (channel, buf, count, bytes_read, &amp;err);
 325 
 326   error = g_io_error_get_from_g_error (status, err);
 327 
 328   if (err)
 329     g_error_free (err);
 330 
 331   return error;
 332 }
 333 
 334 /**
 335  * g_io_channel_write:
 336  * @channel:  a #GIOChannel
 337  * @buf: the buffer containing the data to write
 338  * @count: the number of bytes to write
 339  * @bytes_written: the number of bytes actually written
 340  *
 341  * Writes data to a #GIOChannel.
 342  *
 343  * Returns:  %G_IO_ERROR_NONE if the operation was successful.
 344  *
 345  * Deprecated:2.2: Use g_io_channel_write_chars() instead.
 346  **/
 347 GIOError
 348 g_io_channel_write (GIOChannel  *channel,
<a name="7" id="anc7"></a><span class="line-modified"> 349             const gchar *buf,</span>
<span class="line-modified"> 350             gsize        count,</span>
<span class="line-modified"> 351             gsize       *bytes_written)</span>
 352 {
 353   GError *err = NULL;
 354   GIOError error;
 355   GIOStatus status;
 356 
 357   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 358   g_return_val_if_fail (bytes_written != NULL, G_IO_ERROR_UNKNOWN);
 359 
 360   status = channel-&gt;funcs-&gt;io_write (channel, buf, count, bytes_written, &amp;err);
 361 
 362   error = g_io_error_get_from_g_error (status, err);
 363 
 364   if (err)
 365     g_error_free (err);
 366 
 367   return error;
 368 }
 369 
 370 /**
 371  * g_io_channel_seek:
 372  * @channel: a #GIOChannel
 373  * @offset: an offset, in bytes, which is added to the position specified
 374  *          by @type
 375  * @type: the position in the file, which can be %G_SEEK_CUR (the current
 376  *        position), %G_SEEK_SET (the start of the file), or %G_SEEK_END
 377  *        (the end of the file)
 378  *
 379  * Sets the current position in the #GIOChannel, similar to the standard
 380  * library function fseek().
 381  *
 382  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 383  *
 384  * Deprecated:2.2: Use g_io_channel_seek_position() instead.
 385  **/
 386 GIOError
 387 g_io_channel_seek (GIOChannel *channel,
<a name="8" id="anc8"></a><span class="line-modified"> 388            gint64      offset,</span>
<span class="line-modified"> 389            GSeekType   type)</span>
 390 {
 391   GError *err = NULL;
 392   GIOError error;
 393   GIOStatus status;
 394 
 395   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 396   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_ERROR_UNKNOWN);
 397 
 398   switch (type)
 399     {
 400       case G_SEEK_CUR:
 401       case G_SEEK_SET:
 402       case G_SEEK_END:
 403         break;
 404       default:
 405         g_warning (&quot;g_io_channel_seek: unknown seek type&quot;);
 406         return G_IO_ERROR_UNKNOWN;
 407     }
 408 
 409   status = channel-&gt;funcs-&gt;io_seek (channel, offset, type, &amp;err);
 410 
 411   error = g_io_error_get_from_g_error (status, err);
 412 
 413   if (err)
 414     g_error_free (err);
 415 
 416   return error;
 417 }
 418 
 419 /* The function g_io_channel_new_file() is prototyped in both
 420  * giounix.c and giowin32.c, so we stick its documentation here.
 421  */
 422 
 423 /**
 424  * g_io_channel_new_file:
 425  * @filename: (type filename): A string containing the name of a file
 426  * @mode: One of &quot;r&quot;, &quot;w&quot;, &quot;a&quot;, &quot;r+&quot;, &quot;w+&quot;, &quot;a+&quot;. These have
 427  *        the same meaning as in fopen()
 428  * @error: A location to return an error of type %G_FILE_ERROR
 429  *
 430  * Open a file @filename as a #GIOChannel using mode @mode. This
 431  * channel will be closed when the last reference to it is dropped,
 432  * so there is no need to call g_io_channel_close() (though doing
 433  * so will not cause problems, as long as no attempt is made to
 434  * access the channel after it is closed).
 435  *
 436  * Returns: A #GIOChannel on success, %NULL on failure.
 437  **/
 438 
 439 /**
 440  * g_io_channel_close:
 441  * @channel: A #GIOChannel
 442  *
 443  * Close an IO channel. Any pending data to be written will be
 444  * flushed, ignoring errors. The channel will not be freed until the
 445  * last reference is dropped using g_io_channel_unref().
 446  *
 447  * Deprecated:2.2: Use g_io_channel_shutdown() instead.
 448  **/
 449 void
 450 g_io_channel_close (GIOChannel *channel)
 451 {
 452   GError *err = NULL;
 453 
 454   g_return_if_fail (channel != NULL);
 455 
 456   g_io_channel_purge (channel);
 457 
 458   channel-&gt;funcs-&gt;io_close (channel, &amp;err);
 459 
 460   if (err)
 461     { /* No way to return the error */
 462       g_warning (&quot;Error closing channel: %s&quot;, err-&gt;message);
 463       g_error_free (err);
 464     }
 465 
 466   channel-&gt;close_on_unref = FALSE; /* Because we already did */
 467   channel-&gt;is_readable = FALSE;
 468   channel-&gt;is_writeable = FALSE;
 469   channel-&gt;is_seekable = FALSE;
 470 }
 471 
 472 /**
 473  * g_io_channel_shutdown:
 474  * @channel: a #GIOChannel
 475  * @flush: if %TRUE, flush pending
 476  * @err: location to store a #GIOChannelError
 477  *
 478  * Close an IO channel. Any pending data to be written will be
 479  * flushed if @flush is %TRUE. The channel will not be freed until the
 480  * last reference is dropped using g_io_channel_unref().
 481  *
 482  * Returns: the status of the operation.
 483  **/
 484 GIOStatus
 485 g_io_channel_shutdown (GIOChannel  *channel,
<a name="9" id="anc9"></a><span class="line-modified"> 486                gboolean     flush,</span>
<span class="line-modified"> 487                GError     **err)</span>
 488 {
 489   GIOStatus status, result;
 490   GError *tmperr = NULL;
 491 
 492   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 493   g_return_val_if_fail (err == NULL || *err == NULL, G_IO_STATUS_ERROR);
 494 
 495   if (channel-&gt;write_buf &amp;&amp; channel-&gt;write_buf-&gt;len &gt; 0)
 496     {
 497       if (flush)
 498         {
 499           GIOFlags flags;
 500 
 501           /* Set the channel to blocking, to avoid a busy loop
 502            */
 503           flags = g_io_channel_get_flags (channel);
 504           /* Ignore any errors here, they&#39;re irrelevant */
 505           g_io_channel_set_flags (channel, flags &amp; ~G_IO_FLAG_NONBLOCK, NULL);
 506 
 507           result = g_io_channel_flush (channel, &amp;tmperr);
 508         }
 509       else
 510         result = G_IO_STATUS_NORMAL;
 511 
 512       g_string_truncate(channel-&gt;write_buf, 0);
 513     }
 514   else
 515     result = G_IO_STATUS_NORMAL;
 516 
 517   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
 518     {
 519       if (flush)
 520         g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
 521       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
 522     }
 523 
 524   status = channel-&gt;funcs-&gt;io_close (channel, err);
 525 
 526   channel-&gt;close_on_unref = FALSE; /* Because we already did */
 527   channel-&gt;is_readable = FALSE;
 528   channel-&gt;is_writeable = FALSE;
 529   channel-&gt;is_seekable = FALSE;
 530 
 531   if (status != G_IO_STATUS_NORMAL)
 532     {
 533       g_clear_error (&amp;tmperr);
 534       return status;
 535     }
 536   else if (result != G_IO_STATUS_NORMAL)
 537     {
 538       g_propagate_error (err, tmperr);
 539       return result;
 540     }
 541   else
 542     return G_IO_STATUS_NORMAL;
 543 }
 544 
 545 /* This function is used for the final flush on close or unref */
 546 static void
 547 g_io_channel_purge (GIOChannel *channel)
 548 {
 549   GError *err = NULL;
 550   GIOStatus status G_GNUC_UNUSED;
 551 
 552   g_return_if_fail (channel != NULL);
 553 
 554   if (channel-&gt;write_buf &amp;&amp; channel-&gt;write_buf-&gt;len &gt; 0)
 555     {
 556       GIOFlags flags;
 557 
 558       /* Set the channel to blocking, to avoid a busy loop
 559        */
 560       flags = g_io_channel_get_flags (channel);
 561       g_io_channel_set_flags (channel, flags &amp; ~G_IO_FLAG_NONBLOCK, NULL);
 562 
 563       status = g_io_channel_flush (channel, &amp;err);
 564 
 565       if (err)
 566         { /* No way to return the error */
 567           g_warning (&quot;Error flushing string: %s&quot;, err-&gt;message);
 568           g_error_free (err);
 569         }
 570     }
 571 
 572   /* Flush these in case anyone tries to close without unrefing */
 573 
 574   if (channel-&gt;read_buf)
 575     g_string_truncate (channel-&gt;read_buf, 0);
 576   if (channel-&gt;write_buf)
 577     g_string_truncate (channel-&gt;write_buf, 0);
 578   if (channel-&gt;encoding)
 579     {
 580       if (channel-&gt;encoded_read_buf)
 581         g_string_truncate (channel-&gt;encoded_read_buf, 0);
 582 
 583       if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
 584         {
 585           g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
 586           channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
 587         }
 588     }
 589 }
 590 
 591 /**
 592  * g_io_create_watch:
 593  * @channel: a #GIOChannel to watch
 594  * @condition: conditions to watch for
 595  *
 596  * Creates a #GSource that&#39;s dispatched when @condition is met for the
 597  * given @channel. For example, if condition is #G_IO_IN, the source will
 598  * be dispatched when there&#39;s data available for reading.
 599  *
 600  * g_io_add_watch() is a simpler interface to this same functionality, for
 601  * the case where you want to add the source to the default main loop context
 602  * at the default priority.
 603  *
 604  * On Windows, polling a #GSource created to watch a channel for a socket
 605  * puts the socket in non-blocking mode. This is a side-effect of the
 606  * implementation and unavoidable.
 607  *
 608  * Returns: a new #GSource
 609  */
 610 GSource *
 611 g_io_create_watch (GIOChannel   *channel,
<a name="10" id="anc10"></a><span class="line-modified"> 612            GIOCondition  condition)</span>
 613 {
 614   g_return_val_if_fail (channel != NULL, NULL);
 615 
 616   return channel-&gt;funcs-&gt;io_create_watch (channel, condition);
 617 }
 618 
 619 /**
 620  * g_io_add_watch_full: (rename-to g_io_add_watch)
 621  * @channel: a #GIOChannel
 622  * @priority: the priority of the #GIOChannel source
 623  * @condition: the condition to watch for
 624  * @func: the function to call when the condition is satisfied
 625  * @user_data: user data to pass to @func
 626  * @notify: the function to call when the source is removed
 627  *
 628  * Adds the #GIOChannel into the default main loop context
 629  * with the given priority.
 630  *
 631  * This internally creates a main loop source using g_io_create_watch()
 632  * and attaches it to the main loop context with g_source_attach().
 633  * You can do these steps manually if you need greater control.
 634  *
 635  * Returns: the event source id
 636  */
 637 guint
 638 g_io_add_watch_full (GIOChannel    *channel,
<a name="11" id="anc11"></a><span class="line-modified"> 639              gint           priority,</span>
<span class="line-modified"> 640              GIOCondition   condition,</span>
<span class="line-modified"> 641              GIOFunc        func,</span>
<span class="line-modified"> 642              gpointer       user_data,</span>
<span class="line-modified"> 643              GDestroyNotify notify)</span>
 644 {
 645   GSource *source;
 646   guint id;
 647 
 648   g_return_val_if_fail (channel != NULL, 0);
 649 
 650   source = g_io_create_watch (channel, condition);
 651 
 652   if (priority != G_PRIORITY_DEFAULT)
 653     g_source_set_priority (source, priority);
 654   g_source_set_callback (source, (GSourceFunc)func, user_data, notify);
 655 
 656   id = g_source_attach (source, NULL);
 657   g_source_unref (source);
 658 
 659   return id;
 660 }
 661 
 662 /**
 663  * g_io_add_watch:
 664  * @channel: a #GIOChannel
 665  * @condition: the condition to watch for
 666  * @func: the function to call when the condition is satisfied
 667  * @user_data: user data to pass to @func
 668  *
 669  * Adds the #GIOChannel into the default main loop context
 670  * with the default priority.
 671  *
 672  * Returns: the event source id
 673  */
 674 /**
 675  * GIOFunc:
 676  * @source: the #GIOChannel event source
 677  * @condition: the condition which has been satisfied
 678  * @data: user data set in g_io_add_watch() or g_io_add_watch_full()
 679  *
 680  * Specifies the type of function passed to g_io_add_watch() or
 681  * g_io_add_watch_full(), which is called when the requested condition
 682  * on a #GIOChannel is satisfied.
 683  *
 684  * Returns: the function should return %FALSE if the event source
 685  *          should be removed
 686  **/
 687 /**
 688  * GIOCondition:
 689  * @G_IO_IN: There is data to read.
 690  * @G_IO_OUT: Data can be written (without blocking).
 691  * @G_IO_PRI: There is urgent data to read.
 692  * @G_IO_ERR: Error condition.
 693  * @G_IO_HUP: Hung up (the connection has been broken, usually for
 694  *            pipes and sockets).
 695  * @G_IO_NVAL: Invalid request. The file descriptor is not open.
 696  *
 697  * A bitwise combination representing a condition to watch for on an
 698  * event source.
 699  **/
 700 guint
 701 g_io_add_watch (GIOChannel   *channel,
<a name="12" id="anc12"></a><span class="line-modified"> 702         GIOCondition  condition,</span>
<span class="line-modified"> 703         GIOFunc       func,</span>
<span class="line-modified"> 704         gpointer      user_data)</span>
 705 {
 706   return g_io_add_watch_full (channel, G_PRIORITY_DEFAULT, condition, func, user_data, NULL);
 707 }
 708 
 709 /**
 710  * g_io_channel_get_buffer_condition:
 711  * @channel: A #GIOChannel
 712  *
 713  * This function returns a #GIOCondition depending on whether there
 714  * is data to be read/space to write data in the internal buffers in
 715  * the #GIOChannel. Only the flags %G_IO_IN and %G_IO_OUT may be set.
 716  *
 717  * Returns: A #GIOCondition
 718  **/
 719 GIOCondition
 720 g_io_channel_get_buffer_condition (GIOChannel *channel)
 721 {
 722   GIOCondition condition = 0;
 723 
 724   if (channel-&gt;encoding)
 725     {
 726       if (channel-&gt;encoded_read_buf &amp;&amp; (channel-&gt;encoded_read_buf-&gt;len &gt; 0))
 727         condition |= G_IO_IN; /* Only return if we have full characters */
 728     }
 729   else
 730     {
 731       if (channel-&gt;read_buf &amp;&amp; (channel-&gt;read_buf-&gt;len &gt; 0))
 732         condition |= G_IO_IN;
 733     }
 734 
 735   if (channel-&gt;write_buf &amp;&amp; (channel-&gt;write_buf-&gt;len &lt; channel-&gt;buf_size))
 736     condition |= G_IO_OUT;
 737 
 738   return condition;
 739 }
 740 
 741 /**
 742  * g_io_channel_error_from_errno:
 743  * @en: an `errno` error number, e.g. `EINVAL`
 744  *
 745  * Converts an `errno` error number to a #GIOChannelError.
 746  *
 747  * Returns: a #GIOChannelError error number, e.g.
 748  *      %G_IO_CHANNEL_ERROR_INVAL.
 749  **/
 750 GIOChannelError
 751 g_io_channel_error_from_errno (gint en)
 752 {
 753 #ifdef EAGAIN
 754   g_return_val_if_fail (en != EAGAIN, G_IO_CHANNEL_ERROR_FAILED);
 755 #endif
 756 
 757   switch (en)
 758     {
 759 #ifdef EBADF
 760     case EBADF:
 761       g_warning (&quot;Invalid file descriptor.&quot;);
 762       return G_IO_CHANNEL_ERROR_FAILED;
 763 #endif
 764 
 765 #ifdef EFAULT
 766     case EFAULT:
 767       g_warning (&quot;Buffer outside valid address space.&quot;);
 768       return G_IO_CHANNEL_ERROR_FAILED;
 769 #endif
 770 
 771 #ifdef EFBIG
 772     case EFBIG:
 773       return G_IO_CHANNEL_ERROR_FBIG;
 774 #endif
 775 
 776 #ifdef EINTR
 777     /* In general, we should catch EINTR before we get here,
 778      * but close() is allowed to return EINTR by POSIX, so
 779      * we need to catch it here; EINTR from close() is
 780      * unrecoverable, because it&#39;s undefined whether
 781      * the fd was actually closed or not, so we just return
 782      * a generic error code.
 783      */
 784     case EINTR:
 785       return G_IO_CHANNEL_ERROR_FAILED;
 786 #endif
 787 
 788 #ifdef EINVAL
 789     case EINVAL:
 790       return G_IO_CHANNEL_ERROR_INVAL;
 791 #endif
 792 
 793 #ifdef EIO
 794     case EIO:
 795       return G_IO_CHANNEL_ERROR_IO;
 796 #endif
 797 
 798 #ifdef EISDIR
 799     case EISDIR:
 800       return G_IO_CHANNEL_ERROR_ISDIR;
 801 #endif
 802 
 803 #ifdef ENOSPC
 804     case ENOSPC:
 805       return G_IO_CHANNEL_ERROR_NOSPC;
 806 #endif
 807 
 808 #ifdef ENXIO
 809     case ENXIO:
 810       return G_IO_CHANNEL_ERROR_NXIO;
 811 #endif
 812 
 813 #ifdef EOVERFLOW
 814 #if EOVERFLOW != EFBIG
 815     case EOVERFLOW:
 816       return G_IO_CHANNEL_ERROR_OVERFLOW;
 817 #endif
 818 #endif
 819 
 820 #ifdef EPIPE
 821     case EPIPE:
 822       return G_IO_CHANNEL_ERROR_PIPE;
 823 #endif
 824 
 825     default:
 826       return G_IO_CHANNEL_ERROR_FAILED;
 827     }
 828 }
 829 
 830 /**
 831  * g_io_channel_set_buffer_size:
 832  * @channel: a #GIOChannel
 833  * @size: the size of the buffer, or 0 to let GLib pick a good size
 834  *
 835  * Sets the buffer size.
 836  **/
 837 void
 838 g_io_channel_set_buffer_size (GIOChannel *channel,
 839                               gsize       size)
 840 {
 841   g_return_if_fail (channel != NULL);
 842 
 843   if (size == 0)
 844     size = G_IO_NICE_BUF_SIZE;
 845 
 846   if (size &lt; MAX_CHAR_SIZE)
 847     size = MAX_CHAR_SIZE;
 848 
 849   channel-&gt;buf_size = size;
 850 }
 851 
 852 /**
 853  * g_io_channel_get_buffer_size:
 854  * @channel: a #GIOChannel
 855  *
 856  * Gets the buffer size.
 857  *
 858  * Returns: the size of the buffer.
 859  **/
 860 gsize
 861 g_io_channel_get_buffer_size (GIOChannel *channel)
 862 {
 863   g_return_val_if_fail (channel != NULL, 0);
 864 
 865   return channel-&gt;buf_size;
 866 }
 867 
 868 /**
 869  * g_io_channel_set_line_term:
 870  * @channel: a #GIOChannel
 871  * @line_term: (nullable): The line termination string. Use %NULL for
 872  *             autodetect.  Autodetection breaks on &quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\0&quot;,
 873  *             and the Unicode paragraph separator. Autodetection should not be
 874  *             used for anything other than file-based channels.
 875  * @length: The length of the termination string. If -1 is passed, the
 876  *          string is assumed to be nul-terminated. This option allows
 877  *          termination strings with embedded nuls.
 878  *
 879  * This sets the string that #GIOChannel uses to determine
 880  * where in the file a line break occurs.
 881  **/
 882 void
 883 g_io_channel_set_line_term (GIOChannel  *channel,
 884                             const gchar *line_term,
<a name="13" id="anc13"></a><span class="line-modified"> 885                 gint         length)</span>
 886 {
 887   g_return_if_fail (channel != NULL);
 888   g_return_if_fail (line_term == NULL || length != 0); /* Disallow &quot;&quot; */
 889 
 890   if (line_term == NULL)
 891     length = 0;
 892   else if (length &lt; 0)
 893     length = strlen (line_term);
 894 
 895   g_free (channel-&gt;line_term);
 896   channel-&gt;line_term = line_term ? g_memdup (line_term, length) : NULL;
 897   channel-&gt;line_term_len = length;
 898 }
 899 
 900 /**
 901  * g_io_channel_get_line_term:
 902  * @channel: a #GIOChannel
 903  * @length: a location to return the length of the line terminator
 904  *
 905  * This returns the string that #GIOChannel uses to determine
 906  * where in the file a line break occurs. A value of %NULL
 907  * indicates autodetection.
 908  *
 909  * Returns: The line termination string. This value
 910  *   is owned by GLib and must not be freed.
 911  **/
 912 const gchar *
 913 g_io_channel_get_line_term (GIOChannel *channel,
<a name="14" id="anc14"></a><span class="line-modified"> 914                 gint       *length)</span>
 915 {
 916   g_return_val_if_fail (channel != NULL, NULL);
 917 
 918   if (length)
 919     *length = channel-&gt;line_term_len;
 920 
 921   return channel-&gt;line_term;
 922 }
 923 
 924 /**
 925  * g_io_channel_set_flags:
 926  * @channel: a #GIOChannel
 927  * @flags: the flags to set on the IO channel
 928  * @error: A location to return an error of type #GIOChannelError
 929  *
 930  * Sets the (writeable) flags in @channel to (@flags &amp; %G_IO_FLAG_SET_MASK).
 931  *
 932  * Returns: the status of the operation.
 933  **/
 934 /**
 935  * GIOFlags:
 936  * @G_IO_FLAG_APPEND: turns on append mode, corresponds to %O_APPEND
 937  *     (see the documentation of the UNIX open() syscall)
 938  * @G_IO_FLAG_NONBLOCK: turns on nonblocking mode, corresponds to
 939  *     %O_NONBLOCK/%O_NDELAY (see the documentation of the UNIX open()
 940  *     syscall)
 941  * @G_IO_FLAG_IS_READABLE: indicates that the io channel is readable.
 942  *     This flag cannot be changed.
 943  * @G_IO_FLAG_IS_WRITABLE: indicates that the io channel is writable.
 944  *     This flag cannot be changed.
 945  * @G_IO_FLAG_IS_WRITEABLE: a misspelled version of @G_IO_FLAG_IS_WRITABLE
 946  *     that existed before the spelling was fixed in GLib 2.30. It is kept
 947  *     here for compatibility reasons. Deprecated since 2.30
 948  * @G_IO_FLAG_IS_SEEKABLE: indicates that the io channel is seekable,
 949  *     i.e. that g_io_channel_seek_position() can be used on it.
 950  *     This flag cannot be changed.
 951  * @G_IO_FLAG_MASK: the mask that specifies all the valid flags.
 952  * @G_IO_FLAG_GET_MASK: the mask of the flags that are returned from
 953  *     g_io_channel_get_flags()
 954  * @G_IO_FLAG_SET_MASK: the mask of the flags that the user can modify
 955  *     with g_io_channel_set_flags()
 956  *
 957  * Specifies properties of a #GIOChannel. Some of the flags can only be
 958  * read with g_io_channel_get_flags(), but not changed with
 959  * g_io_channel_set_flags().
 960  */
 961 GIOStatus
 962 g_io_channel_set_flags (GIOChannel  *channel,
 963                         GIOFlags     flags,
 964                         GError     **error)
 965 {
 966   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 967   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="15" id="anc15"></a><span class="line-modified"> 968             G_IO_STATUS_ERROR);</span>
 969 
 970   return (*channel-&gt;funcs-&gt;io_set_flags) (channel,
<a name="16" id="anc16"></a><span class="line-modified"> 971                       flags &amp; G_IO_FLAG_SET_MASK,</span>
<span class="line-modified"> 972                       error);</span>
 973 }
 974 
 975 /**
 976  * g_io_channel_get_flags:
 977  * @channel: a #GIOChannel
 978  *
 979  * Gets the current flags for a #GIOChannel, including read-only
 980  * flags such as %G_IO_FLAG_IS_READABLE.
 981  *
 982  * The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITABLE
 983  * are cached for internal use by the channel when it is created.
 984  * If they should change at some later point (e.g. partial shutdown
 985  * of a socket with the UNIX shutdown() function), the user
 986  * should immediately call g_io_channel_get_flags() to update
 987  * the internal values of these flags.
 988  *
 989  * Returns: the flags which are set on the channel
 990  **/
 991 GIOFlags
 992 g_io_channel_get_flags (GIOChannel *channel)
 993 {
 994   GIOFlags flags;
 995 
 996   g_return_val_if_fail (channel != NULL, 0);
 997 
 998   flags = (* channel-&gt;funcs-&gt;io_get_flags) (channel);
 999 
1000   /* Cross implementation code */
1001 
1002   if (channel-&gt;is_seekable)
1003     flags |= G_IO_FLAG_IS_SEEKABLE;
1004   if (channel-&gt;is_readable)
1005     flags |= G_IO_FLAG_IS_READABLE;
1006   if (channel-&gt;is_writeable)
1007     flags |= G_IO_FLAG_IS_WRITABLE;
1008 
1009   return flags;
1010 }
1011 
1012 /**
1013  * g_io_channel_set_close_on_unref:
1014  * @channel: a #GIOChannel
1015  * @do_close: Whether to close the channel on the final unref of
1016  *            the GIOChannel data structure.
1017  *
1018  * Whether to close the channel on the final unref of the #GIOChannel
1019  * data structure. The default value of this is %TRUE for channels
1020  * created by g_io_channel_new_file (), and %FALSE for all other channels.
1021  *
1022  * Setting this flag to %TRUE for a channel you have already closed
1023  * can cause problems when the final reference to the #GIOChannel is dropped.
1024  **/
1025 void
1026 g_io_channel_set_close_on_unref (GIOChannel *channel,
<a name="17" id="anc17"></a><span class="line-modified">1027                                  gboolean    do_close)</span>
1028 {
1029   g_return_if_fail (channel != NULL);
1030 
1031   channel-&gt;close_on_unref = do_close;
1032 }
1033 
1034 /**
1035  * g_io_channel_get_close_on_unref:
1036  * @channel: a #GIOChannel.
1037  *
1038  * Returns whether the file/socket/whatever associated with @channel
1039  * will be closed when @channel receives its final unref and is
1040  * destroyed. The default value of this is %TRUE for channels created
1041  * by g_io_channel_new_file (), and %FALSE for all other channels.
1042  *
1043  * Returns: %TRUE if the channel will be closed, %FALSE otherwise.
1044  **/
1045 gboolean
1046 g_io_channel_get_close_on_unref (GIOChannel *channel)
1047 {
1048   g_return_val_if_fail (channel != NULL, FALSE);
1049 
1050   return channel-&gt;close_on_unref;
1051 }
1052 
1053 /**
1054  * g_io_channel_seek_position:
1055  * @channel: a #GIOChannel
1056  * @offset: The offset in bytes from the position specified by @type
1057  * @type: a #GSeekType. The type %G_SEEK_CUR is only allowed in those
1058  *                      cases where a call to g_io_channel_set_encoding ()
1059  *                      is allowed. See the documentation for
1060  *                      g_io_channel_set_encoding () for details.
1061  * @error: A location to return an error of type #GIOChannelError
1062  *
1063  * Replacement for g_io_channel_seek() with the new API.
1064  *
1065  * Returns: the status of the operation.
1066  **/
1067 /**
1068  * GSeekType:
1069  * @G_SEEK_CUR: the current position in the file.
1070  * @G_SEEK_SET: the start of the file.
1071  * @G_SEEK_END: the end of the file.
1072  *
1073  * An enumeration specifying the base position for a
1074  * g_io_channel_seek_position() operation.
1075  **/
1076 GIOStatus
1077 g_io_channel_seek_position (GIOChannel  *channel,
1078                             gint64       offset,
1079                             GSeekType    type,
1080                             GError     **error)
1081 {
1082   GIOStatus status;
1083 
1084   /* For files, only one of the read and write buffers can contain data.
1085    * For sockets, both can contain data.
1086    */
1087 
1088   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1089   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="18" id="anc18"></a><span class="line-modified">1090             G_IO_STATUS_ERROR);</span>
1091   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_STATUS_ERROR);
1092 
1093   switch (type)
1094     {
1095       case G_SEEK_CUR: /* The user is seeking relative to the head of the buffer */
1096         if (channel-&gt;use_buffer)
1097           {
1098             if (channel-&gt;do_encode &amp;&amp; channel-&gt;encoded_read_buf
1099                 &amp;&amp; channel-&gt;encoded_read_buf-&gt;len &gt; 0)
1100               {
1101                 g_warning (&quot;Seek type G_SEEK_CUR not allowed for this&quot;
1102                   &quot; channel&#39;s encoding.&quot;);
1103                 return G_IO_STATUS_ERROR;
1104               }
1105           if (channel-&gt;read_buf)
1106             offset -= channel-&gt;read_buf-&gt;len;
1107           if (channel-&gt;encoded_read_buf)
1108             {
1109               g_assert (channel-&gt;encoded_read_buf-&gt;len == 0 || !channel-&gt;do_encode);
1110 
1111               /* If there&#39;s anything here, it&#39;s because the encoding is UTF-8,
1112                * so we can just subtract the buffer length, the same as for
1113                * the unencoded data.
1114                */
1115 
1116               offset -= channel-&gt;encoded_read_buf-&gt;len;
1117             }
1118           }
1119         break;
1120       case G_SEEK_SET:
1121       case G_SEEK_END:
1122         break;
1123       default:
1124         g_warning (&quot;g_io_channel_seek_position: unknown seek type&quot;);
1125         return G_IO_STATUS_ERROR;
1126     }
1127 
1128   if (channel-&gt;use_buffer)
1129     {
1130       status = g_io_channel_flush (channel, error);
1131       if (status != G_IO_STATUS_NORMAL)
1132         return status;
1133     }
1134 
1135   status = channel-&gt;funcs-&gt;io_seek (channel, offset, type, error);
1136 
1137   if ((status == G_IO_STATUS_NORMAL) &amp;&amp; (channel-&gt;use_buffer))
1138     {
1139       if (channel-&gt;read_buf)
1140         g_string_truncate (channel-&gt;read_buf, 0);
1141 
1142       /* Conversion state no longer matches position in file */
1143       if (channel-&gt;read_cd != (GIConv) -1)
1144         g_iconv (channel-&gt;read_cd, NULL, NULL, NULL, NULL);
1145       if (channel-&gt;write_cd != (GIConv) -1)
1146         g_iconv (channel-&gt;write_cd, NULL, NULL, NULL, NULL);
1147 
1148       if (channel-&gt;encoded_read_buf)
1149         {
1150           g_assert (channel-&gt;encoded_read_buf-&gt;len == 0 || !channel-&gt;do_encode);
1151           g_string_truncate (channel-&gt;encoded_read_buf, 0);
1152         }
1153 
1154       if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
1155         {
1156           g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
1157           channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1158         }
1159     }
1160 
1161   return status;
1162 }
1163 
1164 /**
1165  * g_io_channel_flush:
1166  * @channel: a #GIOChannel
1167  * @error: location to store an error of type #GIOChannelError
1168  *
1169  * Flushes the write buffer for the GIOChannel.
1170  *
1171  * Returns: the status of the operation: One of
1172  *   #G_IO_STATUS_NORMAL, #G_IO_STATUS_AGAIN, or
1173  *   #G_IO_STATUS_ERROR.
1174  **/
1175 GIOStatus
1176 g_io_channel_flush (GIOChannel  *channel,
<a name="19" id="anc19"></a><span class="line-modified">1177                     GError     **error)</span>
1178 {
1179   GIOStatus status;
1180   gsize this_time = 1, bytes_written = 0;
1181 
1182   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1183   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1184 
1185   if (channel-&gt;write_buf == NULL || channel-&gt;write_buf-&gt;len == 0)
1186     return G_IO_STATUS_NORMAL;
1187 
1188   do
1189     {
1190       g_assert (this_time &gt; 0);
1191 
1192       status = channel-&gt;funcs-&gt;io_write (channel,
<a name="20" id="anc20"></a><span class="line-modified">1193                      channel-&gt;write_buf-&gt;str + bytes_written,</span>
<span class="line-modified">1194                      channel-&gt;write_buf-&gt;len - bytes_written,</span>
<span class="line-modified">1195                      &amp;this_time, error);</span>
1196       bytes_written += this_time;
1197     }
1198   while ((bytes_written &lt; channel-&gt;write_buf-&gt;len)
1199          &amp;&amp; (status == G_IO_STATUS_NORMAL));
1200 
1201   g_string_erase (channel-&gt;write_buf, 0, bytes_written);
1202 
1203   return status;
1204 }
1205 
1206 /**
1207  * g_io_channel_set_buffered:
1208  * @channel: a #GIOChannel
1209  * @buffered: whether to set the channel buffered or unbuffered
1210  *
1211  * The buffering state can only be set if the channel&#39;s encoding
1212  * is %NULL. For any other encoding, the channel must be buffered.
1213  *
1214  * A buffered channel can only be set unbuffered if the channel&#39;s
1215  * internal buffers have been flushed. Newly created channels or
1216  * channels which have returned %G_IO_STATUS_EOF
1217  * not require such a flush. For write-only channels, a call to
1218  * g_io_channel_flush () is sufficient. For all other channels,
1219  * the buffers may be flushed by a call to g_io_channel_seek_position ().
1220  * This includes the possibility of seeking with seek type %G_SEEK_CUR
1221  * and an offset of zero. Note that this means that socket-based
1222  * channels cannot be set unbuffered once they have had data
1223  * read from them.
1224  *
1225  * On unbuffered channels, it is safe to mix read and write
1226  * calls from the new and old APIs, if this is necessary for
1227  * maintaining old code.
1228  *
1229  * The default state of the channel is buffered.
1230  **/
1231 void
1232 g_io_channel_set_buffered (GIOChannel *channel,
1233                            gboolean    buffered)
1234 {
1235   g_return_if_fail (channel != NULL);
1236 
1237   if (channel-&gt;encoding != NULL)
1238     {
1239       g_warning (&quot;Need to have NULL encoding to set the buffering state of the &quot;
1240                  &quot;channel.&quot;);
1241       return;
1242     }
1243 
1244   g_return_if_fail (!channel-&gt;read_buf || channel-&gt;read_buf-&gt;len == 0);
1245   g_return_if_fail (!channel-&gt;write_buf || channel-&gt;write_buf-&gt;len == 0);
1246 
1247   channel-&gt;use_buffer = buffered;
1248 }
1249 
1250 /**
1251  * g_io_channel_get_buffered:
1252  * @channel: a #GIOChannel
1253  *
1254  * Returns whether @channel is buffered.
1255  *
1256  * Return Value: %TRUE if the @channel is buffered.
1257  **/
1258 gboolean
1259 g_io_channel_get_buffered (GIOChannel *channel)
1260 {
1261   g_return_val_if_fail (channel != NULL, FALSE);
1262 
1263   return channel-&gt;use_buffer;
1264 }
1265 
1266 /**
1267  * g_io_channel_set_encoding:
1268  * @channel: a #GIOChannel
1269  * @encoding: (nullable): the encoding type
1270  * @error: location to store an error of type #GConvertError
1271  *
1272  * Sets the encoding for the input/output of the channel.
1273  * The internal encoding is always UTF-8. The default encoding
1274  * for the external file is UTF-8.
1275  *
1276  * The encoding %NULL is safe to use with binary data.
1277  *
1278  * The encoding can only be set if one of the following conditions
1279  * is true:
1280  *
1281  * - The channel was just created, and has not been written to or read from yet.
1282  *
1283  * - The channel is write-only.
1284  *
1285  * - The channel is a file, and the file pointer was just repositioned
1286  *   by a call to g_io_channel_seek_position(). (This flushes all the
1287  *   internal buffers.)
1288  *
1289  * - The current encoding is %NULL or UTF-8.
1290  *
1291  * - One of the (new API) read functions has just returned %G_IO_STATUS_EOF
1292  *   (or, in the case of g_io_channel_read_to_end(), %G_IO_STATUS_NORMAL).
1293  *
1294  * -  One of the functions g_io_channel_read_chars() or
1295  *    g_io_channel_read_unichar() has returned %G_IO_STATUS_AGAIN or
1296  *    %G_IO_STATUS_ERROR. This may be useful in the case of
1297  *    %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1298  *    Returning one of these statuses from g_io_channel_read_line(),
1299  *    g_io_channel_read_line_string(), or g_io_channel_read_to_end()
1300  *    does not guarantee that the encoding can be changed.
1301  *
1302  * Channels which do not meet one of the above conditions cannot call
1303  * g_io_channel_seek_position() with an offset of %G_SEEK_CUR, and, if
1304  * they are &quot;seekable&quot;, cannot call g_io_channel_write_chars() after
1305  * calling one of the API &quot;read&quot; functions.
1306  *
1307  * Return Value: %G_IO_STATUS_NORMAL if the encoding was successfully set
1308  */
1309 GIOStatus
<a name="21" id="anc21"></a><span class="line-modified">1310 g_io_channel_set_encoding (GIOChannel   *channel,</span>
1311                            const gchar  *encoding,
<a name="22" id="anc22"></a><span class="line-modified">1312                            GError      **error)</span>
1313 {
1314   GIConv read_cd, write_cd;
<a name="23" id="anc23"></a>
1315   gboolean did_encode;
<a name="24" id="anc24"></a>
1316 
1317   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1318   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1319 
1320   /* Make sure the encoded buffers are empty */
1321 
1322   g_return_val_if_fail (!channel-&gt;do_encode || !channel-&gt;encoded_read_buf ||
<a name="25" id="anc25"></a><span class="line-modified">1323             channel-&gt;encoded_read_buf-&gt;len == 0, G_IO_STATUS_ERROR);</span>
1324 
1325   if (!channel-&gt;use_buffer)
1326     {
1327       g_warning (&quot;Need to set the channel buffered before setting the encoding.&quot;);
1328       g_warning (&quot;Assuming this is what you meant and acting accordingly.&quot;);
1329 
1330       channel-&gt;use_buffer = TRUE;
1331     }
1332 
1333   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
1334     {
1335       g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
1336       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1337     }
1338 
<a name="26" id="anc26"></a>
1339   did_encode = channel-&gt;do_encode;
<a name="27" id="anc27"></a>
1340 
1341   if (!encoding || strcmp (encoding, &quot;UTF8&quot;) == 0 || strcmp (encoding, &quot;UTF-8&quot;) == 0)
1342     {
1343       channel-&gt;do_encode = FALSE;
1344       read_cd = write_cd = (GIConv) -1;
1345     }
1346   else
1347     {
1348       gint err = 0;
1349       const gchar *from_enc = NULL, *to_enc = NULL;
1350 
1351       if (channel-&gt;is_readable)
1352         {
1353           read_cd = g_iconv_open (&quot;UTF-8&quot;, encoding);
1354 
1355           if (read_cd == (GIConv) -1)
1356             {
1357               err = errno;
1358               from_enc = encoding;
1359               to_enc = &quot;UTF-8&quot;;
1360             }
1361         }
1362       else
1363         read_cd = (GIConv) -1;
1364 
1365       if (channel-&gt;is_writeable &amp;&amp; err == 0)
1366         {
1367           write_cd = g_iconv_open (encoding, &quot;UTF-8&quot;);
1368 
1369           if (write_cd == (GIConv) -1)
1370             {
1371               err = errno;
1372               from_enc = &quot;UTF-8&quot;;
1373               to_enc = encoding;
1374             }
1375         }
1376       else
1377         write_cd = (GIConv) -1;
1378 
1379       if (err != 0)
1380         {
1381           g_assert (from_enc);
1382           g_assert (to_enc);
1383 
1384           if (err == EINVAL)
1385             g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,
1386                          _(&quot;Conversion from character set &#39;%s&#39; to &#39;%s&#39; is not supported&quot;),
1387                          from_enc, to_enc);
1388           else
1389             g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
1390                          _(&quot;Could not open converter from &#39;%s&#39; to &#39;%s&#39;: %s&quot;),
1391                          from_enc, to_enc, g_strerror (err));
1392 
1393           if (read_cd != (GIConv) -1)
1394             g_iconv_close (read_cd);
1395           if (write_cd != (GIConv) -1)
1396             g_iconv_close (write_cd);
1397 
1398           return G_IO_STATUS_ERROR;
1399         }
1400 
1401       channel-&gt;do_encode = TRUE;
1402     }
1403 
1404   /* The encoding is ok, so set the fields in channel */
1405 
1406   if (channel-&gt;read_cd != (GIConv) -1)
1407     g_iconv_close (channel-&gt;read_cd);
1408   if (channel-&gt;write_cd != (GIConv) -1)
1409     g_iconv_close (channel-&gt;write_cd);
1410 
1411   if (channel-&gt;encoded_read_buf &amp;&amp; channel-&gt;encoded_read_buf-&gt;len &gt; 0)
1412     {
1413       g_assert (!did_encode); /* Encoding UTF-8, NULL doesn&#39;t use encoded_read_buf */
1414 
1415       /* This is just validated UTF-8, so we can copy it back into read_buf
1416        * so it can be encoded in whatever the new encoding is.
1417        */
1418 
1419       g_string_prepend_len (channel-&gt;read_buf, channel-&gt;encoded_read_buf-&gt;str,
1420                             channel-&gt;encoded_read_buf-&gt;len);
1421       g_string_truncate (channel-&gt;encoded_read_buf, 0);
1422     }
1423 
1424   channel-&gt;read_cd = read_cd;
1425   channel-&gt;write_cd = write_cd;
1426 
1427   g_free (channel-&gt;encoding);
1428   channel-&gt;encoding = g_strdup (encoding);
1429 
1430   return G_IO_STATUS_NORMAL;
1431 }
1432 
1433 /**
1434  * g_io_channel_get_encoding:
1435  * @channel: a #GIOChannel
1436  *
1437  * Gets the encoding for the input/output of the channel.
1438  * The internal encoding is always UTF-8. The encoding %NULL
1439  * makes the channel safe for binary data.
1440  *
1441  * Returns: A string containing the encoding, this string is
1442  *   owned by GLib and must not be freed.
1443  **/
1444 const gchar *
1445 g_io_channel_get_encoding (GIOChannel *channel)
1446 {
1447   g_return_val_if_fail (channel != NULL, NULL);
1448 
1449   return channel-&gt;encoding;
1450 }
1451 
1452 static GIOStatus
1453 g_io_channel_fill_buffer (GIOChannel  *channel,
1454                           GError     **err)
1455 {
1456   gsize read_size, cur_len, oldlen;
1457   GIOStatus status;
1458 
1459   if (channel-&gt;is_seekable &amp;&amp; channel-&gt;write_buf &amp;&amp; channel-&gt;write_buf-&gt;len &gt; 0)
1460     {
1461       status = g_io_channel_flush (channel, err);
1462       if (status != G_IO_STATUS_NORMAL)
1463         return status;
1464     }
1465   if (channel-&gt;is_seekable &amp;&amp; channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
1466     {
1467       g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
1468       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1469     }
1470 
1471   if (!channel-&gt;read_buf)
1472     channel-&gt;read_buf = g_string_sized_new (channel-&gt;buf_size);
1473 
1474   cur_len = channel-&gt;read_buf-&gt;len;
1475 
1476   g_string_set_size (channel-&gt;read_buf, channel-&gt;read_buf-&gt;len + channel-&gt;buf_size);
1477 
1478   status = channel-&gt;funcs-&gt;io_read (channel, channel-&gt;read_buf-&gt;str + cur_len,
1479                                     channel-&gt;buf_size, &amp;read_size, err);
1480 
1481   g_assert ((status == G_IO_STATUS_NORMAL) || (read_size == 0));
1482 
1483   g_string_truncate (channel-&gt;read_buf, read_size + cur_len);
1484 
1485   if ((status != G_IO_STATUS_NORMAL) &amp;&amp;
1486       ((status != G_IO_STATUS_EOF) || (channel-&gt;read_buf-&gt;len == 0)))
1487     return status;
1488 
1489   g_assert (channel-&gt;read_buf-&gt;len &gt; 0);
1490 
1491   if (channel-&gt;encoded_read_buf)
1492     oldlen = channel-&gt;encoded_read_buf-&gt;len;
1493   else
1494     {
1495       oldlen = 0;
1496       if (channel-&gt;encoding)
1497         channel-&gt;encoded_read_buf = g_string_sized_new (channel-&gt;buf_size);
1498     }
1499 
1500   if (channel-&gt;do_encode)
1501     {
1502       gsize errnum, inbytes_left, outbytes_left;
1503       gchar *inbuf, *outbuf;
1504       int errval;
1505 
1506       g_assert (channel-&gt;encoded_read_buf);
1507 
1508 reencode:
1509 
1510       inbytes_left = channel-&gt;read_buf-&gt;len;
1511       outbytes_left = MAX (channel-&gt;read_buf-&gt;len,
1512                            channel-&gt;encoded_read_buf-&gt;allocated_len
1513                            - channel-&gt;encoded_read_buf-&gt;len - 1); /* 1 for NULL */
1514       outbytes_left = MAX (outbytes_left, 6);
1515 
1516       inbuf = channel-&gt;read_buf-&gt;str;
1517       g_string_set_size (channel-&gt;encoded_read_buf,
1518                          channel-&gt;encoded_read_buf-&gt;len + outbytes_left);
1519       outbuf = channel-&gt;encoded_read_buf-&gt;str + channel-&gt;encoded_read_buf-&gt;len
1520                - outbytes_left;
1521 
1522       errnum = g_iconv (channel-&gt;read_cd, &amp;inbuf, &amp;inbytes_left,
<a name="28" id="anc28"></a><span class="line-modified">1523             &amp;outbuf, &amp;outbytes_left);</span>
1524       errval = errno;
1525 
1526       g_assert (inbuf + inbytes_left == channel-&gt;read_buf-&gt;str
1527                 + channel-&gt;read_buf-&gt;len);
1528       g_assert (outbuf + outbytes_left == channel-&gt;encoded_read_buf-&gt;str
1529                 + channel-&gt;encoded_read_buf-&gt;len);
1530 
1531       g_string_erase (channel-&gt;read_buf, 0,
<a name="29" id="anc29"></a><span class="line-modified">1532               channel-&gt;read_buf-&gt;len - inbytes_left);</span>
1533       g_string_truncate (channel-&gt;encoded_read_buf,
<a name="30" id="anc30"></a><span class="line-modified">1534              channel-&gt;encoded_read_buf-&gt;len - outbytes_left);</span>
1535 
1536       if (errnum == (gsize) -1)
1537         {
1538           switch (errval)
1539             {
1540               case EINVAL:
1541                 if ((oldlen == channel-&gt;encoded_read_buf-&gt;len)
1542                   &amp;&amp; (status == G_IO_STATUS_EOF))
1543                   status = G_IO_STATUS_EOF;
1544                 else
1545                   status = G_IO_STATUS_NORMAL;
1546                 break;
1547               case E2BIG:
1548                 /* Buffer size at least 6, wrote at least on character */
1549                 g_assert (inbuf != channel-&gt;read_buf-&gt;str);
1550                 goto reencode;
1551               case EILSEQ:
1552                 if (oldlen &lt; channel-&gt;encoded_read_buf-&gt;len)
1553                   status = G_IO_STATUS_NORMAL;
1554                 else
1555                   {
1556                     g_set_error_literal (err, G_CONVERT_ERROR,
1557                       G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
1558                       _(&quot;Invalid byte sequence in conversion input&quot;));
1559                     return G_IO_STATUS_ERROR;
1560                   }
1561                 break;
1562               default:
1563                 g_assert (errval != EBADF); /* The converter should be open */
1564                 g_set_error (err, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
1565                   _(&quot;Error during conversion: %s&quot;), g_strerror (errval));
1566                 return G_IO_STATUS_ERROR;
1567             }
1568         }
1569       g_assert ((status != G_IO_STATUS_NORMAL)
1570                || (channel-&gt;encoded_read_buf-&gt;len &gt; 0));
1571     }
1572   else if (channel-&gt;encoding) /* UTF-8 */
1573     {
1574       gchar *nextchar, *lastchar;
1575 
1576       g_assert (channel-&gt;encoded_read_buf);
1577 
1578       nextchar = channel-&gt;read_buf-&gt;str;
1579       lastchar = channel-&gt;read_buf-&gt;str + channel-&gt;read_buf-&gt;len;
1580 
1581       while (nextchar &lt; lastchar)
1582         {
1583           gunichar val_char;
1584 
1585           val_char = g_utf8_get_char_validated (nextchar, lastchar - nextchar);
1586 
1587           switch (val_char)
1588             {
1589               case -2:
1590                 /* stop, leave partial character in buffer */
1591                 lastchar = nextchar;
1592                 break;
1593               case -1:
1594                 if (oldlen &lt; channel-&gt;encoded_read_buf-&gt;len)
1595                   status = G_IO_STATUS_NORMAL;
1596                 else
1597                   {
1598                     g_set_error_literal (err, G_CONVERT_ERROR,
1599                       G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
1600                       _(&quot;Invalid byte sequence in conversion input&quot;));
1601                     status = G_IO_STATUS_ERROR;
1602                   }
1603                 lastchar = nextchar;
1604                 break;
1605               default:
1606                 nextchar = g_utf8_next_char (nextchar);
1607                 break;
1608             }
1609         }
1610 
1611       if (lastchar &gt; channel-&gt;read_buf-&gt;str)
1612         {
1613           gint copy_len = lastchar - channel-&gt;read_buf-&gt;str;
1614 
1615           g_string_append_len (channel-&gt;encoded_read_buf, channel-&gt;read_buf-&gt;str,
1616                                copy_len);
1617           g_string_erase (channel-&gt;read_buf, 0, copy_len);
1618         }
1619     }
1620 
1621   return status;
1622 }
1623 
1624 /**
1625  * g_io_channel_read_line:
1626  * @channel: a #GIOChannel
1627  * @str_return: (out): The line read from the #GIOChannel, including the
1628  *              line terminator. This data should be freed with g_free()
1629  *              when no longer needed. This is a nul-terminated string.
1630  *              If a @length of zero is returned, this will be %NULL instead.
1631  * @length: (out) (optional): location to store length of the read data, or %NULL
1632  * @terminator_pos: (out) (optional): location to store position of line terminator, or %NULL
1633  * @error: A location to return an error of type #GConvertError
1634  *         or #GIOChannelError
1635  *
1636  * Reads a line, including the terminating character(s),
1637  * from a #GIOChannel into a newly-allocated string.
1638  * @str_return will contain allocated memory if the return
1639  * is %G_IO_STATUS_NORMAL.
1640  *
1641  * Returns: the status of the operation.
1642  **/
1643 GIOStatus
1644 g_io_channel_read_line (GIOChannel  *channel,
1645                         gchar      **str_return,
1646                         gsize       *length,
<a name="31" id="anc31"></a><span class="line-modified">1647             gsize       *terminator_pos,</span>
<span class="line-modified">1648                 GError     **error)</span>
1649 {
1650   GIOStatus status;
1651   gsize got_length;
1652 
1653   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1654   g_return_val_if_fail (str_return != NULL, G_IO_STATUS_ERROR);
1655   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="32" id="anc32"></a><span class="line-modified">1656             G_IO_STATUS_ERROR);</span>
1657   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1658 
1659   status = g_io_channel_read_line_backend (channel, &amp;got_length, terminator_pos, error);
1660 
1661   if (length &amp;&amp; status != G_IO_STATUS_ERROR)
1662     *length = got_length;
1663 
1664   if (status == G_IO_STATUS_NORMAL)
1665     {
1666       g_assert (USE_BUF (channel));
1667       *str_return = g_strndup (USE_BUF (channel)-&gt;str, got_length);
1668       g_string_erase (USE_BUF (channel), 0, got_length);
1669     }
1670   else
1671     *str_return = NULL;
1672 
1673   return status;
1674 }
1675 
1676 /**
1677  * g_io_channel_read_line_string:
1678  * @channel: a #GIOChannel
1679  * @buffer: a #GString into which the line will be written.
1680  *          If @buffer already contains data, the old data will
1681  *          be overwritten.
1682  * @terminator_pos: (nullable): location to store position of line terminator, or %NULL
1683  * @error: a location to store an error of type #GConvertError
1684  *         or #GIOChannelError
1685  *
1686  * Reads a line from a #GIOChannel, using a #GString as a buffer.
1687  *
1688  * Returns: the status of the operation.
1689  **/
1690 GIOStatus
1691 g_io_channel_read_line_string (GIOChannel  *channel,
1692                                GString     *buffer,
<a name="33" id="anc33"></a><span class="line-modified">1693                                gsize       *terminator_pos,</span>
<span class="line-modified">1694                                GError     **error)</span>
1695 {
1696   gsize length;
1697   GIOStatus status;
1698 
1699   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1700   g_return_val_if_fail (buffer != NULL, G_IO_STATUS_ERROR);
1701   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="34" id="anc34"></a><span class="line-modified">1702             G_IO_STATUS_ERROR);</span>
1703   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1704 
1705   if (buffer-&gt;len &gt; 0)
1706     g_string_truncate (buffer, 0); /* clear out the buffer */
1707 
1708   status = g_io_channel_read_line_backend (channel, &amp;length, terminator_pos, error);
1709 
1710   if (status == G_IO_STATUS_NORMAL)
1711     {
1712       g_assert (USE_BUF (channel));
1713       g_string_append_len (buffer, USE_BUF (channel)-&gt;str, length);
1714       g_string_erase (USE_BUF (channel), 0, length);
1715     }
1716 
1717   return status;
1718 }
1719 
1720 
1721 static GIOStatus
1722 g_io_channel_read_line_backend (GIOChannel  *channel,
1723                                 gsize       *length,
1724                                 gsize       *terminator_pos,
1725                                 GError     **error)
1726 {
1727   GIOStatus status;
1728   gsize checked_to, line_term_len, line_length, got_term_len;
1729   gboolean first_time = TRUE;
1730 
1731   if (!channel-&gt;use_buffer)
1732     {
1733       /* Can&#39;t do a raw read in read_line */
1734       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
1735                            _(&quot;Can&#39;t do a raw read in g_io_channel_read_line_string&quot;));
1736       return G_IO_STATUS_ERROR;
1737     }
1738 
1739   status = G_IO_STATUS_NORMAL;
1740 
1741   if (channel-&gt;line_term)
1742     line_term_len = channel-&gt;line_term_len;
1743   else
1744     line_term_len = 3;
1745     /* This value used for setting checked_to, it&#39;s the longest of the four
1746      * we autodetect for.
1747      */
1748 
1749   checked_to = 0;
1750 
1751   while (TRUE)
1752     {
1753       gchar *nextchar, *lastchar;
1754       GString *use_buf;
1755 
1756       if (!first_time || (BUF_LEN (USE_BUF (channel)) == 0))
1757         {
1758 read_again:
1759           status = g_io_channel_fill_buffer (channel, error);
1760           switch (status)
1761             {
1762               case G_IO_STATUS_NORMAL:
1763                 if (BUF_LEN (USE_BUF (channel)) == 0)
1764                   /* Can happen when using conversion and only read
1765                    * part of a character
1766                    */
1767                   {
1768                     first_time = FALSE;
1769                     continue;
1770                   }
1771                 break;
1772               case G_IO_STATUS_EOF:
1773                 if (BUF_LEN (USE_BUF (channel)) == 0)
1774                   {
1775                     if (length)
1776                       *length = 0;
1777 
1778                     if (channel-&gt;encoding &amp;&amp; channel-&gt;read_buf-&gt;len != 0)
1779                       {
1780                         g_set_error_literal (error, G_CONVERT_ERROR,
1781                                              G_CONVERT_ERROR_PARTIAL_INPUT,
1782                                              _(&quot;Leftover unconverted data in &quot;
1783                                                &quot;read buffer&quot;));
1784                         return G_IO_STATUS_ERROR;
1785                       }
1786                     else
1787                       return G_IO_STATUS_EOF;
1788                   }
1789                 break;
1790               default:
1791                 if (length)
1792                   *length = 0;
1793                 return status;
1794             }
1795         }
1796 
1797       g_assert (BUF_LEN (USE_BUF (channel)) != 0);
1798 
1799       use_buf = USE_BUF (channel); /* The buffer has been created by this point */
1800 
1801       first_time = FALSE;
1802 
1803       lastchar = use_buf-&gt;str + use_buf-&gt;len;
1804 
1805       for (nextchar = use_buf-&gt;str + checked_to; nextchar &lt; lastchar;
1806            channel-&gt;encoding ? nextchar = g_utf8_next_char (nextchar) : nextchar++)
1807         {
1808           if (channel-&gt;line_term)
1809             {
1810               if (memcmp (channel-&gt;line_term, nextchar, line_term_len) == 0)
1811                 {
1812                   line_length = nextchar - use_buf-&gt;str;
1813                   got_term_len = line_term_len;
1814                   goto done;
1815                 }
1816             }
1817           else /* auto detect */
1818             {
1819               switch (*nextchar)
1820                 {
1821                   case &#39;\n&#39;: /* unix */
1822                     line_length = nextchar - use_buf-&gt;str;
1823                     got_term_len = 1;
1824                     goto done;
1825                   case &#39;\r&#39;: /* Warning: do not use with sockets */
1826                     line_length = nextchar - use_buf-&gt;str;
1827                     if ((nextchar == lastchar - 1) &amp;&amp; (status != G_IO_STATUS_EOF)
1828                        &amp;&amp; (lastchar == use_buf-&gt;str + use_buf-&gt;len))
1829                       goto read_again; /* Try to read more data */
1830                     if ((nextchar &lt; lastchar - 1) &amp;&amp; (*(nextchar + 1) == &#39;\n&#39;)) /* dos */
1831                       got_term_len = 2;
1832                     else /* mac */
1833                       got_term_len = 1;
1834                     goto done;
1835                   case &#39;\xe2&#39;: /* Unicode paragraph separator */
1836                     if (strncmp (&quot;\xe2\x80\xa9&quot;, nextchar, 3) == 0)
1837                       {
1838                         line_length = nextchar - use_buf-&gt;str;
1839                         got_term_len = 3;
1840                         goto done;
1841                       }
1842                     break;
1843                   case &#39;\0&#39;: /* Embeded null in input */
1844                     line_length = nextchar - use_buf-&gt;str;
1845                     got_term_len = 1;
1846                     goto done;
1847                   default: /* no match */
1848                     break;
1849                 }
1850             }
1851         }
1852 
1853       /* If encoding != NULL, valid UTF-8, didn&#39;t overshoot */
1854       g_assert (nextchar == lastchar);
1855 
1856       /* Check for EOF */
1857 
1858       if (status == G_IO_STATUS_EOF)
1859         {
1860           if (channel-&gt;encoding &amp;&amp; channel-&gt;read_buf-&gt;len &gt; 0)
1861             {
1862               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1863                                    _(&quot;Channel terminates in a partial character&quot;));
1864               return G_IO_STATUS_ERROR;
1865             }
1866           line_length = use_buf-&gt;len;
1867           got_term_len = 0;
1868           break;
1869         }
1870 
1871       if (use_buf-&gt;len &gt; line_term_len - 1)
<a name="35" id="anc35"></a><span class="line-modified">1872     checked_to = use_buf-&gt;len - (line_term_len - 1);</span>
1873       else
<a name="36" id="anc36"></a><span class="line-modified">1874     checked_to = 0;</span>
1875     }
1876 
1877 done:
1878 
1879   if (terminator_pos)
1880     *terminator_pos = line_length;
1881 
1882   if (length)
1883     *length = line_length + got_term_len;
1884 
1885   return G_IO_STATUS_NORMAL;
1886 }
1887 
1888 /**
1889  * g_io_channel_read_to_end:
1890  * @channel: a #GIOChannel
1891  * @str_return:  (out) (array length=length) (element-type guint8): Location to
1892  *              store a pointer to a string holding the remaining data in the
1893  *              #GIOChannel. This data should be freed with g_free() when no
1894  *              longer needed. This data is terminated by an extra nul
1895  *              character, but there may be other nuls in the intervening data.
1896  * @length: (out): location to store length of the data
1897  * @error: location to return an error of type #GConvertError
1898  *         or #GIOChannelError
1899  *
1900  * Reads all the remaining data from the file.
1901  *
1902  * Returns: %G_IO_STATUS_NORMAL on success.
1903  *     This function never returns %G_IO_STATUS_EOF.
1904  **/
1905 GIOStatus
1906 g_io_channel_read_to_end (GIOChannel  *channel,
1907                           gchar      **str_return,
1908                           gsize       *length,
1909                           GError     **error)
1910 {
1911   GIOStatus status;
1912 
1913   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1914   g_return_val_if_fail ((error == NULL) || (*error == NULL),
1915     G_IO_STATUS_ERROR);
1916   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1917 
1918   if (str_return)
1919     *str_return = NULL;
1920   if (length)
1921     *length = 0;
1922 
1923   if (!channel-&gt;use_buffer)
1924     {
1925       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
1926                            _(&quot;Can&#39;t do a raw read in g_io_channel_read_to_end&quot;));
1927       return G_IO_STATUS_ERROR;
1928     }
1929 
1930   do
1931     status = g_io_channel_fill_buffer (channel, error);
1932   while (status == G_IO_STATUS_NORMAL);
1933 
1934   if (status != G_IO_STATUS_EOF)
1935     return status;
1936 
1937   if (channel-&gt;encoding &amp;&amp; channel-&gt;read_buf-&gt;len &gt; 0)
1938     {
1939       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1940                            _(&quot;Channel terminates in a partial character&quot;));
1941       return G_IO_STATUS_ERROR;
1942     }
1943 
1944   if (USE_BUF (channel) == NULL)
1945     {
1946       /* length is already set to zero */
1947       if (str_return)
1948         *str_return = g_strdup (&quot;&quot;);
1949     }
1950   else
1951     {
1952       if (length)
1953         *length = USE_BUF (channel)-&gt;len;
1954 
1955       if (str_return)
1956         *str_return = g_string_free (USE_BUF (channel), FALSE);
1957       else
1958         g_string_free (USE_BUF (channel), TRUE);
1959 
1960       if (channel-&gt;encoding)
<a name="37" id="anc37"></a><span class="line-modified">1961     channel-&gt;encoded_read_buf = NULL;</span>
1962       else
<a name="38" id="anc38"></a><span class="line-modified">1963     channel-&gt;read_buf = NULL;</span>
1964     }
1965 
1966   return G_IO_STATUS_NORMAL;
1967 }
1968 
1969 /**
1970  * g_io_channel_read_chars:
1971  * @channel: a #GIOChannel
1972  * @buf: (out caller-allocates) (array length=count) (element-type guint8):
1973  *     a buffer to read data into
1974  * @count: (in): the size of the buffer. Note that the buffer may not be
1975  *     complelely filled even if there is data in the buffer if the
1976  *     remaining data is not a complete character.
1977  * @bytes_read: (out) (optional): The number of bytes read. This may be
1978  *     zero even on success if count &lt; 6 and the channel&#39;s encoding
1979  *     is non-%NULL. This indicates that the next UTF-8 character is
1980  *     too wide for the buffer.
1981  * @error: a location to return an error of type #GConvertError
1982  *     or #GIOChannelError.
1983  *
1984  * Replacement for g_io_channel_read() with the new API.
1985  *
1986  * Returns: the status of the operation.
1987  */
1988 GIOStatus
1989 g_io_channel_read_chars (GIOChannel  *channel,
1990                          gchar       *buf,
1991                          gsize        count,
1992                          gsize       *bytes_read,
1993                          GError     **error)
1994 {
1995   GIOStatus status;
1996   gsize got_bytes;
1997 
1998   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1999   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
2000   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
2001 
2002   if (count == 0)
2003     {
2004       if (bytes_read)
2005         *bytes_read = 0;
2006       return G_IO_STATUS_NORMAL;
2007     }
2008   g_return_val_if_fail (buf != NULL, G_IO_STATUS_ERROR);
2009 
2010   if (!channel-&gt;use_buffer)
2011     {
2012       gsize tmp_bytes;
2013 
2014       g_assert (!channel-&gt;read_buf || channel-&gt;read_buf-&gt;len == 0);
2015 
2016       status = channel-&gt;funcs-&gt;io_read (channel, buf, count, &amp;tmp_bytes, error);
2017 
2018       if (bytes_read)
2019         *bytes_read = tmp_bytes;
2020 
2021       return status;
2022     }
2023 
2024   status = G_IO_STATUS_NORMAL;
2025 
2026   while (BUF_LEN (USE_BUF (channel)) &lt; count &amp;&amp; status == G_IO_STATUS_NORMAL)
2027     status = g_io_channel_fill_buffer (channel, error);
2028 
2029   /* Only return an error if we have no data */
2030 
2031   if (BUF_LEN (USE_BUF (channel)) == 0)
2032     {
2033       g_assert (status != G_IO_STATUS_NORMAL);
2034 
2035       if (status == G_IO_STATUS_EOF &amp;&amp; channel-&gt;encoding
2036           &amp;&amp; BUF_LEN (channel-&gt;read_buf) &gt; 0)
2037         {
2038           g_set_error_literal (error, G_CONVERT_ERROR,
2039                                G_CONVERT_ERROR_PARTIAL_INPUT,
2040                                _(&quot;Leftover unconverted data in read buffer&quot;));
2041           status = G_IO_STATUS_ERROR;
2042         }
2043 
2044       if (bytes_read)
2045         *bytes_read = 0;
2046 
2047       return status;
2048     }
2049 
2050   if (status == G_IO_STATUS_ERROR)
2051     g_clear_error (error);
2052 
2053   got_bytes = MIN (count, BUF_LEN (USE_BUF (channel)));
2054 
2055   g_assert (got_bytes &gt; 0);
2056 
2057   if (channel-&gt;encoding)
2058     /* Don&#39;t validate for NULL encoding, binary safe */
2059     {
2060       gchar *nextchar, *prevchar;
2061 
2062       g_assert (USE_BUF (channel) == channel-&gt;encoded_read_buf);
2063 
2064       nextchar = channel-&gt;encoded_read_buf-&gt;str;
2065 
2066       do
2067         {
2068           prevchar = nextchar;
2069           nextchar = g_utf8_next_char (nextchar);
2070           g_assert (nextchar != prevchar); /* Possible for *prevchar of -1 or -2 */
2071         }
2072       while (nextchar &lt; channel-&gt;encoded_read_buf-&gt;str + got_bytes);
2073 
2074       if (nextchar &gt; channel-&gt;encoded_read_buf-&gt;str + got_bytes)
2075         got_bytes = prevchar - channel-&gt;encoded_read_buf-&gt;str;
2076 
2077       g_assert (got_bytes &gt; 0 || count &lt; 6);
2078     }
2079 
2080   memcpy (buf, USE_BUF (channel)-&gt;str, got_bytes);
2081   g_string_erase (USE_BUF (channel), 0, got_bytes);
2082 
2083   if (bytes_read)
2084     *bytes_read = got_bytes;
2085 
2086   return G_IO_STATUS_NORMAL;
2087 }
2088 
2089 /**
2090  * g_io_channel_read_unichar:
2091  * @channel: a #GIOChannel
2092  * @thechar: (out): a location to return a character
2093  * @error: a location to return an error of type #GConvertError
2094  *         or #GIOChannelError
2095  *
2096  * Reads a Unicode character from @channel.
2097  * This function cannot be called on a channel with %NULL encoding.
2098  *
2099  * Returns: a #GIOStatus
2100  **/
2101 GIOStatus
2102 g_io_channel_read_unichar (GIOChannel  *channel,
<a name="39" id="anc39"></a><span class="line-modified">2103                gunichar    *thechar,</span>
<span class="line-modified">2104                GError     **error)</span>
2105 {
2106   GIOStatus status = G_IO_STATUS_NORMAL;
2107 
2108   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2109   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2110   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="40" id="anc40"></a><span class="line-modified">2111             G_IO_STATUS_ERROR);</span>
2112   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
2113 
2114   while (BUF_LEN (channel-&gt;encoded_read_buf) == 0 &amp;&amp; status == G_IO_STATUS_NORMAL)
2115     status = g_io_channel_fill_buffer (channel, error);
2116 
2117   /* Only return an error if we have no data */
2118 
2119   if (BUF_LEN (USE_BUF (channel)) == 0)
2120     {
2121       g_assert (status != G_IO_STATUS_NORMAL);
2122 
2123       if (status == G_IO_STATUS_EOF &amp;&amp; BUF_LEN (channel-&gt;read_buf) &gt; 0)
2124         {
2125           g_set_error_literal (error, G_CONVERT_ERROR,
2126                                G_CONVERT_ERROR_PARTIAL_INPUT,
2127                                _(&quot;Leftover unconverted data in read buffer&quot;));
2128           status = G_IO_STATUS_ERROR;
2129         }
2130 
2131       if (thechar)
2132         *thechar = (gunichar) -1;
2133 
2134       return status;
2135     }
2136 
2137   if (status == G_IO_STATUS_ERROR)
2138     g_clear_error (error);
2139 
2140   if (thechar)
2141     *thechar = g_utf8_get_char (channel-&gt;encoded_read_buf-&gt;str);
2142 
2143   g_string_erase (channel-&gt;encoded_read_buf, 0,
2144                   g_utf8_next_char (channel-&gt;encoded_read_buf-&gt;str)
2145                   - channel-&gt;encoded_read_buf-&gt;str);
2146 
2147   return G_IO_STATUS_NORMAL;
2148 }
2149 
2150 /**
2151  * g_io_channel_write_chars:
2152  * @channel: a #GIOChannel
2153  * @buf: (array) (element-type guint8): a buffer to write data from
2154  * @count: the size of the buffer. If -1, the buffer
2155  *         is taken to be a nul-terminated string.
2156  * @bytes_written: (out): The number of bytes written. This can be nonzero
2157  *                 even if the return value is not %G_IO_STATUS_NORMAL.
2158  *                 If the return value is %G_IO_STATUS_NORMAL and the
2159  *                 channel is blocking, this will always be equal
2160  *                 to @count if @count &gt;= 0.
2161  * @error: a location to return an error of type #GConvertError
2162  *         or #GIOChannelError
2163  *
2164  * Replacement for g_io_channel_write() with the new API.
2165  *
2166  * On seekable channels with encodings other than %NULL or UTF-8, generic
2167  * mixing of reading and writing is not allowed. A call to g_io_channel_write_chars ()
2168  * may only be made on a channel from which data has been read in the
2169  * cases described in the documentation for g_io_channel_set_encoding ().
2170  *
2171  * Returns: the status of the operation.
2172  **/
2173 GIOStatus
2174 g_io_channel_write_chars (GIOChannel   *channel,
2175                           const gchar  *buf,
2176                           gssize        count,
<a name="41" id="anc41"></a><span class="line-modified">2177               gsize        *bytes_written,</span>
2178                           GError      **error)
2179 {
<a name="42" id="anc42"></a>
2180   GIOStatus status;
2181   gssize wrote_bytes = 0;
2182 
2183   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2184   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="43" id="anc43"></a><span class="line-modified">2185             G_IO_STATUS_ERROR);</span>
2186   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2187 
2188   if ((count &lt; 0) &amp;&amp; buf)
2189     count = strlen (buf);
<a name="44" id="anc44"></a>
2190 
<a name="45" id="anc45"></a><span class="line-modified">2191   if (count == 0)</span>
2192     {
2193       if (bytes_written)
2194         *bytes_written = 0;
2195       return G_IO_STATUS_NORMAL;
2196     }
2197 
2198   g_return_val_if_fail (buf != NULL, G_IO_STATUS_ERROR);
<a name="46" id="anc46"></a><span class="line-modified">2199   g_return_val_if_fail (count &gt; 0, G_IO_STATUS_ERROR);</span>
2200 
2201   /* Raw write case */
2202 
2203   if (!channel-&gt;use_buffer)
2204     {
2205       gsize tmp_bytes;
2206 
2207       g_assert (!channel-&gt;write_buf || channel-&gt;write_buf-&gt;len == 0);
2208       g_assert (channel-&gt;partial_write_buf[0] == &#39;\0&#39;);
2209 
<a name="47" id="anc47"></a><span class="line-modified">2210       status = channel-&gt;funcs-&gt;io_write (channel, buf, count, &amp;tmp_bytes, error);</span>

2211 
2212       if (bytes_written)
<a name="48" id="anc48"></a><span class="line-modified">2213     *bytes_written = tmp_bytes;</span>
2214 
2215       return status;
2216     }
2217 
2218   /* General case */
2219 
2220   if (channel-&gt;is_seekable &amp;&amp; (( BUF_LEN (channel-&gt;read_buf) &gt; 0)
2221     || (BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)))
2222     {
2223       if (channel-&gt;do_encode &amp;&amp; BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)
2224         {
2225           g_warning (&quot;Mixed reading and writing not allowed on encoded files&quot;);
2226           return G_IO_STATUS_ERROR;
2227         }
2228       status = g_io_channel_seek_position (channel, 0, G_SEEK_CUR, error);
2229       if (status != G_IO_STATUS_NORMAL)
2230         {
2231           if (bytes_written)
2232             *bytes_written = 0;
2233           return status;
2234         }
2235     }
2236 
2237   if (!channel-&gt;write_buf)
2238     channel-&gt;write_buf = g_string_sized_new (channel-&gt;buf_size);
2239 
2240   while (wrote_bytes &lt; count)
2241     {
2242       gsize space_in_buf;
2243 
2244       /* If the buffer is full, try a write immediately. In
2245        * the nonblocking case, this prevents the user from
2246        * writing just a little bit to the buffer every time
2247        * and never receiving an EAGAIN.
2248        */
2249 
2250       if (channel-&gt;write_buf-&gt;len &gt;= channel-&gt;buf_size - MAX_CHAR_SIZE)
2251         {
2252           gsize did_write = 0, this_time;
2253 
2254           do
2255             {
2256               status = channel-&gt;funcs-&gt;io_write (channel, channel-&gt;write_buf-&gt;str
2257                                                  + did_write, channel-&gt;write_buf-&gt;len
2258                                                  - did_write, &amp;this_time, error);
2259               did_write += this_time;
2260             }
2261           while (status == G_IO_STATUS_NORMAL &amp;&amp;
2262                  did_write &lt; MIN (channel-&gt;write_buf-&gt;len, MAX_CHAR_SIZE));
2263 
2264           g_string_erase (channel-&gt;write_buf, 0, did_write);
2265 
2266           if (status != G_IO_STATUS_NORMAL)
2267             {
2268               if (status == G_IO_STATUS_AGAIN &amp;&amp; wrote_bytes &gt; 0)
2269                 status = G_IO_STATUS_NORMAL;
2270               if (bytes_written)
2271                 *bytes_written = wrote_bytes;
2272               return status;
2273             }
2274         }
2275 
2276       space_in_buf = MAX (channel-&gt;buf_size, channel-&gt;write_buf-&gt;allocated_len - 1)
2277                      - channel-&gt;write_buf-&gt;len; /* 1 for NULL */
2278 
2279       /* This is only true because g_io_channel_set_buffer_size ()
2280        * ensures that channel-&gt;buf_size &gt;= MAX_CHAR_SIZE.
2281        */
2282       g_assert (space_in_buf &gt;= MAX_CHAR_SIZE);
2283 
2284       if (!channel-&gt;encoding)
2285         {
<a name="49" id="anc49"></a><span class="line-modified">2286           gssize write_this = MIN (space_in_buf, count - wrote_bytes);</span>
2287 
2288           g_string_append_len (channel-&gt;write_buf, buf, write_this);
2289           buf += write_this;
2290           wrote_bytes += write_this;
2291         }
2292       else
2293         {
2294           const gchar *from_buf;
2295           gsize from_buf_len, from_buf_old_len, left_len;
2296           gsize err;
2297           gint errnum;
2298 
2299           if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2300             {
2301               g_assert (wrote_bytes == 0);
2302 
2303               from_buf = channel-&gt;partial_write_buf;
2304               from_buf_old_len = strlen (channel-&gt;partial_write_buf);
2305               g_assert (from_buf_old_len &gt; 0);
<a name="50" id="anc50"></a><span class="line-modified">2306               from_buf_len = MIN (6, from_buf_old_len + count);</span>
2307 
2308               memcpy (channel-&gt;partial_write_buf + from_buf_old_len, buf,
2309                       from_buf_len - from_buf_old_len);
2310             }
2311           else
2312             {
2313               from_buf = buf;
<a name="51" id="anc51"></a><span class="line-modified">2314               from_buf_len = count - wrote_bytes;</span>
2315               from_buf_old_len = 0;
2316             }
2317 
2318 reconvert:
2319 
2320           if (!channel-&gt;do_encode) /* UTF-8 encoding */
2321             {
2322               const gchar *badchar;
2323               gsize try_len = MIN (from_buf_len, space_in_buf);
2324 
2325               /* UTF-8, just validate, emulate g_iconv */
2326 
<a name="52" id="anc52"></a><span class="line-modified">2327               if (!_g_utf8_validate_len (from_buf, try_len, &amp;badchar))</span>
2328                 {
2329                   gunichar try_char;
2330                   gsize incomplete_len = from_buf + try_len - badchar;
2331 
2332                   left_len = from_buf + from_buf_len - badchar;
2333 
2334                   try_char = g_utf8_get_char_validated (badchar, incomplete_len);
2335 
2336                   switch (try_char)
2337                     {
2338                       case -2:
2339                         g_assert (incomplete_len &lt; 6);
2340                         if (try_len == from_buf_len)
2341                           {
2342                             errnum = EINVAL;
2343                             err = (gsize) -1;
2344                           }
2345                         else
2346                           {
2347                             errnum = 0;
2348                             err = (gsize) 0;
2349                           }
2350                         break;
2351                       case -1:
2352                         g_warning (&quot;Invalid UTF-8 passed to g_io_channel_write_chars().&quot;);
2353                         /* FIXME bail here? */
2354                         errnum = EILSEQ;
2355                         err = (gsize) -1;
2356                         break;
2357                       default:
2358                         g_assert_not_reached ();
2359                         err = (gsize) -1;
2360                         errnum = 0; /* Don&#39;t confunse the compiler */
2361                     }
2362                 }
2363               else
2364                 {
2365                   err = (gsize) 0;
2366                   errnum = 0;
2367                   left_len = from_buf_len - try_len;
2368                 }
2369 
2370               g_string_append_len (channel-&gt;write_buf, from_buf,
2371                                    from_buf_len - left_len);
2372               from_buf += from_buf_len - left_len;
2373             }
2374           else
2375             {
2376                gchar *outbuf;
2377 
2378                left_len = from_buf_len;
2379                g_string_set_size (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2380                                   + space_in_buf);
2381                outbuf = channel-&gt;write_buf-&gt;str + channel-&gt;write_buf-&gt;len
2382                         - space_in_buf;
2383                err = g_iconv (channel-&gt;write_cd, (gchar **) &amp;from_buf, &amp;left_len,
2384                               &amp;outbuf, &amp;space_in_buf);
2385                errnum = errno;
2386                g_string_truncate (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2387                                   - space_in_buf);
2388             }
2389 
2390           if (err == (gsize) -1)
2391             {
2392               switch (errnum)
<a name="53" id="anc53"></a><span class="line-modified">2393             {</span>
2394                   case EINVAL:
2395                     g_assert (left_len &lt; 6);
2396 
2397                     if (from_buf_old_len == 0)
2398                       {
2399                         /* Not from partial_write_buf */
2400 
2401                         memcpy (channel-&gt;partial_write_buf, from_buf, left_len);
2402                         channel-&gt;partial_write_buf[left_len] = &#39;\0&#39;;
2403                         if (bytes_written)
<a name="54" id="anc54"></a><span class="line-modified">2404                           *bytes_written = count;</span>
2405                         return G_IO_STATUS_NORMAL;
2406                       }
2407 
2408                     /* Working in partial_write_buf */
2409 
2410                     if (left_len == from_buf_len)
2411                       {
2412                         /* Didn&#39;t convert anything, must still have
2413                          * less than a full character
2414                          */
2415 
<a name="55" id="anc55"></a><span class="line-modified">2416                         g_assert (count == from_buf_len - from_buf_old_len);</span>
2417 
2418                         channel-&gt;partial_write_buf[from_buf_len] = &#39;\0&#39;;
2419 
2420                         if (bytes_written)
<a name="56" id="anc56"></a><span class="line-modified">2421                           *bytes_written = count;</span>
2422 
2423                         return G_IO_STATUS_NORMAL;
2424                       }
2425 
2426                     g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2427 
2428                     /* We converted all the old data. This is fine */
2429 
2430                     break;
2431                   case E2BIG:
2432                     if (from_buf_len == left_len)
2433                       {
2434                         /* Nothing was written, add enough space for
2435                          * at least one character.
2436                          */
2437                         space_in_buf += MAX_CHAR_SIZE;
2438                         goto reconvert;
2439                       }
2440                     break;
2441                   case EILSEQ:
2442                     g_set_error_literal (error, G_CONVERT_ERROR,
2443                       G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
2444                       _(&quot;Invalid byte sequence in conversion input&quot;));
2445                     if (from_buf_old_len &gt; 0 &amp;&amp; from_buf_len == left_len)
2446                       g_warning (&quot;Illegal sequence due to partial character &quot;
2447                                  &quot;at the end of a previous write.&quot;);
2448                     else
2449                       wrote_bytes += from_buf_len - left_len - from_buf_old_len;
2450                     if (bytes_written)
2451                       *bytes_written = wrote_bytes;
2452                     channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2453                     return G_IO_STATUS_ERROR;
2454                   default:
2455                     g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
2456                       _(&quot;Error during conversion: %s&quot;), g_strerror (errnum));
2457                     if (from_buf_len &gt;= left_len + from_buf_old_len)
2458                       wrote_bytes += from_buf_len - left_len - from_buf_old_len;
2459                     if (bytes_written)
2460                       *bytes_written = wrote_bytes;
2461                     channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2462                     return G_IO_STATUS_ERROR;
2463                 }
2464             }
2465 
2466           g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2467 
2468           wrote_bytes += from_buf_len - left_len - from_buf_old_len;
2469 
2470           if (from_buf_old_len &gt; 0)
2471             {
2472               /* We were working in partial_write_buf */
2473 
2474               buf += from_buf_len - left_len - from_buf_old_len;
2475               channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2476             }
2477           else
2478             buf = from_buf;
2479         }
2480     }
2481 
2482   if (bytes_written)
<a name="57" id="anc57"></a><span class="line-modified">2483     *bytes_written = count;</span>
2484 
2485   return G_IO_STATUS_NORMAL;
2486 }
2487 
2488 /**
2489  * g_io_channel_write_unichar:
2490  * @channel: a #GIOChannel
2491  * @thechar: a character
2492  * @error: location to return an error of type #GConvertError
2493  *         or #GIOChannelError
2494  *
2495  * Writes a Unicode character to @channel.
2496  * This function cannot be called on a channel with %NULL encoding.
2497  *
2498  * Returns: a #GIOStatus
2499  **/
2500 GIOStatus
2501 g_io_channel_write_unichar (GIOChannel  *channel,
<a name="58" id="anc58"></a><span class="line-modified">2502                 gunichar     thechar,</span>
<span class="line-modified">2503                 GError     **error)</span>
2504 {
2505   GIOStatus status;
2506   gchar static_buf[6];
2507   gsize char_len, wrote_len;
2508 
2509   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2510   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2511   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<a name="59" id="anc59"></a><span class="line-modified">2512             G_IO_STATUS_ERROR);</span>
2513   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2514 
2515   char_len = g_unichar_to_utf8 (thechar, static_buf);
2516 
2517   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2518     {
2519       g_warning (&quot;Partial character written before writing unichar.&quot;);
2520       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2521     }
2522 
2523   status = g_io_channel_write_chars (channel, static_buf,
2524                                      char_len, &amp;wrote_len, error);
2525 
2526   /* We validate UTF-8, so we can&#39;t get a partial write */
2527 
2528   g_assert (wrote_len == char_len || status != G_IO_STATUS_NORMAL);
2529 
2530   return status;
2531 }
2532 
2533 /**
2534  * G_IO_CHANNEL_ERROR:
2535  *
2536  * Error domain for #GIOChannel operations. Errors in this domain will
2537  * be from the #GIOChannelError enumeration. See #GError for
2538  * information on error domains.
2539  **/
2540 /**
2541  * GIOChannelError:
2542  * @G_IO_CHANNEL_ERROR_FBIG: File too large.
2543  * @G_IO_CHANNEL_ERROR_INVAL: Invalid argument.
2544  * @G_IO_CHANNEL_ERROR_IO: IO error.
2545  * @G_IO_CHANNEL_ERROR_ISDIR: File is a directory.
2546  * @G_IO_CHANNEL_ERROR_NOSPC: No space left on device.
2547  * @G_IO_CHANNEL_ERROR_NXIO: No such device or address.
2548  * @G_IO_CHANNEL_ERROR_OVERFLOW: Value too large for defined datatype.
2549  * @G_IO_CHANNEL_ERROR_PIPE: Broken pipe.
2550  * @G_IO_CHANNEL_ERROR_FAILED: Some other error.
2551  *
2552  * Error codes returned by #GIOChannel operations.
2553  **/
2554 
2555 G_DEFINE_QUARK (g-io-channel-error-quark, g_io_channel_error)
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>