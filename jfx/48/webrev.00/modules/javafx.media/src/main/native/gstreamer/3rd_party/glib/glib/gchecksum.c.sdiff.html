<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gcharset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gconstructor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 160 #if G_BYTE_ORDER == G_BIG_ENDIAN
 161 #define sha_byte_reverse(buffer,length)
 162 #else
 163 static inline void
 164 sha_byte_reverse (guint32 *buffer,
 165                   gint     length)
 166 {
 167   length /= sizeof (guint32);
 168   while (length--)
 169     {
 170       *buffer = GUINT32_SWAP_LE_BE (*buffer);
 171       ++buffer;
 172     }
 173 }
 174 #endif /* G_BYTE_ORDER == G_BIG_ENDIAN */
 175 
 176 static gchar *
 177 digest_to_string (guint8 *digest,
 178                   gsize   digest_len)
 179 {
<span class="line-modified"> 180   gint len = digest_len * 2;</span>
<span class="line-removed"> 181   gint i;</span>
 182   gchar *retval;
 183 
 184   retval = g_new (gchar, len + 1);
 185 
 186   for (i = 0; i &lt; digest_len; i++)
 187     {
 188       guint8 byte = digest[i];
 189 
 190       retval[2 * i] = hex_digits[byte &gt;&gt; 4];
 191       retval[2 * i + 1] = hex_digits[byte &amp; 0xf];
 192     }
 193 
 194   retval[len] = 0;
 195 
 196   return retval;
 197 }
 198 
 199 /*
 200  * MD5 Checksum
 201  */
</pre>
<hr />
<pre>
 446 {
 447   return digest_to_string (md5-&gt;digest, MD5_DIGEST_LEN);
 448 }
 449 
 450 static void
 451 md5_sum_digest (Md5sum *md5,
 452                 guint8 *digest)
 453 {
 454   gint i;
 455 
 456   for (i = 0; i &lt; MD5_DIGEST_LEN; i++)
 457     digest[i] = md5-&gt;digest[i];
 458 }
 459 
 460 /*
 461  * SHA-1 Checksum
 462  */
 463 
 464 /* The following implementation comes from D-Bus dbus-sha.c. I&#39;ve changed
 465  * it to use GLib types and to work more like the MD5 implementation above.
<span class="line-modified"> 466  * I left the comments to have an history of this code.</span>
 467  *      -- Emmanuele Bassi, ebassi@gnome.org
 468  */
 469 
 470 /* The following comments have the history of where this code
 471  * comes from. I actually copied it from GNet in GNOME CVS.
 472  * - hp@redhat.com
 473  */
 474 
 475 /*
 476  *  sha.h : Implementation of the Secure Hash Algorithm
 477  *
 478  * Part of the Python Cryptography Toolkit, version 1.0.0
 479  *
 480  * Copyright (C) 1995, A.M. Kuchling
 481  *
 482  * Distribute and use freely; there are no restrictions on further
 483  * dissemination and usage except those imposed by the laws of your
 484  * country of residence.
 485  *
 486  */
</pre>
<hr />
<pre>
1073 sha256_sum_to_string (Sha256sum *sha256)
1074 {
1075   return digest_to_string (sha256-&gt;digest, SHA256_DIGEST_LEN);
1076 }
1077 
1078 static void
1079 sha256_sum_digest (Sha256sum *sha256,
1080                    guint8    *digest)
1081 {
1082   gint i;
1083 
1084   for (i = 0; i &lt; SHA256_DIGEST_LEN; i++)
1085     digest[i] = sha256-&gt;digest[i];
1086 }
1087 
1088 /*
1089  * SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Checksums
1090  *
1091  * Implemented following FIPS-180-4 standard at
1092  * http://csrc.nist.gov/publications/fips/fips180-4/fips180-4.pdf.
<span class="line-modified">1093  * References in the form [�x.y.z] map to sections in that document.</span>
1094  *
1095  *   Author(s): Eduardo Lima Mitev &lt;elima@igalia.com&gt;
1096  *              Igor Gnatenko &lt;ignatenko@src.gnome.org&gt;
1097  */
1098 
<span class="line-modified">1099 /* SHA-384, SHA-512, SHA-512/224 and SHA-512/256 functions [�4.1.3] */</span>
1100 #define Ch(x,y,z)  ((x &amp; y) ^ (~x &amp; z))
1101 #define Maj(x,y,z) ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))
1102 #define SHR(n,x)   (x &gt;&gt; n)
1103 #define ROTR(n,x)  (SHR (n, x) | (x &lt;&lt; (64 - n)))
1104 #define SIGMA0(x)  (ROTR (28, x) ^ ROTR (34, x) ^ ROTR (39, x))
1105 #define SIGMA1(x)  (ROTR (14, x) ^ ROTR (18, x) ^ ROTR (41, x))
1106 #define sigma0(x)  (ROTR ( 1, x) ^ ROTR ( 8, x) ^ SHR  ( 7, x))
1107 #define sigma1(x)  (ROTR (19, x) ^ ROTR (61, x) ^ SHR  ( 6, x))
1108 
1109 #define PUT_UINT64(n,b,i)                G_STMT_START{   \
1110     (b)[(i)    ] = (guint8) (n &gt;&gt; 56);                   \
1111     (b)[(i) + 1] = (guint8) (n &gt;&gt; 48);                   \
1112     (b)[(i) + 2] = (guint8) (n &gt;&gt; 40);                   \
1113     (b)[(i) + 3] = (guint8) (n &gt;&gt; 32);                   \
1114     (b)[(i) + 4] = (guint8) (n &gt;&gt; 24);                   \
1115     (b)[(i) + 5] = (guint8) (n &gt;&gt; 16);                   \
1116     (b)[(i) + 6] = (guint8) (n &gt;&gt;  8);                   \
1117     (b)[(i) + 7] = (guint8) (n      ); } G_STMT_END
1118 
<span class="line-modified">1119 /* SHA-384 and SHA-512 constants [�4.2.3] */</span>
1120 static const guint64 SHA2_K[80] = {
1121   G_GUINT64_CONSTANT (0x428a2f98d728ae22), G_GUINT64_CONSTANT (0x7137449123ef65cd),
1122   G_GUINT64_CONSTANT (0xb5c0fbcfec4d3b2f), G_GUINT64_CONSTANT (0xe9b5dba58189dbbc),
1123   G_GUINT64_CONSTANT (0x3956c25bf348b538), G_GUINT64_CONSTANT (0x59f111f1b605d019),
1124   G_GUINT64_CONSTANT (0x923f82a4af194f9b), G_GUINT64_CONSTANT (0xab1c5ed5da6d8118),
1125   G_GUINT64_CONSTANT (0xd807aa98a3030242), G_GUINT64_CONSTANT (0x12835b0145706fbe),
1126   G_GUINT64_CONSTANT (0x243185be4ee4b28c), G_GUINT64_CONSTANT (0x550c7dc3d5ffb4e2),
1127   G_GUINT64_CONSTANT (0x72be5d74f27b896f), G_GUINT64_CONSTANT (0x80deb1fe3b1696b1),
1128   G_GUINT64_CONSTANT (0x9bdc06a725c71235), G_GUINT64_CONSTANT (0xc19bf174cf692694),
1129   G_GUINT64_CONSTANT (0xe49b69c19ef14ad2), G_GUINT64_CONSTANT (0xefbe4786384f25e3),
1130   G_GUINT64_CONSTANT (0x0fc19dc68b8cd5b5), G_GUINT64_CONSTANT (0x240ca1cc77ac9c65),
1131   G_GUINT64_CONSTANT (0x2de92c6f592b0275), G_GUINT64_CONSTANT (0x4a7484aa6ea6e483),
1132   G_GUINT64_CONSTANT (0x5cb0a9dcbd41fbd4), G_GUINT64_CONSTANT (0x76f988da831153b5),
1133   G_GUINT64_CONSTANT (0x983e5152ee66dfab), G_GUINT64_CONSTANT (0xa831c66d2db43210),
1134   G_GUINT64_CONSTANT (0xb00327c898fb213f), G_GUINT64_CONSTANT (0xbf597fc7beef0ee4),
1135   G_GUINT64_CONSTANT (0xc6e00bf33da88fc2), G_GUINT64_CONSTANT (0xd5a79147930aa725),
1136   G_GUINT64_CONSTANT (0x06ca6351e003826f), G_GUINT64_CONSTANT (0x142929670a0e6e70),
1137   G_GUINT64_CONSTANT (0x27b70a8546d22ffc), G_GUINT64_CONSTANT (0x2e1b21385c26c926),
1138   G_GUINT64_CONSTANT (0x4d2c6dfc5ac42aed), G_GUINT64_CONSTANT (0x53380d139d95b3df),
1139   G_GUINT64_CONSTANT (0x650a73548baf63de), G_GUINT64_CONSTANT (0x766a0abb3c77b2a8),
</pre>
<hr />
<pre>
1147   G_GUINT64_CONSTANT (0x391c0cb3c5c95a63), G_GUINT64_CONSTANT (0x4ed8aa4ae3418acb),
1148   G_GUINT64_CONSTANT (0x5b9cca4f7763e373), G_GUINT64_CONSTANT (0x682e6ff3d6b2b8a3),
1149   G_GUINT64_CONSTANT (0x748f82ee5defb2fc), G_GUINT64_CONSTANT (0x78a5636f43172f60),
1150   G_GUINT64_CONSTANT (0x84c87814a1f0ab72), G_GUINT64_CONSTANT (0x8cc702081a6439ec),
1151   G_GUINT64_CONSTANT (0x90befffa23631e28), G_GUINT64_CONSTANT (0xa4506cebde82bde9),
1152   G_GUINT64_CONSTANT (0xbef9a3f7b2c67915), G_GUINT64_CONSTANT (0xc67178f2e372532b),
1153   G_GUINT64_CONSTANT (0xca273eceea26619c), G_GUINT64_CONSTANT (0xd186b8c721c0c207),
1154   G_GUINT64_CONSTANT (0xeada7dd6cde0eb1e), G_GUINT64_CONSTANT (0xf57d4f7fee6ed178),
1155   G_GUINT64_CONSTANT (0x06f067aa72176fba), G_GUINT64_CONSTANT (0x0a637dc5a2c898a6),
1156   G_GUINT64_CONSTANT (0x113f9804bef90dae), G_GUINT64_CONSTANT (0x1b710b35131c471b),
1157   G_GUINT64_CONSTANT (0x28db77f523047d84), G_GUINT64_CONSTANT (0x32caab7b40c72493),
1158   G_GUINT64_CONSTANT (0x3c9ebe0a15c9bebc), G_GUINT64_CONSTANT (0x431d67c49c100d4c),
1159   G_GUINT64_CONSTANT (0x4cc5d4becb3e42b6), G_GUINT64_CONSTANT (0x597f299cfc657e2a),
1160   G_GUINT64_CONSTANT (0x5fcb6fab3ad6faec), G_GUINT64_CONSTANT (0x6c44198c4a475817)
1161 };
1162 
1163 
1164 static void
1165 sha384_sum_init (Sha512sum *sha512)
1166 {
<span class="line-modified">1167   /* Initial Hash Value [�5.3.4] */</span>
1168   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0xcbbb9d5dc1059ed8);
1169   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0x629a292a367cd507);
1170   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x9159015a3070dd17);
1171   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0x152fecd8f70e5939);
1172   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x67332667ffc00b31);
1173   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x8eb44a8768581511);
1174   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0xdb0c2e0d64f98fa7);
1175   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x47b5481dbefa4fa4);
1176 
1177   sha512-&gt;block_len = 0;
1178 
1179   sha512-&gt;data_len[0] = 0;
1180   sha512-&gt;data_len[1] = 0;
1181 }
1182 
1183 static void
1184 sha512_sum_init (Sha512sum *sha512)
1185 {
<span class="line-modified">1186   /* Initial Hash Value [�5.3.5] */</span>
1187   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0x6a09e667f3bcc908);
1188   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0xbb67ae8584caa73b);
1189   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x3c6ef372fe94f82b);
1190   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0xa54ff53a5f1d36f1);
1191   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x510e527fade682d1);
1192   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x9b05688c2b3e6c1f);
1193   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0x1f83d9abfb41bd6b);
1194   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x5be0cd19137e2179);
1195 
1196   sha512-&gt;block_len = 0;
1197 
1198   sha512-&gt;data_len[0] = 0;
1199   sha512-&gt;data_len[1] = 0;
1200 }
1201 
1202 static void
1203 sha512_transform (guint64      H[8],
1204                   guint8 const data[SHA2_BLOCK_LEN])
1205 {
1206   gint i;
1207   gint t;
1208   guint64 a, b, c, d, e, f, g, h;
1209   guint64 M[16];
1210   guint64 W[80];
1211 
<span class="line-modified">1212   /* SHA-512 hash computation [�6.4.2] */</span>
1213 
1214   /* prepare the message schedule */
1215   for (i = 0; i &lt; 16; i++)
1216     {
1217       gint p = i * 8;
1218 
1219       M[i] =
1220         ((guint64) data[p + 0] &lt;&lt; 56) |
1221         ((guint64) data[p + 1] &lt;&lt; 48) |
1222         ((guint64) data[p + 2] &lt;&lt; 40) |
1223         ((guint64) data[p + 3] &lt;&lt; 32) |
1224         ((guint64) data[p + 4] &lt;&lt; 24) |
1225         ((guint64) data[p + 5] &lt;&lt; 16) |
1226         ((guint64) data[p + 6] &lt;&lt;  8) |
1227         ((guint64) data[p + 7]      );
1228     }
1229 
1230   for (t = 0; t &lt; 80; t++)
1231     if (t &lt; 16)
1232       W[t] = M[t];
</pre>
<hr />
<pre>
1314       offset += SHA2_BLOCK_LEN;
1315     }
1316 
1317   /* keep remaining data for next block */
1318   if (length &gt; 0)
1319     {
1320       memcpy (sha512-&gt;block, buffer + offset, length);
1321       sha512-&gt;block_len = length;
1322     }
1323 }
1324 
1325 static void
1326 sha512_sum_close (Sha512sum *sha512)
1327 {
1328   guint l;
1329   gint zeros;
1330   guint8 pad[SHA2_BLOCK_LEN * 2] = { 0, };
1331   guint pad_len = 0;
1332   gint i;
1333 
<span class="line-modified">1334   /* apply padding [�5.1.2] */</span>
1335   l = sha512-&gt;block_len * 8;
1336   zeros = 896 - (l + 1);
1337 
1338   if (zeros &lt; 0)
1339     zeros += 128 * 8;
1340 
1341   pad[0] = 0x80; /* 1000 0000 */
1342   zeros -= 7;
1343   pad_len++;
1344 
1345   memset (pad + pad_len, 0x00, zeros / 8);
1346   pad_len += zeros / 8;
1347   zeros = zeros % 8;
1348 
1349   /* put message bit length at the end of padding */
1350   PUT_UINT64 (sha512-&gt;data_len[1], pad, pad_len);
1351   pad_len += 8;
1352 
1353   PUT_UINT64 (sha512-&gt;data_len[0], pad, pad_len);
1354   pad_len += 8;
</pre>
<hr />
<pre>
1612     case G_CHECKSUM_SHA1:
1613       sha1_sum_update (&amp;(checksum-&gt;sum.sha1), data, length);
1614       break;
1615     case G_CHECKSUM_SHA256:
1616       sha256_sum_update (&amp;(checksum-&gt;sum.sha256), data, length);
1617       break;
1618     case G_CHECKSUM_SHA384:
1619     case G_CHECKSUM_SHA512:
1620       sha512_sum_update (&amp;(checksum-&gt;sum.sha512), data, length);
1621       break;
1622     default:
1623       g_assert_not_reached ();
1624       break;
1625     }
1626 }
1627 
1628 /**
1629  * g_checksum_get_string:
1630  * @checksum: a #GChecksum
1631  *
<span class="line-modified">1632  * Gets the digest as an hexadecimal string.</span>
1633  *
1634  * Once this function has been called the #GChecksum can no longer be
1635  * updated with g_checksum_update().
1636  *
1637  * The hexadecimal characters will be lower case.
1638  *
1639  * Returns: the hexadecimal representation of the checksum. The
1640  *   returned string is owned by the checksum and should not be modified
1641  *   or freed.
1642  *
1643  * Since: 2.16
1644  */
1645 const gchar *
1646 g_checksum_get_string (GChecksum *checksum)
1647 {
1648   gchar *str = NULL;
1649 
1650   g_return_val_if_fail (checksum != NULL, NULL);
1651 
1652   if (checksum-&gt;digest_str)
</pre>
</td>
<td>
<hr />
<pre>
 160 #if G_BYTE_ORDER == G_BIG_ENDIAN
 161 #define sha_byte_reverse(buffer,length)
 162 #else
 163 static inline void
 164 sha_byte_reverse (guint32 *buffer,
 165                   gint     length)
 166 {
 167   length /= sizeof (guint32);
 168   while (length--)
 169     {
 170       *buffer = GUINT32_SWAP_LE_BE (*buffer);
 171       ++buffer;
 172     }
 173 }
 174 #endif /* G_BYTE_ORDER == G_BIG_ENDIAN */
 175 
 176 static gchar *
 177 digest_to_string (guint8 *digest,
 178                   gsize   digest_len)
 179 {
<span class="line-modified"> 180   gsize i, len = digest_len * 2;</span>

 181   gchar *retval;
 182 
 183   retval = g_new (gchar, len + 1);
 184 
 185   for (i = 0; i &lt; digest_len; i++)
 186     {
 187       guint8 byte = digest[i];
 188 
 189       retval[2 * i] = hex_digits[byte &gt;&gt; 4];
 190       retval[2 * i + 1] = hex_digits[byte &amp; 0xf];
 191     }
 192 
 193   retval[len] = 0;
 194 
 195   return retval;
 196 }
 197 
 198 /*
 199  * MD5 Checksum
 200  */
</pre>
<hr />
<pre>
 445 {
 446   return digest_to_string (md5-&gt;digest, MD5_DIGEST_LEN);
 447 }
 448 
 449 static void
 450 md5_sum_digest (Md5sum *md5,
 451                 guint8 *digest)
 452 {
 453   gint i;
 454 
 455   for (i = 0; i &lt; MD5_DIGEST_LEN; i++)
 456     digest[i] = md5-&gt;digest[i];
 457 }
 458 
 459 /*
 460  * SHA-1 Checksum
 461  */
 462 
 463 /* The following implementation comes from D-Bus dbus-sha.c. I&#39;ve changed
 464  * it to use GLib types and to work more like the MD5 implementation above.
<span class="line-modified"> 465  * I left the comments to have a history of this code.</span>
 466  *      -- Emmanuele Bassi, ebassi@gnome.org
 467  */
 468 
 469 /* The following comments have the history of where this code
 470  * comes from. I actually copied it from GNet in GNOME CVS.
 471  * - hp@redhat.com
 472  */
 473 
 474 /*
 475  *  sha.h : Implementation of the Secure Hash Algorithm
 476  *
 477  * Part of the Python Cryptography Toolkit, version 1.0.0
 478  *
 479  * Copyright (C) 1995, A.M. Kuchling
 480  *
 481  * Distribute and use freely; there are no restrictions on further
 482  * dissemination and usage except those imposed by the laws of your
 483  * country of residence.
 484  *
 485  */
</pre>
<hr />
<pre>
1072 sha256_sum_to_string (Sha256sum *sha256)
1073 {
1074   return digest_to_string (sha256-&gt;digest, SHA256_DIGEST_LEN);
1075 }
1076 
1077 static void
1078 sha256_sum_digest (Sha256sum *sha256,
1079                    guint8    *digest)
1080 {
1081   gint i;
1082 
1083   for (i = 0; i &lt; SHA256_DIGEST_LEN; i++)
1084     digest[i] = sha256-&gt;digest[i];
1085 }
1086 
1087 /*
1088  * SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Checksums
1089  *
1090  * Implemented following FIPS-180-4 standard at
1091  * http://csrc.nist.gov/publications/fips/fips180-4/fips180-4.pdf.
<span class="line-modified">1092  * References in the form [x.y.z] map to sections in that document.</span>
1093  *
1094  *   Author(s): Eduardo Lima Mitev &lt;elima@igalia.com&gt;
1095  *              Igor Gnatenko &lt;ignatenko@src.gnome.org&gt;
1096  */
1097 
<span class="line-modified">1098 /* SHA-384, SHA-512, SHA-512/224 and SHA-512/256 functions [4.1.3] */</span>
1099 #define Ch(x,y,z)  ((x &amp; y) ^ (~x &amp; z))
1100 #define Maj(x,y,z) ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))
1101 #define SHR(n,x)   (x &gt;&gt; n)
1102 #define ROTR(n,x)  (SHR (n, x) | (x &lt;&lt; (64 - n)))
1103 #define SIGMA0(x)  (ROTR (28, x) ^ ROTR (34, x) ^ ROTR (39, x))
1104 #define SIGMA1(x)  (ROTR (14, x) ^ ROTR (18, x) ^ ROTR (41, x))
1105 #define sigma0(x)  (ROTR ( 1, x) ^ ROTR ( 8, x) ^ SHR  ( 7, x))
1106 #define sigma1(x)  (ROTR (19, x) ^ ROTR (61, x) ^ SHR  ( 6, x))
1107 
1108 #define PUT_UINT64(n,b,i)                G_STMT_START{   \
1109     (b)[(i)    ] = (guint8) (n &gt;&gt; 56);                   \
1110     (b)[(i) + 1] = (guint8) (n &gt;&gt; 48);                   \
1111     (b)[(i) + 2] = (guint8) (n &gt;&gt; 40);                   \
1112     (b)[(i) + 3] = (guint8) (n &gt;&gt; 32);                   \
1113     (b)[(i) + 4] = (guint8) (n &gt;&gt; 24);                   \
1114     (b)[(i) + 5] = (guint8) (n &gt;&gt; 16);                   \
1115     (b)[(i) + 6] = (guint8) (n &gt;&gt;  8);                   \
1116     (b)[(i) + 7] = (guint8) (n      ); } G_STMT_END
1117 
<span class="line-modified">1118 /* SHA-384 and SHA-512 constants [4.2.3] */</span>
1119 static const guint64 SHA2_K[80] = {
1120   G_GUINT64_CONSTANT (0x428a2f98d728ae22), G_GUINT64_CONSTANT (0x7137449123ef65cd),
1121   G_GUINT64_CONSTANT (0xb5c0fbcfec4d3b2f), G_GUINT64_CONSTANT (0xe9b5dba58189dbbc),
1122   G_GUINT64_CONSTANT (0x3956c25bf348b538), G_GUINT64_CONSTANT (0x59f111f1b605d019),
1123   G_GUINT64_CONSTANT (0x923f82a4af194f9b), G_GUINT64_CONSTANT (0xab1c5ed5da6d8118),
1124   G_GUINT64_CONSTANT (0xd807aa98a3030242), G_GUINT64_CONSTANT (0x12835b0145706fbe),
1125   G_GUINT64_CONSTANT (0x243185be4ee4b28c), G_GUINT64_CONSTANT (0x550c7dc3d5ffb4e2),
1126   G_GUINT64_CONSTANT (0x72be5d74f27b896f), G_GUINT64_CONSTANT (0x80deb1fe3b1696b1),
1127   G_GUINT64_CONSTANT (0x9bdc06a725c71235), G_GUINT64_CONSTANT (0xc19bf174cf692694),
1128   G_GUINT64_CONSTANT (0xe49b69c19ef14ad2), G_GUINT64_CONSTANT (0xefbe4786384f25e3),
1129   G_GUINT64_CONSTANT (0x0fc19dc68b8cd5b5), G_GUINT64_CONSTANT (0x240ca1cc77ac9c65),
1130   G_GUINT64_CONSTANT (0x2de92c6f592b0275), G_GUINT64_CONSTANT (0x4a7484aa6ea6e483),
1131   G_GUINT64_CONSTANT (0x5cb0a9dcbd41fbd4), G_GUINT64_CONSTANT (0x76f988da831153b5),
1132   G_GUINT64_CONSTANT (0x983e5152ee66dfab), G_GUINT64_CONSTANT (0xa831c66d2db43210),
1133   G_GUINT64_CONSTANT (0xb00327c898fb213f), G_GUINT64_CONSTANT (0xbf597fc7beef0ee4),
1134   G_GUINT64_CONSTANT (0xc6e00bf33da88fc2), G_GUINT64_CONSTANT (0xd5a79147930aa725),
1135   G_GUINT64_CONSTANT (0x06ca6351e003826f), G_GUINT64_CONSTANT (0x142929670a0e6e70),
1136   G_GUINT64_CONSTANT (0x27b70a8546d22ffc), G_GUINT64_CONSTANT (0x2e1b21385c26c926),
1137   G_GUINT64_CONSTANT (0x4d2c6dfc5ac42aed), G_GUINT64_CONSTANT (0x53380d139d95b3df),
1138   G_GUINT64_CONSTANT (0x650a73548baf63de), G_GUINT64_CONSTANT (0x766a0abb3c77b2a8),
</pre>
<hr />
<pre>
1146   G_GUINT64_CONSTANT (0x391c0cb3c5c95a63), G_GUINT64_CONSTANT (0x4ed8aa4ae3418acb),
1147   G_GUINT64_CONSTANT (0x5b9cca4f7763e373), G_GUINT64_CONSTANT (0x682e6ff3d6b2b8a3),
1148   G_GUINT64_CONSTANT (0x748f82ee5defb2fc), G_GUINT64_CONSTANT (0x78a5636f43172f60),
1149   G_GUINT64_CONSTANT (0x84c87814a1f0ab72), G_GUINT64_CONSTANT (0x8cc702081a6439ec),
1150   G_GUINT64_CONSTANT (0x90befffa23631e28), G_GUINT64_CONSTANT (0xa4506cebde82bde9),
1151   G_GUINT64_CONSTANT (0xbef9a3f7b2c67915), G_GUINT64_CONSTANT (0xc67178f2e372532b),
1152   G_GUINT64_CONSTANT (0xca273eceea26619c), G_GUINT64_CONSTANT (0xd186b8c721c0c207),
1153   G_GUINT64_CONSTANT (0xeada7dd6cde0eb1e), G_GUINT64_CONSTANT (0xf57d4f7fee6ed178),
1154   G_GUINT64_CONSTANT (0x06f067aa72176fba), G_GUINT64_CONSTANT (0x0a637dc5a2c898a6),
1155   G_GUINT64_CONSTANT (0x113f9804bef90dae), G_GUINT64_CONSTANT (0x1b710b35131c471b),
1156   G_GUINT64_CONSTANT (0x28db77f523047d84), G_GUINT64_CONSTANT (0x32caab7b40c72493),
1157   G_GUINT64_CONSTANT (0x3c9ebe0a15c9bebc), G_GUINT64_CONSTANT (0x431d67c49c100d4c),
1158   G_GUINT64_CONSTANT (0x4cc5d4becb3e42b6), G_GUINT64_CONSTANT (0x597f299cfc657e2a),
1159   G_GUINT64_CONSTANT (0x5fcb6fab3ad6faec), G_GUINT64_CONSTANT (0x6c44198c4a475817)
1160 };
1161 
1162 
1163 static void
1164 sha384_sum_init (Sha512sum *sha512)
1165 {
<span class="line-modified">1166   /* Initial Hash Value [5.3.4] */</span>
1167   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0xcbbb9d5dc1059ed8);
1168   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0x629a292a367cd507);
1169   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x9159015a3070dd17);
1170   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0x152fecd8f70e5939);
1171   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x67332667ffc00b31);
1172   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x8eb44a8768581511);
1173   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0xdb0c2e0d64f98fa7);
1174   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x47b5481dbefa4fa4);
1175 
1176   sha512-&gt;block_len = 0;
1177 
1178   sha512-&gt;data_len[0] = 0;
1179   sha512-&gt;data_len[1] = 0;
1180 }
1181 
1182 static void
1183 sha512_sum_init (Sha512sum *sha512)
1184 {
<span class="line-modified">1185   /* Initial Hash Value [5.3.5] */</span>
1186   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0x6a09e667f3bcc908);
1187   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0xbb67ae8584caa73b);
1188   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x3c6ef372fe94f82b);
1189   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0xa54ff53a5f1d36f1);
1190   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x510e527fade682d1);
1191   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x9b05688c2b3e6c1f);
1192   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0x1f83d9abfb41bd6b);
1193   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x5be0cd19137e2179);
1194 
1195   sha512-&gt;block_len = 0;
1196 
1197   sha512-&gt;data_len[0] = 0;
1198   sha512-&gt;data_len[1] = 0;
1199 }
1200 
1201 static void
1202 sha512_transform (guint64      H[8],
1203                   guint8 const data[SHA2_BLOCK_LEN])
1204 {
1205   gint i;
1206   gint t;
1207   guint64 a, b, c, d, e, f, g, h;
1208   guint64 M[16];
1209   guint64 W[80];
1210 
<span class="line-modified">1211   /* SHA-512 hash computation [6.4.2] */</span>
1212 
1213   /* prepare the message schedule */
1214   for (i = 0; i &lt; 16; i++)
1215     {
1216       gint p = i * 8;
1217 
1218       M[i] =
1219         ((guint64) data[p + 0] &lt;&lt; 56) |
1220         ((guint64) data[p + 1] &lt;&lt; 48) |
1221         ((guint64) data[p + 2] &lt;&lt; 40) |
1222         ((guint64) data[p + 3] &lt;&lt; 32) |
1223         ((guint64) data[p + 4] &lt;&lt; 24) |
1224         ((guint64) data[p + 5] &lt;&lt; 16) |
1225         ((guint64) data[p + 6] &lt;&lt;  8) |
1226         ((guint64) data[p + 7]      );
1227     }
1228 
1229   for (t = 0; t &lt; 80; t++)
1230     if (t &lt; 16)
1231       W[t] = M[t];
</pre>
<hr />
<pre>
1313       offset += SHA2_BLOCK_LEN;
1314     }
1315 
1316   /* keep remaining data for next block */
1317   if (length &gt; 0)
1318     {
1319       memcpy (sha512-&gt;block, buffer + offset, length);
1320       sha512-&gt;block_len = length;
1321     }
1322 }
1323 
1324 static void
1325 sha512_sum_close (Sha512sum *sha512)
1326 {
1327   guint l;
1328   gint zeros;
1329   guint8 pad[SHA2_BLOCK_LEN * 2] = { 0, };
1330   guint pad_len = 0;
1331   gint i;
1332 
<span class="line-modified">1333   /* apply padding [5.1.2] */</span>
1334   l = sha512-&gt;block_len * 8;
1335   zeros = 896 - (l + 1);
1336 
1337   if (zeros &lt; 0)
1338     zeros += 128 * 8;
1339 
1340   pad[0] = 0x80; /* 1000 0000 */
1341   zeros -= 7;
1342   pad_len++;
1343 
1344   memset (pad + pad_len, 0x00, zeros / 8);
1345   pad_len += zeros / 8;
1346   zeros = zeros % 8;
1347 
1348   /* put message bit length at the end of padding */
1349   PUT_UINT64 (sha512-&gt;data_len[1], pad, pad_len);
1350   pad_len += 8;
1351 
1352   PUT_UINT64 (sha512-&gt;data_len[0], pad, pad_len);
1353   pad_len += 8;
</pre>
<hr />
<pre>
1611     case G_CHECKSUM_SHA1:
1612       sha1_sum_update (&amp;(checksum-&gt;sum.sha1), data, length);
1613       break;
1614     case G_CHECKSUM_SHA256:
1615       sha256_sum_update (&amp;(checksum-&gt;sum.sha256), data, length);
1616       break;
1617     case G_CHECKSUM_SHA384:
1618     case G_CHECKSUM_SHA512:
1619       sha512_sum_update (&amp;(checksum-&gt;sum.sha512), data, length);
1620       break;
1621     default:
1622       g_assert_not_reached ();
1623       break;
1624     }
1625 }
1626 
1627 /**
1628  * g_checksum_get_string:
1629  * @checksum: a #GChecksum
1630  *
<span class="line-modified">1631  * Gets the digest as a hexadecimal string.</span>
1632  *
1633  * Once this function has been called the #GChecksum can no longer be
1634  * updated with g_checksum_update().
1635  *
1636  * The hexadecimal characters will be lower case.
1637  *
1638  * Returns: the hexadecimal representation of the checksum. The
1639  *   returned string is owned by the checksum and should not be modified
1640  *   or freed.
1641  *
1642  * Since: 2.16
1643  */
1644 const gchar *
1645 g_checksum_get_string (GChecksum *checksum)
1646 {
1647   gchar *str = NULL;
1648 
1649   g_return_val_if_fail (checksum != NULL, NULL);
1650 
1651   if (checksum-&gt;digest_str)
</pre>
</td>
</tr>
</table>
<center><a href="gcharset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gconstructor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>