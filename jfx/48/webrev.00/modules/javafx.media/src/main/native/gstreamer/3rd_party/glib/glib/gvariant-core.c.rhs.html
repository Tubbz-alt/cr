<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-core.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright (C) 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 
  21 #include &lt;glib/gvariant-core.h&gt;
  22 
  23 #include &lt;glib/gvariant-internal.h&gt;
  24 #include &lt;glib/gvariant-serialiser.h&gt;
  25 #include &lt;glib/gtestutils.h&gt;
  26 #include &lt;glib/gbitlock.h&gt;
  27 #include &lt;glib/gatomic.h&gt;
  28 #include &lt;glib/gbytes.h&gt;
  29 #include &lt;glib/gslice.h&gt;
  30 #include &lt;glib/gmem.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  31 #include &lt;glib/grefcount.h&gt;</span>
  32 #include &lt;string.h&gt;
  33 
  34 
  35 /*
  36  * This file includes the structure definition for GVariant and a small
  37  * set of functions that are allowed to access the structure directly.
  38  *
  39  * This minimises the amount of code that can possibly touch a GVariant
  40  * structure directly to a few simple fundamental operations.  These few
  41  * operations are written to be completely threadsafe with respect to
  42  * all possible outside access.  This means that we only need to be
  43  * concerned about thread safety issues in this one small file.
  44  *
  45  * Most GVariant API functions are in gvariant.c.
  46  */
  47 
  48 /**
  49  * GVariant:
  50  *
  51  * #GVariant is an opaque data structure and can only be accessed
  52  * using the following functions.
  53  *
  54  * Since: 2.24
  55  **/
  56 struct _GVariant
  57 /* see below for field member documentation */
  58 {
  59   GVariantTypeInfo *type_info;
  60   gsize size;
  61 
  62   union
  63   {
  64     struct
  65     {
  66       GBytes *bytes;
  67       gconstpointer data;
  68     } serialised;
  69 
  70     struct
  71     {
  72       GVariant **children;
  73       gsize n_children;
  74     } tree;
  75   } contents;
  76 
  77   gint state;
<a name="3" id="anc3"></a><span class="line-modified">  78   gatomicrefcount ref_count;</span>
  79   gsize depth;
  80 };
  81 
  82 /* struct GVariant:
  83  *
  84  * There are two primary forms of GVariant instances: &quot;serialised form&quot;
  85  * and &quot;tree form&quot;.
  86  *
  87  * &quot;serialised form&quot;: A serialised GVariant instance stores its value in
  88  *                    the GVariant serialisation format.  All
  89  *                    basic-typed instances (ie: non-containers) are in
  90  *                    serialised format, as are some containers.
  91  *
  92  * &quot;tree form&quot;: Some containers are in &quot;tree form&quot;.  In this case,
  93  *              instead of containing the serialised data for the
  94  *              container, the instance contains an array of pointers to
  95  *              the child values of the container (thus forming a tree).
  96  *
  97  * It is possible for an instance to transition from tree form to
  98  * serialised form.  This happens, implicitly, if the serialised data is
  99  * requested (eg: via g_variant_get_data()).  Serialised form instances
 100  * never transition into tree form.
 101  *
 102  *
 103  * The fields of the structure are documented here:
 104  *
 105  * type_info: this is a reference to a GVariantTypeInfo describing the
 106  *            type of the instance.  When the instance is freed, this
 107  *            reference must be released with g_variant_type_info_unref().
 108  *
 109  *            The type_info field never changes during the life of the
 110  *            instance, so it can be accessed without a lock.
 111  *
 112  * size: this is the size of the serialised form for the instance, if it
 113  *       is known.  If the instance is in serialised form then it is, by
 114  *       definition, known.  If the instance is in tree form then it may
 115  *       be unknown (in which case it is -1).  It is possible for the
 116  *       size to be known when in tree form if, for example, the user
 117  *       has called g_variant_get_size() without calling
 118  *       g_variant_get_data().  Additionally, even when the user calls
 119  *       g_variant_get_data() the size of the data must first be
 120  *       determined so that a large enough buffer can be allocated for
 121  *       the data.
 122  *
 123  *       Once the size is known, it can never become unknown again.
 124  *       g_variant_ensure_size() is used to ensure that the size is in
 125  *       the known state -- it calculates the size if needed.  After
 126  *       that, the size field can be accessed without a lock.
 127  *
 128  * contents: a union containing either the information associated with
 129  *           holding a value in serialised form or holding a value in
 130  *           tree form.
 131  *
 132  *   .serialised: Only valid when the instance is in serialised form.
 133  *
 134  *                Since an instance can never transition away from
 135  *                serialised form, once these fields are set, they will
 136  *                never be changed.  It is therefore valid to access
 137  *                them without holding a lock.
 138  *
 139  *     .bytes:  the #GBytes that contains the memory pointed to by
 140  *              .data, or %NULL if .data is %NULL.  In the event that
 141  *              the instance was deserialised from another instance,
 142  *              then the bytes will be shared by both of them.  When
 143  *              the instance is freed, this reference must be released
 144  *              with g_bytes_unref().
 145  *
 146  *     .data: the serialised data (of size &#39;size&#39;) of the instance.
 147  *            This pointer should not be freed or modified in any way.
 148  *            #GBytes is responsible for memory management.
 149  *
 150  *            This pointer may be %NULL in two cases:
 151  *
 152  *              - if the serialised size of the instance is 0
 153  *
 154  *              - if the instance is of a fixed-sized type and was
 155  *                deserialised out of a corrupted container such that
 156  *                the container contains too few bytes to point to the
 157  *                entire proper fixed-size of this instance.  In this
 158  *                case, &#39;size&#39; will still be equal to the proper fixed
 159  *                size, but this pointer will be %NULL.  This is exactly
 160  *                the reason that g_variant_get_data() sometimes returns
 161  *                %NULL.  For all other calls, the effect should be as
 162  *                if .data pointed to the appropriate number of nul
 163  *                bytes.
 164  *
 165  *   .tree: Only valid when the instance is in tree form.
 166  *
 167  *          Note that accesses from other threads could result in
 168  *          conversion of the instance from tree form to serialised form
 169  *          at any time.  For this reason, the instance lock must always
 170  *          be held while performing any operations on &#39;contents.tree&#39;.
 171  *
 172  *     .children: the array of the child instances of this instance.
 173  *                When the instance is freed (or converted to serialised
 174  *                form) then each child must have g_variant_unref()
 175  *                called on it and the array must be freed using
 176  *                g_free().
 177  *
 178  *     .n_children: the number of items in the .children array.
 179  *
 180  * state: a bitfield describing the state of the instance.  It is a
 181  *        bitwise-or of the following STATE_* constants:
 182  *
 183  *    STATE_LOCKED: the instance lock is held.  This is the bit used by
 184  *                  g_bit_lock().
 185  *
 186  *    STATE_SERIALISED: the instance is in serialised form.  If this
 187  *                      flag is not set then the instance is in tree
 188  *                      form.
 189  *
 190  *    STATE_TRUSTED: for serialised form instances, this means that the
 191  *                   serialised data is known to be in normal form (ie:
 192  *                   not corrupted).
 193  *
 194  *                   For tree form instances, this means that all of the
 195  *                   child instances in the contents.tree.children array
 196  *                   are trusted.  This means that if the container is
 197  *                   serialised then the resulting data will be in
 198  *                   normal form.
 199  *
 200  *                   If this flag is unset it does not imply that the
 201  *                   data is corrupted.  It merely means that we&#39;re not
 202  *                   sure that it&#39;s valid.  See g_variant_is_trusted().
 203  *
 204  *    STATE_FLOATING: if this flag is set then the object has a floating
 205  *                    reference.  See g_variant_ref_sink().
 206  *
 207  * ref_count: the reference count of the instance
 208  *
 209  * depth: the depth of the GVariant in a hierarchy of nested containers,
 210  *        increasing with the level of nesting. The top-most GVariant has depth
 211  *        zero.  This is used to avoid recursing too deeply and overflowing the
 212  *        stack when handling deeply nested untrusted serialised GVariants.
 213  */
 214 #define STATE_LOCKED     1
 215 #define STATE_SERIALISED 2
 216 #define STATE_TRUSTED    4
 217 #define STATE_FLOATING   8
 218 
 219 /* -- private -- */
 220 /* &lt; private &gt;
 221  * g_variant_lock:
 222  * @value: a #GVariant
 223  *
 224  * Locks @value for performing sensitive operations.
 225  */
 226 static void
 227 g_variant_lock (GVariant *value)
 228 {
 229   g_bit_lock (&amp;value-&gt;state, 0);
 230 }
 231 
 232 /* &lt; private &gt;
 233  * g_variant_unlock:
 234  * @value: a #GVariant
 235  *
 236  * Unlocks @value after performing sensitive operations.
 237  */
 238 static void
 239 g_variant_unlock (GVariant *value)
 240 {
 241   g_bit_unlock (&amp;value-&gt;state, 0);
 242 }
 243 
 244 /* &lt; private &gt;
 245  * g_variant_release_children:
 246  * @value: a #GVariant
 247  *
 248  * Releases the reference held on each child in the &#39;children&#39; array of
 249  * @value and frees the array itself.  @value must be in tree form.
 250  *
 251  * This is done when freeing a tree-form instance or converting it to
 252  * serialised form.
 253  *
 254  * The current thread must hold the lock on @value.
 255  */
 256 static void
 257 g_variant_release_children (GVariant *value)
 258 {
 259   gsize i;
 260 
 261   g_assert (value-&gt;state &amp; STATE_LOCKED);
 262   g_assert (~value-&gt;state &amp; STATE_SERIALISED);
 263 
 264   for (i = 0; i &lt; value-&gt;contents.tree.n_children; i++)
 265     g_variant_unref (value-&gt;contents.tree.children[i]);
 266 
 267   g_free (value-&gt;contents.tree.children);
 268 }
 269 
 270 /* This begins the main body of the recursive serialiser.
 271  *
 272  * There are 3 functions here that work as a team with the serialiser to
 273  * get things done.  g_variant_store() has a trivial role, but as a
 274  * public API function, it has its definition elsewhere.
 275  *
 276  * Note that &quot;serialisation&quot; of an instance does not mean that the
 277  * instance is converted to serialised form -- it means that the
 278  * serialised form of an instance is written to an external buffer.
 279  * g_variant_ensure_serialised() (which is not part of this set of
 280  * functions) is the function that is responsible for converting an
 281  * instance to serialised form.
 282  *
 283  * We are only concerned here with container types since non-container
 284  * instances are always in serialised form.  For these instances,
 285  * storing their serialised form merely involves a memcpy().
 286  *
 287  * Serialisation is a two-step process.  First, the size of the
 288  * serialised data must be calculated so that an appropriately-sized
 289  * buffer can be allocated.  Second, the data is written into the
 290  * buffer.
 291  *
 292  * Determining the size:
 293  *   The process of determining the size is triggered by a call to
 294  *   g_variant_ensure_size() on a container.  This invokes the
 295  *   serialiser code to determine the size.  The serialiser is passed
 296  *   g_variant_fill_gvs() as a callback.
 297  *
 298  *   g_variant_fill_gvs() is called by the serialiser on each child of
 299  *   the container which, in turn, calls g_variant_ensure_size() on
 300  *   itself and fills in the result of its own size calculation.
 301  *
 302  *   The serialiser uses the size information from the children to
 303  *   calculate the size needed for the entire container.
 304  *
 305  * Writing the data:
 306  *   After the buffer has been allocated, g_variant_serialise() is
 307  *   called on the container.  This invokes the serialiser code to write
 308  *   the bytes to the container.  The serialiser is, again, passed
 309  *   g_variant_fill_gvs() as a callback.
 310  *
 311  *   This time, when g_variant_fill_gvs() is called for each child, the
 312  *   child is given a pointer to a sub-region of the allocated buffer
 313  *   where it should write its data.  This is done by calling
 314  *   g_variant_store().  In the event that the instance is in serialised
 315  *   form this means a memcpy() of the serialised data into the
 316  *   allocated buffer.  In the event that the instance is in tree form
 317  *   this means a recursive call back into g_variant_serialise().
 318  *
 319  *
 320  * The forward declaration here allows corecursion via callback:
 321  */
 322 static void g_variant_fill_gvs (GVariantSerialised *, gpointer);
 323 
 324 /* &lt; private &gt;
 325  * g_variant_ensure_size:
 326  * @value: a #GVariant
 327  *
 328  * Ensures that the -&gt;size field of @value is filled in properly.  This
 329  * must be done as a precursor to any serialisation of the value in
 330  * order to know how large of a buffer is needed to store the data.
 331  *
 332  * The current thread must hold the lock on @value.
 333  */
 334 static void
 335 g_variant_ensure_size (GVariant *value)
 336 {
 337   g_assert (value-&gt;state &amp; STATE_LOCKED);
 338 
<a name="4" id="anc4"></a><span class="line-modified"> 339   if (value-&gt;size == (gsize) -1)</span>
 340     {
 341       gpointer *children;
 342       gsize n_children;
 343 
 344       children = (gpointer *) value-&gt;contents.tree.children;
 345       n_children = value-&gt;contents.tree.n_children;
 346       value-&gt;size = g_variant_serialiser_needed_size (value-&gt;type_info,
 347                                                       g_variant_fill_gvs,
 348                                                       children, n_children);
 349     }
 350 }
 351 
 352 /* &lt; private &gt;
 353  * g_variant_serialise:
 354  * @value: a #GVariant
 355  * @data: an appropriately-sized buffer
 356  *
 357  * Serialises @value into @data.  @value must be in tree form.
 358  *
 359  * No change is made to @value.
 360  *
 361  * The current thread must hold the lock on @value.
 362  */
 363 static void
 364 g_variant_serialise (GVariant *value,
 365                      gpointer  data)
 366 {
 367   GVariantSerialised serialised = { 0, };
 368   gpointer *children;
 369   gsize n_children;
 370 
 371   g_assert (~value-&gt;state &amp; STATE_SERIALISED);
 372   g_assert (value-&gt;state &amp; STATE_LOCKED);
 373 
 374   serialised.type_info = value-&gt;type_info;
 375   serialised.size = value-&gt;size;
 376   serialised.data = data;
 377   serialised.depth = value-&gt;depth;
 378 
 379   children = (gpointer *) value-&gt;contents.tree.children;
 380   n_children = value-&gt;contents.tree.n_children;
 381 
 382   g_variant_serialiser_serialise (serialised, g_variant_fill_gvs,
 383                                   children, n_children);
 384 }
 385 
 386 /* &lt; private &gt;
 387  * g_variant_fill_gvs:
 388  * @serialised: a pointer to a #GVariantSerialised
 389  * @data: a #GVariant instance
 390  *
 391  * This is the callback that is passed by a tree-form container instance
 392  * to the serialiser.  This callback gets called on each child of the
 393  * container.  Each child is responsible for performing the following
 394  * actions:
 395  *
 396  *  - reporting its type
 397  *
 398  *  - reporting its serialised size (requires knowing the size first)
 399  *
 400  *  - possibly storing its serialised form into the provided buffer
 401  */
 402 static void
 403 g_variant_fill_gvs (GVariantSerialised *serialised,
 404                     gpointer            data)
 405 {
 406   GVariant *value = data;
 407 
 408   g_variant_lock (value);
 409   g_variant_ensure_size (value);
 410   g_variant_unlock (value);
 411 
 412   if (serialised-&gt;type_info == NULL)
 413     serialised-&gt;type_info = value-&gt;type_info;
 414   g_assert (serialised-&gt;type_info == value-&gt;type_info);
 415 
 416   if (serialised-&gt;size == 0)
 417     serialised-&gt;size = value-&gt;size;
 418   g_assert (serialised-&gt;size == value-&gt;size);
 419   serialised-&gt;depth = value-&gt;depth;
 420 
 421   if (serialised-&gt;data)
 422     /* g_variant_store() is a public API, so it
 423      * it will reacquire the lock if it needs to.
 424      */
 425     g_variant_store (value, serialised-&gt;data);
 426 }
 427 
 428 /* this ends the main body of the recursive serialiser */
 429 
 430 /* &lt; private &gt;
 431  * g_variant_ensure_serialised:
 432  * @value: a #GVariant
 433  *
 434  * Ensures that @value is in serialised form.
 435  *
 436  * If @value is in tree form then this function ensures that the
 437  * serialised size is known and then allocates a buffer of that size and
 438  * serialises the instance into the buffer.  The &#39;children&#39; array is
 439  * then released and the instance is set to serialised form based on the
 440  * contents of the buffer.
 441  *
 442  * The current thread must hold the lock on @value.
 443  */
 444 static void
 445 g_variant_ensure_serialised (GVariant *value)
 446 {
 447   g_assert (value-&gt;state &amp; STATE_LOCKED);
 448 
 449   if (~value-&gt;state &amp; STATE_SERIALISED)
 450     {
 451       GBytes *bytes;
 452       gpointer data;
 453 
 454       g_variant_ensure_size (value);
 455       data = g_malloc (value-&gt;size);
 456       g_variant_serialise (value, data);
 457 
 458       g_variant_release_children (value);
 459 
 460       bytes = g_bytes_new_take (data, value-&gt;size);
 461       value-&gt;contents.serialised.data = g_bytes_get_data (bytes, NULL);
 462       value-&gt;contents.serialised.bytes = bytes;
 463       value-&gt;state |= STATE_SERIALISED;
 464     }
 465 }
 466 
 467 /* &lt; private &gt;
 468  * g_variant_alloc:
 469  * @type: the type of the new instance
 470  * @serialised: if the instance will be in serialised form
 471  * @trusted: if the instance will be trusted
 472  *
 473  * Allocates a #GVariant instance and does some common work (such as
 474  * looking up and filling in the type info), setting the state field,
 475  * and setting the ref_count to 1.
 476  *
 477  * Returns: a new #GVariant with a floating reference
 478  */
 479 static GVariant *
 480 g_variant_alloc (const GVariantType *type,
 481                  gboolean            serialised,
 482                  gboolean            trusted)
 483 {
 484   GVariant *value;
 485 
 486   value = g_slice_new (GVariant);
 487 #ifdef GSTREAMER_LITE
 488   if (value == NULL) {
 489     return NULL;
 490   }
 491 #endif // GSTREAMER_LITE
 492   value-&gt;type_info = g_variant_type_info_get (type);
 493   value-&gt;state = (serialised ? STATE_SERIALISED : 0) |
 494                  (trusted ? STATE_TRUSTED : 0) |
 495                  STATE_FLOATING;
 496   value-&gt;size = (gssize) -1;
<a name="5" id="anc5"></a><span class="line-modified"> 497   g_atomic_ref_count_init (&amp;value-&gt;ref_count);</span>
 498   value-&gt;depth = 0;
 499 
 500   return value;
 501 }
 502 
 503 /**
 504  * g_variant_new_from_bytes:
 505  * @type: a #GVariantType
 506  * @bytes: a #GBytes
 507  * @trusted: if the contents of @bytes are trusted
 508  *
 509  * Constructs a new serialised-mode #GVariant instance.  This is the
 510  * inner interface for creation of new serialised values that gets
 511  * called from various functions in gvariant.c.
 512  *
 513  * A reference is taken on @bytes.
 514  *
<a name="6" id="anc6"></a><span class="line-added"> 515  * The data in @bytes must be aligned appropriately for the @type being loaded.</span>
<span class="line-added"> 516  * Otherwise this function will internally create a copy of the memory (since</span>
<span class="line-added"> 517  * GLib 2.60) or (in older versions) fail and exit the process.</span>
<span class="line-added"> 518  *</span>
 519  * Returns: (transfer none): a new #GVariant with a floating reference
 520  *
 521  * Since: 2.36
 522  */
 523 GVariant *
 524 g_variant_new_from_bytes (const GVariantType *type,
 525                           GBytes             *bytes,
 526                           gboolean            trusted)
 527 {
 528   GVariant *value;
 529   guint alignment;
 530   gsize size;
<a name="7" id="anc7"></a><span class="line-added"> 531   GBytes *owned_bytes = NULL;</span>
<span class="line-added"> 532   GVariantSerialised serialised;</span>
 533 
 534   value = g_variant_alloc (type, TRUE, trusted);
 535 #ifdef GSTREAMER_LITE
 536   if (value == NULL) {
 537     return NULL;
 538   }
 539 #endif // GSTREAMER_LITE
 540 
<a name="8" id="anc8"></a>

 541   g_variant_type_info_query (value-&gt;type_info,
 542                              &amp;alignment, &amp;size);
 543 
<a name="9" id="anc9"></a><span class="line-added"> 544   /* Ensure the alignment is correct. This is a huge performance hit if it&#39;s</span>
<span class="line-added"> 545    * not correct, but that&#39;s better than aborting if a caller provides data</span>
<span class="line-added"> 546    * with the wrong alignment (which is likely to happen very occasionally, and</span>
<span class="line-added"> 547    * only cause an abort on some architectures - so is unlikely to be caught</span>
<span class="line-added"> 548    * in testing). Callers can always actively ensure they use the correct</span>
<span class="line-added"> 549    * alignment to avoid the performance hit. */</span>
<span class="line-added"> 550   serialised.type_info = value-&gt;type_info;</span>
<span class="line-added"> 551   serialised.data = (guchar *) g_bytes_get_data (bytes, &amp;serialised.size);</span>
<span class="line-added"> 552   serialised.depth = 0;</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554   if (!g_variant_serialised_check (serialised))</span>
<span class="line-added"> 555     {</span>
<span class="line-added"> 556 #ifdef HAVE_POSIX_MEMALIGN</span>
<span class="line-added"> 557       gpointer aligned_data = NULL;</span>
<span class="line-added"> 558       gsize aligned_size = g_bytes_get_size (bytes);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560       /* posix_memalign() requires the alignment to be a multiple of</span>
<span class="line-added"> 561        * sizeof(void*), and a power of 2. See g_variant_type_info_query() for</span>
<span class="line-added"> 562        * details on the alignment format. */</span>
<span class="line-added"> 563       if (posix_memalign (&amp;aligned_data, MAX (sizeof (void *), alignment + 1),</span>
<span class="line-added"> 564                           aligned_size) != 0)</span>
<span class="line-added"> 565         g_error (&quot;posix_memalign failed&quot;);</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567       memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size);</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569       bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data,</span>
<span class="line-added"> 570                                                         aligned_size,</span>
<span class="line-added"> 571                                                         free, aligned_data);</span>
<span class="line-added"> 572       aligned_data = NULL;</span>
<span class="line-added"> 573 #else</span>
<span class="line-added"> 574       /* NOTE: there may be platforms that lack posix_memalign() and also</span>
<span class="line-added"> 575        * have malloc() that returns non-8-aligned.  if so, we need to try</span>
<span class="line-added"> 576        * harder here.</span>
<span class="line-added"> 577        */</span>
<span class="line-added"> 578       bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL),</span>
<span class="line-added"> 579                                          g_bytes_get_size (bytes));</span>
<span class="line-added"> 580 #endif</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583   value-&gt;contents.serialised.bytes = g_bytes_ref (bytes);</span>
<span class="line-added"> 584 </span>
 585   if (size &amp;&amp; g_bytes_get_size (bytes) != size)
 586     {
 587       /* Creating a fixed-sized GVariant with a bytes of the wrong
 588        * size.
 589        *
 590        * We should do the equivalent of pulling a fixed-sized child out
 591        * of a brozen container (ie: data is NULL size is equal to the correct
 592        * fixed size).
 593        */
 594       value-&gt;contents.serialised.data = NULL;
 595       value-&gt;size = size;
 596     }
 597   else
 598     {
 599       value-&gt;contents.serialised.data = g_bytes_get_data (bytes, &amp;value-&gt;size);
 600     }
 601 
<a name="10" id="anc10"></a><span class="line-added"> 602   g_clear_pointer (&amp;owned_bytes, g_bytes_unref);</span>
<span class="line-added"> 603 </span>
 604   return value;
 605 }
 606 
 607 /* -- internal -- */
 608 
 609 /* &lt; internal &gt;
 610  * g_variant_new_from_children:
 611  * @type: a #GVariantType
 612  * @children: an array of #GVariant pointers.  Consumed.
 613  * @n_children: the length of @children
 614  * @trusted: %TRUE if every child in @children in trusted
 615  *
 616  * Constructs a new tree-mode #GVariant instance.  This is the inner
 617  * interface for creation of new serialised values that gets called from
 618  * various functions in gvariant.c.
 619  *
 620  * @children is consumed by this function.  g_free() will be called on
 621  * it some time later.
 622  *
 623  * Returns: a new #GVariant with a floating reference
 624  */
 625 GVariant *
 626 g_variant_new_from_children (const GVariantType  *type,
 627                              GVariant           **children,
 628                              gsize                n_children,
 629                              gboolean             trusted)
 630 {
 631   GVariant *value;
 632 
 633   value = g_variant_alloc (type, FALSE, trusted);
 634 #ifdef GSTREAMER_LITE
 635   if (value == NULL) {
 636     return NULL;
 637   }
 638 #endif // GSTREAMER_LITE
 639   value-&gt;contents.tree.children = children;
 640   value-&gt;contents.tree.n_children = n_children;
 641 
 642   return value;
 643 }
 644 
 645 /* &lt; internal &gt;
 646  * g_variant_get_type_info:
 647  * @value: a #GVariant
 648  *
 649  * Returns the #GVariantTypeInfo corresponding to the type of @value.  A
 650  * reference is not added, so the return value is only good for the
 651  * duration of the life of @value.
 652  *
 653  * Returns: the #GVariantTypeInfo for @value
 654  */
 655 GVariantTypeInfo *
 656 g_variant_get_type_info (GVariant *value)
 657 {
 658   return value-&gt;type_info;
 659 }
 660 
 661 /* &lt; internal &gt;
 662  * g_variant_is_trusted:
 663  * @value: a #GVariant
 664  *
 665  * Determines if @value is trusted by #GVariant to contain only
 666  * fully-valid data.  All values constructed solely via #GVariant APIs
 667  * are trusted, but values containing data read in from other sources
 668  * are usually not trusted.
 669  *
 670  * The main advantage of trusted data is that certain checks can be
 671  * skipped.  For example, we don&#39;t need to check that a string is
 672  * properly nul-terminated or that an object path is actually a
 673  * properly-formatted object path.
 674  *
 675  * Returns: if @value is trusted
 676  */
 677 gboolean
 678 g_variant_is_trusted (GVariant *value)
 679 {
 680   return (value-&gt;state &amp; STATE_TRUSTED) != 0;
 681 }
 682 
 683 /* -- public -- */
 684 
 685 /**
 686  * g_variant_unref:
 687  * @value: a #GVariant
 688  *
 689  * Decreases the reference count of @value.  When its reference count
 690  * drops to 0, the memory used by the variant is freed.
 691  *
 692  * Since: 2.24
 693  **/
 694 void
 695 g_variant_unref (GVariant *value)
 696 {
 697   g_return_if_fail (value != NULL);
<a name="11" id="anc11"></a>
 698 
<a name="12" id="anc12"></a><span class="line-modified"> 699   if (g_atomic_ref_count_dec (&amp;value-&gt;ref_count))</span>
 700     {
 701       if G_UNLIKELY (value-&gt;state &amp; STATE_LOCKED)
 702         g_critical (&quot;attempting to free a locked GVariant instance.  &quot;
 703                     &quot;This should never happen.&quot;);
 704 
 705       value-&gt;state |= STATE_LOCKED;
 706 
 707       g_variant_type_info_unref (value-&gt;type_info);
 708 
 709       if (value-&gt;state &amp; STATE_SERIALISED)
 710         g_bytes_unref (value-&gt;contents.serialised.bytes);
 711       else
 712         g_variant_release_children (value);
 713 
 714       memset (value, 0, sizeof (GVariant));
 715       g_slice_free (GVariant, value);
 716     }
 717 }
 718 
 719 /**
 720  * g_variant_ref:
 721  * @value: a #GVariant
 722  *
 723  * Increases the reference count of @value.
 724  *
 725  * Returns: the same @value
 726  *
 727  * Since: 2.24
 728  **/
 729 GVariant *
 730 g_variant_ref (GVariant *value)
 731 {
 732   g_return_val_if_fail (value != NULL, NULL);
<a name="13" id="anc13"></a>
 733 
<a name="14" id="anc14"></a><span class="line-modified"> 734   g_atomic_ref_count_inc (&amp;value-&gt;ref_count);</span>
 735 
 736   return value;
 737 }
 738 
 739 /**
 740  * g_variant_ref_sink:
 741  * @value: a #GVariant
 742  *
 743  * #GVariant uses a floating reference count system.  All functions with
 744  * names starting with `g_variant_new_` return floating
 745  * references.
 746  *
 747  * Calling g_variant_ref_sink() on a #GVariant with a floating reference
 748  * will convert the floating reference into a full reference.  Calling
 749  * g_variant_ref_sink() on a non-floating #GVariant results in an
 750  * additional normal reference being added.
 751  *
 752  * In other words, if the @value is floating, then this call &quot;assumes
 753  * ownership&quot; of the floating reference, converting it to a normal
 754  * reference.  If the @value is not floating, then this call adds a
 755  * new normal reference increasing the reference count by one.
 756  *
 757  * All calls that result in a #GVariant instance being inserted into a
 758  * container will call g_variant_ref_sink() on the instance.  This means
 759  * that if the value was just created (and has only its floating
 760  * reference) then the container will assume sole ownership of the value
 761  * at that point and the caller will not need to unreference it.  This
 762  * makes certain common styles of programming much easier while still
 763  * maintaining normal refcounting semantics in situations where values
 764  * are not floating.
 765  *
 766  * Returns: the same @value
 767  *
 768  * Since: 2.24
 769  **/
 770 GVariant *
 771 g_variant_ref_sink (GVariant *value)
 772 {
 773   g_return_val_if_fail (value != NULL, NULL);
<a name="15" id="anc15"></a><span class="line-modified"> 774   g_return_val_if_fail (!g_atomic_ref_count_compare (&amp;value-&gt;ref_count, 0), NULL);</span>
 775 
 776   g_variant_lock (value);
 777 
 778   if (~value-&gt;state &amp; STATE_FLOATING)
 779     g_variant_ref (value);
 780   else
 781     value-&gt;state &amp;= ~STATE_FLOATING;
 782 
 783   g_variant_unlock (value);
 784 
 785   return value;
 786 }
 787 
 788 /**
 789  * g_variant_take_ref:
 790  * @value: a #GVariant
 791  *
 792  * If @value is floating, sink it.  Otherwise, do nothing.
 793  *
 794  * Typically you want to use g_variant_ref_sink() in order to
 795  * automatically do the correct thing with respect to floating or
 796  * non-floating references, but there is one specific scenario where
 797  * this function is helpful.
 798  *
 799  * The situation where this function is helpful is when creating an API
 800  * that allows the user to provide a callback function that returns a
 801  * #GVariant.  We certainly want to allow the user the flexibility to
 802  * return a non-floating reference from this callback (for the case
 803  * where the value that is being returned already exists).
 804  *
 805  * At the same time, the style of the #GVariant API makes it likely that
 806  * for newly-created #GVariant instances, the user can be saved some
 807  * typing if they are allowed to return a #GVariant with a floating
 808  * reference.
 809  *
 810  * Using this function on the return value of the user&#39;s callback allows
 811  * the user to do whichever is more convenient for them.  The caller
 812  * will alway receives exactly one full reference to the value: either
 813  * the one that was returned in the first place, or a floating reference
 814  * that has been converted to a full reference.
 815  *
 816  * This function has an odd interaction when combined with
 817  * g_variant_ref_sink() running at the same time in another thread on
 818  * the same #GVariant instance.  If g_variant_ref_sink() runs first then
 819  * the result will be that the floating reference is converted to a hard
 820  * reference.  If g_variant_take_ref() runs first then the result will
 821  * be that the floating reference is converted to a hard reference and
 822  * an additional reference on top of that one is added.  It is best to
 823  * avoid this situation.
 824  *
 825  * Returns: the same @value
 826  **/
 827 GVariant *
 828 g_variant_take_ref (GVariant *value)
 829 {
 830   g_return_val_if_fail (value != NULL, NULL);
<a name="16" id="anc16"></a><span class="line-modified"> 831   g_return_val_if_fail (!g_atomic_ref_count_compare (&amp;value-&gt;ref_count, 0), NULL);</span>
 832 
 833   g_atomic_int_and (&amp;value-&gt;state, ~STATE_FLOATING);
 834 
 835   return value;
 836 }
 837 
 838 /**
 839  * g_variant_is_floating:
 840  * @value: a #GVariant
 841  *
 842  * Checks whether @value has a floating reference count.
 843  *
 844  * This function should only ever be used to assert that a given variant
 845  * is or is not floating, or for debug purposes. To acquire a reference
 846  * to a variant that might be floating, always use g_variant_ref_sink()
 847  * or g_variant_take_ref().
 848  *
 849  * See g_variant_ref_sink() for more information about floating reference
 850  * counts.
 851  *
 852  * Returns: whether @value is floating
 853  *
 854  * Since: 2.26
 855  **/
 856 gboolean
 857 g_variant_is_floating (GVariant *value)
 858 {
 859   g_return_val_if_fail (value != NULL, FALSE);
 860 
 861   return (value-&gt;state &amp; STATE_FLOATING) != 0;
 862 }
 863 
 864 /**
 865  * g_variant_get_size:
 866  * @value: a #GVariant instance
 867  *
 868  * Determines the number of bytes that would be required to store @value
 869  * with g_variant_store().
 870  *
 871  * If @value has a fixed-sized type then this function always returned
 872  * that fixed size.
 873  *
 874  * In the case that @value is already in serialised form or the size has
 875  * already been calculated (ie: this function has been called before)
 876  * then this function is O(1).  Otherwise, the size is calculated, an
 877  * operation which is approximately O(n) in the number of values
 878  * involved.
 879  *
 880  * Returns: the serialised size of @value
 881  *
 882  * Since: 2.24
 883  **/
 884 gsize
 885 g_variant_get_size (GVariant *value)
 886 {
 887   g_variant_lock (value);
 888   g_variant_ensure_size (value);
 889   g_variant_unlock (value);
 890 
 891   return value-&gt;size;
 892 }
 893 
 894 /**
 895  * g_variant_get_data:
 896  * @value: a #GVariant instance
 897  *
 898  * Returns a pointer to the serialised form of a #GVariant instance.
 899  * The returned data may not be in fully-normalised form if read from an
 900  * untrusted source.  The returned data must not be freed; it remains
 901  * valid for as long as @value exists.
 902  *
 903  * If @value is a fixed-sized value that was deserialised from a
 904  * corrupted serialised container then %NULL may be returned.  In this
 905  * case, the proper thing to do is typically to use the appropriate
 906  * number of nul bytes in place of @value.  If @value is not fixed-sized
 907  * then %NULL is never returned.
 908  *
 909  * In the case that @value is already in serialised form, this function
 910  * is O(1).  If the value is not already in serialised form,
 911  * serialisation occurs implicitly and is approximately O(n) in the size
 912  * of the result.
 913  *
 914  * To deserialise the data returned by this function, in addition to the
 915  * serialised data, you must know the type of the #GVariant, and (if the
 916  * machine might be different) the endianness of the machine that stored
 917  * it. As a result, file formats or network messages that incorporate
 918  * serialised #GVariants must include this information either
 919  * implicitly (for instance &quot;the file always contains a
 920  * %G_VARIANT_TYPE_VARIANT and it is always in little-endian order&quot;) or
 921  * explicitly (by storing the type and/or endianness in addition to the
 922  * serialised data).
 923  *
 924  * Returns: (transfer none): the serialised form of @value, or %NULL
 925  *
 926  * Since: 2.24
 927  **/
 928 gconstpointer
 929 g_variant_get_data (GVariant *value)
 930 {
 931   g_variant_lock (value);
 932   g_variant_ensure_serialised (value);
 933   g_variant_unlock (value);
 934 
 935   return value-&gt;contents.serialised.data;
 936 }
 937 
 938 /**
 939  * g_variant_get_data_as_bytes:
 940  * @value: a #GVariant
 941  *
 942  * Returns a pointer to the serialised form of a #GVariant instance.
 943  * The semantics of this function are exactly the same as
 944  * g_variant_get_data(), except that the returned #GBytes holds
 945  * a reference to the variant data.
 946  *
 947  * Returns: (transfer full): A new #GBytes representing the variant data
 948  *
 949  * Since: 2.36
 950  */
 951 GBytes *
 952 g_variant_get_data_as_bytes (GVariant *value)
 953 {
 954   const gchar *bytes_data;
 955   const gchar *data;
 956   gsize bytes_size;
 957   gsize size;
 958 
 959   g_variant_lock (value);
 960   g_variant_ensure_serialised (value);
 961   g_variant_unlock (value);
 962 
 963   bytes_data = g_bytes_get_data (value-&gt;contents.serialised.bytes, &amp;bytes_size);
 964   data = value-&gt;contents.serialised.data;
 965   size = value-&gt;size;
 966 
<a name="17" id="anc17"></a><span class="line-added"> 967   if (data == NULL)</span>
<span class="line-added"> 968     {</span>
<span class="line-added"> 969       g_assert (size == 0);</span>
<span class="line-added"> 970       data = bytes_data;</span>
<span class="line-added"> 971     }</span>
<span class="line-added"> 972 </span>
 973   if (data == bytes_data &amp;&amp; size == bytes_size)
 974     return g_bytes_ref (value-&gt;contents.serialised.bytes);
 975   else
 976     return g_bytes_new_from_bytes (value-&gt;contents.serialised.bytes,
 977                                    data - bytes_data, size);
 978 }
 979 
 980 
 981 /**
 982  * g_variant_n_children:
 983  * @value: a container #GVariant
 984  *
 985  * Determines the number of children in a container #GVariant instance.
 986  * This includes variants, maybes, arrays, tuples and dictionary
 987  * entries.  It is an error to call this function on any other type of
 988  * #GVariant.
 989  *
 990  * For variants, the return value is always 1.  For values with maybe
 991  * types, it is always zero or one.  For arrays, it is the length of the
 992  * array.  For tuples it is the number of tuple items (which depends
 993  * only on the type).  For dictionary entries, it is always 2
 994  *
 995  * This function is O(1).
 996  *
 997  * Returns: the number of children in the container
 998  *
 999  * Since: 2.24
1000  **/
1001 gsize
1002 g_variant_n_children (GVariant *value)
1003 {
1004   gsize n_children;
1005 
1006 #ifdef GSTREAMER_LITE
1007   if (value == NULL) {
1008     return 0;
1009   }
1010 #endif // GSTREAMER_LITE
1011 
1012   g_variant_lock (value);
1013 
1014   if (value-&gt;state &amp; STATE_SERIALISED)
1015     {
1016       GVariantSerialised serialised = {
1017         value-&gt;type_info,
1018         (gpointer) value-&gt;contents.serialised.data,
1019         value-&gt;size,
1020         value-&gt;depth,
1021       };
1022 
1023       n_children = g_variant_serialised_n_children (serialised);
1024     }
1025   else
1026     n_children = value-&gt;contents.tree.n_children;
1027 
1028   g_variant_unlock (value);
1029 
1030   return n_children;
1031 }
1032 
1033 /**
1034  * g_variant_get_child_value:
1035  * @value: a container #GVariant
1036  * @index_: the index of the child to fetch
1037  *
1038  * Reads a child item out of a container #GVariant instance.  This
1039  * includes variants, maybes, arrays, tuples and dictionary
1040  * entries.  It is an error to call this function on any other type of
1041  * #GVariant.
1042  *
1043  * It is an error if @index_ is greater than the number of child items
1044  * in the container.  See g_variant_n_children().
1045  *
1046  * The returned value is never floating.  You should free it with
1047  * g_variant_unref() when you&#39;re done with it.
1048  *
1049  * There may be implementation specific restrictions on deeply nested values,
1050  * which would result in the unit tuple being returned as the child value,
1051  * instead of further nested children. #GVariant is guaranteed to handle
1052  * nesting up to at least 64 levels.
1053  *
1054  * This function is O(1).
1055  *
1056  * Returns: (transfer full): the child at the specified index
1057  *
1058  * Since: 2.24
1059  **/
1060 GVariant *
1061 g_variant_get_child_value (GVariant *value,
1062                            gsize     index_)
1063 {
1064   g_return_val_if_fail (index_ &lt; g_variant_n_children (value), NULL);
1065   g_return_val_if_fail (value-&gt;depth &lt; G_MAXSIZE, NULL);
1066 
1067   if (~g_atomic_int_get (&amp;value-&gt;state) &amp; STATE_SERIALISED)
1068     {
1069       g_variant_lock (value);
1070 
1071       if (~value-&gt;state &amp; STATE_SERIALISED)
1072         {
1073           GVariant *child;
1074 
1075           child = g_variant_ref (value-&gt;contents.tree.children[index_]);
1076           g_variant_unlock (value);
1077 
1078           return child;
1079         }
1080 
1081       g_variant_unlock (value);
1082     }
1083 
1084   {
1085     GVariantSerialised serialised = {
1086       value-&gt;type_info,
1087       (gpointer) value-&gt;contents.serialised.data,
1088       value-&gt;size,
1089       value-&gt;depth,
1090     };
1091     GVariantSerialised s_child;
1092     GVariant *child;
1093 
1094     /* get the serialiser to extract the serialised data for the child
1095      * from the serialised data for the container
1096      */
1097     s_child = g_variant_serialised_get_child (serialised, index_);
1098 
1099     /* Check whether this would cause nesting too deep. If so, return a fake
1100      * child. The only situation we expect this to happen in is with a variant,
1101      * as all other deeply-nested types have a static type, and hence should
1102      * have been rejected earlier. In the case of a variant whose nesting plus
1103      * the depth of its child is too great, return a unit variant () instead of
1104      * the real child. */
1105     if (!(value-&gt;state &amp; STATE_TRUSTED) &amp;&amp;
1106         g_variant_type_info_query_depth (s_child.type_info) &gt;=
1107         G_VARIANT_MAX_RECURSION_DEPTH - value-&gt;depth)
1108       {
1109         g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));
1110         return g_variant_new_tuple (NULL, 0);
1111       }
1112 
1113     /* create a new serialised instance out of it */
1114     child = g_slice_new (GVariant);
1115 #ifdef GSTREAMER_LITE
1116     if (child == NULL) {
1117       return NULL;
1118     }
1119 #endif // GSTREAMER_LITE
1120     child-&gt;type_info = s_child.type_info;
1121     child-&gt;state = (value-&gt;state &amp; STATE_TRUSTED) |
1122                    STATE_SERIALISED;
1123     child-&gt;size = s_child.size;
<a name="18" id="anc18"></a><span class="line-modified">1124     g_atomic_ref_count_init (&amp;child-&gt;ref_count);</span>
1125     child-&gt;depth = value-&gt;depth + 1;
1126     child-&gt;contents.serialised.bytes =
1127       g_bytes_ref (value-&gt;contents.serialised.bytes);
1128     child-&gt;contents.serialised.data = s_child.data;
1129 
1130     return child;
1131   }
1132 }
1133 
1134 /**
1135  * g_variant_store:
1136  * @value: the #GVariant to store
1137  * @data: (not nullable): the location to store the serialised data at
1138  *
1139  * Stores the serialised form of @value at @data.  @data should be
1140  * large enough.  See g_variant_get_size().
1141  *
1142  * The stored data is in machine native byte order but may not be in
1143  * fully-normalised form if read from an untrusted source.  See
1144  * g_variant_get_normal_form() for a solution.
1145  *
1146  * As with g_variant_get_data(), to be able to deserialise the
1147  * serialised variant successfully, its type and (if the destination
1148  * machine might be different) its endianness must also be available.
1149  *
1150  * This function is approximately O(n) in the size of @data.
1151  *
1152  * Since: 2.24
1153  **/
1154 void
1155 g_variant_store (GVariant *value,
1156                  gpointer  data)
1157 {
1158   g_variant_lock (value);
1159 
1160   if (value-&gt;state &amp; STATE_SERIALISED)
1161     {
1162       if (value-&gt;contents.serialised.data != NULL)
1163         memcpy (data, value-&gt;contents.serialised.data, value-&gt;size);
1164       else
1165         memset (data, 0, value-&gt;size);
1166     }
1167   else
1168     g_variant_serialise (value, data);
1169 
1170   g_variant_unlock (value);
1171 }
1172 
1173 /**
1174  * g_variant_is_normal_form:
1175  * @value: a #GVariant instance
1176  *
1177  * Checks if @value is in normal form.
1178  *
1179  * The main reason to do this is to detect if a given chunk of
1180  * serialised data is in normal form: load the data into a #GVariant
1181  * using g_variant_new_from_data() and then use this function to
1182  * check.
1183  *
1184  * If @value is found to be in normal form then it will be marked as
1185  * being trusted.  If the value was already marked as being trusted then
1186  * this function will immediately return %TRUE.
1187  *
1188  * There may be implementation specific restrictions on deeply nested values.
1189  * GVariant is guaranteed to handle nesting up to at least 64 levels.
1190  *
1191  * Returns: %TRUE if @value is in normal form
1192  *
1193  * Since: 2.24
1194  **/
1195 gboolean
1196 g_variant_is_normal_form (GVariant *value)
1197 {
1198   if (value-&gt;state &amp; STATE_TRUSTED)
1199     return TRUE;
1200 
1201   g_variant_lock (value);
1202 
1203   if (value-&gt;depth &gt;= G_VARIANT_MAX_RECURSION_DEPTH)
1204     return FALSE;
1205 
1206   if (value-&gt;state &amp; STATE_SERIALISED)
1207     {
1208       GVariantSerialised serialised = {
1209         value-&gt;type_info,
1210         (gpointer) value-&gt;contents.serialised.data,
1211         value-&gt;size,
1212         value-&gt;depth
1213       };
1214 
1215       if (g_variant_serialised_is_normal (serialised))
1216         value-&gt;state |= STATE_TRUSTED;
1217     }
1218   else
1219     {
1220       gboolean normal = TRUE;
1221       gsize i;
1222 
1223       for (i = 0; i &lt; value-&gt;contents.tree.n_children; i++)
1224         normal &amp;= g_variant_is_normal_form (value-&gt;contents.tree.children[i]);
1225 
1226       if (normal)
1227         value-&gt;state |= STATE_TRUSTED;
1228     }
1229 
1230   g_variant_unlock (value);
1231 
1232   return (value-&gt;state &amp; STATE_TRUSTED) != 0;
1233 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>