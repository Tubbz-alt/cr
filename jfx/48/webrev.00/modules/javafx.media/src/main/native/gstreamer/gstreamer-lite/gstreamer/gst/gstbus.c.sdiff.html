<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbus.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbufferpool.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstcaps.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbus.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 112 struct _GstBusPrivate
 113 {
 114   GstAtomicQueue *queue;
 115   GMutex queue_lock;
 116 
 117   GstBusSyncHandler sync_handler;
 118   gpointer sync_handler_data;
 119   GDestroyNotify sync_handler_notify;
 120 
 121   guint num_signal_watchers;
 122 
 123   guint num_sync_message_emitters;
 124   GSource *signal_watch;
 125 
 126   gboolean enable_async;
 127   GstPoll *poll;
 128   GPollFD pollfd;
 129 };
 130 
 131 #define gst_bus_parent_class parent_class
<span class="line-modified"> 132 G_DEFINE_TYPE (GstBus, gst_bus, GST_TYPE_OBJECT);</span>
 133 
 134 static void
 135 gst_bus_set_property (GObject * object,
 136     guint prop_id, const GValue * value, GParamSpec * pspec)
 137 {
 138   GstBus *bus = GST_BUS_CAST (object);
 139 
 140   switch (prop_id) {
 141     case PROP_ENABLE_ASYNC:
 142       bus-&gt;priv-&gt;enable_async = g_value_get_boolean (value);
 143       break;
 144     default:
 145       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 146       break;
 147   }
 148 }
 149 
 150 static void
 151 gst_bus_constructed (GObject * object)
 152 {
</pre>
<hr />
<pre>
 200   gst_bus_signals[SYNC_MESSAGE] =
 201       g_signal_new (&quot;sync-message&quot;, G_TYPE_FROM_CLASS (klass),
 202       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 203       G_STRUCT_OFFSET (GstBusClass, sync_message), NULL, NULL,
 204       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);
 205 
 206   /**
 207    * GstBus::message:
 208    * @bus: the object which received the signal
 209    * @message: the message that has been posted asynchronously
 210    *
 211    * A message has been posted on the bus. This signal is emitted from a
 212    * GSource added to the mainloop. this signal will only be emitted when
 213    * there is a mainloop running.
 214    */
 215   gst_bus_signals[ASYNC_MESSAGE] =
 216       g_signal_new (&quot;message&quot;, G_TYPE_FROM_CLASS (klass),
 217       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 218       G_STRUCT_OFFSET (GstBusClass, message), NULL, NULL,
 219       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);
<span class="line-removed"> 220 </span>
<span class="line-removed"> 221   g_type_class_add_private (klass, sizeof (GstBusPrivate));</span>
 222 }
 223 
 224 static void
 225 gst_bus_init (GstBus * bus)
 226 {
<span class="line-modified"> 227   bus-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (bus, GST_TYPE_BUS, GstBusPrivate);</span>
 228   bus-&gt;priv-&gt;enable_async = DEFAULT_ENABLE_ASYNC;
 229   g_mutex_init (&amp;bus-&gt;priv-&gt;queue_lock);
 230   bus-&gt;priv-&gt;queue = gst_atomic_queue_new (32);
 231 
 232   GST_DEBUG_OBJECT (bus, &quot;created&quot;);
 233 }
 234 
 235 static void
 236 gst_bus_dispose (GObject * object)
 237 {
 238   GstBus *bus = GST_BUS (object);
 239 
 240   if (bus-&gt;priv-&gt;queue) {
 241     GstMessage *message;
 242 
 243     g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 244     do {
 245       message = gst_atomic_queue_pop (bus-&gt;priv-&gt;queue);
 246       if (message)
 247         gst_message_unref (message);
</pre>
<hr />
<pre>
 747     GST_OBJECT_LOCK (bus);
 748   }
 749   bus-&gt;priv-&gt;sync_handler = func;
 750   bus-&gt;priv-&gt;sync_handler_data = user_data;
 751   bus-&gt;priv-&gt;sync_handler_notify = notify;
 752   GST_OBJECT_UNLOCK (bus);
 753 
 754   return;
 755 
 756 no_replace:
 757   {
 758     GST_OBJECT_UNLOCK (bus);
 759     g_warning (&quot;cannot replace existing sync handler&quot;);
 760     return;
 761   }
 762 }
 763 
 764 /**
 765  * gst_bus_get_pollfd:
 766  * @bus: A #GstBus
<span class="line-modified"> 767  * @fd: A GPollFD to fill</span>
 768  *
 769  * Gets the file descriptor from the bus which can be used to get notified about
 770  * messages being available with functions like g_poll(), and allows integration
 771  * into other event loops based on file descriptors.
 772  * Whenever a message is available, the POLLIN / %G_IO_IN event is set.
 773  *
 774  * Warning: NEVER read or write anything to the returned fd but only use it
 775  * for getting notifications via g_poll() or similar and then use the normal
 776  * GstBus API, e.g. gst_bus_pop().
 777  *
 778  * Since: 1.14
 779  */
 780 void
 781 gst_bus_get_pollfd (GstBus * bus, GPollFD * fd)
 782 {
 783   g_return_if_fail (GST_IS_BUS (bus));
 784   g_return_if_fail (bus-&gt;priv-&gt;poll != NULL);
 785 
 786   *fd = bus-&gt;priv-&gt;pollfd;
 787 }
</pre>
<hr />
<pre>
1029 gst_bus_add_watch (GstBus * bus, GstBusFunc func, gpointer user_data)
1030 {
1031   return gst_bus_add_watch_full (bus, G_PRIORITY_DEFAULT, func,
1032       user_data, NULL);
1033 }
1034 
1035 /**
1036  * gst_bus_remove_watch:
1037  * @bus: a #GstBus to remove the watch from.
1038  *
1039  * Removes an installed bus watch from @bus.
1040  *
1041  * Returns: %TRUE on success or %FALSE if @bus has no event source.
1042  *
1043  * Since: 1.6
1044  *
1045  */
1046 gboolean
1047 gst_bus_remove_watch (GstBus * bus)
1048 {
<span class="line-modified">1049   GSource *watch_id;</span>
1050 
1051   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
1052 
1053   GST_OBJECT_LOCK (bus);
1054 
1055   if (bus-&gt;priv-&gt;signal_watch == NULL) {
1056     GST_ERROR_OBJECT (bus, &quot;no bus watch was present&quot;);
<span class="line-modified">1057     goto no_watch;</span>
1058   }
1059 
<span class="line-modified">1060   watch_id = bus-&gt;priv-&gt;signal_watch;</span>







1061 
1062   GST_OBJECT_UNLOCK (bus);
1063 
<span class="line-modified">1064   g_source_destroy (watch_id);</span>



1065 
1066   return TRUE;
1067 
<span class="line-modified">1068 no_watch:</span>
1069   GST_OBJECT_UNLOCK (bus);
1070 
1071   return FALSE;
1072 }
1073 
1074 typedef struct
1075 {
1076   GMainLoop *loop;
1077   guint timeout_id;
1078   gboolean source_running;
1079   GstMessageType events;
1080   GstMessage *message;
1081 } GstBusPollData;
1082 
1083 static void
1084 poll_func (GstBus * bus, GstMessage * message, GstBusPollData * poll_data)
1085 {
1086   GstMessageType type;
1087 
1088   if (!g_main_loop_is_running (poll_data-&gt;loop)) {
</pre>
<hr />
<pre>
1362  *
1363  * There can only be a single bus watch per bus, you must remove any signal
1364  * watch before you can set another type of watch.
1365  *
1366  * MT safe.
1367  */
1368 void
1369 gst_bus_add_signal_watch_full (GstBus * bus, gint priority)
1370 {
1371   g_return_if_fail (GST_IS_BUS (bus));
1372 
1373   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1374   GST_OBJECT_LOCK (bus);
1375 
1376   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1377     goto done;
1378 
1379   /* this should not fail because the counter above takes care of it */
1380   g_assert (!bus-&gt;priv-&gt;signal_watch);
1381 
<span class="line-modified">1382       gst_bus_add_watch_full_unlocked (bus, priority, gst_bus_async_signal_func,</span>
1383       NULL, NULL);
1384 
1385   if (G_UNLIKELY (!bus-&gt;priv-&gt;signal_watch))
1386     goto add_failed;
1387 
1388 done:
1389 
1390   bus-&gt;priv-&gt;num_signal_watchers++;
1391 
1392   GST_OBJECT_UNLOCK (bus);
1393   return;
1394 
1395   /* ERRORS */
1396 add_failed:
1397   {
1398     g_critical (&quot;Could not add signal watch to bus %s&quot;, GST_OBJECT_NAME (bus));
1399     GST_OBJECT_UNLOCK (bus);
1400     return;
1401   }
1402 }
</pre>
<hr />
<pre>
1438 gst_bus_remove_signal_watch (GstBus * bus)
1439 {
1440   GSource *source = NULL;
1441 
1442   g_return_if_fail (GST_IS_BUS (bus));
1443 
1444   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1445   GST_OBJECT_LOCK (bus);
1446 
1447   if (bus-&gt;priv-&gt;num_signal_watchers == 0)
1448     goto error;
1449 
1450   bus-&gt;priv-&gt;num_signal_watchers--;
1451 
1452   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1453     goto done;
1454 
1455   GST_DEBUG_OBJECT (bus, &quot;removing signal watch %u&quot;,
1456       g_source_get_id (bus-&gt;priv-&gt;signal_watch));
1457 
<span class="line-modified">1458   source = bus-&gt;priv-&gt;signal_watch;</span>

1459 
1460 done:
1461   GST_OBJECT_UNLOCK (bus);
1462 
<span class="line-modified">1463   if (source)</span>
1464     g_source_destroy (source);


1465 
1466   return;
1467 
1468   /* ERRORS */
1469 error:
1470   {
1471     g_critical (&quot;Bus %s has no signal watches attached&quot;, GST_OBJECT_NAME (bus));
1472     GST_OBJECT_UNLOCK (bus);
1473     return;
1474   }
1475 }
</pre>
</td>
<td>
<hr />
<pre>
 112 struct _GstBusPrivate
 113 {
 114   GstAtomicQueue *queue;
 115   GMutex queue_lock;
 116 
 117   GstBusSyncHandler sync_handler;
 118   gpointer sync_handler_data;
 119   GDestroyNotify sync_handler_notify;
 120 
 121   guint num_signal_watchers;
 122 
 123   guint num_sync_message_emitters;
 124   GSource *signal_watch;
 125 
 126   gboolean enable_async;
 127   GstPoll *poll;
 128   GPollFD pollfd;
 129 };
 130 
 131 #define gst_bus_parent_class parent_class
<span class="line-modified"> 132 G_DEFINE_TYPE_WITH_PRIVATE (GstBus, gst_bus, GST_TYPE_OBJECT);</span>
 133 
 134 static void
 135 gst_bus_set_property (GObject * object,
 136     guint prop_id, const GValue * value, GParamSpec * pspec)
 137 {
 138   GstBus *bus = GST_BUS_CAST (object);
 139 
 140   switch (prop_id) {
 141     case PROP_ENABLE_ASYNC:
 142       bus-&gt;priv-&gt;enable_async = g_value_get_boolean (value);
 143       break;
 144     default:
 145       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 146       break;
 147   }
 148 }
 149 
 150 static void
 151 gst_bus_constructed (GObject * object)
 152 {
</pre>
<hr />
<pre>
 200   gst_bus_signals[SYNC_MESSAGE] =
 201       g_signal_new (&quot;sync-message&quot;, G_TYPE_FROM_CLASS (klass),
 202       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 203       G_STRUCT_OFFSET (GstBusClass, sync_message), NULL, NULL,
 204       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);
 205 
 206   /**
 207    * GstBus::message:
 208    * @bus: the object which received the signal
 209    * @message: the message that has been posted asynchronously
 210    *
 211    * A message has been posted on the bus. This signal is emitted from a
 212    * GSource added to the mainloop. this signal will only be emitted when
 213    * there is a mainloop running.
 214    */
 215   gst_bus_signals[ASYNC_MESSAGE] =
 216       g_signal_new (&quot;message&quot;, G_TYPE_FROM_CLASS (klass),
 217       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 218       G_STRUCT_OFFSET (GstBusClass, message), NULL, NULL,
 219       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);


 220 }
 221 
 222 static void
 223 gst_bus_init (GstBus * bus)
 224 {
<span class="line-modified"> 225   bus-&gt;priv = gst_bus_get_instance_private (bus);</span>
 226   bus-&gt;priv-&gt;enable_async = DEFAULT_ENABLE_ASYNC;
 227   g_mutex_init (&amp;bus-&gt;priv-&gt;queue_lock);
 228   bus-&gt;priv-&gt;queue = gst_atomic_queue_new (32);
 229 
 230   GST_DEBUG_OBJECT (bus, &quot;created&quot;);
 231 }
 232 
 233 static void
 234 gst_bus_dispose (GObject * object)
 235 {
 236   GstBus *bus = GST_BUS (object);
 237 
 238   if (bus-&gt;priv-&gt;queue) {
 239     GstMessage *message;
 240 
 241     g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 242     do {
 243       message = gst_atomic_queue_pop (bus-&gt;priv-&gt;queue);
 244       if (message)
 245         gst_message_unref (message);
</pre>
<hr />
<pre>
 745     GST_OBJECT_LOCK (bus);
 746   }
 747   bus-&gt;priv-&gt;sync_handler = func;
 748   bus-&gt;priv-&gt;sync_handler_data = user_data;
 749   bus-&gt;priv-&gt;sync_handler_notify = notify;
 750   GST_OBJECT_UNLOCK (bus);
 751 
 752   return;
 753 
 754 no_replace:
 755   {
 756     GST_OBJECT_UNLOCK (bus);
 757     g_warning (&quot;cannot replace existing sync handler&quot;);
 758     return;
 759   }
 760 }
 761 
 762 /**
 763  * gst_bus_get_pollfd:
 764  * @bus: A #GstBus
<span class="line-modified"> 765  * @fd: (out): A GPollFD to fill</span>
 766  *
 767  * Gets the file descriptor from the bus which can be used to get notified about
 768  * messages being available with functions like g_poll(), and allows integration
 769  * into other event loops based on file descriptors.
 770  * Whenever a message is available, the POLLIN / %G_IO_IN event is set.
 771  *
 772  * Warning: NEVER read or write anything to the returned fd but only use it
 773  * for getting notifications via g_poll() or similar and then use the normal
 774  * GstBus API, e.g. gst_bus_pop().
 775  *
 776  * Since: 1.14
 777  */
 778 void
 779 gst_bus_get_pollfd (GstBus * bus, GPollFD * fd)
 780 {
 781   g_return_if_fail (GST_IS_BUS (bus));
 782   g_return_if_fail (bus-&gt;priv-&gt;poll != NULL);
 783 
 784   *fd = bus-&gt;priv-&gt;pollfd;
 785 }
</pre>
<hr />
<pre>
1027 gst_bus_add_watch (GstBus * bus, GstBusFunc func, gpointer user_data)
1028 {
1029   return gst_bus_add_watch_full (bus, G_PRIORITY_DEFAULT, func,
1030       user_data, NULL);
1031 }
1032 
1033 /**
1034  * gst_bus_remove_watch:
1035  * @bus: a #GstBus to remove the watch from.
1036  *
1037  * Removes an installed bus watch from @bus.
1038  *
1039  * Returns: %TRUE on success or %FALSE if @bus has no event source.
1040  *
1041  * Since: 1.6
1042  *
1043  */
1044 gboolean
1045 gst_bus_remove_watch (GstBus * bus)
1046 {
<span class="line-modified">1047   GSource *source;</span>
1048 
1049   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
1050 
1051   GST_OBJECT_LOCK (bus);
1052 
1053   if (bus-&gt;priv-&gt;signal_watch == NULL) {
1054     GST_ERROR_OBJECT (bus, &quot;no bus watch was present&quot;);
<span class="line-modified">1055     goto error;</span>
1056   }
1057 
<span class="line-modified">1058   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0) {</span>
<span class="line-added">1059     GST_ERROR_OBJECT (bus,</span>
<span class="line-added">1060         &quot;trying to remove signal watch with gst_bus_remove_watch()&quot;);</span>
<span class="line-added">1061     goto error;</span>
<span class="line-added">1062   }</span>
<span class="line-added">1063 </span>
<span class="line-added">1064   source =</span>
<span class="line-added">1065       bus-&gt;priv-&gt;signal_watch ? g_source_ref (bus-&gt;priv-&gt;signal_watch) : NULL;</span>
1066 
1067   GST_OBJECT_UNLOCK (bus);
1068 
<span class="line-modified">1069   if (source) {</span>
<span class="line-added">1070     g_source_destroy (source);</span>
<span class="line-added">1071     g_source_unref (source);</span>
<span class="line-added">1072   }</span>
1073 
1074   return TRUE;
1075 
<span class="line-modified">1076 error:</span>
1077   GST_OBJECT_UNLOCK (bus);
1078 
1079   return FALSE;
1080 }
1081 
1082 typedef struct
1083 {
1084   GMainLoop *loop;
1085   guint timeout_id;
1086   gboolean source_running;
1087   GstMessageType events;
1088   GstMessage *message;
1089 } GstBusPollData;
1090 
1091 static void
1092 poll_func (GstBus * bus, GstMessage * message, GstBusPollData * poll_data)
1093 {
1094   GstMessageType type;
1095 
1096   if (!g_main_loop_is_running (poll_data-&gt;loop)) {
</pre>
<hr />
<pre>
1370  *
1371  * There can only be a single bus watch per bus, you must remove any signal
1372  * watch before you can set another type of watch.
1373  *
1374  * MT safe.
1375  */
1376 void
1377 gst_bus_add_signal_watch_full (GstBus * bus, gint priority)
1378 {
1379   g_return_if_fail (GST_IS_BUS (bus));
1380 
1381   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1382   GST_OBJECT_LOCK (bus);
1383 
1384   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1385     goto done;
1386 
1387   /* this should not fail because the counter above takes care of it */
1388   g_assert (!bus-&gt;priv-&gt;signal_watch);
1389 
<span class="line-modified">1390   gst_bus_add_watch_full_unlocked (bus, priority, gst_bus_async_signal_func,</span>
1391       NULL, NULL);
1392 
1393   if (G_UNLIKELY (!bus-&gt;priv-&gt;signal_watch))
1394     goto add_failed;
1395 
1396 done:
1397 
1398   bus-&gt;priv-&gt;num_signal_watchers++;
1399 
1400   GST_OBJECT_UNLOCK (bus);
1401   return;
1402 
1403   /* ERRORS */
1404 add_failed:
1405   {
1406     g_critical (&quot;Could not add signal watch to bus %s&quot;, GST_OBJECT_NAME (bus));
1407     GST_OBJECT_UNLOCK (bus);
1408     return;
1409   }
1410 }
</pre>
<hr />
<pre>
1446 gst_bus_remove_signal_watch (GstBus * bus)
1447 {
1448   GSource *source = NULL;
1449 
1450   g_return_if_fail (GST_IS_BUS (bus));
1451 
1452   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1453   GST_OBJECT_LOCK (bus);
1454 
1455   if (bus-&gt;priv-&gt;num_signal_watchers == 0)
1456     goto error;
1457 
1458   bus-&gt;priv-&gt;num_signal_watchers--;
1459 
1460   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1461     goto done;
1462 
1463   GST_DEBUG_OBJECT (bus, &quot;removing signal watch %u&quot;,
1464       g_source_get_id (bus-&gt;priv-&gt;signal_watch));
1465 
<span class="line-modified">1466   source =</span>
<span class="line-added">1467       bus-&gt;priv-&gt;signal_watch ? g_source_ref (bus-&gt;priv-&gt;signal_watch) : NULL;</span>
1468 
1469 done:
1470   GST_OBJECT_UNLOCK (bus);
1471 
<span class="line-modified">1472   if (source) {</span>
1473     g_source_destroy (source);
<span class="line-added">1474     g_source_unref (source);</span>
<span class="line-added">1475   }</span>
1476 
1477   return;
1478 
1479   /* ERRORS */
1480 error:
1481   {
1482     g_critical (&quot;Bus %s has no signal watches attached&quot;, GST_OBJECT_NAME (bus));
1483     GST_OBJECT_UNLOCK (bus);
1484     return;
1485   }
1486 }
</pre>
</td>
</tr>
</table>
<center><a href="gstbufferpool.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstcaps.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>