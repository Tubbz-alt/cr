<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstdataqueue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstcollectpads.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstdataqueue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstdataqueue.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gstdataqueue
 24  * @title: GstDataQueue
 25  * @short_description: Threadsafe queueing object
 26  *
 27  * #GstDataQueue is an object that handles threadsafe queueing of objects. It
 28  * also provides size-related functionality. This object should be used for
 29  * any #GstElement that wishes to provide some sort of queueing functionality.
 30  */



 31 
 32 #include &lt;gst/gst.h&gt;
 33 #include &quot;string.h&quot;
 34 #include &quot;gstdataqueue.h&quot;
 35 #include &quot;gstqueuearray.h&quot;
 36 #include &quot;gst/glib-compat-private.h&quot;
 37 
 38 GST_DEBUG_CATEGORY_STATIC (data_queue_debug);
 39 #define GST_CAT_DEFAULT (data_queue_debug)
 40 GST_DEBUG_CATEGORY_STATIC (data_queue_dataflow);
 41 
 42 
 43 /* Queue signals and args */
 44 enum
 45 {
 46   SIGNAL_EMPTY,
 47   SIGNAL_FULL,
 48   LAST_SIGNAL
 49 };
 50 
</pre>
<hr />
<pre>
112                gst_queue_array_get_length (q-&gt;priv-&gt;queue))
113 
114 static void gst_data_queue_finalize (GObject * object);
115 
116 static void gst_data_queue_set_property (GObject * object,
117     guint prop_id, const GValue * value, GParamSpec * pspec);
118 static void gst_data_queue_get_property (GObject * object,
119     guint prop_id, GValue * value, GParamSpec * pspec);
120 
121 static guint gst_data_queue_signals[LAST_SIGNAL] = { 0 };
122 
123 #define _do_init \
124 { \
125   GST_DEBUG_CATEGORY_INIT (data_queue_debug, &quot;dataqueue&quot;, 0, \
126       &quot;data queue object&quot;); \
127   GST_DEBUG_CATEGORY_INIT (data_queue_dataflow, &quot;data_queue_dataflow&quot;, 0, \
128       &quot;dataflow inside the data queue object&quot;); \
129 }
130 
131 #define parent_class gst_data_queue_parent_class
<span class="line-modified">132 G_DEFINE_TYPE_WITH_CODE (GstDataQueue, gst_data_queue, G_TYPE_OBJECT, _do_init);</span>

133 
134 static void
135 gst_data_queue_class_init (GstDataQueueClass * klass)
136 {
137   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
138 
<span class="line-removed">139   g_type_class_add_private (klass, sizeof (GstDataQueuePrivate));</span>
<span class="line-removed">140 </span>
141   gobject_class-&gt;set_property = gst_data_queue_set_property;
142   gobject_class-&gt;get_property = gst_data_queue_get_property;
143 
144   /* signals */
145   /**
146    * GstDataQueue::empty: (skip)
147    * @queue: the queue instance
148    *
149    * Reports that the queue became empty (empty).
150    * A queue is empty if the total amount of visible items inside it (num-visible, time,
151    * size) is lower than the boundary values which can be set through the GObject
152    * properties.
153    */
154   gst_data_queue_signals[SIGNAL_EMPTY] =
155       g_signal_new (&quot;empty&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
156       G_STRUCT_OFFSET (GstDataQueueClass, empty), NULL, NULL,
157       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
158 
159   /**
160    * GstDataQueue::full: (skip)
</pre>
<hr />
<pre>
174   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BYTES,
175       g_param_spec_uint (&quot;current-level-bytes&quot;, &quot;Current level (kB)&quot;,
176           &quot;Current amount of data in the queue (bytes)&quot;,
177           0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
178   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_VISIBLE,
179       g_param_spec_uint (&quot;current-level-visible&quot;,
180           &quot;Current level (visible items)&quot;,
181           &quot;Current number of visible items in the queue&quot;, 0, G_MAXUINT, 0,
182           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
183   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_TIME,
184       g_param_spec_uint64 (&quot;current-level-time&quot;, &quot;Current level (ns)&quot;,
185           &quot;Current amount of data in the queue (in ns)&quot;, 0, G_MAXUINT64, 0,
186           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
187 
188   gobject_class-&gt;finalize = gst_data_queue_finalize;
189 }
190 
191 static void
192 gst_data_queue_init (GstDataQueue * queue)
193 {
<span class="line-modified">194   queue-&gt;priv =</span>
<span class="line-removed">195       G_TYPE_INSTANCE_GET_PRIVATE (queue, GST_TYPE_DATA_QUEUE,</span>
<span class="line-removed">196       GstDataQueuePrivate);</span>
197 
198   queue-&gt;priv-&gt;cur_level.visible = 0;   /* no content */
199   queue-&gt;priv-&gt;cur_level.bytes = 0;     /* no content */
200   queue-&gt;priv-&gt;cur_level.time = 0;      /* no content */
201 
202   queue-&gt;priv-&gt;checkfull = NULL;
203 
204   g_mutex_init (&amp;queue-&gt;priv-&gt;qlock);
205   g_cond_init (&amp;queue-&gt;priv-&gt;item_add);
206   g_cond_init (&amp;queue-&gt;priv-&gt;item_del);
207   queue-&gt;priv-&gt;queue = gst_queue_array_new (50);
208 
209   GST_DEBUG (&quot;initialized queue&#39;s not_empty &amp; not_full conditions&quot;);
210 }
211 
212 /**
213  * gst_data_queue_new: (skip)
214  * @checkfull: the callback used to tell if the element considers the queue full
215  * or not.
216  * @fullcallback: the callback which will be called when the queue is considered full.
</pre>
<hr />
<pre>
545 }
546 
547 static gboolean
548 _gst_data_queue_wait_non_empty (GstDataQueue * queue)
549 {
550   GstDataQueuePrivate *priv = queue-&gt;priv;
551 
552   while (gst_data_queue_locked_is_empty (queue)) {
553     priv-&gt;waiting_add = TRUE;
554     g_cond_wait (&amp;priv-&gt;item_add, &amp;priv-&gt;qlock);
555     priv-&gt;waiting_add = FALSE;
556     if (priv-&gt;flushing)
557       return FALSE;
558   }
559   return TRUE;
560 }
561 
562 /**
563  * gst_data_queue_pop: (skip)
564  * @queue: a #GstDataQueue.
<span class="line-modified">565  * @item: pointer to store the returned #GstDataQueueItem.</span>
566  *
567  * Retrieves the first @item available on the @queue. If the queue is currently
568  * empty, the call will block until at least one item is available, OR the
569  * @queue is set to the flushing state.
570  * MT safe.
571  *
572  * Returns: %TRUE if an @item was successfully retrieved from the @queue.
573  *
574  * Since: 1.2
575  */
576 gboolean
577 gst_data_queue_pop (GstDataQueue * queue, GstDataQueueItem ** item)
578 {
579   GstDataQueuePrivate *priv = queue-&gt;priv;
580 
581   g_return_val_if_fail (GST_IS_DATA_QUEUE (queue), FALSE);
582   g_return_val_if_fail (item != NULL, FALSE);
583 
584   GST_DATA_QUEUE_MUTEX_LOCK_CHECK (queue, flushing);
585 
</pre>
<hr />
<pre>
615   return TRUE;
616 
617   /* ERRORS */
618 flushing:
619   {
620     GST_DEBUG (&quot;queue:%p, we are flushing&quot;, queue);
621     GST_DATA_QUEUE_MUTEX_UNLOCK (queue);
622     return FALSE;
623   }
624 }
625 
626 static gint
627 is_of_type (gconstpointer a, gconstpointer b)
628 {
629   return !G_TYPE_CHECK_INSTANCE_TYPE (a, GPOINTER_TO_SIZE (b));
630 }
631 
632 /**
633  * gst_data_queue_peek: (skip)
634  * @queue: a #GstDataQueue.
<span class="line-modified">635  * @item: pointer to store the returned #GstDataQueueItem.</span>
636  *
637  * Retrieves the first @item available on the @queue without removing it.
638  * If the queue is currently empty, the call will block until at least
639  * one item is available, OR the @queue is set to the flushing state.
640  * MT safe.
641  *
642  * Returns: %TRUE if an @item was successfully retrieved from the @queue.
643  *
644  * Since: 1.2
645  */
646 gboolean
647 gst_data_queue_peek (GstDataQueue * queue, GstDataQueueItem ** item)
648 {
649   GstDataQueuePrivate *priv = queue-&gt;priv;
650 
651   g_return_val_if_fail (GST_IS_DATA_QUEUE (queue), FALSE);
652   g_return_val_if_fail (item != NULL, FALSE);
653 
654   GST_DATA_QUEUE_MUTEX_LOCK_CHECK (queue, flushing);
655 
</pre>
<hr />
<pre>
742  * Since: 1.2
743  */
744 void
745 gst_data_queue_limits_changed (GstDataQueue * queue)
746 {
747   GstDataQueuePrivate *priv = queue-&gt;priv;
748 
749   g_return_if_fail (GST_IS_DATA_QUEUE (queue));
750 
751   GST_DATA_QUEUE_MUTEX_LOCK (queue);
752   if (priv-&gt;waiting_del) {
753     GST_DEBUG (&quot;signal del&quot;);
754     g_cond_signal (&amp;priv-&gt;item_del);
755   }
756   GST_DATA_QUEUE_MUTEX_UNLOCK (queue);
757 }
758 
759 /**
760  * gst_data_queue_get_level: (skip)
761  * @queue: The #GstDataQueue
<span class="line-modified">762  * @level: the location to store the result</span>
763  *
764  * Get the current level of the queue.
765  *
766  * Since: 1.2
767  */
768 void
769 gst_data_queue_get_level (GstDataQueue * queue, GstDataQueueSize * level)
770 {
771   GstDataQueuePrivate *priv = queue-&gt;priv;
772 
773   memcpy (level, (&amp;priv-&gt;cur_level), sizeof (GstDataQueueSize));
774 }
775 
776 static void
777 gst_data_queue_set_property (GObject * object,
778     guint prop_id, const GValue * value, GParamSpec * pspec)
779 {
780   switch (prop_id) {
781     default:
782       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
</pre>
</td>
<td>
<hr />
<pre>
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gstdataqueue
 24  * @title: GstDataQueue
 25  * @short_description: Threadsafe queueing object
 26  *
 27  * #GstDataQueue is an object that handles threadsafe queueing of objects. It
 28  * also provides size-related functionality. This object should be used for
 29  * any #GstElement that wishes to provide some sort of queueing functionality.
 30  */
<span class="line-added"> 31 #ifdef HAVE_CONFIG_H</span>
<span class="line-added"> 32 #include &quot;config.h&quot;</span>
<span class="line-added"> 33 #endif</span>
 34 
 35 #include &lt;gst/gst.h&gt;
 36 #include &quot;string.h&quot;
 37 #include &quot;gstdataqueue.h&quot;
 38 #include &quot;gstqueuearray.h&quot;
 39 #include &quot;gst/glib-compat-private.h&quot;
 40 
 41 GST_DEBUG_CATEGORY_STATIC (data_queue_debug);
 42 #define GST_CAT_DEFAULT (data_queue_debug)
 43 GST_DEBUG_CATEGORY_STATIC (data_queue_dataflow);
 44 
 45 
 46 /* Queue signals and args */
 47 enum
 48 {
 49   SIGNAL_EMPTY,
 50   SIGNAL_FULL,
 51   LAST_SIGNAL
 52 };
 53 
</pre>
<hr />
<pre>
115                gst_queue_array_get_length (q-&gt;priv-&gt;queue))
116 
117 static void gst_data_queue_finalize (GObject * object);
118 
119 static void gst_data_queue_set_property (GObject * object,
120     guint prop_id, const GValue * value, GParamSpec * pspec);
121 static void gst_data_queue_get_property (GObject * object,
122     guint prop_id, GValue * value, GParamSpec * pspec);
123 
124 static guint gst_data_queue_signals[LAST_SIGNAL] = { 0 };
125 
126 #define _do_init \
127 { \
128   GST_DEBUG_CATEGORY_INIT (data_queue_debug, &quot;dataqueue&quot;, 0, \
129       &quot;data queue object&quot;); \
130   GST_DEBUG_CATEGORY_INIT (data_queue_dataflow, &quot;data_queue_dataflow&quot;, 0, \
131       &quot;dataflow inside the data queue object&quot;); \
132 }
133 
134 #define parent_class gst_data_queue_parent_class
<span class="line-modified">135 G_DEFINE_TYPE_WITH_CODE (GstDataQueue, gst_data_queue, G_TYPE_OBJECT,</span>
<span class="line-added">136     G_ADD_PRIVATE (GstDataQueue) _do_init);</span>
137 
138 static void
139 gst_data_queue_class_init (GstDataQueueClass * klass)
140 {
141   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
142 


143   gobject_class-&gt;set_property = gst_data_queue_set_property;
144   gobject_class-&gt;get_property = gst_data_queue_get_property;
145 
146   /* signals */
147   /**
148    * GstDataQueue::empty: (skip)
149    * @queue: the queue instance
150    *
151    * Reports that the queue became empty (empty).
152    * A queue is empty if the total amount of visible items inside it (num-visible, time,
153    * size) is lower than the boundary values which can be set through the GObject
154    * properties.
155    */
156   gst_data_queue_signals[SIGNAL_EMPTY] =
157       g_signal_new (&quot;empty&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
158       G_STRUCT_OFFSET (GstDataQueueClass, empty), NULL, NULL,
159       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
160 
161   /**
162    * GstDataQueue::full: (skip)
</pre>
<hr />
<pre>
176   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BYTES,
177       g_param_spec_uint (&quot;current-level-bytes&quot;, &quot;Current level (kB)&quot;,
178           &quot;Current amount of data in the queue (bytes)&quot;,
179           0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
180   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_VISIBLE,
181       g_param_spec_uint (&quot;current-level-visible&quot;,
182           &quot;Current level (visible items)&quot;,
183           &quot;Current number of visible items in the queue&quot;, 0, G_MAXUINT, 0,
184           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
185   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_TIME,
186       g_param_spec_uint64 (&quot;current-level-time&quot;, &quot;Current level (ns)&quot;,
187           &quot;Current amount of data in the queue (in ns)&quot;, 0, G_MAXUINT64, 0,
188           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
189 
190   gobject_class-&gt;finalize = gst_data_queue_finalize;
191 }
192 
193 static void
194 gst_data_queue_init (GstDataQueue * queue)
195 {
<span class="line-modified">196   queue-&gt;priv = gst_data_queue_get_instance_private (queue);</span>


197 
198   queue-&gt;priv-&gt;cur_level.visible = 0;   /* no content */
199   queue-&gt;priv-&gt;cur_level.bytes = 0;     /* no content */
200   queue-&gt;priv-&gt;cur_level.time = 0;      /* no content */
201 
202   queue-&gt;priv-&gt;checkfull = NULL;
203 
204   g_mutex_init (&amp;queue-&gt;priv-&gt;qlock);
205   g_cond_init (&amp;queue-&gt;priv-&gt;item_add);
206   g_cond_init (&amp;queue-&gt;priv-&gt;item_del);
207   queue-&gt;priv-&gt;queue = gst_queue_array_new (50);
208 
209   GST_DEBUG (&quot;initialized queue&#39;s not_empty &amp; not_full conditions&quot;);
210 }
211 
212 /**
213  * gst_data_queue_new: (skip)
214  * @checkfull: the callback used to tell if the element considers the queue full
215  * or not.
216  * @fullcallback: the callback which will be called when the queue is considered full.
</pre>
<hr />
<pre>
545 }
546 
547 static gboolean
548 _gst_data_queue_wait_non_empty (GstDataQueue * queue)
549 {
550   GstDataQueuePrivate *priv = queue-&gt;priv;
551 
552   while (gst_data_queue_locked_is_empty (queue)) {
553     priv-&gt;waiting_add = TRUE;
554     g_cond_wait (&amp;priv-&gt;item_add, &amp;priv-&gt;qlock);
555     priv-&gt;waiting_add = FALSE;
556     if (priv-&gt;flushing)
557       return FALSE;
558   }
559   return TRUE;
560 }
561 
562 /**
563  * gst_data_queue_pop: (skip)
564  * @queue: a #GstDataQueue.
<span class="line-modified">565  * @item: (out): pointer to store the returned #GstDataQueueItem.</span>
566  *
567  * Retrieves the first @item available on the @queue. If the queue is currently
568  * empty, the call will block until at least one item is available, OR the
569  * @queue is set to the flushing state.
570  * MT safe.
571  *
572  * Returns: %TRUE if an @item was successfully retrieved from the @queue.
573  *
574  * Since: 1.2
575  */
576 gboolean
577 gst_data_queue_pop (GstDataQueue * queue, GstDataQueueItem ** item)
578 {
579   GstDataQueuePrivate *priv = queue-&gt;priv;
580 
581   g_return_val_if_fail (GST_IS_DATA_QUEUE (queue), FALSE);
582   g_return_val_if_fail (item != NULL, FALSE);
583 
584   GST_DATA_QUEUE_MUTEX_LOCK_CHECK (queue, flushing);
585 
</pre>
<hr />
<pre>
615   return TRUE;
616 
617   /* ERRORS */
618 flushing:
619   {
620     GST_DEBUG (&quot;queue:%p, we are flushing&quot;, queue);
621     GST_DATA_QUEUE_MUTEX_UNLOCK (queue);
622     return FALSE;
623   }
624 }
625 
626 static gint
627 is_of_type (gconstpointer a, gconstpointer b)
628 {
629   return !G_TYPE_CHECK_INSTANCE_TYPE (a, GPOINTER_TO_SIZE (b));
630 }
631 
632 /**
633  * gst_data_queue_peek: (skip)
634  * @queue: a #GstDataQueue.
<span class="line-modified">635  * @item: (out): pointer to store the returned #GstDataQueueItem.</span>
636  *
637  * Retrieves the first @item available on the @queue without removing it.
638  * If the queue is currently empty, the call will block until at least
639  * one item is available, OR the @queue is set to the flushing state.
640  * MT safe.
641  *
642  * Returns: %TRUE if an @item was successfully retrieved from the @queue.
643  *
644  * Since: 1.2
645  */
646 gboolean
647 gst_data_queue_peek (GstDataQueue * queue, GstDataQueueItem ** item)
648 {
649   GstDataQueuePrivate *priv = queue-&gt;priv;
650 
651   g_return_val_if_fail (GST_IS_DATA_QUEUE (queue), FALSE);
652   g_return_val_if_fail (item != NULL, FALSE);
653 
654   GST_DATA_QUEUE_MUTEX_LOCK_CHECK (queue, flushing);
655 
</pre>
<hr />
<pre>
742  * Since: 1.2
743  */
744 void
745 gst_data_queue_limits_changed (GstDataQueue * queue)
746 {
747   GstDataQueuePrivate *priv = queue-&gt;priv;
748 
749   g_return_if_fail (GST_IS_DATA_QUEUE (queue));
750 
751   GST_DATA_QUEUE_MUTEX_LOCK (queue);
752   if (priv-&gt;waiting_del) {
753     GST_DEBUG (&quot;signal del&quot;);
754     g_cond_signal (&amp;priv-&gt;item_del);
755   }
756   GST_DATA_QUEUE_MUTEX_UNLOCK (queue);
757 }
758 
759 /**
760  * gst_data_queue_get_level: (skip)
761  * @queue: The #GstDataQueue
<span class="line-modified">762  * @level: (out): the location to store the result</span>
763  *
764  * Get the current level of the queue.
765  *
766  * Since: 1.2
767  */
768 void
769 gst_data_queue_get_level (GstDataQueue * queue, GstDataQueueSize * level)
770 {
771   GstDataQueuePrivate *priv = queue-&gt;priv;
772 
773   memcpy (level, (&amp;priv-&gt;cur_level), sizeof (GstDataQueueSize));
774 }
775 
776 static void
777 gst_data_queue_set_property (GObject * object,
778     guint prop_id, const GValue * value, GParamSpec * pspec)
779 {
780   switch (prop_id) {
781     default:
782       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
</pre>
</td>
</tr>
</table>
<center><a href="gstcollectpads.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstdataqueue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>