<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-channels.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="audio-channel-mixer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio-converter.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-channels.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
179   if (channel_mask_out)
180     *channel_mask_out = channel_mask;
181 
182   return TRUE;
183 }
184 
185 /**
186  * gst_audio_reorder_channels:
187  * @data: (array length=size) (element-type guint8): The pointer to
188  *   the memory.
189  * @size: The size of the memory.
190  * @format: The %GstAudioFormat of the buffer.
191  * @channels: The number of channels.
192  * @from: (array length=channels): The channel positions in the buffer.
193  * @to: (array length=channels): The channel positions to convert to.
194  *
195  * Reorders @data from the channel positions @from to the channel
196  * positions @to. @from and @to must contain the same number of
197  * positions and the same positions, only in a different order.
198  *


199  * Returns: %TRUE if the reordering was possible.
200  */
201 gboolean
202 gst_audio_reorder_channels (gpointer data, gsize size, GstAudioFormat format,
203     gint channels, const GstAudioChannelPosition * from,
204     const GstAudioChannelPosition * to)
205 {
206   const GstAudioFormatInfo *info;
207   gint i, j, n;
208   gint reorder_map[64] = { 0, };
209   guint8 *ptr;
210   gint bpf, bps;
211   guint8 tmp[64 * 8];
212 
213   info = gst_audio_format_get_info (format);
214 
215   g_return_val_if_fail (data != NULL, FALSE);
216   g_return_val_if_fail (from != NULL, FALSE);
217   g_return_val_if_fail (to != NULL, FALSE);
218   g_return_val_if_fail (info != NULL &amp;&amp; info-&gt;width &gt; 0, FALSE);
</pre>
<hr />
<pre>
231   if (!gst_audio_get_channel_reorder_map (channels, from, to, reorder_map))
232     return FALSE;
233 
234   bps = info-&gt;width / 8;
235   bpf = bps * channels;
236   ptr = data;
237 
238   n = size / bpf;
239   for (i = 0; i &lt; n; i++) {
240 
241     memcpy (tmp, ptr, bpf);
242     for (j = 0; j &lt; channels; j++)
243       memcpy (ptr + reorder_map[j] * bps, tmp + j * bps, bps);
244 
245     ptr += bpf;
246   }
247 
248   return TRUE;
249 }
250 

























251 /**
252  * gst_audio_buffer_reorder_channels:
253  * @buffer: The buffer to reorder.
254  * @format: The %GstAudioFormat of the buffer.
255  * @channels: The number of channels.
256  * @from: (array length=channels): The channel positions in the buffer.
257  * @to: (array length=channels): The channel positions to convert to.
258  *
259  * Reorders @buffer from the channel positions @from to the channel
260  * positions @to. @from and @to must contain the same number of
261  * positions and the same positions, only in a different order.
262  * @buffer must be writable.
263  *
264  * Returns: %TRUE if the reordering was possible.
265  */
266 gboolean
267 gst_audio_buffer_reorder_channels (GstBuffer * buffer,
268     GstAudioFormat format, gint channels,
269     const GstAudioChannelPosition * from, const GstAudioChannelPosition * to)
270 {
271   GstMapInfo info;
<span class="line-modified">272   gboolean ret;</span>

273 
274   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
275   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
276 
277   if (gst_audio_channel_positions_equal (from, to, channels))
278     return TRUE;
279 
<span class="line-modified">280   if (!gst_buffer_map (buffer, &amp;info, GST_MAP_READWRITE))</span>
<span class="line-modified">281     return FALSE;</span>

282 
<span class="line-modified">283   ret =</span>
<span class="line-modified">284       gst_audio_reorder_channels (info.data, info.size, format, channels, from,</span>
<span class="line-modified">285       to);</span>

286 
<span class="line-modified">287   gst_buffer_unmap (buffer, &amp;info);</span>

288 


289   return ret;
290 }
291 
292 /**
293  * gst_audio_check_valid_channel_positions:
294  * @position: (array length=channels): The %GstAudioChannelPositions
295  *   to check.
296  * @channels: The number of channels.
297  * @force_order: Only consider the GStreamer channel order.
298  *
299  * Checks if @position contains valid channel positions for
300  * @channels channels. If @force_order is %TRUE it additionally
301  * checks if the channels are in the order required by GStreamer.
302  *
303  * Returns: %TRUE if the channel positions are valid.
304  */
305 gboolean
306 gst_audio_check_valid_channel_positions (const GstAudioChannelPosition *
307     position, gint channels, gboolean force_order)
308 {
</pre>
<hr />
<pre>
373     for (i = 0; i &lt; 64; i++) {
374       if ((channel_mask &amp; (G_GUINT64_CONSTANT (1) &lt;&lt; i))) {
375         if (j &lt; channels)
376           position[j] = default_channel_order[i];
377         j++;
378       }
379     }
380     if (j != channels)
381       GST_WARNING (&quot;Only partially valid channel mask 0x%016&quot; G_GINT64_MODIFIER
382           &quot;x for %d channels&quot;, channel_mask, channels);
383   }
384 
385   return TRUE;
386 
387   /* ERROR */
388 no_channel_mask:
389   {
390     GST_ERROR (&quot;no channel-mask property given&quot;);
391     return FALSE;
392   }
<span class="line-modified">393   }</span>
394 
395 
396 /**
397  * gst_audio_get_channel_reorder_map:
398  * @channels: The number of channels.
399  * @from: (array length=channels): The channel positions to reorder from.
400  * @to: (array length=channels): The channel positions to reorder to.
401  * @reorder_map: (array length=channels): Pointer to the reorder map.
402  *
403  * Returns a reorder map for @from to @to that can be used in
404  * custom channel reordering code, e.g. to convert from or to the
405  * GStreamer channel order. @from and @to must contain the same
406  * number of positions and the same positions, only in a
407  * different order.
408  *
409  * The resulting @reorder_map can be used for reordering by assigning
410  * channel i of the input to channel reorder_map[i] of the output.
411  *
412  * Returns: %TRUE if the channel positions are valid and reordering
413  * is possible.
</pre>
<hr />
<pre>
625       return &quot;SR&quot;;
626     default:
627       break;
628   }
629 
630   return &quot;UNKNOWN&quot;;
631 }
632 
633 /**
634  * gst_audio_channel_positions_to_string:
635  * @position: (array length=channels): The %GstAudioChannelPositions
636  *   to convert.
637  * @channels: The number of channels.
638  *
639  * Converts @position to a human-readable string representation for
640  * debugging purposes.
641  *
642  * Returns: (transfer full): a newly allocated string representing
643  * @position
644  *
<span class="line-modified">645  * Since 1.10</span>
646  */
647 gchar *
648 gst_audio_channel_positions_to_string (const GstAudioChannelPosition * position,
649     gint channels)
650 {
651   guint i;
652   GString *tmp;
653 
654   g_return_val_if_fail (channels &gt; 0, FALSE);
655   g_return_val_if_fail (position != NULL, FALSE);
656 
657   tmp = g_string_new (&quot;[&quot;);
658   for (i = 0; i &lt; channels; i++)
659     g_string_append_printf (tmp, &quot; %s&quot;, position_to_string (position[i]));
660   g_string_append (tmp, &quot; ]&quot;);
661 
662   return g_string_free (tmp, FALSE);
663 }
</pre>
</td>
<td>
<hr />
<pre>
179   if (channel_mask_out)
180     *channel_mask_out = channel_mask;
181 
182   return TRUE;
183 }
184 
185 /**
186  * gst_audio_reorder_channels:
187  * @data: (array length=size) (element-type guint8): The pointer to
188  *   the memory.
189  * @size: The size of the memory.
190  * @format: The %GstAudioFormat of the buffer.
191  * @channels: The number of channels.
192  * @from: (array length=channels): The channel positions in the buffer.
193  * @to: (array length=channels): The channel positions to convert to.
194  *
195  * Reorders @data from the channel positions @from to the channel
196  * positions @to. @from and @to must contain the same number of
197  * positions and the same positions, only in a different order.
198  *
<span class="line-added">199  * Note: this function assumes the audio data is in interleaved layout</span>
<span class="line-added">200  *</span>
201  * Returns: %TRUE if the reordering was possible.
202  */
203 gboolean
204 gst_audio_reorder_channels (gpointer data, gsize size, GstAudioFormat format,
205     gint channels, const GstAudioChannelPosition * from,
206     const GstAudioChannelPosition * to)
207 {
208   const GstAudioFormatInfo *info;
209   gint i, j, n;
210   gint reorder_map[64] = { 0, };
211   guint8 *ptr;
212   gint bpf, bps;
213   guint8 tmp[64 * 8];
214 
215   info = gst_audio_format_get_info (format);
216 
217   g_return_val_if_fail (data != NULL, FALSE);
218   g_return_val_if_fail (from != NULL, FALSE);
219   g_return_val_if_fail (to != NULL, FALSE);
220   g_return_val_if_fail (info != NULL &amp;&amp; info-&gt;width &gt; 0, FALSE);
</pre>
<hr />
<pre>
233   if (!gst_audio_get_channel_reorder_map (channels, from, to, reorder_map))
234     return FALSE;
235 
236   bps = info-&gt;width / 8;
237   bpf = bps * channels;
238   ptr = data;
239 
240   n = size / bpf;
241   for (i = 0; i &lt; n; i++) {
242 
243     memcpy (tmp, ptr, bpf);
244     for (j = 0; j &lt; channels; j++)
245       memcpy (ptr + reorder_map[j] * bps, tmp + j * bps, bps);
246 
247     ptr += bpf;
248   }
249 
250   return TRUE;
251 }
252 
<span class="line-added">253 static gboolean</span>
<span class="line-added">254 gst_audio_meta_reorder_channels (GstAudioMeta * meta,</span>
<span class="line-added">255     const GstAudioChannelPosition * from, const GstAudioChannelPosition * to)</span>
<span class="line-added">256 {</span>
<span class="line-added">257   gint reorder_map[64] = { 0, };</span>
<span class="line-added">258   gsize tmp_offsets[64] = { 0, };</span>
<span class="line-added">259   gint i;</span>
<span class="line-added">260 </span>
<span class="line-added">261   g_return_val_if_fail (meta, FALSE);</span>
<span class="line-added">262   g_return_val_if_fail (meta-&gt;info.channels &gt; 0, FALSE);</span>
<span class="line-added">263   g_return_val_if_fail (meta-&gt;info.channels &lt;= 64, FALSE);</span>
<span class="line-added">264   g_return_val_if_fail (meta-&gt;offsets != NULL, FALSE);</span>
<span class="line-added">265 </span>
<span class="line-added">266   if (!gst_audio_get_channel_reorder_map (meta-&gt;info.channels, from, to,</span>
<span class="line-added">267           reorder_map))</span>
<span class="line-added">268     return FALSE;</span>
<span class="line-added">269 </span>
<span class="line-added">270   memcpy (tmp_offsets, meta-&gt;offsets, meta-&gt;info.channels * sizeof (gsize));</span>
<span class="line-added">271   for (i = 0; i &lt; meta-&gt;info.channels; i++) {</span>
<span class="line-added">272     meta-&gt;offsets[reorder_map[i]] = tmp_offsets[i];</span>
<span class="line-added">273   }</span>
<span class="line-added">274 </span>
<span class="line-added">275   return TRUE;</span>
<span class="line-added">276 }</span>
<span class="line-added">277 </span>
278 /**
279  * gst_audio_buffer_reorder_channels:
280  * @buffer: The buffer to reorder.
281  * @format: The %GstAudioFormat of the buffer.
282  * @channels: The number of channels.
283  * @from: (array length=channels): The channel positions in the buffer.
284  * @to: (array length=channels): The channel positions to convert to.
285  *
286  * Reorders @buffer from the channel positions @from to the channel
287  * positions @to. @from and @to must contain the same number of
288  * positions and the same positions, only in a different order.
289  * @buffer must be writable.
290  *
291  * Returns: %TRUE if the reordering was possible.
292  */
293 gboolean
294 gst_audio_buffer_reorder_channels (GstBuffer * buffer,
295     GstAudioFormat format, gint channels,
296     const GstAudioChannelPosition * from, const GstAudioChannelPosition * to)
297 {
298   GstMapInfo info;
<span class="line-modified">299   GstAudioMeta *meta;</span>
<span class="line-added">300   gboolean ret = TRUE;</span>
301 
302   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
303   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
304 
305   if (gst_audio_channel_positions_equal (from, to, channels))
306     return TRUE;
307 
<span class="line-modified">308   meta = gst_buffer_get_audio_meta (buffer);</span>
<span class="line-modified">309   if (meta &amp;&amp; meta-&gt;info.layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
<span class="line-added">310     g_return_val_if_fail (channels == meta-&gt;info.channels, FALSE);</span>
311 
<span class="line-modified">312     ret = gst_audio_meta_reorder_channels (meta, from, to);</span>
<span class="line-modified">313   } else {</span>
<span class="line-modified">314     if (!gst_buffer_map (buffer, &amp;info, GST_MAP_READWRITE))</span>
<span class="line-added">315       return FALSE;</span>
316 
<span class="line-modified">317     ret = gst_audio_reorder_channels (info.data, info.size, format, channels,</span>
<span class="line-added">318         from, to);</span>
319 
<span class="line-added">320     gst_buffer_unmap (buffer, &amp;info);</span>
<span class="line-added">321   }</span>
322   return ret;
323 }
324 
325 /**
326  * gst_audio_check_valid_channel_positions:
327  * @position: (array length=channels): The %GstAudioChannelPositions
328  *   to check.
329  * @channels: The number of channels.
330  * @force_order: Only consider the GStreamer channel order.
331  *
332  * Checks if @position contains valid channel positions for
333  * @channels channels. If @force_order is %TRUE it additionally
334  * checks if the channels are in the order required by GStreamer.
335  *
336  * Returns: %TRUE if the channel positions are valid.
337  */
338 gboolean
339 gst_audio_check_valid_channel_positions (const GstAudioChannelPosition *
340     position, gint channels, gboolean force_order)
341 {
</pre>
<hr />
<pre>
406     for (i = 0; i &lt; 64; i++) {
407       if ((channel_mask &amp; (G_GUINT64_CONSTANT (1) &lt;&lt; i))) {
408         if (j &lt; channels)
409           position[j] = default_channel_order[i];
410         j++;
411       }
412     }
413     if (j != channels)
414       GST_WARNING (&quot;Only partially valid channel mask 0x%016&quot; G_GINT64_MODIFIER
415           &quot;x for %d channels&quot;, channel_mask, channels);
416   }
417 
418   return TRUE;
419 
420   /* ERROR */
421 no_channel_mask:
422   {
423     GST_ERROR (&quot;no channel-mask property given&quot;);
424     return FALSE;
425   }
<span class="line-modified">426 }</span>
427 
428 
429 /**
430  * gst_audio_get_channel_reorder_map:
431  * @channels: The number of channels.
432  * @from: (array length=channels): The channel positions to reorder from.
433  * @to: (array length=channels): The channel positions to reorder to.
434  * @reorder_map: (array length=channels): Pointer to the reorder map.
435  *
436  * Returns a reorder map for @from to @to that can be used in
437  * custom channel reordering code, e.g. to convert from or to the
438  * GStreamer channel order. @from and @to must contain the same
439  * number of positions and the same positions, only in a
440  * different order.
441  *
442  * The resulting @reorder_map can be used for reordering by assigning
443  * channel i of the input to channel reorder_map[i] of the output.
444  *
445  * Returns: %TRUE if the channel positions are valid and reordering
446  * is possible.
</pre>
<hr />
<pre>
658       return &quot;SR&quot;;
659     default:
660       break;
661   }
662 
663   return &quot;UNKNOWN&quot;;
664 }
665 
666 /**
667  * gst_audio_channel_positions_to_string:
668  * @position: (array length=channels): The %GstAudioChannelPositions
669  *   to convert.
670  * @channels: The number of channels.
671  *
672  * Converts @position to a human-readable string representation for
673  * debugging purposes.
674  *
675  * Returns: (transfer full): a newly allocated string representing
676  * @position
677  *
<span class="line-modified">678  * Since: 1.10</span>
679  */
680 gchar *
681 gst_audio_channel_positions_to_string (const GstAudioChannelPosition * position,
682     gint channels)
683 {
684   guint i;
685   GString *tmp;
686 
687   g_return_val_if_fail (channels &gt; 0, FALSE);
688   g_return_val_if_fail (position != NULL, FALSE);
689 
690   tmp = g_string_new (&quot;[&quot;);
691   for (i = 0; i &lt; channels; i++)
692     g_string_append_printf (tmp, &quot; %s&quot;, position_to_string (position[i]));
693   g_string_append (tmp, &quot; ]&quot;);
694 
695   return g_string_free (tmp, FALSE);
696 }
</pre>
</td>
</tr>
</table>
<center><a href="audio-channel-mixer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio-converter.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>