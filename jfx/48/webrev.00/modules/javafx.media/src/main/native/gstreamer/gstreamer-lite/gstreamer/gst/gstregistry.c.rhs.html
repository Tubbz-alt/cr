<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstregistry.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2005 David A. Schleef &lt;ds@schleef.org&gt;
   5  *
   6  * gstregistry.c: handle registry
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstregistry
  26  * @title: GstRegistry
  27  * @short_description: Abstract base class for management of #GstPlugin objects
  28  * @see_also: #GstPlugin, #GstPluginFeature
  29  *
  30  * One registry holds the metadata of a set of plugins.
  31  *
  32  * &lt;emphasis role=&quot;bold&quot;&gt;Design:&lt;/emphasis&gt;
  33  *
  34  * The #GstRegistry object is a list of plugins and some functions for dealing
  35  * with them. Each #GstPlugin is matched 1-1 with a file on disk, and may or may
  36  * not be loaded at a given time.
  37  *
  38  * The primary source, at all times, of plugin information is each plugin file
  39  * itself. Thus, if an application wants information about a particular plugin,
  40  * or wants to search for a feature that satisfies given criteria, the primary
  41  * means of doing so is to load every plugin and look at the resulting
  42  * information that is gathered in the default registry. Clearly, this is a time
  43  * consuming process, so we cache information in the registry file. The format
  44  * and location of the cache file is internal to gstreamer.
  45  *
  46  * On startup, plugins are searched for in the plugin search path. The following
  47  * locations are checked in this order:
  48  *
  49  * * location from --gst-plugin-path commandline option.
  50  * * the GST_PLUGIN_PATH environment variable.
  51  * * the GST_PLUGIN_SYSTEM_PATH environment variable.
  52  * * default locations (if GST_PLUGIN_SYSTEM_PATH is not set).
  53  *   Those default locations are:
  54  *   `$XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/`
  55  *   and `$prefix/libs/gstreamer-$GST_API_VERSION/`.
  56  *   [$XDG_DATA_HOME](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html) defaults to
  57  *   `$HOME/.local/share`.
  58  *
  59  * The registry cache file is loaded from
  60  * `$XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin`
  61  * (where $XDG_CACHE_HOME defaults to `$HOME/.cache`) or the file listed in the `GST_REGISTRY`
  62  * env var. One reason to change the registry location is for testing.
  63  *
  64  * For each plugin that is found in the plugin search path, there could be 3
  65  * possibilities for cached information:
  66  *
  67  *   * the cache may not contain information about a given file.
  68  *   * the cache may have stale information.
  69  *   * the cache may have current information.
  70  *
  71  * In the first two cases, the plugin is loaded and the cache updated. In
  72  * addition to these cases, the cache may have entries for plugins that are not
  73  * relevant to the current process. These are marked as not available to the
  74  * current process. If the cache is updated for whatever reason, it is marked
  75  * dirty.
  76  *
  77  * A dirty cache is written out at the end of initialization. Each entry is
  78  * checked to make sure the information is minimally valid. If not, the entry is
  79  * simply dropped.
  80  *
  81  * ## Implementation notes:
  82  *
  83  * The &quot;cache&quot; and &quot;registry&quot; are different concepts and can represent
  84  * different sets of plugins. For various reasons, at init time, the cache is
  85  * stored in the default registry, and plugins not relevant to the current
  86  * process are marked with the %GST_PLUGIN_FLAG_CACHED bit. These plugins are
  87  * removed at the end of initialization.
  88  */
  89 
  90 #ifdef HAVE_CONFIG_H
  91 #include &quot;config.h&quot;
  92 #endif
  93 #include &quot;gstconfig.h&quot;
  94 #include &quot;gst_private.h&quot;
  95 #include &lt;glib.h&gt;
  96 #include &lt;sys/types.h&gt;
  97 #include &lt;sys/stat.h&gt;
  98 #ifdef HAVE_UNISTD_H
  99 #include &lt;unistd.h&gt;
 100 #endif
 101 #include &lt;errno.h&gt;
 102 #include &lt;stdio.h&gt;
 103 #include &lt;string.h&gt;
 104 
 105 /* For g_stat () */
 106 #include &lt;glib/gstdio.h&gt;
 107 
 108 #include &quot;gstinfo.h&quot;
 109 #include &quot;gsterror.h&quot;
 110 #include &quot;gstregistry.h&quot;
 111 #ifndef GSTREAMER_LITE
 112 #include &quot;gstdeviceproviderfactory.h&quot;
 113 #endif // GSTREAMER_LITE
 114 
 115 #include &quot;gstpluginloader.h&quot;
 116 
 117 #include &quot;gst-i18n-lib.h&quot;
 118 
 119 #include &quot;gst.h&quot;
 120 #include &quot;glib-compat-private.h&quot;
 121 
 122 #ifdef GSTREAMER_LITE
 123 #define LIBGSTREAMER_LIB_NAME &quot;gstreamer-lite&quot;
 124 #endif // GSTREAMER_LITE
 125 
 126 
 127 #ifdef G_OS_WIN32
 128 #include &lt;windows.h&gt;
 129 extern HMODULE _priv_gst_dll_handle;
 130 #endif
 131 
 132 #if defined(GSTREAMER_LITE) &amp;&amp; defined(HAVE_OSX)
 133 #include &lt;mach-o/dyld.h&gt;
 134 #include &lt;mach-o/ldsyms.h&gt; //defines _mh_dylib_header see man page for ld
 135 #endif // GSTREAMER_LITE
 136 
 137 #if defined (GSTREAMER_LITE) &amp;&amp; defined(LINUX)
 138 #include &lt;link.h&gt;
 139 #include &lt;dlfcn.h&gt;
 140 
 141 // For libav (libavcodec.so)
 142 static const int AVCODEC_LIBAV_EXPLICIT_VERSIONS[] = { 54, 56 };
 143 // For ffmpeg (libavcodec-ffmpeg.so)
 144 static const int AVCODEC_FFMPEG_EXPLICIT_VERSIONS[] = { 56 };
 145 // For libav or ffmpeg (libavcodec.so)
 146 static const int AVCODEC_EXPLICIT_VERSIONS[] = { 57, 58 };
 147 
 148 /*
 149  * Callback passed to dl_iterate_phdr(): finds the path of
 150  * LIBGSTREAMER_LIB_NAME and returns it in data which is actually
 151  * a char**.
 152  */
 153 static int dl_callback (struct dl_phdr_info *info, size_t size, void *data)
 154 {
 155     int result = 0;
 156 
 157     if (NULL != info)
 158     {
 159         if (NULL != strstr (info-&gt;dlpi_name, LIBGSTREAMER_LIB_NAME))
 160         {
 161             if (NULL != data)
 162             {
 163                 char** name = (char**)data;
 164                 *name = (char*)info-&gt;dlpi_name;
 165             }
 166 
 167             result = 1;
 168         }
 169     }
 170 
 171     return result;
 172 }
 173 #endif // GSTREAMER_LITE &amp;&amp; LINUX
 174 
 175 #define GST_CAT_DEFAULT GST_CAT_REGISTRY
 176 
 177 struct _GstRegistryPrivate
 178 {
 179   GList *plugins;
 180   GList *features;
 181 
 182   guint n_plugins;
 183 #if 0
 184   GList *paths;
 185 #endif
 186 
 187   int cache_file;
 188 
 189   /* hash to speedup _lookup_feature_locked() */
 190   GHashTable *feature_hash;
 191   /* hash to speedup _lookup */
 192   GHashTable *basename_hash;
 193 
 194   /* updated whenever the feature list changes */
 195   guint32 cookie;
 196   /* speedup for searching features */
 197   GList *element_factory_list;
 198   guint32 efl_cookie;
 199   GList *typefind_factory_list;
 200   guint32 tfl_cookie;
 201   GList *device_provider_factory_list;
 202   guint32 dmfl_cookie;
 203 };
 204 
 205 /* the one instance of the default registry and the mutex protecting the
 206  * variable. */
 207 static GMutex _gst_registry_mutex;
 208 static GstRegistry *_gst_registry_default = NULL;
 209 
 210 /* defaults */
 211 #ifndef GSTREAMER_LITE
 212 #define DEFAULT_FORK TRUE
 213 #else // GSTREAMER_LITE
 214 // For GSTREAMER_LITE do not use fork for registry since it may break things, because
 215 // we do not use file to store registry and registry is kept in memory.
 216 #define DEFAULT_FORK FALSE
 217 #define LIBGSTREAMER_LIB_NAME &quot;gstreamer-lite&quot;
 218 #endif // GSTREAMER_LITE
 219 
 220 /* control the behaviour of registry rebuild */
 221 static gboolean _gst_enable_registry_fork = DEFAULT_FORK;
 222 /* List of plugins that need preloading/reloading after scanning registry */
 223 extern GSList *_priv_gst_preload_plugins;
 224 
 225 #ifndef GST_DISABLE_REGISTRY
 226 /* Set to TRUE to disable registry, behaves similar to GST_DISABLE_REGISTRY */
 227 gboolean _priv_gst_disable_registry = FALSE;
 228 /*set to TRUE when registry needn&#39;t to be updated */
 229 gboolean _priv_gst_disable_registry_update = FALSE;
 230 extern GList *_priv_gst_plugin_paths;
 231 
 232 /* Set to TRUE when the registry cache should be disabled */
 233 gboolean _gst_disable_registry_cache = FALSE;
 234 
 235 static gboolean __registry_reuse_plugin_scanner = TRUE;
 236 #endif
 237 
 238 /* Element signals and args */
 239 enum
 240 {
 241   PLUGIN_ADDED,
 242   FEATURE_ADDED,
 243   LAST_SIGNAL
 244 };
 245 
 246 #ifdef GSTREAMER_LITE
 247 gchar *gstlite_plugins_list[] =
 248 {
 249 #ifdef LINUX
 250 
 251     &quot;libfxplugins&quot;,
 252     &quot;libavplugin&quot;,
 253 #elif defined (G_OS_WIN32)
 254     &quot;fxplugins&quot;,
 255 #elif defined (HAVE_OSX)
 256     &quot;libfxplugins&quot;,
 257 #endif
 258     NULL
 259 };
 260 #endif // GSTREAMER_LITE
 261 
 262 static void gst_registry_finalize (GObject * object);
 263 
 264 static guint gst_registry_signals[LAST_SIGNAL] = { 0 };
 265 
 266 static GstPluginFeature *gst_registry_lookup_feature_locked (GstRegistry *
 267     registry, const char *name);
 268 static GstPlugin *gst_registry_lookup_bn_locked (GstRegistry * registry,
 269     const char *basename);
 270 
 271 #define gst_registry_parent_class parent_class
<a name="1" id="anc1"></a><span class="line-modified"> 272 G_DEFINE_TYPE_WITH_PRIVATE (GstRegistry, gst_registry, GST_TYPE_OBJECT);</span>
 273 
 274 static void
 275 gst_registry_class_init (GstRegistryClass * klass)
 276 {
 277   GObjectClass *gobject_class;
 278 
 279   gobject_class = (GObjectClass *) klass;
 280 
<a name="2" id="anc2"></a>

 281   /**
 282    * GstRegistry::plugin-added:
 283    * @registry: the registry that emitted the signal
 284    * @plugin: the plugin that has been added
 285    *
 286    * Signals that a plugin has been added to the registry (possibly
 287    * replacing a previously-added one by the same name)
 288    */
 289   gst_registry_signals[PLUGIN_ADDED] =
 290       g_signal_new (&quot;plugin-added&quot;, G_TYPE_FROM_CLASS (klass),
 291       G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
 292       G_TYPE_NONE, 1, GST_TYPE_PLUGIN);
 293 
 294   /**
 295    * GstRegistry::feature-added:
 296    * @registry: the registry that emitted the signal
 297    * @feature: the feature that has been added
 298    *
 299    * Signals that a feature has been added to the registry (possibly
 300    * replacing a previously-added one by the same name)
 301    */
 302   gst_registry_signals[FEATURE_ADDED] =
 303       g_signal_new (&quot;feature-added&quot;, G_TYPE_FROM_CLASS (klass),
 304       G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
 305       G_TYPE_NONE, 1, GST_TYPE_PLUGIN_FEATURE);
 306 
 307   gobject_class-&gt;finalize = gst_registry_finalize;
 308 }
 309 
 310 static void
 311 gst_registry_init (GstRegistry * registry)
 312 {
<a name="3" id="anc3"></a><span class="line-modified"> 313   registry-&gt;priv = gst_registry_get_instance_private (registry);</span>


 314   registry-&gt;priv-&gt;feature_hash = g_hash_table_new (g_str_hash, g_str_equal);
 315   registry-&gt;priv-&gt;basename_hash = g_hash_table_new (g_str_hash, g_str_equal);
 316 }
 317 
 318 static void
 319 gst_registry_finalize (GObject * object)
 320 {
 321   GstRegistry *registry = GST_REGISTRY (object);
 322   GList *plugins, *p;
 323   GList *features, *f;
 324 
 325   plugins = registry-&gt;priv-&gt;plugins;
 326   registry-&gt;priv-&gt;plugins = NULL;
 327   registry-&gt;priv-&gt;n_plugins = 0;
 328 
 329   GST_DEBUG_OBJECT (registry, &quot;registry finalize&quot;);
 330   p = plugins;
 331   while (p) {
 332     GstPlugin *plugin = p-&gt;data;
 333 
 334     if (plugin) {
 335       GST_LOG_OBJECT (registry, &quot;removing plugin %s&quot;,
 336           gst_plugin_get_name (plugin));
 337       gst_object_unref (plugin);
 338     }
 339     p = g_list_next (p);
 340   }
 341   g_list_free (plugins);
 342 
 343   features = registry-&gt;priv-&gt;features;
 344   registry-&gt;priv-&gt;features = NULL;
 345 
 346   f = features;
 347   while (f) {
 348     GstPluginFeature *feature = f-&gt;data;
 349 
 350     if (feature) {
 351       GST_LOG_OBJECT (registry, &quot;removing feature %p (%s)&quot;, feature,
 352           GST_OBJECT_NAME (feature));
 353       gst_object_unparent (GST_OBJECT_CAST (feature));
 354     }
 355     f = g_list_next (f);
 356   }
 357   g_list_free (features);
 358 
 359   g_hash_table_destroy (registry-&gt;priv-&gt;feature_hash);
 360   registry-&gt;priv-&gt;feature_hash = NULL;
 361   g_hash_table_destroy (registry-&gt;priv-&gt;basename_hash);
 362   registry-&gt;priv-&gt;basename_hash = NULL;
 363 
 364   if (registry-&gt;priv-&gt;element_factory_list) {
 365     GST_DEBUG_OBJECT (registry, &quot;Cleaning up cached element factory list&quot;);
 366     gst_plugin_feature_list_free (registry-&gt;priv-&gt;element_factory_list);
 367   }
 368 
 369   if (registry-&gt;priv-&gt;typefind_factory_list) {
 370     GST_DEBUG_OBJECT (registry, &quot;Cleaning up cached typefind factory list&quot;);
 371     gst_plugin_feature_list_free (registry-&gt;priv-&gt;typefind_factory_list);
 372   }
 373 
 374   if (registry-&gt;priv-&gt;device_provider_factory_list) {
 375     GST_DEBUG_OBJECT (registry,
 376         &quot;Cleaning up cached device provider factory list&quot;);
 377     gst_plugin_feature_list_free (registry-&gt;priv-&gt;device_provider_factory_list);
 378   }
 379 
 380   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 381 }
 382 
 383 /**
 384  * gst_registry_get:
 385  *
 386  * Retrieves the singleton plugin registry. The caller does not own a
 387  * reference on the registry, as it is alive as long as GStreamer is
 388  * initialized.
 389  *
 390  * Returns: (transfer none): the #GstRegistry.
 391  */
 392 GstRegistry *
 393 gst_registry_get (void)
 394 {
 395   GstRegistry *registry;
 396 
 397   g_mutex_lock (&amp;_gst_registry_mutex);
 398   if (G_UNLIKELY (!_gst_registry_default)) {
 399     _gst_registry_default = g_object_new (GST_TYPE_REGISTRY, NULL);
 400     gst_object_ref_sink (GST_OBJECT_CAST (_gst_registry_default));
 401   }
 402   registry = _gst_registry_default;
 403   g_mutex_unlock (&amp;_gst_registry_mutex);
 404 
 405   return registry;
 406 }
 407 
 408 #if 0
 409 /**
 410  * gst_registry_add_path:
 411  * @registry: the registry to add the path to
 412  * @path: the path to add to the registry
 413  *
 414  * Add the given path to the registry. The syntax of the
 415  * path is specific to the registry. If the path has already been
 416  * added, do nothing.
 417  */
 418 void
 419 gst_registry_add_path (GstRegistry * registry, const gchar * path)
 420 {
 421   g_return_if_fail (GST_IS_REGISTRY (registry));
 422   g_return_if_fail (path != NULL);
 423 
 424   if (strlen (path) == 0)
 425     goto empty_path;
 426 
 427   GST_OBJECT_LOCK (registry);
 428   if (g_list_find_custom (registry-&gt;priv-&gt;paths, path, (GCompareFunc) strcmp))
 429     goto was_added;
 430 
 431   GST_INFO (&quot;Adding plugin path: \&quot;%s\&quot;&quot;, path);
 432   registry-&gt;priv-&gt;paths =
 433       g_list_append (registry-&gt;priv-&gt;paths, g_strdup (path));
 434   GST_OBJECT_UNLOCK (registry);
 435 
 436   return;
 437 
 438 empty_path:
 439   {
 440     GST_INFO (&quot;Ignoring empty plugin path&quot;);
 441     return;
 442   }
 443 was_added:
 444   {
 445     g_warning (&quot;path %s already added to registry&quot;, path);
 446     GST_OBJECT_UNLOCK (registry);
 447     return;
 448   }
 449 }
 450 
 451 /**
 452  * gst_registry_get_path_list:
 453  * @registry: the registry to get the pathlist of
 454  *
 455  * Get the list of paths for the given registry.
 456  *
 457  * Returns: (transfer container) (element-type char*): A #GList of paths as
 458  *     strings. g_list_free after use.
 459  *
 460  * MT safe.
 461  */
 462 GList *
 463 gst_registry_get_path_list (GstRegistry * registry)
 464 {
 465   GList *list;
 466 
 467   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 468 
 469   GST_OBJECT_LOCK (registry);
 470   /* We don&#39;t need to copy the strings, because they won&#39;t be deleted
 471    * as long as the GstRegistry is around */
 472   list = g_list_copy (registry-&gt;priv-&gt;paths);
 473   GST_OBJECT_UNLOCK (registry);
 474 
 475   return list;
 476 }
 477 #endif
 478 
 479 /**
 480  * gst_registry_add_plugin:
 481  * @registry: the registry to add the plugin to
 482  * @plugin: (transfer floating): the plugin to add
 483  *
 484  * Add the plugin to the registry. The plugin-added signal will be emitted.
 485  *
 486  * @plugin&#39;s reference count will be incremented, and any floating
 487  * reference will be removed (see gst_object_ref_sink())
 488  *
 489  * Returns: %TRUE on success.
 490  *
 491  * MT safe.
 492  */
 493 gboolean
 494 gst_registry_add_plugin (GstRegistry * registry, GstPlugin * plugin)
 495 {
 496   GstPlugin *existing_plugin;
 497 
 498   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
 499   g_return_val_if_fail (GST_IS_PLUGIN (plugin), FALSE);
 500 
 501   GST_OBJECT_LOCK (registry);
 502   if (G_LIKELY (plugin-&gt;basename)) {
 503     /* we have a basename, see if we find the plugin */
 504     existing_plugin =
 505         gst_registry_lookup_bn_locked (registry, plugin-&gt;basename);
 506     if (existing_plugin) {
 507       GST_DEBUG_OBJECT (registry,
 508           &quot;Replacing existing plugin \&quot;%s\&quot; %p with new plugin %p for filename \&quot;%s\&quot;&quot;,
 509           GST_STR_NULL (existing_plugin-&gt;filename), existing_plugin, plugin,
 510           GST_STR_NULL (plugin-&gt;filename));
 511       /* If the new plugin is blacklisted and the existing one isn&#39;t cached, do not
 512        * accept if it&#39;s from a different location than the existing one */
 513       if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED) &amp;&amp;
 514           strcmp (plugin-&gt;filename, existing_plugin-&gt;filename)) {
 515         GST_WARNING_OBJECT (registry,
 516             &quot;Not replacing plugin because new one (%s) is blacklisted but for a different location than existing one (%s)&quot;,
 517             plugin-&gt;filename, existing_plugin-&gt;filename);
 518         /* Keep reference counting consistent */
 519         gst_object_ref_sink (plugin);
 520         gst_object_unref (plugin);
 521         GST_OBJECT_UNLOCK (registry);
 522         return FALSE;
 523       }
 524       registry-&gt;priv-&gt;plugins =
 525           g_list_remove (registry-&gt;priv-&gt;plugins, existing_plugin);
 526       --registry-&gt;priv-&gt;n_plugins;
 527       if (G_LIKELY (existing_plugin-&gt;basename))
 528         g_hash_table_remove (registry-&gt;priv-&gt;basename_hash,
 529             existing_plugin-&gt;basename);
 530       gst_object_unref (existing_plugin);
 531     }
 532   }
 533 
 534   GST_DEBUG_OBJECT (registry, &quot;adding plugin %p for filename \&quot;%s\&quot;&quot;,
 535       plugin, GST_STR_NULL (plugin-&gt;filename));
 536 
 537   registry-&gt;priv-&gt;plugins = g_list_prepend (registry-&gt;priv-&gt;plugins, plugin);
 538   ++registry-&gt;priv-&gt;n_plugins;
 539 
 540   if (G_LIKELY (plugin-&gt;basename))
 541     g_hash_table_replace (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename,
 542         plugin);
 543 
 544   gst_object_ref_sink (plugin);
 545   GST_OBJECT_UNLOCK (registry);
 546 
 547   GST_LOG_OBJECT (registry, &quot;emitting plugin-added for filename \&quot;%s\&quot;&quot;,
 548       GST_STR_NULL (plugin-&gt;filename));
 549   g_signal_emit (registry, gst_registry_signals[PLUGIN_ADDED], 0, plugin);
 550 
 551   return TRUE;
 552 }
 553 
 554 static void
 555 gst_registry_remove_features_for_plugin_unlocked (GstRegistry * registry,
 556     GstPlugin * plugin)
 557 {
 558   GList *f;
 559 
 560   g_return_if_fail (GST_IS_REGISTRY (registry));
 561   g_return_if_fail (GST_IS_PLUGIN (plugin));
 562 
 563   /* Remove all features for this plugin */
 564   f = registry-&gt;priv-&gt;features;
 565   while (f != NULL) {
 566     GList *next = g_list_next (f);
 567     GstPluginFeature *feature = f-&gt;data;
 568 
 569     if (G_UNLIKELY (feature &amp;&amp; feature-&gt;plugin == plugin)) {
 570       GST_DEBUG_OBJECT (registry, &quot;removing feature %p (%s) for plugin %p (%s)&quot;,
 571           feature, gst_plugin_feature_get_name (feature), plugin,
 572           plugin-&gt;desc.name);
 573 
 574       registry-&gt;priv-&gt;features =
 575           g_list_delete_link (registry-&gt;priv-&gt;features, f);
 576       g_hash_table_remove (registry-&gt;priv-&gt;feature_hash,
 577           GST_OBJECT_NAME (feature));
 578       gst_object_unparent (GST_OBJECT_CAST (feature));
 579     }
 580     f = next;
 581   }
 582   registry-&gt;priv-&gt;cookie++;
 583 }
 584 
 585 /**
 586  * gst_registry_remove_plugin:
 587  * @registry: the registry to remove the plugin from
 588  * @plugin: (transfer none): the plugin to remove
 589  *
 590  * Remove the plugin from the registry.
 591  *
 592  * MT safe.
 593  */
 594 void
 595 gst_registry_remove_plugin (GstRegistry * registry, GstPlugin * plugin)
 596 {
 597   g_return_if_fail (GST_IS_REGISTRY (registry));
 598   g_return_if_fail (GST_IS_PLUGIN (plugin));
 599 
 600   GST_DEBUG_OBJECT (registry, &quot;removing plugin %p (%s)&quot;,
 601       plugin, gst_plugin_get_name (plugin));
 602 
 603   GST_OBJECT_LOCK (registry);
 604   registry-&gt;priv-&gt;plugins = g_list_remove (registry-&gt;priv-&gt;plugins, plugin);
 605   --registry-&gt;priv-&gt;n_plugins;
 606   if (G_LIKELY (plugin-&gt;basename))
 607     g_hash_table_remove (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename);
 608   gst_registry_remove_features_for_plugin_unlocked (registry, plugin);
 609   GST_OBJECT_UNLOCK (registry);
 610   gst_object_unref (plugin);
 611 }
 612 
 613 /**
 614  * gst_registry_add_feature:
 615  * @registry: the registry to add the plugin to
 616  * @feature: (transfer floating): the feature to add
 617  *
 618  * Add the feature to the registry. The feature-added signal will be emitted.
 619  *
 620  * @feature&#39;s reference count will be incremented, and any floating
 621  * reference will be removed (see gst_object_ref_sink())
 622  *
 623  * Returns: %TRUE on success.
 624  *
 625  * MT safe.
 626  */
 627 gboolean
 628 gst_registry_add_feature (GstRegistry * registry, GstPluginFeature * feature)
 629 {
 630   GstPluginFeature *existing_feature;
 631 
 632   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
 633   g_return_val_if_fail (GST_IS_PLUGIN_FEATURE (feature), FALSE);
 634   g_return_val_if_fail (GST_OBJECT_NAME (feature) != NULL, FALSE);
 635   g_return_val_if_fail (feature-&gt;plugin_name != NULL, FALSE);
 636 
 637   GST_OBJECT_LOCK (registry);
 638   existing_feature = gst_registry_lookup_feature_locked (registry,
 639       GST_OBJECT_NAME (feature));
 640   if (G_UNLIKELY (existing_feature)) {
 641     GST_DEBUG_OBJECT (registry, &quot;replacing existing feature %p (%s)&quot;,
 642         existing_feature, GST_OBJECT_NAME (feature));
 643     /* Remove the existing feature from the list now, before we insert the new
 644      * one, but don&#39;t unref yet because the hash is still storing a reference to
 645      * it. */
 646     registry-&gt;priv-&gt;features =
 647         g_list_remove (registry-&gt;priv-&gt;features, existing_feature);
 648   }
 649 
 650   GST_DEBUG_OBJECT (registry, &quot;adding feature %p (%s)&quot;, feature,
 651       GST_OBJECT_NAME (feature));
 652 
 653   registry-&gt;priv-&gt;features = g_list_prepend (registry-&gt;priv-&gt;features, feature);
 654   g_hash_table_replace (registry-&gt;priv-&gt;feature_hash, GST_OBJECT_NAME (feature),
 655       feature);
 656 
 657   if (G_UNLIKELY (existing_feature)) {
 658     /* We unref now. No need to remove the feature name from the hash table, it
 659      * got replaced by the new feature */
 660     gst_object_unparent (GST_OBJECT_CAST (existing_feature));
 661   }
 662 
 663   gst_object_set_parent (GST_OBJECT_CAST (feature), GST_OBJECT_CAST (registry));
 664 
 665   registry-&gt;priv-&gt;cookie++;
 666   GST_OBJECT_UNLOCK (registry);
 667 
 668   GST_LOG_OBJECT (registry, &quot;emitting feature-added for %s&quot;,
 669       GST_OBJECT_NAME (feature));
 670   g_signal_emit (registry, gst_registry_signals[FEATURE_ADDED], 0, feature);
 671 
 672   return TRUE;
 673 }
 674 
 675 /**
 676  * gst_registry_remove_feature:
 677  * @registry: the registry to remove the feature from
 678  * @feature: (transfer none): the feature to remove
 679  *
 680  * Remove the feature from the registry.
 681  *
 682  * MT safe.
 683  */
 684 void
 685 gst_registry_remove_feature (GstRegistry * registry, GstPluginFeature * feature)
 686 {
 687   g_return_if_fail (GST_IS_REGISTRY (registry));
 688   g_return_if_fail (GST_IS_PLUGIN_FEATURE (feature));
 689 
 690   GST_DEBUG_OBJECT (registry, &quot;removing feature %p (%s)&quot;,
 691       feature, gst_plugin_feature_get_name (feature));
 692 
 693   GST_OBJECT_LOCK (registry);
 694   registry-&gt;priv-&gt;features = g_list_remove (registry-&gt;priv-&gt;features, feature);
 695   g_hash_table_remove (registry-&gt;priv-&gt;feature_hash, GST_OBJECT_NAME (feature));
 696   registry-&gt;priv-&gt;cookie++;
 697   GST_OBJECT_UNLOCK (registry);
 698 
 699   gst_object_unparent ((GstObject *) feature);
 700 }
 701 
 702 /**
 703  * gst_registry_plugin_filter:
 704  * @registry: registry to query
 705  * @filter: (scope call): the filter to use
 706  * @first: only return first match
 707  * @user_data: (closure): user data passed to the filter function
 708  *
 709  * Runs a filter against all plugins in the registry and returns a #GList with
 710  * the results. If the first flag is set, only the first match is
 711  * returned (as a list with a single object).
 712  * Every plugin is reffed; use gst_plugin_list_free() after use, which
 713  * will unref again.
 714  *
 715  * Returns: (transfer full) (element-type Gst.Plugin): a #GList of #GstPlugin.
 716  *     Use gst_plugin_list_free() after usage.
 717  *
 718  * MT safe.
 719  */
 720 GList *
 721 gst_registry_plugin_filter (GstRegistry * registry,
 722     GstPluginFilter filter, gboolean first, gpointer user_data)
 723 {
 724   GstPlugin **plugins;
 725   GList *walk, *list = NULL;
 726   guint n_plugins, i;
 727 
 728   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 729 
 730   GST_OBJECT_LOCK (registry);
 731   n_plugins = registry-&gt;priv-&gt;n_plugins;
 732   plugins = g_newa (GstPlugin *, n_plugins + 1);
 733   for (walk = registry-&gt;priv-&gt;plugins, i = 0; walk != NULL; walk = walk-&gt;next)
 734     plugins[i++] = gst_object_ref (walk-&gt;data);
 735   GST_OBJECT_UNLOCK (registry);
 736 
 737   for (i = 0; i &lt; n_plugins; ++i) {
 738     if (filter == NULL || filter (plugins[i], user_data)) {
 739       list = g_list_prepend (list, gst_object_ref (plugins[i]));
 740 
<a name="4" id="anc4"></a><span class="line-modified"> 741       if (first)</span>
<span class="line-modified"> 742         break;</span>

 743     }
<a name="5" id="anc5"></a><span class="line-added"> 744   }</span>
 745 
 746   for (i = 0; i &lt; n_plugins; ++i)
 747     gst_object_unref (plugins[i]);
 748 
 749   return list;
 750 }
 751 
 752 typedef struct
 753 {
 754   const gchar *name;
 755   GType type;
 756 } GstTypeNameData;
 757 
 758 static gboolean
 759 gst_plugin_feature_type_name_filter (GstPluginFeature * feature,
 760     GstTypeNameData * data)
 761 {
 762   g_assert (GST_IS_PLUGIN_FEATURE (feature));
 763 
 764   return ((data-&gt;type == 0 || data-&gt;type == G_OBJECT_TYPE (feature)) &amp;&amp;
 765       (data-&gt;name == NULL || !strcmp (data-&gt;name, GST_OBJECT_NAME (feature))));
 766 }
 767 
 768 /* returns TRUE if the list was changed
 769  *
 770  * Must be called with the object lock taken */
 771 static gboolean
 772 gst_registry_get_feature_list_or_create (GstRegistry * registry,
 773     GList ** previous, guint32 * cookie, GType type)
 774 {
 775   gboolean res = FALSE;
 776   GstRegistryPrivate *priv = registry-&gt;priv;
 777 
 778   if (G_UNLIKELY (!*previous || priv-&gt;cookie != *cookie)) {
 779     GstTypeNameData data;
 780     const GList *walk;
 781 
 782     if (*previous) {
 783       gst_plugin_feature_list_free (*previous);
 784       *previous = NULL;
 785     }
 786 
 787     data.type = type;
 788     data.name = NULL;
 789 
 790     for (walk = registry-&gt;priv-&gt;features; walk != NULL; walk = walk-&gt;next) {
 791       GstPluginFeature *feature = walk-&gt;data;
 792 
 793       if (gst_plugin_feature_type_name_filter (feature, &amp;data)) {
 794         *previous = g_list_prepend (*previous, gst_object_ref (feature));
 795       }
 796     }
 797 
 798     *cookie = priv-&gt;cookie;
 799     res = TRUE;
 800   }
 801 
 802   return res;
 803 }
 804 
 805 static gint
 806 type_find_factory_rank_cmp (const GstPluginFeature * fac1,
 807     const GstPluginFeature * fac2)
 808 {
 809   if (G_LIKELY (fac1-&gt;rank != fac2-&gt;rank))
 810     return fac2-&gt;rank - fac1-&gt;rank;
 811 
 812   /* to make the order in which things happen more deterministic,
 813    * sort by name when the ranks are the same. */
 814   return strcmp (GST_OBJECT_NAME (fac1), GST_OBJECT_NAME (fac2));
 815 }
 816 
 817 static GList *
 818 gst_registry_get_element_factory_list (GstRegistry * registry)
 819 {
 820   GList *list;
 821 
 822   GST_OBJECT_LOCK (registry);
 823 
 824   gst_registry_get_feature_list_or_create (registry,
 825       &amp;registry-&gt;priv-&gt;element_factory_list, &amp;registry-&gt;priv-&gt;efl_cookie,
 826       GST_TYPE_ELEMENT_FACTORY);
 827 
 828   /* Return reffed copy */
 829   list = gst_plugin_feature_list_copy (registry-&gt;priv-&gt;element_factory_list);
 830 
 831   GST_OBJECT_UNLOCK (registry);
 832 
 833   return list;
 834 }
 835 
 836 static GList *
 837 gst_registry_get_typefind_factory_list (GstRegistry * registry)
 838 {
 839   GList *list;
 840 
 841   GST_OBJECT_LOCK (registry);
 842 
 843   if (G_UNLIKELY (gst_registry_get_feature_list_or_create (registry,
 844               &amp;registry-&gt;priv-&gt;typefind_factory_list,
 845               &amp;registry-&gt;priv-&gt;tfl_cookie, GST_TYPE_TYPE_FIND_FACTORY)))
 846     registry-&gt;priv-&gt;typefind_factory_list =
 847         g_list_sort (registry-&gt;priv-&gt;typefind_factory_list,
 848         (GCompareFunc) type_find_factory_rank_cmp);
 849 
 850   /* Return reffed copy */
 851   list = gst_plugin_feature_list_copy (registry-&gt;priv-&gt;typefind_factory_list);
 852 
 853   GST_OBJECT_UNLOCK (registry);
 854 
 855   return list;
 856 }
 857 
 858 #ifndef GSTREAMER_LITE
 859 static GList *
 860 gst_registry_get_device_provider_factory_list (GstRegistry * registry)
 861 {
 862   GList *list;
 863 
 864   GST_OBJECT_LOCK (registry);
 865 
 866   gst_registry_get_feature_list_or_create (registry,
 867       &amp;registry-&gt;priv-&gt;device_provider_factory_list,
 868       &amp;registry-&gt;priv-&gt;dmfl_cookie, GST_TYPE_DEVICE_PROVIDER_FACTORY);
 869 
 870   /* Return reffed copy */
 871   list =
 872       gst_plugin_feature_list_copy (registry-&gt;
 873       priv-&gt;device_provider_factory_list);
 874 
 875   GST_OBJECT_UNLOCK (registry);
 876 
 877   return list;
 878 }
 879 #endif // GSTREAMER_LITE
 880 
 881 /**
 882  * gst_registry_feature_filter:
 883  * @registry: registry to query
 884  * @filter: (scope call): the filter to use
 885  * @first: only return first match
 886  * @user_data: (closure): user data passed to the filter function
 887  *
 888  * Runs a filter against all features of the plugins in the registry
 889  * and returns a GList with the results.
 890  * If the first flag is set, only the first match is
 891  * returned (as a list with a single object).
 892  *
 893  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
 894  *     #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.
 895  *
 896  * MT safe.
 897  */
 898 GList *
 899 gst_registry_feature_filter (GstRegistry * registry,
 900     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
 901 {
 902   GstPluginFeature **features;
 903   GList *walk, *list = NULL;
 904   guint n_features, i;
 905 
 906   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 907 
 908   GST_OBJECT_LOCK (registry);
 909   n_features = g_hash_table_size (registry-&gt;priv-&gt;feature_hash);
 910   features = g_newa (GstPluginFeature *, n_features + 1);
 911   for (walk = registry-&gt;priv-&gt;features, i = 0; walk != NULL; walk = walk-&gt;next)
 912     features[i++] = gst_object_ref (walk-&gt;data);
 913   GST_OBJECT_UNLOCK (registry);
 914 
 915   for (i = 0; i &lt; n_features; ++i) {
 916     if (filter == NULL || filter (features[i], user_data)) {
 917       list = g_list_prepend (list, gst_object_ref (features[i]));
 918 
<a name="6" id="anc6"></a><span class="line-modified"> 919       if (first)</span>
<span class="line-modified"> 920         break;</span>

 921     }
<a name="7" id="anc7"></a><span class="line-added"> 922   }</span>
 923 
 924   for (i = 0; i &lt; n_features; ++i)
 925     gst_object_unref (features[i]);
 926 
 927   return list;
 928 }
 929 
 930 static gboolean
 931 gst_registry_plugin_name_filter (GstPlugin * plugin, const gchar * name)
 932 {
 933   return (plugin-&gt;desc.name &amp;&amp; !strcmp (plugin-&gt;desc.name, name));
 934 }
 935 
 936 /**
 937  * gst_registry_find_plugin:
 938  * @registry: the registry to search
 939  * @name: the plugin name to find
 940  *
 941  * Find the plugin with the given name in the registry.
 942  * The plugin will be reffed; caller is responsible for unreffing.
 943  *
 944  * Returns: (transfer full) (nullable): the plugin with the given name
 945  *     or %NULL if the plugin was not found. gst_object_unref() after
 946  *     usage.
 947  *
 948  * MT safe.
 949  */
 950 GstPlugin *
 951 gst_registry_find_plugin (GstRegistry * registry, const gchar * name)
 952 {
 953   GList *walk;
 954   GstPlugin *result = NULL;
 955 
 956   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 957   g_return_val_if_fail (name != NULL, NULL);
 958 
 959   walk = gst_registry_plugin_filter (registry,
 960       (GstPluginFilter) gst_registry_plugin_name_filter, TRUE, (gpointer) name);
 961   if (walk) {
 962     result = GST_PLUGIN_CAST (walk-&gt;data);
 963 
 964     gst_object_ref (result);
 965     gst_plugin_list_free (walk);
 966   }
 967 
 968   return result;
 969 }
 970 
 971 /**
 972  * gst_registry_find_feature:
 973  * @registry: the registry to search
 974  * @name: the pluginfeature name to find
 975  * @type: the pluginfeature type to find
 976  *
 977  * Find the pluginfeature with the given name and type in the registry.
 978  *
 979  * Returns: (transfer full) (nullable): the pluginfeature with the
 980  *     given name and type or %NULL if the plugin was not
 981  *     found. gst_object_unref() after usage.
 982  *
 983  * MT safe.
 984  */
 985 GstPluginFeature *
 986 gst_registry_find_feature (GstRegistry * registry, const gchar * name,
 987     GType type)
 988 {
 989   GstPluginFeature *feature = NULL;
 990 
 991   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 992   g_return_val_if_fail (name != NULL, NULL);
 993   g_return_val_if_fail (g_type_is_a (type, GST_TYPE_PLUGIN_FEATURE), NULL);
 994 
 995   feature = gst_registry_lookup_feature (registry, name);
 996   if (feature &amp;&amp; !g_type_is_a (G_TYPE_FROM_INSTANCE (feature), type)) {
 997     gst_object_unref (feature);
 998     feature = NULL;
 999   }
1000 
1001   return feature;
1002 }
1003 
1004 /**
1005  * gst_registry_get_feature_list:
1006  * @registry: a #GstRegistry
1007  * @type: a #GType.
1008  *
1009  * Retrieves a #GList of #GstPluginFeature of @type.
1010  *
1011  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
1012  *     #GstPluginFeature of @type. Use gst_plugin_feature_list_free() after use
1013  *
1014  * MT safe.
1015  */
1016 GList *
1017 gst_registry_get_feature_list (GstRegistry * registry, GType type)
1018 {
1019   GstTypeNameData data;
1020 
1021   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1022   g_return_val_if_fail (g_type_is_a (type, GST_TYPE_PLUGIN_FEATURE), NULL);
1023 
1024   /* Speed up */
1025   if (type == GST_TYPE_ELEMENT_FACTORY)
1026     return gst_registry_get_element_factory_list (registry);
1027   else if (type == GST_TYPE_TYPE_FIND_FACTORY)
1028     return gst_registry_get_typefind_factory_list (registry);
1029 #ifndef GSTREAMER_LITE
1030   else if (type == GST_TYPE_DEVICE_PROVIDER_FACTORY)
1031     return gst_registry_get_device_provider_factory_list (registry);
1032 #endif // GSTREAMER_LITE
1033 
1034   data.type = type;
1035   data.name = NULL;
1036 
1037   return gst_registry_feature_filter (registry,
1038       (GstPluginFeatureFilter) gst_plugin_feature_type_name_filter,
1039       FALSE, &amp;data);
1040 }
1041 
1042 /**
1043  * gst_registry_get_plugin_list:
1044  * @registry: the registry to search
1045  *
1046  * Get a copy of all plugins registered in the given registry. The refcount
1047  * of each element in the list in incremented.
1048  *
1049  * Returns: (transfer full) (element-type Gst.Plugin): a #GList of #GstPlugin.
1050  *     Use gst_plugin_list_free() after usage.
1051  *
1052  * MT safe.
1053  */
1054 GList *
1055 gst_registry_get_plugin_list (GstRegistry * registry)
1056 {
1057   GList *list;
1058   GList *g;
1059 
1060   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1061 
1062   GST_OBJECT_LOCK (registry);
1063   list = g_list_copy (registry-&gt;priv-&gt;plugins);
1064   for (g = list; g; g = g-&gt;next) {
1065     gst_object_ref (GST_PLUGIN_CAST (g-&gt;data));
1066   }
1067   GST_OBJECT_UNLOCK (registry);
1068 
1069   return list;
1070 }
1071 
1072 static GstPluginFeature *
1073 gst_registry_lookup_feature_locked (GstRegistry * registry, const char *name)
1074 {
1075   return g_hash_table_lookup (registry-&gt;priv-&gt;feature_hash, name);
1076 }
1077 
1078 /**
1079  * gst_registry_lookup_feature:
1080  * @registry: a #GstRegistry
1081  * @name: a #GstPluginFeature name
1082  *
1083  * Find a #GstPluginFeature with @name in @registry.
1084  *
1085  * Returns: (transfer full): a #GstPluginFeature with its refcount incremented,
1086  *     use gst_object_unref() after usage.
1087  *
1088  * MT safe.
1089  */
1090 GstPluginFeature *
1091 gst_registry_lookup_feature (GstRegistry * registry, const char *name)
1092 {
1093   GstPluginFeature *feature;
1094 
1095   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1096   g_return_val_if_fail (name != NULL, NULL);
1097 
1098   GST_OBJECT_LOCK (registry);
1099   feature = gst_registry_lookup_feature_locked (registry, name);
1100   if (feature)
1101     gst_object_ref (feature);
1102   GST_OBJECT_UNLOCK (registry);
1103 
1104   return feature;
1105 }
1106 
1107 static GstPlugin *
1108 gst_registry_lookup_bn_locked (GstRegistry * registry, const char *basename)
1109 {
1110   return g_hash_table_lookup (registry-&gt;priv-&gt;basename_hash, basename);
1111 }
1112 
1113 static GstPlugin *
1114 gst_registry_lookup_bn (GstRegistry * registry, const char *basename)
1115 {
1116   GstPlugin *plugin;
1117 
1118   GST_OBJECT_LOCK (registry);
1119   plugin = gst_registry_lookup_bn_locked (registry, basename);
1120   if (plugin)
1121     gst_object_ref (plugin);
1122   GST_OBJECT_UNLOCK (registry);
1123 
1124   return plugin;
1125 }
1126 
1127 /**
1128  * gst_registry_lookup:
1129  * @registry: the registry to look up in
1130  * @filename: the name of the file to look up
1131  *
1132  * Look up a plugin in the given registry with the given filename.
1133  * If found, plugin is reffed.
1134  *
1135  * Returns: (transfer full) (nullable): the #GstPlugin if found, or
1136  *     %NULL if not.  gst_object_unref() after usage.
1137  */
1138 GstPlugin *
1139 gst_registry_lookup (GstRegistry * registry, const char *filename)
1140 {
1141   GstPlugin *plugin;
1142   gchar *basename;
1143 
1144   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1145   g_return_val_if_fail (filename != NULL, NULL);
1146 
1147   basename = g_path_get_basename (filename);
1148   if (G_UNLIKELY (basename == NULL))
1149     return NULL;
1150 
1151   plugin = gst_registry_lookup_bn (registry, basename);
1152 
1153   g_free (basename);
1154 
1155   return plugin;
1156 }
1157 
1158 typedef enum
1159 {
1160   REGISTRY_SCAN_HELPER_NOT_STARTED = 0,
1161   REGISTRY_SCAN_HELPER_DISABLED,
1162   REGISTRY_SCAN_HELPER_RUNNING
1163 } GstRegistryScanHelperState;
1164 
1165 typedef struct
1166 {
1167   GstRegistry *registry;
1168   GstRegistryScanHelperState helper_state;
1169   GstPluginLoader *helper;
1170   gboolean changed;
1171 } GstRegistryScanContext;
1172 
1173 static void
1174 init_scan_context (GstRegistryScanContext * context, GstRegistry * registry)
1175 {
1176   gboolean do_fork;
1177 
1178   context-&gt;registry = registry;
1179 
1180   /* see if forking is enabled and set up the scan helper state accordingly */
1181   do_fork = _gst_enable_registry_fork;
1182   if (do_fork) {
1183     const gchar *fork_env;
1184 
1185     /* forking enabled, see if it is disabled with an env var */
1186     if ((fork_env = g_getenv (&quot;GST_REGISTRY_FORK&quot;))) {
1187       /* fork enabled for any value different from &quot;no&quot; */
1188       do_fork = strcmp (fork_env, &quot;no&quot;) != 0;
1189     }
1190   }
1191 
1192   if (do_fork)
1193     context-&gt;helper_state = REGISTRY_SCAN_HELPER_NOT_STARTED;
1194   else
1195     context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1196 
1197   context-&gt;helper = NULL;
1198   context-&gt;changed = FALSE;
1199 }
1200 
1201 static void
1202 clear_scan_context (GstRegistryScanContext * context)
1203 {
1204   if (context-&gt;helper) {
1205     context-&gt;changed |= _priv_gst_plugin_loader_funcs.destroy (context-&gt;helper);
1206     context-&gt;helper = NULL;
1207   }
1208 }
1209 
1210 static gboolean
1211 gst_registry_scan_plugin_file (GstRegistryScanContext * context,
1212     const gchar * filename, off_t file_size, time_t file_mtime)
1213 {
1214   gboolean changed = FALSE;
1215   GstPlugin *newplugin = NULL;
1216 
1217 #ifdef G_OS_WIN32
1218   /* Disable external plugin loader on Windows until it is ported properly. */
1219   context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1220 #endif
1221 
1222 
1223   /* Have a plugin to load - see if the scan-helper needs starting */
1224   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_NOT_STARTED) {
1225     GST_DEBUG (&quot;Starting plugin scanner for file %s&quot;, filename);
1226     context-&gt;helper = _priv_gst_plugin_loader_funcs.create (context-&gt;registry);
1227     if (context-&gt;helper != NULL)
1228       context-&gt;helper_state = REGISTRY_SCAN_HELPER_RUNNING;
1229     else {
1230       GST_WARNING (&quot;Failed starting plugin scanner. Scanning in-process&quot;);
1231       context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1232     }
1233   }
1234 
1235   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_RUNNING) {
1236     GST_DEBUG (&quot;Using scan-helper to load plugin %s&quot;, filename);
1237     if (!_priv_gst_plugin_loader_funcs.load (context-&gt;helper,
1238             filename, file_size, file_mtime)) {
1239       g_warning (&quot;External plugin loader failed. This most likely means that &quot;
1240           &quot;the plugin loader helper binary was not found or could not be run. &quot;
1241           &quot;You might need to set the GST_PLUGIN_SCANNER environment variable &quot;
1242           &quot;if your setup is unusual. This should normally not be required &quot;
1243           &quot;though.&quot;);
1244       context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1245     }
1246   }
1247 
1248   /* Check if the helper is disabled (or just got disabled above) */
1249   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_DISABLED) {
1250     /* Load plugin the old fashioned way... */
1251 
1252     /* We don&#39;t use a GError here because a failure to load some shared
1253      * objects as plugins is normal (particularly in the uninstalled case)
1254      */
1255     newplugin = _priv_gst_plugin_load_file_for_registry (filename,
1256         context-&gt;registry, NULL);
1257   }
1258 
1259   if (newplugin) {
1260     GST_DEBUG_OBJECT (context-&gt;registry, &quot;marking new plugin %p as registered&quot;,
1261         newplugin);
1262     newplugin-&gt;registered = TRUE;
1263     gst_object_unref (newplugin);
1264     changed = TRUE;
1265   }
1266 #ifndef GST_DISABLE_REGISTRY
1267   if (!__registry_reuse_plugin_scanner) {
1268     clear_scan_context (context);
1269     context-&gt;helper_state = REGISTRY_SCAN_HELPER_NOT_STARTED;
1270   }
1271 #endif
1272 
1273   return changed;
1274 }
1275 
1276 #ifndef GSTREAMER_LITE
1277 static gboolean
1278 is_blacklisted_hidden_directory (const gchar * dirent)
1279 {
1280   if (G_LIKELY (dirent[0] != &#39;.&#39;))
1281     return FALSE;
1282 
1283   /* skip the .debug directory, these contain elf files that are not
1284    * useful or worse, can crash dlopen () */
1285   if (strcmp (dirent, &quot;.debug&quot;) == 0)
1286     return TRUE;
1287 
1288   /* can also skip .git and .deps dirs, those won&#39;t contain useful files.
1289    * This speeds up scanning a bit in uninstalled setups. */
1290   if (strcmp (dirent, &quot;.git&quot;) == 0 || strcmp (dirent, &quot;.deps&quot;) == 0)
1291     return TRUE;
1292 
1293   return FALSE;
1294 }
1295 #endif
1296 
1297 #ifdef GSTREAMER_LITE
1298 // Only for Linux 32-bit
1299 #if defined(LINUX) &amp;&amp; !defined(__x86_64__)
1300 gpointer load_plugin(gpointer data)
1301 {
1302   return dlopen((gchar*)data, RTLD_GLOBAL|RTLD_NOW);
1303 }
1304 
1305 gboolean preload_plugin_on_thread(int version, gchar *filename)
1306 {
1307   void *handle = NULL;
1308 
1309   if (version != 57) // Only needed for 57
1310     return TRUE;
1311 
1312   if (filename == NULL)
1313     return FALSE;
1314 
1315   GThread *thread = g_thread_new(NULL, load_plugin, filename);
1316   if (thread != NULL) {
1317     handle = g_thread_join(thread);
1318     if (handle != NULL) {
1319       return TRUE;
1320     }
1321   }
1322 
1323   return FALSE;
1324 }
1325 #endif
1326 #endif // GSTREAMER_LITE
1327 
1328 static gboolean
1329 gst_registry_scan_path_level (GstRegistryScanContext * context,
1330     const gchar * path, int level)
1331 {
1332 #ifndef GSTREAMER_LITE
1333   GDir *dir;
1334   const gchar *dirent;
1335 #endif // GSTREAMER_LITE
1336   gchar *filename;
1337   GstPlugin *plugin;
1338   gboolean changed = FALSE;
1339 #ifdef GSTREAMER_LITE
1340   gint gstlite_plugins_list_index = 0;
1341   struct stat file_status;
1342   gchar *filename_partial;
1343 #ifdef LINUX
1344   void *avcHandle = NULL;
1345   gboolean isAVCFFMPEG = FALSE;
1346 #endif // LINUX
1347 #endif // GSTREAMER_LITE
1348 
1349 #ifndef GSTREAMER_LITE
1350   dir = g_dir_open (path, 0, NULL);
1351   if (!dir)
1352     return FALSE;
1353 
1354   while ((dirent = g_dir_read_name (dir))) {
1355     GStatBuf file_status;
1356 
1357     filename = g_build_filename (path, dirent, NULL);
1358     if (g_stat (filename, &amp;file_status) &lt; 0) {
1359       /* Plugin will be removed from cache after the scan completes if it
1360        * is still marked &#39;cached&#39; */
1361       g_free (filename);
1362       continue;
1363     }
1364 
1365     if (file_status.st_mode &amp; S_IFDIR) {
1366       if (G_UNLIKELY (is_blacklisted_hidden_directory (dirent))) {
1367         GST_TRACE_OBJECT (context-&gt;registry, &quot;ignoring %s directory&quot;, dirent);
1368         g_free (filename);
1369         continue;
1370       }
1371       /* FIXME 2.0: Don&#39;t recurse into directories, this behaviour
1372        * is inconsistent with other PATH environment variables
1373        */
1374       if (level &gt; 0) {
1375         GST_LOG_OBJECT (context-&gt;registry, &quot;recursing into directory %s&quot;,
1376             filename);
1377         changed |= gst_registry_scan_path_level (context, filename, level - 1);
1378       } else {
1379         GST_LOG_OBJECT (context-&gt;registry, &quot;not recursing into directory %s, &quot;
1380             &quot;recursion level too deep&quot;, filename);
1381       }
1382       g_free (filename);
1383       continue;
1384     }
1385     if (!(file_status.st_mode &amp; S_IFREG)) {
1386       GST_TRACE_OBJECT (context-&gt;registry, &quot;%s is not a regular file, ignoring&quot;,
1387           filename);
1388       g_free (filename);
1389       continue;
1390     }
1391     if (!g_str_has_suffix (dirent, &quot;.&quot; G_MODULE_SUFFIX)
1392 #ifdef GST_EXTRA_MODULE_SUFFIX
1393         &amp;&amp; !g_str_has_suffix (dirent, GST_EXTRA_MODULE_SUFFIX)
1394 #endif
1395         ) {
1396       GST_TRACE_OBJECT (context-&gt;registry,
1397           &quot;extension is not recognized as module file, ignoring file %s&quot;,
1398           filename);
1399       g_free (filename);
1400       continue;
1401     }
1402 #else // GSTREAMER_LITE
1403 
1404   for (gstlite_plugins_list_index = 0; gstlite_plugins_list[gstlite_plugins_list_index] != NULL; gstlite_plugins_list_index++) {
1405     filename_partial = g_build_filename (path, gstlite_plugins_list[gstlite_plugins_list_index], NULL);
1406 #ifdef LINUX
1407     if (g_str_has_suffix(filename_partial, &quot;libavplugin&quot;)) { // Check libav version and load correspondent module.
1408       int plugin_version = 0;
1409       // Look for libavcodec and check its version to figure out if it is
1410       // libav or ffmpeg. Starting from 57 and up
1411       int vi = (sizeof(AVCODEC_EXPLICIT_VERSIONS)/sizeof(AVCODEC_EXPLICIT_VERSIONS[0]));
1412       while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1413         int version = AVCODEC_EXPLICIT_VERSIONS[vi];
1414         gchar* libname = g_strdup_printf(&quot;libavcodec.so.%d&quot;, version);
1415         avcHandle = dlopen(libname, RTLD_NOW);
1416         g_free(libname);
1417       }
1418 
1419       // Check if it is libav or ffmpeg
1420       if (avcHandle) {
1421         unsigned int (*av_version)(void);
1422         av_version = dlsym(avcHandle, &quot;avcodec_version&quot;);
1423         if (av_version != NULL) {
1424           unsigned int version = (*av_version)();
1425           unsigned int micro = version &amp; 0xFF;
1426           if (micro &gt;= 100)
1427             isAVCFFMPEG = TRUE;
1428           plugin_version = AVCODEC_EXPLICIT_VERSIONS[vi];
1429         } else { // Something wrong
1430           dlclose(avcHandle);
1431           avcHandle = NULL;
1432         }
1433       }
1434 
1435       // Look for libavcodec-ffmpeg. For 56 only
1436       if (avcHandle == NULL) {
1437         vi = (sizeof(AVCODEC_FFMPEG_EXPLICIT_VERSIONS)/sizeof(AVCODEC_FFMPEG_EXPLICIT_VERSIONS[0]));
1438         while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1439           int version = AVCODEC_FFMPEG_EXPLICIT_VERSIONS[vi];
1440           gchar* libname = g_strdup_printf(&quot;libavcodec-ffmpeg.so.%d&quot;, version);
1441           avcHandle = dlopen(libname, RTLD_NOW);
1442           g_free(libname);
1443         }
1444 
1445         if (avcHandle) {
1446           plugin_version = AVCODEC_FFMPEG_EXPLICIT_VERSIONS[vi];
1447           isAVCFFMPEG = TRUE;
1448         }
1449       }
1450 
1451       // Looks for libav 56 and below
1452       if (avcHandle == NULL) {
1453         vi = (sizeof(AVCODEC_LIBAV_EXPLICIT_VERSIONS)/sizeof(AVCODEC_LIBAV_EXPLICIT_VERSIONS[0]));
1454         while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1455           int version = AVCODEC_LIBAV_EXPLICIT_VERSIONS[vi];
1456           gchar* libname = g_strdup_printf(&quot;libavcodec.so.%d&quot;, version);
1457           avcHandle = dlopen(libname, RTLD_NOW);
1458           g_free(libname);
1459         }
1460 
1461         if (avcHandle) {
1462           plugin_version = AVCODEC_LIBAV_EXPLICIT_VERSIONS[vi];
1463         }
1464       }
1465 
1466       if (avcHandle) {
1467         dlclose(avcHandle);
1468         avcHandle = NULL;
1469 
1470         // Try simple name first. OpenJDK build may contain the latest bits.
1471         filename = g_strdup_printf(&quot;%s%s&quot;, filename_partial, GST_EXTRA_MODULE_SUFFIX);
1472         if (g_stat (filename, &amp;file_status) &lt; 0) { // Not available, create a versioned filename
1473           g_free(filename);
1474           if (isAVCFFMPEG)
1475             filename = g_strdup_printf(&quot;%s-ffmpeg-%d%s&quot;, filename_partial, plugin_version, GST_EXTRA_MODULE_SUFFIX);
1476           else
1477             filename = g_strdup_printf(&quot;%s-%d%s&quot;, filename_partial, plugin_version, GST_EXTRA_MODULE_SUFFIX);
1478         }
1479 #if defined(LINUX) &amp;&amp; !defined(__x86_64__)
1480         if (!preload_plugin_on_thread(plugin_version, filename)) {
1481           g_free(filename_partial);
1482           filename_partial = NULL;
1483           g_free(filename);
1484           filename = NULL;
1485           continue; // If we fail preload do not load such plugin.
1486         }
1487 #endif
1488       } else {
1489         g_free(filename_partial);
1490         continue; // No libavcodec.so installed.
1491       }
1492     } else {
1493       filename = g_strconcat(filename_partial, GST_EXTRA_MODULE_SUFFIX, NULL);
1494     }
1495 #else
1496     filename = g_strconcat(filename_partial, GST_EXTRA_MODULE_SUFFIX, NULL);
1497 #endif
1498     g_free(filename_partial);
1499 
1500     if (g_stat (filename, &amp;file_status) &lt; 0) {
1501       /* Plugin will be removed from cache after the scan completes if it
1502        * is still marked &#39;cached&#39; */
1503       g_free (filename);
1504       continue;
1505     }
1506 #endif // GSTREAMER_LITE
1507 
1508     GST_LOG_OBJECT (context-&gt;registry, &quot;file %s looks like a possible module&quot;,
1509         filename);
1510 
1511 #ifndef GSTREAMER_LITE
1512     /* try to avoid unnecessary plugin-move pain */
1513     if (g_str_has_prefix (dirent, &quot;libgstvalve&quot;) ||
1514         g_str_has_prefix (dirent, &quot;libgstselector&quot;)) {
1515       GST_WARNING_OBJECT (context-&gt;registry, &quot;ignoring old plugin %s which &quot;
1516           &quot;has been merged into the corelements plugin&quot;, filename);
1517       /* Plugin will be removed from cache after the scan completes if it
1518        * is still marked &#39;cached&#39; */
1519       g_free (filename);
1520       continue;
1521     }
1522 
1523     /* plug-ins are considered unique by basename; if the given name
1524      * was already seen by the registry, we ignore it */
1525     plugin = gst_registry_lookup_bn (context-&gt;registry, dirent);
1526 #else // GSTREAMER_LITE
1527     plugin = gst_registry_lookup (context-&gt;registry, filename);
1528 #endif // GSTREAMER_LITE
1529     if (plugin) {
1530       gboolean env_vars_changed, deps_changed = FALSE;
1531 
1532       if (plugin-&gt;registered) {
1533         GST_DEBUG_OBJECT (context-&gt;registry,
1534             &quot;plugin already registered from path \&quot;%s\&quot;&quot;,
1535             GST_STR_NULL (plugin-&gt;filename));
1536         g_free (filename);
1537         gst_object_unref (plugin);
1538         continue;
1539       }
1540 
1541       env_vars_changed = _priv_plugin_deps_env_vars_changed (plugin);
1542 
1543       /* If a file with a certain basename is seen on a different path,
1544        * update the plugin to ensure the registry cache will reflect up
1545        * to date information */
1546 
1547       if (plugin-&gt;file_mtime == file_status.st_mtime &amp;&amp;
1548           plugin-&gt;file_size == file_status.st_size &amp;&amp; !env_vars_changed &amp;&amp;
1549           !(deps_changed = _priv_plugin_deps_files_changed (plugin)) &amp;&amp;
1550           !strcmp (plugin-&gt;filename, filename)) {
1551         GST_LOG_OBJECT (context-&gt;registry, &quot;file %s cached&quot;, filename);
1552         GST_OBJECT_FLAG_UNSET (plugin, GST_PLUGIN_FLAG_CACHED);
1553         GST_LOG_OBJECT (context-&gt;registry,
1554             &quot;marking plugin %p as registered as %s&quot;, plugin, filename);
1555         plugin-&gt;registered = TRUE;
1556       } else {
1557         GST_INFO_OBJECT (context-&gt;registry, &quot;cached info for %s is stale&quot;,
1558             filename);
1559         GST_DEBUG_OBJECT (context-&gt;registry, &quot;mtime %&quot; G_GINT64_FORMAT &quot; != %&quot;
1560             G_GINT64_FORMAT &quot; or size %&quot; G_GINT64_FORMAT &quot; != %&quot;
1561             G_GINT64_FORMAT &quot; or external dependency env_vars changed: %d or&quot;
1562             &quot; external dependencies changed: %d or old path %s != new path %s&quot;,
1563             (gint64) plugin-&gt;file_mtime, (gint64) file_status.st_mtime,
1564             (gint64) plugin-&gt;file_size, (gint64) file_status.st_size,
1565             env_vars_changed, deps_changed, plugin-&gt;filename, filename);
1566         gst_registry_remove_plugin (context-&gt;registry, plugin);
1567         changed |= gst_registry_scan_plugin_file (context, filename,
1568             file_status.st_size, file_status.st_mtime);
1569       }
1570       gst_object_unref (plugin);
1571 
1572     } else {
1573       GST_DEBUG_OBJECT (context-&gt;registry, &quot;file %s not yet in registry&quot;,
1574           filename);
1575       changed |= gst_registry_scan_plugin_file (context, filename,
1576           file_status.st_size, file_status.st_mtime);
1577     }
1578 
1579     g_free (filename);
1580   }
1581 
1582 #ifndef GSTREAMER_LITE
1583   g_dir_close (dir);
1584 #endif // GSTREAMER_LITE
1585 
1586   return changed;
1587 }
1588 
1589 static gboolean
1590 gst_registry_scan_path_internal (GstRegistryScanContext * context,
1591     const gchar * path)
1592 {
1593   gboolean changed;
1594 
1595   GST_DEBUG_OBJECT (context-&gt;registry, &quot;scanning path %s&quot;, path);
1596 #ifndef GSTREAMER_LITE
1597   changed = gst_registry_scan_path_level (context, path, 10);
1598 #else // GSTREAMER_LITE
1599   changed = gst_registry_scan_path_level (context, path, 0);
1600 #endif // GSTREAMER_LITE
1601 
1602   GST_DEBUG_OBJECT (context-&gt;registry, &quot;registry changed in path %s: %d&quot;, path,
1603       changed);
1604   return changed;
1605 }
1606 
1607 /**
1608  * gst_registry_scan_path:
1609  * @registry: the registry to add found plugins to
1610  * @path: (type filename): the path to scan
1611  *
1612  * Scan the given path for plugins to add to the registry. The syntax of the
1613  * path is specific to the registry.
1614  *
1615  * Returns: %TRUE if registry changed
1616  */
1617 gboolean
1618 gst_registry_scan_path (GstRegistry * registry, const gchar * path)
1619 {
1620   GstRegistryScanContext context;
1621   gboolean result;
1622 
1623   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
1624   g_return_val_if_fail (path != NULL, FALSE);
1625 
1626   init_scan_context (&amp;context, registry);
1627 
1628   result = gst_registry_scan_path_internal (&amp;context, path);
1629 
1630   clear_scan_context (&amp;context);
1631   result |= context.changed;
1632 
1633   return result;
1634 }
1635 
1636 static gboolean
1637 _gst_plugin_feature_filter_plugin_name (GstPluginFeature * feature,
1638     gpointer user_data)
1639 {
1640   return (strcmp (feature-&gt;plugin_name, (gchar *) user_data) == 0);
1641 }
1642 
1643 /**
1644  * gst_registry_get_feature_list_by_plugin:
1645  * @registry: a #GstRegistry.
1646  * @name: a plugin name.
1647  *
1648  * Retrieves a #GList of features of the plugin with name @name.
1649  *
1650  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
1651  *     #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.
1652  */
1653 GList *
1654 gst_registry_get_feature_list_by_plugin (GstRegistry * registry,
1655     const gchar * name)
1656 {
1657   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1658   g_return_val_if_fail (name != NULL, NULL);
1659 
1660   return gst_registry_feature_filter (registry,
1661       _gst_plugin_feature_filter_plugin_name, FALSE, (gpointer) name);
1662 }
1663 
1664 /* Unref and delete the default registry */
1665 void
1666 _priv_gst_registry_cleanup (void)
1667 {
1668   GstRegistry *registry;
1669 
1670   g_mutex_lock (&amp;_gst_registry_mutex);
1671   if ((registry = _gst_registry_default) != NULL) {
1672     _gst_registry_default = NULL;
1673   }
1674   g_mutex_unlock (&amp;_gst_registry_mutex);
1675 
1676   /* unref outside of the lock because we can. */
1677   if (registry)
1678     gst_object_unref (registry);
1679 }
1680 
1681 /**
1682  * gst_registry_check_feature_version:
1683  * @registry: a #GstRegistry
1684  * @feature_name: the name of the feature (e.g. &quot;oggdemux&quot;)
1685  * @min_major: the minimum major version number
1686  * @min_minor: the minimum minor version number
1687  * @min_micro: the minimum micro version number
1688  *
1689  * Checks whether a plugin feature by the given name exists in
1690  * @registry and whether its version is at least the
1691  * version required.
1692  *
1693  * Returns: %TRUE if the feature could be found and the version is
1694  * the same as the required version or newer, and %FALSE otherwise.
1695  */
1696 gboolean
1697 gst_registry_check_feature_version (GstRegistry * registry,
1698     const gchar * feature_name, guint min_major, guint min_minor,
1699     guint min_micro)
1700 {
1701   GstPluginFeature *feature;
1702   gboolean ret = FALSE;
1703 
1704   g_return_val_if_fail (feature_name != NULL, FALSE);
1705 
1706   GST_DEBUG (&quot;Looking up plugin feature &#39;%s&#39;&quot;, feature_name);
1707 
1708   feature = gst_registry_lookup_feature (registry, feature_name);
1709   if (feature) {
1710     ret = gst_plugin_feature_check_version (feature, min_major, min_minor,
1711         min_micro);
1712     gst_object_unref (feature);
1713   } else {
1714     GST_DEBUG (&quot;Could not find plugin feature &#39;%s&#39;&quot;, feature_name);
1715   }
1716 
1717   return ret;
1718 }
1719 
1720 static void
1721 load_plugin_func (gpointer data, gpointer user_data)
1722 {
1723   GstPlugin *plugin;
1724   const gchar *filename;
1725   GError *err = NULL;
1726 
1727   filename = (const gchar *) data;
1728   GST_DEBUG (&quot;Pre-loading plugin %s&quot;, filename);
1729 
1730   plugin = gst_plugin_load_file (filename, &amp;err);
1731 
1732   if (plugin) {
1733     GST_INFO (&quot;Loaded plugin: \&quot;%s\&quot;&quot;, filename);
1734 
1735     gst_registry_add_plugin (gst_registry_get (), plugin);
1736   } else {
1737     if (err) {
1738       /* Report error to user, and free error */
1739       GST_ERROR (&quot;Failed to load plugin: %s&quot;, err-&gt;message);
1740       g_error_free (err);
1741     } else {
1742       GST_WARNING (&quot;Failed to load plugin: \&quot;%s\&quot;&quot;, filename);
1743     }
1744   }
1745 }
1746 
1747 #ifndef GST_DISABLE_REGISTRY
1748 /* Unref all plugins marked &#39;cached&#39;, to clear old plugins that no
1749  * longer exist. Returns %TRUE if any plugins were removed */
1750 static gboolean
1751 gst_registry_remove_cache_plugins (GstRegistry * registry)
1752 {
1753   GList *g;
1754   GList *g_next;
1755   GstPlugin *plugin;
1756   gboolean changed = FALSE;
1757 
1758   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
1759 
1760   GST_OBJECT_LOCK (registry);
1761 
1762   GST_DEBUG_OBJECT (registry, &quot;removing cached plugins&quot;);
1763   g = registry-&gt;priv-&gt;plugins;
1764   while (g) {
1765     g_next = g-&gt;next;
1766     plugin = g-&gt;data;
1767     if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_CACHED)) {
1768       GST_DEBUG_OBJECT (registry, &quot;removing cached plugin \&quot;%s\&quot;&quot;,
1769           GST_STR_NULL (plugin-&gt;filename));
1770       registry-&gt;priv-&gt;plugins = g_list_delete_link (registry-&gt;priv-&gt;plugins, g);
1771       --registry-&gt;priv-&gt;n_plugins;
1772       if (G_LIKELY (plugin-&gt;basename))
1773         g_hash_table_remove (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename);
1774       gst_registry_remove_features_for_plugin_unlocked (registry, plugin);
1775       gst_object_unref (plugin);
1776       changed = TRUE;
1777     }
1778     g = g_next;
1779   }
1780 
1781   GST_OBJECT_UNLOCK (registry);
1782 
1783   return changed;
1784 }
1785 
1786 typedef enum
1787 {
1788   REGISTRY_SCAN_AND_UPDATE_FAILURE = 0,
1789   REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED,
1790   REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED
1791 } GstRegistryScanAndUpdateResult;
1792 
1793 /*
1794  * scan_and_update_registry:
1795  * @default_registry: the #GstRegistry
1796  * @registry_file: registry filename
1797  * @write_changes: write registry if it has changed?
1798  *
1799  * Scans for registry changes and eventually updates the registry cache.
1800  *
1801  * Return: %REGISTRY_SCAN_AND_UPDATE_FAILURE if the registry could not scanned
1802  *         or updated, %REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED if the
1803  *         registry is clean and %REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED if
1804  *         it has been updated and the cache needs to be re-read.
1805  */
1806 static GstRegistryScanAndUpdateResult
1807 scan_and_update_registry (GstRegistry * default_registry,
1808     const gchar * registry_file, gboolean write_changes, GError ** error)
1809 {
1810   const gchar *plugin_path;
1811   gboolean changed = FALSE;
1812   GList *l;
1813   GstRegistryScanContext context;
1814 
1815   GST_INFO (&quot;Validating plugins from registry cache: %s&quot;, registry_file);
1816 
1817 #ifdef GSTREAMER_LITE
1818 #ifdef G_OS_WIN32
1819   {
1820     HMODULE hmodule = NULL;
1821     char *dir = NULL;
1822     gchar *p = NULL;
1823     wchar_t wc_fn[MAX_PATH];
1824 
1825     hmodule = GetModuleHandle(LIBGSTREAMER_LIB_NAME);
1826     if (hmodule)
1827     {
1828       if (GetModuleFileNameW(hmodule, wc_fn, MAX_PATH))
1829       {
1830         dir = g_utf16_to_utf8(wc_fn, -1, NULL, NULL, NULL);
1831         if (dir)
1832         {
1833           if ((p = strrchr (dir, G_DIR_SEPARATOR)) != NULL)
1834             *p = &#39;\0&#39;;
1835 
1836           changed |= gst_registry_scan_path (default_registry, dir);
1837 
1838           g_free(dir);
1839         }
1840       }
1841     }
1842   }
1843 #elif defined(HAVE_OSX)
1844   {
1845     const void* pHeader = (void*) &amp;_mh_dylib_header;
1846     const char* pImageName = 0;
1847     gchar*      pBasePath = NULL;
1848     int         iCount = _dyld_image_count();
1849     int         i;
1850 
1851     for(i = 1; i &lt; iCount; i++)
1852     {
1853         if (((void*)_dyld_get_image_header(i)) == pHeader)
1854             pImageName = _dyld_get_image_name(i);//contains absolute path to dylib
1855     }
1856 
1857     if (NULL != pImageName)
1858     {
1859         pBasePath = g_path_get_dirname((const gchar*) pImageName);
1860         changed |= gst_registry_scan_path (default_registry, pBasePath);
1861     }
1862   }
1863 #elif defined (LINUX)
1864   {
1865     // Get base path of Gstreamer-lite lib.
1866     gchar *base_path = NULL;
1867     if (dl_iterate_phdr (dl_callback, &amp;base_path))
1868     {
1869       base_path = g_path_get_dirname((const gchar*) base_path);
1870     }
1871 
1872     if (base_path != NULL)
1873     {
1874       changed |= gst_registry_scan_path (default_registry, base_path);
1875     }
1876     else
1877     {
1878       GST_ERROR (&quot;Could not locate %s&quot;, LIBGSTREAMER_LIB_NAME);
1879     }
1880   }
1881 #else // other platforms ...
1882   {
1883     // Scan current path
1884     gchar *current_path = g_get_current_dir();
1885     if (current_path != NULL)
1886     {
1887       changed |= gst_registry_scan_path (default_registry, current_path);
1888       g_free(current_path);
1889     }
1890     else
1891     {
1892       GST_ERROR (&quot;g_get_current_dir() returned NULL&quot;);
1893     }
1894   }
1895 #endif // other platforms
1896 #endif // GSTREAMER_LITE
1897 
1898 #ifndef GSTREAMER_LITE
1899   init_scan_context (&amp;context, default_registry);
1900 
1901   /* It sounds tempting to just compare the mtime of directories with the mtime
1902    * of the registry cache, but it does not work. It would not catch updated
1903    * plugins, which might bring more or less features.
1904    */
1905 
1906   /* scan paths specified via --gst-plugin-path */
1907   GST_DEBUG (&quot;scanning paths added via --gst-plugin-path&quot;);
1908   for (l = _priv_gst_plugin_paths; l != NULL; l = l-&gt;next) {
1909     GST_INFO (&quot;Scanning plugin path: \&quot;%s\&quot;&quot;, (gchar *) l-&gt;data);
1910     changed |= gst_registry_scan_path_internal (&amp;context, (gchar *) l-&gt;data);
1911   }
1912   /* keep plugin_paths around in case a re-scan is forced later on */
1913 
1914   /* GST_PLUGIN_PATH specifies a list of directories to scan for
1915    * additional plugins.  These take precedence over the system plugins */
1916   plugin_path = g_getenv (&quot;GST_PLUGIN_PATH_1_0&quot;);
1917   if (plugin_path == NULL)
<a name="8" id="anc8"></a><span class="line-modified">1918     plugin_path = g_getenv (&quot;GST_PLUGIN_PATH&quot;);</span>
1919   if (plugin_path) {
1920     char **list;
1921     int i;
1922 
1923     GST_DEBUG (&quot;GST_PLUGIN_PATH set to %s&quot;, plugin_path);
1924     list = g_strsplit (plugin_path, G_SEARCHPATH_SEPARATOR_S, 0);
1925     for (i = 0; list[i]; i++) {
1926       changed |= gst_registry_scan_path_internal (&amp;context, list[i]);
1927     }
1928     g_strfreev (list);
1929   } else {
1930     GST_DEBUG (&quot;GST_PLUGIN_PATH not set&quot;);
1931   }
1932 
1933   /* GST_PLUGIN_SYSTEM_PATH specifies a list of plugins that are always
1934    * loaded by default.  If not set, this defaults to the system-installed
1935    * path, and the plugins installed in the user&#39;s home directory */
1936   plugin_path = g_getenv (&quot;GST_PLUGIN_SYSTEM_PATH_1_0&quot;);
1937   if (plugin_path == NULL)
<a name="9" id="anc9"></a><span class="line-modified">1938     plugin_path = g_getenv (&quot;GST_PLUGIN_SYSTEM_PATH&quot;);</span>
1939   if (plugin_path == NULL) {
1940     char *home_plugins;
1941 
1942     GST_DEBUG (&quot;GST_PLUGIN_SYSTEM_PATH not set&quot;);
1943 
1944     /* plugins in the user&#39;s home directory take precedence over
1945      * system-installed ones */
1946     home_plugins = g_build_filename (g_get_user_data_dir (),
1947         &quot;gstreamer-&quot; GST_API_VERSION, &quot;plugins&quot;, NULL);
1948 
1949     GST_DEBUG (&quot;scanning home plugins %s&quot;, home_plugins);
1950     changed |= gst_registry_scan_path_internal (&amp;context, home_plugins);
1951     g_free (home_plugins);
1952 
1953     /* add the main (installed) library path */
1954 
1955 #ifdef G_OS_WIN32
1956     {
1957       char *base_dir;
1958       char *dir;
1959 
1960       base_dir =
1961           g_win32_get_package_installation_directory_of_module
1962           (_priv_gst_dll_handle);
1963 
<a name="10" id="anc10"></a><span class="line-modified">1964       dir = g_build_filename (base_dir, GST_PLUGIN_SUBDIR,</span>
<span class="line-modified">1965           &quot;gstreamer-&quot; GST_API_VERSION, NULL);</span>



1966       GST_DEBUG (&quot;scanning DLL dir %s&quot;, dir);
1967 
1968       changed |= gst_registry_scan_path_internal (&amp;context, dir);
1969 
1970       g_free (dir);
1971       g_free (base_dir);
1972     }
1973 #else
1974     GST_DEBUG (&quot;scanning main plugins %s&quot;, PLUGINDIR);
1975     changed |= gst_registry_scan_path_internal (&amp;context, PLUGINDIR);
1976 #endif
1977   } else {
1978     gchar **list;
1979     gint i;
1980 
1981     GST_DEBUG (&quot;GST_PLUGIN_SYSTEM_PATH set to %s&quot;, plugin_path);
1982     list = g_strsplit (plugin_path, G_SEARCHPATH_SEPARATOR_S, 0);
1983     for (i = 0; list[i]; i++) {
1984       changed |= gst_registry_scan_path_internal (&amp;context, list[i]);
1985     }
1986     g_strfreev (list);
1987   }
1988 
1989 
1990   clear_scan_context (&amp;context);
1991 
1992   changed |= context.changed;
1993 #endif // GSTREAMER_LITE
1994 
1995   /* Remove cached plugins so stale info is cleared. */
1996   changed |= gst_registry_remove_cache_plugins (default_registry);
1997 
1998   if (!changed) {
1999     GST_INFO (&quot;Registry cache has not changed&quot;);
2000     return REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED;
2001   }
2002 
2003   if (!write_changes) {
2004     GST_INFO (&quot;Registry cache changed, but writing is disabled. Not writing.&quot;);
2005     return REGISTRY_SCAN_AND_UPDATE_FAILURE;
2006   }
2007 
2008 #ifndef GSTREAMER_LITE
2009   GST_INFO (&quot;Registry cache changed. Writing new registry cache&quot;);
2010   if (!priv_gst_registry_binary_write_cache (default_registry,
2011           default_registry-&gt;priv-&gt;plugins, registry_file)) {
2012     g_set_error (error, GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
2013         _(&quot;Error writing registry cache to %s: %s&quot;),
2014         registry_file, g_strerror (errno));
2015     return REGISTRY_SCAN_AND_UPDATE_FAILURE;
2016   }
2017 #endif // GSTREAMER_LITE
2018 
2019   GST_INFO (&quot;Registry cache written successfully&quot;);
2020   return REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED;
2021 }
2022 
2023 static gboolean
2024 ensure_current_registry (GError ** error)
2025 {
2026   gchar *registry_file;
2027   GstRegistry *default_registry;
2028   gboolean ret = TRUE;
2029   gboolean do_update = TRUE;
2030   gboolean have_cache = TRUE;
2031 
2032   default_registry = gst_registry_get ();
2033 
2034   registry_file = g_strdup (g_getenv (&quot;GST_REGISTRY_1_0&quot;));
2035   if (registry_file == NULL)
<a name="11" id="anc11"></a><span class="line-modified">2036     registry_file = g_strdup (g_getenv (&quot;GST_REGISTRY&quot;));</span>
2037   if (registry_file == NULL) {
2038     registry_file = g_build_filename (g_get_user_cache_dir (),
2039         &quot;gstreamer-&quot; GST_API_VERSION, &quot;registry.&quot; TARGET_CPU &quot;.bin&quot;, NULL);
2040   }
2041 
2042   if (!_gst_disable_registry_cache) {
2043     GST_INFO (&quot;reading registry cache: %s&quot;, registry_file);
2044 #ifndef GSTREAMER_LITE
2045     have_cache = priv_gst_registry_binary_read_cache (default_registry,
2046         registry_file);
2047 #else // GSTREAMER_LITE
2048     have_cache = FALSE;
2049 #endif // GSTREAMER_LITE
2050     /* Only ever read the registry cache once, then disable it for
2051      * subsequent updates during the program lifetime */
2052     _gst_disable_registry_cache = TRUE;
2053   }
2054 
2055   if (have_cache) {
2056     do_update = !_priv_gst_disable_registry_update;
2057     if (do_update) {
2058       const gchar *update_env;
2059 
2060       if ((update_env = g_getenv (&quot;GST_REGISTRY_UPDATE&quot;))) {
2061         /* do update for any value different from &quot;no&quot; */
2062         do_update = (strcmp (update_env, &quot;no&quot;) != 0);
2063       }
2064     }
2065   }
2066 
2067   if (do_update) {
2068     const gchar *reuse_env;
2069 
2070     if ((reuse_env = g_getenv (&quot;GST_REGISTRY_REUSE_PLUGIN_SCANNER&quot;))) {
2071       /* do reuse for any value different from &quot;no&quot; */
2072       __registry_reuse_plugin_scanner = (strcmp (reuse_env, &quot;no&quot;) != 0);
2073     }
2074     /* now check registry */
2075     GST_DEBUG (&quot;Updating registry cache&quot;);
2076     scan_and_update_registry (default_registry, registry_file, TRUE, error);
2077   } else {
2078     GST_DEBUG (&quot;Not updating registry cache (disabled)&quot;);
2079   }
2080 
2081   g_free (registry_file);
2082   GST_INFO (&quot;registry reading and updating done, result = %d&quot;, ret);
2083 
2084   return ret;
2085 }
2086 #endif /* GST_DISABLE_REGISTRY */
2087 
2088 /**
2089  * gst_registry_fork_is_enabled:
2090  *
2091  * By default GStreamer will perform scanning and rebuilding of the
2092  * registry file using a helper child process.
2093  *
2094  * Applications might want to disable this behaviour with the
2095  * gst_registry_fork_set_enabled() function, in which case new plugins
2096  * are scanned (and loaded) into the application process.
2097  *
2098  * Returns: %TRUE if GStreamer will use the child helper process when
2099  * rebuilding the registry.
2100  */
2101 gboolean
2102 gst_registry_fork_is_enabled (void)
2103 {
2104   return _gst_enable_registry_fork;
2105 }
2106 
2107 /**
2108  * gst_registry_fork_set_enabled:
2109  * @enabled: whether rebuilding the registry can use a temporary child helper process.
2110  *
2111  * Applications might want to disable/enable spawning of a child helper process
2112  * when rebuilding the registry. See gst_registry_fork_is_enabled() for more
2113  * information.
2114  */
2115 void
2116 gst_registry_fork_set_enabled (gboolean enabled)
2117 {
2118   _gst_enable_registry_fork = enabled;
2119 }
2120 
2121 /**
2122  * gst_update_registry:
2123  *
2124  * Forces GStreamer to re-scan its plugin paths and update the default
2125  * plugin registry.
2126  *
2127  * Applications will almost never need to call this function, it is only
2128  * useful if the application knows new plugins have been installed (or old
2129  * ones removed) since the start of the application (or, to be precise, the
2130  * first call to gst_init()) and the application wants to make use of any
2131  * newly-installed plugins without restarting the application.
2132  *
2133  * Applications should assume that the registry update is neither atomic nor
2134  * thread-safe and should therefore not have any dynamic pipelines running
2135  * (including the playbin and decodebin elements) and should also not create
2136  * any elements or access the GStreamer registry while the update is in
2137  * progress.
2138  *
2139  * Note that this function may block for a significant amount of time.
2140  *
2141  * Returns: %TRUE if the registry has been updated successfully (does not
2142  *          imply that there were changes), otherwise %FALSE.
2143  */
2144 gboolean
2145 gst_update_registry (void)
2146 {
2147   gboolean res;
2148 
2149 #ifndef GST_DISABLE_REGISTRY
2150   if (!_priv_gst_disable_registry) {
<a name="12" id="anc12"></a><span class="line-modified">2151     GError *err = NULL;</span>
2152 
<a name="13" id="anc13"></a><span class="line-modified">2153     res = ensure_current_registry (&amp;err);</span>
<span class="line-modified">2154     if (err) {</span>
<span class="line-modified">2155       GST_WARNING (&quot;registry update failed: %s&quot;, err-&gt;message);</span>
<span class="line-modified">2156       g_error_free (err);</span>
<span class="line-modified">2157     } else {</span>
<span class="line-modified">2158       GST_LOG (&quot;registry update succeeded&quot;);</span>
<span class="line-modified">2159     }</span>
2160   } else {
2161     GST_INFO (&quot;registry update disabled by environment&quot;);
2162     res = TRUE;
2163   }
2164 
2165 #else
2166   GST_WARNING (&quot;registry update failed: %s&quot;, &quot;registry disabled&quot;);
2167   res = TRUE;
2168 #endif /* GST_DISABLE_REGISTRY */
2169 
2170   if (_priv_gst_preload_plugins) {
2171     GST_DEBUG (&quot;Preloading indicated plugins...&quot;);
2172     g_slist_foreach (_priv_gst_preload_plugins, load_plugin_func, NULL);
2173   }
2174 
2175   return res;
2176 }
2177 
2178 /**
2179  * gst_registry_get_feature_list_cookie:
2180  * @registry: the registry
2181  *
2182  * Returns the registry&#39;s feature list cookie. This changes
2183  * every time a feature is added or removed from the registry.
2184  *
2185  * Returns: the feature list cookie.
2186  */
2187 guint32
2188 gst_registry_get_feature_list_cookie (GstRegistry * registry)
2189 {
2190   g_return_val_if_fail (GST_IS_REGISTRY (registry), 0);
2191 
2192   return registry-&gt;priv-&gt;cookie;
2193 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>