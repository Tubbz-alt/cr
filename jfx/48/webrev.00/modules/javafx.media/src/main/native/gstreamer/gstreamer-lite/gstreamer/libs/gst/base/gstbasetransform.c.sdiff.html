<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasetransform.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbasesrc.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbasetransform.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasetransform.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 138 #endif
 139 
 140 #include &lt;stdlib.h&gt;
 141 #include &lt;string.h&gt;
 142 
 143 #include &quot;../../../gst/gst_private.h&quot;
 144 #include &quot;../../../gst/gst-i18n-lib.h&quot;
 145 #include &quot;../../../gst/glib-compat-private.h&quot;
 146 #include &quot;gstbasetransform.h&quot;
 147 
 148 GST_DEBUG_CATEGORY_STATIC (gst_base_transform_debug);
 149 #define GST_CAT_DEFAULT gst_base_transform_debug
 150 
 151 /* BaseTransform signals and args */
 152 enum
 153 {
 154   /* FILL ME */
 155   LAST_SIGNAL
 156 };
 157 
<span class="line-modified"> 158 #define DEFAULT_PROP_QOS    FALSE</span>
 159 
 160 enum
 161 {
 162   PROP_0,
 163   PROP_QOS
 164 };
 165 
<span class="line-removed"> 166 #define GST_BASE_TRANSFORM_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 167     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_TRANSFORM, GstBaseTransformPrivate))</span>
<span class="line-removed"> 168 </span>
 169 struct _GstBaseTransformPrivate
 170 {
 171   /* Set by sub-class */
 172   gboolean passthrough;
 173   gboolean always_in_place;
 174 
 175   GstCaps *cache_caps1;
 176   gsize cache_caps1_size;
 177   GstCaps *cache_caps2;
 178   gsize cache_caps2_size;
 179   gboolean have_same_caps;
 180 
 181   gboolean negotiated;
 182 
 183   /* QoS *//* with LOCK */
 184   gboolean qos_enabled;
 185   gdouble proportion;
 186   GstClockTime earliest_time;
 187   /* previous buffer had a discont */
 188   gboolean discont;
</pre>
<hr />
<pre>
 190   GstPadMode pad_mode;
 191 
 192   gboolean gap_aware;
 193   gboolean prefer_passthrough;
 194 
 195   /* QoS stats */
 196   guint64 processed;
 197   guint64 dropped;
 198 
 199   GstClockTime position_out;
 200 
 201   GstBufferPool *pool;
 202   gboolean pool_active;
 203   GstAllocator *allocator;
 204   GstAllocationParams params;
 205   GstQuery *query;
 206 };
 207 
 208 
 209 static GstElementClass *parent_class = NULL;

 210 
 211 static void gst_base_transform_class_init (GstBaseTransformClass * klass);
 212 static void gst_base_transform_init (GstBaseTransform * trans,
 213     GstBaseTransformClass * klass);
 214 static GstFlowReturn default_submit_input_buffer (GstBaseTransform * trans,
 215     gboolean is_discont, GstBuffer * input);
 216 static GstFlowReturn default_generate_output (GstBaseTransform * trans,
 217     GstBuffer ** outbuf);
 218 
 219 /* we can&#39;t use G_DEFINE_ABSTRACT_TYPE because we need the klass in the _init
 220  * method to get to the padtemplates */
 221 GType
 222 gst_base_transform_get_type (void)
 223 {
 224   static volatile gsize base_transform_type = 0;
 225 
 226   if (g_once_init_enter (&amp;base_transform_type)) {
 227     GType _type;
 228     static const GTypeInfo base_transform_info = {
 229       sizeof (GstBaseTransformClass),
 230       NULL,
 231       NULL,
 232       (GClassInitFunc) gst_base_transform_class_init,
 233       NULL,
 234       NULL,
 235       sizeof (GstBaseTransform),
 236       0,
 237       (GInstanceInitFunc) gst_base_transform_init,
 238     };
 239 
 240     _type = g_type_register_static (GST_TYPE_ELEMENT,
 241         &quot;GstBaseTransform&quot;, &amp;base_transform_info, G_TYPE_FLAG_ABSTRACT);




 242     g_once_init_leave (&amp;base_transform_type, _type);
 243   }
 244   return base_transform_type;
 245 }
 246 






 247 static void gst_base_transform_finalize (GObject * object);
 248 static void gst_base_transform_set_property (GObject * object, guint prop_id,
 249     const GValue * value, GParamSpec * pspec);
 250 static void gst_base_transform_get_property (GObject * object, guint prop_id,
 251     GValue * value, GParamSpec * pspec);
 252 static gboolean gst_base_transform_src_activate_mode (GstPad * pad,
 253     GstObject * parent, GstPadMode mode, gboolean active);
 254 static gboolean gst_base_transform_sink_activate_mode (GstPad * pad,
 255     GstObject * parent, GstPadMode mode, gboolean active);
 256 static gboolean gst_base_transform_activate (GstBaseTransform * trans,
 257     gboolean active);
 258 static gboolean gst_base_transform_get_unit_size (GstBaseTransform * trans,
 259     GstCaps * caps, gsize * size);
 260 
 261 static gboolean gst_base_transform_src_event (GstPad * pad, GstObject * parent,
 262     GstEvent * event);
 263 static gboolean gst_base_transform_src_eventfunc (GstBaseTransform * trans,
 264     GstEvent * event);
 265 static gboolean gst_base_transform_sink_event (GstPad * pad, GstObject * parent,
 266     GstEvent * event);
</pre>
<hr />
<pre>
 299 static gboolean
 300 gst_base_transform_default_transform_meta (GstBaseTransform * trans,
 301     GstBuffer * inbuf, GstMeta * meta, GstBuffer * outbuf);
 302 
 303 /* static guint gst_base_transform_signals[LAST_SIGNAL] = { 0 }; */
 304 
 305 
 306 static void
 307 gst_base_transform_finalize (GObject * object)
 308 {
 309   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 310 }
 311 
 312 static void
 313 gst_base_transform_class_init (GstBaseTransformClass * klass)
 314 {
 315   GObjectClass *gobject_class;
 316 
 317   gobject_class = G_OBJECT_CLASS (klass);
 318 



 319   GST_DEBUG_CATEGORY_INIT (gst_base_transform_debug, &quot;basetransform&quot;, 0,
 320       &quot;basetransform element&quot;);
 321 
 322   GST_DEBUG (&quot;gst_base_transform_class_init&quot;);
 323 
<span class="line-removed"> 324   g_type_class_add_private (klass, sizeof (GstBaseTransformPrivate));</span>
<span class="line-removed"> 325 </span>
 326   parent_class = g_type_class_peek_parent (klass);
 327 
 328   gobject_class-&gt;set_property = gst_base_transform_set_property;
 329   gobject_class-&gt;get_property = gst_base_transform_get_property;
 330 
 331   g_object_class_install_property (gobject_class, PROP_QOS,
 332       g_param_spec_boolean (&quot;qos&quot;, &quot;QoS&quot;, &quot;Handle Quality-of-Service events&quot;,
 333           DEFAULT_PROP_QOS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 334 
 335   gobject_class-&gt;finalize = gst_base_transform_finalize;
 336 
 337   klass-&gt;passthrough_on_same_caps = FALSE;
 338   klass-&gt;transform_ip_on_passthrough = TRUE;
 339 
 340   klass-&gt;transform_caps =
 341       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_caps);
 342   klass-&gt;fixate_caps =
 343       GST_DEBUG_FUNCPTR (gst_base_transform_default_fixate_caps);
 344   klass-&gt;accept_caps =
 345       GST_DEBUG_FUNCPTR (gst_base_transform_acceptcaps_default);
</pre>
<hr />
<pre>
 354       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_meta);
 355 
 356   klass-&gt;sink_event = GST_DEBUG_FUNCPTR (gst_base_transform_sink_eventfunc);
 357   klass-&gt;src_event = GST_DEBUG_FUNCPTR (gst_base_transform_src_eventfunc);
 358   klass-&gt;prepare_output_buffer =
 359       GST_DEBUG_FUNCPTR (default_prepare_output_buffer);
 360   klass-&gt;copy_metadata = GST_DEBUG_FUNCPTR (default_copy_metadata);
 361   klass-&gt;submit_input_buffer = GST_DEBUG_FUNCPTR (default_submit_input_buffer);
 362   klass-&gt;generate_output = GST_DEBUG_FUNCPTR (default_generate_output);
 363 }
 364 
 365 static void
 366 gst_base_transform_init (GstBaseTransform * trans,
 367     GstBaseTransformClass * bclass)
 368 {
 369   GstPadTemplate *pad_template;
 370   GstBaseTransformPrivate *priv;
 371 
 372   GST_DEBUG (&quot;gst_base_transform_init&quot;);
 373 
<span class="line-modified"> 374   priv = trans-&gt;priv = GST_BASE_TRANSFORM_GET_PRIVATE (trans);</span>
 375 
 376   pad_template =
 377       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 378   g_return_if_fail (pad_template != NULL);
 379   trans-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 380   gst_pad_set_event_function (trans-&gt;sinkpad,
 381       GST_DEBUG_FUNCPTR (gst_base_transform_sink_event));
 382   gst_pad_set_chain_function (trans-&gt;sinkpad,
 383       GST_DEBUG_FUNCPTR (gst_base_transform_chain));
 384   gst_pad_set_activatemode_function (trans-&gt;sinkpad,
 385       GST_DEBUG_FUNCPTR (gst_base_transform_sink_activate_mode));
 386   gst_pad_set_query_function (trans-&gt;sinkpad,
 387       GST_DEBUG_FUNCPTR (gst_base_transform_query));
 388   gst_element_add_pad (GST_ELEMENT (trans), trans-&gt;sinkpad);
 389 
 390   pad_template =
 391       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 392   g_return_if_fail (pad_template != NULL);
 393   trans-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 394   gst_pad_set_event_function (trans-&gt;srcpad,
</pre>
<hr />
<pre>
 844       pool = gst_buffer_pool_new ();
 845     }
 846   } else {
 847     pool = NULL;
 848     size = min = max = 0;
 849   }
 850 
 851   /* now configure */
 852   if (pool) {
 853     config = gst_buffer_pool_get_config (pool);
 854     gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 855     gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 856 
 857     /* buffer pool may have to do some changes */
 858     if (!gst_buffer_pool_set_config (pool, config)) {
 859       config = gst_buffer_pool_get_config (pool);
 860 
 861       /* If change are not acceptable, fallback to generic pool */
 862       if (!gst_buffer_pool_config_validate_params (config, outcaps, size, min,
 863               max)) {
<span class="line-modified"> 864         GST_DEBUG_OBJECT (trans, &quot;unsuported pool, making new pool&quot;);</span>
 865 
 866         gst_object_unref (pool);
 867         pool = gst_buffer_pool_new ();
 868         gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 869         gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 870       }
 871 
 872       if (!gst_buffer_pool_set_config (pool, config))
 873         goto config_failed;
 874     }
 875   }
 876 
 877   if (update_allocator)
 878     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
 879   else
 880     gst_query_add_allocation_param (query, allocator, &amp;params);
 881   if (allocator)
 882     gst_object_unref (allocator);
 883 
 884   if (pool) {
</pre>
<hr />
<pre>
1756   /* clear the GAP flag when the subclass does not understand it */
1757   if (!priv-&gt;gap_aware)
1758     GST_BUFFER_FLAG_UNSET (outbuf, GST_BUFFER_FLAG_GAP);
1759 
1760 
1761   data.trans = trans;
1762   data.outbuf = outbuf;
1763 
1764   gst_buffer_foreach_meta (inbuf, foreach_metadata, &amp;data);
1765 
1766   return TRUE;
1767 
1768   /* ERRORS */
1769 not_writable:
1770   {
1771     GST_WARNING_OBJECT (trans, &quot;buffer %p not writable&quot;, outbuf);
1772     return FALSE;
1773   }
1774 }
1775 
<span class="line-modified">1776 /* Given @caps calcultate the size of one unit.</span>
1777  *
1778  * For video caps, this is the size of one frame (and thus one buffer).
1779  * For audio caps, this is the size of one sample.
1780  *
1781  * These values are cached since they do not change and the calculation
1782  * potentially involves parsing caps and other expensive stuff.
1783  *
1784  * We have two cache locations to store the size, one for the source caps
1785  * and one for the sink caps.
1786  *
1787  * this function returns %FALSE if no size could be calculated.
1788  */
1789 static gboolean
1790 gst_base_transform_get_unit_size (GstBaseTransform * trans, GstCaps * caps,
1791     gsize * size)
1792 {
1793   gboolean res = FALSE;
1794   GstBaseTransformClass *bclass;
1795   GstBaseTransformPrivate *priv = trans-&gt;priv;
1796 
</pre>
<hr />
<pre>
2822     GstAllocator ** allocator, GstAllocationParams * params)
2823 {
2824   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2825 
2826   if (allocator)
2827     *allocator = trans-&gt;priv-&gt;allocator ?
2828         gst_object_ref (trans-&gt;priv-&gt;allocator) : NULL;
2829 
2830   if (params)
2831     *params = trans-&gt;priv-&gt;params;
2832 }
2833 
2834 /**
2835  * gst_base_transform_update_src_caps:
2836  * @trans: a #GstBaseTransform
2837  * @updated_caps: An updated version of the srcpad caps to be pushed
2838  * downstream
2839  *
2840  * Updates the srcpad caps and send the caps downstream. This function
2841  * can be used by subclasses when they have already negotiated their caps
<span class="line-modified">2842  * but found a change in them (or computed new informations). This way,</span>
<span class="line-modified">2843  * they can notify downstream about that change without loosing any</span>
2844  * buffer.
2845  *
2846  * Returns: %TRUE if the caps could be send downstream %FALSE otherwise
2847  *
2848  * Since: 1.6
2849  */
2850 gboolean
2851 gst_base_transform_update_src_caps (GstBaseTransform * trans,
2852     GstCaps * updated_caps)
2853 {
2854   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2855 
2856   if (gst_pad_push_event (GST_BASE_TRANSFORM_SRC_PAD (trans),
2857           gst_event_new_caps (updated_caps))) {
2858     gst_pad_mark_reconfigure (trans-&gt;srcpad);
2859 
2860     return TRUE;
2861   }
2862 
2863   return FALSE;
</pre>
</td>
<td>
<hr />
<pre>
 138 #endif
 139 
 140 #include &lt;stdlib.h&gt;
 141 #include &lt;string.h&gt;
 142 
 143 #include &quot;../../../gst/gst_private.h&quot;
 144 #include &quot;../../../gst/gst-i18n-lib.h&quot;
 145 #include &quot;../../../gst/glib-compat-private.h&quot;
 146 #include &quot;gstbasetransform.h&quot;
 147 
 148 GST_DEBUG_CATEGORY_STATIC (gst_base_transform_debug);
 149 #define GST_CAT_DEFAULT gst_base_transform_debug
 150 
 151 /* BaseTransform signals and args */
 152 enum
 153 {
 154   /* FILL ME */
 155   LAST_SIGNAL
 156 };
 157 
<span class="line-modified"> 158 #define DEFAULT_PROP_QOS  FALSE</span>
 159 
 160 enum
 161 {
 162   PROP_0,
 163   PROP_QOS
 164 };
 165 



 166 struct _GstBaseTransformPrivate
 167 {
 168   /* Set by sub-class */
 169   gboolean passthrough;
 170   gboolean always_in_place;
 171 
 172   GstCaps *cache_caps1;
 173   gsize cache_caps1_size;
 174   GstCaps *cache_caps2;
 175   gsize cache_caps2_size;
 176   gboolean have_same_caps;
 177 
 178   gboolean negotiated;
 179 
 180   /* QoS *//* with LOCK */
 181   gboolean qos_enabled;
 182   gdouble proportion;
 183   GstClockTime earliest_time;
 184   /* previous buffer had a discont */
 185   gboolean discont;
</pre>
<hr />
<pre>
 187   GstPadMode pad_mode;
 188 
 189   gboolean gap_aware;
 190   gboolean prefer_passthrough;
 191 
 192   /* QoS stats */
 193   guint64 processed;
 194   guint64 dropped;
 195 
 196   GstClockTime position_out;
 197 
 198   GstBufferPool *pool;
 199   gboolean pool_active;
 200   GstAllocator *allocator;
 201   GstAllocationParams params;
 202   GstQuery *query;
 203 };
 204 
 205 
 206 static GstElementClass *parent_class = NULL;
<span class="line-added"> 207 static gint private_offset = 0;</span>
 208 
 209 static void gst_base_transform_class_init (GstBaseTransformClass * klass);
 210 static void gst_base_transform_init (GstBaseTransform * trans,
 211     GstBaseTransformClass * klass);
 212 static GstFlowReturn default_submit_input_buffer (GstBaseTransform * trans,
 213     gboolean is_discont, GstBuffer * input);
 214 static GstFlowReturn default_generate_output (GstBaseTransform * trans,
 215     GstBuffer ** outbuf);
 216 
 217 /* we can&#39;t use G_DEFINE_ABSTRACT_TYPE because we need the klass in the _init
 218  * method to get to the padtemplates */
 219 GType
 220 gst_base_transform_get_type (void)
 221 {
 222   static volatile gsize base_transform_type = 0;
 223 
 224   if (g_once_init_enter (&amp;base_transform_type)) {
 225     GType _type;
 226     static const GTypeInfo base_transform_info = {
 227       sizeof (GstBaseTransformClass),
 228       NULL,
 229       NULL,
 230       (GClassInitFunc) gst_base_transform_class_init,
 231       NULL,
 232       NULL,
 233       sizeof (GstBaseTransform),
 234       0,
 235       (GInstanceInitFunc) gst_base_transform_init,
 236     };
 237 
 238     _type = g_type_register_static (GST_TYPE_ELEMENT,
 239         &quot;GstBaseTransform&quot;, &amp;base_transform_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added"> 240 </span>
<span class="line-added"> 241     private_offset =</span>
<span class="line-added"> 242         g_type_add_instance_private (_type, sizeof (GstBaseTransformPrivate));</span>
<span class="line-added"> 243 </span>
 244     g_once_init_leave (&amp;base_transform_type, _type);
 245   }
 246   return base_transform_type;
 247 }
 248 
<span class="line-added"> 249 static inline GstBaseTransformPrivate *</span>
<span class="line-added"> 250 gst_base_transform_get_instance_private (GstBaseTransform * self)</span>
<span class="line-added"> 251 {</span>
<span class="line-added"> 252   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 253 }</span>
<span class="line-added"> 254 </span>
 255 static void gst_base_transform_finalize (GObject * object);
 256 static void gst_base_transform_set_property (GObject * object, guint prop_id,
 257     const GValue * value, GParamSpec * pspec);
 258 static void gst_base_transform_get_property (GObject * object, guint prop_id,
 259     GValue * value, GParamSpec * pspec);
 260 static gboolean gst_base_transform_src_activate_mode (GstPad * pad,
 261     GstObject * parent, GstPadMode mode, gboolean active);
 262 static gboolean gst_base_transform_sink_activate_mode (GstPad * pad,
 263     GstObject * parent, GstPadMode mode, gboolean active);
 264 static gboolean gst_base_transform_activate (GstBaseTransform * trans,
 265     gboolean active);
 266 static gboolean gst_base_transform_get_unit_size (GstBaseTransform * trans,
 267     GstCaps * caps, gsize * size);
 268 
 269 static gboolean gst_base_transform_src_event (GstPad * pad, GstObject * parent,
 270     GstEvent * event);
 271 static gboolean gst_base_transform_src_eventfunc (GstBaseTransform * trans,
 272     GstEvent * event);
 273 static gboolean gst_base_transform_sink_event (GstPad * pad, GstObject * parent,
 274     GstEvent * event);
</pre>
<hr />
<pre>
 307 static gboolean
 308 gst_base_transform_default_transform_meta (GstBaseTransform * trans,
 309     GstBuffer * inbuf, GstMeta * meta, GstBuffer * outbuf);
 310 
 311 /* static guint gst_base_transform_signals[LAST_SIGNAL] = { 0 }; */
 312 
 313 
 314 static void
 315 gst_base_transform_finalize (GObject * object)
 316 {
 317   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 318 }
 319 
 320 static void
 321 gst_base_transform_class_init (GstBaseTransformClass * klass)
 322 {
 323   GObjectClass *gobject_class;
 324 
 325   gobject_class = G_OBJECT_CLASS (klass);
 326 
<span class="line-added"> 327   if (private_offset != 0)</span>
<span class="line-added"> 328     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
<span class="line-added"> 329 </span>
 330   GST_DEBUG_CATEGORY_INIT (gst_base_transform_debug, &quot;basetransform&quot;, 0,
 331       &quot;basetransform element&quot;);
 332 
 333   GST_DEBUG (&quot;gst_base_transform_class_init&quot;);
 334 


 335   parent_class = g_type_class_peek_parent (klass);
 336 
 337   gobject_class-&gt;set_property = gst_base_transform_set_property;
 338   gobject_class-&gt;get_property = gst_base_transform_get_property;
 339 
 340   g_object_class_install_property (gobject_class, PROP_QOS,
 341       g_param_spec_boolean (&quot;qos&quot;, &quot;QoS&quot;, &quot;Handle Quality-of-Service events&quot;,
 342           DEFAULT_PROP_QOS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 343 
 344   gobject_class-&gt;finalize = gst_base_transform_finalize;
 345 
 346   klass-&gt;passthrough_on_same_caps = FALSE;
 347   klass-&gt;transform_ip_on_passthrough = TRUE;
 348 
 349   klass-&gt;transform_caps =
 350       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_caps);
 351   klass-&gt;fixate_caps =
 352       GST_DEBUG_FUNCPTR (gst_base_transform_default_fixate_caps);
 353   klass-&gt;accept_caps =
 354       GST_DEBUG_FUNCPTR (gst_base_transform_acceptcaps_default);
</pre>
<hr />
<pre>
 363       GST_DEBUG_FUNCPTR (gst_base_transform_default_transform_meta);
 364 
 365   klass-&gt;sink_event = GST_DEBUG_FUNCPTR (gst_base_transform_sink_eventfunc);
 366   klass-&gt;src_event = GST_DEBUG_FUNCPTR (gst_base_transform_src_eventfunc);
 367   klass-&gt;prepare_output_buffer =
 368       GST_DEBUG_FUNCPTR (default_prepare_output_buffer);
 369   klass-&gt;copy_metadata = GST_DEBUG_FUNCPTR (default_copy_metadata);
 370   klass-&gt;submit_input_buffer = GST_DEBUG_FUNCPTR (default_submit_input_buffer);
 371   klass-&gt;generate_output = GST_DEBUG_FUNCPTR (default_generate_output);
 372 }
 373 
 374 static void
 375 gst_base_transform_init (GstBaseTransform * trans,
 376     GstBaseTransformClass * bclass)
 377 {
 378   GstPadTemplate *pad_template;
 379   GstBaseTransformPrivate *priv;
 380 
 381   GST_DEBUG (&quot;gst_base_transform_init&quot;);
 382 
<span class="line-modified"> 383   priv = trans-&gt;priv = gst_base_transform_get_instance_private (trans);</span>
 384 
 385   pad_template =
 386       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 387   g_return_if_fail (pad_template != NULL);
 388   trans-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 389   gst_pad_set_event_function (trans-&gt;sinkpad,
 390       GST_DEBUG_FUNCPTR (gst_base_transform_sink_event));
 391   gst_pad_set_chain_function (trans-&gt;sinkpad,
 392       GST_DEBUG_FUNCPTR (gst_base_transform_chain));
 393   gst_pad_set_activatemode_function (trans-&gt;sinkpad,
 394       GST_DEBUG_FUNCPTR (gst_base_transform_sink_activate_mode));
 395   gst_pad_set_query_function (trans-&gt;sinkpad,
 396       GST_DEBUG_FUNCPTR (gst_base_transform_query));
 397   gst_element_add_pad (GST_ELEMENT (trans), trans-&gt;sinkpad);
 398 
 399   pad_template =
 400       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 401   g_return_if_fail (pad_template != NULL);
 402   trans-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 403   gst_pad_set_event_function (trans-&gt;srcpad,
</pre>
<hr />
<pre>
 853       pool = gst_buffer_pool_new ();
 854     }
 855   } else {
 856     pool = NULL;
 857     size = min = max = 0;
 858   }
 859 
 860   /* now configure */
 861   if (pool) {
 862     config = gst_buffer_pool_get_config (pool);
 863     gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 864     gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 865 
 866     /* buffer pool may have to do some changes */
 867     if (!gst_buffer_pool_set_config (pool, config)) {
 868       config = gst_buffer_pool_get_config (pool);
 869 
 870       /* If change are not acceptable, fallback to generic pool */
 871       if (!gst_buffer_pool_config_validate_params (config, outcaps, size, min,
 872               max)) {
<span class="line-modified"> 873         GST_DEBUG_OBJECT (trans, &quot;unsupported pool, making new pool&quot;);</span>
 874 
 875         gst_object_unref (pool);
 876         pool = gst_buffer_pool_new ();
 877         gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
 878         gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
 879       }
 880 
 881       if (!gst_buffer_pool_set_config (pool, config))
 882         goto config_failed;
 883     }
 884   }
 885 
 886   if (update_allocator)
 887     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
 888   else
 889     gst_query_add_allocation_param (query, allocator, &amp;params);
 890   if (allocator)
 891     gst_object_unref (allocator);
 892 
 893   if (pool) {
</pre>
<hr />
<pre>
1765   /* clear the GAP flag when the subclass does not understand it */
1766   if (!priv-&gt;gap_aware)
1767     GST_BUFFER_FLAG_UNSET (outbuf, GST_BUFFER_FLAG_GAP);
1768 
1769 
1770   data.trans = trans;
1771   data.outbuf = outbuf;
1772 
1773   gst_buffer_foreach_meta (inbuf, foreach_metadata, &amp;data);
1774 
1775   return TRUE;
1776 
1777   /* ERRORS */
1778 not_writable:
1779   {
1780     GST_WARNING_OBJECT (trans, &quot;buffer %p not writable&quot;, outbuf);
1781     return FALSE;
1782   }
1783 }
1784 
<span class="line-modified">1785 /* Given @caps calculate the size of one unit.</span>
1786  *
1787  * For video caps, this is the size of one frame (and thus one buffer).
1788  * For audio caps, this is the size of one sample.
1789  *
1790  * These values are cached since they do not change and the calculation
1791  * potentially involves parsing caps and other expensive stuff.
1792  *
1793  * We have two cache locations to store the size, one for the source caps
1794  * and one for the sink caps.
1795  *
1796  * this function returns %FALSE if no size could be calculated.
1797  */
1798 static gboolean
1799 gst_base_transform_get_unit_size (GstBaseTransform * trans, GstCaps * caps,
1800     gsize * size)
1801 {
1802   gboolean res = FALSE;
1803   GstBaseTransformClass *bclass;
1804   GstBaseTransformPrivate *priv = trans-&gt;priv;
1805 
</pre>
<hr />
<pre>
2831     GstAllocator ** allocator, GstAllocationParams * params)
2832 {
2833   g_return_if_fail (GST_IS_BASE_TRANSFORM (trans));
2834 
2835   if (allocator)
2836     *allocator = trans-&gt;priv-&gt;allocator ?
2837         gst_object_ref (trans-&gt;priv-&gt;allocator) : NULL;
2838 
2839   if (params)
2840     *params = trans-&gt;priv-&gt;params;
2841 }
2842 
2843 /**
2844  * gst_base_transform_update_src_caps:
2845  * @trans: a #GstBaseTransform
2846  * @updated_caps: An updated version of the srcpad caps to be pushed
2847  * downstream
2848  *
2849  * Updates the srcpad caps and send the caps downstream. This function
2850  * can be used by subclasses when they have already negotiated their caps
<span class="line-modified">2851  * but found a change in them (or computed new information). This way,</span>
<span class="line-modified">2852  * they can notify downstream about that change without losing any</span>
2853  * buffer.
2854  *
2855  * Returns: %TRUE if the caps could be send downstream %FALSE otherwise
2856  *
2857  * Since: 1.6
2858  */
2859 gboolean
2860 gst_base_transform_update_src_caps (GstBaseTransform * trans,
2861     GstCaps * updated_caps)
2862 {
2863   g_return_val_if_fail (GST_IS_BASE_TRANSFORM (trans), FALSE);
2864 
2865   if (gst_pad_push_event (GST_BASE_TRANSFORM_SRC_PAD (trans),
2866           gst_event_new_caps (updated_caps))) {
2867     gst_pad_mark_reconfigure (trans-&gt;srcpad);
2868 
2869     return TRUE;
2870   }
2871 
2872   return FALSE;
</pre>
</td>
</tr>
</table>
<center><a href="gstbasesrc.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbasetransform.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>