<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../fft/fft-prelude.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="descriptions.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstpbutilscodecutils
  27  * @title: Codec utilities
  28  * @short_description: Miscellaneous codec-specific utility functions
  29  *
  30  * Provides codec-specific ulility functions such as functions to provide the
  31  * codec profile and level in human-readable string form from header data.
  32  *
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &quot;pbutils.h&quot;
  40 #include &lt;gst/base/base.h&gt;

  41 #include &lt;gst/tag/tag.h&gt;
  42 
  43 #include &lt;string.h&gt;
  44 
  45 #define GST_SIMPLE_CAPS_HAS_NAME(caps,name) \
  46     gst_structure_has_name(gst_caps_get_structure((caps),0),(name))
  47 
  48 #define GST_SIMPLE_CAPS_HAS_FIELD(caps,field) \
  49     gst_structure_has_field(gst_caps_get_structure((caps),0),(field))
  50 
  51 static const guint aac_sample_rates[] = { 96000, 88200, 64000, 48000, 44100,
  52   32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350
  53 };
  54 
  55 static const gchar *
  56 digit_to_string (guint digit)
  57 {
  58   static const char itoa[][2] = {
  59     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
  60   };
</pre>
<hr />
<pre>
  90  * @rate: Sample rate
  91  *
  92  * Translates the sample rate to the index corresponding to it in AAC spec.
  93  *
  94  * Returns: The AAC index for this sample rate, -1 if the rate is not a
  95  * valid AAC sample rate.
  96  */
  97 gint
  98 gst_codec_utils_aac_get_index_from_sample_rate (guint rate)
  99 {
 100   guint n;
 101 
 102   for (n = 0; n &lt; G_N_ELEMENTS (aac_sample_rates); n++)
 103     if (aac_sample_rates[n] == rate)
 104       return n;
 105 
 106   GST_WARNING (&quot;Invalid sample rate %u&quot;, rate);
 107   return -1;
 108 }
 109 













































































 110 /**
 111  * gst_codec_utils_aac_get_sample_rate:
 112  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 113  *                as specified in the Elementary Stream Descriptor (esds)
 114  *                in ISO/IEC 14496-1.
 115  * @len: Length of @audio_config
 116  *
 117  * Translates the sample rate index found in AAC headers to the actual sample
 118  * rate.
 119  *
 120  * Returns: The sample rate if sr_idx is valid, 0 otherwise.
 121  *
<span class="line-modified"> 122  * Since 1.10</span>
 123  */
 124 guint
 125 gst_codec_utils_aac_get_sample_rate (const guint8 * audio_config, guint len)
 126 {
<span class="line-modified"> 127   guint rate_index;</span>


 128 
 129   if (len &lt; 2)
 130     return 0;
 131 
<span class="line-modified"> 132   rate_index = ((audio_config[0] &amp; 0x7) &lt;&lt; 1) | ((audio_config[1] &amp; 0x80) &gt;&gt; 7);</span>
<span class="line-modified"> 133   return gst_codec_utils_aac_get_sample_rate_from_index (rate_index);</span>


 134 }
 135 
 136 /**
 137  * gst_codec_utils_aac_get_channels:
 138  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 139  *                as specified in the Elementary Stream Descriptor (esds)
 140  *                in ISO/IEC 14496-1.
 141  * @len: Length of @audio_config in bytes
 142  *
 143  * Returns the channels of the given AAC stream.
 144  *
 145  * Returns: The channels or 0 if the channel could not be determined.
 146  *
<span class="line-modified"> 147  * Since 1.10</span>
 148  */
 149 guint
 150 gst_codec_utils_aac_get_channels (const guint8 * audio_config, guint len)
 151 {
 152   guint channels;
 153 
 154   if (len &lt; 2)
 155     return 0;
 156 
 157   channels = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;
 158   if (channels &gt; 0 &amp;&amp; channels &lt; 7)
 159     return channels;
 160   else if (channels == 7)
 161     return 8;
 162   else
 163     return 0;
 164 }
 165 
 166 /**
 167  * gst_codec_utils_aac_get_profile:
 168  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 169  *                as specified in the Elementary Stream Descriptor (esds)
 170  *                in ISO/IEC 14496-1.
 171  * @len: Length of @audio_config in bytes
 172  *
 173  * Returns the profile of the given AAC stream as a string. The profile is
<span class="line-modified"> 174  * determined using the AudioObjectType field which is in the first 5 bits of</span>
<span class="line-modified"> 175  * @audio_config.</span>
<span class="line-removed"> 176  *</span>
<span class="line-removed"> 177  * &gt; HE-AAC support has not yet been implemented.</span>
 178  *
 179  * Returns: The profile as a const string and %NULL if the profile could not be
 180  * determined.
 181  */
 182 const gchar *
 183 gst_codec_utils_aac_get_profile (const guint8 * audio_config, guint len)
 184 {
<span class="line-modified"> 185   guint profile;</span>



 186 
 187   if (len &lt; 1)
 188     return NULL;
 189 
 190   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 191 
<span class="line-modified"> 192   profile = audio_config[0] &gt;&gt; 3;</span>
<span class="line-modified"> 193   switch (profile) {</span>




 194     case 1:
<span class="line-modified"> 195       return &quot;main&quot;;</span>

 196     case 2:
<span class="line-modified"> 197       return &quot;lc&quot;;</span>

 198     case 3:
<span class="line-modified"> 199       return &quot;ssr&quot;;</span>

 200     case 4:
<span class="line-modified"> 201       return &quot;ltp&quot;;</span>

 202     default:

 203       break;
 204   }
 205 
<span class="line-modified"> 206   GST_DEBUG (&quot;Invalid profile idx: %u&quot;, profile);</span>
<span class="line-removed"> 207   return NULL;</span>
 208 }
 209 
 210 /**
 211  * gst_codec_utils_aac_get_level:
 212  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 213  *                as specified in the Elementary Stream Descriptor (esds)
 214  *                in ISO/IEC 14496-1.
 215  * @len: Length of @audio_config in bytes
 216  *
 217  * Determines the level of a stream as defined in ISO/IEC 14496-3. For AAC LC
 218  * streams, the constraints from the AAC audio profile are applied. For AAC
 219  * Main, LTP, SSR and others, the Main profile is used.
 220  *
 221  * The @audio_config parameter follows the following format, starting from the
 222  * most significant bit of the first byte:
 223  *
<span class="line-modified"> 224  *   * Bit 0:4 contains the AudioObjectType</span>

 225  *   * Bit 5:8 contains the sample frequency index (if this is 0xf, then the
 226  *     next 24 bits define the actual sample frequency, and subsequent
 227  *     fields are appropriately shifted).
 228  *   * Bit 9:12 contains the channel configuration
 229  *
<span class="line-removed"> 230  * &gt; HE-AAC support has not yet been implemented.</span>
<span class="line-removed"> 231  *</span>
 232  * Returns: The level as a const string and %NULL if the level could not be
 233  * determined.
 234  */
 235 const gchar *
 236 gst_codec_utils_aac_get_level (const guint8 * audio_config, guint len)
 237 {
<span class="line-modified"> 238   int profile, sr_idx, channel_config, rate;</span>

 239   /* Number of single channel elements, channel pair elements, low frequency
 240    * elements, independently switched coupling channel elements, and
 241    * dependently switched coupling channel elements.
 242    *
 243    * Note: The 2 CCE types are ignored for now as they require us to actually
 244    * parse the first frame, and they are rarely found in actual streams.
 245    */
 246   int num_sce = 0, num_cpe = 0, num_lfe = 0, num_cce_indep = 0, num_cce_dep = 0;
 247   int num_channels;
 248   /* Processor and RAM Complexity Units (calculated and &quot;reference&quot; for single
 249    * channel) */
<span class="line-modified"> 250   int pcu, rcu, pcu_ref, rcu_ref;</span>
 251   int ret = -1;

 252 
 253   g_return_val_if_fail (audio_config != NULL, NULL);
 254 
 255   if (len &lt; 2)
 256     return NULL;
 257 
 258   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 259 
<span class="line-modified"> 260   profile = audio_config[0] &gt;&gt; 3;</span>
<span class="line-modified"> 261   /* FIXME: add support for sr_idx = 0xf */</span>
<span class="line-removed"> 262   sr_idx = ((audio_config[0] &amp; 0x7) &lt;&lt; 1) | ((audio_config[1] &amp; 0x80) &gt;&gt; 7);</span>
<span class="line-removed"> 263   rate = gst_codec_utils_aac_get_sample_rate_from_index (sr_idx);</span>
<span class="line-removed"> 264   channel_config = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;</span>
<span class="line-removed"> 265 </span>
<span class="line-removed"> 266   if (rate == 0)</span>
 267     return NULL;

 268 
 269   switch (channel_config) {
 270     case 0:
 271       /* Channel config is defined in the AudioObjectType&#39;s SpecificConfig,
 272        * which requires some amount of digging through the headers. I only see
 273        * this done in the MPEG conformance streams - FIXME */
 274       GST_WARNING (&quot;Found a stream with channel configuration in the &quot;
 275           &quot;AudioSpecificConfig. Please file a bug with a link to the media if &quot;
 276           &quot;possible.&quot;);
 277       return NULL;
 278     case 1:
 279       /* front center */
 280       num_sce = 1;
 281       break;
 282     case 2:
 283       /* front left and right */
 284       num_cpe = 1;
 285       break;
 286     case 3:
 287       /* front left, right, and center */
</pre>
<hr />
<pre>
 305       break;
 306     case 7:
 307     case 12:
 308     case 14:
 309       /* front left, right, center and LFE; outside front left and right;
 310        * rear left and right surround */
 311       num_sce = 1;
 312       num_cpe = 3;
 313       num_lfe = 1;
 314       break;
 315     case 11:
 316       num_sce = 2;
 317       num_cpe = 2;
 318       num_lfe = 1;
 319       break;
 320     default:
 321       GST_WARNING (&quot;Unknown channel config in header: %d&quot;, channel_config);
 322       return NULL;
 323   }
 324 
<span class="line-modified"> 325   switch (profile) {</span>
 326     case 0:                    /* NULL */
 327       GST_WARNING (&quot;profile 0 is not a valid profile&quot;);
 328       return NULL;
 329     case 2:                    /* LC */
 330       pcu_ref = 3;
 331       rcu_ref = 3;
 332       break;
 333     case 3:                    /* SSR */
 334       pcu_ref = 4;
 335       rcu_ref = 3;
 336       break;
 337     case 4:                    /* LTP */
 338       pcu_ref = 4;
 339       rcu_ref = 4;
 340       break;
 341     case 1:                    /* Main */
 342     default:
 343       /* Other than a couple of ER profiles, Main is the worst-case */
 344       pcu_ref = 5;
 345       rcu_ref = 5;
 346       break;
 347   }
 348 
 349   /* &quot;fs_ref&quot; is 48000 Hz for AAC Main/LC/SSR/LTP. SBR&#39;s fs_ref is defined as
 350    * 24000/48000 (in/out), for SBR streams. Actual support is a FIXME */
 351 
 352   pcu = ((float) rate / 48000) * pcu_ref *
 353       ((2 * num_cpe) + num_sce + num_lfe + num_cce_indep + (0.3 * num_cce_dep));
 354 
 355   rcu = ((float) rcu_ref) * (num_sce + (0.5 * num_lfe) + (0.5 * num_cce_indep) +
 356       (0.4 * num_cce_dep));
 357 
 358   if (num_cpe &lt; 2)
 359     rcu += (rcu_ref + (rcu_ref - 1)) * num_cpe;
 360   else
 361     rcu += (rcu_ref + (rcu_ref - 1) * ((2 * num_cpe) - 1));
 362 
 363   num_channels = num_sce + (2 * num_cpe) + num_lfe;
 364 
<span class="line-modified"> 365   if (profile == 2) {</span>
 366     /* AAC LC =&gt; return the level as per the &#39;AAC Profile&#39; */
 367     if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 24000 &amp;&amp; pcu &lt;= 3 &amp;&amp; rcu &lt;= 5)
 368       ret = 1;
 369     else if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 6 &amp;&amp; rcu &lt;= 5)
 370       ret = 2;
 371     /* There is no level 3 for the AAC Profile */
 372     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 19 &amp;&amp; rcu &lt;= 15)
 373       ret = 4;
 374     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 38 &amp;&amp; rcu &lt;= 15)
 375       ret = 5;
 376     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 25 &amp;&amp; rcu &lt;= 19)
 377       ret = 6;
 378     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 50 &amp;&amp; rcu &lt;= 19)
 379       ret = 7;
 380   } else {
 381     /* Return the level as per the &#39;Main Profile&#39; */
 382     if (pcu &lt; 40 &amp;&amp; rcu &lt; 20)
 383       ret = 1;
 384     else if (pcu &lt; 80 &amp;&amp; rcu &lt; 64)
 385       ret = 2;
 386     else if (pcu &lt; 160 &amp;&amp; rcu &lt; 128)
 387       ret = 3;
 388     else if (pcu &lt; 320 &amp;&amp; rcu &lt; 256)
 389       ret = 4;
 390   }
 391 
 392   if (ret == -1) {
 393     GST_WARNING (&quot;couldn&#39;t determine level: profile=%u, rate=%u, &quot;
<span class="line-modified"> 394         &quot;channel_config=%u, pcu=%d,rcu=%d&quot;, profile, rate, channel_config, pcu,</span>
<span class="line-modified"> 395         rcu);</span>
 396     return NULL;
 397   } else {
 398     return digit_to_string (ret);
 399   }
 400 }
 401 
 402 /**
 403  * gst_codec_utils_aac_caps_set_level_and_profile:
 404  * @caps: the #GstCaps to which level and profile fields are to be added
 405  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 406  *                as specified in the Elementary Stream Descriptor (esds)
 407  *                in ISO/IEC 14496-1. (See below for more details)
 408  * @len: Length of @audio_config in bytes
 409  *
 410  * Sets the level and profile on @caps if it can be determined from
 411  * @audio_config. See gst_codec_utils_aac_get_level() and
 412  * gst_codec_utils_aac_get_profile() for more details on the parameters.
 413  * @caps must be audio/mpeg caps with an &quot;mpegversion&quot; field of either 2 or 4.
 414  * If mpegversion is 4, the &quot;base-profile&quot; field is also set in @caps.
 415  *
</pre>
<hr />
<pre>
 719  *
 720  * Converts the profile indication (general_profile_idc) in the stream&#39;s
 721  * profile_level_tier structure into a string. The profile_tier_level is
 722  * expected to have the following format, as defined in the H.265
 723  * specification. The profile_tier_level is viewed as a bitstream here,
 724  * with bit 0 being the most significant bit of the first byte.
 725  *
 726  * * Bit 0:1   - general_profile_space
 727  * * Bit 2     - general_tier_flag
 728  * * Bit 3:7   - general_profile_idc
 729  * * Bit 8:39  - gernal_profile_compatibility_flags
 730  * * Bit 40    - general_progressive_source_flag
 731  * * Bit 41    - general_interlaced_source_flag
 732  * * Bit 42    - general_non_packed_constraint_flag
 733  * * Bit 43    - general_frame_only_constraint_flag
 734  * * Bit 44:87 - general_reserved_zero_44bits
 735  * * Bit 88:95 - general_level_idc
 736  *
 737  * Returns: The profile as a const string, or %NULL if there is an error.
 738  *
<span class="line-modified"> 739  * Since 1.4</span>
 740  */
 741 const gchar *
 742 gst_codec_utils_h265_get_profile (const guint8 * profile_tier_level, guint len)
 743 {
 744   const gchar *profile = NULL;
 745   gint profile_idc;
 746 
 747   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 748 
 749   if (len &lt; 2)
 750     return NULL;
 751 
 752   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 753 
 754   profile_idc = (profile_tier_level[0] &amp; 0x1f);
 755 
 756   if (profile_idc == 1)
 757     profile = &quot;main&quot;;
 758   else if (profile_idc == 2)
 759     profile = &quot;main-10&quot;;
 760   else if (profile_idc == 3)
 761     profile = &quot;main-still-picture&quot;;
 762   else
 763     profile = NULL;
 764 
 765   return profile;
 766 }
 767 
 768 /**
 769  * gst_codec_utils_h265_get_tier:
 770  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 771  *   for the stream.
 772  * @len: Length of the data available in @profile_tier_level.
 773  *
 774  * Converts the tier indication (general_tier_flag) in the stream&#39;s
 775  * profile_tier_level structure into a string. The profile_tier_level
 776  * is expected to have the same format as for gst_codec_utils_h264_get_profile().
 777  *
 778  * Returns: The tier as a const string, or %NULL if there is an error.
 779  *
<span class="line-modified"> 780  * Since 1.4</span>
 781  */
 782 const gchar *
 783 gst_codec_utils_h265_get_tier (const guint8 * profile_tier_level, guint len)
 784 {
 785   const gchar *tier = NULL;
 786   gint tier_flag = 0;
 787 
 788   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 789 
 790   if (len &lt; 1)
 791     return NULL;
 792 
 793   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 794 
 795   tier_flag = (profile_tier_level[0] &amp; 0x20) &gt;&gt; 5;
 796 
 797   if (tier_flag)
 798     tier = &quot;high&quot;;
 799   else
 800     tier = &quot;main&quot;;
 801 
 802   return tier;
 803 }
 804 
 805 /**
 806  * gst_codec_utils_h265_get_level:
 807  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 808  *   for the stream
 809  * @len: Length of the data available in @profile_tier_level.
 810  *
 811  * Converts the level indication (general_level_idc) in the stream&#39;s
 812  * profile_tier_level structure into a string. The profiel_tier_level is
 813  * expected to have the same format as for gst_codec_utils_h264_get_profile().
 814  *
 815  * Returns: The level as a const string, or %NULL if there is an error.
 816  *
<span class="line-modified"> 817  * Since 1.4</span>
 818  */
 819 const gchar *
 820 gst_codec_utils_h265_get_level (const guint8 * profile_tier_level, guint len)
 821 {
 822   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 823 
 824   if (len &lt; 12)
 825     return NULL;
 826 
 827   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 828 
 829   if (profile_tier_level[11] == 0)
 830     return NULL;
 831   else if (profile_tier_level[11] % 30 == 0)
 832     return digit_to_string (profile_tier_level[11] / 30);
 833   else {
 834     switch (profile_tier_level[11]) {
 835       case 63:
 836         return &quot;2.1&quot;;
 837         break;
</pre>
<hr />
<pre>
 850       case 183:
 851         return &quot;6.1&quot;;
 852         break;
 853       case 186:
 854         return &quot;6.2&quot;;
 855         break;
 856       default:
 857         return NULL;
 858     }
 859   }
 860 }
 861 
 862 /**
 863  * gst_codec_utils_h265_get_level_idc:
 864  * @level: A level string from caps
 865  *
 866  * Transform a level string from the caps into the level_idc
 867  *
 868  * Returns: the level_idc or 0 if the level is unknown
 869  *
<span class="line-modified"> 870  * Since 1.4</span>
 871  */
 872 guint8
 873 gst_codec_utils_h265_get_level_idc (const gchar * level)
 874 {
 875   g_return_val_if_fail (level != NULL, 0);
 876 
 877   if (!strcmp (level, &quot;1&quot;))
 878     return 30;
 879   else if (!strcmp (level, &quot;2&quot;))
 880     return 60;
 881   else if (!strcmp (level, &quot;2.1&quot;))
 882     return 63;
 883   else if (!strcmp (level, &quot;3&quot;))
 884     return 90;
 885   else if (!strcmp (level, &quot;3.1&quot;))
 886     return 93;
 887   else if (!strcmp (level, &quot;4&quot;))
 888     return 120;
 889   else if (!strcmp (level, &quot;4.1&quot;))
 890     return 123;
</pre>
<hr />
<pre>
 902     return 186;
 903 
 904   GST_WARNING (&quot;Invalid level %s&quot;, level);
 905   return 0;
 906 }
 907 
 908 /**
 909  * gst_codec_utils_h265_caps_set_level_tier_and_profile:
 910  * @caps: the #GstCaps to which the level, tier and profile are to be added
 911  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 912  *   struct
 913  * @len: Length of the data available in @profile_tier_level.
 914  *
 915  * Sets the level, tier and profile in @caps if it can be determined from
 916  * @profile_tier_level. See gst_codec_utils_h265_get_level(),
 917  * gst_codec_utils_h265_get_tier() and gst_codec_utils_h265_get_profile()
 918  * for more details on the parameters.
 919  *
 920  * Returns: %TRUE if the level, tier, profile could be set, %FALSE otherwise.
 921  *
<span class="line-modified"> 922  * Since 1.4</span>
 923  */
 924 gboolean
 925 gst_codec_utils_h265_caps_set_level_tier_and_profile (GstCaps * caps,
 926     const guint8 * profile_tier_level, guint len)
 927 {
 928   const gchar *level, *tier, *profile;
 929 
 930   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 931   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 932   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h265&quot;), FALSE);
 933   g_return_val_if_fail (profile_tier_level != NULL, FALSE);
 934 
 935   level = gst_codec_utils_h265_get_level (profile_tier_level, len);
 936   if (level != NULL)
 937     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 938 
 939   tier = gst_codec_utils_h265_get_tier (profile_tier_level, len);
 940   if (tier != NULL)
 941     gst_caps_set_simple (caps, &quot;tier&quot;, G_TYPE_STRING, tier, NULL);
 942 
</pre>
<hr />
<pre>
1551     g_return_val_if_fail (channel_mapping != NULL, NULL);
1552   }
1553 
1554   gst_byte_writer_init (&amp;bw);
1555   /* See http://wiki.xiph.org/OggOpus */
1556   hdl &amp;= gst_byte_writer_put_data (&amp;bw, (const guint8 *) &quot;OpusHead&quot;, 8);
1557   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, 0x01); /* version number */
1558   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channels);
1559   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, pre_skip);
1560   hdl &amp;= gst_byte_writer_put_uint32_le (&amp;bw, rate);
1561   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, output_gain);
1562   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channel_mapping_family);
1563   if (channel_mapping_family &gt; 0) {
1564     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, stream_count);
1565     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, coupled_count);
1566     hdl &amp;= gst_byte_writer_put_data (&amp;bw, channel_mapping, channels);
1567   }
1568 
1569   if (!hdl) {
1570     GST_WARNING (&quot;Error creating header&quot;);

1571     return NULL;
1572   }
1573 
1574   buffer = gst_byte_writer_reset_and_get_buffer (&amp;bw);
1575   GST_BUFFER_OFFSET (buffer) = 0;
1576   GST_BUFFER_OFFSET_END (buffer) = 0;
1577 
1578   return buffer;
1579 }
1580 
1581 /**
1582  * gst_codec_utils_opus_parse_header:
1583  * @header: the OpusHead #GstBuffer
1584  * @rate: (out): the sample rate
1585  * @channels: (out): the number of channels
1586  * @channel_mapping_family: (out): the channel mapping family
1587  * @stream_count: (out): the number of independent streams
1588  * @coupled_count: (out): the number of stereo streams
1589  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1590  * @pre_skip: (out): Pre-skip in 48kHz samples or 0
</pre>
</td>
<td>
<hr />
<pre>
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstpbutilscodecutils
  27  * @title: Codec utilities
  28  * @short_description: Miscellaneous codec-specific utility functions
  29  *
  30  * Provides codec-specific ulility functions such as functions to provide the
  31  * codec profile and level in human-readable string form from header data.
  32  *
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &quot;pbutils.h&quot;
  40 #include &lt;gst/base/base.h&gt;
<span class="line-added">  41 #include &lt;gst/base/gstbitreader.h&gt;</span>
  42 #include &lt;gst/tag/tag.h&gt;
  43 
  44 #include &lt;string.h&gt;
  45 
  46 #define GST_SIMPLE_CAPS_HAS_NAME(caps,name) \
  47     gst_structure_has_name(gst_caps_get_structure((caps),0),(name))
  48 
  49 #define GST_SIMPLE_CAPS_HAS_FIELD(caps,field) \
  50     gst_structure_has_field(gst_caps_get_structure((caps),0),(field))
  51 
  52 static const guint aac_sample_rates[] = { 96000, 88200, 64000, 48000, 44100,
  53   32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350
  54 };
  55 
  56 static const gchar *
  57 digit_to_string (guint digit)
  58 {
  59   static const char itoa[][2] = {
  60     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
  61   };
</pre>
<hr />
<pre>
  91  * @rate: Sample rate
  92  *
  93  * Translates the sample rate to the index corresponding to it in AAC spec.
  94  *
  95  * Returns: The AAC index for this sample rate, -1 if the rate is not a
  96  * valid AAC sample rate.
  97  */
  98 gint
  99 gst_codec_utils_aac_get_index_from_sample_rate (guint rate)
 100 {
 101   guint n;
 102 
 103   for (n = 0; n &lt; G_N_ELEMENTS (aac_sample_rates); n++)
 104     if (aac_sample_rates[n] == rate)
 105       return n;
 106 
 107   GST_WARNING (&quot;Invalid sample rate %u&quot;, rate);
 108   return -1;
 109 }
 110 
<span class="line-added"> 111 static gboolean</span>
<span class="line-added"> 112 gst_codec_utils_aac_get_audio_object_type (GstBitReader * br,</span>
<span class="line-added"> 113     guint8 * audio_object_type)</span>
<span class="line-added"> 114 {</span>
<span class="line-added"> 115   guint8 aot;</span>
<span class="line-added"> 116 </span>
<span class="line-added"> 117   if (!gst_bit_reader_get_bits_uint8 (br, &amp;aot, 5))</span>
<span class="line-added"> 118     return FALSE;</span>
<span class="line-added"> 119 </span>
<span class="line-added"> 120   if (aot == 31) {</span>
<span class="line-added"> 121     if (!gst_bit_reader_get_bits_uint8 (br, &amp;aot, 6))</span>
<span class="line-added"> 122       return FALSE;</span>
<span class="line-added"> 123     aot += 32;</span>
<span class="line-added"> 124   }</span>
<span class="line-added"> 125 </span>
<span class="line-added"> 126   *audio_object_type = aot;</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128   return TRUE;</span>
<span class="line-added"> 129 }</span>
<span class="line-added"> 130 </span>
<span class="line-added"> 131 static gboolean</span>
<span class="line-added"> 132 gst_codec_utils_aac_get_audio_sample_rate (GstBitReader * br,</span>
<span class="line-added"> 133     guint * sample_rate)</span>
<span class="line-added"> 134 {</span>
<span class="line-added"> 135   guint8 sampling_freq_index;</span>
<span class="line-added"> 136   guint32 sampling_rate;</span>
<span class="line-added"> 137 </span>
<span class="line-added"> 138   if (!gst_bit_reader_get_bits_uint8 (br, &amp;sampling_freq_index, 4))</span>
<span class="line-added"> 139     return FALSE;</span>
<span class="line-added"> 140 </span>
<span class="line-added"> 141   if (sampling_freq_index == 0xf) {</span>
<span class="line-added"> 142     if (!gst_bit_reader_get_bits_uint32 (br, &amp;sampling_rate, 24))</span>
<span class="line-added"> 143       return FALSE;</span>
<span class="line-added"> 144   } else {</span>
<span class="line-added"> 145     sampling_rate =</span>
<span class="line-added"> 146         gst_codec_utils_aac_get_sample_rate_from_index (sampling_freq_index);</span>
<span class="line-added"> 147     if (!sampling_rate)</span>
<span class="line-added"> 148       return FALSE;</span>
<span class="line-added"> 149   }</span>
<span class="line-added"> 150 </span>
<span class="line-added"> 151   *sample_rate = sampling_rate;</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153   return TRUE;</span>
<span class="line-added"> 154 }</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156 static gboolean</span>
<span class="line-added"> 157 gst_codec_utils_aac_get_audio_object_type_full (GstBitReader * br,</span>
<span class="line-added"> 158     guint8 * audio_object_type, guint8 * channel_config, guint * sample_rate)</span>
<span class="line-added"> 159 {</span>
<span class="line-added"> 160   guint8 aot, channels;</span>
<span class="line-added"> 161   guint rate;</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163   if (!gst_codec_utils_aac_get_audio_object_type (br, &amp;aot))</span>
<span class="line-added"> 164     return FALSE;</span>
<span class="line-added"> 165 </span>
<span class="line-added"> 166   if (!gst_codec_utils_aac_get_audio_sample_rate (br, &amp;rate))</span>
<span class="line-added"> 167     return FALSE;</span>
<span class="line-added"> 168 </span>
<span class="line-added"> 169   if (!gst_bit_reader_get_bits_uint8 (br, &amp;channels, 4))</span>
<span class="line-added"> 170     return FALSE;</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172   /* 5 indicates SBR extension (i.e. HE-AAC) */</span>
<span class="line-added"> 173   /* 29 indicates PS extension */</span>
<span class="line-added"> 174   if (aot == 5 || aot == 29) {</span>
<span class="line-added"> 175     if (!gst_codec_utils_aac_get_audio_sample_rate (br, &amp;rate))</span>
<span class="line-added"> 176       return FALSE;</span>
<span class="line-added"> 177     if (!gst_codec_utils_aac_get_audio_object_type (br, &amp;aot))</span>
<span class="line-added"> 178       return FALSE;</span>
<span class="line-added"> 179   }</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181   *audio_object_type = aot;</span>
<span class="line-added"> 182   *sample_rate = rate;</span>
<span class="line-added"> 183   *channel_config = channels;</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185   return TRUE;</span>
<span class="line-added"> 186 }</span>
<span class="line-added"> 187 </span>
 188 /**
 189  * gst_codec_utils_aac_get_sample_rate:
 190  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 191  *                as specified in the Elementary Stream Descriptor (esds)
 192  *                in ISO/IEC 14496-1.
 193  * @len: Length of @audio_config
 194  *
 195  * Translates the sample rate index found in AAC headers to the actual sample
 196  * rate.
 197  *
 198  * Returns: The sample rate if sr_idx is valid, 0 otherwise.
 199  *
<span class="line-modified"> 200  * Since: 1.10</span>
 201  */
 202 guint
 203 gst_codec_utils_aac_get_sample_rate (const guint8 * audio_config, guint len)
 204 {
<span class="line-modified"> 205   guint sample_rate = 0;</span>
<span class="line-added"> 206   guint8 audio_object_type = 0, channel_config = 0;</span>
<span class="line-added"> 207   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);</span>
 208 
 209   if (len &lt; 2)
 210     return 0;
 211 
<span class="line-modified"> 212   gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,</span>
<span class="line-modified"> 213       &amp;channel_config, &amp;sample_rate);</span>
<span class="line-added"> 214 </span>
<span class="line-added"> 215   return sample_rate;</span>
 216 }
 217 
 218 /**
 219  * gst_codec_utils_aac_get_channels:
 220  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 221  *                as specified in the Elementary Stream Descriptor (esds)
 222  *                in ISO/IEC 14496-1.
 223  * @len: Length of @audio_config in bytes
 224  *
 225  * Returns the channels of the given AAC stream.
 226  *
 227  * Returns: The channels or 0 if the channel could not be determined.
 228  *
<span class="line-modified"> 229  * Since: 1.10</span>
 230  */
 231 guint
 232 gst_codec_utils_aac_get_channels (const guint8 * audio_config, guint len)
 233 {
 234   guint channels;
 235 
 236   if (len &lt; 2)
 237     return 0;
 238 
 239   channels = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;
 240   if (channels &gt; 0 &amp;&amp; channels &lt; 7)
 241     return channels;
 242   else if (channels == 7)
 243     return 8;
 244   else
 245     return 0;
 246 }
 247 
 248 /**
 249  * gst_codec_utils_aac_get_profile:
 250  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 251  *                as specified in the Elementary Stream Descriptor (esds)
 252  *                in ISO/IEC 14496-1.
 253  * @len: Length of @audio_config in bytes
 254  *
 255  * Returns the profile of the given AAC stream as a string. The profile is
<span class="line-modified"> 256  * normally determined using the AudioObjectType field which is in the first</span>
<span class="line-modified"> 257  * 5 bits of @audio_config</span>


 258  *
 259  * Returns: The profile as a const string and %NULL if the profile could not be
 260  * determined.
 261  */
 262 const gchar *
 263 gst_codec_utils_aac_get_profile (const guint8 * audio_config, guint len)
 264 {
<span class="line-modified"> 265   const gchar *profile = NULL;</span>
<span class="line-added"> 266   guint sample_rate;</span>
<span class="line-added"> 267   guint8 audio_object_type, channel_config;</span>
<span class="line-added"> 268   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);</span>
 269 
 270   if (len &lt; 1)
 271     return NULL;
 272 
 273   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 274 
<span class="line-modified"> 275   if (!gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,</span>
<span class="line-modified"> 276           &amp;channel_config, &amp;sample_rate)) {</span>
<span class="line-added"> 277     return NULL;</span>
<span class="line-added"> 278   }</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280   switch (audio_object_type) {</span>
 281     case 1:
<span class="line-modified"> 282       profile = &quot;main&quot;;</span>
<span class="line-added"> 283       break;</span>
 284     case 2:
<span class="line-modified"> 285       profile = &quot;lc&quot;;</span>
<span class="line-added"> 286       break;</span>
 287     case 3:
<span class="line-modified"> 288       profile = &quot;ssr&quot;;</span>
<span class="line-added"> 289       break;</span>
 290     case 4:
<span class="line-modified"> 291       profile = &quot;ltp&quot;;</span>
<span class="line-added"> 292       break;</span>
 293     default:
<span class="line-added"> 294       GST_DEBUG (&quot;Invalid profile idx: %u&quot;, audio_object_type);</span>
 295       break;
 296   }
 297 
<span class="line-modified"> 298   return profile;</span>

 299 }
 300 
 301 /**
 302  * gst_codec_utils_aac_get_level:
 303  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 304  *                as specified in the Elementary Stream Descriptor (esds)
 305  *                in ISO/IEC 14496-1.
 306  * @len: Length of @audio_config in bytes
 307  *
 308  * Determines the level of a stream as defined in ISO/IEC 14496-3. For AAC LC
 309  * streams, the constraints from the AAC audio profile are applied. For AAC
 310  * Main, LTP, SSR and others, the Main profile is used.
 311  *
 312  * The @audio_config parameter follows the following format, starting from the
 313  * most significant bit of the first byte:
 314  *
<span class="line-modified"> 315  *   * Bit 0:4 contains the AudioObjectType (if this is 0x5, then the</span>
<span class="line-added"> 316  *     real AudioObjectType is carried after the rate and channel data)</span>
 317  *   * Bit 5:8 contains the sample frequency index (if this is 0xf, then the
 318  *     next 24 bits define the actual sample frequency, and subsequent
 319  *     fields are appropriately shifted).
 320  *   * Bit 9:12 contains the channel configuration
 321  *


 322  * Returns: The level as a const string and %NULL if the level could not be
 323  * determined.
 324  */
 325 const gchar *
 326 gst_codec_utils_aac_get_level (const guint8 * audio_config, guint len)
 327 {
<span class="line-modified"> 328   guint8 audio_object_type = 0xFF, channel_config = 0xFF;</span>
<span class="line-added"> 329   guint rate;</span>
 330   /* Number of single channel elements, channel pair elements, low frequency
 331    * elements, independently switched coupling channel elements, and
 332    * dependently switched coupling channel elements.
 333    *
 334    * Note: The 2 CCE types are ignored for now as they require us to actually
 335    * parse the first frame, and they are rarely found in actual streams.
 336    */
 337   int num_sce = 0, num_cpe = 0, num_lfe = 0, num_cce_indep = 0, num_cce_dep = 0;
 338   int num_channels;
 339   /* Processor and RAM Complexity Units (calculated and &quot;reference&quot; for single
 340    * channel) */
<span class="line-modified"> 341   int pcu = -1, rcu = -1, pcu_ref, rcu_ref;</span>
 342   int ret = -1;
<span class="line-added"> 343   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);</span>
 344 
 345   g_return_val_if_fail (audio_config != NULL, NULL);
 346 
 347   if (len &lt; 2)
 348     return NULL;
 349 
 350   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 351 
<span class="line-modified"> 352   if (!gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,</span>
<span class="line-modified"> 353           &amp;channel_config, &amp;rate)) {</span>





 354     return NULL;
<span class="line-added"> 355   }</span>
 356 
 357   switch (channel_config) {
 358     case 0:
 359       /* Channel config is defined in the AudioObjectType&#39;s SpecificConfig,
 360        * which requires some amount of digging through the headers. I only see
 361        * this done in the MPEG conformance streams - FIXME */
 362       GST_WARNING (&quot;Found a stream with channel configuration in the &quot;
 363           &quot;AudioSpecificConfig. Please file a bug with a link to the media if &quot;
 364           &quot;possible.&quot;);
 365       return NULL;
 366     case 1:
 367       /* front center */
 368       num_sce = 1;
 369       break;
 370     case 2:
 371       /* front left and right */
 372       num_cpe = 1;
 373       break;
 374     case 3:
 375       /* front left, right, and center */
</pre>
<hr />
<pre>
 393       break;
 394     case 7:
 395     case 12:
 396     case 14:
 397       /* front left, right, center and LFE; outside front left and right;
 398        * rear left and right surround */
 399       num_sce = 1;
 400       num_cpe = 3;
 401       num_lfe = 1;
 402       break;
 403     case 11:
 404       num_sce = 2;
 405       num_cpe = 2;
 406       num_lfe = 1;
 407       break;
 408     default:
 409       GST_WARNING (&quot;Unknown channel config in header: %d&quot;, channel_config);
 410       return NULL;
 411   }
 412 
<span class="line-modified"> 413   switch (audio_object_type) {</span>
 414     case 0:                    /* NULL */
 415       GST_WARNING (&quot;profile 0 is not a valid profile&quot;);
 416       return NULL;
 417     case 2:                    /* LC */
 418       pcu_ref = 3;
 419       rcu_ref = 3;
 420       break;
 421     case 3:                    /* SSR */
 422       pcu_ref = 4;
 423       rcu_ref = 3;
 424       break;
 425     case 4:                    /* LTP */
 426       pcu_ref = 4;
 427       rcu_ref = 4;
 428       break;
 429     case 1:                    /* Main */
 430     default:
 431       /* Other than a couple of ER profiles, Main is the worst-case */
 432       pcu_ref = 5;
 433       rcu_ref = 5;
 434       break;
 435   }
 436 
 437   /* &quot;fs_ref&quot; is 48000 Hz for AAC Main/LC/SSR/LTP. SBR&#39;s fs_ref is defined as
 438    * 24000/48000 (in/out), for SBR streams. Actual support is a FIXME */
 439 
 440   pcu = ((float) rate / 48000) * pcu_ref *
 441       ((2 * num_cpe) + num_sce + num_lfe + num_cce_indep + (0.3 * num_cce_dep));
 442 
 443   rcu = ((float) rcu_ref) * (num_sce + (0.5 * num_lfe) + (0.5 * num_cce_indep) +
 444       (0.4 * num_cce_dep));
 445 
 446   if (num_cpe &lt; 2)
 447     rcu += (rcu_ref + (rcu_ref - 1)) * num_cpe;
 448   else
 449     rcu += (rcu_ref + (rcu_ref - 1) * ((2 * num_cpe) - 1));
 450 
 451   num_channels = num_sce + (2 * num_cpe) + num_lfe;
 452 
<span class="line-modified"> 453   if (audio_object_type == 2) {</span>
 454     /* AAC LC =&gt; return the level as per the &#39;AAC Profile&#39; */
 455     if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 24000 &amp;&amp; pcu &lt;= 3 &amp;&amp; rcu &lt;= 5)
 456       ret = 1;
 457     else if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 6 &amp;&amp; rcu &lt;= 5)
 458       ret = 2;
 459     /* There is no level 3 for the AAC Profile */
 460     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 19 &amp;&amp; rcu &lt;= 15)
 461       ret = 4;
 462     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 38 &amp;&amp; rcu &lt;= 15)
 463       ret = 5;
 464     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 25 &amp;&amp; rcu &lt;= 19)
 465       ret = 6;
 466     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 50 &amp;&amp; rcu &lt;= 19)
 467       ret = 7;
 468   } else {
 469     /* Return the level as per the &#39;Main Profile&#39; */
 470     if (pcu &lt; 40 &amp;&amp; rcu &lt; 20)
 471       ret = 1;
 472     else if (pcu &lt; 80 &amp;&amp; rcu &lt; 64)
 473       ret = 2;
 474     else if (pcu &lt; 160 &amp;&amp; rcu &lt; 128)
 475       ret = 3;
 476     else if (pcu &lt; 320 &amp;&amp; rcu &lt; 256)
 477       ret = 4;
 478   }
 479 
 480   if (ret == -1) {
 481     GST_WARNING (&quot;couldn&#39;t determine level: profile=%u, rate=%u, &quot;
<span class="line-modified"> 482         &quot;channel_config=%u, pcu=%d,rcu=%d&quot;, audio_object_type, rate,</span>
<span class="line-modified"> 483         channel_config, pcu, rcu);</span>
 484     return NULL;
 485   } else {
 486     return digit_to_string (ret);
 487   }
 488 }
 489 
 490 /**
 491  * gst_codec_utils_aac_caps_set_level_and_profile:
 492  * @caps: the #GstCaps to which level and profile fields are to be added
 493  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 494  *                as specified in the Elementary Stream Descriptor (esds)
 495  *                in ISO/IEC 14496-1. (See below for more details)
 496  * @len: Length of @audio_config in bytes
 497  *
 498  * Sets the level and profile on @caps if it can be determined from
 499  * @audio_config. See gst_codec_utils_aac_get_level() and
 500  * gst_codec_utils_aac_get_profile() for more details on the parameters.
 501  * @caps must be audio/mpeg caps with an &quot;mpegversion&quot; field of either 2 or 4.
 502  * If mpegversion is 4, the &quot;base-profile&quot; field is also set in @caps.
 503  *
</pre>
<hr />
<pre>
 807  *
 808  * Converts the profile indication (general_profile_idc) in the stream&#39;s
 809  * profile_level_tier structure into a string. The profile_tier_level is
 810  * expected to have the following format, as defined in the H.265
 811  * specification. The profile_tier_level is viewed as a bitstream here,
 812  * with bit 0 being the most significant bit of the first byte.
 813  *
 814  * * Bit 0:1   - general_profile_space
 815  * * Bit 2     - general_tier_flag
 816  * * Bit 3:7   - general_profile_idc
 817  * * Bit 8:39  - gernal_profile_compatibility_flags
 818  * * Bit 40    - general_progressive_source_flag
 819  * * Bit 41    - general_interlaced_source_flag
 820  * * Bit 42    - general_non_packed_constraint_flag
 821  * * Bit 43    - general_frame_only_constraint_flag
 822  * * Bit 44:87 - general_reserved_zero_44bits
 823  * * Bit 88:95 - general_level_idc
 824  *
 825  * Returns: The profile as a const string, or %NULL if there is an error.
 826  *
<span class="line-modified"> 827  * Since: 1.4</span>
 828  */
 829 const gchar *
 830 gst_codec_utils_h265_get_profile (const guint8 * profile_tier_level, guint len)
 831 {
 832   const gchar *profile = NULL;
 833   gint profile_idc;
 834 
 835   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 836 
 837   if (len &lt; 2)
 838     return NULL;
 839 
 840   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 841 
 842   profile_idc = (profile_tier_level[0] &amp; 0x1f);
 843 
 844   if (profile_idc == 1)
 845     profile = &quot;main&quot;;
 846   else if (profile_idc == 2)
 847     profile = &quot;main-10&quot;;
 848   else if (profile_idc == 3)
 849     profile = &quot;main-still-picture&quot;;
 850   else
 851     profile = NULL;
 852 
 853   return profile;
 854 }
 855 
 856 /**
 857  * gst_codec_utils_h265_get_tier:
 858  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 859  *   for the stream.
 860  * @len: Length of the data available in @profile_tier_level.
 861  *
 862  * Converts the tier indication (general_tier_flag) in the stream&#39;s
 863  * profile_tier_level structure into a string. The profile_tier_level
 864  * is expected to have the same format as for gst_codec_utils_h264_get_profile().
 865  *
 866  * Returns: The tier as a const string, or %NULL if there is an error.
 867  *
<span class="line-modified"> 868  * Since: 1.4</span>
 869  */
 870 const gchar *
 871 gst_codec_utils_h265_get_tier (const guint8 * profile_tier_level, guint len)
 872 {
 873   const gchar *tier = NULL;
 874   gint tier_flag = 0;
 875 
 876   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 877 
 878   if (len &lt; 1)
 879     return NULL;
 880 
 881   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 882 
 883   tier_flag = (profile_tier_level[0] &amp; 0x20) &gt;&gt; 5;
 884 
 885   if (tier_flag)
 886     tier = &quot;high&quot;;
 887   else
 888     tier = &quot;main&quot;;
 889 
 890   return tier;
 891 }
 892 
 893 /**
 894  * gst_codec_utils_h265_get_level:
 895  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 896  *   for the stream
 897  * @len: Length of the data available in @profile_tier_level.
 898  *
 899  * Converts the level indication (general_level_idc) in the stream&#39;s
 900  * profile_tier_level structure into a string. The profiel_tier_level is
 901  * expected to have the same format as for gst_codec_utils_h264_get_profile().
 902  *
 903  * Returns: The level as a const string, or %NULL if there is an error.
 904  *
<span class="line-modified"> 905  * Since: 1.4</span>
 906  */
 907 const gchar *
 908 gst_codec_utils_h265_get_level (const guint8 * profile_tier_level, guint len)
 909 {
 910   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 911 
 912   if (len &lt; 12)
 913     return NULL;
 914 
 915   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 916 
 917   if (profile_tier_level[11] == 0)
 918     return NULL;
 919   else if (profile_tier_level[11] % 30 == 0)
 920     return digit_to_string (profile_tier_level[11] / 30);
 921   else {
 922     switch (profile_tier_level[11]) {
 923       case 63:
 924         return &quot;2.1&quot;;
 925         break;
</pre>
<hr />
<pre>
 938       case 183:
 939         return &quot;6.1&quot;;
 940         break;
 941       case 186:
 942         return &quot;6.2&quot;;
 943         break;
 944       default:
 945         return NULL;
 946     }
 947   }
 948 }
 949 
 950 /**
 951  * gst_codec_utils_h265_get_level_idc:
 952  * @level: A level string from caps
 953  *
 954  * Transform a level string from the caps into the level_idc
 955  *
 956  * Returns: the level_idc or 0 if the level is unknown
 957  *
<span class="line-modified"> 958  * Since: 1.4</span>
 959  */
 960 guint8
 961 gst_codec_utils_h265_get_level_idc (const gchar * level)
 962 {
 963   g_return_val_if_fail (level != NULL, 0);
 964 
 965   if (!strcmp (level, &quot;1&quot;))
 966     return 30;
 967   else if (!strcmp (level, &quot;2&quot;))
 968     return 60;
 969   else if (!strcmp (level, &quot;2.1&quot;))
 970     return 63;
 971   else if (!strcmp (level, &quot;3&quot;))
 972     return 90;
 973   else if (!strcmp (level, &quot;3.1&quot;))
 974     return 93;
 975   else if (!strcmp (level, &quot;4&quot;))
 976     return 120;
 977   else if (!strcmp (level, &quot;4.1&quot;))
 978     return 123;
</pre>
<hr />
<pre>
 990     return 186;
 991 
 992   GST_WARNING (&quot;Invalid level %s&quot;, level);
 993   return 0;
 994 }
 995 
 996 /**
 997  * gst_codec_utils_h265_caps_set_level_tier_and_profile:
 998  * @caps: the #GstCaps to which the level, tier and profile are to be added
 999  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
1000  *   struct
1001  * @len: Length of the data available in @profile_tier_level.
1002  *
1003  * Sets the level, tier and profile in @caps if it can be determined from
1004  * @profile_tier_level. See gst_codec_utils_h265_get_level(),
1005  * gst_codec_utils_h265_get_tier() and gst_codec_utils_h265_get_profile()
1006  * for more details on the parameters.
1007  *
1008  * Returns: %TRUE if the level, tier, profile could be set, %FALSE otherwise.
1009  *
<span class="line-modified">1010  * Since: 1.4</span>
1011  */
1012 gboolean
1013 gst_codec_utils_h265_caps_set_level_tier_and_profile (GstCaps * caps,
1014     const guint8 * profile_tier_level, guint len)
1015 {
1016   const gchar *level, *tier, *profile;
1017 
1018   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1019   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
1020   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h265&quot;), FALSE);
1021   g_return_val_if_fail (profile_tier_level != NULL, FALSE);
1022 
1023   level = gst_codec_utils_h265_get_level (profile_tier_level, len);
1024   if (level != NULL)
1025     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
1026 
1027   tier = gst_codec_utils_h265_get_tier (profile_tier_level, len);
1028   if (tier != NULL)
1029     gst_caps_set_simple (caps, &quot;tier&quot;, G_TYPE_STRING, tier, NULL);
1030 
</pre>
<hr />
<pre>
1639     g_return_val_if_fail (channel_mapping != NULL, NULL);
1640   }
1641 
1642   gst_byte_writer_init (&amp;bw);
1643   /* See http://wiki.xiph.org/OggOpus */
1644   hdl &amp;= gst_byte_writer_put_data (&amp;bw, (const guint8 *) &quot;OpusHead&quot;, 8);
1645   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, 0x01); /* version number */
1646   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channels);
1647   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, pre_skip);
1648   hdl &amp;= gst_byte_writer_put_uint32_le (&amp;bw, rate);
1649   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, output_gain);
1650   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channel_mapping_family);
1651   if (channel_mapping_family &gt; 0) {
1652     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, stream_count);
1653     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, coupled_count);
1654     hdl &amp;= gst_byte_writer_put_data (&amp;bw, channel_mapping, channels);
1655   }
1656 
1657   if (!hdl) {
1658     GST_WARNING (&quot;Error creating header&quot;);
<span class="line-added">1659     gst_byte_writer_reset (&amp;bw);</span>
1660     return NULL;
1661   }
1662 
1663   buffer = gst_byte_writer_reset_and_get_buffer (&amp;bw);
1664   GST_BUFFER_OFFSET (buffer) = 0;
1665   GST_BUFFER_OFFSET_END (buffer) = 0;
1666 
1667   return buffer;
1668 }
1669 
1670 /**
1671  * gst_codec_utils_opus_parse_header:
1672  * @header: the OpusHead #GstBuffer
1673  * @rate: (out): the sample rate
1674  * @channels: (out): the number of channels
1675  * @channel_mapping_family: (out): the channel mapping family
1676  * @stream_count: (out): the number of independent streams
1677  * @coupled_count: (out): the number of stereo streams
1678  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1679  * @pre_skip: (out): Pre-skip in 48kHz samples or 0
</pre>
</td>
</tr>
</table>
<center><a href="../fft/fft-prelude.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="descriptions.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>