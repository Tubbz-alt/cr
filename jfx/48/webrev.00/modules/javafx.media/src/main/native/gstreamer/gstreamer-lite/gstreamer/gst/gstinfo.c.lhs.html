<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   5  * Copyright (C) 2008-2009 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   6  *
   7  * gstinfo.c: debugging functions
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstinfo
  27  * @title: GstInfo
  28  * @short_description: Debugging and logging facilities
  29  * @see_also: #gst-running for command line parameters
  30  * and environment variables that affect the debugging output.
  31  *
  32  * GStreamer&#39;s debugging subsystem is an easy way to get information about what
  33  * the application is doing.  It is not meant for programming errors. Use GLib
  34  * methods (g_warning and friends) for that.
  35  *
  36  * The debugging subsystem works only after GStreamer has been initialized
  37  * - for example by calling gst_init().
  38  *
  39  * The debugging subsystem is used to log informational messages while the
  40  * application runs.  Each messages has some properties attached to it. Among
  41  * these properties are the debugging category, the severity (called &quot;level&quot;
  42  * here) and an optional #GObject it belongs to. Each of these messages is sent
  43  * to all registered debugging handlers, which then handle the messages.
  44  * GStreamer attaches a default handler on startup, which outputs requested
  45  * messages to stderr.
  46  *
  47  * Messages are output by using shortcut macros like #GST_DEBUG,
  48  * #GST_CAT_ERROR_OBJECT or similar. These all expand to calling gst_debug_log()
  49  * with the right parameters.
  50  * The only thing a developer will probably want to do is define his own
  51  * categories. This is easily done with 3 lines. At the top of your code,
  52  * declare
  53  * the variables and set the default category.
  54  * |[&lt;!-- language=&quot;C&quot; --&gt;
  55  *   GST_DEBUG_CATEGORY_STATIC (my_category);  // define category (statically)
  56  *   #define GST_CAT_DEFAULT my_category       // set as default
  57  * ]|
  58  * After that you only need to initialize the category.
  59  * |[&lt;!-- language=&quot;C&quot; --&gt;
  60  *   GST_DEBUG_CATEGORY_INIT (my_category, &quot;my category&quot;,
  61  *                            0, &quot;This is my very own&quot;);
  62  * ]|
  63  * Initialization must be done before the category is used first.
  64  * Plugins do this
  65  * in their plugin_init function, libraries and applications should do that
  66  * during their initialization.
  67  *
  68  * The whole debugging subsystem can be disabled at build time with passing the
  69  * --disable-gst-debug switch to configure. If this is done, every function,
  70  * macro and even structs described in this file evaluate to default values or
  71  * nothing at all.
  72  * So don&#39;t take addresses of these functions or use other tricks.
  73  * If you must do that for some reason, there is still an option.
  74  * If the debugging
  75  * subsystem was compiled out, #GST_DISABLE_GST_DEBUG is defined in
  76  * &amp;lt;gst/gst.h&amp;gt;,
  77  * so you can check that before doing your trick.
  78  * Disabling the debugging subsystem will give you a slight (read: unnoticeable)
  79  * speed increase and will reduce the size of your compiled code. The GStreamer
  80  * library itself becomes around 10% smaller.
  81  *
  82  * Please note that there are naming conventions for the names of debugging
  83  * categories. These are explained at GST_DEBUG_CATEGORY_INIT().
  84  */
  85 
  86 #define GST_INFO_C
  87 #include &quot;gst_private.h&quot;
  88 #include &quot;gstinfo.h&quot;
  89 
  90 #undef gst_debug_remove_log_function
  91 #undef gst_debug_add_log_function
  92 
  93 #ifndef GST_DISABLE_GST_DEBUG
  94 #ifdef HAVE_DLFCN_H
  95 #  include &lt;dlfcn.h&gt;
  96 #endif
  97 #include &lt;stdio.h&gt;              /* fprintf */
  98 #include &lt;glib/gstdio.h&gt;
  99 #include &lt;errno.h&gt;
 100 #ifdef HAVE_UNISTD_H
 101 #  include &lt;unistd.h&gt;           /* getpid on UNIX */
 102 #endif
 103 #ifdef HAVE_PROCESS_H
 104 #  include &lt;process.h&gt;          /* getpid on win32 */
 105 #endif
 106 #include &lt;string.h&gt;             /* G_VA_COPY */
 107 #ifdef G_OS_WIN32
 108 #  define WIN32_LEAN_AND_MEAN   /* prevents from including too many things */
 109 #  include &lt;windows.h&gt;          /* GetStdHandle, windows console */
 110 #endif
 111 
 112 #include &quot;gst_private.h&quot;
 113 #include &quot;gstutils.h&quot;
 114 #include &quot;gstquark.h&quot;
 115 #include &quot;gstsegment.h&quot;
 116 #include &quot;gstvalue.h&quot;
 117 #include &quot;gstcapsfeatures.h&quot;
 118 
 119 #ifdef HAVE_VALGRIND_VALGRIND_H
 120 #  include &lt;valgrind/valgrind.h&gt;
 121 #endif
 122 #include &lt;glib/gprintf.h&gt;       /* g_sprintf */
 123 
 124 /* our own printf implementation with custom extensions to %p for caps etc. */
 125 #include &quot;printf/printf.h&quot;
 126 #include &quot;printf/printf-extension.h&quot;
 127 
 128 static char *gst_info_printf_pointer_extension_func (const char *format,
 129     void *ptr);
 130 #else /* GST_DISABLE_GST_DEBUG */
 131 
 132 #include &lt;glib/gprintf.h&gt;
 133 #endif /* !GST_DISABLE_GST_DEBUG */
 134 
 135 #ifdef HAVE_UNWIND
 136 /* No need for remote debugging so turn on the &#39;local only&#39; optimizations in
 137  * libunwind */
 138 #define UNW_LOCAL_ONLY
 139 
 140 #include &lt;libunwind.h&gt;
 141 #include &lt;stdio.h&gt;
 142 #include &lt;stdlib.h&gt;
 143 #include &lt;string.h&gt;
 144 #include &lt;stdarg.h&gt;
 145 #include &lt;unistd.h&gt;
 146 #include &lt;errno.h&gt;
 147 
 148 #ifdef HAVE_DW
 149 #include &lt;elfutils/libdwfl.h&gt;
 150 #endif /* HAVE_DW */
 151 #endif /* HAVE_UNWIND */
 152 
 153 #ifdef HAVE_BACKTRACE
 154 #include &lt;execinfo.h&gt;
 155 #define BT_BUF_SIZE 100
 156 #endif /* HAVE_BACKTRACE */
 157 
<a name="1" id="anc1"></a>





 158 extern gboolean gst_is_initialized (void);
 159 
<a name="2" id="anc2"></a>










 160 /* we want these symbols exported even if debug is disabled, to maintain
 161  * ABI compatibility. Unless GST_REMOVE_DISABLED is defined. */
 162 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
 163 
 164 /* disabled by default, as soon as some threshold is set &gt; NONE,
 165  * it becomes enabled. */
 166 gboolean _gst_debug_enabled = FALSE;
 167 GstDebugLevel _gst_debug_min = GST_LEVEL_NONE;
 168 
 169 GstDebugCategory *GST_CAT_DEFAULT = NULL;
 170 
 171 GstDebugCategory *GST_CAT_GST_INIT = NULL;
 172 GstDebugCategory *GST_CAT_MEMORY = NULL;
 173 GstDebugCategory *GST_CAT_PARENTAGE = NULL;
 174 GstDebugCategory *GST_CAT_STATES = NULL;
 175 GstDebugCategory *GST_CAT_SCHEDULING = NULL;
 176 
 177 GstDebugCategory *GST_CAT_BUFFER = NULL;
 178 GstDebugCategory *GST_CAT_BUFFER_LIST = NULL;
 179 GstDebugCategory *GST_CAT_BUS = NULL;
 180 GstDebugCategory *GST_CAT_CAPS = NULL;
 181 GstDebugCategory *GST_CAT_CLOCK = NULL;
 182 GstDebugCategory *GST_CAT_ELEMENT_PADS = NULL;
 183 GstDebugCategory *GST_CAT_PADS = NULL;
 184 GstDebugCategory *GST_CAT_PERFORMANCE = NULL;
 185 GstDebugCategory *GST_CAT_PIPELINE = NULL;
 186 GstDebugCategory *GST_CAT_PLUGIN_LOADING = NULL;
 187 GstDebugCategory *GST_CAT_PLUGIN_INFO = NULL;
 188 GstDebugCategory *GST_CAT_PROPERTIES = NULL;
 189 GstDebugCategory *GST_CAT_NEGOTIATION = NULL;
 190 GstDebugCategory *GST_CAT_REFCOUNTING = NULL;
 191 GstDebugCategory *GST_CAT_ERROR_SYSTEM = NULL;
 192 GstDebugCategory *GST_CAT_EVENT = NULL;
 193 GstDebugCategory *GST_CAT_MESSAGE = NULL;
 194 GstDebugCategory *GST_CAT_PARAMS = NULL;
 195 GstDebugCategory *GST_CAT_CALL_TRACE = NULL;
 196 GstDebugCategory *GST_CAT_SIGNAL = NULL;
 197 GstDebugCategory *GST_CAT_PROBE = NULL;
 198 GstDebugCategory *GST_CAT_REGISTRY = NULL;
 199 GstDebugCategory *GST_CAT_QOS = NULL;
 200 GstDebugCategory *_priv_GST_CAT_POLL = NULL;
 201 GstDebugCategory *GST_CAT_META = NULL;
 202 GstDebugCategory *GST_CAT_LOCKING = NULL;
 203 GstDebugCategory *GST_CAT_CONTEXT = NULL;
 204 GstDebugCategory *_priv_GST_CAT_PROTECTION = NULL;
 205 
 206 
 207 #endif /* !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED) */
 208 
 209 #ifndef GST_DISABLE_GST_DEBUG
 210 
 211 /* underscore is to prevent conflict with GST_CAT_DEBUG define */
 212 GST_DEBUG_CATEGORY_STATIC (_GST_CAT_DEBUG);
 213 
 214 #if 0
 215 #if defined __sgi__
 216 #include &lt;rld_interface.h&gt;
 217 typedef struct DL_INFO
 218 {
 219   const char *dli_fname;
 220   void *dli_fbase;
 221   const char *dli_sname;
 222   void *dli_saddr;
 223   int dli_version;
 224   int dli_reserved1;
 225   long dli_reserved[4];
 226 }
 227 Dl_info;
 228 
 229 #define _RLD_DLADDR             14
 230 int dladdr (void *address, Dl_info * dl);
 231 
 232 int
 233 dladdr (void *address, Dl_info * dl)
 234 {
 235   void *v;
 236 
 237   v = _rld_new_interface (_RLD_DLADDR, address, dl);
 238   return (int) v;
 239 }
 240 #endif /* __sgi__ */
 241 #endif
 242 
 243 static void gst_debug_reset_threshold (gpointer category, gpointer unused);
 244 static void gst_debug_reset_all_thresholds (void);
 245 
 246 struct _GstDebugMessage
 247 {
 248   gchar *message;
 249   const gchar *format;
 250   va_list arguments;
 251 };
 252 
 253 /* list of all name/level pairs from --gst-debug and GST_DEBUG */
 254 static GMutex __level_name_mutex;
 255 static GSList *__level_name = NULL;
 256 typedef struct
 257 {
 258   GPatternSpec *pat;
 259   GstDebugLevel level;
 260 }
 261 LevelNameEntry;
 262 
 263 /* list of all categories */
 264 static GMutex __cat_mutex;
 265 static GSList *__categories = NULL;
 266 
 267 static GstDebugCategory *_gst_debug_get_category_locked (const gchar * name);
 268 
 269 
 270 /* all registered debug handlers */
 271 typedef struct
 272 {
 273   GstLogFunction func;
 274   gpointer user_data;
 275   GDestroyNotify notify;
 276 }
 277 LogFuncEntry;
 278 static GMutex __log_func_mutex;
 279 static GSList *__log_functions = NULL;
 280 
 281 /* whether to add the default log function in gst_init() */
 282 static gboolean add_default_log_func = TRUE;
 283 
 284 #define PRETTY_TAGS_DEFAULT  TRUE
 285 static gboolean pretty_tags = PRETTY_TAGS_DEFAULT;
 286 
 287 static volatile gint G_GNUC_MAY_ALIAS __default_level = GST_LEVEL_DEFAULT;
 288 static volatile gint G_GNUC_MAY_ALIAS __use_color = GST_DEBUG_COLOR_MODE_ON;
 289 
 290 /* FIXME: export this? */
 291 gboolean
 292 _priv_gst_in_valgrind (void)
 293 {
 294   static enum
 295   {
 296     GST_VG_UNCHECKED,
 297     GST_VG_NO_VALGRIND,
 298     GST_VG_INSIDE
 299   }
 300   in_valgrind = GST_VG_UNCHECKED;
 301 
 302   if (in_valgrind == GST_VG_UNCHECKED) {
 303 #ifdef HAVE_VALGRIND_VALGRIND_H
 304     if (RUNNING_ON_VALGRIND) {
 305       GST_CAT_INFO (GST_CAT_GST_INIT, &quot;we&#39;re running inside valgrind&quot;);
 306       in_valgrind = GST_VG_INSIDE;
 307     } else {
 308       GST_CAT_LOG (GST_CAT_GST_INIT, &quot;not doing extra valgrind stuff&quot;);
 309       in_valgrind = GST_VG_NO_VALGRIND;
 310     }
 311 #else
 312     in_valgrind = GST_VG_NO_VALGRIND;
 313 #endif
 314     g_assert (in_valgrind == GST_VG_NO_VALGRIND ||
 315         in_valgrind == GST_VG_INSIDE);
 316   }
 317   return (in_valgrind == GST_VG_INSIDE);
 318 }
 319 
 320 static gchar *
 321 _replace_pattern_in_gst_debug_file_name (gchar * name, const char *token,
 322     guint val)
 323 {
 324   gchar *token_start;
 325   if ((token_start = strstr (name, token))) {
 326     gsize token_len = strlen (token);
 327     gchar *name_prefix = name;
 328     gchar *name_suffix = token_start + token_len;
 329     token_start[0] = &#39;\0&#39;;
 330     name = g_strdup_printf (&quot;%s%u%s&quot;, name_prefix, val, name_suffix);
 331     g_free (name_prefix);
 332   }
 333   return name;
 334 }
 335 
 336 static gchar *
 337 _priv_gst_debug_file_name (const gchar * env)
 338 {
 339   gchar *name;
 340 
 341   name = g_strdup (env);
 342   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%p&quot;, getpid ());
 343   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%r&quot;, g_random_int ());
 344 
 345   return name;
 346 }
 347 
 348 /* Initialize the debugging system */
 349 void
 350 _priv_gst_debug_init (void)
 351 {
 352   const gchar *env;
 353   FILE *log_file;
 354 
 355   if (add_default_log_func) {
<a name="3" id="anc3"></a><span class="line-modified"> 356   env = g_getenv (&quot;GST_DEBUG_FILE&quot;);</span>
<span class="line-modified"> 357   if (env != NULL &amp;&amp; *env != &#39;\0&#39;) {</span>
<span class="line-modified"> 358     if (strcmp (env, &quot;-&quot;) == 0) {</span>
<span class="line-modified"> 359       log_file = stdout;</span>
<span class="line-modified"> 360     } else {</span>
 361         gchar *name = _priv_gst_debug_file_name (env);
 362         log_file = g_fopen (name, &quot;w&quot;);
 363         g_free (name);
<a name="4" id="anc4"></a><span class="line-modified"> 364       if (log_file == NULL) {</span>
<span class="line-modified"> 365         g_printerr (&quot;Could not open log file &#39;%s&#39; for writing: %s\n&quot;, env,</span>
<span class="line-modified"> 366             g_strerror (errno));</span>
<span class="line-modified"> 367         log_file = stderr;</span>

 368       }
<a name="5" id="anc5"></a>

 369     }
<a name="6" id="anc6"></a><span class="line-removed"> 370   } else {</span>
<span class="line-removed"> 371     log_file = stderr;</span>
<span class="line-removed"> 372   }</span>
 373 
 374     gst_debug_add_log_function (gst_debug_log_default, log_file, NULL);
 375   }
 376 
 377   __gst_printf_pointer_extension_set_func
 378       (gst_info_printf_pointer_extension_func);
 379 
 380   /* do NOT use a single debug function before this line has been run */
 381   GST_CAT_DEFAULT = _gst_debug_category_new (&quot;default&quot;,
 382       GST_DEBUG_UNDERLINE, NULL);
 383   _GST_CAT_DEBUG = _gst_debug_category_new (&quot;GST_DEBUG&quot;,
 384       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, &quot;debugging subsystem&quot;);
 385 
 386   /* FIXME: add descriptions here */
 387   GST_CAT_GST_INIT = _gst_debug_category_new (&quot;GST_INIT&quot;,
 388       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 389   GST_CAT_MEMORY = _gst_debug_category_new (&quot;GST_MEMORY&quot;,
 390       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, &quot;memory&quot;);
 391   GST_CAT_PARENTAGE = _gst_debug_category_new (&quot;GST_PARENTAGE&quot;,
 392       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 393   GST_CAT_STATES = _gst_debug_category_new (&quot;GST_STATES&quot;,
 394       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 395   GST_CAT_SCHEDULING = _gst_debug_category_new (&quot;GST_SCHEDULING&quot;,
 396       GST_DEBUG_BOLD | GST_DEBUG_FG_MAGENTA, NULL);
 397   GST_CAT_BUFFER = _gst_debug_category_new (&quot;GST_BUFFER&quot;,
 398       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 399   GST_CAT_BUFFER_LIST = _gst_debug_category_new (&quot;GST_BUFFER_LIST&quot;,
 400       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 401   GST_CAT_BUS = _gst_debug_category_new (&quot;GST_BUS&quot;, GST_DEBUG_BG_YELLOW, NULL);
 402   GST_CAT_CAPS = _gst_debug_category_new (&quot;GST_CAPS&quot;,
 403       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 404   GST_CAT_CLOCK = _gst_debug_category_new (&quot;GST_CLOCK&quot;,
 405       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, NULL);
 406   GST_CAT_ELEMENT_PADS = _gst_debug_category_new (&quot;GST_ELEMENT_PADS&quot;,
 407       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 408   GST_CAT_PADS = _gst_debug_category_new (&quot;GST_PADS&quot;,
<a name="7" id="anc7"></a><span class="line-modified"> 409       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_RED, NULL);</span>
 410   GST_CAT_PERFORMANCE = _gst_debug_category_new (&quot;GST_PERFORMANCE&quot;,
 411       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 412   GST_CAT_PIPELINE = _gst_debug_category_new (&quot;GST_PIPELINE&quot;,
 413       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 414   GST_CAT_PLUGIN_LOADING = _gst_debug_category_new (&quot;GST_PLUGIN_LOADING&quot;,
 415       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 416   GST_CAT_PLUGIN_INFO = _gst_debug_category_new (&quot;GST_PLUGIN_INFO&quot;,
 417       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 418   GST_CAT_PROPERTIES = _gst_debug_category_new (&quot;GST_PROPERTIES&quot;,
 419       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_BLUE, NULL);
 420   GST_CAT_NEGOTIATION = _gst_debug_category_new (&quot;GST_NEGOTIATION&quot;,
 421       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 422   GST_CAT_REFCOUNTING = _gst_debug_category_new (&quot;GST_REFCOUNTING&quot;,
 423       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
 424   GST_CAT_ERROR_SYSTEM = _gst_debug_category_new (&quot;GST_ERROR_SYSTEM&quot;,
 425       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_WHITE, NULL);
 426 
 427   GST_CAT_EVENT = _gst_debug_category_new (&quot;GST_EVENT&quot;,
 428       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 429   GST_CAT_MESSAGE = _gst_debug_category_new (&quot;GST_MESSAGE&quot;,
 430       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 431   GST_CAT_PARAMS = _gst_debug_category_new (&quot;GST_PARAMS&quot;,
 432       GST_DEBUG_BOLD | GST_DEBUG_FG_BLACK | GST_DEBUG_BG_YELLOW, NULL);
 433   GST_CAT_CALL_TRACE = _gst_debug_category_new (&quot;GST_CALL_TRACE&quot;,
 434       GST_DEBUG_BOLD, NULL);
 435   GST_CAT_SIGNAL = _gst_debug_category_new (&quot;GST_SIGNAL&quot;,
 436       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 437   GST_CAT_PROBE = _gst_debug_category_new (&quot;GST_PROBE&quot;,
 438       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;pad probes&quot;);
 439   GST_CAT_REGISTRY = _gst_debug_category_new (&quot;GST_REGISTRY&quot;, 0, &quot;registry&quot;);
 440   GST_CAT_QOS = _gst_debug_category_new (&quot;GST_QOS&quot;, 0, &quot;QoS&quot;);
 441   _priv_GST_CAT_POLL = _gst_debug_category_new (&quot;GST_POLL&quot;, 0, &quot;poll&quot;);
 442   GST_CAT_META = _gst_debug_category_new (&quot;GST_META&quot;, 0, &quot;meta&quot;);
 443   GST_CAT_LOCKING = _gst_debug_category_new (&quot;GST_LOCKING&quot;, 0, &quot;locking&quot;);
 444   GST_CAT_CONTEXT = _gst_debug_category_new (&quot;GST_CONTEXT&quot;, 0, NULL);
 445   _priv_GST_CAT_PROTECTION =
 446       _gst_debug_category_new (&quot;GST_PROTECTION&quot;, 0, &quot;protection&quot;);
 447 
 448   /* print out the valgrind message if we&#39;re in valgrind */
 449   _priv_gst_in_valgrind ();
 450 
 451   env = g_getenv (&quot;GST_DEBUG_OPTIONS&quot;);
 452   if (env != NULL) {
 453     if (strstr (env, &quot;full_tags&quot;) || strstr (env, &quot;full-tags&quot;))
 454       pretty_tags = FALSE;
 455     else if (strstr (env, &quot;pretty_tags&quot;) || strstr (env, &quot;pretty-tags&quot;))
 456       pretty_tags = TRUE;
 457   }
 458 
 459   if (g_getenv (&quot;GST_DEBUG_NO_COLOR&quot;) != NULL)
 460     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
 461   env = g_getenv (&quot;GST_DEBUG_COLOR_MODE&quot;);
 462   if (env)
 463     gst_debug_set_color_mode_from_string (env);
 464 
 465   env = g_getenv (&quot;GST_DEBUG&quot;);
 466   if (env)
 467     gst_debug_set_threshold_from_string (env, FALSE);
<a name="8" id="anc8"></a><span class="line-modified"> 468   }</span>
 469 
 470 /* we can&#39;t do this further above, because we initialize the GST_CAT_DEFAULT struct */
 471 #define GST_CAT_DEFAULT _GST_CAT_DEBUG
 472 
 473 /**
 474  * gst_debug_log:
 475  * @category: category to log
 476  * @level: level of the message is in
 477  * @file: the file that emitted the message, usually the __FILE__ identifier
 478  * @function: the function that emitted the message
 479  * @line: the line from that the message was emitted, usually __LINE__
 480  * @object: (transfer none) (allow-none): the object this message relates to,
 481  *     or %NULL if none
 482  * @format: a printf style format string
 483  * @...: optional arguments for the format
 484  *
 485  * Logs the given message using the currently registered debugging handlers.
 486  */
 487 void
 488 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
 489     const gchar * file, const gchar * function, gint line,
 490     GObject * object, const gchar * format, ...)
 491 {
 492   va_list var_args;
 493 
 494   va_start (var_args, format);
 495   gst_debug_log_valist (category, level, file, function, line, object, format,
 496       var_args);
 497   va_end (var_args);
 498 }
 499 
 500 /* based on g_basename(), which we can&#39;t use because it was deprecated */
 501 static inline const gchar *
 502 gst_path_basename (const gchar * file_name)
 503 {
 504   register const gchar *base;
 505 
 506   base = strrchr (file_name, G_DIR_SEPARATOR);
 507 
 508   {
 509     const gchar *q = strrchr (file_name, &#39;/&#39;);
 510     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
 511       base = q;
 512   }
 513 
 514   if (base)
 515     return base + 1;
 516 
 517   if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
 518     return file_name + 2;
 519 
 520   return file_name;
 521 }
 522 
 523 /**
 524  * gst_debug_log_valist:
 525  * @category: category to log
 526  * @level: level of the message is in
 527  * @file: the file that emitted the message, usually the __FILE__ identifier
 528  * @function: the function that emitted the message
 529  * @line: the line from that the message was emitted, usually __LINE__
 530  * @object: (transfer none) (allow-none): the object this message relates to,
 531  *     or %NULL if none
 532  * @format: a printf style format string
 533  * @args: optional arguments for the format
 534  *
 535  * Logs the given message using the currently registered debugging handlers.
 536  */
 537 void
 538 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
 539     const gchar * file, const gchar * function, gint line,
 540     GObject * object, const gchar * format, va_list args)
 541 {
 542   GstDebugMessage message;
 543   LogFuncEntry *entry;
 544   GSList *handler;
 545 
 546   g_return_if_fail (category != NULL);
 547 
 548   if (level &gt; gst_debug_category_get_threshold (category))
 549     return;
 550 
 551   g_return_if_fail (file != NULL);
 552   g_return_if_fail (function != NULL);
 553   g_return_if_fail (format != NULL);
 554 
 555   message.message = NULL;
 556   message.format = format;
 557   G_VA_COPY (message.arguments, args);
 558 
 559   handler = __log_functions;
 560   while (handler) {
 561     entry = handler-&gt;data;
 562     handler = g_slist_next (handler);
 563     entry-&gt;func (category, level, file, function, line, object, &amp;message,
 564         entry-&gt;user_data);
 565   }
 566   g_free (message.message);
 567   va_end (message.arguments);
 568 }
 569 
 570 /**
 571  * gst_debug_message_get:
 572  * @message: a debug message
 573  *
 574  * Gets the string representation of a #GstDebugMessage. This function is used
 575  * in debug handlers to extract the message.
 576  *
 577  * Returns: (nullable): the string representation of a #GstDebugMessage.
 578  */
 579 const gchar *
 580 gst_debug_message_get (GstDebugMessage * message)
 581 {
 582   if (message-&gt;message == NULL) {
 583     int len;
 584 
 585     len = __gst_vasprintf (&amp;message-&gt;message, message-&gt;format,
 586         message-&gt;arguments);
 587 
 588     if (len &lt; 0)
 589       message-&gt;message = NULL;
 590   }
 591   return message-&gt;message;
 592 }
 593 
 594 #define MAX_BUFFER_DUMP_STRING_LEN  100
 595 
 596 /* structure_to_pretty_string:
 597  * @str: a serialized #GstStructure
 598  *
 599  * If the serialized structure contains large buffers such as images the hex
 600  * representation of those buffers will be shortened so that the string remains
 601  * readable.
 602  *
 603  * Returns: the filtered string
 604  */
 605 static gchar *
 606 prettify_structure_string (gchar * str)
 607 {
 608   gchar *pos = str, *end;
 609 
 610   while ((pos = strstr (pos, &quot;(buffer)&quot;))) {
 611     guint count = 0;
 612 
 613     pos += strlen (&quot;(buffer)&quot;);
 614     for (end = pos; *end != &#39;\0&#39; &amp;&amp; *end != &#39;;&#39; &amp;&amp; *end != &#39; &#39;; ++end)
 615       ++count;
 616     if (count &gt; MAX_BUFFER_DUMP_STRING_LEN) {
 617       memcpy (pos + MAX_BUFFER_DUMP_STRING_LEN - 6, &quot;..&quot;, 2);
 618       memcpy (pos + MAX_BUFFER_DUMP_STRING_LEN - 4, pos + count - 4, 4);
 619       memmove (pos + MAX_BUFFER_DUMP_STRING_LEN, pos + count,
 620           strlen (pos + count) + 1);
 621       pos += MAX_BUFFER_DUMP_STRING_LEN;
 622     }
 623   }
 624 
 625   return str;
 626 }
 627 
 628 static inline gchar *
 629 gst_info_structure_to_string (const GstStructure * s)
 630 {
 631   if (G_LIKELY (s)) {
 632     gchar *str = gst_structure_to_string (s);
 633     if (G_UNLIKELY (pretty_tags &amp;&amp; s-&gt;name == GST_QUARK (TAGLIST)))
 634       return prettify_structure_string (str);
 635     else
 636       return str;
 637   }
 638   return NULL;
 639 }
 640 
 641 static inline gchar *
 642 gst_info_describe_buffer (GstBuffer * buffer)
 643 {
 644   const gchar *offset_str = &quot;none&quot;;
 645   const gchar *offset_end_str = &quot;none&quot;;
 646   gchar offset_buf[32], offset_end_buf[32];
 647 
 648   if (GST_BUFFER_OFFSET_IS_VALID (buffer)) {
 649     g_snprintf (offset_buf, sizeof (offset_buf), &quot;%&quot; G_GUINT64_FORMAT,
 650         GST_BUFFER_OFFSET (buffer));
 651     offset_str = offset_buf;
 652   }
 653   if (GST_BUFFER_OFFSET_END_IS_VALID (buffer)) {
 654     g_snprintf (offset_end_buf, sizeof (offset_end_buf), &quot;%&quot; G_GUINT64_FORMAT,
 655         GST_BUFFER_OFFSET_END (buffer));
 656     offset_end_str = offset_end_buf;
 657   }
 658 
 659   return g_strdup_printf (&quot;buffer: %p, pts %&quot; GST_TIME_FORMAT &quot;, dts %&quot;
 660       GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT
 661       &quot;, offset %s, offset_end %s, flags 0x%x&quot;, buffer,
 662       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
 663       GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
 664       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)),
 665       gst_buffer_get_size (buffer), offset_str, offset_end_str,
 666       GST_BUFFER_FLAGS (buffer));
 667 }
 668 
 669 static inline gchar *
 670 gst_info_describe_buffer_list (GstBufferList * list)
 671 {
 672   GstClockTime pts = GST_CLOCK_TIME_NONE;
 673   GstClockTime dts = GST_CLOCK_TIME_NONE;
 674   gsize total_size = 0;
 675   guint n, i;
 676 
 677   n = gst_buffer_list_length (list);
 678   for (i = 0; i &lt; n; ++i) {
 679     GstBuffer *buf = gst_buffer_list_get (list, i);
 680 
 681     if (i == 0) {
 682       pts = GST_BUFFER_PTS (buf);
 683       dts = GST_BUFFER_DTS (buf);
 684     }
 685 
 686     total_size += gst_buffer_get_size (buf);
 687   }
 688 
 689   return g_strdup_printf (&quot;bufferlist: %p, %u buffers, pts %&quot; GST_TIME_FORMAT
 690       &quot;, dts %&quot; GST_TIME_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, list, n,
 691       GST_TIME_ARGS (pts), GST_TIME_ARGS (dts), total_size);
 692 }
 693 
 694 static inline gchar *
 695 gst_info_describe_event (GstEvent * event)
 696 {
 697   gchar *s, *ret;
 698 
 699   s = gst_info_structure_to_string (gst_event_get_structure (event));
 700   ret = g_strdup_printf (&quot;%s event: %p, time %&quot; GST_TIME_FORMAT
 701       &quot;, seq-num %d, %s&quot;, GST_EVENT_TYPE_NAME (event), event,
 702       GST_TIME_ARGS (GST_EVENT_TIMESTAMP (event)), GST_EVENT_SEQNUM (event),
 703       (s ? s : &quot;(NULL)&quot;));
 704   g_free (s);
 705   return ret;
 706 }
 707 
 708 static inline gchar *
 709 gst_info_describe_message (GstMessage * message)
 710 {
 711   gchar *s, *ret;
 712 
 713   s = gst_info_structure_to_string (gst_message_get_structure (message));
 714   ret = g_strdup_printf (&quot;%s message: %p, time %&quot; GST_TIME_FORMAT
 715       &quot;, seq-num %d, element &#39;%s&#39;, %s&quot;, GST_MESSAGE_TYPE_NAME (message),
 716       message, GST_TIME_ARGS (GST_MESSAGE_TIMESTAMP (message)),
 717       GST_MESSAGE_SEQNUM (message),
 718       ((message-&gt;src) ? GST_ELEMENT_NAME (message-&gt;src) : &quot;(NULL)&quot;),
 719       (s ? s : &quot;(NULL)&quot;));
 720   g_free (s);
 721   return ret;
 722 }
 723 
 724 static inline gchar *
 725 gst_info_describe_query (GstQuery * query)
 726 {
 727   gchar *s, *ret;
 728 
 729   s = gst_info_structure_to_string (gst_query_get_structure (query));
 730   ret = g_strdup_printf (&quot;%s query: %p, %s&quot;, GST_QUERY_TYPE_NAME (query),
 731       query, (s ? s : &quot;(NULL)&quot;));
 732   g_free (s);
 733   return ret;
 734 }
 735 
 736 static inline gchar *
 737 gst_info_describe_stream (GstStream * stream)
 738 {
 739   gchar *ret, *caps_str = NULL, *tags_str = NULL;
 740   GstCaps *caps;
 741   GstTagList *tags;
 742 
 743   caps = gst_stream_get_caps (stream);
 744   if (caps) {
 745     caps_str = gst_caps_to_string (caps);
 746     gst_caps_unref (caps);
 747   }
 748 
 749   tags = gst_stream_get_tags (stream);
 750   if (tags) {
 751     tags_str = gst_tag_list_to_string (tags);
 752     gst_tag_list_unref (tags);
 753   }
 754 
 755   ret =
 756       g_strdup_printf (&quot;stream %s %p, ID %s, flags 0x%x, caps [%s], tags [%s]&quot;,
 757       gst_stream_type_get_name (gst_stream_get_stream_type (stream)), stream,
 758       gst_stream_get_stream_id (stream), gst_stream_get_stream_flags (stream),
 759       caps_str ? caps_str : &quot;&quot;, tags_str ? tags_str : &quot;&quot;);
 760 
 761   g_free (caps_str);
 762   g_free (tags_str);
 763 
 764   return ret;
 765 }
 766 
 767 static inline gchar *
 768 gst_info_describe_stream_collection (GstStreamCollection * collection)
 769 {
 770   gchar *ret;
 771   GString *streams_str;
 772   guint i;
 773 
 774   streams_str = g_string_new (&quot;&lt;&quot;);
 775   for (i = 0; i &lt; gst_stream_collection_get_size (collection); i++) {
 776     GstStream *stream = gst_stream_collection_get_stream (collection, i);
 777     gchar *s;
 778 
 779     s = gst_info_describe_stream (stream);
 780     g_string_append_printf (streams_str, &quot; %s,&quot;, s);
 781     g_free (s);
 782   }
 783   g_string_append (streams_str, &quot; &gt;&quot;);
 784 
 785   ret = g_strdup_printf (&quot;collection %p (%d streams) %s&quot;, collection,
 786       gst_stream_collection_get_size (collection), streams_str-&gt;str);
 787 
 788   g_string_free (streams_str, TRUE);
 789   return ret;
 790 }
 791 
 792 static gchar *
 793 gst_debug_print_object (gpointer ptr)
 794 {
 795   GObject *object = (GObject *) ptr;
 796 
 797 #ifdef unused
 798   /* This is a cute trick to detect unmapped memory, but is unportable,
 799    * slow, screws around with madvise, and not actually that useful. */
 800   {
 801     int ret;
 802 
 803     ret = madvise ((void *) ((unsigned long) ptr &amp; (~0xfff)), 4096, 0);
 804     if (ret == -1 &amp;&amp; errno == ENOMEM) {
 805       buffer = g_strdup_printf (&quot;%p (unmapped memory)&quot;, ptr);
 806     }
 807   }
 808 #endif
 809 
 810   /* nicely printed object */
 811   if (object == NULL) {
 812     return g_strdup (&quot;(NULL)&quot;);
 813   }
 814   if (GST_IS_CAPS (ptr)) {
 815     return gst_caps_to_string ((const GstCaps *) ptr);
 816   }
 817   if (GST_IS_STRUCTURE (ptr)) {
 818     return gst_info_structure_to_string ((const GstStructure *) ptr);
 819   }
 820   if (*(GType *) ptr == GST_TYPE_CAPS_FEATURES) {
 821     return gst_caps_features_to_string ((const GstCapsFeatures *) ptr);
 822   }
 823   if (GST_IS_TAG_LIST (ptr)) {
 824     gchar *str = gst_tag_list_to_string ((GstTagList *) ptr);
 825     if (G_UNLIKELY (pretty_tags))
 826       return prettify_structure_string (str);
 827     else
 828       return str;
 829   }
 830   if (*(GType *) ptr == GST_TYPE_DATE_TIME) {
 831     return __gst_date_time_serialize ((GstDateTime *) ptr, TRUE);
 832   }
 833   if (GST_IS_BUFFER (ptr)) {
 834     return gst_info_describe_buffer (GST_BUFFER_CAST (ptr));
 835   }
 836   if (GST_IS_BUFFER_LIST (ptr)) {
 837     return gst_info_describe_buffer_list (GST_BUFFER_LIST_CAST (ptr));
 838   }
 839 #ifdef USE_POISONING
 840   if (*(guint32 *) ptr == 0xffffffff) {
 841     return g_strdup_printf (&quot;&lt;poisoned@%p&gt;&quot;, ptr);
 842   }
 843 #endif
 844   if (GST_IS_MESSAGE (object)) {
 845     return gst_info_describe_message (GST_MESSAGE_CAST (object));
 846   }
 847   if (GST_IS_QUERY (object)) {
 848     return gst_info_describe_query (GST_QUERY_CAST (object));
 849   }
 850   if (GST_IS_EVENT (object)) {
 851     return gst_info_describe_event (GST_EVENT_CAST (object));
 852   }
 853   if (GST_IS_CONTEXT (object)) {
 854     GstContext *context = GST_CONTEXT_CAST (object);
 855     gchar *s, *ret;
 856     const gchar *type;
 857     const GstStructure *structure;
 858 
 859     type = gst_context_get_context_type (context);
 860     structure = gst_context_get_structure (context);
 861 
 862     s = gst_info_structure_to_string (structure);
 863 
 864     ret = g_strdup_printf (&quot;context &#39;%s&#39;=&#39;%s&#39;&quot;, type, s);
 865     g_free (s);
 866     return ret;
 867   }
 868   if (GST_IS_STREAM (object)) {
 869     return gst_info_describe_stream (GST_STREAM_CAST (object));
 870   }
 871   if (GST_IS_STREAM_COLLECTION (object)) {
 872     return
 873         gst_info_describe_stream_collection (GST_STREAM_COLLECTION_CAST
 874         (object));
 875   }
 876   if (GST_IS_PAD (object) &amp;&amp; GST_OBJECT_NAME (object)) {
 877     return g_strdup_printf (&quot;&lt;%s:%s&gt;&quot;, GST_DEBUG_PAD_NAME (object));
 878   }
 879   if (GST_IS_OBJECT (object) &amp;&amp; GST_OBJECT_NAME (object)) {
 880     return g_strdup_printf (&quot;&lt;%s&gt;&quot;, GST_OBJECT_NAME (object));
 881   }
 882   if (G_IS_OBJECT (object)) {
 883     return g_strdup_printf (&quot;&lt;%s@%p&gt;&quot;, G_OBJECT_TYPE_NAME (object), object);
 884   }
 885 
 886   return g_strdup_printf (&quot;%p&quot;, ptr);
 887 }
 888 
 889 static gchar *
 890 gst_debug_print_segment (gpointer ptr)
 891 {
 892   GstSegment *segment = (GstSegment *) ptr;
 893 
 894   /* nicely printed segment */
 895   if (segment == NULL) {
 896     return g_strdup (&quot;(NULL)&quot;);
 897   }
 898 
 899   switch (segment-&gt;format) {
 900     case GST_FORMAT_UNDEFINED:{
 901       return g_strdup_printf (&quot;UNDEFINED segment&quot;);
 902     }
 903     case GST_FORMAT_TIME:{
 904       return g_strdup_printf (&quot;time segment start=%&quot; GST_TIME_FORMAT
 905           &quot;, offset=%&quot; GST_TIME_FORMAT &quot;, stop=%&quot; GST_TIME_FORMAT
 906           &quot;, rate=%f, applied_rate=%f&quot; &quot;, flags=0x%02x, time=%&quot; GST_TIME_FORMAT
 907           &quot;, base=%&quot; GST_TIME_FORMAT &quot;, position %&quot; GST_TIME_FORMAT
 908           &quot;, duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (segment-&gt;start),
 909           GST_TIME_ARGS (segment-&gt;offset), GST_TIME_ARGS (segment-&gt;stop),
 910           segment-&gt;rate, segment-&gt;applied_rate, (guint) segment-&gt;flags,
 911           GST_TIME_ARGS (segment-&gt;time), GST_TIME_ARGS (segment-&gt;base),
 912           GST_TIME_ARGS (segment-&gt;position), GST_TIME_ARGS (segment-&gt;duration));
 913     }
 914     default:{
 915       const gchar *format_name;
 916 
 917       format_name = gst_format_get_name (segment-&gt;format);
 918       if (G_UNLIKELY (format_name == NULL))
 919         format_name = &quot;(UNKNOWN FORMAT)&quot;;
 920       return g_strdup_printf (&quot;%s segment start=%&quot; G_GINT64_FORMAT
 921           &quot;, offset=%&quot; G_GINT64_FORMAT &quot;, stop=%&quot; G_GINT64_FORMAT
 922           &quot;, rate=%f, applied_rate=%f&quot; &quot;, flags=0x%02x, time=%&quot; G_GINT64_FORMAT
 923           &quot;, base=%&quot; G_GINT64_FORMAT &quot;, position %&quot; G_GINT64_FORMAT
 924           &quot;, duration %&quot; G_GINT64_FORMAT, format_name, segment-&gt;start,
 925           segment-&gt;offset, segment-&gt;stop, segment-&gt;rate, segment-&gt;applied_rate,
 926           (guint) segment-&gt;flags, segment-&gt;time, segment-&gt;base,
 927           segment-&gt;position, segment-&gt;duration);
 928     }
 929   }
 930 }
 931 
 932 static char *
 933 gst_info_printf_pointer_extension_func (const char *format, void *ptr)
 934 {
 935   char *s = NULL;
 936 
 937   if (format[0] == &#39;p&#39; &amp;&amp; format[1] == &#39;\a&#39;) {
 938     switch (format[2]) {
 939       case &#39;A&#39;:                /* GST_PTR_FORMAT     */
 940         s = gst_debug_print_object (ptr);
 941         break;
 942       case &#39;B&#39;:                /* GST_SEGMENT_FORMAT */
 943         s = gst_debug_print_segment (ptr);
 944         break;
 945       case &#39;a&#39;:                /* GST_WRAPPED_PTR_FORMAT */
 946         s = priv_gst_string_take_and_wrap (gst_debug_print_object (ptr));
 947         break;
 948       default:
 949         /* must have been compiled against a newer version with an extension
 950          * we don&#39;t known about yet - just ignore and fallback to %p below */
 951         break;
 952     }
 953   }
 954   if (s == NULL)
 955     s = g_strdup_printf (&quot;%p&quot;, ptr);
 956 
 957   return s;
 958 }
 959 
 960 /**
 961  * gst_debug_construct_term_color:
 962  * @colorinfo: the color info
 963  *
 964  * Constructs a string that can be used for getting the desired color in color
 965  * terminals.
 966  * You need to free the string after use.
 967  *
 968  * Returns: (transfer full) (type gchar*): a string containing the color
 969  *     definition
 970  */
 971 gchar *
 972 gst_debug_construct_term_color (guint colorinfo)
 973 {
 974   GString *color;
 975 
 976   color = g_string_new (&quot;\033[00&quot;);
 977 
 978   if (colorinfo &amp; GST_DEBUG_BOLD) {
 979     g_string_append_len (color, &quot;;01&quot;, 3);
 980   }
 981   if (colorinfo &amp; GST_DEBUG_UNDERLINE) {
 982     g_string_append_len (color, &quot;;04&quot;, 3);
 983   }
 984   if (colorinfo &amp; GST_DEBUG_FG_MASK) {
 985     g_string_append_printf (color, &quot;;3%1d&quot;, colorinfo &amp; GST_DEBUG_FG_MASK);
 986   }
 987   if (colorinfo &amp; GST_DEBUG_BG_MASK) {
 988     g_string_append_printf (color, &quot;;4%1d&quot;,
 989         (colorinfo &amp; GST_DEBUG_BG_MASK) &gt;&gt; 4);
 990   }
 991   g_string_append_c (color, &#39;m&#39;);
 992 
 993   return g_string_free (color, FALSE);
 994 }
 995 
 996 /**
 997  * gst_debug_construct_win_color:
 998  * @colorinfo: the color info
 999  *
1000  * Constructs an integer that can be used for getting the desired color in
1001  * windows&#39; terminals (cmd.exe). As there is no mean to underline, we simply
1002  * ignore this attribute.
1003  *
1004  * This function returns 0 on non-windows machines.
1005  *
1006  * Returns: an integer containing the color definition
1007  */
1008 gint
1009 gst_debug_construct_win_color (guint colorinfo)
1010 {
1011   gint color = 0;
1012 #ifdef G_OS_WIN32
1013   static const guchar ansi_to_win_fg[8] = {
1014     0,                          /* black   */
1015     FOREGROUND_RED,             /* red     */
1016     FOREGROUND_GREEN,           /* green   */
1017     FOREGROUND_RED | FOREGROUND_GREEN,  /* yellow  */
1018     FOREGROUND_BLUE,            /* blue    */
1019     FOREGROUND_RED | FOREGROUND_BLUE,   /* magenta */
1020     FOREGROUND_GREEN | FOREGROUND_BLUE, /* cyan    */
1021     FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE /* white   */
1022   };
1023   static const guchar ansi_to_win_bg[8] = {
1024     0,
1025     BACKGROUND_RED,
1026     BACKGROUND_GREEN,
1027     BACKGROUND_RED | BACKGROUND_GREEN,
1028     BACKGROUND_BLUE,
1029     BACKGROUND_RED | BACKGROUND_BLUE,
1030     BACKGROUND_GREEN | FOREGROUND_BLUE,
1031     BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE
1032   };
1033 
1034   /* we draw black as white, as cmd.exe can only have black bg */
1035   if ((colorinfo &amp; (GST_DEBUG_FG_MASK | GST_DEBUG_BG_MASK)) == 0) {
1036     color = ansi_to_win_fg[7];
1037   }
1038   if (colorinfo &amp; GST_DEBUG_UNDERLINE) {
1039     color |= BACKGROUND_INTENSITY;
1040   }
1041   if (colorinfo &amp; GST_DEBUG_BOLD) {
1042     color |= FOREGROUND_INTENSITY;
1043   }
1044   if (colorinfo &amp; GST_DEBUG_FG_MASK) {
1045     color |= ansi_to_win_fg[colorinfo &amp; GST_DEBUG_FG_MASK];
1046   }
1047   if (colorinfo &amp; GST_DEBUG_BG_MASK) {
1048     color |= ansi_to_win_bg[(colorinfo &amp; GST_DEBUG_BG_MASK) &gt;&gt; 4];
1049   }
1050 #endif
1051   return color;
1052 }
1053 
1054 /* width of %p varies depending on actual value of pointer, which can make
1055  * output unevenly aligned if multiple threads are involved, hence the %14p
1056  * (should really be %18p, but %14p seems a good compromise between too many
1057  * white spaces and likely unalignment on my system) */
1058 #if defined (GLIB_SIZEOF_VOID_P) &amp;&amp; GLIB_SIZEOF_VOID_P == 8
1059 #define PTR_FMT &quot;%14p&quot;
1060 #else
1061 #define PTR_FMT &quot;%10p&quot;
1062 #endif
1063 #define PID_FMT &quot;%5d&quot;
1064 #define CAT_FMT &quot;%20s %s:%d:%s:%s&quot;
1065 
1066 #ifdef G_OS_WIN32
1067 static const guchar levelcolormap_w32[GST_LEVEL_COUNT] = {
1068   /* GST_LEVEL_NONE */
1069   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1070   /* GST_LEVEL_ERROR */
1071   FOREGROUND_RED | FOREGROUND_INTENSITY,
1072   /* GST_LEVEL_WARNING */
1073   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY,
1074   /* GST_LEVEL_INFO */
1075   FOREGROUND_GREEN | FOREGROUND_INTENSITY,
1076   /* GST_LEVEL_DEBUG */
1077   FOREGROUND_GREEN | FOREGROUND_BLUE,
1078   /* GST_LEVEL_LOG */
1079   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1080   /* GST_LEVEL_FIXME */
1081   FOREGROUND_RED | FOREGROUND_GREEN,
1082   /* GST_LEVEL_TRACE */
1083   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1084   /* placeholder for log level 8 */
1085   0,
1086   /* GST_LEVEL_MEMDUMP */
1087   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE
1088 };
1089 
1090 static const guchar available_colors[] = {
1091   FOREGROUND_RED, FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN,
1092   FOREGROUND_BLUE, FOREGROUND_RED | FOREGROUND_BLUE,
1093   FOREGROUND_GREEN | FOREGROUND_BLUE,
1094 };
1095 #endif /* G_OS_WIN32 */
1096 static const gchar *levelcolormap[GST_LEVEL_COUNT] = {
1097   &quot;\033[37m&quot;,                   /* GST_LEVEL_NONE */
1098   &quot;\033[31;01m&quot;,                /* GST_LEVEL_ERROR */
1099   &quot;\033[33;01m&quot;,                /* GST_LEVEL_WARNING */
1100   &quot;\033[32;01m&quot;,                /* GST_LEVEL_INFO */
1101   &quot;\033[36m&quot;,                   /* GST_LEVEL_DEBUG */
1102   &quot;\033[37m&quot;,                   /* GST_LEVEL_LOG */
1103   &quot;\033[33;01m&quot;,                /* GST_LEVEL_FIXME */
1104   &quot;\033[37m&quot;,                   /* GST_LEVEL_TRACE */
1105   &quot;\033[37m&quot;,                   /* placeholder for log level 8 */
1106   &quot;\033[37m&quot;                    /* GST_LEVEL_MEMDUMP */
1107 };
1108 
1109 /**
1110  * gst_debug_log_default:
1111  * @category: category to log
1112  * @level: level of the message
1113  * @file: the file that emitted the message, usually the __FILE__ identifier
1114  * @function: the function that emitted the message
1115  * @line: the line from that the message was emitted, usually __LINE__
1116  * @message: the actual message
1117  * @object: (transfer none) (allow-none): the object this message relates to,
1118  *     or %NULL if none
1119  * @user_data: the FILE* to log to
1120  *
1121  * The default logging handler used by GStreamer. Logging functions get called
1122  * whenever a macro like GST_DEBUG or similar is used. By default this function
1123  * is setup to output the message and additional info to stderr (or the log file
1124  * specified via the GST_DEBUG_FILE environment variable) as received via
1125  * @user_data.
1126  *
1127  * You can add other handlers by using gst_debug_add_log_function().
1128  * And you can remove this handler by calling
1129  * gst_debug_remove_log_function(gst_debug_log_default);
1130  */
1131 void
1132 gst_debug_log_default (GstDebugCategory * category, GstDebugLevel level,
1133     const gchar * file, const gchar * function, gint line,
1134     GObject * object, GstDebugMessage * message, gpointer user_data)
1135 {
1136   gint pid;
1137   GstClockTime elapsed;
1138   gchar *obj = NULL;
1139   GstDebugColorMode color_mode;
1140   const gchar *message_str;
1141   FILE *log_file = user_data ? user_data : stderr;
1142   gchar c;
1143 
1144   /* Get message string first because printing it might call into our custom
1145    * printf format extension mechanism which in turn might log something, e.g.
1146    * from inside gst_structure_to_string() when something can&#39;t be serialised.
1147    * This means we either need to do this outside of any critical section or
1148    * use a recursive lock instead. As we always need the message string in all
1149    * code paths, we might just as well get it here first thing and outside of
1150    * the win_print_mutex critical section. */
1151   message_str = gst_debug_message_get (message);
1152 
1153   /* __FILE__ might be a file name or an absolute path or a
1154    * relative path, irrespective of the exact compiler used,
1155    * in which case we want to shorten it to the filename for
1156    * readability. */
1157   c = file[0];
1158   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {
1159     file = gst_path_basename (file);
1160   }
1161 
1162   pid = getpid ();
1163   color_mode = gst_debug_get_color_mode ();
1164 
1165   if (object) {
1166     obj = gst_debug_print_object (object);
1167   } else {
1168     obj = (gchar *) &quot;&quot;;
1169   }
1170 
1171   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());
1172 
1173   if (color_mode != GST_DEBUG_COLOR_MODE_OFF) {
1174 #ifdef G_OS_WIN32
1175     /* We take a lock to keep colors and content together.
1176      * Maybe there is a better way but for now this will do the right
1177      * thing. */
1178     static GMutex win_print_mutex;
1179     g_mutex_lock (&amp;win_print_mutex);
1180     if (color_mode == GST_DEBUG_COLOR_MODE_UNIX) {
1181 #endif
1182       /* colors, non-windows */
1183       gchar *color = NULL;
1184       const gchar *clear;
1185       gchar pidcolor[10];
1186       const gchar *levelcolor;
1187 
1188       color = gst_debug_construct_term_color (gst_debug_category_get_color
1189           (category));
1190       clear = &quot;\033[00m&quot;;
1191       g_sprintf (pidcolor, &quot;\033[3%1dm&quot;, pid % 6 + 31);
1192       levelcolor = levelcolormap[level];
1193 
1194 #define PRINT_FMT &quot; %s&quot;PID_FMT&quot;%s &quot;PTR_FMT&quot; %s%s%s %s&quot;CAT_FMT&quot;%s %s\n&quot;
1195       fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1196           pidcolor, pid, clear, g_thread_self (), levelcolor,
1197           gst_debug_level_get_name (level), clear, color,
1198           gst_debug_category_get_name (category), file, line, function, obj,
1199           clear, message_str);
1200       fflush (log_file);
1201 #undef PRINT_FMT
1202       g_free (color);
1203 #ifdef G_OS_WIN32
1204     } else {
1205       /* colors, windows. */
1206       const gint clear = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
1207 #define SET_COLOR(c) G_STMT_START { \
1208   if (log_file == stderr) \
1209     SetConsoleTextAttribute (GetStdHandle (STD_ERROR_HANDLE), (c)); \
1210   } G_STMT_END
1211       /* timestamp */
1212       fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT &quot; &quot;, GST_TIME_ARGS (elapsed));
1213       fflush (log_file);
1214       /* pid */
1215       SET_COLOR (available_colors[pid % G_N_ELEMENTS (available_colors)]);
1216       fprintf (log_file, PID_FMT, pid);
1217       fflush (log_file);
1218       /* thread */
1219       SET_COLOR (clear);
1220       fprintf (log_file, &quot; &quot; PTR_FMT &quot; &quot;, g_thread_self ());
1221       fflush (log_file);
1222       /* level */
1223       SET_COLOR (levelcolormap_w32[level]);
1224       fprintf (log_file, &quot;%s &quot;, gst_debug_level_get_name (level));
1225       fflush (log_file);
1226       /* category */
1227       SET_COLOR (gst_debug_construct_win_color (gst_debug_category_get_color
1228               (category)));
1229       fprintf (log_file, CAT_FMT, gst_debug_category_get_name (category),
1230           file, line, function, obj);
1231       fflush (log_file);
1232       /* message */
1233       SET_COLOR (clear);
1234       fprintf (log_file, &quot; %s\n&quot;, message_str);
1235       fflush (log_file);
1236     }
1237     g_mutex_unlock (&amp;win_print_mutex);
1238 #endif
1239   } else {
1240     /* no color, all platforms */
1241 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;
1242     fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1243         pid, g_thread_self (), gst_debug_level_get_name (level),
1244         gst_debug_category_get_name (category), file, line, function, obj,
1245         message_str);
1246     fflush (log_file);
1247 #undef PRINT_FMT
1248   }
1249 
1250   if (object != NULL)
<a name="9" id="anc9"></a><span class="line-modified">1251   g_free (obj);</span>
1252 }
1253 
1254 /**
1255  * gst_debug_level_get_name:
1256  * @level: the level to get the name for
1257  *
1258  * Get the string representation of a debugging level
1259  *
1260  * Returns: the name
1261  */
1262 const gchar *
1263 gst_debug_level_get_name (GstDebugLevel level)
1264 {
1265   switch (level) {
1266     case GST_LEVEL_NONE:
1267       return &quot;&quot;;
1268     case GST_LEVEL_ERROR:
1269       return &quot;ERROR  &quot;;
1270     case GST_LEVEL_WARNING:
1271       return &quot;WARN   &quot;;
1272     case GST_LEVEL_INFO:
1273       return &quot;INFO   &quot;;
1274     case GST_LEVEL_DEBUG:
1275       return &quot;DEBUG  &quot;;
1276     case GST_LEVEL_LOG:
1277       return &quot;LOG    &quot;;
1278     case GST_LEVEL_FIXME:
1279       return &quot;FIXME  &quot;;
1280     case GST_LEVEL_TRACE:
1281       return &quot;TRACE  &quot;;
1282     case GST_LEVEL_MEMDUMP:
1283       return &quot;MEMDUMP&quot;;
1284     default:
1285       g_warning (&quot;invalid level specified for gst_debug_level_get_name&quot;);
1286       return &quot;&quot;;
1287   }
1288 }
1289 
1290 /**
1291  * gst_debug_add_log_function:
1292  * @func: the function to use
1293  * @user_data: user data
1294  * @notify: called when @user_data is not used anymore
1295  *
1296  * Adds the logging function to the list of logging functions.
1297  * Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.
1298  */
1299 void
1300 gst_debug_add_log_function (GstLogFunction func, gpointer user_data,
1301     GDestroyNotify notify)
1302 {
1303   LogFuncEntry *entry;
1304   GSList *list;
1305 
1306   if (func == NULL)
1307     func = gst_debug_log_default;
1308 
1309   entry = g_slice_new (LogFuncEntry);
1310   entry-&gt;func = func;
1311   entry-&gt;user_data = user_data;
1312   entry-&gt;notify = notify;
1313   /* FIXME: we leak the old list here - other threads might access it right now
1314    * in gst_debug_logv. Another solution is to lock the mutex in gst_debug_logv,
1315    * but that is waaay costly.
1316    * It&#39;d probably be clever to use some kind of RCU here, but I don&#39;t know
1317    * anything about that.
1318    */
1319   g_mutex_lock (&amp;__log_func_mutex);
1320   list = g_slist_copy (__log_functions);
1321   __log_functions = g_slist_prepend (list, entry);
1322   g_mutex_unlock (&amp;__log_func_mutex);
1323 
1324   if (gst_is_initialized ())
1325     GST_DEBUG (&quot;prepended log function %p (user data %p) to log functions&quot;,
1326         func, user_data);
1327 }
1328 
1329 static gint
1330 gst_debug_compare_log_function_by_func (gconstpointer entry, gconstpointer func)
1331 {
1332   gpointer entryfunc = (gpointer) (((LogFuncEntry *) entry)-&gt;func);
1333 
1334   return (entryfunc &lt; func) ? -1 : (entryfunc &gt; func) ? 1 : 0;
1335 }
1336 
1337 static gint
1338 gst_debug_compare_log_function_by_data (gconstpointer entry, gconstpointer data)
1339 {
1340   gpointer entrydata = ((LogFuncEntry *) entry)-&gt;user_data;
1341 
1342   return (entrydata &lt; data) ? -1 : (entrydata &gt; data) ? 1 : 0;
1343 }
1344 
1345 static guint
1346 gst_debug_remove_with_compare_func (GCompareFunc func, gpointer data)
1347 {
1348   GSList *found;
1349   GSList *new, *cleanup = NULL;
1350   guint removals = 0;
1351 
1352   g_mutex_lock (&amp;__log_func_mutex);
1353   new = __log_functions;
1354   cleanup = NULL;
1355   while ((found = g_slist_find_custom (new, data, func))) {
1356     if (new == __log_functions) {
1357       /* make a copy when we have the first hit, so that we modify the copy and
1358        * make that the new list later */
1359       new = g_slist_copy (new);
1360       continue;
1361     }
1362     cleanup = g_slist_prepend (cleanup, found-&gt;data);
1363     new = g_slist_delete_link (new, found);
1364     removals++;
1365   }
1366   /* FIXME: We leak the old list here. See _add_log_function for why. */
1367   __log_functions = new;
1368   g_mutex_unlock (&amp;__log_func_mutex);
1369 
1370   while (cleanup) {
1371     LogFuncEntry *entry = cleanup-&gt;data;
1372 
1373     if (entry-&gt;notify)
1374       entry-&gt;notify (entry-&gt;user_data);
1375 
1376     g_slice_free (LogFuncEntry, entry);
1377     cleanup = g_slist_delete_link (cleanup, cleanup);
1378   }
1379   return removals;
1380 }
1381 
1382 /**
1383  * gst_debug_remove_log_function:
1384  * @func: (scope call) (allow-none): the log function to remove, or %NULL to
1385  *     remove the default log function
1386  *
1387  * Removes all registered instances of the given logging functions.
1388  *
1389  * Returns: How many instances of the function were removed
1390  */
1391 guint
1392 gst_debug_remove_log_function (GstLogFunction func)
1393 {
1394   guint removals;
1395 
1396   if (func == NULL)
1397     func = gst_debug_log_default;
1398 
1399   removals =
1400       gst_debug_remove_with_compare_func
1401       (gst_debug_compare_log_function_by_func, (gpointer) func);
1402 
1403   if (gst_is_initialized ()) {
1404     GST_DEBUG (&quot;removed log function %p %d times from log function list&quot;, func,
1405         removals);
1406   } else {
1407     /* If the default log function is removed before gst_init() was called,
1408      * set a flag so we don&#39;t add it in gst_init() later */
1409     if (func == gst_debug_log_default) {
1410       add_default_log_func = FALSE;
1411       ++removals;
1412     }
1413   }
1414 
1415   return removals;
1416 }
1417 
1418 /**
1419  * gst_debug_remove_log_function_by_data:
1420  * @data: user data of the log function to remove
1421  *
1422  * Removes all registered instances of log functions with the given user data.
1423  *
1424  * Returns: How many instances of the function were removed
1425  */
1426 guint
1427 gst_debug_remove_log_function_by_data (gpointer data)
1428 {
1429   guint removals;
1430 
1431   removals =
1432       gst_debug_remove_with_compare_func
1433       (gst_debug_compare_log_function_by_data, data);
1434 
1435   if (gst_is_initialized ())
1436     GST_DEBUG
1437         (&quot;removed %d log functions with user data %p from log function list&quot;,
1438         removals, data);
1439 
1440   return removals;
1441 }
1442 
1443 /**
1444  * gst_debug_set_colored:
1445  * @colored: Whether to use colored output or not
1446  *
1447  * Sets or unsets the use of coloured debugging output.
1448  * Same as gst_debug_set_color_mode () with the argument being
1449  * being GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.
1450  *
1451  * This function may be called before gst_init().
1452  */
1453 void
1454 gst_debug_set_colored (gboolean colored)
1455 {
1456   GstDebugColorMode new_mode;
1457   new_mode = colored ? GST_DEBUG_COLOR_MODE_ON : GST_DEBUG_COLOR_MODE_OFF;
1458   g_atomic_int_set (&amp;__use_color, (gint) new_mode);
1459 }
1460 
1461 /**
1462  * gst_debug_set_color_mode:
1463  * @mode: The coloring mode for debug output. See @GstDebugColorMode.
1464  *
1465  * Changes the coloring mode for debug output.
1466  *
1467  * This function may be called before gst_init().
1468  *
1469  * Since: 1.2
1470  */
1471 void
1472 gst_debug_set_color_mode (GstDebugColorMode mode)
1473 {
1474   g_atomic_int_set (&amp;__use_color, mode);
1475 }
1476 
1477 /**
1478  * gst_debug_set_color_mode_from_string:
1479  * @mode: The coloring mode for debug output. One of the following:
1480  * &quot;on&quot;, &quot;auto&quot;, &quot;off&quot;, &quot;disable&quot;, &quot;unix&quot;.
1481  *
1482  * Changes the coloring mode for debug output.
1483  *
1484  * This function may be called before gst_init().
1485  *
1486  * Since: 1.2
1487  */
1488 void
1489 gst_debug_set_color_mode_from_string (const gchar * mode)
1490 {
1491   if ((strcmp (mode, &quot;on&quot;) == 0) || (strcmp (mode, &quot;auto&quot;) == 0))
1492     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_ON);
1493   else if ((strcmp (mode, &quot;off&quot;) == 0) || (strcmp (mode, &quot;disable&quot;) == 0))
1494     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
1495   else if (strcmp (mode, &quot;unix&quot;) == 0)
1496     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_UNIX);
1497 }
1498 
1499 /**
1500  * gst_debug_is_colored:
1501  *
1502  * Checks if the debugging output should be colored.
1503  *
1504  * Returns: %TRUE, if the debug output should be colored.
1505  */
1506 gboolean
1507 gst_debug_is_colored (void)
1508 {
1509   GstDebugColorMode mode = g_atomic_int_get (&amp;__use_color);
1510   return (mode == GST_DEBUG_COLOR_MODE_UNIX || mode == GST_DEBUG_COLOR_MODE_ON);
1511 }
1512 
1513 /**
1514  * gst_debug_get_color_mode:
1515  *
1516  * Changes the coloring mode for debug output.
1517  *
1518  * Returns: see @GstDebugColorMode for possible values.
1519  *
1520  * Since: 1.2
1521  */
1522 GstDebugColorMode
1523 gst_debug_get_color_mode (void)
1524 {
1525   return g_atomic_int_get (&amp;__use_color);
1526 }
1527 
1528 /**
1529  * gst_debug_set_active:
1530  * @active: Whether to use debugging output or not
1531  *
1532  * If activated, debugging messages are sent to the debugging
1533  * handlers.
1534  * It makes sense to deactivate it for speed issues.
1535  * &gt; This function is not threadsafe. It makes sense to only call it
1536  * during initialization.
1537  */
1538 void
1539 gst_debug_set_active (gboolean active)
1540 {
1541   _gst_debug_enabled = active;
1542   if (active)
1543     _gst_debug_min = GST_LEVEL_COUNT;
1544   else
1545     _gst_debug_min = GST_LEVEL_NONE;
1546 }
1547 
1548 /**
1549  * gst_debug_is_active:
1550  *
1551  * Checks if debugging output is activated.
1552  *
1553  * Returns: %TRUE, if debugging is activated
1554  */
1555 gboolean
1556 gst_debug_is_active (void)
1557 {
1558   return _gst_debug_enabled;
1559 }
1560 
1561 /**
1562  * gst_debug_set_default_threshold:
1563  * @level: level to set
1564  *
1565  * Sets the default threshold to the given level and updates all categories to
1566  * use this threshold.
1567  *
1568  * This function may be called before gst_init().
1569  */
1570 void
1571 gst_debug_set_default_threshold (GstDebugLevel level)
1572 {
1573   g_atomic_int_set (&amp;__default_level, level);
1574   gst_debug_reset_all_thresholds ();
1575 }
1576 
1577 /**
1578  * gst_debug_get_default_threshold:
1579  *
1580  * Returns the default threshold that is used for new categories.
1581  *
1582  * Returns: the default threshold level
1583  */
1584 GstDebugLevel
1585 gst_debug_get_default_threshold (void)
1586 {
1587   return (GstDebugLevel) g_atomic_int_get (&amp;__default_level);
1588 }
1589 
<a name="10" id="anc10"></a>













1590 static void
1591 gst_debug_reset_threshold (gpointer category, gpointer unused)
1592 {
1593   GstDebugCategory *cat = (GstDebugCategory *) category;
1594   GSList *walk;
1595 
1596   g_mutex_lock (&amp;__level_name_mutex);
<a name="11" id="anc11"></a><span class="line-removed">1597   walk = __level_name;</span>
<span class="line-removed">1598   while (walk) {</span>
<span class="line-removed">1599     LevelNameEntry *entry = walk-&gt;data;</span>
1600 
<a name="12" id="anc12"></a><span class="line-modified">1601     walk = g_slist_next (walk);</span>
<span class="line-modified">1602     if (g_pattern_match_string (entry-&gt;pat, cat-&gt;name)) {</span>
<span class="line-modified">1603       if (gst_is_initialized ())</span>
<span class="line-removed">1604         GST_LOG (&quot;category %s matches pattern %p - gets set to level %d&quot;,</span>
<span class="line-removed">1605             cat-&gt;name, entry-&gt;pat, entry-&gt;level);</span>
<span class="line-removed">1606       gst_debug_category_set_threshold (cat, entry-&gt;level);</span>
<span class="line-removed">1607       goto exit;</span>
<span class="line-removed">1608     }</span>
1609   }
<a name="13" id="anc13"></a><span class="line-removed">1610   gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());</span>
1611 
<a name="14" id="anc14"></a><span class="line-removed">1612 exit:</span>
1613   g_mutex_unlock (&amp;__level_name_mutex);
<a name="15" id="anc15"></a>


1614 }
1615 
1616 static void
1617 gst_debug_reset_all_thresholds (void)
1618 {
1619   g_mutex_lock (&amp;__cat_mutex);
1620   g_slist_foreach (__categories, gst_debug_reset_threshold, NULL);
1621   g_mutex_unlock (&amp;__cat_mutex);
1622 }
1623 
1624 static void
1625 for_each_threshold_by_entry (gpointer data, gpointer user_data)
1626 {
1627   GstDebugCategory *cat = (GstDebugCategory *) data;
1628   LevelNameEntry *entry = (LevelNameEntry *) user_data;
1629 
<a name="16" id="anc16"></a><span class="line-modified">1630   if (g_pattern_match_string (entry-&gt;pat, cat-&gt;name)) {</span>
<span class="line-removed">1631     if (gst_is_initialized ())</span>
<span class="line-removed">1632       GST_TRACE (&quot;category %s matches pattern %p - gets set to level %d&quot;,</span>
<span class="line-removed">1633           cat-&gt;name, entry-&gt;pat, entry-&gt;level);</span>
<span class="line-removed">1634     gst_debug_category_set_threshold (cat, entry-&gt;level);</span>
<span class="line-removed">1635   }</span>
1636 }
1637 
1638 /**
1639  * gst_debug_set_threshold_for_name:
1640  * @name: name of the categories to set
1641  * @level: level to set them to
1642  *
1643  * Sets all categories which match the given glob style pattern to the given
1644  * level.
1645  */
1646 void
1647 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
1648 {
1649   GPatternSpec *pat;
1650   LevelNameEntry *entry;
1651 
1652   g_return_if_fail (name != NULL);
1653 
1654   pat = g_pattern_spec_new (name);
1655   entry = g_slice_new (LevelNameEntry);
1656   entry-&gt;pat = pat;
1657   entry-&gt;level = level;
1658   g_mutex_lock (&amp;__level_name_mutex);
1659   __level_name = g_slist_prepend (__level_name, entry);
1660   g_mutex_unlock (&amp;__level_name_mutex);
1661   g_mutex_lock (&amp;__cat_mutex);
1662   g_slist_foreach (__categories, for_each_threshold_by_entry, entry);
1663   g_mutex_unlock (&amp;__cat_mutex);
1664 }
1665 
1666 /**
1667  * gst_debug_unset_threshold_for_name:
1668  * @name: name of the categories to set
1669  *
1670  * Resets all categories with the given name back to the default level.
1671  */
1672 void
1673 gst_debug_unset_threshold_for_name (const gchar * name)
1674 {
1675   GSList *walk;
1676   GPatternSpec *pat;
1677 
1678   g_return_if_fail (name != NULL);
1679 
1680   pat = g_pattern_spec_new (name);
1681   g_mutex_lock (&amp;__level_name_mutex);
1682   walk = __level_name;
1683   /* improve this if you want, it&#39;s mighty slow */
1684   while (walk) {
1685     LevelNameEntry *entry = walk-&gt;data;
1686 
1687     if (g_pattern_spec_equal (entry-&gt;pat, pat)) {
1688       __level_name = g_slist_remove_link (__level_name, walk);
1689       g_pattern_spec_free (entry-&gt;pat);
1690       g_slice_free (LevelNameEntry, entry);
1691       g_slist_free_1 (walk);
1692       walk = __level_name;
1693     } else {
1694       walk = g_slist_next (walk);
1695     }
1696   }
1697   g_mutex_unlock (&amp;__level_name_mutex);
1698   g_pattern_spec_free (pat);
1699   gst_debug_reset_all_thresholds ();
1700 }
1701 
1702 GstDebugCategory *
1703 _gst_debug_category_new (const gchar * name, guint color,
1704     const gchar * description)
1705 {
1706   GstDebugCategory *cat, *catfound;
1707 
1708   g_return_val_if_fail (name != NULL, NULL);
1709 
1710   cat = g_slice_new (GstDebugCategory);
1711   cat-&gt;name = g_strdup (name);
1712   cat-&gt;color = color;
1713   if (description != NULL) {
1714     cat-&gt;description = g_strdup (description);
1715   } else {
1716     cat-&gt;description = g_strdup (&quot;no description&quot;);
1717   }
1718   g_atomic_int_set (&amp;cat-&gt;threshold, 0);
1719   gst_debug_reset_threshold (cat, NULL);
1720 
1721   /* add to category list */
1722   g_mutex_lock (&amp;__cat_mutex);
1723   catfound = _gst_debug_get_category_locked (name);
1724   if (catfound) {
1725     g_free ((gpointer) cat-&gt;name);
1726     g_free ((gpointer) cat-&gt;description);
1727     g_slice_free (GstDebugCategory, cat);
1728     cat = catfound;
1729   } else {
1730     __categories = g_slist_prepend (__categories, cat);
1731   }
1732   g_mutex_unlock (&amp;__cat_mutex);
1733 
1734   return cat;
1735 }
1736 
1737 /**
1738  * gst_debug_category_free:
1739  * @category: #GstDebugCategory to free.
1740  *
1741  * Removes and frees the category and all associated resources.
1742  */
1743 void
1744 gst_debug_category_free (GstDebugCategory * category)
1745 {
1746   if (category == NULL)
1747     return;
1748 
1749   /* remove from category list */
1750   g_mutex_lock (&amp;__cat_mutex);
1751   __categories = g_slist_remove (__categories, category);
1752   g_mutex_unlock (&amp;__cat_mutex);
1753 
1754   g_free ((gpointer) category-&gt;name);
1755   g_free ((gpointer) category-&gt;description);
1756   g_slice_free (GstDebugCategory, category);
1757 }
1758 
1759 /**
1760  * gst_debug_category_set_threshold:
1761  * @category: a #GstDebugCategory to set threshold of.
1762  * @level: the #GstDebugLevel threshold to set.
1763  *
1764  * Sets the threshold of the category to the given level. Debug information will
1765  * only be output if the threshold is lower or equal to the level of the
1766  * debugging message.
1767  * &gt; Do not use this function in production code, because other functions may
1768  * &gt; change the threshold of categories as side effect. It is however a nice
1769  * &gt; function to use when debugging (even from gdb).
1770  */
1771 void
1772 gst_debug_category_set_threshold (GstDebugCategory * category,
1773     GstDebugLevel level)
1774 {
1775   g_return_if_fail (category != NULL);
1776 
1777   if (level &gt; _gst_debug_min) {
1778     _gst_debug_enabled = TRUE;
1779     _gst_debug_min = level;
1780   }
1781 
1782   g_atomic_int_set (&amp;category-&gt;threshold, level);
1783 }
1784 
1785 /**
1786  * gst_debug_category_reset_threshold:
1787  * @category: a #GstDebugCategory to reset threshold of.
1788  *
1789  * Resets the threshold of the category to the default level. Debug information
1790  * will only be output if the threshold is lower or equal to the level of the
1791  * debugging message.
1792  * Use this function to set the threshold back to where it was after using
1793  * gst_debug_category_set_threshold().
1794  */
1795 void
1796 gst_debug_category_reset_threshold (GstDebugCategory * category)
1797 {
1798   gst_debug_reset_threshold (category, NULL);
1799 }
1800 
1801 /**
1802  * gst_debug_category_get_threshold:
1803  * @category: a #GstDebugCategory to get threshold of.
1804  *
1805  * Returns the threshold of a #GstDebugCategory.
1806  *
1807  * Returns: the #GstDebugLevel that is used as threshold.
1808  */
1809 GstDebugLevel
1810 gst_debug_category_get_threshold (GstDebugCategory * category)
1811 {
1812   return (GstDebugLevel) g_atomic_int_get (&amp;category-&gt;threshold);
1813 }
1814 
1815 /**
1816  * gst_debug_category_get_name:
1817  * @category: a #GstDebugCategory to get name of.
1818  *
1819  * Returns the name of a debug category.
1820  *
1821  * Returns: the name of the category.
1822  */
1823 const gchar *
1824 gst_debug_category_get_name (GstDebugCategory * category)
1825 {
1826   return category-&gt;name;
1827 }
1828 
1829 /**
1830  * gst_debug_category_get_color:
1831  * @category: a #GstDebugCategory to get the color of.
1832  *
1833  * Returns the color of a debug category used when printing output in this
1834  * category.
1835  *
1836  * Returns: the color of the category.
1837  */
1838 guint
1839 gst_debug_category_get_color (GstDebugCategory * category)
1840 {
1841   return category-&gt;color;
1842 }
1843 
1844 /**
1845  * gst_debug_category_get_description:
1846  * @category: a #GstDebugCategory to get the description of.
1847  *
1848  * Returns the description of a debug category.
1849  *
1850  * Returns: the description of the category.
1851  */
1852 const gchar *
1853 gst_debug_category_get_description (GstDebugCategory * category)
1854 {
1855   return category-&gt;description;
1856 }
1857 
1858 /**
1859  * gst_debug_get_all_categories:
1860  *
1861  * Returns a snapshot of a all categories that are currently in use . This list
1862  * may change anytime.
1863  * The caller has to free the list after use.
1864  *
1865  * Returns: (transfer container) (element-type Gst.DebugCategory): the list of
1866  *     debug categories
1867  */
1868 GSList *
1869 gst_debug_get_all_categories (void)
1870 {
1871   GSList *ret;
1872 
1873   g_mutex_lock (&amp;__cat_mutex);
1874   ret = g_slist_copy (__categories);
1875   g_mutex_unlock (&amp;__cat_mutex);
1876 
1877   return ret;
1878 }
1879 
1880 static GstDebugCategory *
1881 _gst_debug_get_category_locked (const gchar * name)
1882 {
1883   GstDebugCategory *ret = NULL;
1884   GSList *node;
1885 
1886   for (node = __categories; node; node = g_slist_next (node)) {
1887     ret = (GstDebugCategory *) node-&gt;data;
1888     if (!strcmp (name, ret-&gt;name)) {
1889       return ret;
1890     }
1891   }
1892   return NULL;
1893 }
1894 
1895 GstDebugCategory *
1896 _gst_debug_get_category (const gchar * name)
1897 {
1898   GstDebugCategory *ret;
1899 
1900   g_mutex_lock (&amp;__cat_mutex);
1901   ret = _gst_debug_get_category_locked (name);
1902   g_mutex_unlock (&amp;__cat_mutex);
1903 
1904   return ret;
1905 }
1906 
1907 static gboolean
1908 parse_debug_category (gchar * str, const gchar ** category)
1909 {
1910   if (!str)
1911     return FALSE;
1912 
1913   /* works in place */
1914   g_strstrip (str);
1915 
1916   if (str[0] != &#39;\0&#39;) {
1917     *category = str;
1918     return TRUE;
1919   }
1920 
1921   return FALSE;
1922 }
1923 
1924 static gboolean
1925 parse_debug_level (gchar * str, GstDebugLevel * level)
1926 {
1927   if (!str)
1928     return FALSE;
1929 
1930   /* works in place */
1931   g_strstrip (str);
1932 
1933   if (g_ascii_isdigit (str[0])) {
1934     unsigned long l;
1935     char *endptr;
1936     l = strtoul (str, &amp;endptr, 10);
1937     if (endptr &gt; str &amp;&amp; endptr[0] == 0) {
1938       *level = (GstDebugLevel) l;
1939     } else {
1940       return FALSE;
1941     }
1942   } else if (strcmp (str, &quot;ERROR&quot;) == 0) {
1943     *level = GST_LEVEL_ERROR;
1944   } else if (strncmp (str, &quot;WARN&quot;, 4) == 0) {
1945     *level = GST_LEVEL_WARNING;
1946   } else if (strcmp (str, &quot;FIXME&quot;) == 0) {
1947     *level = GST_LEVEL_FIXME;
1948   } else if (strcmp (str, &quot;INFO&quot;) == 0) {
1949     *level = GST_LEVEL_INFO;
1950   } else if (strcmp (str, &quot;DEBUG&quot;) == 0) {
1951     *level = GST_LEVEL_DEBUG;
1952   } else if (strcmp (str, &quot;LOG&quot;) == 0) {
1953     *level = GST_LEVEL_LOG;
1954   } else if (strcmp (str, &quot;TRACE&quot;) == 0) {
1955     *level = GST_LEVEL_TRACE;
1956   } else if (strcmp (str, &quot;MEMDUMP&quot;) == 0) {
1957     *level = GST_LEVEL_MEMDUMP;
1958   } else
1959     return FALSE;
1960 
1961   return TRUE;
1962 }
1963 
1964 /**
1965  * gst_debug_set_threshold_from_string:
1966  * @list: comma-separated list of &quot;category:level&quot; pairs to be used
1967  *     as debug logging levels
1968  * @reset: %TRUE to clear all previously-set debug levels before setting
1969  *     new thresholds
1970  * %FALSE if adding the threshold described by @list to the one already set.
1971  *
1972  * Sets the debug logging wanted in the same form as with the GST_DEBUG
1973  * environment variable. You can use wildcards such as &#39;*&#39;, but note that
1974  * the order matters when you use wild cards, e.g. &quot;foosrc:6,*src:3,*:2&quot; sets
1975  * everything to log level 2.
1976  *
1977  * Since: 1.2
1978  */
1979 void
1980 gst_debug_set_threshold_from_string (const gchar * list, gboolean reset)
1981 {
1982   gchar **split;
1983   gchar **walk;
1984 
1985   g_assert (list);
1986 
1987   if (reset)
1988     gst_debug_set_default_threshold (GST_LEVEL_DEFAULT);
1989 
1990   split = g_strsplit (list, &quot;,&quot;, 0);
1991 
1992   for (walk = split; *walk; walk++) {
1993     if (strchr (*walk, &#39;:&#39;)) {
1994       gchar **values = g_strsplit (*walk, &quot;:&quot;, 2);
1995 
1996       if (values[0] &amp;&amp; values[1]) {
1997         GstDebugLevel level;
1998         const gchar *category;
1999 
2000         if (parse_debug_category (values[0], &amp;category)
2001             &amp;&amp; parse_debug_level (values[1], &amp;level)) {
2002           gst_debug_set_threshold_for_name (category, level);
2003 
2004           /* bump min-level anyway to allow the category to be registered in the
2005            * future still */
2006           if (level &gt; _gst_debug_min) {
2007             _gst_debug_min = level;
<a name="17" id="anc17"></a><span class="line-modified">2008       }</span>
2009         }
2010       }
2011 
2012       g_strfreev (values);
2013     } else {
2014       GstDebugLevel level;
2015 
2016       if (parse_debug_level (*walk, &amp;level))
2017         gst_debug_set_default_threshold (level);
2018     }
2019   }
2020 
2021   g_strfreev (split);
2022 }
2023 
2024 /*** FUNCTION POINTERS ********************************************************/
2025 
2026 static GHashTable *__gst_function_pointers;     /* NULL */
2027 static GMutex __dbg_functions_mutex;
2028 
2029 /* This function MUST NOT return NULL */
2030 const gchar *
2031 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2032 {
2033   gchar *ptrname;
2034 
2035 #ifdef HAVE_DLADDR
2036   Dl_info dl_info;
2037 #endif
2038 
2039   if (G_UNLIKELY (func == NULL))
2040     return &quot;(NULL)&quot;;
2041 
2042   g_mutex_lock (&amp;__dbg_functions_mutex);
2043   if (G_LIKELY (__gst_function_pointers)) {
2044     ptrname = g_hash_table_lookup (__gst_function_pointers, (gpointer) func);
2045     g_mutex_unlock (&amp;__dbg_functions_mutex);
2046     if (G_LIKELY (ptrname))
2047       return ptrname;
2048   } else {
2049     g_mutex_unlock (&amp;__dbg_functions_mutex);
2050   }
2051   /* we need to create an entry in the hash table for this one so we don&#39;t leak
2052    * the name */
2053 #ifdef HAVE_DLADDR
2054   if (dladdr ((gpointer) func, &amp;dl_info) &amp;&amp; dl_info.dli_sname) {
<a name="18" id="anc18"></a><span class="line-modified">2055     gchar *name = g_strdup (dl_info.dli_sname);</span>
2056 
2057     _gst_debug_register_funcptr (func, name);
2058     return name;
2059   } else
2060 #endif
2061   {
2062     gchar *name = g_strdup_printf (&quot;%p&quot;, (gpointer) func);
<a name="19" id="anc19"></a>
2063 
<a name="20" id="anc20"></a><span class="line-modified">2064     _gst_debug_register_funcptr (func, name);</span>
<span class="line-modified">2065     return name;</span>


2066   }
2067 }
2068 
2069 void
2070 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2071 {
2072   gpointer ptr = (gpointer) func;
2073 
2074   g_mutex_lock (&amp;__dbg_functions_mutex);
2075 
2076   if (!__gst_function_pointers)
2077     __gst_function_pointers = g_hash_table_new (g_direct_hash, g_direct_equal);
<a name="21" id="anc21"></a><span class="line-modified">2078   if (!g_hash_table_lookup (__gst_function_pointers, ptr))</span>
2079     g_hash_table_insert (__gst_function_pointers, ptr, (gpointer) ptrname);
<a name="22" id="anc22"></a>













2080 
2081   g_mutex_unlock (&amp;__dbg_functions_mutex);
2082 }
2083 
2084 static void
2085 gst_info_dump_mem_line (gchar * linebuf, gsize linebuf_size,
2086     const guint8 * mem, gsize mem_offset, gsize mem_size)
2087 {
2088   gchar hexstr[50], ascstr[18], digitstr[4];
2089 
2090   if (mem_size &gt; 16)
2091     mem_size = 16;
2092 
2093   hexstr[0] = &#39;\0&#39;;
2094   ascstr[0] = &#39;\0&#39;;
2095 
2096   if (mem != NULL) {
2097     guint i = 0;
2098 
2099     mem += mem_offset;
2100     while (i &lt; mem_size) {
2101       ascstr[i] = (g_ascii_isprint (mem[i])) ? mem[i] : &#39;.&#39;;
2102       g_snprintf (digitstr, sizeof (digitstr), &quot;%02x &quot;, mem[i]);
2103       g_strlcat (hexstr, digitstr, sizeof (hexstr));
2104       ++i;
2105     }
2106     ascstr[i] = &#39;\0&#39;;
2107   }
2108 
2109   g_snprintf (linebuf, linebuf_size, &quot;%08x: %-48.48s %-16.16s&quot;,
2110       (guint) mem_offset, hexstr, ascstr);
2111 }
2112 
2113 void
2114 _gst_debug_dump_mem (GstDebugCategory * cat, const gchar * file,
2115     const gchar * func, gint line, GObject * obj, const gchar * msg,
2116     const guint8 * data, guint length)
2117 {
2118   guint off = 0;
2119 
2120   gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;--------&quot;
2121       &quot;-------------------------------------------------------------------&quot;);
2122 
2123   if (msg != NULL &amp;&amp; *msg != &#39;\0&#39;) {
2124     gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;%s&quot;, msg);
2125   }
2126 
2127   while (off &lt; length) {
2128     gchar buf[128];
2129 
2130     /* gst_info_dump_mem_line will process 16 bytes at most */
2131     gst_info_dump_mem_line (buf, sizeof (buf), data, off, length - off);
2132     gst_debug_log (cat, GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;%s&quot;, buf);
2133     off += 16;
2134   }
2135 
2136   gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;--------&quot;
2137       &quot;-------------------------------------------------------------------&quot;);
2138 }
2139 
2140 #else /* !GST_DISABLE_GST_DEBUG */
2141 #ifndef GST_REMOVE_DISABLED
2142 
2143 GstDebugCategory *
2144 _gst_debug_category_new (const gchar * name, guint color,
2145     const gchar * description)
2146 {
2147   return NULL;
2148 }
2149 
2150 void
2151 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2152 {
2153 }
2154 
2155 /* This function MUST NOT return NULL */
2156 const gchar *
2157 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2158 {
2159   return &quot;(NULL)&quot;;
2160 }
2161 
<a name="23" id="anc23"></a>




2162 void
2163 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
2164     const gchar * file, const gchar * function, gint line,
2165     GObject * object, const gchar * format, ...)
2166 {
2167 }
2168 
2169 void
2170 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
2171     const gchar * file, const gchar * function, gint line,
2172     GObject * object, const gchar * format, va_list args)
2173 {
2174 }
2175 
2176 const gchar *
2177 gst_debug_message_get (GstDebugMessage * message)
2178 {
2179   return &quot;&quot;;
2180 }
2181 
2182 void
2183 gst_debug_log_default (GstDebugCategory * category, GstDebugLevel level,
2184     const gchar * file, const gchar * function, gint line,
2185     GObject * object, GstDebugMessage * message, gpointer unused)
2186 {
2187 }
2188 
2189 const gchar *
2190 gst_debug_level_get_name (GstDebugLevel level)
2191 {
2192   return &quot;NONE&quot;;
2193 }
2194 
2195 void
2196 gst_debug_add_log_function (GstLogFunction func, gpointer user_data,
2197     GDestroyNotify notify)
2198 {
2199 }
2200 
2201 guint
2202 gst_debug_remove_log_function (GstLogFunction func)
2203 {
2204   return 0;
2205 }
2206 
2207 guint
2208 gst_debug_remove_log_function_by_data (gpointer data)
2209 {
2210   return 0;
2211 }
2212 
2213 void
2214 gst_debug_set_active (gboolean active)
2215 {
2216 }
2217 
2218 gboolean
2219 gst_debug_is_active (void)
2220 {
2221   return FALSE;
2222 }
2223 
2224 void
2225 gst_debug_set_colored (gboolean colored)
2226 {
2227 }
2228 
2229 void
2230 gst_debug_set_color_mode (GstDebugColorMode mode)
2231 {
2232 }
2233 
2234 void
2235 gst_debug_set_color_mode_from_string (const gchar * str)
2236 {
2237 }
2238 
2239 gboolean
2240 gst_debug_is_colored (void)
2241 {
2242   return FALSE;
2243 }
2244 
2245 GstDebugColorMode
2246 gst_debug_get_color_mode (void)
2247 {
2248   return GST_DEBUG_COLOR_MODE_OFF;
2249 }
2250 
2251 void
2252 gst_debug_set_threshold_from_string (const gchar * list, gboolean reset)
2253 {
2254 }
2255 
2256 void
2257 gst_debug_set_default_threshold (GstDebugLevel level)
2258 {
2259 }
2260 
2261 GstDebugLevel
2262 gst_debug_get_default_threshold (void)
2263 {
2264   return GST_LEVEL_NONE;
2265 }
2266 
2267 void
2268 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
2269 {
2270 }
2271 
2272 void
2273 gst_debug_unset_threshold_for_name (const gchar * name)
2274 {
2275 }
2276 
2277 void
2278 gst_debug_category_free (GstDebugCategory * category)
2279 {
2280 }
2281 
2282 void
2283 gst_debug_category_set_threshold (GstDebugCategory * category,
2284     GstDebugLevel level)
2285 {
2286 }
2287 
2288 void
2289 gst_debug_category_reset_threshold (GstDebugCategory * category)
2290 {
2291 }
2292 
2293 GstDebugLevel
2294 gst_debug_category_get_threshold (GstDebugCategory * category)
2295 {
2296   return GST_LEVEL_NONE;
2297 }
2298 
2299 const gchar *
2300 gst_debug_category_get_name (GstDebugCategory * category)
2301 {
2302   return &quot;&quot;;
2303 }
2304 
2305 guint
2306 gst_debug_category_get_color (GstDebugCategory * category)
2307 {
2308   return 0;
2309 }
2310 
2311 const gchar *
2312 gst_debug_category_get_description (GstDebugCategory * category)
2313 {
2314   return &quot;&quot;;
2315 }
2316 
2317 GSList *
2318 gst_debug_get_all_categories (void)
2319 {
2320   return NULL;
2321 }
2322 
2323 GstDebugCategory *
2324 _gst_debug_get_category (const gchar * name)
2325 {
2326   return NULL;
2327 }
2328 
2329 gchar *
2330 gst_debug_construct_term_color (guint colorinfo)
2331 {
2332   return g_strdup (&quot;00&quot;);
2333 }
2334 
2335 gint
2336 gst_debug_construct_win_color (guint colorinfo)
2337 {
2338   return 0;
2339 }
2340 
2341 gboolean
2342 _priv_gst_in_valgrind (void)
2343 {
2344   return FALSE;
2345 }
2346 
2347 void
2348 _gst_debug_dump_mem (GstDebugCategory * cat, const gchar * file,
2349     const gchar * func, gint line, GObject * obj, const gchar * msg,
2350     const guint8 * data, guint length)
2351 {
2352 }
2353 #endif /* GST_REMOVE_DISABLED */
2354 #endif /* GST_DISABLE_GST_DEBUG */
2355 
2356 /* Need this for _gst_element_error_printf even if GST_REMOVE_DISABLED is set:
2357  * fallback function that cleans up the format string and replaces all pointer
2358  * extension formats with plain %p. */
2359 #ifdef GST_DISABLE_GST_DEBUG
2360 int
2361 __gst_info_fallback_vasprintf (char **result, char const *format, va_list args)
2362 {
2363   gchar *clean_format, *c;
2364   gsize len;
2365 
2366   if (format == NULL)
2367     return -1;
2368 
2369   clean_format = g_strdup (format);
2370   c = clean_format;
2371   while ((c = strstr (c, &quot;%p\a&quot;))) {
2372     if (c[3] &lt; &#39;A&#39; || c[3] &gt; &#39;Z&#39;) {
2373       c += 3;
2374       continue;
2375     }
2376     len = strlen (c + 4);
2377     memmove (c + 2, c + 4, len + 1);
2378     c += 2;
2379   }
2380   while ((c = strstr (clean_format, &quot;%P&quot;)))     /* old GST_PTR_FORMAT */
2381     c[1] = &#39;p&#39;;
2382   while ((c = strstr (clean_format, &quot;%Q&quot;)))     /* old GST_SEGMENT_FORMAT */
2383     c[1] = &#39;p&#39;;
2384 
2385   len = g_vasprintf (result, clean_format, args);
2386 
2387   g_free (clean_format);
2388 
2389   if (*result == NULL)
2390     return -1;
2391 
2392   return len;
2393 }
2394 #endif
2395 
2396 /**
2397  * gst_info_vasprintf:
2398  * @result: (out): the resulting string
2399  * @format: a printf style format string
2400  * @args: the va_list of printf arguments for @format
2401  *
2402  * Allocates and fills a string large enough (including the terminating null
2403  * byte) to hold the specified printf style @format and @args.
2404  *
2405  * This function deals with the GStreamer specific printf specifiers
2406  * #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.  If you do not have these specifiers
2407  * in your @format string, you do not need to use this function and can use
2408  * alternatives such as g_vasprintf().
2409  *
2410  * Free @result with g_free().
2411  *
2412  * Returns: the length of the string allocated into @result or -1 on any error
2413  *
2414  * Since: 1.8
2415  */
2416 gint
2417 gst_info_vasprintf (gchar ** result, const gchar * format, va_list args)
2418 {
2419   /* This will fallback to __gst_info_fallback_vasprintf() via a #define in
2420    * gst_private.h if the debug system is disabled which will remove the gst
2421    * specific printf format specifiers */
2422   return __gst_vasprintf (result, format, args);
2423 }
2424 
2425 /**
2426  * gst_info_strdup_vprintf:
2427  * @format: a printf style format string
2428  * @args: the va_list of printf arguments for @format
2429  *
2430  * Allocates, fills and returns a null terminated string from the printf style
2431  * @format string and @args.
2432  *
2433  * See gst_info_vasprintf() for when this function is required.
2434  *
2435  * Free with g_free().
2436  *
2437  * Returns: (nullable): a newly allocated null terminated string or %NULL on any error
2438  *
2439  * Since: 1.8
2440  */
2441 gchar *
2442 gst_info_strdup_vprintf (const gchar * format, va_list args)
2443 {
2444   gchar *ret;
2445 
2446   if (gst_info_vasprintf (&amp;ret, format, args) &lt; 0)
2447     ret = NULL;
2448 
2449   return ret;
2450 }
2451 
2452 /**
2453  * gst_info_strdup_printf:
2454  * @format: a printf style format string
2455  * @...: the printf arguments for @format
2456  *
2457  * Allocates, fills and returns a 0-terminated string from the printf style
2458  * @format string and corresponding arguments.
2459  *
2460  * See gst_info_vasprintf() for when this function is required.
2461  *
2462  * Free with g_free().
2463  *
2464  * Returns: (nullable): a newly allocated null terminated string or %NULL on any error
2465  *
2466  * Since: 1.8
2467  */
2468 gchar *
2469 gst_info_strdup_printf (const gchar * format, ...)
2470 {
2471   gchar *ret;
2472   va_list args;
2473 
2474   va_start (args, format);
2475   ret = gst_info_strdup_vprintf (format, args);
2476   va_end (args);
2477 
2478   return ret;
2479 }
2480 
2481 /**
2482  * gst_print:
2483  * @format: a printf style format string
2484  * @...: the printf arguments for @format
2485  *
2486  * Outputs a formatted message via the GLib print handler. The default print
2487  * handler simply outputs the message to stdout.
2488  *
2489  * This function will not append a new-line character at the end, unlike
2490  * gst_println() which will.
2491  *
2492  * All strings must be in ASCII or UTF-8 encoding.
2493  *
2494  * This function differs from g_print() in that it supports all the additional
2495  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2496  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2497  *
2498  * This function is primarily for printing debug output.
2499  *
2500  * Since: 1.12
2501  */
2502 void
2503 gst_print (const gchar * format, ...)
2504 {
2505   va_list args;
2506   gchar *str;
2507 
2508   va_start (args, format);
2509   str = gst_info_strdup_vprintf (format, args);
2510   va_end (args);
2511 
2512   g_print (&quot;%s&quot;, str);
2513   g_free (str);
2514 }
2515 
2516 /**
2517  * gst_println:
2518  * @format: a printf style format string
2519  * @...: the printf arguments for @format
2520  *
2521  * Outputs a formatted message via the GLib print handler. The default print
2522  * handler simply outputs the message to stdout.
2523  *
2524  * This function will append a new-line character at the end, unlike
2525  * gst_print() which will not.
2526  *
2527  * All strings must be in ASCII or UTF-8 encoding.
2528  *
2529  * This function differs from g_print() in that it supports all the additional
2530  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2531  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2532  *
2533  * This function is primarily for printing debug output.
2534  *
2535  * Since: 1.12
2536  */
2537 void
2538 gst_println (const gchar * format, ...)
2539 {
2540   va_list args;
2541   gchar *str;
2542 
2543   va_start (args, format);
2544   str = gst_info_strdup_vprintf (format, args);
2545   va_end (args);
2546 
2547   g_print (&quot;%s\n&quot;, str);
2548   g_free (str);
2549 }
2550 
2551 /**
2552  * gst_printerr:
2553  * @format: a printf style format string
2554  * @...: the printf arguments for @format
2555  *
2556  * Outputs a formatted message via the GLib error message handler. The default
2557  * handler simply outputs the message to stderr.
2558  *
2559  * This function will not append a new-line character at the end, unlike
2560  * gst_printerrln() which will.
2561  *
2562  * All strings must be in ASCII or UTF-8 encoding.
2563  *
2564  * This function differs from g_printerr() in that it supports the additional
2565  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2566  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2567  *
2568  * This function is primarily for printing debug output.
2569  *
2570  * Since: 1.12
2571  */
2572 void
2573 gst_printerr (const gchar * format, ...)
2574 {
2575   va_list args;
2576   gchar *str;
2577 
2578   va_start (args, format);
2579   str = gst_info_strdup_vprintf (format, args);
2580   va_end (args);
2581 
2582   g_printerr (&quot;%s&quot;, str);
2583   g_free (str);
2584 }
2585 
2586 /**
2587  * gst_printerrln:
2588  * @format: a printf style format string
2589  * @...: the printf arguments for @format
2590  *
2591  * Outputs a formatted message via the GLib error message handler. The default
2592  * handler simply outputs the message to stderr.
2593  *
2594  * This function will append a new-line character at the end, unlike
2595  * gst_printerr() which will not.
2596  *
2597  * All strings must be in ASCII or UTF-8 encoding.
2598  *
2599  * This function differs from g_printerr() in that it supports the additional
2600  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2601  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2602  *
2603  * This function is primarily for printing debug output.
2604  *
2605  * Since: 1.12
2606  */
2607 void
2608 gst_printerrln (const gchar * format, ...)
2609 {
2610   va_list args;
2611   gchar *str;
2612 
2613   va_start (args, format);
2614   str = gst_info_strdup_vprintf (format, args);
2615   va_end (args);
2616 
2617   g_printerr (&quot;%s\n&quot;, str);
2618   g_free (str);
<a name="24" id="anc24"></a><span class="line-modified">2619   }</span>
2620 
2621 #ifdef HAVE_UNWIND
2622 #ifdef HAVE_DW
2623 static gboolean
2624 append_debug_info (GString * trace, Dwfl * dwfl, const void *ip)
2625 {
2626   Dwfl_Line *line;
2627   Dwarf_Addr addr;
2628   Dwfl_Module *module;
2629   const gchar *function_name;
2630 
2631   if (dwfl_linux_proc_report (dwfl, getpid ()) != 0)
2632     return FALSE;
2633 
2634   if (dwfl_report_end (dwfl, NULL, NULL))
2635     return FALSE;
2636 
2637   addr = (uintptr_t) ip;
2638   module = dwfl_addrmodule (dwfl, addr);
2639   function_name = dwfl_module_addrname (module, addr);
2640 
2641   g_string_append_printf (trace, &quot;%s (&quot;, function_name ? function_name : &quot;??&quot;);
2642 
2643   line = dwfl_getsrc (dwfl, addr);
2644   if (line != NULL) {
2645     gint nline;
2646     Dwarf_Addr addr;
2647     const gchar *filename = dwfl_lineinfo (line, &amp;addr,
2648         &amp;nline, NULL, NULL, NULL);
2649 
2650     g_string_append_printf (trace, &quot;%s:%d&quot;, strrchr (filename,
2651             G_DIR_SEPARATOR) + 1, nline);
2652   } else {
2653     const gchar *eflfile = NULL;
2654 
2655     dwfl_module_info (module, NULL, NULL, NULL, NULL, NULL, &amp;eflfile, NULL);
2656     g_string_append_printf (trace, &quot;%s:%p&quot;, eflfile ? eflfile : &quot;??&quot;, ip);
<a name="25" id="anc25"></a><span class="line-modified">2657 }</span>
2658 
2659   return TRUE;
2660 }
2661 #endif /* HAVE_DW */
2662 
2663 static gchar *
2664 generate_unwind_trace (GstStackTraceFlags flags)
2665 {
2666   gint unret;
2667   unw_context_t uc;
2668   unw_cursor_t cursor;
2669   gboolean use_libunwind = TRUE;
2670   GString *trace = g_string_new (NULL);
2671 
2672 #ifdef HAVE_DW
2673   Dwfl *dwfl = NULL;
2674   Dwfl_Callbacks callbacks = {
2675     .find_elf = dwfl_linux_proc_find_elf,
2676     .find_debuginfo = dwfl_standard_find_debuginfo,
2677   };
2678 
2679   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL))
2680     dwfl = dwfl_begin (&amp;callbacks);
2681 #endif /* HAVE_DW */
2682 
2683   unret = unw_getcontext (&amp;uc);
2684   if (unret) {
2685     GST_DEBUG (&quot;Could not get libunwind context (%d)&quot;, unret);
2686 
2687     goto done;
2688   }
2689   unret = unw_init_local (&amp;cursor, &amp;uc);
2690   if (unret) {
2691     GST_DEBUG (&quot;Could not init libunwind context (%d)&quot;, unret);
2692 
2693     goto done;
2694   }
2695 
2696   while (unw_step (&amp;cursor) &gt; 0) {
2697 #ifdef HAVE_DW
2698     if (dwfl) {
2699       unw_word_t ip;
2700 
2701       unret = unw_get_reg (&amp;cursor, UNW_REG_IP, &amp;ip);
2702       if (unret) {
2703         GST_DEBUG (&quot;libunwind could read frame info (%d)&quot;, unret);
2704 
2705         goto done;
2706       }
2707 
2708       if (append_debug_info (trace, dwfl, (void *) (ip - 4))) {
2709         use_libunwind = FALSE;
2710         g_string_append (trace, &quot;)\n&quot;);
2711       }
2712     }
2713 #endif /* HAVE_DW */
2714 
2715     if (use_libunwind) {
2716       char name[32];
2717 
2718       unw_word_t offset = 0;
2719       unw_get_proc_name (&amp;cursor, name, sizeof (name), &amp;offset);
2720       g_string_append_printf (trace, &quot;%s (0x%&quot; G_GSIZE_FORMAT &quot;)\n&quot;, name,
2721           (gsize) offset);
2722     }
2723   }
2724 
2725 done:
2726 #ifdef HAVE_DW
2727   if (dwfl)
2728     dwfl_end (dwfl);
2729 #endif
2730 
2731   return g_string_free (trace, FALSE);
2732 }
2733 
2734 #endif /* HAVE_UNWIND */
2735 
2736 #ifdef HAVE_BACKTRACE
2737 static gchar *
2738 generate_backtrace_trace (void)
2739 {
2740   int j, nptrs;
2741   void *buffer[BT_BUF_SIZE];
2742   char **strings;
2743   GString *trace;
2744 
2745   trace = g_string_new (NULL);
2746   nptrs = backtrace (buffer, BT_BUF_SIZE);
2747 
2748   strings = backtrace_symbols (buffer, nptrs);
2749 
2750   if (!strings)
2751     return NULL;
2752 
2753   for (j = 0; j &lt; nptrs; j++)
2754     g_string_append_printf (trace, &quot;%s\n&quot;, strings[j]);
2755 
2756   free (strings);
2757 
2758   return g_string_free (trace, FALSE);
2759 }
2760 #else
2761 #define generate_backtrace_trace() NULL
2762 #endif /* HAVE_BACKTRACE */
2763 
<a name="26" id="anc26"></a>



























































































2764 /**
2765  * gst_debug_get_stack_trace:
2766  * @flags: A set of #GstStackTraceFlags to determine how the stack
2767  * trace should look like. Pass 0 to retrieve a minimal backtrace.
2768  *
2769  * Returns: (nullable): a stack trace, if libunwind or glibc backtrace are
2770  * present, else %NULL.
2771  *
2772  * Since: 1.12
2773  */
2774 gchar *
2775 gst_debug_get_stack_trace (GstStackTraceFlags flags)
2776 {
2777   gchar *trace = NULL;
2778 #ifdef HAVE_BACKTRACE
2779   gboolean have_backtrace = TRUE;
2780 #else
2781   gboolean have_backtrace = FALSE;
2782 #endif
2783 
2784 #ifdef HAVE_UNWIND
2785   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL) || !have_backtrace)
2786     trace = generate_unwind_trace (flags);
2787 #endif /* HAVE_UNWIND */
2788 
<a name="27" id="anc27"></a>



2789   if (trace)
2790     return trace;
2791   else if (have_backtrace)
2792     return generate_backtrace_trace ();
2793 
2794   return NULL;
2795 }
2796 
2797 /**
2798  * gst_debug_print_stack_trace:
2799  *
<a name="28" id="anc28"></a><span class="line-modified">2800  * If libunwind or glibc backtrace are present</span>
2801  * a stack trace is printed.
2802  */
2803 void
2804 gst_debug_print_stack_trace (void)
2805 {
2806   gchar *trace = gst_debug_get_stack_trace (GST_STACK_TRACE_SHOW_FULL);
2807 
2808   if (trace)
2809     g_print (&quot;%s\n&quot;, trace);
2810 
2811   g_free (trace);
2812 }
2813 
2814 #ifndef GST_DISABLE_GST_DEBUG
2815 typedef struct
2816 {
2817   guint max_size_per_thread;
2818   guint thread_timeout;
2819   GQueue threads;
2820   GHashTable *thread_index;
2821 } GstRingBufferLogger;
2822 
2823 typedef struct
2824 {
2825   GList *link;
2826   gint64 last_use;
2827   GThread *thread;
2828 
2829   GQueue log;
2830   gsize log_size;
2831 } GstRingBufferLog;
2832 
2833 G_LOCK_DEFINE_STATIC (ring_buffer_logger);
2834 static GstRingBufferLogger *ring_buffer_logger = NULL;
2835 
2836 static void
2837 gst_ring_buffer_logger_log (GstDebugCategory * category,
2838     GstDebugLevel level,
2839     const gchar * file,
2840     const gchar * function,
2841     gint line, GObject * object, GstDebugMessage * message, gpointer user_data)
2842 {
2843   GstRingBufferLogger *logger = user_data;
2844   gint pid;
2845   GThread *thread;
2846   GstClockTime elapsed;
2847   gchar *obj = NULL;
2848   gchar c;
2849   gchar *output;
2850   gsize output_len;
2851   GstRingBufferLog *log;
2852   gint64 now = g_get_monotonic_time ();
2853   const gchar *message_str = gst_debug_message_get (message);
2854 
<a name="29" id="anc29"></a>
































2855   G_LOCK (ring_buffer_logger);
2856 
2857   if (logger-&gt;thread_timeout &gt; 0) {
<a name="30" id="anc30"></a>

2858     /* Remove all threads that saw no output since thread_timeout seconds.
2859      * By construction these are all at the tail of the queue, and the queue
2860      * is ordered by last use, so we just need to look at the tail.
2861      */
2862     while (logger-&gt;threads.tail) {
2863       log = logger-&gt;threads.tail-&gt;data;
2864       if (log-&gt;last_use + logger-&gt;thread_timeout * G_USEC_PER_SEC &gt;= now)
2865         break;
2866 
2867       g_hash_table_remove (logger-&gt;thread_index, log-&gt;thread);
<a name="31" id="anc31"></a><span class="line-modified">2868       while ((output = g_queue_pop_head (&amp;log-&gt;log)))</span>
<span class="line-modified">2869         g_free (output);</span>
2870       g_free (log);
2871       g_queue_pop_tail (&amp;logger-&gt;threads);
2872     }
2873   }
2874 
2875   /* Get logger for this thread, and put it back at the
2876    * head of the threads queue */
<a name="32" id="anc32"></a><span class="line-removed">2877   thread = g_thread_self ();</span>
2878   log = g_hash_table_lookup (logger-&gt;thread_index, thread);
2879   if (!log) {
2880     log = g_new0 (GstRingBufferLog, 1);
2881     g_queue_init (&amp;log-&gt;log);
2882     log-&gt;log_size = 0;
2883     g_queue_push_head (&amp;logger-&gt;threads, log);
2884     log-&gt;link = logger-&gt;threads.head;
2885     log-&gt;thread = thread;
2886     g_hash_table_insert (logger-&gt;thread_index, thread, log);
2887   } else {
2888     g_queue_unlink (&amp;logger-&gt;threads, log-&gt;link);
2889     g_queue_push_head_link (&amp;logger-&gt;threads, log-&gt;link);
2890   }
2891   log-&gt;last_use = now;
2892 
<a name="33" id="anc33"></a><span class="line-removed">2893   /* __FILE__ might be a file name or an absolute path or a</span>
<span class="line-removed">2894    * relative path, irrespective of the exact compiler used,</span>
<span class="line-removed">2895    * in which case we want to shorten it to the filename for</span>
<span class="line-removed">2896    * readability. */</span>
<span class="line-removed">2897   c = file[0];</span>
<span class="line-removed">2898   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {</span>
<span class="line-removed">2899     file = gst_path_basename (file);</span>
<span class="line-removed">2900   }</span>
<span class="line-removed">2901 </span>
<span class="line-removed">2902   pid = getpid ();</span>
<span class="line-removed">2903 </span>
<span class="line-removed">2904   if (object) {</span>
<span class="line-removed">2905     obj = gst_debug_print_object (object);</span>
<span class="line-removed">2906   } else {</span>
<span class="line-removed">2907     obj = (gchar *) &quot;&quot;;</span>
<span class="line-removed">2908   }</span>
<span class="line-removed">2909 </span>
<span class="line-removed">2910   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());</span>
<span class="line-removed">2911 </span>
<span class="line-removed">2912   /* no color, all platforms */</span>
<span class="line-removed">2913 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;</span>
<span class="line-removed">2914   output =</span>
<span class="line-removed">2915       g_strdup_printf (&quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),</span>
<span class="line-removed">2916       pid, thread, gst_debug_level_get_name (level),</span>
<span class="line-removed">2917       gst_debug_category_get_name (category), file, line, function, obj,</span>
<span class="line-removed">2918       message_str);</span>
<span class="line-removed">2919 #undef PRINT_FMT</span>
<span class="line-removed">2920 </span>
<span class="line-removed">2921   output_len = strlen (output);</span>
<span class="line-removed">2922 </span>
2923   if (output_len &lt; logger-&gt;max_size_per_thread) {
2924     gchar *buf;
2925 
2926     /* While using a GQueue here is not the most efficient thing to do, we
2927      * have to allocate a string for every output anyway and could just store
2928      * that instead of copying it to an actual ringbuffer.
2929      * Better than GQueue would be GstQueueArray, but that one is in
2930      * libgstbase and we can&#39;t use it here. That one allocation will not make
2931      * much of a difference anymore, considering the number of allocations
2932      * needed to get to this point...
2933      */
2934     while (log-&gt;log_size + output_len &gt; logger-&gt;max_size_per_thread) {
2935       buf = g_queue_pop_head (&amp;log-&gt;log);
2936       log-&gt;log_size -= strlen (buf);
2937       g_free (buf);
2938     }
2939     g_queue_push_tail (&amp;log-&gt;log, output);
2940     log-&gt;log_size += output_len;
2941   } else {
2942     gchar *buf;
2943 
2944     /* Can&#39;t really write anything as the line is bigger than the maximum
2945      * allowed log size already, so just remove everything */
2946 
2947     while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
2948       g_free (buf);
2949     g_free (output);
2950     log-&gt;log_size = 0;
2951   }
2952 
<a name="34" id="anc34"></a><span class="line-removed">2953   if (object != NULL)</span>
<span class="line-removed">2954     g_free (obj);</span>
<span class="line-removed">2955 </span>
2956   G_UNLOCK (ring_buffer_logger);
2957 }
2958 
2959 /**
2960  * gst_debug_ring_buffer_logger_get_logs:
2961  *
2962  * Fetches the current logs per thread from the ring buffer logger. See
2963  * gst_debug_add_ring_buffer_logger() for details.
2964  *
2965  * Returns: (transfer full) (array zero-terminated): NULL-terminated array of
2966  * strings with the debug output per thread
2967  *
2968  * Since: 1.14
2969  */
2970 gchar **
2971 gst_debug_ring_buffer_logger_get_logs (void)
2972 {
2973   gchar **logs, **tmp;
2974   GList *l;
2975 
2976   g_return_val_if_fail (ring_buffer_logger != NULL, NULL);
2977 
2978   G_LOCK (ring_buffer_logger);
2979 
2980   tmp = logs = g_new0 (gchar *, ring_buffer_logger-&gt;threads.length + 1);
2981   for (l = ring_buffer_logger-&gt;threads.head; l; l = l-&gt;next) {
2982     GstRingBufferLog *log = l-&gt;data;
2983     GList *l;
2984     gchar *p;
2985     gsize len;
2986 
2987     *tmp = p = g_new0 (gchar, log-&gt;log_size + 1);
2988 
2989     for (l = log-&gt;log.head; l; l = l-&gt;next) {
2990       len = strlen (l-&gt;data);
2991       memcpy (p, l-&gt;data, len);
2992       p += len;
2993     }
2994 
2995     tmp++;
2996   }
2997 
2998   G_UNLOCK (ring_buffer_logger);
2999 
3000   return logs;
3001 }
3002 
3003 static void
3004 gst_ring_buffer_logger_free (GstRingBufferLogger * logger)
3005 {
3006   G_LOCK (ring_buffer_logger);
3007   if (ring_buffer_logger == logger) {
3008     GstRingBufferLog *log;
3009 
3010     while ((log = g_queue_pop_head (&amp;logger-&gt;threads))) {
3011       gchar *buf;
3012       while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
3013         g_free (buf);
3014       g_free (log);
3015     }
3016 
3017     g_hash_table_unref (logger-&gt;thread_index);
3018 
3019     g_free (logger);
3020     ring_buffer_logger = NULL;
3021   }
3022   G_UNLOCK (ring_buffer_logger);
3023 }
3024 
3025 /**
3026  * gst_debug_add_ring_buffer_logger:
3027  * @max_size_per_thread: Maximum size of log per thread in bytes
3028  * @thread_timeout: Timeout for threads in seconds
3029  *
3030  * Adds a memory ringbuffer based debug logger that stores up to
3031  * @max_size_per_thread bytes of logs per thread and times out threads after
3032  * @thread_timeout seconds of inactivity.
3033  *
3034  * Logs can be fetched with gst_debug_ring_buffer_logger_get_logs() and the
3035  * logger can be removed again with gst_debug_remove_ring_buffer_logger().
3036  * Only one logger at a time is possible.
3037  *
3038  * Since: 1.14
3039  */
3040 void
3041 gst_debug_add_ring_buffer_logger (guint max_size_per_thread,
3042     guint thread_timeout)
3043 {
3044   GstRingBufferLogger *logger;
3045 
3046   G_LOCK (ring_buffer_logger);
3047 
3048   if (ring_buffer_logger) {
3049     g_warn_if_reached ();
3050     G_UNLOCK (ring_buffer_logger);
3051     return;
3052   }
3053 
3054   logger = ring_buffer_logger = g_new0 (GstRingBufferLogger, 1);
3055 
3056   logger-&gt;max_size_per_thread = max_size_per_thread;
3057   logger-&gt;thread_timeout = thread_timeout;
3058   logger-&gt;thread_index = g_hash_table_new (g_direct_hash, g_direct_equal);
3059   g_queue_init (&amp;logger-&gt;threads);
3060 
3061   gst_debug_add_log_function (gst_ring_buffer_logger_log, logger,
3062       (GDestroyNotify) gst_ring_buffer_logger_free);
3063   G_UNLOCK (ring_buffer_logger);
3064 }
3065 
3066 /**
3067  * gst_debug_remove_ring_buffer_logger:
3068  *
3069  * Removes any previously added ring buffer logger with
3070  * gst_debug_add_ring_buffer_logger().
3071  *
3072  * Since: 1.14
3073  */
3074 void
3075 gst_debug_remove_ring_buffer_logger (void)
3076 {
3077   gst_debug_remove_log_function (gst_ring_buffer_logger_log);
3078 }
3079 
3080 #else /* GST_DISABLE_GST_DEBUG */
3081 #ifndef GST_REMOVE_DISABLED
3082 
3083 gchar **
3084 gst_debug_ring_buffer_logger_get_logs (void)
3085 {
3086   return NULL;
3087 }
3088 
3089 void
3090 gst_debug_add_ring_buffer_logger (guint max_size_per_thread,
3091     guint thread_timeout)
3092 {
3093 }
3094 
3095 void
3096 gst_debug_remove_ring_buffer_logger (void)
3097 {
3098 }
3099 
3100 #endif /* GST_REMOVE_DISABLED */
3101 #endif /* GST_DISABLE_GST_DEBUG */
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>