<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpattern.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="goption.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpattern.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpattern.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,12 ***</span>
  
  
  /* --- functions --- */
  static inline gboolean
  g_pattern_ph_match (const gchar *match_pattern,
<span class="line-modified">!             const gchar *match_string,</span>
<span class="line-modified">!             gboolean    *wildcard_reached_p)</span>
  {
    const gchar *pattern, *string;
    gchar ch;
  
    pattern = match_pattern;
<span class="line-new-header">--- 78,12 ---</span>
  
  
  /* --- functions --- */
  static inline gboolean
  g_pattern_ph_match (const gchar *match_pattern,
<span class="line-modified">!         const gchar *match_string,</span>
<span class="line-modified">!         gboolean    *wildcard_reached_p)</span>
  {
    const gchar *pattern, *string;
    gchar ch;
  
    pattern = match_pattern;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,64 ***</span>
    ch = *pattern;
    pattern++;
    while (ch)
      {
        switch (ch)
      {
<span class="line-removed">-     case &#39;?&#39;:</span>
        if (!*string)
          return FALSE;
        string = g_utf8_next_char (string);
<span class="line-modified">!       break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     case &#39;*&#39;:</span>
<span class="line-modified">!       *wildcard_reached_p = TRUE;</span>
<span class="line-modified">!       do</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           ch = *pattern;</span>
<span class="line-removed">-           pattern++;</span>
<span class="line-removed">-           if (ch == &#39;?&#39;)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           if (!*string)</span>
<span class="line-removed">-             return FALSE;</span>
<span class="line-removed">-           string = g_utf8_next_char (string);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       while (ch == &#39;*&#39; || ch == &#39;?&#39;);</span>
<span class="line-removed">-       if (!ch)</span>
<span class="line-removed">-         return TRUE;</span>
<span class="line-removed">-       do</span>
<span class="line-removed">-         {</span>
                gboolean next_wildcard_reached = FALSE;
<span class="line-modified">!           while (ch != *string)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (!*string)</span>
<span class="line-modified">!             return FALSE;</span>
<span class="line-modified">!           string = g_utf8_next_char (string);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!           string++;</span>
<span class="line-modified">!           if (g_pattern_ph_match (pattern, string, &amp;next_wildcard_reached))</span>
<span class="line-modified">!         return TRUE;</span>
                if (next_wildcard_reached)
                  /* the forthcoming pattern substring up to the next wildcard has
                   * been matched, but a mismatch occoured for the rest of the
                   * pattern, following the next wildcard.
                   * there&#39;s no need to advance the current match position any
                   * further if the rest pattern will not match.
                   */
<span class="line-modified">!         return FALSE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       while (*string);</span>
<span class="line-modified">!       break;</span>
  
<span class="line-modified">!     default:</span>
<span class="line-modified">!       if (ch == *string)</span>
<span class="line-modified">!         string++;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         return FALSE;</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
  
        ch = *pattern;
        pattern++;
      }
  
<span class="line-new-header">--- 92,64 ---</span>
    ch = *pattern;
    pattern++;
    while (ch)
      {
        switch (ch)
<span class="line-added">+   {</span>
<span class="line-added">+   case &#39;?&#39;:</span>
<span class="line-added">+     if (!*string)</span>
<span class="line-added">+       return FALSE;</span>
<span class="line-added">+     string = g_utf8_next_char (string);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+   case &#39;*&#39;:</span>
<span class="line-added">+     *wildcard_reached_p = TRUE;</span>
<span class="line-added">+     do</span>
<span class="line-added">+       {</span>
<span class="line-added">+         ch = *pattern;</span>
<span class="line-added">+         pattern++;</span>
<span class="line-added">+         if (ch == &#39;?&#39;)</span>
      {
        if (!*string)
          return FALSE;
        string = g_utf8_next_char (string);
<span class="line-modified">!     }</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     while (ch == &#39;*&#39; || ch == &#39;?&#39;);</span>
<span class="line-modified">!     if (!ch)</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!     do</span>
<span class="line-modified">!       {</span>
                gboolean next_wildcard_reached = FALSE;
<span class="line-modified">!         while (ch != *string)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (!*string)</span>
<span class="line-modified">!         return FALSE;</span>
<span class="line-modified">!       string = g_utf8_next_char (string);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!         string++;</span>
<span class="line-modified">!         if (g_pattern_ph_match (pattern, string, &amp;next_wildcard_reached))</span>
<span class="line-modified">!     return TRUE;</span>
                if (next_wildcard_reached)
                  /* the forthcoming pattern substring up to the next wildcard has
                   * been matched, but a mismatch occoured for the rest of the
                   * pattern, following the next wildcard.
                   * there&#39;s no need to advance the current match position any
                   * further if the rest pattern will not match.
                   */
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     while (*string);</span>
<span class="line-modified">!     break;</span>
  
<span class="line-modified">!   default:</span>
<span class="line-modified">!     if (ch == *string)</span>
<span class="line-modified">!       string++;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     break;</span>
<span class="line-modified">!   }</span>
  
        ch = *pattern;
        pattern++;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,13 ***</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match (GPatternSpec *pspec,
<span class="line-modified">!          guint         string_length,</span>
<span class="line-modified">!          const gchar  *string,</span>
<span class="line-modified">!          const gchar  *string_reversed)</span>
  {
    g_return_val_if_fail (pspec != NULL, FALSE);
    g_return_val_if_fail (string != NULL, FALSE);
  
    if (string_length &lt; pspec-&gt;min_length ||
<span class="line-new-header">--- 184,13 ---</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match (GPatternSpec *pspec,
<span class="line-modified">!      guint         string_length,</span>
<span class="line-modified">!      const gchar  *string,</span>
<span class="line-modified">!      const gchar  *string_reversed)</span>
  {
    g_return_val_if_fail (pspec != NULL, FALSE);
    g_return_val_if_fail (string != NULL, FALSE);
  
    if (string_length &lt; pspec-&gt;min_length ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,32 ***</span>
        gboolean dummy;
      case G_MATCH_ALL:
        return g_pattern_ph_match (pspec-&gt;pattern, string, &amp;dummy);
      case G_MATCH_ALL_TAIL:
        if (string_reversed)
<span class="line-modified">!     return g_pattern_ph_match (pspec-&gt;pattern, string_reversed, &amp;dummy);</span>
        else
<span class="line-modified">!     {</span>
            gboolean result;
            gchar *tmp;
<span class="line-modified">!       tmp = g_utf8_strreverse (string, string_length);</span>
<span class="line-modified">!       result = g_pattern_ph_match (pspec-&gt;pattern, tmp, &amp;dummy);</span>
<span class="line-modified">!       g_free (tmp);</span>
<span class="line-modified">!       return result;</span>
<span class="line-modified">!     }</span>
      case G_MATCH_HEAD:
        if (pspec-&gt;pattern_length == string_length)
<span class="line-modified">!     return strcmp (pspec-&gt;pattern, string) == 0;</span>
        else if (pspec-&gt;pattern_length)
<span class="line-modified">!     return strncmp (pspec-&gt;pattern, string, pspec-&gt;pattern_length) == 0;</span>
        else
<span class="line-modified">!     return TRUE;</span>
      case G_MATCH_TAIL:
        if (pspec-&gt;pattern_length)
          return strcmp (pspec-&gt;pattern, string + (string_length - pspec-&gt;pattern_length)) == 0;
        else
<span class="line-modified">!     return TRUE;</span>
      case G_MATCH_EXACT:
        if (pspec-&gt;pattern_length != string_length)
          return FALSE;
        else
          return strcmp (pspec-&gt;pattern, string) == 0;
<span class="line-new-header">--- 202,32 ---</span>
        gboolean dummy;
      case G_MATCH_ALL:
        return g_pattern_ph_match (pspec-&gt;pattern, string, &amp;dummy);
      case G_MATCH_ALL_TAIL:
        if (string_reversed)
<span class="line-modified">!   return g_pattern_ph_match (pspec-&gt;pattern, string_reversed, &amp;dummy);</span>
        else
<span class="line-modified">!   {</span>
            gboolean result;
            gchar *tmp;
<span class="line-modified">!     tmp = g_utf8_strreverse (string, string_length);</span>
<span class="line-modified">!     result = g_pattern_ph_match (pspec-&gt;pattern, tmp, &amp;dummy);</span>
<span class="line-modified">!     g_free (tmp);</span>
<span class="line-modified">!     return result;</span>
<span class="line-modified">!   }</span>
      case G_MATCH_HEAD:
        if (pspec-&gt;pattern_length == string_length)
<span class="line-modified">!   return strcmp (pspec-&gt;pattern, string) == 0;</span>
        else if (pspec-&gt;pattern_length)
<span class="line-modified">!   return strncmp (pspec-&gt;pattern, string, pspec-&gt;pattern_length) == 0;</span>
        else
<span class="line-modified">!   return TRUE;</span>
      case G_MATCH_TAIL:
        if (pspec-&gt;pattern_length)
          return strcmp (pspec-&gt;pattern, string + (string_length - pspec-&gt;pattern_length)) == 0;
        else
<span class="line-modified">!   return TRUE;</span>
      case G_MATCH_EXACT:
        if (pspec-&gt;pattern_length != string_length)
          return FALSE;
        else
          return strcmp (pspec-&gt;pattern, string) == 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,39 ***</span>
    pspec-&gt;pattern = g_new (gchar, pspec-&gt;pattern_length + 1);
    d = pspec-&gt;pattern;
    for (i = 0, s = pattern; *s != 0; s++)
      {
        switch (*s)
<span class="line-modified">!     {</span>
<span class="line-modified">!     case &#39;*&#39;:</span>
<span class="line-modified">!       if (follows_wildcard) /* compress multiple wildcards */</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           pspec-&gt;pattern_length--;</span>
<span class="line-modified">!           continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       follows_wildcard = TRUE;</span>
<span class="line-removed">-       if (hw_pos &lt; 0)</span>
<span class="line-removed">-         hw_pos = i;</span>
<span class="line-removed">-       tw_pos = i;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     case &#39;?&#39;:</span>
<span class="line-removed">-       pending_jokers++;</span>
<span class="line-removed">-       pspec-&gt;min_length++;</span>
<span class="line-removed">-       pspec-&gt;max_length += 4; /* maximum UTF-8 character length */</span>
<span class="line-removed">-       continue;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       for (; pending_jokers; pending_jokers--, i++) {</span>
<span class="line-removed">-         *d++ = &#39;?&#39;;</span>
<span class="line-removed">-         if (hj_pos &lt; 0)</span>
<span class="line-removed">-          hj_pos = i;</span>
<span class="line-removed">-         tj_pos = i;</span>
        }
<span class="line-modified">!       follows_wildcard = FALSE;</span>
<span class="line-modified">!       pspec-&gt;min_length++;</span>
<span class="line-modified">!       pspec-&gt;max_length++;</span>
<span class="line-modified">!       break;</span>
      }
        *d++ = *s;
        i++;
      }
    for (; pending_jokers; pending_jokers--) {
      *d++ = &#39;?&#39;;
<span class="line-new-header">--- 267,39 ---</span>
    pspec-&gt;pattern = g_new (gchar, pspec-&gt;pattern_length + 1);
    d = pspec-&gt;pattern;
    for (i = 0, s = pattern; *s != 0; s++)
      {
        switch (*s)
<span class="line-modified">!   {</span>
<span class="line-modified">!   case &#39;*&#39;:</span>
<span class="line-modified">!     if (follows_wildcard) /* compress multiple wildcards */</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         pspec-&gt;pattern_length--;</span>
<span class="line-modified">!         continue;</span>
        }
<span class="line-modified">!     follows_wildcard = TRUE;</span>
<span class="line-modified">!     if (hw_pos &lt; 0)</span>
<span class="line-modified">!       hw_pos = i;</span>
<span class="line-modified">!     tw_pos = i;</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   case &#39;?&#39;:</span>
<span class="line-added">+     pending_jokers++;</span>
<span class="line-added">+     pspec-&gt;min_length++;</span>
<span class="line-added">+     pspec-&gt;max_length += 4; /* maximum UTF-8 character length */</span>
<span class="line-added">+     continue;</span>
<span class="line-added">+   default:</span>
<span class="line-added">+     for (; pending_jokers; pending_jokers--, i++) {</span>
<span class="line-added">+       *d++ = &#39;?&#39;;</span>
<span class="line-added">+         if (hj_pos &lt; 0)</span>
<span class="line-added">+        hj_pos = i;</span>
<span class="line-added">+       tj_pos = i;</span>
      }
<span class="line-added">+     follows_wildcard = FALSE;</span>
<span class="line-added">+     pspec-&gt;min_length++;</span>
<span class="line-added">+     pspec-&gt;max_length++;</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   }</span>
        *d++ = *s;
        i++;
      }
    for (; pending_jokers; pending_jokers--) {
      *d++ = &#39;?&#39;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,28 ***</span>
  
    /* special case sole head/tail wildcard or exact matches */
    if (!seen_joker &amp;&amp; !more_wildcards)
      {
        if (pspec-&gt;pattern[0] == &#39;*&#39;)
<span class="line-modified">!     {</span>
<span class="line-modified">!       pspec-&gt;match_type = G_MATCH_TAIL;</span>
            memmove (pspec-&gt;pattern, pspec-&gt;pattern + 1, --pspec-&gt;pattern_length);
<span class="line-modified">!       pspec-&gt;pattern[pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">!       return pspec;</span>
<span class="line-modified">!     }</span>
        if (pspec-&gt;pattern_length &gt; 0 &amp;&amp;
<span class="line-modified">!       pspec-&gt;pattern[pspec-&gt;pattern_length - 1] == &#39;*&#39;)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       pspec-&gt;match_type = G_MATCH_HEAD;</span>
<span class="line-modified">!       pspec-&gt;pattern[--pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">!       return pspec;</span>
<span class="line-modified">!     }</span>
        if (!seen_wildcard)
<span class="line-modified">!     {</span>
<span class="line-modified">!       pspec-&gt;match_type = G_MATCH_EXACT;</span>
<span class="line-modified">!       return pspec;</span>
<span class="line-modified">!     }</span>
      }
  
    /* now just need to distinguish between head or tail match start */
    tw_pos = pspec-&gt;pattern_length - 1 - tw_pos;  /* last pos to tail distance */
    tj_pos = pspec-&gt;pattern_length - 1 - tj_pos;  /* last pos to tail distance */
<span class="line-new-header">--- 316,28 ---</span>
  
    /* special case sole head/tail wildcard or exact matches */
    if (!seen_joker &amp;&amp; !more_wildcards)
      {
        if (pspec-&gt;pattern[0] == &#39;*&#39;)
<span class="line-modified">!   {</span>
<span class="line-modified">!     pspec-&gt;match_type = G_MATCH_TAIL;</span>
            memmove (pspec-&gt;pattern, pspec-&gt;pattern + 1, --pspec-&gt;pattern_length);
<span class="line-modified">!     pspec-&gt;pattern[pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">!     return pspec;</span>
<span class="line-modified">!   }</span>
        if (pspec-&gt;pattern_length &gt; 0 &amp;&amp;
<span class="line-modified">!     pspec-&gt;pattern[pspec-&gt;pattern_length - 1] == &#39;*&#39;)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     pspec-&gt;match_type = G_MATCH_HEAD;</span>
<span class="line-modified">!     pspec-&gt;pattern[--pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">!     return pspec;</span>
<span class="line-modified">!   }</span>
        if (!seen_wildcard)
<span class="line-modified">!   {</span>
<span class="line-modified">!     pspec-&gt;match_type = G_MATCH_EXACT;</span>
<span class="line-modified">!     return pspec;</span>
<span class="line-modified">!   }</span>
      }
  
    /* now just need to distinguish between head or tail match start */
    tw_pos = pspec-&gt;pattern_length - 1 - tw_pos;  /* last pos to tail distance */
    tj_pos = pspec-&gt;pattern_length - 1 - tj_pos;  /* last pos to tail distance */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,18 ***</span>
   *
   * Returns: Whether the compiled patterns are equal
   **/
  gboolean
  g_pattern_spec_equal (GPatternSpec *pspec1,
<span class="line-modified">!               GPatternSpec *pspec2)</span>
  {
    g_return_val_if_fail (pspec1 != NULL, FALSE);
    g_return_val_if_fail (pspec2 != NULL, FALSE);
  
    return (pspec1-&gt;pattern_length == pspec2-&gt;pattern_length &amp;&amp;
<span class="line-modified">!       pspec1-&gt;match_type == pspec2-&gt;match_type &amp;&amp;</span>
<span class="line-modified">!       strcmp (pspec1-&gt;pattern, pspec2-&gt;pattern) == 0);</span>
  }
  
  /**
   * g_pattern_match_string:
   * @pspec: a #GPatternSpec
<span class="line-new-header">--- 378,18 ---</span>
   *
   * Returns: Whether the compiled patterns are equal
   **/
  gboolean
  g_pattern_spec_equal (GPatternSpec *pspec1,
<span class="line-modified">!           GPatternSpec *pspec2)</span>
  {
    g_return_val_if_fail (pspec1 != NULL, FALSE);
    g_return_val_if_fail (pspec2 != NULL, FALSE);
  
    return (pspec1-&gt;pattern_length == pspec2-&gt;pattern_length &amp;&amp;
<span class="line-modified">!     pspec1-&gt;match_type == pspec2-&gt;match_type &amp;&amp;</span>
<span class="line-modified">!     strcmp (pspec1-&gt;pattern, pspec2-&gt;pattern) == 0);</span>
  }
  
  /**
   * g_pattern_match_string:
   * @pspec: a #GPatternSpec
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,11 ***</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match_string (GPatternSpec *pspec,
<span class="line-modified">!             const gchar  *string)</span>
  {
    g_return_val_if_fail (pspec != NULL, FALSE);
    g_return_val_if_fail (string != NULL, FALSE);
  
    return g_pattern_match (pspec, strlen (string), string, NULL);
<span class="line-new-header">--- 401,11 ---</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match_string (GPatternSpec *pspec,
<span class="line-modified">!       const gchar  *string)</span>
  {
    g_return_val_if_fail (pspec != NULL, FALSE);
    g_return_val_if_fail (string != NULL, FALSE);
  
    return g_pattern_match (pspec, strlen (string), string, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,11 ***</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match_simple (const gchar *pattern,
<span class="line-modified">!             const gchar *string)</span>
  {
    GPatternSpec *pspec;
    gboolean ergo;
  
    g_return_val_if_fail (pattern != NULL, FALSE);
<span class="line-new-header">--- 423,11 ---</span>
   *
   * Returns: %TRUE if @string matches @pspec
   **/
  gboolean
  g_pattern_match_simple (const gchar *pattern,
<span class="line-modified">!       const gchar *string)</span>
  {
    GPatternSpec *pspec;
    gboolean ergo;
  
    g_return_val_if_fail (pattern != NULL, FALSE);
</pre>
<center><a href="goption.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpattern.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>