<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiobasesrc.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *
   5  * gstaudiobasesrc.c:
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstaudiobasesrc
  25  * @title: GstAudioBaseSrc
  26  * @short_description: Base class for audio sources
  27  * @see_also: #GstAudioSrc, #GstAudioRingBuffer.
  28  *
  29  * This is the base class for audio sources. Subclasses need to implement the
  30  * ::create_ringbuffer vmethod. This base class will then take care of
  31  * reading samples from the ringbuffer, synchronisation and flushing.
  32  */
  33 
  34 #ifdef HAVE_CONFIG_H
  35 #  include &quot;config.h&quot;
  36 #endif
  37 
  38 #include &lt;string.h&gt;
  39 
  40 #include &lt;gst/audio/audio.h&gt;
  41 #include &quot;gstaudiobasesrc.h&quot;
  42 
  43 #include &quot;gst/gst-i18n-plugin.h&quot;
  44 
  45 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_src_debug);
  46 #define GST_CAT_DEFAULT gst_audio_base_src_debug
  47 
<a name="1" id="anc1"></a><span class="line-removed">  48 #define GST_AUDIO_BASE_SRC_GET_PRIVATE(obj)  \</span>
<span class="line-removed">  49    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_BASE_SRC, GstAudioBaseSrcPrivate))</span>
<span class="line-removed">  50 </span>
  51 struct _GstAudioBaseSrcPrivate
  52 {
  53   /* the clock slaving algorithm in use */
  54   GstAudioBaseSrcSlaveMethod slave_method;
  55 };
  56 
  57 /* BaseAudioSrc signals and args */
  58 enum
  59 {
  60   /* FILL ME */
  61   LAST_SIGNAL
  62 };
  63 
  64 /* FIXME: 2.0, handle BUFFER_TIME and LATENCY in nanoseconds */
  65 #define DEFAULT_BUFFER_TIME     ((200 * GST_MSECOND) / GST_USECOND)
  66 #define DEFAULT_LATENCY_TIME    ((10 * GST_MSECOND) / GST_USECOND)
  67 #define DEFAULT_ACTUAL_BUFFER_TIME     -1
  68 #define DEFAULT_ACTUAL_LATENCY_TIME    -1
  69 #define DEFAULT_PROVIDE_CLOCK   TRUE
  70 #define DEFAULT_SLAVE_METHOD    GST_AUDIO_BASE_SRC_SLAVE_SKEW
  71 
  72 enum
  73 {
  74   PROP_0,
  75   PROP_BUFFER_TIME,
  76   PROP_LATENCY_TIME,
  77   PROP_ACTUAL_BUFFER_TIME,
  78   PROP_ACTUAL_LATENCY_TIME,
  79   PROP_PROVIDE_CLOCK,
  80   PROP_SLAVE_METHOD,
  81   PROP_LAST
  82 };
  83 
  84 static void
  85 _do_init (GType type)
  86 {
  87   GST_DEBUG_CATEGORY_INIT (gst_audio_base_src_debug, &quot;audiobasesrc&quot;, 0,
  88       &quot;audiobasesrc element&quot;);
  89 
  90 #ifdef ENABLE_NLS
  91   GST_DEBUG (&quot;binding text domain %s to locale dir %s&quot;, GETTEXT_PACKAGE,
  92       LOCALEDIR);
  93   bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
  94   bind_textdomain_codeset (GETTEXT_PACKAGE, &quot;UTF-8&quot;);
  95 #endif /* ENABLE_NLS */
  96 }
  97 
  98 #define gst_audio_base_src_parent_class parent_class
  99 G_DEFINE_TYPE_WITH_CODE (GstAudioBaseSrc, gst_audio_base_src, GST_TYPE_PUSH_SRC,
<a name="2" id="anc2"></a>
 100     _do_init (g_define_type_id));
 101 
 102 static void gst_audio_base_src_set_property (GObject * object, guint prop_id,
 103     const GValue * value, GParamSpec * pspec);
 104 static void gst_audio_base_src_get_property (GObject * object, guint prop_id,
 105     GValue * value, GParamSpec * pspec);
 106 static void gst_audio_base_src_dispose (GObject * object);
 107 
 108 static GstStateChangeReturn gst_audio_base_src_change_state (GstElement *
 109     element, GstStateChange transition);
 110 static gboolean gst_audio_base_src_post_message (GstElement * element,
 111     GstMessage * message);
 112 static GstClock *gst_audio_base_src_provide_clock (GstElement * elem);
 113 static GstClockTime gst_audio_base_src_get_time (GstClock * clock,
 114     GstAudioBaseSrc * src);
 115 
 116 static GstFlowReturn gst_audio_base_src_create (GstBaseSrc * bsrc,
 117     guint64 offset, guint length, GstBuffer ** buf);
 118 
 119 static gboolean gst_audio_base_src_event (GstBaseSrc * bsrc, GstEvent * event);
 120 static void gst_audio_base_src_get_times (GstBaseSrc * bsrc,
 121     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 122 static gboolean gst_audio_base_src_setcaps (GstBaseSrc * bsrc, GstCaps * caps);
 123 static gboolean gst_audio_base_src_query (GstBaseSrc * bsrc, GstQuery * query);
 124 static GstCaps *gst_audio_base_src_fixate (GstBaseSrc * bsrc, GstCaps * caps);
 125 
 126 /* static guint gst_audio_base_src_signals[LAST_SIGNAL] = { 0 }; */
 127 
 128 static void
 129 gst_audio_base_src_class_init (GstAudioBaseSrcClass * klass)
 130 {
 131   GObjectClass *gobject_class;
 132   GstElementClass *gstelement_class;
 133   GstBaseSrcClass *gstbasesrc_class;
 134 
 135   gobject_class = (GObjectClass *) klass;
 136   gstelement_class = (GstElementClass *) klass;
 137   gstbasesrc_class = (GstBaseSrcClass *) klass;
 138 
<a name="3" id="anc3"></a><span class="line-removed"> 139   g_type_class_add_private (klass, sizeof (GstAudioBaseSrcPrivate));</span>
<span class="line-removed"> 140 </span>
 141   gobject_class-&gt;set_property = gst_audio_base_src_set_property;
 142   gobject_class-&gt;get_property = gst_audio_base_src_get_property;
 143   gobject_class-&gt;dispose = gst_audio_base_src_dispose;
 144 
 145   /* FIXME: 2.0, handle BUFFER_TIME and LATENCY in nanoseconds */
 146   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
 147       g_param_spec_int64 (&quot;buffer-time&quot;, &quot;Buffer Time&quot;,
 148           &quot;Size of audio buffer in microseconds. This is the maximum amount &quot;
 149           &quot;of data that is buffered in the device and the maximum latency that &quot;
 150           &quot;the source reports. This value might be ignored by the element if &quot;
 151           &quot;necessary; see \&quot;actual-buffer-time\&quot;&quot;,
 152           1, G_MAXINT64, DEFAULT_BUFFER_TIME,
 153           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 154 
 155   g_object_class_install_property (gobject_class, PROP_LATENCY_TIME,
 156       g_param_spec_int64 (&quot;latency-time&quot;, &quot;Latency Time&quot;,
 157           &quot;The minimum amount of data to read in each iteration in &quot;
 158           &quot;microseconds. This is the minimum latency that the source reports. &quot;
 159           &quot;This value might be ignored by the element if necessary; see &quot;
 160           &quot;\&quot;actual-latency-time\&quot;&quot;, 1, G_MAXINT64, DEFAULT_LATENCY_TIME,
 161           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 162 
 163   /**
 164    * GstAudioBaseSrc:actual-buffer-time:
 165    *
 166    * Actual configured size of audio buffer in microseconds.
 167    **/
 168   g_object_class_install_property (gobject_class, PROP_ACTUAL_BUFFER_TIME,
 169       g_param_spec_int64 (&quot;actual-buffer-time&quot;, &quot;Actual Buffer Time&quot;,
 170           &quot;Actual configured size of audio buffer in microseconds&quot;,
 171           DEFAULT_ACTUAL_BUFFER_TIME, G_MAXINT64, DEFAULT_ACTUAL_BUFFER_TIME,
 172           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 173 
 174   /**
 175    * GstAudioBaseSrc:actual-latency-time:
 176    *
 177    * Actual configured audio latency in microseconds.
 178    **/
 179   g_object_class_install_property (gobject_class, PROP_ACTUAL_LATENCY_TIME,
 180       g_param_spec_int64 (&quot;actual-latency-time&quot;, &quot;Actual Latency Time&quot;,
 181           &quot;Actual configured audio latency in microseconds&quot;,
 182           DEFAULT_ACTUAL_LATENCY_TIME, G_MAXINT64, DEFAULT_ACTUAL_LATENCY_TIME,
 183           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 184 
 185   g_object_class_install_property (gobject_class, PROP_PROVIDE_CLOCK,
 186       g_param_spec_boolean (&quot;provide-clock&quot;, &quot;Provide Clock&quot;,
 187           &quot;Provide a clock to be used as the global pipeline clock&quot;,
 188           DEFAULT_PROVIDE_CLOCK, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 189 
 190   g_object_class_install_property (gobject_class, PROP_SLAVE_METHOD,
 191       g_param_spec_enum (&quot;slave-method&quot;, &quot;Slave Method&quot;,
 192           &quot;Algorithm used to match the rate of the masterclock&quot;,
 193           GST_TYPE_AUDIO_BASE_SRC_SLAVE_METHOD, DEFAULT_SLAVE_METHOD,
 194           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 195 
 196   gstelement_class-&gt;change_state =
 197       GST_DEBUG_FUNCPTR (gst_audio_base_src_change_state);
 198   gstelement_class-&gt;provide_clock =
 199       GST_DEBUG_FUNCPTR (gst_audio_base_src_provide_clock);
 200   gstelement_class-&gt;post_message =
 201       GST_DEBUG_FUNCPTR (gst_audio_base_src_post_message);
 202 
 203   gstbasesrc_class-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_audio_base_src_setcaps);
 204   gstbasesrc_class-&gt;event = GST_DEBUG_FUNCPTR (gst_audio_base_src_event);
 205   gstbasesrc_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_src_query);
 206   gstbasesrc_class-&gt;get_times =
 207       GST_DEBUG_FUNCPTR (gst_audio_base_src_get_times);
 208   gstbasesrc_class-&gt;create = GST_DEBUG_FUNCPTR (gst_audio_base_src_create);
 209   gstbasesrc_class-&gt;fixate = GST_DEBUG_FUNCPTR (gst_audio_base_src_fixate);
 210 
 211   /* ref class from a thread-safe context to work around missing bit of
 212    * thread-safety in GObject */
 213   g_type_class_ref (GST_TYPE_AUDIO_CLOCK);
 214   g_type_class_ref (GST_TYPE_AUDIO_RING_BUFFER);
 215 }
 216 
 217 static void
 218 gst_audio_base_src_init (GstAudioBaseSrc * audiobasesrc)
 219 {
<a name="4" id="anc4"></a><span class="line-modified"> 220   audiobasesrc-&gt;priv = GST_AUDIO_BASE_SRC_GET_PRIVATE (audiobasesrc);</span>
 221 
 222   audiobasesrc-&gt;buffer_time = DEFAULT_BUFFER_TIME;
 223   audiobasesrc-&gt;latency_time = DEFAULT_LATENCY_TIME;
 224   if (DEFAULT_PROVIDE_CLOCK)
 225     GST_OBJECT_FLAG_SET (audiobasesrc, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 226   else
 227     GST_OBJECT_FLAG_UNSET (audiobasesrc, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 228   audiobasesrc-&gt;priv-&gt;slave_method = DEFAULT_SLAVE_METHOD;
 229   /* reset blocksize we use latency time to calculate a more useful
 230    * value based on negotiated format. */
 231   GST_BASE_SRC (audiobasesrc)-&gt;blocksize = 0;
 232 
 233   audiobasesrc-&gt;clock = gst_audio_clock_new (&quot;GstAudioSrcClock&quot;,
 234       (GstAudioClockGetTimeFunc) gst_audio_base_src_get_time, audiobasesrc,
 235       NULL);
 236 
 237 
 238   /* we are always a live source */
 239   gst_base_src_set_live (GST_BASE_SRC (audiobasesrc), TRUE);
 240   /* we operate in time */
 241   gst_base_src_set_format (GST_BASE_SRC (audiobasesrc), GST_FORMAT_TIME);
 242 }
 243 
 244 static void
 245 gst_audio_base_src_dispose (GObject * object)
 246 {
 247   GstAudioBaseSrc *src;
 248 
 249   src = GST_AUDIO_BASE_SRC (object);
 250 
 251   GST_OBJECT_LOCK (src);
 252   if (src-&gt;clock) {
 253     gst_audio_clock_invalidate (GST_AUDIO_CLOCK (src-&gt;clock));
 254     gst_object_unref (src-&gt;clock);
 255     src-&gt;clock = NULL;
 256   }
 257 
 258   if (src-&gt;ringbuffer) {
 259     gst_object_unparent (GST_OBJECT_CAST (src-&gt;ringbuffer));
 260     src-&gt;ringbuffer = NULL;
 261   }
 262   GST_OBJECT_UNLOCK (src);
 263 
 264   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 265 }
 266 
 267 static GstClock *
 268 gst_audio_base_src_provide_clock (GstElement * elem)
 269 {
 270   GstAudioBaseSrc *src;
 271   GstClock *clock;
 272 
 273   src = GST_AUDIO_BASE_SRC (elem);
 274 
 275   /* we have no ringbuffer (must be NULL state) */
 276   if (src-&gt;ringbuffer == NULL)
 277     goto wrong_state;
 278 
 279   if (gst_audio_ring_buffer_is_flushing (src-&gt;ringbuffer))
 280     goto wrong_state;
 281 
 282   GST_OBJECT_LOCK (src);
 283 
 284   if (!GST_OBJECT_FLAG_IS_SET (src, GST_ELEMENT_FLAG_PROVIDE_CLOCK))
 285     goto clock_disabled;
 286 
 287   clock = GST_CLOCK_CAST (gst_object_ref (src-&gt;clock));
 288   GST_OBJECT_UNLOCK (src);
 289 
 290   return clock;
 291 
 292   /* ERRORS */
 293 wrong_state:
 294   {
 295     GST_DEBUG_OBJECT (src, &quot;ringbuffer is flushing&quot;);
 296     return NULL;
 297   }
 298 clock_disabled:
 299   {
 300     GST_DEBUG_OBJECT (src, &quot;clock provide disabled&quot;);
 301     GST_OBJECT_UNLOCK (src);
 302     return NULL;
 303   }
 304 }
 305 
 306 static GstClockTime
 307 gst_audio_base_src_get_time (GstClock * clock, GstAudioBaseSrc * src)
 308 {
 309   guint64 raw, samples;
 310   guint delay;
 311   GstClockTime result;
 312 
 313   if (G_UNLIKELY (src-&gt;ringbuffer == NULL
 314           || src-&gt;ringbuffer-&gt;spec.info.rate == 0))
 315     return GST_CLOCK_TIME_NONE;
 316 
 317   raw = samples = gst_audio_ring_buffer_samples_done (src-&gt;ringbuffer);
 318 
 319   /* the number of samples not yet processed, this is still queued in the
 320    * device (not yet read for capture). */
 321   delay = gst_audio_ring_buffer_delay (src-&gt;ringbuffer);
 322 
 323   samples += delay;
 324 
 325   result = gst_util_uint64_scale_int (samples, GST_SECOND,
 326       src-&gt;ringbuffer-&gt;spec.info.rate);
 327 
 328   GST_DEBUG_OBJECT (src,
 329       &quot;processed samples: raw %&quot; G_GUINT64_FORMAT &quot;, delay %u, real %&quot;
 330       G_GUINT64_FORMAT &quot;, time %&quot; GST_TIME_FORMAT, raw, delay, samples,
 331       GST_TIME_ARGS (result));
 332 
 333   return result;
 334 }
 335 
 336 /**
 337  * gst_audio_base_src_set_provide_clock:
 338  * @src: a #GstAudioBaseSrc
 339  * @provide: new state
 340  *
 341  * Controls whether @src will provide a clock or not. If @provide is %TRUE,
 342  * gst_element_provide_clock() will return a clock that reflects the datarate
 343  * of @src. If @provide is %FALSE, gst_element_provide_clock() will return NULL.
 344  */
 345 void
 346 gst_audio_base_src_set_provide_clock (GstAudioBaseSrc * src, gboolean provide)
 347 {
 348   g_return_if_fail (GST_IS_AUDIO_BASE_SRC (src));
 349 
 350   GST_OBJECT_LOCK (src);
 351   if (provide)
 352     GST_OBJECT_FLAG_SET (src, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 353   else
 354     GST_OBJECT_FLAG_UNSET (src, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 355   GST_OBJECT_UNLOCK (src);
 356 }
 357 
 358 /**
 359  * gst_audio_base_src_get_provide_clock:
 360  * @src: a #GstAudioBaseSrc
 361  *
 362  * Queries whether @src will provide a clock or not. See also
 363  * gst_audio_base_src_set_provide_clock.
 364  *
 365  * Returns: %TRUE if @src will provide a clock.
 366  */
 367 gboolean
 368 gst_audio_base_src_get_provide_clock (GstAudioBaseSrc * src)
 369 {
 370   gboolean result;
 371 
 372   g_return_val_if_fail (GST_IS_AUDIO_BASE_SRC (src), FALSE);
 373 
 374   GST_OBJECT_LOCK (src);
 375   result = GST_OBJECT_FLAG_IS_SET (src, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 376   GST_OBJECT_UNLOCK (src);
 377 
 378   return result;
 379 }
 380 
 381 /**
 382  * gst_audio_base_src_set_slave_method:
 383  * @src: a #GstAudioBaseSrc
 384  * @method: the new slave method
 385  *
 386  * Controls how clock slaving will be performed in @src.
 387  */
 388 void
 389 gst_audio_base_src_set_slave_method (GstAudioBaseSrc * src,
 390     GstAudioBaseSrcSlaveMethod method)
 391 {
 392   g_return_if_fail (GST_IS_AUDIO_BASE_SRC (src));
 393 
 394   GST_OBJECT_LOCK (src);
 395   src-&gt;priv-&gt;slave_method = method;
 396   GST_OBJECT_UNLOCK (src);
 397 }
 398 
 399 /**
 400  * gst_audio_base_src_get_slave_method:
 401  * @src: a #GstAudioBaseSrc
 402  *
 403  * Get the current slave method used by @src.
 404  *
 405  * Returns: The current slave method used by @src.
 406  */
 407 GstAudioBaseSrcSlaveMethod
 408 gst_audio_base_src_get_slave_method (GstAudioBaseSrc * src)
 409 {
 410   GstAudioBaseSrcSlaveMethod result;
 411 
 412   g_return_val_if_fail (GST_IS_AUDIO_BASE_SRC (src), -1);
 413 
 414   GST_OBJECT_LOCK (src);
 415   result = src-&gt;priv-&gt;slave_method;
 416   GST_OBJECT_UNLOCK (src);
 417 
 418   return result;
 419 }
 420 
 421 static void
 422 gst_audio_base_src_set_property (GObject * object, guint prop_id,
 423     const GValue * value, GParamSpec * pspec)
 424 {
 425   GstAudioBaseSrc *src;
 426 
 427   src = GST_AUDIO_BASE_SRC (object);
 428 
 429   switch (prop_id) {
 430     case PROP_BUFFER_TIME:
 431       src-&gt;buffer_time = g_value_get_int64 (value);
 432       break;
 433     case PROP_LATENCY_TIME:
 434       src-&gt;latency_time = g_value_get_int64 (value);
 435       break;
 436     case PROP_PROVIDE_CLOCK:
 437       gst_audio_base_src_set_provide_clock (src, g_value_get_boolean (value));
 438       break;
 439     case PROP_SLAVE_METHOD:
 440       gst_audio_base_src_set_slave_method (src, g_value_get_enum (value));
 441       break;
 442     default:
 443       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 444       break;
 445   }
 446 }
 447 
 448 static void
 449 gst_audio_base_src_get_property (GObject * object, guint prop_id,
 450     GValue * value, GParamSpec * pspec)
 451 {
 452   GstAudioBaseSrc *src;
 453 
 454   src = GST_AUDIO_BASE_SRC (object);
 455 
 456   switch (prop_id) {
 457     case PROP_BUFFER_TIME:
 458       g_value_set_int64 (value, src-&gt;buffer_time);
 459       break;
 460     case PROP_LATENCY_TIME:
 461       g_value_set_int64 (value, src-&gt;latency_time);
 462       break;
 463     case PROP_ACTUAL_BUFFER_TIME:
 464       GST_OBJECT_LOCK (src);
 465       if (src-&gt;ringbuffer &amp;&amp; src-&gt;ringbuffer-&gt;acquired)
 466         g_value_set_int64 (value, src-&gt;ringbuffer-&gt;spec.buffer_time);
 467       else
 468         g_value_set_int64 (value, DEFAULT_ACTUAL_BUFFER_TIME);
 469       GST_OBJECT_UNLOCK (src);
 470       break;
 471     case PROP_ACTUAL_LATENCY_TIME:
 472       GST_OBJECT_LOCK (src);
 473       if (src-&gt;ringbuffer &amp;&amp; src-&gt;ringbuffer-&gt;acquired)
 474         g_value_set_int64 (value, src-&gt;ringbuffer-&gt;spec.latency_time);
 475       else
 476         g_value_set_int64 (value, DEFAULT_ACTUAL_LATENCY_TIME);
 477       GST_OBJECT_UNLOCK (src);
 478       break;
 479     case PROP_PROVIDE_CLOCK:
 480       g_value_set_boolean (value, gst_audio_base_src_get_provide_clock (src));
 481       break;
 482     case PROP_SLAVE_METHOD:
 483       g_value_set_enum (value, gst_audio_base_src_get_slave_method (src));
 484       break;
 485     default:
 486       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 487       break;
 488   }
 489 }
 490 
 491 static GstCaps *
 492 gst_audio_base_src_fixate (GstBaseSrc * bsrc, GstCaps * caps)
 493 {
 494   GstStructure *s;
 495 
 496   caps = gst_caps_make_writable (caps);
 497 
 498   s = gst_caps_get_structure (caps, 0);
 499 
 500   /* fields for all formats */
 501   gst_structure_fixate_field_nearest_int (s, &quot;rate&quot;, GST_AUDIO_DEF_RATE);
 502   gst_structure_fixate_field_nearest_int (s, &quot;channels&quot;,
 503       GST_AUDIO_DEF_CHANNELS);
 504   gst_structure_fixate_field_string (s, &quot;format&quot;, GST_AUDIO_DEF_FORMAT);
 505 
 506   caps = GST_BASE_SRC_CLASS (parent_class)-&gt;fixate (bsrc, caps);
 507 
 508   return caps;
 509 }
 510 
 511 static gboolean
 512 gst_audio_base_src_setcaps (GstBaseSrc * bsrc, GstCaps * caps)
 513 {
 514   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (bsrc);
 515   GstAudioRingBufferSpec *spec;
 516   gint bpf, rate;
 517 
 518   spec = &amp;src-&gt;ringbuffer-&gt;spec;
 519 
 520   if (G_UNLIKELY (spec-&gt;caps &amp;&amp; gst_caps_is_equal (spec-&gt;caps, caps))) {
 521     GST_DEBUG_OBJECT (src,
 522         &quot;Ringbuffer caps haven&#39;t changed, skipping reconfiguration&quot;);
 523     return TRUE;
 524   }
 525 
 526   GST_DEBUG (&quot;release old ringbuffer&quot;);
 527   gst_audio_ring_buffer_release (src-&gt;ringbuffer);
 528 
 529   spec-&gt;buffer_time = src-&gt;buffer_time;
 530   spec-&gt;latency_time = src-&gt;latency_time;
 531 
 532   GST_OBJECT_LOCK (src);
 533   if (!gst_audio_ring_buffer_parse_caps (spec, caps)) {
 534     GST_OBJECT_UNLOCK (src);
 535     goto parse_error;
 536   }
 537 
 538   bpf = GST_AUDIO_INFO_BPF (&amp;spec-&gt;info);
 539   rate = GST_AUDIO_INFO_RATE (&amp;spec-&gt;info);
 540 
 541   /* calculate suggested segsize and segtotal */
 542   spec-&gt;segsize = rate * bpf * spec-&gt;latency_time / GST_MSECOND;
 543   /* Round to an integer number of samples */
 544   spec-&gt;segsize -= spec-&gt;segsize % bpf;
 545   spec-&gt;segtotal = spec-&gt;buffer_time / spec-&gt;latency_time;
 546 
 547   GST_OBJECT_UNLOCK (src);
 548 
 549   gst_audio_ring_buffer_debug_spec_buff (spec);
 550 
 551   GST_DEBUG (&quot;acquire new ringbuffer&quot;);
 552 
 553   if (!gst_audio_ring_buffer_acquire (src-&gt;ringbuffer, spec))
 554     goto acquire_error;
 555 
 556   /* calculate actual latency and buffer times */
 557   spec-&gt;latency_time = spec-&gt;segsize * GST_MSECOND / (rate * bpf);
 558   spec-&gt;buffer_time =
 559       spec-&gt;segtotal * spec-&gt;segsize * GST_MSECOND / (rate * bpf);
 560 
 561   gst_audio_ring_buffer_debug_spec_buff (spec);
 562 
 563   g_object_notify (G_OBJECT (src), &quot;actual-buffer-time&quot;);
 564   g_object_notify (G_OBJECT (src), &quot;actual-latency-time&quot;);
 565 
 566   gst_element_post_message (GST_ELEMENT_CAST (bsrc),
 567       gst_message_new_latency (GST_OBJECT (bsrc)));
 568 
 569   return TRUE;
 570 
 571   /* ERRORS */
 572 parse_error:
 573   {
 574     GST_DEBUG (&quot;could not parse caps&quot;);
 575     return FALSE;
 576   }
 577 acquire_error:
 578   {
 579     GST_DEBUG (&quot;could not acquire ringbuffer&quot;);
 580     return FALSE;
 581   }
 582 }
 583 
 584 static void
 585 gst_audio_base_src_get_times (GstBaseSrc * bsrc, GstBuffer * buffer,
 586     GstClockTime * start, GstClockTime * end)
 587 {
 588   /* No need to sync to a clock here. We schedule the samples based
 589    * on our own clock for the moment. */
 590   *start = GST_CLOCK_TIME_NONE;
 591   *end = GST_CLOCK_TIME_NONE;
 592 }
 593 
 594 static gboolean
 595 gst_audio_base_src_query (GstBaseSrc * bsrc, GstQuery * query)
 596 {
 597   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (bsrc);
 598   gboolean res = FALSE;
 599 
 600   switch (GST_QUERY_TYPE (query)) {
 601     case GST_QUERY_LATENCY:
 602     {
 603       GstClockTime min_latency, max_latency;
 604       GstAudioRingBufferSpec *spec;
 605       gint bpf, rate;
 606 
 607       GST_OBJECT_LOCK (src);
 608       if (G_UNLIKELY (src-&gt;ringbuffer == NULL
 609               || src-&gt;ringbuffer-&gt;spec.info.rate == 0)) {
 610         GST_OBJECT_UNLOCK (src);
 611         goto done;
 612       }
 613 
 614       spec = &amp;src-&gt;ringbuffer-&gt;spec;
 615       rate = GST_AUDIO_INFO_RATE (&amp;spec-&gt;info);
 616       bpf = GST_AUDIO_INFO_BPF (&amp;spec-&gt;info);
 617 
 618       /* we have at least 1 segment of latency */
 619       min_latency =
 620           gst_util_uint64_scale_int (spec-&gt;segsize, GST_SECOND, rate * bpf);
 621       /* we cannot delay more than the buffersize else we lose data */
 622       max_latency =
 623           gst_util_uint64_scale_int (spec-&gt;segtotal * spec-&gt;segsize, GST_SECOND,
 624           rate * bpf);
 625       GST_OBJECT_UNLOCK (src);
 626 
 627       GST_DEBUG_OBJECT (src,
 628           &quot;report latency min %&quot; GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT,
 629           GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
 630 
 631       /* we are always live, the min latency is 1 segment and the max latency is
 632        * the complete buffer of segments. */
 633       gst_query_set_latency (query, TRUE, min_latency, max_latency);
 634 
 635       res = TRUE;
 636       break;
 637     }
 638     case GST_QUERY_SCHEDULING:
 639     {
 640       /* We allow limited pull base operation. Basically, pulling can be
 641        * done on any number of bytes as long as the offset is -1 or
 642        * sequentially increasing. */
 643       gst_query_set_scheduling (query, GST_SCHEDULING_FLAG_SEQUENTIAL, 1, -1,
 644           0);
 645       gst_query_add_scheduling_mode (query, GST_PAD_MODE_PULL);
 646       gst_query_add_scheduling_mode (query, GST_PAD_MODE_PUSH);
 647 
 648       res = TRUE;
 649       break;
 650     }
 651     default:
 652       res = GST_BASE_SRC_CLASS (parent_class)-&gt;query (bsrc, query);
 653       break;
 654   }
 655 done:
 656   return res;
 657 }
 658 
 659 static gboolean
 660 gst_audio_base_src_event (GstBaseSrc * bsrc, GstEvent * event)
 661 {
 662   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (bsrc);
 663   gboolean res, forward;
 664 
 665   res = FALSE;
 666   forward = TRUE;
 667 
 668   switch (GST_EVENT_TYPE (event)) {
 669     case GST_EVENT_FLUSH_START:
 670       GST_DEBUG_OBJECT (bsrc, &quot;flush-start&quot;);
 671       gst_audio_ring_buffer_pause (src-&gt;ringbuffer);
 672       gst_audio_ring_buffer_clear_all (src-&gt;ringbuffer);
 673       break;
 674     case GST_EVENT_FLUSH_STOP:
 675       GST_DEBUG_OBJECT (bsrc, &quot;flush-stop&quot;);
 676       /* always resync on sample after a flush */
 677       src-&gt;next_sample = -1;
 678       gst_audio_ring_buffer_clear_all (src-&gt;ringbuffer);
 679       break;
 680     case GST_EVENT_SEEK:
 681       GST_DEBUG_OBJECT (bsrc, &quot;refuse to seek&quot;);
 682       forward = FALSE;
 683       break;
 684     default:
 685       GST_DEBUG_OBJECT (bsrc, &quot;forward event %p&quot;, event);
 686       break;
 687   }
 688   if (forward)
 689     res = GST_BASE_SRC_CLASS (parent_class)-&gt;event (bsrc, event);
 690 
 691   return res;
 692 }
 693 
 694 /* Get the next offset in the ringbuffer for reading samples.
 695  * If the next sample is too far away, this function will position itself to the
 696  * next most recent sample, creating discontinuity */
 697 static guint64
 698 gst_audio_base_src_get_offset (GstAudioBaseSrc * src)
 699 {
 700   guint64 sample;
 701   gint readseg, segdone, segtotal, sps;
 702   gint diff;
 703 
 704   /* assume we can append to the previous sample */
 705   sample = src-&gt;next_sample;
 706 
 707   sps = src-&gt;ringbuffer-&gt;samples_per_seg;
 708   segtotal = src-&gt;ringbuffer-&gt;spec.segtotal;
 709 
 710   /* get the currently processed segment */
 711   segdone = g_atomic_int_get (&amp;src-&gt;ringbuffer-&gt;segdone)
 712       - src-&gt;ringbuffer-&gt;segbase;
 713 
 714   if (sample != -1) {
 715     GST_DEBUG_OBJECT (src, &quot;at segment %d and sample %&quot; G_GUINT64_FORMAT,
 716         segdone, sample);
 717     /* figure out the segment and the offset inside the segment where
 718      * the sample should be read from. */
 719     readseg = sample / sps;
 720 
 721     /* See how far away it is from the read segment. Normally, segdone (where
 722      * new data is written in the ringbuffer) is bigger than readseg
 723      * (where we are reading). */
 724     diff = segdone - readseg;
 725     if (diff &gt;= segtotal) {
 726       GST_DEBUG_OBJECT (src, &quot;dropped, align to segment %d&quot;, segdone);
 727       /* sample would be dropped, position to next playable position */
 728       sample = ((guint64) (segdone)) * sps;
 729     }
 730   } else {
 731     /* no previous sample, go to the current position */
 732     GST_DEBUG_OBJECT (src, &quot;first sample, align to current %d&quot;, segdone);
 733     sample = ((guint64) (segdone)) * sps;
 734     readseg = segdone;
 735   }
 736 
 737   GST_DEBUG_OBJECT (src,
 738       &quot;reading from %d, we are at %d, sample %&quot; G_GUINT64_FORMAT, readseg,
 739       segdone, sample);
 740 
 741   return sample;
 742 }
 743 
 744 static GstFlowReturn
 745 gst_audio_base_src_create (GstBaseSrc * bsrc, guint64 offset, guint length,
 746     GstBuffer ** outbuf)
 747 {
 748   GstFlowReturn ret;
 749   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (bsrc);
 750   GstBuffer *buf;
 751   GstMapInfo info;
 752   guint8 *ptr;
 753   guint samples, total_samples;
 754   guint64 sample;
 755   gint bpf, rate;
 756   GstAudioRingBuffer *ringbuffer;
 757   GstAudioRingBufferSpec *spec;
 758   guint read;
 759   GstClockTime timestamp, duration;
 760   GstClockTime rb_timestamp = GST_CLOCK_TIME_NONE;
 761   GstClock *clock;
 762   gboolean first;
 763   gboolean first_sample = src-&gt;next_sample == -1;
 764 
 765   ringbuffer = src-&gt;ringbuffer;
 766   spec = &amp;ringbuffer-&gt;spec;
 767 
 768   if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (ringbuffer)))
 769     goto wrong_state;
 770 
 771   bpf = GST_AUDIO_INFO_BPF (&amp;spec-&gt;info);
 772   rate = GST_AUDIO_INFO_RATE (&amp;spec-&gt;info);
 773 
 774   if ((length == 0 &amp;&amp; bsrc-&gt;blocksize == 0) || length == -1)
 775     /* no length given, use the default segment size */
 776     length = spec-&gt;segsize;
 777   else
 778     /* make sure we round down to an integral number of samples */
 779     length -= length % bpf;
 780 
 781   /* figure out the offset in the ringbuffer */
 782   if (G_UNLIKELY (offset != -1)) {
 783     sample = offset / bpf;
 784     /* if a specific offset was given it must be the next sequential
 785      * offset we expect or we fail for now. */
 786     if (src-&gt;next_sample != -1 &amp;&amp; sample != src-&gt;next_sample)
 787       goto wrong_offset;
 788   } else {
 789     /* Calculate the sequentially-next sample we need to read. This can jump and
 790      * create a DISCONT. */
 791     sample = gst_audio_base_src_get_offset (src);
 792   }
 793 
 794   GST_DEBUG_OBJECT (src, &quot;reading from sample %&quot; G_GUINT64_FORMAT &quot; length %u&quot;,
 795       sample, length);
 796 
 797   /* get the number of samples to read */
 798   total_samples = samples = length / bpf;
 799 
 800   /* use the basesrc allocation code to use bufferpools or custom allocators */
 801   ret = GST_BASE_SRC_CLASS (parent_class)-&gt;alloc (bsrc, offset, length, &amp;buf);
 802   if (G_UNLIKELY (ret != GST_FLOW_OK))
 803     goto alloc_failed;
 804 
 805   gst_buffer_map (buf, &amp;info, GST_MAP_WRITE);
 806   ptr = info.data;
 807   first = TRUE;
 808   do {
 809     GstClockTime tmp_ts = GST_CLOCK_TIME_NONE;
 810 
 811     read =
 812         gst_audio_ring_buffer_read (ringbuffer, sample, ptr, samples, &amp;tmp_ts);
 813     if (first &amp;&amp; GST_CLOCK_TIME_IS_VALID (tmp_ts)) {
 814       first = FALSE;
 815       rb_timestamp = tmp_ts;
 816     }
 817     GST_DEBUG_OBJECT (src, &quot;read %u of %u&quot;, read, samples);
 818     /* if we read all, we&#39;re done */
 819     if (read == samples)
 820       break;
 821 
 822     if (g_atomic_int_get (&amp;ringbuffer-&gt;state) ==
 823         GST_AUDIO_RING_BUFFER_STATE_ERROR)
 824       goto got_error;
 825 
 826     /* else something interrupted us and we wait for playing again. */
 827     GST_DEBUG_OBJECT (src, &quot;wait playing&quot;);
 828     if (gst_base_src_wait_playing (bsrc) != GST_FLOW_OK)
 829       goto stopped;
 830 
 831     GST_DEBUG_OBJECT (src, &quot;continue playing&quot;);
 832 
 833     /* read next samples */
 834     sample += read;
 835     samples -= read;
 836     ptr += read * bpf;
 837   } while (TRUE);
 838   gst_buffer_unmap (buf, &amp;info);
 839 
 840   /* mark discontinuity if needed */
 841   if (G_UNLIKELY (sample != src-&gt;next_sample) &amp;&amp; src-&gt;next_sample != -1) {
 842     GST_WARNING_OBJECT (src,
 843         &quot;create DISCONT of %&quot; G_GUINT64_FORMAT &quot; samples at sample %&quot;
 844         G_GUINT64_FORMAT, sample - src-&gt;next_sample, sample);
 845     GST_ELEMENT_WARNING (src, CORE, CLOCK,
 846         (_(&quot;Can&#39;t record audio fast enough&quot;)),
 847         (&quot;Dropped %&quot; G_GUINT64_FORMAT &quot; samples. This is most likely because &quot;
 848             &quot;downstream can&#39;t keep up and is consuming samples too slowly.&quot;,
 849             sample - src-&gt;next_sample));
 850     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
 851   }
 852 
 853   src-&gt;next_sample = sample + samples;
 854 
 855   /* get the normal timestamp to get the duration. */
 856   timestamp = gst_util_uint64_scale_int (sample, GST_SECOND, rate);
 857   duration = gst_util_uint64_scale_int (src-&gt;next_sample, GST_SECOND,
 858       rate) - timestamp;
 859 
 860   GST_OBJECT_LOCK (src);
 861   if (!(clock = GST_ELEMENT_CLOCK (src)))
 862     goto no_sync;
 863 
 864   if (!GST_CLOCK_TIME_IS_VALID (rb_timestamp) &amp;&amp; clock != src-&gt;clock) {
 865     /* we are slaved, check how to handle this */
 866     switch (src-&gt;priv-&gt;slave_method) {
 867       case GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE:
 868         /* Not implemented, use skew algorithm. This algorithm should
 869          * work on the readout pointer and produce more or less samples based
 870          * on the clock drift */
 871       case GST_AUDIO_BASE_SRC_SLAVE_SKEW:
 872       {
 873         GstClockTime running_time;
 874         GstClockTime base_time;
 875         GstClockTime current_time;
 876         guint64 running_time_sample;
 877         gint running_time_segment;
 878         gint last_read_segment;
 879         gint segment_skew;
 880         gint sps;
 881         gint segments_written;
 882         gint last_written_segment;
 883 
 884         /* get the amount of segments written from the device by now */
 885         segments_written = g_atomic_int_get (&amp;ringbuffer-&gt;segdone);
 886 
 887         /* subtract the base to segments_written to get the number of the
 888          * last written segment in the ringbuffer
 889          * (one segment written = segment 0) */
 890         last_written_segment = segments_written - ringbuffer-&gt;segbase - 1;
 891 
 892         /* samples per segment */
 893         sps = ringbuffer-&gt;samples_per_seg;
 894 
 895         /* get the current time */
 896         current_time = gst_clock_get_time (clock);
 897 
 898         /* get the basetime */
 899         base_time = GST_ELEMENT_CAST (src)-&gt;base_time;
 900 
 901         /* get the running_time */
 902         running_time = current_time - base_time;
 903 
 904         /* the running_time converted to a sample
 905          * (relative to the ringbuffer) */
 906         running_time_sample =
 907             gst_util_uint64_scale_int (running_time, rate, GST_SECOND);
 908 
 909         /* the segmentnr corresponding to running_time, round down */
 910         running_time_segment = running_time_sample / sps;
 911 
 912         /* the segment currently read from the ringbuffer */
 913         last_read_segment = sample / sps;
 914 
 915         /* the skew we have between running_time and the ringbuffertime
 916          * (last written to) */
 917         segment_skew = running_time_segment - last_written_segment;
 918 
 919         GST_DEBUG_OBJECT (bsrc,
 920             &quot;\n running_time                                              = %&quot;
 921             GST_TIME_FORMAT
 922             &quot;\n timestamp                                                  = %&quot;
 923             GST_TIME_FORMAT
 924             &quot;\n running_time_segment                                       = %d&quot;
 925             &quot;\n last_written_segment                                       = %d&quot;
 926             &quot;\n segment_skew (running time segment - last_written_segment) = %d&quot;
 927             &quot;\n last_read_segment                                          = %d&quot;,
 928             GST_TIME_ARGS (running_time), GST_TIME_ARGS (timestamp),
 929             running_time_segment, last_written_segment, segment_skew,
 930             last_read_segment);
 931 
 932         /* Resync the ringbuffer if:
 933          *
 934          * 1. We are more than the length of the ringbuffer behind.
 935          *    The length of the ringbuffer then gets to dictate
 936          *    the threshold for what is considered &quot;too late&quot;
 937          *
 938          * 2. If this is our first buffer.
 939          *    We know that we should catch up to running_time
 940          *    the first time we are ran.
 941          */
 942         if ((segment_skew &gt;= ringbuffer-&gt;spec.segtotal) ||
 943             (last_read_segment == 0) || first_sample) {
 944           gint new_read_segment;
 945           gint segment_diff;
 946           guint64 new_sample;
 947 
 948           /* the difference between running_time and the last written segment */
 949           segment_diff = running_time_segment - last_written_segment;
 950 
 951           /* advance the ringbuffer */
 952           gst_audio_ring_buffer_advance (ringbuffer, segment_diff);
 953 
 954           /* we move the  new read segment to the last known written segment */
 955           new_read_segment =
 956               g_atomic_int_get (&amp;ringbuffer-&gt;segdone) - ringbuffer-&gt;segbase;
 957 
 958           /* we calculate the new sample value */
 959           new_sample = ((guint64) new_read_segment) * sps;
 960 
 961           /* and get the relative time to this -&gt; our new timestamp */
 962           timestamp = gst_util_uint64_scale_int (new_sample, GST_SECOND, rate);
 963 
 964           /* we update the next sample accordingly */
 965           src-&gt;next_sample = new_sample + samples;
 966 
 967           GST_DEBUG_OBJECT (bsrc,
 968               &quot;Timeshifted the ringbuffer with %d segments: &quot;
 969               &quot;Updating the timestamp to %&quot; GST_TIME_FORMAT &quot;, &quot;
 970               &quot;and src-&gt;next_sample to %&quot; G_GUINT64_FORMAT, segment_diff,
 971               GST_TIME_ARGS (timestamp), src-&gt;next_sample);
 972         }
 973         break;
 974       }
 975       case GST_AUDIO_BASE_SRC_SLAVE_RE_TIMESTAMP:
 976       {
 977         GstClockTime base_time, latency;
 978 
 979         /* We are slaved to another clock. Take running time of the pipeline
 980          * clock and timestamp against it. Somebody else in the pipeline should
 981          * figure out the clock drift. We keep the duration we calculated
 982          * above. */
 983         timestamp = gst_clock_get_time (clock);
 984         base_time = GST_ELEMENT_CAST (src)-&gt;base_time;
 985 
 986         if (GST_CLOCK_DIFF (timestamp, base_time) &lt; 0)
 987           timestamp -= base_time;
 988         else
 989           timestamp = 0;
 990 
 991         /* subtract latency */
 992         latency = gst_util_uint64_scale_int (total_samples, GST_SECOND, rate);
 993         if (timestamp &gt; latency)
 994           timestamp -= latency;
 995         else
 996           timestamp = 0;
 997       }
 998       case GST_AUDIO_BASE_SRC_SLAVE_NONE:
 999         break;
1000     }
1001   } else {
1002     GstClockTime base_time;
1003 
1004     if (GST_CLOCK_TIME_IS_VALID (rb_timestamp)) {
1005       /* the read method returned a timestamp so we use this instead */
1006       timestamp = rb_timestamp;
1007     } else {
1008       /* to get the timestamp against the clock we also need to add our
1009        * offset */
1010       timestamp = gst_audio_clock_adjust (GST_AUDIO_CLOCK (clock), timestamp);
1011     }
1012 
1013     /* we are not slaved, subtract base_time */
1014     base_time = GST_ELEMENT_CAST (src)-&gt;base_time;
1015 
1016     if (GST_CLOCK_DIFF (timestamp, base_time) &lt; 0) {
1017       timestamp -= base_time;
1018       GST_LOG_OBJECT (src,
1019           &quot;buffer timestamp %&quot; GST_TIME_FORMAT &quot; (base_time %&quot; GST_TIME_FORMAT
1020           &quot;)&quot;, GST_TIME_ARGS (timestamp), GST_TIME_ARGS (base_time));
1021     } else {
1022       GST_LOG_OBJECT (src,
1023           &quot;buffer timestamp 0, ts %&quot; GST_TIME_FORMAT &quot; &lt;= base_time %&quot;
1024           GST_TIME_FORMAT, GST_TIME_ARGS (timestamp),
1025           GST_TIME_ARGS (base_time));
1026       timestamp = 0;
1027     }
1028   }
1029 
1030 no_sync:
1031   GST_OBJECT_UNLOCK (src);
1032 
1033   GST_BUFFER_TIMESTAMP (buf) = timestamp;
1034   GST_BUFFER_DURATION (buf) = duration;
1035   GST_BUFFER_OFFSET (buf) = sample;
1036   GST_BUFFER_OFFSET_END (buf) = sample + samples;
1037 
1038   *outbuf = buf;
1039 
1040   GST_LOG_OBJECT (src, &quot;Pushed buffer timestamp %&quot; GST_TIME_FORMAT,
1041       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
1042 
1043   return GST_FLOW_OK;
1044 
1045   /* ERRORS */
1046 wrong_state:
1047   {
1048     GST_DEBUG_OBJECT (src, &quot;ringbuffer in wrong state&quot;);
1049     return GST_FLOW_FLUSHING;
1050   }
1051 wrong_offset:
1052   {
1053     GST_ELEMENT_ERROR (src, RESOURCE, SEEK,
1054         (NULL), (&quot;resource can only be operated on sequentially but offset %&quot;
1055             G_GUINT64_FORMAT &quot; was given&quot;, offset));
1056     return GST_FLOW_ERROR;
1057   }
1058 alloc_failed:
1059   {
1060     GST_DEBUG_OBJECT (src, &quot;alloc failed: %s&quot;, gst_flow_get_name (ret));
1061     return ret;
1062   }
1063 stopped:
1064   {
1065     gst_buffer_unmap (buf, &amp;info);
1066     gst_buffer_unref (buf);
1067     GST_DEBUG_OBJECT (src, &quot;ringbuffer stopped&quot;);
1068     return GST_FLOW_FLUSHING;
1069   }
1070 got_error:
1071   {
1072     gst_buffer_unmap (buf, &amp;info);
1073     gst_buffer_unref (buf);
1074     GST_DEBUG_OBJECT (src, &quot;ringbuffer was in error state, bailing out&quot;);
1075     return GST_FLOW_ERROR;
1076   }
1077 }
1078 
1079 /**
1080  * gst_audio_base_src_create_ringbuffer:
1081  * @src: a #GstAudioBaseSrc.
1082  *
1083  * Create and return the #GstAudioRingBuffer for @src. This function will call
1084  * the ::create_ringbuffer vmethod and will set @src as the parent of the
1085  * returned buffer (see gst_object_set_parent()).
1086  *
1087  * Returns: (transfer none): The new ringbuffer of @src.
1088  */
1089 GstAudioRingBuffer *
1090 gst_audio_base_src_create_ringbuffer (GstAudioBaseSrc * src)
1091 {
1092   GstAudioBaseSrcClass *bclass;
1093   GstAudioRingBuffer *buffer = NULL;
1094 
1095   bclass = GST_AUDIO_BASE_SRC_GET_CLASS (src);
1096   if (bclass-&gt;create_ringbuffer)
1097     buffer = bclass-&gt;create_ringbuffer (src);
1098 
1099   if (G_LIKELY (buffer))
1100     gst_object_set_parent (GST_OBJECT_CAST (buffer), GST_OBJECT_CAST (src));
1101 
1102   return buffer;
1103 }
1104 
1105 static GstStateChangeReturn
1106 gst_audio_base_src_change_state (GstElement * element,
1107     GstStateChange transition)
1108 {
1109   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
1110   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (element);
1111 
1112   switch (transition) {
1113     case GST_STATE_CHANGE_NULL_TO_READY:{
1114       GstAudioRingBuffer *rb;
1115 
1116       GST_DEBUG_OBJECT (src, &quot;NULL-&gt;READY&quot;);
1117       gst_audio_clock_reset (GST_AUDIO_CLOCK (src-&gt;clock), 0);
1118       rb = gst_audio_base_src_create_ringbuffer (src);
1119       if (rb == NULL)
1120         goto create_failed;
1121 
1122       GST_OBJECT_LOCK (src);
1123       src-&gt;ringbuffer = rb;
1124       GST_OBJECT_UNLOCK (src);
1125 
1126       if (!gst_audio_ring_buffer_open_device (src-&gt;ringbuffer)) {
1127         GST_OBJECT_LOCK (src);
1128         gst_object_unparent (GST_OBJECT_CAST (src-&gt;ringbuffer));
1129         src-&gt;ringbuffer = NULL;
1130         GST_OBJECT_UNLOCK (src);
1131         goto open_failed;
1132       }
1133       break;
1134     }
1135     case GST_STATE_CHANGE_READY_TO_PAUSED:
1136       GST_DEBUG_OBJECT (src, &quot;READY-&gt;PAUSED&quot;);
1137       src-&gt;next_sample = -1;
1138       gst_audio_ring_buffer_set_flushing (src-&gt;ringbuffer, FALSE);
1139       gst_audio_ring_buffer_may_start (src-&gt;ringbuffer, FALSE);
1140       /* Only post clock-provide messages if this is the clock that
1141        * we&#39;ve created. If the subclass has overriden it the subclass
1142        * should post this messages whenever necessary */
1143       if (src-&gt;clock &amp;&amp; GST_IS_AUDIO_CLOCK (src-&gt;clock) &amp;&amp;
1144           GST_AUDIO_CLOCK_CAST (src-&gt;clock)-&gt;func ==
1145           (GstAudioClockGetTimeFunc) gst_audio_base_src_get_time)
1146         gst_element_post_message (element,
1147             gst_message_new_clock_provide (GST_OBJECT_CAST (element),
1148                 src-&gt;clock, TRUE));
1149       break;
1150     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
1151       GST_DEBUG_OBJECT (src, &quot;PAUSED-&gt;PLAYING&quot;);
1152       gst_audio_ring_buffer_may_start (src-&gt;ringbuffer, TRUE);
1153       break;
1154     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
1155       GST_DEBUG_OBJECT (src, &quot;PLAYING-&gt;PAUSED&quot;);
1156       gst_audio_ring_buffer_may_start (src-&gt;ringbuffer, FALSE);
1157       gst_audio_ring_buffer_pause (src-&gt;ringbuffer);
1158       break;
1159     case GST_STATE_CHANGE_PAUSED_TO_READY:
1160       GST_DEBUG_OBJECT (src, &quot;PAUSED-&gt;READY&quot;);
1161       /* Only post clock-lost messages if this is the clock that
1162        * we&#39;ve created. If the subclass has overriden it the subclass
1163        * should post this messages whenever necessary */
1164       if (src-&gt;clock &amp;&amp; GST_IS_AUDIO_CLOCK (src-&gt;clock) &amp;&amp;
1165           GST_AUDIO_CLOCK_CAST (src-&gt;clock)-&gt;func ==
1166           (GstAudioClockGetTimeFunc) gst_audio_base_src_get_time)
1167         gst_element_post_message (element,
1168             gst_message_new_clock_lost (GST_OBJECT_CAST (element), src-&gt;clock));
1169       gst_audio_ring_buffer_set_flushing (src-&gt;ringbuffer, TRUE);
1170       break;
1171     default:
1172       break;
1173   }
1174 
1175   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1176 
1177   switch (transition) {
1178     case GST_STATE_CHANGE_PAUSED_TO_READY:
1179       GST_DEBUG_OBJECT (src, &quot;PAUSED-&gt;READY&quot;);
1180       gst_audio_ring_buffer_release (src-&gt;ringbuffer);
1181       break;
1182     case GST_STATE_CHANGE_READY_TO_NULL:
1183       GST_DEBUG_OBJECT (src, &quot;READY-&gt;NULL&quot;);
1184       gst_audio_ring_buffer_close_device (src-&gt;ringbuffer);
1185       GST_OBJECT_LOCK (src);
1186       gst_object_unparent (GST_OBJECT_CAST (src-&gt;ringbuffer));
1187       src-&gt;ringbuffer = NULL;
1188       GST_OBJECT_UNLOCK (src);
1189       break;
1190     default:
1191       break;
1192   }
1193 
1194   return ret;
1195 
1196   /* ERRORS */
1197 create_failed:
1198   {
1199     /* subclass must post a meaningful error message */
1200     GST_DEBUG_OBJECT (src, &quot;create failed&quot;);
1201     return GST_STATE_CHANGE_FAILURE;
1202   }
1203 open_failed:
1204   {
1205     /* subclass must post a meaningful error message */
1206     GST_DEBUG_OBJECT (src, &quot;open failed&quot;);
1207     return GST_STATE_CHANGE_FAILURE;
1208   }
1209 
1210 }
1211 
1212 static gboolean
1213 gst_audio_base_src_post_message (GstElement * element, GstMessage * message)
1214 {
1215   GstAudioBaseSrc *src = GST_AUDIO_BASE_SRC (element);
1216   gboolean ret;
1217 
<a name="5" id="anc5"></a><span class="line-modified">1218   if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ERROR) {</span>
1219     GstAudioRingBuffer *ringbuffer;
1220 
1221     GST_INFO_OBJECT (element, &quot;subclass posted error&quot;);
1222 
1223     ringbuffer = gst_object_ref (src-&gt;ringbuffer);
1224 
1225     /* post message first before signalling the error to the ringbuffer, to
1226      * make sure it ends up on the bus before the generic basesrc internal
1227      * flow error message */
1228     ret = GST_ELEMENT_CLASS (parent_class)-&gt;post_message (element, message);
1229 
1230     g_atomic_int_set (&amp;ringbuffer-&gt;state, GST_AUDIO_RING_BUFFER_STATE_ERROR);
1231     GST_AUDIO_RING_BUFFER_SIGNAL (ringbuffer);
1232     gst_object_unref (ringbuffer);
1233   } else {
1234     ret = GST_ELEMENT_CLASS (parent_class)-&gt;post_message (element, message);
1235   }
1236   return ret;
1237 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>