<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstplugin.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstplugin.c: Plugin subsystem for loading elements, types, and libs
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstplugin
  25  * @title: GstPlugin
  26  * @short_description: Container for features loaded from a shared object module
  27  * @see_also: #GstPluginFeature, #GstElementFactory
  28  *
  29  * GStreamer is extensible, so #GstElement instances can be loaded at runtime.
  30  * A plugin system can provide one or more of the basic
  31  * &lt;application&gt;GStreamer&lt;/application&gt; #GstPluginFeature subclasses.
  32  *
  33  * A plugin should export a symbol &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt; that is a
  34  * struct of type #GstPluginDesc.
  35  * the plugin loader will check the version of the core library the plugin was
  36  * linked against and will create a new #GstPlugin. It will then call the
  37  * #GstPluginInitFunc function that was provided in the
  38  * &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt;.
  39  *
  40  * Once you have a handle to a #GstPlugin (e.g. from the #GstRegistry), you
  41  * can add any object that subclasses #GstPluginFeature.
  42  *
  43  * Usually plugins are always automatically loaded so you don&#39;t need to call
  44  * gst_plugin_load() explicitly to bring it into memory. There are options to
  45  * statically link plugins to an app or even use GStreamer without a plugin
  46  * repository in which case gst_plugin_load() can be needed to bring the plugin
  47  * into memory.
  48  */
  49 
  50 #ifdef HAVE_CONFIG_H
  51 #include &quot;config.h&quot;
  52 #endif
  53 
  54 #include &quot;gst_private.h&quot;
  55 
  56 #include &lt;glib/gstdio.h&gt;
  57 #include &lt;sys/types.h&gt;
  58 #ifdef HAVE_DIRENT_H
  59 #include &lt;dirent.h&gt;
  60 #endif
  61 #ifdef HAVE_UNISTD_H
  62 #include &lt;unistd.h&gt;
  63 #endif
  64 #include &lt;signal.h&gt;
  65 #include &lt;errno.h&gt;
  66 #include &lt;string.h&gt;
  67 
  68 #include &quot;glib-compat-private.h&quot;
  69 
  70 #include &lt;gst/gst.h&gt;
  71 
  72 #ifndef GSTREAMER_LITE
  73 #define GST_CAT_DEFAULT GST_CAT_PLUGIN_LOADING
  74 #else // GSTREAMER_LITE
  75 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
  76 #define GST_CAT_DEFAULT GST_CAT_PLUGIN_LOADING
  77 #else
  78 #define GST_CAT_DEFAULT NULL
  79 #endif
  80 #endif // GSTREAMER_LITE
  81 
  82 static guint _num_static_plugins;       /* 0    */
  83 static GstPluginDesc *_static_plugins;  /* NULL */
  84 static gboolean _gst_plugin_inited;
  85 static gchar **_plugin_loading_whitelist;       /* NULL */
  86 
  87 /* static variables for segfault handling of plugin loading */
  88 static char *_gst_plugin_fault_handler_filename = NULL;
  89 
  90 /* list of valid licenses.
  91  * One of these must be specified or the plugin won&#39;t be loaded
  92  * Please file a bug to request any additional license be added.
  93  *
  94  * GPL: http://www.gnu.org/copyleft/gpl.html
  95  * LGPL: http://www.gnu.org/copyleft/lesser.html
  96  * QPL: http://www.trolltech.com/licenses/qpl.html
  97  * MPL: http://www.opensource.org/licenses/mozilla1.1.php
  98  * MIT/X11: http://www.opensource.org/licenses/mit-license.php
<a name="1" id="anc1"></a><span class="line-modified">  99  * 3-clause BSD: http://www.opensource.org/licenses/bsd-license.php</span>

 100  */
 101 static const gchar valid_licenses[] = &quot;LGPL\000&quot;        /* GNU Lesser General Public License */
 102     &quot;GPL\000&quot;                   /* GNU General Public License */
 103     &quot;QPL\000&quot;                   /* Trolltech Qt Public License */
 104     &quot;GPL/QPL\000&quot;               /* Combi-license of GPL + QPL */
 105     &quot;MPL\000&quot;                   /* MPL 1.1 license */
 106     &quot;BSD\000&quot;                   /* 3-clause BSD license */
 107     &quot;MIT/X11\000&quot;               /* MIT/X11 license */
<a name="2" id="anc2"></a>
 108     &quot;Proprietary\000&quot;           /* Proprietary license */
 109     GST_LICENSE_UNKNOWN;        /* some other license */
 110 
<a name="3" id="anc3"></a><span class="line-modified"> 111 static const guint8 valid_licenses_idx[] = { 0, 5, 9, 13, 21, 25, 29, 37, 49 };</span>


 112 
 113 static GstPlugin *gst_plugin_register_func (GstPlugin * plugin,
 114     const GstPluginDesc * desc, gpointer user_data);
 115 static void gst_plugin_desc_copy (GstPluginDesc * dest,
 116     const GstPluginDesc * src);
 117 
 118 static void gst_plugin_ext_dep_free (GstPluginDep * dep);
 119 
<a name="4" id="anc4"></a><span class="line-modified"> 120 G_DEFINE_TYPE (GstPlugin, gst_plugin, GST_TYPE_OBJECT);</span>
 121 
 122 static void
 123 gst_plugin_init (GstPlugin * plugin)
 124 {
<a name="5" id="anc5"></a><span class="line-modified"> 125   plugin-&gt;priv =</span>
<span class="line-removed"> 126       G_TYPE_INSTANCE_GET_PRIVATE (plugin, GST_TYPE_PLUGIN, GstPluginPrivate);</span>
 127 }
 128 
 129 static void
 130 gst_plugin_finalize (GObject * object)
 131 {
 132   GstPlugin *plugin = GST_PLUGIN_CAST (object);
 133 #ifndef GSTREAMER_LITE
 134 
 135   GST_DEBUG (&quot;finalizing plugin %&quot; GST_PTR_FORMAT, plugin);
 136 
 137   /* FIXME: make registry add a weak ref instead */
 138 #if 0
 139   GstRegistry *registry = gst_registry_get ();
 140   GList *g;
 141   for (g = registry-&gt;plugins; g; g = g-&gt;next) {
 142     if (g-&gt;data == (gpointer) plugin) {
 143       g_warning (&quot;removing plugin that is still in registry&quot;);
 144     }
 145   }
 146 #endif
 147 
 148 #endif // GSTREAMER_LITE
 149   g_free (plugin-&gt;filename);
 150   g_free (plugin-&gt;basename);
 151 
 152   g_list_foreach (plugin-&gt;priv-&gt;deps, (GFunc) gst_plugin_ext_dep_free, NULL);
 153   g_list_free (plugin-&gt;priv-&gt;deps);
 154   plugin-&gt;priv-&gt;deps = NULL;
 155 
 156   if (plugin-&gt;priv-&gt;cache_data) {
 157     gst_structure_free (plugin-&gt;priv-&gt;cache_data);
 158   }
 159 
 160   G_OBJECT_CLASS (gst_plugin_parent_class)-&gt;finalize (object);
 161 }
 162 
 163 static void
 164 gst_plugin_class_init (GstPluginClass * klass)
 165 {
 166   G_OBJECT_CLASS (klass)-&gt;finalize = gst_plugin_finalize;
<a name="6" id="anc6"></a><span class="line-removed"> 167 </span>
<span class="line-removed"> 168   g_type_class_add_private (klass, sizeof (GstPluginPrivate));</span>
 169 }
 170 
 171 GQuark
 172 gst_plugin_error_quark (void)
 173 {
 174   static GQuark quark = 0;
 175 
 176   if (!quark)
 177     quark = g_quark_from_static_string (&quot;gst_plugin_error&quot;);
 178   return quark;
 179 }
 180 
 181 /**
 182  * gst_plugin_register_static:
 183  * @major_version: the major version number of the GStreamer core that the
 184  *     plugin was compiled for, you can just use GST_VERSION_MAJOR here
 185  * @minor_version: the minor version number of the GStreamer core that the
 186  *     plugin was compiled for, you can just use GST_VERSION_MINOR here
 187  * @name: a unique name of the plugin (ideally prefixed with an application- or
 188  *     library-specific namespace prefix in order to avoid name conflicts in
 189  *     case a similar plugin with the same name ever gets added to GStreamer)
 190  * @description: description of the plugin
 191  * @init_func: (scope call): pointer to the init function of this plugin.
 192  * @version: version string of the plugin
 193  * @license: effective license of plugin. Must be one of the approved licenses
 194  *     (see #GstPluginDesc above) or the plugin will not be registered.
 195  * @source: source module plugin belongs to
 196  * @package: shipped package plugin belongs to
 197  * @origin: URL to provider of plugin
 198  *
 199  * Registers a static plugin, ie. a plugin which is private to an application
 200  * or library and contained within the application or library (as opposed to
 201  * being shipped as a separate module file).
 202  *
 203  * You must make sure that GStreamer has been initialised (with gst_init() or
 204  * via gst_init_get_option_group()) before calling this function.
 205  *
 206  * Returns: %TRUE if the plugin was registered correctly, otherwise %FALSE.
 207  */
 208 gboolean
 209 gst_plugin_register_static (gint major_version, gint minor_version,
 210     const gchar * name, const gchar * description, GstPluginInitFunc init_func,
 211     const gchar * version, const gchar * license, const gchar * source,
 212     const gchar * package, const gchar * origin)
 213 {
 214   GstPluginDesc desc = { major_version, minor_version, name, description,
 215     init_func, version, license, source, package, origin, NULL,
 216   };
 217   GstPlugin *plugin;
 218   gboolean res = FALSE;
 219 
 220   g_return_val_if_fail (name != NULL, FALSE);
 221   g_return_val_if_fail (description != NULL, FALSE);
 222   g_return_val_if_fail (init_func != NULL, FALSE);
 223   g_return_val_if_fail (version != NULL, FALSE);
 224   g_return_val_if_fail (license != NULL, FALSE);
 225   g_return_val_if_fail (source != NULL, FALSE);
 226   g_return_val_if_fail (package != NULL, FALSE);
 227   g_return_val_if_fail (origin != NULL, FALSE);
 228 
 229   /* make sure gst_init() has been called */
 230   g_return_val_if_fail (_gst_plugin_inited != FALSE, FALSE);
 231 
 232   GST_LOG (&quot;attempting to load static plugin \&quot;%s\&quot; now...&quot;, name);
 233   plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 234   if (gst_plugin_register_func (plugin, &amp;desc, NULL) != NULL) {
 235     GST_INFO (&quot;registered static plugin \&quot;%s\&quot;&quot;, name);
 236     res = gst_registry_add_plugin (gst_registry_get (), plugin);
 237     GST_INFO (&quot;added static plugin \&quot;%s\&quot;, result: %d&quot;, name, res);
 238   }
 239   return res;
 240 }
 241 
 242 /**
 243  * gst_plugin_register_static_full:
 244  * @major_version: the major version number of the GStreamer core that the
 245  *     plugin was compiled for, you can just use GST_VERSION_MAJOR here
 246  * @minor_version: the minor version number of the GStreamer core that the
 247  *     plugin was compiled for, you can just use GST_VERSION_MINOR here
 248  * @name: a unique name of the plugin (ideally prefixed with an application- or
 249  *     library-specific namespace prefix in order to avoid name conflicts in
 250  *     case a similar plugin with the same name ever gets added to GStreamer)
 251  * @description: description of the plugin
 252  * @init_full_func: (scope call): pointer to the init function with user data
 253  *     of this plugin.
 254  * @version: version string of the plugin
 255  * @license: effective license of plugin. Must be one of the approved licenses
 256  *     (see #GstPluginDesc above) or the plugin will not be registered.
 257  * @source: source module plugin belongs to
 258  * @package: shipped package plugin belongs to
 259  * @origin: URL to provider of plugin
 260  * @user_data: gpointer to user data
 261  *
 262  * Registers a static plugin, ie. a plugin which is private to an application
 263  * or library and contained within the application or library (as opposed to
 264  * being shipped as a separate module file) with a #GstPluginInitFullFunc
 265  * which allows user data to be passed to the callback function (useful
 266  * for bindings).
 267  *
 268  * You must make sure that GStreamer has been initialised (with gst_init() or
 269  * via gst_init_get_option_group()) before calling this function.
 270  *
 271  * Returns: %TRUE if the plugin was registered correctly, otherwise %FALSE.
 272  */
 273 gboolean
 274 gst_plugin_register_static_full (gint major_version, gint minor_version,
 275     const gchar * name, const gchar * description,
 276     GstPluginInitFullFunc init_full_func, const gchar * version,
 277     const gchar * license, const gchar * source, const gchar * package,
 278     const gchar * origin, gpointer user_data)
 279 {
 280   GstPluginDesc desc = { major_version, minor_version, name, description,
 281     (GstPluginInitFunc) init_full_func, version, license, source, package,
 282     origin, NULL,
 283   };
 284   GstPlugin *plugin;
 285   gboolean res = FALSE;
 286 
 287   g_return_val_if_fail (name != NULL, FALSE);
 288   g_return_val_if_fail (description != NULL, FALSE);
 289   g_return_val_if_fail (init_full_func != NULL, FALSE);
 290   g_return_val_if_fail (version != NULL, FALSE);
 291   g_return_val_if_fail (license != NULL, FALSE);
 292   g_return_val_if_fail (source != NULL, FALSE);
 293   g_return_val_if_fail (package != NULL, FALSE);
 294   g_return_val_if_fail (origin != NULL, FALSE);
 295 
 296   /* make sure gst_init() has been called */
 297   g_return_val_if_fail (_gst_plugin_inited != FALSE, FALSE);
 298 
 299   GST_LOG (&quot;attempting to load static plugin \&quot;%s\&quot; now...&quot;, name);
 300   plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 301   if (gst_plugin_register_func (plugin, &amp;desc, user_data) != NULL) {
 302     GST_INFO (&quot;registered static plugin \&quot;%s\&quot;&quot;, name);
 303     res = gst_registry_add_plugin (gst_registry_get (), plugin);
 304     GST_INFO (&quot;added static plugin \&quot;%s\&quot;, result: %d&quot;, name, res);
 305   }
 306   return res;
 307 }
 308 
 309 void
 310 _priv_gst_plugin_initialize (void)
 311 {
 312   const gchar *whitelist;
 313   guint i;
 314 
 315   _gst_plugin_inited = TRUE;
 316 
 317   whitelist = g_getenv (&quot;GST_PLUGIN_LOADING_WHITELIST&quot;);
 318   if (whitelist != NULL &amp;&amp; *whitelist != &#39;\0&#39;) {
 319     _plugin_loading_whitelist = g_strsplit (whitelist,
 320         G_SEARCHPATH_SEPARATOR_S, -1);
 321     for (i = 0; _plugin_loading_whitelist[i] != NULL; ++i) {
 322       GST_INFO (&quot;plugins whitelist entry: %s&quot;, _plugin_loading_whitelist[i]);
 323     }
 324   }
 325 
 326   /* now register all static plugins */
 327   GST_INFO (&quot;registering %u static plugins&quot;, _num_static_plugins);
 328   for (i = 0; i &lt; _num_static_plugins; ++i) {
 329     gst_plugin_register_static (_static_plugins[i].major_version,
 330         _static_plugins[i].minor_version, _static_plugins[i].name,
 331         _static_plugins[i].description, _static_plugins[i].plugin_init,
 332         _static_plugins[i].version, _static_plugins[i].license,
 333         _static_plugins[i].source, _static_plugins[i].package,
 334         _static_plugins[i].origin);
 335   }
 336 
 337   if (_static_plugins) {
 338     free (_static_plugins);
 339     _static_plugins = NULL;
 340     _num_static_plugins = 0;
 341   }
 342 }
 343 
 344 /* Whitelist entry format:
 345  *
 346  *   plugin1,plugin2@pathprefix or
 347  *   plugin1,plugin2@* or just
 348  *   plugin1,plugin2 or
 349  *   source-package@pathprefix or
 350  *   source-package@* or just
 351  *   source-package
 352  *
 353  * ie. the bit before the path will be checked against both the plugin
 354  * name and the plugin&#39;s source package name, to keep the format simple.
 355  */
 356 static gboolean
 357 gst_plugin_desc_matches_whitelist_entry (const GstPluginDesc * desc,
 358     const gchar * filename, const gchar * pattern)
 359 {
 360   const gchar *sep;
 361   gboolean ret = FALSE;
 362   gchar *name;
 363 
 364   GST_LOG (&quot;Whitelist pattern &#39;%s&#39;, plugin: %s of %s@%s&quot;, pattern, desc-&gt;name,
 365       desc-&gt;source, GST_STR_NULL (filename));
 366 
 367   /* do we have a path prefix? */
 368   sep = strchr (pattern, &#39;@&#39;);
 369   if (sep != NULL &amp;&amp; strcmp (sep, &quot;@*&quot;) != 0 &amp;&amp; strcmp (sep, &quot;@&quot;) != 0) {
 370     /* paths are not canonicalised or treated with realpath() here. This
 371      * should be good enough for our use case, since we just use the paths
 372      * autotools uses, and those will be constructed from the same prefix. */
 373     if (filename != NULL &amp;&amp; !g_str_has_prefix (filename, sep + 1))
 374       return FALSE;
 375 
 376     GST_LOG (&quot;%s matches path prefix %s&quot;, GST_STR_NULL (filename), sep + 1);
 377   }
 378 
 379   if (sep != NULL) {
 380     name = g_strndup (pattern, (gsize) (sep - pattern));
 381   } else {
 382     name = g_strdup (pattern);
 383   }
 384 
 385   g_strstrip (name);
 386   if (!g_ascii_isalnum (*name)) {
 387     GST_WARNING (&quot;Invalid whitelist pattern: %s&quot;, pattern);
 388     goto done;
 389   }
 390 
 391   /* now check plugin names / source package name */
 392   if (strchr (name, &#39;,&#39;) == NULL) {
 393     /* only a single name: either a plugin name or the source package name */
 394     ret = (strcmp (desc-&gt;source, name) == 0 || strcmp (desc-&gt;name, name) == 0);
 395   } else {
 396     gchar **n, **names;
 397 
 398     /* multiple names: assume these are plugin names */
 399     names = g_strsplit (name, &quot;,&quot;, -1);
 400     for (n = names; n != NULL &amp;&amp; *n != NULL; ++n) {
 401       g_strstrip (*n);
 402       if (strcmp (desc-&gt;name, *n) == 0) {
 403         ret = TRUE;
 404         break;
 405       }
 406     }
 407     g_strfreev (names);
 408   }
 409 
 410   GST_LOG (&quot;plugin / source package name match: %d&quot;, ret);
 411 
 412 done:
 413 
 414   g_free (name);
 415   return ret;
 416 }
 417 
 418 gboolean
 419 priv_gst_plugin_desc_is_whitelisted (const GstPluginDesc * desc,
 420     const gchar * filename)
 421 {
 422   gchar **entry;
 423 
 424   if (_plugin_loading_whitelist == NULL)
 425     return TRUE;
 426 
 427   for (entry = _plugin_loading_whitelist; *entry != NULL; ++entry) {
 428     if (gst_plugin_desc_matches_whitelist_entry (desc, filename, *entry)) {
 429       GST_LOG (&quot;Plugin %s is in whitelist&quot;, filename);
 430       return TRUE;
 431     }
 432   }
 433 
 434   GST_LOG (&quot;Plugin %s (package %s, file %s) not in whitelist&quot;, desc-&gt;name,
 435       desc-&gt;source, filename);
 436   return FALSE;
 437 }
 438 
 439 gboolean
 440 priv_gst_plugin_loading_have_whitelist (void)
 441 {
 442   return (_plugin_loading_whitelist != NULL);
 443 }
 444 
 445 guint32
 446 priv_gst_plugin_loading_get_whitelist_hash (void)
 447 {
 448   guint32 hash = 0;
 449 
 450   if (_plugin_loading_whitelist != NULL) {
 451     gchar **w;
 452 
 453     for (w = _plugin_loading_whitelist; *w != NULL; ++w)
 454       hash ^= g_str_hash (*w);
 455   }
 456 
 457   return hash;
 458 }
 459 
 460 /* this function could be extended to check if the plugin license matches the
 461  * applications license (would require the app to register its license somehow).
 462  * We&#39;ll wait for someone who&#39;s interested in it to code it :)
 463  */
 464 static gboolean
 465 gst_plugin_check_license (const gchar * license)
 466 {
 467   gint i;
 468 
 469   for (i = 0; i &lt; G_N_ELEMENTS (valid_licenses_idx); ++i) {
 470     if (strcmp (license, valid_licenses + valid_licenses_idx[i]) == 0)
 471       return TRUE;
 472   }
 473   return FALSE;
 474 }
 475 
 476 static gboolean
 477 gst_plugin_check_version (gint major, gint minor)
 478 {
 479   /* return NULL if the major and minor version numbers are not compatible */
 480   /* with ours. */
 481   if (major != GST_VERSION_MAJOR || minor &gt; GST_VERSION_MINOR)
 482     return FALSE;
 483 
 484   return TRUE;
 485 }
 486 
 487 static GstPlugin *
 488 gst_plugin_register_func (GstPlugin * plugin, const GstPluginDesc * desc,
 489     gpointer user_data)
 490 {
 491   if (!gst_plugin_check_version (desc-&gt;major_version, desc-&gt;minor_version)) {
 492     if (GST_CAT_DEFAULT)
 493       GST_WARNING (&quot;plugin \&quot;%s\&quot; has incompatible version &quot;
 494           &quot;(plugin: %d.%d, gst: %d,%d), not loading&quot;,
 495           GST_STR_NULL (plugin-&gt;filename), desc-&gt;major_version,
 496           desc-&gt;minor_version, GST_VERSION_MAJOR, GST_VERSION_MINOR);
 497     return NULL;
 498   }
 499 
 500   if (!desc-&gt;license || !desc-&gt;description || !desc-&gt;source ||
 501       !desc-&gt;package || !desc-&gt;origin) {
 502     if (GST_CAT_DEFAULT)
 503       GST_WARNING (&quot;plugin \&quot;%s\&quot; has missing detail in GstPluginDesc, not &quot;
 504           &quot;loading&quot;, GST_STR_NULL (plugin-&gt;filename));
 505     return NULL;
 506   }
 507 
 508   if (!gst_plugin_check_license (desc-&gt;license)) {
 509     if (GST_CAT_DEFAULT)
 510       GST_WARNING (&quot;plugin \&quot;%s\&quot; has invalid license \&quot;%s\&quot;, not loading&quot;,
 511           GST_STR_NULL (plugin-&gt;filename), desc-&gt;license);
 512     return NULL;
 513   }
 514 
 515   if (GST_CAT_DEFAULT)
 516     GST_LOG (&quot;plugin \&quot;%s\&quot; looks good&quot;, GST_STR_NULL (plugin-&gt;filename));
 517 
 518   gst_plugin_desc_copy (&amp;plugin-&gt;desc, desc);
 519 
 520   /* make resident so we&#39;re really sure it never gets unloaded again.
 521    * Theoretically this is not needed, but practically it doesn&#39;t hurt.
 522    * And we&#39;re rather safe than sorry. */
 523   if (plugin-&gt;module)
 524     g_module_make_resident (plugin-&gt;module);
 525 
 526   if (user_data) {
 527     if (!(((GstPluginInitFullFunc) (desc-&gt;plugin_init)) (plugin, user_data))) {
 528       if (GST_CAT_DEFAULT)
 529         GST_WARNING (&quot;plugin \&quot;%s\&quot; failed to initialise&quot;,
 530             GST_STR_NULL (plugin-&gt;filename));
 531       return NULL;
 532     }
 533   } else {
 534     if (!((desc-&gt;plugin_init) (plugin))) {
 535       if (GST_CAT_DEFAULT)
 536         GST_WARNING (&quot;plugin \&quot;%s\&quot; failed to initialise&quot;,
 537             GST_STR_NULL (plugin-&gt;filename));
 538       return NULL;
 539     }
 540   }
 541 
 542   if (GST_CAT_DEFAULT)
 543     GST_LOG (&quot;plugin \&quot;%s\&quot; initialised&quot;, GST_STR_NULL (plugin-&gt;filename));
 544 
 545   return plugin;
 546 }
 547 
 548 #ifdef HAVE_SIGACTION
 549 static struct sigaction oldaction;
 550 static gboolean _gst_plugin_fault_handler_is_setup = FALSE;
 551 
 552 /*
 553  * _gst_plugin_fault_handler_restore:
 554  * segfault handler restorer
 555  */
 556 static void
 557 _gst_plugin_fault_handler_restore (void)
 558 {
 559   if (!_gst_plugin_fault_handler_is_setup)
 560     return;
 561 
 562   _gst_plugin_fault_handler_is_setup = FALSE;
 563 
 564   sigaction (SIGSEGV, &amp;oldaction, NULL);
 565 }
 566 
 567 /*
 568  * _gst_plugin_fault_handler_sighandler:
 569  * segfault handler implementation
 570  */
 571 static void
 572 _gst_plugin_fault_handler_sighandler (int signum)
 573 {
 574   /* We need to restore the fault handler or we&#39;ll keep getting it */
 575   _gst_plugin_fault_handler_restore ();
 576 
 577   switch (signum) {
 578     case SIGSEGV:
 579       g_print (&quot;\nERROR: &quot;);
 580       g_print (&quot;Caught a segmentation fault while loading plugin file:\n&quot;);
 581       g_print (&quot;%s\n\n&quot;, _gst_plugin_fault_handler_filename);
 582       g_print (&quot;Please either:\n&quot;);
 583       g_print (&quot;- remove it and restart.\n&quot;);
 584       g_print
 585           (&quot;- run with --gst-disable-segtrap --gst-disable-registry-fork and debug.\n&quot;);
 586       exit (-1);
 587       break;
 588     default:
 589       g_print (&quot;Caught unhandled signal on plugin loading\n&quot;);
 590       break;
 591   }
 592 }
 593 
 594 /*
 595  * _gst_plugin_fault_handler_setup:
 596  * sets up the segfault handler
 597  */
 598 static void
 599 _gst_plugin_fault_handler_setup (void)
 600 {
 601   struct sigaction action;
 602 
 603   /* if asked to leave segfaults alone, just return */
 604   if (!gst_segtrap_is_enabled ())
 605     return;
 606 
 607   if (_gst_plugin_fault_handler_is_setup)
 608     return;
 609 
 610   _gst_plugin_fault_handler_is_setup = TRUE;
 611 
 612   memset (&amp;action, 0, sizeof (action));
 613   action.sa_handler = _gst_plugin_fault_handler_sighandler;
 614 
 615   sigaction (SIGSEGV, &amp;action, &amp;oldaction);
 616 }
 617 #else /* !HAVE_SIGACTION */
 618 static void
 619 _gst_plugin_fault_handler_restore (void)
 620 {
 621 }
 622 
 623 static void
 624 _gst_plugin_fault_handler_setup (void)
 625 {
 626 }
 627 #endif /* HAVE_SIGACTION */
 628 
 629 /* g_time_val_from_iso8601() doesn&#39;t do quite what we want */
 630 static gboolean
 631 check_release_datetime (const gchar * date_time)
 632 {
 633   guint64 val;
 634 
 635   /* we require YYYY-MM-DD or YYYY-MM-DDTHH:MMZ format */
 636   if (!g_ascii_isdigit (*date_time))
 637     return FALSE;
 638 
 639   val = g_ascii_strtoull (date_time, (gchar **) &amp; date_time, 10);
 640   if (val &lt; 2000 || val &gt; 2100 || *date_time != &#39;-&#39;)
 641     return FALSE;
 642 
 643   val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 644   if (val == 0 || val &gt; 12 || *date_time != &#39;-&#39;)
 645     return FALSE;
 646 
 647   val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 648   if (val == 0 || val &gt; 32)
 649     return FALSE;
 650 
 651   /* end of string or date/time separator + HH:MMZ */
 652   if (*date_time == &#39;T&#39; || *date_time == &#39; &#39;) {
 653     val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 654     if (val &gt; 24 || *date_time != &#39;:&#39;)
 655       return FALSE;
 656 
 657     val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 658     if (val &gt; 59 || *date_time != &#39;Z&#39;)
 659       return FALSE;
 660 
 661     ++date_time;
 662   }
 663 
 664   return (*date_time == &#39;\0&#39;);
 665 }
 666 
 667 static GMutex gst_plugin_loading_mutex;
 668 
 669 #define CHECK_PLUGIN_DESC_FIELD(desc,field,fn)                               \
 670   if (G_UNLIKELY ((desc)-&gt;field == NULL || *(desc)-&gt;field == &#39;\0&#39;)) {        \
 671     g_warning (&quot;Plugin description for &#39;%s&#39; has no valid %s field&quot;, fn, G_STRINGIFY (field)); \
 672     g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE, \
 673         &quot;Plugin %s has invalid plugin description field &#39;%s&#39;&quot;, \
 674         filename, G_STRINGIFY (field)); \
 675     goto return_error;                                                       \
 676   }
 677 
 678 /**
 679  * gst_plugin_load_file:
 680  * @filename: (type filename): the plugin filename to load
 681  * @error: pointer to a %NULL-valued GError
 682  *
 683  * Loads the given plugin and refs it.  Caller needs to unref after use.
 684  *
 685  * Returns: (transfer full): a reference to the existing loaded GstPlugin, a
 686  * reference to the newly-loaded GstPlugin, or %NULL if an error occurred.
 687  */
 688 GstPlugin *
 689 gst_plugin_load_file (const gchar * filename, GError ** error)
 690 {
 691   return _priv_gst_plugin_load_file_for_registry (filename, NULL, error);
 692 }
 693 
 694 static gchar *
 695 extract_symname (const char *filename)
 696 {
 697   gchar *bname, *name, *symname;
 698   const gchar *dot;
 699   gsize prefix_len, len;
 700   int i;
 701 
 702   bname = g_path_get_basename (filename);
 703   for (i = 0; bname[i]; ++i) {
 704     if (bname[i] == &#39;-&#39;)
 705       bname[i] = &#39;_&#39;;
 706   }
 707 
 708   if (g_str_has_prefix (bname, &quot;libgst&quot;))
 709     prefix_len = 6;
 710   else if (g_str_has_prefix (bname, &quot;lib&quot;))
 711     prefix_len = 3;
 712   else if (g_str_has_prefix (bname, &quot;gst&quot;))
 713     prefix_len = 3;
 714   else
 715     prefix_len = 0;             /* use whole name (minus suffix) as plugin name */
 716 
 717   dot = g_utf8_strchr (bname, -1, &#39;.&#39;);
 718   if (dot)
 719     len = dot - bname - prefix_len;
 720   else
 721     len = strlen (bname + prefix_len);
 722 
 723   name = g_strndup (bname + prefix_len, len);
 724   g_free (bname);
 725 
 726   symname = g_strconcat (&quot;gst_plugin_&quot;, name, &quot;_get_desc&quot;, NULL);
 727   g_free (name);
 728 
 729   return symname;
 730 }
 731 
 732 /* Note: The return value is (transfer full) although we work with floating
 733  * references here. If a new plugin instance is created, it is always sinked
 734  * in the registry first and a new reference is returned
 735  */
 736 GstPlugin *
 737 _priv_gst_plugin_load_file_for_registry (const gchar * filename,
 738     GstRegistry * registry, GError ** error)
 739 {
 740   const GstPluginDesc *desc;
 741   GstPlugin *plugin;
 742   gchar *symname;
 743   GModule *module;
 744   gboolean ret;
 745   gpointer ptr;
 746   GStatBuf file_status;
 747   gboolean new_plugin = TRUE;
 748   GModuleFlags flags;
 749 
 750   g_return_val_if_fail (filename != NULL, NULL);
 751 
 752   if (registry == NULL)
<a name="7" id="anc7"></a><span class="line-modified"> 753   registry = gst_registry_get ();</span>
 754 
 755   g_mutex_lock (&amp;gst_plugin_loading_mutex);
 756 
 757   plugin = gst_registry_lookup (registry, filename);
 758   if (plugin) {
 759     if (plugin-&gt;module) {
 760       /* already loaded */
 761       g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 762       return plugin;
 763     } else {
 764       /* load plugin and update fields */
 765       new_plugin = FALSE;
 766     }
 767   }
 768 
 769   GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;attempt to load plugin \&quot;%s\&quot;&quot;,
 770       filename);
 771 
 772   if (!g_module_supported ()) {
 773     GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;module loading not supported&quot;);
 774     g_set_error (error,
 775         GST_PLUGIN_ERROR,
 776         GST_PLUGIN_ERROR_MODULE, &quot;Dynamic loading not supported&quot;);
 777     goto return_error;
 778   }
 779 
 780   if (g_stat (filename, &amp;file_status)) {
 781     GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;problem accessing file&quot;);
 782     g_set_error (error,
 783         GST_PLUGIN_ERROR,
 784         GST_PLUGIN_ERROR_MODULE, &quot;Problem accessing file %s: %s&quot;, filename,
 785         g_strerror (errno));
 786     goto return_error;
 787   }
 788 
 789   flags = G_MODULE_BIND_LOCAL;
 790   /* libgstpython.so is the gst-python plugin loader. It needs to be loaded with
 791    * G_MODULE_BIND_LAZY.
 792    *
 793    * Ideally there should be a generic way for plugins to specify that they
 794    * need to be loaded with _LAZY.
 795    * */
 796   if (strstr (filename, &quot;libgstpython&quot;))
 797     flags |= G_MODULE_BIND_LAZY;
 798 
 799   module = g_module_open (filename, flags);
 800   if (module == NULL) {
 801     GST_CAT_WARNING (GST_CAT_PLUGIN_LOADING, &quot;module_open failed: %s&quot;,
 802         g_module_error ());
 803     g_set_error (error,
 804         GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE, &quot;Opening module failed: %s&quot;,
 805         g_module_error ());
 806     /* If we failed to open the shared object, then it&#39;s probably because a
 807      * plugin is linked against the wrong libraries. Print out an easy-to-see
 808      * message in this case. */
 809     g_warning (&quot;Failed to load plugin &#39;%s&#39;: %s&quot;, filename, g_module_error ());
 810     goto return_error;
 811   }
 812 
 813   symname = extract_symname (filename);
 814   ret = g_module_symbol (module, symname, &amp;ptr);
 815 
 816   if (ret) {
 817     GstPluginDesc *(*get_desc) (void) = ptr;
 818     ptr = get_desc ();
 819   } else {
 820     GST_DEBUG (&quot;Could not find symbol &#39;%s&#39;, falling back to gst_plugin_desc&quot;,
 821         symname);
<a name="8" id="anc8"></a><span class="line-modified"> 822   ret = g_module_symbol (module, &quot;gst_plugin_desc&quot;, &amp;ptr);</span>
 823   }
 824 
 825   g_free (symname);
 826 
 827   if (!ret) {
 828     GST_DEBUG (&quot;Could not find plugin entry point in \&quot;%s\&quot;&quot;, filename);
 829     g_set_error (error,
 830         GST_PLUGIN_ERROR,
 831         GST_PLUGIN_ERROR_MODULE,
 832         &quot;File \&quot;%s\&quot; is not a GStreamer plugin&quot;, filename);
 833     g_module_close (module);
 834     goto return_error;
 835   }
 836 
 837   desc = (const GstPluginDesc *) ptr;
 838 
 839   if (priv_gst_plugin_loading_have_whitelist () &amp;&amp;
 840       !priv_gst_plugin_desc_is_whitelisted (desc, filename)) {
 841     GST_INFO (&quot;Whitelist specified and plugin not in whitelist, not loading: &quot;
 842         &quot;name=%s, package=%s, file=%s&quot;, desc-&gt;name, desc-&gt;source, filename);
 843     g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE,
 844         &quot;Not loading plugin file \&quot;%s\&quot;, not in whitelist&quot;, filename);
 845     g_module_close (module);
 846     goto return_error;
 847   }
 848 
 849   if (new_plugin) {
 850     plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 851     plugin-&gt;file_mtime = file_status.st_mtime;
 852     plugin-&gt;file_size = file_status.st_size;
 853     plugin-&gt;filename = g_strdup (filename);
 854     plugin-&gt;basename = g_path_get_basename (filename);
 855   }
 856 
 857   plugin-&gt;module = module;
 858 
 859   if (new_plugin) {
 860     /* check plugin description: complain about bad values and fail */
 861     CHECK_PLUGIN_DESC_FIELD (desc, name, filename);
 862     CHECK_PLUGIN_DESC_FIELD (desc, description, filename);
 863     CHECK_PLUGIN_DESC_FIELD (desc, version, filename);
 864     CHECK_PLUGIN_DESC_FIELD (desc, license, filename);
 865     CHECK_PLUGIN_DESC_FIELD (desc, source, filename);
 866     CHECK_PLUGIN_DESC_FIELD (desc, package, filename);
 867     CHECK_PLUGIN_DESC_FIELD (desc, origin, filename);
 868 
 869     if (desc-&gt;name != NULL &amp;&amp; desc-&gt;name[0] == &#39;&quot;&#39;) {
 870       g_warning (&quot;Invalid plugin name &#39;%s&#39; - fix your GST_PLUGIN_DEFINE &quot;
 871           &quot;(remove quotes around plugin name)&quot;, desc-&gt;name);
 872     }
 873 
 874     if (desc-&gt;release_datetime != NULL &amp;&amp;
 875         !check_release_datetime (desc-&gt;release_datetime)) {
 876       g_warning (&quot;GstPluginDesc for &#39;%s&#39; has invalid datetime &#39;%s&#39;&quot;,
 877           filename, desc-&gt;release_datetime);
 878       g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE,
 879           &quot;Plugin %s has invalid plugin description field &#39;release_datetime&#39;&quot;,
 880           filename);
 881       goto return_error;
 882     }
 883   }
 884 
 885   GST_LOG (&quot;Plugin %p for file \&quot;%s\&quot; prepared, calling entry function...&quot;,
 886       plugin, filename);
 887 
 888   /* this is where we load the actual .so, so let&#39;s trap SIGSEGV */
 889   _gst_plugin_fault_handler_setup ();
 890   _gst_plugin_fault_handler_filename = plugin-&gt;filename;
 891 
 892   GST_LOG (&quot;Plugin %p for file \&quot;%s\&quot; prepared, registering...&quot;,
 893       plugin, filename);
 894 
 895   if (!gst_plugin_register_func (plugin, desc, NULL)) {
 896     /* remove signal handler */
 897     _gst_plugin_fault_handler_restore ();
 898     GST_DEBUG (&quot;gst_plugin_register_func failed for plugin \&quot;%s\&quot;&quot;, filename);
 899     /* plugin == NULL */
 900     g_set_error (error,
 901         GST_PLUGIN_ERROR,
 902         GST_PLUGIN_ERROR_MODULE,
 903         &quot;File \&quot;%s\&quot; appears to be a GStreamer plugin, but it failed to initialize&quot;,
 904         filename);
 905     goto return_error;
 906   }
 907 
 908   /* remove signal handler */
 909   _gst_plugin_fault_handler_restore ();
 910   _gst_plugin_fault_handler_filename = NULL;
 911   GST_INFO (&quot;plugin \&quot;%s\&quot; loaded&quot;, plugin-&gt;filename);
 912 
 913   if (new_plugin) {
 914     gst_object_ref (plugin);
 915     gst_registry_add_plugin (registry, plugin);
 916   }
 917 
 918   g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 919   return plugin;
 920 
 921 return_error:
 922   {
 923     if (plugin)
 924       gst_object_unref (plugin);
 925     g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 926     return NULL;
 927   }
 928 }
 929 
 930 static void
 931 gst_plugin_desc_copy (GstPluginDesc * dest, const GstPluginDesc * src)
 932 {
 933   dest-&gt;major_version = src-&gt;major_version;
 934   dest-&gt;minor_version = src-&gt;minor_version;
 935   dest-&gt;name = g_intern_string (src-&gt;name);
 936   dest-&gt;description = g_intern_string (src-&gt;description);
 937   dest-&gt;plugin_init = src-&gt;plugin_init;
 938   dest-&gt;version = g_intern_string (src-&gt;version);
 939   dest-&gt;license = g_intern_string (src-&gt;license);
 940   dest-&gt;source = g_intern_string (src-&gt;source);
 941   dest-&gt;package = g_intern_string (src-&gt;package);
 942   dest-&gt;origin = g_intern_string (src-&gt;origin);
 943   dest-&gt;release_datetime = g_intern_string (src-&gt;release_datetime);
 944 }
 945 
 946 /**
 947  * gst_plugin_get_name:
 948  * @plugin: plugin to get the name of
 949  *
 950  * Get the short name of the plugin
 951  *
 952  * Returns: the name of the plugin
 953  */
 954 const gchar *
 955 gst_plugin_get_name (GstPlugin * plugin)
 956 {
 957   g_return_val_if_fail (plugin != NULL, NULL);
 958 
 959   return plugin-&gt;desc.name;
 960 }
 961 
 962 /**
 963  * gst_plugin_get_description:
 964  * @plugin: plugin to get long name of
 965  *
 966  * Get the long descriptive name of the plugin
 967  *
 968  * Returns: the long name of the plugin
 969  */
 970 const gchar *
 971 gst_plugin_get_description (GstPlugin * plugin)
 972 {
 973   g_return_val_if_fail (plugin != NULL, NULL);
 974 
 975   return plugin-&gt;desc.description;
 976 }
 977 
 978 /**
 979  * gst_plugin_get_filename:
 980  * @plugin: plugin to get the filename of
 981  *
 982  * get the filename of the plugin
 983  *
 984  * Returns: (type filename): the filename of the plugin
 985  */
 986 const gchar *
 987 gst_plugin_get_filename (GstPlugin * plugin)
 988 {
 989   g_return_val_if_fail (plugin != NULL, NULL);
 990 
 991   return plugin-&gt;filename;
 992 }
 993 
 994 /**
 995  * gst_plugin_get_version:
 996  * @plugin: plugin to get the version of
 997  *
 998  * get the version of the plugin
 999  *
1000  * Returns: the version of the plugin
1001  */
1002 const gchar *
1003 gst_plugin_get_version (GstPlugin * plugin)
1004 {
1005   g_return_val_if_fail (plugin != NULL, NULL);
1006 
1007   return plugin-&gt;desc.version;
1008 }
1009 
1010 /**
1011  * gst_plugin_get_license:
1012  * @plugin: plugin to get the license of
1013  *
1014  * get the license of the plugin
1015  *
1016  * Returns: the license of the plugin
1017  */
1018 const gchar *
1019 gst_plugin_get_license (GstPlugin * plugin)
1020 {
1021   g_return_val_if_fail (plugin != NULL, NULL);
1022 
1023   return plugin-&gt;desc.license;
1024 }
1025 
1026 /**
1027  * gst_plugin_get_source:
1028  * @plugin: plugin to get the source of
1029  *
1030  * get the source module the plugin belongs to.
1031  *
1032  * Returns: the source of the plugin
1033  */
1034 const gchar *
1035 gst_plugin_get_source (GstPlugin * plugin)
1036 {
1037   g_return_val_if_fail (plugin != NULL, NULL);
1038 
1039   return plugin-&gt;desc.source;
1040 }
1041 
1042 /**
1043  * gst_plugin_get_package:
1044  * @plugin: plugin to get the package of
1045  *
1046  * get the package the plugin belongs to.
1047  *
1048  * Returns: the package of the plugin
1049  */
1050 const gchar *
1051 gst_plugin_get_package (GstPlugin * plugin)
1052 {
1053   g_return_val_if_fail (plugin != NULL, NULL);
1054 
1055   return plugin-&gt;desc.package;
1056 }
1057 
1058 /**
1059  * gst_plugin_get_origin:
1060  * @plugin: plugin to get the origin of
1061  *
1062  * get the URL where the plugin comes from
1063  *
1064  * Returns: the origin of the plugin
1065  */
1066 const gchar *
1067 gst_plugin_get_origin (GstPlugin * plugin)
1068 {
1069   g_return_val_if_fail (plugin != NULL, NULL);
1070 
1071   return plugin-&gt;desc.origin;
1072 }
1073 
1074 /**
1075  * gst_plugin_get_release_date_string:
1076  * @plugin: plugin to get the release date of
1077  *
1078  * Get the release date (and possibly time) in form of a string, if available.
1079  *
1080  * For normal GStreamer plugin releases this will usually just be a date in
1081  * the form of &quot;YYYY-MM-DD&quot;, while pre-releases and builds from git may contain
1082  * a time component after the date as well, in which case the string will be
1083  * formatted like &quot;YYYY-MM-DDTHH:MMZ&quot; (e.g. &quot;2012-04-30T09:30Z&quot;).
1084  *
1085  * There may be plugins that do not have a valid release date set on them.
1086  *
1087  * Returns: (nullable): the date string of the plugin, or %NULL if not
1088  * available.
1089  */
1090 const gchar *
1091 gst_plugin_get_release_date_string (GstPlugin * plugin)
1092 {
1093   g_return_val_if_fail (plugin != NULL, NULL);
1094 
1095   return plugin-&gt;desc.release_datetime;
1096 }
1097 
1098 /**
1099  * gst_plugin_is_loaded:
1100  * @plugin: plugin to query
1101  *
1102  * queries if the plugin is loaded into memory
1103  *
1104  * Returns: %TRUE is loaded, %FALSE otherwise
1105  */
1106 gboolean
1107 gst_plugin_is_loaded (GstPlugin * plugin)
1108 {
1109   g_return_val_if_fail (plugin != NULL, FALSE);
1110 
1111   return (plugin-&gt;module != NULL || plugin-&gt;filename == NULL);
1112 }
1113 
1114 /**
1115  * gst_plugin_get_cache_data:
1116  * @plugin: a plugin
1117  *
1118  * Gets the plugin specific data cache. If it is %NULL there is no cached data
1119  * stored. This is the case when the registry is getting rebuilt.
1120  *
1121  * Returns: (transfer none) (nullable): The cached data as a
1122  * #GstStructure or %NULL.
1123  */
1124 const GstStructure *
1125 gst_plugin_get_cache_data (GstPlugin * plugin)
1126 {
1127   g_return_val_if_fail (GST_IS_PLUGIN (plugin), NULL);
1128 
1129   return plugin-&gt;priv-&gt;cache_data;
1130 }
1131 
1132 /**
1133  * gst_plugin_set_cache_data:
1134  * @plugin: a plugin
1135  * @cache_data: (transfer full): a structure containing the data to cache
1136  *
1137  * Adds plugin specific data to cache. Passes the ownership of the structure to
1138  * the @plugin.
1139  *
1140  * The cache is flushed every time the registry is rebuilt.
1141  */
1142 void
1143 gst_plugin_set_cache_data (GstPlugin * plugin, GstStructure * cache_data)
1144 {
1145   g_return_if_fail (GST_IS_PLUGIN (plugin));
1146   g_return_if_fail (GST_IS_STRUCTURE (cache_data));
1147 
1148   if (plugin-&gt;priv-&gt;cache_data) {
1149     gst_structure_free (plugin-&gt;priv-&gt;cache_data);
1150   }
1151   plugin-&gt;priv-&gt;cache_data = cache_data;
1152 }
1153 
1154 #if 0
1155 /**
1156  * gst_plugin_feature_list:
1157  * @plugin: plugin to query
1158  * @filter: the filter to use
1159  * @first: only return first match
1160  * @user_data: user data passed to the filter function
1161  *
1162  * Runs a filter against all plugin features and returns a GList with
1163  * the results. If the first flag is set, only the first match is
1164  * returned (as a list with a single object).
1165  *
1166  * Returns: a GList of features, g_list_free after use.
1167  */
1168 GList *
1169 gst_plugin_feature_filter (GstPlugin * plugin,
1170     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
1171 {
1172   GList *list;
1173   GList *g;
1174 
1175   list = gst_filter_run (plugin-&gt;features, (GstFilterFunc) filter, first,
1176       user_data);
1177   for (g = list; g; g = g-&gt;next) {
1178     gst_object_ref (plugin);
1179   }
1180 
1181   return list;
1182 }
1183 
1184 typedef struct
1185 {
1186   GstPluginFeatureFilter filter;
1187   gboolean first;
1188   gpointer user_data;
1189   GList *result;
1190 }
1191 FeatureFilterData;
1192 
1193 static gboolean
1194 _feature_filter (GstPlugin * plugin, gpointer user_data)
1195 {
1196   GList *result;
1197   FeatureFilterData *data = (FeatureFilterData *) user_data;
1198 
1199   result = gst_plugin_feature_filter (plugin, data-&gt;filter, data-&gt;first,
1200       data-&gt;user_data);
1201   if (result) {
1202     data-&gt;result = g_list_concat (data-&gt;result, result);
1203     return TRUE;
1204   }
1205   return FALSE;
1206 }
1207 
1208 /**
1209  * gst_plugin_list_feature_filter:
1210  * @list: a #GList of plugins to query
1211  * @filter: the filter function to use
1212  * @first: only return first match
1213  * @user_data: user data passed to the filter function
1214  *
1215  * Runs a filter against all plugin features of the plugins in the given
1216  * list and returns a GList with the results.
1217  * If the first flag is set, only the first match is
1218  * returned (as a list with a single object).
1219  *
1220  * Returns: a GList of features, g_list_free after use.
1221  */
1222 GList *
1223 gst_plugin_list_feature_filter (GList * list,
1224     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
1225 {
1226   FeatureFilterData data;
1227   GList *result;
1228 
1229   data.filter = filter;
1230   data.first = first;
1231   data.user_data = user_data;
1232   data.result = NULL;
1233 
1234   result = gst_filter_run (list, (GstFilterFunc) _feature_filter, first, &amp;data);
1235   g_list_free (result);
1236 
1237   return data.result;
1238 }
1239 
1240 /**
1241  * gst_plugin_find_feature:
1242  * @plugin: plugin to get the feature from
1243  * @name: The name of the feature to find
1244  * @type: The type of the feature to find
1245  *
1246  * Find a feature of the given name and type in the given plugin.
1247  *
1248  * Returns: a GstPluginFeature or %NULL if the feature was not found.
1249  */
1250 GstPluginFeature *
1251 gst_plugin_find_feature (GstPlugin * plugin, const gchar * name, GType type)
1252 {
1253   GList *walk;
1254   GstPluginFeature *result = NULL;
1255   GstTypeNameData data;
1256 
1257   g_return_val_if_fail (name != NULL, NULL);
1258 
1259   data.type = type;
1260   data.name = name;
1261 
1262   walk = gst_filter_run (plugin-&gt;features,
1263       (GstFilterFunc) gst_plugin_feature_type_name_filter, TRUE, &amp;data);
1264 
1265   if (walk) {
1266     result = GST_PLUGIN_FEATURE (walk-&gt;data);
1267 
1268     gst_object_ref (result);
1269     gst_plugin_feature_list_free (walk);
1270   }
1271 
1272   return result;
1273 }
1274 #endif
1275 
1276 #if 0
1277 static gboolean
1278 gst_plugin_feature_name_filter (GstPluginFeature * feature, const gchar * name)
1279 {
1280   return !strcmp (name, GST_PLUGIN_FEATURE_NAME (feature));
1281 }
1282 #endif
1283 
1284 #if 0
1285 /**
1286  * gst_plugin_find_feature_by_name:
1287  * @plugin: plugin to get the feature from
1288  * @name: The name of the feature to find
1289  *
1290  * Find a feature of the given name in the given plugin.
1291  *
1292  * Returns: a GstPluginFeature or %NULL if the feature was not found.
1293  */
1294 GstPluginFeature *
1295 gst_plugin_find_feature_by_name (GstPlugin * plugin, const gchar * name)
1296 {
1297   GList *walk;
1298   GstPluginFeature *result = NULL;
1299 
1300   g_return_val_if_fail (name != NULL, NULL);
1301 
1302   walk = gst_filter_run (plugin-&gt;features,
1303       (GstFilterFunc) gst_plugin_feature_name_filter, TRUE, (void *) name);
1304 
1305   if (walk) {
1306     result = GST_PLUGIN_FEATURE (walk-&gt;data);
1307 
1308     gst_object_ref (result);
1309     gst_plugin_feature_list_free (walk);
1310   }
1311 
1312   return result;
1313 }
1314 #endif
1315 
1316 /**
1317  * gst_plugin_load_by_name:
1318  * @name: name of plugin to load
1319  *
1320  * Load the named plugin. Refs the plugin.
1321  *
1322  * Returns: (transfer full) (nullable): a reference to a loaded plugin, or
1323  * %NULL on error.
1324  */
1325 GstPlugin *
1326 gst_plugin_load_by_name (const gchar * name)
1327 {
1328   GstPlugin *plugin, *newplugin;
1329   GError *error = NULL;
1330 
1331   GST_DEBUG (&quot;looking up plugin %s in default registry&quot;, name);
1332   plugin = gst_registry_find_plugin (gst_registry_get (), name);
1333   if (plugin) {
1334     GST_DEBUG (&quot;loading plugin %s from file %s&quot;, name, plugin-&gt;filename);
1335     newplugin = gst_plugin_load_file (plugin-&gt;filename, &amp;error);
1336     gst_object_unref (plugin);
1337 
1338     if (!newplugin) {
1339       GST_WARNING (&quot;load_plugin error: %s&quot;, error-&gt;message);
1340       g_error_free (error);
1341       return NULL;
1342     }
1343     /* newplugin was reffed by load_file */
1344     return newplugin;
1345   }
1346 
1347   GST_DEBUG (&quot;Could not find plugin %s in registry&quot;, name);
1348   return NULL;
1349 }
1350 
1351 /**
1352  * gst_plugin_load:
1353  * @plugin: (transfer none): plugin to load
1354  *
1355  * Loads @plugin. Note that the *return value* is the loaded plugin; @plugin is
1356  * untouched. The normal use pattern of this function goes like this:
1357  *
1358  * |[
1359  * GstPlugin *loaded_plugin;
1360  * loaded_plugin = gst_plugin_load (plugin);
1361  * // presumably, we&#39;re no longer interested in the potentially-unloaded plugin
1362  * gst_object_unref (plugin);
1363  * plugin = loaded_plugin;
1364  * ]|
1365  *
1366  * Returns: (transfer full) (nullable): a reference to a loaded plugin, or
1367  * %NULL on error.
1368  */
1369 GstPlugin *
1370 gst_plugin_load (GstPlugin * plugin)
1371 {
1372   GError *error = NULL;
1373   GstPlugin *newplugin;
1374 
1375   if (gst_plugin_is_loaded (plugin)) {
1376     return gst_object_ref (plugin);
1377   }
1378 
1379   if (!(newplugin = gst_plugin_load_file (plugin-&gt;filename, &amp;error)))
1380     goto load_error;
1381 
1382   return newplugin;
1383 
1384 load_error:
1385   {
1386     GST_WARNING (&quot;load_plugin error: %s&quot;, error-&gt;message);
1387     g_error_free (error);
1388     return NULL;
1389   }
1390 }
1391 
1392 /**
1393  * gst_plugin_list_free:
1394  * @list: (transfer full) (element-type Gst.Plugin): list of #GstPlugin
1395  *
1396  * Unrefs each member of @list, then frees the list.
1397  */
1398 void
1399 gst_plugin_list_free (GList * list)
1400 {
1401   GList *g;
1402 
1403   for (g = list; g; g = g-&gt;next) {
1404     gst_object_unref (GST_PLUGIN_CAST (g-&gt;data));
1405   }
1406   g_list_free (list);
1407 }
1408 
1409 /* ===== plugin dependencies ===== */
1410 
1411 /* Scenarios:
1412  * ENV + xyz     where ENV can contain multiple values separated by SEPARATOR
1413  *               xyz may be &quot;&quot; (if ENV contains path to file rather than dir)
1414  * ENV + *xyz   same as above, but xyz acts as suffix filter
1415  * ENV + xyz*   same as above, but xyz acts as prefix filter (is this needed?)
1416  * ENV + *xyz*  same as above, but xyz acts as strstr filter (is this needed?)
1417  *
1418  * same as above, with additional paths hard-coded at compile-time:
1419  *   - only check paths + ... if ENV is not set or yields not paths
1420  *   - always check paths + ... in addition to ENV
1421  *
1422  * When user specifies set of environment variables, he/she may also use e.g.
1423  * &quot;HOME/.mystuff/plugins&quot;, and we&#39;ll expand the content of $HOME with the
1424  * remainder
1425  */
1426 
1427 /* we store in registry:
1428  *  sets of:
1429  *   {
1430  *     - environment variables (array of strings)
1431  *     - last hash of env variable contents (uint) (so we can avoid doing stats
1432  *       if one of the env vars has changed; premature optimisation galore)
1433  *     - hard-coded paths (array of strings)
1434  *     - xyz filename/suffix/prefix strings (array of strings)
1435  *     - flags (int)
1436  *     - last hash of file/dir stats (int)
1437  *   }
1438  *   (= struct GstPluginDep)
1439  */
1440 
1441 static guint
1442 gst_plugin_ext_dep_get_env_vars_hash (GstPlugin * plugin, GstPluginDep * dep)
1443 {
1444   gchar **e;
1445   guint hash;
1446 
1447   /* there&#39;s no deeper logic to what we do here; all we want to know (when
1448    * checking if the plugin needs to be rescanned) is whether the content of
1449    * one of the environment variables in the list is different from when it
1450    * was last scanned */
1451   hash = 0;
1452   for (e = dep-&gt;env_vars; e != NULL &amp;&amp; *e != NULL; ++e) {
1453     const gchar *val;
1454     gchar env_var[256];
1455 
1456     /* order matters: &quot;val&quot;,NULL needs to yield a different hash than
1457      * NULL,&quot;val&quot;, so do a shift here whether the var is set or not */
1458     hash = hash &lt;&lt; 5;
1459 
1460     /* want environment variable at beginning of string */
1461     if (!g_ascii_isalnum (**e)) {
1462       GST_WARNING_OBJECT (plugin, &quot;string prefix is not a valid environment &quot;
1463           &quot;variable string: %s&quot;, *e);
1464       continue;
1465     }
1466 
1467     /* user is allowed to specify e.g. &quot;HOME/.pitivi/plugins&quot; */
1468     g_strlcpy (env_var, *e, sizeof (env_var));
1469     g_strdelimit (env_var, &quot;/\\&quot;, &#39;\0&#39;);
1470 
1471     if ((val = g_getenv (env_var)))
1472       hash += g_str_hash (val);
1473   }
1474 
1475   return hash;
1476 }
1477 
1478 gboolean
1479 _priv_plugin_deps_env_vars_changed (GstPlugin * plugin)
1480 {
1481   GList *l;
1482 
1483   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1484     GstPluginDep *dep = l-&gt;data;
1485 
1486     if (dep-&gt;env_hash != gst_plugin_ext_dep_get_env_vars_hash (plugin, dep))
1487       return TRUE;
1488   }
1489 
1490   return FALSE;
1491 }
1492 
1493 static void
1494 gst_plugin_ext_dep_extract_env_vars_paths (GstPlugin * plugin,
1495     GstPluginDep * dep, GQueue * paths)
1496 {
1497   gchar **evars;
1498 
1499   for (evars = dep-&gt;env_vars; evars != NULL &amp;&amp; *evars != NULL; ++evars) {
1500     const gchar *e;
1501     gchar **components;
1502 
1503     /* want environment variable at beginning of string */
1504     if (!g_ascii_isalnum (**evars)) {
1505       GST_WARNING_OBJECT (plugin, &quot;string prefix is not a valid environment &quot;
1506           &quot;variable string: %s&quot;, *evars);
1507       continue;
1508     }
1509 
1510     /* user is allowed to specify e.g. &quot;HOME/.pitivi/plugins&quot;, which we want to
1511      * split into the env_var name component and the path component */
1512     components = g_strsplit_set (*evars, &quot;/\\&quot;, 2);
1513     g_assert (components != NULL);
1514 
1515     e = g_getenv (components[0]);
1516     GST_LOG_OBJECT (plugin, &quot;expanding %s = &#39;%s&#39; (path suffix: %s)&quot;,
1517         components[0], GST_STR_NULL (e), GST_STR_NULL (components[1]));
1518 
1519     if (components[1] != NULL) {
1520       g_strdelimit (components[1], &quot;/\\&quot;, G_DIR_SEPARATOR);
1521     }
1522 
1523     if (e != NULL &amp;&amp; *e != &#39;\0&#39;) {
1524       gchar **arr;
1525       guint i;
1526 
1527       arr = g_strsplit (e, G_SEARCHPATH_SEPARATOR_S, -1);
1528 
1529       for (i = 0; arr != NULL &amp;&amp; arr[i] != NULL; ++i) {
1530         gchar *full_path;
1531 
1532         if (!g_path_is_absolute (arr[i])) {
1533           GST_INFO_OBJECT (plugin, &quot;ignoring environment variable content &#39;%s&#39;&quot;
1534               &quot;: either not an absolute path or not a path at all&quot;, arr[i]);
1535           continue;
1536         }
1537 
1538         if (components[1] != NULL) {
1539           full_path = g_build_filename (arr[i], components[1], NULL);
1540         } else {
1541           full_path = g_strdup (arr[i]);
1542         }
1543 
1544         if (!g_queue_find_custom (paths, full_path, (GCompareFunc) strcmp)) {
1545           GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39;&quot;, full_path);
1546           g_queue_push_tail (paths, full_path);
1547           full_path = NULL;
1548         } else {
1549           GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39; (duplicate,ignoring)&quot;, full_path);
1550           g_free (full_path);
1551         }
1552       }
1553 
1554       g_strfreev (arr);
1555     }
1556 
1557     g_strfreev (components);
1558   }
1559 
1560   GST_LOG_OBJECT (plugin, &quot;Extracted %d paths from environment&quot;, paths-&gt;length);
1561 }
1562 
1563 static guint
1564 gst_plugin_ext_dep_get_hash_from_stat_entry (GStatBuf * s)
1565 {
1566 #ifdef S_IFBLK
1567   if (!(s-&gt;st_mode &amp; (S_IFDIR | S_IFREG | S_IFBLK | S_IFCHR)))
1568 #else
1569   /* MSVC does not have S_IFBLK */
1570   if (!(s-&gt;st_mode &amp; (S_IFDIR | S_IFREG | S_IFCHR)))
1571 #endif
1572     return (guint) - 1;
1573 
1574   /* completely random formula */
1575   return ((s-&gt;st_size &lt;&lt; 3) + (s-&gt;st_mtime &lt;&lt; 5)) ^ s-&gt;st_ctime;
1576 }
1577 
1578 static gboolean
1579 gst_plugin_ext_dep_direntry_matches (GstPlugin * plugin, const gchar * entry,
1580     const gchar ** filenames, GstPluginDependencyFlags flags)
1581 {
1582   /* no filenames specified, match all entries for now (could probably
1583    * optimise by just taking the dir stat hash or so) */
1584   if (filenames == NULL || *filenames == NULL || **filenames == &#39;\0&#39;)
1585     return TRUE;
1586 
1587   while (*filenames != NULL) {
1588     /* suffix match? */
1589     if (((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX)) &amp;&amp;
1590         g_str_has_suffix (entry, *filenames)) {
1591       return TRUE;
1592     } else if (((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX)) &amp;&amp;
1593         g_str_has_prefix (entry, *filenames)) {
1594       return TRUE;
1595       /* else it&#39;s an exact match that&#39;s needed */
1596     } else if (strcmp (entry, *filenames) == 0) {
1597       return TRUE;
1598     }
1599     GST_LOG (&quot;%s does not match %s, flags=0x%04x&quot;, entry, *filenames, flags);
1600     ++filenames;
1601   }
1602   return FALSE;
1603 }
1604 
1605 static guint
1606 gst_plugin_ext_dep_scan_dir_and_match_names (GstPlugin * plugin,
1607     const gchar * path, const gchar ** filenames,
1608     GstPluginDependencyFlags flags, int depth)
1609 {
1610   const gchar *entry;
1611   gboolean recurse_dirs;
1612   GError *err = NULL;
1613   GDir *dir;
1614   guint hash = 0;
1615 
1616   recurse_dirs = ! !(flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);
1617 
1618   dir = g_dir_open (path, 0, &amp;err);
1619   if (dir == NULL) {
1620     GST_DEBUG_OBJECT (plugin, &quot;g_dir_open(%s) failed: %s&quot;, path, err-&gt;message);
1621     g_error_free (err);
1622     return (guint) - 1;
1623   }
1624 
1625   /* FIXME: we&#39;re assuming here that we always get the directory entries in
1626    * the same order, and not in a random order */
1627   while ((entry = g_dir_read_name (dir))) {
1628     gboolean have_match;
1629     GStatBuf s;
1630     gchar *full_path;
1631     guint fhash;
1632 
1633     have_match =
1634         gst_plugin_ext_dep_direntry_matches (plugin, entry, filenames, flags);
1635 
1636     /* avoid the stat if possible */
1637     if (!have_match &amp;&amp; !recurse_dirs)
1638       continue;
1639 
1640     full_path = g_build_filename (path, entry, NULL);
1641     if (g_stat (full_path, &amp;s) &lt; 0) {
1642       fhash = (guint) - 1;
1643       GST_LOG_OBJECT (plugin, &quot;stat: %s (error: %s)&quot;, full_path,
1644           g_strerror (errno));
1645     } else if (have_match) {
1646       fhash = gst_plugin_ext_dep_get_hash_from_stat_entry (&amp;s);
1647       GST_LOG_OBJECT (plugin, &quot;stat: %s (result: %u)&quot;, full_path, fhash);
1648     } else if ((s.st_mode &amp; (S_IFDIR))) {
1649       fhash = gst_plugin_ext_dep_scan_dir_and_match_names (plugin, full_path,
1650           filenames, flags, depth + 1);
1651     } else {
1652       /* it&#39;s not a name match, we want to recurse, but it&#39;s not a directory */
1653       g_free (full_path);
1654       continue;
1655     }
1656 
1657     hash = hash + fhash;
1658     g_free (full_path);
1659   }
1660 
1661   g_dir_close (dir);
1662   return hash;
1663 }
1664 
1665 static guint
1666 gst_plugin_ext_dep_scan_path_with_filenames (GstPlugin * plugin,
1667     const gchar * path, const gchar ** filenames,
1668     GstPluginDependencyFlags flags)
1669 {
1670   const gchar *empty_filenames[] = { &quot;&quot;, NULL };
1671   gboolean recurse_into_dirs, partial_names = FALSE;
1672   guint i, hash = 0;
1673 
1674   /* to avoid special-casing below (FIXME?) */
1675   if (filenames == NULL || *filenames == NULL)
1676     filenames = empty_filenames;
1677 
1678   recurse_into_dirs = ! !(flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);
1679 
1680   if ((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX) ||
1681       (flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX))
1682     partial_names = TRUE;
1683 
1684   /* if we can construct the exact paths to check with the data we have, just
1685    * stat them one by one; this is more efficient than opening the directory
1686    * and going through each entry to see if it matches one of our filenames. */
1687   if (!recurse_into_dirs &amp;&amp; !partial_names) {
1688     for (i = 0; filenames[i] != NULL; ++i) {
1689       GStatBuf s;
1690       gchar *full_path;
1691       guint fhash;
1692 
1693       full_path = g_build_filename (path, filenames[i], NULL);
1694       if (g_stat (full_path, &amp;s) &lt; 0) {
1695         fhash = (guint) - 1;
1696         GST_LOG_OBJECT (plugin, &quot;stat: %s (error: %s)&quot;, full_path,
1697             g_strerror (errno));
1698       } else {
1699         fhash = gst_plugin_ext_dep_get_hash_from_stat_entry (&amp;s);
1700         GST_LOG_OBJECT (plugin, &quot;stat: %s (result: %08x)&quot;, full_path, fhash);
1701       }
1702       hash += fhash;
1703       g_free (full_path);
1704     }
1705   } else {
1706     hash = gst_plugin_ext_dep_scan_dir_and_match_names (plugin, path,
1707         filenames, flags, 0);
1708   }
1709 
1710   return hash;
1711 }
1712 
1713 static guint
1714 gst_plugin_ext_dep_get_stat_hash (GstPlugin * plugin, GstPluginDep * dep)
1715 {
1716   gboolean paths_are_default_only;
1717   gboolean paths_are_relative_to_exe;
1718   GQueue scan_paths = G_QUEUE_INIT;
1719   guint scan_hash = 0;
1720   gchar *path;
1721 
1722   GST_LOG_OBJECT (plugin, &quot;start&quot;);
1723 
1724   paths_are_default_only =
1725       dep-&gt;flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY;
1726   paths_are_relative_to_exe =
1727       dep-&gt;flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE;
1728 
1729   gst_plugin_ext_dep_extract_env_vars_paths (plugin, dep, &amp;scan_paths);
1730 
1731   if (g_queue_is_empty (&amp;scan_paths) || !paths_are_default_only) {
1732     gchar **paths;
1733 
1734     for (paths = dep-&gt;paths; paths != NULL &amp;&amp; *paths != NULL; ++paths) {
1735       const gchar *path = *paths;
1736       gchar *full_path;
1737 
1738       if (paths_are_relative_to_exe &amp;&amp; !g_path_is_absolute (path)) {
1739         gchar *appdir;
1740 
1741         if (!_gst_executable_path) {
1742           GST_FIXME_OBJECT (plugin,
1743               &quot;Path dependency %s relative to executable path but could not retrieve executable path&quot;,
1744               path);
1745           continue;
1746         }
1747         appdir = g_path_get_dirname (_gst_executable_path);
1748         full_path = g_build_filename (appdir, path, NULL);
1749         g_free (appdir);
1750       } else {
1751         full_path = g_strdup (path);
1752       }
1753 
1754       if (!g_queue_find_custom (&amp;scan_paths, full_path, (GCompareFunc) strcmp)) {
1755         GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39;&quot;, full_path);
1756         g_queue_push_tail (&amp;scan_paths, full_path);
1757       } else {
1758         GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39; (duplicate, ignoring)&quot;, full_path);
1759         g_free (full_path);
<a name="9" id="anc9"></a>
1760     }
1761   }
<a name="10" id="anc10"></a><span class="line-removed">1762   }</span>
1763 
1764   while ((path = g_queue_pop_head (&amp;scan_paths))) {
1765     scan_hash += gst_plugin_ext_dep_scan_path_with_filenames (plugin, path,
1766         (const gchar **) dep-&gt;names, dep-&gt;flags);
1767     g_free (path);
1768   }
1769 
1770   GST_LOG_OBJECT (plugin, &quot;done, scan_hash: %08x&quot;, scan_hash);
1771   return scan_hash;
1772 }
1773 
1774 gboolean
1775 _priv_plugin_deps_files_changed (GstPlugin * plugin)
1776 {
1777   GList *l;
1778 
1779   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1780     GstPluginDep *dep = l-&gt;data;
1781 
1782     if (dep-&gt;stat_hash != gst_plugin_ext_dep_get_stat_hash (plugin, dep))
1783       return TRUE;
1784   }
1785 
1786   return FALSE;
1787 }
1788 
1789 static void
1790 gst_plugin_ext_dep_free (GstPluginDep * dep)
1791 {
1792   g_strfreev (dep-&gt;env_vars);
1793   g_strfreev (dep-&gt;paths);
1794   g_strfreev (dep-&gt;names);
1795   g_slice_free (GstPluginDep, dep);
1796 }
1797 
1798 static gboolean
1799 gst_plugin_ext_dep_strv_equal (gchar ** arr1, gchar ** arr2)
1800 {
1801   if (arr1 == arr2)
1802     return TRUE;
1803   if (arr1 == NULL || arr2 == NULL)
1804     return FALSE;
1805   for (; *arr1 != NULL &amp;&amp; *arr2 != NULL; ++arr1, ++arr2) {
1806     if (strcmp (*arr1, *arr2) != 0)
1807       return FALSE;
1808   }
1809   return (*arr1 == *arr2);
1810 }
1811 
1812 static gboolean
1813 gst_plugin_ext_dep_equals (GstPluginDep * dep, const gchar ** env_vars,
1814     const gchar ** paths, const gchar ** names, GstPluginDependencyFlags flags)
1815 {
1816   if (dep-&gt;flags != flags)
1817     return FALSE;
1818 
1819   return gst_plugin_ext_dep_strv_equal (dep-&gt;env_vars, (gchar **) env_vars) &amp;&amp;
1820       gst_plugin_ext_dep_strv_equal (dep-&gt;paths, (gchar **) paths) &amp;&amp;
1821       gst_plugin_ext_dep_strv_equal (dep-&gt;names, (gchar **) names);
1822 }
1823 
1824 /**
1825  * gst_plugin_add_dependency:
1826  * @plugin: a #GstPlugin
1827  * @env_vars: (allow-none) (array zero-terminated=1): %NULL-terminated array of environment variables affecting the
1828  *     feature set of the plugin (e.g. an environment variable containing
1829  *     paths where to look for additional modules/plugins of a library),
1830  *     or %NULL. Environment variable names may be followed by a path component
1831  *      which will be added to the content of the environment variable, e.g.
1832  *      &quot;HOME/.mystuff/plugins&quot;.
1833  * @paths: (allow-none) (array zero-terminated=1): %NULL-terminated array of directories/paths where dependent files
1834  *     may be, or %NULL.
1835  * @names: (allow-none) (array zero-terminated=1): %NULL-terminated array of file names (or file name suffixes,
1836  *     depending on @flags) to be used in combination with the paths from
1837  *     @paths and/or the paths extracted from the environment variables in
1838  *     @env_vars, or %NULL.
1839  * @flags: optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
1840  *
1841  * Make GStreamer aware of external dependencies which affect the feature
1842  * set of this plugin (ie. the elements or typefinders associated with it).
1843  *
1844  * GStreamer will re-inspect plugins with external dependencies whenever any
1845  * of the external dependencies change. This is useful for plugins which wrap
1846  * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
1847  * library and makes visualisations available as GStreamer elements, or a
1848  * codec loader which exposes elements and/or caps dependent on what external
1849  * codec libraries are currently installed.
1850  */
1851 void
1852 gst_plugin_add_dependency (GstPlugin * plugin, const gchar ** env_vars,
1853     const gchar ** paths, const gchar ** names, GstPluginDependencyFlags flags)
1854 {
1855   GstPluginDep *dep;
1856   GList *l;
1857 
1858   g_return_if_fail (GST_IS_PLUGIN (plugin));
1859 
1860   if ((env_vars == NULL || env_vars[0] == NULL) &amp;&amp;
1861       (paths == NULL || paths[0] == NULL)) {
1862     GST_DEBUG_OBJECT (plugin,
1863         &quot;plugin registered empty dependency set. Ignoring&quot;);
1864     return;
1865   }
1866 
1867   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1868     if (gst_plugin_ext_dep_equals (l-&gt;data, env_vars, paths, names, flags)) {
1869       GST_LOG_OBJECT (plugin, &quot;dependency already registered&quot;);
1870       return;
1871     }
1872   }
1873 
1874   dep = g_slice_new (GstPluginDep);
1875 
1876   dep-&gt;env_vars = g_strdupv ((gchar **) env_vars);
1877   dep-&gt;paths = g_strdupv ((gchar **) paths);
1878   dep-&gt;names = g_strdupv ((gchar **) names);
1879   dep-&gt;flags = flags;
1880 
1881   dep-&gt;env_hash = gst_plugin_ext_dep_get_env_vars_hash (plugin, dep);
1882   dep-&gt;stat_hash = gst_plugin_ext_dep_get_stat_hash (plugin, dep);
1883 
1884   plugin-&gt;priv-&gt;deps = g_list_append (plugin-&gt;priv-&gt;deps, dep);
1885 
1886   GST_DEBUG_OBJECT (plugin, &quot;added dependency:&quot;);
1887   for (; env_vars != NULL &amp;&amp; *env_vars != NULL; ++env_vars)
1888     GST_DEBUG_OBJECT (plugin, &quot; evar: %s&quot;, *env_vars);
1889   for (; paths != NULL &amp;&amp; *paths != NULL; ++paths)
1890     GST_DEBUG_OBJECT (plugin, &quot; path: %s&quot;, *paths);
1891   for (; names != NULL &amp;&amp; *names != NULL; ++names)
1892     GST_DEBUG_OBJECT (plugin, &quot; name: %s&quot;, *names);
1893 }
1894 
1895 /**
1896  * gst_plugin_add_dependency_simple:
1897  * @plugin: the #GstPlugin
1898  * @env_vars: (allow-none): one or more environment variables (separated by &#39;:&#39;, &#39;;&#39; or &#39;,&#39;),
1899  *      or %NULL. Environment variable names may be followed by a path component
1900  *      which will be added to the content of the environment variable, e.g.
1901  *      &quot;HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH&quot;
1902  * @paths: (allow-none): one ore more directory paths (separated by &#39;:&#39; or &#39;;&#39; or &#39;,&#39;),
1903  *      or %NULL. Example: &quot;/usr/lib/mystuff/plugins&quot;
1904  * @names: (allow-none): one or more file names or file name suffixes (separated by commas),
1905  *      or %NULL
1906  * @flags: optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
1907  *
1908  * Make GStreamer aware of external dependencies which affect the feature
1909  * set of this plugin (ie. the elements or typefinders associated with it).
1910  *
1911  * GStreamer will re-inspect plugins with external dependencies whenever any
1912  * of the external dependencies change. This is useful for plugins which wrap
1913  * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
1914  * library and makes visualisations available as GStreamer elements, or a
1915  * codec loader which exposes elements and/or caps dependent on what external
1916  * codec libraries are currently installed.
1917  *
1918  * Convenience wrapper function for gst_plugin_add_dependency() which
1919  * takes simple strings as arguments instead of string arrays, with multiple
1920  * arguments separated by predefined delimiters (see above).
1921  */
1922 void
1923 gst_plugin_add_dependency_simple (GstPlugin * plugin,
1924     const gchar * env_vars, const gchar * paths, const gchar * names,
1925     GstPluginDependencyFlags flags)
1926 {
1927   gchar **a_evars = NULL;
1928   gchar **a_paths = NULL;
1929   gchar **a_names = NULL;
1930 
1931   if (env_vars)
1932     a_evars = g_strsplit_set (env_vars, &quot;:;,&quot;, -1);
1933   if (paths)
1934     a_paths = g_strsplit_set (paths, &quot;:;,&quot;, -1);
1935   if (names)
1936     a_names = g_strsplit_set (names, &quot;,&quot;, -1);
1937 
1938   gst_plugin_add_dependency (plugin, (const gchar **) a_evars,
1939       (const gchar **) a_paths, (const gchar **) a_names, flags);
1940 
1941   if (a_evars)
1942     g_strfreev (a_evars);
1943   if (a_paths)
1944     g_strfreev (a_paths);
1945   if (a_names)
1946     g_strfreev (a_names);
1947 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>