<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvariant-internal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant-serialiser.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright ï¿½ 2009, 2010 Codethink Limited</span>
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
</pre>
<hr />
<pre>
 193       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 194         if (!g_ascii_isalnum (*end) &amp;&amp;
 195             *end != &#39;-&#39; &amp;&amp; *end != &#39;+&#39; &amp;&amp; *end != &#39;.&#39;)
 196           break;
 197       break;
 198 
 199     case &#39;b&#39;:
 200       if (stream-&gt;stream + 1 != stream-&gt;end &amp;&amp;
 201           (stream-&gt;stream[1] == &#39;\&#39;&#39; || stream-&gt;stream[1] == &#39;&quot;&#39;))
 202         {
 203           for (end = stream-&gt;stream + 2; end != stream-&gt;end; end++)
 204             if (*end == stream-&gt;stream[1] || *end == &#39;\0&#39; ||
 205                 (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 206               break;
 207 
 208           if (end != stream-&gt;end &amp;&amp; *end)
 209             end++;
 210           break;
 211         }
 212 
<span class="line-modified"> 213       else</span>
<span class="line-removed"> 214         {</span>
<span class="line-removed"> 215           /* ??? */</span>
<span class="line-removed"> 216         }</span>
 217 
 218     case &#39;a&#39;: /* &#39;b&#39; */ case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
 219     case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
 220     case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
 221     case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
 222     case &#39;y&#39;: case &#39;z&#39;:
 223       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 224         if (!g_ascii_isalnum (*end))
 225           break;
 226       break;
 227 
 228     case &#39;\&#39;&#39;: case &#39;&quot;&#39;:
 229       for (end = stream-&gt;stream + 1; end != stream-&gt;end; end++)
 230         if (*end == stream-&gt;stream[0] || *end == &#39;\0&#39; ||
 231             (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 232           break;
 233 
 234       if (end != stream-&gt;end &amp;&amp; *end)
 235         end++;
 236       break;
</pre>
<hr />
<pre>
 348                       const gchar  *token,
 349                       const gchar  *purpose,
 350                       GError      **error)
 351 {
 352 
 353   if (!token_stream_consume (stream, token))
 354     {
 355       token_stream_set_error (stream, error, FALSE,
 356                               G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
 357                               &quot;expected &#39;%s&#39;%s&quot;, token, purpose);
 358       return FALSE;
 359     }
 360 
 361   return TRUE;
 362 }
 363 
 364 static void
 365 token_stream_assert (TokenStream *stream,
 366                      const gchar *token)
 367 {
<span class="line-modified"> 368   gboolean correct_token;</span>
 369 
 370   correct_token = token_stream_consume (stream, token);
 371   g_assert (correct_token);
 372 }
 373 
 374 static gchar *
 375 token_stream_get (TokenStream *stream)
 376 {
 377   gchar *result;
 378 
 379   if (!token_stream_prepare (stream))
 380     return NULL;
 381 
 382   result = g_strndup (stream-&gt;this, stream-&gt;stream - stream-&gt;this);
 383 
 384   return result;
 385 }
 386 
 387 static void
 388 token_stream_start_ref (TokenStream *stream,
</pre>
<hr />
<pre>
 404               const gchar **in)
 405 {
 406   gint brackets = 0;
 407 
 408   while (**in == &#39;a&#39; || **in == &#39;m&#39; || **in == &#39;M&#39;)
 409     *(*out)++ = *(*in)++;
 410 
 411   do
 412     {
 413       if (**in == &#39;(&#39; || **in == &#39;{&#39;)
 414         brackets++;
 415 
 416       else if (**in == &#39;)&#39; || **in == &#39;}&#39;)
 417         brackets--;
 418 
 419       *(*out)++ = *(*in)++;
 420     }
 421   while (brackets);
 422 }
 423 


 424 static gchar *
 425 pattern_coalesce (const gchar *left,
 426                   const gchar *right)
 427 {
 428   gchar *result;
 429   gchar *out;
 430 
 431   /* the length of the output is loosely bound by the sum of the input
 432    * lengths, not simply the greater of the two lengths.
 433    *
 434    *   (*(iii)) + ((iii)*) ((iii)(iii))
 435    *
 436    *      8     +    8    =  12
 437    */
 438   out = result = g_malloc (strlen (left) + strlen (right));
 439 
 440   while (*left &amp;&amp; *right)
 441     {
 442       if (*left == *right)
 443         {
 444           *out++ = *left++;
 445           right++;
 446         }
 447 
 448       else
 449         {
 450           const gchar **one = &amp;left, **the_other = &amp;right;
 451 
 452          again:
 453           if (**one == &#39;*&#39; &amp;&amp; **the_other != &#39;)&#39;)
 454             {
 455               pattern_copy (&amp;out, the_other);
 456               (*one)++;
 457             }
 458 
 459           else if (**one == &#39;M&#39; &amp;&amp; **the_other == &#39;m&#39;)
 460             {
 461               *out++ = *(*the_other)++;
 462             }
 463 
<span class="line-modified"> 464           else if (**one == &#39;M&#39; &amp;&amp; **the_other != &#39;m&#39;)</span>
 465             {
 466               (*one)++;
 467             }
 468 
 469           else if (**one == &#39;N&#39; &amp;&amp; strchr (&quot;ynqiuxthd&quot;, **the_other))
 470             {
 471               *out++ = *(*the_other)++;
 472               (*one)++;
 473             }
 474 
 475           else if (**one == &#39;S&#39; &amp;&amp; strchr (&quot;sog&quot;, **the_other))
 476             {
 477               *out++ = *(*the_other)++;
 478               (*one)++;
 479             }
 480 
 481           else if (one == &amp;left)
 482             {
 483               one = &amp;right, the_other = &amp;left;
 484               goto again;
</pre>
<hr />
<pre>
 657 
 658 static void
 659 ast_array_free (AST  **array,
 660                 gint   n_items)
 661 {
 662   gint i;
 663 
 664   for (i = 0; i &lt; n_items; i++)
 665     ast_free (array[i]);
 666   g_free (array);
 667 }
 668 
 669 static gchar *
 670 ast_array_get_pattern (AST    **array,
 671                        gint     n_items,
 672                        GError **error)
 673 {
 674   gchar *pattern;
 675   gint i;
 676 



 677   pattern = ast_get_pattern (array[0], error);
 678 
 679   if (pattern == NULL)
 680     return NULL;
 681 
 682   for (i = 1; i &lt; n_items; i++)
 683     {
 684       gchar *tmp, *merged;
 685 
 686       tmp = ast_get_pattern (array[i], error);
 687 
 688       if (tmp == NULL)
 689         {
 690           g_free (pattern);
 691           return NULL;
 692         }
 693 
 694       merged = pattern_coalesce (pattern, tmp);
 695       g_free (pattern);
 696       pattern = merged;
 697 
 698       if (merged == NULL)
 699         /* set coalescence implies pairwise coalescence (i think).
 700          * we should therefore be able to trace the failure to a single
 701          * pair of values.
 702          */
 703         {
 704           int j = 0;
 705 
 706           while (TRUE)
 707             {
 708               gchar *tmp2;
 709               gchar *m;
 710 
<span class="line-modified"> 711               /* if &#39;j&#39; reaches &#39;i&#39; then we failed to find the pair */</span>
<span class="line-modified"> 712               g_assert (j &lt; i);</span>










 713 
 714               tmp2 = ast_get_pattern (array[j], NULL);
 715               g_assert (tmp2 != NULL);
 716 
 717               m = pattern_coalesce (tmp, tmp2);
 718               g_free (tmp2);
 719               g_free (m);
 720 
 721               if (m == NULL)
 722                 {
 723                   /* we found a conflict between &#39;i&#39; and &#39;j&#39;.
 724                    *
 725                    * report the error.  note: &#39;j&#39; is first.
 726                    */
 727                   ast_set_error (array[j], error, array[i],
 728                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
 729                                  &quot;unable to find a common type&quot;);
 730                   g_free (tmp);
 731                   return NULL;
 732                 }
</pre>
<hr />
<pre>
1514                          &quot;not a valid signature&quot;);
1515           return NULL;
1516         }
1517 
1518       return g_variant_new_signature (string-&gt;string);
1519     }
1520 
1521   else
1522     return ast_type_error (ast, type, error);
1523 }
1524 
1525 static void
1526 string_free (AST *ast)
1527 {
1528   String *string = (String *) ast;
1529 
1530   g_free (string-&gt;string);
1531   g_slice_free (String, string);
1532 }
1533 


1534 static gboolean
1535 unicode_unescape (const gchar  *src,
1536                   gint         *src_ofs,
1537                   gchar        *dest,
1538                   gint         *dest_ofs,
<span class="line-modified">1539                   gint          length,</span>
1540                   SourceRef    *ref,
1541                   GError      **error)
1542 {
1543   gchar buffer[9];
<span class="line-modified">1544   guint64 value;</span>
1545   gchar *end;

1546 
1547   (*src_ofs)++;
1548 
1549   g_assert (length &lt; sizeof (buffer));
1550   strncpy (buffer, src + *src_ofs, length);
1551   buffer[length] = &#39;\0&#39;;
1552 
<span class="line-modified">1553   value = g_ascii_strtoull (buffer, &amp;end, 0x10);</span>





1554 
1555   if (value == 0 || end != buffer + length)
1556     {
<span class="line-modified">1557       parser_set_error (error, ref, NULL,</span>






1558                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
<span class="line-modified">1559                         &quot;invalid %d-character unicode escape&quot;, length);</span>
1560       return FALSE;
1561     }
1562 
1563   g_assert (value &lt;= G_MAXUINT32);
1564 
1565   *dest_ofs += g_unichar_to_utf8 (value, dest + *dest_ofs);
1566   *src_ofs += length;
1567 
1568   return TRUE;
1569 }
1570 
1571 static AST *
1572 string_parse (TokenStream  *stream,
1573               va_list      *app,
1574               GError      **error)
1575 {
1576   static const ASTClass string_class = {
1577     string_get_pattern,
1578     maybe_wrapper, string_get_value,
1579     string_free
</pre>
<hr />
<pre>
1629 
1630           case &#39;U&#39;:
1631             if (!unicode_unescape (token, &amp;i, str, &amp;j, 8, &amp;ref, error))
1632               {
1633                 g_free (token);
1634                 g_free (str);
1635                 return NULL;
1636               }
1637             continue;
1638 
1639           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1640           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1641           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1642           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1643           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1644           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1645           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1646           case &#39;\n&#39;: i++; continue;
1647           }
1648 


1649       default:
1650         str[j++] = token[i++];
1651       }
1652   str[j++] = &#39;\0&#39;;
1653   g_free (token);
1654 
1655   string = g_slice_new (String);
1656   string-&gt;ast.class = &amp;string_class;
1657   string-&gt;string = str;
1658 
1659   token_stream_next (stream);
1660 
1661   return (AST *) string;
1662 }
1663 
1664 typedef struct
1665 {
1666   AST ast;
1667   gchar *string;
1668 } ByteString;
</pre>
<hr />
<pre>
1756               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1757                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1758 
1759               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1760                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1761 
1762               str[j++] = val;
1763             }
1764             continue;
1765 
1766           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1767           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1768           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1769           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1770           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1771           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1772           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1773           case &#39;\n&#39;: i++; continue;
1774           }
1775 


1776       default:
1777         str[j++] = token[i++];
1778       }
1779   str[j++] = &#39;\0&#39;;
1780   g_free (token);
1781 
1782   string = g_slice_new (ByteString);
1783   string-&gt;ast.class = &amp;bytestring_class;
1784   string-&gt;string = str;
1785 
1786   token_stream_next (stream);
1787 
1788   return (AST *) string;
1789 }
1790 
1791 typedef struct
1792 {
1793   AST ast;
1794 
1795   gchar *token;
</pre>
<hr />
<pre>
1889 
1890       parser_set_error (error, &amp;ref, NULL,
1891                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
1892                         &quot;invalid character in number&quot;);
1893       return NULL;
1894      }
1895 
1896   if (floating)
1897     return g_variant_new_double (dbl_val);
1898 
1899   switch (*g_variant_type_peek_string (type))
1900     {
1901     case &#39;y&#39;:
1902       if (negative || abs_val &gt; G_MAXUINT8)
1903         return number_overflow (ast, type, error);
1904       return g_variant_new_byte (abs_val);
1905 
1906     case &#39;n&#39;:
1907       if (abs_val - negative &gt; G_MAXINT16)
1908         return number_overflow (ast, type, error);
<span class="line-modified">1909       return g_variant_new_int16 (negative ? -abs_val : abs_val);</span>



1910 
1911     case &#39;q&#39;:
1912       if (negative || abs_val &gt; G_MAXUINT16)
1913         return number_overflow (ast, type, error);
1914       return g_variant_new_uint16 (abs_val);
1915 
1916     case &#39;i&#39;:
1917       if (abs_val - negative &gt; G_MAXINT32)
1918         return number_overflow (ast, type, error);
<span class="line-modified">1919       return g_variant_new_int32 (negative ? -abs_val : abs_val);</span>



1920 
1921     case &#39;u&#39;:
1922       if (negative || abs_val &gt; G_MAXUINT32)
1923         return number_overflow (ast, type, error);
1924       return g_variant_new_uint32 (abs_val);
1925 
1926     case &#39;x&#39;:
1927       if (abs_val - negative &gt; G_MAXINT64)
1928         return number_overflow (ast, type, error);
<span class="line-modified">1929       return g_variant_new_int64 (negative ? -abs_val : abs_val);</span>



1930 
1931     case &#39;t&#39;:
1932       if (negative)
1933         return number_overflow (ast, type, error);
1934       return g_variant_new_uint64 (abs_val);
1935 
1936     case &#39;h&#39;:
1937       if (abs_val - negative &gt; G_MAXINT32)
1938         return number_overflow (ast, type, error);
<span class="line-modified">1939       return g_variant_new_handle (negative ? -abs_val : abs_val);</span>



1940 
1941     default:
1942       return ast_type_error (ast, type, error);
1943     }
1944 }
1945 
1946 static void
1947 number_free (AST *ast)
1948 {
1949   Number *number = (Number *) ast;
1950 
1951   g_free (number-&gt;token);
1952   g_slice_free (Number, number);
1953 }
1954 
1955 static AST *
1956 number_parse (TokenStream  *stream,
1957               va_list      *app,
1958               GError      **error)
1959 {
</pre>
<hr />
<pre>
2575  * }
2576  * ]|
2577  *
2578  * Since: 2.26
2579  */
2580 void
2581 g_variant_builder_add_parsed (GVariantBuilder *builder,
2582                               const gchar     *format,
2583                               ...)
2584 {
2585   va_list ap;
2586 
2587   va_start (ap, format);
2588   g_variant_builder_add_value (builder, g_variant_new_parsed_va (format, &amp;ap));
2589   va_end (ap);
2590 }
2591 
2592 static gboolean
2593 parse_num (const gchar *num,
2594            const gchar *limit,
<span class="line-modified">2595            gint        *result)</span>
2596 {
2597   gchar *endptr;
2598   gint64 bignum;
2599 
2600   bignum = g_ascii_strtoll (num, &amp;endptr, 10);
2601 
2602   if (endptr != limit)
2603     return FALSE;
2604 
2605   if (bignum &lt; 0 || bignum &gt; G_MAXINT)
2606     return FALSE;
2607 
<span class="line-modified">2608   *result = bignum;</span>
2609 
2610   return TRUE;
2611 }
2612 
2613 static void
2614 add_last_line (GString     *err,
2615                const gchar *str)
2616 {
2617   const gchar *last_nl;
2618   gchar *chomped;
2619   gint i;
2620 
2621   /* This is an error at the end of input.  If we have a file
2622    * with newlines, that&#39;s probably the empty string after the
2623    * last newline, which is not the most useful thing to show.
2624    *
2625    * Instead, show the last line of non-whitespace that we have
2626    * and put the pointer at the end of it.
2627    */
2628   chomped = g_strchomp (g_strdup (str));
</pre>
<hr />
<pre>
2744    *
2745    *  - a:          -- usually errors from the tokeniser (eof, invalid char, etc.)
2746    *  - a-b:        -- usually errors from handling one single token
2747    *  - a-b,c-d:    -- errors involving two tokens (ie: type inferencing)
2748    *
2749    * We never see, for example &quot;a,c&quot;.
2750    */
2751 
2752   colon = strchr (error-&gt;message, &#39;:&#39;);
2753   dash = strchr (error-&gt;message, &#39;-&#39;);
2754   comma = strchr (error-&gt;message, &#39;,&#39;);
2755 
2756   if (!colon)
2757     return NULL;
2758 
2759   err = g_string_new (colon + 1);
2760   g_string_append (err, &quot;:\n&quot;);
2761 
2762   if (dash == NULL || colon &lt; dash)
2763     {
<span class="line-modified">2764       gint point;</span>
2765 
2766       /* we have a single point */
2767       if (!parse_num (error-&gt;message, colon, &amp;point))
2768         goto out;
2769 
2770       if (point &gt;= strlen (source_str))
2771         /* the error is at the end of the input */
2772         add_last_line (err, source_str);
2773       else
<span class="line-modified">2774         /* otherwise just treat it as a error at a thin range */</span>
2775         add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
2776     }
2777   else
2778     {
2779       /* We have one or two ranges... */
2780       if (comma &amp;&amp; comma &lt; colon)
2781         {
<span class="line-modified">2782           gint start1, end1, start2, end2;</span>
2783           const gchar *dash2;
2784 
2785           /* Two ranges */
2786           dash2 = strchr (comma, &#39;-&#39;);
2787 
2788           if (!parse_num (error-&gt;message, dash, &amp;start1) || !parse_num (dash + 1, comma, &amp;end1) ||
2789               !parse_num (comma + 1, dash2, &amp;start2) || !parse_num (dash2 + 1, colon, &amp;end2))
2790             goto out;
2791 
2792           add_lines_from_range (err, source_str,
2793                                 source_str + start1, source_str + end1,
2794                                 source_str + start2, source_str + end2);
2795         }
2796       else
2797         {
<span class="line-modified">2798           gint start, end;</span>
2799 
2800           /* One range */
2801           if (!parse_num (error-&gt;message, dash, &amp;start) || !parse_num (dash + 1, colon, &amp;end))
2802             goto out;
2803 
2804           add_lines_from_range (err, source_str, source_str + start, source_str + end, NULL, NULL);
2805         }
2806     }
2807 
2808   success = TRUE;
2809 
2810 out:
2811   return g_string_free (err, !success);
2812 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009, 2010 Codethink Limited</span>
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
</pre>
<hr />
<pre>
 193       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 194         if (!g_ascii_isalnum (*end) &amp;&amp;
 195             *end != &#39;-&#39; &amp;&amp; *end != &#39;+&#39; &amp;&amp; *end != &#39;.&#39;)
 196           break;
 197       break;
 198 
 199     case &#39;b&#39;:
 200       if (stream-&gt;stream + 1 != stream-&gt;end &amp;&amp;
 201           (stream-&gt;stream[1] == &#39;\&#39;&#39; || stream-&gt;stream[1] == &#39;&quot;&#39;))
 202         {
 203           for (end = stream-&gt;stream + 2; end != stream-&gt;end; end++)
 204             if (*end == stream-&gt;stream[1] || *end == &#39;\0&#39; ||
 205                 (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 206               break;
 207 
 208           if (end != stream-&gt;end &amp;&amp; *end)
 209             end++;
 210           break;
 211         }
 212 
<span class="line-modified"> 213       G_GNUC_FALLTHROUGH;</span>



 214 
 215     case &#39;a&#39;: /* &#39;b&#39; */ case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
 216     case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
 217     case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
 218     case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
 219     case &#39;y&#39;: case &#39;z&#39;:
 220       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 221         if (!g_ascii_isalnum (*end))
 222           break;
 223       break;
 224 
 225     case &#39;\&#39;&#39;: case &#39;&quot;&#39;:
 226       for (end = stream-&gt;stream + 1; end != stream-&gt;end; end++)
 227         if (*end == stream-&gt;stream[0] || *end == &#39;\0&#39; ||
 228             (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 229           break;
 230 
 231       if (end != stream-&gt;end &amp;&amp; *end)
 232         end++;
 233       break;
</pre>
<hr />
<pre>
 345                       const gchar  *token,
 346                       const gchar  *purpose,
 347                       GError      **error)
 348 {
 349 
 350   if (!token_stream_consume (stream, token))
 351     {
 352       token_stream_set_error (stream, error, FALSE,
 353                               G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
 354                               &quot;expected &#39;%s&#39;%s&quot;, token, purpose);
 355       return FALSE;
 356     }
 357 
 358   return TRUE;
 359 }
 360 
 361 static void
 362 token_stream_assert (TokenStream *stream,
 363                      const gchar *token)
 364 {
<span class="line-modified"> 365   gboolean correct_token G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
 366 
 367   correct_token = token_stream_consume (stream, token);
 368   g_assert (correct_token);
 369 }
 370 
 371 static gchar *
 372 token_stream_get (TokenStream *stream)
 373 {
 374   gchar *result;
 375 
 376   if (!token_stream_prepare (stream))
 377     return NULL;
 378 
 379   result = g_strndup (stream-&gt;this, stream-&gt;stream - stream-&gt;this);
 380 
 381   return result;
 382 }
 383 
 384 static void
 385 token_stream_start_ref (TokenStream *stream,
</pre>
<hr />
<pre>
 401               const gchar **in)
 402 {
 403   gint brackets = 0;
 404 
 405   while (**in == &#39;a&#39; || **in == &#39;m&#39; || **in == &#39;M&#39;)
 406     *(*out)++ = *(*in)++;
 407 
 408   do
 409     {
 410       if (**in == &#39;(&#39; || **in == &#39;{&#39;)
 411         brackets++;
 412 
 413       else if (**in == &#39;)&#39; || **in == &#39;}&#39;)
 414         brackets--;
 415 
 416       *(*out)++ = *(*in)++;
 417     }
 418   while (brackets);
 419 }
 420 
<span class="line-added"> 421 /* Returns the most general pattern that is subpattern of left and subpattern</span>
<span class="line-added"> 422  * of right, or NULL if there is no such pattern. */</span>
 423 static gchar *
 424 pattern_coalesce (const gchar *left,
 425                   const gchar *right)
 426 {
 427   gchar *result;
 428   gchar *out;
 429 
 430   /* the length of the output is loosely bound by the sum of the input
 431    * lengths, not simply the greater of the two lengths.
 432    *
 433    *   (*(iii)) + ((iii)*) ((iii)(iii))
 434    *
 435    *      8     +    8    =  12
 436    */
 437   out = result = g_malloc (strlen (left) + strlen (right));
 438 
 439   while (*left &amp;&amp; *right)
 440     {
 441       if (*left == *right)
 442         {
 443           *out++ = *left++;
 444           right++;
 445         }
 446 
 447       else
 448         {
 449           const gchar **one = &amp;left, **the_other = &amp;right;
 450 
 451          again:
 452           if (**one == &#39;*&#39; &amp;&amp; **the_other != &#39;)&#39;)
 453             {
 454               pattern_copy (&amp;out, the_other);
 455               (*one)++;
 456             }
 457 
 458           else if (**one == &#39;M&#39; &amp;&amp; **the_other == &#39;m&#39;)
 459             {
 460               *out++ = *(*the_other)++;
 461             }
 462 
<span class="line-modified"> 463           else if (**one == &#39;M&#39; &amp;&amp; **the_other != &#39;m&#39; &amp;&amp; **the_other != &#39;*&#39;)</span>
 464             {
 465               (*one)++;
 466             }
 467 
 468           else if (**one == &#39;N&#39; &amp;&amp; strchr (&quot;ynqiuxthd&quot;, **the_other))
 469             {
 470               *out++ = *(*the_other)++;
 471               (*one)++;
 472             }
 473 
 474           else if (**one == &#39;S&#39; &amp;&amp; strchr (&quot;sog&quot;, **the_other))
 475             {
 476               *out++ = *(*the_other)++;
 477               (*one)++;
 478             }
 479 
 480           else if (one == &amp;left)
 481             {
 482               one = &amp;right, the_other = &amp;left;
 483               goto again;
</pre>
<hr />
<pre>
 656 
 657 static void
 658 ast_array_free (AST  **array,
 659                 gint   n_items)
 660 {
 661   gint i;
 662 
 663   for (i = 0; i &lt; n_items; i++)
 664     ast_free (array[i]);
 665   g_free (array);
 666 }
 667 
 668 static gchar *
 669 ast_array_get_pattern (AST    **array,
 670                        gint     n_items,
 671                        GError **error)
 672 {
 673   gchar *pattern;
 674   gint i;
 675 
<span class="line-added"> 676   /* Find the pattern which applies to all children in the array, by l-folding a</span>
<span class="line-added"> 677    * coalesce operation.</span>
<span class="line-added"> 678    */</span>
 679   pattern = ast_get_pattern (array[0], error);
 680 
 681   if (pattern == NULL)
 682     return NULL;
 683 
 684   for (i = 1; i &lt; n_items; i++)
 685     {
 686       gchar *tmp, *merged;
 687 
 688       tmp = ast_get_pattern (array[i], error);
 689 
 690       if (tmp == NULL)
 691         {
 692           g_free (pattern);
 693           return NULL;
 694         }
 695 
 696       merged = pattern_coalesce (pattern, tmp);
 697       g_free (pattern);
 698       pattern = merged;
 699 
 700       if (merged == NULL)
 701         /* set coalescence implies pairwise coalescence (i think).
 702          * we should therefore be able to trace the failure to a single
 703          * pair of values.
 704          */
 705         {
 706           int j = 0;
 707 
 708           while (TRUE)
 709             {
 710               gchar *tmp2;
 711               gchar *m;
 712 
<span class="line-modified"> 713               /* if &#39;j&#39; reaches &#39;i&#39; then we didn&#39;t find the pair that failed</span>
<span class="line-modified"> 714                * to coalesce. This shouldn&#39;t happen (see above), but just in</span>
<span class="line-added"> 715                * case report an error:</span>
<span class="line-added"> 716                */</span>
<span class="line-added"> 717               if (j &gt;= i)</span>
<span class="line-added"> 718                 {</span>
<span class="line-added"> 719                   ast_set_error (array[i], error, NULL,</span>
<span class="line-added"> 720                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,</span>
<span class="line-added"> 721                                  &quot;unable to find a common type&quot;);</span>
<span class="line-added"> 722                   g_free (tmp);</span>
<span class="line-added"> 723                   return NULL;</span>
<span class="line-added"> 724                 }</span>
 725 
 726               tmp2 = ast_get_pattern (array[j], NULL);
 727               g_assert (tmp2 != NULL);
 728 
 729               m = pattern_coalesce (tmp, tmp2);
 730               g_free (tmp2);
 731               g_free (m);
 732 
 733               if (m == NULL)
 734                 {
 735                   /* we found a conflict between &#39;i&#39; and &#39;j&#39;.
 736                    *
 737                    * report the error.  note: &#39;j&#39; is first.
 738                    */
 739                   ast_set_error (array[j], error, array[i],
 740                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
 741                                  &quot;unable to find a common type&quot;);
 742                   g_free (tmp);
 743                   return NULL;
 744                 }
</pre>
<hr />
<pre>
1526                          &quot;not a valid signature&quot;);
1527           return NULL;
1528         }
1529 
1530       return g_variant_new_signature (string-&gt;string);
1531     }
1532 
1533   else
1534     return ast_type_error (ast, type, error);
1535 }
1536 
1537 static void
1538 string_free (AST *ast)
1539 {
1540   String *string = (String *) ast;
1541 
1542   g_free (string-&gt;string);
1543   g_slice_free (String, string);
1544 }
1545 
<span class="line-added">1546 /* Accepts exactly @length hexadecimal digits. No leading sign or `0x`/`0X` prefix allowed.</span>
<span class="line-added">1547  * No leading/trailing space allowed. */</span>
1548 static gboolean
1549 unicode_unescape (const gchar  *src,
1550                   gint         *src_ofs,
1551                   gchar        *dest,
1552                   gint         *dest_ofs,
<span class="line-modified">1553                   gsize         length,</span>
1554                   SourceRef    *ref,
1555                   GError      **error)
1556 {
1557   gchar buffer[9];
<span class="line-modified">1558   guint64 value = 0;</span>
1559   gchar *end;
<span class="line-added">1560   gsize n_valid_chars;</span>
1561 
1562   (*src_ofs)++;
1563 
1564   g_assert (length &lt; sizeof (buffer));
1565   strncpy (buffer, src + *src_ofs, length);
1566   buffer[length] = &#39;\0&#39;;
1567 
<span class="line-modified">1568   for (n_valid_chars = 0; n_valid_chars &lt; length; n_valid_chars++)</span>
<span class="line-added">1569     if (!g_ascii_isxdigit (buffer[n_valid_chars]))</span>
<span class="line-added">1570       break;</span>
<span class="line-added">1571 </span>
<span class="line-added">1572   if (n_valid_chars == length)</span>
<span class="line-added">1573     value = g_ascii_strtoull (buffer, &amp;end, 0x10);</span>
1574 
1575   if (value == 0 || end != buffer + length)
1576     {
<span class="line-modified">1577       SourceRef escape_ref;</span>
<span class="line-added">1578 </span>
<span class="line-added">1579       escape_ref = *ref;</span>
<span class="line-added">1580       escape_ref.start += *src_ofs;</span>
<span class="line-added">1581       escape_ref.end = escape_ref.start + n_valid_chars;</span>
<span class="line-added">1582 </span>
<span class="line-added">1583       parser_set_error (error, &amp;escape_ref, NULL,</span>
1584                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
<span class="line-modified">1585                         &quot;invalid %&quot; G_GSIZE_FORMAT &quot;-character unicode escape&quot;, length);</span>
1586       return FALSE;
1587     }
1588 
1589   g_assert (value &lt;= G_MAXUINT32);
1590 
1591   *dest_ofs += g_unichar_to_utf8 (value, dest + *dest_ofs);
1592   *src_ofs += length;
1593 
1594   return TRUE;
1595 }
1596 
1597 static AST *
1598 string_parse (TokenStream  *stream,
1599               va_list      *app,
1600               GError      **error)
1601 {
1602   static const ASTClass string_class = {
1603     string_get_pattern,
1604     maybe_wrapper, string_get_value,
1605     string_free
</pre>
<hr />
<pre>
1655 
1656           case &#39;U&#39;:
1657             if (!unicode_unescape (token, &amp;i, str, &amp;j, 8, &amp;ref, error))
1658               {
1659                 g_free (token);
1660                 g_free (str);
1661                 return NULL;
1662               }
1663             continue;
1664 
1665           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1666           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1667           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1668           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1669           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1670           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1671           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1672           case &#39;\n&#39;: i++; continue;
1673           }
1674 
<span class="line-added">1675         G_GNUC_FALLTHROUGH;</span>
<span class="line-added">1676 </span>
1677       default:
1678         str[j++] = token[i++];
1679       }
1680   str[j++] = &#39;\0&#39;;
1681   g_free (token);
1682 
1683   string = g_slice_new (String);
1684   string-&gt;ast.class = &amp;string_class;
1685   string-&gt;string = str;
1686 
1687   token_stream_next (stream);
1688 
1689   return (AST *) string;
1690 }
1691 
1692 typedef struct
1693 {
1694   AST ast;
1695   gchar *string;
1696 } ByteString;
</pre>
<hr />
<pre>
1784               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1785                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1786 
1787               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1788                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1789 
1790               str[j++] = val;
1791             }
1792             continue;
1793 
1794           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1795           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1796           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1797           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1798           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1799           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1800           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1801           case &#39;\n&#39;: i++; continue;
1802           }
1803 
<span class="line-added">1804         G_GNUC_FALLTHROUGH;</span>
<span class="line-added">1805 </span>
1806       default:
1807         str[j++] = token[i++];
1808       }
1809   str[j++] = &#39;\0&#39;;
1810   g_free (token);
1811 
1812   string = g_slice_new (ByteString);
1813   string-&gt;ast.class = &amp;bytestring_class;
1814   string-&gt;string = str;
1815 
1816   token_stream_next (stream);
1817 
1818   return (AST *) string;
1819 }
1820 
1821 typedef struct
1822 {
1823   AST ast;
1824 
1825   gchar *token;
</pre>
<hr />
<pre>
1919 
1920       parser_set_error (error, &amp;ref, NULL,
1921                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
1922                         &quot;invalid character in number&quot;);
1923       return NULL;
1924      }
1925 
1926   if (floating)
1927     return g_variant_new_double (dbl_val);
1928 
1929   switch (*g_variant_type_peek_string (type))
1930     {
1931     case &#39;y&#39;:
1932       if (negative || abs_val &gt; G_MAXUINT8)
1933         return number_overflow (ast, type, error);
1934       return g_variant_new_byte (abs_val);
1935 
1936     case &#39;n&#39;:
1937       if (abs_val - negative &gt; G_MAXINT16)
1938         return number_overflow (ast, type, error);
<span class="line-modified">1939       if (negative &amp;&amp; abs_val &gt; G_MAXINT16)</span>
<span class="line-added">1940         return g_variant_new_int16 (G_MININT16);</span>
<span class="line-added">1941       return g_variant_new_int16 (negative ?</span>
<span class="line-added">1942                                   -((gint16) abs_val) : ((gint16) abs_val));</span>
1943 
1944     case &#39;q&#39;:
1945       if (negative || abs_val &gt; G_MAXUINT16)
1946         return number_overflow (ast, type, error);
1947       return g_variant_new_uint16 (abs_val);
1948 
1949     case &#39;i&#39;:
1950       if (abs_val - negative &gt; G_MAXINT32)
1951         return number_overflow (ast, type, error);
<span class="line-modified">1952       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)</span>
<span class="line-added">1953         return g_variant_new_int32 (G_MININT32);</span>
<span class="line-added">1954       return g_variant_new_int32 (negative ?</span>
<span class="line-added">1955                                   -((gint32) abs_val) : ((gint32) abs_val));</span>
1956 
1957     case &#39;u&#39;:
1958       if (negative || abs_val &gt; G_MAXUINT32)
1959         return number_overflow (ast, type, error);
1960       return g_variant_new_uint32 (abs_val);
1961 
1962     case &#39;x&#39;:
1963       if (abs_val - negative &gt; G_MAXINT64)
1964         return number_overflow (ast, type, error);
<span class="line-modified">1965       if (negative &amp;&amp; abs_val &gt; G_MAXINT64)</span>
<span class="line-added">1966         return g_variant_new_int64 (G_MININT64);</span>
<span class="line-added">1967       return g_variant_new_int64 (negative ?</span>
<span class="line-added">1968                                   -((gint64) abs_val) : ((gint64) abs_val));</span>
1969 
1970     case &#39;t&#39;:
1971       if (negative)
1972         return number_overflow (ast, type, error);
1973       return g_variant_new_uint64 (abs_val);
1974 
1975     case &#39;h&#39;:
1976       if (abs_val - negative &gt; G_MAXINT32)
1977         return number_overflow (ast, type, error);
<span class="line-modified">1978       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)</span>
<span class="line-added">1979         return g_variant_new_handle (G_MININT32);</span>
<span class="line-added">1980       return g_variant_new_handle (negative ?</span>
<span class="line-added">1981                                    -((gint32) abs_val) : ((gint32) abs_val));</span>
1982 
1983     default:
1984       return ast_type_error (ast, type, error);
1985     }
1986 }
1987 
1988 static void
1989 number_free (AST *ast)
1990 {
1991   Number *number = (Number *) ast;
1992 
1993   g_free (number-&gt;token);
1994   g_slice_free (Number, number);
1995 }
1996 
1997 static AST *
1998 number_parse (TokenStream  *stream,
1999               va_list      *app,
2000               GError      **error)
2001 {
</pre>
<hr />
<pre>
2617  * }
2618  * ]|
2619  *
2620  * Since: 2.26
2621  */
2622 void
2623 g_variant_builder_add_parsed (GVariantBuilder *builder,
2624                               const gchar     *format,
2625                               ...)
2626 {
2627   va_list ap;
2628 
2629   va_start (ap, format);
2630   g_variant_builder_add_value (builder, g_variant_new_parsed_va (format, &amp;ap));
2631   va_end (ap);
2632 }
2633 
2634 static gboolean
2635 parse_num (const gchar *num,
2636            const gchar *limit,
<span class="line-modified">2637            guint       *result)</span>
2638 {
2639   gchar *endptr;
2640   gint64 bignum;
2641 
2642   bignum = g_ascii_strtoll (num, &amp;endptr, 10);
2643 
2644   if (endptr != limit)
2645     return FALSE;
2646 
2647   if (bignum &lt; 0 || bignum &gt; G_MAXINT)
2648     return FALSE;
2649 
<span class="line-modified">2650   *result = (guint) bignum;</span>
2651 
2652   return TRUE;
2653 }
2654 
2655 static void
2656 add_last_line (GString     *err,
2657                const gchar *str)
2658 {
2659   const gchar *last_nl;
2660   gchar *chomped;
2661   gint i;
2662 
2663   /* This is an error at the end of input.  If we have a file
2664    * with newlines, that&#39;s probably the empty string after the
2665    * last newline, which is not the most useful thing to show.
2666    *
2667    * Instead, show the last line of non-whitespace that we have
2668    * and put the pointer at the end of it.
2669    */
2670   chomped = g_strchomp (g_strdup (str));
</pre>
<hr />
<pre>
2786    *
2787    *  - a:          -- usually errors from the tokeniser (eof, invalid char, etc.)
2788    *  - a-b:        -- usually errors from handling one single token
2789    *  - a-b,c-d:    -- errors involving two tokens (ie: type inferencing)
2790    *
2791    * We never see, for example &quot;a,c&quot;.
2792    */
2793 
2794   colon = strchr (error-&gt;message, &#39;:&#39;);
2795   dash = strchr (error-&gt;message, &#39;-&#39;);
2796   comma = strchr (error-&gt;message, &#39;,&#39;);
2797 
2798   if (!colon)
2799     return NULL;
2800 
2801   err = g_string_new (colon + 1);
2802   g_string_append (err, &quot;:\n&quot;);
2803 
2804   if (dash == NULL || colon &lt; dash)
2805     {
<span class="line-modified">2806       guint point;</span>
2807 
2808       /* we have a single point */
2809       if (!parse_num (error-&gt;message, colon, &amp;point))
2810         goto out;
2811 
2812       if (point &gt;= strlen (source_str))
2813         /* the error is at the end of the input */
2814         add_last_line (err, source_str);
2815       else
<span class="line-modified">2816         /* otherwise just treat it as an error at a thin range */</span>
2817         add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
2818     }
2819   else
2820     {
2821       /* We have one or two ranges... */
2822       if (comma &amp;&amp; comma &lt; colon)
2823         {
<span class="line-modified">2824           guint start1, end1, start2, end2;</span>
2825           const gchar *dash2;
2826 
2827           /* Two ranges */
2828           dash2 = strchr (comma, &#39;-&#39;);
2829 
2830           if (!parse_num (error-&gt;message, dash, &amp;start1) || !parse_num (dash + 1, comma, &amp;end1) ||
2831               !parse_num (comma + 1, dash2, &amp;start2) || !parse_num (dash2 + 1, colon, &amp;end2))
2832             goto out;
2833 
2834           add_lines_from_range (err, source_str,
2835                                 source_str + start1, source_str + end1,
2836                                 source_str + start2, source_str + end2);
2837         }
2838       else
2839         {
<span class="line-modified">2840           guint start, end;</span>
2841 
2842           /* One range */
2843           if (!parse_num (error-&gt;message, dash, &amp;start) || !parse_num (dash + 1, colon, &amp;end))
2844             goto out;
2845 
2846           add_lines_from_range (err, source_str, source_str + start, source_str + end, NULL, NULL);
2847         }
2848     }
2849 
2850   success = TRUE;
2851 
2852 out:
2853   return g_string_free (err, !success);
2854 }
</pre>
</td>
</tr>
</table>
<center><a href="gvariant-internal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant-serialiser.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>