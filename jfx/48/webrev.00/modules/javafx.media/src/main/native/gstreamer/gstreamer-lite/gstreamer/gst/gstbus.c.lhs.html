<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbus.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2004 Wim Taymans &lt;wim@fluendo.com&gt;
   3  *
   4  * gstbus.c: GstBus subsystem
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstbus
  24  * @title: GstBus
  25  * @short_description: Asynchronous message bus subsystem
  26  * @see_also: #GstMessage, #GstElement
  27  *
  28  * The #GstBus is an object responsible for delivering #GstMessage packets in
  29  * a first-in first-out way from the streaming threads (see #GstTask) to the
  30  * application.
  31  *
  32  * Since the application typically only wants to deal with delivery of these
  33  * messages from one thread, the GstBus will marshall the messages between
  34  * different threads. This is important since the actual streaming of media
  35  * is done in another thread than the application.
  36  *
  37  * The GstBus provides support for #GSource based notifications. This makes it
  38  * possible to handle the delivery in the glib mainloop.
  39  *
  40  * The #GSource callback function gst_bus_async_signal_func() can be used to
  41  * convert all bus messages into signal emissions.
  42  *
  43  * A message is posted on the bus with the gst_bus_post() method. With the
  44  * gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
  45  * previously posted message.
  46  *
  47  * The bus can be polled with the gst_bus_poll() method. This methods blocks
  48  * up to the specified timeout value until one of the specified messages types
  49  * is posted on the bus. The application can then gst_bus_pop() the messages
  50  * from the bus to handle them.
  51  * Alternatively the application can register an asynchronous bus function
  52  * using gst_bus_add_watch_full() or gst_bus_add_watch(). This function will
  53  * install a #GSource in the default glib main loop and will deliver messages
  54  * a short while after they have been posted. Note that the main loop should
  55  * be running for the asynchronous callbacks.
  56  *
  57  * It is also possible to get messages from the bus without any thread
  58  * marshalling with the gst_bus_set_sync_handler() method. This makes it
  59  * possible to react to a message in the same thread that posted the
  60  * message on the bus. This should only be used if the application is able
  61  * to deal with messages from different threads.
  62  *
  63  * Every #GstPipeline has one bus.
  64  *
  65  * Note that a #GstPipeline will set its bus into flushing state when changing
  66  * from READY to NULL state.
  67  */
  68 
  69 #include &quot;gst_private.h&quot;
  70 #include &lt;errno.h&gt;
  71 #ifdef HAVE_UNISTD_H
  72 #  include &lt;unistd.h&gt;
  73 #endif
  74 #include &lt;sys/types.h&gt;
  75 
  76 #include &quot;gstatomicqueue.h&quot;
  77 #include &quot;gstinfo.h&quot;
  78 #include &quot;gstpoll.h&quot;
  79 
  80 #include &quot;gstbus.h&quot;
  81 #include &quot;glib-compat-private.h&quot;
  82 
  83 #ifdef G_OS_WIN32
  84 #  ifndef EWOULDBLOCK
  85 #  define EWOULDBLOCK EAGAIN    /* This is just to placate gcc */
  86 #  endif
  87 #endif /* G_OS_WIN32 */
  88 
  89 #define GST_CAT_DEFAULT GST_CAT_BUS
  90 /* bus signals */
  91 enum
  92 {
  93   SYNC_MESSAGE,
  94   ASYNC_MESSAGE,
  95   /* add more above */
  96   LAST_SIGNAL
  97 };
  98 
  99 #define DEFAULT_ENABLE_ASYNC (TRUE)
 100 
 101 enum
 102 {
 103   PROP_0,
 104   PROP_ENABLE_ASYNC
 105 };
 106 
 107 static void gst_bus_dispose (GObject * object);
 108 static void gst_bus_finalize (GObject * object);
 109 
 110 static guint gst_bus_signals[LAST_SIGNAL] = { 0 };
 111 
 112 struct _GstBusPrivate
 113 {
 114   GstAtomicQueue *queue;
 115   GMutex queue_lock;
 116 
 117   GstBusSyncHandler sync_handler;
 118   gpointer sync_handler_data;
 119   GDestroyNotify sync_handler_notify;
 120 
 121   guint num_signal_watchers;
 122 
 123   guint num_sync_message_emitters;
 124   GSource *signal_watch;
 125 
 126   gboolean enable_async;
 127   GstPoll *poll;
 128   GPollFD pollfd;
 129 };
 130 
 131 #define gst_bus_parent_class parent_class
<a name="1" id="anc1"></a><span class="line-modified"> 132 G_DEFINE_TYPE (GstBus, gst_bus, GST_TYPE_OBJECT);</span>
 133 
 134 static void
 135 gst_bus_set_property (GObject * object,
 136     guint prop_id, const GValue * value, GParamSpec * pspec)
 137 {
 138   GstBus *bus = GST_BUS_CAST (object);
 139 
 140   switch (prop_id) {
 141     case PROP_ENABLE_ASYNC:
 142       bus-&gt;priv-&gt;enable_async = g_value_get_boolean (value);
 143       break;
 144     default:
 145       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 146       break;
 147   }
 148 }
 149 
 150 static void
 151 gst_bus_constructed (GObject * object)
 152 {
 153   GstBus *bus = GST_BUS_CAST (object);
 154 
 155   if (bus-&gt;priv-&gt;enable_async) {
 156     bus-&gt;priv-&gt;poll = gst_poll_new_timer ();
 157     gst_poll_get_read_gpollfd (bus-&gt;priv-&gt;poll, &amp;bus-&gt;priv-&gt;pollfd);
 158   }
 159 
 160   G_OBJECT_CLASS (gst_bus_parent_class)-&gt;constructed (object);
 161 }
 162 
 163 static void
 164 gst_bus_class_init (GstBusClass * klass)
 165 {
 166   GObjectClass *gobject_class = (GObjectClass *) klass;
 167 
 168   gobject_class-&gt;dispose = gst_bus_dispose;
 169   gobject_class-&gt;finalize = gst_bus_finalize;
 170   gobject_class-&gt;set_property = gst_bus_set_property;
 171   gobject_class-&gt;constructed = gst_bus_constructed;
 172 
 173   /**
 174    * GstBus::enable-async:
 175    *
 176    * Enable async message delivery support for bus watches,
 177    * gst_bus_pop() and similar API. Without this only the
 178    * synchronous message handlers are called.
 179    *
 180    * This property is used to create the child element buses
 181    * in #GstBin.
 182    */
 183   g_object_class_install_property (gobject_class, PROP_ENABLE_ASYNC,
 184       g_param_spec_boolean (&quot;enable-async&quot;, &quot;Enable Async&quot;,
 185           &quot;Enable async message delivery for bus watches and gst_bus_pop()&quot;,
 186           DEFAULT_ENABLE_ASYNC,
 187           G_PARAM_CONSTRUCT_ONLY | G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
 188 
 189   /**
 190    * GstBus::sync-message:
 191    * @bus: the object which received the signal
 192    * @message: the message that has been posted synchronously
 193    *
 194    * A message has been posted on the bus. This signal is emitted from the
 195    * thread that posted the message so one has to be careful with locking.
 196    *
 197    * This signal will not be emitted by default, you have to call
 198    * gst_bus_enable_sync_message_emission() before.
 199    */
 200   gst_bus_signals[SYNC_MESSAGE] =
 201       g_signal_new (&quot;sync-message&quot;, G_TYPE_FROM_CLASS (klass),
 202       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 203       G_STRUCT_OFFSET (GstBusClass, sync_message), NULL, NULL,
 204       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);
 205 
 206   /**
 207    * GstBus::message:
 208    * @bus: the object which received the signal
 209    * @message: the message that has been posted asynchronously
 210    *
 211    * A message has been posted on the bus. This signal is emitted from a
 212    * GSource added to the mainloop. this signal will only be emitted when
 213    * there is a mainloop running.
 214    */
 215   gst_bus_signals[ASYNC_MESSAGE] =
 216       g_signal_new (&quot;message&quot;, G_TYPE_FROM_CLASS (klass),
 217       G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
 218       G_STRUCT_OFFSET (GstBusClass, message), NULL, NULL,
 219       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_MESSAGE);
<a name="2" id="anc2"></a><span class="line-removed"> 220 </span>
<span class="line-removed"> 221   g_type_class_add_private (klass, sizeof (GstBusPrivate));</span>
 222 }
 223 
 224 static void
 225 gst_bus_init (GstBus * bus)
 226 {
<a name="3" id="anc3"></a><span class="line-modified"> 227   bus-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (bus, GST_TYPE_BUS, GstBusPrivate);</span>
 228   bus-&gt;priv-&gt;enable_async = DEFAULT_ENABLE_ASYNC;
 229   g_mutex_init (&amp;bus-&gt;priv-&gt;queue_lock);
 230   bus-&gt;priv-&gt;queue = gst_atomic_queue_new (32);
 231 
 232   GST_DEBUG_OBJECT (bus, &quot;created&quot;);
 233 }
 234 
 235 static void
 236 gst_bus_dispose (GObject * object)
 237 {
 238   GstBus *bus = GST_BUS (object);
 239 
 240   if (bus-&gt;priv-&gt;queue) {
 241     GstMessage *message;
 242 
 243     g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 244     do {
 245       message = gst_atomic_queue_pop (bus-&gt;priv-&gt;queue);
 246       if (message)
 247         gst_message_unref (message);
 248     } while (message != NULL);
 249     gst_atomic_queue_unref (bus-&gt;priv-&gt;queue);
 250     bus-&gt;priv-&gt;queue = NULL;
 251     g_mutex_unlock (&amp;bus-&gt;priv-&gt;queue_lock);
 252     g_mutex_clear (&amp;bus-&gt;priv-&gt;queue_lock);
 253 
 254     if (bus-&gt;priv-&gt;poll)
 255       gst_poll_free (bus-&gt;priv-&gt;poll);
 256     bus-&gt;priv-&gt;poll = NULL;
 257   }
 258 
 259   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 260 }
 261 
 262 static void
 263 gst_bus_finalize (GObject * object)
 264 {
 265   GstBus *bus = GST_BUS (object);
 266 
 267   if (bus-&gt;priv-&gt;sync_handler_notify)
 268     bus-&gt;priv-&gt;sync_handler_notify (bus-&gt;priv-&gt;sync_handler_data);
 269 
 270   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 271 }
 272 
 273 /**
 274  * gst_bus_new:
 275  *
 276  * Creates a new #GstBus instance.
 277  *
 278  * Returns: (transfer full): a new #GstBus instance
 279  */
 280 GstBus *
 281 gst_bus_new (void)
 282 {
 283   GstBus *result;
 284 
 285   result = g_object_new (gst_bus_get_type (), NULL);
 286   GST_DEBUG_OBJECT (result, &quot;created new bus&quot;);
 287 
 288   /* clear floating flag */
 289   gst_object_ref_sink (result);
 290 
 291   return result;
 292 }
 293 
 294 /**
 295  * gst_bus_post:
 296  * @bus: a #GstBus to post on
 297  * @message: (transfer full): the #GstMessage to post
 298  *
 299  * Post a message on the given bus. Ownership of the message
 300  * is taken by the bus.
 301  *
 302  * Returns: %TRUE if the message could be posted, %FALSE if the bus is flushing.
 303  *
 304  * MT safe.
 305  */
 306 gboolean
 307 gst_bus_post (GstBus * bus, GstMessage * message)
 308 {
 309   GstBusSyncReply reply = GST_BUS_PASS;
 310   GstBusSyncHandler handler;
 311   gboolean emit_sync_message;
 312   gpointer handler_data;
 313 
 314   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
 315   g_return_val_if_fail (GST_IS_MESSAGE (message), FALSE);
 316 
 317   GST_DEBUG_OBJECT (bus, &quot;[msg %p] posting on bus %&quot; GST_PTR_FORMAT, message,
 318       message);
 319 
 320   /* check we didn&#39;t accidentally add a public flag that maps to same value */
 321   g_assert (!GST_MINI_OBJECT_FLAG_IS_SET (message,
 322           GST_MESSAGE_FLAG_ASYNC_DELIVERY));
 323 
 324   GST_OBJECT_LOCK (bus);
 325   /* check if the bus is flushing */
 326   if (GST_OBJECT_FLAG_IS_SET (bus, GST_BUS_FLUSHING))
 327     goto is_flushing;
 328 
 329   handler = bus-&gt;priv-&gt;sync_handler;
 330   handler_data = bus-&gt;priv-&gt;sync_handler_data;
 331   emit_sync_message = bus-&gt;priv-&gt;num_sync_message_emitters &gt; 0;
 332   GST_OBJECT_UNLOCK (bus);
 333 
 334   /* first call the sync handler if it is installed */
 335   if (handler)
 336     reply = handler (bus, message, handler_data);
 337 
 338   /* emit sync-message if requested to do so via
 339      gst_bus_enable_sync_message_emission. terrible but effective */
 340   if (emit_sync_message &amp;&amp; reply != GST_BUS_DROP
 341       &amp;&amp; handler != gst_bus_sync_signal_handler)
 342     gst_bus_sync_signal_handler (bus, message, NULL);
 343 
 344   /* If this is a bus without async message delivery
 345    * always drop the message */
 346   if (!bus-&gt;priv-&gt;poll)
 347     reply = GST_BUS_DROP;
 348 
 349   /* now see what we should do with the message */
 350   switch (reply) {
 351     case GST_BUS_DROP:
 352       /* drop the message */
 353       GST_DEBUG_OBJECT (bus, &quot;[msg %p] dropped&quot;, message);
 354       break;
 355     case GST_BUS_PASS:
 356       /* pass the message to the async queue, refcount passed in the queue */
 357       GST_DEBUG_OBJECT (bus, &quot;[msg %p] pushing on async queue&quot;, message);
 358       gst_atomic_queue_push (bus-&gt;priv-&gt;queue, message);
 359       gst_poll_write_control (bus-&gt;priv-&gt;poll);
 360       GST_DEBUG_OBJECT (bus, &quot;[msg %p] pushed on async queue&quot;, message);
 361 
 362       break;
 363     case GST_BUS_ASYNC:
 364     {
 365       /* async delivery, we need a mutex and a cond to block
 366        * on */
 367       GCond *cond = GST_MESSAGE_GET_COND (message);
 368       GMutex *lock = GST_MESSAGE_GET_LOCK (message);
 369 
 370       g_cond_init (cond);
 371       g_mutex_init (lock);
 372 
 373       GST_MINI_OBJECT_FLAG_SET (message, GST_MESSAGE_FLAG_ASYNC_DELIVERY);
 374 
 375       GST_DEBUG_OBJECT (bus, &quot;[msg %p] waiting for async delivery&quot;, message);
 376 
 377       /* now we lock the message mutex, send the message to the async
 378        * queue. When the message is handled by the app and destroyed,
 379        * the cond will be signalled and we can continue */
 380       g_mutex_lock (lock);
 381 
 382       gst_atomic_queue_push (bus-&gt;priv-&gt;queue, message);
 383       gst_poll_write_control (bus-&gt;priv-&gt;poll);
 384 
 385       /* now block till the message is freed */
 386       g_cond_wait (cond, lock);
 387 
 388       /* we acquired a new ref from gst_message_dispose() so we can clean up */
 389       g_mutex_unlock (lock);
 390 
 391       GST_DEBUG_OBJECT (bus, &quot;[msg %p] delivered asynchronously&quot;, message);
 392 
 393       GST_MINI_OBJECT_FLAG_UNSET (message, GST_MESSAGE_FLAG_ASYNC_DELIVERY);
 394 
 395       g_mutex_clear (lock);
 396       g_cond_clear (cond);
 397 
 398       gst_message_unref (message);
 399       break;
 400     }
 401     default:
 402       g_warning (&quot;invalid return from bus sync handler&quot;);
 403       break;
 404   }
 405   return TRUE;
 406 
 407   /* ERRORS */
 408 is_flushing:
 409   {
 410     GST_DEBUG_OBJECT (bus, &quot;bus is flushing&quot;);
 411     GST_OBJECT_UNLOCK (bus);
 412     gst_message_unref (message);
 413 
 414     return FALSE;
 415   }
 416 }
 417 
 418 /**
 419  * gst_bus_have_pending:
 420  * @bus: a #GstBus to check
 421  *
 422  * Check if there are pending messages on the bus that
 423  * should be handled.
 424  *
 425  * Returns: %TRUE if there are messages on the bus to be handled, %FALSE
 426  * otherwise.
 427  *
 428  * MT safe.
 429  */
 430 gboolean
 431 gst_bus_have_pending (GstBus * bus)
 432 {
 433   gboolean result;
 434 
 435   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
 436 
 437   /* see if there is a message on the bus */
 438   result = gst_atomic_queue_length (bus-&gt;priv-&gt;queue) != 0;
 439 
 440   return result;
 441 }
 442 
 443 /**
 444  * gst_bus_set_flushing:
 445  * @bus: a #GstBus
 446  * @flushing: whether or not to flush the bus
 447  *
 448  * If @flushing, flush out and unref any messages queued in the bus. Releases
 449  * references to the message origin objects. Will flush future messages until
 450  * gst_bus_set_flushing() sets @flushing to %FALSE.
 451  *
 452  * MT safe.
 453  */
 454 void
 455 gst_bus_set_flushing (GstBus * bus, gboolean flushing)
 456 {
 457   GstMessage *message;
 458   GList *message_list = NULL;
 459 
 460   g_return_if_fail (GST_IS_BUS (bus));
 461 
 462   GST_OBJECT_LOCK (bus);
 463 
 464   if (flushing) {
 465     GST_OBJECT_FLAG_SET (bus, GST_BUS_FLUSHING);
 466 
 467     GST_DEBUG_OBJECT (bus, &quot;set bus flushing&quot;);
 468 
 469     while ((message = gst_bus_pop (bus)))
 470       message_list = g_list_prepend (message_list, message);
 471   } else {
 472     GST_DEBUG_OBJECT (bus, &quot;unset bus flushing&quot;);
 473     GST_OBJECT_FLAG_UNSET (bus, GST_BUS_FLUSHING);
 474   }
 475 
 476   GST_OBJECT_UNLOCK (bus);
 477 
 478   g_list_free_full (message_list, (GDestroyNotify) gst_message_unref);
 479 }
 480 
 481 /**
 482  * gst_bus_timed_pop_filtered:
 483  * @bus: a #GstBus to pop from
 484  * @timeout: a timeout in nanoseconds, or GST_CLOCK_TIME_NONE to wait forever
 485  * @types: message types to take into account, GST_MESSAGE_ANY for any type
 486  *
 487  * Get a message from the bus whose type matches the message type mask @types,
 488  * waiting up to the specified timeout (and discarding any messages that do not
 489  * match the mask provided).
 490  *
 491  * If @timeout is 0, this function behaves like gst_bus_pop_filtered(). If
 492  * @timeout is #GST_CLOCK_TIME_NONE, this function will block forever until a
 493  * matching message was posted on the bus.
 494  *
 495  * Returns: (transfer full) (nullable): a #GstMessage matching the
 496  *     filter in @types, or %NULL if no matching message was found on
 497  *     the bus until the timeout expired. The message is taken from
 498  *     the bus and needs to be unreffed with gst_message_unref() after
 499  *     usage.
 500  *
 501  * MT safe.
 502  */
 503 GstMessage *
 504 gst_bus_timed_pop_filtered (GstBus * bus, GstClockTime timeout,
 505     GstMessageType types)
 506 {
 507   GstMessage *message;
 508   GTimeVal now, then;
 509   gboolean first_round = TRUE;
 510   GstClockTime elapsed = 0;
 511 
 512   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 513   g_return_val_if_fail (types != 0, NULL);
 514   g_return_val_if_fail (timeout == 0 || bus-&gt;priv-&gt;poll != NULL, NULL);
 515 
 516   g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 517 
 518   while (TRUE) {
 519     gint ret;
 520 
 521     GST_LOG_OBJECT (bus, &quot;have %d messages&quot;,
 522         gst_atomic_queue_length (bus-&gt;priv-&gt;queue));
 523 
 524     while ((message = gst_atomic_queue_pop (bus-&gt;priv-&gt;queue))) {
 525       if (bus-&gt;priv-&gt;poll) {
 526         while (!gst_poll_read_control (bus-&gt;priv-&gt;poll)) {
 527           if (errno == EWOULDBLOCK) {
 528             /* Retry, this can happen if pushing to the queue has finished,
 529              * popping here succeeded but writing control did not finish
 530              * before we got to this line. */
 531             /* Give other threads the chance to do something */
 532             g_thread_yield ();
 533             continue;
 534           } else {
 535             /* This is a real error and means that either the bus is in an
 536              * inconsistent state, or the GstPoll is invalid. GstPoll already
 537              * prints a critical warning about this, no need to do that again
 538              * ourselves */
 539             break;
 540           }
 541         }
 542       }
 543 
 544       GST_DEBUG_OBJECT (bus, &quot;got message %p, %s from %s, type mask is %u&quot;,
 545           message, GST_MESSAGE_TYPE_NAME (message),
 546           GST_MESSAGE_SRC_NAME (message), (guint) types);
 547       if ((GST_MESSAGE_TYPE (message) &amp; types) != 0) {
 548         /* Extra check to ensure extended types don&#39;t get matched unless
 549          * asked for */
 550         if ((!GST_MESSAGE_TYPE_IS_EXTENDED (message))
 551             || (types &amp; GST_MESSAGE_EXTENDED)) {
 552           /* exit the loop, we have a message */
 553           goto beach;
 554         }
 555       }
 556 
 557       GST_DEBUG_OBJECT (bus, &quot;discarding message, does not match mask&quot;);
 558       gst_message_unref (message);
 559       message = NULL;
 560     }
 561 
 562     /* no need to wait, exit loop */
 563     if (timeout == 0)
 564       break;
 565 
 566     else if (timeout != GST_CLOCK_TIME_NONE) {
 567       if (first_round) {
 568         g_get_current_time (&amp;then);
 569         first_round = FALSE;
 570       } else {
 571         g_get_current_time (&amp;now);
 572 
 573         elapsed = GST_TIMEVAL_TO_TIME (now) - GST_TIMEVAL_TO_TIME (then);
 574 
 575         if (elapsed &gt; timeout)
 576           break;
 577       }
 578     }
 579 
 580     /* only here in timeout case */
 581     g_assert (bus-&gt;priv-&gt;poll);
 582     g_mutex_unlock (&amp;bus-&gt;priv-&gt;queue_lock);
 583     ret = gst_poll_wait (bus-&gt;priv-&gt;poll, timeout - elapsed);
 584     g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 585 
 586     if (ret == 0) {
 587       GST_INFO_OBJECT (bus, &quot;timed out, breaking loop&quot;);
 588       break;
 589     } else {
 590       GST_INFO_OBJECT (bus, &quot;we got woken up, recheck for message&quot;);
 591     }
 592   }
 593 
 594 beach:
 595 
 596   g_mutex_unlock (&amp;bus-&gt;priv-&gt;queue_lock);
 597 
 598   return message;
 599 }
 600 
 601 
 602 /**
 603  * gst_bus_timed_pop:
 604  * @bus: a #GstBus to pop
 605  * @timeout: a timeout
 606  *
 607  * Get a message from the bus, waiting up to the specified timeout.
 608  *
 609  * If @timeout is 0, this function behaves like gst_bus_pop(). If @timeout is
 610  * #GST_CLOCK_TIME_NONE, this function will block forever until a message was
 611  * posted on the bus.
 612  *
 613  * Returns: (transfer full) (nullable): the #GstMessage that is on the
 614  *     bus after the specified timeout or %NULL if the bus is empty
 615  *     after the timeout expired.  The message is taken from the bus
 616  *     and needs to be unreffed with gst_message_unref() after usage.
 617  *
 618  * MT safe.
 619  */
 620 GstMessage *
 621 gst_bus_timed_pop (GstBus * bus, GstClockTime timeout)
 622 {
 623   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 624 
 625   return gst_bus_timed_pop_filtered (bus, timeout, GST_MESSAGE_ANY);
 626 }
 627 
 628 /**
 629  * gst_bus_pop_filtered:
 630  * @bus: a #GstBus to pop
 631  * @types: message types to take into account
 632  *
 633  * Get a message matching @type from the bus.  Will discard all messages on
 634  * the bus that do not match @type and that have been posted before the first
 635  * message that does match @type.  If there is no message matching @type on
 636  * the bus, all messages will be discarded. It is not possible to use message
 637  * enums beyond #GST_MESSAGE_EXTENDED in the @events mask.
 638  *
 639  * Returns: (transfer full) (nullable): the next #GstMessage matching
 640  *     @type that is on the bus, or %NULL if the bus is empty or there
 641  *     is no message matching @type. The message is taken from the bus
 642  *     and needs to be unreffed with gst_message_unref() after usage.
 643  *
 644  * MT safe.
 645  */
 646 GstMessage *
 647 gst_bus_pop_filtered (GstBus * bus, GstMessageType types)
 648 {
 649   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 650   g_return_val_if_fail (types != 0, NULL);
 651 
 652   return gst_bus_timed_pop_filtered (bus, 0, types);
 653 }
 654 
 655 /**
 656  * gst_bus_pop:
 657  * @bus: a #GstBus to pop
 658  *
 659  * Get a message from the bus.
 660  *
 661  * Returns: (transfer full) (nullable): the #GstMessage that is on the
 662  *     bus, or %NULL if the bus is empty. The message is taken from
 663  *     the bus and needs to be unreffed with gst_message_unref() after
 664  *     usage.
 665  *
 666  * MT safe.
 667  */
 668 GstMessage *
 669 gst_bus_pop (GstBus * bus)
 670 {
 671   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 672 
 673   return gst_bus_timed_pop_filtered (bus, 0, GST_MESSAGE_ANY);
 674 }
 675 
 676 /**
 677  * gst_bus_peek:
 678  * @bus: a #GstBus
 679  *
 680  * Peek the message on the top of the bus&#39; queue. The message will remain
 681  * on the bus&#39; message queue. A reference is returned, and needs to be unreffed
 682  * by the caller.
 683  *
 684  * Returns: (transfer full) (nullable): the #GstMessage that is on the
 685  *     bus, or %NULL if the bus is empty.
 686  *
 687  * MT safe.
 688  */
 689 GstMessage *
 690 gst_bus_peek (GstBus * bus)
 691 {
 692   GstMessage *message;
 693 
 694   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 695 
 696   g_mutex_lock (&amp;bus-&gt;priv-&gt;queue_lock);
 697   message = gst_atomic_queue_peek (bus-&gt;priv-&gt;queue);
 698   if (message)
 699     gst_message_ref (message);
 700   g_mutex_unlock (&amp;bus-&gt;priv-&gt;queue_lock);
 701 
 702   GST_DEBUG_OBJECT (bus, &quot;peek on bus, got message %p&quot;, message);
 703 
 704   return message;
 705 }
 706 
 707 /**
 708  * gst_bus_set_sync_handler:
 709  * @bus: a #GstBus to install the handler on
 710  * @func: (allow-none): The handler function to install
 711  * @user_data: User data that will be sent to the handler function.
 712  * @notify: called when @user_data becomes unused
 713  *
 714  * Sets the synchronous handler on the bus. The function will be called
 715  * every time a new message is posted on the bus. Note that the function
 716  * will be called in the same thread context as the posting object. This
 717  * function is usually only called by the creator of the bus. Applications
 718  * should handle messages asynchronously using the gst_bus watch and poll
 719  * functions.
 720  *
 721  * You cannot replace an existing sync_handler. You can pass %NULL to this
 722  * function, which will clear the existing handler.
 723  */
 724 void
 725 gst_bus_set_sync_handler (GstBus * bus, GstBusSyncHandler func,
 726     gpointer user_data, GDestroyNotify notify)
 727 {
 728   GDestroyNotify old_notify;
 729 
 730   g_return_if_fail (GST_IS_BUS (bus));
 731 
 732   GST_OBJECT_LOCK (bus);
 733   /* Assert if the user attempts to replace an existing sync_handler,
 734    * other than to clear it */
 735   if (func != NULL &amp;&amp; bus-&gt;priv-&gt;sync_handler != NULL)
 736     goto no_replace;
 737 
 738   if ((old_notify = bus-&gt;priv-&gt;sync_handler_notify)) {
 739     gpointer old_data = bus-&gt;priv-&gt;sync_handler_data;
 740 
 741     bus-&gt;priv-&gt;sync_handler_data = NULL;
 742     bus-&gt;priv-&gt;sync_handler_notify = NULL;
 743     GST_OBJECT_UNLOCK (bus);
 744 
 745     old_notify (old_data);
 746 
 747     GST_OBJECT_LOCK (bus);
 748   }
 749   bus-&gt;priv-&gt;sync_handler = func;
 750   bus-&gt;priv-&gt;sync_handler_data = user_data;
 751   bus-&gt;priv-&gt;sync_handler_notify = notify;
 752   GST_OBJECT_UNLOCK (bus);
 753 
 754   return;
 755 
 756 no_replace:
 757   {
 758     GST_OBJECT_UNLOCK (bus);
 759     g_warning (&quot;cannot replace existing sync handler&quot;);
 760     return;
 761   }
 762 }
 763 
 764 /**
 765  * gst_bus_get_pollfd:
 766  * @bus: A #GstBus
<a name="4" id="anc4"></a><span class="line-modified"> 767  * @fd: A GPollFD to fill</span>
 768  *
 769  * Gets the file descriptor from the bus which can be used to get notified about
 770  * messages being available with functions like g_poll(), and allows integration
 771  * into other event loops based on file descriptors.
 772  * Whenever a message is available, the POLLIN / %G_IO_IN event is set.
 773  *
 774  * Warning: NEVER read or write anything to the returned fd but only use it
 775  * for getting notifications via g_poll() or similar and then use the normal
 776  * GstBus API, e.g. gst_bus_pop().
 777  *
 778  * Since: 1.14
 779  */
 780 void
 781 gst_bus_get_pollfd (GstBus * bus, GPollFD * fd)
 782 {
 783   g_return_if_fail (GST_IS_BUS (bus));
 784   g_return_if_fail (bus-&gt;priv-&gt;poll != NULL);
 785 
 786   *fd = bus-&gt;priv-&gt;pollfd;
 787 }
 788 
 789 /* GSource for the bus
 790  */
 791 typedef struct
 792 {
 793   GSource source;
 794   GstBus *bus;
 795 } GstBusSource;
 796 
 797 static gboolean
 798 gst_bus_source_prepare (GSource * source, gint * timeout)
 799 {
 800   *timeout = -1;
 801   return FALSE;
 802 }
 803 
 804 static gboolean
 805 gst_bus_source_check (GSource * source)
 806 {
 807   GstBusSource *bsrc = (GstBusSource *) source;
 808 
 809   return bsrc-&gt;bus-&gt;priv-&gt;pollfd.revents &amp; (G_IO_IN | G_IO_HUP | G_IO_ERR);
 810 }
 811 
 812 static gboolean
 813 gst_bus_source_dispatch (GSource * source, GSourceFunc callback,
 814     gpointer user_data)
 815 {
 816   GstBusFunc handler = (GstBusFunc) callback;
 817   GstBusSource *bsource = (GstBusSource *) source;
 818   GstMessage *message;
 819   gboolean keep;
 820   GstBus *bus;
 821 
 822   g_return_val_if_fail (bsource != NULL, FALSE);
 823 
 824   bus = bsource-&gt;bus;
 825 
 826   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
 827 
 828   message = gst_bus_pop (bus);
 829 
 830   /* The message queue might be empty if some other thread or callback set
 831    * the bus to flushing between check/prepare and dispatch */
 832   if (G_UNLIKELY (message == NULL))
 833     return TRUE;
 834 
 835   if (!handler)
 836     goto no_handler;
 837 
 838   GST_DEBUG_OBJECT (bus, &quot;source %p calling dispatch with %&quot; GST_PTR_FORMAT,
 839       source, message);
 840 
 841   keep = handler (bus, message, user_data);
 842   gst_message_unref (message);
 843 
 844   GST_DEBUG_OBJECT (bus, &quot;source %p handler returns %d&quot;, source, keep);
 845 
 846   return keep;
 847 
 848 no_handler:
 849   {
 850     g_warning (&quot;GstBus watch dispatched without callback\n&quot;
 851         &quot;You must call g_source_set_callback().&quot;);
 852     gst_message_unref (message);
 853     return FALSE;
 854   }
 855 }
 856 
 857 static void
 858 gst_bus_source_finalize (GSource * source)
 859 {
 860   GstBusSource *bsource = (GstBusSource *) source;
 861   GstBus *bus;
 862 
 863   bus = bsource-&gt;bus;
 864 
 865   GST_DEBUG_OBJECT (bus, &quot;finalize source %p&quot;, source);
 866 
 867   GST_OBJECT_LOCK (bus);
 868   if (bus-&gt;priv-&gt;signal_watch == source)
 869     bus-&gt;priv-&gt;signal_watch = NULL;
 870   GST_OBJECT_UNLOCK (bus);
 871 
 872   gst_object_unref (bsource-&gt;bus);
 873   bsource-&gt;bus = NULL;
 874 }
 875 
 876 static GSourceFuncs gst_bus_source_funcs = {
 877   gst_bus_source_prepare,
 878   gst_bus_source_check,
 879   gst_bus_source_dispatch,
 880   gst_bus_source_finalize
 881 };
 882 
 883 /**
 884  * gst_bus_create_watch:
 885  * @bus: a #GstBus to create the watch for
 886  *
 887  * Create watch for this bus. The GSource will be dispatched whenever
 888  * a message is on the bus. After the GSource is dispatched, the
 889  * message is popped off the bus and unreffed.
 890  *
 891  * Returns: (transfer full) (nullable): a #GSource that can be added to a mainloop.
 892  */
 893 GSource *
 894 gst_bus_create_watch (GstBus * bus)
 895 {
 896   GstBusSource *source;
 897 
 898   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
 899   g_return_val_if_fail (bus-&gt;priv-&gt;poll != NULL, NULL);
 900 
 901   source = (GstBusSource *) g_source_new (&amp;gst_bus_source_funcs,
 902       sizeof (GstBusSource));
 903 
 904   g_source_set_name ((GSource *) source, &quot;GStreamer message bus watch&quot;);
 905 
 906   source-&gt;bus = gst_object_ref (bus);
 907   g_source_add_poll ((GSource *) source, &amp;bus-&gt;priv-&gt;pollfd);
 908 
 909   return (GSource *) source;
 910 }
 911 
 912 /* must be called with the bus OBJECT LOCK */
 913 static guint
 914 gst_bus_add_watch_full_unlocked (GstBus * bus, gint priority,
 915     GstBusFunc func, gpointer user_data, GDestroyNotify notify)
 916 {
 917   GMainContext *ctx;
 918   guint id;
 919   GSource *source;
 920 
 921   if (bus-&gt;priv-&gt;signal_watch) {
 922     GST_ERROR_OBJECT (bus,
 923         &quot;Tried to add new watch while one was already there&quot;);
 924     return 0;
 925   }
 926 
 927   source = gst_bus_create_watch (bus);
 928   if (!source) {
 929     g_critical (&quot;Creating bus watch failed&quot;);
 930     return 0;
 931   }
 932 
 933   if (priority != G_PRIORITY_DEFAULT)
 934     g_source_set_priority (source, priority);
 935 
 936   g_source_set_callback (source, (GSourceFunc) func, user_data, notify);
 937 
 938   ctx = g_main_context_get_thread_default ();
 939   id = g_source_attach (source, ctx);
 940   g_source_unref (source);
 941 
 942   if (id) {
 943     bus-&gt;priv-&gt;signal_watch = source;
 944   }
 945 
 946   GST_DEBUG_OBJECT (bus, &quot;New source %p with id %u&quot;, source, id);
 947   return id;
 948 }
 949 
 950 /**
 951  * gst_bus_add_watch_full: (rename-to gst_bus_add_watch)
 952  * @bus: a #GstBus to create the watch for.
 953  * @priority: The priority of the watch.
 954  * @func: A function to call when a message is received.
 955  * @user_data: user data passed to @func.
 956  * @notify: the function to call when the source is removed.
 957  *
 958  * Adds a bus watch to the default main context with the given @priority (e.g.
 959  * %G_PRIORITY_DEFAULT). It is also possible to use a non-default  main
 960  * context set up using g_main_context_push_thread_default() (before
 961  * one had to create a bus watch source and attach it to the desired main
 962  * context &#39;manually&#39;).
 963  *
 964  * This function is used to receive asynchronous messages in the main loop.
 965  * There can only be a single bus watch per bus, you must remove it before you
 966  * can set a new one.
 967  *
 968  * The bus watch will only work if a GLib main loop is being run.
 969  *
 970  * When @func is called, the message belongs to the caller; if you want to
 971  * keep a copy of it, call gst_message_ref() before leaving @func.
 972  *
 973  * The watch can be removed using gst_bus_remove_watch() or by returning %FALSE
 974  * from @func. If the watch was added to the default main context it is also
 975  * possible to remove the watch using g_source_remove().
 976  *
 977  * The bus watch will take its own reference to the @bus, so it is safe to unref
 978  * @bus using gst_object_unref() after setting the bus watch.
 979  *
 980  * MT safe.
 981  *
 982  * Returns: The event source id or 0 if @bus already got an event source.
 983  */
 984 guint
 985 gst_bus_add_watch_full (GstBus * bus, gint priority,
 986     GstBusFunc func, gpointer user_data, GDestroyNotify notify)
 987 {
 988   guint id;
 989 
 990   g_return_val_if_fail (GST_IS_BUS (bus), 0);
 991 
 992   GST_OBJECT_LOCK (bus);
 993   id = gst_bus_add_watch_full_unlocked (bus, priority, func, user_data, notify);
 994   GST_OBJECT_UNLOCK (bus);
 995 
 996   return id;
 997 }
 998 
 999 /**
1000  * gst_bus_add_watch: (skip)
1001  * @bus: a #GstBus to create the watch for
1002  * @func: A function to call when a message is received.
1003  * @user_data: user data passed to @func.
1004  *
1005  * Adds a bus watch to the default main context with the default priority
1006  * (%G_PRIORITY_DEFAULT). It is also possible to use a non-default main
1007  * context set up using g_main_context_push_thread_default() (before
1008  * one had to create a bus watch source and attach it to the desired main
1009  * context &#39;manually&#39;).
1010  *
1011  * This function is used to receive asynchronous messages in the main loop.
1012  * There can only be a single bus watch per bus, you must remove it before you
1013  * can set a new one.
1014  *
1015  * The bus watch will only work if a GLib main loop is being run.
1016  *
1017  * The watch can be removed using gst_bus_remove_watch() or by returning %FALSE
1018  * from @func. If the watch was added to the default main context it is also
1019  * possible to remove the watch using g_source_remove().
1020  *
1021  * The bus watch will take its own reference to the @bus, so it is safe to unref
1022  * @bus using gst_object_unref() after setting the bus watch.
1023  *
1024  * MT safe.
1025  *
1026  * Returns: The event source id or 0 if @bus already got an event source.
1027  */
1028 guint
1029 gst_bus_add_watch (GstBus * bus, GstBusFunc func, gpointer user_data)
1030 {
1031   return gst_bus_add_watch_full (bus, G_PRIORITY_DEFAULT, func,
1032       user_data, NULL);
1033 }
1034 
1035 /**
1036  * gst_bus_remove_watch:
1037  * @bus: a #GstBus to remove the watch from.
1038  *
1039  * Removes an installed bus watch from @bus.
1040  *
1041  * Returns: %TRUE on success or %FALSE if @bus has no event source.
1042  *
1043  * Since: 1.6
1044  *
1045  */
1046 gboolean
1047 gst_bus_remove_watch (GstBus * bus)
1048 {
<a name="5" id="anc5"></a><span class="line-modified">1049   GSource *watch_id;</span>
1050 
1051   g_return_val_if_fail (GST_IS_BUS (bus), FALSE);
1052 
1053   GST_OBJECT_LOCK (bus);
1054 
1055   if (bus-&gt;priv-&gt;signal_watch == NULL) {
1056     GST_ERROR_OBJECT (bus, &quot;no bus watch was present&quot;);
<a name="6" id="anc6"></a><span class="line-modified">1057     goto no_watch;</span>
1058   }
1059 
<a name="7" id="anc7"></a><span class="line-modified">1060   watch_id = bus-&gt;priv-&gt;signal_watch;</span>







1061 
1062   GST_OBJECT_UNLOCK (bus);
1063 
<a name="8" id="anc8"></a><span class="line-modified">1064   g_source_destroy (watch_id);</span>



1065 
1066   return TRUE;
1067 
<a name="9" id="anc9"></a><span class="line-modified">1068 no_watch:</span>
1069   GST_OBJECT_UNLOCK (bus);
1070 
1071   return FALSE;
1072 }
1073 
1074 typedef struct
1075 {
1076   GMainLoop *loop;
1077   guint timeout_id;
1078   gboolean source_running;
1079   GstMessageType events;
1080   GstMessage *message;
1081 } GstBusPollData;
1082 
1083 static void
1084 poll_func (GstBus * bus, GstMessage * message, GstBusPollData * poll_data)
1085 {
1086   GstMessageType type;
1087 
1088   if (!g_main_loop_is_running (poll_data-&gt;loop)) {
1089     GST_DEBUG (&quot;mainloop %p not running&quot;, poll_data-&gt;loop);
1090     return;
1091   }
1092 
1093   type = GST_MESSAGE_TYPE (message);
1094 
1095   if (type &amp; poll_data-&gt;events) {
1096     g_assert (poll_data-&gt;message == NULL);
1097     /* keep ref to message */
1098     poll_data-&gt;message = gst_message_ref (message);
1099     GST_DEBUG (&quot;mainloop %p quit&quot;, poll_data-&gt;loop);
1100     g_main_loop_quit (poll_data-&gt;loop);
1101   } else {
1102     GST_DEBUG (&quot;type %08x does not match %08x&quot;, type, poll_data-&gt;events);
1103   }
1104 }
1105 
1106 static gboolean
1107 poll_timeout (GstBusPollData * poll_data)
1108 {
1109   GST_DEBUG (&quot;mainloop %p quit&quot;, poll_data-&gt;loop);
1110   g_main_loop_quit (poll_data-&gt;loop);
1111 
1112   /* we don&#39;t remove the GSource as this would free our poll_data,
1113    * which we still need */
1114   return TRUE;
1115 }
1116 
1117 static void
1118 poll_destroy (GstBusPollData * poll_data, gpointer unused)
1119 {
1120   poll_data-&gt;source_running = FALSE;
1121   if (!poll_data-&gt;timeout_id) {
1122     g_main_loop_unref (poll_data-&gt;loop);
1123     g_slice_free (GstBusPollData, poll_data);
1124   }
1125 }
1126 
1127 static void
1128 poll_destroy_timeout (GstBusPollData * poll_data)
1129 {
1130   poll_data-&gt;timeout_id = 0;
1131   if (!poll_data-&gt;source_running) {
1132     g_main_loop_unref (poll_data-&gt;loop);
1133     g_slice_free (GstBusPollData, poll_data);
1134   }
1135 }
1136 
1137 /**
1138  * gst_bus_poll:
1139  * @bus: a #GstBus
1140  * @events: a mask of #GstMessageType, representing the set of message types to
1141  * poll for (note special handling of extended message types below)
1142  * @timeout: the poll timeout, as a #GstClockTime, or #GST_CLOCK_TIME_NONE to poll
1143  * indefinitely.
1144  *
1145  * Poll the bus for messages. Will block while waiting for messages to come.
1146  * You can specify a maximum time to poll with the @timeout parameter. If
1147  * @timeout is negative, this function will block indefinitely.
1148  *
1149  * All messages not in @events will be popped off the bus and will be ignored.
1150  * It is not possible to use message enums beyond #GST_MESSAGE_EXTENDED in the
1151  * @events mask
1152  *
1153  * Because poll is implemented using the &quot;message&quot; signal enabled by
1154  * gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the &quot;message&quot;
1155  * signal to be emitted for every message that poll sees. Thus a &quot;message&quot;
1156  * signal handler will see the same messages that this function sees -- neither
1157  * will steal messages from the other.
1158  *
1159  * This function will run a main loop from the default main context when
1160  * polling.
1161  *
1162  * You should never use this function, since it is pure evil. This is
1163  * especially true for GUI applications based on Gtk+ or Qt, but also for any
1164  * other non-trivial application that uses the GLib main loop. As this function
1165  * runs a GLib main loop, any callback attached to the default GLib main
1166  * context may be invoked. This could be timeouts, GUI events, I/O events etc.;
1167  * even if gst_bus_poll() is called with a 0 timeout. Any of these callbacks
1168  * may do things you do not expect, e.g. destroy the main application window or
1169  * some other resource; change other application state; display a dialog and
1170  * run another main loop until the user clicks it away. In short, using this
1171  * function may add a lot of complexity to your code through unexpected
1172  * re-entrancy and unexpected changes to your application&#39;s state.
1173  *
1174  * For 0 timeouts use gst_bus_pop_filtered() instead of this function; for
1175  * other short timeouts use gst_bus_timed_pop_filtered(); everything else is
1176  * better handled by setting up an asynchronous bus watch and doing things
1177  * from there.
1178  *
1179  * Returns: (transfer full) (nullable): the message that was received,
1180  *     or %NULL if the poll timed out. The message is taken from the
1181  *     bus and needs to be unreffed with gst_message_unref() after
1182  *     usage.
1183  */
1184 GstMessage *
1185 gst_bus_poll (GstBus * bus, GstMessageType events, GstClockTime timeout)
1186 {
1187   GstBusPollData *poll_data;
1188   GstMessage *ret;
1189   gulong id;
1190 
1191   g_return_val_if_fail (GST_IS_BUS (bus), NULL);
1192 
1193   poll_data = g_slice_new (GstBusPollData);
1194   poll_data-&gt;source_running = TRUE;
1195   poll_data-&gt;loop = g_main_loop_new (NULL, FALSE);
1196   poll_data-&gt;events = events;
1197   poll_data-&gt;message = NULL;
1198 
1199   if (timeout != GST_CLOCK_TIME_NONE)
1200     poll_data-&gt;timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT_IDLE,
1201         timeout / GST_MSECOND, (GSourceFunc) poll_timeout, poll_data,
1202         (GDestroyNotify) poll_destroy_timeout);
1203   else
1204     poll_data-&gt;timeout_id = 0;
1205 
1206   id = g_signal_connect_data (bus, &quot;message&quot;, G_CALLBACK (poll_func), poll_data,
1207       (GClosureNotify) poll_destroy, 0);
1208 
1209   /* these can be nested, so it&#39;s ok */
1210   gst_bus_add_signal_watch (bus);
1211 
1212   GST_DEBUG (&quot;running mainloop %p&quot;, poll_data-&gt;loop);
1213   g_main_loop_run (poll_data-&gt;loop);
1214   GST_DEBUG (&quot;mainloop stopped %p&quot;, poll_data-&gt;loop);
1215 
1216   gst_bus_remove_signal_watch (bus);
1217 
1218   /* holds a ref */
1219   ret = poll_data-&gt;message;
1220 
1221   if (poll_data-&gt;timeout_id)
1222     g_source_remove (poll_data-&gt;timeout_id);
1223 
1224   /* poll_data will be freed now */
1225   g_signal_handler_disconnect (bus, id);
1226 
1227   GST_DEBUG_OBJECT (bus, &quot;finished poll with message %p&quot;, ret);
1228 
1229   return ret;
1230 }
1231 
1232 /**
1233  * gst_bus_async_signal_func:
1234  * @bus: a #GstBus
1235  * @message: the #GstMessage received
1236  * @data: user data
1237  *
1238  * A helper #GstBusFunc that can be used to convert all asynchronous messages
1239  * into signals.
1240  *
1241  * Returns: %TRUE
1242  */
1243 gboolean
1244 gst_bus_async_signal_func (GstBus * bus, GstMessage * message, gpointer data)
1245 {
1246   GQuark detail = 0;
1247 
1248   g_return_val_if_fail (GST_IS_BUS (bus), TRUE);
1249   g_return_val_if_fail (message != NULL, TRUE);
1250 
1251   detail = gst_message_type_to_quark (GST_MESSAGE_TYPE (message));
1252 
1253   g_signal_emit (bus, gst_bus_signals[ASYNC_MESSAGE], detail, message);
1254 
1255   /* we never remove this source based on signal emission return values */
1256   return TRUE;
1257 }
1258 
1259 /**
1260  * gst_bus_sync_signal_handler:
1261  * @bus: a #GstBus
1262  * @message: the #GstMessage received
1263  * @data: user data
1264  *
1265  * A helper GstBusSyncHandler that can be used to convert all synchronous
1266  * messages into signals.
1267  *
1268  * Returns: GST_BUS_PASS
1269  */
1270 GstBusSyncReply
1271 gst_bus_sync_signal_handler (GstBus * bus, GstMessage * message, gpointer data)
1272 {
1273   GQuark detail = 0;
1274 
1275   g_return_val_if_fail (GST_IS_BUS (bus), GST_BUS_DROP);
1276   g_return_val_if_fail (message != NULL, GST_BUS_DROP);
1277 
1278   detail = gst_message_type_to_quark (GST_MESSAGE_TYPE (message));
1279 
1280   g_signal_emit (bus, gst_bus_signals[SYNC_MESSAGE], detail, message);
1281 
1282   return GST_BUS_PASS;
1283 }
1284 
1285 /**
1286  * gst_bus_enable_sync_message_emission:
1287  * @bus: a #GstBus on which you want to receive the &quot;sync-message&quot; signal
1288  *
1289  * Instructs GStreamer to emit the &quot;sync-message&quot; signal after running the bus&#39;s
1290  * sync handler. This function is here so that code can ensure that they can
1291  * synchronously receive messages without having to affect what the bin&#39;s sync
1292  * handler is.
1293  *
1294  * This function may be called multiple times. To clean up, the caller is
1295  * responsible for calling gst_bus_disable_sync_message_emission() as many times
1296  * as this function is called.
1297  *
1298  * While this function looks similar to gst_bus_add_signal_watch(), it is not
1299  * exactly the same -- this function enables &lt;emphasis&gt;synchronous&lt;/emphasis&gt; emission of
1300  * signals when messages arrive; gst_bus_add_signal_watch() adds an idle callback
1301  * to pop messages off the bus &lt;emphasis&gt;asynchronously&lt;/emphasis&gt;. The sync-message signal
1302  * comes from the thread of whatever object posted the message; the &quot;message&quot;
1303  * signal is marshalled to the main thread via the main loop.
1304  *
1305  * MT safe.
1306  */
1307 void
1308 gst_bus_enable_sync_message_emission (GstBus * bus)
1309 {
1310   g_return_if_fail (GST_IS_BUS (bus));
1311 
1312   GST_OBJECT_LOCK (bus);
1313   bus-&gt;priv-&gt;num_sync_message_emitters++;
1314   GST_OBJECT_UNLOCK (bus);
1315 }
1316 
1317 /**
1318  * gst_bus_disable_sync_message_emission:
1319  * @bus: a #GstBus on which you previously called
1320  * gst_bus_enable_sync_message_emission()
1321  *
1322  * Instructs GStreamer to stop emitting the &quot;sync-message&quot; signal for this bus.
1323  * See gst_bus_enable_sync_message_emission() for more information.
1324  *
1325  * In the event that multiple pieces of code have called
1326  * gst_bus_enable_sync_message_emission(), the sync-message emissions will only
1327  * be stopped after all calls to gst_bus_enable_sync_message_emission() were
1328  * &quot;cancelled&quot; by calling this function. In this way the semantics are exactly
1329  * the same as gst_object_ref() that which calls enable should also call
1330  * disable.
1331  *
1332  * MT safe.
1333  */
1334 void
1335 gst_bus_disable_sync_message_emission (GstBus * bus)
1336 {
1337   g_return_if_fail (GST_IS_BUS (bus));
1338   g_return_if_fail (bus-&gt;priv-&gt;num_sync_message_emitters &gt; 0);
1339 
1340   GST_OBJECT_LOCK (bus);
1341   bus-&gt;priv-&gt;num_sync_message_emitters--;
1342   GST_OBJECT_UNLOCK (bus);
1343 }
1344 
1345 /**
1346  * gst_bus_add_signal_watch_full:
1347  * @bus: a #GstBus on which you want to receive the &quot;message&quot; signal
1348  * @priority: The priority of the watch.
1349  *
1350  * Adds a bus signal watch to the default main context with the given @priority
1351  * (e.g. %G_PRIORITY_DEFAULT). It is also possible to use a non-default main
1352  * context set up using g_main_context_push_thread_default()
1353  * (before one had to create a bus watch source and attach it to the desired
1354  * main context &#39;manually&#39;).
1355  *
1356  * After calling this statement, the bus will emit the &quot;message&quot; signal for each
1357  * message posted on the bus when the main loop is running.
1358  *
1359  * This function may be called multiple times. To clean up, the caller is
1360  * responsible for calling gst_bus_remove_signal_watch() as many times as this
1361  * function is called.
1362  *
1363  * There can only be a single bus watch per bus, you must remove any signal
1364  * watch before you can set another type of watch.
1365  *
1366  * MT safe.
1367  */
1368 void
1369 gst_bus_add_signal_watch_full (GstBus * bus, gint priority)
1370 {
1371   g_return_if_fail (GST_IS_BUS (bus));
1372 
1373   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1374   GST_OBJECT_LOCK (bus);
1375 
1376   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1377     goto done;
1378 
1379   /* this should not fail because the counter above takes care of it */
1380   g_assert (!bus-&gt;priv-&gt;signal_watch);
1381 
<a name="10" id="anc10"></a><span class="line-modified">1382       gst_bus_add_watch_full_unlocked (bus, priority, gst_bus_async_signal_func,</span>
1383       NULL, NULL);
1384 
1385   if (G_UNLIKELY (!bus-&gt;priv-&gt;signal_watch))
1386     goto add_failed;
1387 
1388 done:
1389 
1390   bus-&gt;priv-&gt;num_signal_watchers++;
1391 
1392   GST_OBJECT_UNLOCK (bus);
1393   return;
1394 
1395   /* ERRORS */
1396 add_failed:
1397   {
1398     g_critical (&quot;Could not add signal watch to bus %s&quot;, GST_OBJECT_NAME (bus));
1399     GST_OBJECT_UNLOCK (bus);
1400     return;
1401   }
1402 }
1403 
1404 /**
1405  * gst_bus_add_signal_watch:
1406  * @bus: a #GstBus on which you want to receive the &quot;message&quot; signal
1407  *
1408  * Adds a bus signal watch to the default main context with the default priority
1409  * (%G_PRIORITY_DEFAULT). It is also possible to use a non-default
1410  * main context set up using g_main_context_push_thread_default() (before
1411  * one had to create a bus watch source and attach it to the desired main
1412  * context &#39;manually&#39;).
1413  *
1414  * After calling this statement, the bus will emit the &quot;message&quot; signal for each
1415  * message posted on the bus.
1416  *
1417  * This function may be called multiple times. To clean up, the caller is
1418  * responsible for calling gst_bus_remove_signal_watch() as many times as this
1419  * function is called.
1420  *
1421  * MT safe.
1422  */
1423 void
1424 gst_bus_add_signal_watch (GstBus * bus)
1425 {
1426   gst_bus_add_signal_watch_full (bus, G_PRIORITY_DEFAULT);
1427 }
1428 
1429 /**
1430  * gst_bus_remove_signal_watch:
1431  * @bus: a #GstBus you previously added a signal watch to
1432  *
1433  * Removes a signal watch previously added with gst_bus_add_signal_watch().
1434  *
1435  * MT safe.
1436  */
1437 void
1438 gst_bus_remove_signal_watch (GstBus * bus)
1439 {
1440   GSource *source = NULL;
1441 
1442   g_return_if_fail (GST_IS_BUS (bus));
1443 
1444   /* I know the callees don&#39;t take this lock, so go ahead and abuse it */
1445   GST_OBJECT_LOCK (bus);
1446 
1447   if (bus-&gt;priv-&gt;num_signal_watchers == 0)
1448     goto error;
1449 
1450   bus-&gt;priv-&gt;num_signal_watchers--;
1451 
1452   if (bus-&gt;priv-&gt;num_signal_watchers &gt; 0)
1453     goto done;
1454 
1455   GST_DEBUG_OBJECT (bus, &quot;removing signal watch %u&quot;,
1456       g_source_get_id (bus-&gt;priv-&gt;signal_watch));
1457 
<a name="11" id="anc11"></a><span class="line-modified">1458   source = bus-&gt;priv-&gt;signal_watch;</span>

1459 
1460 done:
1461   GST_OBJECT_UNLOCK (bus);
1462 
<a name="12" id="anc12"></a><span class="line-modified">1463   if (source)</span>
1464     g_source_destroy (source);
<a name="13" id="anc13"></a>

1465 
1466   return;
1467 
1468   /* ERRORS */
1469 error:
1470   {
1471     g_critical (&quot;Bus %s has no signal watches attached&quot;, GST_OBJECT_NAME (bus));
1472     GST_OBJECT_UNLOCK (bus);
1473     return;
1474   }
1475 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>