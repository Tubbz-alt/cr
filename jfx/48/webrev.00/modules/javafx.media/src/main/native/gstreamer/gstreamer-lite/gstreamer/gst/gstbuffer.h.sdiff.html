<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbuffer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbufferlist.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
195  *                                 This typically occurs after a seek or a dropped buffer
196  *                                 from a live or network source.
197  * @GST_BUFFER_FLAG_RESYNC:        the buffer timestamps might have a discontinuity
198  *                                 and this buffer is a good point to resynchronize.
199  * @GST_BUFFER_FLAG_CORRUPTED:     the buffer data is corrupted.
200  * @GST_BUFFER_FLAG_MARKER:        the buffer contains a media specific marker. for
201  *                                 video this is typically the end of a frame boundary, for audio
202  *                                 this is usually the start of a talkspurt.
203  * @GST_BUFFER_FLAG_HEADER:        the buffer contains header information that is
204  *                                 needed to decode the following data.
205  * @GST_BUFFER_FLAG_GAP:           the buffer has been created to fill a gap in the
206  *                                 stream and contains media neutral data (elements can
207  *                                 switch to optimized code path that ignores the buffer
208  *                                 content).
209  * @GST_BUFFER_FLAG_DROPPABLE:     the buffer can be dropped without breaking the
210  *                                 stream, for example to reduce bandwidth.
211  * @GST_BUFFER_FLAG_DELTA_UNIT:    this unit cannot be decoded independently.
212  * @GST_BUFFER_FLAG_TAG_MEMORY:    this flag is set when memory of the buffer
213  *                                 is added/removed
214  * @GST_BUFFER_FLAG_SYNC_AFTER:    Elements which write to disk or permanent
<span class="line-modified">215  *               storage should ensure the data is synced after</span>
<span class="line-modified">216  *               writing the contents of this buffer. (Since 1.6)</span>
217  * @GST_BUFFER_FLAG_NON_DROPPABLE: This buffer is important and should not be dropped.
218  *                                 This can be used to mark important buffers, e.g. to flag
219  *                                 RTP packets carrying keyframes or codec setup data for RTP
220  *                                 Forward Error Correction purposes, or to prevent still video
<span class="line-modified">221  *                                 frames from being dropped by elements due to QoS. (Since 1.14)</span>
222  * @GST_BUFFER_FLAG_LAST:          additional media specific flags can be added starting from
223  *                                 this flag.
224  *
225  * A set of buffer flags used to describe properties of a #GstBuffer.
226  */
227 typedef enum {
228   GST_BUFFER_FLAG_LIVE          = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 0),
229   GST_BUFFER_FLAG_DECODE_ONLY   = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 1),
230   GST_BUFFER_FLAG_DISCONT       = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 2),
231   GST_BUFFER_FLAG_RESYNC        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 3),
232   GST_BUFFER_FLAG_CORRUPTED     = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 4),
233   GST_BUFFER_FLAG_MARKER        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 5),
234   GST_BUFFER_FLAG_HEADER        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 6),
235   GST_BUFFER_FLAG_GAP           = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 7),
236   GST_BUFFER_FLAG_DROPPABLE     = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 8),
237   GST_BUFFER_FLAG_DELTA_UNIT    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 9),
238   GST_BUFFER_FLAG_TAG_MEMORY    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 10),
239   GST_BUFFER_FLAG_SYNC_AFTER    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 11),
240   GST_BUFFER_FLAG_NON_DROPPABLE = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 12),
241 
</pre>
<hr />
<pre>
284 GST_API
285 GType       gst_buffer_get_type            (void);
286 
287 GST_API
288 guint       gst_buffer_get_max_memory      (void);
289 
290 /* allocation */
291 
292 GST_API
293 GstBuffer * gst_buffer_new                 (void);
294 
295 GST_API
296 GstBuffer * gst_buffer_new_allocate        (GstAllocator * allocator, gsize size,
297                                             GstAllocationParams * params);
298 GST_API
299 GstBuffer * gst_buffer_new_wrapped_full    (GstMemoryFlags flags, gpointer data, gsize maxsize,
300                                             gsize offset, gsize size, gpointer user_data,
301                                             GDestroyNotify notify);
302 GST_API
303 GstBuffer * gst_buffer_new_wrapped         (gpointer data, gsize size);


304 
305 /* memory blocks */
306 
307 GST_API
308 guint       gst_buffer_n_memory             (GstBuffer *buffer);
309 
310 GST_API
311 void        gst_buffer_insert_memory        (GstBuffer *buffer, gint idx, GstMemory *mem);
312 
313 GST_API
314 void        gst_buffer_replace_memory_range (GstBuffer *buffer, guint idx, gint length, GstMemory *mem);
315 
316 GST_API
317 GstMemory * gst_buffer_peek_memory          (GstBuffer *buffer, guint idx);
318 
319 GST_API
320 GstMemory * gst_buffer_get_memory_range     (GstBuffer *buffer, guint idx, gint length);
321 
322 GST_API
323 void        gst_buffer_remove_memory_range  (GstBuffer *buffer, guint idx, gint length);
</pre>
<hr />
<pre>
429  */
430 static inline GstBuffer *
431 gst_buffer_ref (GstBuffer * buf)
432 {
433   return (GstBuffer *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (buf));
434 }
435 
436 /**
437  * gst_buffer_unref:
438  * @buf: (transfer full): a #GstBuffer.
439  *
440  * Decreases the refcount of the buffer. If the refcount reaches 0, the buffer
441  * with the associated metadata and memory will be freed.
442  */
443 static inline void
444 gst_buffer_unref (GstBuffer * buf)
445 {
446   gst_mini_object_unref (GST_MINI_OBJECT_CAST (buf));
447 }
448 



















449 /* copy buffer */
450 /**
451  * gst_buffer_copy:
452  * @buf: a #GstBuffer.
453  *
454  * Create a copy of the given buffer. This will only copy the buffer&#39;s
455  * data to a newly allocated memory if needed (if the type of memory
456  * requires it), otherwise the underlying data is just referenced.
457  * Check gst_buffer_copy_deep() if you want to force the data
458  * to be copied to newly allocated memory.
459  *
460  * Returns: (transfer full): a new copy of @buf.
461  */
462 static inline GstBuffer *
463 gst_buffer_copy (const GstBuffer * buf)
464 {
465   return GST_BUFFER (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));
466 }
467 
468 GST_API
469 GstBuffer * gst_buffer_copy_deep (const GstBuffer * buf);
470 
471 /**
472  * GstBufferCopyFlags:
473  * @GST_BUFFER_COPY_NONE: copy nothing
474  * @GST_BUFFER_COPY_FLAGS: flag indicating that buffer flags should be copied
475  * @GST_BUFFER_COPY_TIMESTAMPS: flag indicating that buffer pts, dts,
476  *   duration, offset and offset_end should be copied
477  * @GST_BUFFER_COPY_MEMORY: flag indicating that buffer memory should be reffed
478  *   and appended to already existing memory. Unless the memory is marked as
479  *   NO_SHARE, no actual copy of the memory is made but it is simply reffed.
480  *   Add @GST_BUFFER_COPY_DEEP to force a real copy.
481  * @GST_BUFFER_COPY_MERGE: flag indicating that buffer memory should be
482  *   merged
483  * @GST_BUFFER_COPY_META: flag indicating that buffer meta should be
484  *   copied
485  * @GST_BUFFER_COPY_DEEP: flag indicating that memory should always be
<span class="line-modified">486  *   copied instead of reffed (Since 1.2)</span>
487  *
488  * A set of flags that can be provided to the gst_buffer_copy_into()
489  * function to specify which items should be copied.
490  */
491 typedef enum {
492   GST_BUFFER_COPY_NONE           = 0,
493   GST_BUFFER_COPY_FLAGS          = (1 &lt;&lt; 0),
494   GST_BUFFER_COPY_TIMESTAMPS     = (1 &lt;&lt; 1),
495   GST_BUFFER_COPY_META           = (1 &lt;&lt; 2),
496   GST_BUFFER_COPY_MEMORY         = (1 &lt;&lt; 3),
497   GST_BUFFER_COPY_MERGE          = (1 &lt;&lt; 4),
498   GST_BUFFER_COPY_DEEP           = (1 &lt;&lt; 5)
499 } GstBufferCopyFlags;
500 
501 /**
502  * GST_BUFFER_COPY_METADATA: (value 7) (type GstBufferCopyFlags)
503  *
504  * Combination of all possible metadata fields that can be copied with
505  * gst_buffer_copy_into().
506  */
</pre>
</td>
<td>
<hr />
<pre>
195  *                                 This typically occurs after a seek or a dropped buffer
196  *                                 from a live or network source.
197  * @GST_BUFFER_FLAG_RESYNC:        the buffer timestamps might have a discontinuity
198  *                                 and this buffer is a good point to resynchronize.
199  * @GST_BUFFER_FLAG_CORRUPTED:     the buffer data is corrupted.
200  * @GST_BUFFER_FLAG_MARKER:        the buffer contains a media specific marker. for
201  *                                 video this is typically the end of a frame boundary, for audio
202  *                                 this is usually the start of a talkspurt.
203  * @GST_BUFFER_FLAG_HEADER:        the buffer contains header information that is
204  *                                 needed to decode the following data.
205  * @GST_BUFFER_FLAG_GAP:           the buffer has been created to fill a gap in the
206  *                                 stream and contains media neutral data (elements can
207  *                                 switch to optimized code path that ignores the buffer
208  *                                 content).
209  * @GST_BUFFER_FLAG_DROPPABLE:     the buffer can be dropped without breaking the
210  *                                 stream, for example to reduce bandwidth.
211  * @GST_BUFFER_FLAG_DELTA_UNIT:    this unit cannot be decoded independently.
212  * @GST_BUFFER_FLAG_TAG_MEMORY:    this flag is set when memory of the buffer
213  *                                 is added/removed
214  * @GST_BUFFER_FLAG_SYNC_AFTER:    Elements which write to disk or permanent
<span class="line-modified">215  *         storage should ensure the data is synced after</span>
<span class="line-modified">216  *         writing the contents of this buffer. (Since: 1.6)</span>
217  * @GST_BUFFER_FLAG_NON_DROPPABLE: This buffer is important and should not be dropped.
218  *                                 This can be used to mark important buffers, e.g. to flag
219  *                                 RTP packets carrying keyframes or codec setup data for RTP
220  *                                 Forward Error Correction purposes, or to prevent still video
<span class="line-modified">221  *                                 frames from being dropped by elements due to QoS. (Since: 1.14)</span>
222  * @GST_BUFFER_FLAG_LAST:          additional media specific flags can be added starting from
223  *                                 this flag.
224  *
225  * A set of buffer flags used to describe properties of a #GstBuffer.
226  */
227 typedef enum {
228   GST_BUFFER_FLAG_LIVE          = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 0),
229   GST_BUFFER_FLAG_DECODE_ONLY   = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 1),
230   GST_BUFFER_FLAG_DISCONT       = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 2),
231   GST_BUFFER_FLAG_RESYNC        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 3),
232   GST_BUFFER_FLAG_CORRUPTED     = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 4),
233   GST_BUFFER_FLAG_MARKER        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 5),
234   GST_BUFFER_FLAG_HEADER        = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 6),
235   GST_BUFFER_FLAG_GAP           = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 7),
236   GST_BUFFER_FLAG_DROPPABLE     = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 8),
237   GST_BUFFER_FLAG_DELTA_UNIT    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 9),
238   GST_BUFFER_FLAG_TAG_MEMORY    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 10),
239   GST_BUFFER_FLAG_SYNC_AFTER    = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 11),
240   GST_BUFFER_FLAG_NON_DROPPABLE = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 12),
241 
</pre>
<hr />
<pre>
284 GST_API
285 GType       gst_buffer_get_type            (void);
286 
287 GST_API
288 guint       gst_buffer_get_max_memory      (void);
289 
290 /* allocation */
291 
292 GST_API
293 GstBuffer * gst_buffer_new                 (void);
294 
295 GST_API
296 GstBuffer * gst_buffer_new_allocate        (GstAllocator * allocator, gsize size,
297                                             GstAllocationParams * params);
298 GST_API
299 GstBuffer * gst_buffer_new_wrapped_full    (GstMemoryFlags flags, gpointer data, gsize maxsize,
300                                             gsize offset, gsize size, gpointer user_data,
301                                             GDestroyNotify notify);
302 GST_API
303 GstBuffer * gst_buffer_new_wrapped         (gpointer data, gsize size);
<span class="line-added">304 GST_API</span>
<span class="line-added">305 GstBuffer * gst_buffer_new_wrapped_bytes   (GBytes * bytes);</span>
306 
307 /* memory blocks */
308 
309 GST_API
310 guint       gst_buffer_n_memory             (GstBuffer *buffer);
311 
312 GST_API
313 void        gst_buffer_insert_memory        (GstBuffer *buffer, gint idx, GstMemory *mem);
314 
315 GST_API
316 void        gst_buffer_replace_memory_range (GstBuffer *buffer, guint idx, gint length, GstMemory *mem);
317 
318 GST_API
319 GstMemory * gst_buffer_peek_memory          (GstBuffer *buffer, guint idx);
320 
321 GST_API
322 GstMemory * gst_buffer_get_memory_range     (GstBuffer *buffer, guint idx, gint length);
323 
324 GST_API
325 void        gst_buffer_remove_memory_range  (GstBuffer *buffer, guint idx, gint length);
</pre>
<hr />
<pre>
431  */
432 static inline GstBuffer *
433 gst_buffer_ref (GstBuffer * buf)
434 {
435   return (GstBuffer *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (buf));
436 }
437 
438 /**
439  * gst_buffer_unref:
440  * @buf: (transfer full): a #GstBuffer.
441  *
442  * Decreases the refcount of the buffer. If the refcount reaches 0, the buffer
443  * with the associated metadata and memory will be freed.
444  */
445 static inline void
446 gst_buffer_unref (GstBuffer * buf)
447 {
448   gst_mini_object_unref (GST_MINI_OBJECT_CAST (buf));
449 }
450 
<span class="line-added">451 /**</span>
<span class="line-added">452  * gst_clear_buffer: (skip)</span>
<span class="line-added">453  * @buf_ptr: a pointer to a #GstBuffer reference</span>
<span class="line-added">454  *</span>
<span class="line-added">455  * Clears a reference to a #GstBuffer.</span>
<span class="line-added">456  *</span>
<span class="line-added">457  * @buf_ptr must not be %NULL.</span>
<span class="line-added">458  *</span>
<span class="line-added">459  * If the reference is %NULL then this function does nothing. Otherwise, the</span>
<span class="line-added">460  * reference count of the buffer is decreased and the pointer is set to %NULL.</span>
<span class="line-added">461  *</span>
<span class="line-added">462  * Since: 1.16</span>
<span class="line-added">463  */</span>
<span class="line-added">464 static inline void</span>
<span class="line-added">465 gst_clear_buffer (GstBuffer ** buf_ptr)</span>
<span class="line-added">466 {</span>
<span class="line-added">467   gst_clear_mini_object ((GstMiniObject **) buf_ptr);</span>
<span class="line-added">468 }</span>
<span class="line-added">469 </span>
470 /* copy buffer */
471 /**
472  * gst_buffer_copy:
473  * @buf: a #GstBuffer.
474  *
475  * Create a copy of the given buffer. This will only copy the buffer&#39;s
476  * data to a newly allocated memory if needed (if the type of memory
477  * requires it), otherwise the underlying data is just referenced.
478  * Check gst_buffer_copy_deep() if you want to force the data
479  * to be copied to newly allocated memory.
480  *
481  * Returns: (transfer full): a new copy of @buf.
482  */
483 static inline GstBuffer *
484 gst_buffer_copy (const GstBuffer * buf)
485 {
486   return GST_BUFFER (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (buf)));
487 }
488 
489 GST_API
490 GstBuffer * gst_buffer_copy_deep (const GstBuffer * buf);
491 
492 /**
493  * GstBufferCopyFlags:
494  * @GST_BUFFER_COPY_NONE: copy nothing
495  * @GST_BUFFER_COPY_FLAGS: flag indicating that buffer flags should be copied
496  * @GST_BUFFER_COPY_TIMESTAMPS: flag indicating that buffer pts, dts,
497  *   duration, offset and offset_end should be copied
498  * @GST_BUFFER_COPY_MEMORY: flag indicating that buffer memory should be reffed
499  *   and appended to already existing memory. Unless the memory is marked as
500  *   NO_SHARE, no actual copy of the memory is made but it is simply reffed.
501  *   Add @GST_BUFFER_COPY_DEEP to force a real copy.
502  * @GST_BUFFER_COPY_MERGE: flag indicating that buffer memory should be
503  *   merged
504  * @GST_BUFFER_COPY_META: flag indicating that buffer meta should be
505  *   copied
506  * @GST_BUFFER_COPY_DEEP: flag indicating that memory should always be
<span class="line-modified">507  *   copied instead of reffed (Since: 1.2)</span>
508  *
509  * A set of flags that can be provided to the gst_buffer_copy_into()
510  * function to specify which items should be copied.
511  */
512 typedef enum {
513   GST_BUFFER_COPY_NONE           = 0,
514   GST_BUFFER_COPY_FLAGS          = (1 &lt;&lt; 0),
515   GST_BUFFER_COPY_TIMESTAMPS     = (1 &lt;&lt; 1),
516   GST_BUFFER_COPY_META           = (1 &lt;&lt; 2),
517   GST_BUFFER_COPY_MEMORY         = (1 &lt;&lt; 3),
518   GST_BUFFER_COPY_MERGE          = (1 &lt;&lt; 4),
519   GST_BUFFER_COPY_DEEP           = (1 &lt;&lt; 5)
520 } GstBufferCopyFlags;
521 
522 /**
523  * GST_BUFFER_COPY_METADATA: (value 7) (type GstBufferCopyFlags)
524  *
525  * Combination of all possible metadata fields that can be copied with
526  * gst_buffer_copy_into().
527  */
</pre>
</td>
</tr>
</table>
<center><a href="gstbuffer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbufferlist.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>