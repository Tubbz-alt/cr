diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c
@@ -410,42 +410,50 @@
  * g_string_insert_len:
  * @string: a #GString
  * @pos: position in @string where insertion should
  *       happen, or -1 for at the end
  * @val: bytes to insert
- * @len: number of bytes of @val to insert
+ * @len: number of bytes of @val to insert, or -1 for all of @val
  *
  * Inserts @len bytes of @val into @string at @pos.
- * Because @len is provided, @val may contain embedded
- * nuls and need not be nul-terminated. If @pos is -1,
- * bytes are inserted at the end of the string.
  *
- * Since this function does not stop at nul bytes, it is
- * the caller's responsibility to ensure that @val has at
- * least @len addressable bytes.
+ * If @len is positive, @val may contain embedded nuls and need
+ * not be nul-terminated. It is the caller's responsibility to
+ * ensure that @val has at least @len addressable bytes.
+ *
+ * If @len is negative, @val must be nul-terminated and @len
+ * is considered to request the entire string length.
+ *
+ * If @pos is -1, bytes are inserted at the end of the string.
  *
  * Returns: (transfer none): @string
  */
 GString *
 g_string_insert_len (GString     *string,
                      gssize       pos,
                      const gchar *val,
                      gssize       len)
 {
+  gsize len_unsigned, pos_unsigned;
+
   g_return_val_if_fail (string != NULL, NULL);
   g_return_val_if_fail (len == 0 || val != NULL, string);
 
   if (len == 0)
     return string;
 
   if (len < 0)
     len = strlen (val);
+  len_unsigned = len;
 
   if (pos < 0)
-    pos = string->len;
+    pos_unsigned = string->len;
   else
-    g_return_val_if_fail (pos <= string->len, string);
+    {
+      pos_unsigned = pos;
+      g_return_val_if_fail (pos_unsigned <= string->len, string);
+    }
 
   /* Check whether val represents a substring of string.
    * This test probably violates chapter and verse of the C standards,
    * since ">=" and "<=" are only valid when val really is a substring.
    * In practice, it will work on modern archs.
@@ -453,49 +461,52 @@
   if (G_UNLIKELY (val >= string->str && val <= string->str + string->len))
     {
       gsize offset = val - string->str;
       gsize precount = 0;
 
-      g_string_maybe_expand (string, len);
+      g_string_maybe_expand (string, len_unsigned);
       val = string->str + offset;
       /* At this point, val is valid again.  */
 
       /* Open up space where we are going to insert.  */
-      if (pos < string->len)
-        memmove (string->str + pos + len, string->str + pos, string->len - pos);
+      if (pos_unsigned < string->len)
+        memmove (string->str + pos_unsigned + len_unsigned,
+                 string->str + pos_unsigned, string->len - pos_unsigned);
 
       /* Move the source part before the gap, if any.  */
-      if (offset < pos)
+      if (offset < pos_unsigned)
         {
-          precount = MIN (len, pos - offset);
-          memcpy (string->str + pos, val, precount);
+          precount = MIN (len_unsigned, pos_unsigned - offset);
+          memcpy (string->str + pos_unsigned, val, precount);
         }
 
       /* Move the source part after the gap, if any.  */
-      if (len > precount)
-        memcpy (string->str + pos + precount,
-                val + /* Already moved: */ precount + /* Space opened up: */ len,
-                len - precount);
+      if (len_unsigned > precount)
+        memcpy (string->str + pos_unsigned + precount,
+                val + /* Already moved: */ precount +
+                      /* Space opened up: */ len_unsigned,
+                len_unsigned - precount);
     }
   else
     {
-      g_string_maybe_expand (string, len);
+      g_string_maybe_expand (string, len_unsigned);
 
       /* If we aren't appending at the end, move a hunk
        * of the old string to the end, opening up space
        */
-      if (pos < string->len)
-        memmove (string->str + pos + len, string->str + pos, string->len - pos);
+      if (pos_unsigned < string->len)
+        memmove (string->str + pos_unsigned + len_unsigned,
+                 string->str + pos_unsigned, string->len - pos_unsigned);
 
       /* insert the new string */
-      if (len == 1)
-        string->str[pos] = *val;
+      if (len_unsigned == 1)
+        string->str[pos_unsigned] = *val;
       else
-        memcpy (string->str + pos, val, len);
+        memcpy (string->str + pos_unsigned, val, len_unsigned);
     }
 
-  string->len += len;
+  string->len += len_unsigned;
 
   string->str[string->len] = 0;
 
   return string;
 }
@@ -603,19 +614,21 @@
 
 /**
  * g_string_append_len:
  * @string: a #GString
  * @val: bytes to append
- * @len: number of bytes of @val to use
+ * @len: number of bytes of @val to use, or -1 for all of @val
  *
- * Appends @len bytes of @val to @string. Because @len is
- * provided, @val may contain embedded nuls and need not
- * be nul-terminated.
+ * Appends @len bytes of @val to @string.
  *
- * Since this function does not stop at nul bytes, it is
- * the caller's responsibility to ensure that @val has at
- * least @len addressable bytes.
+ * If @len is positive, @val may contain embedded nuls and need
+ * not be nul-terminated. It is the caller's responsibility to
+ * ensure that @val has at least @len addressable bytes.
+ *
+ * If @len is negative, @val must be nul-terminated and @len
+ * is considered to request the entire string length. This
+ * makes g_string_append_len() equivalent to g_string_append().
  *
  * Returns: (transfer none): @string
  */
 GString *
 g_string_append_len (GString     *string,
@@ -683,19 +696,21 @@
 
 /**
  * g_string_prepend_len:
  * @string: a #GString
  * @val: bytes to prepend
- * @len: number of bytes in @val to prepend
+ * @len: number of bytes in @val to prepend, or -1 for all of @val
  *
  * Prepends @len bytes of @val to @string.
- * Because @len is provided, @val may contain
- * embedded nuls and need not be nul-terminated.
  *
- * Since this function does not stop at nul bytes,
- * it is the caller's responsibility to ensure that
- * @val has at least @len addressable bytes.
+ * If @len is positive, @val may contain embedded nuls and need
+ * not be nul-terminated. It is the caller's responsibility to
+ * ensure that @val has at least @len addressable bytes.
+ *
+ * If @len is negative, @val must be nul-terminated and @len
+ * is considered to request the entire string length. This
+ * makes g_string_prepend_len() equivalent to g_string_prepend().
  *
  * Returns: (transfer none): @string
  */
 GString *
 g_string_prepend_len (GString     *string,
@@ -775,24 +790,28 @@
 GString *
 g_string_insert_c (GString *string,
                    gssize   pos,
                    gchar    c)
 {
+  gsize pos_unsigned;
+
   g_return_val_if_fail (string != NULL, NULL);
 
   g_string_maybe_expand (string, 1);
 
   if (pos < 0)
     pos = string->len;
   else
-    g_return_val_if_fail (pos <= string->len, string);
+    g_return_val_if_fail ((gsize) pos <= string->len, string);
+  pos_unsigned = pos;
 
   /* If not just an append, move the old stuff */
-  if (pos < string->len)
-    memmove (string->str + pos + 1, string->str + pos, string->len - pos);
+  if (pos_unsigned < string->len)
+    memmove (string->str + pos_unsigned + 1,
+             string->str + pos_unsigned, string->len - pos_unsigned);
 
-  string->str[pos] = c;
+  string->str[pos_unsigned] = c;
 
   string->len += 1;
 
   string->str[string->len] = 0;
 
@@ -857,14 +876,14 @@
   g_string_maybe_expand (string, charlen);
 
   if (pos < 0)
     pos = string->len;
   else
-    g_return_val_if_fail (pos <= string->len, string);
+    g_return_val_if_fail ((gsize) pos <= string->len, string);
 
   /* If not just an append, move the old stuff */
-  if (pos < string->len)
+  if ((gsize) pos < string->len)
     memmove (string->str + pos + charlen, string->str + pos, string->len - pos);
 
   dest = string->str + pos;
   /* Code copied from g_unichar_to_utf() */
   for (i = charlen - 1; i > 0; --i)
@@ -967,25 +986,32 @@
 GString *
 g_string_erase (GString *string,
                 gssize   pos,
                 gssize   len)
 {
+  gsize len_unsigned, pos_unsigned;
+
   g_return_val_if_fail (string != NULL, NULL);
   g_return_val_if_fail (pos >= 0, string);
-  g_return_val_if_fail (pos <= string->len, string);
+  pos_unsigned = pos;
+
+  g_return_val_if_fail (pos_unsigned <= string->len, string);
 
   if (len < 0)
-    len = string->len - pos;
+    len_unsigned = string->len - pos_unsigned;
   else
     {
-      g_return_val_if_fail (pos + len <= string->len, string);
+      len_unsigned = len;
+      g_return_val_if_fail (pos_unsigned + len_unsigned <= string->len, string);
 
-      if (pos + len < string->len)
-        memmove (string->str + pos, string->str + pos + len, string->len - (pos + len));
+      if (pos_unsigned + len_unsigned < string->len)
+        memmove (string->str + pos_unsigned,
+                 string->str + pos_unsigned + len_unsigned,
+                 string->len - (pos_unsigned + len_unsigned));
     }
 
-  string->len -= len;
+  string->len -= len_unsigned;
 
   string->str[string->len] = 0;
 
   return string;
 }
