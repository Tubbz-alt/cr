<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  * Copyright (C) 2005-2009 Tim-Philipp Müller &lt;tim centricular net&gt;
   4  * Copyright (C) 2009 Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;
   5  *
   6  * gsttypefindfunctions.c: collection of various typefind functions
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #ifdef HAVE_CONFIG_H
  25 #include &quot;config.h&quot;
  26 #endif
  27 
  28 #include &lt;glib.h&gt;
  29 #include &lt;glib/gprintf.h&gt;
  30 
  31 /* don&#39;t want to add gio xdgmime typefinder if gio was disabled via configure */
  32 #ifdef HAVE_GIO
  33 #include &lt;gio/gio.h&gt;
  34 #define USE_GIO
  35 #endif
  36 
  37 #include &lt;gst/gst.h&gt;
  38 
  39 #include &lt;stdio.h&gt;
  40 #include &lt;string.h&gt;
  41 #include &lt;ctype.h&gt;
  42 
  43 #include &lt;gst/pbutils/pbutils.h&gt;
  44 #include &lt;gst/base/gstbytereader.h&gt;
  45 
  46 GST_DEBUG_CATEGORY_STATIC (type_find_debug);
  47 #define GST_CAT_DEFAULT type_find_debug
  48 
  49 /* DataScanCtx: helper for typefind functions that scan through data
  50  * step-by-step, to avoid doing a peek at each and every offset */
  51 
  52 #define DATA_SCAN_CTX_CHUNK_SIZE 4096
  53 
  54 typedef struct
  55 {
  56   guint64 offset;
  57   const guint8 *data;
<a name="1" id="anc1"></a><span class="line-modified">  58   gint size;</span>
  59 } DataScanCtx;
  60 
  61 static inline void
  62 data_scan_ctx_advance (GstTypeFind * tf, DataScanCtx * c, guint bytes_to_skip)
  63 {
  64   c-&gt;offset += bytes_to_skip;
  65   if (G_LIKELY (c-&gt;size &gt; bytes_to_skip)) {
  66     c-&gt;size -= bytes_to_skip;
  67     c-&gt;data += bytes_to_skip;
  68   } else {
  69     c-&gt;data += c-&gt;size;
  70     c-&gt;size = 0;
  71   }
  72 }
  73 
  74 static inline gboolean
<a name="2" id="anc2"></a><span class="line-modified">  75 data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, gint min_len)</span>
  76 {
  77   const guint8 *data;
  78   guint64 len;
  79   guint chunk_len = MAX (DATA_SCAN_CTX_CHUNK_SIZE, min_len);
  80 
  81   if (G_LIKELY (c-&gt;size &gt;= min_len))
  82     return TRUE;
  83 
  84   data = gst_type_find_peek (tf, c-&gt;offset, chunk_len);
  85   if (G_LIKELY (data != NULL)) {
  86     c-&gt;data = data;
  87     c-&gt;size = chunk_len;
  88     return TRUE;
  89   }
  90 
  91   /* if there&#39;s less than our chunk size, try to get as much as we can, but
  92    * always at least min_len bytes (we might be typefinding the first buffer
  93    * of the stream and not have as much data available as we&#39;d like) */
  94   len = gst_type_find_get_length (tf);
  95   if (len &gt; 0) {
  96     len = CLAMP (len - c-&gt;offset, min_len, chunk_len);
  97   } else {
  98     len = min_len;
  99   }
 100 
 101   data = gst_type_find_peek (tf, c-&gt;offset, len);
 102   if (data != NULL) {
 103     c-&gt;data = data;
 104     c-&gt;size = len;
 105     return TRUE;
 106   }
 107 
 108   return FALSE;
 109 }
 110 
 111 static inline gboolean
 112 data_scan_ctx_memcmp (GstTypeFind * tf, DataScanCtx * c, guint offset,
 113     const gchar * data, guint len)
 114 {
<a name="3" id="anc3"></a>


 115   if (!data_scan_ctx_ensure_data (tf, c, offset + len))
 116     return FALSE;
 117 
 118   return (memcmp (c-&gt;data + offset, data, len) == 0);
 119 }
 120 
 121 /*** text/plain ***/
 122 static gboolean xml_check_first_element (GstTypeFind * tf,
 123     const gchar * element, guint elen, gboolean strict);
 124 static gboolean sdp_check_header (GstTypeFind * tf);
 125 
 126 static GstStaticCaps utf8_caps = GST_STATIC_CAPS (&quot;text/plain&quot;);
 127 
 128 #define UTF8_CAPS gst_static_caps_get(&amp;utf8_caps)
 129 
 130 static gboolean
 131 utf8_type_find_have_valid_utf8_at_offset (GstTypeFind * tf, guint64 offset,
 132     GstTypeFindProbability * prob)
 133 {
 134   const guint8 *data;
 135 
 136   /* randomly decided values */
 137   guint min_size = 16;          /* minimum size  */
 138   guint size = 32 * 1024;       /* starting size */
 139   guint probability = 95;       /* starting probability */
 140   guint step = 10;              /* how much we reduce probability in each
 141                                  * iteration */
 142 
 143   while (probability &gt; step &amp;&amp; size &gt; min_size) {
 144     data = gst_type_find_peek (tf, offset, size);
 145     if (data) {
 146       gchar *end;
 147       gchar *start = (gchar *) data;
 148 
 149       if (g_utf8_validate (start, size, (const gchar **) &amp;end) || (end - start + 4 &gt; size)) {   /* allow last char to be cut off */
 150         *prob = probability;
 151         return TRUE;
 152       }
 153       *prob = 0;
 154       return FALSE;
 155     }
 156     size /= 2;
 157     probability -= step;
 158   }
 159   *prob = 0;
 160   return FALSE;
 161 }
 162 
 163 static void
 164 utf8_type_find (GstTypeFind * tf, gpointer unused)
 165 {
 166   GstTypeFindProbability start_prob, mid_prob;
 167   guint64 length;
 168 
 169   /* leave xml to the xml typefinders */
 170   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE))
 171     return;
 172 
 173   /* leave sdp to the sdp typefinders */
 174   if (sdp_check_header (tf))
 175     return;
 176 
 177   /* check beginning of stream */
 178   if (!utf8_type_find_have_valid_utf8_at_offset (tf, 0, &amp;start_prob))
 179     return;
 180 
 181   GST_LOG (&quot;start is plain text with probability of %u&quot;, start_prob);
 182 
 183   /* POSSIBLE is the highest probability we ever return if we can&#39;t
 184    * probe into the middle of the file and don&#39;t know its length */
 185 
 186   length = gst_type_find_get_length (tf);
 187   if (length == 0 || length == (guint64) - 1) {
 188     gst_type_find_suggest (tf, MIN (start_prob, GST_TYPE_FIND_POSSIBLE),
 189         UTF8_CAPS);
 190     return;
 191   }
 192 
 193   if (length &lt; 64 * 1024) {
 194     gst_type_find_suggest (tf, start_prob, UTF8_CAPS);
 195     return;
 196   }
 197 
 198   /* check middle of stream */
 199   if (!utf8_type_find_have_valid_utf8_at_offset (tf, length / 2, &amp;mid_prob))
 200     return;
 201 
 202   GST_LOG (&quot;middle is plain text with probability of %u&quot;, mid_prob);
 203   gst_type_find_suggest (tf, (start_prob + mid_prob) / 2, UTF8_CAPS);
 204 }
 205 
 206 /*** text/utf-16 and text/utf-32} ***/
 207 /* While UTF-8 is unicode too, using text/plain for UTF-16 and UTF-32
 208    is going to break stuff. */
 209 
 210 typedef struct
 211 {
 212   size_t bomlen;
 213   const char *const bom;
 214     gboolean (*checker) (const guint8 *, gint, gint);
 215   int boost;
 216   int endianness;
 217 } GstUnicodeTester;
 218 
 219 static gboolean
 220 check_utf16 (const guint8 * data, gint len, gint endianness)
 221 {
 222   GstByteReader br;
 223   guint16 high, low;
 224 
 225   low = high = 0;
 226 
 227   if (len &amp; 1)
 228     return FALSE;
 229 
 230   gst_byte_reader_init (&amp;br, data, len);
 231   while (len &gt;= 2) {
 232     /* test first for a single 16 bit value in the BMP */
 233     if (endianness == G_BIG_ENDIAN)
 234       high = gst_byte_reader_get_uint16_be_unchecked (&amp;br);
 235     else
 236       high = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
 237     if (high &gt;= 0xD800 &amp;&amp; high &lt;= 0xDBFF) {
 238       /* start of a surrogate pair */
 239       if (len &lt; 4)
 240         return FALSE;
 241       len -= 2;
 242       if (endianness == G_BIG_ENDIAN)
 243         low = gst_byte_reader_get_uint16_be_unchecked (&amp;br);
 244       else
 245         low = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
 246       if (low &gt;= 0xDC00 &amp;&amp; low &lt;= 0xDFFF) {
 247         /* second half of the surrogate pair */
 248       } else
 249         return FALSE;
 250     } else {
 251       if (high &gt;= 0xDC00 &amp;&amp; high &lt;= 0xDFFF)
 252         return FALSE;
 253     }
 254     len -= 2;
 255   }
 256   return TRUE;
 257 }
 258 
 259 static gboolean
 260 check_utf32 (const guint8 * data, gint len, gint endianness)
 261 {
 262   if (len &amp; 3)
 263     return FALSE;
 264   while (len &gt; 3) {
 265     guint32 v;
 266     if (endianness == G_BIG_ENDIAN)
 267       v = GST_READ_UINT32_BE (data);
 268     else
 269       v = GST_READ_UINT32_LE (data);
 270     if (v &gt;= 0x10FFFF)
 271       return FALSE;
 272     data += 4;
 273     len -= 4;
 274   }
 275   return TRUE;
 276 }
 277 
 278 static void
 279 unicode_type_find (GstTypeFind * tf, const GstUnicodeTester * tester,
 280     guint n_tester, const char *media_type, gboolean require_bom)
 281 {
<a name="4" id="anc4"></a><span class="line-modified"> 282   size_t n;</span>
<span class="line-modified"> 283   gint len = 4;</span>
 284   const guint8 *data = gst_type_find_peek (tf, 0, len);
 285   int prob = -1;
 286   const gint max_scan_size = 256 * 1024;
 287   int endianness = 0;
 288 
 289   if (!data) {
 290     len = 2;
 291     data = gst_type_find_peek (tf, 0, len);
 292     if (!data)
 293       return;
 294   }
 295 
 296   /* find a large enough size that works */
 297   while (len &lt; max_scan_size) {
 298     size_t newlen = len &lt;&lt; 1;
 299     const guint8 *newdata = gst_type_find_peek (tf, 0, newlen);
 300     if (!newdata)
 301       break;
 302     len = newlen;
 303     data = newdata;
 304   }
 305 
 306   for (n = 0; n &lt; n_tester; ++n) {
 307     int bom_boost = 0, tmpprob;
 308     if (len &gt;= tester[n].bomlen) {
 309       if (!memcmp (data, tester[n].bom, tester[n].bomlen))
 310         bom_boost = tester[n].boost;
 311     }
 312     if (require_bom &amp;&amp; bom_boost == 0)
 313       continue;
 314     if (!(*tester[n].checker) (data, len, tester[n].endianness))
 315       continue;
 316     tmpprob = GST_TYPE_FIND_POSSIBLE - 20 + bom_boost;
 317     if (tmpprob &gt; prob) {
 318       prob = tmpprob;
 319       endianness = tester[n].endianness;
 320     }
 321   }
 322 
 323   if (prob &gt; 0) {
 324     GST_DEBUG (&quot;This is valid %s %s&quot;, media_type,
 325         endianness == G_BIG_ENDIAN ? &quot;be&quot; : &quot;le&quot;);
 326     gst_type_find_suggest_simple (tf, prob, media_type,
 327         &quot;endianness&quot;, G_TYPE_INT, endianness, NULL);
 328   }
 329 }
 330 
 331 static GstStaticCaps utf16_caps = GST_STATIC_CAPS (&quot;text/utf-16&quot;);
 332 
 333 #define UTF16_CAPS gst_static_caps_get(&amp;utf16_caps)
 334 
 335 static void
 336 utf16_type_find (GstTypeFind * tf, gpointer unused)
 337 {
 338   static const GstUnicodeTester utf16tester[2] = {
 339     {2, &quot;\xff\xfe&quot;, check_utf16, 10, G_LITTLE_ENDIAN},
 340     {2, &quot;\xfe\xff&quot;, check_utf16, 20, G_BIG_ENDIAN},
 341   };
 342   unicode_type_find (tf, utf16tester, G_N_ELEMENTS (utf16tester),
 343       &quot;text/utf-16&quot;, TRUE);
 344 }
 345 
 346 static GstStaticCaps utf32_caps = GST_STATIC_CAPS (&quot;text/utf-32&quot;);
 347 
 348 #define UTF32_CAPS gst_static_caps_get(&amp;utf32_caps)
 349 
 350 static void
 351 utf32_type_find (GstTypeFind * tf, gpointer unused)
 352 {
 353   static const GstUnicodeTester utf32tester[2] = {
 354     {4, &quot;\xff\xfe\x00\x00&quot;, check_utf32, 10, G_LITTLE_ENDIAN},
 355     {4, &quot;\x00\x00\xfe\xff&quot;, check_utf32, 20, G_BIG_ENDIAN}
 356   };
 357   unicode_type_find (tf, utf32tester, G_N_ELEMENTS (utf32tester),
 358       &quot;text/utf-32&quot;, TRUE);
 359 }
 360 
 361 /*** text/uri-list ***/
 362 
 363 static GstStaticCaps uri_caps = GST_STATIC_CAPS (&quot;text/uri-list&quot;);
 364 
 365 #define URI_CAPS (gst_static_caps_get(&amp;uri_caps))
 366 #define BUFFER_SIZE 16          /* If the string is &lt; 16 bytes we&#39;re screwed */
 367 #define INC_BUFFER {                                                    \
 368   pos++;                                                                \
 369   if (pos == BUFFER_SIZE) {                                             \
 370     pos = 0;                                                            \
 371     offset += BUFFER_SIZE;                                              \
 372     data = gst_type_find_peek (tf, offset, BUFFER_SIZE);                \
 373     if (data == NULL) return;                                           \
 374   } else {                                                              \
 375     data++;                                                             \
 376   }                                                                     \
 377 }
 378 static void
 379 uri_type_find (GstTypeFind * tf, gpointer unused)
 380 {
 381   const guint8 *data = gst_type_find_peek (tf, 0, BUFFER_SIZE);
 382   guint pos = 0;
 383   guint offset = 0;
 384 
 385   if (data) {
 386     /* Search for # comment lines */
 387     while (*data == &#39;#&#39;) {
 388       /* Goto end of line */
 389       while (*data != &#39;\n&#39;) {
 390         INC_BUFFER;
 391       }
 392 
 393       INC_BUFFER;
 394     }
 395 
 396     if (!g_ascii_isalpha (*data)) {
 397       /* Had a non alpha char - can&#39;t be uri-list */
 398       return;
 399     }
 400 
 401     INC_BUFFER;
 402 
 403     while (g_ascii_isalnum (*data)) {
 404       INC_BUFFER;
 405     }
 406 
 407     if (*data != &#39;:&#39;) {
 408       /* First non alpha char is not a : */
 409       return;
 410     }
 411 
 412     /* Get the next 2 bytes as well */
 413     data = gst_type_find_peek (tf, offset + pos, 3);
 414     if (data == NULL)
 415       return;
 416 
 417     if (data[1] != &#39;/&#39; &amp;&amp; data[2] != &#39;/&#39;) {
 418       return;
 419     }
 420 
 421     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, URI_CAPS);
 422   }
 423 }
 424 
 425 /*** application/itc ***/
 426 static GstStaticCaps itc_caps = GST_STATIC_CAPS (&quot;application/itc&quot;);
 427 #define ITC_CAPS (gst_static_caps_get(&amp;itc_caps))
 428 
 429 static void
 430 itc_type_find (GstTypeFind * tf, gpointer unused)
 431 {
 432   DataScanCtx c = { 0, NULL, 0 };
 433   guint8 magic[8] = { 0x00, 0x00, 0x01, 0x1C, 0x69, 0x74, 0x63, 0x68 };
 434   guint8 preamble[4] = { 0x00, 0x00, 0x00, 0x02 };
 435   guint8 artwork_marker[8] = { 0x00, 0x00, 0x00, 0x00, 0x61, 0x72, 0x74, 0x77 };
 436   guint8 item_marker[4] = { 0x69, 0x74, 0x65, 0x6D };
 437   GstTypeFindProbability itc_prob = GST_TYPE_FIND_NONE;
 438   int i;
 439 
 440   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 441     return;
 442 
 443   if (memcmp (c.data, magic, 8))
 444     return;
 445 
 446   /* At least we found the right magic */
 447   itc_prob = GST_TYPE_FIND_MINIMUM;
 448   data_scan_ctx_advance (tf, &amp;c, 8);
 449 
 450   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 12)))
 451     goto done;
 452 
 453   /* Check preamble 3 consecutive times */
 454   for (i = 0; i &lt; 3; i++) {
 455     if (memcmp (c.data, preamble, 4))
 456       goto done;
 457     data_scan_ctx_advance (tf, &amp;c, 4);
 458   }
 459 
 460   itc_prob = GST_TYPE_FIND_POSSIBLE;
 461 
 462   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 463     goto done;
 464 
 465   if (memcmp (c.data, artwork_marker, 8))
 466     goto done;
 467 
 468   itc_prob = GST_TYPE_FIND_LIKELY;
 469   data_scan_ctx_advance (tf, &amp;c, 8);
 470 
 471   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 256)))
 472     goto done;
 473 
 474   /* ...and 256 0x00 padding bytes on what looks like the header&#39;s end */
 475   for (i = 0; i &lt; 256; i++) {
 476     if (c.data[i])
 477       goto done;
 478   }
 479 
 480   itc_prob = GST_TYPE_FIND_NEARLY_CERTAIN;
 481   data_scan_ctx_advance (tf, &amp;c, 256);
 482 
 483   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 8)))
 484     goto done;
 485 
 486   if (memcmp (c.data + 4, item_marker, 4))
 487     goto done;
 488 
 489   itc_prob = GST_TYPE_FIND_MAXIMUM;
 490 
 491 done:
 492   gst_type_find_suggest (tf, itc_prob, ITC_CAPS);
 493 }
 494 
 495 /*** application/x-hls ***/
 496 
 497 static GstStaticCaps hls_caps = GST_STATIC_CAPS (&quot;application/x-hls&quot;);
 498 #define HLS_CAPS (gst_static_caps_get(&amp;hls_caps))
 499 
 500 /* See http://tools.ietf.org/html/draft-pantos-http-live-streaming-05 */
 501 static void
 502 hls_type_find (GstTypeFind * tf, gpointer unused)
 503 {
 504   DataScanCtx c = { 0, NULL, 0 };
 505 
 506   /* Minimum useful size is #EXTM3U\n + 1 tag + &#39;:&#39; = 30 bytes */
 507   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 30)))
 508     return;
 509 
 510   if (memcmp (c.data, &quot;#EXTM3U&quot;, 7))
 511     return;
 512 
 513   data_scan_ctx_advance (tf, &amp;c, 7);
 514 
 515   /* Check only the first 4KB */
 516   while (c.offset &lt; 4096) {
 517     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 21)))
 518       return;
 519 
 520     /* Search for # comment lines */
 521     if (c.data[0] == &#39;#&#39; &amp;&amp; (memcmp (c.data, &quot;#EXT-X-TARGETDURATION&quot;, 21) == 0
 522             || memcmp (c.data, &quot;#EXT-X-STREAM-INF&quot;, 17) == 0
 523             || memcmp (c.data, &quot;#EXT-X-MEDIA&quot;, 12) == 0)) {
 524       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HLS_CAPS);
 525       return;
 526     }
 527 
 528     data_scan_ctx_advance (tf, &amp;c, 1);
 529   }
 530 }
 531 
 532 
 533 /*** application/xml **********************************************************/
 534 
 535 #define XML_BUFFER_SIZE 16
 536 #define XML_INC_BUFFER {                                                \
 537   pos++;                                                                \
 538   if (pos == XML_BUFFER_SIZE) {                                         \
 539     pos = 0;                                                            \
 540     offset += XML_BUFFER_SIZE;                                          \
 541     data = gst_type_find_peek (tf, offset, XML_BUFFER_SIZE);            \
 542     if (data == NULL) return FALSE;                                     \
 543   } else {                                                              \
 544     data++;                                                             \
 545   }                                                                     \
 546 }
 547 
 548 #define XML_INC_BUFFER_DATA {                                           \
 549   pos++;                                                                \
 550   if (pos &gt;= length) {                                                  \
 551     return FALSE;                                                       \
 552   } else {                                                              \
 553     data++;                                                             \
 554   }                                                                     \
 555 }
 556 
 557 static gboolean
 558 xml_check_first_element_from_data (const guint8 * data, guint length,
 559     const gchar * element, guint elen, gboolean strict)
 560 {
 561   gboolean got_xmldec;
 562   guint pos = 0;
 563 
 564   g_return_val_if_fail (data != NULL, FALSE);
 565 
 566   if (length &lt;= 5)
 567     return FALSE;
 568 
 569   /* look for the XMLDec
 570    * see XML spec 2.8, Prolog and Document Type Declaration
 571    * http://www.w3.org/TR/2004/REC-xml-20040204/#sec-prolog-dtd */
 572   got_xmldec = (memcmp (data, &quot;&lt;?xml&quot;, 5) == 0);
 573 
 574   if (strict &amp;&amp; !got_xmldec)
 575     return FALSE;
 576 
 577   /* skip XMLDec in any case if we&#39;ve got one */
 578   if (got_xmldec) {
 579     pos += 5;
 580     data += 5;
 581   }
 582 
 583   /* look for the first element, it has to be the requested element. Bail
 584    * out if it is not within the first 4kB. */
 585   while (pos &lt; MIN (4096, length)) {
 586     while (*data != &#39;&lt;&#39; &amp;&amp; pos &lt; MIN (4096, length)) {
 587       XML_INC_BUFFER_DATA;
 588     }
 589 
 590     XML_INC_BUFFER_DATA;
 591     if (!g_ascii_isalpha (*data)) {
 592       /* if not alphabetic, it&#39;s a PI or an element / attribute declaration
 593        * like &lt;?xxx or &lt;!xxx */
 594       XML_INC_BUFFER_DATA;
 595       continue;
 596     }
 597 
 598     /* the first normal element, check if it&#39;s the one asked for */
 599     if (pos + elen + 1 &gt;= length)
 600       return FALSE;
 601     return (element &amp;&amp; strncmp ((const char *) data, element, elen) == 0);
 602   }
 603 
 604   return FALSE;
 605 }
 606 
 607 static gboolean
 608 xml_check_first_element (GstTypeFind * tf, const gchar * element, guint elen,
 609     gboolean strict)
 610 {
 611   gboolean got_xmldec;
 612   const guint8 *data;
 613   guint offset = 0;
 614   guint pos = 0;
 615 
 616   data = gst_type_find_peek (tf, 0, XML_BUFFER_SIZE);
 617   if (!data)
 618     return FALSE;
 619 
 620   /* look for the XMLDec
 621    * see XML spec 2.8, Prolog and Document Type Declaration
 622    * http://www.w3.org/TR/2004/REC-xml-20040204/#sec-prolog-dtd */
 623   got_xmldec = (memcmp (data, &quot;&lt;?xml&quot;, 5) == 0);
 624 
 625   if (strict &amp;&amp; !got_xmldec)
 626     return FALSE;
 627 
 628   /* skip XMLDec in any case if we&#39;ve got one */
 629   if (got_xmldec) {
 630     pos += 5;
 631     data += 5;
 632   }
 633 
 634   /* look for the first element, it has to be the requested element. Bail
 635    * out if it is not within the first 4kB. */
 636   while (data &amp;&amp; (offset + pos) &lt; 4096) {
 637     while (*data != &#39;&lt;&#39; &amp;&amp; (offset + pos) &lt; 4096) {
 638       XML_INC_BUFFER;
 639     }
 640 
 641     XML_INC_BUFFER;
 642     if (!g_ascii_isalpha (*data)) {
 643       /* if not alphabetic, it&#39;s a PI or an element / attribute declaration
 644        * like &lt;?xxx or &lt;!xxx */
 645       XML_INC_BUFFER;
 646       continue;
 647     }
 648 
 649     /* the first normal element, check if it&#39;s the one asked for */
 650     data = gst_type_find_peek (tf, offset + pos, elen + 1);
 651     return (data &amp;&amp; element &amp;&amp; strncmp ((char *) data, element, elen) == 0);
 652   }
 653 
 654   return FALSE;
 655 }
 656 
 657 static GstStaticCaps generic_xml_caps = GST_STATIC_CAPS (&quot;application/xml&quot;);
 658 
 659 #define GENERIC_XML_CAPS (gst_static_caps_get(&amp;generic_xml_caps))
 660 static void
 661 xml_type_find (GstTypeFind * tf, gpointer unused)
 662 {
 663   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE)) {
 664     gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, GENERIC_XML_CAPS);
 665   }
 666 }
 667 
 668 /*** application/dash+xml ****************************************************/
 669 
 670 static GstStaticCaps dash_caps = GST_STATIC_CAPS (&quot;application/dash+xml&quot;);
 671 
 672 #define DASH_CAPS gst_static_caps_get (&amp;dash_caps)
 673 
 674 static void
 675 dash_mpd_type_find (GstTypeFind * tf, gpointer unused)
 676 {
 677   if (xml_check_first_element (tf, &quot;MPD&quot;, 3, FALSE) ||
 678       xml_check_first_element (tf, &quot;mpd&quot;, 3, FALSE)) {
 679     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DASH_CAPS);
 680   }
 681 }
 682 
<a name="5" id="anc5"></a>














 683 /*** application/sdp *********************************************************/
 684 
 685 static GstStaticCaps sdp_caps = GST_STATIC_CAPS (&quot;application/sdp&quot;);
 686 
 687 #define SDP_CAPS (gst_static_caps_get(&amp;sdp_caps))
 688 static gboolean
 689 sdp_check_header (GstTypeFind * tf)
 690 {
 691   const guint8 *data;
 692 
 693   data = gst_type_find_peek (tf, 0, 5);
 694   if (!data)
 695     return FALSE;
 696 
 697   /* sdp must start with v=0[\r]\n */
 698   if (memcmp (data, &quot;v=0&quot;, 3))
 699     return FALSE;
 700 
 701   if (data[3] == &#39;\r&#39; &amp;&amp; data[4] == &#39;\n&#39;)
 702     return TRUE;
 703   if (data[3] == &#39;\n&#39;)
 704     return TRUE;
 705 
 706   return FALSE;
 707 }
 708 
 709 static void
 710 sdp_type_find (GstTypeFind * tf, gpointer unused)
 711 {
 712   if (sdp_check_header (tf))
 713     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SDP_CAPS);
 714 }
 715 
 716 /*** application/smil *********************************************************/
 717 
 718 static GstStaticCaps smil_caps = GST_STATIC_CAPS (&quot;application/smil&quot;);
 719 
 720 #define SMIL_CAPS (gst_static_caps_get(&amp;smil_caps))
 721 static void
 722 smil_type_find (GstTypeFind * tf, gpointer unused)
 723 {
 724   if (xml_check_first_element (tf, &quot;smil&quot;, 4, FALSE)) {
 725     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SMIL_CAPS);
 726   }
 727 }
 728 
 729 /*** application/ttml+xml *****************************************************/
 730 
 731 static GstStaticCaps ttml_xml_caps = GST_STATIC_CAPS (&quot;application/ttml+xml&quot;);
 732 
 733 #define TTML_XML_CAPS (gst_static_caps_get(&amp;ttml_xml_caps))
 734 static void
 735 ttml_xml_type_find (GstTypeFind * tf, gpointer unused)
 736 {
 737   if (xml_check_first_element (tf, &quot;tt&quot;, 2, FALSE)) {
 738     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TTML_XML_CAPS);
 739   }
 740 }
 741 
 742 /*** text/html ***/
 743 
 744 static GstStaticCaps html_caps = GST_STATIC_CAPS (&quot;text/html&quot;);
 745 
 746 #define HTML_CAPS gst_static_caps_get (&amp;html_caps)
 747 
 748 static void
 749 html_type_find (GstTypeFind * tf, gpointer unused)
 750 {
 751   const gchar *d, *data;
 752 
 753   data = (const gchar *) gst_type_find_peek (tf, 0, 16);
 754   if (!data)
 755     return;
 756 
 757   if (!g_ascii_strncasecmp (data, &quot;&lt;!DOCTYPE HTML&quot;, 14)) {
 758     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 759   } else if (xml_check_first_element (tf, &quot;html&quot;, 4, FALSE)) {
 760     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 761   } else if ((d = memchr (data, &#39;&lt;&#39;, 16))) {
 762     data = (const gchar *) gst_type_find_peek (tf, d - data, 6);
 763     if (data &amp;&amp; g_ascii_strncasecmp (data, &quot;&lt;html&gt;&quot;, 6) == 0) {
 764       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, HTML_CAPS);
 765     }
 766   }
 767 }
 768 
 769 /*** audio/midi ***/
 770 
 771 static GstStaticCaps mid_caps = GST_STATIC_CAPS (&quot;audio/midi&quot;);
 772 
 773 #define MID_CAPS gst_static_caps_get(&amp;mid_caps)
 774 static void
 775 mid_type_find (GstTypeFind * tf, gpointer unused)
 776 {
 777   const guint8 *data = gst_type_find_peek (tf, 0, 4);
 778 
 779   /* http://jedi.ks.uiuc.edu/~johns/links/music/midifile.html */
 780   if (data &amp;&amp; data[0] == &#39;M&#39; &amp;&amp; data[1] == &#39;T&#39; &amp;&amp; data[2] == &#39;h&#39;
 781       &amp;&amp; data[3] == &#39;d&#39;)
 782     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MID_CAPS);
 783 }
 784 
 785 /*** audio/mobile-xmf ***/
 786 
 787 static GstStaticCaps mxmf_caps = GST_STATIC_CAPS (&quot;audio/mobile-xmf&quot;);
 788 
 789 #define MXMF_CAPS gst_static_caps_get(&amp;mxmf_caps)
 790 static void
 791 mxmf_type_find (GstTypeFind * tf, gpointer unused)
 792 {
 793   const guint8 *data = NULL;
 794 
 795   /* Search FileId &quot;XMF_&quot; 4 bytes */
 796   data = gst_type_find_peek (tf, 0, 4);
 797   if (data &amp;&amp; data[0] == &#39;X&#39; &amp;&amp; data[1] == &#39;M&#39; &amp;&amp; data[2] == &#39;F&#39;
 798       &amp;&amp; data[3] == &#39;_&#39;) {
 799     /* Search Format version &quot;2.00&quot; 4 bytes */
 800     data = gst_type_find_peek (tf, 4, 4);
 801     if (data &amp;&amp; data[0] == &#39;2&#39; &amp;&amp; data[1] == &#39;.&#39; &amp;&amp; data[2] == &#39;0&#39;
 802         &amp;&amp; data[3] == &#39;0&#39;) {
 803       /* Search TypeId 2     1 byte */
 804       data = gst_type_find_peek (tf, 11, 1);
 805       if (data &amp;&amp; data[0] == 2) {
 806         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MXMF_CAPS);
 807       }
 808     }
 809   }
 810 }
 811 
 812 
 813 /*** video/x-fli ***/
 814 
 815 static GstStaticCaps flx_caps = GST_STATIC_CAPS (&quot;video/x-fli&quot;);
 816 
 817 #define FLX_CAPS gst_static_caps_get(&amp;flx_caps)
 818 static void
 819 flx_type_find (GstTypeFind * tf, gpointer unused)
 820 {
 821   const guint8 *data = gst_type_find_peek (tf, 0, 134);
 822 
 823   if (data) {
 824     /* check magic and the frame type of the first frame */
 825     if ((data[4] == 0x11 || data[4] == 0x12 ||
 826             data[4] == 0x30 || data[4] == 0x44) &amp;&amp;
 827         data[5] == 0xaf &amp;&amp;
 828         ((data[132] == 0x00 || data[132] == 0xfa) &amp;&amp; data[133] == 0xf1)) {
 829       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLX_CAPS);
 830     }
 831     return;
 832   }
 833   data = gst_type_find_peek (tf, 0, 6);
 834   if (data) {
 835     /* check magic only */
 836     if ((data[4] == 0x11 || data[4] == 0x12 ||
 837             data[4] == 0x30 || data[4] == 0x44) &amp;&amp; data[5] == 0xaf) {
 838       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, FLX_CAPS);
 839     }
 840     return;
 841   }
 842 }
 843 
 844 /*** application/x-id3 ***/
 845 
 846 static GstStaticCaps id3_caps = GST_STATIC_CAPS (&quot;application/x-id3&quot;);
 847 
 848 #define ID3_CAPS gst_static_caps_get(&amp;id3_caps)
 849 static void
 850 id3v2_type_find (GstTypeFind * tf, gpointer unused)
 851 {
 852   const guint8 *data = gst_type_find_peek (tf, 0, 10);
 853 
 854   if (data &amp;&amp; memcmp (data, &quot;ID3&quot;, 3) == 0 &amp;&amp;
 855       data[3] != 0xFF &amp;&amp; data[4] != 0xFF &amp;&amp;
 856       (data[6] &amp; 0x80) == 0 &amp;&amp; (data[7] &amp; 0x80) == 0 &amp;&amp;
 857       (data[8] &amp; 0x80) == 0 &amp;&amp; (data[9] &amp; 0x80) == 0) {
 858     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, ID3_CAPS);
 859   }
 860 }
 861 
 862 static void
 863 id3v1_type_find (GstTypeFind * tf, gpointer unused)
 864 {
 865   const guint8 *data = gst_type_find_peek (tf, -128, 3);
 866 
 867   if (data &amp;&amp; memcmp (data, &quot;TAG&quot;, 3) == 0) {
 868     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, ID3_CAPS);
 869   }
 870 }
 871 
 872 /*** application/x-ape ***/
 873 
 874 static GstStaticCaps apetag_caps = GST_STATIC_CAPS (&quot;application/x-apetag&quot;);
 875 
 876 #define APETAG_CAPS gst_static_caps_get(&amp;apetag_caps)
 877 static void
 878 apetag_type_find (GstTypeFind * tf, gpointer unused)
 879 {
 880   const guint8 *data;
 881 
 882   /* APEv1/2 at start of file */
 883   data = gst_type_find_peek (tf, 0, 8);
 884   if (data &amp;&amp; !memcmp (data, &quot;APETAGEX&quot;, 8)) {
 885     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, APETAG_CAPS);
 886     return;
 887   }
 888 
 889   /* APEv1/2 at end of file */
 890   data = gst_type_find_peek (tf, -32, 8);
 891   if (data &amp;&amp; !memcmp (data, &quot;APETAGEX&quot;, 8)) {
 892     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, APETAG_CAPS);
 893     return;
 894   }
 895 }
 896 
 897 /*** audio/x-ttafile ***/
 898 
 899 static GstStaticCaps tta_caps = GST_STATIC_CAPS (&quot;audio/x-ttafile&quot;);
 900 
 901 #define TTA_CAPS gst_static_caps_get(&amp;tta_caps)
 902 static void
 903 tta_type_find (GstTypeFind * tf, gpointer unused)
 904 {
 905   const guint8 *data = gst_type_find_peek (tf, 0, 3);
 906 
 907   if (data) {
 908     if (memcmp (data, &quot;TTA&quot;, 3) == 0) {
 909       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TTA_CAPS);
 910       return;
 911     }
 912   }
 913 }
 914 
 915 /*** audio/x-flac ***/
 916 static GstStaticCaps flac_caps = GST_STATIC_CAPS (&quot;audio/x-flac&quot;);
 917 
 918 #define FLAC_CAPS (gst_static_caps_get(&amp;flac_caps))
 919 
 920 static void
 921 flac_type_find (GstTypeFind * tf, gpointer unused)
 922 {
 923   DataScanCtx c = { 0, NULL, 0 };
 924 
 925   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
 926     return;
 927 
 928   /* standard flac (also old/broken flac-in-ogg with an initial 4-byte marker
 929    * packet and without the usual packet framing) */
 930   if (memcmp (c.data, &quot;fLaC&quot;, 4) == 0) {
 931     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLAC_CAPS);
 932     return;
 933   }
 934 
 935   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
 936     return;
 937 
 938   /* flac-in-ogg, see http://flac.sourceforge.net/ogg_mapping.html */
 939   if (memcmp (c.data, &quot;\177FLAC\001&quot;, 6) == 0) {
 940     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, FLAC_CAPS);
 941     return;
 942   }
 943 
 944 /* disabled because it happily typefinds /dev/urandom as audio/x-flac, and
 945  * because I yet have to see header-less flac in the wild */
 946 #if 0
 947   /* flac without headers (subset format) */
 948   /* 64K should be enough */
 949   while (c.offset &lt; (64 * 1024)) {
 950     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
 951       break;
 952 
 953     /* look for frame header,
 954      * http://flac.sourceforge.net/format.html#frame_header
 955      */
 956     if (c.data[0] == 0xff &amp;&amp; (c.data[1] &gt;&gt; 2) == 0x3e) {
 957       /* bit 15 in the header must be 0 */
 958       if (((c.data[1] &gt;&gt; 1) &amp; 0x01) == 0x01)
 959         goto advance;
 960 
 961       /* blocksize must be != 0x00 */
 962       if ((c.data[2] &gt;&gt; 4) == 0x00)
 963         goto advance;
 964 
 965       /* samplerate must be != 0x0f */
 966       if ((c.data[2] &amp; 0x0f) == 0x0f)
 967         goto advance;
 968       /* also 0 is invalid, as it means get the info from the header and we
 969        * don&#39;t have headers if we are here */
 970       if ((c.data[2] &amp; 0x0f) == 0x00)
 971         goto advance;
 972 
 973       /* channel assignment must be &lt; 11 */
 974       if ((c.data[3] &gt;&gt; 4) &gt;= 11)
 975         goto advance;
 976 
 977       /* sample size must be != 0x07 and != 0x05 */
 978       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x07)
 979         goto advance;
 980       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x05)
 981         goto advance;
 982       /* also 0 is invalid, as it means get the info from the header and we
 983        * don&#39;t have headers if we are here */
 984       if (((c.data[3] &gt;&gt; 1) &amp; 0x07) == 0x00)
 985         goto advance;
 986 
 987       /* next bit must be 0 */
 988       if ((c.data[3] &amp; 0x01) == 0x01)
 989         goto advance;
 990 
 991       /* FIXME: shouldn&#39;t we include the crc check ? */
 992 
 993       GST_DEBUG (&quot;Found flac without headers at %d&quot;, (gint) c.offset);
 994       gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, FLAC_CAPS);
 995       return;
 996     }
 997   advance:
 998     data_scan_ctx_advance (tf, &amp;c, 1);
 999   }
1000 #endif
1001 }
1002 
1003 /* TODO: we could probably make a generic function for this.. */
1004 static gint
1005 aac_type_find_scan_loas_frames_ep (GstTypeFind * tf, DataScanCtx * scan_ctx,
1006     gint max_frames)
1007 {
1008   DataScanCtx c = *scan_ctx;
1009   guint16 snc;
1010   guint len;
1011   gint count = 0;
1012 
1013   do {
1014     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
1015       break;
1016 
1017     /* EPAudioSyncStream */
1018     len = ((c.data[2] &amp; 0x0f) &lt;&lt; 9) | (c.data[3] &lt;&lt; 1) |
1019         ((c.data[4] &amp; 0x80) &gt;&gt; 7);
1020 
1021     if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 2)) {
1022       GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1023       break;
1024     }
1025 
1026     /* check length of frame  */
1027     snc = GST_READ_UINT16_BE (c.data + len);
1028     if (snc != 0x4de1) {
1029       GST_DEBUG (&quot;No sync found at 0x%&quot; G_GINT64_MODIFIER &quot;x&quot;, c.offset + len);
1030       break;
1031     }
1032 
1033     ++count;
1034 
1035     GST_DEBUG (&quot;Found LOAS syncword #%d at offset 0x%&quot; G_GINT64_MODIFIER &quot;x, &quot;
1036         &quot;framelen %u&quot;, count, c.offset, len);
1037 
1038     data_scan_ctx_advance (tf, &amp;c, len);
1039   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1040 
1041   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1042   return count;
1043 }
1044 
1045 static gint
1046 aac_type_find_scan_loas_frames (GstTypeFind * tf, DataScanCtx * scan_ctx,
1047     gint max_frames)
1048 {
1049   DataScanCtx c = *scan_ctx;
1050   guint16 snc;
1051   guint len;
1052   gint count = 0;
1053 
1054   do {
1055     if (!data_scan_ctx_ensure_data (tf, &amp;c, 3))
1056       break;
1057 
1058     /* AudioSyncStream */
1059     len = ((c.data[1] &amp; 0x1f) &lt;&lt; 8) | c.data[2];
1060     /* add size of sync stream header */
1061     len += 3;
1062 
1063     if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 2)) {
1064       GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1065       break;
1066     }
1067 
1068     /* check length of frame  */
1069     snc = GST_READ_UINT16_BE (c.data + len);
1070     if ((snc &amp; 0xffe0) != 0x56e0) {
1071       GST_DEBUG (&quot;No sync found at 0x%&quot; G_GINT64_MODIFIER &quot;x&quot;, c.offset + len);
1072       break;
1073     }
1074 
1075     ++count;
1076 
1077     GST_DEBUG (&quot;Found LOAS syncword #%d at offset 0x%&quot; G_GINT64_MODIFIER &quot;x, &quot;
1078         &quot;framelen %u&quot;, count, c.offset, len);
1079 
1080     data_scan_ctx_advance (tf, &amp;c, len);
1081   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1082 
1083   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1084   return count;
1085 }
1086 
1087 /*** audio/mpeg version 2, 4 ***/
1088 
1089 static GstStaticCaps aac_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1090     &quot;mpegversion = (int) { 2, 4 }, framed = (bool) false&quot;);
1091 #define AAC_CAPS (gst_static_caps_get(&amp;aac_caps))
1092 #define AAC_AMOUNT (4096)
1093 static void
1094 aac_type_find (GstTypeFind * tf, gpointer unused)
1095 {
1096   DataScanCtx c = { 0, NULL, 0 };
1097   GstTypeFindProbability best_probability = GST_TYPE_FIND_NONE;
1098   GstCaps *best_caps = NULL;
<a name="6" id="anc6"></a><span class="line-modified">1099   guint best_count = 0;</span>
1100 
1101   while (c.offset &lt; AAC_AMOUNT) {
1102     guint snc, len, offset, i;
1103 
1104     /* detect adts header or adif header.
1105      * The ADIF header is 4 bytes, that should be OK. The ADTS header, on
1106      * the other hand, is 14 bits only, so we require one valid frame with
1107      * again a valid syncpoint on the next one (28 bits) for certainty. We
1108      * require 4 kB, which is quite a lot, since frames are generally 200-400
1109      * bytes.
1110      * LOAS has 2 possible syncwords, which are 11 bits and 16 bits long.
1111      * The following stream syntax depends on which one is found.
1112      */
1113     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1114       break;
1115 
1116     snc = GST_READ_UINT16_BE (c.data);
1117     if (G_UNLIKELY ((snc &amp; 0xfff6) == 0xfff0)) {
1118       /* ADTS header - find frame length */
1119       GST_DEBUG (&quot;Found one ADTS syncpoint at offset 0x%&quot; G_GINT64_MODIFIER
1120           &quot;x, tracing next...&quot;, c.offset);
1121       len = ((c.data[3] &amp; 0x03) &lt;&lt; 11) |
1122           (c.data[4] &lt;&lt; 3) | ((c.data[5] &amp; 0xe0) &gt;&gt; 5);
1123 
1124       if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, len + 6)) {
1125         GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
1126         goto next;
1127       }
1128 
1129       offset = len;
1130       /* check if there&#39;s a second ADTS frame */
1131       snc = GST_READ_UINT16_BE (c.data + offset);
1132       if ((snc &amp; 0xfff6) == 0xfff0) {
1133         GstCaps *caps;
1134         guint mpegversion, sample_freq_idx, channel_config, profile_idx, rate;
1135         guint8 audio_config[2];
1136 
1137         mpegversion = (c.data[1] &amp; 0x08) ? 2 : 4;
1138         profile_idx = c.data[2] &gt;&gt; 6;
1139         sample_freq_idx = ((c.data[2] &amp; 0x3c) &gt;&gt; 2);
1140         channel_config = ((c.data[2] &amp; 0x01) &lt;&lt; 2) + (c.data[3] &gt;&gt; 6);
1141 
1142         GST_DEBUG (&quot;Found second ADTS-%d syncpoint at offset 0x%&quot;
1143             G_GINT64_MODIFIER &quot;x, framelen %u&quot;, mpegversion, c.offset, len);
1144 
1145         /* 0xd and 0xe are reserved. 0xf means the sample frequency is directly
1146          * specified in the header, but that&#39;s not allowed for ADTS */
1147         if (sample_freq_idx &gt; 0xc) {
1148           GST_DEBUG (&quot;Unexpected sample frequency index %d or wrong sync&quot;,
1149               sample_freq_idx);
1150           goto next;
1151         }
1152 
1153         rate = gst_codec_utils_aac_get_sample_rate_from_index (sample_freq_idx);
1154         GST_LOG (&quot;ADTS: profile=%u, rate=%u&quot;, profile_idx, rate);
1155 
1156         /* The ADTS frame header is slightly different from the
1157          * AudioSpecificConfig defined for the MPEG-4 container, so we just
1158          * construct enough of it for getting the level here. */
1159         /* ADTS counts profiles from 0 instead of 1 to save bits */
1160         audio_config[0] = (profile_idx + 1) &lt;&lt; 3;
1161         audio_config[0] |= (sample_freq_idx &gt;&gt; 1) &amp; 0x7;
1162         audio_config[1] = (sample_freq_idx &amp; 0x1) &lt;&lt; 7;
1163         audio_config[1] |= (channel_config &amp; 0xf) &lt;&lt; 3;
1164 
1165         caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1166             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1167             &quot;mpegversion&quot;, G_TYPE_INT, mpegversion,
1168             &quot;stream-format&quot;, G_TYPE_STRING, &quot;adts&quot;, NULL);
1169 
1170         gst_codec_utils_aac_caps_set_level_and_profile (caps, audio_config, 2);
1171 
1172         /* add rate and number of channels if we can */
1173         if (channel_config != 0 &amp;&amp; channel_config &lt;= 7) {
1174           const guint channels_map[] = { 0, 1, 2, 3, 4, 5, 6, 8 };
1175 
1176           gst_caps_set_simple (caps, &quot;channels&quot;, G_TYPE_INT,
1177               channels_map[channel_config], &quot;rate&quot;, G_TYPE_INT, rate, NULL);
1178         }
1179 
1180         /* length of the second ADTS frame */
1181         len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1182             (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1183 
1184         if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1185           GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
<a name="7" id="anc7"></a><span class="line-modified">1186         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
1187         } else {
1188           offset += len;
1189           /* find more aac sync to select correctly */
1190           /* check if there&#39;s a third/fourth/fifth/sixth ADTS frame, if there is a sixth frame, set probability to maximum:100% */
1191           for (i = 3; i &lt;= 6; i++) {
1192             len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1193                 (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1194             if (len == 0
1195                 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1196               GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;,
1197                   len);
1198               break;
1199             }
1200             snc = GST_READ_UINT16_BE (c.data + offset);
1201             if ((snc &amp; 0xfff6) == 0xfff0) {
1202               GST_DEBUG (&quot;Find %und Sync..probability is %u &quot;, i,
1203                   GST_TYPE_FIND_LIKELY + 5 * (i - 2));
1204               offset += len;
1205             } else {
1206               break;
1207             }
1208           }
1209           gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY + 5 * (i - 3), caps);
1210 
1211         }
1212         gst_caps_unref (caps);
1213         break;
1214       }
1215 
1216       GST_DEBUG (&quot;No next frame found... (should have been at 0x%x)&quot;, len);
1217     } else if (G_UNLIKELY ((snc &amp; 0xffe0) == 0x56e0 || snc == 0x4de1)) {
1218       gint count;
1219 
1220       /* LOAS frame */
1221       GST_INFO (&quot;Possible LOAS syncword at offset 0x%&quot; G_GINT64_MODIFIER
1222           &quot;x, scanning for more frames...&quot;, c.offset);
1223 
1224       if (snc == 0x4de1)
1225         count = aac_type_find_scan_loas_frames_ep (tf, &amp;c, 20);
1226       else
1227         count = aac_type_find_scan_loas_frames (tf, &amp;c, 20);
1228 
1229       if (count &gt;= 3 &amp;&amp; count &gt; best_count) {
1230         gst_caps_replace (&amp;best_caps, NULL);
1231         best_caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1232             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1233             &quot;mpegversion&quot;, G_TYPE_INT, 4,
1234             &quot;stream-format&quot;, G_TYPE_STRING, &quot;loas&quot;, NULL);
1235         best_count = count;
1236         best_probability = GST_TYPE_FIND_POSSIBLE - 10 + count * 3;
1237         if (best_probability &gt;= GST_TYPE_FIND_LIKELY)
<a name="8" id="anc8"></a><span class="line-modified">1238         break;</span>
1239       }
1240     } else if (!memcmp (c.data, &quot;ADIF&quot;, 4)) {
1241       /* ADIF header */
1242       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, &quot;audio/mpeg&quot;,
1243           &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, &quot;mpegversion&quot;, G_TYPE_INT, 4,
1244           &quot;stream-format&quot;, G_TYPE_STRING, &quot;adif&quot;, NULL);
1245       break;
1246     }
1247 
1248   next:
1249 
1250     data_scan_ctx_advance (tf, &amp;c, 1);
1251   }
1252 
1253   if (best_probability &gt; GST_TYPE_FIND_NONE) {
1254     gst_type_find_suggest (tf, best_probability, best_caps);
1255     gst_caps_unref (best_caps);
1256   }
1257 }
1258 
1259 /*** audio/mpeg version 1 ***/
1260 
1261 /*
1262  * The chance that random data is identified as a valid mp3 header is 63 / 2^18
1263  * (0.024%) per try. This makes the function for calculating false positives
1264  *   1 - (1 - ((63 / 2 ^18) ^ GST_MP3_TYPEFIND_MIN_HEADERS)) ^ buffersize)
1265  * This has the following probabilities of false positives:
1266  * datasize               MIN_HEADERS
1267  * (bytes)      1       2       3       4
1268  * 4096         62.6%    0.02%   0%      0%
1269  * 16384        98%      0.09%   0%      0%
1270  * 1 MiB       100%      5.88%   0%      0%
1271  * 1 GiB       100%    100%      1.44%   0%
1272  * 1 TiB       100%    100%    100%      0.35%
1273  * This means that the current choice (3 headers by most of the time 4096 byte
1274  * buffers is pretty safe for now.
1275  *
1276  * The max. size of each frame is 1440 bytes, which means that for N frames to
1277  * be detected, we need 1440 * GST_MP3_TYPEFIND_MIN_HEADERS + 3 bytes of data.
1278  * Assuming we step into the stream right after the frame header, this
1279  * means we need 1440 * (GST_MP3_TYPEFIND_MIN_HEADERS + 1) - 1 + 3 bytes
1280  * of data (5762) to always detect any mp3.
1281  */
1282 
1283 static const guint mp3types_bitrates[2][3][16] =
1284     { {{0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448,},
1285     {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384,},
1286     {0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320,}},
1287 {{0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256,},
1288     {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160,},
1289     {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160,}},
1290 };
1291 
1292 static const guint mp3types_freqs[3][3] = { {11025, 12000, 8000},
1293 {22050, 24000, 16000},
1294 {44100, 48000, 32000}
1295 };
1296 
1297 static inline guint
1298 mp3_type_frame_length_from_header (guint32 header, guint * put_layer,
1299     guint * put_channels, guint * put_bitrate, guint * put_samplerate,
1300     gboolean * may_be_free_format, gint possible_free_framelen)
1301 {
1302   guint bitrate, layer, length, mode, samplerate, version, channels;
1303 
1304   if ((header &amp; 0xffe00000) != 0xffe00000)
1305     return 0;
1306 
1307   /* we don&#39;t need extension, copyright, original or
1308    * emphasis for the frame length */
1309   header &gt;&gt;= 6;
1310 
1311   /* mode */
1312   mode = header &amp; 0x3;
1313   header &gt;&gt;= 3;
1314 
1315   /* padding */
1316   length = header &amp; 0x1;
1317   header &gt;&gt;= 1;
1318 
1319   /* sampling frequency */
1320   samplerate = header &amp; 0x3;
1321   if (samplerate == 3)
1322     return 0;
1323   header &gt;&gt;= 2;
1324 
1325   /* bitrate index */
1326   bitrate = header &amp; 0xF;
1327   if (bitrate == 0 &amp;&amp; possible_free_framelen == -1) {
1328     GST_LOG (&quot;Possibly a free format mp3 - signaling&quot;);
1329     *may_be_free_format = TRUE;
1330   }
1331   if (bitrate == 15 || (bitrate == 0 &amp;&amp; possible_free_framelen == -1))
1332     return 0;
1333 
1334   /* ignore error correction, too */
1335   header &gt;&gt;= 5;
1336 
1337   /* layer */
1338   layer = 4 - (header &amp; 0x3);
1339   if (layer == 4)
1340     return 0;
1341   header &gt;&gt;= 2;
1342 
1343   /* version 0=MPEG2.5; 2=MPEG2; 3=MPEG1 */
1344   version = header &amp; 0x3;
1345   if (version == 1)
1346     return 0;
1347 
1348   /* lookup */
1349   channels = (mode == 3) ? 1 : 2;
1350   samplerate = mp3types_freqs[version &gt; 0 ? version - 1 : 0][samplerate];
1351   if (bitrate == 0) {
1352     /* possible freeform mp3 */
1353     if (layer == 1) {
1354       length *= 4;
1355       length += possible_free_framelen;
1356       bitrate = length * samplerate / 48000;
1357     } else {
1358       length += possible_free_framelen;
1359       bitrate = length * samplerate /
1360           ((layer == 3 &amp;&amp; version != 3) ? 72000 : 144000);
1361     }
1362     /* freeform mp3 should have a higher-than-usually-allowed bitrate */
1363     GST_LOG (&quot;calculated bitrate: %u, max usually: %u&quot;, bitrate,
1364         mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][14]);
1365     if (bitrate &lt; mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][14])
1366       return 0;
1367   } else {
1368     /* calculating */
1369     bitrate = mp3types_bitrates[version == 3 ? 0 : 1][layer - 1][bitrate];
1370     if (layer == 1) {
1371       length = ((12000 * bitrate / samplerate) + length) * 4;
1372     } else {
1373       length += ((layer == 3
1374               &amp;&amp; version != 3) ? 72000 : 144000) * bitrate / samplerate;
1375     }
1376   }
1377 
1378   GST_LOG (&quot;mp3typefind: calculated mp3 frame length of %u bytes&quot;, length);
1379   GST_LOG
1380       (&quot;mp3typefind: samplerate = %u - bitrate = %u - layer = %u - version = %u&quot;
1381       &quot; - channels = %u&quot;, samplerate, bitrate, layer, version, channels);
1382 
1383   if (put_layer)
1384     *put_layer = layer;
1385   if (put_channels)
1386     *put_channels = channels;
1387   if (put_bitrate)
1388     *put_bitrate = bitrate;
1389   if (put_samplerate)
1390     *put_samplerate = samplerate;
1391 
1392   return length;
1393 }
1394 
1395 
1396 static GstStaticCaps mp3_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1397     &quot;mpegversion = (int) 1, layer = (int) [ 1, 3 ]&quot;);
1398 #define MP3_CAPS (gst_static_caps_get(&amp;mp3_caps))
1399 /*
1400  * random values for typefinding
1401  * if no more data is available, we will return a probability of
1402  * (found_headers/TRY_HEADERS) * (MAXIMUM * (TRY_SYNC - bytes_skipped)
1403  *        / TRY_SYNC)
1404  * if found_headers &gt;= MIN_HEADERS
1405  */
1406 #define GST_MP3_TYPEFIND_MIN_HEADERS (2)
1407 #define GST_MP3_TYPEFIND_TRY_HEADERS (5)
1408 #define GST_MP3_TYPEFIND_TRY_SYNC (GST_TYPE_FIND_MAXIMUM * 100) /* 10kB */
1409 #define GST_MP3_TYPEFIND_SYNC_SIZE (2048)
1410 #define GST_MP3_WRONG_HEADER (10)
1411 
1412 static void
1413 mp3_type_find_at_offset (GstTypeFind * tf, guint64 start_off,
1414     guint * found_layer, GstTypeFindProbability * found_prob)
1415 {
1416   const guint8 *data = NULL;
1417   const guint8 *data_end = NULL;
1418   guint size;
1419   guint64 skipped;
1420   gint last_free_offset = -1;
1421   gint last_free_framelen = -1;
1422   gboolean headerstart = TRUE;
1423 
1424   *found_layer = 0;
1425   *found_prob = 0;
1426 
1427   size = 0;
1428   skipped = 0;
1429   while (skipped &lt; GST_MP3_TYPEFIND_TRY_SYNC) {
1430     if (size &lt;= 0) {
1431       size = GST_MP3_TYPEFIND_SYNC_SIZE * 2;
1432       do {
1433         size /= 2;
1434         data = gst_type_find_peek (tf, skipped + start_off, size);
1435       } while (size &gt; 10 &amp;&amp; !data);
1436       if (!data)
1437         break;
1438       data_end = data + size;
1439     }
1440     if (*data == 0xFF) {
1441       const guint8 *head_data = NULL;
1442       guint layer = 0, bitrate, samplerate, channels;
1443       guint found = 0;          /* number of valid headers found */
1444       guint64 offset = skipped;
1445       gboolean changed = FALSE;
1446       guint prev_layer = 0;
1447       guint prev_channels = 0, prev_samplerate = 0;
1448 
1449       while (found &lt; GST_MP3_TYPEFIND_TRY_HEADERS) {
1450         guint32 head;
1451         guint length;
1452         gboolean free = FALSE;
1453 
1454         if ((gint64) (offset - skipped + 4) &gt;= 0 &amp;&amp;
1455             data + offset - skipped + 4 &lt; data_end) {
1456           head_data = data + offset - skipped;
1457         } else {
1458           head_data = gst_type_find_peek (tf, offset + start_off, 4);
1459         }
1460         if (!head_data)
1461           break;
1462         head = GST_READ_UINT32_BE (head_data);
1463         if (!(length = mp3_type_frame_length_from_header (head, &amp;layer,
1464                     &amp;channels, &amp;bitrate, &amp;samplerate, &amp;free,
1465                     last_free_framelen))) {
1466           if (free) {
1467             if (last_free_offset == -1)
1468               last_free_offset = offset;
1469             else {
1470               last_free_framelen = offset - last_free_offset;
1471               offset = last_free_offset;
1472               continue;
1473             }
1474           } else {
1475             last_free_framelen = -1;
1476           }
1477 
1478           /* Mark the fact that we didn&#39;t find a valid header at the beginning */
1479           if (found == 0)
1480             headerstart = FALSE;
1481 
1482           GST_LOG (&quot;%d. header at offset %&quot; G_GUINT64_FORMAT
1483               &quot; (0x%&quot; G_GINT64_MODIFIER &quot;x) was not an mp3 header &quot;
1484               &quot;(possibly-free: %s)&quot;, found + 1, start_off + offset,
1485               start_off + offset, free ? &quot;yes&quot; : &quot;no&quot;);
1486           break;
1487         }
1488         if ((prev_layer &amp;&amp; prev_layer != layer) ||
1489             /* (prev_bitrate &amp;&amp; prev_bitrate != bitrate) || &lt;-- VBR */
1490             (prev_samplerate &amp;&amp; prev_samplerate != samplerate) ||
1491             (prev_channels &amp;&amp; prev_channels != channels)) {
1492           /* this means an invalid property, or a change, which might mean
1493            * that this is not a mp3 but just a random bytestream. It could
1494            * be a freaking funky encoded mp3 though. We&#39;ll just not count
1495            * this header*/
1496           if (prev_layer)
1497             changed = TRUE;
1498         } else {
1499           found++;
1500           GST_LOG (&quot;found %d. header at offset %&quot; G_GUINT64_FORMAT &quot; (0x%&quot;
1501               G_GINT64_MODIFIER &quot;X)&quot;, found, start_off + offset,
1502               start_off + offset);
1503         }
1504         prev_layer = layer;
1505         prev_channels = channels;
1506         prev_samplerate = samplerate;
1507 
1508         offset += length;
1509       }
1510       g_assert (found &lt;= GST_MP3_TYPEFIND_TRY_HEADERS);
1511       if (found != 0 &amp;&amp; head_data == NULL &amp;&amp;
1512           gst_type_find_peek (tf, offset + start_off - 1, 1) == NULL)
1513         /* Incomplete last frame - don&#39;t count it. */
1514         found--;
1515       if (found == GST_MP3_TYPEFIND_TRY_HEADERS ||
1516           (found &gt;= GST_MP3_TYPEFIND_MIN_HEADERS &amp;&amp; head_data == NULL)) {
1517         /* we can make a valid guess */
1518         guint probability = found * GST_TYPE_FIND_MAXIMUM *
1519             (GST_MP3_TYPEFIND_TRY_SYNC - skipped) /
1520             GST_MP3_TYPEFIND_TRY_HEADERS / GST_MP3_TYPEFIND_TRY_SYNC;
1521 
1522         if (!headerstart
1523             &amp;&amp; probability &gt; (GST_TYPE_FIND_MINIMUM + GST_MP3_WRONG_HEADER))
1524           probability -= GST_MP3_WRONG_HEADER;
1525         if (probability &lt; GST_TYPE_FIND_MINIMUM)
1526           probability = GST_TYPE_FIND_MINIMUM;
1527         if (start_off &gt; 0)
1528           probability /= 2;
1529         if (!changed)
1530           probability = (probability + GST_TYPE_FIND_MAXIMUM) / 2;
1531 
1532         GST_INFO
1533             (&quot;audio/mpeg calculated %u  =  %u  *  %u / %u  *  (%u - %&quot;
1534             G_GUINT64_FORMAT &quot;) / %u&quot;, probability, GST_TYPE_FIND_MAXIMUM,
1535             found, GST_MP3_TYPEFIND_TRY_HEADERS, GST_MP3_TYPEFIND_TRY_SYNC,
1536             (guint64) skipped, GST_MP3_TYPEFIND_TRY_SYNC);
1537         /* make sure we&#39;re not id3 tagged */
1538         head_data = gst_type_find_peek (tf, -128, 3);
1539         if (head_data &amp;&amp; (memcmp (head_data, &quot;TAG&quot;, 3) == 0)) {
1540           probability = 0;
1541         }
1542         g_assert (probability &lt;= GST_TYPE_FIND_MAXIMUM);
1543 
1544         *found_prob = probability;
1545         if (probability &gt; 0)
1546           *found_layer = layer;
1547         return;
1548       }
1549     }
1550     data++;
1551     skipped++;
1552     size--;
1553   }
1554 }
1555 
1556 static void
1557 mp3_type_find (GstTypeFind * tf, gpointer unused)
1558 {
1559   GstTypeFindProbability prob, mid_prob;
1560   const guint8 *data;
1561   guint layer, mid_layer;
1562   guint64 length;
1563 
1564   mp3_type_find_at_offset (tf, 0, &amp;layer, &amp;prob);
1565   length = gst_type_find_get_length (tf);
1566 
1567   if (length == 0 || length == (guint64) - 1) {
1568     if (prob != 0)
1569       goto suggest;
1570     return;
1571   }
1572 
1573   /* if we&#39;re pretty certain already, skip the additional check */
1574   if (prob &gt;= GST_TYPE_FIND_LIKELY)
1575     goto suggest;
1576 
1577   mp3_type_find_at_offset (tf, length / 2, &amp;mid_layer, &amp;mid_prob);
1578 
1579   if (mid_prob &gt; 0) {
1580     if (prob == 0) {
1581       GST_LOG (&quot;detected audio/mpeg only in the middle (p=%u)&quot;, mid_prob);
1582       layer = mid_layer;
1583       prob = mid_prob;
1584       goto suggest;
1585     }
1586 
1587     if (layer != mid_layer) {
1588       GST_WARNING (&quot;audio/mpeg layer discrepancy: %u vs. %u&quot;, layer, mid_layer);
1589       return;                   /* FIXME: or should we just go with the one in the middle? */
1590     }
1591 
1592     /* detected mpeg audio both in middle of the file and at the start */
1593     prob = (prob + mid_prob) / 2;
1594     goto suggest;
1595   }
1596 
1597   /* a valid header right at the start makes it more likely
1598    * that this is actually plain mpeg-1 audio */
1599   if (prob &gt; 0) {
1600     data = gst_type_find_peek (tf, 0, 4);       /* use min. frame size? */
<a name="9" id="anc9"></a><span class="line-modified">1601   if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="line-modified">1602           &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
1603       prob = MIN (prob + 10, GST_TYPE_FIND_MAXIMUM);
<a name="10" id="anc10"></a><span class="line-modified">1604   }</span>
1605   }
1606 
1607   if (prob &gt; 0)
1608     goto suggest;
1609 
1610   return;
1611 
1612 suggest:
1613   {
1614     g_return_if_fail (layer &gt;= 1 &amp;&amp; layer &lt;= 3);
1615 
1616     gst_type_find_suggest_simple (tf, prob, &quot;audio/mpeg&quot;,
1617         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;layer&quot;, G_TYPE_INT, layer,
1618         &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1619   }
1620 }
1621 
1622 /*** audio/x-musepack ***/
1623 
1624 static GstStaticCaps musepack_caps =
1625 GST_STATIC_CAPS (&quot;audio/x-musepack, streamversion= (int) { 7, 8 }&quot;);
1626 
1627 #define MUSEPACK_CAPS (gst_static_caps_get(&amp;musepack_caps))
1628 static void
1629 musepack_type_find (GstTypeFind * tf, gpointer unused)
1630 {
1631   const guint8 *data = gst_type_find_peek (tf, 0, 4);
1632   GstTypeFindProbability prop = GST_TYPE_FIND_MINIMUM;
1633   gint streamversion = -1;
1634 
1635   if (data &amp;&amp; memcmp (data, &quot;MP+&quot;, 3) == 0) {
1636     streamversion = 7;
1637     if ((data[3] &amp; 0x7f) == 7) {
1638       prop = GST_TYPE_FIND_MAXIMUM;
1639     } else {
1640       prop = GST_TYPE_FIND_LIKELY + 10;
1641     }
1642   } else if (data &amp;&amp; memcmp (data, &quot;MPCK&quot;, 4) == 0) {
1643     streamversion = 8;
1644     prop = GST_TYPE_FIND_MAXIMUM;
1645   }
1646 
1647   if (streamversion != -1) {
1648     gst_type_find_suggest_simple (tf, prop, &quot;audio/x-musepack&quot;,
1649         &quot;streamversion&quot;, G_TYPE_INT, streamversion, NULL);
1650   }
1651 }
1652 
1653 /*** audio/x-ac3 ***/
1654 /* FIXME 0.11: should be audio/ac3, but isn&#39;t for backwards compatibility */
1655 static GstStaticCaps ac3_caps = GST_STATIC_CAPS (&quot;audio/x-ac3&quot;);
1656 
1657 #define AC3_CAPS (gst_static_caps_get(&amp;ac3_caps))
1658 
1659 static GstStaticCaps eac3_caps = GST_STATIC_CAPS (&quot;audio/x-eac3&quot;);
1660 
1661 #define EAC3_CAPS (gst_static_caps_get(&amp;eac3_caps))
1662 
1663 struct ac3_frmsize
1664 {
1665   unsigned short bit_rate;
1666   unsigned short frm_size[3];
1667 };
1668 
1669 static const struct ac3_frmsize ac3_frmsizecod_tbl[] = {
1670   {32, {64, 69, 96}},
1671   {32, {64, 70, 96}},
1672   {40, {80, 87, 120}},
1673   {40, {80, 88, 120}},
1674   {48, {96, 104, 144}},
1675   {48, {96, 105, 144}},
1676   {56, {112, 121, 168}},
1677   {56, {112, 122, 168}},
1678   {64, {128, 139, 192}},
1679   {64, {128, 140, 192}},
1680   {80, {160, 174, 240}},
1681   {80, {160, 175, 240}},
1682   {96, {192, 208, 288}},
1683   {96, {192, 209, 288}},
1684   {112, {224, 243, 336}},
1685   {112, {224, 244, 336}},
1686   {128, {256, 278, 384}},
1687   {128, {256, 279, 384}},
1688   {160, {320, 348, 480}},
1689   {160, {320, 349, 480}},
1690   {192, {384, 417, 576}},
1691   {192, {384, 418, 576}},
1692   {224, {448, 487, 672}},
1693   {224, {448, 488, 672}},
1694   {256, {512, 557, 768}},
1695   {256, {512, 558, 768}},
1696   {320, {640, 696, 960}},
1697   {320, {640, 697, 960}},
1698   {384, {768, 835, 1152}},
1699   {384, {768, 836, 1152}},
1700   {448, {896, 975, 1344}},
1701   {448, {896, 976, 1344}},
1702   {512, {1024, 1114, 1536}},
1703   {512, {1024, 1115, 1536}},
1704   {576, {1152, 1253, 1728}},
1705   {576, {1152, 1254, 1728}},
1706   {640, {1280, 1393, 1920}},
1707   {640, {1280, 1394, 1920}}
1708 };
1709 
1710 static void
1711 ac3_type_find (GstTypeFind * tf, gpointer unused)
1712 {
1713   DataScanCtx c = { 0, NULL, 0 };
1714 
1715   /* Search for an ac3 frame; not necessarily right at the start, but give it
1716    * a lower probability if not found right at the start. Check that the
1717    * frame is followed by a second frame at the expected offset.
1718    * We could also check the two ac3 CRCs, but we don&#39;t do that right now */
1719   while (c.offset &lt; 1024) {
1720     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1721       break;
1722 
1723     if (c.data[0] == 0x0b &amp;&amp; c.data[1] == 0x77) {
1724       guint bsid = c.data[5] &gt;&gt; 3;
1725 
1726       if (bsid &lt;= 8) {
1727         /* ac3 */
1728         guint fscod = c.data[4] &gt;&gt; 6;
1729         guint frmsizecod = c.data[4] &amp; 0x3f;
1730 
1731         if (fscod &lt; 3 &amp;&amp; frmsizecod &lt; 38) {
1732           DataScanCtx c_next = c;
1733           guint frame_size;
1734 
1735           frame_size = ac3_frmsizecod_tbl[frmsizecod].frm_size[fscod];
1736           GST_LOG (&quot;possible AC3 frame sync at offset %&quot;
1737               G_GUINT64_FORMAT &quot;, size=%u&quot;, c.offset, frame_size);
1738           if (data_scan_ctx_ensure_data (tf, &amp;c_next, (frame_size * 2) + 5)) {
1739             data_scan_ctx_advance (tf, &amp;c_next, frame_size * 2);
1740 
1741             if (c_next.data[0] == 0x0b &amp;&amp; c_next.data[1] == 0x77) {
1742               fscod = c_next.data[4] &gt;&gt; 6;
1743               frmsizecod = c_next.data[4] &amp; 0x3f;
1744 
1745               if (fscod &lt; 3 &amp;&amp; frmsizecod &lt; 38) {
1746                 GstTypeFindProbability prob;
1747 
1748                 GST_LOG (&quot;found second AC3 frame (size=%u), looks good&quot;,
1749                     ac3_frmsizecod_tbl[frmsizecod].frm_size[fscod]);
1750                 if (c.offset == 0)
1751                   prob = GST_TYPE_FIND_MAXIMUM;
1752                 else
1753                   prob = GST_TYPE_FIND_NEARLY_CERTAIN;
1754 
1755                 gst_type_find_suggest (tf, prob, AC3_CAPS);
1756                 return;
1757               }
1758             } else {
1759               GST_LOG (&quot;no second AC3 frame found, false sync&quot;);
1760             }
1761           }
1762         }
1763       } else if (bsid &lt;= 16 &amp;&amp; bsid &gt; 10) {
1764         /* eac3 */
1765         DataScanCtx c_next = c;
1766         guint frame_size;
1767 
1768         frame_size = (((c.data[2] &amp; 0x07) &lt;&lt; 8) + c.data[3]) + 1;
1769         GST_LOG (&quot;possible E-AC3 frame sync at offset %&quot;
1770             G_GUINT64_FORMAT &quot;, size=%u&quot;, c.offset, frame_size);
1771         if (data_scan_ctx_ensure_data (tf, &amp;c_next, (frame_size * 2) + 5)) {
1772           data_scan_ctx_advance (tf, &amp;c_next, frame_size * 2);
1773 
1774           if (c_next.data[0] == 0x0b &amp;&amp; c_next.data[1] == 0x77) {
1775             GstTypeFindProbability prob;
1776 
1777             GST_LOG (&quot;found second E-AC3 frame, looks good&quot;);
1778             if (c.offset == 0)
1779               prob = GST_TYPE_FIND_MAXIMUM;
1780             else
1781               prob = GST_TYPE_FIND_NEARLY_CERTAIN;
1782 
1783             gst_type_find_suggest (tf, prob, EAC3_CAPS);
1784             return;
1785           } else {
1786             GST_LOG (&quot;no second E-AC3 frame found, false sync&quot;);
1787           }
1788         }
1789       } else {
1790         GST_LOG (&quot;invalid AC3 BSID: %u&quot;, bsid);
1791       }
1792     }
1793     data_scan_ctx_advance (tf, &amp;c, 1);
1794   }
1795 }
1796 
1797 /*** audio/x-dts ***/
1798 static GstStaticCaps dts_caps = GST_STATIC_CAPS (&quot;audio/x-dts&quot;);
1799 #define DTS_CAPS (gst_static_caps_get (&amp;dts_caps))
1800 #define DTS_MIN_FRAMESIZE 96
1801 #define DTS_MAX_FRAMESIZE 18725 /* 16384*16/14 */
1802 
1803 static gboolean
1804 dts_parse_frame_header (DataScanCtx * c, guint * frame_size,
1805     guint * sample_rate, guint * channels, guint * depth, guint * endianness)
1806 {
1807   static const int sample_rates[16] = { 0, 8000, 16000, 32000, 0, 0, 11025,
1808     22050, 44100, 0, 0, 12000, 24000, 48000, 96000, 192000
1809   };
1810   static const guint8 channels_table[16] = { 1, 2, 2, 2, 2, 3, 3, 4, 4, 5,
1811     6, 6, 6, 7, 8, 8
1812   };
1813   guint16 hdr[8];
1814   guint32 marker;
1815   guint num_blocks, chans, lfe, i;
1816 
1817   marker = GST_READ_UINT32_BE (c-&gt;data);
1818 
1819   /* raw big endian or 14-bit big endian */
1820   if (marker == 0x7FFE8001 || marker == 0x1FFFE800) {
1821     *endianness = G_BIG_ENDIAN;
1822     for (i = 0; i &lt; G_N_ELEMENTS (hdr); ++i)
1823       hdr[i] = GST_READ_UINT16_BE (c-&gt;data + (i * sizeof (guint16)));
1824   } else
1825     /* raw little endian or 14-bit little endian */
1826   if (marker == 0xFE7F0180 || marker == 0xFF1F00E8) {
1827     *endianness = G_LITTLE_ENDIAN;
1828     for (i = 0; i &lt; G_N_ELEMENTS (hdr); ++i)
1829       hdr[i] = GST_READ_UINT16_LE (c-&gt;data + (i * sizeof (guint16)));
1830   } else {
1831     return FALSE;
1832   }
1833 
1834   GST_LOG (&quot;dts sync marker 0x%08x at offset %u&quot;, marker, (guint) c-&gt;offset);
1835 
1836   /* 14-bit mode */
1837   if (marker == 0x1FFFE800 || marker == 0xFF1F00E8) {
1838     if ((hdr[2] &amp; 0xFFF0) != 0x07F0)
1839       return FALSE;
1840     /* discard top 2 bits (2 void), shift in 2 */
1841     hdr[0] = (hdr[0] &lt;&lt; 2) | ((hdr[1] &gt;&gt; 12) &amp; 0x0003);
1842     /* discard top 4 bits (2 void, 2 shifted into hdr[0]), shift in 4 etc. */
1843     hdr[1] = (hdr[1] &lt;&lt; 4) | ((hdr[2] &gt;&gt; 10) &amp; 0x000F);
1844     hdr[2] = (hdr[2] &lt;&lt; 6) | ((hdr[3] &gt;&gt; 8) &amp; 0x003F);
1845     hdr[3] = (hdr[3] &lt;&lt; 8) | ((hdr[4] &gt;&gt; 6) &amp; 0x00FF);
1846     hdr[4] = (hdr[4] &lt;&lt; 10) | ((hdr[5] &gt;&gt; 4) &amp; 0x03FF);
1847     hdr[5] = (hdr[5] &lt;&lt; 12) | ((hdr[6] &gt;&gt; 2) &amp; 0x0FFF);
1848     hdr[6] = (hdr[6] &lt;&lt; 14) | ((hdr[7] &gt;&gt; 0) &amp; 0x3FFF);
1849     g_assert (hdr[0] == 0x7FFE &amp;&amp; hdr[1] == 0x8001);
1850     *depth = 14;
1851   } else {
1852     *depth = 16;
1853   }
1854 
1855   GST_LOG (&quot;frame header: %04x%04x%04x%04x&quot;, hdr[2], hdr[3], hdr[4], hdr[5]);
1856 
1857   num_blocks = (hdr[2] &gt;&gt; 2) &amp; 0x7F;
1858   *frame_size = (((hdr[2] &amp; 0x03) &lt;&lt; 12) | (hdr[3] &gt;&gt; 4)) + 1;
1859   chans = ((hdr[3] &amp; 0x0F) &lt;&lt; 2) | (hdr[4] &gt;&gt; 14);
1860   *sample_rate = sample_rates[(hdr[4] &gt;&gt; 10) &amp; 0x0F];
1861   lfe = (hdr[5] &gt;&gt; 9) &amp; 0x03;
1862 
1863   if (num_blocks &lt; 5 || *frame_size &lt; 96 || *sample_rate == 0)
1864     return FALSE;
1865 
1866   if (marker == 0x1FFFE800 || marker == 0xFF1F00E8)
1867     *frame_size = (*frame_size * 16) / 14;      /* FIXME: round up? */
1868 
1869   if (chans &lt; G_N_ELEMENTS (channels_table))
1870     *channels = channels_table[chans] + ((lfe) ? 1 : 0);
1871   else
1872     *channels = 0;
1873 
1874   return TRUE;
1875 }
1876 
1877 static void
1878 dts_type_find (GstTypeFind * tf, gpointer unused)
1879 {
1880   DataScanCtx c = { 0, NULL, 0 };
1881 
1882   /* Search for an dts frame; not necessarily right at the start, but give it
1883    * a lower probability if not found right at the start. Check that the
1884    * frame is followed by a second frame at the expected offset. */
1885   while (c.offset &lt;= DTS_MAX_FRAMESIZE) {
1886     guint frame_size = 0, rate = 0, chans = 0, depth = 0, endianness = 0;
1887 
1888     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, DTS_MIN_FRAMESIZE)))
1889       return;
1890 
1891     if (G_UNLIKELY (dts_parse_frame_header (&amp;c, &amp;frame_size, &amp;rate, &amp;chans,
1892                 &amp;depth, &amp;endianness))) {
1893       GstTypeFindProbability prob;
1894       DataScanCtx next_c;
1895 
1896       prob = (c.offset == 0) ? GST_TYPE_FIND_LIKELY : GST_TYPE_FIND_POSSIBLE;
1897 
1898       /* check for second frame sync */
1899       next_c = c;
1900       data_scan_ctx_advance (tf, &amp;next_c, frame_size);
1901       if (data_scan_ctx_ensure_data (tf, &amp;next_c, 4)) {
1902         GST_LOG (&quot;frame size: %u 0x%04x&quot;, frame_size, frame_size);
1903         GST_MEMDUMP (&quot;second frame sync&quot;, next_c.data, 4);
1904         if (GST_READ_UINT32_BE (c.data) == GST_READ_UINT32_BE (next_c.data))
1905           prob = GST_TYPE_FIND_MAXIMUM;
1906       }
1907 
1908       if (chans &gt; 0) {
1909         gst_type_find_suggest_simple (tf, prob, &quot;audio/x-dts&quot;,
1910             &quot;rate&quot;, G_TYPE_INT, rate, &quot;channels&quot;, G_TYPE_INT, chans,
1911             &quot;depth&quot;, G_TYPE_INT, depth, &quot;endianness&quot;, G_TYPE_INT, endianness,
1912             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1913       } else {
1914         gst_type_find_suggest_simple (tf, prob, &quot;audio/x-dts&quot;,
1915             &quot;rate&quot;, G_TYPE_INT, rate, &quot;depth&quot;, G_TYPE_INT, depth,
1916             &quot;endianness&quot;, G_TYPE_INT, endianness,
1917             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1918       }
1919 
1920       return;
1921     }
1922 
1923     data_scan_ctx_advance (tf, &amp;c, 1);
1924   }
1925 }
1926 
1927 /*** gsm ***/
1928 
1929 /* can only be detected by using the extension, in which case we use the default
1930  * GSM properties */
1931 static GstStaticCaps gsm_caps =
1932 GST_STATIC_CAPS (&quot;audio/x-gsm, rate=8000, channels=1&quot;);
1933 
1934 #define GSM_CAPS (gst_static_caps_get(&amp;gsm_caps))
1935 
1936 /*** wavpack ***/
1937 
1938 static GstStaticCaps wavpack_caps =
1939 GST_STATIC_CAPS (&quot;audio/x-wavpack, framed = (boolean) false&quot;);
1940 
1941 #define WAVPACK_CAPS (gst_static_caps_get(&amp;wavpack_caps))
1942 
1943 static GstStaticCaps wavpack_correction_caps =
1944 GST_STATIC_CAPS (&quot;audio/x-wavpack-correction, framed = (boolean) false&quot;);
1945 
1946 #define WAVPACK_CORRECTION_CAPS (gst_static_caps_get(&amp;wavpack_correction_caps))
1947 
1948 static void
1949 wavpack_type_find (GstTypeFind * tf, gpointer unused)
1950 {
1951   GstTypeFindProbability base_prob = GST_TYPE_FIND_POSSIBLE;
1952   guint64 offset;
1953   guint32 blocksize;
1954   const guint8 *data;
1955   guint count_wv, count_wvc;
1956 
1957   data = gst_type_find_peek (tf, 0, 32);
1958   if (!data)
1959     return;
1960 
1961   if (data[0] != &#39;w&#39; || data[1] != &#39;v&#39; || data[2] != &#39;p&#39; || data[3] != &#39;k&#39;)
1962     return;
1963 
1964   /* Note: wavpack blocks can be fairly large (easily 60-110k), possibly
1965    * larger than the max. limits imposed by certain typefinding elements
1966    * like id3demux or apedemux, so typefinding is most likely only going to
1967    * work in pull-mode */
1968   blocksize = GST_READ_UINT32_LE (data + 4);
1969   GST_LOG (&quot;wavpack header, blocksize=0x%04x&quot;, blocksize);
1970   /* If bigger than maximum allowed blocksize, refuse */
1971   if (blocksize &gt; 131072)
1972     return;
1973   count_wv = 0;
1974   count_wvc = 0;
1975   offset = 32;
1976   while (offset &lt; 8 + blocksize) {
1977     guint32 sublen;
1978 
1979     /* get chunk header */
1980     GST_LOG (&quot;peeking at chunk at offset 0x%04x&quot;, (guint) offset);
1981     data = gst_type_find_peek (tf, offset, 4);
1982     if (data == NULL)
1983       break;
1984     sublen = ((guint32) data[1]) &lt;&lt; 1;
1985     if (data[0] &amp; 0x80) {
1986       sublen |= (((guint32) data[2]) &lt;&lt; 9) | (((guint32) data[3]) &lt;&lt; 17);
1987       sublen += 1 + 3;          /* id + length */
1988     } else {
1989       sublen += 1 + 1;          /* id + length */
1990     }
1991     if (offset + sublen &gt; 8 + blocksize) {
1992       GST_LOG (&quot;chunk length too big (%u &gt; %&quot; G_GUINT64_FORMAT &quot;)&quot;, sublen,
1993           blocksize - offset);
1994       break;
1995     }
1996     if ((data[0] &amp; 0x20) == 0) {
1997       switch (data[0] &amp; 0x0f) {
1998         case 0xa:              /* ID_WV_BITSTREAM  */
1999         case 0xc:              /* ID_WVX_BITSTREAM */
2000           ++count_wv;
2001           break;
2002         case 0xb:              /* ID_WVC_BITSTREAM */
2003           ++count_wvc;
2004           break;
2005         default:
2006           break;
2007       }
2008       if (count_wv &gt;= 5 || count_wvc &gt;= 5)
2009         break;
2010     }
2011     offset += sublen;
2012   }
2013 
2014   /* check for second block header */
2015   data = gst_type_find_peek (tf, 8 + blocksize, 4);
2016   if (data != NULL &amp;&amp; memcmp (data, &quot;wvpk&quot;, 4) == 0) {
2017     GST_DEBUG (&quot;found second block sync&quot;);
2018     base_prob = GST_TYPE_FIND_LIKELY;
2019   }
2020 
2021   GST_DEBUG (&quot;wvc=%d, wv=%d&quot;, count_wvc, count_wv);
2022 
2023   if (count_wvc &gt; 0 &amp;&amp; count_wvc &gt; count_wv) {
2024     gst_type_find_suggest (tf,
2025         MIN (base_prob + 5 * count_wvc, GST_TYPE_FIND_NEARLY_CERTAIN),
2026         WAVPACK_CORRECTION_CAPS);
2027   } else if (count_wv &gt; 0) {
2028     gst_type_find_suggest (tf,
2029         MIN (base_prob + 5 * count_wv, GST_TYPE_FIND_NEARLY_CERTAIN),
2030         WAVPACK_CAPS);
2031   }
2032 }
2033 
2034 /*** application/postscrip ***/
2035 static GstStaticCaps postscript_caps =
2036 GST_STATIC_CAPS (&quot;application/postscript&quot;);
2037 
2038 #define POSTSCRIPT_CAPS (gst_static_caps_get(&amp;postscript_caps))
2039 
2040 static void
2041 postscript_type_find (GstTypeFind * tf, gpointer unused)
2042 {
2043   const guint8 *data = gst_type_find_peek (tf, 0, 3);
2044   if (!data)
2045     return;
2046 
2047   if (data[0] == 0x04)
2048     data++;
2049   if (data[0] == &#39;%&#39; &amp;&amp; data[1] == &#39;!&#39;)
2050     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, POSTSCRIPT_CAPS);
2051 
2052 }
2053 
2054 /*** image/svg+xml ***/
2055 static GstStaticCaps svg_caps = GST_STATIC_CAPS (&quot;image/svg+xml&quot;);
2056 
2057 #define SVG_CAPS (gst_static_caps_get(&amp;svg_caps))
2058 
2059 static void
2060 svg_type_find (GstTypeFind * tf, gpointer unused)
2061 {
2062   static const gchar svg_doctype[] = &quot;!DOCTYPE svg&quot;;
2063   static const gchar svg_tag[] = &quot;&lt;svg&quot;;
2064   DataScanCtx c = { 0, NULL, 0 };
2065 
2066   while (c.offset &lt;= 1024) {
2067     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 12)))
2068       break;
2069 
2070     if (memcmp (svg_doctype, c.data, 12) == 0) {
2071       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SVG_CAPS);
2072       return;
2073     } else if (memcmp (svg_tag, c.data, 4) == 0) {
2074       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, SVG_CAPS);
2075       return;
2076     }
2077     data_scan_ctx_advance (tf, &amp;c, 1);
2078   }
2079 }
2080 
2081 /*** multipart/x-mixed-replace mimestream ***/
2082 
2083 static GstStaticCaps multipart_caps =
2084 GST_STATIC_CAPS (&quot;multipart/x-mixed-replace&quot;);
2085 #define MULTIPART_CAPS gst_static_caps_get(&amp;multipart_caps)
2086 
2087 /* multipart/x-mixed replace is:
2088  *   &lt;maybe some whitespace&gt;--&lt;some ascii chars&gt;[\r]\n
2089  *   &lt;more ascii chars&gt;[\r]\nContent-type:&lt;more ascii&gt;[\r]\n */
2090 static void
2091 multipart_type_find (GstTypeFind * tf, gpointer unused)
2092 {
2093   const guint8 *data;
2094   const guint8 *x;
2095 
2096 #define MULTIPART_MAX_BOUNDARY_OFFSET 16
2097   data = gst_type_find_peek (tf, 0, MULTIPART_MAX_BOUNDARY_OFFSET);
2098   if (!data)
2099     return;
2100 
2101   for (x = data;
2102       x - data &lt; MULTIPART_MAX_BOUNDARY_OFFSET - 2 &amp;&amp; g_ascii_isspace (*x);
2103       x++);
2104   if (x[0] != &#39;-&#39; || x[1] != &#39;-&#39;)
2105     return;
2106 
2107   /* Could be okay, peek what should be enough for a complete header */
2108 #define MULTIPART_MAX_HEADER_SIZE 256
2109   data = gst_type_find_peek (tf, 0, MULTIPART_MAX_HEADER_SIZE);
2110   if (!data)
2111     return;
2112 
2113   for (x = data; x - data &lt; MULTIPART_MAX_HEADER_SIZE - 14; x++) {
2114     if (!isascii (*x)) {
2115       return;
2116     }
2117     if (*x == &#39;\n&#39; &amp;&amp;
2118         !g_ascii_strncasecmp (&quot;content-type:&quot;, (gchar *) x + 1, 13)) {
2119       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MULTIPART_CAPS);
2120       return;
2121     }
2122   }
2123 }
2124 
2125 /*** video/mpeg systemstream ***/
2126 static GstStaticCaps mpeg_sys_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2127     &quot;systemstream = (boolean) true, mpegversion = (int) [ 1, 2 ]&quot;);
2128 
2129 #define MPEG_SYS_CAPS gst_static_caps_get(&amp;mpeg_sys_caps)
2130 #define IS_MPEG_HEADER(data) (G_UNLIKELY((((guint8 *)(data))[0] == 0x00) &amp;&amp;  \
2131                                          (((guint8 *)(data))[1] == 0x00) &amp;&amp;  \
2132                                          (((guint8 *)(data))[2] == 0x01)))
2133 
2134 #define IS_MPEG_PACK_CODE(b) ((b) == 0xBA)
2135 #define IS_MPEG_SYS_CODE(b) ((b) == 0xBB)
2136 #define IS_MPEG_PACK_HEADER(data)       (IS_MPEG_HEADER (data) &amp;&amp;            \
2137                                          IS_MPEG_PACK_CODE (((guint8 *)(data))[3]))
2138 
2139 #define IS_MPEG_PES_CODE(b) (((b) &amp; 0xF0) == 0xE0 || ((b) &amp; 0xF0) == 0xC0 || \
2140                              (b) &gt;= 0xBD)
2141 #define IS_MPEG_PES_HEADER(data)        (IS_MPEG_HEADER (data) &amp;&amp;            \
2142                                          IS_MPEG_PES_CODE (((guint8 *)(data))[3]))
2143 
2144 #define MPEG2_MAX_PROBE_LENGTH (128 * 1024)     /* 128kB should be 64 packs of the
2145                                                  * most common 2kB pack size. */
2146 
2147 #define MPEG2_MIN_SYS_HEADERS 2
2148 #define MPEG2_MAX_SYS_HEADERS 5
2149 
2150 static gboolean
2151 mpeg_sys_is_valid_pack (GstTypeFind * tf, const guint8 * data, guint len,
2152     guint * pack_size)
2153 {
2154   /* Check the pack header @ offset for validity, assuming that the 4 byte header
2155    * itself has already been checked. */
2156   guint8 stuff_len;
2157 
2158   if (len &lt; 12)
2159     return FALSE;
2160 
2161   /* Check marker bits */
2162   if ((data[4] &amp; 0xC4) == 0x44) {
2163     /* MPEG-2 PACK */
2164     if (len &lt; 14)
2165       return FALSE;
2166 
2167     if ((data[6] &amp; 0x04) != 0x04 ||
2168         (data[8] &amp; 0x04) != 0x04 ||
2169         (data[9] &amp; 0x01) != 0x01 || (data[12] &amp; 0x03) != 0x03)
2170       return FALSE;
2171 
2172     stuff_len = data[13] &amp; 0x07;
2173 
2174     /* Check the following header bytes, if we can */
2175     if ((14 + stuff_len + 4) &lt;= len) {
2176       if (!IS_MPEG_HEADER (data + 14 + stuff_len))
2177         return FALSE;
2178     }
2179     if (pack_size)
2180       *pack_size = 14 + stuff_len;
2181     return TRUE;
2182   } else if ((data[4] &amp; 0xF1) == 0x21) {
2183     /* MPEG-1 PACK */
2184     if ((data[6] &amp; 0x01) != 0x01 ||
2185         (data[8] &amp; 0x01) != 0x01 ||
2186         (data[9] &amp; 0x80) != 0x80 || (data[11] &amp; 0x01) != 0x01)
2187       return FALSE;
2188 
2189     /* Check the following header bytes, if we can */
2190     if ((12 + 4) &lt;= len) {
2191       if (!IS_MPEG_HEADER (data + 12))
2192         return FALSE;
2193     }
2194     if (pack_size)
2195       *pack_size = 12;
2196     return TRUE;
2197   }
2198 
2199   return FALSE;
2200 }
2201 
2202 static gboolean
2203 mpeg_sys_is_valid_pes (GstTypeFind * tf, const guint8 * data, guint len,
2204     guint * pack_size)
2205 {
2206   guint pes_packet_len;
2207 
2208   /* Check the PES header at the given position, assuming the header code itself
2209    * was already checked */
2210   if (len &lt; 6)
2211     return FALSE;
2212 
2213   /* For MPEG Program streams, unbounded PES is not allowed, so we must have a
2214    * valid length present */
2215   pes_packet_len = GST_READ_UINT16_BE (data + 4);
2216   if (pes_packet_len == 0)
2217     return FALSE;
2218 
2219   /* Check the following header, if we can */
2220   if (6 + pes_packet_len + 4 &lt;= len) {
2221     if (!IS_MPEG_HEADER (data + 6 + pes_packet_len))
2222       return FALSE;
2223   }
2224 
2225   if (pack_size)
2226     *pack_size = 6 + pes_packet_len;
2227   return TRUE;
2228 }
2229 
2230 static gboolean
2231 mpeg_sys_is_valid_sys (GstTypeFind * tf, const guint8 * data, guint len,
2232     guint * pack_size)
2233 {
2234   guint sys_hdr_len;
2235 
2236   /* Check the System header at the given position, assuming the header code itself
2237    * was already checked */
2238   if (len &lt; 6)
2239     return FALSE;
2240   sys_hdr_len = GST_READ_UINT16_BE (data + 4);
2241   if (sys_hdr_len &lt; 6)
2242     return FALSE;
2243 
2244   /* Check the following header, if we can */
2245   if (6 + sys_hdr_len + 4 &lt;= len) {
2246     if (!IS_MPEG_HEADER (data + 6 + sys_hdr_len))
2247       return FALSE;
2248   }
2249 
2250   if (pack_size)
2251     *pack_size = 6 + sys_hdr_len;
2252 
2253   return TRUE;
2254 }
2255 
2256 /* calculation of possibility to identify random data as mpeg systemstream:
2257  * bits that must match in header detection:            32 (or more)
2258  * chance that random data is identifed:                1/2^32
2259  * chance that MPEG2_MIN_PACK_HEADERS headers are identified:
2260  *       1/2^(32*MPEG2_MIN_PACK_HEADERS)
2261  * chance that this happens in MPEG2_MAX_PROBE_LENGTH bytes:
2262  *       1-(1+1/2^(32*MPEG2_MIN_PACK_HEADERS)^MPEG2_MAX_PROBE_LENGTH)
2263  * for current values:
2264  *       1-(1+1/2^(32*4)^101024)
2265  *       = &lt;some_number&gt;
2266  * Since we also check marker bits and pes packet lengths, this probability is a
2267  * very coarse upper bound.
2268  */
2269 static void
2270 mpeg_sys_type_find (GstTypeFind * tf, gpointer unused)
2271 {
2272   const guint8 *data, *data0, *first_sync, *end;
2273   gint mpegversion = 0;
2274   guint pack_headers = 0;
2275   guint pes_headers = 0;
2276   guint pack_size;
2277   guint since_last_sync = 0;
2278   guint32 sync_word = 0xffffffff;
2279   guint potential_headers = 0;
2280 
2281   G_STMT_START {
2282     gint len;
2283 
2284     len = MPEG2_MAX_PROBE_LENGTH;
2285 
2286     while (len &gt;= 16) {
2287       data = gst_type_find_peek (tf, 0, 5 + len);
2288       if (data != NULL)
2289         break;
2290       len = len / 2;
2291     }
2292 
2293     if (!data)
2294       return;
2295 
2296     end = data + len;
2297   }
2298   G_STMT_END;
2299 
2300   data0 = data;
2301   first_sync = NULL;
2302 
2303   while (data &lt; end) {
2304     sync_word &lt;&lt;= 8;
2305     if (sync_word == 0x00000100) {
2306       /* Found potential sync word */
2307       if (first_sync == NULL)
2308         first_sync = data - 3;
2309 
2310       if (since_last_sync &gt; 4) {
2311         /* If more than 4 bytes since the last sync word, reset our counters,
2312          * as we&#39;re only interested in counting contiguous packets */
2313         pes_headers = pack_headers = 0;
2314       }
2315       pack_size = 0;
2316 
2317       potential_headers++;
2318       if (IS_MPEG_PACK_CODE (data[0])) {
2319         if ((data[1] &amp; 0xC0) == 0x40) {
2320           /* MPEG-2 */
2321           mpegversion = 2;
2322         } else if ((data[1] &amp; 0xF0) == 0x20) {
2323           mpegversion = 1;
2324         }
2325         if (mpegversion != 0 &amp;&amp;
2326             mpeg_sys_is_valid_pack (tf, data - 3, end - data + 3, &amp;pack_size)) {
2327           pack_headers++;
2328         }
2329       } else if (IS_MPEG_PES_CODE (data[0])) {
2330         /* PES stream */
2331         if (mpeg_sys_is_valid_pes (tf, data - 3, end - data + 3, &amp;pack_size)) {
2332           pes_headers++;
2333           if (mpegversion == 0)
2334             mpegversion = 2;
2335         }
2336       } else if (IS_MPEG_SYS_CODE (data[0])) {
2337         if (mpeg_sys_is_valid_sys (tf, data - 3, end - data + 3, &amp;pack_size)) {
2338           pack_headers++;
2339         }
2340       }
2341 
2342       /* If we found a packet with a known size, skip the bytes in it and loop
2343        * around to check the next packet. */
2344       if (pack_size != 0) {
2345         data += pack_size - 3;
2346         sync_word = 0xffffffff;
2347         since_last_sync = 0;
2348         continue;
2349       }
2350     }
2351 
2352     sync_word |= data[0];
2353     since_last_sync++;
2354     data++;
2355 
2356     /* If we have found MAX headers, and *some* were pes headers (pack headers
2357      * are optional in an mpeg system stream) then return our high-probability
2358      * result */
2359     if (pes_headers &gt; 0 &amp;&amp; (pack_headers + pes_headers) &gt; MPEG2_MAX_SYS_HEADERS)
2360       goto suggest;
2361   }
2362 
2363   /* If we at least saw MIN headers, and *some* were pes headers (pack headers
2364    * are optional in an mpeg system stream) then return a lower-probability
2365    * result */
2366   if (pes_headers &gt; 0 &amp;&amp; (pack_headers + pes_headers) &gt; MPEG2_MIN_SYS_HEADERS)
2367     goto suggest;
2368 
2369   return;
2370 suggest:
2371   {
2372     guint prob;
2373 
2374     prob = GST_TYPE_FIND_POSSIBLE + (10 * (pack_headers + pes_headers));
2375     prob = MIN (prob, GST_TYPE_FIND_MAXIMUM);
2376 
2377     /* With the above test, we get into problems when we try to typefind
2378        a MPEG stream from a small amount of data, which can happen when
2379        we get data pushed from a HTTP source. We thus make a second test
2380        to give higher probability if all the potential headers were either
2381        pack or pes headers (ie, no potential header was unrecognized). */
2382     if (potential_headers == pack_headers + pes_headers) {
2383       GST_LOG (&quot;Only %u headers, but all were recognized&quot;, potential_headers);
2384       prob += 10;
2385       prob = MIN (prob, GST_TYPE_FIND_MAXIMUM);
2386     }
2387 
2388     /* lower probability if the first packet wasn&#39;t right at the start */
2389     if (data0 != first_sync &amp;&amp; prob &gt;= 10)
2390       prob -= 10;
2391 
2392     GST_LOG (&quot;Suggesting MPEG %d system stream, %d packs, %d pes, prob %u%%&quot;,
2393         mpegversion, pack_headers, pes_headers, prob);
2394 
2395     gst_type_find_suggest_simple (tf, prob, &quot;video/mpeg&quot;,
2396         &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2397         &quot;mpegversion&quot;, G_TYPE_INT, mpegversion, NULL);
2398   }
2399 };
2400 
2401 /*** video/mpegts Transport Stream ***/
2402 static GstStaticCaps mpegts_caps = GST_STATIC_CAPS (&quot;video/mpegts, &quot;
2403     &quot;systemstream = (boolean) true, packetsize = (int) [ 188, 208 ]&quot;);
2404 #define MPEGTS_CAPS gst_static_caps_get(&amp;mpegts_caps)
2405 
2406 #define GST_MPEGTS_TYPEFIND_MIN_HEADERS 4
2407 #define GST_MPEGTS_TYPEFIND_MAX_HEADERS 10
2408 #define GST_MPEGTS_MAX_PACKET_SIZE 208
2409 #define GST_MPEGTS_TYPEFIND_SYNC_SIZE \
2410             (GST_MPEGTS_TYPEFIND_MIN_HEADERS * GST_MPEGTS_MAX_PACKET_SIZE)
2411 #define GST_MPEGTS_TYPEFIND_MAX_SYNC \
2412             (GST_MPEGTS_TYPEFIND_MAX_HEADERS * GST_MPEGTS_MAX_PACKET_SIZE)
2413 #define GST_MPEGTS_TYPEFIND_SCAN_LENGTH \
2414             (GST_MPEGTS_TYPEFIND_MAX_SYNC * 4)
2415 
2416 #define MPEGTS_HDR_SIZE 4
2417 /* Check for sync byte, error_indicator == 0 and packet has payload.
2418  * Adaptation control field (data[3] &amp; 0x30) may be zero for TS packets with
2419  * null PIDs. Still, these streams are valid TS streams (for null packets,
2420  * AFC is supposed to be 0x1, but the spec also says decoders should just
2421  * discard any packets with AFC = 0x00) */
2422 #define IS_MPEGTS_HEADER(data) (data[0] == 0x47 &amp;&amp; \
2423                                 (data[1] &amp; 0x80) == 0x00 &amp;&amp; \
2424                                 ((data[3] &amp; 0x30) != 0x00 || \
2425                                 ((data[3] &amp; 0x30) == 0x00 &amp;&amp; (data[1] &amp; 0x1f) == 0x1f &amp;&amp; (data[2] &amp; 0xff) == 0xff)))
2426 
2427 /* Helper function to search ahead at intervals of packet_size for mpegts
2428  * headers */
2429 static gint
2430 mpeg_ts_probe_headers (GstTypeFind * tf, guint64 offset, gint packet_size)
2431 {
2432   /* We always enter this function having found at least one header already */
2433   gint found = 1;
2434   const guint8 *data = NULL;
2435 
2436   GST_LOG (&quot;looking for mpeg-ts packets of size %u&quot;, packet_size);
2437   while (found &lt; GST_MPEGTS_TYPEFIND_MAX_HEADERS) {
2438     offset += packet_size;
2439 
2440     data = gst_type_find_peek (tf, offset, MPEGTS_HDR_SIZE);
2441     if (data == NULL || !IS_MPEGTS_HEADER (data))
2442       return found;
2443 
2444     found++;
2445     GST_LOG (&quot;mpeg-ts sync #%2d at offset %&quot; G_GUINT64_FORMAT, found, offset);
2446   }
2447 
2448   return found;
2449 }
2450 
2451 /* Try and detect at least 4 packets in at most 10 packets worth of
2452  * data. Need to try several possible packet sizes */
2453 static void
2454 mpeg_ts_type_find (GstTypeFind * tf, gpointer unused)
2455 {
2456   /* TS packet sizes to test: normal, DVHS packet size and
2457    * FEC with 16 or 20 byte codes packet size. */
2458   const gint pack_sizes[] = { 188, 192, 204, 208 };
2459   const guint8 *data = NULL;
2460   guint size = 0;
2461   guint64 skipped = 0;
2462 
2463   while (skipped &lt; GST_MPEGTS_TYPEFIND_SCAN_LENGTH) {
2464     if (size &lt; MPEGTS_HDR_SIZE) {
2465       data = gst_type_find_peek (tf, skipped, GST_MPEGTS_TYPEFIND_SYNC_SIZE);
2466       if (!data)
2467         break;
2468       size = GST_MPEGTS_TYPEFIND_SYNC_SIZE;
2469     }
2470 
2471     /* Have at least MPEGTS_HDR_SIZE bytes at this point */
2472     if (IS_MPEGTS_HEADER (data)) {
<a name="11" id="anc11"></a><span class="line-modified">2473       gint p;</span>
2474 
2475       GST_LOG (&quot;possible mpeg-ts sync at offset %&quot; G_GUINT64_FORMAT, skipped);
2476 
2477       for (p = 0; p &lt; G_N_ELEMENTS (pack_sizes); p++) {
2478         gint found;
2479 
2480         /* Probe ahead at size pack_sizes[p] */
2481         found = mpeg_ts_probe_headers (tf, skipped, pack_sizes[p]);
2482         if (found &gt;= GST_MPEGTS_TYPEFIND_MIN_HEADERS) {
2483           gint probability;
2484 
2485           /* found at least 4 headers. 10 headers = MAXIMUM probability.
2486            * Arbitrarily, I assigned 10% probability for each header we
2487            * found, 40% -&gt; 100% */
2488           probability = MIN (10 * found, GST_TYPE_FIND_MAXIMUM);
2489 
2490           gst_type_find_suggest_simple (tf, probability, &quot;video/mpegts&quot;,
2491               &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2492               &quot;packetsize&quot;, G_TYPE_INT, pack_sizes[p], NULL);
2493           return;
2494         }
2495       }
2496     }
2497     data++;
2498     skipped++;
2499     size--;
2500   }
2501 }
2502 
2503 #define GST_MPEGVID_TYPEFIND_TRY_PICTURES 6
2504 #define GST_MPEGVID_TYPEFIND_TRY_SYNC (100 * 1024)      /* 100 kB */
2505 
2506 /* Scan ahead a maximum of max_extra_offset bytes until the next IS_MPEG_HEADER
2507  * offset.  After the call, offset will be after the 0x000001, i.e. at the 4th
2508  * byte of the MPEG header.  Returns TRUE if a header was found, FALSE if not.
2509  */
2510 static gboolean
2511 mpeg_find_next_header (GstTypeFind * tf, DataScanCtx * c,
2512     guint64 max_extra_offset)
2513 {
2514   guint64 extra_offset;
2515 
2516   for (extra_offset = 0; extra_offset &lt;= max_extra_offset; ++extra_offset) {
2517     if (!data_scan_ctx_ensure_data (tf, c, 4))
2518       return FALSE;
2519     if (IS_MPEG_HEADER (c-&gt;data)) {
2520       data_scan_ctx_advance (tf, c, 3);
2521       return TRUE;
2522     }
2523     data_scan_ctx_advance (tf, c, 1);
2524   }
2525   return FALSE;
2526 }
2527 
2528 /*** video/mpeg MPEG-4 elementary video stream ***/
2529 
2530 static GstStaticCaps mpeg4_video_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2531     &quot;systemstream=(boolean)false, mpegversion=4, parsed=(boolean)false&quot;);
2532 #define MPEG4_VIDEO_CAPS gst_static_caps_get(&amp;mpeg4_video_caps)
2533 
2534 /*
2535  * This typefind is based on the elementary video header defined in
2536  * http://xhelmboyx.tripod.com/formats/mpeg-layout.txt
2537  * In addition, it allows the visual object sequence header to be
2538  * absent, and even the VOS header to be absent.  In the latter case,
2539  * a number of VOPs have to be present.
2540  */
2541 static void
2542 mpeg4_video_type_find (GstTypeFind * tf, gpointer unused)
2543 {
2544   DataScanCtx c = { 0, NULL, 0 };
2545   gboolean seen_vios_at_0 = FALSE;
2546   gboolean seen_vios = FALSE;
2547   gboolean seen_vos = FALSE;
2548   gboolean seen_vol = FALSE;
2549   guint num_vop_headers = 0;
2550   guint8 sc;
2551 
2552   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2553     if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2554       break;
2555 
2556     if (!mpeg_find_next_header (tf, &amp;c,
2557             GST_MPEGVID_TYPEFIND_TRY_SYNC - c.offset))
2558       break;
2559 
2560     sc = c.data[0];
2561 
2562     /* visual_object_sequence_start_code */
2563     if (sc == 0xB0) {
2564       if (seen_vios)
2565         break;                  /* Terminate at second vios */
2566       if (c.offset == 0)
2567         seen_vios_at_0 = TRUE;
2568       seen_vios = TRUE;
2569       data_scan_ctx_advance (tf, &amp;c, 2);
2570       if (!mpeg_find_next_header (tf, &amp;c, 0))
2571         break;
2572 
2573       sc = c.data[0];
2574 
2575       /* Optional metadata */
2576       if (sc == 0xB2)
2577         if (!mpeg_find_next_header (tf, &amp;c, 24))
2578           break;
2579     }
2580 
2581     /* visual_object_start_code (consider it optional) */
2582     if (sc == 0xB5) {
2583       data_scan_ctx_advance (tf, &amp;c, 2);
2584       /* may contain ID marker and YUV clamping */
2585       if (!mpeg_find_next_header (tf, &amp;c, 7))
2586         break;
2587 
2588       sc = c.data[0];
2589     }
2590 
2591     /* video_object_start_code */
2592     if (sc &lt;= 0x1F) {
2593       if (seen_vos)
2594         break;                  /* Terminate at second vos */
2595       seen_vos = TRUE;
2596       data_scan_ctx_advance (tf, &amp;c, 2);
2597       continue;
2598     }
2599 
2600     /* video_object_layer_start_code */
2601     if (sc &gt;= 0x20 &amp;&amp; sc &lt;= 0x2F) {
2602       seen_vol = TRUE;
2603       data_scan_ctx_advance (tf, &amp;c, 5);
2604       continue;
2605     }
2606 
2607     /* video_object_plane_start_code */
2608     if (sc == 0xB6) {
2609       num_vop_headers++;
2610       data_scan_ctx_advance (tf, &amp;c, 2);
2611       continue;
2612     }
2613 
2614     /* Unknown start code. */
2615   }
2616 
2617   if (num_vop_headers &gt; 0 || seen_vol) {
2618     GstTypeFindProbability probability = 0;
2619 
2620     GST_LOG (&quot;Found %d pictures, vios: %d, vos:%d, vol:%d&quot;, num_vop_headers,
2621         seen_vios, seen_vos, seen_vol);
2622 
2623     if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vios_at_0
2624         &amp;&amp; seen_vos &amp;&amp; seen_vol)
2625       probability = GST_TYPE_FIND_MAXIMUM - 1;
2626     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vios
2627         &amp;&amp; seen_vos &amp;&amp; seen_vol)
2628       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 1;
2629     else if (seen_vios_at_0 &amp;&amp; seen_vos &amp;&amp; seen_vol)
2630       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 6;
2631     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vos
2632         &amp;&amp; seen_vol)
2633       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 6;
2634     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_vol)
2635       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 9;
2636     else if (num_vop_headers &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2637       probability = GST_TYPE_FIND_LIKELY - 1;
2638     else if (num_vop_headers &gt; 2 &amp;&amp; seen_vios &amp;&amp; seen_vos &amp;&amp; seen_vol)
2639       probability = GST_TYPE_FIND_LIKELY - 9;
2640     else if (seen_vios &amp;&amp; seen_vos &amp;&amp; seen_vol)
2641       probability = GST_TYPE_FIND_LIKELY - 20;
2642     else if (num_vop_headers &gt; 0 &amp;&amp; seen_vos &amp;&amp; seen_vol)
2643       probability = GST_TYPE_FIND_POSSIBLE;
2644     else if (num_vop_headers &gt; 0)
2645       probability = GST_TYPE_FIND_POSSIBLE - 10;
2646     else if (seen_vos &amp;&amp; seen_vol)
2647       probability = GST_TYPE_FIND_POSSIBLE - 20;
2648 
2649     gst_type_find_suggest (tf, probability, MPEG4_VIDEO_CAPS);
2650   }
2651 }
2652 
2653 /*** video/x-h263 H263 video stream ***/
2654 static GstStaticCaps h263_video_caps =
2655 GST_STATIC_CAPS (&quot;video/x-h263, variant=(string)itu&quot;);
2656 
2657 #define H263_VIDEO_CAPS gst_static_caps_get(&amp;h263_video_caps)
2658 
2659 #define H263_MAX_PROBE_LENGTH (128 * 1024)
2660 
2661 static void
2662 h263_video_type_find (GstTypeFind * tf, gpointer unused)
2663 {
2664   DataScanCtx c = { 0, NULL, 0 };
2665   guint64 data = 0xffff;        /* prevents false positive for first 2 bytes */
2666   guint64 psc = 0;
2667   guint8 ptype = 0;
2668   guint format;
2669   guint good = 0;
2670   guint bad = 0;
2671   guint pc_type, pb_mode;
2672 
2673   while (c.offset &lt; H263_MAX_PROBE_LENGTH) {
2674     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
2675       break;
2676 
2677     /* Find the picture start code */
2678     data = (data &lt;&lt; 8) + c.data[0];
2679     psc = data &amp; G_GUINT64_CONSTANT (0xfffffc0000);
2680     if (psc == 0x800000) {
2681       /* Found PSC */
2682       /* PTYPE */
2683       ptype = (data &amp; 0x3fc) &gt;&gt; 2;
2684       /* Source Format */
2685       format = ptype &amp; 0x07;
2686 
2687       /* Now that we have a Valid PSC, check if we also have a valid PTYPE and
2688          the Source Format, which should range between 1 and 5 */
2689       if (((ptype &gt;&gt; 6) == 0x2) &amp;&amp; (format &gt; 0 &amp;&amp; format &lt; 6)) {
2690         pc_type = data &amp; 0x02;
2691         pb_mode = c.data[1] &amp; 0x20 &gt;&gt; 4;
2692         if (!pc_type &amp;&amp; pb_mode)
2693           bad++;
2694         else
<a name="12" id="anc12"></a><span class="line-modified">2695         good++;</span>
2696       } else
2697         bad++;
2698 
2699       /* FIXME: maybe bail out early if we get mostly bad syncs ? */
2700     }
2701 
2702     data_scan_ctx_advance (tf, &amp;c, 1);
2703   }
2704 
2705   GST_LOG (&quot;good: %d, bad: %d&quot;, good, bad);
2706 
2707   if (good &gt; 2 * bad)
2708     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H263_VIDEO_CAPS);
2709 
2710   return;
2711 }
2712 
2713 /*** video/x-h264 H264 elementary video stream ***/
2714 
2715 static GstStaticCaps h264_video_caps =
2716 GST_STATIC_CAPS (&quot;video/x-h264,stream-format=byte-stream&quot;);
2717 
2718 #define H264_VIDEO_CAPS gst_static_caps_get(&amp;h264_video_caps)
2719 
2720 #define H264_MAX_PROBE_LENGTH (128 * 1024)      /* 128kB for HD should be enough. */
2721 
2722 static void
2723 h264_video_type_find (GstTypeFind * tf, gpointer unused)
2724 {
2725   DataScanCtx c = { 0, NULL, 0 };
2726 
2727   /* Stream consists of: a series of sync codes (00 00 00 01) followed
2728    * by NALs
2729    */
2730   gboolean seen_idr = FALSE;
2731   gboolean seen_sps = FALSE;
2732   gboolean seen_pps = FALSE;
2733   gboolean seen_ssps = FALSE;
2734   int nut, ref;
2735   int good = 0;
2736   int bad = 0;
2737 
2738   while (c.offset &lt; H264_MAX_PROBE_LENGTH) {
2739     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 4)))
2740       break;
2741 
2742     if (IS_MPEG_HEADER (c.data)) {
2743       nut = c.data[3] &amp; 0x9f;   /* forbiden_zero_bit | nal_unit_type */
2744       ref = c.data[3] &amp; 0x60;   /* nal_ref_idc */
2745 
2746       /* if forbidden bit is different to 0 won&#39;t be h264 */
2747       if (nut &gt; 0x1f) {
2748         bad++;
2749         break;
2750       }
2751 
2752       /* collect statistics about the NAL types */
2753       if ((nut &gt;= 1 &amp;&amp; nut &lt;= 13) || nut == 19) {
2754         if ((nut == 5 &amp;&amp; ref == 0) ||
2755             ((nut == 6 || (nut &gt;= 9 &amp;&amp; nut &lt;= 12)) &amp;&amp; ref != 0)) {
2756           bad++;
2757         } else {
2758           if (nut == 7)
2759             seen_sps = TRUE;
2760           else if (nut == 8)
2761             seen_pps = TRUE;
2762           else if (nut == 5)
2763             seen_idr = TRUE;
2764 
2765           good++;
2766         }
2767       } else if (nut &gt;= 14 &amp;&amp; nut &lt;= 33) {
2768         if (nut == 15) {
2769           seen_ssps = TRUE;
2770           good++;
2771         } else if (nut == 14 || nut == 20) {
2772           /* Sometimes we see NAL 14 or 20 without SSPS
2773            * if dropped into the middle of a stream -
2774            * just ignore those (don&#39;t add to bad count) */
2775           if (seen_ssps)
<a name="13" id="anc13"></a><span class="line-modified">2776           good++;</span>
2777         } else {
<a name="14" id="anc14"></a><span class="line-modified">2778         /* reserved */</span>
<span class="line-modified">2779         /* Theoretically these are good, since if they exist in the</span>
<span class="line-modified">2780            stream it merely means that a newer backwards-compatible</span>
<span class="line-modified">2781            h.264 stream.  But we should be identifying that separately. */</span>
<span class="line-modified">2782         bad++;</span>
2783         }
2784       } else {
2785         /* unspecified, application specific */
2786         /* don&#39;t consider these bad */
2787       }
2788 
2789       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps:%d&quot;, good, bad,
2790           seen_pps, seen_sps, seen_idr, seen_ssps);
2791 
2792       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_idr &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2793         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H264_VIDEO_CAPS);
2794         return;
2795       }
2796 
2797       data_scan_ctx_advance (tf, &amp;c, 4);
2798     }
2799     data_scan_ctx_advance (tf, &amp;c, 1);
2800   }
2801 
2802   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps=%d&quot;, good, bad,
2803       seen_pps, seen_sps, seen_idr, seen_ssps);
2804 
2805   if (good &gt;= 2 &amp;&amp; bad == 0) {
2806     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H264_VIDEO_CAPS);
2807   }
2808 }
2809 
2810 /*** video/x-h265 H265 elementary video stream ***/
2811 
2812 static GstStaticCaps h265_video_caps =
2813 GST_STATIC_CAPS (&quot;video/x-h265,stream-format=byte-stream&quot;);
2814 
2815 #define H265_VIDEO_CAPS gst_static_caps_get(&amp;h265_video_caps)
2816 
2817 #define H265_MAX_PROBE_LENGTH (128 * 1024)      /* 128kB for HD should be enough. */
2818 
2819 static void
2820 h265_video_type_find (GstTypeFind * tf, gpointer unused)
2821 {
2822   DataScanCtx c = { 0, NULL, 0 };
2823 
2824   /* Stream consists of: a series of sync codes (00 00 00 01) followed
2825    * by NALs
2826    */
2827   gboolean seen_irap = FALSE;
2828   gboolean seen_vps = FALSE;
2829   gboolean seen_sps = FALSE;
2830   gboolean seen_pps = FALSE;
2831   int nut;
2832   int good = 0;
2833   int bad = 0;
2834 
2835   while (c.offset &lt; H265_MAX_PROBE_LENGTH) {
2836     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 5)))
2837       break;
2838 
2839     if (IS_MPEG_HEADER (c.data)) {
2840       /* forbiden_zero_bit | nal_unit_type */
2841       nut = c.data[3] &amp; 0xfe;
2842 
2843       /* if forbidden bit is different to 0 won&#39;t be h265 */
2844       if (nut &gt; 0x7e) {
2845         bad++;
2846         break;
2847       }
2848       nut = nut &gt;&gt; 1;
2849 
2850       /* if nuh_layer_id is not zero or nuh_temporal_id_plus1 is zero then
2851        * it won&#39;t be h265 */
2852       if ((c.data[3] &amp; 0x01) || (c.data[4] &amp; 0xf8) || !(c.data[4] &amp; 0x07)) {
2853         bad++;
2854         break;
2855       }
2856 
2857       /* collect statistics about the NAL types */
2858       if ((nut &gt;= 0 &amp;&amp; nut &lt;= 9) || (nut &gt;= 16 &amp;&amp; nut &lt;= 21) || (nut &gt;= 32
2859               &amp;&amp; nut &lt;= 40)) {
2860         if (nut == 32)
2861           seen_vps = TRUE;
2862         else if (nut == 33)
2863           seen_sps = TRUE;
2864         else if (nut == 34)
2865           seen_pps = TRUE;
2866         else if (nut &gt;= 16 &amp;&amp; nut &lt;= 21) {
2867           /* BLA, IDR and CRA pictures are belongs to be IRAP picture */
2868           /* we are not counting the reserved IRAP pictures (22 and 23) to good */
2869           seen_irap = TRUE;
2870         }
2871 
2872         good++;
2873       } else if ((nut &gt;= 10 &amp;&amp; nut &lt;= 15) || (nut &gt;= 22 &amp;&amp; nut &lt;= 31)
2874           || (nut &gt;= 41 &amp;&amp; nut &lt;= 47)) {
2875         /* reserved values are counting as bad */
2876         bad++;
2877       } else {
2878         /* unspecified (48..63), application specific */
2879         /* don&#39;t consider these as bad */
2880       }
2881 
2882       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d&quot;, good, bad,
2883           seen_pps, seen_sps, seen_vps, seen_irap);
2884 
2885       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_irap &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2886         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H265_VIDEO_CAPS);
2887         return;
2888       }
2889 
2890       data_scan_ctx_advance (tf, &amp;c, 5);
2891     }
2892     data_scan_ctx_advance (tf, &amp;c, 1);
2893   }
2894 
2895   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d&quot;, good, bad,
2896       seen_pps, seen_sps, seen_vps, seen_irap);
2897 
2898   if (good &gt;= 2 &amp;&amp; bad == 0) {
2899     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H265_VIDEO_CAPS);
2900   }
2901 }
2902 
2903 /*** video/mpeg video stream ***/
2904 
2905 static GstStaticCaps mpeg_video_caps = GST_STATIC_CAPS (&quot;video/mpeg, &quot;
2906     &quot;systemstream = (boolean) false&quot;);
2907 #define MPEG_VIDEO_CAPS gst_static_caps_get(&amp;mpeg_video_caps)
2908 
2909 /*
2910  * Idea is the same as MPEG system stream typefinding: We check each
2911  * byte of the stream to see if - from that point on - the stream
2912  * matches a predefined set of marker bits as defined in the MPEG
2913  * video specs.
2914  *
2915  * I&#39;m sure someone will do a chance calculation here too.
2916  */
2917 
2918 static void
2919 mpeg_video_stream_type_find (GstTypeFind * tf, gpointer unused)
2920 {
2921   DataScanCtx c = { 0, NULL, 0 };
2922   gboolean seen_seq_at_0 = FALSE;
2923   gboolean seen_seq = FALSE;
2924   gboolean seen_gop = FALSE;
2925   guint64 last_pic_offset = 0;
<a name="15" id="anc15"></a><span class="line-modified">2926   guint num_pic_headers = 0;</span>
2927   gint found = 0;
2928 
2929   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2930     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2931       break;
2932 
2933     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
2934       break;
2935 
2936     if (!IS_MPEG_HEADER (c.data))
2937       goto next;
2938 
2939     /* a pack header indicates that this isn&#39;t an elementary stream */
2940     if (c.data[3] == 0xBA &amp;&amp; mpeg_sys_is_valid_pack (tf, c.data, c.size, NULL))
2941       return;
2942 
2943     /* do we have a sequence header? */
2944     if (c.data[3] == 0xB3) {
2945       seen_seq_at_0 = seen_seq_at_0 || (c.offset == 0);
2946       seen_seq = TRUE;
2947       data_scan_ctx_advance (tf, &amp;c, 4 + 8);
2948       continue;
2949     }
2950 
2951     /* or a GOP header */
2952     if (c.data[3] == 0xB8) {
2953       seen_gop = TRUE;
2954       data_scan_ctx_advance (tf, &amp;c, 8);
2955       continue;
2956     }
2957 
2958     /* but what we&#39;d really like to see is a picture header */
2959     if (c.data[3] == 0x00) {
2960       ++num_pic_headers;
2961       last_pic_offset = c.offset;
2962       data_scan_ctx_advance (tf, &amp;c, 8);
2963       continue;
2964     }
2965 
2966     /* ... each followed by a slice header with slice_vertical_pos=1 that&#39;s
2967      * not too far away from the previously seen picture header. */
2968     if (c.data[3] == 0x01 &amp;&amp; num_pic_headers &gt; found &amp;&amp;
2969         (c.offset - last_pic_offset) &gt;= 4 &amp;&amp;
2970         (c.offset - last_pic_offset) &lt;= 64) {
2971       data_scan_ctx_advance (tf, &amp;c, 4);
2972       found += 1;
2973       continue;
2974     }
2975 
2976   next:
2977 
2978     data_scan_ctx_advance (tf, &amp;c, 1);
2979   }
2980 
2981   if (found &gt; 0 || seen_seq) {
2982     GstTypeFindProbability probability = 0;
2983 
2984     GST_LOG (&quot;Found %d pictures, seq:%d, gop:%d&quot;, found, seen_seq, seen_gop);
2985 
2986     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_seq &amp;&amp; seen_gop)
2987       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 1;
2988     else if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES &amp;&amp; seen_seq)
2989       probability = GST_TYPE_FIND_NEARLY_CERTAIN - 9;
2990     else if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2991       probability = GST_TYPE_FIND_LIKELY;
2992     else if (seen_seq_at_0 &amp;&amp; seen_gop &amp;&amp; found &gt; 2)
2993       probability = GST_TYPE_FIND_LIKELY - 10;
2994     else if (seen_seq &amp;&amp; seen_gop &amp;&amp; found &gt; 2)
2995       probability = GST_TYPE_FIND_LIKELY - 20;
2996     else if (seen_seq_at_0 &amp;&amp; found &gt; 0)
2997       probability = GST_TYPE_FIND_POSSIBLE;
2998     else if (seen_seq &amp;&amp; found &gt; 0)
2999       probability = GST_TYPE_FIND_POSSIBLE - 5;
3000     else if (found &gt; 0)
3001       probability = GST_TYPE_FIND_POSSIBLE - 10;
3002     else if (seen_seq)
3003       probability = GST_TYPE_FIND_POSSIBLE - 20;
3004 
3005     gst_type_find_suggest_simple (tf, probability, &quot;video/mpeg&quot;,
3006         &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE,
3007         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
3008   }
3009 }
3010 
3011 /*** audio/x-aiff ***/
3012 
3013 static GstStaticCaps aiff_caps = GST_STATIC_CAPS (&quot;audio/x-aiff&quot;);
3014 
3015 #define AIFF_CAPS gst_static_caps_get(&amp;aiff_caps)
3016 static void
3017 aiff_type_find (GstTypeFind * tf, gpointer unused)
3018 {
3019   const guint8 *data = gst_type_find_peek (tf, 0, 16);
3020 
3021   if (data &amp;&amp; memcmp (data, &quot;FORM&quot;, 4) == 0) {
3022     data += 8;
3023     if (memcmp (data, &quot;AIFF&quot;, 4) == 0 || memcmp (data, &quot;AIFC&quot;, 4) == 0)
3024       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, AIFF_CAPS);
3025   }
3026 }
3027 
3028 /*** audio/x-svx ***/
3029 
3030 static GstStaticCaps svx_caps = GST_STATIC_CAPS (&quot;audio/x-svx&quot;);
3031 
3032 #define SVX_CAPS gst_static_caps_get(&amp;svx_caps)
3033 static void
3034 svx_type_find (GstTypeFind * tf, gpointer unused)
3035 {
3036   const guint8 *data = gst_type_find_peek (tf, 0, 16);
3037 
3038   if (data &amp;&amp; memcmp (data, &quot;FORM&quot;, 4) == 0) {
3039     data += 8;
3040     if (memcmp (data, &quot;8SVX&quot;, 4) == 0 || memcmp (data, &quot;16SV&quot;, 4) == 0)
3041       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SVX_CAPS);
3042   }
3043 }
3044 
3045 /*** audio/x-shorten ***/
3046 
3047 static GstStaticCaps shn_caps = GST_STATIC_CAPS (&quot;audio/x-shorten&quot;);
3048 
3049 #define SHN_CAPS gst_static_caps_get(&amp;shn_caps)
3050 static void
3051 shn_type_find (GstTypeFind * tf, gpointer unused)
3052 {
3053   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3054 
3055   if (data &amp;&amp; memcmp (data, &quot;ajkg&quot;, 4) == 0) {
3056     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SHN_CAPS);
3057   }
3058   data = gst_type_find_peek (tf, -8, 8);
3059   if (data &amp;&amp; memcmp (data, &quot;SHNAMPSK&quot;, 8) == 0) {
3060     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SHN_CAPS);
3061   }
3062 }
3063 
3064 /*** application/x-ape ***/
3065 
3066 static GstStaticCaps ape_caps = GST_STATIC_CAPS (&quot;application/x-ape&quot;);
3067 
3068 #define APE_CAPS gst_static_caps_get(&amp;ape_caps)
3069 static void
3070 ape_type_find (GstTypeFind * tf, gpointer unused)
3071 {
3072   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3073 
3074   if (data &amp;&amp; memcmp (data, &quot;MAC &quot;, 4) == 0) {
3075     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY + 10, APE_CAPS);
3076   }
3077 }
3078 
3079 /*** ISO FORMATS ***/
3080 
3081 /*** audio/x-m4a ***/
3082 
3083 static GstStaticCaps m4a_caps = GST_STATIC_CAPS (&quot;audio/x-m4a&quot;);
3084 
3085 #define M4A_CAPS (gst_static_caps_get(&amp;m4a_caps))
3086 static void
3087 m4a_type_find (GstTypeFind * tf, gpointer unused)
3088 {
3089   const guint8 *data = gst_type_find_peek (tf, 4, 8);
3090 
3091   if (data &amp;&amp; (memcmp (data, &quot;ftypM4A &quot;, 8) == 0)) {
3092     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, M4A_CAPS);
3093   }
3094 }
3095 
3096 /*** application/x-3gp ***/
3097 
3098 /* The Q is there because variables can&#39;t start with a number. */
3099 static GstStaticCaps q3gp_caps = GST_STATIC_CAPS (&quot;application/x-3gp&quot;);
3100 #define Q3GP_CAPS (gst_static_caps_get(&amp;q3gp_caps))
3101 
3102 static const gchar *
3103 q3gp_type_find_get_profile (const guint8 * data)
3104 {
3105   switch (GST_MAKE_FOURCC (data[0], data[1], data[2], 0)) {
3106     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;g&#39;, 0):
3107       return &quot;general&quot;;
3108     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;p&#39;, 0):
3109       return &quot;basic&quot;;
3110     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;s&#39;, 0):
3111       return &quot;streaming-server&quot;;
3112     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;r&#39;, 0):
3113       return &quot;progressive-download&quot;;
3114     default:
3115       break;
3116   }
3117   return NULL;
3118 }
3119 
3120 static void
3121 q3gp_type_find (GstTypeFind * tf, gpointer unused)
3122 {
3123   const gchar *profile;
3124   guint32 ftyp_size = 0;
<a name="16" id="anc16"></a><span class="line-modified">3125   gint offset = 0;</span>
3126   const guint8 *data = NULL;
3127 
3128   if ((data = gst_type_find_peek (tf, 0, 12)) == NULL) {
3129     return;
3130   }
3131 
3132   data += 4;
3133   if (memcmp (data, &quot;ftyp&quot;, 4) != 0) {
3134     return;
3135   }
3136 
3137   /* check major brand */
3138   data += 4;
3139   if ((profile = q3gp_type_find_get_profile (data))) {
3140     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
3141         &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
3142     return;
3143   }
3144 
3145   /* check compatible brands */
3146   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3147     ftyp_size = GST_READ_UINT32_BE (data);
3148   }
3149   if ((data = gst_type_find_peek (tf, 0, ftyp_size)) != NULL) {
3150     for (offset = 16; offset + 4 &lt; ftyp_size; offset += 4) {
3151       if ((profile = q3gp_type_find_get_profile (data + offset))) {
<a name="17" id="anc17"></a><span class="line-modified">3152       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-modified">3153           &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="line-modified">3154       return;</span>

3155     }
3156   }
<a name="18" id="anc18"></a><span class="line-removed">3157   }</span>
3158 
3159   return;
3160 
3161 }
3162 
3163 /*** video/mj2 and image/jp2 ***/
3164 static GstStaticCaps mj2_caps = GST_STATIC_CAPS (&quot;video/mj2&quot;);
3165 
3166 #define MJ2_CAPS gst_static_caps_get(&amp;mj2_caps)
3167 
3168 static GstStaticCaps jp2_caps = GST_STATIC_CAPS (&quot;image/jp2&quot;);
3169 
3170 #define JP2_CAPS gst_static_caps_get(&amp;jp2_caps)
3171 
3172 static void
3173 jp2_type_find (GstTypeFind * tf, gpointer unused)
3174 {
3175   const guint8 *data;
3176 
3177   data = gst_type_find_peek (tf, 0, 24);
3178   if (!data)
3179     return;
3180 
3181   /* jp2 signature */
3182   if (memcmp (data, &quot;\000\000\000\014jP  \015\012\207\012&quot;, 12) != 0)
3183     return;
3184 
3185   /* check ftyp box */
3186   data += 12;
3187   if (memcmp (data + 4, &quot;ftyp&quot;, 4) == 0) {
3188     if (memcmp (data + 8, &quot;jp2 &quot;, 4) == 0)
3189       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, JP2_CAPS);
3190     else if (memcmp (data + 8, &quot;mjp2&quot;, 4) == 0)
3191       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MJ2_CAPS);
3192   }
3193 }
3194 
3195 
3196 static GstStaticCaps jpc_caps = GST_STATIC_CAPS (&quot;image/x-jpc&quot;);
3197 
3198 #define JPC_CAPS gst_static_caps_get(&amp;jpc_caps)
3199 
3200 static void
3201 jpc_type_find (GstTypeFind * tf, gpointer unused)
3202 {
3203   gboolean found_cod = FALSE;
3204   gboolean found_qcd = FALSE;
3205   gboolean found_sot = FALSE;
3206   const guint8 *data;
3207   gint offset = 0;
3208   const guint8 soc_siz[] = { 0xff, 0x4f, 0xff, 0x51 };
3209 
3210 #define GST_TYPE_FIND_JPC_MARKER_SOT  0xFF90
3211 #define GST_TYPE_FIND_JPC_MARKER_COD  0xFF52
3212 #define GST_TYPE_FIND_JPC_MARKER_QCD  0xFF5C
3213 #define GST_TYPE_FIND_JPC_MARKER_COC  0xFF53
3214 #define GST_TYPE_FIND_JPC_MARKER_RGN  0xFF5E
3215 #define GST_TYPE_FIND_JPC_MARKER_QCC  0xFF5D
3216 #define GST_TYPE_FIND_JPC_MARKER_POC  0xFF5F
3217 #define GST_TYPE_FIND_JPC_MARKER_PLM  0xFF57
3218 #define GST_TYPE_FIND_JPC_MARKER_PPM  0xFF60
3219 #define GST_TYPE_FIND_JPC_MARKER_TLM  0xFF55
3220 #define GST_TYPE_FIND_JPC_MARKER_CRG  0xFF63
3221 #define GST_TYPE_FIND_JPC_MARKER_COM  0xFF64
3222 #define GST_TYPE_FIND_JPC_MARKER_CBD  0xFF78
3223 #define GST_TYPE_FIND_JPC_MARKER_MCC  0xFF75
3224 #define GST_TYPE_FIND_JPC_MARKER_MCT  0xFF74
3225 #define GST_TYPE_FIND_JPC_MARKER_MCO  0xFF77
3226 
3227 
3228   /* SOC marker + SIZ marker */
3229   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3230     if (memcmp (data, soc_siz, 4) != 0)
3231       return;
3232     offset += 4;
3233   } else {
3234     return;
3235   }
3236 
3237   while (!found_sot) {
3238 
3239     /* skip actual marker data */
3240     if ((data = gst_type_find_peek (tf, offset, 2)) != NULL) {
3241       offset += GST_READ_UINT16_BE (data);
3242     } else {
3243       return;
3244     }
3245 
3246     /* read marker */
3247     if ((data = gst_type_find_peek (tf, offset, 2)) != NULL) {
3248       guint16 marker = GST_READ_UINT16_BE (data);
3249       switch (marker) {
3250         case GST_TYPE_FIND_JPC_MARKER_SOT:
3251           found_sot = TRUE;
3252           break;
3253         case GST_TYPE_FIND_JPC_MARKER_COD:
3254           found_cod = TRUE;
3255           break;
3256         case GST_TYPE_FIND_JPC_MARKER_QCD:
3257           found_qcd = TRUE;
3258           break;
3259           /* optional header markers */
3260         case GST_TYPE_FIND_JPC_MARKER_COC:
3261         case GST_TYPE_FIND_JPC_MARKER_RGN:
3262         case GST_TYPE_FIND_JPC_MARKER_QCC:
3263         case GST_TYPE_FIND_JPC_MARKER_POC:
3264         case GST_TYPE_FIND_JPC_MARKER_PLM:
3265         case GST_TYPE_FIND_JPC_MARKER_PPM:
3266         case GST_TYPE_FIND_JPC_MARKER_TLM:
3267         case GST_TYPE_FIND_JPC_MARKER_CRG:
3268         case GST_TYPE_FIND_JPC_MARKER_COM:
3269         case GST_TYPE_FIND_JPC_MARKER_CBD:
3270         case GST_TYPE_FIND_JPC_MARKER_MCC:
3271         case GST_TYPE_FIND_JPC_MARKER_MCT:
3272         case GST_TYPE_FIND_JPC_MARKER_MCO:
3273           break;
3274           /* unrecognized marker */
3275         default:
3276           return;
3277       }
3278       offset += 2;
3279     } else {
3280       return;
3281     }
3282   }
3283 
3284   if (found_cod &amp;&amp; found_qcd &amp;&amp; found_sot)
3285     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, JPC_CAPS);
3286 }
3287 
3288 
3289 /*** video/quicktime ***/
3290 
3291 static GstStaticCaps qt_caps = GST_STATIC_CAPS (&quot;video/quicktime&quot;);
3292 
3293 #define QT_CAPS gst_static_caps_get(&amp;qt_caps)
3294 #define STRNCMP(x,y,z) (strncmp ((char*)(x), (char*)(y), z))
3295 
3296 /* FIXME 0.11: go through http://www.ftyps.com/ */
3297 static void
3298 qt_type_find (GstTypeFind * tf, gpointer unused)
3299 {
3300   const guint8 *data;
3301   guint tip = 0;
3302   guint64 offset = 0;
3303   guint64 size;
3304   const gchar *variant = NULL;
3305 
3306   while ((data = gst_type_find_peek (tf, offset, 12)) != NULL) {
3307     guint64 new_offset;
3308 
3309     if (STRNCMP (&amp;data[4], &quot;ftypqt  &quot;, 8) == 0) {
3310       tip = GST_TYPE_FIND_MAXIMUM;
3311       break;
3312     }
3313 
3314     if (STRNCMP (&amp;data[4], &quot;ftypisom&quot;, 8) == 0 ||
3315         STRNCMP (&amp;data[4], &quot;ftypavc1&quot;, 8) == 0 ||
3316         STRNCMP (&amp;data[4], &quot;ftypmp42&quot;, 8) == 0) {
3317       tip = GST_TYPE_FIND_MAXIMUM;
3318       variant = &quot;iso&quot;;
3319       break;
3320     }
3321 
3322     if (STRNCMP (&amp;data[4], &quot;ftypisml&quot;, 8) == 0 ||
3323         STRNCMP (&amp;data[4], &quot;ftypavc3&quot;, 8) == 0) {
3324       tip = GST_TYPE_FIND_MAXIMUM;
3325       variant = &quot;iso-fragmented&quot;;
3326       break;
3327     }
3328 
3329     if (STRNCMP (&amp;data[4], &quot;ftypccff&quot;, 8) == 0) {
3330       tip = GST_TYPE_FIND_MAXIMUM;
3331       variant = &quot;ccff&quot;;
3332       break;
3333     }
3334 
3335     /* box/atom types that are in common with ISO base media file format */
3336     if (STRNCMP (&amp;data[4], &quot;moov&quot;, 4) == 0 ||
3337         STRNCMP (&amp;data[4], &quot;mdat&quot;, 4) == 0 ||
3338         STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0 ||
3339         STRNCMP (&amp;data[4], &quot;free&quot;, 4) == 0 ||
3340         STRNCMP (&amp;data[4], &quot;uuid&quot;, 4) == 0 ||
3341         STRNCMP (&amp;data[4], &quot;moof&quot;, 4) == 0 ||
3342         STRNCMP (&amp;data[4], &quot;skip&quot;, 4) == 0) {
3343       if (tip == 0) {
3344         tip = GST_TYPE_FIND_LIKELY;
3345       } else {
3346         tip = GST_TYPE_FIND_NEARLY_CERTAIN;
3347       }
3348     }
3349     /* other box/atom types, apparently quicktime specific */
3350     else if (STRNCMP (&amp;data[4], &quot;pnot&quot;, 4) == 0 ||
3351         STRNCMP (&amp;data[4], &quot;PICT&quot;, 4) == 0 ||
3352         STRNCMP (&amp;data[4], &quot;wide&quot;, 4) == 0 ||
3353         STRNCMP (&amp;data[4], &quot;prfl&quot;, 4) == 0) {
3354       tip = GST_TYPE_FIND_MAXIMUM;
3355       break;
3356     } else {
3357       tip = 0;
3358       break;
3359     }
3360 
3361     size = GST_READ_UINT32_BE (data);
3362     if (size + offset &gt;= G_MAXINT64)
3363       break;
3364     /* check compatible brands rather than ever expaning major brands above */
3365     if ((STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0) &amp;&amp; (size &gt;= 16)) {
3366       data = gst_type_find_peek (tf, offset, size);
<a name="19" id="anc19"></a><span class="line-modified">3367         if (data == NULL)</span>
<span class="line-modified">3368           goto done;</span>
3369       new_offset = 12;
3370       while (new_offset + 4 &lt;= size) {
3371         if (STRNCMP (&amp;data[new_offset], &quot;isom&quot;, 4) == 0 ||
3372             STRNCMP (&amp;data[new_offset], &quot;dash&quot;, 4) == 0 ||
3373             STRNCMP (&amp;data[new_offset], &quot;avc1&quot;, 4) == 0 ||
3374             STRNCMP (&amp;data[new_offset], &quot;avc3&quot;, 4) == 0 ||
3375             STRNCMP (&amp;data[new_offset], &quot;mp41&quot;, 4) == 0 ||
3376             STRNCMP (&amp;data[new_offset], &quot;mp42&quot;, 4) == 0) {
3377           tip = GST_TYPE_FIND_MAXIMUM;
3378           variant = &quot;iso&quot;;
3379           goto done;
3380         }
3381         new_offset += 4;
3382       }
3383     }
3384     if (size == 1) {
3385       const guint8 *sizedata;
3386 
3387       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3388       if (sizedata == NULL)
3389         break;
3390 
3391       size = GST_READ_UINT64_BE (sizedata);
3392     } else {
3393       if (size &lt; 8)
3394         break;
3395     }
3396     new_offset = offset + size;
3397     if (new_offset &lt;= offset)
3398       break;
3399     if (new_offset + 16 &gt;= G_MAXINT64)
3400       break;
3401     offset = new_offset;
3402   }
3403 
3404 done:
3405   if (tip &gt; 0) {
3406     if (variant) {
3407       GstCaps *caps = gst_caps_copy (QT_CAPS);
3408 
3409       gst_caps_set_simple (caps, &quot;variant&quot;, G_TYPE_STRING, variant, NULL);
3410       gst_type_find_suggest (tf, tip, caps);
3411       gst_caps_unref (caps);
3412     } else {
3413       gst_type_find_suggest (tf, tip, QT_CAPS);
3414     }
3415   }
3416 };
3417 
3418 
3419 /*** image/x-quicktime ***/
3420 
3421 static GstStaticCaps qtif_caps = GST_STATIC_CAPS (&quot;image/x-quicktime&quot;);
3422 
3423 #define QTIF_CAPS gst_static_caps_get(&amp;qtif_caps)
3424 
3425 /* how many atoms we check before we give up */
3426 #define QTIF_MAXROUNDS 25
3427 
3428 static void
3429 qtif_type_find (GstTypeFind * tf, gpointer unused)
3430 {
3431   const guint8 *data;
3432   gboolean found_idsc = FALSE;
3433   gboolean found_idat = FALSE;
3434   guint64 offset = 0;
3435   guint rounds = 0;
3436 
3437   while ((data = gst_type_find_peek (tf, offset, 8)) != NULL) {
3438     guint64 size;
3439 
3440     size = GST_READ_UINT32_BE (data);
3441     if (size == 1) {
3442       const guint8 *sizedata;
3443 
3444       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3445       if (sizedata == NULL)
3446         break;
3447 
3448       size = GST_READ_UINT64_BE (sizedata);
3449     }
3450     if (size &lt; 8)
3451       break;
3452 
3453     if (STRNCMP (data + 4, &quot;idsc&quot;, 4) == 0)
3454       found_idsc = TRUE;
3455     if (STRNCMP (data + 4, &quot;idat&quot;, 4) == 0)
3456       found_idat = TRUE;
3457 
3458     if (found_idsc &amp;&amp; found_idat) {
3459       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, QTIF_CAPS);
3460       return;
3461     }
3462 
3463     offset += size;
3464     if (offset + 8 &gt;= G_MAXINT64)
3465       break;
3466     if (++rounds &gt; QTIF_MAXROUNDS)
3467       break;
3468   }
3469 
3470   if (found_idsc || found_idat) {
3471     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, QTIF_CAPS);
3472     return;
3473   }
3474 };
3475 
3476 /*** audio/x-mod ***/
3477 
3478 static GstStaticCaps mod_caps = GST_STATIC_CAPS (&quot;audio/x-mod&quot;);
3479 
3480 #define MOD_CAPS gst_static_caps_get(&amp;mod_caps)
3481 /* FIXME: M15 CheckType to do */
3482 static void
3483 mod_type_find (GstTypeFind * tf, gpointer unused)
3484 {
3485   const guint8 *data;
3486   GstTypeFindProbability probability;
3487   const char *mod_type = NULL;
3488 
3489   /* MOD */
3490   if ((data = gst_type_find_peek (tf, 1080, 4)) != NULL) {
3491     /* Protracker and variants */
3492     if ((memcmp (data, &quot;M.K.&quot;, 4) == 0) ||
3493         (memcmp (data, &quot;M!K!&quot;, 4) == 0) ||
3494         (memcmp (data, &quot;M&amp;K!&quot;, 4) == 0) || (memcmp (data, &quot;N.T.&quot;, 4) == 0) ||
3495         /* Star Tracker */
3496         (memcmp (data, &quot;FLT&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3497         (memcmp (data, &quot;EXO&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3498         /* Oktalyzer (Amiga) */
3499         (memcmp (data, &quot;OKTA&quot;, 4) == 0) || (memcmp (data, &quot;OCTA&quot;, 4) == 0) ||
3500         /* Oktalyser (Atari) */
3501         (memcmp (data, &quot;CD81&quot;, 4) == 0) ||
3502         /* Taketracker */
3503         (memcmp (data, &quot;TDZ&quot;, 3) == 0 &amp;&amp; isdigit (data[3])) ||
3504         /* Fasttracker */
3505         (memcmp (data + 1, &quot;CHN&quot;, 3) == 0 &amp;&amp; isdigit (data[0])) ||
3506         /* Fasttracker or Taketracker */
3507         (memcmp (data + 2, &quot;CH&quot;, 2) == 0 &amp;&amp; isdigit (data[0])
3508             &amp;&amp; isdigit (data[1])) || (memcmp (data + 2, &quot;CN&quot;, 2) == 0
3509             &amp;&amp; isdigit (data[0]) &amp;&amp; isdigit (data[1]))) {
3510       mod_type = &quot;mod&quot;;
3511       probability = GST_TYPE_FIND_MAXIMUM;
3512       goto suggest_audio_mod_caps;
3513     }
3514   }
3515   /* J2B (Jazz Jackrabbit 2) */
3516   if ((data = gst_type_find_peek (tf, 0, 8)) != NULL) {
3517     if ((memcmp (data, &quot;MUSE\xDE\xAD&quot;, 4) == 0) &amp;&amp;
3518         ((memcmp (data + 6, &quot;\xBE\xEF&quot;, 2) == 0) ||
3519             (memcmp (data + 6, &quot;\xBA\xBE&quot;, 2) == 0))) {
3520       mod_type = &quot;j2b&quot;;
3521       probability = GST_TYPE_FIND_MAXIMUM;
3522       goto suggest_audio_mod_caps;
3523     }
3524   }
3525   /* AMS (Velvet Studio) */
3526   if ((data = gst_type_find_peek (tf, 0, 7)) != NULL) {
3527     if (memcmp (data, &quot;AMShdr\x1A&quot;, 7) == 0) {
3528       mod_type = &quot;velvet-ams&quot;;
3529       probability = GST_TYPE_FIND_MAXIMUM;
3530       goto suggest_audio_mod_caps;
3531     }
3532   }
3533   /* AMS (Extreme Tracker) */
3534   if ((data = gst_type_find_peek (tf, 0, 9)) != NULL) {
3535     if ((memcmp (data, &quot;Extreme&quot;, 7) == 0) &amp;&amp; (data[8] == 1)) {
3536       mod_type = &quot;extreme-ams&quot;;
3537       probability = GST_TYPE_FIND_LIKELY;
3538       goto suggest_audio_mod_caps;
3539     }
3540   }
3541   /* ULT (Ultratracker) */
3542   if ((data = gst_type_find_peek (tf, 0, 14)) != NULL) {
3543     if (memcmp (data, &quot;MAS_UTrack_V00&quot;, 14) == 0) {
3544       mod_type = &quot;ult&quot;;
3545       probability = GST_TYPE_FIND_MAXIMUM;
3546       goto suggest_audio_mod_caps;
3547     }
3548   }
3549   /* DIGI (DigiBooster) */
3550   if ((data = gst_type_find_peek (tf, 0, 20)) != NULL) {
3551     if (memcmp (data, &quot;DIGI Booster module\0&quot;, 20) == 0) {
3552       mod_type = &quot;digi&quot;;
3553       probability = GST_TYPE_FIND_MAXIMUM;
3554       goto suggest_audio_mod_caps;
3555     }
3556   }
3557   /* PTM (PolyTracker) */
3558   if ((data = gst_type_find_peek (tf, 0x2C, 4)) != NULL) {
3559     if (memcmp (data, &quot;PTMF&quot;, 4) == 0) {
3560       mod_type = &quot;ptm&quot;;
3561       probability = GST_TYPE_FIND_LIKELY;
3562       goto suggest_audio_mod_caps;
3563     }
3564   }
3565   /* XM */
3566   if ((data = gst_type_find_peek (tf, 0, 38)) != NULL) {
3567     if ((memcmp (data, &quot;Extended Module: &quot;, 17) == 0) &amp;&amp; (data[37] == 0x1A)) {
3568       mod_type = &quot;xm&quot;;
3569       probability = GST_TYPE_FIND_MAXIMUM;
3570       goto suggest_audio_mod_caps;
3571     }
3572   }
3573   /* OKT */
3574   if (data || (data = gst_type_find_peek (tf, 0, 8)) != NULL) {
3575     if (memcmp (data, &quot;OKTASONG&quot;, 8) == 0) {
3576       mod_type = &quot;okt&quot;;
3577       probability = GST_TYPE_FIND_MAXIMUM;
3578       goto suggest_audio_mod_caps;
3579     }
3580   }
3581   /* Various formats with a 4-byte magic ID at the beginning of the file */
3582   if (data || (data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3583     /* PSM (Protracker Studio PSM) */
3584     if (memcmp (data, &quot;PSM&quot;, 3) == 0) {
3585       unsigned char fbyte = data[3];
3586       if ((fbyte == &#39; &#39;) || (fbyte == 254)) {
3587         mod_type = &quot;psm&quot;;
3588         probability = GST_TYPE_FIND_MAXIMUM;
3589         goto suggest_audio_mod_caps;
3590       }
3591     }
3592     /* 669 */
3593     if ((memcmp (data, &quot;if&quot;, 2) == 0) || (memcmp (data, &quot;JN&quot;, 2) == 0)) {
3594       mod_type = &quot;669&quot;;
3595       probability = GST_TYPE_FIND_LIKELY;
3596       goto suggest_audio_mod_caps;
3597     }
3598     /* AMF */
3599     if ((memcmp (data, &quot;AMF&quot;, 3) == 0) &amp;&amp; (data[3] &gt; 10) &amp;&amp; (data[3] &lt; 14)) {
3600       mod_type = &quot;dsmi-amf&quot;;
3601       probability = GST_TYPE_FIND_MAXIMUM;
3602       goto suggest_audio_mod_caps;
3603     }
<a name="20" id="anc20"></a><span class="line-modified">3604         /* IT */</span>
3605     if (memcmp (data, &quot;IMPM&quot;, 4) == 0) {
3606       mod_type = &quot;it&quot;;
3607       probability = GST_TYPE_FIND_MAXIMUM;
3608       goto suggest_audio_mod_caps;
3609     }
3610     /* DBM (DigiBooster Pro) */
3611     if (memcmp (data, &quot;DBM0&quot;, 4) == 0) {
3612       mod_type = &quot;dbm&quot;;
3613       probability = GST_TYPE_FIND_MAXIMUM;
3614       goto suggest_audio_mod_caps;
3615     }
3616     /* MDL (DigiTrakker) */
3617     if (memcmp (data, &quot;DMDL&quot;, 4) == 0) {
3618       mod_type = &quot;mdl&quot;;
3619       probability = GST_TYPE_FIND_MAXIMUM;
3620       goto suggest_audio_mod_caps;
3621     }
3622     /* MT2 (MadTracker 2.0) */
3623     if (memcmp (data, &quot;MT20&quot;, 4) == 0) {
3624       mod_type = &quot;mt2&quot;;
3625       probability = GST_TYPE_FIND_MAXIMUM;
3626       goto suggest_audio_mod_caps;
3627     }
3628     /* DMF (X-Tracker) */
3629     if (memcmp (data, &quot;DDMF&quot;, 4) == 0) {
3630       mod_type = &quot;dmf&quot;;
3631       probability = GST_TYPE_FIND_MAXIMUM;
3632       goto suggest_audio_mod_caps;
3633     }
<a name="21" id="anc21"></a><span class="line-modified">3634         /* MED */</span>
3635     if ((memcmp (data, &quot;MMD0&quot;, 4) == 0) || (memcmp (data, &quot;MMD1&quot;, 4) == 0)) {
3636       mod_type = &quot;med&quot;;
3637       probability = GST_TYPE_FIND_MAXIMUM;
3638       goto suggest_audio_mod_caps;
3639     }
<a name="22" id="anc22"></a><span class="line-modified">3640         /* MTM */</span>
3641     if (memcmp (data, &quot;MTM&quot;, 3) == 0) {
3642       mod_type = &quot;mtm&quot;;
3643       probability = GST_TYPE_FIND_MAXIMUM;
3644       goto suggest_audio_mod_caps;
3645     }
3646     /* DSM */
3647     if (memcmp (data, &quot;RIFF&quot;, 4) == 0) {
3648       const guint8 *data2 = gst_type_find_peek (tf, 8, 4);
3649 
3650       if (data2) {
3651         if (memcmp (data2, &quot;DSMF&quot;, 4) == 0) {
3652           mod_type = &quot;dsm&quot;;
3653           probability = GST_TYPE_FIND_MAXIMUM;
3654           goto suggest_audio_mod_caps;
3655         }
3656       }
3657     }
3658     /* FAR (Farandole) */
3659     if (memcmp (data, &quot;FAR\xFE&quot;, 4) == 0) {
3660       mod_type = &quot;far&quot;;
3661       probability = GST_TYPE_FIND_MAXIMUM;
3662       goto suggest_audio_mod_caps;
3663     }
3664     /* FAM */
3665     if (memcmp (data, &quot;FAM\xFE&quot;, 4) == 0) {
3666       const guint8 *data2 = gst_type_find_peek (tf, 44, 3);
3667 
3668       if (data2) {
3669         if (memcmp (data2, &quot;compare&quot;, 3) == 0) {
3670           mod_type = &quot;fam&quot;;
3671           probability = GST_TYPE_FIND_MAXIMUM;
3672           goto suggest_audio_mod_caps;
3673         }
3674         /* otherwise do not suggest anything */
3675       } else {
3676         mod_type = &quot;fam&quot;;
3677         probability = GST_TYPE_FIND_LIKELY;
3678         goto suggest_audio_mod_caps;
3679       }
3680     }
3681     /* GDM */
3682     if (memcmp (data, &quot;GDM\xFE&quot;, 4) == 0) {
3683       const guint8 *data2 = gst_type_find_peek (tf, 71, 4);
3684 
3685       if (data2) {
3686         if (memcmp (data2, &quot;GMFS&quot;, 4) == 0) {
3687           mod_type = &quot;gdm&quot;;
3688           probability = GST_TYPE_FIND_MAXIMUM;
3689           goto suggest_audio_mod_caps;
3690         }
3691         /* otherwise do not suggest anything */
3692       } else {
3693         mod_type = &quot;gdm&quot;;
3694         probability = GST_TYPE_FIND_LIKELY;
3695         goto suggest_audio_mod_caps;
3696       }
3697     }
3698     /* UMX */
3699     if (memcmp (data, &quot;\xC1\x83\x2A\x9E&quot;, 4) == 0) {
3700       mod_type = &quot;umx&quot;;
3701       probability = GST_TYPE_FIND_POSSIBLE;
3702       goto suggest_audio_mod_caps;
<a name="23" id="anc23"></a><span class="line-modified">3703   }</span>
3704   }
3705   /* FAR (Farandole) (secondary detection) */
3706   if ((data = gst_type_find_peek (tf, 44, 3)) != NULL) {
3707     if (memcmp (data, &quot;\x0D\x0A\x1A&quot;, 3) == 0) {
3708       mod_type = &quot;far&quot;;
3709       probability = GST_TYPE_FIND_POSSIBLE;
3710       goto suggest_audio_mod_caps;
3711     }
3712   }
3713   /* IMF */
3714   if ((data = gst_type_find_peek (tf, 60, 4)) != NULL) {
3715     if (memcmp (data, &quot;IM10&quot;, 4) == 0) {
3716       mod_type = &quot;imf&quot;;
3717       probability = GST_TYPE_FIND_MAXIMUM;
3718       goto suggest_audio_mod_caps;
3719     }
3720   }
3721   /* S3M */
3722   if ((data = gst_type_find_peek (tf, 44, 4)) != NULL) {
3723     if (memcmp (data, &quot;SCRM&quot;, 4) == 0) {
3724       mod_type = &quot;s3m&quot;;
3725       probability = GST_TYPE_FIND_MAXIMUM;
3726       goto suggest_audio_mod_caps;
3727     }
3728   }
3729   /* STM */
3730   if ((data = gst_type_find_peek (tf, 20, 8)) != NULL) {
3731     if (g_ascii_strncasecmp ((gchar *) data, &quot;!Scream!&quot;, 8) == 0 ||
3732         g_ascii_strncasecmp ((gchar *) data, &quot;BMOD2STM&quot;, 8) == 0) {
3733       const guint8 *id, *stmtype;
3734 
3735       if ((id = gst_type_find_peek (tf, 28, 1)) == NULL)
3736         return;
3737       if ((stmtype = gst_type_find_peek (tf, 29, 1)) == NULL)
3738         return;
3739       if (*id == 0x1A &amp;&amp; *stmtype == 2) {
3740         mod_type = &quot;stm&quot;;
3741         probability = GST_TYPE_FIND_MAXIMUM;
3742         goto suggest_audio_mod_caps;
3743       }
3744     }
3745   }
3746   /* AMF */
3747   if ((data = gst_type_find_peek (tf, 0, 19)) != NULL) {
3748     if (memcmp (data, &quot;ASYLUM Music Format&quot;, 19) == 0) {
3749       mod_type = &quot;asylum-amf&quot;;
3750       probability = GST_TYPE_FIND_MAXIMUM;
3751       goto suggest_audio_mod_caps;
3752     }
3753   }
3754 
3755 suggest_audio_mod_caps:
3756   if (mod_type != NULL) {
3757     GstCaps *caps = gst_caps_new_simple (&quot;audio/x-mod&quot;,
3758         &quot;type&quot;, G_TYPE_STRING, mod_type, NULL);
3759 
3760     gst_type_find_suggest (tf, probability, caps);
3761     gst_caps_unref (caps);
3762   }
3763 }
3764 
3765 /*** application/x-shockwave-flash ***/
3766 
3767 static GstStaticCaps swf_caps =
3768 GST_STATIC_CAPS (&quot;application/x-shockwave-flash&quot;);
3769 #define SWF_CAPS (gst_static_caps_get(&amp;swf_caps))
3770 static void
3771 swf_type_find (GstTypeFind * tf, gpointer unused)
3772 {
3773   const guint8 *data = gst_type_find_peek (tf, 0, 4);
3774 
3775   if (data &amp;&amp; (data[0] == &#39;F&#39; || data[0] == &#39;C&#39;) &amp;&amp;
3776       data[1] == &#39;W&#39; &amp;&amp; data[2] == &#39;S&#39;) {
3777     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SWF_CAPS);
3778   }
3779 }
3780 
3781 /*** application/vnd.ms-sstr+xml ***/
3782 
3783 static void
3784 mss_manifest_load_utf16 (gunichar2 * utf16_ne, const guint8 * utf16_data,
3785     gsize data_size, guint data_endianness)
3786 {
3787   memcpy (utf16_ne, utf16_data, data_size);
3788   if (data_endianness != G_BYTE_ORDER) {
3789     guint i;
3790 
3791     for (i = 0; i &lt; data_size / 2; ++i)
3792       utf16_ne[i] = GUINT16_SWAP_LE_BE (utf16_ne[i]);
3793   }
3794 }
3795 
3796 static GstStaticCaps mss_manifest_caps =
3797 GST_STATIC_CAPS (&quot;application/vnd.ms-sstr+xml&quot;);
3798 #define MSS_MANIFEST_CAPS (gst_static_caps_get(&amp;mss_manifest_caps))
3799 static void
3800 mss_manifest_type_find (GstTypeFind * tf, gpointer unused)
3801 {
3802   gunichar2 utf16_ne[512];
3803   const guint8 *data;
3804   guint data_endianness = 0;
3805   glong n_read = 0, size = 0;
3806   guint length;
3807   gchar *utf8;
3808   gboolean utf8_bom_detected = FALSE;
3809 
3810   if (xml_check_first_element (tf, &quot;SmoothStreamingMedia&quot;, 20, TRUE)) {
3811     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3812     return;
3813   }
3814 
3815   length = gst_type_find_get_length (tf);
3816 
<a name="24" id="anc24"></a><span class="line-modified">3817     /* try detecting the charset */</span>
3818   data = gst_type_find_peek (tf, 0, 3);
3819 
<a name="25" id="anc25"></a><span class="line-modified">3820     if (data == NULL)</span>
<span class="line-modified">3821       return;</span>
3822 
<a name="26" id="anc26"></a><span class="line-modified">3823     /* look for a possible BOM */</span>
3824   if (data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF)
3825     utf8_bom_detected = TRUE;
3826   else if (data[0] == 0xFF &amp;&amp; data[1] == 0xFE)
3827     data_endianness = G_LITTLE_ENDIAN;
3828   else if (data[0] == 0xFE &amp;&amp; data[1] == 0xFF)
3829     data_endianness = G_BIG_ENDIAN;
3830   else
3831     return;
3832 
<a name="27" id="anc27"></a><span class="line-modified">3833       /* try a default that should be enough */</span>
<span class="line-modified">3834       if (length == 0)</span>
<span class="line-modified">3835         length = 512;</span>
3836   else if (length &lt; 64)
3837     return;
3838   else                          /* the first few bytes should be enough */
3839     length = MIN (1024, length);
3840 
<a name="28" id="anc28"></a><span class="line-modified">3841       data = gst_type_find_peek (tf, 0, length);</span>
3842 
3843   if (data == NULL)
3844     return;
3845 
<a name="29" id="anc29"></a><span class="line-modified">3846         /* skip the BOM */</span>
<span class="line-modified">3847         data += 2;</span>
<span class="line-modified">3848         length -= 2;</span>
3849 
3850   if (utf8_bom_detected) {
3851     /* skip last byte of the BOM */
3852     data++;
3853     length--;
3854 
3855     if (xml_check_first_element_from_data (data, length,
<a name="30" id="anc30"></a><span class="line-modified">3856                   &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
3857       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3858   } else {
3859     length = GST_ROUND_DOWN_2 (length);
3860 
3861     /* convert to native endian UTF-16 */
3862     mss_manifest_load_utf16 (utf16_ne, data, length, data_endianness);
3863 
3864     /* and now convert to UTF-8 */
3865     utf8 = g_utf16_to_utf8 (utf16_ne, length / 2, &amp;n_read, &amp;size, NULL);
3866     if (utf8 != NULL &amp;&amp; n_read &gt; 0) {
3867       if (xml_check_first_element_from_data ((const guint8 *) utf8, size,
3868               &quot;SmoothStreamingMedia&quot;, 20, TRUE))
3869         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
<a name="31" id="anc31"></a><span class="line-removed">3870         }</span>
<span class="line-removed">3871     g_free (utf8);</span>
<span class="line-removed">3872       }</span>
3873     }
<a name="32" id="anc32"></a>


3874 
3875 /*** image/jpeg ***/
3876 
3877 #define JPEG_MARKER_IS_START_OF_FRAME(x) \
3878     ((x)&gt;=0xc0 &amp;&amp; (x) &lt;= 0xcf &amp;&amp; (x)!=0xc4 &amp;&amp; (x)!=0xc8 &amp;&amp; (x)!=0xcc)
3879 
3880 static GstStaticCaps jpeg_caps = GST_STATIC_CAPS (&quot;image/jpeg&quot;);
3881 
3882 #define JPEG_CAPS (gst_static_caps_get(&amp;jpeg_caps))
3883 static void
3884 jpeg_type_find (GstTypeFind * tf, gpointer unused)
3885 {
3886   GstTypeFindProbability prob = GST_TYPE_FIND_POSSIBLE;
3887   DataScanCtx c = { 0, NULL, 0 };
3888   GstCaps *caps;
3889   guint num_markers;
3890 
3891   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 2)))
3892     return;
3893 
3894   if (c.data[0] != 0xff || c.data[1] != 0xd8)
3895     return;
3896 
3897   num_markers = 1;
3898   data_scan_ctx_advance (tf, &amp;c, 2);
3899 
3900   caps = gst_caps_copy (JPEG_CAPS);
3901 
3902   while (data_scan_ctx_ensure_data (tf, &amp;c, 4) &amp;&amp; c.offset &lt; (200 * 1024)) {
3903     guint16 len;
3904     guint8 marker;
3905 
3906     if (c.data[0] != 0xff)
3907       break;
3908 
3909     marker = c.data[1];
3910     if (G_UNLIKELY (marker == 0xff)) {
3911       data_scan_ctx_advance (tf, &amp;c, 1);
3912       continue;
3913     }
3914 
3915     data_scan_ctx_advance (tf, &amp;c, 2);
3916 
3917     /* we assume all markers we&#39;ll see before SOF have a payload length; if
3918      * that&#39;s not the case we&#39;ll just detect a false sync and bail out, but
3919      * still report POSSIBLE probability */
3920     len = GST_READ_UINT16_BE (c.data);
3921 
3922     GST_LOG (&quot;possible JPEG marker 0x%02x (@0x%04x), segment length %u&quot;,
3923         marker, (guint) c.offset, len);
3924 
3925     if (!data_scan_ctx_ensure_data (tf, &amp;c, len))
3926       break;
3927 
3928     if (marker == 0xc4 ||       /* DEFINE_HUFFMAN_TABLES          */
3929         marker == 0xcc ||       /* DEFINE_ARITHMETIC_CONDITIONING */
3930         marker == 0xdb ||       /* DEFINE_QUANTIZATION_TABLES     */
3931         marker == 0xdd ||       /* DEFINE_RESTART_INTERVAL        */
3932         marker == 0xfe) {       /* COMMENT                        */
3933       data_scan_ctx_advance (tf, &amp;c, len);
3934       ++num_markers;
3935     } else if (marker == 0xe0 &amp;&amp; len &gt;= (2 + 4) &amp;&amp;      /* APP0 */
3936         data_scan_ctx_memcmp (tf, &amp;c, 2, &quot;JFIF&quot;, 4)) {
3937       GST_LOG (&quot;found JFIF tag&quot;);
3938       prob = GST_TYPE_FIND_MAXIMUM;
3939       data_scan_ctx_advance (tf, &amp;c, len);
3940       ++num_markers;
3941       /* we continue until we find a start of frame marker */
3942     } else if (marker == 0xe1 &amp;&amp; len &gt;= (2 + 4) &amp;&amp;      /* APP1 */
3943         data_scan_ctx_memcmp (tf, &amp;c, 2, &quot;Exif&quot;, 4)) {
3944       GST_LOG (&quot;found Exif tag&quot;);
3945       prob = GST_TYPE_FIND_MAXIMUM;
3946       data_scan_ctx_advance (tf, &amp;c, len);
3947       ++num_markers;
3948       /* we continue until we find a start of frame marker */
3949     } else if (marker &gt;= 0xe0 &amp;&amp; marker &lt;= 0xef) {      /* APPn */
3950       data_scan_ctx_advance (tf, &amp;c, len);
3951       ++num_markers;
3952     } else if (JPEG_MARKER_IS_START_OF_FRAME (marker) &amp;&amp; len &gt;= (2 + 8)) {
3953       int h, w;
3954 
3955       h = GST_READ_UINT16_BE (c.data + 2 + 1);
3956       w = GST_READ_UINT16_BE (c.data + 2 + 1 + 2);
3957       if (h == 0 || w == 0) {
3958         GST_WARNING (&quot;bad width %u and/or height %u in SOF header&quot;, w, h);
3959         break;
3960       }
3961 
3962       GST_LOG (&quot;SOF at offset %&quot; G_GUINT64_FORMAT &quot;, num_markers=%d, &quot;
3963           &quot;WxH=%dx%d&quot;, c.offset - 2, num_markers, w, h);
3964 
3965       if (num_markers &gt;= 5 || prob == GST_TYPE_FIND_MAXIMUM)
3966         prob = GST_TYPE_FIND_MAXIMUM;
3967       else
3968         prob = GST_TYPE_FIND_LIKELY;
3969 
3970       gst_caps_set_simple (caps, &quot;width&quot;, G_TYPE_INT, w,
3971           &quot;height&quot;, G_TYPE_INT, h, &quot;sof-marker&quot;, G_TYPE_INT, marker &amp; 0xf,
3972           NULL);
3973 
3974       break;
3975     } else {
3976       GST_WARNING (&quot;bad length or unexpected JPEG marker 0xff 0x%02x&quot;, marker);
3977       break;
3978     }
3979   }
3980 
3981   gst_type_find_suggest (tf, prob, caps);
3982   gst_caps_unref (caps);
3983 }
3984 
3985 /*** image/bmp ***/
3986 
3987 static GstStaticCaps bmp_caps = GST_STATIC_CAPS (&quot;image/bmp&quot;);
3988 
3989 #define BMP_CAPS (gst_static_caps_get(&amp;bmp_caps))
3990 static void
3991 bmp_type_find (GstTypeFind * tf, gpointer unused)
3992 {
3993   DataScanCtx c = { 0, NULL, 0 };
3994   guint32 struct_size, w, h, planes, bpp;
3995 
3996   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 54)))
3997     return;
3998 
3999   if (c.data[0] != &#39;B&#39; || c.data[1] != &#39;M&#39;)
4000     return;
4001 
4002   /* skip marker + size */
4003   data_scan_ctx_advance (tf, &amp;c, 2 + 4);
4004 
4005   /* reserved, must be 0 */
4006   if (c.data[0] != 0 || c.data[1] != 0 || c.data[2] != 0 || c.data[3] != 0)
4007     return;
4008 
4009   data_scan_ctx_advance (tf, &amp;c, 2 + 2);
4010 
4011   /* offset to start of image data in bytes (check for sanity) */
4012   GST_LOG (&quot;offset=%u&quot;, GST_READ_UINT32_LE (c.data));
4013   if (GST_READ_UINT32_LE (c.data) &gt; (10 * 1024 * 1024))
4014     return;
4015 
4016   struct_size = GST_READ_UINT32_LE (c.data + 4);
4017   GST_LOG (&quot;struct_size=%u&quot;, struct_size);
4018 
4019   data_scan_ctx_advance (tf, &amp;c, 4 + 4);
4020 
4021   if (struct_size == 0x0C) {
4022     w = GST_READ_UINT16_LE (c.data);
4023     h = GST_READ_UINT16_LE (c.data + 2);
4024     planes = GST_READ_UINT16_LE (c.data + 2 + 2);
4025     bpp = GST_READ_UINT16_LE (c.data + 2 + 2 + 2);
4026   } else if (struct_size == 40 || struct_size == 64 || struct_size == 108
4027       || struct_size == 124 || struct_size == 0xF0) {
4028     w = GST_READ_UINT32_LE (c.data);
4029     h = GST_READ_UINT32_LE (c.data + 4);
4030     planes = GST_READ_UINT16_LE (c.data + 4 + 4);
4031     bpp = GST_READ_UINT16_LE (c.data + 4 + 4 + 2);
4032   } else {
4033     return;
4034   }
4035 
4036   /* image sizes sanity check */
4037   GST_LOG (&quot;w=%u, h=%u, planes=%u, bpp=%u&quot;, w, h, planes, bpp);
4038   if (w == 0 || w &gt; 0xfffff || h == 0 || h &gt; 0xfffff || planes != 1 ||
4039       (bpp != 1 &amp;&amp; bpp != 4 &amp;&amp; bpp != 8 &amp;&amp; bpp != 16 &amp;&amp; bpp != 24 &amp;&amp; bpp != 32))
4040     return;
4041 
4042   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, &quot;image/bmp&quot;,
4043       &quot;width&quot;, G_TYPE_INT, w, &quot;height&quot;, G_TYPE_INT, h, &quot;bpp&quot;, G_TYPE_INT, bpp,
4044       NULL);
4045 }
4046 
4047 /*** image/tiff ***/
4048 static GstStaticCaps tiff_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4049     &quot;endianness = (int) { BIG_ENDIAN, LITTLE_ENDIAN }&quot;);
4050 #define TIFF_CAPS (gst_static_caps_get(&amp;tiff_caps))
4051 static GstStaticCaps tiff_be_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4052     &quot;endianness = (int) BIG_ENDIAN&quot;);
4053 #define TIFF_BE_CAPS (gst_static_caps_get(&amp;tiff_be_caps))
4054 static GstStaticCaps tiff_le_caps = GST_STATIC_CAPS (&quot;image/tiff, &quot;
4055     &quot;endianness = (int) LITTLE_ENDIAN&quot;);
4056 #define TIFF_LE_CAPS (gst_static_caps_get(&amp;tiff_le_caps))
4057 static void
4058 tiff_type_find (GstTypeFind * tf, gpointer ununsed)
4059 {
4060   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4061   guint8 le_header[4] = { 0x49, 0x49, 0x2A, 0x00 };
4062   guint8 be_header[4] = { 0x4D, 0x4D, 0x00, 0x2A };
4063 
4064   if (data) {
4065     if (memcmp (data, le_header, 4) == 0) {
4066       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TIFF_LE_CAPS);
4067     } else if (memcmp (data, be_header, 4) == 0) {
4068       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TIFF_BE_CAPS);
4069     }
4070   }
4071 }
4072 
4073 /*** image/x-exr ***/
4074 static GstStaticCaps exr_caps = GST_STATIC_CAPS (&quot;image/x-exr&quot;);
4075 #define EXR_CAPS (gst_static_caps_get(&amp;exr_caps))
4076 static void
4077 exr_type_find (GstTypeFind * tf, gpointer ununsed)
4078 {
4079   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4080 
4081   if (data) {
4082     guint32 flags;
4083 
4084     if (GST_READ_UINT32_LE (data) != 0x01312f76)
4085       return;
4086 
4087     flags = GST_READ_UINT32_LE (data + 4);
4088     if ((flags &amp; 0xff) != 1 &amp;&amp; (flags &amp; 0xff) != 2)
4089       return;
4090 
4091     /* If bit 9 is set, bit 11 and 12 must be 0 */
4092     if ((flags &amp; 0x200) &amp;&amp; (flags &amp; 0x1800))
4093       return;
4094 
4095     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, EXR_CAPS);
4096   }
4097 }
4098 
4099 
4100 /*** PNM ***/
4101 
4102 static GstStaticCaps pnm_caps = GST_STATIC_CAPS (&quot;image/x-portable-bitmap; &quot;
4103     &quot;image/x-portable-graymap; image/x-portable-pixmap; &quot;
4104     &quot;image/x-portable-anymap&quot;);
4105 
4106 #define PNM_CAPS (gst_static_caps_get(&amp;pnm_caps))
4107 
4108 #define IS_PNM_WHITESPACE(c) \
4109     ((c) == &#39; &#39; || (c) == &#39;\r&#39; || (c) == &#39;\n&#39; || (c) == &#39;t&#39;)
4110 
4111 static void
4112 pnm_type_find (GstTypeFind * tf, gpointer ununsed)
4113 {
4114   const gchar *media_type = NULL;
4115   DataScanCtx c = { 0, NULL, 0 };
4116   guint h = 0, w = 0;
4117 
4118   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 16)))
4119     return;
4120 
4121   /* see http://en.wikipedia.org/wiki/Netpbm_format */
4122   if (c.data[0] != &#39;P&#39; || c.data[1] &lt; &#39;1&#39; || c.data[1] &gt; &#39;7&#39; ||
4123       !IS_PNM_WHITESPACE (c.data[2]) ||
4124       (c.data[3] != &#39;#&#39; &amp;&amp; c.data[3] &lt; &#39;0&#39; &amp;&amp; c.data[3] &gt; &#39;9&#39;))
4125     return;
4126 
4127   switch (c.data[1]) {
4128     case &#39;1&#39;:
4129       media_type = &quot;image/x-portable-bitmap&quot;;   /* ASCII */
4130       break;
4131     case &#39;2&#39;:
4132       media_type = &quot;image/x-portable-graymap&quot;;  /* ASCII */
4133       break;
4134     case &#39;3&#39;:
4135       media_type = &quot;image/x-portable-pixmap&quot;;   /* ASCII */
4136       break;
4137     case &#39;4&#39;:
4138       media_type = &quot;image/x-portable-bitmap&quot;;   /* Raw */
4139       break;
4140     case &#39;5&#39;:
4141       media_type = &quot;image/x-portable-graymap&quot;;  /* Raw */
4142       break;
4143     case &#39;6&#39;:
4144       media_type = &quot;image/x-portable-pixmap&quot;;   /* Raw */
4145       break;
4146     case &#39;7&#39;:
4147       media_type = &quot;image/x-portable-anymap&quot;;
4148       break;
4149     default:
4150       g_return_if_reached ();
4151   }
4152 
4153   /* try to extract width and height as well */
4154   if (c.data[1] != &#39;7&#39;) {
4155     gchar s[64] = { 0, }
4156     , sep1, sep2;
4157 
4158     /* need to skip any comment lines first */
4159     data_scan_ctx_advance (tf, &amp;c, 3);
4160 
4161     if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4162       return;
4163 
4164     while (c.data[0] == &#39;#&#39;) {  /* we know there&#39;s still data left */
4165       data_scan_ctx_advance (tf, &amp;c, 1);
4166       if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4167         return;
4168 
4169       while (c.data[0] != &#39;\n&#39; &amp;&amp; c.data[0] != &#39;\r&#39;) {
4170         data_scan_ctx_advance (tf, &amp;c, 1);
4171         if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4172           return;
4173       }
4174       data_scan_ctx_advance (tf, &amp;c, 1);
4175       GST_LOG (&quot;skipped comment line in PNM header&quot;);
4176       if (!data_scan_ctx_ensure_data (tf, &amp;c, 1))
4177         return;
4178     }
4179 
4180     if (!data_scan_ctx_ensure_data (tf, &amp;c, 32) &amp;&amp;
4181         !data_scan_ctx_ensure_data (tf, &amp;c, 4)) {
4182       return;
4183     }
4184 
4185     /* need to NUL-terminate data for sscanf */
4186     memcpy (s, c.data, MIN (sizeof (s) - 1, c.size));
4187     if (sscanf (s, &quot;%u%c%u%c&quot;, &amp;w, &amp;sep1, &amp;h, &amp;sep2) == 4 &amp;&amp;
4188         IS_PNM_WHITESPACE (sep1) &amp;&amp; IS_PNM_WHITESPACE (sep2) &amp;&amp;
4189         w &gt; 0 &amp;&amp; w &lt; G_MAXINT &amp;&amp; h &gt; 0 &amp;&amp; h &lt; G_MAXINT) {
4190       GST_LOG (&quot;extracted PNM width and height: %dx%d&quot;, w, h);
4191     } else {
4192       w = 0;
4193       h = 0;
4194     }
4195   } else {
4196     /* FIXME: extract width + height for anymaps too */
4197   }
4198 
4199   if (w &gt; 0 &amp;&amp; h &gt; 0) {
4200     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, media_type,
4201         &quot;width&quot;, G_TYPE_INT, w, &quot;height&quot;, G_TYPE_INT, h, NULL);
4202   } else {
4203     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, media_type, NULL);
4204   }
4205 }
4206 
4207 static GstStaticCaps sds_caps = GST_STATIC_CAPS (&quot;audio/x-sds&quot;);
4208 
4209 #define SDS_CAPS (gst_static_caps_get(&amp;sds_caps))
4210 static void
4211 sds_type_find (GstTypeFind * tf, gpointer ununsed)
4212 {
4213   const guint8 *data = gst_type_find_peek (tf, 0, 4);
4214   guint8 mask[4] = { 0xFF, 0xFF, 0x80, 0xFF };
4215   guint8 match[4] = { 0xF0, 0x7E, 0, 0x01 };
4216   gint x;
4217 
4218   if (data) {
4219     for (x = 0; x &lt; 4; x++) {
4220       if ((data[x] &amp; mask[x]) != match[x]) {
4221         return;
4222       }
4223     }
4224     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SDS_CAPS);
4225   }
4226 }
4227 
4228 static GstStaticCaps ircam_caps = GST_STATIC_CAPS (&quot;audio/x-ircam&quot;);
4229 
4230 #define IRCAM_CAPS (gst_static_caps_get(&amp;ircam_caps))
4231 static void
4232 ircam_type_find (GstTypeFind * tf, gpointer ununsed)
4233 {
4234   const guint8 *data = gst_type_find_peek (tf, 0, 4);
4235   guint8 mask[4] = { 0xFF, 0xFF, 0xF8, 0xFF };
4236   guint8 match[4] = { 0x64, 0xA3, 0x00, 0x00 };
4237   gint x;
4238   gboolean matched = TRUE;
4239 
4240   if (!data) {
4241     return;
4242   }
4243   for (x = 0; x &lt; 4; x++) {
4244     if ((data[x] &amp; mask[x]) != match[x]) {
4245       matched = FALSE;
4246     }
4247   }
4248   if (matched) {
4249     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, IRCAM_CAPS);
4250     return;
4251   }
4252   /* now try the reverse version */
4253   matched = TRUE;
4254   for (x = 0; x &lt; 4; x++) {
4255     if ((data[x] &amp; mask[3 - x]) != match[3 - x]) {
4256       matched = FALSE;
4257     }
4258   }
4259 }
4260 
4261 /*** Matroska/WebM ***/
4262 
4263 #define EBML_HEADER           0x1A45DFA3
4264 #define EBML_VERSION          0x4286
4265 #define EBML_DOCTYPE          0x4282
4266 #define EBML_DOCTYPE_VERSION  0x4287
4267 #define MATROSKA_SEGMENT      0x18538067
4268 #define MATROSKA_CLUSTER      0x1F43B675
4269 #define MATROSKA_TRACKS       0x1654AE6B
4270 #define MATROSKA_TRACK_ENTRY  0xAE
4271 #define MATROSKA_TRACK_TYPE   0x83
4272 #define MATROSKA_STEREO_MODE  0x53B8
4273 
4274 #define EBML_MAX_LEN (2 * 1024 * 1024)
4275 
4276 typedef enum
4277 {
4278   EBML_DOCTYPE_UNKNOWN = 0,
4279   EBML_DOCTYPE_MATROSKA,
4280   EBML_DOCTYPE_WEBM
4281 } GstEbmlDocType;
4282 
4283 typedef struct
4284 {
4285   GstEbmlDocType doctype;
4286   guint audio;
4287   guint video;
4288   guint other;
4289   guint video_stereo;
4290   guint chunks;
4291   guint tracks_ok;              /* if we&#39;ve seen and fully parsed the TRACKS element */
4292 } GstMatroskaInfo;
4293 
4294 static inline guint
4295 ebml_read_chunk_header (GstTypeFind * tf, DataScanCtx * c, guint max_size,
4296     guint32 * id, guint64 * size)
4297 {
4298   guint64 mask;
4299   guint msbit_set, i, len, id_len;
4300 
4301   if (c-&gt;size &lt; 12 || max_size &lt; 1)
4302     return 0;
4303 
4304   /* element ID */
4305   *id = c-&gt;data[0];
4306   if ((c-&gt;data[0] &amp; 0x80) == 0x80) {
4307     id_len = 1;
4308   } else if ((c-&gt;data[0] &amp; 0xC0) == 0x40) {
4309     id_len = 2;
4310   } else if ((c-&gt;data[0] &amp; 0xE0) == 0x20) {
4311     id_len = 3;
4312   } else if ((c-&gt;data[0] &amp; 0xF0) == 0x10) {
4313     id_len = 4;
4314   } else {
4315     return 0;
4316   }
4317 
4318   if (max_size &lt; id_len)
4319     return 0;
4320 
4321   for (i = 1; i &lt; id_len; ++i) {
4322     *id = (*id &lt;&lt; 8) | c-&gt;data[i];
4323   }
4324 
4325   data_scan_ctx_advance (tf, c, id_len);
4326   max_size -= id_len;
4327 
4328   /* size */
4329   if (max_size &lt; 1 || c-&gt;data[0] == 0)
4330     return 0;
4331 
4332   msbit_set = g_bit_nth_msf (c-&gt;data[0], 8);
4333   mask = ((1 &lt;&lt; msbit_set) - 1);
4334   *size = c-&gt;data[0] &amp; mask;
4335   len = 7 - msbit_set;
4336 
4337   if (max_size &lt; 1 + len)
4338     return 0;
4339   for (i = 0; i &lt; len; ++i) {
4340     mask = (mask &lt;&lt; 8) | 0xff;
4341     *size = (*size &lt;&lt; 8) | c-&gt;data[1 + i];
4342   }
4343 
4344   data_scan_ctx_advance (tf, c, 1 + len);
4345 
4346   /* undefined/unknown size? (all bits 1) */
4347   if (*size == mask) {
4348     /* allow unknown size for SEGMENT chunk, bail out otherwise */
4349     if (*id == MATROSKA_SEGMENT)
4350       *size = G_MAXUINT64;
4351     else
4352       return 0;
4353   }
4354 
4355   return id_len + (1 + len);
4356 }
4357 
4358 static gboolean
4359 ebml_parse_chunk (GstTypeFind * tf, DataScanCtx * ctx, guint32 chunk_id,
4360     guint chunk_size, GstMatroskaInfo * info, guint depth)
4361 {                               /* FIXME: make sure input size is clipped to 32 bit */
4362   static const gchar SPACES[] = &quot;                &quot;;
4363   DataScanCtx c = *ctx;
<a name="33" id="anc33"></a><span class="line-modified">4364   guint64 element_size;</span>
4365   guint32 id, hdr_len;
4366 
4367   if (depth &gt;= 8)               /* keep SPACES large enough for depth */
4368     return FALSE;
4369 
4370   while (chunk_size &gt; 0) {
4371     if (c.offset &gt; EBML_MAX_LEN || !data_scan_ctx_ensure_data (tf, &amp;c, 64))
<a name="34" id="anc34"></a><span class="line-modified">4372     return FALSE;</span>
4373 
4374     hdr_len = ebml_read_chunk_header (tf, &amp;c, chunk_size, &amp;id, &amp;element_size);
4375     if (hdr_len == 0)
<a name="35" id="anc35"></a><span class="line-modified">4376     return FALSE;</span>
4377 
4378     g_assert (hdr_len &lt;= chunk_size);
4379     chunk_size -= hdr_len;
4380 
4381     if (element_size &gt; chunk_size)
<a name="36" id="anc36"></a><span class="line-modified">4382     return FALSE;</span>
4383 
4384     GST_DEBUG (&quot;%s %08x, size %&quot; G_GUINT64_FORMAT &quot; / %&quot; G_GUINT64_FORMAT,
4385         SPACES + sizeof (SPACES) - 1 - (2 * depth), id, element_size,
4386         hdr_len + element_size);
4387 
<a name="37" id="anc37"></a>




4388     if (!data_scan_ctx_ensure_data (tf, &amp;c, element_size)) {
4389       GST_DEBUG (&quot;not enough data&quot;);
4390       return FALSE;
4391     }
4392 
4393     switch (id) {
4394       case EBML_DOCTYPE:
4395         if (element_size &gt;= 8 &amp;&amp; memcmp (c.data, &quot;matroska&quot;, 8) == 0)
4396           info-&gt;doctype = EBML_DOCTYPE_MATROSKA;
4397         else if (element_size &gt;= 4 &amp;&amp; memcmp (c.data, &quot;webm&quot;, 4) == 0)
4398           info-&gt;doctype = EBML_DOCTYPE_WEBM;
4399         break;
4400       case MATROSKA_SEGMENT:
4401         GST_LOG (&quot;parsing segment&quot;);
4402         ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4403         GST_LOG (&quot;parsed segment, done&quot;);
<a name="38" id="anc38"></a><span class="line-modified">4404   return FALSE;</span>
4405       case MATROSKA_TRACKS:
4406         GST_LOG (&quot;parsing tracks&quot;);
4407         info-&gt;tracks_ok =
4408             ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4409         GST_LOG (&quot;parsed tracks: %s, done (after %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
4410             info-&gt;tracks_ok ? &quot;ok&quot; : &quot;FAIL&quot;, c.offset + element_size);
4411         return FALSE;
4412       case MATROSKA_TRACK_ENTRY:
4413         GST_LOG (&quot;parsing track entry&quot;);
4414         if (!ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1))
4415           return FALSE;
4416         break;
4417       case MATROSKA_TRACK_TYPE:{
4418         guint type = 0, i;
4419 
4420         /* is supposed to always be 1-byte, but not everyone&#39;s following that */
4421         for (i = 0; i &lt; element_size; ++i)
4422           type = (type &lt;&lt; 8) | c.data[i];
4423 
4424         GST_DEBUG (&quot;%s   track type %u&quot;,
4425             SPACES + sizeof (SPACES) - 1 - (2 * depth), type);
4426 
4427         if (type == 1)
4428           ++info-&gt;video;
4429         else if (c.data[0] == 2)
4430           ++info-&gt;audio;
4431         else
4432           ++info-&gt;other;
4433         break;
4434       }
4435       case MATROSKA_STEREO_MODE:
4436         ++info-&gt;video_stereo;
4437         break;
4438       case MATROSKA_CLUSTER:
4439         GST_WARNING (&quot;cluster, bailing out (should&#39;ve found tracks by now)&quot;);
4440         return FALSE;
4441       default:
4442         break;
4443     }
4444     data_scan_ctx_advance (tf, &amp;c, element_size);
4445     chunk_size -= element_size;
4446     ++info-&gt;chunks;
4447   }
4448 
4449   return TRUE;
4450 }
4451 
4452 static GstStaticCaps matroska_caps = GST_STATIC_CAPS (&quot;video/x-matroska&quot;);
4453 
4454 #define MATROSKA_CAPS (gst_static_caps_get(&amp;matroska_caps))
4455 static void
4456 matroska_type_find (GstTypeFind * tf, gpointer ununsed)
4457 {
4458   GstTypeFindProbability prob;
4459   GstMatroskaInfo info = { 0, };
4460   const gchar *type_name;
4461   DataScanCtx c = { 0, NULL, 0 };
4462   gboolean is_audio;
4463   guint64 size;
4464   guint32 id, hdr_len;
4465 
4466   if (!data_scan_ctx_ensure_data (tf, &amp;c, 64))
4467     return;
4468 
4469   if (GST_READ_UINT32_BE (c.data) != EBML_HEADER)
4470     return;
4471 
4472   while (c.offset &lt; EBML_MAX_LEN &amp;&amp; data_scan_ctx_ensure_data (tf, &amp;c, 64)) {
4473     hdr_len = ebml_read_chunk_header (tf, &amp;c, c.size, &amp;id, &amp;size);
4474     if (hdr_len == 0)
4475       return;
4476 
4477     GST_INFO (&quot;=== top-level chunk %08x, size %&quot; G_GUINT64_FORMAT
4478         &quot; / %&quot; G_GUINT64_FORMAT, id, size, size + hdr_len);
4479 
4480     if (!ebml_parse_chunk (tf, &amp;c, id, size, &amp;info, 0))
4481       break;
4482     data_scan_ctx_advance (tf, &amp;c, size);
4483     GST_INFO (&quot;=== done with chunk %08x&quot;, id);
4484     if (id == MATROSKA_SEGMENT)
4485       break;
4486   }
4487 
4488   GST_INFO (&quot;audio=%u video=%u other=%u chunks=%u doctype=%d all_tracks=%d&quot;,
4489       info.audio, info.video, info.other, info.chunks, info.doctype,
4490       info.tracks_ok);
4491 
4492   /* perhaps we should bail out if tracks_ok is FALSE and wait for more data?
4493    * (we would need new API to signal this properly and prevent other
4494    * typefinders from taking over the decision then) */
4495   is_audio = (info.audio &gt; 0 &amp;&amp; info.video == 0 &amp;&amp; info.other == 0);
4496 
4497   if (info.doctype == EBML_DOCTYPE_WEBM) {
4498     type_name = (is_audio) ? &quot;audio/webm&quot; : &quot;video/webm&quot;;
4499   } else if (info.video &gt; 0 &amp;&amp; info.video_stereo) {
4500     type_name = &quot;video/x-matroska-3d&quot;;
4501   } else {
4502     type_name = (is_audio) ? &quot;audio/x-matroska&quot; : &quot;video/x-matroska&quot;;
4503   }
4504 
4505   if (info.doctype == EBML_DOCTYPE_UNKNOWN)
4506     prob = GST_TYPE_FIND_LIKELY;
4507   else
4508     prob = GST_TYPE_FIND_MAXIMUM;
4509 
4510   gst_type_find_suggest_simple (tf, prob, type_name, NULL);
4511 }
4512 
4513 /*** application/mxf ***/
4514 static GstStaticCaps mxf_caps = GST_STATIC_CAPS (&quot;application/mxf&quot;);
4515 
4516 #define MXF_MAX_PROBE_LENGTH (1024 * 64)
4517 #define MXF_CAPS (gst_static_caps_get(&amp;mxf_caps))
4518 
4519 /*
4520  * MXF files start with a header partition pack key of 16 bytes which is defined
4521  * at SMPTE-377M 6.1. Before this there can be up to 64K of run-in which _must_
4522  * not contain the partition pack key.
4523  */
4524 static void
4525 mxf_type_find (GstTypeFind * tf, gpointer ununsed)
4526 {
4527   static const guint8 partition_pack_key[] =
4528       { 0x06, 0x0e, 0x2b, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0d, 0x01, 0x02, 0x01,
4529     0x01
4530   };
4531   DataScanCtx c = { 0, NULL, 0 };
4532 
4533   while (c.offset &lt;= MXF_MAX_PROBE_LENGTH) {
4534     guint i;
4535     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 1024)))
4536       break;
4537 
4538     /* look over in chunks of 1kbytes to avoid too much overhead */
4539 
4540     for (i = 0; i &lt; 1024 - 16; i++) {
4541       /* Check first byte before calling more expensive memcmp function */
4542       if (G_UNLIKELY (c.data[i] == 0x06
4543               &amp;&amp; memcmp (c.data + i, partition_pack_key, 13) == 0)) {
4544         /* Header partition pack? */
4545         if (c.data[i + 13] != 0x02)
4546           goto advance;
4547 
4548         /* Partition status */
4549         if (c.data[i + 14] &gt;= 0x05)
4550           goto advance;
4551 
4552         /* Reserved, must be 0x00 */
4553         if (c.data[i + 15] != 0x00)
4554           goto advance;
4555 
4556         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MXF_CAPS);
4557         return;
4558       }
4559     }
4560 
4561   advance:
4562     data_scan_ctx_advance (tf, &amp;c, 1024 - 16);
4563   }
4564 }
4565 
4566 /*** video/x-dv ***/
4567 
4568 static GstStaticCaps dv_caps = GST_STATIC_CAPS (&quot;video/x-dv, &quot;
4569     &quot;systemstream = (boolean) true&quot;);
4570 #define DV_CAPS (gst_static_caps_get(&amp;dv_caps))
4571 static void
4572 dv_type_find (GstTypeFind * tf, gpointer private)
4573 {
4574   const guint8 *data;
4575 
4576   data = gst_type_find_peek (tf, 0, 5);
4577 
4578   /* check for DIF  and DV flag */
4579   if (data &amp;&amp; (data[0] == 0x1f) &amp;&amp; (data[1] == 0x07) &amp;&amp; (data[2] == 0x00)) {
4580     const gchar *format;
4581 
4582     if (data[3] &amp; 0x80) {
4583       format = &quot;PAL&quot;;
4584     } else {
4585       format = &quot;NTSC&quot;;
4586     }
4587 
4588     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, &quot;video/x-dv&quot;,
4589         &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
4590         &quot;format&quot;, G_TYPE_STRING, format, NULL);
4591   }
4592 }
4593 
4594 
4595 /*** Ogg variants ***/
4596 static GstStaticCaps ogg_caps =
4597     GST_STATIC_CAPS (&quot;application/ogg;video/ogg;audio/ogg;application/kate&quot;);
4598 
4599 #define OGG_CAPS (gst_static_caps_get(&amp;ogg_caps))
4600 
4601 typedef enum
4602 {
4603   OGG_AUDIO = 0,
4604   OGG_VIDEO,
4605   OGG_KATE,
4606   OGG_OTHER,
4607   OGG_SKELETON,
4608   OGG_ANNODEX,
4609   OGG_NUM
4610 } GstOggStreamType;
4611 
4612 static void
4613 ogganx_type_find (GstTypeFind * tf, gpointer private)
4614 {
4615   const gchar *media_type;
4616   DataScanCtx c = { 0, NULL, 0 };
4617   guint ogg_syncs = 0;
4618   guint hdr_count[OGG_NUM] = { 0, };
4619   static const struct
4620   {
4621     const gchar marker[10];
4622     guint8 marker_size;
4623     GstOggStreamType stream_type;
4624   } markers[] = {
4625     {
4626     &quot;\001vorbis&quot;, 7, OGG_AUDIO}, {
4627     &quot;\200theora&quot;, 7, OGG_VIDEO}, {
4628     &quot;fLaC&quot;, 4, OGG_AUDIO}, {
4629     &quot;\177FLAC&quot;, 5, OGG_AUDIO}, {
4630     &quot;Speex&quot;, 5, OGG_AUDIO}, {
4631     &quot;CMML\0\0\0\0&quot;, 8, OGG_OTHER}, {
4632     &quot;PCM     &quot;, 8, OGG_AUDIO}, {
4633     &quot;Annodex&quot;, 7, OGG_ANNODEX}, {
4634     &quot;fishead&quot;, 7, OGG_SKELETON}, {
4635     &quot;AnxData&quot;, 7, OGG_ANNODEX}, {
4636     &quot;CELT    &quot;, 8, OGG_AUDIO}, {
4637     &quot;\200kate\0\0\0&quot;, 8, OGG_KATE}, {
4638     &quot;BBCD\0&quot;, 5, OGG_VIDEO}, {
4639     &quot;OVP80\1\1&quot;, 7, OGG_VIDEO}, {
4640     &quot;OpusHead&quot;, 8, OGG_AUDIO}, {
4641     &quot;\001audio\0\0\0&quot;, 9, OGG_AUDIO}, {
4642     &quot;\001video\0\0\0&quot;, 9, OGG_VIDEO}, {
4643     &quot;\001text\0\0\0&quot;, 9, OGG_OTHER}
4644   };
4645 
4646   while (c.offset &lt; 4096 &amp;&amp; data_scan_ctx_ensure_data (tf, &amp;c, 64)) {
4647     guint size, i;
4648 
4649     if (memcmp (c.data, &quot;OggS&quot;, 5) != 0)
4650       break;
4651 
4652     ++ogg_syncs;
4653 
4654     /* check if BOS */
4655     if (c.data[5] != 0x02)
4656       break;
4657 
4658     /* headers should only have one segment */
4659     if (c.data[26] != 1)
4660       break;
4661 
4662     size = c.data[27];
4663     if (size &lt; 8)
4664       break;
4665 
4666     data_scan_ctx_advance (tf, &amp;c, 28);
4667 
4668     if (!data_scan_ctx_ensure_data (tf, &amp;c, MAX (size, 8)))
4669       break;
4670 
4671     for (i = 0; i &lt; G_N_ELEMENTS (markers); ++i) {
4672       if (memcmp (c.data, markers[i].marker, markers[i].marker_size) == 0) {
4673         ++hdr_count[markers[i].stream_type];
4674         break;
4675       }
4676     }
4677 
4678     if (i == G_N_ELEMENTS (markers)) {
4679       GST_MEMDUMP (&quot;unknown Ogg stream marker&quot;, c.data, size);
4680       ++hdr_count[OGG_OTHER];
4681     }
4682 
4683     data_scan_ctx_advance (tf, &amp;c, size);
4684   }
4685 
4686   if (ogg_syncs == 0)
4687     return;
4688 
4689   /* We don&#39;t bother with annodex types. FIXME: what about XSPF? */
4690   if (hdr_count[OGG_VIDEO] &gt; 0) {
4691     media_type = &quot;video/ogg&quot;;
4692   } else if (hdr_count[OGG_AUDIO] &gt; 0) {
4693     media_type = &quot;audio/ogg&quot;;
4694   } else if (hdr_count[OGG_KATE] &gt; 0 &amp;&amp; hdr_count[OGG_OTHER] == 0) {
4695     media_type = &quot;application/kate&quot;;
4696   } else {
4697     media_type = &quot;application/ogg&quot;;
4698   }
4699 
4700   GST_INFO (&quot;found %s (audio:%u, video:%u, annodex:%u, skeleton:%u, other:%u)&quot;,
4701       media_type, hdr_count[OGG_AUDIO], hdr_count[OGG_VIDEO],
4702       hdr_count[OGG_ANNODEX], hdr_count[OGG_SKELETON], hdr_count[OGG_OTHER]);
4703 
4704   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM, media_type, NULL);
4705 }
4706 
4707 /*** audio/x-vorbis ***/
4708 static GstStaticCaps vorbis_caps = GST_STATIC_CAPS (&quot;audio/x-vorbis&quot;);
4709 
4710 #define VORBIS_CAPS (gst_static_caps_get(&amp;vorbis_caps))
4711 static void
4712 vorbis_type_find (GstTypeFind * tf, gpointer private)
4713 {
4714   const guint8 *data = gst_type_find_peek (tf, 0, 30);
4715 
4716   if (data) {
4717     guint blocksize_0;
4718     guint blocksize_1;
4719 
4720     /* 1 byte packet type (identification=0x01)
4721        6 byte string &quot;vorbis&quot;
4722        4 byte vorbis version */
4723     if (memcmp (data, &quot;\001vorbis\000\000\000\000&quot;, 11) != 0)
4724       return;
4725     data += 11;
4726     /* 1 byte channels must be != 0 */
4727     if (data[0] == 0)
4728       return;
4729     data++;
4730     /* 4 byte samplerate must be != 0 */
4731     if (GST_READ_UINT32_LE (data) == 0)
4732       return;
4733     data += 16;
4734     /* blocksize checks */
4735     blocksize_0 = data[0] &amp; 0x0F;
4736     blocksize_1 = (data[0] &amp; 0xF0) &gt;&gt; 4;
4737     if (blocksize_0 &gt; blocksize_1)
4738       return;
4739     if (blocksize_0 &lt; 6 || blocksize_0 &gt; 13)
4740       return;
4741     if (blocksize_1 &lt; 6 || blocksize_1 &gt; 13)
4742       return;
4743     data++;
4744     /* framing bit */
4745     if ((data[0] &amp; 0x01) != 1)
4746       return;
4747     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, VORBIS_CAPS);
4748   }
4749 }
4750 
4751 /*** video/x-theora ***/
4752 
4753 static GstStaticCaps theora_caps = GST_STATIC_CAPS (&quot;video/x-theora&quot;);
4754 
4755 #define THEORA_CAPS (gst_static_caps_get(&amp;theora_caps))
4756 static void
4757 theora_type_find (GstTypeFind * tf, gpointer private)
4758 {
4759   const guint8 *data = gst_type_find_peek (tf, 0, 7);   //42);
4760 
4761   if (data) {
4762     if (data[0] != 0x80)
4763       return;
4764     if (memcmp (&amp;data[1], &quot;theora&quot;, 6) != 0)
4765       return;
4766     /* FIXME: make this more reliable when specs are out */
4767 
4768     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, THEORA_CAPS);
4769   }
4770 }
4771 
4772 /*** kate ***/
4773 static void
4774 kate_type_find (GstTypeFind * tf, gpointer private)
4775 {
4776   const guint8 *data = gst_type_find_peek (tf, 0, 64);
4777   gchar category[16] = { 0, };
4778 
4779   if (G_UNLIKELY (data == NULL))
4780     return;
4781 
4782   /* see: http://wiki.xiph.org/index.php/OggKate#Format_specification */
4783   if (G_LIKELY (memcmp (data, &quot;\200kate\0\0\0&quot;, 8) != 0))
4784     return;
4785 
4786   /* make sure we always have a NUL-terminated string */
4787   memcpy (category, data + 48, 15);
4788   GST_LOG (&quot;kate category: %s&quot;, category);
4789   /* canonical categories for subtitles: subtitles, spu-subtitles, SUB, K-SPU */
4790   if (strcmp (category, &quot;subtitles&quot;) == 0 || strcmp (category, &quot;SUB&quot;) == 0 ||
4791       strcmp (category, &quot;spu-subtitles&quot;) == 0 ||
4792       strcmp (category, &quot;K-SPU&quot;) == 0) {
4793     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
4794         &quot;subtitle/x-kate&quot;, NULL);
4795   } else {
4796     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
4797         &quot;application/x-kate&quot;, NULL);
4798   }
4799 }
4800 
4801 /*** WEBVTTT subtitles ***/
4802 static GstStaticCaps webvtt_caps =
4803 GST_STATIC_CAPS (&quot;application/x-subtitle-vtt, parsed=(boolean)false&quot;);
4804 #define WEBVTT_CAPS (gst_static_caps_get(&amp;webvtt_caps))
4805 
4806 static void
4807 webvtt_type_find (GstTypeFind * tf, gpointer private)
4808 {
4809   const guint8 *data;
4810 
4811   data = gst_type_find_peek (tf, 0, 10);
4812 
4813   if (data == NULL)
4814     return;
4815 
4816   /* there might be a UTF-8 BOM at the beginning */
4817   if (memcmp (data, &quot;WEBVTT&quot;, 6) != 0 &amp;&amp; memcmp (data + 3, &quot;WEBVTT&quot;, 6) != 0) {
4818     return;
4819   }
4820 
4821   if (data[0] != &#39;W&#39;) {
4822     if (data[0] != 0xef || data[1] != 0xbb || data[2] != 0xbf)
4823       return;                   /* Not a UTF-8 BOM */
4824     data += 3;
4825   }
4826 
4827   /* After the WEBVTT magic must be one of these chars:
4828    *   0x20 (space), 0x9 (tab), 0xa (LF) or 0xd (CR) */
4829   if (data[6] != 0x20 &amp;&amp; data[6] != 0x9 &amp;&amp; data[6] != 0xa &amp;&amp; data[6] != 0xd) {
4830     return;
4831   }
4832 
4833   gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, WEBVTT_CAPS);
4834 }
4835 
4836 /*** application/x-ogm-video or audio***/
4837 
4838 static GstStaticCaps ogmvideo_caps =
4839 GST_STATIC_CAPS (&quot;application/x-ogm-video&quot;);
4840 #define OGMVIDEO_CAPS (gst_static_caps_get(&amp;ogmvideo_caps))
4841 static void
4842 ogmvideo_type_find (GstTypeFind * tf, gpointer private)
4843 {
4844   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4845 
4846   if (data) {
4847     if (memcmp (data, &quot;\001video\000\000\000&quot;, 9) != 0)
4848       return;
4849     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMVIDEO_CAPS);
4850   }
4851 }
4852 
4853 static GstStaticCaps ogmaudio_caps =
4854 GST_STATIC_CAPS (&quot;application/x-ogm-audio&quot;);
4855 #define OGMAUDIO_CAPS (gst_static_caps_get(&amp;ogmaudio_caps))
4856 static void
4857 ogmaudio_type_find (GstTypeFind * tf, gpointer private)
4858 {
4859   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4860 
4861   if (data) {
4862     if (memcmp (data, &quot;\001audio\000\000\000&quot;, 9) != 0)
4863       return;
4864     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
4865   }
4866 }
4867 
4868 static GstStaticCaps ogmtext_caps = GST_STATIC_CAPS (&quot;application/x-ogm-text&quot;);
4869 
4870 #define OGMTEXT_CAPS (gst_static_caps_get(&amp;ogmtext_caps))
4871 static void
4872 ogmtext_type_find (GstTypeFind * tf, gpointer private)
4873 {
4874   const guint8 *data = gst_type_find_peek (tf, 0, 9);
4875 
4876   if (data) {
4877     if (memcmp (data, &quot;\001text\000\000\000\000&quot;, 9) != 0)
4878       return;
4879     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMTEXT_CAPS);
4880   }
4881 }
4882 
4883 /*** audio/x-speex ***/
4884 
4885 static GstStaticCaps speex_caps = GST_STATIC_CAPS (&quot;audio/x-speex&quot;);
4886 
4887 #define SPEEX_CAPS (gst_static_caps_get(&amp;speex_caps))
4888 static void
4889 speex_type_find (GstTypeFind * tf, gpointer private)
4890 {
4891   const guint8 *data = gst_type_find_peek (tf, 0, 80);
4892 
4893   if (data) {
4894     /* 8 byte string &quot;Speex   &quot;
4895        24 byte speex version string + int */
4896     if (memcmp (data, &quot;Speex   &quot;, 8) != 0)
4897       return;
4898     data += 32;
4899 
4900     /* 4 byte header size &gt;= 80 */
4901     if (GST_READ_UINT32_LE (data) &lt; 80)
4902       return;
4903     data += 4;
4904 
4905     /* 4 byte sample rate &lt;= 48000 */
4906     if (GST_READ_UINT32_LE (data) &gt; 48000)
4907       return;
4908     data += 4;
4909 
4910     /* currently there are only 3 speex modes. */
4911     if (GST_READ_UINT32_LE (data) &gt; 3)
4912       return;
4913     data += 12;
4914 
4915     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, SPEEX_CAPS);
4916   }
4917 }
4918 
4919 /*** audio/x-celt ***/
4920 
4921 static GstStaticCaps celt_caps = GST_STATIC_CAPS (&quot;audio/x-celt&quot;);
4922 
4923 #define CELT_CAPS (gst_static_caps_get(&amp;celt_caps))
4924 static void
4925 celt_type_find (GstTypeFind * tf, gpointer private)
4926 {
4927   const guint8 *data = gst_type_find_peek (tf, 0, 8);
4928 
4929   if (data) {
4930     /* 8 byte string &quot;CELT   &quot; */
4931     if (memcmp (data, &quot;CELT    &quot;, 8) != 0)
4932       return;
4933 
4934     /* TODO: Check other values of the CELT header */
4935     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, CELT_CAPS);
4936   }
4937 }
4938 
4939 /*** application/x-ogg-skeleton ***/
4940 static GstStaticCaps ogg_skeleton_caps =
4941 GST_STATIC_CAPS (&quot;application/x-ogg-skeleton, parsed=(boolean)FALSE&quot;);
4942 #define OGG_SKELETON_CAPS (gst_static_caps_get(&amp;ogg_skeleton_caps))
4943 static void
4944 oggskel_type_find (GstTypeFind * tf, gpointer private)
4945 {
4946   const guint8 *data = gst_type_find_peek (tf, 0, 12);
4947 
4948   if (data) {
4949     /* 8 byte string &quot;fishead\0&quot; for the ogg skeleton stream */
4950     if (memcmp (data, &quot;fishead\0&quot;, 8) != 0)
4951       return;
4952     data += 8;
4953 
4954     /* Require that the header contains version 3.0 */
4955     if (GST_READ_UINT16_LE (data) != 3)
4956       return;
4957     data += 2;
4958     if (GST_READ_UINT16_LE (data) != 0)
4959       return;
4960 
4961     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGG_SKELETON_CAPS);
4962   }
4963 }
4964 
4965 static GstStaticCaps cmml_caps = GST_STATIC_CAPS (&quot;text/x-cmml&quot;);
4966 
4967 #define CMML_CAPS (gst_static_caps_get(&amp;cmml_caps))
4968 static void
4969 cmml_type_find (GstTypeFind * tf, gpointer private)
4970 {
4971   /* Header is 12 bytes minimum (though we don&#39;t check the minor version */
4972   const guint8 *data = gst_type_find_peek (tf, 0, 12);
4973 
4974   if (data) {
4975 
4976     /* 8 byte string &quot;CMML\0\0\0\0&quot; for the magic number */
4977     if (memcmp (data, &quot;CMML\0\0\0\0&quot;, 8) != 0)
4978       return;
4979     data += 8;
4980 
4981     /* Require that the header contains at least version 2.0 */
4982     if (GST_READ_UINT16_LE (data) &lt; 2)
4983       return;
4984 
4985     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, CMML_CAPS);
4986   }
4987 }
4988 
4989 /*** application/x-tar ***/
4990 
4991 static GstStaticCaps tar_caps = GST_STATIC_CAPS (&quot;application/x-tar&quot;);
4992 
4993 #define TAR_CAPS (gst_static_caps_get(&amp;tar_caps))
4994 #define OLDGNU_MAGIC &quot;ustar  &quot;  /* 7 chars and a NUL */
4995 #define NEWGNU_MAGIC &quot;ustar&quot;    /* 5 chars and a NUL */
4996 static void
4997 tar_type_find (GstTypeFind * tf, gpointer unused)
4998 {
4999   const guint8 *data = gst_type_find_peek (tf, 257, 8);
5000 
5001   /* of course we are not certain, but we don&#39;t want other typefind funcs
5002    * to detect formats of files within the tar archive, e.g. mp3s */
5003   if (data) {
5004     if (memcmp (data, OLDGNU_MAGIC, 8) == 0) {  /* sic */
5005       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, TAR_CAPS);
5006     } else if (memcmp (data, NEWGNU_MAGIC, 6) == 0 &amp;&amp;   /* sic */
5007         g_ascii_isdigit (data[6]) &amp;&amp; g_ascii_isdigit (data[7])) {
5008       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, TAR_CAPS);
5009     }
5010   }
5011 }
5012 
5013 /*** application/x-ar ***/
5014 
5015 static GstStaticCaps ar_caps = GST_STATIC_CAPS (&quot;application/x-ar&quot;);
5016 
5017 #define AR_CAPS (gst_static_caps_get(&amp;ar_caps))
5018 static void
5019 ar_type_find (GstTypeFind * tf, gpointer unused)
5020 {
5021   const guint8 *data = gst_type_find_peek (tf, 0, 24);
5022 
5023   if (data &amp;&amp; memcmp (data, &quot;!&lt;arch&gt;&quot;, 7) == 0) {
5024     gint i;
5025 
5026     for (i = 7; i &lt; 24; ++i) {
5027       if (!g_ascii_isprint (data[i]) &amp;&amp; data[i] != &#39;\n&#39;) {
5028         gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, AR_CAPS);
5029       }
5030     }
5031 
5032     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, AR_CAPS);
5033   }
5034 }
5035 
5036 /*** audio/x-au ***/
5037 
5038 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5039  * as it is only possible to register one typefind factory per &#39;name&#39;
5040  * (which is in this case the caps), and the first one would be replaced by
5041  * the second one. */
5042 static GstStaticCaps au_caps = GST_STATIC_CAPS (&quot;audio/x-au&quot;);
5043 
5044 #define AU_CAPS (gst_static_caps_get(&amp;au_caps))
5045 static void
5046 au_type_find (GstTypeFind * tf, gpointer unused)
5047 {
5048   const guint8 *data = gst_type_find_peek (tf, 0, 4);
5049 
5050   if (data) {
5051     if (memcmp (data, &quot;.snd&quot;, 4) == 0 || memcmp (data, &quot;dns.&quot;, 4) == 0) {
5052       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, AU_CAPS);
5053     }
5054   }
5055 }
5056 
5057 
5058 /*** video/x-nuv ***/
5059 
5060 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5061  * as it is only possible to register one typefind factory per &#39;name&#39;
5062  * (which is in this case the caps), and the first one would be replaced by
5063  * the second one. */
5064 static GstStaticCaps nuv_caps = GST_STATIC_CAPS (&quot;video/x-nuv&quot;);
5065 
5066 #define NUV_CAPS (gst_static_caps_get(&amp;nuv_caps))
5067 static void
5068 nuv_type_find (GstTypeFind * tf, gpointer unused)
5069 {
5070   const guint8 *data = gst_type_find_peek (tf, 0, 11);
5071 
5072   if (data) {
5073     if (memcmp (data, &quot;MythTVVideo&quot;, 11) == 0
5074         || memcmp (data, &quot;NuppelVideo&quot;, 11) == 0) {
5075       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, NUV_CAPS);
5076     }
5077   }
5078 }
5079 
5080 /*** audio/x-paris ***/
5081 /* NOTE: do not replace this function with two TYPE_FIND_REGISTER_START_WITH */
5082 static GstStaticCaps paris_caps = GST_STATIC_CAPS (&quot;audio/x-paris&quot;);
5083 
5084 #define PARIS_CAPS (gst_static_caps_get(&amp;paris_caps))
5085 static void
5086 paris_type_find (GstTypeFind * tf, gpointer unused)
5087 {
5088   const guint8 *data = gst_type_find_peek (tf, 0, 4);
5089 
5090   if (data) {
5091     if (memcmp (data, &quot; paf&quot;, 4) == 0 || memcmp (data, &quot;fap &quot;, 4) == 0) {
5092       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, PARIS_CAPS);
5093     }
5094   }
5095 }
5096 
5097 /*** audio/x-sbc ***/
5098 static GstStaticCaps sbc_caps = GST_STATIC_CAPS (&quot;audio/x-sbc&quot;);
5099 #define SBC_CAPS (gst_static_caps_get(&amp;sbc_caps))
5100 
5101 static gsize
5102 sbc_check_header (const guint8 * data, gsize len, guint * rate,
5103     guint * channels)
5104 {
5105   static const guint16 sbc_rates[4] = { 16000, 32000, 44100, 48000 };
5106   static const guint8 sbc_blocks[4] = { 4, 8, 12, 16 };
5107   guint n_blocks, ch_mode, n_subbands, bitpool;
5108 
5109   if (data[0] != 0x9C || len &lt; 4)
5110     return 0;
5111 
5112   n_blocks = sbc_blocks[(data[1] &gt;&gt; 4) &amp; 0x03];
5113   ch_mode = (data[1] &gt;&gt; 2) &amp; 0x03;
5114   n_subbands = (data[1] &amp; 0x01) ? 8 : 4;
5115   bitpool = data[2];
5116   if (bitpool &lt; 2)
5117     return 0;
5118 
5119   *rate = sbc_rates[(data[1] &gt;&gt; 6) &amp; 0x03];
5120   *channels = (ch_mode == 0) ? 1 : 2;
5121 
5122   if (ch_mode == 0)
5123     return 4 + (n_subbands * 1) / 2 + (n_blocks * 1 * bitpool) / 8;
5124   else if (ch_mode == 1)
5125     return 4 + (n_subbands * 2) / 2 + (n_blocks * 2 * bitpool) / 8;
5126   else if (ch_mode == 2)
5127     return 4 + (n_subbands * 2) / 2 + (n_blocks * bitpool) / 8;
5128   else if (ch_mode == 3)
5129     return 4 + (n_subbands * 2) / 2 + (n_subbands + n_blocks * bitpool) / 8;
5130 
5131   return 0;
5132 }
5133 
5134 static void
5135 sbc_type_find (GstTypeFind * tf, gpointer unused)
5136 {
5137   const guint8 *data;
5138   gsize frame_len;
5139   guint i, rate, channels, offset = 0;
5140 
5141   for (i = 0; i &lt; 10; ++i) {
5142     data = gst_type_find_peek (tf, offset, 8);
5143     if (data == NULL)
5144       return;
5145 
5146     frame_len = sbc_check_header (data, 8, &amp;rate, &amp;channels);
5147     if (frame_len == 0)
5148       return;
5149 
5150     offset += frame_len;
5151   }
5152   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE, &quot;audio/x-sbc&quot;,
5153       &quot;rate&quot;, G_TYPE_INT, rate, &quot;channels&quot;, G_TYPE_INT, channels,
5154       &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5155 }
5156 
5157 /*** audio/iLBC-sh ***/
5158 /* NOTE: do not replace this function with two TYPE_FIND_REGISTER_START_WITH */
5159 static GstStaticCaps ilbc_caps = GST_STATIC_CAPS (&quot;audio/iLBC-sh&quot;);
5160 
5161 #define ILBC_CAPS (gst_static_caps_get(&amp;ilbc_caps))
5162 static void
5163 ilbc_type_find (GstTypeFind * tf, gpointer unused)
5164 {
5165   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5166 
5167   if (data) {
5168     if (memcmp (data, &quot;#!iLBC30&quot;, 8) == 0 || memcmp (data, &quot;#!iLBC20&quot;, 8) == 0) {
5169       gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, ILBC_CAPS);
5170     }
5171   }
5172 }
5173 
5174 /*** application/x-ms-dos-executable ***/
5175 
5176 static GstStaticCaps msdos_caps =
5177 GST_STATIC_CAPS (&quot;application/x-ms-dos-executable&quot;);
5178 #define MSDOS_CAPS (gst_static_caps_get(&amp;msdos_caps))
5179 /* see http://www.madchat.org/vxdevl/papers/winsys/pefile/pefile.htm */
5180 static void
5181 msdos_type_find (GstTypeFind * tf, gpointer unused)
5182 {
5183   const guint8 *data = gst_type_find_peek (tf, 0, 64);
5184 
5185   if (data &amp;&amp; data[0] == &#39;M&#39; &amp;&amp; data[1] == &#39;Z&#39; &amp;&amp;
5186       GST_READ_UINT16_LE (data + 8) == 4) {
5187     guint32 pe_offset = GST_READ_UINT32_LE (data + 60);
5188 
5189     data = gst_type_find_peek (tf, pe_offset, 2);
5190     if (data &amp;&amp; data[0] == &#39;P&#39; &amp;&amp; data[1] == &#39;E&#39;) {
5191       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, MSDOS_CAPS);
5192     }
5193   }
5194 }
5195 
5196 /*** application/x-mmsh ***/
5197 
5198 static GstStaticCaps mmsh_caps = GST_STATIC_CAPS (&quot;application/x-mmsh&quot;);
5199 
5200 #define MMSH_CAPS gst_static_caps_get(&amp;mmsh_caps)
5201 
5202 /* This is to recognise mssh-over-http */
5203 static void
5204 mmsh_type_find (GstTypeFind * tf, gpointer unused)
5205 {
5206   static const guint8 asf_marker[16] = { 0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66,
5207     0xcf, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c
5208   };
5209 
5210   const guint8 *data;
5211 
5212   data = gst_type_find_peek (tf, 0, 2 + 2 + 4 + 2 + 2 + 16);
5213   if (data &amp;&amp; data[0] == 0x24 &amp;&amp; data[1] == 0x48 &amp;&amp;
5214       GST_READ_UINT16_LE (data + 2) &gt; 2 + 2 + 4 + 2 + 2 + 16 &amp;&amp;
5215       memcmp (data + 2 + 2 + 4 + 2 + 2, asf_marker, 16) == 0) {
5216     gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, MMSH_CAPS);
5217   }
5218 }
5219 
5220 /*** video/x-dirac ***/
5221 
5222 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5223  * as it is only possible to register one typefind factory per &#39;name&#39;
5224  * (which is in this case the caps), and the first one would be replaced by
5225  * the second one. */
5226 static GstStaticCaps dirac_caps = GST_STATIC_CAPS (&quot;video/x-dirac&quot;);
5227 
5228 #define DIRAC_CAPS (gst_static_caps_get(&amp;dirac_caps))
5229 static void
5230 dirac_type_find (GstTypeFind * tf, gpointer unused)
5231 {
5232   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5233 
5234   if (data) {
5235     if (memcmp (data, &quot;BBCD&quot;, 4) == 0 || memcmp (data, &quot;KW-DIRAC&quot;, 8) == 0) {
5236       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DIRAC_CAPS);
5237     }
5238   }
5239 }
5240 
<a name="39" id="anc39"></a>





















5241 /*** video/vivo ***/
5242 
5243 static GstStaticCaps vivo_caps = GST_STATIC_CAPS (&quot;video/vivo&quot;);
5244 
5245 #define VIVO_CAPS gst_static_caps_get(&amp;vivo_caps)
5246 
5247 static void
5248 vivo_type_find (GstTypeFind * tf, gpointer unused)
5249 {
5250   static const guint8 vivo_marker[] = { &#39;V&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;,
5251     &#39;:&#39;, &#39;V&#39;, &#39;i&#39;, &#39;v&#39;, &#39;o&#39;, &#39;/&#39;
5252   };
5253   const guint8 *data;
5254   guint hdr_len, pos;
5255 
5256   data = gst_type_find_peek (tf, 0, 1024);
5257   if (data == NULL || data[0] != 0x00)
5258     return;
5259 
5260   if ((data[1] &amp; 0x80)) {
5261     if ((data[2] &amp; 0x80))
5262       return;
5263     hdr_len = ((guint) (data[1] &amp; 0x7f)) &lt;&lt; 7;
5264     hdr_len += data[2];
5265     if (hdr_len &gt; 2048)
5266       return;
5267     pos = 3;
5268   } else {
5269     hdr_len = data[1];
5270     pos = 2;
5271   }
5272 
5273   /* 1008 = 1022 - strlen (&quot;Version:Vivo/&quot;) - 1 */
5274   while (pos &lt; 1008 &amp;&amp; data[pos] == &#39;\r&#39; &amp;&amp; data[pos + 1] == &#39;\n&#39;)
5275     pos += 2;
5276 
5277   if (memcmp (data + pos, vivo_marker, sizeof (vivo_marker)) == 0) {
5278     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, VIVO_CAPS);
5279   }
5280 }
5281 
5282 /*** XDG MIME typefinder (to avoid false positives mostly) ***/
5283 
5284 #ifdef USE_GIO
5285 static void
5286 xdgmime_typefind (GstTypeFind * find, gpointer user_data)
5287 {
5288   gchar *mimetype;
5289   gsize length = 16384;
5290   guint64 tf_length;
5291   const guint8 *data;
5292   gchar *tmp;
5293 
5294   if ((tf_length = gst_type_find_get_length (find)) &gt; 0)
5295     length = MIN (length, tf_length);
5296 
5297   if ((data = gst_type_find_peek (find, 0, length)) == NULL)
5298     return;
5299 
5300   tmp = g_content_type_guess (NULL, data, length, NULL);
5301   if (tmp == NULL || g_content_type_is_unknown (tmp)) {
5302     g_free (tmp);
5303     return;
5304   }
5305 
5306   mimetype = g_content_type_get_mime_type (tmp);
5307   g_free (tmp);
5308 
5309   if (mimetype == NULL)
5310     return;
5311 
5312   GST_DEBUG (&quot;Got mimetype &#39;%s&#39;&quot;, mimetype);
5313 
5314   /* Ignore audio/video types:
5315    *  - our own typefinders in -base are likely to be better at this
5316    *    (and if they&#39;re not, we really want to fix them, that&#39;s why we don&#39;t
5317    *    report xdg-detected audio/video types at all, not even with a low
5318    *    probability)
5319    *  - we want to detect GStreamer media types and not MIME types
5320    *  - the purpose of this xdg mime finder is mainly to prevent false
5321    *    positives of non-media formats, not to typefind audio/video formats */
5322   if (g_str_has_prefix (mimetype, &quot;audio/&quot;) ||
5323       g_str_has_prefix (mimetype, &quot;video/&quot;)) {
5324     GST_LOG (&quot;Ignoring audio/video mime type&quot;);
5325     g_free (mimetype);
5326     return;
5327   }
5328 
5329   /* Again, we mainly want the xdg typefinding to prevent false-positives on
5330    * non-media formats, so suggest the type with a probability that trumps
5331    * uncertain results of our typefinders, but not more than that. */
5332   GST_LOG (&quot;Suggesting &#39;%s&#39; with probability POSSIBLE&quot;, mimetype);
5333   gst_type_find_suggest_simple (find, GST_TYPE_FIND_POSSIBLE, mimetype, NULL);
5334   g_free (mimetype);
5335 }
5336 #endif /* USE_GIO */
5337 
5338 /*** Windows icon typefinder (to avoid false positives mostly) ***/
5339 
5340 static void
5341 windows_icon_typefind (GstTypeFind * find, gpointer user_data)
5342 {
5343   const guint8 *data;
5344   gint64 datalen;
5345   guint16 type, nimages;
5346   gint32 size, offset;
5347 
5348   datalen = gst_type_find_get_length (find);
5349   if (datalen &lt; 22)
5350     return;
5351   if ((data = gst_type_find_peek (find, 0, 6)) == NULL)
5352     return;
5353 
5354   /* header - simple and not enough to rely on it alone */
5355   if (GST_READ_UINT16_LE (data) != 0)
5356     return;
5357   type = GST_READ_UINT16_LE (data + 2);
5358   if (type != 1 &amp;&amp; type != 2)
5359     return;
5360   nimages = GST_READ_UINT16_LE (data + 4);
5361   if (nimages == 0)             /* we can assume we can&#39;t have an empty image file ? */
5362     return;
5363 
5364   /* first image */
5365   if (data[6 + 3] != 0)
5366     return;
5367   if (type == 1) {
5368     guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);
5369     if (planes &gt; 1)
5370       return;
5371   }
5372   size = GST_READ_UINT32_LE (data + 6 + 8);
5373   offset = GST_READ_UINT32_LE (data + 6 + 12);
5374   if (offset &lt; 0 || size &lt;= 0 || size &gt;= datalen || offset &gt;= datalen
5375       || size + offset &gt; datalen)
5376     return;
5377 
5378   gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,
5379       &quot;image/x-icon&quot;, NULL);
5380 }
5381 
5382 /*** WAP WBMP typefinder ***/
5383 
5384 static void
5385 wbmp_typefind (GstTypeFind * find, gpointer user_data)
5386 {
5387   const guint8 *data;
5388   gint64 datalen;
5389   guint w, h, size;
5390 
5391   /* http://en.wikipedia.org/wiki/Wireless_Application_Protocol_Bitmap_Format */
5392   datalen = gst_type_find_get_length (find);
5393   if (datalen == 0)
5394     return;
5395 
5396   data = gst_type_find_peek (find, 0, 5);
5397   if (data == NULL)
5398     return;
5399 
5400   /* want 0x00 0x00 at start */
5401   if (*data++ != 0 || *data++ != 0)
5402     return;
5403 
5404   /* min header size */
5405   size = 4;
5406 
5407   /* let&#39;s assume max width/height is 65536 */
5408   w = *data++;
5409   if ((w &amp; 0x80)) {
5410     w = (w &lt;&lt; 8) | *data++;
5411     if ((w &amp; 0x80))
5412       return;
5413     ++size;
5414     data = gst_type_find_peek (find, 4, 2);
5415     if (data == NULL)
5416       return;
5417   }
5418   h = *data++;
5419   if ((h &amp; 0x80)) {
5420     h = (h &lt;&lt; 8) | *data++;
5421     if ((h &amp; 0x80))
5422       return;
5423     ++size;
5424   }
5425 
5426   if (w == 0 || h == 0)
5427     return;
5428 
5429   /* now add bitmap size */
5430   size += h * (GST_ROUND_UP_8 (w) / 8);
5431 
5432   if (datalen == size) {
5433     gst_type_find_suggest_simple (find, GST_TYPE_FIND_POSSIBLE - 10,
5434         &quot;image/vnd.wap.wbmp&quot;, NULL);
5435   }
5436 }
5437 
5438 /*** DEGAS Atari images (also to avoid false positives, see #625129) ***/
5439 static void
5440 degas_type_find (GstTypeFind * tf, gpointer private)
5441 {
5442   /* No magic, but it should have a fixed size and a few invalid values */
5443   /* http://www.fileformat.info/format/atari/spec/6ecf9f6eb5be494284a47feb8a214687/view.htm */
5444   gint64 len;
5445   const guint8 *data;
5446   guint16 resolution;
5447   int n;
5448 
5449   len = gst_type_find_get_length (tf);
5450   if (len &lt; 34)                 /* smallest header of the lot */
5451     return;
5452   data = gst_type_find_peek (tf, 0, 4);
5453   if (G_UNLIKELY (data == NULL))
5454     return;
5455   resolution = GST_READ_UINT16_BE (data);
5456   if (len == 32034) {
5457     /* could be DEGAS */
5458     if (resolution &lt;= 2)
5459       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5460           &quot;image/x-degas&quot;, NULL);
5461   } else if (len == 32066) {
5462     /* could be DEGAS Elite */
5463     if (resolution &lt;= 2) {
5464       data = gst_type_find_peek (tf, len - 16, 8);
5465       if (G_UNLIKELY (data == NULL))
5466         return;
5467       for (n = 0; n &lt; 4; n++) {
5468         if (GST_READ_UINT16_BE (data + n * 2) &gt; 2)
5469           return;
5470       }
5471       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5472           &quot;image/x-degas&quot;, NULL);
5473     }
5474   } else if (len &gt;= 66 &amp;&amp; len &lt; 32066) {
5475     /* could be compressed DEGAS Elite, but it&#39;s compressed and so we can&#39;t rely on size,
5476        it does have 4 16 bytes values near the end that are 0-2 though. */
5477     if ((resolution &amp; 0x8000) &amp;&amp; (resolution &amp; 0x7fff) &lt;= 2) {
5478       data = gst_type_find_peek (tf, len - 16, 8);
5479       if (G_UNLIKELY (data == NULL))
5480         return;
5481       for (n = 0; n &lt; 4; n++) {
5482         if (GST_READ_UINT16_BE (data + n * 2) &gt; 2)
5483           return;
5484       }
5485       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_POSSIBLE + 5,
5486           &quot;image/x-degas&quot;, NULL);
5487     }
5488   }
5489 }
5490 
5491 /*** y4m ***/
5492 
5493 static void
5494 y4m_typefind (GstTypeFind * tf, gpointer private)
5495 {
5496   const guint8 *data;
5497 
5498   data = gst_type_find_peek (tf, 0, 10);
5499   if (data != NULL &amp;&amp; memcmp (data, &quot;YUV4MPEG2 &quot;, 10) == 0) {
5500     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY,
5501         &quot;application/x-yuv4mpeg&quot;, &quot;y4mversion&quot;, G_TYPE_INT, 2, NULL);
5502   }
5503 }
5504 
5505 /*** DVD ISO images (looks like H.264, see #674069) ***/
5506 static void
5507 dvdiso_type_find (GstTypeFind * tf, gpointer private)
5508 {
5509   /* 0x8000 bytes of zeros, then &quot;\001CD001&quot; */
5510   gint64 len;
5511   const guint8 *data;
5512 
5513   len = gst_type_find_get_length (tf);
5514   if (len &lt; 0x8006)
5515     return;
5516   data = gst_type_find_peek (tf, 0, 0x8006);
5517   if (G_UNLIKELY (data == NULL))
5518     return;
5519   for (len = 0; len &lt; 0x8000; len++)
5520     if (data[len])
5521       return;
5522   /* Can the &#39;1&#39; be anything else ? My three samples all have &#39;1&#39;. */
5523   if (memcmp (data + 0x8000, &quot;\001CD001&quot;, 6))
5524     return;
5525 
5526   /* May need more inspection, we may be able to demux some of them */
5527   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY,
5528       &quot;application/octet-stream&quot;, NULL);
5529 }
5530 
5531 /* SSA/ASS subtitles
5532  *
5533  * http://en.wikipedia.org/wiki/SubStation_Alpha
5534  * http://matroska.org/technical/specs/subtitles/ssa.html
5535  */
5536 static void
5537 ssa_type_find (GstTypeFind * tf, gpointer private)
5538 {
5539   const gchar *start, *end, *ver_str, *media_type = NULL;
5540   const guint8 *data;
5541   gchar *str, *script_type, *p = NULL;
5542   gint64 len;
5543 
5544   data = gst_type_find_peek (tf, 0, 32);
5545 
5546   if (data == NULL)
5547     return;
5548 
5549   /* FIXME: detect utf-16/32 BOM and convert before typefinding the rest */
5550 
5551   /* there might be a UTF-8 BOM at the beginning */
5552   if (memcmp (data, &quot;[Script Info]&quot;, 13) != 0 &amp;&amp;
5553       memcmp (data + 3, &quot;[Script Info]&quot;, 13) != 0) {
5554     return;
5555   }
5556 
5557   /* now check if we have SSA or ASS */
5558   len = gst_type_find_get_length (tf);
5559   if (len &gt; 8192)
5560     len = 8192;
5561 
5562   data = gst_type_find_peek (tf, 0, len);
5563   if (data == NULL)
5564     return;
5565 
5566   /* skip BOM */
5567   start = (gchar *) memchr (data, &#39;[&#39;, 5);
5568   g_assert (start);
5569   len -= (start - (gchar *) data);
5570 
5571   /* ignore anything non-UTF8 for now, in future we might at least allow
5572    * other UTF variants that are clearly prefixed with the appropriate BOM */
5573   if (!g_utf8_validate (start, len, &amp;end) &amp;&amp; (len - (end - start)) &gt; 6) {
5574     GST_FIXME (&quot;non-UTF8 SSA/ASS file&quot;);
5575     return;
5576   }
5577 
5578   /* something at start,  but not a UTF-8 BOM? */
5579   if (data[0] != &#39;[&#39; &amp;&amp; (data[0] != 0xEF || data[1] != 0xBB || data[2] != 0xBF))
5580     return;
5581 
5582   /* ignore any partial UTF-8 characters at the end */
5583   len = end - start;
5584 
5585   /* create a NUL-terminated string so it&#39;s easier to process it safely */
5586   str = g_strndup (start, len - 1);
5587   script_type = strstr (str, &quot;ScriptType:&quot;);
5588   if (script_type != NULL) {
5589     gdouble version;
5590 
5591     ver_str = script_type + 11;
5592     while (*ver_str == &#39; &#39; || *ver_str == &#39;v&#39; || *ver_str == &#39;V&#39;)
5593       ++ver_str;
5594     version = g_ascii_strtod (ver_str, &amp;p);
5595     if (version == 4.0 &amp;&amp; p != NULL &amp;&amp; *p == &#39;+&#39;)
5596       media_type = &quot;application/x-ass&quot;;
5597     else if (version &gt;= 1.0 &amp;&amp; version &lt;= 4.0)
5598       media_type = &quot;application/x-ssa&quot;;
5599   }
5600 
5601   if (media_type == NULL) {
5602     if (strstr (str, &quot;[v4+ Styles]&quot;) || strstr (str, &quot;[V4+ Styles]&quot;))
5603       media_type = &quot;application/x-ass&quot;;
5604     else if (strstr (str, &quot;[v4 Styles]&quot;) || strstr (str, &quot;[V4 Styles]&quot;))
5605       media_type = &quot;application/x-ssa&quot;;
5606   }
5607 
5608   if (media_type != NULL) {
5609     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
5610         media_type, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5611   } else {
5612     GST_WARNING (&quot;could not detect SSA/ASS variant&quot;);
5613   }
5614 
5615   g_free (str);
5616 }
5617 
<a name="40" id="anc40"></a>

























5618 /*** video/x-pva ***/
5619 
5620 static GstStaticCaps pva_caps = GST_STATIC_CAPS (&quot;video/x-pva&quot;);
5621 
5622 #define PVA_CAPS gst_static_caps_get(&amp;pva_caps)
5623 
5624 static void
5625 pva_type_find (GstTypeFind * tf, gpointer private)
5626 {
5627   const guint8 *data;
5628 
5629   data = gst_type_find_peek (tf, 0, 5);
5630 
5631   if (data == NULL)
5632     return;
5633 
5634   if (data[0] == &#39;A&#39; &amp;&amp; data[1] == &#39;V&#39; &amp;&amp; data[2] &lt; 3 &amp;&amp; data[4] == 0x55)
5635     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, PVA_CAPS);
5636 }
5637 
5638 /*** audio/audible ***/
5639 
5640 /* derived from pyaudibletags
5641  * http://code.google.com/p/pyaudibletags/source/browse/trunk/pyaudibletags.py
5642  */
5643 static GstStaticCaps aa_caps = GST_STATIC_CAPS (&quot;audio/x-audible&quot;);
5644 
5645 #define AA_CAPS gst_static_caps_get(&amp;aa_caps)
5646 
5647 static void
5648 aa_type_find (GstTypeFind * tf, gpointer private)
5649 {
5650   const guint8 *data;
5651 
5652   data = gst_type_find_peek (tf, 0, 12);
5653   if (data == NULL)
5654     return;
5655 
5656   if (GST_READ_UINT32_BE (data + 4) == 0x57907536) {
5657     guint64 media_len;
5658 
5659     media_len = gst_type_find_get_length (tf);
5660     if (media_len &gt; 0 &amp;&amp; GST_READ_UINT32_BE (data) == media_len)
5661       gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, AA_CAPS);
5662     else
5663       gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, AA_CAPS);
5664   }
5665 }
5666 
5667 /*** generic typefind for streams that have some data at a specific position***/
5668 typedef struct
5669 {
5670   const guint8 *data;
5671   guint size;
5672   guint probability;
5673   GstCaps *caps;
5674 }
5675 GstTypeFindData;
5676 
5677 static void
5678 start_with_type_find (GstTypeFind * tf, gpointer private)
5679 {
5680   GstTypeFindData *start_with = (GstTypeFindData *) private;
5681   const guint8 *data;
5682 
5683   GST_LOG (&quot;trying to find mime type %s with the first %u bytes of data&quot;,
5684       gst_structure_get_name (gst_caps_get_structure (start_with-&gt;caps, 0)),
5685       start_with-&gt;size);
5686   data = gst_type_find_peek (tf, 0, start_with-&gt;size);
5687   if (data &amp;&amp; memcmp (data, start_with-&gt;data, start_with-&gt;size) == 0) {
5688     gst_type_find_suggest (tf, start_with-&gt;probability, start_with-&gt;caps);
5689   }
5690 }
5691 
5692 static void
5693 sw_data_destroy (GstTypeFindData * sw_data)
5694 {
5695   if (G_LIKELY (sw_data-&gt;caps != NULL))
5696     gst_caps_unref (sw_data-&gt;caps);
5697   g_slice_free (GstTypeFindData, sw_data);
5698 }
5699 
5700 #define TYPE_FIND_REGISTER_START_WITH(plugin,name,rank,ext,_data,_size,_probability)\
5701 G_BEGIN_DECLS{                                                          \
5702   GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \
5703   sw_data-&gt;data = (const guint8 *)_data;                                \
5704   sw_data-&gt;size = _size;                                                \
5705   sw_data-&gt;probability = _probability;                                  \
5706   sw_data-&gt;caps = gst_caps_new_empty_simple (name);                     \
5707   if (!gst_type_find_register (plugin, name, rank, start_with_type_find,\
5708                      ext, sw_data-&gt;caps, sw_data,                       \
5709                      (GDestroyNotify) (sw_data_destroy))) {             \
5710     sw_data_destroy (sw_data);                                          \
5711   }                                                                     \
5712 }G_END_DECLS
5713 
5714 /*** same for riff types ***/
5715 
5716 static void
5717 riff_type_find (GstTypeFind * tf, gpointer private)
5718 {
5719   GstTypeFindData *riff_data = (GstTypeFindData *) private;
5720   const guint8 *data = gst_type_find_peek (tf, 0, 12);
5721 
5722   if (data &amp;&amp; (memcmp (data, &quot;RIFF&quot;, 4) == 0 || memcmp (data, &quot;AVF0&quot;, 4) == 0)) {
5723     data += 8;
5724     if (memcmp (data, riff_data-&gt;data, 4) == 0)
5725       gst_type_find_suggest (tf, riff_data-&gt;probability, riff_data-&gt;caps);
5726   }
5727 }
5728 
5729 #define TYPE_FIND_REGISTER_RIFF(plugin,name,rank,ext,_data)             \
5730 G_BEGIN_DECLS{                                                          \
5731   GstTypeFindData *sw_data = g_slice_new (GstTypeFindData);             \
5732   sw_data-&gt;data = (gpointer)_data;                                      \
5733   sw_data-&gt;size = 4;                                                    \
5734   sw_data-&gt;probability = GST_TYPE_FIND_MAXIMUM;                         \
5735   sw_data-&gt;caps = gst_caps_new_empty_simple (name);                     \
5736   if (!gst_type_find_register (plugin, name, rank, riff_type_find,      \
5737                       ext, sw_data-&gt;caps, sw_data,                      \
5738                       (GDestroyNotify) (sw_data_destroy))) {            \
5739     sw_data_destroy (sw_data);                                          \
5740   }                                                                     \
5741 }G_END_DECLS
5742 
5743 
5744 /*** plugin initialization ***/
5745 
5746 #define TYPE_FIND_REGISTER(plugin,name,rank,func,ext,caps,priv,notify) \
5747 G_BEGIN_DECLS{\
5748   if (!gst_type_find_register (plugin, name, rank, func, ext, caps, priv, notify))\
5749     return FALSE; \
5750 }G_END_DECLS
5751 
5752 
5753 #ifdef GSTREAMER_LITE
5754 gboolean
5755 plugin_init_typefind (GstPlugin * plugin)
5756 #else // GSTREAMER_LITE
5757 static gboolean
5758 plugin_init (GstPlugin * plugin)
5759 #endif // GSTREAMER_LITE
5760 {
5761   /* can&#39;t initialize this via a struct as caps can&#39;t be statically initialized */
5762 
5763   GST_DEBUG_CATEGORY_INIT (type_find_debug, &quot;typefindfunctions&quot;,
5764       GST_DEBUG_FG_GREEN | GST_DEBUG_BG_RED, &quot;generic type find functions&quot;);
5765 
5766   /* note: asx/wax/wmx are XML files, asf doesn&#39;t handle them */
5767   /* must use strings, macros don&#39;t accept initializers */
5768 #ifndef GSTREAMER_LITE
5769   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ms-asf&quot;, GST_RANK_SECONDARY,
5770       &quot;asf,wm,wma,wmv&quot;,
5771       &quot;\060\046\262\165\216\146\317\021\246\331\000\252\000\142\316\154&quot;, 16,
5772       GST_TYPE_FIND_MAXIMUM);
5773   TYPE_FIND_REGISTER (plugin, &quot;audio/x-musepack&quot;, GST_RANK_PRIMARY,
5774       musepack_type_find, &quot;mpc,mpp,mp+&quot;, MUSEPACK_CAPS, NULL, NULL);
5775   TYPE_FIND_REGISTER (plugin, &quot;audio/x-au&quot;, GST_RANK_MARGINAL,
5776       au_type_find, &quot;au,snd&quot;, AU_CAPS, NULL, NULL);
5777   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-msvideo&quot;, GST_RANK_PRIMARY,
5778       &quot;avi&quot;, &quot;AVI &quot;);
5779   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/qcelp&quot;, GST_RANK_PRIMARY,
5780       &quot;qcp&quot;, &quot;QLCM&quot;);
5781   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-cdxa&quot;, GST_RANK_PRIMARY,
5782       &quot;dat&quot;, &quot;CDXA&quot;);
5783   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-vcd&quot;, GST_RANK_PRIMARY,
5784       &quot;dat&quot;, &quot;\000\377\377\377\377\377\377\377\377\377\377\000&quot;, 12,
5785       GST_TYPE_FIND_MAXIMUM);
5786   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-imelody&quot;, GST_RANK_PRIMARY,
5787       &quot;imy,ime,imelody&quot;, &quot;BEGIN:IMELODY&quot;, 13, GST_TYPE_FIND_MAXIMUM);
<a name="41" id="anc41"></a>




5788 #if 0
5789   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-smoke&quot;, GST_RANK_PRIMARY,
5790       NULL, &quot;\x80smoke\x00\x01\x00&quot;, 6, GST_TYPE_FIND_MAXIMUM);
5791 #endif
5792   TYPE_FIND_REGISTER (plugin, &quot;audio/midi&quot;, GST_RANK_PRIMARY, mid_type_find,
5793       &quot;mid,midi&quot;, MID_CAPS, NULL, NULL);
5794   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/riff-midi&quot;, GST_RANK_PRIMARY,
5795       &quot;mid,midi&quot;, &quot;RMID&quot;);
5796   TYPE_FIND_REGISTER (plugin, &quot;audio/mobile-xmf&quot;, GST_RANK_PRIMARY,
5797       mxmf_type_find, &quot;mxmf&quot;, MXMF_CAPS, NULL, NULL);
5798   TYPE_FIND_REGISTER (plugin, &quot;video/x-fli&quot;, GST_RANK_MARGINAL, flx_type_find,
5799       &quot;flc,fli&quot;, FLX_CAPS, NULL, NULL);
5800   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v2&quot;, GST_RANK_PRIMARY + 103,
5801       id3v2_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5802   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v1&quot;, GST_RANK_PRIMARY + 101,
5803       id3v1_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5804   TYPE_FIND_REGISTER (plugin, &quot;application/x-apetag&quot;, GST_RANK_PRIMARY + 102,
5805       apetag_type_find, &quot;mp3,ape,mpc,wv&quot;, APETAG_CAPS, NULL, NULL);
5806   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ttafile&quot;, GST_RANK_PRIMARY,
5807       tta_type_find, &quot;tta&quot;, TTA_CAPS, NULL, NULL);
5808   TYPE_FIND_REGISTER (plugin, &quot;audio/x-mod&quot;, GST_RANK_SECONDARY, mod_type_find,
5809       &quot;669,amf,ams,dbm,digi,dmf,dsm,gdm,far,imf,it,j2b,mdl,med,mod,mt2,mtm,&quot;
5810       &quot;okt,psm,ptm,sam,s3m,stm,stx,ult,umx,xm&quot;, MOD_CAPS, NULL, NULL);
5811 #endif // GSTREAMER_LITE
5812   TYPE_FIND_REGISTER (plugin, &quot;audio/mpeg&quot;, GST_RANK_PRIMARY, mp3_type_find,
5813       &quot;mp3,mp2,mp1,mpga&quot;, MP3_CAPS, NULL, NULL);
5814 #ifndef GSTREAMER_LITE
5815   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ac3&quot;, GST_RANK_PRIMARY, ac3_type_find,
5816       &quot;ac3,eac3&quot;, AC3_CAPS, NULL, NULL);
5817   TYPE_FIND_REGISTER (plugin, &quot;audio/x-dts&quot;, GST_RANK_SECONDARY, dts_type_find,
5818       &quot;dts&quot;, DTS_CAPS, NULL, NULL);
5819   TYPE_FIND_REGISTER (plugin, &quot;audio/x-gsm&quot;, GST_RANK_PRIMARY, NULL, &quot;gsm&quot;,
5820       GSM_CAPS, NULL, NULL);
5821   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg-sys&quot;, GST_RANK_PRIMARY,
5822       mpeg_sys_type_find, &quot;mpe,mpeg,mpg&quot;, MPEG_SYS_CAPS, NULL, NULL);
5823   TYPE_FIND_REGISTER (plugin, &quot;video/mpegts&quot;, GST_RANK_PRIMARY,
5824       mpeg_ts_type_find, &quot;ts,mts&quot;, MPEGTS_CAPS, NULL, NULL);
5825   TYPE_FIND_REGISTER (plugin, &quot;application/ogg&quot;, GST_RANK_PRIMARY,
5826       ogganx_type_find, &quot;ogg,oga,ogv,ogm,ogx,spx,anx,axa,axv&quot;, OGG_CAPS,
5827       NULL, NULL);
5828   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg-elementary&quot;, GST_RANK_MARGINAL,
5829       mpeg_video_stream_type_find, &quot;mpv,mpeg,mpg&quot;, MPEG_VIDEO_CAPS, NULL, NULL);
5830   TYPE_FIND_REGISTER (plugin, &quot;video/mpeg4&quot;, GST_RANK_PRIMARY,
5831       mpeg4_video_type_find, &quot;m4v&quot;, MPEG_VIDEO_CAPS, NULL, NULL);
5832   TYPE_FIND_REGISTER (plugin, &quot;video/x-h263&quot;, GST_RANK_SECONDARY,
5833       h263_video_type_find, &quot;h263,263&quot;, H263_VIDEO_CAPS, NULL, NULL);
5834   TYPE_FIND_REGISTER (plugin, &quot;video/x-h264&quot;, GST_RANK_PRIMARY,
5835       h264_video_type_find, &quot;h264,x264,264&quot;, H264_VIDEO_CAPS, NULL, NULL);
5836   TYPE_FIND_REGISTER (plugin, &quot;video/x-h265&quot;, GST_RANK_PRIMARY,
5837       h265_video_type_find, &quot;h265,x265,265&quot;, H265_VIDEO_CAPS, NULL, NULL);
5838   TYPE_FIND_REGISTER (plugin, &quot;video/x-nuv&quot;, GST_RANK_SECONDARY, nuv_type_find,
5839       &quot;nuv&quot;, NUV_CAPS, NULL, NULL);
5840 
5841   /* ISO formats */
5842   TYPE_FIND_REGISTER (plugin, &quot;audio/x-m4a&quot;, GST_RANK_PRIMARY, m4a_type_find,
5843       &quot;m4a&quot;, M4A_CAPS, NULL, NULL);
5844   TYPE_FIND_REGISTER (plugin, &quot;application/x-3gp&quot;, GST_RANK_PRIMARY,
5845       q3gp_type_find, &quot;3gp&quot;, Q3GP_CAPS, NULL, NULL);
5846   TYPE_FIND_REGISTER (plugin, &quot;video/quicktime&quot;, GST_RANK_PRIMARY,
5847       qt_type_find, &quot;mov,mp4&quot;, QT_CAPS, NULL, NULL);
5848   TYPE_FIND_REGISTER (plugin, &quot;image/x-quicktime&quot;, GST_RANK_SECONDARY,
5849       qtif_type_find, &quot;qif,qtif,qti&quot;, QTIF_CAPS, NULL, NULL);
5850   TYPE_FIND_REGISTER (plugin, &quot;image/jp2&quot;, GST_RANK_PRIMARY,
5851       jp2_type_find, &quot;jp2&quot;, JP2_CAPS, NULL, NULL);
5852   TYPE_FIND_REGISTER (plugin, &quot;image/x-jpc&quot;, GST_RANK_PRIMARY,
5853       jpc_type_find, &quot;jpc,j2k&quot;, JPC_CAPS, NULL, NULL);
5854   TYPE_FIND_REGISTER (plugin, &quot;video/mj2&quot;, GST_RANK_PRIMARY,
5855       jp2_type_find, &quot;mj2&quot;, MJ2_CAPS, NULL, NULL);
5856 
5857   TYPE_FIND_REGISTER (plugin, &quot;text/html&quot;, GST_RANK_SECONDARY, html_type_find,
5858       &quot;htm,html&quot;, HTML_CAPS, NULL, NULL);
5859   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/vnd.rn-realmedia&quot;,
5860       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.RMF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5861   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-pn-realaudio&quot;,
5862       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.ra\375&quot;, 4,
5863       GST_TYPE_FIND_MAXIMUM);
5864   TYPE_FIND_REGISTER (plugin, &quot;application/x-shockwave-flash&quot;,
5865       GST_RANK_SECONDARY, swf_type_find, &quot;swf,swfl&quot;, SWF_CAPS, NULL, NULL);
<a name="42" id="anc42"></a>

5866   TYPE_FIND_REGISTER (plugin, &quot;application/dash+xml&quot;,
5867       GST_RANK_PRIMARY, dash_mpd_type_find, &quot;mpd,MPD&quot;, DASH_CAPS, NULL, NULL);
5868   TYPE_FIND_REGISTER (plugin, &quot;application/vnd.ms-sstr+xml&quot;,
5869       GST_RANK_PRIMARY, mss_manifest_type_find, NULL, MSS_MANIFEST_CAPS, NULL,
5870       NULL);
5871 #endif // GSTREAMER_LITE
5872   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-flv&quot;, GST_RANK_SECONDARY,
5873       &quot;flv&quot;, &quot;FLV&quot;, 3, GST_TYPE_FIND_MAXIMUM);
5874 #ifndef GSTREAMER_LITE
5875   TYPE_FIND_REGISTER (plugin, &quot;text/plain&quot;, GST_RANK_MARGINAL, utf8_type_find,
5876       &quot;txt&quot;, UTF8_CAPS, NULL, NULL);
5877   TYPE_FIND_REGISTER (plugin, &quot;text/utf-16&quot;, GST_RANK_MARGINAL, utf16_type_find,
5878       &quot;txt&quot;, UTF16_CAPS, NULL, NULL);
5879   TYPE_FIND_REGISTER (plugin, &quot;text/utf-32&quot;, GST_RANK_MARGINAL, utf32_type_find,
5880       &quot;txt&quot;, UTF32_CAPS, NULL, NULL);
5881   TYPE_FIND_REGISTER (plugin, &quot;text/uri-list&quot;, GST_RANK_MARGINAL, uri_type_find,
5882       &quot;ram&quot;, URI_CAPS, NULL, NULL);
5883   TYPE_FIND_REGISTER (plugin, &quot;application/itc&quot;, GST_RANK_SECONDARY,
5884       itc_type_find, &quot;itc&quot;, ITC_CAPS, NULL, NULL);
5885   TYPE_FIND_REGISTER (plugin, &quot;application/x-hls&quot;, GST_RANK_MARGINAL,
5886       hls_type_find, &quot;m3u8&quot;, HLS_CAPS, NULL, NULL);
5887   TYPE_FIND_REGISTER (plugin, &quot;application/sdp&quot;, GST_RANK_SECONDARY,
5888       sdp_type_find, &quot;sdp&quot;, SDP_CAPS, NULL, NULL);
5889   TYPE_FIND_REGISTER (plugin, &quot;application/smil&quot;, GST_RANK_SECONDARY,
5890       smil_type_find, &quot;smil&quot;, SMIL_CAPS, NULL, NULL);
5891   TYPE_FIND_REGISTER (plugin, &quot;application/ttml+xml&quot;, GST_RANK_SECONDARY,
5892       ttml_xml_type_find, &quot;ttml+xml&quot;, TTML_XML_CAPS, NULL, NULL);
5893   TYPE_FIND_REGISTER (plugin, &quot;application/xml&quot;, GST_RANK_MARGINAL,
5894       xml_type_find, &quot;xml&quot;, GENERIC_XML_CAPS, NULL, NULL);
5895 #endif // GSTREAMER_LITE
5896   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/x-wav&quot;, GST_RANK_PRIMARY, &quot;wav&quot;,
5897       &quot;WAVE&quot;);
5898   TYPE_FIND_REGISTER (plugin, &quot;audio/x-aiff&quot;, GST_RANK_SECONDARY,
5899       aiff_type_find, &quot;aiff,aif,aifc&quot;, AIFF_CAPS, NULL, NULL);
5900 #ifndef GSTREAMER_LITE
5901   TYPE_FIND_REGISTER (plugin, &quot;audio/x-svx&quot;, GST_RANK_SECONDARY, svx_type_find,
5902       &quot;iff,svx&quot;, SVX_CAPS, NULL, NULL);
5903   TYPE_FIND_REGISTER (plugin, &quot;audio/x-paris&quot;, GST_RANK_SECONDARY,
5904       paris_type_find, &quot;paf&quot;, PARIS_CAPS, NULL, NULL);
5905   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-nist&quot;, GST_RANK_SECONDARY,
5906       &quot;nist&quot;, &quot;NIST&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5907   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-voc&quot;, GST_RANK_SECONDARY,
5908       &quot;voc&quot;, &quot;Creative&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5909   TYPE_FIND_REGISTER (plugin, &quot;audio/x-sds&quot;, GST_RANK_SECONDARY, sds_type_find,
5910       &quot;sds&quot;, SDS_CAPS, NULL, NULL);
5911   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ircam&quot;, GST_RANK_SECONDARY,
5912       ircam_type_find, &quot;sf&quot;, IRCAM_CAPS, NULL, NULL);
5913   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-w64&quot;, GST_RANK_SECONDARY,
5914       &quot;w64&quot;, &quot;riff&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5915   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-rf64&quot;, GST_RANK_PRIMARY,
5916       &quot;rf64&quot;, &quot;RF64&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5917   TYPE_FIND_REGISTER (plugin, &quot;audio/x-shorten&quot;, GST_RANK_SECONDARY,
5918       shn_type_find, &quot;shn&quot;, SHN_CAPS, NULL, NULL);
5919   TYPE_FIND_REGISTER (plugin, &quot;application/x-ape&quot;, GST_RANK_SECONDARY,
5920       ape_type_find, &quot;ape&quot;, APE_CAPS, NULL, NULL);
5921   TYPE_FIND_REGISTER (plugin, &quot;image/jpeg&quot;, GST_RANK_PRIMARY + 15,
5922       jpeg_type_find, &quot;jpg,jpe,jpeg&quot;, JPEG_CAPS, NULL, NULL);
5923   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/gif&quot;, GST_RANK_PRIMARY, &quot;gif&quot;,
5924       &quot;GIF8&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5925   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/png&quot;, GST_RANK_PRIMARY + 14,
5926       &quot;png&quot;, &quot;\211PNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5927   TYPE_FIND_REGISTER (plugin, &quot;image/bmp&quot;, GST_RANK_PRIMARY, bmp_type_find,
5928       &quot;bmp&quot;, BMP_CAPS, NULL, NULL);
5929   TYPE_FIND_REGISTER (plugin, &quot;image/tiff&quot;, GST_RANK_PRIMARY, tiff_type_find,
5930       &quot;tif,tiff&quot;, TIFF_CAPS, NULL, NULL);
5931   TYPE_FIND_REGISTER_RIFF (plugin, &quot;image/webp&quot;, GST_RANK_PRIMARY,
5932       &quot;webp&quot;, &quot;WEBP&quot;);
5933   TYPE_FIND_REGISTER (plugin, &quot;image/x-exr&quot;, GST_RANK_PRIMARY, exr_type_find,
5934       &quot;exr&quot;, EXR_CAPS, NULL, NULL);
5935   TYPE_FIND_REGISTER (plugin, &quot;image/x-portable-pixmap&quot;, GST_RANK_SECONDARY,
5936       pnm_type_find, &quot;pnm,ppm,pgm,pbm&quot;, PNM_CAPS, NULL, NULL);
5937   TYPE_FIND_REGISTER (plugin, &quot;video/x-matroska&quot;, GST_RANK_PRIMARY,
5938       matroska_type_find, &quot;mkv,mka,mk3d,webm&quot;, MATROSKA_CAPS, NULL, NULL);
5939   TYPE_FIND_REGISTER (plugin, &quot;application/mxf&quot;, GST_RANK_PRIMARY,
5940       mxf_type_find, &quot;mxf&quot;, MXF_CAPS, NULL, NULL);
5941   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-mve&quot;, GST_RANK_SECONDARY,
5942       &quot;mve&quot;, &quot;Interplay MVE File\032\000\032\000\000\001\063\021&quot;, 26,
5943       GST_TYPE_FIND_MAXIMUM);
5944   TYPE_FIND_REGISTER (plugin, &quot;video/x-dv&quot;, GST_RANK_SECONDARY, dv_type_find,
5945       &quot;dv,dif&quot;, DV_CAPS, NULL, NULL);
5946   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-amr-nb-sh&quot;, GST_RANK_PRIMARY,
5947       &quot;amr&quot;, &quot;#!AMR&quot;, 5, GST_TYPE_FIND_LIKELY);
5948   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-amr-wb-sh&quot;, GST_RANK_PRIMARY,
5949       &quot;amr&quot;, &quot;#!AMR-WB&quot;, 7, GST_TYPE_FIND_MAXIMUM);
5950   TYPE_FIND_REGISTER (plugin, &quot;audio/iLBC-sh&quot;, GST_RANK_PRIMARY, ilbc_type_find,
5951       &quot;ilbc&quot;, ILBC_CAPS, NULL, NULL);
5952   TYPE_FIND_REGISTER (plugin, &quot;audio/x-sbc&quot;, GST_RANK_MARGINAL, sbc_type_find,
5953       &quot;sbc&quot;, SBC_CAPS, NULL, NULL);
5954   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-sid&quot;, GST_RANK_MARGINAL,
5955       &quot;sid&quot;, &quot;PSID&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5956   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-xcf&quot;, GST_RANK_SECONDARY,
5957       &quot;xcf&quot;, &quot;gimp xcf&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5958   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-mng&quot;, GST_RANK_SECONDARY,
5959       &quot;mng&quot;, &quot;\212MNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5960   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-jng&quot;, GST_RANK_SECONDARY,
5961       &quot;jng&quot;, &quot;\213JNG\015\012\032\012&quot;, 8, GST_TYPE_FIND_MAXIMUM);
5962   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-xpixmap&quot;, GST_RANK_SECONDARY,
5963       &quot;xpm&quot;, &quot;/* XPM */&quot;, 9, GST_TYPE_FIND_MAXIMUM);
5964   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/x-sun-raster&quot;,
5965       GST_RANK_SECONDARY, &quot;ras&quot;, &quot;\131\246\152\225&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5966   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-bzip&quot;,
5967       GST_RANK_SECONDARY, &quot;bz2&quot;, &quot;BZh&quot;, 3, GST_TYPE_FIND_LIKELY);
5968   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-gzip&quot;,
5969       GST_RANK_SECONDARY, &quot;gz&quot;, &quot;\037\213&quot;, 2, GST_TYPE_FIND_LIKELY);
5970   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/zip&quot;, GST_RANK_SECONDARY,
5971       &quot;zip&quot;, &quot;PK\003\004&quot;, 4, GST_TYPE_FIND_LIKELY);
5972   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-compress&quot;,
5973       GST_RANK_SECONDARY, &quot;Z&quot;, &quot;\037\235&quot;, 2, GST_TYPE_FIND_LIKELY);
5974   TYPE_FIND_REGISTER (plugin, &quot;subtitle/x-kate&quot;, GST_RANK_MARGINAL,
5975       kate_type_find, NULL, NULL, NULL, NULL);
5976   TYPE_FIND_REGISTER (plugin, &quot;application/x-subtitle-vtt&quot;, GST_RANK_MARGINAL,
5977       webvtt_type_find, &quot;vtt&quot;, WEBVTT_CAPS, NULL, NULL);
5978   TYPE_FIND_REGISTER (plugin, &quot;audio/x-flac&quot;, GST_RANK_PRIMARY, flac_type_find,
5979       &quot;flac&quot;, FLAC_CAPS, NULL, NULL);
5980   TYPE_FIND_REGISTER (plugin, &quot;audio/x-vorbis&quot;, GST_RANK_PRIMARY,
5981       vorbis_type_find, NULL, VORBIS_CAPS, NULL, NULL);
5982   TYPE_FIND_REGISTER (plugin, &quot;video/x-theora&quot;, GST_RANK_PRIMARY,
5983       theora_type_find, NULL, THEORA_CAPS, NULL, NULL);
5984   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-video&quot;, GST_RANK_PRIMARY,
5985       ogmvideo_type_find, NULL, OGMVIDEO_CAPS, NULL, NULL);
5986   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-audio&quot;, GST_RANK_PRIMARY,
5987       ogmaudio_type_find, NULL, OGMAUDIO_CAPS, NULL, NULL);
5988   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogm-text&quot;, GST_RANK_PRIMARY,
5989       ogmtext_type_find, NULL, OGMTEXT_CAPS, NULL, NULL);
5990   TYPE_FIND_REGISTER (plugin, &quot;audio/x-speex&quot;, GST_RANK_PRIMARY,
5991       speex_type_find, NULL, SPEEX_CAPS, NULL, NULL);
5992   TYPE_FIND_REGISTER (plugin, &quot;audio/x-celt&quot;, GST_RANK_PRIMARY, celt_type_find,
5993       NULL, CELT_CAPS, NULL, NULL);
5994   TYPE_FIND_REGISTER (plugin, &quot;application/x-ogg-skeleton&quot;, GST_RANK_PRIMARY,
5995       oggskel_type_find, NULL, OGG_SKELETON_CAPS, NULL, NULL);
5996   TYPE_FIND_REGISTER (plugin, &quot;text/x-cmml&quot;, GST_RANK_PRIMARY, cmml_type_find,
5997       NULL, CMML_CAPS, NULL, NULL);
5998   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-executable&quot;,
5999       GST_RANK_MARGINAL, NULL, &quot;\177ELF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6000   TYPE_FIND_REGISTER (plugin, &quot;audio/aac&quot;, GST_RANK_SECONDARY, aac_type_find,
6001       &quot;aac,adts,adif,loas&quot;, AAC_CAPS, NULL, NULL);
6002   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-spc&quot;, GST_RANK_SECONDARY,
6003       &quot;spc&quot;, &quot;SNES-SPC700 Sound File Data&quot;, 27, GST_TYPE_FIND_MAXIMUM);
6004   TYPE_FIND_REGISTER (plugin, &quot;audio/x-wavpack&quot;, GST_RANK_SECONDARY,
6005       wavpack_type_find, &quot;wv,wvp&quot;, WAVPACK_CAPS, NULL, NULL);
6006   TYPE_FIND_REGISTER (plugin, &quot;audio/x-wavpack-correction&quot;, GST_RANK_SECONDARY,
6007       wavpack_type_find, &quot;wvc&quot;, WAVPACK_CORRECTION_CAPS, NULL, NULL);
6008   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-caf&quot;, GST_RANK_SECONDARY,
6009       &quot;caf&quot;, &quot;caff\000\001&quot;, 6, GST_TYPE_FIND_MAXIMUM);
6010   TYPE_FIND_REGISTER (plugin, &quot;application/postscript&quot;, GST_RANK_SECONDARY,
6011       postscript_type_find, &quot;ps&quot;, POSTSCRIPT_CAPS, NULL, NULL);
6012   TYPE_FIND_REGISTER (plugin, &quot;image/svg+xml&quot;, GST_RANK_SECONDARY,
6013       svg_type_find, &quot;svg&quot;, SVG_CAPS, NULL, NULL);
6014   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-rar&quot;,
6015       GST_RANK_SECONDARY, &quot;rar&quot;, &quot;Rar!&quot;, 4, GST_TYPE_FIND_LIKELY);
6016   TYPE_FIND_REGISTER (plugin, &quot;application/x-tar&quot;, GST_RANK_SECONDARY,
6017       tar_type_find, &quot;tar&quot;, TAR_CAPS, NULL, NULL);
6018   TYPE_FIND_REGISTER (plugin, &quot;application/x-ar&quot;, GST_RANK_SECONDARY,
6019       ar_type_find, &quot;a&quot;, AR_CAPS, NULL, NULL);
6020   TYPE_FIND_REGISTER (plugin, &quot;application/x-ms-dos-executable&quot;,
6021       GST_RANK_SECONDARY, msdos_type_find, &quot;dll,exe,ocx,sys,scr,msstyles,cpl&quot;,
6022       MSDOS_CAPS, NULL, NULL);
6023   TYPE_FIND_REGISTER (plugin, &quot;video/x-dirac&quot;, GST_RANK_PRIMARY,
6024       dirac_type_find, NULL, DIRAC_CAPS, NULL, NULL);
6025   TYPE_FIND_REGISTER (plugin, &quot;multipart/x-mixed-replace&quot;, GST_RANK_SECONDARY,
6026       multipart_type_find, NULL, MULTIPART_CAPS, NULL, NULL);
6027   TYPE_FIND_REGISTER (plugin, &quot;application/x-mmsh&quot;, GST_RANK_SECONDARY,
6028       mmsh_type_find, NULL, MMSH_CAPS, NULL, NULL);
6029   TYPE_FIND_REGISTER (plugin, &quot;video/vivo&quot;, GST_RANK_SECONDARY, vivo_type_find,
6030       &quot;viv&quot;, VIVO_CAPS, NULL, NULL);
6031   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-nsf&quot;, GST_RANK_SECONDARY,
6032       &quot;nsf&quot;, &quot;NESM\x1a&quot;, 5, GST_TYPE_FIND_MAXIMUM);
6033   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-gym&quot;, GST_RANK_SECONDARY,
6034       &quot;gym&quot;, &quot;GYMX&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6035   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-ay&quot;, GST_RANK_SECONDARY, &quot;ay&quot;,
6036       &quot;ZXAYEMUL&quot;, 8, GST_TYPE_FIND_MAXIMUM);
6037   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-gbs&quot;, GST_RANK_SECONDARY,
6038       &quot;gbs&quot;, &quot;GBS\x01&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6039   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-vgm&quot;, GST_RANK_SECONDARY,
6040       &quot;vgm&quot;, &quot;Vgm\x20&quot;, 4, GST_TYPE_FIND_MAXIMUM);
6041   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-sap&quot;, GST_RANK_SECONDARY,
6042       &quot;sap&quot;, &quot;SAP\x0d\x0a&quot; &quot;AUTHOR\x20&quot;, 12, GST_TYPE_FIND_MAXIMUM);
6043   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ivf&quot;, GST_RANK_SECONDARY,
6044       &quot;ivf&quot;, &quot;DKIF&quot;, 4, GST_TYPE_FIND_NEARLY_CERTAIN);
6045   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-kss&quot;, GST_RANK_SECONDARY,
6046       &quot;kss&quot;, &quot;KSSX\0&quot;, 5, GST_TYPE_FIND_MAXIMUM);
6047   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/pdf&quot;, GST_RANK_SECONDARY,
6048       &quot;pdf&quot;, &quot;%PDF-&quot;, 5, GST_TYPE_FIND_LIKELY);
6049   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/msword&quot;,
6050       GST_RANK_SECONDARY, &quot;doc&quot;, &quot;\320\317\021\340\241\261\032\341&quot;, 8,
6051       GST_TYPE_FIND_LIKELY);
6052   /* Mac OS X .DS_Store files tend to be taken for video/mpeg */
6053   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/octet-stream&quot;,
6054       GST_RANK_SECONDARY, &quot;DS_Store&quot;, &quot;\000\000\000\001Bud1&quot;, 8,
6055       GST_TYPE_FIND_LIKELY);
6056   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;image/vnd.adobe.photoshop&quot;,
6057       GST_RANK_SECONDARY, &quot;psd&quot;, &quot;8BPS\000\001\000\000\000\000&quot;, 10,
6058       GST_TYPE_FIND_LIKELY);
6059   TYPE_FIND_REGISTER (plugin, &quot;image/vnd.wap.wbmp&quot;, GST_RANK_MARGINAL,
6060       wbmp_typefind, NULL, NULL, NULL, NULL);
6061   TYPE_FIND_REGISTER (plugin, &quot;application/x-yuv4mpeg&quot;, GST_RANK_SECONDARY,
6062       y4m_typefind, NULL, NULL, NULL, NULL);
6063   TYPE_FIND_REGISTER (plugin, &quot;image/x-icon&quot;, GST_RANK_MARGINAL,
6064       windows_icon_typefind, NULL, NULL, NULL, NULL);
6065 
6066 #ifdef USE_GIO
6067   TYPE_FIND_REGISTER (plugin, &quot;xdgmime-base&quot;, GST_RANK_MARGINAL,
6068       xdgmime_typefind, NULL, NULL, NULL, NULL);
6069 #endif
6070 
6071   TYPE_FIND_REGISTER (plugin, &quot;image/x-degas&quot;, GST_RANK_MARGINAL,
6072       degas_type_find, NULL, NULL, NULL, NULL);
6073   TYPE_FIND_REGISTER (plugin, &quot;application/octet-stream&quot;, GST_RANK_MARGINAL,
6074       dvdiso_type_find, NULL, NULL, NULL, NULL);
6075 
6076   TYPE_FIND_REGISTER (plugin, &quot;application/x-ssa&quot;, GST_RANK_SECONDARY,
6077       ssa_type_find, &quot;ssa,ass&quot;, NULL, NULL, NULL);
6078 
6079   TYPE_FIND_REGISTER (plugin, &quot;video/x-pva&quot;, GST_RANK_SECONDARY,
6080       pva_type_find, &quot;pva&quot;, PVA_CAPS, NULL, NULL);
6081 
6082   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-xi&quot;, GST_RANK_SECONDARY,
6083       &quot;xi&quot;, &quot;Extended Instrument: &quot;, 21, GST_TYPE_FIND_MAXIMUM);
6084 
6085   TYPE_FIND_REGISTER (plugin, &quot;audio/audible&quot;, GST_RANK_MARGINAL,
6086       aa_type_find, &quot;aa,aax&quot;, AA_CAPS, NULL, NULL);
6087 #endif // GSTREAMER_LITE
6088 
<a name="43" id="anc43"></a>




6089   return TRUE;
6090 }
6091 
6092 #ifndef GSTREAMER_LITE
6093 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
6094     GST_VERSION_MINOR,
6095     typefindfunctions,
6096     &quot;default typefind functions&quot;,
6097     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
<a name="44" id="anc44"></a><span class="line-modified">6098 #endif // GSTREAMER_LITE</span>
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>