diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstelement.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstelement.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstelement.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstelement.c
@@ -638,13 +638,12 @@
  * @pad: (transfer floating): the #GstPad to add to the element.
  *
  * Adds a pad (link point) to @element. @pad's parent will be set to @element;
  * see gst_object_set_parent() for refcounting information.
  *
- * Pads are not automatically activated so elements should perform the needed
- * steps to activate the pad in case this pad is added in the PAUSED or PLAYING
- * state. See gst_pad_set_active() for more information about activating pads.
+ * Pads are automatically activated when added in the PAUSED or PLAYING
+ * state.
  *
  * The pad and the element should be unlocked when calling this function.
  *
  * This function will emit the #GstElement::pad-added signal on the element.
  *
@@ -683,13 +682,10 @@
     goto had_parent;
 
   /* check for active pads */
   if (!active && (GST_STATE (element) > GST_STATE_READY ||
           GST_STATE_NEXT (element) == GST_STATE_PAUSED)) {
-    g_warning ("adding inactive pad '%s' to running element '%s', you need to "
-        "use gst_pad_set_active(pad,TRUE) before adding it.",
-        GST_STR_NULL (pad_name), GST_ELEMENT_NAME (element));
     gst_pad_set_active (pad, TRUE);
   }
 
   g_free (pad_name);
 
@@ -977,11 +973,11 @@
     /* check characters followed by the specifier */
     if (*(templ_name_ptr + 2) != '\0' && *(templ_name_ptr + 2) != '_') {
       if (next_specifier) {
         templ_postfix_len = templ_name - (templ_name_ptr + 2);
         name_postfix_len = name - name_ptr;
-    } else {
+      } else {
         templ_postfix_len = strlen (templ_name_ptr + 2);
         name_postfix_len = strlen (name_ptr);
       }
 
       if (strncmp (templ_name_ptr + 2,
@@ -1106,14 +1102,14 @@
   g_return_val_if_fail (GST_IS_ELEMENT (element), NULL);
   g_return_val_if_fail (name != NULL, NULL);
 
   class = GST_ELEMENT_GET_CLASS (element);
 
-    templ = gst_element_class_get_request_pad_template (class, name);
+  templ = gst_element_class_get_request_pad_template (class, name);
   if (templ) {
     req_name = strstr (name, "%") ? NULL : name;
-      templ_found = TRUE;
+    templ_found = TRUE;
   } else {
     /* there is no % in the name, try to find a matching template */
     list = class->padtemplates;
     while (!templ_found && list) {
       templ = (GstPadTemplate *) list->data;
@@ -1124,11 +1120,11 @@
                 name)) {
           templ_found = TRUE;
           req_name = name;
           break;
         }
-            }
+      }
       list = list->next;
     }
   }
 
   if (!templ_found)
@@ -1732,11 +1728,11 @@
 
   return NULL;
 }
 
 /* get a random pad on element of the given direction.
- * The pad is random in a sense that it is the first pad that is (optionaly) linked.
+ * The pad is random in a sense that it is the first pad that is (optionally) linked.
  */
 static GstPad *
 gst_element_get_random_pad (GstElement * element,
     gboolean need_linked, GstPadDirection dir)
 {
@@ -2243,10 +2239,14 @@
  * @locked_state: %TRUE to lock the element's state
  *
  * Locks the state of an element, so state changes of the parent don't affect
  * this element anymore.
  *
+ * Note that this is racy if the state lock of the parent bin is not taken.
+ * The parent bin might've just checked the flag in another thread and as the
+ * next step proceed to change the child element's state.
+ *
  * MT safe.
  *
  * Returns: %TRUE if the state was changed, %FALSE if bad parameters were given
  * or the elements state-locking needed no change.
  */
@@ -2446,11 +2446,11 @@
     if (state)
       *state = GST_STATE_VOID_PENDING;
     if (pending)
       *pending = GST_STATE_VOID_PENDING;
 
-    GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, "interruped");
+    GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, "interrupted");
 
     GST_OBJECT_UNLOCK (element);
 
     return GST_STATE_CHANGE_FAILURE;
   }
@@ -2984,18 +2984,18 @@
       break;
     }
     case GST_STATE_CHANGE_SUCCESS:
       GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
           "element changed state SUCCESS");
-      /* we can commit the state now which will proceeed to
+      /* we can commit the state now which will proceed to
        * the next state */
       ret = gst_element_continue_state (element, ret);
       break;
     case GST_STATE_CHANGE_NO_PREROLL:
       GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
           "element changed state NO_PREROLL");
-      /* we can commit the state now which will proceeed to
+      /* we can commit the state now which will proceed to
        * the next state */
       ret = gst_element_continue_state (element, ret);
       break;
     default:
       goto invalid_return;
@@ -3038,11 +3038,11 @@
   gboolean cont = TRUE;
 
   if (!gst_pad_set_active (pad, *active)) {
     if (GST_PAD_PARENT (pad) != NULL) {
       cont = FALSE;
-    g_value_set_boolean (ret, FALSE);
+      g_value_set_boolean (ret, FALSE);
     }
   }
 
   return cont;
 }
@@ -3224,12 +3224,12 @@
  * gst_element_get_factory:
  * @element: a #GstElement to request the element factory of.
  *
  * Retrieves the factory that was used to create this element.
  *
- * Returns: (transfer none): the #GstElementFactory used for creating this
- *     element. no refcounting is needed.
+ * Returns: (transfer none) (nullable): the #GstElementFactory used for creating this
+ *     element or %NULL if element has not been registered (static element). no refcounting is needed.
  */
 GstElementFactory *
 gst_element_get_factory (GstElement * element)
 {
   g_return_val_if_fail (GST_IS_ELEMENT (element), NULL);
