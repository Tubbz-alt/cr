diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c
@@ -85,10 +85,11 @@
 #include "ghash.h"
 #include "ghook.h"
 #include "gqueue.h"
 #include "gstrfuncs.h"
 #include "gtestutils.h"
+#include "gthreadprivate.h"
 
 #ifdef G_OS_WIN32
 #include "gwin32.h"
 #endif
 
@@ -188,11 +189,11 @@
  *
  * There are two options for memory management of the user data passed to a
  * #GSource to be passed to its callback on invocation. This data is provided
  * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
  * more generally, using g_source_set_callback(). This data is typically an
- * object which �owns� the timeout or idle callback, such as a widget or a
+ * object which 'owns' the timeout or idle callback, such as a widget or a
  * network protocol implementation. In many cases, it is an error for the
  * callback to be invoked after this owning object has been destroyed, as that
  * results in use of freed memory.
  *
  * The first, and preferred, option is to store the source ID returned by
@@ -200,14 +201,14 @@
  * remove that source from the main context using g_source_remove() when the
  * owning object is finalized. This ensures that the callback can only be
  * invoked while the object is still alive.
  *
  * The second option is to hold a strong reference to the object in the
- * callback, and to release it in the callback�s #GDestroyNotify. This ensures
+ * callback, and to release it in the callback's #GDestroyNotify. This ensures
  * that the object is kept alive until after the source is finalized, which is
  * guaranteed to be after it is invoked for the final time. The #GDestroyNotify
- * is another callback passed to the �full� variants of #GSource functions (for
+ * is another callback passed to the 'full' variants of #GSource functions (for
  * example, g_timeout_add_full()). It is called when the source is finalized,
  * and is designed for releasing references like this.
  *
  * One important caveat of this second approach is that it will keep the object
  * alive indefinitely if the main loop is stopped before the #GSource is
@@ -271,11 +272,11 @@
   volatile gint ref_count;
 
   GHashTable *sources;              /* guint -> GSource */
 
   GPtrArray *pending_dispatches;
-  gint timeout;         /* Timeout for current iteration */
+  gint timeout;     /* Timeout for current iteration */
 
   guint next_id;
   GList *source_lists;
   gint in_check_or_prepare;
 
@@ -306,17 +307,18 @@
 };
 
 struct _GMainLoop
 {
   GMainContext *context;
-  gboolean is_running;
+  gboolean is_running; /* (atomic) */
   volatile gint ref_count;
 };
 
 struct _GTimeoutSource
 {
   GSource     source;
+  /* Measured in seconds if 'seconds' is TRUE, or milliseconds otherwise. */
   guint       interval;
   gboolean    seconds;
 };
 
 struct _GChildWatchSource
@@ -325,19 +327,19 @@
   GPid        pid;
   gint        child_status;
 #ifdef G_OS_WIN32
   GPollFD     poll;
 #else /* G_OS_WIN32 */
-  gboolean    child_exited;
+  gboolean    child_exited; /* (atomic) */
 #endif /* G_OS_WIN32 */
 };
 
 struct _GUnixSignalWatchSource
 {
   GSource     source;
   int         signum;
-  gboolean    pending;
+  gboolean    pending; /* (atomic) */
 };
 
 struct _GPollRec
 {
   GPollFD *fd;
@@ -372,77 +374,68 @@
 #define G_THREAD_SELF g_thread_self ()
 
 #define SOURCE_DESTROYED(source) (((source)->flags & G_HOOK_FLAG_ACTIVE) == 0)
 #define SOURCE_BLOCKED(source) (((source)->flags & G_SOURCE_BLOCKED) != 0)
 
-#define SOURCE_UNREF(source, context)                       \
-   G_STMT_START {                                           \
-    if ((source)->ref_count > 1)                            \
-      (source)->ref_count--;                                \
-    else                                                    \
-      g_source_unref_internal ((source), (context), TRUE);  \
-   } G_STMT_END
-
-
 /* Forward declarations */
 
 static void g_source_unref_internal             (GSource      *source,
-                         GMainContext *context,
-                         gboolean      have_lock);
+             GMainContext *context,
+             gboolean      have_lock);
 static void g_source_destroy_internal           (GSource      *source,
-                         GMainContext *context,
-                         gboolean      have_lock);
+             GMainContext *context,
+             gboolean      have_lock);
 static void g_source_set_priority_unlocked      (GSource      *source,
-                         GMainContext *context,
-                         gint          priority);
+             GMainContext *context,
+             gint          priority);
 static void g_child_source_remove_internal      (GSource      *child_source,
                                                  GMainContext *context);
 
 static void g_main_context_poll                 (GMainContext *context,
-                         gint          timeout,
-                         gint          priority,
-                         GPollFD      *fds,
-                         gint          n_fds);
+             gint          timeout,
+             gint          priority,
+             GPollFD      *fds,
+             gint          n_fds);
 static void g_main_context_add_poll_unlocked    (GMainContext *context,
-                         gint          priority,
-                         GPollFD      *fd);
+             gint          priority,
+             GPollFD      *fd);
 static void g_main_context_remove_poll_unlocked (GMainContext *context,
-                         GPollFD      *fd);
+             GPollFD      *fd);
 
 static void     g_source_iter_init  (GSourceIter   *iter,
-                     GMainContext  *context,
-                     gboolean       may_modify);
+             GMainContext  *context,
+             gboolean       may_modify);
 static gboolean g_source_iter_next  (GSourceIter   *iter,
-                     GSource      **source);
+             GSource      **source);
 static void     g_source_iter_clear (GSourceIter   *iter);
 
 static gboolean g_timeout_dispatch (GSource     *source,
-                    GSourceFunc  callback,
-                    gpointer     user_data);
+            GSourceFunc  callback,
+            gpointer     user_data);
 static gboolean g_child_watch_prepare  (GSource     *source,
-                        gint        *timeout);
+                gint        *timeout);
 static gboolean g_child_watch_check    (GSource     *source);
 static gboolean g_child_watch_dispatch (GSource     *source,
-                    GSourceFunc  callback,
-                    gpointer     user_data);
+          GSourceFunc  callback,
+          gpointer     user_data);
 static void     g_child_watch_finalize (GSource     *source);
 #ifdef G_OS_UNIX
 static void g_unix_signal_handler (int signum);
 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
-                          gint        *timeout);
+                gint        *timeout);
 static gboolean g_unix_signal_watch_check    (GSource     *source);
 static gboolean g_unix_signal_watch_dispatch (GSource     *source,
-                          GSourceFunc  callback,
-                          gpointer     user_data);
+                GSourceFunc  callback,
+                gpointer     user_data);
 static void     g_unix_signal_watch_finalize  (GSource     *source);
 #endif
 static gboolean g_idle_prepare     (GSource     *source,
-                    gint        *timeout);
+            gint        *timeout);
 static gboolean g_idle_check       (GSource     *source);
 static gboolean g_idle_dispatch    (GSource     *source,
-                    GSourceFunc  callback,
-                    gpointer     user_data);
+            GSourceFunc  callback,
+            gpointer     user_data);
 
 static void block_source (GSource *source);
 
 static GMainContext *glib_worker_context;
 
@@ -460,50 +453,52 @@
 static volatile sig_atomic_t any_unix_signal_pending;
 #else
 static volatile int unix_signal_pending[NSIG];
 static volatile int any_unix_signal_pending;
 #endif
-static volatile guint unix_signal_refcount[NSIG];
 
 /* Guards all the data below */
 G_LOCK_DEFINE_STATIC (unix_signal_lock);
+static guint unix_signal_refcount[NSIG];
 static GSList *unix_signal_watches;
 static GSList *unix_child_watches;
 
 GSourceFuncs g_unix_signal_funcs =
 {
   g_unix_signal_watch_prepare,
   g_unix_signal_watch_check,
   g_unix_signal_watch_dispatch,
-  g_unix_signal_watch_finalize
+  g_unix_signal_watch_finalize,
+  NULL, NULL
 };
 #endif /* !G_OS_WIN32 */
 G_LOCK_DEFINE_STATIC (main_context_list);
 static GSList *main_context_list = NULL;
 
 GSourceFuncs g_timeout_funcs =
 {
   NULL, /* prepare */
   NULL, /* check */
   g_timeout_dispatch,
-  NULL
+  NULL, NULL, NULL
 };
 
 GSourceFuncs g_child_watch_funcs =
 {
   g_child_watch_prepare,
   g_child_watch_check,
   g_child_watch_dispatch,
-  g_child_watch_finalize
+  g_child_watch_finalize,
+  NULL, NULL
 };
 
 GSourceFuncs g_idle_funcs =
 {
   g_idle_prepare,
   g_idle_check,
   g_idle_dispatch,
-  NULL
+  NULL, NULL, NULL
 };
 
 /**
  * g_main_context_ref:
  * @context: a #GMainContext
@@ -523,11 +518,11 @@
   return context;
 }
 
 static inline void
 poll_rec_list_free (GMainContext *context,
-            GPollRec     *list)
+        GPollRec     *list)
 {
   g_slice_free_chain (GPollRec, list, next);
 }
 
 /**
@@ -693,11 +688,11 @@
 
       TRACE (GLIB_MAIN_CONTEXT_DEFAULT (default_main_context));
 
 #ifdef G_MAIN_POLL_DEBUG
       if (_g_main_poll_debug)
-    g_print ("default context=%p\n", default_main_context);
+  g_print ("default context=%p\n", default_main_context);
 #endif
     }
 
   G_UNLOCK (main_loop);
 
@@ -903,11 +898,11 @@
  *
  * Returns: the newly-created #GSource.
  **/
 GSource *
 g_source_new (GSourceFuncs *source_funcs,
-          guint         struct_size)
+        guint         struct_size)
 {
   GSource *source;
 
   g_return_val_if_fail (source_funcs != NULL, NULL);
   g_return_val_if_fail (struct_size >= sizeof (GSource), NULL);
@@ -944,12 +939,12 @@
 }
 
 /* Holds context's lock */
 static void
 g_source_iter_init (GSourceIter  *iter,
-            GMainContext *context,
-            gboolean      may_modify)
+        GMainContext *context,
+        gboolean      may_modify)
 {
   iter->context = context;
   iter->current_list = NULL;
   iter->source = NULL;
   iter->may_modify = may_modify;
@@ -967,33 +962,33 @@
     next_source = NULL;
 
   if (!next_source)
     {
       if (iter->current_list)
-    iter->current_list = iter->current_list->next;
+  iter->current_list = iter->current_list->next;
       else
-    iter->current_list = iter->context->source_lists;
+  iter->current_list = iter->context->source_lists;
 
       if (iter->current_list)
-    {
-      GSourceList *source_list = iter->current_list->data;
+  {
+    GSourceList *source_list = iter->current_list->data;
 
-      next_source = source_list->head;
-    }
+    next_source = source_list->head;
+  }
     }
 
   /* Note: unreffing iter->source could potentially cause its
    * GSourceList to be removed from source_lists (if iter->source is
    * the only source in its list, and it is destroyed), so we have to
    * keep it reffed until after we advance iter->current_list, above.
    */
 
   if (iter->source && iter->may_modify)
-    SOURCE_UNREF (iter->source, iter->context);
+    g_source_unref_internal (iter->source, iter->context, TRUE);
   iter->source = next_source;
   if (iter->source && iter->may_modify)
-    iter->source->ref_count++;
+    g_source_ref (iter->source);
 
   *source = iter->source;
   return *source != NULL;
 }
 
@@ -1003,45 +998,45 @@
 static void
 g_source_iter_clear (GSourceIter *iter)
 {
   if (iter->source && iter->may_modify)
     {
-      SOURCE_UNREF (iter->source, iter->context);
+      g_source_unref_internal (iter->source, iter->context, TRUE);
       iter->source = NULL;
     }
 }
 
 /* Holds context's lock
  */
 static GSourceList *
 find_source_list_for_priority (GMainContext *context,
-                   gint          priority,
-                   gboolean      create)
+             gint          priority,
+             gboolean      create)
 {
   GList *iter, *last;
   GSourceList *source_list;
 
   last = NULL;
   for (iter = context->source_lists; iter != NULL; last = iter, iter = iter->next)
     {
       source_list = iter->data;
 
       if (source_list->priority == priority)
-    return source_list;
+  return source_list;
 
       if (source_list->priority > priority)
-    {
-      if (!create)
-        return NULL;
-
-      source_list = g_slice_new0 (GSourceList);
-      source_list->priority = priority;
-      context->source_lists = g_list_insert_before (context->source_lists,
-                            iter,
-                            source_list);
-      return source_list;
-    }
+  {
+    if (!create)
+      return NULL;
+
+    source_list = g_slice_new0 (GSourceList);
+    source_list->priority = priority;
+    context->source_lists = g_list_insert_before (context->source_lists,
+              iter,
+              source_list);
+    return source_list;
+  }
     }
 
   if (!create)
     return NULL;
 
@@ -1062,11 +1057,11 @@
 
 /* Holds context's lock
  */
 static void
 source_add_to_context (GSource      *source,
-               GMainContext *context)
+           GMainContext *context)
 {
   GSourceList *source_list;
   GSource *prev, *next;
 
   source_list = find_source_list_for_priority (context, source->priority, TRUE);
@@ -1100,11 +1095,11 @@
 
 /* Holds context's lock
  */
 static void
 source_remove_from_context (GSource      *source,
-                GMainContext *context)
+          GMainContext *context)
 {
   GSourceList *source_list;
 
   source_list = find_source_list_for_priority (context, source->priority, FALSE);
   g_return_if_fail (source_list != NULL);
@@ -1148,11 +1143,11 @@
     id = context->next_id++;
   while (id == 0 || g_hash_table_contains (context->sources, GUINT_TO_POINTER (id)));
 
   source->context = context;
   source->source_id = id;
-  source->ref_count++;
+  g_source_ref (source);
 
   g_hash_table_insert (context->sources, GUINT_TO_POINTER (id), source);
 
   source_add_to_context (source, context);
 
@@ -1196,11 +1191,11 @@
  * Returns: the ID (greater than 0) for the source within the
  *   #GMainContext.
  **/
 guint
 g_source_attach (GSource      *source,
-         GMainContext *context)
+     GMainContext *context)
 {
   guint result = 0;
 
 #ifdef GSTREAMER_LITE
   if (source == NULL) {
@@ -1226,12 +1221,12 @@
   return result;
 }
 
 static void
 g_source_destroy_internal (GSource      *source,
-               GMainContext *context,
-               gboolean      have_lock)
+         GMainContext *context,
+         gboolean      have_lock)
 {
   TRACE (GLIB_MAIN_SOURCE_DESTROY (g_source_get_name (source), source,
                                    context));
 
   if (!have_lock)
@@ -1250,28 +1245,28 @@
 
       source->callback_data = NULL;
       source->callback_funcs = NULL;
 
       if (old_cb_funcs)
-    {
-      UNLOCK_CONTEXT (context);
-      old_cb_funcs->unref (old_cb_data);
-      LOCK_CONTEXT (context);
-    }
+  {
+    UNLOCK_CONTEXT (context);
+    old_cb_funcs->unref (old_cb_data);
+    LOCK_CONTEXT (context);
+  }
 
       if (!SOURCE_BLOCKED (source))
-    {
-      tmp_list = source->poll_fds;
-      while (tmp_list)
-        {
-          g_main_context_remove_poll_unlocked (context, tmp_list->data);
-          tmp_list = tmp_list->next;
-        }
+  {
+    tmp_list = source->poll_fds;
+    while (tmp_list)
+      {
+        g_main_context_remove_poll_unlocked (context, tmp_list->data);
+        tmp_list = tmp_list->next;
+      }
 
           for (tmp_list = source->priv->fds; tmp_list; tmp_list = tmp_list->next)
             g_main_context_remove_poll_unlocked (context, tmp_list->data);
-    }
+  }
 
       while (source->priv->child_sources)
         g_child_source_remove_internal (source->priv->child_sources->data, context);
 
       if (source->priv->parent_source)
@@ -1290,11 +1285,14 @@
  *
  * Removes a source from its #GMainContext, if any, and mark it as
  * destroyed.  The source cannot be subsequently added to another
  * context. It is safe to call this on sources which have already been
  * removed from their context.
- **/
+ *
+ * This does not unref the #GSource: if you still hold a reference, use
+ * g_source_unref() to drop it.
+ */
 void
 g_source_destroy (GSource *source)
 {
   GMainContext *context;
 
@@ -1383,11 +1381,11 @@
  * main loop iteration.  Newly-written event sources should try to use
  * g_source_add_unix_fd() instead of this API.
  **/
 void
 g_source_add_poll (GSource *source,
-           GPollFD *fd)
+       GPollFD *fd)
 {
   GMainContext *context;
 
   g_return_if_fail (source != NULL);
   g_return_if_fail (fd != NULL);
@@ -1406,11 +1404,11 @@
   source->poll_fds = g_slist_prepend (source->poll_fds, fd);
 
   if (context)
     {
       if (!SOURCE_BLOCKED (source))
-    g_main_context_add_poll_unlocked (context, source->priority, fd);
+  g_main_context_add_poll_unlocked (context, source->priority, fd);
       UNLOCK_CONTEXT (context);
     }
 }
 
 /**
@@ -1424,11 +1422,11 @@
  * This API is only intended to be used by implementations of #GSource.
  * Do not call this API on a #GSource that you did not create.
  **/
 void
 g_source_remove_poll (GSource *source,
-              GPollFD *fd)
+          GPollFD *fd)
 {
   GMainContext *context;
 
   g_return_if_fail (source != NULL);
   g_return_if_fail (fd != NULL);
@@ -1442,11 +1440,11 @@
   source->poll_fds = g_slist_remove (source->poll_fds, fd);
 
   if (context)
     {
       if (!SOURCE_BLOCKED (source))
-    g_main_context_remove_poll_unlocked (context, fd);
+  g_main_context_remove_poll_unlocked (context, fd);
       UNLOCK_CONTEXT (context);
     }
 }
 
 /**
@@ -1474,11 +1472,11 @@
  *
  * Since: 2.28
  **/
 void
 g_source_add_child_source (GSource *source,
-               GSource *child_source)
+         GSource *child_source)
 {
   GMainContext *context;
 
   g_return_if_fail (source != NULL);
   g_return_if_fail (child_source != NULL);
@@ -1493,11 +1491,11 @@
     LOCK_CONTEXT (context);
 
   TRACE (GLIB_SOURCE_ADD_CHILD_SOURCE (source, child_source));
 
   source->priv->child_sources = g_slist_prepend (source->priv->child_sources,
-                         g_source_ref (child_source));
+             g_source_ref (child_source));
   child_source->priv->parent_source = source;
   g_source_set_priority_unlocked (child_source, NULL, source->priority);
   if (SOURCE_BLOCKED (source))
     block_source (child_source);
 
@@ -1535,11 +1533,11 @@
  *
  * Since: 2.28
  **/
 void
 g_source_remove_child_source (GSource *source,
-                  GSource *child_source)
+            GSource *child_source)
 {
   GMainContext *context;
 
   g_return_if_fail (source != NULL);
   g_return_if_fail (child_source != NULL);
@@ -1579,13 +1577,13 @@
     }
 }
 
 static void
 g_source_callback_get (gpointer     cb_data,
-               GSource     *source,
-               GSourceFunc *func,
-               gpointer    *data)
+           GSource     *source,
+           GSourceFunc *func,
+           gpointer    *data)
 {
   GSourceCallback *callback = cb_data;
 
   *func = callback->func;
   *data = callback->data;
@@ -1608,15 +1606,19 @@
  * "object". This is used internally. Note that calling
  * g_source_set_callback_indirect() assumes
  * an initial reference count on @callback_data, and thus
  * @callback_funcs->unref will eventually be called once more
  * than @callback_funcs->ref.
+ *
+ * It is safe to call this function multiple times on a source which has already
+ * been attached to a context. The changes will take effect for the next time
+ * the source is dispatched after this call returns.
  **/
 void
 g_source_set_callback_indirect (GSource              *source,
-                gpointer              callback_data,
-                GSourceCallbackFuncs *callback_funcs)
+        gpointer              callback_data,
+        GSourceCallbackFuncs *callback_funcs)
 {
   GMainContext *context;
   gpointer old_cb_data;
   GSourceCallbackFuncs *old_cb_funcs;
 
@@ -1627,14 +1629,16 @@
 
   if (context)
     LOCK_CONTEXT (context);
 
   if (callback_funcs != &g_source_callback_funcs)
-    TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,
-                                              callback_funcs->ref,
-                                              callback_funcs->unref,
-                                              callback_funcs->get));
+    {
+      TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,
+                                                callback_funcs->ref,
+                                                callback_funcs->unref,
+                                                callback_funcs->get));
+    }
 
   old_cb_data = source->callback_data;
   old_cb_funcs = source->callback_funcs;
 
   source->callback_data = callback_data;
@@ -1664,17 +1668,21 @@
  *
  * See [memory management of sources][mainloop-memory-management] for details
  * on how to handle memory management of @data.
  *
  * Typically, you won't use this function. Instead use functions specific
- * to the type of source you are using.
+ * to the type of source you are using, such as g_idle_add() or g_timeout_add().
+ *
+ * It is safe to call this function multiple times on a source which has already
+ * been attached to a context. The changes will take effect for the next time
+ * the source is dispatched after this call returns.
  **/
 void
 g_source_set_callback (GSource        *source,
-               GSourceFunc     func,
-               gpointer        data,
-               GDestroyNotify  notify)
+           GSourceFunc     func,
+           gpointer        data,
+           GDestroyNotify  notify)
 {
   GSourceCallback *new_callback;
 
   g_return_if_fail (source != NULL);
 #ifdef GSTREAMER_LITE
@@ -1705,24 +1713,24 @@
  *
  * Since: 2.12
  */
 void
 g_source_set_funcs (GSource     *source,
-               GSourceFuncs *funcs)
+             GSourceFuncs *funcs)
 {
   g_return_if_fail (source != NULL);
   g_return_if_fail (source->context == NULL);
-  g_return_if_fail (source->ref_count > 0);
+  g_return_if_fail (g_atomic_int_get (&source->ref_count) > 0);
   g_return_if_fail (funcs != NULL);
 
   source->source_funcs = funcs;
 }
 
 static void
 g_source_set_priority_unlocked (GSource      *source,
-                GMainContext *context,
-                gint          priority)
+        GMainContext *context,
+        gint          priority)
 {
   GSList *tmp_list;
 
 #ifdef GSTREAMER_LITE
   if (source == NULL || source->priv == NULL || source->priv->parent_source == NULL)
@@ -1731,11 +1739,11 @@
   if (context == NULL)
     return;
 #endif // GSTREAMER_LITE
 
   g_return_if_fail (source->priv->parent_source == NULL ||
-            source->priv->parent_source->priority == priority);
+        source->priv->parent_source->priority == priority);
 
   TRACE (GLIB_SOURCE_SET_PRIORITY (source, context, priority));
 
   if (context)
     {
@@ -1750,36 +1758,36 @@
   if (context)
     {
       source_add_to_context (source, source->context);
 
       if (!SOURCE_BLOCKED (source))
-    {
-      tmp_list = source->poll_fds;
-      while (tmp_list)
-        {
-          g_main_context_remove_poll_unlocked (context, tmp_list->data);
-          g_main_context_add_poll_unlocked (context, priority, tmp_list->data);
+  {
+    tmp_list = source->poll_fds;
+    while (tmp_list)
+      {
+        g_main_context_remove_poll_unlocked (context, tmp_list->data);
+        g_main_context_add_poll_unlocked (context, priority, tmp_list->data);
 
-          tmp_list = tmp_list->next;
-        }
+        tmp_list = tmp_list->next;
+      }
 
           for (tmp_list = source->priv->fds; tmp_list; tmp_list = tmp_list->next)
             {
               g_main_context_remove_poll_unlocked (context, tmp_list->data);
               g_main_context_add_poll_unlocked (context, priority, tmp_list->data);
             }
-    }
+  }
     }
 
   if (source->priv->child_sources)
     {
       tmp_list = source->priv->child_sources;
       while (tmp_list)
-    {
-      g_source_set_priority_unlocked (tmp_list->data, context, priority);
-      tmp_list = tmp_list->next;
-    }
+  {
+    g_source_set_priority_unlocked (tmp_list->data, context, priority);
+    tmp_list = tmp_list->next;
+  }
     }
 }
 
 /**
  * g_source_set_priority:
@@ -1795,11 +1803,11 @@
  * permitted to change the priority of a source once it has been added
  * as a child of another source.
  **/
 void
 g_source_set_priority (GSource  *source,
-               gint      priority)
+           gint      priority)
 {
   GMainContext *context;
 
 #ifdef GSTREAMER_LITE
   if (source == NULL || source->priv == NULL || source->priv->parent_source == NULL)
@@ -1943,11 +1951,11 @@
  * will be processed normally. Otherwise, all processing of this
  * source is blocked until the dispatch function returns.
  **/
 void
 g_source_set_can_recurse (GSource  *source,
-              gboolean  can_recurse)
+        gboolean  can_recurse)
 {
   GMainContext *context;
 
   g_return_if_fail (source != NULL);
 
@@ -2102,44 +2110,33 @@
  * Returns: @source
  **/
 GSource *
 g_source_ref (GSource *source)
 {
-  GMainContext *context;
-
   g_return_val_if_fail (source != NULL, NULL);
 
-  context = source->context;
-
-  if (context)
-    LOCK_CONTEXT (context);
-
-  source->ref_count++;
-
-  if (context)
-    UNLOCK_CONTEXT (context);
+  g_atomic_int_inc (&source->ref_count);
 
   return source;
 }
 
 /* g_source_unref() but possible to call within context lock
  */
 static void
 g_source_unref_internal (GSource      *source,
-             GMainContext *context,
-             gboolean      have_lock)
+       GMainContext *context,
+       gboolean      have_lock)
 {
   gpointer old_cb_data = NULL;
   GSourceCallbackFuncs *old_cb_funcs = NULL;
 
   g_return_if_fail (source != NULL);
 
   if (!have_lock && context)
     LOCK_CONTEXT (context);
 
-  source->ref_count--;
-  if (source->ref_count == 0)
+  if (g_atomic_int_dec_and_test (&source->ref_count))
     {
       TRACE (GLIB_SOURCE_BEFORE_FREE (source, context,
                                       source->source_funcs->finalize));
 
       old_cb_data = source->callback_data;
@@ -2147,44 +2144,44 @@
 
       source->callback_data = NULL;
       source->callback_funcs = NULL;
 
       if (context)
-    {
-      if (!SOURCE_DESTROYED (source))
-        g_warning (G_STRLOC ": ref_count == 0, but source was still attached to a context!");
-      source_remove_from_context (source, context);
+  {
+    if (!SOURCE_DESTROYED (source))
+      g_warning (G_STRLOC ": ref_count == 0, but source was still attached to a context!");
+    source_remove_from_context (source, context);
 
           g_hash_table_remove (context->sources, GUINT_TO_POINTER (source->source_id));
-    }
+  }
 
       if (source->source_funcs->finalize)
-    {
+  {
           /* Temporarily increase the ref count again so that GSource methods
            * can be called from finalize(). */
-          source->ref_count++;
-      if (context)
-        UNLOCK_CONTEXT (context);
-      source->source_funcs->finalize (source);
-      if (context)
-        LOCK_CONTEXT (context);
-          source->ref_count--;
-    }
+          g_atomic_int_inc (&source->ref_count);
+    if (context)
+      UNLOCK_CONTEXT (context);
+    source->source_funcs->finalize (source);
+    if (context)
+      LOCK_CONTEXT (context);
+          g_atomic_int_add (&source->ref_count, -1);
+  }
 
       if (old_cb_funcs)
         {
           /* Temporarily increase the ref count again so that GSource methods
            * can be called from callback_funcs.unref(). */
-          source->ref_count++;
+          g_atomic_int_inc (&source->ref_count);
           if (context)
             UNLOCK_CONTEXT (context);
 
           old_cb_funcs->unref (old_cb_data);
 
           if (context)
             LOCK_CONTEXT (context);
-          source->ref_count--;
+          g_atomic_int_add (&source->ref_count, -1);
         }
 
       g_free (source->name);
       source->name = NULL;
 
@@ -2210,11 +2207,11 @@
       g_free (source);
     }
 
   if (!have_lock && context)
     UNLOCK_CONTEXT (context);
-    }
+}
 
 /**
  * g_source_unref:
  * @source: a #GSource
  *
@@ -2239,11 +2236,11 @@
  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
  * @source_id: the source ID, as returned by g_source_get_id().
  *
  * Finds a #GSource given a pair of context and ID.
  *
- * It is a programmer error to attempt to lookup a non-existent source.
+ * It is a programmer error to attempt to look up a non-existent source.
  *
  * More specifically: source IDs can be reissued after a source has been
  * destroyed and therefore it is never valid to use this function with a
  * source ID which may have already been removed.  An example is when
  * scheduling an idle to run in another thread with g_idle_add(): the
@@ -2287,12 +2284,12 @@
  *
  * Returns: (transfer none): the source, if one was found, otherwise %NULL
  **/
 GSource *
 g_main_context_find_source_by_funcs_user_data (GMainContext *context,
-                           GSourceFuncs *funcs,
-                           gpointer      user_data)
+                 GSourceFuncs *funcs,
+                 gpointer      user_data)
 {
   GSourceIter iter;
   GSource *source;
 
   g_return_val_if_fail (funcs != NULL, NULL);
@@ -2304,21 +2301,21 @@
 
   g_source_iter_init (&iter, context, FALSE);
   while (g_source_iter_next (&iter, &source))
     {
       if (!SOURCE_DESTROYED (source) &&
-      source->source_funcs == funcs &&
-      source->callback_funcs)
-    {
-      GSourceFunc callback;
-      gpointer callback_data;
+    source->source_funcs == funcs &&
+    source->callback_funcs)
+  {
+    GSourceFunc callback;
+    gpointer callback_data;
 
-      source->callback_funcs->get (source->callback_data, source, &callback, &callback_data);
+    source->callback_funcs->get (source->callback_data, source, &callback, &callback_data);
 
-      if (callback_data == user_data)
-        break;
-    }
+    if (callback_data == user_data)
+      break;
+  }
     }
   g_source_iter_clear (&iter);
 
   UNLOCK_CONTEXT (context);
 
@@ -2336,11 +2333,11 @@
  *
  * Returns: (transfer none): the source, if one was found, otherwise %NULL
  **/
 GSource *
 g_main_context_find_source_by_user_data (GMainContext *context,
-                     gpointer      user_data)
+           gpointer      user_data)
 {
   GSourceIter iter;
   GSource *source;
 
   if (context == NULL)
@@ -2350,20 +2347,20 @@
 
   g_source_iter_init (&iter, context, FALSE);
   while (g_source_iter_next (&iter, &source))
     {
       if (!SOURCE_DESTROYED (source) &&
-      source->callback_funcs)
-    {
-      GSourceFunc callback;
-      gpointer callback_data = NULL;
+    source->callback_funcs)
+  {
+    GSourceFunc callback;
+    gpointer callback_data = NULL;
 
-      source->callback_funcs->get (source->callback_data, source, &callback, &callback_data);
+    source->callback_funcs->get (source->callback_data, source, &callback, &callback_data);
 
-      if (callback_data == user_data)
-        break;
-    }
+    if (callback_data == user_data)
+      break;
+  }
     }
   g_source_iter_clear (&iter);
 
   UNLOCK_CONTEXT (context);
 
@@ -2448,11 +2445,11 @@
  *
  * Returns: %TRUE if a source was found and removed.
  **/
 gboolean
 g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
-                    gpointer      user_data)
+            gpointer      user_data)
 {
   GSource *source;
 
   g_return_val_if_fail (funcs != NULL, FALSE);
 
@@ -2684,43 +2681,28 @@
  * @result: #GTimeVal structure in which to store current time.
  *
  * Equivalent to the UNIX gettimeofday() function, but portable.
  *
  * You may find g_get_real_time() to be more convenient.
+ *
+ * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_get_real_time()
+ *    instead.
  **/
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 void
 g_get_current_time (GTimeVal *result)
 {
-#ifndef G_OS_WIN32
-  struct timeval r;
-
-  g_return_if_fail (result != NULL);
-
-  /*this is required on alpha, there the timeval structs are int's
-    not longs and a cast only would fail horribly*/
-  gettimeofday (&r, NULL);
-  result->tv_sec = r.tv_sec;
-  result->tv_usec = r.tv_usec;
-#else
-  FILETIME ft;
-  guint64 time64;
+  gint64 tv;
 
   g_return_if_fail (result != NULL);
 
-  GetSystemTimeAsFileTime (&ft);
-  memmove (&time64, &ft, sizeof (FILETIME));
+  tv = g_get_real_time ();
 
-  /* Convert from 100s of nanoseconds since 1601-01-01
-   * to Unix epoch. Yes, this is Y2038 unsafe.
-   */
-  time64 -= G_GINT64_CONSTANT (116444736000000000);
-  time64 /= 10;
-
-  result->tv_sec = time64 / 1000000;
-  result->tv_usec = time64 % 1000000;
-#endif
+  result->tv_sec = tv / 1000000;
+  result->tv_usec = tv % 1000000;
 }
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 /**
  * g_get_real_time:
  *
  * Queries the system wall-clock time.
@@ -2738,15 +2720,33 @@
  * Since: 2.28
  **/
 gint64
 g_get_real_time (void)
 {
-  GTimeVal tv;
+#ifndef G_OS_WIN32
+  struct timeval r;
 
-  g_get_current_time (&tv);
+  /* this is required on alpha, there the timeval structs are ints
+   * not longs and a cast only would fail horribly */
+  gettimeofday (&r, NULL);
 
-  return (((gint64) tv.tv_sec) * 1000000) + tv.tv_usec;
+  return (((gint64) r.tv_sec) * 1000000) + r.tv_usec;
+#else
+  FILETIME ft;
+  guint64 time64;
+
+  GetSystemTimeAsFileTime (&ft);
+  memmove (&time64, &ft, sizeof (FILETIME));
+
+  /* Convert from 100s of nanoseconds since 1601-01-01
+   * to Unix epoch. This is Y2038 safe.
+   */
+  time64 -= G_GINT64_CONSTANT (116444736000000000);
+  time64 /= 10;
+
+  return time64;
+#endif
 }
 
 /**
  * g_get_monotonic_time:
  *
@@ -2783,11 +2783,11 @@
   if (!QueryPerformanceFrequency (&freq) || freq.QuadPart == 0)
     {
       /* The documentation says that this should never happen */
       g_assert_not_reached ();
       return;
-}
+    }
 
   g_monotonic_usec_per_tick = (gdouble)G_USEC_PER_SEC / freq.QuadPart;
 }
 
 gint64
@@ -2803,11 +2803,11 @@
       g_warning ("QueryPerformanceCounter Failed (%lu)", GetLastError ());
       g_monotonic_usec_per_tick = 0;
     }
 
   return 0;
-        }
+}
 #elif defined(HAVE_MACH_MACH_TIME_H) /* Mac OS */
 gint64
 g_get_monotonic_time (void)
 {
   static mach_timebase_info_data_t timebase_info;
@@ -2869,11 +2869,11 @@
 #endif
 
 static void
 g_main_dispatch_free (gpointer dispatch)
 {
-  g_slice_free (GMainDispatch, dispatch);
+  g_free (dispatch);
 }
 
 /* Running the main loop */
 
 static GMainDispatch *
@@ -2883,14 +2883,11 @@
   GMainDispatch *dispatch;
 
   dispatch = g_private_get (&depth_private);
 
   if (!dispatch)
-    {
-      dispatch = g_slice_new0 (GMainDispatch);
-      g_private_set (&depth_private, dispatch);
-    }
+    dispatch = g_private_set_alloc0 (&depth_private, sizeof (GMainDispatch));
 
   return dispatch;
 }
 
 /**
@@ -3133,14 +3130,14 @@
 
   if (source->priv && source->priv->child_sources)
     {
       tmp_list = source->priv->child_sources;
       while (tmp_list)
-    {
-      block_source (tmp_list->data);
-      tmp_list = tmp_list->next;
-    }
+  {
+    block_source (tmp_list->data);
+    tmp_list = tmp_list->next;
+  }
     }
 }
 
 /* HOLDS: source->context's lock */
 static void
@@ -3165,14 +3162,14 @@
 
   if (source->priv && source->priv->child_sources)
     {
       tmp_list = source->priv->child_sources;
       while (tmp_list)
-    {
-      unblock_source (tmp_list->data);
-      tmp_list = tmp_list->next;
-    }
+  {
+    unblock_source (tmp_list->data);
+    tmp_list = tmp_list->next;
+  }
     }
 }
 
 /* HOLDS: context's lock */
 static void
@@ -3189,40 +3186,40 @@
       g_assert (source);
 
       source->flags &= ~G_SOURCE_READY;
 
       if (!SOURCE_DESTROYED (source))
-    {
-      gboolean was_in_call;
-      gpointer user_data = NULL;
-      GSourceFunc callback = NULL;
-      GSourceCallbackFuncs *cb_funcs;
-      gpointer cb_data;
-      gboolean need_destroy;
-
-      gboolean (*dispatch) (GSource *,
-                GSourceFunc,
-                gpointer);
+  {
+    gboolean was_in_call;
+    gpointer user_data = NULL;
+    GSourceFunc callback = NULL;
+    GSourceCallbackFuncs *cb_funcs;
+    gpointer cb_data;
+    gboolean need_destroy;
+
+    gboolean (*dispatch) (GSource *,
+        GSourceFunc,
+        gpointer);
           GSource *prev_source;
 
-      dispatch = source->source_funcs->dispatch;
-      cb_funcs = source->callback_funcs;
-      cb_data = source->callback_data;
+    dispatch = source->source_funcs->dispatch;
+    cb_funcs = source->callback_funcs;
+    cb_data = source->callback_data;
 
-      if (cb_funcs)
-        cb_funcs->ref (cb_data);
+    if (cb_funcs)
+      cb_funcs->ref (cb_data);
 
-      if ((source->flags & G_SOURCE_CAN_RECURSE) == 0)
-        block_source (source);
+    if ((source->flags & G_SOURCE_CAN_RECURSE) == 0)
+      block_source (source);
 
-      was_in_call = source->flags & G_HOOK_FLAG_IN_CALL;
-      source->flags |= G_HOOK_FLAG_IN_CALL;
+    was_in_call = source->flags & G_HOOK_FLAG_IN_CALL;
+    source->flags |= G_HOOK_FLAG_IN_CALL;
 
-      if (cb_funcs)
-        cb_funcs->get (cb_data, source, &callback, &user_data);
+    if (cb_funcs)
+      cb_funcs->get (cb_data, source, &callback, &user_data);
 
-      UNLOCK_CONTEXT (context);
+    UNLOCK_CONTEXT (context);
 
           /* These operations are safe because 'current' is thread-local
            * and not modified from anywhere but this function.
            */
           prev_source = current->source;
@@ -3236,32 +3233,32 @@
                                            dispatch, need_destroy));
 
           current->source = prev_source;
           current->depth--;
 
-      if (cb_funcs)
-        cb_funcs->unref (cb_data);
+    if (cb_funcs)
+      cb_funcs->unref (cb_data);
 
-      LOCK_CONTEXT (context);
+    LOCK_CONTEXT (context);
 
-      if (!was_in_call)
-        source->flags &= ~G_HOOK_FLAG_IN_CALL;
+    if (!was_in_call)
+      source->flags &= ~G_HOOK_FLAG_IN_CALL;
 
-      if (SOURCE_BLOCKED (source) && !SOURCE_DESTROYED (source))
-        unblock_source (source);
+    if (SOURCE_BLOCKED (source) && !SOURCE_DESTROYED (source))
+      unblock_source (source);
 
-      /* Note: this depends on the fact that we can't switch
-       * sources from one main context to another
-       */
-      if (need_destroy && !SOURCE_DESTROYED (source))
-        {
-          g_assert (source->context == context);
-          g_source_destroy_internal (source, context, TRUE);
-        }
-    }
+    /* Note: this depends on the fact that we can't switch
+     * sources from one main context to another
+     */
+    if (need_destroy && !SOURCE_DESTROYED (source))
+      {
+        g_assert (source->context == context);
+        g_source_destroy_internal (source, context, TRUE);
+      }
+  }
 
-      SOURCE_UNREF (source, context);
+      g_source_unref_internal (source, context, TRUE);
     }
 
   g_ptr_array_set_size (context->pending_dispatches, 0);
 }
 
@@ -3339,32 +3336,32 @@
       TRACE (GLIB_MAIN_CONTEXT_RELEASE (context));
 
       context->owner = NULL;
 
       if (context->waiters)
-    {
-      GMainWaiter *waiter = context->waiters->data;
-      gboolean loop_internal_waiter = (waiter->mutex == &context->mutex);
-      context->waiters = g_slist_delete_link (context->waiters,
-                          context->waiters);
-      if (!loop_internal_waiter)
-        g_mutex_lock (waiter->mutex);
+  {
+    GMainWaiter *waiter = context->waiters->data;
+    gboolean loop_internal_waiter = (waiter->mutex == &context->mutex);
+    context->waiters = g_slist_delete_link (context->waiters,
+              context->waiters);
+    if (!loop_internal_waiter)
+      g_mutex_lock (waiter->mutex);
 
-      g_cond_signal (waiter->cond);
+    g_cond_signal (waiter->cond);
 
-      if (!loop_internal_waiter)
-        g_mutex_unlock (waiter->mutex);
-    }
+    if (!loop_internal_waiter)
+      g_mutex_unlock (waiter->mutex);
+  }
     }
 
   UNLOCK_CONTEXT (context);
 }
 
 static gboolean
 g_main_context_wait_internal (GMainContext *context,
-             GCond        *cond,
-             GMutex       *mutex)
+                              GCond        *cond,
+                              GMutex       *mutex)
 {
   gboolean result = FALSE;
   GThread *self = G_THREAD_SELF;
   gboolean loop_internal_waiter;
 
@@ -3384,14 +3381,14 @@
       waiter.mutex = mutex;
 
       context->waiters = g_slist_append (context->waiters, &waiter);
 
       if (!loop_internal_waiter)
-    UNLOCK_CONTEXT (context);
+        UNLOCK_CONTEXT (context);
       g_cond_wait (cond, mutex);
       if (!loop_internal_waiter)
-    LOCK_CONTEXT (context);
+        LOCK_CONTEXT (context);
 
       context->waiters = g_slist_remove (context->waiters, &waiter);
     }
 
   if (!context->owner)
@@ -3452,11 +3449,11 @@
 }
 
 /**
  * g_main_context_prepare:
  * @context: a #GMainContext
- * @priority: location to store priority of highest priority
+ * @priority: (out) (optional): location to store priority of highest priority
  *            source already ready.
  *
  * Prepares to poll sources within a main loop. The resulting information
  * for polling is determined by calling g_main_context_query ().
  *
@@ -3466,11 +3463,11 @@
  * Returns: %TRUE if some source is ready to be dispatched
  *               prior to polling.
  **/
 gboolean
 g_main_context_prepare (GMainContext *context,
-            gint         *priority)
+      gint         *priority)
 {
   guint i;
   gint n_ready = 0;
   gint current_priority = G_MAXINT;
   GSource *source;
@@ -3484,11 +3481,11 @@
   context->time_is_fresh = FALSE;
 
   if (context->in_check_or_prepare)
     {
       g_warning ("g_main_context_prepare() called recursively from within a source's check() or "
-         "prepare() member.");
+     "prepare() member.");
       UNLOCK_CONTEXT (context);
       return FALSE;
     }
 
   TRACE (GLIB_MAIN_CONTEXT_BEFORE_PREPARE (context));
@@ -3496,11 +3493,11 @@
 #if 0
   /* If recursing, finish up current dispatch, before starting over */
   if (context->pending_dispatches)
     {
       if (dispatch)
-    g_main_dispatch (context, &current_time);
+  g_main_dispatch (context, &current_time);
 
       UNLOCK_CONTEXT (context);
       return TRUE;
     }
 #endif
@@ -3508,11 +3505,11 @@
   /* If recursing, clear list of pending dispatches */
 
   for (i = 0; i < context->pending_dispatches->len; i++)
     {
       if (context->pending_dispatches->pdata[i])
-    SOURCE_UNREF ((GSource *)context->pending_dispatches->pdata[i], context);
+        g_source_unref_internal ((GSource *)context->pending_dispatches->pdata[i], context, TRUE);
     }
   g_ptr_array_set_size (context->pending_dispatches, 0);
 
   /* Prepare all sources */
 
@@ -3522,18 +3519,18 @@
   while (g_source_iter_next (&iter, &source))
     {
       gint source_timeout = -1;
 
       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
-    continue;
+  continue;
       if ((n_ready > 0) && (source->priority > current_priority))
-    break;
+  break;
 
       if (!(source->flags & G_SOURCE_READY))
-    {
-      gboolean result;
-      gboolean (* prepare) (GSource  *source,
+  {
+    gboolean result;
+    gboolean (* prepare) (GSource  *source,
                                 gint     *timeout);
 
           prepare = source->source_funcs->prepare;
 
           if (prepare)
@@ -3566,46 +3563,46 @@
                   source_timeout = 0;
                   result = TRUE;
                 }
               else
                 {
-                  gint timeout;
+                  gint64 timeout;
 
                   /* rounding down will lead to spinning, so always round up */
                   timeout = (source->priv->ready_time - context->time + 999) / 1000;
 
                   if (source_timeout < 0 || timeout < source_timeout)
-                    source_timeout = timeout;
+                    source_timeout = MIN (timeout, G_MAXINT);
                 }
             }
 
-      if (result)
-        {
-          GSource *ready_source = source;
+    if (result)
+      {
+        GSource *ready_source = source;
 
-          while (ready_source)
-        {
-          ready_source->flags |= G_SOURCE_READY;
-          ready_source = ready_source->priv->parent_source;
-        }
-        }
+        while (ready_source)
+    {
+      ready_source->flags |= G_SOURCE_READY;
+      ready_source = ready_source->priv->parent_source;
     }
+      }
+  }
 
       if (source->flags & G_SOURCE_READY)
-    {
-      n_ready++;
-      current_priority = source->priority;
-      context->timeout = 0;
-    }
+  {
+    n_ready++;
+    current_priority = source->priority;
+    context->timeout = 0;
+  }
 
       if (source_timeout >= 0)
-    {
-      if (context->timeout < 0)
-        context->timeout = source_timeout;
-      else
-        context->timeout = MIN (context->timeout, source_timeout);
-    }
+  {
+    if (context->timeout < 0)
+      context->timeout = source_timeout;
+    else
+      context->timeout = MIN (context->timeout, source_timeout);
+  }
     }
   g_source_iter_clear (&iter);
 
   TRACE (GLIB_MAIN_CONTEXT_AFTER_PREPARE (context, current_priority, n_ready));
 
@@ -3635,14 +3632,14 @@
  *   or, if more than @n_fds records need to be stored, the number
  *   of records that need to be stored.
  **/
 gint
 g_main_context_query (GMainContext *context,
-              gint          max_priority,
-              gint         *timeout,
-              GPollFD      *fds,
-              gint          n_fds)
+          gint          max_priority,
+          gint         *timeout,
+          GPollFD      *fds,
+          gint          n_fds)
 {
   gint n_poll;
   GPollRec *pollrec, *lastpollrec;
   gushort events;
 
@@ -3673,15 +3670,15 @@
         {
           if (n_poll < n_fds)
             {
               fds[n_poll].fd = pollrec->fd->fd;
               fds[n_poll].events = events;
-      fds[n_poll].revents = 0;
-    }
+              fds[n_poll].revents = 0;
+            }
 
-      n_poll++;
-    }
+          n_poll++;
+        }
 
       lastpollrec = pollrec;
     }
 
   context->poll_changed = FALSE;
@@ -3716,13 +3713,13 @@
  *
  * Returns: %TRUE if some sources are ready to be dispatched.
  **/
 gboolean
 g_main_context_check (GMainContext *context,
-              gint          max_priority,
-              GPollFD      *fds,
-              gint          n_fds)
+          gint          max_priority,
+          GPollFD      *fds,
+          gint          n_fds)
 {
   GSource *source;
   GSourceIter iter;
   GPollRec *pollrec;
   gint n_ready = 0;
@@ -3731,11 +3728,11 @@
   LOCK_CONTEXT (context);
 
   if (context->in_check_or_prepare)
     {
       g_warning ("g_main_context_check() called recursively from within a source's check() or "
-         "prepare() member.");
+     "prepare() member.");
       UNLOCK_CONTEXT (context);
       return FALSE;
     }
 
   TRACE (GLIB_MAIN_CONTEXT_BEFORE_CHECK (context, max_priority, fds, n_fds));
@@ -3745,11 +3742,11 @@
       if (fds[i].fd == context->wake_up_rec.fd)
         {
           if (fds[i].revents)
             {
               TRACE (GLIB_MAIN_CONTEXT_WAKEUP_ACKNOWLEDGE (context));
-    g_wakeup_acknowledge (context->wakeup);
+              g_wakeup_acknowledge (context->wakeup);
             }
           break;
         }
     }
 
@@ -3783,16 +3780,16 @@
 
   g_source_iter_init (&iter, context, TRUE);
   while (g_source_iter_next (&iter, &source))
     {
       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
-    continue;
+  continue;
       if ((n_ready > 0) && (source->priority > max_priority))
-    break;
+  break;
 
       if (!(source->flags & G_SOURCE_READY))
-    {
+  {
           gboolean result;
           gboolean (* check) (GSource *source);
 
           check = source->source_funcs->check;
 
@@ -3842,34 +3839,34 @@
 
               if (source->priv->ready_time <= context->time)
                 result = TRUE;
             }
 
-      if (result)
-        {
-          GSource *ready_source = source;
+    if (result)
+      {
+        GSource *ready_source = source;
 
-          while (ready_source)
-        {
-          ready_source->flags |= G_SOURCE_READY;
-          ready_source = ready_source->priv->parent_source;
-        }
-        }
+        while (ready_source)
+    {
+      ready_source->flags |= G_SOURCE_READY;
+      ready_source = ready_source->priv->parent_source;
     }
+      }
+  }
 
       if (source->flags & G_SOURCE_READY)
-    {
-      source->ref_count++;
-      g_ptr_array_add (context->pending_dispatches, source);
+  {
+          g_source_ref (source);
+    g_ptr_array_add (context->pending_dispatches, source);
 
-      n_ready++;
+    n_ready++;
 
           /* never dispatch sources with less priority than the first
            * one we choose to dispatch
            */
           max_priority = source->priority;
-    }
+  }
     }
   g_source_iter_clear (&iter);
 
   TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, n_ready));
 
@@ -3905,13 +3902,13 @@
 }
 
 /* HOLDS context lock */
 static gboolean
 g_main_context_iterate (GMainContext *context,
-            gboolean      block,
-            gboolean      dispatch,
-            GThread      *self)
+      gboolean      block,
+      gboolean      dispatch,
+      GThread      *self)
 {
   gint max_priority;
   gint timeout;
   gboolean some_ready;
   gint nfds, allocated_nfds;
@@ -3924,18 +3921,18 @@
       gboolean got_ownership;
 
       LOCK_CONTEXT (context);
 
       if (!block)
-    return FALSE;
+  return FALSE;
 
       got_ownership = g_main_context_wait_internal (context,
                                                     &context->cond,
                                                     &context->mutex);
 
       if (!got_ownership)
-    return FALSE;
+  return FALSE;
     }
   else
     LOCK_CONTEXT (context);
 
   if (!context->cached_poll_array)
@@ -3950,11 +3947,11 @@
   UNLOCK_CONTEXT (context);
 
   g_main_context_prepare (context, &max_priority);
 
   while ((nfds = g_main_context_query (context, max_priority, &timeout, fds,
-                       allocated_nfds)) > allocated_nfds)
+               allocated_nfds)) > allocated_nfds)
     {
       LOCK_CONTEXT (context);
       g_free (fds);
       context->cached_poll_array_size = allocated_nfds = nfds;
       context->cached_poll_array = fds = g_new (GPollFD, nfds);
@@ -4052,11 +4049,11 @@
  *
  * Returns: a new #GMainLoop.
  **/
 GMainLoop *
 g_main_loop_new (GMainContext *context,
-         gboolean      is_running)
+     gboolean      is_running)
 {
   GMainLoop *loop;
 
   if (!context)
     context = g_main_context_default();
@@ -4135,43 +4132,41 @@
 
       /* Another thread owns this context */
       LOCK_CONTEXT (loop->context);
 
       g_atomic_int_inc (&loop->ref_count);
+      g_atomic_int_set (&loop->is_running, TRUE);
 
-      if (!loop->is_running)
-    loop->is_running = TRUE;
-
-      while (loop->is_running && !got_ownership)
+      while (g_atomic_int_get (&loop->is_running) && !got_ownership)
         got_ownership = g_main_context_wait_internal (loop->context,
                                                       &loop->context->cond,
                                                       &loop->context->mutex);
 
-      if (!loop->is_running)
-    {
-      UNLOCK_CONTEXT (loop->context);
-      if (got_ownership)
-        g_main_context_release (loop->context);
-      g_main_loop_unref (loop);
-      return;
-    }
+      if (!g_atomic_int_get (&loop->is_running))
+  {
+    UNLOCK_CONTEXT (loop->context);
+    if (got_ownership)
+      g_main_context_release (loop->context);
+    g_main_loop_unref (loop);
+    return;
+  }
 
       g_assert (got_ownership);
     }
   else
     LOCK_CONTEXT (loop->context);
 
   if (loop->context->in_check_or_prepare)
     {
       g_warning ("g_main_loop_run(): called recursively from within a source's "
-         "check() or prepare() member, iteration not possible.");
+     "check() or prepare() member, iteration not possible.");
       return;
     }
 
   g_atomic_int_inc (&loop->ref_count);
-  loop->is_running = TRUE;
-  while (loop->is_running)
+  g_atomic_int_set (&loop->is_running, TRUE);
+  while (g_atomic_int_get (&loop->is_running))
     g_main_context_iterate (loop->context, TRUE, TRUE, self);
 
   UNLOCK_CONTEXT (loop->context);
 
   g_main_context_release (loop->context);
@@ -4194,11 +4189,11 @@
 {
   g_return_if_fail (loop != NULL);
   g_return_if_fail (g_atomic_int_get (&loop->ref_count) > 0);
 
   LOCK_CONTEXT (loop->context);
-  loop->is_running = FALSE;
+  g_atomic_int_set (&loop->is_running, FALSE);
   g_wakeup_signal (loop->context->wakeup);
 
   g_cond_broadcast (&loop->context->cond);
 
   UNLOCK_CONTEXT (loop->context);
@@ -4218,11 +4213,11 @@
 g_main_loop_is_running (GMainLoop *loop)
 {
   g_return_val_if_fail (loop != NULL, FALSE);
   g_return_val_if_fail (g_atomic_int_get (&loop->ref_count) > 0, FALSE);
 
-  return loop->is_running;
+  return g_atomic_int_get (&loop->is_running);
 }
 
 /**
  * g_main_loop_get_context:
  * @loop: a #GMainLoop.
@@ -4241,14 +4236,14 @@
 }
 
 /* HOLDS: context's lock */
 static void
 g_main_context_poll (GMainContext *context,
-             gint          timeout,
-             gint          priority,
-             GPollFD      *fds,
-             gint          n_fds)
+         gint          timeout,
+         gint          priority,
+         GPollFD      *fds,
+         gint          n_fds)
 {
 #ifdef  G_MAIN_POLL_DEBUG
   GTimer *poll_timer;
   GPollRec *pollrec;
   gint i;
@@ -4261,78 +4256,78 @@
       int ret, errsv;
 
 #ifdef  G_MAIN_POLL_DEBUG
       poll_timer = NULL;
       if (_g_main_poll_debug)
-    {
-      g_print ("polling context=%p n=%d timeout=%d\n",
-           context, n_fds, timeout);
-      poll_timer = g_timer_new ();
-    }
+  {
+    g_print ("polling context=%p n=%d timeout=%d\n",
+       context, n_fds, timeout);
+    poll_timer = g_timer_new ();
+  }
 #endif
 
       LOCK_CONTEXT (context);
 
       poll_func = context->poll_func;
 
       UNLOCK_CONTEXT (context);
       ret = (*poll_func) (fds, n_fds, timeout);
       errsv = errno;
       if (ret < 0 && errsv != EINTR)
-    {
+  {
 #ifndef G_OS_WIN32
-      g_warning ("poll(2) failed due to: %s.",
-             g_strerror (errsv));
+    g_warning ("poll(2) failed due to: %s.",
+         g_strerror (errsv));
 #else
-      /* If g_poll () returns -1, it has already called g_warning() */
+    /* If g_poll () returns -1, it has already called g_warning() */
 #endif
-    }
+  }
 
 #ifdef  G_MAIN_POLL_DEBUG
       if (_g_main_poll_debug)
-    {
-      LOCK_CONTEXT (context);
-
-      g_print ("g_main_poll(%d) timeout: %d - elapsed %12.10f seconds",
-           n_fds,
-           timeout,
-           g_timer_elapsed (poll_timer, NULL));
-      g_timer_destroy (poll_timer);
-      pollrec = context->poll_records;
+  {
+    LOCK_CONTEXT (context);
 
-      while (pollrec != NULL)
-        {
-          i = 0;
-          while (i < n_fds)
+    g_print ("g_main_poll(%d) timeout: %d - elapsed %12.10f seconds",
+       n_fds,
+       timeout,
+       g_timer_elapsed (poll_timer, NULL));
+    g_timer_destroy (poll_timer);
+    pollrec = context->poll_records;
+
+    while (pollrec != NULL)
+      {
+        i = 0;
+        while (i < n_fds)
+    {
+      if (fds[i].fd == pollrec->fd->fd &&
+          pollrec->fd->events &&
+          fds[i].revents)
         {
-          if (fds[i].fd == pollrec->fd->fd &&
-              pollrec->fd->events &&
-              fds[i].revents)
-            {
-              g_print (" [" G_POLLFD_FORMAT " :", fds[i].fd);
-              if (fds[i].revents & G_IO_IN)
-            g_print ("i");
-              if (fds[i].revents & G_IO_OUT)
-            g_print ("o");
-              if (fds[i].revents & G_IO_PRI)
-            g_print ("p");
-              if (fds[i].revents & G_IO_ERR)
-            g_print ("e");
-              if (fds[i].revents & G_IO_HUP)
-            g_print ("h");
-              if (fds[i].revents & G_IO_NVAL)
-            g_print ("n");
-              g_print ("]");
-            }
-          i++;
+          g_print (" [" G_POLLFD_FORMAT " :", fds[i].fd);
+          if (fds[i].revents & G_IO_IN)
+      g_print ("i");
+          if (fds[i].revents & G_IO_OUT)
+      g_print ("o");
+          if (fds[i].revents & G_IO_PRI)
+      g_print ("p");
+          if (fds[i].revents & G_IO_ERR)
+      g_print ("e");
+          if (fds[i].revents & G_IO_HUP)
+      g_print ("h");
+          if (fds[i].revents & G_IO_NVAL)
+      g_print ("n");
+          g_print ("]");
         }
-          pollrec = pollrec->next;
-        }
-      g_print ("\n");
-
-      UNLOCK_CONTEXT (context);
+      i++;
     }
+        pollrec = pollrec->next;
+      }
+    g_print ("\n");
+
+    UNLOCK_CONTEXT (context);
+  }
 #endif
     } /* if (n_fds || timeout != 0) */
 }
 
 /**
@@ -4348,12 +4343,12 @@
  * this context. This will very seldom be used directly. Instead
  * a typical event source will use g_source_add_unix_fd() instead.
  **/
 void
 g_main_context_add_poll (GMainContext *context,
-             GPollFD      *fd,
-             gint          priority)
+       GPollFD      *fd,
+       gint          priority)
 {
   if (!context)
     context = g_main_context_default ();
 
   g_return_if_fail (g_atomic_int_get (&context->ref_count) > 0);
@@ -4365,12 +4360,12 @@
 }
 
 /* HOLDS: main_loop_lock */
 static void
 g_main_context_add_poll_unlocked (GMainContext *context,
-                  gint          priority,
-                  GPollFD      *fd)
+          gint          priority,
+          GPollFD      *fd)
 {
   GPollRec *prevrec, *nextrec;
   GPollRec *newrec = g_slice_new (GPollRec);
 #ifdef GSTREAMER_LITE
   if (newrec == NULL) {
@@ -4420,11 +4415,11 @@
  * Removes file descriptor from the set of file descriptors to be
  * polled for a particular context.
  **/
 void
 g_main_context_remove_poll (GMainContext *context,
-                GPollFD      *fd)
+          GPollFD      *fd)
 {
   if (!context)
     context = g_main_context_default ();
 
   g_return_if_fail (g_atomic_int_get (&context->ref_count) > 0);
@@ -4435,35 +4430,35 @@
   UNLOCK_CONTEXT (context);
 }
 
 static void
 g_main_context_remove_poll_unlocked (GMainContext *context,
-                     GPollFD      *fd)
+             GPollFD      *fd)
 {
   GPollRec *pollrec, *prevrec, *nextrec;
 
   prevrec = NULL;
   pollrec = context->poll_records;
 
   while (pollrec)
     {
       nextrec = pollrec->next;
       if (pollrec->fd == fd)
-    {
-      if (prevrec != NULL)
-        prevrec->next = nextrec;
-      else
-        context->poll_records = nextrec;
+  {
+    if (prevrec != NULL)
+      prevrec->next = nextrec;
+    else
+      context->poll_records = nextrec;
 
-      if (nextrec != NULL)
-        nextrec->prev = prevrec;
+    if (nextrec != NULL)
+      nextrec->prev = prevrec;
 
-      g_slice_free (GPollRec, pollrec);
+    g_slice_free (GPollRec, pollrec);
 
-      context->n_poll_records--;
-      break;
-    }
+    context->n_poll_records--;
+    break;
+  }
       prevrec = pollrec;
       pollrec = nextrec;
     }
 
   context->poll_changed = TRUE;
@@ -4480,16 +4475,18 @@
  * This function ignores @source and is otherwise the same as
  * g_get_current_time().
  *
  * Deprecated: 2.28: use g_source_get_time() instead
  **/
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 void
 g_source_get_current_time (GSource  *source,
-               GTimeVal *timeval)
+         GTimeVal *timeval)
 {
   g_get_current_time (timeval);
 }
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 /**
  * g_source_get_time:
  * @source: a #GSource
  *
@@ -4543,11 +4540,11 @@
  * This function could possibly be used to integrate the GLib event
  * loop with an external event loop.
  **/
 void
 g_main_context_set_poll_func (GMainContext *context,
-                  GPollFunc     func)
+            GPollFunc     func)
 {
   if (!context)
     context = g_main_context_default ();
 
   g_return_if_fail (g_atomic_int_get (&context->ref_count) > 0);
@@ -4667,12 +4664,10 @@
 g_timeout_set_expiration (GTimeoutSource *timeout_source,
                           gint64          current_time)
 {
   gint64 expiration;
 
-  expiration = current_time + (guint64) timeout_source->interval * 1000;
-
   if (timeout_source->seconds)
     {
       gint64 remainder;
       static gint timer_perturb = -1;
 
@@ -4690,10 +4685,12 @@
             timer_perturb = ABS ((gint) g_str_hash (session_bus_address)) % 1000000;
           else
             timer_perturb = 0;
         }
 
+      expiration = current_time + (guint64) timeout_source->interval * 1000 * 1000;
+
       /* We want the microseconds part of the timeout to land on the
        * 'timer_perturb' mark, but we need to make sure we don't try to
        * set the timeout in the past.  We do this by ensuring that we
        * always only *increase* the expiration time by adding a full
        * second in the case that the microsecond portion decreases.
@@ -4705,10 +4702,14 @@
         expiration += 1000000;
 
       expiration -= remainder;
       expiration += timer_perturb;
     }
+  else
+    {
+      expiration = current_time + (guint64) timeout_source->interval * 1000;
+    }
 
   g_source_set_ready_time ((GSource *) timeout_source, expiration);
 }
 
 static gboolean
@@ -4792,11 +4793,11 @@
 g_timeout_source_new_seconds (guint interval)
 {
   GSource *source = g_source_new (&g_timeout_funcs, sizeof (GTimeoutSource));
   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
 
-  timeout_source->interval = 1000 * interval;
+  timeout_source->interval = interval;
   timeout_source->seconds = TRUE;
 
   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
 
   return source;
@@ -4841,14 +4842,14 @@
  *
  * Returns: the ID (greater than 0) of the event source.
  **/
 guint
 g_timeout_add_full (gint           priority,
-            guint          interval,
-            GSourceFunc    function,
-            gpointer       data,
-            GDestroyNotify notify)
+        guint          interval,
+        GSourceFunc    function,
+        gpointer       data,
+        GDestroyNotify notify)
 {
   GSource *source;
   guint id;
 
   g_return_val_if_fail (function != NULL, 0);
@@ -4910,15 +4911,15 @@
  *
  * Returns: the ID (greater than 0) of the event source.
  **/
 guint
 g_timeout_add (guint32        interval,
-           GSourceFunc    function,
-           gpointer       data)
+         GSourceFunc    function,
+         gpointer       data)
 {
   return g_timeout_add_full (G_PRIORITY_DEFAULT,
-                 interval, function, data, NULL);
+           interval, function, data, NULL);
 }
 
 #ifndef GSTREAMER_LITE
 /**
  * g_timeout_add_seconds_full: (rename-to g_timeout_add_seconds)
@@ -5039,11 +5040,11 @@
 
 #ifdef G_OS_WIN32
 
 static gboolean
 g_child_watch_prepare (GSource *source,
-               gint    *timeout)
+           gint    *timeout)
 {
   *timeout = -1;
   return FALSE;
 }
 
@@ -5067,18 +5068,18 @@
        * problems if the child process "happens to return STILL_ACTIVE(259)"
        * as Microsoft's Platform SDK puts it.
        */
       if (!GetExitCodeProcess (child_watch_source->pid, &child_status))
         {
-      gchar *emsg = g_win32_error_message (GetLastError ());
-      g_warning (G_STRLOC ": GetExitCodeProcess() failed: %s", emsg);
-      g_free (emsg);
+    gchar *emsg = g_win32_error_message (GetLastError ());
+    g_warning (G_STRLOC ": GetExitCodeProcess() failed: %s", emsg);
+    g_free (emsg);
 
-      child_watch_source->child_status = -1;
-    }
+    child_watch_source->child_status = -1;
+  }
       else
-    child_watch_source->child_status = child_status;
+  child_watch_source->child_status = child_status;
     }
 
   return child_exited;
 }
 
@@ -5171,28 +5172,28 @@
        */
       for (node = unix_child_watches; node; node = node->next)
         {
           GChildWatchSource *source = node->data;
 
-          if (!source->child_exited)
+          if (!g_atomic_int_get (&source->child_exited))
             {
               pid_t pid;
               do
                 {
                   g_assert (source->pid > 0);
 
                   pid = waitpid (source->pid, &source->child_status, WNOHANG);
                   if (pid > 0)
                     {
-                      source->child_exited = TRUE;
+                      g_atomic_int_set (&source->child_exited, TRUE);
                       wake_source ((GSource *) source);
                     }
                   else if (pid == -1 && errno == ECHILD)
                     {
                       g_warning ("GChildWatchSource: Exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.");
-                      source->child_exited = TRUE;
                       source->child_status = 0;
+                      g_atomic_int_set (&source->child_exited, TRUE);
                       wake_source ((GSource *) source);
                     }
                 }
               while (pid == -1 && errno == EINTR);
             }
@@ -5202,18 +5203,14 @@
   /* handle GUnixSignalWatchSource instances */
   for (node = unix_signal_watches; node; node = node->next)
     {
       GUnixSignalWatchSource *source = node->data;
 
-      if (!source->pending)
+      if (pending[source->signum] &&
+          g_atomic_int_compare_and_exchange (&source->pending, FALSE, TRUE))
         {
-          if (pending[source->signum])
-            {
-              source->pending = TRUE;
-
-              wake_source ((GSource *) source);
-            }
+          wake_source ((GSource *) source);
         }
     }
 
 }
 
@@ -5225,70 +5222,70 @@
   G_UNLOCK(unix_signal_lock);
 }
 
 static gboolean
 g_child_watch_prepare (GSource *source,
-               gint    *timeout)
+           gint    *timeout)
 {
   GChildWatchSource *child_watch_source;
 
   child_watch_source = (GChildWatchSource *) source;
 
-  return child_watch_source->child_exited;
+  return g_atomic_int_get (&child_watch_source->child_exited);
 }
 
 static gboolean
 g_child_watch_check (GSource *source)
 {
   GChildWatchSource *child_watch_source;
 
   child_watch_source = (GChildWatchSource *) source;
 
-  return child_watch_source->child_exited;
+  return g_atomic_int_get (&child_watch_source->child_exited);
 }
 
 static gboolean
 g_unix_signal_watch_prepare (GSource *source,
-                 gint    *timeout)
+           gint    *timeout)
 {
   GUnixSignalWatchSource *unix_signal_source;
 
   unix_signal_source = (GUnixSignalWatchSource *) source;
 
-  return unix_signal_source->pending;
+  return g_atomic_int_get (&unix_signal_source->pending);
 }
 
 static gboolean
 g_unix_signal_watch_check (GSource  *source)
 {
   GUnixSignalWatchSource *unix_signal_source;
 
   unix_signal_source = (GUnixSignalWatchSource *) source;
 
-  return unix_signal_source->pending;
+  return g_atomic_int_get (&unix_signal_source->pending);
 }
 
 static gboolean
 g_unix_signal_watch_dispatch (GSource    *source,
-                  GSourceFunc callback,
-                  gpointer    user_data)
+            GSourceFunc callback,
+            gpointer    user_data)
 {
   GUnixSignalWatchSource *unix_signal_source;
   gboolean again;
 
   unix_signal_source = (GUnixSignalWatchSource *) source;
 
   if (!callback)
     {
       g_warning ("Unix signal source dispatched without callback. "
-         "You must call g_source_set_callback().");
+     "You must call g_source_set_callback().");
       return FALSE;
     }
 
-  again = (callback) (user_data);
+  g_atomic_int_set (&unix_signal_source->pending, FALSE);
 
-  unix_signal_source->pending = FALSE;
+  again = (callback) (user_data);
 
   return again;
 }
 
 static void
@@ -5435,22 +5432,22 @@
 
 #endif /* G_OS_WIN32 */
 
 static gboolean
 g_child_watch_dispatch (GSource    *source,
-            GSourceFunc callback,
-            gpointer    user_data)
+      GSourceFunc callback,
+      gpointer    user_data)
 {
   GChildWatchSource *child_watch_source;
   GChildWatchFunc child_watch_callback = (GChildWatchFunc) callback;
 
   child_watch_source = (GChildWatchSource *) source;
 
   if (!callback)
     {
       g_warning ("Child watch source dispatched without callback. "
-         "You must call g_source_set_callback().");
+     "You must call g_source_set_callback().");
       return FALSE;
     }
 
   (child_watch_callback) (child_watch_source->pid, child_watch_source->child_status, user_data);
 
@@ -5595,14 +5592,14 @@
  *
  * Since: 2.4
  **/
 guint
 g_child_watch_add_full (gint            priority,
-            GPid            pid,
-            GChildWatchFunc function,
-            gpointer        data,
-            GDestroyNotify  notify)
+      GPid            pid,
+      GChildWatchFunc function,
+      gpointer        data,
+      GDestroyNotify  notify)
 {
   GSource *source;
   guint id;
 
   g_return_val_if_fail (function != NULL, 0);
@@ -5655,22 +5652,22 @@
  *
  * Since: 2.4
  **/
 guint
 g_child_watch_add (GPid            pid,
-           GChildWatchFunc function,
-           gpointer        data)
+       GChildWatchFunc function,
+       gpointer        data)
 {
   return g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, function, data, NULL);
 }
 
 
 /* Idle functions */
 
 static gboolean
 g_idle_prepare  (GSource  *source,
-         gint     *timeout)
+     gint     *timeout)
 {
   *timeout = 0;
 
   return TRUE;
 }
@@ -5681,19 +5678,19 @@
   return TRUE;
 }
 
 static gboolean
 g_idle_dispatch (GSource    *source,
-         GSourceFunc callback,
-         gpointer    user_data)
+     GSourceFunc callback,
+     gpointer    user_data)
 {
   gboolean again;
 
   if (!callback)
     {
       g_warning ("Idle source dispatched without callback. "
-         "You must call g_source_set_callback().");
+     "You must call g_source_set_callback().");
       return FALSE;
     }
 
   again = callback (user_data);
 
@@ -5752,13 +5749,13 @@
  *
  * Returns: the ID (greater than 0) of the event source.
  **/
 guint
 g_idle_add_full (gint           priority,
-         GSourceFunc    function,
-         gpointer       data,
-         GDestroyNotify notify)
+     GSourceFunc    function,
+     gpointer       data,
+     GDestroyNotify notify)
 {
   GSource *source;
   guint id;
 
   g_return_val_if_fail (function != NULL, 0);
@@ -5800,11 +5797,11 @@
  *
  * Returns: the ID (greater than 0) of the event source.
  **/
 guint
 g_idle_add (GSourceFunc    function,
-        gpointer       data)
+      gpointer       data)
 {
   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, function, data, NULL);
 }
 
 /**
@@ -5828,12 +5825,12 @@
  * @data: data to pass to @function
  *
  * Invokes a function in such a way that @context is owned during the
  * invocation of @function.
  *
- * If @context is %NULL then the global default main context as
- * returned by g_main_context_default() is used.
+ * If @context is %NULL then the global default main context - as
+ * returned by g_main_context_default() - is used.
  *
  * If @context is owned by the current thread, @function is called
  * directly.  Otherwise, if @context is the thread-default main context
  * of the current thread and g_main_context_acquire() succeeds, then
  * @function is called and g_main_context_release() is called
