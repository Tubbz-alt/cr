<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbin.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  *
   3  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   4  *                    2004 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   5  *
   6  * gstbin.c: GstBin container object and support code
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  * MT safe.
  24  */
  25 
  26 /**
  27  * SECTION:gstbin
  28  * @title: GstBin
  29  * @short_description: Base class and element that can contain other elements
  30  *
  31  * #GstBin is an element that can contain other #GstElement, allowing them to be
  32  * managed as a group.
  33  * Pads from the child elements can be ghosted to the bin, see #GstGhostPad.
  34  * This makes the bin look like any other elements and enables creation of
  35  * higher-level abstraction elements.
  36  *
  37  * A new #GstBin is created with gst_bin_new(). Use a #GstPipeline instead if you
  38  * want to create a toplevel bin because a normal bin doesn&#39;t have a bus or
  39  * handle clock distribution of its own.
  40  *
  41  * After the bin has been created you will typically add elements to it with
  42  * gst_bin_add(). You can remove elements with gst_bin_remove().
  43  *
  44  * An element can be retrieved from a bin with gst_bin_get_by_name(), using the
  45  * elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
  46  * purposes and will query the parent bins when the element is not found in the
  47  * current bin.
  48  *
  49  * An iterator of elements in a bin can be retrieved with
  50  * gst_bin_iterate_elements(). Various other iterators exist to retrieve the
  51  * elements in a bin.
  52  *
  53  * gst_object_unref() is used to drop your reference to the bin.
  54  *
  55  * The #GstBin::element-added signal is fired whenever a new element is added to
  56  * the bin. Likewise the #GstBin::element-removed signal is fired whenever an
  57  * element is removed from the bin.
  58  *
  59  * ## Notes
  60  *
  61  * A #GstBin internally intercepts every #GstMessage posted by its children and
  62  * implements the following default behaviour for each of them:
  63  *
  64  * * GST_MESSAGE_EOS: This message is only posted by sinks in the PLAYING
  65  * state. If all sinks posted the EOS message, this bin will post and EOS
  66  * message upwards.
  67  *
  68  * * GST_MESSAGE_SEGMENT_START: Just collected and never forwarded upwards.
  69  * The messages are used to decide when all elements have completed playback
  70  * of their segment.
  71  *
  72  * * GST_MESSAGE_SEGMENT_DONE: Is posted by #GstBin when all elements that posted
  73  * a SEGMENT_START have posted a SEGMENT_DONE.
  74  *
  75  * * GST_MESSAGE_DURATION_CHANGED: Is posted by an element that detected a change
  76  * in the stream duration. The default bin behaviour is to clear any
  77  * cached duration values so that the next duration query will perform
  78  * a full duration recalculation. The duration change is posted to the
  79  * application so that it can refetch the new duration with a duration
  80  * query. Note that these messages can be posted before the bin is
  81  * prerolled, in which case the duration query might fail.
  82  *
  83  * * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it
  84  * can no longer provide a clock. The default bin behaviour is to
  85  * check if the lost clock was the one provided by the bin. If so and
  86  * the bin is currently in the PLAYING state, the message is forwarded to
  87  * the bin parent.
  88  * This message is also generated when a clock provider is removed from
  89  * the bin. If this message is received by the application, it should
  90  * PAUSE the pipeline and set it back to PLAYING to force a new clock
  91  * distribution.
  92  *
  93  * * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element
  94  * can provide a clock. This mostly happens when a new clock
  95  * provider is added to the bin. The default behaviour of the bin is to
  96  * mark the currently selected clock as dirty, which will perform a clock
  97  * recalculation the next time the bin is asked to provide a clock.
  98  * This message is never sent tot the application but is forwarded to
  99  * the parent of the bin.
 100  *
 101  * * OTHERS: posted upwards.
 102  *
 103  * A #GstBin implements the following default behaviour for answering to a
 104  * #GstQuery:
 105  *
 106  * * GST_QUERY_DURATION:If the query has been asked before with the same format
 107  * and the bin is a toplevel bin (ie. has no parent),
 108  * use the cached previous value. If no previous value was cached, the
 109  * query is sent to all sink elements in the bin and the MAXIMUM of all
 110  * values is returned. If the bin is a toplevel bin the value is cached.
 111  * If no sinks are available in the bin, the query fails.
 112  *
 113  * * GST_QUERY_POSITION:The query is sent to all sink elements in the bin and the
 114  * MAXIMUM of all values is returned. If no sinks are available in the bin,
 115  * the query fails.
 116  *
 117  * * OTHERS:the query is forwarded to all sink elements, the result
 118  * of the first sink that answers the query successfully is returned. If no
 119  * sink is in the bin, the query fails.
 120  *
 121  * A #GstBin will by default forward any event sent to it to all sink
 122  * (#GST_EVENT_TYPE_DOWNSTREAM) or source (#GST_EVENT_TYPE_UPSTREAM) elements
 123  * depending on the event type.
 124  * If all the elements return %TRUE, the bin will also return %TRUE, else %FALSE
 125  * is returned. If no elements of the required type are in the bin, the event
 126  * handler will return %TRUE.
 127  *
 128  */
 129 
 130 #include &quot;gst_private.h&quot;
 131 
 132 #include &quot;gstevent.h&quot;
 133 #include &quot;gstbin.h&quot;
 134 #include &quot;gstinfo.h&quot;
 135 #include &quot;gsterror.h&quot;
 136 
 137 #include &quot;gstutils.h&quot;
 138 #include &quot;gstchildproxy.h&quot;
 139 
 140 GST_DEBUG_CATEGORY_STATIC (bin_debug);
 141 #define GST_CAT_DEFAULT bin_debug
 142 
 143 /* a bin is toplevel if it has no parent or when it is configured to behave like
 144  * a toplevel bin */
 145 #define BIN_IS_TOPLEVEL(bin) ((GST_OBJECT_PARENT (bin) == NULL) || bin-&gt;priv-&gt;asynchandling)
 146 
<a name="1" id="anc1"></a><span class="line-removed"> 147 #define GST_BIN_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 148    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BIN, GstBinPrivate))</span>
<span class="line-removed"> 149 </span>
 150 struct _GstBinPrivate
 151 {
 152   gboolean asynchandling;
 153   /* if we get an ASYNC_DONE message from ourselves, this means that the
 154    * subclass will simulate ASYNC behaviour without having ASYNC children. When
 155    * such an ASYNC_DONE message is posted while we are doing a state change, we
 156    * have to process the message after finishing the state change even when no
 157    * child returned GST_STATE_CHANGE_ASYNC. */
 158   gboolean pending_async_done;
 159 
 160   guint32 structure_cookie;
 161 
 162 #if 0
 163   /* cached index */
 164   GstIndex *index;
 165 #endif
 166 
 167   /* forward messages from our children */
 168   gboolean message_forward;
 169 
 170   gboolean posted_eos;
 171   gboolean posted_playing;
 172   GstElementFlags suppressed_flags;
 173 };
 174 
 175 typedef struct
 176 {
 177   guint32 cookie;
 178   GstState pending;
 179 } BinContinueData;
 180 
 181 static void gst_bin_dispose (GObject * object);
 182 
 183 static void gst_bin_set_property (GObject * object, guint prop_id,
 184     const GValue * value, GParamSpec * pspec);
 185 static void gst_bin_get_property (GObject * object, guint prop_id,
 186     GValue * value, GParamSpec * pspec);
 187 
 188 static GstStateChangeReturn gst_bin_change_state_func (GstElement * element,
 189     GstStateChange transition);
 190 static gboolean gst_bin_post_message (GstElement * element, GstMessage * msg);
 191 static GstStateChangeReturn gst_bin_get_state_func (GstElement * element,
 192     GstState * state, GstState * pending, GstClockTime timeout);
 193 static void bin_handle_async_done (GstBin * bin, GstStateChangeReturn ret,
 194     gboolean flag_pending, GstClockTime running_time);
 195 static void bin_handle_async_start (GstBin * bin);
 196 static void bin_push_state_continue (GstBin * bin, BinContinueData * data);
 197 static void bin_do_eos (GstBin * bin);
 198 
 199 static gboolean gst_bin_add_func (GstBin * bin, GstElement * element);
 200 static gboolean gst_bin_remove_func (GstBin * bin, GstElement * element);
 201 static void gst_bin_deep_element_added_func (GstBin * bin, GstBin * sub_bin,
 202     GstElement * element);
 203 static void gst_bin_deep_element_removed_func (GstBin * bin, GstBin * sub_bin,
 204     GstElement * element);
 205 static void gst_bin_update_context (GstBin * bin, GstContext * context);
 206 static void gst_bin_update_context_unlocked (GstBin * bin,
 207     GstContext * context);
 208 
 209 #if 0
 210 static void gst_bin_set_index_func (GstElement * element, GstIndex * index);
 211 static GstIndex *gst_bin_get_index_func (GstElement * element);
 212 #endif
 213 
 214 static GstClock *gst_bin_provide_clock_func (GstElement * element);
 215 static gboolean gst_bin_set_clock_func (GstElement * element, GstClock * clock);
 216 
 217 static void gst_bin_handle_message_func (GstBin * bin, GstMessage * message);
 218 static gboolean gst_bin_send_event (GstElement * element, GstEvent * event);
 219 static GstBusSyncReply bin_bus_handler (GstBus * bus,
 220     GstMessage * message, GstBin * bin);
 221 static gboolean gst_bin_query (GstElement * element, GstQuery * query);
 222 static void gst_bin_set_context (GstElement * element, GstContext * context);
 223 
 224 static gboolean gst_bin_do_latency_func (GstBin * bin);
 225 
 226 static void bin_remove_messages (GstBin * bin, GstObject * src,
 227     GstMessageType types);
 228 static void gst_bin_continue_func (GstBin * bin, BinContinueData * data);
 229 static gint bin_element_is_sink (GstElement * child, GstBin * bin);
 230 static gint bin_element_is_src (GstElement * child, GstBin * bin);
 231 
 232 static GstIterator *gst_bin_sort_iterator_new (GstBin * bin);
 233 
 234 /* Bin signals and properties */
 235 enum
 236 {
 237   ELEMENT_ADDED,
 238   ELEMENT_REMOVED,
 239   DO_LATENCY,
 240   DEEP_ELEMENT_ADDED,
 241   DEEP_ELEMENT_REMOVED,
 242   LAST_SIGNAL
 243 };
 244 
 245 #define DEFAULT_ASYNC_HANDLING  FALSE
 246 #define DEFAULT_MESSAGE_FORWARD FALSE
 247 
 248 enum
 249 {
 250   PROP_0,
 251   PROP_ASYNC_HANDLING,
 252   PROP_MESSAGE_FORWARD,
 253   PROP_LAST
 254 };
 255 
 256 static void gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data);
 257 
 258 static guint gst_bin_signals[LAST_SIGNAL] = { 0 };
 259 
 260 #define _do_init \
 261 { \
 262   static const GInterfaceInfo iface_info = { \
 263     gst_bin_child_proxy_init, \
 264     NULL, \
 265     NULL}; \
 266   \
 267   g_type_add_interface_static (g_define_type_id, GST_TYPE_CHILD_PROXY, &amp;iface_info); \
 268   \
 269   GST_DEBUG_CATEGORY_INIT (bin_debug, &quot;bin&quot;, GST_DEBUG_BOLD, \
 270       &quot;debugging info for the &#39;bin&#39; container element&quot;); \
 271   \
 272 }
 273 
 274 #define gst_bin_parent_class parent_class
<a name="2" id="anc2"></a><span class="line-modified"> 275 G_DEFINE_TYPE_WITH_CODE (GstBin, gst_bin, GST_TYPE_ELEMENT, _do_init);</span>


 276 
 277 static GObject *
 278 gst_bin_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
 279     guint index)
 280 {
 281   GstObject *res;
 282   GstBin *bin;
 283 
 284   bin = GST_BIN_CAST (child_proxy);
 285 
 286   GST_OBJECT_LOCK (bin);
 287   if ((res = g_list_nth_data (bin-&gt;children, index)))
 288     gst_object_ref (res);
 289   GST_OBJECT_UNLOCK (bin);
 290 
 291   return (GObject *) res;
 292 }
 293 
 294 static guint
 295 gst_bin_child_proxy_get_children_count (GstChildProxy * child_proxy)
 296 {
 297   guint num;
 298   GstBin *bin;
 299 
 300   bin = GST_BIN_CAST (child_proxy);
 301 
 302   GST_OBJECT_LOCK (bin);
 303   num = bin-&gt;numchildren;
 304   GST_OBJECT_UNLOCK (bin);
 305 
 306   return num;
 307 }
 308 
 309 static void
 310 gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data)
 311 {
 312   GstChildProxyInterface *iface = g_iface;
 313 
 314   iface-&gt;get_children_count = gst_bin_child_proxy_get_children_count;
 315   iface-&gt;get_child_by_index = gst_bin_child_proxy_get_child_by_index;
 316 }
 317 
 318 static gboolean
 319 _gst_boolean_accumulator (GSignalInvocationHint * ihint,
 320     GValue * return_accu, const GValue * handler_return, gpointer dummy)
 321 {
 322   gboolean myboolean;
 323 
 324   myboolean = g_value_get_boolean (handler_return);
 325   if (!(ihint-&gt;run_type &amp; G_SIGNAL_RUN_CLEANUP))
 326     g_value_set_boolean (return_accu, myboolean);
 327 
 328   GST_DEBUG (&quot;invocation %d, %d&quot;, ihint-&gt;run_type, myboolean);
 329 
 330   /* stop emission */
 331   return FALSE;
 332 }
 333 
 334 static void
 335 gst_bin_class_init (GstBinClass * klass)
 336 {
 337   GObjectClass *gobject_class;
 338   GstElementClass *gstelement_class;
 339 
 340   gobject_class = (GObjectClass *) klass;
 341   gstelement_class = (GstElementClass *) klass;
 342 
<a name="3" id="anc3"></a><span class="line-removed"> 343   g_type_class_add_private (klass, sizeof (GstBinPrivate));</span>
<span class="line-removed"> 344 </span>
 345   gobject_class-&gt;set_property = gst_bin_set_property;
 346   gobject_class-&gt;get_property = gst_bin_get_property;
 347 
 348   /**
 349    * GstBin:async-handling:
 350    *
 351    * If set to %TRUE, the bin will handle asynchronous state changes.
 352    * This should be used only if the bin subclass is modifying the state
 353    * of its children on its own.
 354    */
 355   g_object_class_install_property (gobject_class, PROP_ASYNC_HANDLING,
 356       g_param_spec_boolean (&quot;async-handling&quot;, &quot;Async Handling&quot;,
 357           &quot;The bin will handle Asynchronous state changes&quot;,
 358           DEFAULT_ASYNC_HANDLING, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 359 
 360   /**
 361    * GstBin::element-added:
 362    * @bin: the #GstBin
 363    * @element: the #GstElement that was added to the bin
 364    *
 365    * Will be emitted after the element was added to the bin.
 366    */
 367   gst_bin_signals[ELEMENT_ADDED] =
 368       g_signal_new (&quot;element-added&quot;, G_TYPE_FROM_CLASS (klass),
 369       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, element_added), NULL,
 370       NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 371   /**
 372    * GstBin::element-removed:
 373    * @bin: the #GstBin
 374    * @element: the #GstElement that was removed from the bin
 375    *
 376    * Will be emitted after the element was removed from the bin.
 377    */
 378   gst_bin_signals[ELEMENT_REMOVED] =
 379       g_signal_new (&quot;element-removed&quot;, G_TYPE_FROM_CLASS (klass),
 380       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, element_removed), NULL,
 381       NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 382   /**
 383    * GstBin::deep-element-added:
 384    * @bin: the #GstBin
 385    * @sub_bin: the #GstBin the element was added to
 386    * @element: the #GstElement that was added to @sub_bin
 387    *
 388    * Will be emitted after the element was added to sub_bin.
 389    *
 390    * Since: 1.10
 391    */
 392   gst_bin_signals[DEEP_ELEMENT_ADDED] =
 393       g_signal_new (&quot;deep-element-added&quot;, G_TYPE_FROM_CLASS (klass),
 394       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, deep_element_added),
 395       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 2, GST_TYPE_BIN,
 396       GST_TYPE_ELEMENT);
 397   /**
 398    * GstBin::deep-element-removed:
 399    * @bin: the #GstBin
 400    * @sub_bin: the #GstBin the element was removed from
 401    * @element: the #GstElement that was removed from @sub_bin
 402    *
 403    * Will be emitted after the element was removed from sub_bin.
 404    *
 405    * Since: 1.10
 406    */
 407   gst_bin_signals[DEEP_ELEMENT_REMOVED] =
 408       g_signal_new (&quot;deep-element-removed&quot;, G_TYPE_FROM_CLASS (klass),
 409       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, deep_element_removed),
 410       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 2, GST_TYPE_BIN,
 411       GST_TYPE_ELEMENT);
 412   /**
 413    * GstBin::do-latency:
 414    * @bin: the #GstBin
 415    *
 416    * Will be emitted when the bin needs to perform latency calculations. This
 417    * signal is only emitted for toplevel bins or when async-handling is
 418    * enabled.
 419    *
 420    * Only one signal handler is invoked. If no signals are connected, the
 421    * default handler is invoked, which will query and distribute the lowest
 422    * possible latency to all sinks.
 423    *
 424    * Connect to this signal if the default latency calculations are not
 425    * sufficient, like when you need different latencies for different sinks in
 426    * the same pipeline.
 427    */
 428   gst_bin_signals[DO_LATENCY] =
 429       g_signal_new (&quot;do-latency&quot;, G_TYPE_FROM_CLASS (klass),
 430       G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstBinClass, do_latency),
 431       _gst_boolean_accumulator, NULL, g_cclosure_marshal_generic,
 432       G_TYPE_BOOLEAN, 0, G_TYPE_NONE);
 433 
 434   /**
 435    * GstBin:message-forward:
 436    *
 437    * Forward all children messages, even those that would normally be filtered by
 438    * the bin. This can be interesting when one wants to be notified of the EOS
 439    * state of individual elements, for example.
 440    *
 441    * The messages are converted to an ELEMENT message with the bin as the
 442    * source. The structure of the message is named &#39;GstBinForwarded&#39; and contains
 443    * a field named &#39;message&#39; of type GST_TYPE_MESSAGE that contains the original
 444    * forwarded message.
 445    */
 446   g_object_class_install_property (gobject_class, PROP_MESSAGE_FORWARD,
 447       g_param_spec_boolean (&quot;message-forward&quot;, &quot;Message Forward&quot;,
 448           &quot;Forwards all children messages&quot;,
 449           DEFAULT_MESSAGE_FORWARD, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 450 
 451   gobject_class-&gt;dispose = gst_bin_dispose;
 452 
 453   gst_element_class_set_static_metadata (gstelement_class, &quot;Generic bin&quot;,
 454       &quot;Generic/Bin&quot;,
 455       &quot;Simple container object&quot;,
 456       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;,&quot;
 457       &quot;Wim Taymans &lt;wim.taymans@gmail.com&gt;&quot;);
 458 
 459   gstelement_class-&gt;change_state =
 460       GST_DEBUG_FUNCPTR (gst_bin_change_state_func);
 461   gstelement_class-&gt;post_message = GST_DEBUG_FUNCPTR (gst_bin_post_message);
 462   gstelement_class-&gt;get_state = GST_DEBUG_FUNCPTR (gst_bin_get_state_func);
 463 #if 0
 464   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_bin_get_index_func);
 465   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_bin_set_index_func);
 466 #endif
 467   gstelement_class-&gt;provide_clock =
 468       GST_DEBUG_FUNCPTR (gst_bin_provide_clock_func);
 469   gstelement_class-&gt;set_clock = GST_DEBUG_FUNCPTR (gst_bin_set_clock_func);
 470 
 471   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_bin_send_event);
 472   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_bin_query);
 473   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_bin_set_context);
 474 
 475   klass-&gt;add_element = GST_DEBUG_FUNCPTR (gst_bin_add_func);
 476   klass-&gt;remove_element = GST_DEBUG_FUNCPTR (gst_bin_remove_func);
 477   klass-&gt;handle_message = GST_DEBUG_FUNCPTR (gst_bin_handle_message_func);
 478 
 479   klass-&gt;deep_element_added = gst_bin_deep_element_added_func;
 480   klass-&gt;deep_element_removed = gst_bin_deep_element_removed_func;
 481 
 482   klass-&gt;do_latency = GST_DEBUG_FUNCPTR (gst_bin_do_latency_func);
<a name="4" id="anc4"></a><span class="line-modified"> 483   }</span>
 484 
 485 static void
 486 gst_bin_init (GstBin * bin)
 487 {
 488   GstBus *bus;
 489 
 490   bin-&gt;numchildren = 0;
 491   bin-&gt;children = NULL;
 492   bin-&gt;children_cookie = 0;
 493   bin-&gt;messages = NULL;
 494   bin-&gt;provided_clock = NULL;
 495   bin-&gt;clock_dirty = FALSE;
 496 
 497   /* Set up a bus for listening to child elements */
 498   bus = g_object_new (GST_TYPE_BUS, &quot;enable-async&quot;, FALSE, NULL);
 499   gst_object_ref_sink (bus);
 500   bin-&gt;child_bus = bus;
 501   GST_DEBUG_OBJECT (bin, &quot;using bus %&quot; GST_PTR_FORMAT &quot; to listen to children&quot;,
 502       bus);
 503   gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bin_bus_handler, bin,
 504       NULL);
 505 
<a name="5" id="anc5"></a><span class="line-modified"> 506   bin-&gt;priv = GST_BIN_GET_PRIVATE (bin);</span>
 507   bin-&gt;priv-&gt;asynchandling = DEFAULT_ASYNC_HANDLING;
 508   bin-&gt;priv-&gt;structure_cookie = 0;
 509   bin-&gt;priv-&gt;message_forward = DEFAULT_MESSAGE_FORWARD;
 510 }
 511 
 512 static void
 513 gst_bin_dispose (GObject * object)
 514 {
 515   GstBin *bin = GST_BIN_CAST (object);
 516   GstBus **child_bus_p = &amp;bin-&gt;child_bus;
 517   GstClock **provided_clock_p = &amp;bin-&gt;provided_clock;
 518   GstElement **clock_provider_p = &amp;bin-&gt;clock_provider;
 519 
 520   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p dispose&quot;, object);
 521 
 522   GST_OBJECT_LOCK (object);
 523   gst_object_replace ((GstObject **) child_bus_p, NULL);
 524   gst_object_replace ((GstObject **) provided_clock_p, NULL);
 525   gst_object_replace ((GstObject **) clock_provider_p, NULL);
 526   bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
 527   GST_OBJECT_UNLOCK (object);
 528 
 529   while (bin-&gt;children) {
 530     gst_bin_remove (bin, GST_ELEMENT_CAST (bin-&gt;children-&gt;data));
 531   }
 532   if (G_UNLIKELY (bin-&gt;children != NULL)) {
 533     g_critical (&quot;could not remove elements from bin &#39;%s&#39;&quot;,
 534         GST_STR_NULL (GST_OBJECT_NAME (object)));
 535   }
 536 
 537   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 538 }
 539 
 540 /**
 541  * gst_bin_new:
 542  * @name: (allow-none): the name of the new bin
 543  *
 544  * Creates a new bin with the given name.
 545  *
 546  * Returns: (transfer floating): a new #GstBin
 547  */
 548 GstElement *
 549 gst_bin_new (const gchar * name)
 550 {
 551   return gst_element_factory_make (&quot;bin&quot;, name);
 552 }
 553 
 554 static void
 555 gst_bin_set_property (GObject * object, guint prop_id,
 556     const GValue * value, GParamSpec * pspec)
 557 {
 558   GstBin *gstbin;
 559 
 560   gstbin = GST_BIN_CAST (object);
 561 
 562   switch (prop_id) {
 563     case PROP_ASYNC_HANDLING:
 564       GST_OBJECT_LOCK (gstbin);
 565       gstbin-&gt;priv-&gt;asynchandling = g_value_get_boolean (value);
 566       GST_OBJECT_UNLOCK (gstbin);
 567       break;
 568     case PROP_MESSAGE_FORWARD:
 569       GST_OBJECT_LOCK (gstbin);
 570       gstbin-&gt;priv-&gt;message_forward = g_value_get_boolean (value);
 571       GST_OBJECT_UNLOCK (gstbin);
 572       break;
 573     default:
 574       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 575       break;
 576   }
 577 }
 578 
 579 static void
 580 gst_bin_get_property (GObject * object, guint prop_id,
 581     GValue * value, GParamSpec * pspec)
 582 {
 583   GstBin *gstbin;
 584 
 585   gstbin = GST_BIN_CAST (object);
 586 
 587   switch (prop_id) {
 588     case PROP_ASYNC_HANDLING:
 589       GST_OBJECT_LOCK (gstbin);
 590       g_value_set_boolean (value, gstbin-&gt;priv-&gt;asynchandling);
 591       GST_OBJECT_UNLOCK (gstbin);
 592       break;
 593     case PROP_MESSAGE_FORWARD:
 594       GST_OBJECT_LOCK (gstbin);
 595       g_value_set_boolean (value, gstbin-&gt;priv-&gt;message_forward);
 596       GST_OBJECT_UNLOCK (gstbin);
 597       break;
 598     default:
 599       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 600       break;
 601   }
 602 }
 603 
 604 #if 0
 605 /* return the cached index */
 606 static GstIndex *
 607 gst_bin_get_index_func (GstElement * element)
 608 {
 609   GstBin *bin;
 610   GstIndex *result;
 611 
 612   bin = GST_BIN_CAST (element);
 613 
 614   GST_OBJECT_LOCK (bin);
 615   if ((result = bin-&gt;priv-&gt;index))
 616     gst_object_ref (result);
 617   GST_OBJECT_UNLOCK (bin);
 618 
 619   return result;
 620 }
 621 
 622 /* set the index on all elements in this bin
 623  *
 624  * MT safe
 625  */
 626 static void
 627 gst_bin_set_index_func (GstElement * element, GstIndex * index)
 628 {
 629   GstBin *bin;
 630   gboolean done;
 631   GstIterator *it;
 632   GstIndex *old;
 633   GValue data = { 0, };
 634 
 635   bin = GST_BIN_CAST (element);
 636 
 637   GST_OBJECT_LOCK (bin);
 638   old = bin-&gt;priv-&gt;index;
 639   if (G_UNLIKELY (old == index))
 640     goto was_set;
 641   if (index)
 642     gst_object_ref (index);
 643   bin-&gt;priv-&gt;index = index;
 644   GST_OBJECT_UNLOCK (bin);
 645 
 646   if (old)
 647     gst_object_unref (old);
 648 
 649   it = gst_bin_iterate_elements (bin);
 650 
 651   /* set the index on all elements in the bin */
 652   done = FALSE;
 653   while (!done) {
 654     switch (gst_iterator_next (it, &amp;data)) {
 655       case GST_ITERATOR_OK:
 656       {
 657         GstElement *child = g_value_get_object (&amp;data);
 658 
 659         GST_DEBUG_OBJECT (bin, &quot;setting index on &#39;%s&#39;&quot;,
 660             GST_ELEMENT_NAME (child));
 661         gst_element_set_index (child, index);
 662 
 663         g_value_reset (&amp;data);
 664         break;
 665       }
 666       case GST_ITERATOR_RESYNC:
 667         GST_DEBUG_OBJECT (bin, &quot;iterator doing resync&quot;);
 668         gst_iterator_resync (it);
 669         break;
 670       default:
 671       case GST_ITERATOR_DONE:
 672         GST_DEBUG_OBJECT (bin, &quot;iterator done&quot;);
 673         done = TRUE;
 674         break;
 675     }
 676   }
 677   g_value_unset (&amp;data);
 678   gst_iterator_free (it);
 679   return;
 680 
 681 was_set:
 682   {
 683     GST_DEBUG_OBJECT (bin, &quot;index was already set&quot;);
 684     GST_OBJECT_UNLOCK (bin);
 685     return;
 686   }
 687 }
 688 #endif
 689 
 690 /* set the clock on all elements in this bin
 691  *
 692  * MT safe
 693  */
 694 static gboolean
 695 gst_bin_set_clock_func (GstElement * element, GstClock * clock)
 696 {
 697   GstBin *bin;
 698   gboolean done;
 699   GstIterator *it;
 700   gboolean res = TRUE;
 701   GValue data = { 0, };
 702 
 703   bin = GST_BIN_CAST (element);
 704 
 705   it = gst_bin_iterate_elements (bin);
 706 
 707   done = FALSE;
 708   while (!done) {
 709     switch (gst_iterator_next (it, &amp;data)) {
 710       case GST_ITERATOR_OK:
 711       {
 712         GstElement *child = g_value_get_object (&amp;data);
 713 
 714         res &amp;= gst_element_set_clock (child, clock);
 715 
 716         g_value_reset (&amp;data);
 717         break;
 718       }
 719       case GST_ITERATOR_RESYNC:
 720         GST_DEBUG_OBJECT (bin, &quot;iterator doing resync&quot;);
 721         gst_iterator_resync (it);
 722         res = TRUE;
 723         break;
 724       default:
 725       case GST_ITERATOR_DONE:
 726         GST_DEBUG_OBJECT (bin, &quot;iterator done&quot;);
 727         done = TRUE;
 728         break;
 729     }
 730   }
 731   g_value_unset (&amp;data);
 732   gst_iterator_free (it);
 733 
 734   if (res)
 735     res = GST_ELEMENT_CLASS (parent_class)-&gt;set_clock (element, clock);
 736 
 737   return res;
 738 }
 739 
 740 /* get the clock for this bin by asking all of the children in this bin
 741  *
 742  * The ref of the returned clock in increased so unref after usage.
 743  *
 744  * We loop the elements in state order and pick the last clock we can
 745  * get. This makes sure we get a clock from the source.
 746  *
 747  * MT safe
 748  */
 749 static GstClock *
 750 gst_bin_provide_clock_func (GstElement * element)
 751 {
 752   GstClock *result = NULL;
 753   GstElement *provider = NULL;
 754   GstBin *bin;
 755   GstIterator *it;
 756   gboolean done;
 757   GValue val = { 0, };
 758   GstClock **provided_clock_p;
 759   GstElement **clock_provider_p;
 760 
 761   bin = GST_BIN_CAST (element);
 762 
 763   GST_OBJECT_LOCK (bin);
 764   if (!bin-&gt;clock_dirty)
 765     goto not_dirty;
 766 
 767   GST_DEBUG_OBJECT (bin, &quot;finding new clock&quot;);
 768 
 769   it = gst_bin_sort_iterator_new (bin);
 770   GST_OBJECT_UNLOCK (bin);
 771 
 772   done = FALSE;
 773   while (!done) {
 774     switch (gst_iterator_next (it, &amp;val)) {
 775       case GST_ITERATOR_OK:
 776       {
 777         GstElement *child = g_value_get_object (&amp;val);
 778         GstClock *clock;
 779 
 780         clock = gst_element_provide_clock (child);
 781         if (clock) {
 782           GST_DEBUG_OBJECT (bin, &quot;found candidate clock %p by element %s&quot;,
 783               clock, GST_ELEMENT_NAME (child));
 784           if (result) {
 785             gst_object_unref (result);
 786             gst_object_unref (provider);
 787           }
 788           result = clock;
 789           provider = gst_object_ref (child);
 790         }
 791 
 792         g_value_reset (&amp;val);
 793         break;
 794       }
 795       case GST_ITERATOR_RESYNC:
 796         gst_iterator_resync (it);
 797         break;
 798       default:
 799       case GST_ITERATOR_DONE:
 800         done = TRUE;
 801         break;
 802     }
 803   }
 804   g_value_unset (&amp;val);
 805   gst_iterator_free (it);
 806 
 807   GST_OBJECT_LOCK (bin);
 808   if (!bin-&gt;clock_dirty) {
 809     if (provider)
 810       gst_object_unref (provider);
 811     if (result)
 812       gst_object_unref (result);
 813     result = NULL;
 814 
 815     goto not_dirty;
 816   }
 817 
 818   provided_clock_p = &amp;bin-&gt;provided_clock;
 819   clock_provider_p = &amp;bin-&gt;clock_provider;
 820   gst_object_replace ((GstObject **) provided_clock_p, (GstObject *) result);
 821   gst_object_replace ((GstObject **) clock_provider_p, (GstObject *) provider);
 822   bin-&gt;clock_dirty = FALSE;
 823   GST_DEBUG_OBJECT (bin,
 824       &quot;provided new clock %&quot; GST_PTR_FORMAT &quot; by provider %&quot; GST_PTR_FORMAT,
 825       result, provider);
 826   /* Provider is not being returned to caller, just the result */
 827   if (provider)
 828     gst_object_unref (provider);
 829   GST_OBJECT_UNLOCK (bin);
 830 
 831   return result;
 832 
 833 not_dirty:
 834   {
 835     if ((result = bin-&gt;provided_clock))
 836       gst_object_ref (result);
 837     GST_DEBUG_OBJECT (bin, &quot;returning old clock %p&quot;, result);
 838     GST_OBJECT_UNLOCK (bin);
 839 
 840     return result;
 841   }
 842 }
 843 
 844 /*
 845  * functions for manipulating cached messages
 846  */
 847 typedef struct
 848 {
 849   GstObject *src;
 850   GstMessageType types;
 851 } MessageFind;
 852 
 853 /* check if a message is of given src and type */
 854 static gint
 855 message_check (GstMessage * message, MessageFind * target)
 856 {
 857   gboolean eq = TRUE;
 858 
 859   if (target-&gt;src)
 860     eq &amp;= GST_MESSAGE_SRC (message) == target-&gt;src;
 861   if (target-&gt;types)
 862     eq &amp;= (GST_MESSAGE_TYPE (message) &amp; target-&gt;types) != 0;
 863   GST_LOG (&quot;looking at message %p: %d&quot;, message, eq);
 864 
 865   return (eq ? 0 : 1);
 866 }
 867 
 868 static GList *
 869 find_message (GstBin * bin, GstObject * src, GstMessageType types)
 870 {
 871   GList *result;
 872   MessageFind find;
 873 
 874   find.src = src;
 875   find.types = types;
 876 
 877   result = g_list_find_custom (bin-&gt;messages, &amp;find,
 878       (GCompareFunc) message_check);
 879 
 880   if (result) {
 881     GST_DEBUG_OBJECT (bin, &quot;we found a message %p from %s matching types %08x&quot;,
 882         result-&gt;data, GST_OBJECT_NAME (GST_MESSAGE_CAST (result-&gt;data)-&gt;src),
 883         types);
 884   } else {
 885     GST_DEBUG_OBJECT (bin, &quot;no message found matching types %08x&quot;, types);
 886 #ifndef GST_DISABLE_GST_DEBUG
 887     {
 888       guint i;
 889 
 890       for (i = 0; i &lt; 32; i++)
 891         if (types &amp; (1U &lt;&lt; i))
 892           GST_DEBUG_OBJECT (bin, &quot;  %s&quot;, gst_message_type_get_name (1U &lt;&lt; i));
 893     }
 894 #endif
 895   }
 896 
 897   return result;
 898 }
 899 
 900 /* with LOCK, returns TRUE if message had a valid SRC, takes ownership of
 901  * the message.
 902  *
 903  * A message that is cached and has the same SRC and type is replaced
 904  * by the given message.
 905  */
 906 static gboolean
 907 bin_replace_message (GstBin * bin, GstMessage * message, GstMessageType types)
 908 {
 909   GList *previous;
 910   GstObject *src;
 911   gboolean res = TRUE;
 912 
 913   if ((src = GST_MESSAGE_SRC (message))) {
 914     /* first find the previous message posted by this element */
 915     if ((previous = find_message (bin, src, types))) {
 916       GstMessage *previous_msg;
 917 
 918       /* if we found a previous message, replace it */
 919       previous_msg = previous-&gt;data;
 920       previous-&gt;data = message;
 921 
 922       GST_DEBUG_OBJECT (bin, &quot;replace old message %s from %s with %s message&quot;,
 923           GST_MESSAGE_TYPE_NAME (previous_msg), GST_ELEMENT_NAME (src),
 924           GST_MESSAGE_TYPE_NAME (message));
 925 
 926       gst_message_unref (previous_msg);
 927     } else {
 928       /* keep new message */
 929       bin-&gt;messages = g_list_prepend (bin-&gt;messages, message);
 930 
 931       GST_DEBUG_OBJECT (bin, &quot;got new message %p, %s from %s&quot;,
 932           message, GST_MESSAGE_TYPE_NAME (message), GST_ELEMENT_NAME (src));
 933     }
 934   } else {
 935     GST_DEBUG_OBJECT (bin, &quot;got message %s from (NULL), not processing&quot;,
 936         GST_MESSAGE_TYPE_NAME (message));
 937     res = FALSE;
 938     gst_message_unref (message);
 939   }
 940   return res;
 941 }
 942 
 943 /* with LOCK. Remove all messages of given types */
 944 static void
 945 bin_remove_messages (GstBin * bin, GstObject * src, GstMessageType types)
 946 {
 947   MessageFind find;
 948   GList *walk, *next;
 949 
 950   find.src = src;
 951   find.types = types;
 952 
 953   for (walk = bin-&gt;messages; walk; walk = next) {
 954     GstMessage *message = (GstMessage *) walk-&gt;data;
 955 
 956     next = g_list_next (walk);
 957 
 958     if (message_check (message, &amp;find) == 0) {
 959       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (message),
 960           &quot;deleting message %p of type %s (types 0x%08x)&quot;, message,
 961           GST_MESSAGE_TYPE_NAME (message), types);
 962       bin-&gt;messages = g_list_delete_link (bin-&gt;messages, walk);
 963       gst_message_unref (message);
 964     } else {
 965       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (message),
 966           &quot;not deleting message %p of type 0x%08x&quot;, message,
 967           GST_MESSAGE_TYPE (message));
 968     }
 969   }
 970 }
 971 
 972 
 973 /* Check if the bin is EOS. We do this by scanning all sinks and
 974  * checking if they posted an EOS message.
 975  *
 976  * call with bin LOCK */
 977 static gboolean
 978 is_eos (GstBin * bin, guint32 * seqnum)
 979 {
 980   gboolean result;
 981   gint n_eos = 0;
 982   GList *walk, *msgs;
 983 
 984   result = TRUE;
 985   for (walk = bin-&gt;children; walk; walk = g_list_next (walk)) {
 986     GstElement *element;
 987 
 988     element = GST_ELEMENT_CAST (walk-&gt;data);
 989     if (bin_element_is_sink (element, bin) == 0) {
 990       /* check if element posted EOS */
 991       if ((msgs =
 992               find_message (bin, GST_OBJECT_CAST (element), GST_MESSAGE_EOS))) {
 993         GST_DEBUG (&quot;sink &#39;%s&#39; posted EOS&quot;, GST_ELEMENT_NAME (element));
 994         *seqnum = gst_message_get_seqnum (GST_MESSAGE_CAST (msgs-&gt;data));
 995         n_eos++;
 996       } else {
 997         GST_DEBUG (&quot;sink &#39;%s&#39; did not post EOS yet&quot;,
 998             GST_ELEMENT_NAME (element));
 999         result = FALSE;
1000         break;
1001       }
1002     }
1003   }
1004   /* FIXME: Some tests (e.g. elements/capsfilter) use
1005    * pipelines with a dangling sinkpad but no sink element.
1006    * These tests assume that no EOS message is ever
1007    * posted on the bus so let&#39;s keep that behaviour.
1008    * In valid pipelines this doesn&#39;t make a difference.
1009    */
1010   return result &amp;&amp; n_eos &gt; 0;
1011 }
1012 
1013 
1014 /* Check if the bin is STREAM_START. We do this by scanning all sinks and
1015  * checking if they posted an STREAM_START message.
1016  *
1017  * call with bin LOCK */
1018 static gboolean
1019 is_stream_start (GstBin * bin, guint32 * seqnum, gboolean * have_group_id,
1020     guint * group_id)
1021 {
1022   gboolean result;
1023   GList *walk, *msgs;
1024   guint tmp_group_id;
1025   gboolean first = TRUE, same_group_id = TRUE;
1026 
1027   *have_group_id = TRUE;
1028   *group_id = 0;
1029   result = TRUE;
1030   for (walk = bin-&gt;children; walk; walk = g_list_next (walk)) {
1031     GstElement *element;
1032 
1033     element = GST_ELEMENT_CAST (walk-&gt;data);
1034     if (bin_element_is_sink (element, bin) == 0) {
1035       /* check if element posted STREAM_START */
1036       if ((msgs =
1037               find_message (bin, GST_OBJECT_CAST (element),
1038                   GST_MESSAGE_STREAM_START))) {
1039         GST_DEBUG (&quot;sink &#39;%s&#39; posted STREAM_START&quot;, GST_ELEMENT_NAME (element));
1040         *seqnum = gst_message_get_seqnum (GST_MESSAGE_CAST (msgs-&gt;data));
1041         if (gst_message_parse_group_id (GST_MESSAGE_CAST (msgs-&gt;data),
1042                 &amp;tmp_group_id)) {
1043           if (first) {
1044             first = FALSE;
1045             *group_id = tmp_group_id;
1046           } else {
1047             if (tmp_group_id != *group_id)
1048               same_group_id = FALSE;
1049           }
1050         } else {
1051           *have_group_id = FALSE;
1052         }
1053       } else {
1054         GST_DEBUG (&quot;sink &#39;%s&#39; did not post STREAM_START yet&quot;,
1055             GST_ELEMENT_NAME (element));
1056         result = FALSE;
1057         break;
1058       }
1059     }
1060   }
1061 
1062   /* If all have a group_id we only consider this stream started
1063    * if all group ids were the same and all sinks posted a stream-start
1064    * message */
1065   if (*have_group_id)
1066     return same_group_id &amp;&amp; result;
1067   /* otherwise consider this stream started after all sinks
1068    * have reported stream-start for backward compatibility.
1069    * FIXME 2.0: This should go away! */
1070   return result;
1071 }
1072 
1073 static void
1074 unlink_pads (const GValue * item, gpointer user_data)
1075 {
1076   GstPad *pad;
1077   GstPad *peer;
1078 
1079   pad = g_value_get_object (item);
1080 
1081   if ((peer = gst_pad_get_peer (pad))) {
1082     if (gst_pad_get_direction (pad) == GST_PAD_SRC)
1083       gst_pad_unlink (pad, peer);
1084     else
1085       gst_pad_unlink (peer, pad);
1086     gst_object_unref (peer);
1087   }
1088 }
1089 
1090 static void
1091 bin_deep_iterator_foreach (const GValue * item, gpointer user_data)
1092 {
1093   GQueue *queue = user_data;
1094 
1095   g_queue_push_tail (queue, g_value_dup_object (item));
1096 }
1097 
1098 static void
1099 gst_bin_do_deep_add_remove (GstBin * bin, gint sig_id, const gchar * sig_name,
1100     GstElement * element)
1101 {
1102   g_signal_emit (bin, sig_id, 0, bin, element);
1103 
1104   /* When removing a bin, emit deep-element-* for everything in the bin too */
1105   if (GST_IS_BIN (element)) {
1106     GstIterator *it;
1107     GstIteratorResult ires;
1108     GQueue elements = G_QUEUE_INIT;
1109 
1110     GST_LOG_OBJECT (bin, &quot;Recursing into bin %&quot; GST_PTR_FORMAT &quot; for %s&quot;,
1111         element, sig_name);
1112     it = gst_bin_iterate_recurse (GST_BIN_CAST (element));
1113     do {
1114       ires = gst_iterator_foreach (it, bin_deep_iterator_foreach, &amp;elements);
1115       if (ires != GST_ITERATOR_DONE) {
1116         g_queue_foreach (&amp;elements, (GFunc) g_object_unref, NULL);
1117         g_queue_clear (&amp;elements);
1118       }
1119       if (ires == GST_ITERATOR_RESYNC)
1120         gst_iterator_resync (it);
1121     } while (ires == GST_ITERATOR_RESYNC);
1122     if (ires != GST_ITERATOR_ERROR) {
1123       GstElement *e;
1124 
1125       while ((e = g_queue_pop_head (&amp;elements))) {
1126         GstObject *parent = gst_object_get_parent (GST_OBJECT_CAST (e));
1127 
<a name="6" id="anc6"></a><span class="line-modified">1128         GST_LOG_OBJECT (bin, &quot;calling %s for element %&quot; GST_PTR_FORMAT</span>
<span class="line-modified">1129             &quot; in bin %&quot; GST_PTR_FORMAT, sig_name, e, parent);</span>
<span class="line-modified">1130         g_signal_emit (bin, sig_id, 0, parent, e);</span>
<span class="line-modified">1131         gst_object_unref (parent);</span>
<span class="line-modified">1132         g_object_unref (e);</span>




1133       }
1134     }
1135     gst_iterator_free (it);
1136   }
1137 }
1138 
1139 /* vmethod that adds an element to a bin
1140  *
1141  * MT safe
1142  */
1143 static gboolean
1144 gst_bin_add_func (GstBin * bin, GstElement * element)
1145 {
1146   gchar *elem_name;
1147   GstIterator *it;
1148   gboolean is_sink, is_source, provides_clock, requires_clock;
1149   GstMessage *clock_message = NULL, *async_message = NULL;
1150   GstStateChangeReturn ret;
1151   GList *l, *elem_contexts, *need_context_messages;
1152 
1153   GST_DEBUG_OBJECT (bin, &quot;element :%s&quot;, GST_ELEMENT_NAME (element));
1154 
1155   /* we obviously can&#39;t add ourself to ourself */
1156   if (G_UNLIKELY (element == GST_ELEMENT_CAST (bin)))
1157     goto adding_itself;
1158 
1159   /* get the element name to make sure it is unique in this bin. */
1160   GST_OBJECT_LOCK (element);
1161   elem_name = g_strdup (GST_ELEMENT_NAME (element));
1162   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
1163   is_source = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE);
1164   provides_clock =
1165       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1166   requires_clock =
1167       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1168   GST_OBJECT_UNLOCK (element);
1169 
1170   GST_OBJECT_LOCK (bin);
1171 
1172   /* then check to see if the element&#39;s name is already taken in the bin,
1173    * we can safely take the lock here. This check is probably bogus because
1174    * you can safely change the element name after this check and before setting
1175    * the object parent. The window is very small though... */
1176   if (G_UNLIKELY (!gst_object_check_uniqueness (bin-&gt;children, elem_name)))
1177     goto duplicate_name;
1178 
1179   /* set the element&#39;s parent and add the element to the bin&#39;s list of children */
1180   if (G_UNLIKELY (!gst_object_set_parent (GST_OBJECT_CAST (element),
1181               GST_OBJECT_CAST (bin))))
1182     goto had_parent;
1183 
1184   /* if we add a sink we become a sink */
1185   if (is_sink &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SINK)) {
1186     GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;element \&quot;%s\&quot; was sink&quot;,
1187         elem_name);
1188     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_SINK);
1189   }
1190   if (is_source &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SOURCE)) {
1191     GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;element \&quot;%s\&quot; was source&quot;,
1192         elem_name);
1193     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_SOURCE);
1194   }
1195   if (provides_clock
1196       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_PROVIDE_CLOCK)) {
1197     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; can provide a clock&quot;, elem_name);
1198     clock_message =
1199         gst_message_new_clock_provide (GST_OBJECT_CAST (element), NULL, TRUE);
1200     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1201   }
1202   if (requires_clock
1203       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_REQUIRE_CLOCK)) {
1204     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; requires a clock&quot;, elem_name);
1205     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1206   }
1207 
1208   bin-&gt;children = g_list_prepend (bin-&gt;children, element);
1209   bin-&gt;numchildren++;
1210   bin-&gt;children_cookie++;
1211   if (!GST_BIN_IS_NO_RESYNC (bin))
1212     bin-&gt;priv-&gt;structure_cookie++;
1213 
1214   /* distribute the bus */
1215   gst_element_set_bus (element, bin-&gt;child_bus);
1216 
1217   /* propagate the current base_time, start_time and clock */
1218   gst_element_set_base_time (element, GST_ELEMENT_CAST (bin)-&gt;base_time);
1219   gst_element_set_start_time (element, GST_ELEMENT_START_TIME (bin));
1220   /* it&#39;s possible that the element did not accept the clock but
1221    * that is not important right now. When the pipeline goes to PLAYING,
1222    * a new clock will be selected */
1223   gst_element_set_clock (element, GST_ELEMENT_CLOCK (bin));
1224 
1225   /* get the element&#39;s list of contexts before propagating our own */
1226   elem_contexts = gst_element_get_contexts (element);
1227   for (l = GST_ELEMENT_CAST (bin)-&gt;contexts; l; l = l-&gt;next)
1228     gst_element_set_context (element, l-&gt;data);
1229 
1230   need_context_messages = NULL;
1231   for (l = elem_contexts; l; l = l-&gt;next) {
1232     GstContext *replacement, *context = l-&gt;data;
1233     const gchar *context_type;
1234 
1235     context_type = gst_context_get_context_type (context);
1236 
1237     /* we already set this context above? */
1238     replacement =
1239         gst_element_get_context_unlocked (GST_ELEMENT (bin), context_type);
1240     if (replacement) {
1241       gst_context_unref (replacement);
1242     } else {
1243       GstMessage *msg;
1244       GstStructure *s;
1245 
1246       /* ask our parent for the context */
1247       msg = gst_message_new_need_context (GST_OBJECT_CAST (bin), context_type);
1248       s = (GstStructure *) gst_message_get_structure (msg);
1249       gst_structure_set (s, &quot;bin.old.context&quot;, GST_TYPE_CONTEXT, context, NULL);
1250 
1251       need_context_messages = g_list_prepend (need_context_messages, msg);
1252     }
1253   }
1254 
1255 #if 0
1256   /* set the cached index on the children */
1257   if (bin-&gt;priv-&gt;index)
1258     gst_element_set_index (element, bin-&gt;priv-&gt;index);
1259 #endif
1260 
1261   ret = GST_STATE_RETURN (bin);
1262   /* no need to update the state if we are in error */
1263   if (ret == GST_STATE_CHANGE_FAILURE)
1264     goto no_state_recalc;
1265 
1266   /* update the bin state, the new element could have been an ASYNC or
1267    * NO_PREROLL element */
1268   ret = GST_STATE_RETURN (element);
1269   GST_DEBUG_OBJECT (bin, &quot;added %s element&quot;,
1270       gst_element_state_change_return_get_name (ret));
1271 
1272   switch (ret) {
1273     case GST_STATE_CHANGE_ASYNC:
1274     {
1275       /* create message to track this aync element when it posts an async-done
1276        * message */
1277       async_message = gst_message_new_async_start (GST_OBJECT_CAST (element));
1278       break;
1279     }
1280     case GST_STATE_CHANGE_NO_PREROLL:
1281       /* ignore all async elements we might have and commit our state */
1282       bin_handle_async_done (bin, ret, FALSE, GST_CLOCK_TIME_NONE);
1283       break;
1284     case GST_STATE_CHANGE_FAILURE:
1285       break;
1286     default:
1287       break;
1288   }
1289 
1290 no_state_recalc:
1291   GST_OBJECT_UNLOCK (bin);
1292 
1293   for (l = need_context_messages; l; l = l-&gt;next) {
1294     GstMessage *msg = l-&gt;data;
1295     GstStructure *s;
1296     const gchar *context_type;
1297     GstContext *replacement, *context;
1298 
1299     gst_message_parse_context_type (msg, &amp;context_type);
1300 
1301     GST_LOG_OBJECT (bin, &quot;asking parent for context type: %s &quot;
1302         &quot;from %&quot; GST_PTR_FORMAT, context_type, element);
1303 
1304     s = (GstStructure *) gst_message_get_structure (msg);
1305     gst_structure_get (s, &quot;bin.old.context&quot;, GST_TYPE_CONTEXT, &amp;context, NULL);
1306     gst_structure_remove_field (s, &quot;bin.old.context&quot;);
1307     /* Keep the msg around while we still need access to the context_type */
1308     gst_element_post_message (GST_ELEMENT_CAST (bin), gst_message_ref (msg));
1309 
1310     /* lock to avoid losing a potential write */
1311     GST_OBJECT_LOCK (bin);
1312     replacement =
1313         gst_element_get_context_unlocked (GST_ELEMENT_CAST (bin), context_type);
1314     gst_message_unref (msg);
1315 
1316     if (replacement) {
1317       /* we got the context set from GstElement::set_context */
1318       gst_context_unref (replacement);
1319       GST_OBJECT_UNLOCK (bin);
1320     } else {
1321       /* Propagate the element&#39;s context upwards */
1322       GST_LOG_OBJECT (bin, &quot;propagating existing context type: %s %p &quot;
1323           &quot;from %&quot; GST_PTR_FORMAT, context_type, context, element);
1324 
1325       gst_bin_update_context_unlocked (bin, context);
1326 
1327       msg =
1328           gst_message_new_have_context (GST_OBJECT_CAST (bin),
1329           gst_context_ref (context));
1330       GST_OBJECT_UNLOCK (bin);
1331       gst_element_post_message (GST_ELEMENT_CAST (bin), msg);
1332     }
1333     gst_context_unref (context);
1334   }
1335   g_list_free_full (elem_contexts, (GDestroyNotify) gst_context_unref);
1336   g_list_free (need_context_messages);
1337 
1338   /* post the messages on the bus of the element so that the bin can handle
1339    * them */
1340   if (clock_message)
1341     gst_element_post_message (element, clock_message);
1342 
1343   if (async_message)
1344     gst_element_post_message (element, async_message);
1345 
1346   /* unlink all linked pads */
1347   it = gst_element_iterate_pads (element);
1348   while (gst_iterator_foreach (it, (GstIteratorForeachFunction) unlink_pads,
1349           NULL) == GST_ITERATOR_RESYNC)
1350     gst_iterator_resync (it);
1351   gst_iterator_free (it);
1352 
1353   GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;added element \&quot;%s\&quot;&quot;,
1354       elem_name);
1355 
1356   g_signal_emit (bin, gst_bin_signals[ELEMENT_ADDED], 0, element);
1357   gst_child_proxy_child_added ((GstChildProxy *) bin, (GObject *) element,
1358       elem_name);
1359 
1360   gst_bin_do_deep_add_remove (bin, gst_bin_signals[DEEP_ELEMENT_ADDED],
1361       &quot;deep-element-added&quot;, element);
1362 
1363   g_free (elem_name);
1364 
1365   return TRUE;
1366 
1367   /* ERROR handling here */
1368 adding_itself:
1369   {
1370     GST_OBJECT_LOCK (bin);
1371     g_warning (&quot;Cannot add bin &#39;%s&#39; to itself&quot;, GST_ELEMENT_NAME (bin));
1372     GST_OBJECT_UNLOCK (bin);
1373     gst_object_ref_sink (element);
1374     gst_object_unref (element);
1375     return FALSE;
1376   }
1377 duplicate_name:
1378   {
1379     g_warning (&quot;Name &#39;%s&#39; is not unique in bin &#39;%s&#39;, not adding&quot;,
1380         elem_name, GST_ELEMENT_NAME (bin));
1381     GST_OBJECT_UNLOCK (bin);
1382     g_free (elem_name);
1383     gst_object_ref_sink (element);
1384     gst_object_unref (element);
1385     return FALSE;
1386   }
1387 had_parent:
1388   {
1389     g_warning (&quot;Element &#39;%s&#39; already has parent&quot;, elem_name);
1390     GST_OBJECT_UNLOCK (bin);
1391     g_free (elem_name);
1392     return FALSE;
1393   }
1394 }
1395 
1396 /**
1397  * gst_bin_set_suppressed_flags:
1398  * @bin: a #GstBin
1399  * @flags: the #GstElementFlags to suppress
1400  *
1401  * Suppress the given flags on the bin. #GstElementFlags of a
1402  * child element are propagated when it is added to the bin.
1403  * When suppressed flags are set, those specified flags will
1404  * not be propagated to the bin.
1405  *
1406  * MT safe.
1407  *
1408  * Since: 1.10
1409  */
1410 void
1411 gst_bin_set_suppressed_flags (GstBin * bin, GstElementFlags flags)
1412 {
1413   g_return_if_fail (GST_IS_BIN (bin));
1414 
1415   GST_OBJECT_LOCK (bin);
1416   bin-&gt;priv-&gt;suppressed_flags = bin-&gt;priv-&gt;suppressed_flags | flags;
1417   GST_OBJECT_UNLOCK (bin);
1418 
1419   GST_DEBUG_OBJECT (bin, &quot;Set suppressed flags(0x%x) to bin &#39;%s&#39;&quot;, flags,
1420       GST_ELEMENT_NAME (bin));
1421 }
1422 
1423 /**
1424  * gst_bin_get_suppressed_flags:
1425  * @bin: a #GstBin
1426  *
1427  * Return the suppressed flags of the bin.
1428  *
1429  * MT safe.
1430  *
1431  * Returns: the bin&#39;s suppressed #GstElementFlags.
1432  *
1433  * Since: 1.10
1434  */
1435 GstElementFlags
1436 gst_bin_get_suppressed_flags (GstBin * bin)
1437 {
1438   GstElementFlags res;
1439 
1440   g_return_val_if_fail (GST_IS_BIN (bin), 0);
1441 
1442   GST_OBJECT_LOCK (bin);
1443   res = bin-&gt;priv-&gt;suppressed_flags;
1444   GST_OBJECT_UNLOCK (bin);
1445 
1446   return res;
1447 }
1448 
1449 /* signal vfunc, will be called when a new element was added */
1450 static void
1451 gst_bin_deep_element_added_func (GstBin * bin, GstBin * sub_bin,
1452     GstElement * child)
1453 {
1454   GstBin *parent_bin;
1455 
1456   parent_bin = (GstBin *) gst_object_get_parent (GST_OBJECT_CAST (bin));
1457   if (parent_bin == NULL) {
1458     GST_LOG_OBJECT (bin, &quot;no parent, reached top-level&quot;);
1459     return;
1460   }
1461 
1462   GST_LOG_OBJECT (parent_bin, &quot;emitting deep-element-added for element &quot;
1463       &quot;%&quot; GST_PTR_FORMAT &quot; which has just been added to %&quot; GST_PTR_FORMAT,
1464       child, sub_bin);
1465 
1466   g_signal_emit (parent_bin, gst_bin_signals[DEEP_ELEMENT_ADDED], 0, sub_bin,
1467       child);
1468 
1469   gst_object_unref (parent_bin);
1470 }
1471 
1472 /* signal vfunc, will be called when an element was removed */
1473 static void
1474 gst_bin_deep_element_removed_func (GstBin * bin, GstBin * sub_bin,
1475     GstElement * child)
1476 {
1477   GstBin *parent_bin;
1478 
1479   parent_bin = (GstBin *) gst_object_get_parent (GST_OBJECT_CAST (bin));
1480   if (parent_bin == NULL) {
1481     GST_LOG_OBJECT (bin, &quot;no parent, reached top-level&quot;);
1482     return;
1483   }
1484 
1485   GST_LOG_OBJECT (parent_bin, &quot;emitting deep-element-removed for element &quot;
1486       &quot;%&quot; GST_PTR_FORMAT &quot; which has just been removed from %&quot; GST_PTR_FORMAT,
1487       sub_bin, child);
1488 
1489   g_signal_emit (parent_bin, gst_bin_signals[DEEP_ELEMENT_REMOVED], 0, sub_bin,
1490       child);
1491 
1492   gst_object_unref (parent_bin);
1493 }
1494 
1495 /**
1496  * gst_bin_add:
1497  * @bin: a #GstBin
1498  * @element: (transfer floating): the #GstElement to add
1499  *
1500  * Adds the given element to the bin.  Sets the element&#39;s parent, and thus
1501  * takes ownership of the element. An element can only be added to one bin.
1502  *
1503  * If the element&#39;s pads are linked to other pads, the pads will be unlinked
1504  * before the element is added to the bin.
1505  *
1506  * &gt; When you add an element to an already-running pipeline, you will have to
1507  * &gt; take care to set the state of the newly-added element to the desired
1508  * &gt; state (usually PLAYING or PAUSED, same you set the pipeline to originally)
1509  * &gt; with gst_element_set_state(), or use gst_element_sync_state_with_parent().
1510  * &gt; The bin or pipeline will not take care of this for you.
1511  *
1512  * MT safe.
1513  *
1514  * Returns: %TRUE if the element could be added, %FALSE if
1515  * the bin does not want to accept the element.
1516  */
1517 gboolean
1518 gst_bin_add (GstBin * bin, GstElement * element)
1519 {
1520   GstBinClass *bclass;
1521   gboolean result;
1522 
1523   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
1524   g_return_val_if_fail (GST_IS_ELEMENT (element), FALSE);
1525   g_return_val_if_fail (GST_ELEMENT_CAST (bin) != element, FALSE);
1526 
1527   bclass = GST_BIN_GET_CLASS (bin);
1528 
1529   if (G_UNLIKELY (bclass-&gt;add_element == NULL))
1530     goto no_function;
1531 
1532   GST_CAT_DEBUG (GST_CAT_PARENTAGE, &quot;adding element %s to bin %s&quot;,
1533       GST_STR_NULL (GST_ELEMENT_NAME (element)),
1534       GST_STR_NULL (GST_ELEMENT_NAME (bin)));
1535 
1536   GST_TRACER_BIN_ADD_PRE (bin, element);
1537   result = bclass-&gt;add_element (bin, element);
1538   GST_TRACER_BIN_ADD_POST (bin, element, result);
1539 
1540   return result;
1541 
1542   /* ERROR handling */
1543 no_function:
1544   {
1545     g_warning (&quot;adding elements to bin &#39;%s&#39; is not supported&quot;,
1546         GST_ELEMENT_NAME (bin));
1547     gst_object_ref_sink (element);
1548     gst_object_unref (element);
1549     return FALSE;
1550   }
1551 }
1552 
1553 /* remove an element from the bin
1554  *
1555  * MT safe
1556  */
1557 static gboolean
1558 gst_bin_remove_func (GstBin * bin, GstElement * element)
1559 {
1560   gchar *elem_name;
1561   GstIterator *it;
1562   gboolean is_sink, is_source, provides_clock, requires_clock;
1563   gboolean othersink, othersource, otherprovider, otherrequirer, found;
1564   GstMessage *clock_message = NULL;
1565   GstClock **provided_clock_p;
1566   GstElement **clock_provider_p;
1567   GList *walk, *next;
1568   gboolean other_async, this_async, have_no_preroll;
1569   GstStateChangeReturn ret;
1570 
1571   GST_DEBUG_OBJECT (bin, &quot;element :%s&quot;, GST_ELEMENT_NAME (element));
1572 
1573   /* we obviously can&#39;t remove ourself from ourself */
1574   if (G_UNLIKELY (element == GST_ELEMENT_CAST (bin)))
1575     goto removing_itself;
1576 
1577   GST_OBJECT_LOCK (bin);
1578 
1579   GST_OBJECT_LOCK (element);
1580   elem_name = g_strdup (GST_ELEMENT_NAME (element));
1581 
1582   if (GST_OBJECT_PARENT (element) != GST_OBJECT_CAST (bin))
1583     goto not_in_bin;
1584 
1585   /* remove the parent ref */
1586   GST_OBJECT_PARENT (element) = NULL;
1587 
1588   /* grab element name so we can print it */
1589   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
1590   is_source = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE);
1591   provides_clock =
1592       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1593   requires_clock =
1594       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1595   GST_OBJECT_UNLOCK (element);
1596 
1597   found = FALSE;
1598   othersink = FALSE;
1599   othersource = FALSE;
1600   otherprovider = FALSE;
1601   otherrequirer = FALSE;
1602   have_no_preroll = FALSE;
1603   /* iterate the elements, we collect which ones are async and no_preroll. We
1604    * also remove the element when we find it. */
1605   for (walk = bin-&gt;children; walk; walk = next) {
1606     GstElement *child = GST_ELEMENT_CAST (walk-&gt;data);
1607 
1608     next = g_list_next (walk);
1609 
1610     if (child == element) {
1611       found = TRUE;
1612       /* remove the element */
1613       bin-&gt;children = g_list_delete_link (bin-&gt;children, walk);
1614     } else {
1615       gboolean child_sink, child_source, child_provider, child_requirer;
1616 
1617       GST_OBJECT_LOCK (child);
1618       child_sink = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SINK);
1619       child_source = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SOURCE);
1620       child_provider =
1621           GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1622       child_requirer =
1623           GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1624       /* when we remove a sink, check if there are other sinks. */
1625       if (is_sink &amp;&amp; !othersink &amp;&amp; child_sink)
1626         othersink = TRUE;
1627       if (is_source &amp;&amp; !othersource &amp;&amp; child_source)
1628         othersource = TRUE;
1629       if (provides_clock &amp;&amp; !otherprovider &amp;&amp; child_provider)
1630         otherprovider = TRUE;
1631       if (requires_clock &amp;&amp; !otherrequirer &amp;&amp; child_requirer)
1632         otherrequirer = TRUE;
1633       /* check if we have NO_PREROLL children */
1634       if (GST_STATE_RETURN (child) == GST_STATE_CHANGE_NO_PREROLL)
1635         have_no_preroll = TRUE;
1636       GST_OBJECT_UNLOCK (child);
1637     }
1638   }
1639 
1640   /* the element must have been in the bin&#39;s list of children */
1641   if (G_UNLIKELY (!found))
1642     goto not_in_bin;
1643 
1644   /* we now removed the element from the list of elements, increment the cookie
1645    * so that others can detect a change in the children list. */
1646   bin-&gt;numchildren--;
1647   bin-&gt;children_cookie++;
1648   if (!GST_BIN_IS_NO_RESYNC (bin))
1649     bin-&gt;priv-&gt;structure_cookie++;
1650 
1651   if (is_sink &amp;&amp; !othersink
1652       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SINK)) {
1653     /* we&#39;re not a sink anymore */
1654     GST_DEBUG_OBJECT (bin, &quot;we removed the last sink&quot;);
1655     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_SINK);
1656   }
1657   if (is_source &amp;&amp; !othersource
1658       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SOURCE)) {
1659     /* we&#39;re not a source anymore */
1660     GST_DEBUG_OBJECT (bin, &quot;we removed the last source&quot;);
1661     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_SOURCE);
1662   }
1663   if (provides_clock &amp;&amp; !otherprovider
1664       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_PROVIDE_CLOCK)) {
1665     /* we&#39;re not a clock provider anymore */
1666     GST_DEBUG_OBJECT (bin, &quot;we removed the last clock provider&quot;);
1667     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1668   }
1669   if (requires_clock &amp;&amp; !otherrequirer
1670       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_REQUIRE_CLOCK)) {
1671     /* we&#39;re not a clock requirer anymore */
1672     GST_DEBUG_OBJECT (bin, &quot;we removed the last clock requirer&quot;);
1673     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1674   }
1675 
1676   /* if the clock provider for this element is removed, we lost
1677    * the clock as well, we need to inform the parent of this
1678    * so that it can select a new clock */
1679   if (bin-&gt;clock_provider == element) {
1680     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; provided the clock&quot;, elem_name);
1681     bin-&gt;clock_dirty = TRUE;
1682     clock_message =
1683         gst_message_new_clock_lost (GST_OBJECT_CAST (bin), bin-&gt;provided_clock);
1684     provided_clock_p = &amp;bin-&gt;provided_clock;
1685     clock_provider_p = &amp;bin-&gt;clock_provider;
1686     gst_object_replace ((GstObject **) provided_clock_p, NULL);
1687     gst_object_replace ((GstObject **) clock_provider_p, NULL);
1688   }
1689 
1690   /* remove messages for the element, if there was a pending ASYNC_START
1691    * message we must see if removing the element caused the bin to lose its
1692    * async state. */
1693   this_async = FALSE;
1694   other_async = FALSE;
1695   for (walk = bin-&gt;messages; walk; walk = next) {
1696     GstMessage *message = (GstMessage *) walk-&gt;data;
1697     GstElement *src = GST_ELEMENT_CAST (GST_MESSAGE_SRC (message));
1698     gboolean remove;
1699 
1700     next = g_list_next (walk);
1701     remove = FALSE;
1702 
1703     switch (GST_MESSAGE_TYPE (message)) {
1704       case GST_MESSAGE_ASYNC_START:
1705         if (src == element)
1706           this_async = TRUE;
1707         else
1708           other_async = TRUE;
1709 
1710         GST_DEBUG_OBJECT (src, &quot;looking at message %p&quot;, message);
1711         break;
1712       case GST_MESSAGE_STRUCTURE_CHANGE:
1713       {
1714         GstElement *owner;
1715 
1716         GST_DEBUG_OBJECT (src, &quot;looking at structure change message %p&quot;,
1717             message);
1718         /* it&#39;s unlikely that this message is still in the list of messages
1719          * because this would mean that a link/unlink is busy in another thread
1720          * while we remove the element. We still have to remove the message
1721          * because we might not receive the done message anymore when the element
1722          * is removed from the bin. */
1723         gst_message_parse_structure_change (message, NULL, &amp;owner, NULL);
1724         if (owner == element)
1725           remove = TRUE;
1726         break;
1727       }
1728       default:
1729         break;
1730     }
1731     if (src == element)
1732       remove = TRUE;
1733 
1734     if (remove) {
1735       /* delete all message types */
1736       GST_DEBUG_OBJECT (src, &quot;deleting message %p of element \&quot;%s\&quot;&quot;,
1737           message, elem_name);
1738       bin-&gt;messages = g_list_delete_link (bin-&gt;messages, walk);
1739       gst_message_unref (message);
1740     }
1741   }
1742 
1743   /* get last return */
1744   ret = GST_STATE_RETURN (bin);
1745 
1746   /* no need to update the state if we are in error */
1747   if (ret == GST_STATE_CHANGE_FAILURE)
1748     goto no_state_recalc;
1749 
1750   if (!other_async &amp;&amp; this_async) {
1751     /* all other elements were not async and we removed the async one,
1752      * handle the async-done case because we are not async anymore now. */
1753     GST_DEBUG_OBJECT (bin,
1754         &quot;we removed the last async element, have no_preroll %d&quot;,
1755         have_no_preroll);
1756 
1757     /* the current state return of the bin depends on if there are no_preroll
1758      * elements in the pipeline or not */
1759     if (have_no_preroll)
1760       ret = GST_STATE_CHANGE_NO_PREROLL;
1761     else
1762       ret = GST_STATE_CHANGE_SUCCESS;
1763 
1764     bin_handle_async_done (bin, ret, FALSE, GST_CLOCK_TIME_NONE);
1765   } else {
1766     GST_DEBUG_OBJECT (bin,
1767         &quot;recalc state preroll: %d, other async: %d, this async %d&quot;,
1768         have_no_preroll, other_async, this_async);
1769 
1770     if (have_no_preroll) {
1771       ret = GST_STATE_CHANGE_NO_PREROLL;
1772     } else if (other_async) {
1773       /* there are other async elements and we were not doing an async state
1774        * change, change our pending state and go async */
1775       if (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING) {
1776         GST_STATE_NEXT (bin) = GST_STATE (bin);
1777         GST_STATE_PENDING (bin) = GST_STATE (bin);
1778       }
1779       ret = GST_STATE_CHANGE_ASYNC;
1780     }
1781     GST_STATE_RETURN (bin) = ret;
1782   }
1783 no_state_recalc:
1784   /* clear bus */
1785   gst_element_set_bus (element, NULL);
1786   /* Clear the clock we provided to the element */
1787   gst_element_set_clock (element, NULL);
1788   GST_OBJECT_UNLOCK (bin);
1789 
1790   if (clock_message)
1791     gst_element_post_message (GST_ELEMENT_CAST (bin), clock_message);
1792 
1793   /* unlink all linked pads */
1794   it = gst_element_iterate_pads (element);
1795   while (gst_iterator_foreach (it, (GstIteratorForeachFunction) unlink_pads,
1796           NULL) == GST_ITERATOR_RESYNC)
1797     gst_iterator_resync (it);
1798   gst_iterator_free (it);
1799 
1800   GST_CAT_INFO_OBJECT (GST_CAT_PARENTAGE, bin, &quot;removed child \&quot;%s\&quot;&quot;,
1801       elem_name);
1802 
1803   g_signal_emit (bin, gst_bin_signals[ELEMENT_REMOVED], 0, element);
1804   gst_child_proxy_child_removed ((GstChildProxy *) bin, (GObject *) element,
1805       elem_name);
1806 
1807   gst_bin_do_deep_add_remove (bin, gst_bin_signals[DEEP_ELEMENT_REMOVED],
1808       &quot;deep-element-removed&quot;, element);
1809 
1810   g_free (elem_name);
1811   /* element is really out of our control now */
1812   gst_object_unref (element);
1813 
1814   return TRUE;
1815 
1816   /* ERROR handling */
1817 removing_itself:
1818   {
1819     GST_OBJECT_LOCK (bin);
1820     g_warning (&quot;Cannot remove bin &#39;%s&#39; from itself&quot;, GST_ELEMENT_NAME (bin));
1821     GST_OBJECT_UNLOCK (bin);
1822     return FALSE;
1823   }
1824 not_in_bin:
1825   {
1826     g_warning (&quot;Element &#39;%s&#39; is not in bin &#39;%s&#39;&quot;, elem_name,
1827         GST_ELEMENT_NAME (bin));
1828     GST_OBJECT_UNLOCK (element);
1829     GST_OBJECT_UNLOCK (bin);
1830     g_free (elem_name);
1831     return FALSE;
1832   }
1833 }
1834 
1835 /**
1836  * gst_bin_remove:
1837  * @bin: a #GstBin
1838  * @element: (transfer none): the #GstElement to remove
1839  *
1840  * Removes the element from the bin, unparenting it as well.
1841  * Unparenting the element means that the element will be dereferenced,
1842  * so if the bin holds the only reference to the element, the element
1843  * will be freed in the process of removing it from the bin.  If you
1844  * want the element to still exist after removing, you need to call
1845  * gst_object_ref() before removing it from the bin.
1846  *
1847  * If the element&#39;s pads are linked to other pads, the pads will be unlinked
1848  * before the element is removed from the bin.
1849  *
1850  * MT safe.
1851  *
1852  * Returns: %TRUE if the element could be removed, %FALSE if
1853  * the bin does not want to remove the element.
1854  */
1855 gboolean
1856 gst_bin_remove (GstBin * bin, GstElement * element)
1857 {
1858   GstBinClass *bclass;
1859   gboolean result;
1860 
1861   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
1862   g_return_val_if_fail (GST_IS_ELEMENT (element), FALSE);
1863   g_return_val_if_fail (GST_ELEMENT_CAST (bin) != element, FALSE);
1864 
1865   bclass = GST_BIN_GET_CLASS (bin);
1866 
1867   if (G_UNLIKELY (bclass-&gt;remove_element == NULL))
1868     goto no_function;
1869 
1870   GST_CAT_DEBUG (GST_CAT_PARENTAGE, &quot;removing element %s from bin %s&quot;,
1871       GST_ELEMENT_NAME (element), GST_ELEMENT_NAME (bin));
1872 
1873   GST_TRACER_BIN_REMOVE_PRE (bin, element);
1874   result = bclass-&gt;remove_element (bin, element);
1875   GST_TRACER_BIN_REMOVE_POST (bin, result);
1876 
1877   return result;
1878 
1879   /* ERROR handling */
1880 no_function:
1881   {
1882     g_warning (&quot;removing elements from bin &#39;%s&#39; is not supported&quot;,
1883         GST_ELEMENT_NAME (bin));
1884     return FALSE;
1885   }
1886 }
1887 
1888 /**
1889  * gst_bin_iterate_elements:
1890  * @bin: a #GstBin
1891  *
1892  * Gets an iterator for the elements in this bin.
1893  *
1894  * MT safe.  Caller owns returned value.
1895  *
1896  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
1897  * or %NULL
1898  */
1899 GstIterator *
1900 gst_bin_iterate_elements (GstBin * bin)
1901 {
1902   GstIterator *result;
1903 
1904   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
1905 
1906   GST_OBJECT_LOCK (bin);
1907   result = gst_iterator_new_list (GST_TYPE_ELEMENT,
1908       GST_OBJECT_GET_LOCK (bin),
1909       &amp;bin-&gt;children_cookie, &amp;bin-&gt;children, (GObject *) bin, NULL);
1910   GST_OBJECT_UNLOCK (bin);
1911 
1912   return result;
1913 }
1914 
1915 static GstIteratorItem
1916 iterate_child_recurse (GstIterator * it, const GValue * item)
1917 {
1918   GstElement *child = g_value_get_object (item);
1919 
1920   if (GST_IS_BIN (child)) {
1921     GstIterator *other = gst_bin_iterate_recurse (GST_BIN_CAST (child));
1922 
1923     gst_iterator_push (it, other);
1924   }
1925   return GST_ITERATOR_ITEM_PASS;
1926 }
1927 
1928 /**
1929  * gst_bin_iterate_recurse:
1930  * @bin: a #GstBin
1931  *
1932  * Gets an iterator for the elements in this bin.
1933  * This iterator recurses into GstBin children.
1934  *
1935  * MT safe.  Caller owns returned value.
1936  *
1937  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
1938  * or %NULL
1939  */
1940 GstIterator *
1941 gst_bin_iterate_recurse (GstBin * bin)
1942 {
1943   GstIterator *result;
1944 
1945   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
1946 
1947   GST_OBJECT_LOCK (bin);
1948   result = gst_iterator_new_list (GST_TYPE_ELEMENT,
1949       GST_OBJECT_GET_LOCK (bin),
1950       &amp;bin-&gt;children_cookie,
1951       &amp;bin-&gt;children,
1952       (GObject *) bin, (GstIteratorItemFunction) iterate_child_recurse);
1953   GST_OBJECT_UNLOCK (bin);
1954 
1955   return result;
1956 }
1957 
1958 /* returns 0 when TRUE because this is a GCompareFunc */
1959 /* MT safe */
1960 static gint
1961 bin_element_is_sink (GstElement * child, GstBin * bin)
1962 {
1963   gboolean is_sink;
1964 
1965 #ifdef GSTREAMER_LITE
1966   if (child == NULL)
1967       return 1;
1968 #endif // GSTREAMER_LITE
1969 
1970   /* we lock the child here for the remainder of the function to
1971    * get its name and flag safely. */
1972   GST_OBJECT_LOCK (child);
1973   is_sink = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SINK);
1974 
1975   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
1976       &quot;child %s %s sink&quot;, GST_OBJECT_NAME (child), is_sink ? &quot;is&quot; : &quot;is not&quot;);
1977 
1978   GST_OBJECT_UNLOCK (child);
1979   return is_sink ? 0 : 1;
1980 }
1981 
1982 static gint
1983 sink_iterator_filter (const GValue * vchild, GValue * vbin)
1984 {
1985   GstBin *bin = g_value_get_object (vbin);
1986   GstElement *child = g_value_get_object (vchild);
1987 
1988   return (bin_element_is_sink (child, bin));
1989 }
1990 
1991 /**
1992  * gst_bin_iterate_sinks:
1993  * @bin: a #GstBin
1994  *
1995  * Gets an iterator for all elements in the bin that have the
1996  * #GST_ELEMENT_FLAG_SINK flag set.
1997  *
1998  * MT safe.  Caller owns returned value.
1999  *
2000  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2001  * or %NULL
2002  */
2003 GstIterator *
2004 gst_bin_iterate_sinks (GstBin * bin)
2005 {
2006   GstIterator *children;
2007   GstIterator *result;
2008   GValue vbin = { 0, };
2009 
2010   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2011 
2012   g_value_init (&amp;vbin, GST_TYPE_BIN);
2013   g_value_set_object (&amp;vbin, bin);
2014 
2015   children = gst_bin_iterate_elements (bin);
2016   result = gst_iterator_filter (children,
2017       (GCompareFunc) sink_iterator_filter, &amp;vbin);
2018 
2019   g_value_unset (&amp;vbin);
2020 
2021   return result;
2022 }
2023 
2024 /* returns 0 when TRUE because this is a GCompareFunc */
2025 /* MT safe */
2026 static gint
2027 bin_element_is_src (GstElement * child, GstBin * bin)
2028 {
2029   gboolean is_src;
2030 
2031   /* we lock the child here for the remainder of the function to
2032    * get its name and other info safely. */
2033   GST_OBJECT_LOCK (child);
2034   is_src = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SOURCE);
2035 
2036   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
2037       &quot;child %s %s src&quot;, GST_OBJECT_NAME (child), is_src ? &quot;is&quot; : &quot;is not&quot;);
2038 
2039   GST_OBJECT_UNLOCK (child);
2040   return is_src ? 0 : 1;
2041 }
2042 
2043 static gint
2044 src_iterator_filter (const GValue * vchild, GValue * vbin)
2045 {
2046   GstBin *bin = g_value_get_object (vbin);
2047   GstElement *child = g_value_get_object (vchild);
2048 
2049   return (bin_element_is_src (child, bin));
2050 }
2051 
2052 /**
2053  * gst_bin_iterate_sources:
2054  * @bin: a #GstBin
2055  *
2056  * Gets an iterator for all elements in the bin that have the
2057  * #GST_ELEMENT_FLAG_SOURCE flag set.
2058  *
2059  * MT safe.  Caller owns returned value.
2060  *
2061  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2062  * or %NULL
2063  */
2064 GstIterator *
2065 gst_bin_iterate_sources (GstBin * bin)
2066 {
2067   GstIterator *children;
2068   GstIterator *result;
2069   GValue vbin = { 0, };
2070 
2071   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2072 
2073   g_value_init (&amp;vbin, GST_TYPE_BIN);
2074   g_value_set_object (&amp;vbin, bin);
2075 
2076   children = gst_bin_iterate_elements (bin);
2077   result = gst_iterator_filter (children,
2078       (GCompareFunc) src_iterator_filter, &amp;vbin);
2079 
2080   g_value_unset (&amp;vbin);
2081 
2082   return result;
2083 }
2084 
2085 /*
2086  * MT safe
2087  */
2088 static GstStateChangeReturn
2089 gst_bin_get_state_func (GstElement * element, GstState * state,
2090     GstState * pending, GstClockTime timeout)
2091 {
2092   GstStateChangeReturn ret;
2093 
2094   GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, &quot;getting state&quot;);
2095 
2096   ret =
2097       GST_ELEMENT_CLASS (parent_class)-&gt;get_state (element, state, pending,
2098       timeout);
2099 
2100   return ret;
2101 }
2102 
2103 /***********************************************
2104  * Topologically sorted iterator
2105  * see http://en.wikipedia.org/wiki/Topological_sorting
2106  *
2107  * For each element in the graph, an entry is kept in a HashTable
2108  * with its number of srcpad connections (degree).
2109  * We then change state of all elements without dependencies
2110  * (degree 0) and decrement the degree of all elements connected
2111  * on the sinkpads. When an element reaches degree 0, its state is
2112  * changed next.
2113  * When all elements are handled the algorithm stops.
2114  */
2115 typedef struct _GstBinSortIterator
2116 {
2117   GstIterator it;
2118   GQueue queue;                 /* elements queued for state change */
2119   GstBin *bin;                  /* bin we iterate */
2120   gint mode;                    /* adding or removing dependency */
2121   GstElement *best;             /* next element with least dependencies */
2122   gint best_deg;                /* best degree */
2123   GHashTable *hash;             /* hashtable with element dependencies */
2124   gboolean dirty;               /* we detected structure change */
2125 } GstBinSortIterator;
2126 
2127 static void
2128 copy_to_queue (gpointer data, gpointer user_data)
2129 {
2130   GstElement *element = data;
2131   GQueue *queue = user_data;
2132 
2133   gst_object_ref (element);
2134   g_queue_push_tail (queue, element);
2135 }
2136 
2137 static void
2138 gst_bin_sort_iterator_copy (const GstBinSortIterator * it,
2139     GstBinSortIterator * copy)
2140 {
2141   GHashTableIter iter;
2142   gpointer key, value;
2143 
2144   g_queue_init (&amp;copy-&gt;queue);
2145   g_queue_foreach ((GQueue *) &amp; it-&gt;queue, copy_to_queue, &amp;copy-&gt;queue);
2146 
2147   copy-&gt;bin = gst_object_ref (it-&gt;bin);
2148   if (it-&gt;best)
2149     copy-&gt;best = gst_object_ref (it-&gt;best);
2150 
2151   copy-&gt;hash = g_hash_table_new (NULL, NULL);
2152   g_hash_table_iter_init (&amp;iter, it-&gt;hash);
2153   while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
2154     g_hash_table_insert (copy-&gt;hash, key, value);
2155 }
2156 
2157 /* we add and subtract 1 to make sure we don&#39;t confuse NULL and 0 */
2158 #define HASH_SET_DEGREE(bit, elem, deg) \
2159     g_hash_table_replace (bit-&gt;hash, elem, GINT_TO_POINTER(deg+1))
2160 #define HASH_GET_DEGREE(bit, elem) \
2161     (GPOINTER_TO_INT(g_hash_table_lookup (bit-&gt;hash, elem))-1)
2162 
2163 /* add element to queue of next elements in the iterator.
2164  * We push at the tail to give higher priority elements a
2165  * chance first */
2166 static void
2167 add_to_queue (GstBinSortIterator * bit, GstElement * element)
2168 {
2169   GST_DEBUG_OBJECT (bit-&gt;bin, &quot;adding &#39;%s&#39; to queue&quot;,
2170       GST_ELEMENT_NAME (element));
2171   gst_object_ref (element);
2172   g_queue_push_tail (&amp;bit-&gt;queue, element);
2173   HASH_SET_DEGREE (bit, element, -1);
2174 }
2175 
2176 static void
2177 remove_from_queue (GstBinSortIterator * bit, GstElement * element)
2178 {
2179   GList *find;
2180 
2181   if ((find = g_queue_find (&amp;bit-&gt;queue, element))) {
2182     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;removing &#39;%s&#39; from queue&quot;,
2183         GST_ELEMENT_NAME (element));
2184 
2185     g_queue_delete_link (&amp;bit-&gt;queue, find);
2186     gst_object_unref (element);
2187   } else {
2188     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;unable to remove &#39;%s&#39; from queue&quot;,
2189         GST_ELEMENT_NAME (element));
2190   }
2191 }
2192 
2193 /* clear the queue, unref all objects as we took a ref when
2194  * we added them to the queue */
2195 static void
2196 clear_queue (GQueue * queue)
2197 {
2198   gpointer p;
2199 
2200   while ((p = g_queue_pop_head (queue)))
2201     gst_object_unref (p);
2202 }
2203 
2204 /* set all degrees to 0. Elements marked as a sink are
2205  * added to the queue immediately. Since we only look at the SINK flag of the
2206  * element, it is possible that we add non-sinks to the queue. These will be
2207  * removed from the queue again when we can prove that it provides data for some
2208  * other element. */
2209 static void
2210 reset_degree (GstElement * element, GstBinSortIterator * bit)
2211 {
2212   gboolean is_sink;
2213 
2214   /* sinks are added right away */
2215   GST_OBJECT_LOCK (element);
2216   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
2217   GST_OBJECT_UNLOCK (element);
2218 
2219   if (is_sink) {
2220     add_to_queue (bit, element);
2221   } else {
2222     /* others are marked with 0 and handled when sinks are done */
2223     HASH_SET_DEGREE (bit, element, 0);
2224   }
2225 }
2226 
2227 /* adjust the degree of all elements connected to the given
2228  * element. If a degree of an element drops to 0, it is
2229  * added to the queue of elements to schedule next.
2230  *
2231  * We have to make sure not to cross the bin boundary this element
2232  * belongs to.
2233  */
2234 static void
2235 update_degree (GstElement * element, GstBinSortIterator * bit)
2236 {
2237   gboolean linked = FALSE;
2238 
2239   GST_OBJECT_LOCK (element);
2240   /* don&#39;t touch degree if element has no sinkpads */
2241   if (element-&gt;numsinkpads != 0) {
2242     /* loop over all sinkpads, decrement degree for all connected
2243      * elements in this bin */
2244     GList *pads;
2245 
2246     for (pads = element-&gt;sinkpads; pads; pads = g_list_next (pads)) {
2247       GstPad *pad, *peer;
2248 
2249       pad = GST_PAD_CAST (pads-&gt;data);
2250 
2251       /* we&#39;re iterating over the sinkpads, check if it&#39;s busy in a link/unlink */
2252       if (G_UNLIKELY (find_message (bit-&gt;bin, GST_OBJECT_CAST (pad),
2253                   GST_MESSAGE_STRUCTURE_CHANGE))) {
2254         /* mark the iterator as dirty because we won&#39;t be updating the degree
2255          * of the peer parent now. This would result in the &#39;loop detected&#39;
2256          * later on because the peer parent element could become the best next
2257          * element with a degree &gt; 0. We will simply continue our state
2258          * changes and we&#39;ll eventually resync when the unlink completed and
2259          * the iterator cookie is updated. */
2260         bit-&gt;dirty = TRUE;
2261         continue;
2262       }
2263 
2264       if ((peer = gst_pad_get_peer (pad))) {
2265         GstElement *peer_element;
2266 
2267         if ((peer_element = gst_pad_get_parent_element (peer))) {
2268           GST_OBJECT_LOCK (peer_element);
2269           /* check that we don&#39;t go outside of this bin */
2270           if (GST_OBJECT_CAST (peer_element)-&gt;parent ==
2271               GST_OBJECT_CAST (bit-&gt;bin)) {
2272             gint old_deg, new_deg;
2273 
2274             old_deg = HASH_GET_DEGREE (bit, peer_element);
2275 
2276             /* check to see if we added an element as sink that was not really a
2277              * sink because it was connected to some other element. */
2278             if (old_deg == -1) {
2279               remove_from_queue (bit, peer_element);
2280               old_deg = 0;
2281             }
2282             new_deg = old_deg + bit-&gt;mode;
2283 
2284             GST_DEBUG_OBJECT (bit-&gt;bin,
2285                 &quot;change element %s, degree %d-&gt;%d, linked to %s&quot;,
2286                 GST_ELEMENT_NAME (peer_element), old_deg, new_deg,
2287                 GST_ELEMENT_NAME (element));
2288 
2289             /* update degree, it is possible that an element was in 0 and
2290              * reaches -1 here. This would mean that the element had no sinkpads
2291              * but became linked while the state change was happening. We will
2292              * resync on this with the structure change message. */
2293             if (new_deg == 0) {
2294               /* degree hit 0, add to queue */
2295               add_to_queue (bit, peer_element);
2296             } else {
2297               HASH_SET_DEGREE (bit, peer_element, new_deg);
2298             }
2299             linked = TRUE;
2300           }
2301           GST_OBJECT_UNLOCK (peer_element);
2302           gst_object_unref (peer_element);
2303         }
2304         gst_object_unref (peer);
2305       }
2306     }
2307   }
2308   if (!linked) {
2309     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;element %s not linked on any sinkpads&quot;,
2310         GST_ELEMENT_NAME (element));
2311   }
2312   GST_OBJECT_UNLOCK (element);
2313 }
2314 
2315 /* find the next best element not handled yet. This is the one
2316  * with the lowest non-negative degree */
2317 static void
2318 find_element (GstElement * element, GstBinSortIterator * bit)
2319 {
2320   gint degree;
2321 
2322   /* element is already handled */
2323   if ((degree = HASH_GET_DEGREE (bit, element)) &lt; 0)
2324     return;
2325 
2326   /* first element or element with smaller degree */
2327   if (bit-&gt;best == NULL || bit-&gt;best_deg &gt; degree) {
2328     bit-&gt;best = element;
2329     bit-&gt;best_deg = degree;
2330   } else if (bit-&gt;best_deg == degree
2331       &amp;&amp; GST_OBJECT_FLAG_IS_SET (bit-&gt;best, GST_ELEMENT_FLAG_SOURCE)
2332       &amp;&amp; !GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE)) {
2333     /* If two elements have the same degree, we want to ensure we
2334      * return non-source elements first. */
2335     bit-&gt;best = element;
2336   }
2337 }
2338 
2339 /* get next element in iterator. */
2340 static GstIteratorResult
2341 gst_bin_sort_iterator_next (GstBinSortIterator * bit, GValue * result)
2342 {
2343   GstElement *best;
2344   GstBin *bin = bit-&gt;bin;
2345 
2346   /* empty queue, we have to find a next best element */
2347   if (g_queue_is_empty (&amp;bit-&gt;queue)) {
2348     bit-&gt;best = NULL;
2349     bit-&gt;best_deg = G_MAXINT;
2350     g_list_foreach (bin-&gt;children, (GFunc) find_element, bit);
2351     if ((best = bit-&gt;best)) {
2352       /* when we detected an unlink, don&#39;t warn because our degrees might be
2353        * screwed up. We will resync later */
2354       if (bit-&gt;best_deg != 0 &amp;&amp; !bit-&gt;dirty) {
2355         /* we don&#39;t fail on this one yet */
2356         GST_WARNING_OBJECT (bin, &quot;loop dected in graph&quot;);
2357         g_warning (&quot;loop detected in the graph of bin &#39;%s&#39;!!&quot;,
2358             GST_ELEMENT_NAME (bin));
2359       }
2360       /* best unhandled element, schedule as next element */
2361       GST_DEBUG_OBJECT (bin, &quot;queue empty, next best: %s&quot;,
2362           GST_ELEMENT_NAME (best));
2363       HASH_SET_DEGREE (bit, best, -1);
2364       g_value_set_object (result, best);
2365     } else {
2366       GST_DEBUG_OBJECT (bin, &quot;queue empty, elements exhausted&quot;);
2367       /* no more unhandled elements, we are done */
2368       return GST_ITERATOR_DONE;
2369     }
2370   } else {
2371     /* everything added to the queue got reffed */
2372     best = g_queue_pop_head (&amp;bit-&gt;queue);
2373     g_value_set_object (result, best);
2374     gst_object_unref (best);
2375   }
2376 
2377   GST_DEBUG_OBJECT (bin, &quot;queue head gives %s&quot;, GST_ELEMENT_NAME (best));
2378   /* update degrees of linked elements */
2379   update_degree (best, bit);
2380 
2381   return GST_ITERATOR_OK;
2382 }
2383 
2384 /* clear queues, recalculate the degrees and restart. */
2385 static void
2386 gst_bin_sort_iterator_resync (GstBinSortIterator * bit)
2387 {
2388   GstBin *bin = bit-&gt;bin;
2389 
2390   GST_DEBUG_OBJECT (bin, &quot;resync&quot;);
2391   bit-&gt;dirty = FALSE;
2392   clear_queue (&amp;bit-&gt;queue);
2393   /* reset degrees */
2394   g_list_foreach (bin-&gt;children, (GFunc) reset_degree, bit);
2395   /* calc degrees, incrementing */
2396   bit-&gt;mode = 1;
2397   g_list_foreach (bin-&gt;children, (GFunc) update_degree, bit);
2398   /* for the rest of the function we decrement the degrees */
2399   bit-&gt;mode = -1;
2400 }
2401 
2402 /* clear queues, unref bin and free iterator. */
2403 static void
2404 gst_bin_sort_iterator_free (GstBinSortIterator * bit)
2405 {
2406   GstBin *bin = bit-&gt;bin;
2407 
2408   GST_DEBUG_OBJECT (bin, &quot;free&quot;);
2409   clear_queue (&amp;bit-&gt;queue);
2410   g_hash_table_destroy (bit-&gt;hash);
2411   gst_object_unref (bin);
2412 }
2413 
2414 /* should be called with the bin LOCK held */
2415 static GstIterator *
2416 gst_bin_sort_iterator_new (GstBin * bin)
2417 {
2418   GstBinSortIterator *result;
2419 
2420   /* we don&#39;t need an ItemFunction because we ref the items in the _next
2421    * method already */
2422   result = (GstBinSortIterator *)
2423       gst_iterator_new (sizeof (GstBinSortIterator),
2424       GST_TYPE_ELEMENT,
2425       GST_OBJECT_GET_LOCK (bin),
2426       &amp;bin-&gt;priv-&gt;structure_cookie,
2427       (GstIteratorCopyFunction) gst_bin_sort_iterator_copy,
2428       (GstIteratorNextFunction) gst_bin_sort_iterator_next,
2429       (GstIteratorItemFunction) NULL,
2430       (GstIteratorResyncFunction) gst_bin_sort_iterator_resync,
2431       (GstIteratorFreeFunction) gst_bin_sort_iterator_free);
2432   g_queue_init (&amp;result-&gt;queue);
2433   result-&gt;hash = g_hash_table_new (NULL, NULL);
2434   gst_object_ref (bin);
2435   result-&gt;bin = bin;
2436   gst_bin_sort_iterator_resync (result);
2437 
2438   return (GstIterator *) result;
2439 }
2440 
2441 /**
2442  * gst_bin_iterate_sorted:
2443  * @bin: a #GstBin
2444  *
2445  * Gets an iterator for the elements in this bin in topologically
2446  * sorted order. This means that the elements are returned from
2447  * the most downstream elements (sinks) to the sources.
2448  *
2449  * This function is used internally to perform the state changes
2450  * of the bin elements and for clock selection.
2451  *
2452  * MT safe.  Caller owns returned value.
2453  *
2454  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2455  * or %NULL
2456  */
2457 GstIterator *
2458 gst_bin_iterate_sorted (GstBin * bin)
2459 {
2460   GstIterator *result;
2461 
2462   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2463 
2464   GST_OBJECT_LOCK (bin);
2465   result = gst_bin_sort_iterator_new (bin);
2466   GST_OBJECT_UNLOCK (bin);
2467 
2468   return result;
2469 }
2470 
2471 static GstStateChangeReturn
2472 gst_bin_element_set_state (GstBin * bin, GstElement * element,
2473     GstClockTime base_time, GstClockTime start_time, GstState current,
2474     GstState next)
2475 {
2476   GstStateChangeReturn ret;
2477   GstState child_current, child_pending;
2478   gboolean locked;
2479   GList *found;
2480 
2481   GST_STATE_LOCK (element);
2482 
2483   GST_OBJECT_LOCK (element);
2484   /* set base_time and start time on child */
2485   GST_ELEMENT_START_TIME (element) = start_time;
2486   element-&gt;base_time = base_time;
2487   /* peel off the locked flag */
2488   locked = GST_ELEMENT_IS_LOCKED_STATE (element);
2489   /* Get the previous set_state result to preserve NO_PREROLL and ASYNC */
2490   ret = GST_STATE_RETURN (element);
2491   child_current = GST_STATE (element);
2492   child_pending = GST_STATE_PENDING (element);
2493   GST_OBJECT_UNLOCK (element);
2494 
2495   /* skip locked elements */
2496   if (G_UNLIKELY (locked))
2497     goto locked;
2498 
2499   /* if the element was no preroll, just start changing the state regardless
2500    * if it had async elements (in the case of a bin) because they won&#39;t preroll
2501    * anyway. */
2502   if (G_UNLIKELY (ret == GST_STATE_CHANGE_NO_PREROLL)) {
2503     GST_DEBUG_OBJECT (element, &quot;element is NO_PREROLL, ignore async elements&quot;);
2504     goto no_preroll;
2505   }
2506 
2507   GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2508       &quot;current %s pending %s, desired next %s&quot;,
2509       gst_element_state_get_name (child_current),
2510       gst_element_state_get_name (child_pending),
2511       gst_element_state_get_name (next));
2512 
2513   /* always recurse into bins so that we can set the base time */
2514   if (GST_IS_BIN (element))
2515     goto do_state;
2516 
2517   /* Try not to change the state of elements that are already in the state we&#39;re
2518    * going to */
2519   if (child_current == next &amp;&amp; child_pending == GST_STATE_VOID_PENDING) {
2520     /* child is already at the requested state, return previous return. Note that
2521      * if the child has a pending state to next, we will still call the
2522      * set_state function */
2523     goto unneeded;
2524   } else if (next &gt; current) {
2525     /* upward state change */
2526     if (child_pending == GST_STATE_VOID_PENDING) {
2527       /* .. and the child is not busy doing anything */
2528       if (child_current &gt; next) {
2529         /* .. and is already past the requested state, assume it got there
2530          * without error */
2531         ret = GST_STATE_CHANGE_SUCCESS;
2532         goto unneeded;
2533       }
2534     } else if (child_pending &gt; child_current) {
2535       /* .. and the child is busy going upwards */
2536       if (child_current &gt;= next) {
2537         /* .. and is already past the requested state, assume it got there
2538          * without error */
2539         ret = GST_STATE_CHANGE_SUCCESS;
2540         goto unneeded;
2541       }
2542     } else {
2543       /* .. and the child is busy going downwards */
2544       if (child_current &gt; next) {
2545         /* .. and is already past the requested state, assume it got there
2546          * without error */
2547         ret = GST_STATE_CHANGE_SUCCESS;
2548         goto unneeded;
2549       }
2550     }
2551   } else if (next &lt; current) {
2552     /* downward state change */
2553     if (child_pending == GST_STATE_VOID_PENDING) {
2554       /* .. and the child is not busy doing anything */
2555       if (child_current &lt; next) {
2556         /* .. and is already past the requested state, assume it got there
2557          * without error */
2558         ret = GST_STATE_CHANGE_SUCCESS;
2559         goto unneeded;
2560       }
2561     } else if (child_pending &lt; child_current) {
2562       /* .. and the child is busy going downwards */
2563       if (child_current &lt;= next) {
2564         /* .. and is already past the requested state, assume it got there
2565          * without error */
2566         ret = GST_STATE_CHANGE_SUCCESS;
2567         goto unneeded;
2568       }
2569     } else {
2570       /* .. and the child is busy going upwards */
2571       if (child_current &lt; next) {
2572         /* .. and is already past the requested state, assume it got there
2573          * without error */
2574         ret = GST_STATE_CHANGE_SUCCESS;
2575         goto unneeded;
2576       }
2577     }
2578   }
2579 
2580 do_state:
2581   GST_OBJECT_LOCK (bin);
2582   /* the element was busy with an upwards async state change, we must wait for
<a name="7" id="anc7"></a><span class="line-modified">2583    * an ASYNC_DONE message before we attemp to change the state. */</span>
2584   if ((found =
2585           find_message (bin, GST_OBJECT_CAST (element),
2586               GST_MESSAGE_ASYNC_START))) {
2587 #ifndef GST_DISABLE_GST_DEBUG
2588     GstMessage *message = GST_MESSAGE_CAST (found-&gt;data);
2589 
2590     GST_DEBUG_OBJECT (element, &quot;element message %p, %s async busy&quot;,
2591         message, GST_ELEMENT_NAME (GST_MESSAGE_SRC (message)));
2592 #endif
2593     /* only wait for upward state changes */
2594     if (next &gt; current) {
2595       /* We found an async element check if we can force its state to change or
2596        * if we have to wait for it to preroll. */
2597       goto was_busy;
2598     }
2599   }
2600   GST_OBJECT_UNLOCK (bin);
2601 
2602 no_preroll:
2603   GST_DEBUG_OBJECT (bin,
2604       &quot;setting element %s to %s, base_time %&quot; GST_TIME_FORMAT,
2605       GST_ELEMENT_NAME (element), gst_element_state_get_name (next),
2606       GST_TIME_ARGS (base_time));
2607 
2608   /* change state */
2609   ret = gst_element_set_state (element, next);
2610 
2611   GST_STATE_UNLOCK (element);
2612 
2613   return ret;
2614 
2615 locked:
2616   {
2617     GST_DEBUG_OBJECT (element,
2618         &quot;element is locked, return previous return %s&quot;,
2619         gst_element_state_change_return_get_name (ret));
2620     GST_STATE_UNLOCK (element);
2621     return ret;
2622   }
2623 unneeded:
2624   {
2625     GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2626         &quot;skipping transition from %s to  %s&quot;,
2627         gst_element_state_get_name (child_current),
2628         gst_element_state_get_name (next));
2629     GST_STATE_UNLOCK (element);
2630     return ret;
2631   }
2632 was_busy:
2633   {
2634     GST_DEBUG_OBJECT (element, &quot;element was busy, delaying state change&quot;);
2635     GST_OBJECT_UNLOCK (bin);
2636     GST_STATE_UNLOCK (element);
2637     return GST_STATE_CHANGE_ASYNC;
2638   }
2639 }
2640 
2641 /* gst_iterator_fold functions for pads_activate
2642  * Stop the iterator if activating one pad failed, but only if that pad
2643  * has not been removed from the element. */
2644 static gboolean
2645 activate_pads (const GValue * vpad, GValue * ret, gboolean * active)
2646 {
2647   GstPad *pad = g_value_get_object (vpad);
2648   gboolean cont = TRUE;
2649 
2650   if (!gst_pad_set_active (pad, *active)) {
2651     if (GST_PAD_PARENT (pad) != NULL) {
2652       cont = FALSE;
<a name="8" id="anc8"></a><span class="line-modified">2653     g_value_set_boolean (ret, FALSE);</span>
2654     }
2655   }
2656 
2657   return cont;
2658 }
2659 
2660 /* returns false on error or early cutout of the fold, true if all
2661  * pads in @iter were (de)activated successfully. */
2662 static gboolean
2663 iterator_activate_fold_with_resync (GstIterator * iter, gpointer user_data)
2664 {
2665   GstIteratorResult ires;
2666   GValue ret = { 0 };
2667 
2668   /* no need to unset this later, it&#39;s just a boolean */
2669   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
2670   g_value_set_boolean (&amp;ret, TRUE);
2671 
2672   while (1) {
2673     ires = gst_iterator_fold (iter, (GstIteratorFoldFunction) activate_pads,
2674         &amp;ret, user_data);
2675     switch (ires) {
2676       case GST_ITERATOR_RESYNC:
2677         /* need to reset the result again */
2678         g_value_set_boolean (&amp;ret, TRUE);
2679         gst_iterator_resync (iter);
2680         break;
2681       case GST_ITERATOR_DONE:
2682         /* all pads iterated, return collected value */
2683         goto done;
2684       default:
2685         /* iterator returned _ERROR or premature end with _OK,
2686          * mark an error and exit */
2687         g_value_set_boolean (&amp;ret, FALSE);
2688         goto done;
2689     }
2690   }
2691 done:
2692   /* return collected value */
2693   return g_value_get_boolean (&amp;ret);
2694 }
2695 
2696 /* is called with STATE_LOCK
2697  */
2698 static gboolean
2699 gst_bin_src_pads_activate (GstBin * bin, gboolean active)
2700 {
2701   GstIterator *iter;
2702   gboolean fold_ok;
2703 
2704   GST_DEBUG_OBJECT (bin, &quot;%s pads&quot;, active ? &quot;activate&quot; : &quot;deactivate&quot;);
2705 
2706   iter = gst_element_iterate_src_pads ((GstElement *) bin);
2707   fold_ok = iterator_activate_fold_with_resync (iter, &amp;active);
2708   gst_iterator_free (iter);
2709   if (G_UNLIKELY (!fold_ok))
2710     goto failed;
2711 
2712   GST_DEBUG_OBJECT (bin, &quot;pad %sactivation successful&quot;, active ? &quot;&quot; : &quot;de&quot;);
2713 
2714   return TRUE;
2715 
2716   /* ERRORS */
2717 failed:
2718   {
2719     GST_DEBUG_OBJECT (bin, &quot;pad %sactivation failed&quot;, active ? &quot;&quot; : &quot;de&quot;);
2720     return FALSE;
2721   }
2722 }
2723 
2724 /**
2725  * gst_bin_recalculate_latency:
2726  * @bin: a #GstBin
2727  *
2728  * Query @bin for the current latency using and reconfigures this latency to all the
2729  * elements with a LATENCY event.
2730  *
2731  * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
2732  * is posted on the bus.
2733  *
2734  * This function simply emits the &#39;do-latency&#39; signal so any custom latency
2735  * calculations will be performed.
2736  *
2737  * Returns: %TRUE if the latency could be queried and reconfigured.
2738  */
2739 gboolean
2740 gst_bin_recalculate_latency (GstBin * bin)
2741 {
2742   gboolean res;
2743 
2744   g_signal_emit (bin, gst_bin_signals[DO_LATENCY], 0, &amp;res);
2745   GST_DEBUG_OBJECT (bin, &quot;latency returned %d&quot;, res);
2746 
2747   return res;
2748 }
2749 
2750 static gboolean
2751 gst_bin_do_latency_func (GstBin * bin)
2752 {
2753   GstQuery *query;
2754   GstElement *element;
2755   GstClockTime min_latency, max_latency;
2756   gboolean res;
2757 
2758   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
2759 
2760   element = GST_ELEMENT_CAST (bin);
2761 
2762   GST_DEBUG_OBJECT (element, &quot;querying latency&quot;);
2763 
2764   query = gst_query_new_latency ();
2765   if ((res = gst_element_query (element, query))) {
2766     gboolean live;
2767 
2768     gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
2769 
2770     GST_DEBUG_OBJECT (element,
2771         &quot;got min latency %&quot; GST_TIME_FORMAT &quot;, max latency %&quot;
2772         GST_TIME_FORMAT &quot;, live %d&quot;, GST_TIME_ARGS (min_latency),
2773         GST_TIME_ARGS (max_latency), live);
2774 
2775     if (max_latency &lt; min_latency) {
2776       /* this is an impossible situation, some parts of the pipeline might not
2777        * work correctly. We post a warning for now. */
2778       GST_ELEMENT_WARNING (element, CORE, CLOCK, (NULL),
2779           (&quot;Impossible to configure latency: max %&quot; GST_TIME_FORMAT &quot; &lt; min %&quot;
2780               GST_TIME_FORMAT &quot;. Add queues or other buffering elements.&quot;,
2781               GST_TIME_ARGS (max_latency), GST_TIME_ARGS (min_latency)));
2782     }
2783 
2784     /* configure latency on elements */
2785     res = gst_element_send_event (element, gst_event_new_latency (min_latency));
2786     if (res) {
2787       GST_INFO_OBJECT (element, &quot;configured latency of %&quot; GST_TIME_FORMAT,
2788           GST_TIME_ARGS (min_latency));
2789     } else {
2790       GST_WARNING_OBJECT (element,
2791           &quot;did not really configure latency of %&quot; GST_TIME_FORMAT,
2792           GST_TIME_ARGS (min_latency));
2793     }
2794   } else {
2795     /* this is not a real problem, we just don&#39;t configure any latency. */
2796     GST_WARNING_OBJECT (element, &quot;failed to query latency&quot;);
2797   }
2798   gst_query_unref (query);
2799 
2800   return res;
2801 }
2802 
2803 static gboolean
2804 gst_bin_post_message (GstElement * element, GstMessage * msg)
2805 {
2806   GstElementClass *pklass = (GstElementClass *) parent_class;
2807   gboolean ret;
2808 
2809   ret = pklass-&gt;post_message (element, gst_message_ref (msg));
2810 
2811   if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STATE_CHANGED &amp;&amp;
2812       GST_MESSAGE_SRC (msg) == GST_OBJECT_CAST (element)) {
2813     GstState newstate, pending;
2814 
2815     gst_message_parse_state_changed (msg, NULL, &amp;newstate, &amp;pending);
2816     if (newstate == GST_STATE_PLAYING &amp;&amp; pending == GST_STATE_VOID_PENDING) {
2817       GST_BIN_CAST (element)-&gt;priv-&gt;posted_playing = TRUE;
2818       bin_do_eos (GST_BIN_CAST (element));
2819     } else {
2820       GST_BIN_CAST (element)-&gt;priv-&gt;posted_playing = FALSE;
2821     }
2822   }
2823 
2824   gst_message_unref (msg);
2825 
2826   return ret;
2827 }
2828 
2829 static void
2830 reset_state (const GValue * data, gpointer user_data)
2831 {
2832   GstElement *e = g_value_get_object (data);
2833   GstState state = GPOINTER_TO_INT (user_data);
2834 
2835   if (gst_element_set_state (e, state) == GST_STATE_CHANGE_FAILURE)
2836     GST_WARNING_OBJECT (e, &quot;Failed to switch back down to %s&quot;,
2837         gst_element_state_get_name (state));
2838 }
2839 
2840 static GstStateChangeReturn
2841 gst_bin_change_state_func (GstElement * element, GstStateChange transition)
2842 {
2843   GstBin *bin;
2844   GstStateChangeReturn ret;
2845   GstState current, next;
2846   gboolean have_async;
2847   gboolean have_no_preroll;
2848   GstClockTime base_time, start_time;
2849   GstIterator *it;
2850   gboolean done;
2851   GValue data = { 0, };
2852 
2853   /* we don&#39;t need to take the STATE_LOCK, it is already taken */
2854   current = (GstState) GST_STATE_TRANSITION_CURRENT (transition);
2855   next = (GstState) GST_STATE_TRANSITION_NEXT (transition);
2856 
2857   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
2858       &quot;changing state of children from %s to %s&quot;,
2859       gst_element_state_get_name (current), gst_element_state_get_name (next));
2860 
2861   bin = GST_BIN_CAST (element);
2862 
2863   switch (next) {
2864     case GST_STATE_PLAYING:
2865     {
2866       gboolean toplevel, asynchandling;
2867 
2868       GST_OBJECT_LOCK (bin);
2869       toplevel = BIN_IS_TOPLEVEL (bin);
2870       asynchandling = bin-&gt;priv-&gt;asynchandling;
2871       GST_OBJECT_UNLOCK (bin);
2872 
2873       if (toplevel)
2874         gst_bin_recalculate_latency (bin);
2875       if (asynchandling)
2876         gst_element_post_message (element,
2877             gst_message_new_latency (GST_OBJECT_CAST (element)));
2878       break;
2879     }
2880     case GST_STATE_PAUSED:
2881       /* Clear EOS list on next PAUSED */
2882       GST_OBJECT_LOCK (bin);
2883       GST_DEBUG_OBJECT (element, &quot;clearing EOS elements&quot;);
2884       bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
2885       bin-&gt;priv-&gt;posted_eos = FALSE;
2886       if (current == GST_STATE_READY)
2887         bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
2888       GST_OBJECT_UNLOCK (bin);
2889       if (current == GST_STATE_READY)
2890         if (!(gst_bin_src_pads_activate (bin, TRUE)))
2891           goto activate_failure;
2892       break;
2893     case GST_STATE_READY:
2894       /* Clear message list on next READY */
2895       GST_OBJECT_LOCK (bin);
2896       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2897       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2898       GST_OBJECT_UNLOCK (bin);
2899       /* We might not have reached PAUSED yet due to async errors,
2900        * make sure to always deactivate the pads nonetheless */
2901       if (!(gst_bin_src_pads_activate (bin, FALSE)))
2902         goto activate_failure;
2903       break;
2904     case GST_STATE_NULL:
2905       /* Clear message list on next NULL */
2906       GST_OBJECT_LOCK (bin);
2907       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2908       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2909       GST_OBJECT_UNLOCK (bin);
2910       if (current == GST_STATE_READY) {
2911         if (!(gst_bin_src_pads_activate (bin, FALSE)))
2912           goto activate_failure;
<a name="9" id="anc9"></a><span class="line-modified">2913           }</span>
2914       break;
2915     default:
2916       break;
2917   }
2918 
2919   /* this flag is used to make the async state changes return immediately. We
2920    * don&#39;t want them to interfere with this state change */
2921   GST_OBJECT_LOCK (bin);
2922   bin-&gt;polling = TRUE;
2923   GST_OBJECT_UNLOCK (bin);
2924 
2925   /* iterate in state change order */
2926   it = gst_bin_iterate_sorted (bin);
2927 
2928   /* mark if we&#39;ve seen an ASYNC element in the bin when we did a state change.
2929    * Note how we don&#39;t reset this value when a resync happens, the reason being
2930    * that the async element posted ASYNC_START and we want to post ASYNC_DONE
2931    * even after a resync when the async element is gone */
2932   have_async = FALSE;
2933 
2934 restart:
2935   /* take base_time */
2936   base_time = gst_element_get_base_time (element);
2937   start_time = gst_element_get_start_time (element);
2938 
2939   have_no_preroll = FALSE;
2940 
2941   done = FALSE;
2942   while (!done) {
2943     switch (gst_iterator_next (it, &amp;data)) {
2944       case GST_ITERATOR_OK:
2945       {
2946         GstElement *child;
2947 
2948         child = g_value_get_object (&amp;data);
2949 
2950         /* set state and base_time now */
2951         ret = gst_bin_element_set_state (bin, child, base_time, start_time,
2952             current, next);
2953 
2954         switch (ret) {
2955           case GST_STATE_CHANGE_SUCCESS:
2956             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2957                 &quot;child &#39;%s&#39; changed state to %d(%s) successfully&quot;,
2958                 GST_ELEMENT_NAME (child), next,
2959                 gst_element_state_get_name (next));
2960             break;
2961           case GST_STATE_CHANGE_ASYNC:
2962           {
2963             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2964                 &quot;child &#39;%s&#39; is changing state asynchronously to %s&quot;,
2965                 GST_ELEMENT_NAME (child), gst_element_state_get_name (next));
2966             have_async = TRUE;
2967             break;
2968           }
2969           case GST_STATE_CHANGE_FAILURE:{
2970             GstObject *parent;
2971 
2972             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2973                 &quot;child &#39;%s&#39; failed to go to state %d(%s)&quot;,
2974                 GST_ELEMENT_NAME (child),
2975                 next, gst_element_state_get_name (next));
2976 
2977             /* Only fail if the child is still inside
2978              * this bin. It might&#39;ve been removed already
2979              * because of the error by the bin subclass
2980              * to ignore the error.  */
2981             parent = gst_object_get_parent (GST_OBJECT_CAST (child));
2982             if (parent == GST_OBJECT_CAST (element)) {
2983               /* element is still in bin, really error now */
2984               gst_object_unref (parent);
2985               goto undo;
2986             }
2987             /* child removed from bin, let the resync code redo the state
2988              * change */
2989             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2990                 &quot;child &#39;%s&#39; was removed from the bin&quot;,
2991                 GST_ELEMENT_NAME (child));
2992 
2993             if (parent)
2994               gst_object_unref (parent);
2995 
2996             break;
2997           }
2998           case GST_STATE_CHANGE_NO_PREROLL:
2999             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
3000                 &quot;child &#39;%s&#39; changed state to %d(%s) successfully without preroll&quot;,
3001                 GST_ELEMENT_NAME (child), next,
3002                 gst_element_state_get_name (next));
3003             have_no_preroll = TRUE;
3004             break;
3005           default:
3006             g_assert_not_reached ();
3007             break;
3008         }
3009         g_value_reset (&amp;data);
3010         break;
3011       }
3012       case GST_ITERATOR_RESYNC:
3013         GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, &quot;iterator doing resync&quot;);
3014         gst_iterator_resync (it);
3015         goto restart;
3016       default:
3017       case GST_ITERATOR_DONE:
3018         GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, &quot;iterator done&quot;);
3019         done = TRUE;
3020         break;
3021     }
3022   }
3023 
3024   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
3025   if (G_UNLIKELY (ret == GST_STATE_CHANGE_FAILURE))
3026     goto done;
3027 
3028   if (have_no_preroll) {
3029     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3030         &quot;we have NO_PREROLL elements %s -&gt; NO_PREROLL&quot;,
3031         gst_element_state_change_return_get_name (ret));
3032     ret = GST_STATE_CHANGE_NO_PREROLL;
3033   } else if (have_async) {
3034     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3035         &quot;we have ASYNC elements %s -&gt; ASYNC&quot;,
3036         gst_element_state_change_return_get_name (ret));
3037     ret = GST_STATE_CHANGE_ASYNC;
3038   }
3039 
3040 done:
3041   g_value_unset (&amp;data);
3042   gst_iterator_free (it);
3043 
3044   GST_OBJECT_LOCK (bin);
3045   bin-&gt;polling = FALSE;
3046   /* it&#39;s possible that we did not get ASYNC from the children while the bin is
3047    * simulating ASYNC behaviour by posting an ASYNC_DONE message on the bus with
3048    * itself as the source. In that case we still want to check if the state
3049    * change completed. */
3050   if (ret != GST_STATE_CHANGE_ASYNC &amp;&amp; !bin-&gt;priv-&gt;pending_async_done) {
3051     /* no element returned ASYNC and there are no pending async_done messages,
3052      * we can just complete. */
3053     GST_DEBUG_OBJECT (bin, &quot;no async elements&quot;);
3054     goto state_end;
3055   }
3056   /* when we get here an ASYNC element was found */
3057   if (GST_STATE_TARGET (bin) &lt;= GST_STATE_READY) {
3058     /* we ignore ASYNC state changes when we go to READY or NULL */
3059     GST_DEBUG_OBJECT (bin, &quot;target state %s &lt;= READY&quot;,
3060         gst_element_state_get_name (GST_STATE_TARGET (bin)));
3061     goto state_end;
3062   }
3063 
3064   GST_DEBUG_OBJECT (bin, &quot;check async elements&quot;);
3065   /* check if all elements managed to commit their state already */
3066   if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3067     /* nothing found, remove all old ASYNC_DONE messages. This can happen when
<a name="10" id="anc10"></a><span class="line-modified">3068      * all the elements commited their state while we were doing the state</span>
3069      * change. We will still return ASYNC for consistency but we commit the
3070      * state already so that a _get_state() will return immediately. */
3071     bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3072 
<a name="11" id="anc11"></a><span class="line-modified">3073     GST_DEBUG_OBJECT (bin, &quot;async elements commited&quot;);</span>
3074     bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, FALSE,
3075         GST_CLOCK_TIME_NONE);
3076   }
3077 
3078 state_end:
3079   bin-&gt;priv-&gt;pending_async_done = FALSE;
3080   GST_OBJECT_UNLOCK (bin);
3081 
3082   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
3083       &quot;done changing bin&#39;s state from %s to %s, now in %s, ret %s&quot;,
3084       gst_element_state_get_name (current),
3085       gst_element_state_get_name (next),
3086       gst_element_state_get_name (GST_STATE (element)),
3087       gst_element_state_change_return_get_name (ret));
3088 
3089   return ret;
3090 
3091   /* ERRORS */
3092 activate_failure:
3093   {
3094     GST_CAT_WARNING_OBJECT (GST_CAT_STATES, element,
3095         &quot;failure (de)activating src pads&quot;);
3096     return GST_STATE_CHANGE_FAILURE;
3097   }
3098 
3099 undo:
3100   {
3101     if (current &lt; next) {
3102       GstIterator *it = gst_bin_iterate_sorted (GST_BIN (element));
3103       GstIteratorResult ret;
3104 
3105       GST_DEBUG_OBJECT (element,
3106           &quot;Bin failed to change state, switching children back to %s&quot;,
3107           gst_element_state_get_name (current));
3108       while (TRUE) {
3109         ret =
3110             gst_iterator_foreach (it, &amp;reset_state, GINT_TO_POINTER (current));
3111         if (ret != GST_ITERATOR_RESYNC)
3112           break;
3113         gst_iterator_resync (it);
<a name="12" id="anc12"></a><span class="line-modified">3114 }</span>
3115       gst_iterator_free (it);
3116     }
3117     goto done;
3118   }
3119 }
3120 
3121 /*
3122  * This function is a utility event handler. It will send the event to all sinks
3123  * or sources and appropriate ghost pads depending on the event-direction.
3124  *
3125  * Applications are free to override this behaviour and implement their own
3126  * handler, but this will work for pretty much all cases in practice.
3127  */
3128 static gboolean
3129 gst_bin_send_event (GstElement * element, GstEvent * event)
3130 {
3131   GstBin *bin = GST_BIN_CAST (element);
3132   GstIterator *iter;
3133   gboolean res = TRUE;
3134   gboolean done = FALSE;
3135   GValue data = { 0, };
3136 
3137   if (GST_EVENT_IS_DOWNSTREAM (event)) {
3138     iter = gst_bin_iterate_sources (bin);
3139     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to src children&quot;,
3140         GST_EVENT_TYPE_NAME (event));
3141   } else {
3142     iter = gst_bin_iterate_sinks (bin);
3143     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to sink children&quot;,
3144         GST_EVENT_TYPE_NAME (event));
3145   }
3146 
3147   while (!done) {
3148     switch (gst_iterator_next (iter, &amp;data)) {
3149       case GST_ITERATOR_OK:
3150       {
3151         GstElement *child = g_value_get_object (&amp;data);
3152 
3153         gst_event_ref (event);
3154         res &amp;= gst_element_send_event (child, event);
3155 
3156         GST_LOG_OBJECT (child, &quot;After handling %s event: %d&quot;,
3157             GST_EVENT_TYPE_NAME (event), res);
3158 
3159         g_value_reset (&amp;data);
3160         break;
3161       }
3162       case GST_ITERATOR_RESYNC:
3163         gst_iterator_resync (iter);
3164         res = TRUE;
3165         break;
3166       case GST_ITERATOR_DONE:
3167         done = TRUE;
3168         break;
3169       case GST_ITERATOR_ERROR:
3170         g_assert_not_reached ();
3171         break;
3172     }
3173   }
3174   g_value_unset (&amp;data);
3175   gst_iterator_free (iter);
3176 
3177   if (GST_EVENT_IS_DOWNSTREAM (event)) {
3178     iter = gst_element_iterate_sink_pads (GST_ELEMENT (bin));
3179     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to sink pads&quot;,
3180         GST_EVENT_TYPE_NAME (event));
3181   } else {
3182     iter = gst_element_iterate_src_pads (GST_ELEMENT (bin));
3183     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to src pads&quot;,
3184         GST_EVENT_TYPE_NAME (event));
3185   }
3186 
3187   done = FALSE;
3188   while (!done) {
3189     switch (gst_iterator_next (iter, &amp;data)) {
3190       case GST_ITERATOR_OK:
3191       {
3192         GstPad *pad = g_value_get_object (&amp;data);
3193 
3194         gst_event_ref (event);
3195         res &amp;= gst_pad_send_event (pad, event);
3196         GST_LOG_OBJECT (pad, &quot;After handling %s event: %d&quot;,
3197             GST_EVENT_TYPE_NAME (event), res);
3198         break;
3199       }
3200       case GST_ITERATOR_RESYNC:
3201         gst_iterator_resync (iter);
3202         res = TRUE;
3203         break;
3204       case GST_ITERATOR_DONE:
3205         done = TRUE;
3206         break;
3207       case GST_ITERATOR_ERROR:
3208         g_assert_not_reached ();
3209         break;
3210     }
3211   }
3212 
3213   g_value_unset (&amp;data);
3214   gst_iterator_free (iter);
3215   gst_event_unref (event);
3216 
3217   return res;
3218 }
3219 
3220 /* this is the function called by the threadpool. When async elements commit
3221  * their state, this function will attempt to bring the bin to the next state.
3222  */
3223 static void
3224 gst_bin_continue_func (GstBin * bin, BinContinueData * data)
3225 {
3226   GstState current, next, pending;
3227   GstStateChange transition;
3228 
3229   pending = data-&gt;pending;
3230 
3231   GST_DEBUG_OBJECT (bin, &quot;waiting for state lock&quot;);
3232   GST_STATE_LOCK (bin);
3233 
3234   GST_DEBUG_OBJECT (bin, &quot;doing state continue&quot;);
3235   GST_OBJECT_LOCK (bin);
3236 
3237   /* if a new state change happened after this thread was scheduled, we return
3238    * immediately. */
3239   if (data-&gt;cookie != GST_ELEMENT_CAST (bin)-&gt;state_cookie)
3240     goto interrupted;
3241 
3242   current = GST_STATE (bin);
3243   next = GST_STATE_GET_NEXT (current, pending);
3244   transition = (GstStateChange) GST_STATE_TRANSITION (current, next);
3245 
3246   GST_STATE_NEXT (bin) = next;
3247   GST_STATE_PENDING (bin) = pending;
3248   /* mark busy */
3249   GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3250   GST_OBJECT_UNLOCK (bin);
3251 
3252   GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3253       &quot;continue state change %s to %s, final %s&quot;,
3254       gst_element_state_get_name (current),
3255       gst_element_state_get_name (next), gst_element_state_get_name (pending));
3256 
3257   gst_element_change_state (GST_ELEMENT_CAST (bin), transition);
3258 
3259   GST_STATE_UNLOCK (bin);
3260   GST_DEBUG_OBJECT (bin, &quot;state continue done&quot;);
3261 
3262   return;
3263 
3264 interrupted:
3265   {
3266     GST_OBJECT_UNLOCK (bin);
3267     GST_STATE_UNLOCK (bin);
3268     GST_DEBUG_OBJECT (bin, &quot;state continue aborted due to intervening change&quot;);
3269     return;
3270   }
3271 }
3272 
3273 static GstBusSyncReply
3274 bin_bus_handler (GstBus * bus, GstMessage * message, GstBin * bin)
3275 {
3276   GstBinClass *bclass;
3277 
3278   bclass = GST_BIN_GET_CLASS (bin);
3279   if (bclass-&gt;handle_message)
3280     bclass-&gt;handle_message (bin, message);
3281   else
3282     gst_message_unref (message);
3283 
3284   return GST_BUS_DROP;
3285 }
3286 
3287 static void
3288 free_bin_continue_data (BinContinueData * data)
3289 {
3290   g_slice_free (BinContinueData, data);
3291 }
3292 
3293 static void
3294 bin_push_state_continue (GstBin * bin, BinContinueData * data)
3295 {
3296   GST_DEBUG_OBJECT (bin, &quot;pushing continue on thread pool&quot;);
3297   gst_element_call_async (GST_ELEMENT_CAST (bin),
3298       (GstElementCallAsyncFunc) gst_bin_continue_func, data,
3299       (GDestroyNotify) free_bin_continue_data);
3300 }
3301 
3302 /* an element started an async state change, if we were not busy with a state
3303  * change, we perform a lost state.
3304  * This function is called with the OBJECT lock.
3305  */
3306 static void
3307 bin_handle_async_start (GstBin * bin)
3308 {
3309   GstState old_state, new_state;
3310   gboolean toplevel;
3311   GstMessage *amessage = NULL;
3312 
3313   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_FAILURE)
3314     goto had_error;
3315 
3316   /* get our toplevel state */
3317   toplevel = BIN_IS_TOPLEVEL (bin);
3318 
3319   /* prepare an ASYNC_START message, we always post the start message even if we
3320    * are busy with a state change or when we are NO_PREROLL. */
3321   if (!toplevel)
3322     /* non toplevel bin, prepare async-start for the parent */
3323     amessage = gst_message_new_async_start (GST_OBJECT_CAST (bin));
3324 
3325   if (bin-&gt;polling || GST_STATE_PENDING (bin) != GST_STATE_VOID_PENDING)
3326     goto was_busy;
3327 
3328   /* async starts are ignored when we are NO_PREROLL */
3329   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_NO_PREROLL)
3330     goto was_no_preroll;
3331 
3332   old_state = GST_STATE (bin);
3333 
3334   /* when we PLAYING we go back to PAUSED, when preroll happens, we go back to
3335    * PLAYING after optionally redistributing the base_time. */
3336   if (old_state &gt; GST_STATE_PAUSED)
3337     new_state = GST_STATE_PAUSED;
3338   else
3339     new_state = old_state;
3340 
3341   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3342       &quot;lost state of %s, new %s&quot;, gst_element_state_get_name (old_state),
3343       gst_element_state_get_name (new_state));
3344 
3345   GST_STATE (bin) = new_state;
3346   GST_STATE_NEXT (bin) = new_state;
3347   GST_STATE_PENDING (bin) = new_state;
3348   GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3349   GST_OBJECT_UNLOCK (bin);
3350 
3351   /* post message */
3352   _priv_gst_element_state_changed (GST_ELEMENT_CAST (bin), new_state, new_state,
3353       new_state);
3354 
3355 post_start:
3356   if (amessage) {
3357     /* post our ASYNC_START. */
3358     GST_DEBUG_OBJECT (bin, &quot;posting ASYNC_START to parent&quot;);
3359     gst_element_post_message (GST_ELEMENT_CAST (bin), amessage);
3360   }
3361   GST_OBJECT_LOCK (bin);
3362 
3363   return;
3364 
3365 had_error:
3366   {
3367     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;we had an error&quot;);
3368     return;
3369   }
3370 was_busy:
3371   {
3372     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3373     GST_OBJECT_UNLOCK (bin);
3374     goto post_start;
3375   }
3376 was_no_preroll:
3377   {
3378     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;ignoring, we are NO_PREROLL&quot;);
3379     GST_OBJECT_UNLOCK (bin);
3380     goto post_start;
3381   }
3382 }
3383 
3384 /* this function is called when there are no more async elements in the bin. We
3385  * post a state changed message and an ASYNC_DONE message.
3386  * This function is called with the OBJECT lock.
3387  */
3388 static void
3389 bin_handle_async_done (GstBin * bin, GstStateChangeReturn ret,
3390     gboolean flag_pending, GstClockTime running_time)
3391 {
3392   GstState current, pending, target;
3393   GstStateChangeReturn old_ret;
3394   GstState old_state, old_next;
3395   gboolean toplevel, state_changed = FALSE;
3396   GstMessage *amessage = NULL;
3397   BinContinueData *cont = NULL;
3398 
3399   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_FAILURE)
3400     goto had_error;
3401 
3402   pending = GST_STATE_PENDING (bin);
3403 
3404   if (bin-&gt;polling)
3405     goto was_busy;
3406 
3407   /* check if there is something to commit */
3408   if (pending == GST_STATE_VOID_PENDING)
3409     goto nothing_pending;
3410 
3411   old_ret = GST_STATE_RETURN (bin);
3412   GST_STATE_RETURN (bin) = ret;
3413 
3414   /* move to the next target state */
3415   target = GST_STATE_TARGET (bin);
3416   pending = GST_STATE_PENDING (bin) = target;
3417 
3418   amessage = gst_message_new_async_done (GST_OBJECT_CAST (bin), running_time);
3419 
3420   old_state = GST_STATE (bin);
3421   /* this is the state we should go to next */
3422   old_next = GST_STATE_NEXT (bin);
3423 
3424   if (old_next != GST_STATE_PLAYING) {
3425     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3426         &quot;committing state from %s to %s, old pending %s&quot;,
3427         gst_element_state_get_name (old_state),
3428         gst_element_state_get_name (old_next),
3429         gst_element_state_get_name (pending));
3430 
3431     /* update current state */
3432     current = GST_STATE (bin) = old_next;
3433   } else {
3434     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3435         &quot;setting state from %s to %s, pending %s&quot;,
3436         gst_element_state_get_name (old_state),
3437         gst_element_state_get_name (old_state),
3438         gst_element_state_get_name (pending));
3439     current = old_state;
3440   }
3441 
3442   /* get our toplevel state */
3443   toplevel = BIN_IS_TOPLEVEL (bin);
3444 
3445   /* see if we reached the final state. If we are not toplevel, we also have to
3446    * stop here, the parent will continue our state. */
3447   if ((pending == current) || !toplevel) {
3448     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3449         &quot;completed state change, pending VOID&quot;);
3450 
3451     /* mark VOID pending */
3452     pending = GST_STATE_VOID_PENDING;
3453     GST_STATE_PENDING (bin) = pending;
3454     GST_STATE_NEXT (bin) = GST_STATE_VOID_PENDING;
3455   } else {
3456     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3457         &quot;continue state change, pending %s&quot;,
3458         gst_element_state_get_name (pending));
3459 
3460     cont = g_slice_new (BinContinueData);
3461 
3462     /* cookie to detect concurrent state change */
3463     cont-&gt;cookie = GST_ELEMENT_CAST (bin)-&gt;state_cookie;
3464     /* pending target state */
3465     cont-&gt;pending = pending;
3466     /* mark busy */
3467     GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3468     GST_STATE_NEXT (bin) = GST_STATE_GET_NEXT (old_state, pending);
3469   }
3470 
3471   if (old_next != GST_STATE_PLAYING) {
3472     if (old_state != old_next || old_ret == GST_STATE_CHANGE_ASYNC) {
3473       state_changed = TRUE;
3474     }
3475   }
3476   GST_OBJECT_UNLOCK (bin);
3477 
3478   if (state_changed) {
3479     _priv_gst_element_state_changed (GST_ELEMENT_CAST (bin), old_state,
3480         old_next, pending);
3481   }
3482   if (amessage) {
3483     /* post our combined ASYNC_DONE when all is ASYNC_DONE. */
3484     GST_DEBUG_OBJECT (bin, &quot;posting ASYNC_DONE to parent&quot;);
3485     gst_element_post_message (GST_ELEMENT_CAST (bin), amessage);
3486   }
3487 
3488   GST_OBJECT_LOCK (bin);
3489   if (cont) {
3490     /* toplevel, start continue state */
3491     GST_DEBUG_OBJECT (bin, &quot;all async-done, starting state continue&quot;);
3492     bin_push_state_continue (bin, cont);
3493   } else {
3494     GST_DEBUG_OBJECT (bin, &quot;state change complete&quot;);
3495     GST_STATE_BROADCAST (bin);
3496   }
3497   return;
3498 
3499 had_error:
3500   {
3501     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;we had an error&quot;);
3502     return;
3503   }
3504 was_busy:
3505   {
3506     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3507     /* if we were busy with a state change and we are requested to flag a
3508      * pending async done, we do so here */
3509     if (flag_pending)
3510       bin-&gt;priv-&gt;pending_async_done = TRUE;
3511     return;
3512   }
3513 nothing_pending:
3514   {
3515     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin, &quot;nothing pending&quot;);
3516     return;
3517   }
3518 }
3519 
3520 static void
3521 bin_do_eos (GstBin * bin)
3522 {
<a name="13" id="anc13"></a><span class="line-modified">3523   guint32 seqnum = 0;</span>
3524   gboolean eos;
3525 
3526   GST_OBJECT_LOCK (bin);
3527   /* If all sinks are EOS, we&#39;re in PLAYING and no state change is pending
<a name="14" id="anc14"></a><span class="line-modified">3528    * (or we&#39;re doing playing to playing and noone else will trigger posting</span>
3529    * EOS for us) we forward the EOS message to the parent bin or application
3530    */
3531   eos = GST_STATE (bin) == GST_STATE_PLAYING
3532       &amp;&amp; (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING ||
3533       GST_STATE_PENDING (bin) == GST_STATE_PLAYING)
3534       &amp;&amp; bin-&gt;priv-&gt;posted_playing &amp;&amp; is_eos (bin, &amp;seqnum);
3535   GST_OBJECT_UNLOCK (bin);
3536 
3537   if (eos
3538       &amp;&amp; g_atomic_int_compare_and_exchange (&amp;bin-&gt;priv-&gt;posted_eos, FALSE,
3539           TRUE)) {
3540     GstMessage *tmessage;
3541 
3542     /* Clear out any further messages, and reset posted_eos so we can
3543        detect any new EOS that happens (eg, after a seek). Since all
3544        sinks have now posted an EOS, there will be no further EOS events
3545        seen unless there is a new logical EOS */
3546     GST_OBJECT_LOCK (bin);
3547     bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
3548     bin-&gt;priv-&gt;posted_eos = FALSE;
3549     GST_OBJECT_UNLOCK (bin);
3550 
3551     tmessage = gst_message_new_eos (GST_OBJECT_CAST (bin));
<a name="15" id="anc15"></a><span class="line-modified">3552     gst_message_set_seqnum (tmessage, seqnum);</span>

3553     GST_DEBUG_OBJECT (bin,
3554         &quot;all sinks posted EOS, posting seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3555     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3556   } else {
3557     GST_LOG_OBJECT (bin, &quot;Not forwarding EOS due to in progress state change, &quot;
3558         &quot; or already posted, or waiting for more EOS&quot;);
3559   }
3560 }
3561 
3562 static void
3563 bin_do_stream_start (GstBin * bin)
3564 {
<a name="16" id="anc16"></a><span class="line-modified">3565   guint32 seqnum = 0;</span>
3566   gboolean stream_start;
3567   gboolean have_group_id = FALSE;
3568   guint group_id = 0;
3569 
3570   GST_OBJECT_LOCK (bin);
3571   /* If all sinks are STREAM_START we forward the STREAM_START message
3572    * to the parent bin or application
3573    */
3574   stream_start = is_stream_start (bin, &amp;seqnum, &amp;have_group_id, &amp;group_id);
3575   GST_OBJECT_UNLOCK (bin);
3576 
3577   if (stream_start) {
3578     GstMessage *tmessage;
3579 
3580     GST_OBJECT_LOCK (bin);
3581     bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
3582     GST_OBJECT_UNLOCK (bin);
3583 
3584     tmessage = gst_message_new_stream_start (GST_OBJECT_CAST (bin));
<a name="17" id="anc17"></a><span class="line-modified">3585     gst_message_set_seqnum (tmessage, seqnum);</span>

3586     if (have_group_id)
3587       gst_message_set_group_id (tmessage, group_id);
3588 
3589     GST_DEBUG_OBJECT (bin,
3590         &quot;all sinks posted STREAM_START, posting seqnum #%&quot; G_GUINT32_FORMAT,
3591         seqnum);
3592     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3593   }
3594 }
3595 
3596 /* must be called without the object lock as it posts messages */
3597 static void
3598 bin_do_message_forward (GstBin * bin, GstMessage * message)
3599 {
3600   if (bin-&gt;priv-&gt;message_forward) {
3601     GstMessage *forwarded;
3602 
3603     GST_DEBUG_OBJECT (bin, &quot;pass %s message upward&quot;,
3604         GST_MESSAGE_TYPE_NAME (message));
3605 
3606     /* we need to convert these messages to element messages so that our parent
3607      * bin can easily ignore them and so that the application can easily
3608      * distinguish between the internally forwarded and the real messages. */
3609     forwarded = gst_message_new_element (GST_OBJECT_CAST (bin),
3610         gst_structure_new (&quot;GstBinForwarded&quot;,
3611             &quot;message&quot;, GST_TYPE_MESSAGE, message, NULL));
3612 
3613     gst_element_post_message (GST_ELEMENT_CAST (bin), forwarded);
3614   }
3615 }
3616 
3617 static void
3618 gst_bin_update_context (GstBin * bin, GstContext * context)
3619 {
3620   GST_OBJECT_LOCK (bin);
3621   gst_bin_update_context_unlocked (bin, context);
3622   GST_OBJECT_UNLOCK (bin);
3623 }
3624 
3625 static void
3626 gst_bin_update_context_unlocked (GstBin * bin, GstContext * context)
3627 {
3628   const gchar *context_type;
3629   GList *l, **contexts;
3630 
3631   contexts = &amp;GST_ELEMENT_CAST (bin)-&gt;contexts;
3632   context_type = gst_context_get_context_type (context);
3633 
3634   GST_DEBUG_OBJECT (bin, &quot;set context %p %&quot; GST_PTR_FORMAT, context,
3635       gst_context_get_structure (context));
3636   for (l = *contexts; l; l = l-&gt;next) {
3637     GstContext *tmp = l-&gt;data;
3638     const gchar *tmp_type = gst_context_get_context_type (tmp);
3639 
3640     /* Always store newest context but never replace
3641      * a persistent one by a non-persistent one */
3642     if (strcmp (context_type, tmp_type) == 0 &amp;&amp;
3643         (gst_context_is_persistent (context) ||
3644             !gst_context_is_persistent (tmp))) {
3645       gst_context_replace ((GstContext **) &amp; l-&gt;data, context);
3646       break;
3647     }
3648   }
3649   /* Not found? Add */
3650   if (l == NULL) {
3651     *contexts = g_list_prepend (*contexts, gst_context_ref (context));
<a name="18" id="anc18"></a><span class="line-modified">3652 }</span>
3653 }
3654 
3655 /* handle child messages:
3656  *
3657  * This method is called synchronously when a child posts a message on
3658  * the internal bus.
3659  *
3660  * GST_MESSAGE_EOS: This message is only posted by sinks
3661  *     in the PLAYING state. If all sinks posted the EOS message, post
3662  *     one upwards.
3663  *
3664  * GST_MESSAGE_STATE_DIRTY: Deprecated
3665  *
3666  * GST_MESSAGE_SEGMENT_START: just collect, never forward upwards. If an
3667  *     element posts segment_start twice, only the last message is kept.
3668  *
3669  * GST_MESSAGE_SEGMENT_DONE: replace SEGMENT_START message from same poster
3670  *     with the segment_done message. If there are no more segment_start
3671  *     messages, post segment_done message upwards.
3672  *
3673  * GST_MESSAGE_DURATION_CHANGED: clear any cached durations.
3674  *     Whenever someone performs a duration query on the bin, we store the
3675  *     result so we can answer it quicker the next time. Any element that
3676  *     changes its duration marks our cached values invalid.
3677  *     This message is also posted upwards. This is currently disabled
3678  *     because too many elements don&#39;t post DURATION_CHANGED messages when
3679  *     the duration changes.
3680  *
3681  * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it
3682  *     can no longer provide a clock. The default bin behaviour is to
3683  *     check if the lost clock was the one provided by the bin. If so and
3684  *     we are currently in the PLAYING state, we forward the message to
3685  *     our parent.
3686  *     This message is also generated when we remove a clock provider from
3687  *     a bin. If this message is received by the application, it should
3688  *     PAUSE the pipeline and set it back to PLAYING to force a new clock
3689  *     and a new base_time distribution.
3690  *
3691  * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element
3692  *     can provide a clock. This mostly happens when we add a new clock
3693  *     provider to the bin. The default behaviour of the bin is to mark the
3694  *     currently selected clock as dirty, which will perform a clock
3695  *     recalculation the next time we are asked to provide a clock.
3696  *     This message is never sent to the application but is forwarded to
3697  *     the parent.
3698  *
3699  * GST_MESSAGE_ASYNC_START: Create an internal ELEMENT message that stores
3700  *     the state of the element and the fact that the element will need a
3701  *     new base_time. This message is not forwarded to the application.
3702  *
3703  * GST_MESSAGE_ASYNC_DONE: Find the internal ELEMENT message we kept for the
3704  *     element when it posted ASYNC_START. If all elements are done, post a
3705  *     ASYNC_DONE message to the parent.
3706  *
3707  * OTHER: post upwards.
3708  */
3709 static void
3710 gst_bin_handle_message_func (GstBin * bin, GstMessage * message)
3711 {
3712   GstObject *src;
3713   GstMessageType type;
3714   GstMessage *tmessage;
3715   guint32 seqnum;
3716 
3717   src = GST_MESSAGE_SRC (message);
3718   type = GST_MESSAGE_TYPE (message);
3719 
3720   GST_DEBUG_OBJECT (bin, &quot;[msg %p] handling child %s message of type %s&quot;,
3721       message, src ? GST_ELEMENT_NAME (src) : &quot;(NULL)&quot;,
3722       GST_MESSAGE_TYPE_NAME (message));
3723 
3724   switch (type) {
3725     case GST_MESSAGE_ERROR:
3726     {
3727       GST_OBJECT_LOCK (bin);
3728       /* flag error */
3729       GST_DEBUG_OBJECT (bin, &quot;got ERROR message, unlocking state change&quot;);
3730       GST_STATE_RETURN (bin) = GST_STATE_CHANGE_FAILURE;
3731       GST_STATE_BROADCAST (bin);
3732       GST_OBJECT_UNLOCK (bin);
3733 
3734       goto forward;
3735     }
3736     case GST_MESSAGE_EOS:
3737     {
3738 
3739       /* collect all eos messages from the children */
3740       bin_do_message_forward (bin, message);
3741       GST_OBJECT_LOCK (bin);
3742       /* ref message for future use  */
3743       bin_replace_message (bin, message, GST_MESSAGE_EOS);
3744       GST_OBJECT_UNLOCK (bin);
3745 
3746       bin_do_eos (bin);
3747       break;
3748     }
3749     case GST_MESSAGE_STREAM_START:
3750     {
3751 
3752       /* collect all stream_start messages from the children */
3753       GST_OBJECT_LOCK (bin);
3754       /* ref message for future use  */
3755       bin_replace_message (bin, message, GST_MESSAGE_STREAM_START);
3756       GST_OBJECT_UNLOCK (bin);
3757 
3758       bin_do_stream_start (bin);
3759       break;
3760     }
3761     case GST_MESSAGE_STATE_DIRTY:
3762     {
3763       GST_WARNING_OBJECT (bin, &quot;received deprecated STATE_DIRTY message&quot;);
3764 
3765       /* free message */
3766       gst_message_unref (message);
3767       break;
3768     }
3769     case GST_MESSAGE_SEGMENT_START:{
3770       gboolean post = FALSE;
3771       GstFormat format;
3772       gint64 position;
3773 
3774       gst_message_parse_segment_start (message, &amp;format, &amp;position);
3775       seqnum = gst_message_get_seqnum (message);
3776 
3777       bin_do_message_forward (bin, message);
3778 
3779       GST_OBJECT_LOCK (bin);
3780       /* if this is the first segment-start, post to parent but not to the
3781        * application */
3782       if (!find_message (bin, NULL, GST_MESSAGE_SEGMENT_START) &amp;&amp;
3783           (GST_OBJECT_PARENT (bin) != NULL)) {
3784         post = TRUE;
3785       }
3786       /* replace any previous segment_start message from this source
3787        * with the new segment start message */
3788       bin_replace_message (bin, message, GST_MESSAGE_SEGMENT_START);
3789       GST_OBJECT_UNLOCK (bin);
3790       if (post) {
3791         tmessage = gst_message_new_segment_start (GST_OBJECT_CAST (bin),
3792             format, position);
3793         gst_message_set_seqnum (tmessage, seqnum);
3794 
3795         /* post segment start with initial format and position. */
3796         GST_DEBUG_OBJECT (bin, &quot;posting SEGMENT_START (%u) bus message: %p&quot;,
3797             seqnum, message);
3798         gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3799       }
3800       break;
3801     }
3802     case GST_MESSAGE_SEGMENT_DONE:
3803     {
3804       gboolean post = FALSE;
3805       GstFormat format;
3806       gint64 position;
3807 
3808       gst_message_parse_segment_done (message, &amp;format, &amp;position);
3809       seqnum = gst_message_get_seqnum (message);
3810 
3811       bin_do_message_forward (bin, message);
3812 
3813       GST_OBJECT_LOCK (bin);
3814       bin_replace_message (bin, message, GST_MESSAGE_SEGMENT_START);
3815       /* if there are no more segment_start messages, everybody posted
3816        * a segment_done and we can post one on the bus. */
3817 
3818       /* we don&#39;t care who still has a pending segment start */
3819       if (!find_message (bin, NULL, GST_MESSAGE_SEGMENT_START)) {
3820         /* nothing found */
3821         post = TRUE;
3822         /* remove all old segment_done messages */
3823         bin_remove_messages (bin, NULL, GST_MESSAGE_SEGMENT_DONE);
3824       }
3825       GST_OBJECT_UNLOCK (bin);
3826       if (post) {
3827         tmessage = gst_message_new_segment_done (GST_OBJECT_CAST (bin),
3828             format, position);
3829         gst_message_set_seqnum (tmessage, seqnum);
3830 
3831         /* post segment done with latest format and position. */
3832         GST_DEBUG_OBJECT (bin, &quot;posting SEGMENT_DONE (%u) bus message: %p&quot;,
3833             seqnum, message);
3834         gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3835       }
3836       break;
3837     }
3838     case GST_MESSAGE_DURATION_CHANGED:
3839     {
3840       /* FIXME: remove all cached durations, next time somebody asks
3841        * for duration, we will recalculate. */
3842 #if 0
3843       GST_OBJECT_LOCK (bin);
3844       bin_remove_messages (bin, NULL, GST_MESSAGE_DURATION_CHANGED);
3845       GST_OBJECT_UNLOCK (bin);
3846 #endif
3847       goto forward;
3848     }
3849     case GST_MESSAGE_CLOCK_LOST:
3850     {
3851       GstClock **provided_clock_p;
3852       GstElement **clock_provider_p;
3853       gboolean playing, toplevel, provided, forward;
3854       GstClock *clock;
3855 
3856       gst_message_parse_clock_lost (message, &amp;clock);
3857 
3858       GST_OBJECT_LOCK (bin);
3859       bin-&gt;clock_dirty = TRUE;
3860       /* if we lost the clock that we provided, post to parent but
3861        * only if we are not a top-level bin or PLAYING.
3862        * The reason for this is that applications should be able
3863        * to PAUSE/PLAY if they receive this message without worrying
3864        * about the state of the pipeline. */
3865       provided = (clock == bin-&gt;provided_clock);
3866       playing = (GST_STATE (bin) == GST_STATE_PLAYING);
3867       toplevel = GST_OBJECT_PARENT (bin) == NULL;
3868       forward = provided &amp;&amp; (playing || !toplevel);
3869       if (provided) {
3870         GST_DEBUG_OBJECT (bin,
3871             &quot;Lost clock %&quot; GST_PTR_FORMAT &quot; provided by %&quot; GST_PTR_FORMAT,
3872             bin-&gt;provided_clock, bin-&gt;clock_provider);
3873         provided_clock_p = &amp;bin-&gt;provided_clock;
3874         clock_provider_p = &amp;bin-&gt;clock_provider;
3875         gst_object_replace ((GstObject **) provided_clock_p, NULL);
3876         gst_object_replace ((GstObject **) clock_provider_p, NULL);
3877       }
3878       GST_DEBUG_OBJECT (bin, &quot;provided %d, playing %d, forward %d&quot;,
3879           provided, playing, forward);
3880       GST_OBJECT_UNLOCK (bin);
3881 
3882       if (forward)
3883         goto forward;
3884 
3885       /* free message */
3886       gst_message_unref (message);
3887       break;
3888     }
3889     case GST_MESSAGE_CLOCK_PROVIDE:
3890     {
3891       gboolean forward;
3892 
3893       GST_OBJECT_LOCK (bin);
3894       bin-&gt;clock_dirty = TRUE;
3895       /* a new clock is available, post to parent but not
3896        * to the application */
3897       forward = GST_OBJECT_PARENT (bin) != NULL;
3898       GST_OBJECT_UNLOCK (bin);
3899 
3900       if (forward)
3901         goto forward;
3902 
3903       /* free message */
3904       gst_message_unref (message);
3905       break;
3906     }
3907     case GST_MESSAGE_ASYNC_START:
3908     {
3909       GstState target;
3910 
3911       GST_DEBUG_OBJECT (bin, &quot;ASYNC_START message %p, %s&quot;, message,
3912           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3913 
3914       bin_do_message_forward (bin, message);
3915 
3916       GST_OBJECT_LOCK (bin);
3917       /* we ignore the message if we are going to &lt;= READY */
3918       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3919         goto ignore_start_message;
3920 
3921       /* takes ownership of the message */
3922       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3923 
3924       bin_handle_async_start (bin);
3925       GST_OBJECT_UNLOCK (bin);
3926       break;
3927 
3928     ignore_start_message:
3929       {
3930         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3931             gst_element_state_get_name (target));
3932         GST_OBJECT_UNLOCK (bin);
3933         gst_message_unref (message);
3934         break;
3935       }
3936     }
3937     case GST_MESSAGE_ASYNC_DONE:
3938     {
3939       GstClockTime running_time;
3940       GstState target;
3941 
3942       GST_DEBUG_OBJECT (bin, &quot;ASYNC_DONE message %p, %s&quot;, message,
3943           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3944 
3945       gst_message_parse_async_done (message, &amp;running_time);
3946 
3947       bin_do_message_forward (bin, message);
3948 
3949       GST_OBJECT_LOCK (bin);
3950       /* ignore messages if we are shutting down */
3951       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3952         goto ignore_done_message;
3953 
3954       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3955       /* if there are no more ASYNC_START messages, everybody posted
3956        * a ASYNC_DONE and we can post one on the bus. When checking, we
3957        * don&#39;t care who still has a pending ASYNC_START */
3958       if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3959         /* nothing found, remove all old ASYNC_DONE messages */
3960         bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3961 
<a name="19" id="anc19"></a><span class="line-modified">3962         GST_DEBUG_OBJECT (bin, &quot;async elements commited&quot;);</span>
3963         /* when we get an async done message when a state change was busy, we
3964          * need to set the pending_done flag so that at the end of the state
3965          * change we can see if we need to verify pending async elements, hence
3966          * the TRUE argument here. */
3967         bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, TRUE,
3968             running_time);
3969       } else {
3970         GST_DEBUG_OBJECT (bin, &quot;there are more async elements pending&quot;);
3971       }
3972       GST_OBJECT_UNLOCK (bin);
3973       break;
3974 
3975     ignore_done_message:
3976       {
3977         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3978             gst_element_state_get_name (target));
3979         GST_OBJECT_UNLOCK (bin);
3980         gst_message_unref (message);
3981         break;
3982       }
3983     }
3984     case GST_MESSAGE_STRUCTURE_CHANGE:
3985     {
3986       gboolean busy;
3987 
3988       gst_message_parse_structure_change (message, NULL, NULL, &amp;busy);
3989 
3990       GST_OBJECT_LOCK (bin);
3991       if (busy) {
3992         /* while the pad is busy, avoid following it when doing state changes.
3993          * Don&#39;t update the cookie yet, we will do that after the structure
3994          * change finished and we are ready to inspect the new updated
3995          * structure. */
3996         bin_replace_message (bin, message, GST_MESSAGE_STRUCTURE_CHANGE);
3997         message = NULL;
3998       } else {
3999         /* a pad link/unlink ended, signal the state change iterator that we
4000          * need to resync by updating the structure_cookie. */
4001         bin_remove_messages (bin, GST_MESSAGE_SRC (message),
4002             GST_MESSAGE_STRUCTURE_CHANGE);
4003         if (!GST_BIN_IS_NO_RESYNC (bin))
4004           bin-&gt;priv-&gt;structure_cookie++;
4005       }
4006       GST_OBJECT_UNLOCK (bin);
4007 
4008       if (message)
4009         gst_message_unref (message);
4010 
4011       break;
4012     }
4013     case GST_MESSAGE_NEED_CONTEXT:{
4014       const gchar *context_type;
4015       GList *l, *contexts;
4016 
4017       gst_message_parse_context_type (message, &amp;context_type);
4018       GST_OBJECT_LOCK (bin);
4019       contexts = GST_ELEMENT_CAST (bin)-&gt;contexts;
4020       GST_LOG_OBJECT (bin, &quot;got need-context message type: %s&quot;, context_type);
4021       for (l = contexts; l; l = l-&gt;next) {
4022         GstContext *tmp = l-&gt;data;
4023         const gchar *tmp_type = gst_context_get_context_type (tmp);
4024 
4025         if (strcmp (context_type, tmp_type) == 0) {
4026           gst_element_set_context (GST_ELEMENT (src), l-&gt;data);
4027           break;
4028         }
4029       }
4030       GST_OBJECT_UNLOCK (bin);
4031 
4032       /* Forward if we couldn&#39;t answer the message */
4033       if (l == NULL) {
4034         goto forward;
4035       } else {
4036         gst_message_unref (message);
4037       }
4038 
4039       break;
4040     }
4041     case GST_MESSAGE_HAVE_CONTEXT:{
4042       GstContext *context;
4043 
4044       gst_message_parse_have_context (message, &amp;context);
4045       gst_bin_update_context (bin, context);
4046       gst_context_unref (context);
4047 
4048       goto forward;
4049       break;
4050     }
4051     default:
4052       goto forward;
4053   }
4054   return;
4055 
4056 forward:
4057   {
4058     /* Send all other messages upward */
4059     GST_DEBUG_OBJECT (bin, &quot;posting message upward&quot;);
4060     gst_element_post_message (GST_ELEMENT_CAST (bin), message);
4061     return;
4062   }
4063 }
4064 
4065 /* generic struct passed to all query fold methods */
4066 typedef struct
4067 {
4068   GstQuery *query;
4069   gint64 min;
4070   gint64 max;
4071   gboolean live;
4072 } QueryFold;
4073 
4074 typedef void (*QueryInitFunction) (GstBin * bin, QueryFold * fold);
4075 typedef void (*QueryDoneFunction) (GstBin * bin, QueryFold * fold);
4076 
4077 /* for duration/position we collect all durations/positions and take
4078  * the MAX of all valid results */
4079 static void
4080 bin_query_min_max_init (GstBin * bin, QueryFold * fold)
4081 {
4082   fold-&gt;min = 0;
4083   fold-&gt;max = -1;
4084   fold-&gt;live = FALSE;
4085 }
4086 
4087 static gboolean
4088 bin_query_duration_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4089 {
4090   gboolean res = FALSE;
4091   GstObject *item = g_value_get_object (vitem);
4092   if (GST_IS_PAD (item))
4093     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4094   else
4095     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4096 
4097   if (res) {
4098     gint64 duration;
4099 
4100     g_value_set_boolean (ret, TRUE);
4101 
4102     gst_query_parse_duration (fold-&gt;query, NULL, &amp;duration);
4103 
4104     GST_DEBUG_OBJECT (item, &quot;got duration %&quot; G_GINT64_FORMAT, duration);
4105 
4106     if (duration == -1) {
4107       /* duration query succeeded, but duration is unknown */
4108       fold-&gt;max = -1;
4109       return FALSE;
4110     }
4111 
4112     if (duration &gt; fold-&gt;max)
4113       fold-&gt;max = duration;
4114   }
4115 
4116   return TRUE;
4117 }
4118 
4119 static void
4120 bin_query_duration_done (GstBin * bin, QueryFold * fold)
4121 {
4122   GstFormat format;
4123 
4124   gst_query_parse_duration (fold-&gt;query, &amp;format, NULL);
4125   /* store max in query result */
4126   gst_query_set_duration (fold-&gt;query, format, fold-&gt;max);
4127 
4128   GST_DEBUG_OBJECT (bin, &quot;max duration %&quot; G_GINT64_FORMAT, fold-&gt;max);
4129 
4130   /* FIXME: re-implement duration caching */
4131 #if 0
4132   /* and cache now */
4133   GST_OBJECT_LOCK (bin);
4134   bin-&gt;messages = g_list_prepend (bin-&gt;messages,
4135       gst_message_new_duration (GST_OBJECT_CAST (bin), format, fold-&gt;max));
4136   GST_OBJECT_UNLOCK (bin);
4137 #endif
4138 }
4139 
4140 static gboolean
4141 bin_query_position_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4142 {
4143   gboolean res = FALSE;
4144   GstObject *item = g_value_get_object (vitem);
4145   if (GST_IS_PAD (item))
4146     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4147   else
4148     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4149 
4150   if (res) {
4151     gint64 position;
4152 
4153     g_value_set_boolean (ret, TRUE);
4154 
4155     gst_query_parse_position (fold-&gt;query, NULL, &amp;position);
4156 
4157     GST_DEBUG_OBJECT (item, &quot;got position %&quot; G_GINT64_FORMAT, position);
4158 
4159     if (position &gt; fold-&gt;max)
4160       fold-&gt;max = position;
4161   }
4162 
4163   return TRUE;
4164 }
4165 
4166 static void
4167 bin_query_position_done (GstBin * bin, QueryFold * fold)
4168 {
4169   GstFormat format;
4170 
4171   gst_query_parse_position (fold-&gt;query, &amp;format, NULL);
4172   /* store max in query result */
4173   gst_query_set_position (fold-&gt;query, format, fold-&gt;max);
4174 
4175   GST_DEBUG_OBJECT (bin, &quot;max position %&quot; G_GINT64_FORMAT, fold-&gt;max);
4176 }
4177 
4178 static gboolean
4179 bin_query_latency_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4180 {
4181   gboolean res = FALSE;
4182   GstObject *item = g_value_get_object (vitem);
4183   if (GST_IS_PAD (item))
4184     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4185   else
4186     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4187   if (res) {
4188     GstClockTime min, max;
4189     gboolean live;
4190 
4191     gst_query_parse_latency (fold-&gt;query, &amp;live, &amp;min, &amp;max);
4192 
4193     GST_DEBUG_OBJECT (item,
4194         &quot;got latency min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT
4195         &quot;, live %d&quot;, GST_TIME_ARGS (min), GST_TIME_ARGS (max), live);
4196 
4197     /* for the combined latency we collect the MAX of all min latencies and
4198      * the MIN of all max latencies */
4199     if (live) {
4200       if (min &gt; fold-&gt;min)
4201         fold-&gt;min = min;
4202       if (fold-&gt;max == -1)
4203         fold-&gt;max = max;
4204       else if (max &lt; fold-&gt;max)
4205         fold-&gt;max = max;
4206       if (!fold-&gt;live)
4207         fold-&gt;live = live;
4208     }
4209   } else {
4210     g_value_set_boolean (ret, FALSE);
4211     GST_DEBUG_OBJECT (item, &quot;failed query&quot;);
4212   }
4213 
4214   return TRUE;
4215 }
4216 
4217 static void
4218 bin_query_latency_done (GstBin * bin, QueryFold * fold)
4219 {
4220   /* store max in query result */
4221   gst_query_set_latency (fold-&gt;query, fold-&gt;live, fold-&gt;min, fold-&gt;max);
4222 
4223   GST_DEBUG_OBJECT (bin,
4224       &quot;latency min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT
4225       &quot;, live %d&quot;, GST_TIME_ARGS (fold-&gt;min), GST_TIME_ARGS (fold-&gt;max),
4226       fold-&gt;live);
4227 }
4228 
4229 /* generic fold, return first valid result */
4230 static gboolean
4231 bin_query_generic_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4232 {
4233   gboolean res = FALSE;
4234   GstObject *item = g_value_get_object (vitem);
4235   if (GST_IS_PAD (item))
4236     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4237   else
4238     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4239   if (res) {
4240     g_value_set_boolean (ret, TRUE);
4241     GST_DEBUG_OBJECT (item, &quot;answered query %p&quot;, fold-&gt;query);
4242   }
4243 
4244   /* and stop as soon as we have a valid result */
4245   return !res;
4246 }
4247 
4248 /* Perform a query iteration for the given bin. The query is stored in
4249  * QueryFold and iter should be either a GstPad iterator or a
4250  * GstElement iterator. */
4251 static gboolean
4252 bin_iterate_fold (GstBin * bin, GstIterator * iter, QueryInitFunction fold_init,
4253     QueryDoneFunction fold_done, GstIteratorFoldFunction fold_func,
4254     QueryFold * fold_data, gboolean default_return)
4255 {
4256   gboolean res = default_return;
4257   GValue ret = { 0 };
4258   /* set the result of the query to FALSE initially */
4259   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
4260   g_value_set_boolean (&amp;ret, res);
4261 
4262   while (TRUE) {
4263     GstIteratorResult ires;
4264 
4265     ires = gst_iterator_fold (iter, fold_func, &amp;ret, fold_data);
4266 
4267     switch (ires) {
4268       case GST_ITERATOR_RESYNC:
4269         gst_iterator_resync (iter);
4270         if (fold_init)
4271           fold_init (bin, fold_data);
4272         g_value_set_boolean (&amp;ret, res);
4273         break;
4274       case GST_ITERATOR_OK:
4275       case GST_ITERATOR_DONE:
4276         res = g_value_get_boolean (&amp;ret);
4277         if (fold_done != NULL &amp;&amp; res)
4278           fold_done (bin, fold_data);
4279         goto done;
4280       default:
4281         res = FALSE;
4282         goto done;
4283     }
4284   }
4285 done:
4286   return res;
4287 }
4288 
4289 static gboolean
4290 gst_bin_query (GstElement * element, GstQuery * query)
4291 {
4292   GstBin *bin = GST_BIN_CAST (element);
4293   GstIterator *iter;
4294   gboolean default_return = FALSE;
4295   gboolean res = FALSE;
4296   gboolean src_pads_query_result = FALSE;
4297   GstIteratorFoldFunction fold_func;
4298   QueryInitFunction fold_init = NULL;
4299   QueryDoneFunction fold_done = NULL;
4300   QueryFold fold_data;
4301 
4302   switch (GST_QUERY_TYPE (query)) {
4303     case GST_QUERY_DURATION:
4304     {
4305       /* FIXME: implement duration caching in GstBin again */
4306 #if 0
4307       GList *cached;
4308       GstFormat qformat;
4309 
4310       gst_query_parse_duration (query, &amp;qformat, NULL);
4311 
4312       /* find cached duration query */
4313       GST_OBJECT_LOCK (bin);
4314       for (cached = bin-&gt;messages; cached; cached = g_list_next (cached)) {
4315         GstMessage *message = (GstMessage *) cached-&gt;data;
4316 
4317         if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_DURATION_CHANGED &amp;&amp;
4318             GST_MESSAGE_SRC (message) == GST_OBJECT_CAST (bin)) {
4319           GstFormat format;
4320           gint64 duration;
4321 
4322           gst_message_parse_duration (message, &amp;format, &amp;duration);
4323 
4324           /* if cached same format, copy duration in query result */
4325           if (format == qformat) {
4326             GST_DEBUG_OBJECT (bin, &quot;return cached duration %&quot; G_GINT64_FORMAT,
4327                 duration);
4328             GST_OBJECT_UNLOCK (bin);
4329 
4330             gst_query_set_duration (query, qformat, duration);
4331             res = TRUE;
4332             goto exit;
4333           }
4334         }
4335       }
4336       GST_OBJECT_UNLOCK (bin);
4337 #else
4338 #ifndef GST_DISABLE_GST_DEBUG
4339       G_STMT_START {
4340         /* Quieten this particularly annoying FIXME a bit: */
4341         static gboolean printed_fixme = FALSE;
4342         if (!printed_fixme) {
<a name="20" id="anc20"></a><span class="line-modified">4343       GST_FIXME (&quot;implement duration caching in GstBin again&quot;);</span>
4344           printed_fixme = TRUE;
4345         }
4346       }
4347       G_STMT_END;
4348 #endif
4349 #endif
4350       /* no cached value found, iterate and collect durations */
4351       fold_func = (GstIteratorFoldFunction) bin_query_duration_fold;
4352       fold_init = bin_query_min_max_init;
4353       fold_done = bin_query_duration_done;
4354       break;
4355     }
4356     case GST_QUERY_POSITION:
4357     {
4358       fold_func = (GstIteratorFoldFunction) bin_query_position_fold;
4359       fold_init = bin_query_min_max_init;
4360       fold_done = bin_query_position_done;
4361       break;
4362     }
4363     case GST_QUERY_LATENCY:
4364     {
4365       fold_func = (GstIteratorFoldFunction) bin_query_latency_fold;
4366       fold_init = bin_query_min_max_init;
4367       fold_done = bin_query_latency_done;
4368       default_return = TRUE;
4369       break;
4370     }
4371     default:
4372       fold_func = (GstIteratorFoldFunction) bin_query_generic_fold;
4373       break;
4374   }
4375 
4376   fold_data.query = query;
4377 
4378   iter = gst_bin_iterate_sinks (bin);
4379   GST_DEBUG_OBJECT (bin, &quot;Sending query %p (type %s) to sink children&quot;,
4380       query, GST_QUERY_TYPE_NAME (query));
4381 
4382   if (fold_init)
4383     fold_init (bin, &amp;fold_data);
4384 
4385   res =
4386       bin_iterate_fold (bin, iter, fold_init, fold_done, fold_func, &amp;fold_data,
4387       default_return);
4388   gst_iterator_free (iter);
4389 
4390   if (!res) {
4391     /* Query the source pads of the element */
4392     iter = gst_element_iterate_src_pads (element);
4393     src_pads_query_result =
4394         bin_iterate_fold (bin, iter, fold_init, fold_done, fold_func,
4395         &amp;fold_data, default_return);
4396     gst_iterator_free (iter);
4397 
4398     if (src_pads_query_result)
4399       res = TRUE;
4400   }
4401 
4402   GST_DEBUG_OBJECT (bin, &quot;query %p result %d&quot;, query, res);
4403 
4404   return res;
4405 }
4406 
4407 static void
4408 set_context (const GValue * item, gpointer user_data)
4409 {
4410   GstElement *element = g_value_get_object (item);
4411 
4412   gst_element_set_context (element, user_data);
4413 }
4414 
4415 static void
4416 gst_bin_set_context (GstElement * element, GstContext * context)
4417 {
4418   GstBin *bin;
4419   GstIterator *children;
4420 
4421   g_return_if_fail (GST_IS_BIN (element));
4422 
4423   bin = GST_BIN (element);
4424 
4425   GST_ELEMENT_CLASS (parent_class)-&gt;set_context (element, context);
4426 
4427   children = gst_bin_iterate_elements (bin);
4428   while (gst_iterator_foreach (children, set_context,
4429           context) == GST_ITERATOR_RESYNC)
4430     gst_iterator_resync (children);
4431   gst_iterator_free (children);
4432 }
4433 
4434 static gint
4435 compare_name (const GValue * velement, const gchar * name)
4436 {
4437   gint eq;
4438   GstElement *element = g_value_get_object (velement);
4439 
4440   GST_OBJECT_LOCK (element);
4441   eq = strcmp (GST_ELEMENT_NAME (element), name);
4442   GST_OBJECT_UNLOCK (element);
4443 
4444   return eq;
4445 }
4446 
4447 /**
4448  * gst_bin_get_by_name:
4449  * @bin: a #GstBin
4450  * @name: the element name to search for
4451  *
4452  * Gets the element with the given name from a bin. This
4453  * function recurses into child bins.
4454  *
4455  * Returns %NULL if no element with the given name is found in the bin.
4456  *
4457  * MT safe.  Caller owns returned reference.
4458  *
4459  * Returns: (transfer full) (nullable): the #GstElement with the given
4460  * name, or %NULL
4461  */
4462 GstElement *
4463 gst_bin_get_by_name (GstBin * bin, const gchar * name)
4464 {
4465   GstIterator *children;
4466   GValue result = { 0, };
4467   GstElement *element;
4468   gboolean found;
4469 
4470   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4471 
4472   GST_CAT_INFO (GST_CAT_PARENTAGE, &quot;[%s]: looking up child element %s&quot;,
4473       GST_ELEMENT_NAME (bin), name);
4474 
4475   children = gst_bin_iterate_recurse (bin);
4476   found = gst_iterator_find_custom (children,
4477       (GCompareFunc) compare_name, &amp;result, (gpointer) name);
4478   gst_iterator_free (children);
4479 
4480   if (found) {
4481     element = g_value_dup_object (&amp;result);
4482     g_value_unset (&amp;result);
4483   } else {
4484     element = NULL;
4485   }
4486 
4487   return element;
4488 }
4489 
4490 /**
4491  * gst_bin_get_by_name_recurse_up:
4492  * @bin: a #GstBin
4493  * @name: the element name to search for
4494  *
4495  * Gets the element with the given name from this bin. If the
4496  * element is not found, a recursion is performed on the parent bin.
4497  *
4498  * Returns %NULL if:
4499  * - no element with the given name is found in the bin
4500  *
4501  * MT safe.  Caller owns returned reference.
4502  *
4503  * Returns: (transfer full) (nullable): the #GstElement with the given
4504  * name, or %NULL
4505  */
4506 GstElement *
4507 gst_bin_get_by_name_recurse_up (GstBin * bin, const gchar * name)
4508 {
4509   GstElement *result;
4510 
4511   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4512   g_return_val_if_fail (name != NULL, NULL);
4513 
4514   result = gst_bin_get_by_name (bin, name);
4515 
4516   if (!result) {
4517     GstObject *parent;
4518 
4519     parent = gst_object_get_parent (GST_OBJECT_CAST (bin));
4520     if (parent) {
4521       if (GST_IS_BIN (parent)) {
4522         result = gst_bin_get_by_name_recurse_up (GST_BIN_CAST (parent), name);
4523       }
4524       gst_object_unref (parent);
4525     }
4526   }
4527 
4528   return result;
4529 }
4530 
4531 static gint
4532 compare_interface (const GValue * velement, GValue * interface)
4533 {
4534   GstElement *element = g_value_get_object (velement);
4535   GType interface_type = (GType) g_value_get_pointer (interface);
4536   gint ret;
4537 
4538   if (G_TYPE_CHECK_INSTANCE_TYPE (element, interface_type)) {
4539     ret = 0;
4540   } else {
4541     ret = 1;
4542   }
4543   return ret;
4544 }
4545 
4546 /**
4547  * gst_bin_get_by_interface:
4548  * @bin: a #GstBin
4549  * @iface: the #GType of an interface
4550  *
4551  * Looks for an element inside the bin that implements the given
4552  * interface. If such an element is found, it returns the element.
4553  * You can cast this element to the given interface afterwards.  If you want
4554  * all elements that implement the interface, use
4555  * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
4556  *
4557  * MT safe.  Caller owns returned reference.
4558  *
4559  * Returns: (transfer full) (nullable): A #GstElement inside the bin
4560  * implementing the interface
4561  */
4562 GstElement *
4563 gst_bin_get_by_interface (GstBin * bin, GType iface)
4564 {
4565   GstIterator *children;
4566   GValue result = { 0, };
4567   GstElement *element;
4568   gboolean found;
4569   GValue viface = { 0, };
4570 
4571   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4572   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface), NULL);
4573 
4574   g_value_init (&amp;viface, G_TYPE_POINTER);
4575   g_value_set_pointer (&amp;viface, (gpointer) iface);
4576 
4577   children = gst_bin_iterate_recurse (bin);
4578   found = gst_iterator_find_custom (children, (GCompareFunc) compare_interface,
4579       &amp;result, &amp;viface);
4580   gst_iterator_free (children);
4581 
4582   if (found) {
4583     element = g_value_dup_object (&amp;result);
4584     g_value_unset (&amp;result);
4585   } else {
4586     element = NULL;
4587   }
4588   g_value_unset (&amp;viface);
4589 
4590   return element;
4591 }
4592 
4593 /**
4594  * gst_bin_iterate_all_by_interface:
4595  * @bin: a #GstBin
4596  * @iface: the #GType of an interface
4597  *
4598  * Looks for all elements inside the bin that implements the given
4599  * interface. You can safely cast all returned elements to the given interface.
4600  * The function recurses inside child bins. The iterator will yield a series
4601  * of #GstElement that should be unreffed after use.
4602  *
4603  * MT safe.  Caller owns returned value.
4604  *
4605  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement
4606  *     for all elements in the bin implementing the given interface,
4607  *     or %NULL
4608  */
4609 GstIterator *
4610 gst_bin_iterate_all_by_interface (GstBin * bin, GType iface)
4611 {
4612   GstIterator *children;
4613   GstIterator *result;
4614   GValue viface = { 0, };
4615 
4616   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4617   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface), NULL);
4618 
4619   g_value_init (&amp;viface, G_TYPE_POINTER);
4620   g_value_set_pointer (&amp;viface, (gpointer) iface);
4621 
4622   children = gst_bin_iterate_recurse (bin);
4623   result = gst_iterator_filter (children, (GCompareFunc) compare_interface,
4624       &amp;viface);
4625 
4626   g_value_unset (&amp;viface);
4627 
4628   return result;
4629 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>