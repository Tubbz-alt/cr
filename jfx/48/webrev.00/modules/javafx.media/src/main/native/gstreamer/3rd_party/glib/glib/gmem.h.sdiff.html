<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmem.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41  * @calloc: function to use for allocating zero-filled memory.
 42  * @try_malloc: function to use for allocating memory without a default error handler.
 43  * @try_realloc: function to use for reallocating memory without a default error handler.
 44  *
 45  * A set of functions used to perform memory allocation. The same #GMemVTable must
 46  * be used for all allocations in the same program; a call to g_mem_set_vtable(),
 47  * if it exists, should be prior to any use of GLib.
 48  *
 49  * This functions related to this has been deprecated in 2.46, and no longer work.
 50  */
 51 typedef struct _GMemVTable GMemVTable;
 52 
 53 
 54 #if GLIB_SIZEOF_VOID_P &gt; GLIB_SIZEOF_LONG
 55 /**
 56  * G_MEM_ALIGN:
 57  *
 58  * Indicates the number of bytes to which memory will be aligned on the
 59  * current platform.
 60  */
<span class="line-modified"> 61 #  define G_MEM_ALIGN   GLIB_SIZEOF_VOID_P</span>
<span class="line-modified"> 62 #else   /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */</span>
<span class="line-modified"> 63 #  define G_MEM_ALIGN   GLIB_SIZEOF_LONG</span>
 64 #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
 65 
 66 
 67 /* Memory allocation functions
 68  */
 69 
 70 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 71 void     g_free           (gpointer  mem);</span>
 72 
 73 GLIB_AVAILABLE_IN_2_34
 74 void     g_clear_pointer  (gpointer      *pp,
 75                            GDestroyNotify destroy);
 76 
 77 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 78 gpointer g_malloc         (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 79 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 80 gpointer g_malloc0        (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 81 GLIB_AVAILABLE_IN_ALL
 82 gpointer g_realloc        (gpointer  mem,
<span class="line-modified"> 83                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 84 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 85 gpointer g_try_malloc     (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 86 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 87 gpointer g_try_malloc0    (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 88 GLIB_AVAILABLE_IN_ALL
 89 gpointer g_try_realloc    (gpointer  mem,
<span class="line-modified"> 90                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 91 
 92 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 93 gpointer g_malloc_n       (gsize     n_blocks,</span>
<span class="line-modified"> 94                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 95 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 96 gpointer g_malloc0_n      (gsize     n_blocks,</span>
<span class="line-modified"> 97                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 98 GLIB_AVAILABLE_IN_ALL
 99 gpointer g_realloc_n      (gpointer  mem,
<span class="line-modified">100                gsize     n_blocks,</span>
<span class="line-modified">101                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
102 GLIB_AVAILABLE_IN_ALL
<span class="line-modified">103 gpointer g_try_malloc_n   (gsize     n_blocks,</span>
<span class="line-modified">104                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
105 GLIB_AVAILABLE_IN_ALL
<span class="line-modified">106 gpointer g_try_malloc0_n  (gsize     n_blocks,</span>
<span class="line-modified">107                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
108 GLIB_AVAILABLE_IN_ALL
109 gpointer g_try_realloc_n  (gpointer  mem,
<span class="line-modified">110                gsize     n_blocks,</span>
<span class="line-modified">111                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
112 
113 #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
114 #define g_clear_pointer(pp, destroy)                                           \
115   G_STMT_START {                                                               \
116     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
117     __typeof__((pp)) _pp = (pp);                                               \
118     __typeof__(*(pp)) _ptr = *_pp;                                             \
119     *_pp = NULL;                                                               \
120     if (_ptr)                                                                  \
121       (destroy) (_ptr);                                                        \
<span class="line-modified">122   } G_STMT_END</span>

123 #else /* __GNUC__ */
124 #define g_clear_pointer(pp, destroy) \
125   G_STMT_START {                                                               \
126     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
127     /* Only one access, please; work around type aliasing */                   \
128     union { char *in; gpointer *out; } _pp;                                    \
129     gpointer _p;                                                               \
130     /* This assignment is needed to avoid a gcc warning */                     \
131     GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
132                                                                                \
133     _pp.in = (char *) (pp);                                                    \
134     _p = *_pp.out;                                                             \
<span class="line-modified">135     if (_p)                                        \</span>
<span class="line-modified">136       {                                        \</span>
137         *_pp.out = NULL;                                                       \
138         _destroy (_p);                                                         \
139       }                                                                        \
<span class="line-modified">140   } G_STMT_END</span>

141 #endif /* __GNUC__ */
142 
143 /**
144  * g_steal_pointer:
145  * @pp: (not nullable): a pointer to a pointer
146  *
147  * Sets @pp to %NULL, returning the value that was there before.
148  *
149  * Conceptually, this transfers the ownership of the pointer from the
150  * referenced variable to the &quot;caller&quot; of the macro (ie: &quot;steals&quot; the
151  * reference).
152  *
153  * The return value will be properly typed, according to the type of
154  * @pp.
155  *
156  * This can be very useful when combined with g_autoptr() to prevent the
157  * return value of a function from being automatically freed.  Consider
158  * the following example (which only works on GCC and clang):
159  *
160  * |[
</pre>
<hr />
<pre>
205   *ptr = NULL;
206 
207   return ref;
208 }
209 
210 /* type safety */
211 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 8)) &amp;&amp; !defined(__cplusplus) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
212 #define g_steal_pointer(pp) ((__typeof__(*pp)) (g_steal_pointer) (pp))
213 #else  /* __GNUC__ */
214 /* This version does not depend on gcc extensions, but gcc does not warn
215  * about incompatible-pointer-types: */
216 #define g_steal_pointer(pp) \
217   (0 ? (*(pp)) : (g_steal_pointer) (pp))
218 #endif /* __GNUC__ */
219 
220 /* Optimise: avoid the call to the (slower) _n function if we can
221  * determine at compile-time that no overflow happens.
222  */
223 #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
224 #  define _G_NEW(struct_type, n_structs, func) \
<span class="line-modified">225     (struct_type *) (G_GNUC_EXTENSION ({            \</span>
<span class="line-modified">226       gsize __n = (gsize) (n_structs);          \</span>
<span class="line-modified">227       gsize __s = sizeof (struct_type);         \</span>
<span class="line-modified">228       gpointer __p;                     \</span>
<span class="line-modified">229       if (__s == 1)                     \</span>
<span class="line-modified">230         __p = g_##func (__n);               \</span>
<span class="line-modified">231       else if (__builtin_constant_p (__n) &amp;&amp;        \</span>
<span class="line-modified">232                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \</span>
<span class="line-modified">233         __p = g_##func (__n * __s);             \</span>
<span class="line-modified">234       else                          \</span>
<span class="line-modified">235         __p = g_##func##_n (__n, __s);          \</span>
<span class="line-modified">236       __p;                          \</span>
<span class="line-modified">237     }))</span>
238 #  define _G_RENEW(struct_type, mem, n_structs, func) \
<span class="line-modified">239     (struct_type *) (G_GNUC_EXTENSION ({            \</span>
<span class="line-modified">240       gsize __n = (gsize) (n_structs);          \</span>
<span class="line-modified">241       gsize __s = sizeof (struct_type);         \</span>
<span class="line-modified">242       gpointer __p = (gpointer) (mem);          \</span>
<span class="line-modified">243       if (__s == 1)                     \</span>
<span class="line-modified">244         __p = g_##func (__p, __n);              \</span>
<span class="line-modified">245       else if (__builtin_constant_p (__n) &amp;&amp;        \</span>
<span class="line-modified">246                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \</span>
<span class="line-modified">247         __p = g_##func (__p, __n * __s);            \</span>
<span class="line-modified">248       else                          \</span>
<span class="line-modified">249         __p = g_##func##_n (__p, __n, __s);         \</span>
<span class="line-modified">250       __p;                          \</span>
<span class="line-modified">251     }))</span>
252 
253 #else
254 
255 /* Unoptimised version: always call the _n() function. */
256 
257 #define _G_NEW(struct_type, n_structs, func) \
258         ((struct_type *) g_##func##_n ((n_structs), sizeof (struct_type)))
259 #define _G_RENEW(struct_type, mem, n_structs, func) \
260         ((struct_type *) g_##func##_n (mem, (n_structs), sizeof (struct_type)))
261 
262 #endif
263 
264 /**
265  * g_new:
266  * @struct_type: the type of the elements to allocate
267  * @n_structs: the number of elements to allocate
268  *
269  * Allocates @n_structs elements of type @struct_type.
270  * The returned pointer is cast to a pointer to the given type.
271  * If @n_structs is 0 it returns %NULL.
272  * Care is taken to avoid overflow when calculating the size of the allocated block.
273  *
274  * Since the returned pointer is already casted to the right type,
275  * it is normally unnecessary to cast it explicitly, and doing
276  * so might hide memory allocation errors.
277  *
278  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
279  */
<span class="line-modified">280 #define g_new(struct_type, n_structs)           _G_NEW (struct_type, n_structs, malloc)</span>
281 /**
282  * g_new0:
283  * @struct_type: the type of the elements to allocate.
284  * @n_structs: the number of elements to allocate.
285  *
286  * Allocates @n_structs elements of type @struct_type, initialized to 0&#39;s.
287  * The returned pointer is cast to a pointer to the given type.
288  * If @n_structs is 0 it returns %NULL.
289  * Care is taken to avoid overflow when calculating the size of the allocated block.
290  *
291  * Since the returned pointer is already casted to the right type,
292  * it is normally unnecessary to cast it explicitly, and doing
293  * so might hide memory allocation errors.
294  *
295  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
296  */
<span class="line-modified">297 #define g_new0(struct_type, n_structs)          _G_NEW (struct_type, n_structs, malloc0)</span>
298 /**
299  * g_renew:
300  * @struct_type: the type of the elements to allocate
301  * @mem: the currently allocated memory
302  * @n_structs: the number of elements to allocate
303  *
304  * Reallocates the memory pointed to by @mem, so that it now has space for
305  * @n_structs elements of type @struct_type. It returns the new address of
306  * the memory, which may have been moved.
307  * Care is taken to avoid overflow when calculating the size of the allocated block.
308  *
309  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
310  */
<span class="line-modified">311 #define g_renew(struct_type, mem, n_structs)        _G_RENEW (struct_type, mem, n_structs, realloc)</span>
312 /**
313  * g_try_new:
314  * @struct_type: the type of the elements to allocate
315  * @n_structs: the number of elements to allocate
316  *
317  * Attempts to allocate @n_structs elements of type @struct_type, and returns
318  * %NULL on failure. Contrast with g_new(), which aborts the program on failure.
319  * The returned pointer is cast to a pointer to the given type.
320  * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
321  *
322  * Since: 2.8
323  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
324  */
<span class="line-modified">325 #define g_try_new(struct_type, n_structs)       _G_NEW (struct_type, n_structs, try_malloc)</span>
326 /**
327  * g_try_new0:
328  * @struct_type: the type of the elements to allocate
329  * @n_structs: the number of elements to allocate
330  *
331  * Attempts to allocate @n_structs elements of type @struct_type, initialized
332  * to 0&#39;s, and returns %NULL on failure. Contrast with g_new0(), which aborts
333  * the program on failure.
334  * The returned pointer is cast to a pointer to the given type.
335  * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
336  *
337  * Since: 2.8
338  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
339  */
<span class="line-modified">340 #define g_try_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, try_malloc0)</span>
341 /**
342  * g_try_renew:
343  * @struct_type: the type of the elements to allocate
344  * @mem: the currently allocated memory
345  * @n_structs: the number of elements to allocate
346  *
347  * Attempts to reallocate the memory pointed to by @mem, so that it now has
348  * space for @n_structs elements of type @struct_type, and returns %NULL on
349  * failure. Contrast with g_renew(), which aborts the program on failure.
350  * It returns the new address of the memory, which may have been moved.
351  * The function returns %NULL if an overflow occurs.
352  *
353  * Since: 2.8
354  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
355  */
<span class="line-modified">356 #define g_try_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, try_realloc)</span>
357 
358 
359 /* Memory allocation virtualization for debugging purposes
360  * g_mem_set_vtable() has to be the very first GLib function called
361  * if being used
362  */
363 struct _GMemVTable {
364   gpointer (*malloc)      (gsize    n_bytes);
365   gpointer (*realloc)     (gpointer mem,
<span class="line-modified">366                gsize    n_bytes);</span>
367   void     (*free)        (gpointer mem);
368   /* optional; set to NULL if not used ! */
369   gpointer (*calloc)      (gsize    n_blocks,
<span class="line-modified">370                gsize    n_block_bytes);</span>
371   gpointer (*try_malloc)  (gsize    n_bytes);
372   gpointer (*try_realloc) (gpointer mem,
<span class="line-modified">373                gsize    n_bytes);</span>
374 };
375 GLIB_DEPRECATED_IN_2_46
<span class="line-modified">376 void     g_mem_set_vtable (GMemVTable   *vtable);</span>
377 GLIB_DEPRECATED_IN_2_46
378 gboolean g_mem_is_system_malloc (void);
379 
380 GLIB_VAR gboolean g_mem_gc_friendly;
381 
382 /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
383  */
384 GLIB_VAR GMemVTable *glib_mem_profiler_table;
385 GLIB_DEPRECATED_IN_2_46
<span class="line-modified">386 void    g_mem_profile   (void);</span>
387 
388 G_END_DECLS
389 
390 #endif /* __G_MEM_H__ */
</pre>
</td>
<td>
<hr />
<pre>
 41  * @calloc: function to use for allocating zero-filled memory.
 42  * @try_malloc: function to use for allocating memory without a default error handler.
 43  * @try_realloc: function to use for reallocating memory without a default error handler.
 44  *
 45  * A set of functions used to perform memory allocation. The same #GMemVTable must
 46  * be used for all allocations in the same program; a call to g_mem_set_vtable(),
 47  * if it exists, should be prior to any use of GLib.
 48  *
 49  * This functions related to this has been deprecated in 2.46, and no longer work.
 50  */
 51 typedef struct _GMemVTable GMemVTable;
 52 
 53 
 54 #if GLIB_SIZEOF_VOID_P &gt; GLIB_SIZEOF_LONG
 55 /**
 56  * G_MEM_ALIGN:
 57  *
 58  * Indicates the number of bytes to which memory will be aligned on the
 59  * current platform.
 60  */
<span class="line-modified"> 61 #  define G_MEM_ALIGN GLIB_SIZEOF_VOID_P</span>
<span class="line-modified"> 62 #else /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */</span>
<span class="line-modified"> 63 #  define G_MEM_ALIGN GLIB_SIZEOF_LONG</span>
 64 #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
 65 
 66 
 67 /* Memory allocation functions
 68  */
 69 
 70 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 71 void   g_free           (gpointer  mem);</span>
 72 
 73 GLIB_AVAILABLE_IN_2_34
 74 void     g_clear_pointer  (gpointer      *pp,
 75                            GDestroyNotify destroy);
 76 
 77 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 78 gpointer g_malloc         (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 79 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 80 gpointer g_malloc0        (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 81 GLIB_AVAILABLE_IN_ALL
 82 gpointer g_realloc        (gpointer  mem,
<span class="line-modified"> 83          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 84 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 85 gpointer g_try_malloc     (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 86 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 87 gpointer g_try_malloc0    (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 88 GLIB_AVAILABLE_IN_ALL
 89 gpointer g_try_realloc    (gpointer  mem,
<span class="line-modified"> 90          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 91 
 92 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 93 gpointer g_malloc_n       (gsize   n_blocks,</span>
<span class="line-modified"> 94          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 95 GLIB_AVAILABLE_IN_ALL
<span class="line-modified"> 96 gpointer g_malloc0_n      (gsize   n_blocks,</span>
<span class="line-modified"> 97          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 98 GLIB_AVAILABLE_IN_ALL
 99 gpointer g_realloc_n      (gpointer  mem,
<span class="line-modified">100          gsize   n_blocks,</span>
<span class="line-modified">101          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
102 GLIB_AVAILABLE_IN_ALL
<span class="line-modified">103 gpointer g_try_malloc_n   (gsize   n_blocks,</span>
<span class="line-modified">104          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
105 GLIB_AVAILABLE_IN_ALL
<span class="line-modified">106 gpointer g_try_malloc0_n  (gsize   n_blocks,</span>
<span class="line-modified">107          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
108 GLIB_AVAILABLE_IN_ALL
109 gpointer g_try_realloc_n  (gpointer  mem,
<span class="line-modified">110          gsize   n_blocks,</span>
<span class="line-modified">111          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
112 
113 #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
114 #define g_clear_pointer(pp, destroy)                                           \
115   G_STMT_START {                                                               \
116     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
117     __typeof__((pp)) _pp = (pp);                                               \
118     __typeof__(*(pp)) _ptr = *_pp;                                             \
119     *_pp = NULL;                                                               \
120     if (_ptr)                                                                  \
121       (destroy) (_ptr);                                                        \
<span class="line-modified">122   } G_STMT_END                                                                 \</span>
<span class="line-added">123   GLIB_AVAILABLE_MACRO_IN_2_34</span>
124 #else /* __GNUC__ */
125 #define g_clear_pointer(pp, destroy) \
126   G_STMT_START {                                                               \
127     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
128     /* Only one access, please; work around type aliasing */                   \
129     union { char *in; gpointer *out; } _pp;                                    \
130     gpointer _p;                                                               \
131     /* This assignment is needed to avoid a gcc warning */                     \
132     GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
133                                                                                \
134     _pp.in = (char *) (pp);                                                    \
135     _p = *_pp.out;                                                             \
<span class="line-modified">136     if (_p)                        \</span>
<span class="line-modified">137       {                        \</span>
138         *_pp.out = NULL;                                                       \
139         _destroy (_p);                                                         \
140       }                                                                        \
<span class="line-modified">141   } G_STMT_END                                                                 \</span>
<span class="line-added">142   GLIB_AVAILABLE_MACRO_IN_2_34</span>
143 #endif /* __GNUC__ */
144 
145 /**
146  * g_steal_pointer:
147  * @pp: (not nullable): a pointer to a pointer
148  *
149  * Sets @pp to %NULL, returning the value that was there before.
150  *
151  * Conceptually, this transfers the ownership of the pointer from the
152  * referenced variable to the &quot;caller&quot; of the macro (ie: &quot;steals&quot; the
153  * reference).
154  *
155  * The return value will be properly typed, according to the type of
156  * @pp.
157  *
158  * This can be very useful when combined with g_autoptr() to prevent the
159  * return value of a function from being automatically freed.  Consider
160  * the following example (which only works on GCC and clang):
161  *
162  * |[
</pre>
<hr />
<pre>
207   *ptr = NULL;
208 
209   return ref;
210 }
211 
212 /* type safety */
213 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 8)) &amp;&amp; !defined(__cplusplus) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
214 #define g_steal_pointer(pp) ((__typeof__(*pp)) (g_steal_pointer) (pp))
215 #else  /* __GNUC__ */
216 /* This version does not depend on gcc extensions, but gcc does not warn
217  * about incompatible-pointer-types: */
218 #define g_steal_pointer(pp) \
219   (0 ? (*(pp)) : (g_steal_pointer) (pp))
220 #endif /* __GNUC__ */
221 
222 /* Optimise: avoid the call to the (slower) _n function if we can
223  * determine at compile-time that no overflow happens.
224  */
225 #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
226 #  define _G_NEW(struct_type, n_structs, func) \
<span class="line-modified">227   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">228     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">229     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">230     gpointer __p;           \</span>
<span class="line-modified">231     if (__s == 1)           \</span>
<span class="line-modified">232       __p = g_##func (__n);       \</span>
<span class="line-modified">233     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">234              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">235       __p = g_##func (__n * __s);       \</span>
<span class="line-modified">236     else              \</span>
<span class="line-modified">237       __p = g_##func##_n (__n, __s);      \</span>
<span class="line-modified">238     __p;              \</span>
<span class="line-modified">239   }))</span>
240 #  define _G_RENEW(struct_type, mem, n_structs, func) \
<span class="line-modified">241   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">242     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">243     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">244     gpointer __p = (gpointer) (mem);      \</span>
<span class="line-modified">245     if (__s == 1)           \</span>
<span class="line-modified">246       __p = g_##func (__p, __n);        \</span>
<span class="line-modified">247     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">248              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">249       __p = g_##func (__p, __n * __s);      \</span>
<span class="line-modified">250     else              \</span>
<span class="line-modified">251       __p = g_##func##_n (__p, __n, __s);     \</span>
<span class="line-modified">252     __p;              \</span>
<span class="line-modified">253   }))</span>
254 
255 #else
256 
257 /* Unoptimised version: always call the _n() function. */
258 
259 #define _G_NEW(struct_type, n_structs, func) \
260         ((struct_type *) g_##func##_n ((n_structs), sizeof (struct_type)))
261 #define _G_RENEW(struct_type, mem, n_structs, func) \
262         ((struct_type *) g_##func##_n (mem, (n_structs), sizeof (struct_type)))
263 
264 #endif
265 
266 /**
267  * g_new:
268  * @struct_type: the type of the elements to allocate
269  * @n_structs: the number of elements to allocate
270  *
271  * Allocates @n_structs elements of type @struct_type.
272  * The returned pointer is cast to a pointer to the given type.
273  * If @n_structs is 0 it returns %NULL.
274  * Care is taken to avoid overflow when calculating the size of the allocated block.
275  *
276  * Since the returned pointer is already casted to the right type,
277  * it is normally unnecessary to cast it explicitly, and doing
278  * so might hide memory allocation errors.
279  *
280  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
281  */
<span class="line-modified">282 #define g_new(struct_type, n_structs)     _G_NEW (struct_type, n_structs, malloc)</span>
283 /**
284  * g_new0:
285  * @struct_type: the type of the elements to allocate.
286  * @n_structs: the number of elements to allocate.
287  *
288  * Allocates @n_structs elements of type @struct_type, initialized to 0&#39;s.
289  * The returned pointer is cast to a pointer to the given type.
290  * If @n_structs is 0 it returns %NULL.
291  * Care is taken to avoid overflow when calculating the size of the allocated block.
292  *
293  * Since the returned pointer is already casted to the right type,
294  * it is normally unnecessary to cast it explicitly, and doing
295  * so might hide memory allocation errors.
296  *
297  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
298  */
<span class="line-modified">299 #define g_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, malloc0)</span>
300 /**
301  * g_renew:
302  * @struct_type: the type of the elements to allocate
303  * @mem: the currently allocated memory
304  * @n_structs: the number of elements to allocate
305  *
306  * Reallocates the memory pointed to by @mem, so that it now has space for
307  * @n_structs elements of type @struct_type. It returns the new address of
308  * the memory, which may have been moved.
309  * Care is taken to avoid overflow when calculating the size of the allocated block.
310  *
311  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
312  */
<span class="line-modified">313 #define g_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, realloc)</span>
314 /**
315  * g_try_new:
316  * @struct_type: the type of the elements to allocate
317  * @n_structs: the number of elements to allocate
318  *
319  * Attempts to allocate @n_structs elements of type @struct_type, and returns
320  * %NULL on failure. Contrast with g_new(), which aborts the program on failure.
321  * The returned pointer is cast to a pointer to the given type.
322  * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
323  *
324  * Since: 2.8
325  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
326  */
<span class="line-modified">327 #define g_try_new(struct_type, n_structs)   _G_NEW (struct_type, n_structs, try_malloc)</span>
328 /**
329  * g_try_new0:
330  * @struct_type: the type of the elements to allocate
331  * @n_structs: the number of elements to allocate
332  *
333  * Attempts to allocate @n_structs elements of type @struct_type, initialized
334  * to 0&#39;s, and returns %NULL on failure. Contrast with g_new0(), which aborts
335  * the program on failure.
336  * The returned pointer is cast to a pointer to the given type.
337  * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
338  *
339  * Since: 2.8
340  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
341  */
<span class="line-modified">342 #define g_try_new0(struct_type, n_structs)    _G_NEW (struct_type, n_structs, try_malloc0)</span>
343 /**
344  * g_try_renew:
345  * @struct_type: the type of the elements to allocate
346  * @mem: the currently allocated memory
347  * @n_structs: the number of elements to allocate
348  *
349  * Attempts to reallocate the memory pointed to by @mem, so that it now has
350  * space for @n_structs elements of type @struct_type, and returns %NULL on
351  * failure. Contrast with g_renew(), which aborts the program on failure.
352  * It returns the new address of the memory, which may have been moved.
353  * The function returns %NULL if an overflow occurs.
354  *
355  * Since: 2.8
356  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
357  */
<span class="line-modified">358 #define g_try_renew(struct_type, mem, n_structs)  _G_RENEW (struct_type, mem, n_structs, try_realloc)</span>
359 
360 
361 /* Memory allocation virtualization for debugging purposes
362  * g_mem_set_vtable() has to be the very first GLib function called
363  * if being used
364  */
365 struct _GMemVTable {
366   gpointer (*malloc)      (gsize    n_bytes);
367   gpointer (*realloc)     (gpointer mem,
<span class="line-modified">368          gsize    n_bytes);</span>
369   void     (*free)        (gpointer mem);
370   /* optional; set to NULL if not used ! */
371   gpointer (*calloc)      (gsize    n_blocks,
<span class="line-modified">372          gsize    n_block_bytes);</span>
373   gpointer (*try_malloc)  (gsize    n_bytes);
374   gpointer (*try_realloc) (gpointer mem,
<span class="line-modified">375          gsize    n_bytes);</span>
376 };
377 GLIB_DEPRECATED_IN_2_46
<span class="line-modified">378 void   g_mem_set_vtable (GMemVTable *vtable);</span>
379 GLIB_DEPRECATED_IN_2_46
380 gboolean g_mem_is_system_malloc (void);
381 
382 GLIB_VAR gboolean g_mem_gc_friendly;
383 
384 /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
385  */
386 GLIB_VAR GMemVTable *glib_mem_profiler_table;
387 GLIB_DEPRECATED_IN_2_46
<span class="line-modified">388 void  g_mem_profile (void);</span>
389 
390 G_END_DECLS
391 
392 #endif /* __G_MEM_H__ */
</pre>
</td>
</tr>
</table>
<center><a href="gmem.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>