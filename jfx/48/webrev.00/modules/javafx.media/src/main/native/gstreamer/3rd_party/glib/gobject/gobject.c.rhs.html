<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * MT safe with regards to reference counting.
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &lt;string.h&gt;
  25 #include &lt;signal.h&gt;
  26 
  27 #include &quot;gobject.h&quot;
  28 #include &quot;gtype-private.h&quot;
  29 #include &quot;gvaluecollector.h&quot;
  30 #include &quot;gsignal.h&quot;
  31 #include &quot;gparamspecs.h&quot;
  32 #include &quot;gvaluetypes.h&quot;
  33 #include &quot;gobject_trace.h&quot;
  34 #include &quot;gconstructor.h&quot;
  35 
  36 /**
  37  * SECTION:objects
  38  * @title: GObject
  39  * @short_description: The base object type
  40  * @see_also: #GParamSpecObject, g_param_spec_object()
  41  *
  42  * GObject is the fundamental type providing the common attributes and
  43  * methods for all object types in GTK+, Pango and other libraries
  44  * based on GObject.  The GObject class provides methods for object
  45  * construction and destruction, property access methods, and signal
  46  * support.  Signals are described in detail [here][gobject-Signals].
  47  *
  48  * For a tutorial on implementing a new GObject class, see [How to define and
  49  * implement a new GObject][howto-gobject]. For a list of naming conventions for
  50  * GObjects and their methods, see the [GType conventions][gtype-conventions].
  51  * For the high-level concepts behind GObject, read [Instantiable classed types:
  52  * Objects][gtype-instantiable-classed].
  53  *
  54  * ## Floating references # {#floating-ref}
  55  *
<a name="1" id="anc1"></a><span class="line-added">  56  * **Note**: Floating references are a C convenience API and should not be</span>
<span class="line-added">  57  * used in modern GObject code. Language bindings in particular find the</span>
<span class="line-added">  58  * concept highly problematic, as floating references are not identifiable</span>
<span class="line-added">  59  * through annotations, and neither are deviations from the floating reference</span>
<span class="line-added">  60  * behavior, like types that inherit from #GInitiallyUnowned and still return</span>
<span class="line-added">  61  * a full reference from g_object_new().</span>
<span class="line-added">  62  *</span>
  63  * GInitiallyUnowned is derived from GObject. The only difference between
  64  * the two is that the initial reference of a GInitiallyUnowned is flagged
  65  * as a &quot;floating&quot; reference. This means that it is not specifically
  66  * claimed to be &quot;owned&quot; by any code portion. The main motivation for
  67  * providing floating references is C convenience. In particular, it
  68  * allows code to be written as:
  69  * |[&lt;!-- language=&quot;C&quot; --&gt;
  70  * container = create_container ();
  71  * container_add_child (container, create_child());
  72  * ]|
  73  * If container_add_child() calls g_object_ref_sink() on the passed-in child,
  74  * no reference of the newly created child is leaked. Without floating
  75  * references, container_add_child() can only g_object_ref() the new child,
  76  * so to implement this code without reference leaks, it would have to be
  77  * written as:
  78  * |[&lt;!-- language=&quot;C&quot; --&gt;
  79  * Child *child;
  80  * container = create_container ();
  81  * child = create_child ();
  82  * container_add_child (container, child);
  83  * g_object_unref (child);
  84  * ]|
  85  * The floating reference can be converted into an ordinary reference by
  86  * calling g_object_ref_sink(). For already sunken objects (objects that
  87  * don&#39;t have a floating reference anymore), g_object_ref_sink() is equivalent
  88  * to g_object_ref() and returns a new reference.
  89  *
  90  * Since floating references are useful almost exclusively for C convenience,
  91  * language bindings that provide automated reference and memory ownership
  92  * maintenance (such as smart pointers or garbage collection) should not
<a name="2" id="anc2"></a><span class="line-modified">  93  * expose floating references in their API. The best practice for handling</span>
<span class="line-added">  94  * types that have initially floating references is to immediately sink those</span>
<span class="line-added">  95  * references after g_object_new() returns, by checking if the #GType</span>
<span class="line-added">  96  * inherits from #GInitiallyUnowned. For instance:</span>
<span class="line-added">  97  *</span>
<span class="line-added">  98  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added">  99  * GObject *res = g_object_new_with_properties (gtype,</span>
<span class="line-added"> 100  *                                              n_props,</span>
<span class="line-added"> 101  *                                              prop_names,</span>
<span class="line-added"> 102  *                                              prop_values);</span>
<span class="line-added"> 103  *</span>
<span class="line-added"> 104  * // or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))</span>
<span class="line-added"> 105  * if (G_IS_INITIALLY_UNOWNED (res))</span>
<span class="line-added"> 106  *   g_object_ref_sink (res);</span>
<span class="line-added"> 107  *</span>
<span class="line-added"> 108  * return res;</span>
<span class="line-added"> 109  * ]|</span>
 110  *
 111  * Some object implementations may need to save an objects floating state
 112  * across certain code portions (an example is #GtkMenu), to achieve this,
 113  * the following sequence can be used:
 114  *
 115  * |[&lt;!-- language=&quot;C&quot; --&gt;
 116  * // save floating state
 117  * gboolean was_floating = g_object_is_floating (object);
 118  * g_object_ref_sink (object);
 119  * // protected code portion
 120  *
 121  * ...
 122  *
 123  * // restore floating state
 124  * if (was_floating)
 125  *   g_object_force_floating (object);
 126  * else
 127  *   g_object_unref (object); // release previously acquired reference
 128  * ]|
 129  */
 130 
 131 
 132 /* --- macros --- */
<a name="3" id="anc3"></a><span class="line-modified"> 133 #define PARAM_SPEC_PARAM_ID(pspec)    ((pspec)-&gt;param_id)</span>
 134 #define PARAM_SPEC_SET_PARAM_ID(pspec, id)  ((pspec)-&gt;param_id = (id))
 135 
 136 #define OBJECT_HAS_TOGGLE_REF_FLAG 0x1
 137 #define OBJECT_HAS_TOGGLE_REF(object) \
 138     ((g_datalist_get_flags (&amp;(object)-&gt;qdata) &amp; OBJECT_HAS_TOGGLE_REF_FLAG) != 0)
 139 #define OBJECT_FLOATING_FLAG 0x2
 140 
 141 #define CLASS_HAS_PROPS_FLAG 0x1
 142 #define CLASS_HAS_PROPS(class) \
 143     ((class)-&gt;flags &amp; CLASS_HAS_PROPS_FLAG)
 144 #define CLASS_HAS_CUSTOM_CONSTRUCTOR(class) \
 145     ((class)-&gt;constructor != g_object_constructor)
 146 #define CLASS_HAS_CUSTOM_CONSTRUCTED(class) \
 147     ((class)-&gt;constructed != g_object_constructed)
 148 
 149 #define CLASS_HAS_DERIVED_CLASS_FLAG 0x2
 150 #define CLASS_HAS_DERIVED_CLASS(class) \
 151     ((class)-&gt;flags &amp; CLASS_HAS_DERIVED_CLASS_FLAG)
 152 
 153 /* --- signals --- */
 154 enum {
 155   NOTIFY,
 156   LAST_SIGNAL
 157 };
 158 
 159 
 160 /* --- properties --- */
 161 enum {
 162   PROP_NONE
 163 };
 164 
 165 
 166 /* --- prototypes --- */
<a name="4" id="anc4"></a><span class="line-modified"> 167 static void g_object_base_class_init    (GObjectClass *class);</span>
<span class="line-modified"> 168 static void g_object_base_class_finalize    (GObjectClass *class);</span>
<span class="line-modified"> 169 static void g_object_do_class_init      (GObjectClass *class);</span>
<span class="line-modified"> 170 static void g_object_init       (GObject  *object,</span>
<span class="line-modified"> 171                GObjectClass *class);</span>
<span class="line-modified"> 172 static GObject* g_object_constructor      (GType                  type,</span>
<span class="line-modified"> 173                guint                  n_construct_properties,</span>
<span class="line-modified"> 174                GObjectConstructParam *construct_params);</span>
 175 static void     g_object_constructed                    (GObject        *object);
<a name="5" id="anc5"></a><span class="line-modified"> 176 static void g_object_real_dispose     (GObject  *object);</span>
<span class="line-modified"> 177 static void g_object_finalize     (GObject  *object);</span>
<span class="line-modified"> 178 static void g_object_do_set_property    (GObject        *object,</span>
<span class="line-modified"> 179                guint           property_id,</span>
<span class="line-modified"> 180                const GValue   *value,</span>
<span class="line-modified"> 181                GParamSpec     *pspec);</span>
<span class="line-modified"> 182 static void g_object_do_get_property    (GObject        *object,</span>
<span class="line-modified"> 183                guint           property_id,</span>
<span class="line-modified"> 184                GValue         *value,</span>
<span class="line-modified"> 185                GParamSpec     *pspec);</span>
<span class="line-modified"> 186 static void g_value_object_init     (GValue   *value);</span>
<span class="line-modified"> 187 static void g_value_object_free_value   (GValue   *value);</span>
<span class="line-modified"> 188 static void g_value_object_copy_value   (const GValue *src_value,</span>
<span class="line-modified"> 189                GValue   *dest_value);</span>
<span class="line-modified"> 190 static void g_value_object_transform_value    (const GValue *src_value,</span>
<span class="line-modified"> 191                GValue   *dest_value);</span>
 192 static gpointer g_value_object_peek_pointer             (const GValue   *value);
<a name="6" id="anc6"></a><span class="line-modified"> 193 static gchar* g_value_object_collect_value    (GValue   *value,</span>
<span class="line-modified"> 194                guint           n_collect_values,</span>
<span class="line-modified"> 195                GTypeCValue    *collect_values,</span>
<span class="line-modified"> 196                guint           collect_flags);</span>
<span class="line-modified"> 197 static gchar* g_value_object_lcopy_value    (const GValue *value,</span>
<span class="line-modified"> 198                guint           n_collect_values,</span>
<span class="line-modified"> 199                GTypeCValue    *collect_values,</span>
<span class="line-modified"> 200                guint           collect_flags);</span>
<span class="line-modified"> 201 static void g_object_dispatch_properties_changed  (GObject  *object,</span>
<span class="line-modified"> 202                guint     n_pspecs,</span>
<span class="line-modified"> 203                GParamSpec    **pspecs);</span>
 204 static guint               object_floating_flag_handler (GObject        *object,
 205                                                          gint            job);
 206 
 207 static void object_interface_check_properties           (gpointer        check_data,
<a name="7" id="anc7"></a><span class="line-modified"> 208                gpointer        g_iface);</span>
 209 
 210 /* --- typedefs --- */
 211 typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
 212 
 213 struct _GObjectNotifyQueue
 214 {
 215   GSList  *pspecs;
 216   guint16  n_pspecs;
 217   guint16  freeze_count;
 218 };
 219 
 220 /* --- variables --- */
 221 G_LOCK_DEFINE_STATIC (closure_array_mutex);
 222 G_LOCK_DEFINE_STATIC (weak_refs_mutex);
 223 G_LOCK_DEFINE_STATIC (toggle_refs_mutex);
<a name="8" id="anc8"></a><span class="line-modified"> 224 static GQuark             quark_closure_array = 0;</span>
<span class="line-modified"> 225 static GQuark             quark_weak_refs = 0;</span>
<span class="line-modified"> 226 static GQuark             quark_toggle_refs = 0;</span>
 227 static GQuark               quark_notify_queue;
 228 static GQuark               quark_in_construction;
 229 static GParamSpecPool      *pspec_pool = NULL;
<a name="9" id="anc9"></a><span class="line-modified"> 230 static gulong             gobject_signals[LAST_SIGNAL] = { 0, };</span>
 231 static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
 232 /* qdata pointing to GSList&lt;GWeakRef *&gt;, protected by weak_locations_lock */
<a name="10" id="anc10"></a><span class="line-modified"> 233 static GQuark             quark_weak_locations = 0;</span>
 234 static GRWLock              weak_locations_lock;
 235 
 236 G_LOCK_DEFINE_STATIC(notify_lock);
 237 
 238 /* --- functions --- */
 239 static void
 240 g_object_notify_queue_free (gpointer data)
 241 {
 242   GObjectNotifyQueue *nqueue = data;
 243 
 244   g_slist_free (nqueue-&gt;pspecs);
 245   g_slice_free (GObjectNotifyQueue, nqueue);
 246 }
 247 
 248 static GObjectNotifyQueue*
 249 g_object_notify_queue_freeze (GObject  *object,
 250                               gboolean  conditional)
 251 {
 252   GObjectNotifyQueue *nqueue;
 253 
 254   G_LOCK(notify_lock);
 255   nqueue = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_notify_queue);
 256   if (!nqueue)
 257     {
 258       if (conditional)
 259         {
 260           G_UNLOCK(notify_lock);
 261           return NULL;
 262         }
 263 
 264       nqueue = g_slice_new0 (GObjectNotifyQueue);
 265       g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_notify_queue,
 266                                    nqueue, g_object_notify_queue_free);
 267     }
 268 
 269   if (nqueue-&gt;freeze_count &gt;= 65535)
 270     g_critical(&quot;Free queue for %s (%p) is larger than 65535,&quot;
 271                &quot; called g_object_freeze_notify() too often.&quot;
 272                &quot; Forgot to call g_object_thaw_notify() or infinite loop&quot;,
 273                G_OBJECT_TYPE_NAME (object), object);
 274   else
 275     nqueue-&gt;freeze_count++;
 276   G_UNLOCK(notify_lock);
 277 
 278   return nqueue;
 279 }
 280 
 281 static void
 282 g_object_notify_queue_thaw (GObject            *object,
 283                             GObjectNotifyQueue *nqueue)
 284 {
 285   GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
 286   GSList *slist;
 287   guint n_pspecs = 0;
 288 
<a name="11" id="anc11"></a>
 289   g_return_if_fail (g_atomic_int_get(&amp;object-&gt;ref_count) &gt; 0);
 290 
 291   G_LOCK(notify_lock);
 292 
 293   /* Just make sure we never get into some nasty race condition */
 294   if (G_UNLIKELY(nqueue-&gt;freeze_count == 0)) {
 295     G_UNLOCK(notify_lock);
 296     g_warning (&quot;%s: property-changed notification for %s(%p) is not frozen&quot;,
 297                G_STRFUNC, G_OBJECT_TYPE_NAME (object), object);
 298     return;
 299   }
 300 
 301   nqueue-&gt;freeze_count--;
 302   if (nqueue-&gt;freeze_count) {
 303     G_UNLOCK(notify_lock);
 304     return;
 305   }
 306 
 307   pspecs = nqueue-&gt;n_pspecs &gt; 16 ? free_me = g_new (GParamSpec*, nqueue-&gt;n_pspecs) : pspecs_mem;
 308 
 309   for (slist = nqueue-&gt;pspecs; slist; slist = slist-&gt;next)
 310     {
 311       pspecs[n_pspecs++] = slist-&gt;data;
 312     }
 313   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_notify_queue, NULL);
 314 
 315   G_UNLOCK(notify_lock);
 316 
 317   if (n_pspecs)
 318     G_OBJECT_GET_CLASS (object)-&gt;dispatch_properties_changed (object, n_pspecs, pspecs);
 319   g_free (free_me);
 320 }
 321 
 322 static void
 323 g_object_notify_queue_add (GObject            *object,
 324                            GObjectNotifyQueue *nqueue,
 325                            GParamSpec         *pspec)
 326 {
 327   G_LOCK(notify_lock);
 328 
 329   g_assert (nqueue-&gt;n_pspecs &lt; 65535);
 330 
 331   if (g_slist_find (nqueue-&gt;pspecs, pspec) == NULL)
 332     {
 333       nqueue-&gt;pspecs = g_slist_prepend (nqueue-&gt;pspecs, pspec);
 334       nqueue-&gt;n_pspecs++;
 335     }
 336 
 337   G_UNLOCK(notify_lock);
 338 }
 339 
 340 #ifdef  G_ENABLE_DEBUG
 341 G_LOCK_DEFINE_STATIC     (debug_objects);
<a name="12" id="anc12"></a><span class="line-modified"> 342 static guint     debug_objects_count = 0;</span>
<span class="line-modified"> 343 static GHashTable *debug_objects_ht = NULL;</span>
 344 
 345 static void
 346 debug_objects_foreach (gpointer key,
<a name="13" id="anc13"></a><span class="line-modified"> 347            gpointer value,</span>
<span class="line-modified"> 348            gpointer user_data)</span>
 349 {
 350   GObject *object = value;
 351 
 352   g_message (&quot;[%p] stale %s\tref_count=%u&quot;,
<a name="14" id="anc14"></a><span class="line-modified"> 353        object,</span>
<span class="line-modified"> 354        G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified"> 355        object-&gt;ref_count);</span>
 356 }
 357 
 358 #ifdef G_HAS_CONSTRUCTORS
 359 #ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA
 360 #pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(debug_objects_atexit)
 361 #endif
 362 G_DEFINE_DESTRUCTOR(debug_objects_atexit)
 363 #endif /* G_HAS_CONSTRUCTORS */
 364 
 365 static void
 366 debug_objects_atexit (void)
 367 {
 368   GOBJECT_IF_DEBUG (OBJECTS,
 369     {
 370       G_LOCK (debug_objects);
 371       g_message (&quot;stale GObjects: %u&quot;, debug_objects_count);
 372       g_hash_table_foreach (debug_objects_ht, debug_objects_foreach, NULL);
 373       G_UNLOCK (debug_objects);
 374     });
 375 }
 376 #endif  /* G_ENABLE_DEBUG */
 377 
 378 void
 379 _g_object_type_init (void)
 380 {
 381   static gboolean initialized = FALSE;
 382   static const GTypeFundamentalInfo finfo = {
 383     G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE,
 384   };
 385   GTypeInfo info = {
 386     sizeof (GObjectClass),
 387     (GBaseInitFunc) g_object_base_class_init,
 388     (GBaseFinalizeFunc) g_object_base_class_finalize,
 389     (GClassInitFunc) g_object_do_class_init,
<a name="15" id="anc15"></a><span class="line-modified"> 390     NULL  /* class_destroy */,</span>
<span class="line-modified"> 391     NULL  /* class_data */,</span>
 392     sizeof (GObject),
<a name="16" id="anc16"></a><span class="line-modified"> 393     0   /* n_preallocs */,</span>
 394     (GInstanceInitFunc) g_object_init,
<a name="17" id="anc17"></a><span class="line-modified"> 395     NULL, /* value_table */</span>
 396   };
 397   static const GTypeValueTable value_table = {
<a name="18" id="anc18"></a><span class="line-modified"> 398     g_value_object_init,    /* value_init */</span>
 399     g_value_object_free_value,    /* value_free */
 400     g_value_object_copy_value,    /* value_copy */
 401     g_value_object_peek_pointer,  /* value_peek_pointer */
<a name="19" id="anc19"></a><span class="line-modified"> 402     &quot;p&quot;,        /* collect_format */</span>
 403     g_value_object_collect_value, /* collect_value */
<a name="20" id="anc20"></a><span class="line-modified"> 404     &quot;p&quot;,        /* lcopy_format */</span>
 405     g_value_object_lcopy_value,   /* lcopy_value */
 406   };
<a name="21" id="anc21"></a><span class="line-modified"> 407   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
 408 
 409   g_return_if_fail (initialized == FALSE);
 410   initialized = TRUE;
 411 
 412   /* G_TYPE_OBJECT
 413    */
 414   info.value_table = &amp;value_table;
 415   type = g_type_register_fundamental (G_TYPE_OBJECT, g_intern_static_string (&quot;GObject&quot;), &amp;info, &amp;finfo, 0);
 416   g_assert (type == G_TYPE_OBJECT);
 417   g_value_register_transform_func (G_TYPE_OBJECT, G_TYPE_OBJECT, g_value_object_transform_value);
 418 
 419 #if G_ENABLE_DEBUG
 420   /* We cannot use GOBJECT_IF_DEBUG here because of the G_HAS_CONSTRUCTORS
 421    * conditional in between, as the C spec leaves conditionals inside macro
 422    * expansions as undefined behavior. Only GCC and Clang are known to work
 423    * but compilation breaks on MSVC.
 424    *
 425    * See: https://bugzilla.gnome.org/show_bug.cgi?id=769504
 426    */
 427   if (_g_type_debug_flags &amp; G_TYPE_DEBUG_OBJECTS) \
 428     {
 429       debug_objects_ht = g_hash_table_new (g_direct_hash, NULL);
 430 # ifndef G_HAS_CONSTRUCTORS
 431       g_atexit (debug_objects_atexit);
 432 # endif /* G_HAS_CONSTRUCTORS */
 433     }
 434 #endif /* G_ENABLE_DEBUG */
 435 }
 436 
 437 static void
 438 g_object_base_class_init (GObjectClass *class)
 439 {
 440   GObjectClass *pclass = g_type_class_peek_parent (class);
 441 
 442   /* Don&#39;t inherit HAS_DERIVED_CLASS flag from parent class */
 443   class-&gt;flags &amp;= ~CLASS_HAS_DERIVED_CLASS_FLAG;
 444 
 445   if (pclass)
 446     pclass-&gt;flags |= CLASS_HAS_DERIVED_CLASS_FLAG;
 447 
 448   /* reset instance specific fields and methods that don&#39;t get inherited */
 449   class-&gt;construct_properties = pclass ? g_slist_copy (pclass-&gt;construct_properties) : NULL;
 450   class-&gt;get_property = NULL;
 451   class-&gt;set_property = NULL;
 452 }
 453 
 454 static void
 455 g_object_base_class_finalize (GObjectClass *class)
 456 {
 457   GList *list, *node;
 458 
 459   _g_signals_destroy (G_OBJECT_CLASS_TYPE (class));
 460 
 461   g_slist_free (class-&gt;construct_properties);
 462   class-&gt;construct_properties = NULL;
 463   list = g_param_spec_pool_list_owned (pspec_pool, G_OBJECT_CLASS_TYPE (class));
 464   for (node = list; node; node = node-&gt;next)
 465     {
 466       GParamSpec *pspec = node-&gt;data;
 467 
 468       g_param_spec_pool_remove (pspec_pool, pspec);
 469       PARAM_SPEC_SET_PARAM_ID (pspec, 0);
 470       g_param_spec_unref (pspec);
 471     }
 472   g_list_free (list);
 473 }
 474 
 475 static void
 476 g_object_do_class_init (GObjectClass *class)
 477 {
 478   /* read the comment about typedef struct CArray; on why not to change this quark */
 479   quark_closure_array = g_quark_from_static_string (&quot;GObject-closure-array&quot;);
 480 
 481   quark_weak_refs = g_quark_from_static_string (&quot;GObject-weak-references&quot;);
 482   quark_weak_locations = g_quark_from_static_string (&quot;GObject-weak-locations&quot;);
 483   quark_toggle_refs = g_quark_from_static_string (&quot;GObject-toggle-references&quot;);
 484   quark_notify_queue = g_quark_from_static_string (&quot;GObject-notify-queue&quot;);
 485   quark_in_construction = g_quark_from_static_string (&quot;GObject-in-construction&quot;);
 486   pspec_pool = g_param_spec_pool_new (TRUE);
 487 
 488   class-&gt;constructor = g_object_constructor;
 489   class-&gt;constructed = g_object_constructed;
 490   class-&gt;set_property = g_object_do_set_property;
 491   class-&gt;get_property = g_object_do_get_property;
 492   class-&gt;dispose = g_object_real_dispose;
 493   class-&gt;finalize = g_object_finalize;
 494   class-&gt;dispatch_properties_changed = g_object_dispatch_properties_changed;
 495   class-&gt;notify = NULL;
 496 
 497   /**
 498    * GObject::notify:
 499    * @gobject: the object which received the signal.
 500    * @pspec: the #GParamSpec of the property which changed.
 501    *
 502    * The notify signal is emitted on an object when one of its properties has
 503    * its value set through g_object_set_property(), g_object_set(), et al.
 504    *
 505    * Note that getting this signal doesn&#39;t itself guarantee that the value of
 506    * the property has actually changed. When it is emitted is determined by the
 507    * derived GObject class. If the implementor did not create the property with
 508    * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
 509    * in ::notify being emitted, even if the new value is the same as the old.
 510    * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
 511    * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
 512    * and common practice is to do that only when the value has actually changed.
 513    *
 514    * This signal is typically used to obtain change notification for a
 515    * single property, by specifying the property name as a detail in the
 516    * g_signal_connect() call, like this:
 517    * |[&lt;!-- language=&quot;C&quot; --&gt;
 518    * g_signal_connect (text_view-&gt;buffer, &quot;notify::paste-target-list&quot;,
 519    *                   G_CALLBACK (gtk_text_view_target_list_notify),
 520    *                   text_view)
 521    * ]|
 522    * It is important to note that you must use
 523    * [canonical parameter names][canonical-parameter-names] as
 524    * detail strings for the notify signal.
 525    */
 526   gobject_signals[NOTIFY] =
 527     g_signal_new (g_intern_static_string (&quot;notify&quot;),
<a name="22" id="anc22"></a><span class="line-modified"> 528       G_TYPE_FROM_CLASS (class),</span>
<span class="line-modified"> 529       G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,</span>
<span class="line-modified"> 530       G_STRUCT_OFFSET (GObjectClass, notify),</span>
<span class="line-modified"> 531       NULL, NULL,</span>
<span class="line-modified"> 532       NULL,</span>
<span class="line-modified"> 533       G_TYPE_NONE,</span>
<span class="line-modified"> 534       1, G_TYPE_PARAM);</span>
 535 
 536   /* Install a check function that we&#39;ll use to verify that classes that
 537    * implement an interface implement all properties for that interface
 538    */
 539   g_type_add_interface_check (NULL, object_interface_check_properties);
 540 }
 541 
 542 static inline gboolean
 543 install_property_internal (GType       g_type,
<a name="23" id="anc23"></a><span class="line-modified"> 544          guint       property_id,</span>
<span class="line-modified"> 545          GParamSpec *pspec)</span>
 546 {
 547   if (g_param_spec_pool_lookup (pspec_pool, pspec-&gt;name, g_type, FALSE))
 548     {
 549       g_warning (&quot;When installing property: type &#39;%s&#39; already has a property named &#39;%s&#39;&quot;,
<a name="24" id="anc24"></a><span class="line-modified"> 550      g_type_name (g_type),</span>
<span class="line-modified"> 551      pspec-&gt;name);</span>
 552       return FALSE;
 553     }
 554 
 555   g_param_spec_ref_sink (pspec);
 556   PARAM_SPEC_SET_PARAM_ID (pspec, property_id);
 557   g_param_spec_pool_insert (pspec_pool, pspec, g_type);
 558   return TRUE;
 559 }
 560 
 561 static gboolean
 562 validate_pspec_to_install (GParamSpec *pspec)
 563 {
 564   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
<a name="25" id="anc25"></a><span class="line-modified"> 565   g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE); /* paranoid */</span>
 566 
 567   g_return_val_if_fail (pspec-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);
 568 
 569   if (pspec-&gt;flags &amp; G_PARAM_CONSTRUCT)
 570     g_return_val_if_fail ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) == 0, FALSE);
 571 
 572   if (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
 573     g_return_val_if_fail (pspec-&gt;flags &amp; G_PARAM_WRITABLE, FALSE);
 574 
 575   return TRUE;
 576 }
 577 
 578 static gboolean
 579 validate_and_install_class_property (GObjectClass *class,
 580                                      GType         oclass_type,
 581                                      GType         parent_type,
 582                                      guint         property_id,
 583                                      GParamSpec   *pspec)
 584 {
 585   if (!validate_pspec_to_install (pspec))
 586     return FALSE;
 587 
 588   if (pspec-&gt;flags &amp; G_PARAM_WRITABLE)
 589     g_return_val_if_fail (class-&gt;set_property != NULL, FALSE);
 590   if (pspec-&gt;flags &amp; G_PARAM_READABLE)
 591     g_return_val_if_fail (class-&gt;get_property != NULL, FALSE);
 592 
 593   class-&gt;flags |= CLASS_HAS_PROPS_FLAG;
 594   if (install_property_internal (oclass_type, property_id, pspec))
 595     {
 596       if (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
 597         class-&gt;construct_properties = g_slist_append (class-&gt;construct_properties, pspec);
 598 
 599       /* for property overrides of construct properties, we have to get rid
 600        * of the overidden inherited construct property
 601        */
 602       pspec = g_param_spec_pool_lookup (pspec_pool, pspec-&gt;name, parent_type, TRUE);
 603       if (pspec &amp;&amp; pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
 604         class-&gt;construct_properties = g_slist_remove (class-&gt;construct_properties, pspec);
 605 
 606       return TRUE;
 607     }
 608   else
 609     return FALSE;
 610 }
 611 
 612 /**
 613  * g_object_class_install_property:
 614  * @oclass: a #GObjectClass
 615  * @property_id: the id for the new property
 616  * @pspec: the #GParamSpec for the new property
 617  *
 618  * Installs a new property.
 619  *
 620  * All properties should be installed during the class initializer.  It
 621  * is possible to install properties after that, but doing so is not
 622  * recommend, and specifically, is not guaranteed to be thread-safe vs.
 623  * use of properties on the same type on other threads.
 624  *
 625  * Note that it is possible to redefine a property in a derived class,
 626  * by installing a property with the same name. This can be useful at times,
 627  * e.g. to change the range of allowed values or the default value.
 628  */
 629 void
 630 g_object_class_install_property (GObjectClass *class,
<a name="26" id="anc26"></a><span class="line-modified"> 631          guint         property_id,</span>
<span class="line-modified"> 632          GParamSpec   *pspec)</span>
 633 {
 634   GType oclass_type, parent_type;
 635 
 636   g_return_if_fail (G_IS_OBJECT_CLASS (class));
 637   g_return_if_fail (property_id &gt; 0);
 638 
 639   oclass_type = G_OBJECT_CLASS_TYPE (class);
 640   parent_type = g_type_parent (oclass_type);
 641 
 642   if (CLASS_HAS_DERIVED_CLASS (class))
 643     g_error (&quot;Attempt to add property %s::%s to class after it was derived&quot;, G_OBJECT_CLASS_NAME (class), pspec-&gt;name);
 644 
 645   (void) validate_and_install_class_property (class,
 646                                               oclass_type,
 647                                               parent_type,
 648                                               property_id,
 649                                               pspec);
 650 }
 651 
 652 /**
 653  * g_object_class_install_properties:
 654  * @oclass: a #GObjectClass
 655  * @n_pspecs: the length of the #GParamSpecs array
 656  * @pspecs: (array length=n_pspecs): the #GParamSpecs array
 657  *   defining the new properties
 658  *
 659  * Installs new properties from an array of #GParamSpecs.
 660  *
 661  * All properties should be installed during the class initializer.  It
 662  * is possible to install properties after that, but doing so is not
 663  * recommend, and specifically, is not guaranteed to be thread-safe vs.
 664  * use of properties on the same type on other threads.
 665  *
 666  * The property id of each property is the index of each #GParamSpec in
 667  * the @pspecs array.
 668  *
 669  * The property id of 0 is treated specially by #GObject and it should not
 670  * be used to store a #GParamSpec.
 671  *
 672  * This function should be used if you plan to use a static array of
 673  * #GParamSpecs and g_object_notify_by_pspec(). For instance, this
 674  * class initialization:
 675  *
 676  * |[&lt;!-- language=&quot;C&quot; --&gt;
 677  * enum {
 678  *   PROP_0, PROP_FOO, PROP_BAR, N_PROPERTIES
 679  * };
 680  *
 681  * static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };
 682  *
 683  * static void
 684  * my_object_class_init (MyObjectClass *klass)
 685  * {
 686  *   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 687  *
 688  *   obj_properties[PROP_FOO] =
 689  *     g_param_spec_int (&quot;foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;,
 690  *                       -1, G_MAXINT,
 691  *                       0,
 692  *                       G_PARAM_READWRITE);
 693  *
 694  *   obj_properties[PROP_BAR] =
 695  *     g_param_spec_string (&quot;bar&quot;, &quot;Bar&quot;, &quot;Bar&quot;,
 696  *                          NULL,
 697  *                          G_PARAM_READWRITE);
 698  *
 699  *   gobject_class-&gt;set_property = my_object_set_property;
 700  *   gobject_class-&gt;get_property = my_object_get_property;
 701  *   g_object_class_install_properties (gobject_class,
 702  *                                      N_PROPERTIES,
 703  *                                      obj_properties);
 704  * }
 705  * ]|
 706  *
 707  * allows calling g_object_notify_by_pspec() to notify of property changes:
 708  *
 709  * |[&lt;!-- language=&quot;C&quot; --&gt;
 710  * void
 711  * my_object_set_foo (MyObject *self, gint foo)
 712  * {
 713  *   if (self-&gt;foo != foo)
 714  *     {
 715  *       self-&gt;foo = foo;
 716  *       g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
 717  *     }
 718  *  }
 719  * ]|
 720  *
 721  * Since: 2.26
 722  */
 723 void
 724 g_object_class_install_properties (GObjectClass  *oclass,
 725                                    guint          n_pspecs,
 726                                    GParamSpec   **pspecs)
 727 {
 728   GType oclass_type, parent_type;
 729   gint i;
 730 
 731   g_return_if_fail (G_IS_OBJECT_CLASS (oclass));
 732   g_return_if_fail (n_pspecs &gt; 1);
 733   g_return_if_fail (pspecs[0] == NULL);
 734 
 735   if (CLASS_HAS_DERIVED_CLASS (oclass))
 736     g_error (&quot;Attempt to add properties to %s after it was derived&quot;,
 737              G_OBJECT_CLASS_NAME (oclass));
 738 
 739   oclass_type = G_OBJECT_CLASS_TYPE (oclass);
 740   parent_type = g_type_parent (oclass_type);
 741 
 742   /* we skip the first element of the array as it would have a 0 prop_id */
 743   for (i = 1; i &lt; n_pspecs; i++)
 744     {
 745       GParamSpec *pspec = pspecs[i];
 746 
 747       if (!validate_and_install_class_property (oclass,
 748                                                 oclass_type,
 749                                                 parent_type,
 750                                                 i,
 751                                                 pspec))
 752         {
 753           break;
 754         }
 755     }
 756 }
 757 
 758 /**
 759  * g_object_interface_install_property:
 760  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 761  *    interface, or the default
 762  *  vtable for the interface.
 763  * @pspec: the #GParamSpec for the new property
 764  *
 765  * Add a property to an interface; this is only useful for interfaces
 766  * that are added to GObject-derived types. Adding a property to an
 767  * interface forces all objects classes with that interface to have a
 768  * compatible property. The compatible property could be a newly
 769  * created #GParamSpec, but normally
 770  * g_object_class_override_property() will be used so that the object
 771  * class only needs to provide an implementation and inherits the
 772  * property description, default value, bounds, and so forth from the
 773  * interface property.
 774  *
 775  * This function is meant to be called from the interface&#39;s default
 776  * vtable initialization function (the @class_init member of
 777  * #GTypeInfo.) It must not be called after after @class_init has
 778  * been called for any object types implementing this interface.
 779  *
 780  * If @pspec is a floating reference, it will be consumed.
 781  *
 782  * Since: 2.4
 783  */
 784 void
 785 g_object_interface_install_property (gpointer      g_iface,
<a name="27" id="anc27"></a><span class="line-modified"> 786              GParamSpec   *pspec)</span>
 787 {
 788   GTypeInterface *iface_class = g_iface;
 789 
 790   g_return_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type));
 791   g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
 792 
 793   if (!validate_pspec_to_install (pspec))
 794     return;
 795 
 796   (void) install_property_internal (iface_class-&gt;g_type, 0, pspec);
 797 }
 798 
 799 /**
 800  * g_object_class_find_property:
 801  * @oclass: a #GObjectClass
 802  * @property_name: the name of the property to look up
 803  *
 804  * Looks up the #GParamSpec for a property of a class.
 805  *
 806  * Returns: (transfer none): the #GParamSpec for the property, or
 807  *          %NULL if the class doesn&#39;t have a property of that name
 808  */
 809 GParamSpec*
 810 g_object_class_find_property (GObjectClass *class,
<a name="28" id="anc28"></a><span class="line-modified"> 811             const gchar  *property_name)</span>
 812 {
 813   GParamSpec *pspec;
 814   GParamSpec *redirect;
 815 
 816   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 817   g_return_val_if_fail (property_name != NULL, NULL);
 818 
 819   pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="29" id="anc29"></a><span class="line-modified"> 820             property_name,</span>
<span class="line-modified"> 821             G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 822             TRUE);</span>
 823   if (pspec)
 824     {
 825       redirect = g_param_spec_get_redirect_target (pspec);
 826       if (redirect)
<a name="30" id="anc30"></a><span class="line-modified"> 827   return redirect;</span>
 828       else
<a name="31" id="anc31"></a><span class="line-modified"> 829   return pspec;</span>
 830     }
 831   else
 832     return NULL;
 833 }
 834 
 835 /**
 836  * g_object_interface_find_property:
 837  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 838  *  interface, or the default vtable for the interface
<a name="32" id="anc32"></a><span class="line-modified"> 839  * @property_name: name of a property to look up.</span>
 840  *
 841  * Find the #GParamSpec with the given name for an
 842  * interface. Generally, the interface vtable passed in as @g_iface
 843  * will be the default vtable from g_type_default_interface_ref(), or,
 844  * if you know the interface has already been loaded,
 845  * g_type_default_interface_peek().
 846  *
 847  * Since: 2.4
 848  *
 849  * Returns: (transfer none): the #GParamSpec for the property of the
 850  *          interface with the name @property_name, or %NULL if no
 851  *          such property exists.
 852  */
 853 GParamSpec*
 854 g_object_interface_find_property (gpointer      g_iface,
<a name="33" id="anc33"></a><span class="line-modified"> 855           const gchar  *property_name)</span>
 856 {
 857   GTypeInterface *iface_class = g_iface;
 858 
 859   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
 860   g_return_val_if_fail (property_name != NULL, NULL);
 861 
 862   return g_param_spec_pool_lookup (pspec_pool,
<a name="34" id="anc34"></a><span class="line-modified"> 863            property_name,</span>
<span class="line-modified"> 864            iface_class-&gt;g_type,</span>
<span class="line-modified"> 865            FALSE);</span>
 866 }
 867 
 868 /**
 869  * g_object_class_override_property:
 870  * @oclass: a #GObjectClass
 871  * @property_id: the new property ID
 872  * @name: the name of a property registered in a parent class or
 873  *  in an interface of this class.
 874  *
 875  * Registers @property_id as referring to a property with the name
 876  * @name in a parent class or in an interface implemented by @oclass.
 877  * This allows this class to &quot;override&quot; a property implementation in
 878  * a parent class or to provide the implementation of a property from
 879  * an interface.
 880  *
 881  * Internally, overriding is implemented by creating a property of type
 882  * #GParamSpecOverride; generally operations that query the properties of
 883  * the object class, such as g_object_class_find_property() or
 884  * g_object_class_list_properties() will return the overridden
 885  * property. However, in one case, the @construct_properties argument of
 886  * the @constructor virtual function, the #GParamSpecOverride is passed
 887  * instead, so that the @param_id field of the #GParamSpec will be
 888  * correct.  For virtually all uses, this makes no difference. If you
 889  * need to get the overridden property, you can call
 890  * g_param_spec_get_redirect_target().
 891  *
 892  * Since: 2.4
 893  */
 894 void
 895 g_object_class_override_property (GObjectClass *oclass,
<a name="35" id="anc35"></a><span class="line-modified"> 896           guint         property_id,</span>
<span class="line-modified"> 897           const gchar  *name)</span>
 898 {
 899   GParamSpec *overridden = NULL;
 900   GParamSpec *new;
 901   GType parent_type;
 902 
 903   g_return_if_fail (G_IS_OBJECT_CLASS (oclass));
 904   g_return_if_fail (property_id &gt; 0);
 905   g_return_if_fail (name != NULL);
 906 
 907   /* Find the overridden property; first check parent types
 908    */
 909   parent_type = g_type_parent (G_OBJECT_CLASS_TYPE (oclass));
 910   if (parent_type != G_TYPE_NONE)
 911     overridden = g_param_spec_pool_lookup (pspec_pool,
<a name="36" id="anc36"></a><span class="line-modified"> 912              name,</span>
<span class="line-modified"> 913              parent_type,</span>
<span class="line-modified"> 914              TRUE);</span>
 915   if (!overridden)
 916     {
 917       GType *ifaces;
 918       guint n_ifaces;
 919 
 920       /* Now check interfaces
 921        */
 922       ifaces = g_type_interfaces (G_OBJECT_CLASS_TYPE (oclass), &amp;n_ifaces);
 923       while (n_ifaces-- &amp;&amp; !overridden)
<a name="37" id="anc37"></a><span class="line-modified"> 924   {</span>
<span class="line-modified"> 925     overridden = g_param_spec_pool_lookup (pspec_pool,</span>
<span class="line-modified"> 926              name,</span>
<span class="line-modified"> 927              ifaces[n_ifaces],</span>
<span class="line-modified"> 928              FALSE);</span>
<span class="line-modified"> 929   }</span>
 930 
 931       g_free (ifaces);
 932     }
 933 
 934   if (!overridden)
 935     {
 936       g_warning (&quot;%s: Can&#39;t find property to override for &#39;%s::%s&#39;&quot;,
<a name="38" id="anc38"></a><span class="line-modified"> 937      G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);</span>
 938       return;
 939     }
 940 
 941   new = g_param_spec_override (name, overridden);
 942   g_object_class_install_property (oclass, property_id, new);
 943 }
 944 
 945 /**
 946  * g_object_class_list_properties:
 947  * @oclass: a #GObjectClass
 948  * @n_properties: (out): return location for the length of the returned array
 949  *
 950  * Get an array of #GParamSpec* for all properties of a class.
 951  *
 952  * Returns: (array length=n_properties) (transfer container): an array of
 953  *          #GParamSpec* which should be freed after use
 954  */
 955 GParamSpec** /* free result */
 956 g_object_class_list_properties (GObjectClass *class,
<a name="39" id="anc39"></a><span class="line-modified"> 957         guint        *n_properties_p)</span>
 958 {
 959   GParamSpec **pspecs;
 960   guint n;
 961 
 962   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 963 
 964   pspecs = g_param_spec_pool_list (pspec_pool,
<a name="40" id="anc40"></a><span class="line-modified"> 965            G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 966            &amp;n);</span>
 967   if (n_properties_p)
 968     *n_properties_p = n;
 969 
 970   return pspecs;
 971 }
 972 
 973 /**
 974  * g_object_interface_list_properties:
 975  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 976  *  interface, or the default vtable for the interface
 977  * @n_properties_p: (out): location to store number of properties returned.
 978  *
 979  * Lists the properties of an interface.Generally, the interface
 980  * vtable passed in as @g_iface will be the default vtable from
 981  * g_type_default_interface_ref(), or, if you know the interface has
 982  * already been loaded, g_type_default_interface_peek().
 983  *
 984  * Since: 2.4
 985  *
 986  * Returns: (array length=n_properties_p) (transfer container): a
 987  *          pointer to an array of pointers to #GParamSpec
 988  *          structures. The paramspecs are owned by GLib, but the
 989  *          array should be freed with g_free() when you are done with
 990  *          it.
 991  */
 992 GParamSpec**
 993 g_object_interface_list_properties (gpointer      g_iface,
<a name="41" id="anc41"></a><span class="line-modified"> 994             guint        *n_properties_p)</span>
 995 {
 996   GTypeInterface *iface_class = g_iface;
 997   GParamSpec **pspecs;
 998   guint n;
 999 
1000   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
1001 
1002   pspecs = g_param_spec_pool_list (pspec_pool,
<a name="42" id="anc42"></a><span class="line-modified">1003            iface_class-&gt;g_type,</span>
<span class="line-modified">1004            &amp;n);</span>
1005   if (n_properties_p)
1006     *n_properties_p = n;
1007 
1008   return pspecs;
1009 }
1010 
1011 static inline gboolean
1012 object_in_construction (GObject *object)
1013 {
1014   return g_datalist_id_get_data (&amp;object-&gt;qdata, quark_in_construction) != NULL;
1015 }
1016 
1017 static void
<a name="43" id="anc43"></a><span class="line-modified">1018 g_object_init (GObject    *object,</span>
<span class="line-modified">1019          GObjectClass *class)</span>
1020 {
1021   object-&gt;ref_count = 1;
1022   object-&gt;qdata = NULL;
1023 
1024   if (CLASS_HAS_PROPS (class))
1025     {
1026       /* freeze object&#39;s notification queue, g_object_newv() preserves pairedness */
1027       g_object_notify_queue_freeze (object, FALSE);
1028     }
1029 
1030   if (CLASS_HAS_CUSTOM_CONSTRUCTOR (class))
1031     {
1032       /* mark object in-construction for notify_queue_thaw() and to allow construct-only properties */
1033       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_in_construction, object);
1034     }
1035 
1036   GOBJECT_IF_DEBUG (OBJECTS,
1037     {
1038       G_LOCK (debug_objects);
1039       debug_objects_count++;
1040       g_hash_table_add (debug_objects_ht, object);
1041       G_UNLOCK (debug_objects);
1042     });
1043 }
1044 
1045 static void
1046 g_object_do_set_property (GObject      *object,
<a name="44" id="anc44"></a><span class="line-modified">1047         guint         property_id,</span>
<span class="line-modified">1048         const GValue *value,</span>
<span class="line-modified">1049         GParamSpec   *pspec)</span>
1050 {
1051   switch (property_id)
1052     {
1053     default:
1054       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1055       break;
1056     }
1057 }
1058 
1059 static void
1060 g_object_do_get_property (GObject     *object,
<a name="45" id="anc45"></a><span class="line-modified">1061         guint        property_id,</span>
<span class="line-modified">1062         GValue      *value,</span>
<span class="line-modified">1063         GParamSpec  *pspec)</span>
1064 {
1065   switch (property_id)
1066     {
1067     default:
1068       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1069       break;
1070     }
1071 }
1072 
1073 static void
1074 g_object_real_dispose (GObject *object)
1075 {
1076   g_signal_handlers_destroy (object);
1077   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
1078   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
1079 }
1080 
1081 static void
1082 g_object_finalize (GObject *object)
1083 {
1084   if (object_in_construction (object))
1085     {
1086       g_critical (&quot;object %s %p finalized while still in-construction&quot;,
1087                   G_OBJECT_TYPE_NAME (object), object);
1088     }
1089 
1090   g_datalist_clear (&amp;object-&gt;qdata);
1091 
1092   GOBJECT_IF_DEBUG (OBJECTS,
1093     {
1094       G_LOCK (debug_objects);
1095       g_assert (g_hash_table_contains (debug_objects_ht, object));
1096       g_hash_table_remove (debug_objects_ht, object);
1097       debug_objects_count--;
1098       G_UNLOCK (debug_objects);
1099     });
1100 }
1101 
1102 static void
1103 g_object_dispatch_properties_changed (GObject     *object,
<a name="46" id="anc46"></a><span class="line-modified">1104               guint        n_pspecs,</span>
<span class="line-modified">1105               GParamSpec **pspecs)</span>
1106 {
1107   guint i;
1108 
1109   for (i = 0; i &lt; n_pspecs; i++)
1110     g_signal_emit (object, gobject_signals[NOTIFY], g_param_spec_get_name_quark (pspecs[i]), pspecs[i]);
1111 }
1112 
1113 /**
1114  * g_object_run_dispose:
1115  * @object: a #GObject
1116  *
1117  * Releases all references to other objects. This can be used to break
1118  * reference cycles.
1119  *
1120  * This function should only be called from object system implementations.
1121  */
1122 void
1123 g_object_run_dispose (GObject *object)
1124 {
1125   g_return_if_fail (G_IS_OBJECT (object));
<a name="47" id="anc47"></a><span class="line-modified">1126   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0);</span>
1127 
1128   g_object_ref (object);
1129   TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 0));
1130   G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
1131   TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 0));
1132   g_object_unref (object);
1133 }
1134 
1135 /**
1136  * g_object_freeze_notify:
1137  * @object: a #GObject
1138  *
1139  * Increases the freeze count on @object. If the freeze count is
1140  * non-zero, the emission of &quot;notify&quot; signals on @object is
1141  * stopped. The signals are queued until the freeze count is decreased
1142  * to zero. Duplicate notifications are squashed so that at most one
1143  * #GObject::notify signal is emitted for each property modified while the
1144  * object is frozen.
1145  *
1146  * This is necessary for accessors that modify multiple properties to prevent
1147  * premature notification while the object is still being modified.
1148  */
1149 void
1150 g_object_freeze_notify (GObject *object)
1151 {
1152   g_return_if_fail (G_IS_OBJECT (object));
1153 
1154   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1155     return;
1156 
1157   g_object_ref (object);
1158   g_object_notify_queue_freeze (object, FALSE);
1159   g_object_unref (object);
1160 }
1161 
1162 static GParamSpec *
1163 get_notify_pspec (GParamSpec *pspec)
1164 {
1165   GParamSpec *redirected;
1166 
1167   /* we don&#39;t notify on non-READABLE parameters */
1168   if (~pspec-&gt;flags &amp; G_PARAM_READABLE)
1169     return NULL;
1170 
1171   /* if the paramspec is redirected, notify on the target */
1172   redirected = g_param_spec_get_redirect_target (pspec);
1173   if (redirected != NULL)
1174     return redirected;
1175 
1176   /* else, notify normally */
1177   return pspec;
1178 }
1179 
1180 static inline void
1181 g_object_notify_by_spec_internal (GObject    *object,
<a name="48" id="anc48"></a><span class="line-modified">1182           GParamSpec *pspec)</span>
1183 {
1184   GParamSpec *notify_pspec;
1185 
1186   notify_pspec = get_notify_pspec (pspec);
1187 
1188   if (notify_pspec != NULL)
1189     {
1190       GObjectNotifyQueue *nqueue;
1191 
1192       /* conditional freeze: only increase freeze count if already frozen */
1193       nqueue = g_object_notify_queue_freeze (object, TRUE);
1194 
1195       if (nqueue != NULL)
1196         {
1197           /* we&#39;re frozen, so add to the queue and release our freeze */
1198           g_object_notify_queue_add (object, nqueue, notify_pspec);
1199           g_object_notify_queue_thaw (object, nqueue);
1200         }
1201       else
1202         /* not frozen, so just dispatch the notification directly */
1203         G_OBJECT_GET_CLASS (object)
1204           -&gt;dispatch_properties_changed (object, 1, &amp;notify_pspec);
1205     }
1206 }
1207 
1208 /**
1209  * g_object_notify:
1210  * @object: a #GObject
1211  * @property_name: the name of a property installed on the class of @object.
1212  *
1213  * Emits a &quot;notify&quot; signal for the property @property_name on @object.
1214  *
1215  * When possible, eg. when signaling a property change from within the class
1216  * that registered the property, you should use g_object_notify_by_pspec()
1217  * instead.
1218  *
1219  * Note that emission of the notify signal may be blocked with
1220  * g_object_freeze_notify(). In this case, the signal emissions are queued
1221  * and will be emitted (in reverse order) when g_object_thaw_notify() is
1222  * called.
1223  */
1224 void
1225 g_object_notify (GObject     *object,
<a name="49" id="anc49"></a><span class="line-modified">1226      const gchar *property_name)</span>
1227 {
1228   GParamSpec *pspec;
1229 
1230   g_return_if_fail (G_IS_OBJECT (object));
1231   g_return_if_fail (property_name != NULL);
1232   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1233     return;
1234 
1235   g_object_ref (object);
1236   /* We don&#39;t need to get the redirect target
1237    * (by, e.g. calling g_object_class_find_property())
1238    * because g_object_notify_queue_add() does that
1239    */
1240   pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="50" id="anc50"></a><span class="line-modified">1241             property_name,</span>
<span class="line-modified">1242             G_OBJECT_TYPE (object),</span>
<span class="line-modified">1243             TRUE);</span>
1244 
1245   if (!pspec)
1246     g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
<a name="51" id="anc51"></a><span class="line-modified">1247          G_STRFUNC,</span>
<span class="line-modified">1248          G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">1249          property_name);</span>
1250   else
1251     g_object_notify_by_spec_internal (object, pspec);
1252   g_object_unref (object);
1253 }
1254 
1255 /**
1256  * g_object_notify_by_pspec:
1257  * @object: a #GObject
1258  * @pspec: the #GParamSpec of a property installed on the class of @object.
1259  *
1260  * Emits a &quot;notify&quot; signal for the property specified by @pspec on @object.
1261  *
1262  * This function omits the property name lookup, hence it is faster than
1263  * g_object_notify().
1264  *
1265  * One way to avoid using g_object_notify() from within the
1266  * class that registered the properties, and using g_object_notify_by_pspec()
1267  * instead, is to store the GParamSpec used with
1268  * g_object_class_install_property() inside a static array, e.g.:
1269  *
1270  *|[&lt;!-- language=&quot;C&quot; --&gt;
1271  *   enum
1272  *   {
1273  *     PROP_0,
1274  *     PROP_FOO,
1275  *     PROP_LAST
1276  *   };
1277  *
1278  *   static GParamSpec *properties[PROP_LAST];
1279  *
1280  *   static void
1281  *   my_object_class_init (MyObjectClass *klass)
1282  *   {
1283  *     properties[PROP_FOO] = g_param_spec_int (&quot;foo&quot;, &quot;Foo&quot;, &quot;The foo&quot;,
1284  *                                              0, 100,
1285  *                                              50,
1286  *                                              G_PARAM_READWRITE);
1287  *     g_object_class_install_property (gobject_class,
1288  *                                      PROP_FOO,
1289  *                                      properties[PROP_FOO]);
1290  *   }
1291  * ]|
1292  *
1293  * and then notify a change on the &quot;foo&quot; property with:
1294  *
1295  * |[&lt;!-- language=&quot;C&quot; --&gt;
1296  *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
1297  * ]|
1298  *
1299  * Since: 2.26
1300  */
1301 void
1302 g_object_notify_by_pspec (GObject    *object,
<a name="52" id="anc52"></a><span class="line-modified">1303         GParamSpec *pspec)</span>
1304 {
1305 
1306   g_return_if_fail (G_IS_OBJECT (object));
1307   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
1308 
1309   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1310     return;
1311 
1312   g_object_ref (object);
1313   g_object_notify_by_spec_internal (object, pspec);
1314   g_object_unref (object);
1315 }
1316 
1317 /**
1318  * g_object_thaw_notify:
1319  * @object: a #GObject
1320  *
1321  * Reverts the effect of a previous call to
1322  * g_object_freeze_notify(). The freeze count is decreased on @object
1323  * and when it reaches zero, queued &quot;notify&quot; signals are emitted.
1324  *
1325  * Duplicate notifications for each property are squashed so that at most one
1326  * #GObject::notify signal is emitted for each property, in the reverse order
1327  * in which they have been queued.
1328  *
1329  * It is an error to call this function when the freeze count is zero.
1330  */
1331 void
1332 g_object_thaw_notify (GObject *object)
1333 {
1334   GObjectNotifyQueue *nqueue;
1335 
1336   g_return_if_fail (G_IS_OBJECT (object));
1337   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1338     return;
1339 
1340   g_object_ref (object);
1341 
1342   /* FIXME: Freezing is the only way to get at the notify queue.
1343    * So we freeze once and then thaw twice.
1344    */
1345   nqueue = g_object_notify_queue_freeze (object, FALSE);
1346   g_object_notify_queue_thaw (object, nqueue);
1347   g_object_notify_queue_thaw (object, nqueue);
1348 
1349   g_object_unref (object);
1350 }
1351 
1352 static void
1353 consider_issuing_property_deprecation_warning (const GParamSpec *pspec)
1354 {
1355   static GHashTable *already_warned_table;
1356   static const gchar *enable_diagnostic;
1357   static GMutex already_warned_lock;
1358   gboolean already;
1359 
1360   if (!(pspec-&gt;flags &amp; G_PARAM_DEPRECATED))
1361     return;
1362 
1363   if (g_once_init_enter (&amp;enable_diagnostic))
1364     {
1365       const gchar *value = g_getenv (&quot;G_ENABLE_DIAGNOSTIC&quot;);
1366 
1367       if (!value)
1368         value = &quot;0&quot;;
1369 
1370       g_once_init_leave (&amp;enable_diagnostic, value);
1371     }
1372 
1373   if (enable_diagnostic[0] == &#39;0&#39;)
1374     return;
1375 
1376   /* We hash only on property names: this means that we could end up in
1377    * a situation where we fail to emit a warning about a pair of
1378    * same-named deprecated properties used on two separate types.
1379    * That&#39;s pretty unlikely to occur, and even if it does, you&#39;ll still
1380    * have seen the warning for the first one...
1381    *
1382    * Doing it this way lets us hash directly on the (interned) property
1383    * name pointers.
1384    */
1385   g_mutex_lock (&amp;already_warned_lock);
1386 
1387   if (already_warned_table == NULL)
1388     already_warned_table = g_hash_table_new (NULL, NULL);
1389 
1390   already = g_hash_table_contains (already_warned_table, (gpointer) pspec-&gt;name);
1391   if (!already)
1392     g_hash_table_add (already_warned_table, (gpointer) pspec-&gt;name);
1393 
1394   g_mutex_unlock (&amp;already_warned_lock);
1395 
1396   if (!already)
1397     g_warning (&quot;The property %s:%s is deprecated and shouldn&#39;t be used &quot;
1398                &quot;anymore. It will be removed in a future version.&quot;,
1399                g_type_name (pspec-&gt;owner_type), pspec-&gt;name);
1400 }
1401 
1402 static inline void
1403 object_get_property (GObject     *object,
<a name="53" id="anc53"></a><span class="line-modified">1404          GParamSpec  *pspec,</span>
<span class="line-modified">1405          GValue      *value)</span>
1406 {
1407   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1408   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1409   GParamSpec *redirect;
1410 
1411   if (class == NULL)
1412     {
1413       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1414                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1415       return;
1416     }
1417 
1418   redirect = g_param_spec_get_redirect_target (pspec);
1419   if (redirect)
1420     pspec = redirect;
1421 
1422   consider_issuing_property_deprecation_warning (pspec);
1423 
1424   class-&gt;get_property (object, param_id, value, pspec);
1425 }
1426 
1427 static inline void
1428 object_set_property (GObject             *object,
<a name="54" id="anc54"></a><span class="line-modified">1429          GParamSpec          *pspec,</span>
<span class="line-modified">1430          const GValue        *value,</span>
<span class="line-modified">1431          GObjectNotifyQueue  *nqueue)</span>
1432 {
1433   GValue tmp_value = G_VALUE_INIT;
1434   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1435   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1436   GParamSpec *redirect;
1437 
1438   if (class == NULL)
1439     {
1440       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1441                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1442       return;
1443     }
1444 
1445   redirect = g_param_spec_get_redirect_target (pspec);
1446   if (redirect)
1447     pspec = redirect;
1448 
1449   /* provide a copy to work from, convert (if necessary) and validate */
1450   g_value_init (&amp;tmp_value, pspec-&gt;value_type);
1451   if (!g_value_transform (value, &amp;tmp_value))
1452     g_warning (&quot;unable to set property &#39;%s&#39; of type &#39;%s&#39; from value of type &#39;%s&#39;&quot;,
<a name="55" id="anc55"></a><span class="line-modified">1453          pspec-&gt;name,</span>
<span class="line-modified">1454          g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">1455          G_VALUE_TYPE_NAME (value));</span>
1456   else if (g_param_value_validate (pspec, &amp;tmp_value) &amp;&amp; !(pspec-&gt;flags &amp; G_PARAM_LAX_VALIDATION))
1457     {
1458       gchar *contents = g_strdup_value_contents (value);
1459 
1460       g_warning (&quot;value \&quot;%s\&quot; of type &#39;%s&#39; is invalid or out of range for property &#39;%s&#39; of type &#39;%s&#39;&quot;,
<a name="56" id="anc56"></a><span class="line-modified">1461      contents,</span>
<span class="line-modified">1462      G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">1463      pspec-&gt;name,</span>
<span class="line-modified">1464      g_type_name (pspec-&gt;value_type));</span>
1465       g_free (contents);
1466     }
1467   else
1468     {
1469       class-&gt;set_property (object, param_id, &amp;tmp_value, pspec);
1470 
1471       if (~pspec-&gt;flags &amp; G_PARAM_EXPLICIT_NOTIFY)
1472         {
1473           GParamSpec *notify_pspec;
1474 
1475           notify_pspec = get_notify_pspec (pspec);
1476 
1477           if (notify_pspec != NULL)
1478             g_object_notify_queue_add (object, nqueue, notify_pspec);
1479         }
1480     }
1481   g_value_unset (&amp;tmp_value);
1482 }
1483 
1484 static void
1485 object_interface_check_properties (gpointer check_data,
<a name="57" id="anc57"></a><span class="line-modified">1486            gpointer g_iface)</span>
1487 {
1488   GTypeInterface *iface_class = g_iface;
1489   GObjectClass *class;
1490   GType iface_type = iface_class-&gt;g_type;
1491   GParamSpec **pspecs;
1492   guint n;
1493 
1494   class = g_type_class_ref (iface_class-&gt;g_instance_type);
1495 
1496   if (class == NULL)
1497     return;
1498 
1499   if (!G_IS_OBJECT_CLASS (class))
1500     goto out;
1501 
1502   pspecs = g_param_spec_pool_list (pspec_pool, iface_type, &amp;n);
1503 
1504   while (n--)
1505     {
1506       GParamSpec *class_pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="58" id="anc58"></a><span class="line-modified">1507                 pspecs[n]-&gt;name,</span>
<span class="line-modified">1508                 G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified">1509                 TRUE);</span>
1510 
1511       if (!class_pspec)
<a name="59" id="anc59"></a><span class="line-modified">1512   {</span>
<span class="line-modified">1513     g_critical (&quot;Object class %s doesn&#39;t implement property &quot;</span>
<span class="line-modified">1514           &quot;&#39;%s&#39; from interface &#39;%s&#39;&quot;,</span>
<span class="line-modified">1515           g_type_name (G_OBJECT_CLASS_TYPE (class)),</span>
<span class="line-modified">1516           pspecs[n]-&gt;name,</span>
<span class="line-modified">1517           g_type_name (iface_type));</span>
<span class="line-modified">1518 </span>
<span class="line-modified">1519     continue;</span>
<span class="line-modified">1520   }</span>
1521 
1522       /* We do a number of checks on the properties of an interface to
1523        * make sure that all classes implementing the interface are
1524        * overriding the properties in a sane way.
1525        *
1526        * We do the checks in order of importance so that we can give
1527        * more useful error messages first.
1528        *
1529        * First, we check that the implementation doesn&#39;t remove the
1530        * basic functionality (readability, writability) advertised by
1531        * the interface.  Next, we check that it doesn&#39;t introduce
1532        * additional restrictions (such as construct-only).  Finally, we
1533        * make sure the types are compatible.
1534        */
1535 
1536 #define SUBSET(a,b,mask) (((a) &amp; ~(b) &amp; (mask)) == 0)
1537       /* If the property on the interface is readable then the
1538        * implementation must be readable.  If the interface is writable
1539        * then the implementation must be writable.
1540        */
1541       if (!SUBSET (pspecs[n]-&gt;flags, class_pspec-&gt;flags, G_PARAM_READABLE | G_PARAM_WRITABLE))
1542         {
1543           g_critical (&quot;Flags for property &#39;%s&#39; on class &#39;%s&#39; remove functionality compared with the &quot;
1544                       &quot;property on interface &#39;%s&#39;\n&quot;, pspecs[n]-&gt;name,
1545                       g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (iface_type));
1546           continue;
1547         }
1548 
1549       /* If the property on the interface is writable then we need to
1550        * make sure the implementation doesn&#39;t introduce new restrictions
1551        * on that writability (ie: construct-only).
1552        *
1553        * If the interface was not writable to begin with then we don&#39;t
1554        * really have any problems here because &quot;writable at construct
1555        * time only&quot; is still more permissive than &quot;read only&quot;.
1556        */
1557       if (pspecs[n]-&gt;flags &amp; G_PARAM_WRITABLE)
1558         {
1559           if (!SUBSET (class_pspec-&gt;flags, pspecs[n]-&gt;flags, G_PARAM_CONSTRUCT_ONLY))
1560             {
1561               g_critical (&quot;Flags for property &#39;%s&#39; on class &#39;%s&#39; introduce additional restrictions on &quot;
1562                           &quot;writability compared with the property on interface &#39;%s&#39;\n&quot;, pspecs[n]-&gt;name,
1563                           g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (iface_type));
1564               continue;
1565             }
1566         }
1567 #undef SUBSET
1568 
1569       /* If the property on the interface is readable then we are
1570        * effectively advertising that reading the property will return a
1571        * value of a specific type.  All implementations of the interface
1572        * need to return items of this type -- but may be more
1573        * restrictive.  For example, it is legal to have:
1574        *
1575        *   GtkWidget *get_item();
1576        *
1577        * that is implemented by a function that always returns a
1578        * GtkEntry.  In short: readability implies that the
1579        * implementation  value type must be equal or more restrictive.
1580        *
1581        * Similarly, if the property on the interface is writable then
1582        * must be able to accept the property being set to any value of
1583        * that type, including subclasses.  In this case, we may also be
1584        * less restrictive.  For example, it is legal to have:
1585        *
1586        *   set_item (GtkEntry *);
1587        *
1588        * that is implemented by a function that will actually work with
1589        * any GtkWidget.  In short: writability implies that the
1590        * implementation value type must be equal or less restrictive.
1591        *
1592        * In the case that the property is both readable and writable
1593        * then the only way that both of the above can be satisfied is
1594        * with a type that is exactly equal.
1595        */
1596       switch (pspecs[n]-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE))
1597         {
1598         case G_PARAM_READABLE | G_PARAM_WRITABLE:
1599           /* class pspec value type must have exact equality with interface */
1600           if (pspecs[n]-&gt;value_type != class_pspec-&gt;value_type)
1601             g_critical (&quot;Read/writable property &#39;%s&#39; on class &#39;%s&#39; has type &#39;%s&#39; which is not exactly equal to the &quot;
1602                         &quot;type &#39;%s&#39; of the property on the interface &#39;%s&#39;\n&quot;, pspecs[n]-&gt;name,
1603                         g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
1604                         g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
1605           break;
1606 
1607         case G_PARAM_READABLE:
1608           /* class pspec value type equal or more restrictive than interface */
1609           if (!g_type_is_a (class_pspec-&gt;value_type, pspecs[n]-&gt;value_type))
1610             g_critical (&quot;Read-only property &#39;%s&#39; on class &#39;%s&#39; has type &#39;%s&#39; which is not equal to or more &quot;
1611                         &quot;restrictive than the type &#39;%s&#39; of the property on the interface &#39;%s&#39;\n&quot;, pspecs[n]-&gt;name,
1612                         g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
1613                         g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
1614           break;
1615 
1616         case G_PARAM_WRITABLE:
1617           /* class pspec value type equal or less restrictive than interface */
1618           if (!g_type_is_a (pspecs[n]-&gt;value_type, class_pspec-&gt;value_type))
1619             g_critical (&quot;Write-only property &#39;%s&#39; on class &#39;%s&#39; has type &#39;%s&#39; which is not equal to or less &quot;
1620                         &quot;restrictive than the type &#39;%s&#39; of the property on the interface &#39;%s&#39; \n&quot;, pspecs[n]-&gt;name,
1621                         g_type_name (G_OBJECT_CLASS_TYPE (class)), g_type_name (G_PARAM_SPEC_VALUE_TYPE (class_pspec)),
1622                         g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspecs[n])), g_type_name (iface_type));
1623           break;
1624 
1625         default:
1626           g_assert_not_reached ();
1627         }
1628     }
1629 
1630   g_free (pspecs);
1631 
1632  out:
1633   g_type_class_unref (class);
1634 }
1635 
1636 GType
1637 g_object_get_type (void)
1638 {
1639     return G_TYPE_OBJECT;
1640 }
1641 
1642 /**
1643  * g_object_new: (skip)
1644  * @object_type: the type id of the #GObject subtype to instantiate
1645  * @first_property_name: the name of the first property
1646  * @...: the value of the first property, followed optionally by more
1647  *  name/value pairs, followed by %NULL
1648  *
1649  * Creates a new instance of a #GObject subtype and sets its properties.
1650  *
1651  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
1652  * which are not explicitly specified are set to their default values.
1653  *
1654  * Returns: (transfer full) (type GObject.Object): a new instance of
1655  *   @object_type
1656  */
1657 gpointer
1658 g_object_new (GType    object_type,
<a name="60" id="anc60"></a><span class="line-modified">1659         const gchar *first_property_name,</span>
<span class="line-modified">1660         ...)</span>
1661 {
1662   GObject *object;
1663   va_list var_args;
1664 
1665   /* short circuit for calls supplying no properties */
1666   if (!first_property_name)
1667     return g_object_new_with_properties (object_type, 0, NULL, NULL);
1668 
1669   va_start (var_args, first_property_name);
1670   object = g_object_new_valist (object_type, first_property_name, var_args);
1671   va_end (var_args);
1672 
1673   return object;
1674 }
1675 
1676 static gpointer
1677 g_object_new_with_custom_constructor (GObjectClass          *class,
1678                                       GObjectConstructParam *params,
1679                                       guint                  n_params)
1680 {
1681   GObjectNotifyQueue *nqueue = NULL;
1682   gboolean newly_constructed;
1683   GObjectConstructParam *cparams;
1684   GObject *object;
1685   GValue *cvalues;
1686   gint n_cparams;
1687   gint cvals_used;
1688   GSList *node;
1689   gint i;
1690 
1691   /* If we have -&gt;constructed() then we have to do a lot more work.
1692    * It&#39;s possible that this is a singleton and it&#39;s also possible
1693    * that the user&#39;s constructor() will attempt to modify the values
1694    * that we pass in, so we&#39;ll need to allocate copies of them.
1695    * It&#39;s also possible that the user may attempt to call
1696    * g_object_set() from inside of their constructor, so we need to
1697    * add ourselves to a list of objects for which that is allowed
1698    * while their constructor() is running.
1699    */
1700 
1701   /* Create the array of GObjectConstructParams for constructor() */
1702   n_cparams = g_slist_length (class-&gt;construct_properties);
1703   cparams = g_new (GObjectConstructParam, n_cparams);
1704   cvalues = g_new0 (GValue, n_cparams);
1705   cvals_used = 0;
1706   i = 0;
1707 
1708   /* As above, we may find the value in the passed-in params list.
1709    *
1710    * If we have the value passed in then we can use the GValue from
1711    * it directly because it is safe to modify.  If we use the
1712    * default value from the class, we had better not pass that in
1713    * and risk it being modified, so we create a new one.
1714    * */
1715   for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1716     {
1717       GParamSpec *pspec;
1718       GValue *value;
1719       gint j;
1720 
1721       pspec = node-&gt;data;
1722       value = NULL; /* to silence gcc... */
1723 
1724       for (j = 0; j &lt; n_params; j++)
1725         if (params[j].pspec == pspec)
1726           {
1727             consider_issuing_property_deprecation_warning (pspec);
1728             value = params[j].value;
1729             break;
1730           }
1731 
<a name="61" id="anc61"></a><span class="line-modified">1732       if (value == NULL)</span>
1733         {
1734           value = &amp;cvalues[cvals_used++];
1735           g_value_init (value, pspec-&gt;value_type);
1736           g_param_value_set_default (pspec, value);
1737         }
1738 
1739       cparams[i].pspec = pspec;
1740       cparams[i].value = value;
1741       i++;
1742     }
1743 
1744   /* construct object from construction parameters */
1745   object = class-&gt;constructor (class-&gt;g_type_class.g_type, n_cparams, cparams);
1746   /* free construction values */
1747   g_free (cparams);
1748   while (cvals_used--)
1749     g_value_unset (&amp;cvalues[cvals_used]);
1750   g_free (cvalues);
1751 
1752   /* There is code in the wild that relies on being able to return NULL
1753    * from its custom constructor.  This was never a supported operation,
1754    * but since the code is already out there...
1755    */
1756   if (object == NULL)
1757     {
1758       g_critical (&quot;Custom constructor for class %s returned NULL (which is invalid). &quot;
1759                   &quot;Please use GInitable instead.&quot;, G_OBJECT_CLASS_NAME (class));
1760       return NULL;
1761     }
1762 
1763   /* g_object_init() will have marked the object as being in-construction.
1764    * Check if the returned object still is so marked, or if this is an
1765    * already-existing singleton (in which case we should not do &#39;constructed&#39;).
1766    */
1767   newly_constructed = object_in_construction (object);
1768   if (newly_constructed)
1769     g_datalist_id_set_data (&amp;object-&gt;qdata, quark_in_construction, NULL);
1770 
1771   if (CLASS_HAS_PROPS (class))
1772     {
1773       /* If this object was newly_constructed then g_object_init()
1774        * froze the queue.  We need to freeze it here in order to get
1775        * the handle so that we can thaw it below (otherwise it will
1776        * be frozen forever).
1777        *
1778        * We also want to do a freeze if we have any params to set,
1779        * even on a non-newly_constructed object.
1780        *
1781        * It&#39;s possible that we have the case of non-newly created
1782        * singleton and all of the passed-in params were construct
1783        * properties so n_params &gt; 0 but we will actually set no
1784        * properties.  This is a pretty lame case to optimise, so
1785        * just ignore it and freeze anyway.
1786        */
1787       if (newly_constructed || n_params)
1788         nqueue = g_object_notify_queue_freeze (object, FALSE);
1789 
1790       /* Remember: if it was newly_constructed then g_object_init()
1791        * already did a freeze, so we now have two.  Release one.
1792        */
1793       if (newly_constructed)
1794         g_object_notify_queue_thaw (object, nqueue);
1795     }
1796 
1797   /* run &#39;constructed&#39; handler if there is a custom one */
1798   if (newly_constructed &amp;&amp; CLASS_HAS_CUSTOM_CONSTRUCTED (class))
1799     class-&gt;constructed (object);
1800 
1801   /* set remaining properties */
1802   for (i = 0; i &lt; n_params; i++)
1803     if (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))
1804       {
1805         consider_issuing_property_deprecation_warning (params[i].pspec);
1806         object_set_property (object, params[i].pspec, params[i].value, nqueue);
1807       }
1808 
1809   /* If nqueue is non-NULL then we are frozen.  Thaw it. */
1810   if (nqueue)
1811     g_object_notify_queue_thaw (object, nqueue);
1812 
1813   return object;
1814 }
1815 
1816 static gpointer
1817 g_object_new_internal (GObjectClass          *class,
1818                        GObjectConstructParam *params,
1819                        guint                  n_params)
1820 {
1821   GObjectNotifyQueue *nqueue = NULL;
1822   GObject *object;
1823 
1824   if G_UNLIKELY (CLASS_HAS_CUSTOM_CONSTRUCTOR (class))
1825     return g_object_new_with_custom_constructor (class, params, n_params);
1826 
1827   object = (GObject *) g_type_create_instance (class-&gt;g_type_class.g_type);
1828 
1829   if (CLASS_HAS_PROPS (class))
1830     {
1831       GSList *node;
1832 
1833       /* This will have been setup in g_object_init() */
1834       nqueue = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_notify_queue);
1835       g_assert (nqueue != NULL);
1836 
1837       /* We will set exactly n_construct_properties construct
1838        * properties, but they may come from either the class default
1839        * values or the passed-in parameter list.
1840        */
1841       for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1842         {
1843           const GValue *value;
1844           GParamSpec *pspec;
1845           gint j;
1846 
1847           pspec = node-&gt;data;
1848           value = NULL; /* to silence gcc... */
1849 
1850           for (j = 0; j &lt; n_params; j++)
1851             if (params[j].pspec == pspec)
1852               {
1853                 consider_issuing_property_deprecation_warning (pspec);
1854                 value = params[j].value;
1855                 break;
1856               }
1857 
<a name="62" id="anc62"></a><span class="line-modified">1858           if (value == NULL)</span>
1859             value = g_param_spec_get_default_value (pspec);
1860 
1861           object_set_property (object, pspec, value, nqueue);
1862         }
1863     }
1864 
1865   /* run &#39;constructed&#39; handler if there is a custom one */
1866   if (CLASS_HAS_CUSTOM_CONSTRUCTED (class))
1867     class-&gt;constructed (object);
1868 
1869   if (nqueue)
1870     {
1871       gint i;
1872 
1873       /* Set remaining properties.  The construct properties will
1874        * already have been taken, so set only the non-construct
1875        * ones.
1876        */
1877       for (i = 0; i &lt; n_params; i++)
1878         if (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))
1879           {
1880             consider_issuing_property_deprecation_warning (params[i].pspec);
1881             object_set_property (object, params[i].pspec, params[i].value, nqueue);
1882           }
1883 
1884       g_object_notify_queue_thaw (object, nqueue);
1885     }
1886 
1887   return object;
1888 }
1889 
1890 
1891 static inline gboolean
1892 g_object_new_is_valid_property (GType                  object_type,
1893                                 GParamSpec            *pspec,
1894                                 const char            *name,
1895                                 GObjectConstructParam *params,
1896                                 int                    n_params)
1897 {
1898   gint i;
1899   if (G_UNLIKELY (pspec == NULL))
1900     {
1901       g_critical (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
1902                   G_STRFUNC, g_type_name (object_type), name);
1903       return FALSE;
1904     }
1905 
1906   if (G_UNLIKELY (~pspec-&gt;flags &amp; G_PARAM_WRITABLE))
1907     {
1908       g_critical (&quot;%s: property &#39;%s&#39; of object class &#39;%s&#39; is not writable&quot;,
1909                   G_STRFUNC, pspec-&gt;name, g_type_name (object_type));
1910       return FALSE;
1911     }
1912 
1913   if (G_UNLIKELY (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))
1914     {
1915       for (i = 0; i &lt; n_params; i++)
1916         if (params[i].pspec == pspec)
1917           break;
1918       if (G_UNLIKELY (i != n_params))
1919         {
1920           g_critical (&quot;%s: property &#39;%s&#39; for type &#39;%s&#39; cannot be set twice&quot;,
1921                       G_STRFUNC, name, g_type_name (object_type));
1922           return FALSE;
1923         }
1924     }
1925   return TRUE;
1926 }
1927 
1928 
1929 /**
1930  * g_object_new_with_properties: (skip)
1931  * @object_type: the object type to instantiate
1932  * @n_properties: the number of properties
1933  * @names: (array length=n_properties): the names of each property to be set
1934  * @values: (array length=n_properties): the values of each property to be set
1935  *
1936  * Creates a new instance of a #GObject subtype and sets its properties using
1937  * the provided arrays. Both arrays must have exactly @n_properties elements,
1938  * and the names and values correspond by index.
1939  *
1940  * Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
1941  * which are not explicitly specified are set to their default values.
1942  *
1943  * Returns: (type GObject.Object) (transfer full): a new instance of
1944  * @object_type
1945  *
1946  * Since: 2.54
1947  */
1948 GObject *
1949 g_object_new_with_properties (GType          object_type,
1950                               guint          n_properties,
1951                               const char    *names[],
1952                               const GValue   values[])
1953 {
1954   GObjectClass *class, *unref_class = NULL;
1955   GObject *object;
1956 
1957   g_return_val_if_fail (G_TYPE_IS_OBJECT (object_type), NULL);
1958 
1959   /* Try to avoid thrashing the ref_count if we don&#39;t need to (since
1960    * it&#39;s a locked operation).
1961    */
1962   class = g_type_class_peek_static (object_type);
1963 
1964   if (class == NULL)
1965     class = unref_class = g_type_class_ref (object_type);
1966 
1967   if (n_properties &gt; 0)
1968     {
1969       guint i, count = 0;
1970       GObjectConstructParam *params;
1971 
1972       params = g_newa (GObjectConstructParam, n_properties);
1973       for (i = 0; i &lt; n_properties; i++)
1974         {
1975           GParamSpec *pspec;
1976           pspec = g_param_spec_pool_lookup (pspec_pool, names[i], object_type, TRUE);
1977           if (!g_object_new_is_valid_property (object_type, pspec, names[i], params, count))
1978             continue;
1979           params[count].pspec = pspec;
1980 
1981           /* Init GValue */
1982           params[count].value = g_newa (GValue, 1);
1983           memset (params[count].value, 0, sizeof (GValue));
1984           g_value_init (params[count].value, G_VALUE_TYPE (&amp;values[i]));
1985 
1986           g_value_copy (&amp;values[i], params[count].value);
1987           count++;
1988         }
1989       object = g_object_new_internal (class, params, count);
1990 
1991       while (count--)
1992         g_value_unset (params[count].value);
1993     }
1994   else
1995     object = g_object_new_internal (class, NULL, 0);
1996 
1997   if (unref_class != NULL)
1998     g_type_class_unref (unref_class);
1999 
2000   return object;
2001 }
2002 
2003 /**
2004  * g_object_newv:
2005  * @object_type: the type id of the #GObject subtype to instantiate
2006  * @n_parameters: the length of the @parameters array
2007  * @parameters: (array length=n_parameters): an array of #GParameter
2008  *
2009  * Creates a new instance of a #GObject subtype and sets its properties.
2010  *
2011  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
2012  * which are not explicitly specified are set to their default values.
2013  *
2014  * Returns: (type GObject.Object) (transfer full): a new instance of
2015  * @object_type
2016  *
2017  * Deprecated: 2.54: Use g_object_new_with_properties() instead.
2018  * deprecated. See #GParameter for more information.
2019  */
<a name="63" id="anc63"></a><span class="line-added">2020 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
2021 gpointer
2022 g_object_newv (GType       object_type,
2023                guint       n_parameters,
2024                GParameter *parameters)
2025 {
2026   GObjectClass *class, *unref_class = NULL;
2027   GObject *object;
2028 
2029   g_return_val_if_fail (G_TYPE_IS_OBJECT (object_type), NULL);
2030   g_return_val_if_fail (n_parameters == 0 || parameters != NULL, NULL);
2031 
2032   /* Try to avoid thrashing the ref_count if we don&#39;t need to (since
2033    * it&#39;s a locked operation).
2034    */
2035   class = g_type_class_peek_static (object_type);
2036 
2037   if (!class)
2038     class = unref_class = g_type_class_ref (object_type);
2039 
2040   if (n_parameters)
2041     {
2042       GObjectConstructParam *cparams;
2043       guint i, j;
2044 
2045       cparams = g_newa (GObjectConstructParam, n_parameters);
2046       j = 0;
2047 
2048       for (i = 0; i &lt; n_parameters; i++)
2049         {
2050           GParamSpec *pspec;
2051 
2052           pspec = g_param_spec_pool_lookup (pspec_pool, parameters[i].name, object_type, TRUE);
2053           if (!g_object_new_is_valid_property (object_type, pspec, parameters[i].name, cparams, j))
2054             continue;
2055 
2056           cparams[j].pspec = pspec;
2057           cparams[j].value = &amp;parameters[i].value;
2058           j++;
2059         }
2060 
2061       object = g_object_new_internal (class, cparams, j);
2062     }
2063   else
2064     /* Fast case: no properties passed in. */
2065     object = g_object_new_internal (class, NULL, 0);
2066 
2067   if (unref_class)
2068     g_type_class_unref (unref_class);
2069 
2070   return object;
2071 }
<a name="64" id="anc64"></a><span class="line-added">2072 G_GNUC_END_IGNORE_DEPRECATIONS</span>
2073 
2074 /**
2075  * g_object_new_valist: (skip)
2076  * @object_type: the type id of the #GObject subtype to instantiate
2077  * @first_property_name: the name of the first property
2078  * @var_args: the value of the first property, followed optionally by more
2079  *  name/value pairs, followed by %NULL
2080  *
2081  * Creates a new instance of a #GObject subtype and sets its properties.
2082  *
2083  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
2084  * which are not explicitly specified are set to their default values.
2085  *
2086  * Returns: a new instance of @object_type
2087  */
2088 GObject*
2089 g_object_new_valist (GType        object_type,
2090                      const gchar *first_property_name,
2091                      va_list      var_args)
2092 {
2093   GObjectClass *class, *unref_class = NULL;
2094   GObject *object;
2095 
2096   g_return_val_if_fail (G_TYPE_IS_OBJECT (object_type), NULL);
2097 
2098   /* Try to avoid thrashing the ref_count if we don&#39;t need to (since
2099    * it&#39;s a locked operation).
2100    */
2101   class = g_type_class_peek_static (object_type);
2102 
2103   if (!class)
2104     class = unref_class = g_type_class_ref (object_type);
2105 
2106   if (first_property_name)
2107     {
2108       GObjectConstructParam stack_params[16];
2109       GObjectConstructParam *params;
2110       const gchar *name;
2111       gint n_params = 0;
2112 
2113       name = first_property_name;
2114       params = stack_params;
2115 
2116       do
2117         {
2118           gchar *error = NULL;
2119           GParamSpec *pspec;
2120 
2121           pspec = g_param_spec_pool_lookup (pspec_pool, name, object_type, TRUE);
2122 
2123           if (!g_object_new_is_valid_property (object_type, pspec, name, params, n_params))
2124             break;
2125 
2126           if (n_params == 16)
2127             {
2128               params = g_new (GObjectConstructParam, n_params + 1);
2129               memcpy (params, stack_params, sizeof stack_params);
2130             }
2131           else if (n_params &gt; 16)
2132             params = g_renew (GObjectConstructParam, params, n_params + 1);
2133 
2134           params[n_params].pspec = pspec;
2135           params[n_params].value = g_newa (GValue, 1);
2136           memset (params[n_params].value, 0, sizeof (GValue));
2137 
2138           G_VALUE_COLLECT_INIT (params[n_params].value, pspec-&gt;value_type, var_args, 0, &amp;error);
2139 
2140           if (error)
2141             {
2142               g_critical (&quot;%s: %s&quot;, G_STRFUNC, error);
2143               g_value_unset (params[n_params].value);
2144               g_free (error);
2145               break;
2146             }
2147 
2148           n_params++;
2149         }
2150       while ((name = va_arg (var_args, const gchar *)));
2151 
2152       object = g_object_new_internal (class, params, n_params);
2153 
2154       while (n_params--)
2155         g_value_unset (params[n_params].value);
2156 
2157       if (params != stack_params)
2158         g_free (params);
2159     }
2160   else
2161     /* Fast case: no properties passed in. */
2162     object = g_object_new_internal (class, NULL, 0);
2163 
2164   if (unref_class)
2165     g_type_class_unref (unref_class);
2166 
2167   return object;
2168 }
2169 
2170 static GObject*
2171 g_object_constructor (GType                  type,
<a name="65" id="anc65"></a><span class="line-modified">2172           guint                  n_construct_properties,</span>
<span class="line-modified">2173           GObjectConstructParam *construct_params)</span>
2174 {
2175   GObject *object;
2176 
2177   /* create object */
2178   object = (GObject*) g_type_create_instance (type);
2179 
2180   /* set construction parameters */
2181   if (n_construct_properties)
2182     {
2183       GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);
2184 
2185       /* set construct properties */
2186       while (n_construct_properties--)
<a name="66" id="anc66"></a><span class="line-modified">2187   {</span>
<span class="line-modified">2188     GValue *value = construct_params-&gt;value;</span>
<span class="line-modified">2189     GParamSpec *pspec = construct_params-&gt;pspec;</span>
2190 
<a name="67" id="anc67"></a><span class="line-modified">2191     construct_params++;</span>
<span class="line-modified">2192     object_set_property (object, pspec, value, nqueue);</span>
<span class="line-modified">2193   }</span>
2194       g_object_notify_queue_thaw (object, nqueue);
2195       /* the notification queue is still frozen from g_object_init(), so
2196        * we don&#39;t need to handle it here, g_object_newv() takes
2197        * care of that
2198        */
2199     }
2200 
2201   return object;
2202 }
2203 
2204 static void
2205 g_object_constructed (GObject *object)
2206 {
2207   /* empty default impl to allow unconditional upchaining */
2208 }
2209 
2210 static inline gboolean
2211 g_object_set_is_valid_property (GObject         *object,
2212                                 GParamSpec      *pspec,
2213                                 const char      *property_name)
2214 {
2215   if (G_UNLIKELY (pspec == NULL))
2216     {
2217       g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
2218                  G_STRFUNC, G_OBJECT_TYPE_NAME (object), property_name);
2219       return FALSE;
2220     }
2221   if (G_UNLIKELY (!(pspec-&gt;flags &amp; G_PARAM_WRITABLE)))
2222     {
2223       g_warning (&quot;%s: property &#39;%s&#39; of object class &#39;%s&#39; is not writable&quot;,
2224                  G_STRFUNC, pspec-&gt;name, G_OBJECT_TYPE_NAME (object));
2225       return FALSE;
2226     }
2227   if (G_UNLIKELY (((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) &amp;&amp; !object_in_construction (object))))
2228     {
2229       g_warning (&quot;%s: construct property \&quot;%s\&quot; for object &#39;%s&#39; can&#39;t be set after construction&quot;,
2230                  G_STRFUNC, pspec-&gt;name, G_OBJECT_TYPE_NAME (object));
2231       return FALSE;
2232     }
2233   return TRUE;
2234 }
2235 
2236 /**
2237  * g_object_setv: (skip)
2238  * @object: a #GObject
2239  * @n_properties: the number of properties
2240  * @names: (array length=n_properties): the names of each property to be set
2241  * @values: (array length=n_properties): the values of each property to be set
2242  *
2243  * Sets @n_properties properties for an @object.
2244  * Properties to be set will be taken from @values. All properties must be
2245  * valid. Warnings will be emitted and undefined behaviour may result if invalid
2246  * properties are passed in.
2247  *
2248  * Since: 2.54
2249  */
2250 void
2251 g_object_setv (GObject       *object,
2252                guint          n_properties,
2253                const gchar   *names[],
2254                const GValue   values[])
2255 {
2256   guint i;
2257   GObjectNotifyQueue *nqueue;
2258   GParamSpec *pspec;
2259   GType obj_type;
2260 
2261   g_return_if_fail (G_IS_OBJECT (object));
2262 
2263   if (n_properties == 0)
2264     return;
2265 
2266   g_object_ref (object);
2267   obj_type = G_OBJECT_TYPE (object);
2268   nqueue = g_object_notify_queue_freeze (object, FALSE);
2269   for (i = 0; i &lt; n_properties; i++)
2270     {
2271       pspec = g_param_spec_pool_lookup (pspec_pool, names[i], obj_type, TRUE);
2272 
2273       if (!g_object_set_is_valid_property (object, pspec, names[i]))
2274         break;
2275 
2276       consider_issuing_property_deprecation_warning (pspec);
2277       object_set_property (object, pspec, &amp;values[i], nqueue);
2278     }
2279 
2280   g_object_notify_queue_thaw (object, nqueue);
2281   g_object_unref (object);
2282 }
2283 
2284 /**
2285  * g_object_set_valist: (skip)
2286  * @object: a #GObject
2287  * @first_property_name: name of the first property to set
2288  * @var_args: value for the first property, followed optionally by more
2289  *  name/value pairs, followed by %NULL
2290  *
2291  * Sets properties on an object.
2292  */
2293 void
<a name="68" id="anc68"></a><span class="line-modified">2294 g_object_set_valist (GObject   *object,</span>
<span class="line-modified">2295          const gchar *first_property_name,</span>
<span class="line-modified">2296          va_list    var_args)</span>
2297 {
2298   GObjectNotifyQueue *nqueue;
2299   const gchar *name;
2300 
2301   g_return_if_fail (G_IS_OBJECT (object));
2302 
2303   g_object_ref (object);
2304   nqueue = g_object_notify_queue_freeze (object, FALSE);
2305 
2306   name = first_property_name;
2307   while (name)
2308     {
2309       GValue value = G_VALUE_INIT;
2310       GParamSpec *pspec;
2311       gchar *error = NULL;
2312 
2313       pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="69" id="anc69"></a><span class="line-modified">2314           name,</span>
<span class="line-modified">2315           G_OBJECT_TYPE (object),</span>
<span class="line-modified">2316           TRUE);</span>
2317 
2318       if (!g_object_set_is_valid_property (object, pspec, name))
2319         break;
2320 
2321       G_VALUE_COLLECT_INIT (&amp;value, pspec-&gt;value_type, var_args,
<a name="70" id="anc70"></a><span class="line-modified">2322           0, &amp;error);</span>
2323       if (error)
<a name="71" id="anc71"></a><span class="line-modified">2324   {</span>
<span class="line-modified">2325     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2326     g_free (error);</span>
2327           g_value_unset (&amp;value);
<a name="72" id="anc72"></a><span class="line-modified">2328     break;</span>
<span class="line-modified">2329   }</span>
2330 
2331       consider_issuing_property_deprecation_warning (pspec);
2332       object_set_property (object, pspec, &amp;value, nqueue);
2333       g_value_unset (&amp;value);
2334 
2335       name = va_arg (var_args, gchar*);
2336     }
2337 
2338   g_object_notify_queue_thaw (object, nqueue);
2339   g_object_unref (object);
2340 }
2341 
2342 static inline gboolean
2343 g_object_get_is_valid_property (GObject          *object,
2344                                 GParamSpec       *pspec,
2345                                 const char       *property_name)
2346 {
2347   if (G_UNLIKELY (pspec == NULL))
2348     {
2349       g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
2350                  G_STRFUNC, G_OBJECT_TYPE_NAME (object), property_name);
2351       return FALSE;
2352     }
2353   if (G_UNLIKELY (!(pspec-&gt;flags &amp; G_PARAM_READABLE)))
2354     {
2355       g_warning (&quot;%s: property &#39;%s&#39; of object class &#39;%s&#39; is not readable&quot;,
2356                  G_STRFUNC, pspec-&gt;name, G_OBJECT_TYPE_NAME (object));
2357       return FALSE;
2358     }
2359   return TRUE;
2360 }
2361 
2362 /**
2363  * g_object_getv:
2364  * @object: a #GObject
2365  * @n_properties: the number of properties
2366  * @names: (array length=n_properties): the names of each property to get
2367  * @values: (array length=n_properties): the values of each property to get
2368  *
2369  * Gets @n_properties properties for an @object.
2370  * Obtained properties will be set to @values. All properties must be valid.
2371  * Warnings will be emitted and undefined behaviour may result if invalid
2372  * properties are passed in.
2373  *
2374  * Since: 2.54
2375  */
2376 void
2377 g_object_getv (GObject      *object,
2378                guint         n_properties,
2379                const gchar  *names[],
2380                GValue        values[])
2381 {
2382   guint i;
2383   GParamSpec *pspec;
2384   GType obj_type;
2385 
2386   g_return_if_fail (G_IS_OBJECT (object));
2387 
2388   if (n_properties == 0)
2389     return;
2390 
2391   g_object_ref (object);
2392 
2393   obj_type = G_OBJECT_TYPE (object);
2394   for (i = 0; i &lt; n_properties; i++)
2395     {
2396       pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="73" id="anc73"></a><span class="line-modified">2397                 names[i],</span>
<span class="line-modified">2398                 obj_type,</span>
<span class="line-modified">2399                 TRUE);</span>
2400       if (!g_object_get_is_valid_property (object, pspec, names[i]))
2401         break;
2402 
2403       memset (&amp;values[i], 0, sizeof (GValue));
2404       g_value_init (&amp;values[i], pspec-&gt;value_type);
2405       object_get_property (object, pspec, &amp;values[i]);
2406     }
2407   g_object_unref (object);
2408 }
2409 
2410 /**
2411  * g_object_get_valist: (skip)
2412  * @object: a #GObject
2413  * @first_property_name: name of the first property to get
2414  * @var_args: return location for the first property, followed optionally by more
2415  *  name/return location pairs, followed by %NULL
2416  *
2417  * Gets properties of an object.
2418  *
2419  * In general, a copy is made of the property contents and the caller
2420  * is responsible for freeing the memory in the appropriate manner for
2421  * the type, for instance by calling g_free() or g_object_unref().
2422  *
2423  * See g_object_get().
2424  */
2425 void
<a name="74" id="anc74"></a><span class="line-modified">2426 g_object_get_valist (GObject   *object,</span>
<span class="line-modified">2427          const gchar *first_property_name,</span>
<span class="line-modified">2428          va_list    var_args)</span>
2429 {
2430   const gchar *name;
2431 
2432   g_return_if_fail (G_IS_OBJECT (object));
2433 
2434   g_object_ref (object);
2435 
2436   name = first_property_name;
2437 
2438   while (name)
2439     {
2440       GValue value = G_VALUE_INIT;
2441       GParamSpec *pspec;
2442       gchar *error;
2443 
2444       pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="75" id="anc75"></a><span class="line-modified">2445           name,</span>
<span class="line-modified">2446           G_OBJECT_TYPE (object),</span>
<span class="line-modified">2447           TRUE);</span>
2448 
2449       if (!g_object_get_is_valid_property (object, pspec, name))
2450         break;
2451 
2452       g_value_init (&amp;value, pspec-&gt;value_type);
2453 
2454       object_get_property (object, pspec, &amp;value);
2455 
2456       G_VALUE_LCOPY (&amp;value, var_args, 0, &amp;error);
2457       if (error)
<a name="76" id="anc76"></a><span class="line-modified">2458   {</span>
<span class="line-modified">2459     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2460     g_free (error);</span>
<span class="line-modified">2461     g_value_unset (&amp;value);</span>
<span class="line-modified">2462     break;</span>
<span class="line-modified">2463   }</span>
2464 
2465       g_value_unset (&amp;value);
2466 
2467       name = va_arg (var_args, gchar*);
2468     }
2469 
2470   g_object_unref (object);
2471 }
2472 
2473 /**
2474  * g_object_set: (skip)
2475  * @object: (type GObject.Object): a #GObject
2476  * @first_property_name: name of the first property to set
2477  * @...: value for the first property, followed optionally by more
2478  *  name/value pairs, followed by %NULL
2479  *
2480  * Sets properties on an object.
2481  *
2482  * Note that the &quot;notify&quot; signals are queued and only emitted (in
2483  * reverse order) after all properties have been set. See
2484  * g_object_freeze_notify().
2485  */
2486 void
2487 g_object_set (gpointer     _object,
<a name="77" id="anc77"></a><span class="line-modified">2488         const gchar *first_property_name,</span>
<span class="line-modified">2489         ...)</span>
2490 {
2491   GObject *object = _object;
2492   va_list var_args;
2493 
2494   g_return_if_fail (G_IS_OBJECT (object));
2495 
2496   va_start (var_args, first_property_name);
2497   g_object_set_valist (object, first_property_name, var_args);
2498   va_end (var_args);
2499 }
2500 
2501 /**
2502  * g_object_get: (skip)
2503  * @object: (type GObject.Object): a #GObject
2504  * @first_property_name: name of the first property to get
2505  * @...: return location for the first property, followed optionally by more
2506  *  name/return location pairs, followed by %NULL
2507  *
2508  * Gets properties of an object.
2509  *
2510  * In general, a copy is made of the property contents and the caller
2511  * is responsible for freeing the memory in the appropriate manner for
2512  * the type, for instance by calling g_free() or g_object_unref().
2513  *
2514  * Here is an example of using g_object_get() to get the contents
2515  * of three properties: an integer, a string and an object:
2516  * |[&lt;!-- language=&quot;C&quot; --&gt;
2517  *  gint intval;
2518  *  gchar *strval;
2519  *  GObject *objval;
2520  *
2521  *  g_object_get (my_object,
2522  *                &quot;int-property&quot;, &amp;intval,
2523  *                &quot;str-property&quot;, &amp;strval,
2524  *                &quot;obj-property&quot;, &amp;objval,
2525  *                NULL);
2526  *
2527  *  // Do something with intval, strval, objval
2528  *
2529  *  g_free (strval);
2530  *  g_object_unref (objval);
2531  *  ]|
2532  */
2533 void
2534 g_object_get (gpointer     _object,
<a name="78" id="anc78"></a><span class="line-modified">2535         const gchar *first_property_name,</span>
<span class="line-modified">2536         ...)</span>
2537 {
2538   GObject *object = _object;
2539   va_list var_args;
2540 
2541   g_return_if_fail (G_IS_OBJECT (object));
2542 
2543   va_start (var_args, first_property_name);
2544   g_object_get_valist (object, first_property_name, var_args);
2545   va_end (var_args);
2546 }
2547 
2548 /**
2549  * g_object_set_property:
2550  * @object: a #GObject
2551  * @property_name: the name of the property to set
2552  * @value: the value
2553  *
2554  * Sets a property on an object.
2555  */
2556 void
2557 g_object_set_property (GObject      *object,
<a name="79" id="anc79"></a><span class="line-modified">2558            const gchar  *property_name,</span>
<span class="line-modified">2559            const GValue *value)</span>
2560 {
2561   g_object_setv (object, 1, &amp;property_name, value);
2562 }
2563 
2564 /**
2565  * g_object_get_property:
2566  * @object: a #GObject
2567  * @property_name: the name of the property to get
2568  * @value: return location for the property value
2569  *
<a name="80" id="anc80"></a><span class="line-modified">2570  * Gets a property of an object.</span>
<span class="line-modified">2571  *</span>
<span class="line-modified">2572  * The @value can be:</span>
<span class="line-added">2573  *</span>
<span class="line-added">2574  *  - an empty #GValue initialized by %G_VALUE_INIT, which will be</span>
<span class="line-added">2575  *    automatically initialized with the expected type of the property</span>
<span class="line-added">2576  *    (since GLib 2.60)</span>
<span class="line-added">2577  *  - a #GValue initialized with the expected type of the property</span>
<span class="line-added">2578  *  - a #GValue initialized with a type to which the expected type</span>
<span class="line-added">2579  *    of the property can be transformed</span>
2580  *
2581  * In general, a copy is made of the property contents and the caller is
2582  * responsible for freeing the memory by calling g_value_unset().
2583  *
2584  * Note that g_object_get_property() is really intended for language
2585  * bindings, g_object_get() is much more convenient for C programming.
2586  */
2587 void
2588 g_object_get_property (GObject     *object,
<a name="81" id="anc81"></a><span class="line-modified">2589            const gchar *property_name,</span>
<span class="line-modified">2590            GValue    *value)</span>
2591 {
2592   GParamSpec *pspec;
2593 
2594   g_return_if_fail (G_IS_OBJECT (object));
2595   g_return_if_fail (property_name != NULL);
<a name="82" id="anc82"></a><span class="line-modified">2596   g_return_if_fail (value != NULL);</span>
2597 
2598   g_object_ref (object);
2599 
2600   pspec = g_param_spec_pool_lookup (pspec_pool,
<a name="83" id="anc83"></a><span class="line-modified">2601             property_name,</span>
<span class="line-modified">2602             G_OBJECT_TYPE (object),</span>
<span class="line-modified">2603             TRUE);</span>
2604 
2605   if (g_object_get_is_valid_property (object, pspec, property_name))
2606     {
2607       GValue *prop_value, tmp_value = G_VALUE_INIT;
2608 
<a name="84" id="anc84"></a><span class="line-modified">2609       if (G_VALUE_TYPE (value) == G_TYPE_INVALID)</span>
<span class="line-modified">2610         {</span>
<span class="line-modified">2611           /* zero-initialized value */</span>
<span class="line-modified">2612           g_value_init (value, pspec-&gt;value_type);</span>
<span class="line-modified">2613           prop_value = value;</span>
<span class="line-modified">2614         }</span>
<span class="line-modified">2615       else if (G_VALUE_TYPE (value) == pspec-&gt;value_type)</span>
<span class="line-added">2616         {</span>
<span class="line-added">2617           /* auto-conversion of the callers value type */</span>
<span class="line-added">2618           g_value_reset (value);</span>
<span class="line-added">2619           prop_value = value;</span>
<span class="line-added">2620         }</span>
2621       else if (!g_value_type_transformable (pspec-&gt;value_type, G_VALUE_TYPE (value)))
<a name="85" id="anc85"></a><span class="line-modified">2622         {</span>
<span class="line-modified">2623           g_warning (&quot;%s: can&#39;t retrieve property &#39;%s&#39; of type &#39;%s&#39; as value of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">2624                      G_STRFUNC, pspec-&gt;name,</span>
<span class="line-modified">2625                      g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">2626                      G_VALUE_TYPE_NAME (value));</span>
<span class="line-modified">2627           g_object_unref (object);</span>
<span class="line-modified">2628           return;</span>
<span class="line-modified">2629         }</span>
2630       else
<a name="86" id="anc86"></a><span class="line-modified">2631         {</span>
<span class="line-modified">2632           g_value_init (&amp;tmp_value, pspec-&gt;value_type);</span>
<span class="line-modified">2633           prop_value = &amp;tmp_value;</span>
<span class="line-modified">2634         }</span>
2635       object_get_property (object, pspec, prop_value);
2636       if (prop_value != value)
<a name="87" id="anc87"></a><span class="line-modified">2637         {</span>
<span class="line-modified">2638           g_value_transform (prop_value, value);</span>
<span class="line-modified">2639           g_value_unset (&amp;tmp_value);</span>
<span class="line-modified">2640         }</span>
2641     }
2642 
2643   g_object_unref (object);
2644 }
2645 
2646 /**
2647  * g_object_connect: (skip)
2648  * @object: (type GObject.Object): a #GObject
2649  * @signal_spec: the spec for the first signal
2650  * @...: #GCallback for the first signal, followed by data for the
2651  *       first signal, followed optionally by more signal
2652  *       spec/callback/data triples, followed by %NULL
2653  *
2654  * A convenience function to connect multiple signals at once.
2655  *
2656  * The signal specs expected by this function have the form
2657  * &quot;modifier::signal_name&quot;, where modifier can be one of the following:
<a name="88" id="anc88"></a><span class="line-modified">2658  * - signal: equivalent to g_signal_connect_data (..., NULL, 0)</span>
2659  * - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
2660  * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
2661  * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
2662  * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
2663  * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
2664  * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2665  * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2666  *
2667  * |[&lt;!-- language=&quot;C&quot; --&gt;
2668  *   menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
<a name="89" id="anc89"></a><span class="line-modified">2669  *               &quot;type&quot;, GTK_WINDOW_POPUP,</span>
<span class="line-modified">2670  *               &quot;child&quot;, menu,</span>
<span class="line-modified">2671  *               NULL),</span>
<span class="line-modified">2672  *             &quot;signal::event&quot;, gtk_menu_window_event, menu,</span>
<span class="line-modified">2673  *             &quot;signal::size_request&quot;, gtk_menu_window_size_request, menu,</span>
<span class="line-modified">2674  *             &quot;signal::destroy&quot;, gtk_widget_destroyed, &amp;menu-&gt;toplevel,</span>
<span class="line-modified">2675  *             NULL);</span>
2676  * ]|
2677  *
2678  * Returns: (transfer none) (type GObject.Object): @object
2679  */
2680 gpointer
2681 g_object_connect (gpointer     _object,
<a name="90" id="anc90"></a><span class="line-modified">2682       const gchar *signal_spec,</span>
<span class="line-modified">2683       ...)</span>
2684 {
2685   GObject *object = _object;
2686   va_list var_args;
2687 
2688   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
2689   g_return_val_if_fail (object-&gt;ref_count &gt; 0, object);
2690 
2691   va_start (var_args, signal_spec);
2692   while (signal_spec)
2693     {
2694       GCallback callback = va_arg (var_args, GCallback);
2695       gpointer data = va_arg (var_args, gpointer);
2696 
2697       if (strncmp (signal_spec, &quot;signal::&quot;, 8) == 0)
<a name="91" id="anc91"></a><span class="line-modified">2698   g_signal_connect_data (object, signal_spec + 8,</span>
<span class="line-modified">2699              callback, data, NULL,</span>
<span class="line-modified">2700              0);</span>
2701       else if (strncmp (signal_spec, &quot;object_signal::&quot;, 15) == 0 ||
2702                strncmp (signal_spec, &quot;object-signal::&quot;, 15) == 0)
<a name="92" id="anc92"></a><span class="line-modified">2703   g_signal_connect_object (object, signal_spec + 15,</span>
<span class="line-modified">2704          callback, data,</span>
<span class="line-modified">2705          0);</span>
2706       else if (strncmp (signal_spec, &quot;swapped_signal::&quot;, 16) == 0 ||
2707                strncmp (signal_spec, &quot;swapped-signal::&quot;, 16) == 0)
<a name="93" id="anc93"></a><span class="line-modified">2708   g_signal_connect_data (object, signal_spec + 16,</span>
<span class="line-modified">2709              callback, data, NULL,</span>
<span class="line-modified">2710              G_CONNECT_SWAPPED);</span>
2711       else if (strncmp (signal_spec, &quot;swapped_object_signal::&quot;, 23) == 0 ||
2712                strncmp (signal_spec, &quot;swapped-object-signal::&quot;, 23) == 0)
<a name="94" id="anc94"></a><span class="line-modified">2713   g_signal_connect_object (object, signal_spec + 23,</span>
<span class="line-modified">2714          callback, data,</span>
<span class="line-modified">2715          G_CONNECT_SWAPPED);</span>
2716       else if (strncmp (signal_spec, &quot;signal_after::&quot;, 14) == 0 ||
2717                strncmp (signal_spec, &quot;signal-after::&quot;, 14) == 0)
<a name="95" id="anc95"></a><span class="line-modified">2718   g_signal_connect_data (object, signal_spec + 14,</span>
<span class="line-modified">2719              callback, data, NULL,</span>
<span class="line-modified">2720              G_CONNECT_AFTER);</span>
2721       else if (strncmp (signal_spec, &quot;object_signal_after::&quot;, 21) == 0 ||
2722                strncmp (signal_spec, &quot;object-signal-after::&quot;, 21) == 0)
<a name="96" id="anc96"></a><span class="line-modified">2723   g_signal_connect_object (object, signal_spec + 21,</span>
<span class="line-modified">2724          callback, data,</span>
<span class="line-modified">2725          G_CONNECT_AFTER);</span>
2726       else if (strncmp (signal_spec, &quot;swapped_signal_after::&quot;, 22) == 0 ||
2727                strncmp (signal_spec, &quot;swapped-signal-after::&quot;, 22) == 0)
<a name="97" id="anc97"></a><span class="line-modified">2728   g_signal_connect_data (object, signal_spec + 22,</span>
<span class="line-modified">2729              callback, data, NULL,</span>
<span class="line-modified">2730              G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2731       else if (strncmp (signal_spec, &quot;swapped_object_signal_after::&quot;, 29) == 0 ||
2732                strncmp (signal_spec, &quot;swapped-object-signal-after::&quot;, 29) == 0)
<a name="98" id="anc98"></a><span class="line-modified">2733   g_signal_connect_object (object, signal_spec + 29,</span>
<span class="line-modified">2734          callback, data,</span>
<span class="line-modified">2735          G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2736       else
<a name="99" id="anc99"></a><span class="line-modified">2737   {</span>
<span class="line-modified">2738     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2739     break;</span>
<span class="line-modified">2740   }</span>
2741       signal_spec = va_arg (var_args, gchar*);
2742     }
2743   va_end (var_args);
2744 
2745   return object;
2746 }
2747 
2748 /**
2749  * g_object_disconnect: (skip)
2750  * @object: (type GObject.Object): a #GObject
2751  * @signal_spec: the spec for the first signal
2752  * @...: #GCallback for the first signal, followed by data for the first signal,
2753  *  followed optionally by more signal spec/callback/data triples,
2754  *  followed by %NULL
2755  *
2756  * A convenience function to disconnect multiple signals at once.
2757  *
2758  * The signal specs expected by this function have the form
2759  * &quot;any_signal&quot;, which means to disconnect any signal with matching
2760  * callback and data, or &quot;any_signal::signal_name&quot;, which only
2761  * disconnects the signal named &quot;signal_name&quot;.
2762  */
2763 void
2764 g_object_disconnect (gpointer     _object,
<a name="100" id="anc100"></a><span class="line-modified">2765          const gchar *signal_spec,</span>
<span class="line-modified">2766          ...)</span>
2767 {
2768   GObject *object = _object;
2769   va_list var_args;
2770 
2771   g_return_if_fail (G_IS_OBJECT (object));
2772   g_return_if_fail (object-&gt;ref_count &gt; 0);
2773 
2774   va_start (var_args, signal_spec);
2775   while (signal_spec)
2776     {
2777       GCallback callback = va_arg (var_args, GCallback);
2778       gpointer data = va_arg (var_args, gpointer);
2779       guint sid = 0, detail = 0, mask = 0;
2780 
2781       if (strncmp (signal_spec, &quot;any_signal::&quot;, 12) == 0 ||
2782           strncmp (signal_spec, &quot;any-signal::&quot;, 12) == 0)
<a name="101" id="anc101"></a><span class="line-modified">2783   {</span>
<span class="line-modified">2784     signal_spec += 12;</span>
<span class="line-modified">2785     mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2786   }</span>
2787       else if (strcmp (signal_spec, &quot;any_signal&quot;) == 0 ||
2788                strcmp (signal_spec, &quot;any-signal&quot;) == 0)
<a name="102" id="anc102"></a><span class="line-modified">2789   {</span>
<span class="line-modified">2790     signal_spec += 10;</span>
<span class="line-modified">2791     mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2792   }</span>
2793       else
<a name="103" id="anc103"></a><span class="line-modified">2794   {</span>
<span class="line-modified">2795     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2796     break;</span>
<span class="line-modified">2797   }</span>
2798 
2799       if ((mask &amp; G_SIGNAL_MATCH_ID) &amp;&amp;
<a name="104" id="anc104"></a><span class="line-modified">2800     !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &amp;sid, &amp;detail, FALSE))</span>
<span class="line-modified">2801   g_warning (&quot;%s: invalid signal name \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
2802       else if (!g_signal_handlers_disconnect_matched (object, mask | (detail ? G_SIGNAL_MATCH_DETAIL : 0),
<a name="105" id="anc105"></a><span class="line-modified">2803                   sid, detail,</span>
<span class="line-modified">2804                   NULL, (gpointer)callback, data))</span>
<span class="line-modified">2805   g_warning (&quot;%s: signal handler %p(%p) is not connected&quot;, G_STRFUNC, callback, data);</span>
2806       signal_spec = va_arg (var_args, gchar*);
2807     }
2808   va_end (var_args);
2809 }
2810 
2811 typedef struct {
2812   GObject *object;
2813   guint n_weak_refs;
2814   struct {
2815     GWeakNotify notify;
2816     gpointer    data;
2817   } weak_refs[1];  /* flexible array */
2818 } WeakRefStack;
2819 
2820 static void
2821 weak_refs_notify (gpointer data)
2822 {
2823   WeakRefStack *wstack = data;
2824   guint i;
2825 
2826   for (i = 0; i &lt; wstack-&gt;n_weak_refs; i++)
2827     wstack-&gt;weak_refs[i].notify (wstack-&gt;weak_refs[i].data, wstack-&gt;object);
2828   g_free (wstack);
2829 }
2830 
2831 /**
2832  * g_object_weak_ref: (skip)
2833  * @object: #GObject to reference weakly
2834  * @notify: callback to invoke before the object is freed
2835  * @data: extra data to pass to notify
2836  *
2837  * Adds a weak reference callback to an object. Weak references are
2838  * used for notification when an object is finalized. They are called
2839  * &quot;weak references&quot; because they allow you to safely hold a pointer
2840  * to an object without calling g_object_ref() (g_object_ref() adds a
2841  * strong reference, that is, forces the object to stay alive).
2842  *
2843  * Note that the weak references created by this method are not
2844  * thread-safe: they cannot safely be used in one thread if the
2845  * object&#39;s last g_object_unref() might happen in another thread.
2846  * Use #GWeakRef if thread-safety is required.
2847  */
2848 void
2849 g_object_weak_ref (GObject    *object,
<a name="106" id="anc106"></a><span class="line-modified">2850        GWeakNotify notify,</span>
<span class="line-modified">2851        gpointer    data)</span>
2852 {
2853   WeakRefStack *wstack;
2854   guint i;
2855 
2856   g_return_if_fail (G_IS_OBJECT (object));
2857   g_return_if_fail (notify != NULL);
<a name="107" id="anc107"></a><span class="line-modified">2858   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
2859 
2860   G_LOCK (weak_refs_mutex);
2861   wstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_weak_refs);
2862   if (wstack)
2863     {
2864       i = wstack-&gt;n_weak_refs++;
2865       wstack = g_realloc (wstack, sizeof (*wstack) + sizeof (wstack-&gt;weak_refs[0]) * i);
2866     }
2867   else
2868     {
2869       wstack = g_renew (WeakRefStack, NULL, 1);
2870       wstack-&gt;object = object;
2871       wstack-&gt;n_weak_refs = 1;
2872       i = 0;
2873     }
2874   wstack-&gt;weak_refs[i].notify = notify;
2875   wstack-&gt;weak_refs[i].data = data;
2876   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_weak_refs, wstack, weak_refs_notify);
2877   G_UNLOCK (weak_refs_mutex);
2878 }
2879 
2880 /**
2881  * g_object_weak_unref: (skip)
2882  * @object: #GObject to remove a weak reference from
2883  * @notify: callback to search for
2884  * @data: data to search for
2885  *
2886  * Removes a weak reference callback to an object.
2887  */
2888 void
2889 g_object_weak_unref (GObject    *object,
<a name="108" id="anc108"></a><span class="line-modified">2890          GWeakNotify notify,</span>
<span class="line-modified">2891          gpointer    data)</span>
2892 {
2893   WeakRefStack *wstack;
2894   gboolean found_one = FALSE;
2895 
2896   g_return_if_fail (G_IS_OBJECT (object));
2897   g_return_if_fail (notify != NULL);
2898 
2899   G_LOCK (weak_refs_mutex);
2900   wstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_refs);
2901   if (wstack)
2902     {
2903       guint i;
2904 
2905       for (i = 0; i &lt; wstack-&gt;n_weak_refs; i++)
<a name="109" id="anc109"></a><span class="line-modified">2906   if (wstack-&gt;weak_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">2907       wstack-&gt;weak_refs[i].data == data)</span>
<span class="line-modified">2908     {</span>
<span class="line-modified">2909       found_one = TRUE;</span>
<span class="line-modified">2910       wstack-&gt;n_weak_refs -= 1;</span>
<span class="line-modified">2911       if (i != wstack-&gt;n_weak_refs)</span>
<span class="line-modified">2912         wstack-&gt;weak_refs[i] = wstack-&gt;weak_refs[wstack-&gt;n_weak_refs];</span>
2913 
<a name="110" id="anc110"></a><span class="line-modified">2914       break;</span>
<span class="line-modified">2915     }</span>
2916     }
2917   G_UNLOCK (weak_refs_mutex);
2918   if (!found_one)
2919     g_warning (&quot;%s: couldn&#39;t find weak ref %p(%p)&quot;, G_STRFUNC, notify, data);
2920 }
2921 
2922 /**
2923  * g_object_add_weak_pointer: (skip)
2924  * @object: The object that should be weak referenced.
2925  * @weak_pointer_location: (inout) (not optional): The memory address
2926  *    of a pointer.
2927  *
2928  * Adds a weak reference from weak_pointer to @object to indicate that
2929  * the pointer located at @weak_pointer_location is only valid during
2930  * the lifetime of @object. When the @object is finalized,
2931  * @weak_pointer will be set to %NULL.
2932  *
2933  * Note that as with g_object_weak_ref(), the weak references created by
2934  * this method are not thread-safe: they cannot safely be used in one
2935  * thread if the object&#39;s last g_object_unref() might happen in another
2936  * thread. Use #GWeakRef if thread-safety is required.
2937  */
2938 void
2939 g_object_add_weak_pointer (GObject  *object,
2940                            gpointer *weak_pointer_location)
2941 {
2942   g_return_if_fail (G_IS_OBJECT (object));
2943   g_return_if_fail (weak_pointer_location != NULL);
2944 
2945   g_object_weak_ref (object,
2946                      (GWeakNotify) g_nullify_pointer,
2947                      weak_pointer_location);
2948 }
2949 
2950 /**
2951  * g_object_remove_weak_pointer: (skip)
2952  * @object: The object that is weak referenced.
2953  * @weak_pointer_location: (inout) (not optional): The memory address
2954  *    of a pointer.
2955  *
2956  * Removes a weak reference from @object that was previously added
2957  * using g_object_add_weak_pointer(). The @weak_pointer_location has
2958  * to match the one used with g_object_add_weak_pointer().
2959  */
2960 void
2961 g_object_remove_weak_pointer (GObject  *object,
2962                               gpointer *weak_pointer_location)
2963 {
2964   g_return_if_fail (G_IS_OBJECT (object));
2965   g_return_if_fail (weak_pointer_location != NULL);
2966 
2967   g_object_weak_unref (object,
2968                        (GWeakNotify) g_nullify_pointer,
2969                        weak_pointer_location);
2970 }
2971 
2972 static guint
2973 object_floating_flag_handler (GObject        *object,
2974                               gint            job)
2975 {
2976   switch (job)
2977     {
2978       gpointer oldvalue;
2979     case +1:    /* force floating if possible */
2980       do
2981         oldvalue = g_atomic_pointer_get (&amp;object-&gt;qdata);
2982       while (!g_atomic_pointer_compare_and_exchange ((void**) &amp;object-&gt;qdata, oldvalue,
2983                                                      (gpointer) ((gsize) oldvalue | OBJECT_FLOATING_FLAG)));
2984       return (gsize) oldvalue &amp; OBJECT_FLOATING_FLAG;
2985     case -1:    /* sink if possible */
2986       do
2987         oldvalue = g_atomic_pointer_get (&amp;object-&gt;qdata);
2988       while (!g_atomic_pointer_compare_and_exchange ((void**) &amp;object-&gt;qdata, oldvalue,
2989                                                      (gpointer) ((gsize) oldvalue &amp; ~(gsize) OBJECT_FLOATING_FLAG)));
2990       return (gsize) oldvalue &amp; OBJECT_FLOATING_FLAG;
2991     default:    /* check floating */
2992       return 0 != ((gsize) g_atomic_pointer_get (&amp;object-&gt;qdata) &amp; OBJECT_FLOATING_FLAG);
2993     }
2994 }
2995 
2996 /**
2997  * g_object_is_floating:
2998  * @object: (type GObject.Object): a #GObject
2999  *
3000  * Checks whether @object has a [floating][floating-ref] reference.
3001  *
3002  * Since: 2.10
3003  *
3004  * Returns: %TRUE if @object has a floating reference
3005  */
3006 gboolean
3007 g_object_is_floating (gpointer _object)
3008 {
3009   GObject *object = _object;
3010   g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
3011   return floating_flag_handler (object, 0);
3012 }
3013 
3014 /**
3015  * g_object_ref_sink:
3016  * @object: (type GObject.Object): a #GObject
3017  *
3018  * Increase the reference count of @object, and possibly remove the
3019  * [floating][floating-ref] reference, if @object has a floating reference.
3020  *
3021  * In other words, if the object is floating, then this call &quot;assumes
3022  * ownership&quot; of the floating reference, converting it to a normal
3023  * reference by clearing the floating flag while leaving the reference
3024  * count unchanged.  If the object is not floating, then this call
3025  * adds a new normal reference increasing the reference count by one.
3026  *
3027  * Since GLib 2.56, the type of @object will be propagated to the return type
3028  * under the same conditions as for g_object_ref().
3029  *
3030  * Since: 2.10
3031  *
3032  * Returns: (type GObject.Object) (transfer none): @object
3033  */
3034 gpointer
3035 (g_object_ref_sink) (gpointer _object)
3036 {
3037   GObject *object = _object;
3038   gboolean was_floating;
3039   g_return_val_if_fail (G_IS_OBJECT (object), object);
<a name="111" id="anc111"></a><span class="line-modified">3040   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1, object);</span>
3041   g_object_ref (object);
3042   was_floating = floating_flag_handler (object, -1);
3043   if (was_floating)
3044     g_object_unref (object);
3045   return object;
3046 }
3047 
3048 /**
3049  * g_object_force_floating:
3050  * @object: a #GObject
3051  *
3052  * This function is intended for #GObject implementations to re-enforce
3053  * a [floating][floating-ref] object reference. Doing this is seldom
3054  * required: all #GInitiallyUnowneds are created with a floating reference
3055  * which usually just needs to be sunken by calling g_object_ref_sink().
3056  *
3057  * Since: 2.10
3058  */
3059 void
3060 g_object_force_floating (GObject *object)
3061 {
3062   g_return_if_fail (G_IS_OBJECT (object));
<a name="112" id="anc112"></a><span class="line-modified">3063   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
3064 
3065   floating_flag_handler (object, +1);
3066 }
3067 
3068 typedef struct {
3069   GObject *object;
3070   guint n_toggle_refs;
3071   struct {
3072     GToggleNotify notify;
3073     gpointer    data;
3074   } toggle_refs[1];  /* flexible array */
3075 } ToggleRefStack;
3076 
3077 static void
3078 toggle_refs_notify (GObject *object,
<a name="113" id="anc113"></a><span class="line-modified">3079         gboolean is_last_ref)</span>
3080 {
3081   ToggleRefStack tstack, *tstackptr;
3082 
3083   G_LOCK (toggle_refs_mutex);
3084   tstackptr = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3085   tstack = *tstackptr;
3086   G_UNLOCK (toggle_refs_mutex);
3087 
3088   /* Reentrancy here is not as tricky as it seems, because a toggle reference
3089    * will only be notified when there is exactly one of them.
3090    */
3091   g_assert (tstack.n_toggle_refs == 1);
3092   tstack.toggle_refs[0].notify (tstack.toggle_refs[0].data, tstack.object, is_last_ref);
3093 }
3094 
3095 /**
3096  * g_object_add_toggle_ref: (skip)
3097  * @object: a #GObject
3098  * @notify: a function to call when this reference is the
3099  *  last reference to the object, or is no longer
3100  *  the last reference.
3101  * @data: data to pass to @notify
3102  *
3103  * Increases the reference count of the object by one and sets a
3104  * callback to be called when all other references to the object are
3105  * dropped, or when this is already the last reference to the object
3106  * and another reference is established.
3107  *
3108  * This functionality is intended for binding @object to a proxy
3109  * object managed by another memory manager. This is done with two
3110  * paired references: the strong reference added by
3111  * g_object_add_toggle_ref() and a reverse reference to the proxy
3112  * object which is either a strong reference or weak reference.
3113  *
3114  * The setup is that when there are no other references to @object,
3115  * only a weak reference is held in the reverse direction from @object
3116  * to the proxy object, but when there are other references held to
3117  * @object, a strong reference is held. The @notify callback is called
3118  * when the reference from @object to the proxy object should be
3119  * &quot;toggled&quot; from strong to weak (@is_last_ref true) or weak to strong
3120  * (@is_last_ref false).
3121  *
3122  * Since a (normal) reference must be held to the object before
3123  * calling g_object_add_toggle_ref(), the initial state of the reverse
3124  * link is always strong.
3125  *
3126  * Multiple toggle references may be added to the same gobject,
3127  * however if there are multiple toggle references to an object, none
3128  * of them will ever be notified until all but one are removed.  For
3129  * this reason, you should only ever use a toggle reference if there
3130  * is important state in the proxy object.
3131  *
3132  * Since: 2.8
3133  */
3134 void
3135 g_object_add_toggle_ref (GObject       *object,
<a name="114" id="anc114"></a><span class="line-modified">3136        GToggleNotify  notify,</span>
<span class="line-modified">3137        gpointer       data)</span>
3138 {
3139   ToggleRefStack *tstack;
3140   guint i;
3141 
3142   g_return_if_fail (G_IS_OBJECT (object));
3143   g_return_if_fail (notify != NULL);
<a name="115" id="anc115"></a><span class="line-modified">3144   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
3145 
3146   g_object_ref (object);
3147 
3148   G_LOCK (toggle_refs_mutex);
3149   tstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_toggle_refs);
3150   if (tstack)
3151     {
3152       i = tstack-&gt;n_toggle_refs++;
3153       /* allocate i = tstate-&gt;n_toggle_refs - 1 positions beyond the 1 declared
3154        * in tstate-&gt;toggle_refs */
3155       tstack = g_realloc (tstack, sizeof (*tstack) + sizeof (tstack-&gt;toggle_refs[0]) * i);
3156     }
3157   else
3158     {
3159       tstack = g_renew (ToggleRefStack, NULL, 1);
3160       tstack-&gt;object = object;
3161       tstack-&gt;n_toggle_refs = 1;
3162       i = 0;
3163     }
3164 
3165   /* Set a flag for fast lookup after adding the first toggle reference */
3166   if (tstack-&gt;n_toggle_refs == 1)
3167     g_datalist_set_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
3168 
3169   tstack-&gt;toggle_refs[i].notify = notify;
3170   tstack-&gt;toggle_refs[i].data = data;
3171   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_toggle_refs, tstack,
<a name="116" id="anc116"></a><span class="line-modified">3172              (GDestroyNotify)g_free);</span>
3173   G_UNLOCK (toggle_refs_mutex);
3174 }
3175 
3176 /**
3177  * g_object_remove_toggle_ref: (skip)
3178  * @object: a #GObject
3179  * @notify: a function to call when this reference is the
3180  *  last reference to the object, or is no longer
3181  *  the last reference.
3182  * @data: data to pass to @notify
3183  *
3184  * Removes a reference added with g_object_add_toggle_ref(). The
3185  * reference count of the object is decreased by one.
3186  *
3187  * Since: 2.8
3188  */
3189 void
3190 g_object_remove_toggle_ref (GObject       *object,
<a name="117" id="anc117"></a><span class="line-modified">3191           GToggleNotify  notify,</span>
<span class="line-modified">3192           gpointer       data)</span>
3193 {
3194   ToggleRefStack *tstack;
3195   gboolean found_one = FALSE;
3196 
3197   g_return_if_fail (G_IS_OBJECT (object));
3198   g_return_if_fail (notify != NULL);
3199 
3200   G_LOCK (toggle_refs_mutex);
3201   tstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3202   if (tstack)
3203     {
3204       guint i;
3205 
3206       for (i = 0; i &lt; tstack-&gt;n_toggle_refs; i++)
<a name="118" id="anc118"></a><span class="line-modified">3207   if (tstack-&gt;toggle_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">3208       tstack-&gt;toggle_refs[i].data == data)</span>
<span class="line-modified">3209     {</span>
<span class="line-modified">3210       found_one = TRUE;</span>
<span class="line-modified">3211       tstack-&gt;n_toggle_refs -= 1;</span>
<span class="line-modified">3212       if (i != tstack-&gt;n_toggle_refs)</span>
<span class="line-modified">3213         tstack-&gt;toggle_refs[i] = tstack-&gt;toggle_refs[tstack-&gt;n_toggle_refs];</span>
3214 
<a name="119" id="anc119"></a><span class="line-modified">3215       if (tstack-&gt;n_toggle_refs == 0)</span>
<span class="line-modified">3216         g_datalist_unset_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);</span>
3217 
<a name="120" id="anc120"></a><span class="line-modified">3218       break;</span>
<span class="line-modified">3219     }</span>
3220     }
3221   G_UNLOCK (toggle_refs_mutex);
3222 
3223   if (found_one)
3224     g_object_unref (object);
3225   else
3226     g_warning (&quot;%s: couldn&#39;t find toggle ref %p(%p)&quot;, G_STRFUNC, notify, data);
3227 }
3228 
3229 /**
3230  * g_object_ref:
3231  * @object: (type GObject.Object): a #GObject
3232  *
3233  * Increases the reference count of @object.
3234  *
3235  * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
3236  * of @object will be propagated to the return type (using the GCC typeof()
3237  * extension), so any casting the caller needs to do on the return type must be
3238  * explicit.
3239  *
3240  * Returns: (type GObject.Object) (transfer none): the same @object
3241  */
3242 gpointer
3243 (g_object_ref) (gpointer _object)
3244 {
3245   GObject *object = _object;
3246   gint old_val;
3247 
3248   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<a name="121" id="anc121"></a>
3249 
3250   old_val = g_atomic_int_add (&amp;object-&gt;ref_count, 1);
<a name="122" id="anc122"></a><span class="line-added">3251   g_return_val_if_fail (old_val &gt; 0, NULL);</span>
3252 
3253   if (old_val == 1 &amp;&amp; OBJECT_HAS_TOGGLE_REF (object))
3254     toggle_refs_notify (object, FALSE);
3255 
3256   TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));
3257 
3258   return object;
3259 }
3260 
3261 /**
3262  * g_object_unref:
3263  * @object: (type GObject.Object): a #GObject
3264  *
3265  * Decreases the reference count of @object. When its reference count
3266  * drops to 0, the object is finalized (i.e. its memory is freed).
3267  *
3268  * If the pointer to the #GObject may be reused in future (for example, if it is
3269  * an instance variable of another object), it is recommended to clear the
3270  * pointer to %NULL rather than retain a dangling pointer to a potentially
3271  * invalid #GObject instance. Use g_clear_object() for this.
3272  */
3273 void
3274 g_object_unref (gpointer _object)
3275 {
3276   GObject *object = _object;
3277   gint old_ref;
3278 
3279   g_return_if_fail (G_IS_OBJECT (object));
<a name="123" id="anc123"></a>
3280 
3281   /* here we want to atomically do: if (ref_count&gt;1) { ref_count--; return; } */
3282  retry_atomic_decrement1:
3283   old_ref = g_atomic_int_get (&amp;object-&gt;ref_count);
3284   if (old_ref &gt; 1)
3285     {
3286       /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3287       gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3288 
3289       if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<a name="124" id="anc124"></a><span class="line-modified">3290   goto retry_atomic_decrement1;</span>
3291 
3292       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3293 
3294       /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3295       if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<a name="125" id="anc125"></a><span class="line-modified">3296   toggle_refs_notify (object, TRUE);</span>
3297     }
3298   else
3299     {
3300       GSList **weak_locations;
3301 
3302       /* The only way that this object can live at this point is if
3303        * there are outstanding weak references already established
3304        * before we got here.
3305        *
3306        * If there were not already weak references then no more can be
3307        * established at this time, because the other thread would have
3308        * to hold a strong ref in order to call
3309        * g_object_add_weak_pointer() and then we wouldn&#39;t be here.
3310        */
3311       weak_locations = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_locations);
3312 
3313       if (weak_locations != NULL)
3314         {
3315           g_rw_lock_writer_lock (&amp;weak_locations_lock);
3316 
3317           /* It is possible that one of the weak references beat us to
3318            * the lock. Make sure the refcount is still what we expected
3319            * it to be.
3320            */
3321           old_ref = g_atomic_int_get (&amp;object-&gt;ref_count);
3322           if (old_ref != 1)
3323             {
3324               g_rw_lock_writer_unlock (&amp;weak_locations_lock);
3325               goto retry_atomic_decrement1;
3326             }
3327 
3328           /* We got the lock first, so the object will definitely die
3329            * now. Clear out all the weak references.
3330            */
3331           while (*weak_locations)
3332             {
3333               GWeakRef *weak_ref_location = (*weak_locations)-&gt;data;
3334 
3335               weak_ref_location-&gt;priv.p = NULL;
3336               *weak_locations = g_slist_delete_link (*weak_locations, *weak_locations);
3337             }
3338 
3339           g_rw_lock_writer_unlock (&amp;weak_locations_lock);
3340         }
3341 
3342       /* we are about to remove the last reference */
3343       TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 1));
3344       G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
3345       TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 1));
3346 
3347       /* may have been re-referenced meanwhile */
3348     retry_atomic_decrement2:
3349       old_ref = g_atomic_int_get ((int *)&amp;object-&gt;ref_count);
3350       if (old_ref &gt; 1)
3351         {
3352           /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3353           gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3354 
3355           if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<a name="126" id="anc126"></a><span class="line-modified">3356       goto retry_atomic_decrement2;</span>
3357 
<a name="127" id="anc127"></a><span class="line-modified">3358     TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));</span>
3359 
3360           /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3361           if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<a name="128" id="anc128"></a><span class="line-modified">3362       toggle_refs_notify (object, TRUE);</span>
3363 
<a name="129" id="anc129"></a><span class="line-modified">3364     return;</span>
<span class="line-modified">3365   }</span>
3366 
3367       /* we are still in the process of taking away the last ref */
3368       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
3369       g_signal_handlers_destroy (object);
3370       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
3371 
3372       /* decrement the last reference */
3373       old_ref = g_atomic_int_add (&amp;object-&gt;ref_count, -1);
<a name="130" id="anc130"></a><span class="line-added">3374       g_return_if_fail (old_ref &gt; 0);</span>
3375 
3376       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3377 
3378       /* may have been re-referenced meanwhile */
3379       if (G_LIKELY (old_ref == 1))
<a name="131" id="anc131"></a><span class="line-modified">3380   {</span>
<span class="line-modified">3381     TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));</span>
3382           G_OBJECT_GET_CLASS (object)-&gt;finalize (object);
3383 
<a name="132" id="anc132"></a><span class="line-modified">3384     TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));</span>
3385 
3386           GOBJECT_IF_DEBUG (OBJECTS,
<a name="133" id="anc133"></a><span class="line-modified">3387       {</span>
<span class="line-modified">3388               gboolean was_present;</span>
<span class="line-modified">3389 </span>
<span class="line-modified">3390               /* catch objects not chaining finalize handlers */</span>
<span class="line-modified">3391               G_LOCK (debug_objects);</span>
<span class="line-modified">3392               was_present = g_hash_table_remove (debug_objects_ht, object);</span>
<span class="line-added">3393               G_UNLOCK (debug_objects);</span>
<span class="line-added">3394 </span>
<span class="line-added">3395               if (was_present)</span>
<span class="line-added">3396                 g_critical (&quot;Object %p of type %s not finalized correctly.&quot;,</span>
<span class="line-added">3397                             object, G_OBJECT_TYPE_NAME (object));</span>
<span class="line-added">3398       });</span>
3399           g_type_free_instance ((GTypeInstance*) object);
<a name="134" id="anc134"></a><span class="line-modified">3400   }</span>
3401     }
3402 }
3403 
3404 /**
3405  * g_clear_object: (skip)
3406  * @object_ptr: a pointer to a #GObject reference
3407  *
3408  * Clears a reference to a #GObject.
3409  *
3410  * @object_ptr must not be %NULL.
3411  *
3412  * If the reference is %NULL then this function does nothing.
3413  * Otherwise, the reference count of the object is decreased and the
3414  * pointer is set to %NULL.
3415  *
3416  * A macro is also included that allows this function to be used without
3417  * pointer casts.
3418  *
3419  * Since: 2.28
3420  **/
3421 #undef g_clear_object
3422 void
3423 g_clear_object (GObject **object_ptr)
3424 {
3425   g_clear_pointer (object_ptr, g_object_unref);
3426 }
3427 
3428 /**
3429  * g_object_get_qdata:
3430  * @object: The GObject to get a stored user data pointer from
3431  * @quark: A #GQuark, naming the user data pointer
3432  *
3433  * This function gets back user data pointers stored via
3434  * g_object_set_qdata().
3435  *
3436  * Returns: (transfer none) (nullable): The user data pointer set, or %NULL
3437  */
3438 gpointer
3439 g_object_get_qdata (GObject *object,
<a name="135" id="anc135"></a><span class="line-modified">3440         GQuark   quark)</span>
3441 {
3442   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3443 
3444   return quark ? g_datalist_id_get_data (&amp;object-&gt;qdata, quark) : NULL;
3445 }
3446 
3447 /**
3448  * g_object_set_qdata: (skip)
3449  * @object: The GObject to set store a user data pointer
3450  * @quark: A #GQuark, naming the user data pointer
3451  * @data: (nullable): An opaque user data pointer
3452  *
3453  * This sets an opaque, named pointer on an object.
3454  * The name is specified through a #GQuark (retrived e.g. via
3455  * g_quark_from_static_string()), and the pointer
3456  * can be gotten back from the @object with g_object_get_qdata()
3457  * until the @object is finalized.
3458  * Setting a previously set user data pointer, overrides (frees)
3459  * the old pointer set, using #NULL as pointer essentially
3460  * removes the data stored.
3461  */
3462 void
3463 g_object_set_qdata (GObject *object,
<a name="136" id="anc136"></a><span class="line-modified">3464         GQuark   quark,</span>
<span class="line-modified">3465         gpointer data)</span>
3466 {
3467   g_return_if_fail (G_IS_OBJECT (object));
3468   g_return_if_fail (quark &gt; 0);
3469 
3470   g_datalist_id_set_data (&amp;object-&gt;qdata, quark, data);
3471 }
3472 
3473 /**
3474  * g_object_dup_qdata: (skip)
3475  * @object: the #GObject to store user data on
3476  * @quark: a #GQuark, naming the user data pointer
3477  * @dup_func: (nullable): function to dup the value
3478  * @user_data: (nullable): passed as user_data to @dup_func
3479  *
3480  * This is a variant of g_object_get_qdata() which returns
3481  * a &#39;duplicate&#39; of the value. @dup_func defines the
3482  * meaning of &#39;duplicate&#39; in this context, it could e.g.
3483  * take a reference on a ref-counted object.
3484  *
3485  * If the @quark is not set on the object then @dup_func
3486  * will be called with a %NULL argument.
3487  *
3488  * Note that @dup_func is called while user data of @object
3489  * is locked.
3490  *
3491  * This function can be useful to avoid races when multiple
3492  * threads are using object data on the same key on the same
3493  * object.
3494  *
3495  * Returns: the result of calling @dup_func on the value
3496  *     associated with @quark on @object, or %NULL if not set.
3497  *     If @dup_func is %NULL, the value is returned
3498  *     unmodified.
3499  *
3500  * Since: 2.34
3501  */
3502 gpointer
3503 g_object_dup_qdata (GObject        *object,
3504                     GQuark          quark,
3505                     GDuplicateFunc   dup_func,
3506                     gpointer         user_data)
3507 {
3508   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3509   g_return_val_if_fail (quark &gt; 0, NULL);
3510 
3511   return g_datalist_id_dup_data (&amp;object-&gt;qdata, quark, dup_func, user_data);
3512 }
3513 
3514 /**
3515  * g_object_replace_qdata: (skip)
3516  * @object: the #GObject to store user data on
3517  * @quark: a #GQuark, naming the user data pointer
3518  * @oldval: (nullable): the old value to compare against
3519  * @newval: (nullable): the new value
3520  * @destroy: (nullable): a destroy notify for the new value
3521  * @old_destroy: (out) (optional): destroy notify for the existing value
3522  *
3523  * Compares the user data for the key @quark on @object with
3524  * @oldval, and if they are the same, replaces @oldval with
3525  * @newval.
3526  *
3527  * This is like a typical atomic compare-and-exchange
3528  * operation, for user data on an object.
3529  *
3530  * If the previous value was replaced then ownership of the
3531  * old value (@oldval) is passed to the caller, including
3532  * the registered destroy notify for it (passed out in @old_destroy).
3533  * It&#39;s up to the caller to free this as needed, which may
3534  * or may not include using @old_destroy as sometimes replacement
3535  * should not destroy the object in the normal way.
3536  *
3537  * Returns: %TRUE if the existing value for @quark was replaced
3538  *  by @newval, %FALSE otherwise.
3539  *
3540  * Since: 2.34
3541  */
3542 gboolean
3543 g_object_replace_qdata (GObject        *object,
3544                         GQuark          quark,
3545                         gpointer        oldval,
3546                         gpointer        newval,
3547                         GDestroyNotify  destroy,
3548                         GDestroyNotify *old_destroy)
3549 {
3550   g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
3551   g_return_val_if_fail (quark &gt; 0, FALSE);
3552 
3553   return g_datalist_id_replace_data (&amp;object-&gt;qdata, quark,
3554                                      oldval, newval, destroy,
3555                                      old_destroy);
3556 }
3557 
3558 /**
3559  * g_object_set_qdata_full: (skip)
3560  * @object: The GObject to set store a user data pointer
3561  * @quark: A #GQuark, naming the user data pointer
3562  * @data: (nullable): An opaque user data pointer
3563  * @destroy: (nullable): Function to invoke with @data as argument, when @data
3564  *           needs to be freed
3565  *
3566  * This function works like g_object_set_qdata(), but in addition,
3567  * a void (*destroy) (gpointer) function may be specified which is
3568  * called with @data as argument when the @object is finalized, or
3569  * the data is being overwritten by a call to g_object_set_qdata()
3570  * with the same @quark.
3571  */
3572 void
3573 g_object_set_qdata_full (GObject       *object,
<a name="137" id="anc137"></a><span class="line-modified">3574        GQuark   quark,</span>
<span class="line-modified">3575        gpointer data,</span>
<span class="line-modified">3576        GDestroyNotify destroy)</span>
3577 {
3578   g_return_if_fail (G_IS_OBJECT (object));
3579   g_return_if_fail (quark &gt; 0);
3580 
3581   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark, data,
<a name="138" id="anc138"></a><span class="line-modified">3582              data ? destroy : (GDestroyNotify) NULL);</span>
3583 }
3584 
3585 /**
3586  * g_object_steal_qdata:
3587  * @object: The GObject to get a stored user data pointer from
3588  * @quark: A #GQuark, naming the user data pointer
3589  *
3590  * This function gets back user data pointers stored via
3591  * g_object_set_qdata() and removes the @data from object
3592  * without invoking its destroy() function (if any was
3593  * set).
3594  * Usually, calling this function is only required to update
3595  * user data pointers with a destroy notifier, for example:
3596  * |[&lt;!-- language=&quot;C&quot; --&gt;
3597  * void
3598  * object_add_to_user_list (GObject     *object,
3599  *                          const gchar *new_string)
3600  * {
3601  *   // the quark, naming the object data
3602  *   GQuark quark_string_list = g_quark_from_static_string (&quot;my-string-list&quot;);
3603  *   // retrive the old string list
3604  *   GList *list = g_object_steal_qdata (object, quark_string_list);
3605  *
3606  *   // prepend new string
3607  *   list = g_list_prepend (list, g_strdup (new_string));
3608  *   // this changed &#39;list&#39;, so we need to set it again
3609  *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
3610  * }
3611  * static void
3612  * free_string_list (gpointer data)
3613  * {
3614  *   GList *node, *list = data;
3615  *
3616  *   for (node = list; node; node = node-&gt;next)
3617  *     g_free (node-&gt;data);
3618  *   g_list_free (list);
3619  * }
3620  * ]|
3621  * Using g_object_get_qdata() in the above example, instead of
3622  * g_object_steal_qdata() would have left the destroy function set,
3623  * and thus the partial string list would have been freed upon
3624  * g_object_set_qdata_full().
3625  *
3626  * Returns: (transfer full) (nullable): The user data pointer set, or %NULL
3627  */
3628 gpointer
3629 g_object_steal_qdata (GObject *object,
<a name="139" id="anc139"></a><span class="line-modified">3630           GQuark   quark)</span>
3631 {
3632   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3633   g_return_val_if_fail (quark &gt; 0, NULL);
3634 
3635   return g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark);
3636 }
3637 
3638 /**
3639  * g_object_get_data:
3640  * @object: #GObject containing the associations
3641  * @key: name of the key for that association
3642  *
3643  * Gets a named field from the objects table of associations (see g_object_set_data()).
3644  *
3645  * Returns: (transfer none) (nullable): the data if found,
3646  *          or %NULL if no such data exists.
3647  */
3648 gpointer
3649 g_object_get_data (GObject     *object,
3650                    const gchar *key)
3651 {
3652   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3653   g_return_val_if_fail (key != NULL, NULL);
3654 
3655   return g_datalist_get_data (&amp;object-&gt;qdata, key);
3656 }
3657 
3658 /**
3659  * g_object_set_data:
3660  * @object: #GObject containing the associations.
3661  * @key: name of the key
3662  * @data: (nullable): data to associate with that key
3663  *
3664  * Each object carries around a table of associations from
3665  * strings to pointers.  This function lets you set an association.
3666  *
3667  * If the object already had an association with that name,
3668  * the old association will be destroyed.
<a name="140" id="anc140"></a><span class="line-added">3669  *</span>
<span class="line-added">3670  * Internally, the @key is converted to a #GQuark using g_quark_from_string().</span>
<span class="line-added">3671  * This means a copy of @key is kept permanently (even after @object has been</span>
<span class="line-added">3672  * finalized) - so it is recommended to only use a small, bounded set of values</span>
<span class="line-added">3673  * for @key in your program, to avoid the #GQuark storage growing unbounded.</span>
3674  */
3675 void
3676 g_object_set_data (GObject     *object,
3677                    const gchar *key,
3678                    gpointer     data)
3679 {
3680   g_return_if_fail (G_IS_OBJECT (object));
3681   g_return_if_fail (key != NULL);
3682 
3683   g_datalist_id_set_data (&amp;object-&gt;qdata, g_quark_from_string (key), data);
3684 }
3685 
3686 /**
3687  * g_object_dup_data: (skip)
3688  * @object: the #GObject to store user data on
3689  * @key: a string, naming the user data pointer
3690  * @dup_func: (nullable): function to dup the value
3691  * @user_data: (nullable): passed as user_data to @dup_func
3692  *
3693  * This is a variant of g_object_get_data() which returns
3694  * a &#39;duplicate&#39; of the value. @dup_func defines the
3695  * meaning of &#39;duplicate&#39; in this context, it could e.g.
3696  * take a reference on a ref-counted object.
3697  *
3698  * If the @key is not set on the object then @dup_func
3699  * will be called with a %NULL argument.
3700  *
3701  * Note that @dup_func is called while user data of @object
3702  * is locked.
3703  *
3704  * This function can be useful to avoid races when multiple
3705  * threads are using object data on the same key on the same
3706  * object.
3707  *
3708  * Returns: the result of calling @dup_func on the value
3709  *     associated with @key on @object, or %NULL if not set.
3710  *     If @dup_func is %NULL, the value is returned
3711  *     unmodified.
3712  *
3713  * Since: 2.34
3714  */
3715 gpointer
3716 g_object_dup_data (GObject        *object,
3717                    const gchar    *key,
3718                    GDuplicateFunc   dup_func,
3719                    gpointer         user_data)
3720 {
3721   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3722   g_return_val_if_fail (key != NULL, NULL);
3723 
3724   return g_datalist_id_dup_data (&amp;object-&gt;qdata,
3725                                  g_quark_from_string (key),
3726                                  dup_func, user_data);
3727 }
3728 
3729 /**
3730  * g_object_replace_data: (skip)
3731  * @object: the #GObject to store user data on
3732  * @key: a string, naming the user data pointer
3733  * @oldval: (nullable): the old value to compare against
3734  * @newval: (nullable): the new value
3735  * @destroy: (nullable): a destroy notify for the new value
3736  * @old_destroy: (out) (optional): destroy notify for the existing value
3737  *
3738  * Compares the user data for the key @key on @object with
3739  * @oldval, and if they are the same, replaces @oldval with
3740  * @newval.
3741  *
3742  * This is like a typical atomic compare-and-exchange
3743  * operation, for user data on an object.
3744  *
3745  * If the previous value was replaced then ownership of the
3746  * old value (@oldval) is passed to the caller, including
3747  * the registered destroy notify for it (passed out in @old_destroy).
3748  * It&#39;s up to the caller to free this as needed, which may
3749  * or may not include using @old_destroy as sometimes replacement
3750  * should not destroy the object in the normal way.
3751  *
<a name="141" id="anc141"></a><span class="line-added">3752  * See g_object_set_data() for guidance on using a small, bounded set of values</span>
<span class="line-added">3753  * for @key.</span>
<span class="line-added">3754  *</span>
3755  * Returns: %TRUE if the existing value for @key was replaced
3756  *  by @newval, %FALSE otherwise.
3757  *
3758  * Since: 2.34
3759  */
3760 gboolean
3761 g_object_replace_data (GObject        *object,
3762                        const gchar    *key,
3763                        gpointer        oldval,
3764                        gpointer        newval,
3765                        GDestroyNotify  destroy,
3766                        GDestroyNotify *old_destroy)
3767 {
3768   g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
3769   g_return_val_if_fail (key != NULL, FALSE);
3770 
3771   return g_datalist_id_replace_data (&amp;object-&gt;qdata,
3772                                      g_quark_from_string (key),
3773                                      oldval, newval, destroy,
3774                                      old_destroy);
3775 }
3776 
3777 /**
3778  * g_object_set_data_full: (skip)
3779  * @object: #GObject containing the associations
3780  * @key: name of the key
3781  * @data: (nullable): data to associate with that key
3782  * @destroy: (nullable): function to call when the association is destroyed
3783  *
3784  * Like g_object_set_data() except it adds notification
3785  * for when the association is destroyed, either by setting it
3786  * to a different value or when the object is destroyed.
3787  *
3788  * Note that the @destroy callback is not called if @data is %NULL.
3789  */
3790 void
3791 g_object_set_data_full (GObject       *object,
3792                         const gchar   *key,
3793                         gpointer       data,
3794                         GDestroyNotify destroy)
3795 {
3796   g_return_if_fail (G_IS_OBJECT (object));
3797   g_return_if_fail (key != NULL);
3798 
3799   g_datalist_id_set_data_full (&amp;object-&gt;qdata, g_quark_from_string (key), data,
<a name="142" id="anc142"></a><span class="line-modified">3800              data ? destroy : (GDestroyNotify) NULL);</span>
3801 }
3802 
3803 /**
3804  * g_object_steal_data:
3805  * @object: #GObject containing the associations
3806  * @key: name of the key
3807  *
3808  * Remove a specified datum from the object&#39;s data associations,
3809  * without invoking the association&#39;s destroy handler.
3810  *
3811  * Returns: (transfer full) (nullable): the data if found, or %NULL
3812  *          if no such data exists.
3813  */
3814 gpointer
3815 g_object_steal_data (GObject     *object,
3816                      const gchar *key)
3817 {
3818   GQuark quark;
3819 
3820   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3821   g_return_val_if_fail (key != NULL, NULL);
3822 
3823   quark = g_quark_try_string (key);
3824 
3825   return quark ? g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark) : NULL;
3826 }
3827 
3828 static void
3829 g_value_object_init (GValue *value)
3830 {
3831   value-&gt;data[0].v_pointer = NULL;
3832 }
3833 
3834 static void
3835 g_value_object_free_value (GValue *value)
3836 {
3837   if (value-&gt;data[0].v_pointer)
3838     g_object_unref (value-&gt;data[0].v_pointer);
3839 }
3840 
3841 static void
3842 g_value_object_copy_value (const GValue *src_value,
<a name="143" id="anc143"></a><span class="line-modified">3843          GValue *dest_value)</span>
3844 {
3845   if (src_value-&gt;data[0].v_pointer)
3846     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3847   else
3848     dest_value-&gt;data[0].v_pointer = NULL;
3849 }
3850 
3851 static void
3852 g_value_object_transform_value (const GValue *src_value,
<a name="144" id="anc144"></a><span class="line-modified">3853         GValue       *dest_value)</span>
3854 {
3855   if (src_value-&gt;data[0].v_pointer &amp;&amp; g_type_is_a (G_OBJECT_TYPE (src_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
3856     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3857   else
3858     dest_value-&gt;data[0].v_pointer = NULL;
3859 }
3860 
3861 static gpointer
3862 g_value_object_peek_pointer (const GValue *value)
3863 {
3864   return value-&gt;data[0].v_pointer;
3865 }
3866 
3867 static gchar*
<a name="145" id="anc145"></a><span class="line-modified">3868 g_value_object_collect_value (GValue    *value,</span>
<span class="line-modified">3869             guint        n_collect_values,</span>
<span class="line-modified">3870             GTypeCValue *collect_values,</span>
<span class="line-modified">3871             guint        collect_flags)</span>
3872 {
3873   if (collect_values[0].v_pointer)
3874     {
3875       GObject *object = collect_values[0].v_pointer;
3876 
3877       if (object-&gt;g_type_instance.g_class == NULL)
<a name="146" id="anc146"></a><span class="line-modified">3878   return g_strconcat (&quot;invalid unclassed object pointer for value type &#39;&quot;,</span>
<span class="line-modified">3879           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3880           &quot;&#39;&quot;,</span>
<span class="line-modified">3881           NULL);</span>
3882       else if (!g_value_type_compatible (G_OBJECT_TYPE (object), G_VALUE_TYPE (value)))
<a name="147" id="anc147"></a><span class="line-modified">3883   return g_strconcat (&quot;invalid object type &#39;&quot;,</span>
<span class="line-modified">3884           G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">3885           &quot;&#39; for value type &#39;&quot;,</span>
<span class="line-modified">3886           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3887           &quot;&#39;&quot;,</span>
<span class="line-modified">3888           NULL);</span>
3889       /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
3890       value-&gt;data[0].v_pointer = g_object_ref (object);
3891     }
3892   else
3893     value-&gt;data[0].v_pointer = NULL;
3894 
3895   return NULL;
3896 }
3897 
3898 static gchar*
3899 g_value_object_lcopy_value (const GValue *value,
<a name="148" id="anc148"></a><span class="line-modified">3900           guint        n_collect_values,</span>
<span class="line-modified">3901           GTypeCValue *collect_values,</span>
<span class="line-modified">3902           guint        collect_flags)</span>
3903 {
3904   GObject **object_p = collect_values[0].v_pointer;
3905 
3906   if (!object_p)
3907     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
3908 
3909   if (!value-&gt;data[0].v_pointer)
3910     *object_p = NULL;
3911   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
3912     *object_p = value-&gt;data[0].v_pointer;
3913   else
3914     *object_p = g_object_ref (value-&gt;data[0].v_pointer);
3915 
3916   return NULL;
3917 }
3918 
3919 /**
3920  * g_value_set_object:
3921  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3922  * @v_object: (type GObject.Object) (nullable): object value to be set
3923  *
3924  * Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.
3925  *
3926  * g_value_set_object() increases the reference count of @v_object
3927  * (the #GValue holds a reference to @v_object).  If you do not wish
3928  * to increase the reference count of the object (i.e. you wish to
3929  * pass your current reference to the #GValue because you no longer
3930  * need it), use g_value_take_object() instead.
3931  *
3932  * It is important that your #GValue holds a reference to @v_object (either its
3933  * own, or one it has taken) to ensure that the object won&#39;t be destroyed while
3934  * the #GValue still exists).
3935  */
3936 void
3937 g_value_set_object (GValue   *value,
<a name="149" id="anc149"></a><span class="line-modified">3938         gpointer  v_object)</span>
3939 {
3940   GObject *old;
3941 
3942   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3943 
3944   old = value-&gt;data[0].v_pointer;
3945 
3946   if (v_object)
3947     {
3948       g_return_if_fail (G_IS_OBJECT (v_object));
3949       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
3950 
3951       value-&gt;data[0].v_pointer = v_object;
3952       g_object_ref (value-&gt;data[0].v_pointer);
3953     }
3954   else
3955     value-&gt;data[0].v_pointer = NULL;
3956 
3957   if (old)
3958     g_object_unref (old);
3959 }
3960 
3961 /**
3962  * g_value_set_object_take_ownership: (skip)
3963  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3964  * @v_object: (nullable): object value to be set
3965  *
3966  * This is an internal function introduced mainly for C marshallers.
3967  *
3968  * Deprecated: 2.4: Use g_value_take_object() instead.
3969  */
3970 void
3971 g_value_set_object_take_ownership (GValue  *value,
<a name="150" id="anc150"></a><span class="line-modified">3972            gpointer v_object)</span>
3973 {
3974   g_value_take_object (value, v_object);
3975 }
3976 
3977 /**
3978  * g_value_take_object: (skip)
3979  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3980  * @v_object: (nullable): object value to be set
3981  *
3982  * Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
<a name="151" id="anc151"></a><span class="line-modified">3983  * and takes over the ownership of the caller&#39;s reference to @v_object;</span>
3984  * the caller doesn&#39;t have to unref it any more (i.e. the reference
3985  * count of the object is not increased).
3986  *
3987  * If you want the #GValue to hold its own reference to @v_object, use
3988  * g_value_set_object() instead.
3989  *
3990  * Since: 2.4
3991  */
3992 void
3993 g_value_take_object (GValue  *value,
<a name="152" id="anc152"></a><span class="line-modified">3994          gpointer v_object)</span>
3995 {
3996   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3997 
3998   if (value-&gt;data[0].v_pointer)
3999     {
4000       g_object_unref (value-&gt;data[0].v_pointer);
4001       value-&gt;data[0].v_pointer = NULL;
4002     }
4003 
4004   if (v_object)
4005     {
4006       g_return_if_fail (G_IS_OBJECT (v_object));
4007       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
4008 
4009       value-&gt;data[0].v_pointer = v_object; /* we take over the reference count */
4010     }
4011 }
4012 
4013 /**
4014  * g_value_get_object:
4015  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
4016  *
4017  * Get the contents of a %G_TYPE_OBJECT derived #GValue.
4018  *
4019  * Returns: (type GObject.Object) (transfer none): object contents of @value
4020  */
4021 gpointer
4022 g_value_get_object (const GValue *value)
4023 {
4024   g_return_val_if_fail (G_VALUE_HOLDS_OBJECT (value), NULL);
4025 
4026   return value-&gt;data[0].v_pointer;
4027 }
4028 
4029 /**
4030  * g_value_dup_object:
4031  * @value: a valid #GValue whose type is derived from %G_TYPE_OBJECT
4032  *
4033  * Get the contents of a %G_TYPE_OBJECT derived #GValue, increasing
4034  * its reference count. If the contents of the #GValue are %NULL, then
4035  * %NULL will be returned.
4036  *
4037  * Returns: (type GObject.Object) (transfer full): object content of @value,
4038  *          should be unreferenced when no longer needed.
4039  */
4040 gpointer
4041 g_value_dup_object (const GValue *value)
4042 {
4043   g_return_val_if_fail (G_VALUE_HOLDS_OBJECT (value), NULL);
4044 
4045   return value-&gt;data[0].v_pointer ? g_object_ref (value-&gt;data[0].v_pointer) : NULL;
4046 }
4047 
4048 /**
4049  * g_signal_connect_object: (skip)
4050  * @instance: (type GObject.TypeInstance): the instance to connect to.
4051  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
4052  * @c_handler: the #GCallback to connect.
4053  * @gobject: (type GObject.Object) (nullable): the object to pass as data
4054  *    to @c_handler.
4055  * @connect_flags: a combination of #GConnectFlags.
4056  *
4057  * This is similar to g_signal_connect_data(), but uses a closure which
4058  * ensures that the @gobject stays alive during the call to @c_handler
4059  * by temporarily adding a reference count to @gobject.
4060  *
4061  * When the @gobject is destroyed the signal handler will be automatically
4062  * disconnected.  Note that this is not currently threadsafe (ie:
4063  * emitting a signal while @gobject is being destroyed in another thread
4064  * is not safe).
4065  *
4066  * Returns: the handler id.
4067  */
4068 gulong
4069 g_signal_connect_object (gpointer      instance,
<a name="153" id="anc153"></a><span class="line-modified">4070        const gchar  *detailed_signal,</span>
<span class="line-modified">4071        GCallback     c_handler,</span>
<span class="line-modified">4072        gpointer      gobject,</span>
<span class="line-modified">4073        GConnectFlags connect_flags)</span>
4074 {
4075   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
4076   g_return_val_if_fail (detailed_signal != NULL, 0);
4077   g_return_val_if_fail (c_handler != NULL, 0);
4078 
4079   if (gobject)
4080     {
4081       GClosure *closure;
4082 
4083       g_return_val_if_fail (G_IS_OBJECT (gobject), 0);
4084 
4085       closure = ((connect_flags &amp; G_CONNECT_SWAPPED) ? g_cclosure_new_object_swap : g_cclosure_new_object) (c_handler, gobject);
4086 
4087       return g_signal_connect_closure (instance, detailed_signal, closure, connect_flags &amp; G_CONNECT_AFTER);
4088     }
4089   else
4090     return g_signal_connect_data (instance, detailed_signal, c_handler, NULL, NULL, connect_flags);
4091 }
4092 
4093 typedef struct {
4094   GObject  *object;
4095   guint     n_closures;
4096   GClosure *closures[1]; /* flexible array */
4097 } CArray;
4098 /* don&#39;t change this structure without supplying an accessor for
4099  * watched closures, e.g.:
4100  * GSList* g_object_list_watched_closures (GObject *object)
4101  * {
4102  *   CArray *carray;
4103  *   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
4104  *   carray = g_object_get_data (object, &quot;GObject-closure-array&quot;);
4105  *   if (carray)
4106  *     {
4107  *       GSList *slist = NULL;
4108  *       guint i;
4109  *       for (i = 0; i &lt; carray-&gt;n_closures; i++)
4110  *         slist = g_slist_prepend (slist, carray-&gt;closures[i]);
4111  *       return slist;
4112  *     }
4113  *   return NULL;
4114  * }
4115  */
4116 
4117 static void
4118 object_remove_closure (gpointer  data,
<a name="154" id="anc154"></a><span class="line-modified">4119            GClosure *closure)</span>
4120 {
4121   GObject *object = data;
4122   CArray *carray;
4123   guint i;
4124 
4125   G_LOCK (closure_array_mutex);
4126   carray = g_object_get_qdata (object, quark_closure_array);
4127   for (i = 0; i &lt; carray-&gt;n_closures; i++)
4128     if (carray-&gt;closures[i] == closure)
4129       {
<a name="155" id="anc155"></a><span class="line-modified">4130   carray-&gt;n_closures--;</span>
<span class="line-modified">4131   if (i &lt; carray-&gt;n_closures)</span>
<span class="line-modified">4132     carray-&gt;closures[i] = carray-&gt;closures[carray-&gt;n_closures];</span>
<span class="line-modified">4133   G_UNLOCK (closure_array_mutex);</span>
<span class="line-modified">4134   return;</span>
4135       }
4136   G_UNLOCK (closure_array_mutex);
4137   g_assert_not_reached ();
4138 }
4139 
4140 static void
4141 destroy_closure_array (gpointer data)
4142 {
4143   CArray *carray = data;
4144   GObject *object = carray-&gt;object;
4145   guint i, n = carray-&gt;n_closures;
4146 
4147   for (i = 0; i &lt; n; i++)
4148     {
4149       GClosure *closure = carray-&gt;closures[i];
4150 
4151       /* removing object_remove_closure() upfront is probably faster than
4152        * letting it fiddle with quark_closure_array which is empty anyways
4153        */
4154       g_closure_remove_invalidate_notifier (closure, object, object_remove_closure);
4155       g_closure_invalidate (closure);
4156     }
4157   g_free (carray);
4158 }
4159 
4160 /**
4161  * g_object_watch_closure:
<a name="156" id="anc156"></a><span class="line-modified">4162  * @object: #GObject restricting lifetime of @closure</span>
<span class="line-modified">4163  * @closure: #GClosure to watch</span>
4164  *
4165  * This function essentially limits the life time of the @closure to
4166  * the life time of the object. That is, when the object is finalized,
4167  * the @closure is invalidated by calling g_closure_invalidate() on
4168  * it, in order to prevent invocations of the closure with a finalized
4169  * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
4170  * added as marshal guards to the @closure, to ensure that an extra
4171  * reference count is held on @object during invocation of the
4172  * @closure.  Usually, this function will be called on closures that
4173  * use this @object as closure data.
4174  */
4175 void
4176 g_object_watch_closure (GObject  *object,
<a name="157" id="anc157"></a><span class="line-modified">4177       GClosure *closure)</span>
4178 {
4179   CArray *carray;
4180   guint i;
4181 
4182   g_return_if_fail (G_IS_OBJECT (object));
4183   g_return_if_fail (closure != NULL);
4184   g_return_if_fail (closure-&gt;is_invalid == FALSE);
4185   g_return_if_fail (closure-&gt;in_marshal == FALSE);
<a name="158" id="anc158"></a><span class="line-modified">4186   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0); /* this doesn&#39;t work on finalizing objects */</span>
4187 
4188   g_closure_add_invalidate_notifier (closure, object, object_remove_closure);
4189   g_closure_add_marshal_guards (closure,
<a name="159" id="anc159"></a><span class="line-modified">4190         object, (GClosureNotify) g_object_ref,</span>
<span class="line-modified">4191         object, (GClosureNotify) g_object_unref);</span>
4192   G_LOCK (closure_array_mutex);
4193   carray = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_closure_array);
4194   if (!carray)
4195     {
4196       carray = g_renew (CArray, NULL, 1);
4197       carray-&gt;object = object;
4198       carray-&gt;n_closures = 1;
4199       i = 0;
4200     }
4201   else
4202     {
4203       i = carray-&gt;n_closures++;
4204       carray = g_realloc (carray, sizeof (*carray) + sizeof (carray-&gt;closures[0]) * i);
4205     }
4206   carray-&gt;closures[i] = closure;
4207   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_closure_array, carray, destroy_closure_array);
4208   G_UNLOCK (closure_array_mutex);
4209 }
4210 
4211 /**
4212  * g_closure_new_object:
4213  * @sizeof_closure: the size of the structure to allocate, must be at least
4214  *  `sizeof (GClosure)`
4215  * @object: a #GObject pointer to store in the @data field of the newly
4216  *  allocated #GClosure
4217  *
4218  * A variant of g_closure_new_simple() which stores @object in the
4219  * @data field of the closure and calls g_object_watch_closure() on
4220  * @object and the created closure. This function is mainly useful
4221  * when implementing new types of closures.
4222  *
4223  * Returns: (transfer full): a newly allocated #GClosure
4224  */
4225 GClosure*
4226 g_closure_new_object (guint    sizeof_closure,
<a name="160" id="anc160"></a><span class="line-modified">4227           GObject *object)</span>
4228 {
4229   GClosure *closure;
4230 
4231   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<a name="161" id="anc161"></a><span class="line-modified">4232   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4233 
4234   closure = g_closure_new_simple (sizeof_closure, object);
4235   g_object_watch_closure (object, closure);
4236 
4237   return closure;
4238 }
4239 
4240 /**
4241  * g_cclosure_new_object: (skip)
4242  * @callback_func: the function to invoke
4243  * @object: a #GObject pointer to pass to @callback_func
4244  *
4245  * A variant of g_cclosure_new() which uses @object as @user_data and
4246  * calls g_object_watch_closure() on @object and the created
4247  * closure. This function is useful when you have a callback closely
4248  * associated with a #GObject, and want the callback to no longer run
4249  * after the object is is freed.
4250  *
4251  * Returns: a new #GCClosure
4252  */
4253 GClosure*
4254 g_cclosure_new_object (GCallback callback_func,
<a name="162" id="anc162"></a><span class="line-modified">4255            GObject  *object)</span>
4256 {
4257   GClosure *closure;
4258 
4259   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<a name="163" id="anc163"></a><span class="line-modified">4260   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4261   g_return_val_if_fail (callback_func != NULL, NULL);
4262 
4263   closure = g_cclosure_new (callback_func, object, NULL);
4264   g_object_watch_closure (object, closure);
4265 
4266   return closure;
4267 }
4268 
4269 /**
4270  * g_cclosure_new_object_swap: (skip)
4271  * @callback_func: the function to invoke
4272  * @object: a #GObject pointer to pass to @callback_func
4273  *
4274  * A variant of g_cclosure_new_swap() which uses @object as @user_data
4275  * and calls g_object_watch_closure() on @object and the created
4276  * closure. This function is useful when you have a callback closely
4277  * associated with a #GObject, and want the callback to no longer run
4278  * after the object is is freed.
4279  *
4280  * Returns: a new #GCClosure
4281  */
4282 GClosure*
4283 g_cclosure_new_object_swap (GCallback callback_func,
<a name="164" id="anc164"></a><span class="line-modified">4284           GObject  *object)</span>
4285 {
4286   GClosure *closure;
4287 
4288   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<a name="165" id="anc165"></a><span class="line-modified">4289   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4290   g_return_val_if_fail (callback_func != NULL, NULL);
4291 
4292   closure = g_cclosure_new_swap (callback_func, object, NULL);
4293   g_object_watch_closure (object, closure);
4294 
4295   return closure;
4296 }
4297 
4298 gsize
4299 g_object_compat_control (gsize           what,
4300                          gpointer        data)
4301 {
4302   switch (what)
4303     {
4304       gpointer *pp;
4305     case 1:     /* floating base type */
4306       return G_TYPE_INITIALLY_UNOWNED;
4307     case 2:     /* FIXME: remove this once GLib/Gtk+ break ABI again */
4308       floating_flag_handler = (guint(*)(GObject*,gint)) data;
4309       return 1;
4310     case 3:     /* FIXME: remove this once GLib/Gtk+ break ABI again */
4311       pp = data;
4312       *pp = floating_flag_handler;
4313       return 1;
4314     default:
4315       return 0;
4316     }
4317 }
4318 
4319 G_DEFINE_TYPE (GInitiallyUnowned, g_initially_unowned, G_TYPE_OBJECT)
4320 
4321 static void
4322 g_initially_unowned_init (GInitiallyUnowned *object)
4323 {
4324   g_object_force_floating (object);
4325 }
4326 
4327 static void
4328 g_initially_unowned_class_init (GInitiallyUnownedClass *klass)
4329 {
4330 }
4331 
4332 /**
4333  * GWeakRef:
4334  *
4335  * A structure containing a weak reference to a #GObject.  It can either
4336  * be empty (i.e. point to %NULL), or point to an object for as long as
4337  * at least one &quot;strong&quot; reference to that object exists. Before the
4338  * object&#39;s #GObjectClass.dispose method is called, every #GWeakRef
4339  * associated with becomes empty (i.e. points to %NULL).
4340  *
4341  * Like #GValue, #GWeakRef can be statically allocated, stack- or
4342  * heap-allocated, or embedded in larger structures.
4343  *
4344  * Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
4345  * reference is thread-safe: converting a weak pointer to a reference is
4346  * atomic with respect to invalidation of weak pointers to destroyed
4347  * objects.
4348  *
4349  * If the object&#39;s #GObjectClass.dispose method results in additional
4350  * references to the object being held, any #GWeakRefs taken
4351  * before it was disposed will continue to point to %NULL.  If
4352  * #GWeakRefs are taken after the object is disposed and
4353  * re-referenced, they will continue to point to it until its refcount
4354  * goes back to zero, at which point they too will be invalidated.
4355  */
4356 
4357 /**
4358  * g_weak_ref_init: (skip)
4359  * @weak_ref: (inout): uninitialized or empty location for a weak
4360  *    reference
4361  * @object: (type GObject.Object) (nullable): a #GObject or %NULL
4362  *
4363  * Initialise a non-statically-allocated #GWeakRef.
4364  *
4365  * This function also calls g_weak_ref_set() with @object on the
4366  * freshly-initialised weak reference.
4367  *
4368  * This function should always be matched with a call to
4369  * g_weak_ref_clear().  It is not necessary to use this function for a
4370  * #GWeakRef in static storage because it will already be
4371  * properly initialised.  Just use g_weak_ref_set() directly.
4372  *
4373  * Since: 2.32
4374  */
4375 void
4376 g_weak_ref_init (GWeakRef *weak_ref,
4377                  gpointer  object)
4378 {
4379   weak_ref-&gt;priv.p = NULL;
4380 
4381   g_weak_ref_set (weak_ref, object);
4382 }
4383 
4384 /**
4385  * g_weak_ref_clear: (skip)
4386  * @weak_ref: (inout): location of a weak reference, which
4387  *  may be empty
4388  *
4389  * Frees resources associated with a non-statically-allocated #GWeakRef.
4390  * After this call, the #GWeakRef is left in an undefined state.
4391  *
4392  * You should only call this on a #GWeakRef that previously had
4393  * g_weak_ref_init() called on it.
4394  *
4395  * Since: 2.32
4396  */
4397 void
4398 g_weak_ref_clear (GWeakRef *weak_ref)
4399 {
4400   g_weak_ref_set (weak_ref, NULL);
4401 
4402   /* be unkind */
4403   weak_ref-&gt;priv.p = (void *) 0xccccccccu;
4404 }
4405 
4406 /**
4407  * g_weak_ref_get: (skip)
4408  * @weak_ref: (inout): location of a weak reference to a #GObject
4409  *
4410  * If @weak_ref is not empty, atomically acquire a strong
4411  * reference to the object it points to, and return that reference.
4412  *
4413  * This function is needed because of the potential race between taking
4414  * the pointer value and g_object_ref() on it, if the object was losing
4415  * its last reference at the same time in a different thread.
4416  *
4417  * The caller should release the resulting reference in the usual way,
4418  * by using g_object_unref().
4419  *
4420  * Returns: (transfer full) (type GObject.Object): the object pointed to
4421  *     by @weak_ref, or %NULL if it was empty
4422  *
4423  * Since: 2.32
4424  */
4425 gpointer
4426 g_weak_ref_get (GWeakRef *weak_ref)
4427 {
4428   gpointer object_or_null;
4429 
4430   g_return_val_if_fail (weak_ref!= NULL, NULL);
4431 
4432   g_rw_lock_reader_lock (&amp;weak_locations_lock);
4433 
4434   object_or_null = weak_ref-&gt;priv.p;
4435 
4436   if (object_or_null != NULL)
4437     g_object_ref (object_or_null);
4438 
4439   g_rw_lock_reader_unlock (&amp;weak_locations_lock);
4440 
4441   return object_or_null;
4442 }
4443 
4444 /**
4445  * g_weak_ref_set: (skip)
4446  * @weak_ref: location for a weak reference
4447  * @object: (type GObject.Object) (nullable): a #GObject or %NULL
4448  *
4449  * Change the object to which @weak_ref points, or set it to
4450  * %NULL.
4451  *
4452  * You must own a strong reference on @object while calling this
4453  * function.
4454  *
4455  * Since: 2.32
4456  */
4457 void
4458 g_weak_ref_set (GWeakRef *weak_ref,
4459                 gpointer  object)
4460 {
4461   GSList **weak_locations;
4462   GObject *new_object;
4463   GObject *old_object;
4464 
4465   g_return_if_fail (weak_ref != NULL);
4466   g_return_if_fail (object == NULL || G_IS_OBJECT (object));
4467 
4468   new_object = object;
4469 
4470   g_rw_lock_writer_lock (&amp;weak_locations_lock);
4471 
4472   /* We use the extra level of indirection here so that if we have ever
4473    * had a weak pointer installed at any point in time on this object,
4474    * we can see that there is a non-NULL value associated with the
4475    * weak-pointer quark and know that this value will not change at any
4476    * point in the object&#39;s lifetime.
4477    *
4478    * Both properties are important for reducing the amount of times we
4479    * need to acquire locks and for decreasing the duration of time the
4480    * lock is held while avoiding some rather tricky races.
4481    *
4482    * Specifically: we can avoid having to do an extra unconditional lock
4483    * in g_object_unref() without worrying about some extremely tricky
4484    * races.
4485    */
4486 
4487   old_object = weak_ref-&gt;priv.p;
4488   if (new_object != old_object)
4489     {
4490       weak_ref-&gt;priv.p = new_object;
4491 
4492       /* Remove the weak ref from the old object */
4493       if (old_object != NULL)
4494         {
4495           weak_locations = g_datalist_id_get_data (&amp;old_object-&gt;qdata, quark_weak_locations);
4496           /* for it to point to an object, the object must have had it added once */
4497           g_assert (weak_locations != NULL);
4498 
4499           *weak_locations = g_slist_remove (*weak_locations, weak_ref);
4500         }
4501 
4502       /* Add the weak ref to the new object */
4503       if (new_object != NULL)
4504         {
4505           weak_locations = g_datalist_id_get_data (&amp;new_object-&gt;qdata, quark_weak_locations);
4506 
4507           if (weak_locations == NULL)
4508             {
4509               weak_locations = g_new0 (GSList *, 1);
4510               g_datalist_id_set_data_full (&amp;new_object-&gt;qdata, quark_weak_locations, weak_locations, g_free);
4511             }
4512 
4513           *weak_locations = g_slist_prepend (*weak_locations, weak_ref);
4514         }
4515     }
4516 
4517   g_rw_lock_writer_unlock (&amp;weak_locations_lock);
4518 }
<a name="166" id="anc166"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="166" type="hidden" />
</body>
</html>