<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GObject - GLib Type, Object, Parameter and Signal Library
  2  * Copyright (C) 2000-2001 Red Hat, Inc.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General
 15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 #ifndef __G_SIGNAL_H__
 18 #define __G_SIGNAL_H__
 19 
 20 #if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
 21 #error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
 22 #endif
 23 
 24 #include    &lt;gobject/gclosure.h&gt;
 25 #include    &lt;gobject/gvalue.h&gt;
 26 #include    &lt;gobject/gparam.h&gt;
 27 #include    &lt;gobject/gmarshal.h&gt;
 28 
 29 G_BEGIN_DECLS
 30 
 31 /* --- typedefs --- */
 32 typedef struct _GSignalQuery         GSignalQuery;
 33 typedef struct _GSignalInvocationHint    GSignalInvocationHint;
 34 /**
 35  * GSignalCMarshaller:
 36  *
 37  * This is the signature of marshaller functions, required to marshall
 38  * arrays of parameter values to signal emissions into C language callback
 39  * invocations. It is merely an alias to #GClosureMarshal since the #GClosure
 40  * mechanism takes over responsibility of actual function invocation for the
 41  * signal system.
 42  */
 43 typedef GClosureMarshal          GSignalCMarshaller;
 44 /**
 45  * GSignalCVaMarshaller:
 46  *
 47  * This is the signature of va_list marshaller functions, an optional
 48  * marshaller that can be used in some situations to avoid
 49  * marshalling the signal argument into GValues.
 50  */
 51 typedef GVaClosureMarshal        GSignalCVaMarshaller;
 52 /**
 53  * GSignalEmissionHook:
 54  * @ihint: Signal invocation hint, see #GSignalInvocationHint.
 55  * @n_param_values: the number of parameters to the function, including
 56  *  the instance on which the signal was emitted.
 57  * @param_values: (array length=n_param_values): the instance on which
 58  *  the signal was emitted, followed by the parameters of the emission.
 59  * @data: user data associated with the hook.
 60  *
 61  * A simple function pointer to get invoked when the signal is emitted. This
 62  * allows you to tie a hook to the signal type, so that it will trap all
 63  * emissions of that signal, from any object.
 64  *
 65  * You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
 66  *
 67  * Returns: whether it wants to stay connected. If it returns %FALSE, the signal
 68  *  hook is disconnected (and destroyed).
 69  */
 70 typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
 71                      guint          n_param_values,
 72                      const GValue          *param_values,
 73                      gpointer       data);
 74 /**
 75  * GSignalAccumulator:
 76  * @ihint: Signal invocation hint, see #GSignalInvocationHint.
 77  * @return_accu: Accumulator to collect callback return values in, this
 78  *  is the return value of the current signal emission.
 79  * @handler_return: A #GValue holding the return value of the signal handler.
 80  * @data: Callback data that was specified when creating the signal.
 81  *
 82  * The signal accumulator is a special callback function that can be used
 83  * to collect return values of the various callbacks that are called
 84  * during a signal emission. The signal accumulator is specified at signal
 85  * creation time, if it is left %NULL, no accumulation of callback return
 86  * values is performed. The return value of signal emissions is then the
 87  * value returned by the last callback.
 88  *
 89  * Returns: The accumulator function returns whether the signal emission
 90  *  should be aborted. Returning %FALSE means to abort the
 91  *  current emission and %TRUE is returned for continuation.
 92  */
 93 typedef gboolean (*GSignalAccumulator)  (GSignalInvocationHint *ihint,
 94                      GValue            *return_accu,
 95                      const GValue          *handler_return,
 96                      gpointer               data);
 97 
 98 
 99 /* --- run, match and connect types --- */
100 /**
101  * GSignalFlags:
102  * @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.
103  * @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.
104  * @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
105  * @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in
106  *  emission for this very object will not be emitted recursively,
107  *  but instead cause the first emission to be restarted.
108  * @G_SIGNAL_DETAILED: This signal supports &quot;::detail&quot; appendices to the signal name
109  *  upon handler connections and emissions.
110  * @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive
111  *  objects from user code via g_signal_emit() and friends, without
112  *  the need of being embedded into extra code that performs pre or
113  *  post emission adjustments on the object. They can also be thought
114  *  of as object methods which can be called generically by
115  *  third-party code.
116  * @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.
117  * @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the
118  *   arguments, even if there are no signal handlers connected.  Since 2.30.
119  * @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed
120  *   in a future version. A warning will be generated if it is connected while
121  *   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.
122  *
123  * The signal flags are used to specify a signal&#39;s behaviour, the overall
124  * signal description outlines how especially the RUN flags control the
125  * stages of a signal emission.
126  */
127 typedef enum
128 {
129   G_SIGNAL_RUN_FIRST    = 1 &lt;&lt; 0,
130   G_SIGNAL_RUN_LAST = 1 &lt;&lt; 1,
131   G_SIGNAL_RUN_CLEANUP  = 1 &lt;&lt; 2,
132   G_SIGNAL_NO_RECURSE   = 1 &lt;&lt; 3,
133   G_SIGNAL_DETAILED = 1 &lt;&lt; 4,
134   G_SIGNAL_ACTION   = 1 &lt;&lt; 5,
135   G_SIGNAL_NO_HOOKS = 1 &lt;&lt; 6,
136   G_SIGNAL_MUST_COLLECT = 1 &lt;&lt; 7,
137   G_SIGNAL_DEPRECATED   = 1 &lt;&lt; 8
138 } GSignalFlags;
139 /**
140  * G_SIGNAL_FLAGS_MASK:
141  *
142  * A mask for all #GSignalFlags bits.
143  */
144 #define G_SIGNAL_FLAGS_MASK  0x1ff
145 /**
146  * GConnectFlags:
147  * @G_CONNECT_AFTER: whether the handler should be called before or after the
148  *  default handler of the signal.
149  * @G_CONNECT_SWAPPED: whether the instance and data should be swapped when
150  *  calling the handler; see g_signal_connect_swapped() for an example.
151  *
152  * The connection flags are used to specify the behaviour of a signal&#39;s
153  * connection.
154  */
155 typedef enum
156 {
157   G_CONNECT_AFTER   = 1 &lt;&lt; 0,
158   G_CONNECT_SWAPPED = 1 &lt;&lt; 1
159 } GConnectFlags;
160 /**
161  * GSignalMatchType:
162  * @G_SIGNAL_MATCH_ID: The signal id must be equal.
163  * @G_SIGNAL_MATCH_DETAIL: The signal detail be equal.
164  * @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.
165  * @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.
166  * @G_SIGNAL_MATCH_DATA: The closure data must be the same.
167  * @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may matched.
168  *
169  * The match types specify what g_signal_handlers_block_matched(),
170  * g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
171  * match signals by.
172  */
173 typedef enum
174 {
175   G_SIGNAL_MATCH_ID    = 1 &lt;&lt; 0,
176   G_SIGNAL_MATCH_DETAIL    = 1 &lt;&lt; 1,
177   G_SIGNAL_MATCH_CLOSURE   = 1 &lt;&lt; 2,
178   G_SIGNAL_MATCH_FUNC      = 1 &lt;&lt; 3,
179   G_SIGNAL_MATCH_DATA      = 1 &lt;&lt; 4,
180   G_SIGNAL_MATCH_UNBLOCKED = 1 &lt;&lt; 5
181 } GSignalMatchType;
182 /**
183  * G_SIGNAL_MATCH_MASK:
184  *
185  * A mask for all #GSignalMatchType bits.
186  */
187 #define G_SIGNAL_MATCH_MASK  0x3f
188 /**
189  * G_SIGNAL_TYPE_STATIC_SCOPE:
190  *
191  * This macro flags signal argument types for which the signal system may
192  * assume that instances thereof remain persistent across all signal emissions
193  * they are used in. This is only useful for non ref-counted, value-copy types.
194  *
195  * To flag a signal argument in this way, add `| G_SIGNAL_TYPE_STATIC_SCOPE`
196  * to the corresponding argument of g_signal_new().
197  * |[
198  * g_signal_new (&quot;size_request&quot;,
199  *   G_TYPE_FROM_CLASS (gobject_class),
200  *   G_SIGNAL_RUN_FIRST,
201  *   G_STRUCT_OFFSET (GtkWidgetClass, size_request),
202  *   NULL, NULL,
203  *   _gtk_marshal_VOID__BOXED,
204  *   G_TYPE_NONE, 1,
205  *   GTK_TYPE_REQUISITION | G_SIGNAL_TYPE_STATIC_SCOPE);
206  * ]|
207  */
208 #define G_SIGNAL_TYPE_STATIC_SCOPE (G_TYPE_FLAG_RESERVED_ID_BIT)
209 
210 
211 /* --- signal information --- */
212 /**
213  * GSignalInvocationHint:
214  * @signal_id: The signal id of the signal invoking the callback
215  * @detail: The detail passed on for this emission
216  * @run_type: The stage the signal emission is currently in, this
217  *  field will contain one of %G_SIGNAL_RUN_FIRST,
218  *  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.
219  *
220  * The #GSignalInvocationHint structure is used to pass on additional information
221  * to callbacks during a signal emission.
222  */
223 struct _GSignalInvocationHint
224 {
225   guint     signal_id;
226   GQuark    detail;
227   GSignalFlags  run_type;
228 };
229 /**
230  * GSignalQuery:
231  * @signal_id: The signal id of the signal being queried, or 0 if the
232  *  signal to be queried was unknown.
233  * @signal_name: The signal name.
234  * @itype: The interface/instance type that this signal can be emitted for.
235  * @signal_flags: The signal flags as passed in to g_signal_new().
236  * @return_type: The return type for user callbacks.
237  * @n_params: The number of parameters that user callbacks take.
238  * @param_types: (array length=n_params): The individual parameter types for
239  *  user callbacks, note that the effective callback signature is:
240  *  |[&lt;!-- language=&quot;C&quot; --&gt;
241  *  @return_type callback (#gpointer     data1,
242  *  [param_types param_names,]
243  *  gpointer     data2);
244  *  ]|
245  *
246  * A structure holding in-depth information for a specific signal. It is
247  * filled in by the g_signal_query() function.
248  */
249 struct _GSignalQuery
250 {
251   guint     signal_id;
252   const gchar  *signal_name;
253   GType     itype;
254   GSignalFlags  signal_flags;
255   GType     return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
256   guint     n_params;
257   const GType  *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
258 };
259 
260 
261 /* --- signals --- */
262 GLIB_AVAILABLE_IN_ALL
263 guint                 g_signal_newv         (const gchar        *signal_name,
264                          GType               itype,
265                          GSignalFlags        signal_flags,
266                          GClosure           *class_closure,
267                          GSignalAccumulator  accumulator,
268                          gpointer        accu_data,
269                          GSignalCMarshaller  c_marshaller,
270                          GType               return_type,
271                          guint               n_params,
272                          GType              *param_types);
273 GLIB_AVAILABLE_IN_ALL
274 guint                 g_signal_new_valist   (const gchar        *signal_name,
275                          GType               itype,
276                          GSignalFlags        signal_flags,
277                          GClosure           *class_closure,
278                          GSignalAccumulator  accumulator,
279                          gpointer        accu_data,
280                          GSignalCMarshaller  c_marshaller,
281                          GType               return_type,
282                          guint               n_params,
283                          va_list             args);
284 GLIB_AVAILABLE_IN_ALL
285 guint                 g_signal_new          (const gchar        *signal_name,
286                          GType               itype,
287                          GSignalFlags        signal_flags,
288                          guint               class_offset,
289                          GSignalAccumulator  accumulator,
290                          gpointer        accu_data,
291                          GSignalCMarshaller  c_marshaller,
292                          GType               return_type,
293                          guint               n_params,
294                          ...);
295 GLIB_AVAILABLE_IN_ALL
296 guint            g_signal_new_class_handler (const gchar        *signal_name,
297                                              GType               itype,
298                                              GSignalFlags        signal_flags,
299                                              GCallback           class_handler,
300                                              GSignalAccumulator  accumulator,
301                                              gpointer            accu_data,
302                                              GSignalCMarshaller  c_marshaller,
303                                              GType               return_type,
304                                              guint               n_params,
305                                              ...);
306 GLIB_AVAILABLE_IN_ALL
307 void             g_signal_set_va_marshaller (guint              signal_id,
308                          GType              instance_type,
309                          GSignalCVaMarshaller va_marshaller);
310 
311 GLIB_AVAILABLE_IN_ALL
312 void                  g_signal_emitv        (const GValue       *instance_and_params,
313                          guint               signal_id,
314                          GQuark              detail,
315                          GValue             *return_value);
316 GLIB_AVAILABLE_IN_ALL
317 void                  g_signal_emit_valist  (gpointer            instance,
318                          guint               signal_id,
319                          GQuark              detail,
320                          va_list             var_args);
321 GLIB_AVAILABLE_IN_ALL
322 void                  g_signal_emit         (gpointer            instance,
323                          guint               signal_id,
324                          GQuark              detail,
325                          ...);
326 GLIB_AVAILABLE_IN_ALL
327 void                  g_signal_emit_by_name (gpointer            instance,
328                          const gchar        *detailed_signal,
329                          ...);
330 GLIB_AVAILABLE_IN_ALL
331 guint                 g_signal_lookup       (const gchar        *name,
332                          GType               itype);
333 GLIB_AVAILABLE_IN_ALL
334 const gchar *         g_signal_name         (guint               signal_id);
335 GLIB_AVAILABLE_IN_ALL
336 void                  g_signal_query        (guint               signal_id,
337                          GSignalQuery       *query);
338 GLIB_AVAILABLE_IN_ALL
339 guint*                g_signal_list_ids     (GType               itype,
340                          guint              *n_ids);
341 GLIB_AVAILABLE_IN_ALL
342 gboolean          g_signal_parse_name   (const gchar    *detailed_signal,
343                          GType       itype,
344                          guint      *signal_id_p,
345                          GQuark     *detail_p,
346                          gboolean        force_detail_quark);
347 GLIB_AVAILABLE_IN_ALL
348 GSignalInvocationHint* g_signal_get_invocation_hint (gpointer    instance);
349 
350 
351 /* --- signal emissions --- */
352 GLIB_AVAILABLE_IN_ALL
353 void    g_signal_stop_emission          (gpointer         instance,
354                          guint        signal_id,
355                          GQuark       detail);
356 GLIB_AVAILABLE_IN_ALL
357 void    g_signal_stop_emission_by_name      (gpointer         instance,
358                          const gchar     *detailed_signal);
359 GLIB_AVAILABLE_IN_ALL
360 gulong  g_signal_add_emission_hook      (guint        signal_id,
361                          GQuark       detail,
362                          GSignalEmissionHook  hook_func,
363                          gpointer             hook_data,
364                          GDestroyNotify   data_destroy);
365 GLIB_AVAILABLE_IN_ALL
366 void    g_signal_remove_emission_hook       (guint        signal_id,
367                          gulong       hook_id);
368 
369 
370 /* --- signal handlers --- */
371 GLIB_AVAILABLE_IN_ALL
372 gboolean g_signal_has_handler_pending         (gpointer       instance,
373                            guint          signal_id,
374                            GQuark         detail,
375                            gboolean       may_be_blocked);
376 GLIB_AVAILABLE_IN_ALL
377 gulong   g_signal_connect_closure_by_id       (gpointer       instance,
378                            guint          signal_id,
379                            GQuark         detail,
380                            GClosure      *closure,
381                            gboolean       after);
382 GLIB_AVAILABLE_IN_ALL
383 gulong   g_signal_connect_closure         (gpointer       instance,
384                            const gchar       *detailed_signal,
385                            GClosure      *closure,
386                            gboolean       after);
387 GLIB_AVAILABLE_IN_ALL
388 gulong   g_signal_connect_data            (gpointer       instance,
389                            const gchar   *detailed_signal,
390                            GCallback      c_handler,
391                            gpointer       data,
392                            GClosureNotify     destroy_data,
393                            GConnectFlags      connect_flags);
394 GLIB_AVAILABLE_IN_ALL
395 void     g_signal_handler_block           (gpointer       instance,
396                            gulong         handler_id);
397 GLIB_AVAILABLE_IN_ALL
398 void     g_signal_handler_unblock         (gpointer       instance,
399                            gulong         handler_id);
400 GLIB_AVAILABLE_IN_ALL
401 void     g_signal_handler_disconnect          (gpointer       instance,
402                            gulong         handler_id);
403 GLIB_AVAILABLE_IN_ALL
404 gboolean g_signal_handler_is_connected        (gpointer       instance,
405                            gulong         handler_id);
406 GLIB_AVAILABLE_IN_ALL
407 gulong   g_signal_handler_find            (gpointer       instance,
408                            GSignalMatchType   mask,
409                            guint          signal_id,
410                            GQuark         detail,
411                            GClosure      *closure,
412                            gpointer       func,
413                            gpointer       data);
414 GLIB_AVAILABLE_IN_ALL
415 guint    g_signal_handlers_block_matched      (gpointer       instance,
416                            GSignalMatchType   mask,
417                            guint          signal_id,
418                            GQuark         detail,
419                            GClosure      *closure,
420                            gpointer       func,
421                            gpointer       data);
422 GLIB_AVAILABLE_IN_ALL
423 guint    g_signal_handlers_unblock_matched    (gpointer       instance,
424                            GSignalMatchType   mask,
425                            guint          signal_id,
426                            GQuark         detail,
427                            GClosure      *closure,
428                            gpointer       func,
429                            gpointer       data);
430 GLIB_AVAILABLE_IN_ALL
431 guint    g_signal_handlers_disconnect_matched (gpointer       instance,
432                            GSignalMatchType   mask,
433                            guint          signal_id,
434                            GQuark         detail,
435                            GClosure      *closure,
436                            gpointer       func,
437                            gpointer       data);
438 
439 
440 /* --- overriding and chaining --- */
441 GLIB_AVAILABLE_IN_ALL
442 void    g_signal_override_class_closure       (guint              signal_id,
443                                                GType              instance_type,
444                                                GClosure          *class_closure);
445 GLIB_AVAILABLE_IN_ALL
446 void    g_signal_override_class_handler       (const gchar       *signal_name,
447                                                GType              instance_type,
448                                                GCallback          class_handler);
449 GLIB_AVAILABLE_IN_ALL
450 void    g_signal_chain_from_overridden        (const GValue      *instance_and_params,
451                                                GValue            *return_value);
452 GLIB_AVAILABLE_IN_ALL
453 void   g_signal_chain_from_overridden_handler (gpointer           instance,
454                                                ...);
455 
456 
457 /* --- convenience --- */
458 /**
459  * g_signal_connect:
460  * @instance: the instance to connect to.
461  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
462  * @c_handler: the #GCallback to connect.
463  * @data: data to pass to @c_handler calls.
464  *
465  * Connects a #GCallback function to a signal for a particular object.
466  *
467  * The handler will be called before the default handler of the signal.
468  *
469  * See [memory management of signal handlers][signal-memory-management] for
470  * details on how to handle the return value and memory management of @data.
471  *
472  * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)
473  */
474 #define g_signal_connect(instance, detailed_signal, c_handler, data) \
475     g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, (GConnectFlags) 0)
476 /**
477  * g_signal_connect_after:
478  * @instance: the instance to connect to.
479  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
480  * @c_handler: the #GCallback to connect.
481  * @data: data to pass to @c_handler calls.
482  *
483  * Connects a #GCallback function to a signal for a particular object.
484  *
485  * The handler will be called after the default handler of the signal.
486  *
487  * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)
488  */
489 #define g_signal_connect_after(instance, detailed_signal, c_handler, data) \
490     g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_AFTER)
491 /**
492  * g_signal_connect_swapped:
493  * @instance: the instance to connect to.
494  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
495  * @c_handler: the #GCallback to connect.
496  * @data: data to pass to @c_handler calls.
497  *
498  * Connects a #GCallback function to a signal for a particular object.
499  *
500  * The instance on which the signal is emitted and @data will be swapped when
501  * calling the handler. This is useful when calling pre-existing functions to
502  * operate purely on the @data, rather than the @instance: swapping the
503  * parameters avoids the need to write a wrapper function.
504  *
505  * For example, this allows the shorter code:
506  * |[&lt;!-- language=&quot;C&quot; --&gt;
507  * g_signal_connect_swapped (button, &quot;clicked&quot;,
508  *                           (GCallback) gtk_widget_hide, other_widget);
509  * ]|
510  *
511  * Rather than the cumbersome:
512  * |[&lt;!-- language=&quot;C&quot; --&gt;
513  * static void
514  * button_clicked_cb (GtkButton *button, GtkWidget *other_widget)
515  * {
516  *     gtk_widget_hide (other_widget);
517  * }
518  *
519  * ...
520  *
521  * g_signal_connect (button, &quot;clicked&quot;,
522  *                   (GCallback) button_clicked_cb, other_widget);
523  * ]|
524  *
525  * Returns: the handler ID, of type #gulong (always greater than 0 for successful connections)
526  */
527 #define g_signal_connect_swapped(instance, detailed_signal, c_handler, data) \
528     g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_SWAPPED)
529 /**
530  * g_signal_handlers_disconnect_by_func:
531  * @instance: The instance to remove handlers from.
532  * @func: The C closure callback of the handlers (useless for non-C closures).
533  * @data: The closure data of the handlers&#39; closures.
534  *
535  * Disconnects all handlers on an instance that match @func and @data.
536  *
537  * Returns: The number of handlers that matched.
538  */
539 #define g_signal_handlers_disconnect_by_func(instance, func, data)                      \
540     g_signal_handlers_disconnect_matched ((instance),                               \
541                       (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \
542                       0, 0, NULL, (func), (data))
543 
544 /**
545  * g_signal_handlers_disconnect_by_data:
546  * @instance: The instance to remove handlers from
547  * @data: the closure data of the handlers&#39; closures
548  *
549  * Disconnects all handlers on an instance that match @data.
550  *
551  * Returns: The number of handlers that matched.
552  *
553  * Since: 2.32
554  */
555 #define g_signal_handlers_disconnect_by_data(instance, data) \
556   g_signal_handlers_disconnect_matched ((instance), G_SIGNAL_MATCH_DATA, 0, 0, NULL, NULL, (data))
557 
558 /**
559  * g_signal_handlers_block_by_func:
560  * @instance: The instance to block handlers from.
561  * @func: The C closure callback of the handlers (useless for non-C closures).
562  * @data: The closure data of the handlers&#39; closures.
563  *
564  * Blocks all handlers on an instance that match @func and @data.
565  *
566  * Returns: The number of handlers that matched.
567  */
568 #define g_signal_handlers_block_by_func(instance, func, data)                           \
569     g_signal_handlers_block_matched      ((instance),                               \
570                           (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \
571                           0, 0, NULL, (func), (data))
572 /**
573  * g_signal_handlers_unblock_by_func:
574  * @instance: The instance to unblock handlers from.
575  * @func: The C closure callback of the handlers (useless for non-C closures).
576  * @data: The closure data of the handlers&#39; closures.
577  *
578  * Unblocks all handlers on an instance that match @func and @data.
579  *
580  * Returns: The number of handlers that matched.
581  */
582 #define g_signal_handlers_unblock_by_func(instance, func, data)                         \
583     g_signal_handlers_unblock_matched    ((instance),                               \
584                           (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \
585                           0, 0, NULL, (func), (data))
586 
587 
588 GLIB_AVAILABLE_IN_ALL
589 gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
590                         GValue                *return_accu,
591                         const GValue          *handler_return,
592                         gpointer               dummy);
593 
594 GLIB_AVAILABLE_IN_ALL
595 gboolean g_signal_accumulator_first_wins   (GSignalInvocationHint *ihint,
596                                             GValue                *return_accu,
597                                             const GValue          *handler_return,
598                                             gpointer               dummy);
599 
600 /*&lt; private &gt;*/
601 GLIB_AVAILABLE_IN_ALL
602 void     g_signal_handlers_destroy        (gpointer       instance);
603 void     _g_signals_destroy           (GType          itype);
604 
605 G_END_DECLS
606 
607 #endif /* __G_SIGNAL_H__ */
    </pre>
  </body>
</html>