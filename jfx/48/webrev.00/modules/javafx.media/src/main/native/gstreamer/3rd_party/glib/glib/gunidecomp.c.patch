diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c
@@ -105,43 +105,43 @@
  * according to their combining classes.  See the Unicode
  * manual for more information.
  **/
 void
 g_unicode_canonical_ordering (gunichar *string,
-                  gsize     len)
+            gsize     len)
 {
   gsize i;
   int swap = 1;
 
   while (swap)
     {
       int last;
       swap = 0;
       last = COMBINING_CLASS (string[0]);
       for (i = 0; i < len - 1; ++i)
+  {
+    int next = COMBINING_CLASS (string[i + 1]);
+    if (next != 0 && last > next)
+      {
+        gsize j;
+        /* Percolate item leftward through string.  */
+        for (j = i + 1; j > 0; --j)
     {
-      int next = COMBINING_CLASS (string[i + 1]);
-      if (next != 0 && last > next)
-        {
-          gsize j;
-          /* Percolate item leftward through string.  */
-          for (j = i + 1; j > 0; --j)
-        {
-          gunichar t;
-          if (COMBINING_CLASS (string[j - 1]) <= next)
-            break;
-          t = string[j];
-          string[j] = string[j - 1];
-          string[j - 1] = t;
-          swap = 1;
-        }
-          /* We're re-entering the loop looking at the old
-         character again.  */
-          next = last;
-        }
-      last = next;
+      gunichar t;
+      if (COMBINING_CLASS (string[j - 1]) <= next)
+        break;
+      t = string[j];
+      string[j] = string[j - 1];
+      string[j - 1] = t;
+      swap = 1;
     }
+        /* We're re-entering the loop looking at the old
+     character again.  */
+        next = last;
+      }
+    last = next;
+  }
     }
 }
 
 /* http://www.unicode.org/unicode/reports/tr15/#Hangul
  * r should be null or have sufficient space. Calling with r == NULL will
@@ -162,57 +162,57 @@
     }
 
   if (TIndex)
     {
       if (r)
-    r[2] = TBase + TIndex;
+  r[2] = TBase + TIndex;
       *result_len = 3;
     }
   else
     *result_len = 2;
 }
 
 /* returns a pointer to a null-terminated UTF-8 string */
 static const gchar *
 find_decomposition (gunichar ch,
-            gboolean compat)
+        gboolean compat)
 {
   int start = 0;
   int end = G_N_ELEMENTS (decomp_table);
 
   if (ch >= decomp_table[start].ch &&
       ch <= decomp_table[end - 1].ch)
     {
       while (TRUE)
-    {
-      int half = (start + end) / 2;
-      if (ch == decomp_table[half].ch)
-        {
-          int offset;
+  {
+    int half = (start + end) / 2;
+    if (ch == decomp_table[half].ch)
+      {
+        int offset;
 
-          if (compat)
-        {
-          offset = decomp_table[half].compat_offset;
-          if (offset == G_UNICODE_NOT_PRESENT_OFFSET)
-            offset = decomp_table[half].canon_offset;
-        }
-          else
-        {
-          offset = decomp_table[half].canon_offset;
-          if (offset == G_UNICODE_NOT_PRESENT_OFFSET)
-            return NULL;
-        }
-
-          return &(decomp_expansion_string[offset]);
-        }
-      else if (half == start)
-        break;
-      else if (ch > decomp_table[half].ch)
-        start = half;
-      else
-        end = half;
+        if (compat)
+    {
+      offset = decomp_table[half].compat_offset;
+      if (offset == G_UNICODE_NOT_PRESENT_OFFSET)
+        offset = decomp_table[half].canon_offset;
+    }
+        else
+    {
+      offset = decomp_table[half].canon_offset;
+      if (offset == G_UNICODE_NOT_PRESENT_OFFSET)
+        return NULL;
     }
+
+        return &(decomp_expansion_string[offset]);
+      }
+    else if (half == start)
+      break;
+    else if (ch > decomp_table[half].ch)
+      start = half;
+    else
+      end = half;
+  }
     }
 
   return NULL;
 }
 
@@ -229,11 +229,11 @@
  * Deprecated: 2.30: Use the more flexible g_unichar_fully_decompose()
  *   instead.
  **/
 gunichar *
 g_unicode_canonical_decomposition (gunichar ch,
-                   gsize   *result_len)
+           gsize   *result_len)
 {
   const gchar *decomp;
   const gchar *p;
   gunichar *r;
 
@@ -306,12 +306,12 @@
 #define COMPOSE_INDEX(Char) \
      (((Char >> 8) > (COMPOSE_TABLE_LAST)) ? 0 : CI((Char) >> 8, (Char) & 0xff))
 
 static gboolean
 combine (gunichar  a,
-     gunichar  b,
-     gunichar *result)
+   gunichar  b,
+   gunichar *result)
 {
   gushort index_a, index_b;
 
   if (combine_hangul (a, b, result))
     return TRUE;
@@ -319,59 +319,59 @@
   index_a = COMPOSE_INDEX(a);
 
   if (index_a >= COMPOSE_FIRST_SINGLE_START && index_a < COMPOSE_SECOND_START)
     {
       if (b == compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][0])
-    {
-      *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];
-      return TRUE;
-    }
+  {
+    *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];
+    return TRUE;
+  }
       else
         return FALSE;
     }
 
   index_b = COMPOSE_INDEX(b);
 
   if (index_b >= COMPOSE_SECOND_SINGLE_START)
     {
       if (a == compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][0])
-    {
-      *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];
-      return TRUE;
-    }
+  {
+    *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];
+    return TRUE;
+  }
       else
         return FALSE;
     }
 
   if (index_a >= COMPOSE_FIRST_START && index_a < COMPOSE_FIRST_SINGLE_START &&
       index_b >= COMPOSE_SECOND_START && index_b < COMPOSE_SECOND_SINGLE_START)
     {
       gunichar res = compose_array[index_a - COMPOSE_FIRST_START][index_b - COMPOSE_SECOND_START];
 
       if (res)
-    {
-      *result = res;
-      return TRUE;
-    }
+  {
+    *result = res;
+    return TRUE;
+  }
     }
 
   return FALSE;
 }
 
 gunichar *
 _g_utf8_normalize_wc (const gchar    *str,
-              gssize          max_len,
-              GNormalizeMode  mode)
+          gssize          max_len,
+          GNormalizeMode  mode)
 {
   gsize n_wc;
   gunichar *wc_buffer;
   const char *p;
   gsize last_start;
   gboolean do_compat = (mode == G_NORMALIZE_NFKC ||
-            mode == G_NORMALIZE_NFKD);
+      mode == G_NORMALIZE_NFKD);
   gboolean do_compose = (mode == G_NORMALIZE_NFC ||
-             mode == G_NORMALIZE_NFKC);
+       mode == G_NORMALIZE_NFKC);
 
   n_wc = 0;
   p = str;
   while ((max_len < 0 || p < str + max_len) && *p)
     {
@@ -428,19 +428,19 @@
           else
             wc_buffer[n_wc++] = wc;
         }
 
       if (n_wc > 0)
-    {
-      cc = COMBINING_CLASS (wc_buffer[old_n_wc]);
+  {
+    cc = COMBINING_CLASS (wc_buffer[old_n_wc]);
 
-      if (cc == 0)
-        {
-          g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);
-          last_start = old_n_wc;
-        }
-    }
+    if (cc == 0)
+      {
+        g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);
+        last_start = old_n_wc;
+      }
+  }
 
       p = g_utf8_next_char (p);
     }
 
   if (n_wc > 0)
@@ -458,36 +458,36 @@
       gsize i, j;
       int last_cc = 0;
       last_start = 0;
 
       for (i = 0; i < n_wc; i++)
-    {
-      int cc = COMBINING_CLASS (wc_buffer[i]);
-
-      if (i > 0 &&
-          (last_cc == 0 || last_cc < cc) &&
-          combine (wc_buffer[last_start], wc_buffer[i],
-               &wc_buffer[last_start]))
-        {
-          for (j = i + 1; j < n_wc; j++)
-        wc_buffer[j-1] = wc_buffer[j];
-          n_wc--;
-          i--;
-
-          if (i == last_start)
-        last_cc = 0;
-          else
-        last_cc = COMBINING_CLASS (wc_buffer[i-1]);
-
-          continue;
-        }
-
-      if (cc == 0)
-        last_start = i;
-
-      last_cc = cc;
-    }
+  {
+    int cc = COMBINING_CLASS (wc_buffer[i]);
+
+    if (i > 0 &&
+        (last_cc == 0 || last_cc < cc) &&
+        combine (wc_buffer[last_start], wc_buffer[i],
+           &wc_buffer[last_start]))
+      {
+        for (j = i + 1; j < n_wc; j++)
+    wc_buffer[j-1] = wc_buffer[j];
+        n_wc--;
+        i--;
+
+        if (i == last_start)
+    last_cc = 0;
+        else
+    last_cc = COMBINING_CLASS (wc_buffer[i-1]);
+
+        continue;
+      }
+
+    if (cc == 0)
+      last_start = i;
+
+    last_cc = cc;
+  }
     }
 
   wc_buffer[n_wc] = 0;
 
   return wc_buffer;
@@ -523,18 +523,18 @@
  * than a maximally decomposed form. This is often
  * useful if you intend to convert the string to
  * a legacy encoding or pass it to a system with
  * less capable Unicode handling.
  *
- * Returns: a newly allocated string, that is the
- *   normalized form of @str, or %NULL if @str is not
- *   valid UTF-8.
+ * Returns: (nullable): a newly allocated string, that
+ *   is the normalized form of @str, or %NULL if @str
+ *   is not valid UTF-8.
  **/
 gchar *
 g_utf8_normalize (const gchar    *str,
-          gssize          len,
-          GNormalizeMode  mode)
+      gssize          len,
+      GNormalizeMode  mode)
 {
   gunichar *result_wc = _g_utf8_normalize_wc (str, len, mode);
   gchar *result;
 
   result = g_ucs4_to_utf8 (result_wc, -1, NULL, NULL, NULL);
@@ -573,12 +573,12 @@
 }
 
 /**
  * g_unichar_decompose:
  * @ch: a Unicode character
- * @a: return location for the first component of @ch
- * @b: return location for the second component of @ch
+ * @a: (out) (not optional): return location for the first component of @ch
+ * @b: (out) (not optional): return location for the second component of @ch
  *
  * Performs a single decomposition step of the
  * Unicode canonical decomposition algorithm.
  *
  * This function does not include compatibility
@@ -648,11 +648,11 @@
 
 /**
  * g_unichar_compose:
  * @a: a Unicode character
  * @b: a Unicode character
- * @ch: return location for the composed character
+ * @ch: (out) (not optional): return location for the composed character
  *
  * Performs a single composition step of the
  * Unicode canonical composition algorithm.
  *
  * This function includes algorithmic Hangul Jamo composition,
@@ -687,11 +687,11 @@
 
 /**
  * g_unichar_fully_decompose:
  * @ch: a Unicode character.
  * @compat: whether perform canonical or compatibility decomposition
- * @result: (nullable): location to store decomposed result, or %NULL
+ * @result: (optional) (out caller-allocates): location to store decomposed result, or %NULL
  * @result_len: length of @result
  *
  * Computes the canonical or compatibility decomposition of a
  * Unicode character.  For compatibility decomposition,
  * pass %TRUE for @compat; for canonical decomposition
@@ -716,13 +716,13 @@
  *
  * Since: 2.30
  **/
 gsize
 g_unichar_fully_decompose (gunichar  ch,
-               gboolean  compat,
-               gunichar *result,
-               gsize     result_len)
+         gboolean  compat,
+         gunichar *result,
+         gsize     result_len)
 {
   const gchar *decomp;
   const gchar *p;
 
   /* Hangul syllable */
@@ -731,11 +731,11 @@
       gsize len, i;
       gunichar buffer[3];
       decompose_hangul (ch, result ? buffer : NULL, &len);
       if (result)
         for (i = 0; i < len && i < result_len; i++)
-      result[i] = buffer[i];
+    result[i] = buffer[i];
       return len;
     }
   else if ((decomp = find_decomposition (ch, compat)) != NULL)
     {
       /* Found it.  */
