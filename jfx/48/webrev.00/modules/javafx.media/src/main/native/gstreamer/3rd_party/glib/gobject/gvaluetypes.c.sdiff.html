<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluetypes.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvaluetransform.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluetypes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluetypes.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
<span class="line-modified">   3  * Copyright ï¿½ 2010 Christian Persch</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General
  16  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 /*
  20  * MT safe
  21  */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  26 #include &lt;stdlib.h&gt; /* qsort() */
  27 
  28 #include &quot;gvaluetypes.h&quot;
  29 #include &quot;gtype-private.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gobject.h&quot;
  32 #include &quot;gparam.h&quot;
  33 #include &quot;gboxed.h&quot;
  34 #include &quot;genums.h&quot;
  35 
  36 
  37 /* --- value functions --- */
  38 static void
  39 value_init_long0 (GValue *value)
  40 {
  41   value-&gt;data[0].v_long = 0;
  42 }
  43 
  44 static void
  45 value_copy_long0 (const GValue *src_value,
<span class="line-modified">  46           GValue       *dest_value)</span>
  47 {
  48   dest_value-&gt;data[0].v_long = src_value-&gt;data[0].v_long;
  49 }
  50 
  51 static gchar*
  52 value_lcopy_char (const GValue *value,
<span class="line-modified">  53           guint         n_collect_values,</span>
<span class="line-modified">  54           GTypeCValue  *collect_values,</span>
<span class="line-modified">  55           guint         collect_flags)</span>
  56 {
  57   gint8 *int8_p = collect_values[0].v_pointer;
  58 
  59   if (!int8_p)
  60     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
  61 
  62   *int8_p = value-&gt;data[0].v_int;
  63 
  64   return NULL;
  65 }
  66 
  67 static gchar*
  68 value_lcopy_boolean (const GValue *value,
<span class="line-modified">  69              guint         n_collect_values,</span>
<span class="line-modified">  70              GTypeCValue  *collect_values,</span>
<span class="line-modified">  71              guint         collect_flags)</span>
  72 {
  73   gboolean *bool_p = collect_values[0].v_pointer;
  74 
  75   if (!bool_p)
  76     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
  77 
  78   *bool_p = value-&gt;data[0].v_int;
  79 
  80   return NULL;
  81 }
  82 
  83 static gchar*
  84 value_collect_int (GValue      *value,
<span class="line-modified">  85            guint        n_collect_values,</span>
<span class="line-modified">  86            GTypeCValue *collect_values,</span>
<span class="line-modified">  87            guint        collect_flags)</span>
  88 {
  89   value-&gt;data[0].v_int = collect_values[0].v_int;
  90 
  91   return NULL;
  92 }
  93 
  94 static gchar*
  95 value_lcopy_int (const GValue *value,
<span class="line-modified">  96          guint         n_collect_values,</span>
<span class="line-modified">  97          GTypeCValue  *collect_values,</span>
<span class="line-modified">  98          guint         collect_flags)</span>
  99 {
 100   gint *int_p = collect_values[0].v_pointer;
 101 
 102   if (!int_p)
 103     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 104 
 105   *int_p = value-&gt;data[0].v_int;
 106 
 107   return NULL;
 108 }
 109 
 110 static gchar*
 111 value_collect_long (GValue      *value,
<span class="line-modified"> 112             guint        n_collect_values,</span>
<span class="line-modified"> 113             GTypeCValue *collect_values,</span>
<span class="line-modified"> 114             guint        collect_flags)</span>
 115 {
 116   value-&gt;data[0].v_long = collect_values[0].v_long;
 117 
 118   return NULL;
 119 }
 120 
 121 static gchar*
 122 value_lcopy_long (const GValue *value,
<span class="line-modified"> 123           guint         n_collect_values,</span>
<span class="line-modified"> 124           GTypeCValue  *collect_values,</span>
<span class="line-modified"> 125           guint         collect_flags)</span>
 126 {
 127   glong *long_p = collect_values[0].v_pointer;
 128 
 129   if (!long_p)
 130     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 131 
 132   *long_p = value-&gt;data[0].v_long;
 133 
 134   return NULL;
 135 }
 136 
 137 static void
 138 value_init_int64 (GValue *value)
 139 {
 140   value-&gt;data[0].v_int64 = 0;
 141 }
 142 
 143 static void
 144 value_copy_int64 (const GValue *src_value,
<span class="line-modified"> 145           GValue       *dest_value)</span>
 146 {
 147   dest_value-&gt;data[0].v_int64 = src_value-&gt;data[0].v_int64;
 148 }
 149 
 150 static gchar*
 151 value_collect_int64 (GValue      *value,
<span class="line-modified"> 152              guint        n_collect_values,</span>
<span class="line-modified"> 153              GTypeCValue *collect_values,</span>
<span class="line-modified"> 154              guint        collect_flags)</span>
 155 {
 156   value-&gt;data[0].v_int64 = collect_values[0].v_int64;
 157 
 158   return NULL;
 159 }
 160 
 161 static gchar*
 162 value_lcopy_int64 (const GValue *value,
<span class="line-modified"> 163            guint         n_collect_values,</span>
<span class="line-modified"> 164            GTypeCValue  *collect_values,</span>
<span class="line-modified"> 165            guint         collect_flags)</span>
 166 {
 167   gint64 *int64_p = collect_values[0].v_pointer;
 168 
 169   if (!int64_p)
 170     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 171 
 172   *int64_p = value-&gt;data[0].v_int64;
 173 
 174   return NULL;
 175 }
 176 
 177 static void
 178 value_init_float (GValue *value)
 179 {
 180   value-&gt;data[0].v_float = 0.0;
 181 }
 182 
 183 static void
 184 value_copy_float (const GValue *src_value,
<span class="line-modified"> 185           GValue       *dest_value)</span>
 186 {
 187   dest_value-&gt;data[0].v_float = src_value-&gt;data[0].v_float;
 188 }
 189 
 190 static gchar*
 191 value_collect_float (GValue      *value,
<span class="line-modified"> 192              guint        n_collect_values,</span>
<span class="line-modified"> 193              GTypeCValue *collect_values,</span>
<span class="line-modified"> 194              guint        collect_flags)</span>
 195 {
 196   value-&gt;data[0].v_float = collect_values[0].v_double;
 197 
 198   return NULL;
 199 }
 200 
 201 static gchar*
 202 value_lcopy_float (const GValue *value,
<span class="line-modified"> 203            guint         n_collect_values,</span>
<span class="line-modified"> 204            GTypeCValue  *collect_values,</span>
<span class="line-modified"> 205            guint         collect_flags)</span>
 206 {
 207   gfloat *float_p = collect_values[0].v_pointer;
 208 
 209   if (!float_p)
 210     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 211 
 212   *float_p = value-&gt;data[0].v_float;
 213 
 214   return NULL;
 215 }
 216 
 217 static void
 218 value_init_double (GValue *value)
 219 {
 220   value-&gt;data[0].v_double = 0.0;
 221 }
 222 
 223 static void
 224 value_copy_double (const GValue *src_value,
<span class="line-modified"> 225            GValue   *dest_value)</span>
 226 {
 227   dest_value-&gt;data[0].v_double = src_value-&gt;data[0].v_double;
 228 }
 229 
 230 static gchar*
<span class="line-modified"> 231 value_collect_double (GValue      *value,</span>
<span class="line-modified"> 232               guint        n_collect_values,</span>
<span class="line-modified"> 233               GTypeCValue *collect_values,</span>
<span class="line-modified"> 234               guint        collect_flags)</span>
 235 {
 236   value-&gt;data[0].v_double = collect_values[0].v_double;
 237 
 238   return NULL;
 239 }
 240 
 241 static gchar*
 242 value_lcopy_double (const GValue *value,
<span class="line-modified"> 243             guint         n_collect_values,</span>
<span class="line-modified"> 244             GTypeCValue  *collect_values,</span>
<span class="line-modified"> 245             guint         collect_flags)</span>
 246 {
 247   gdouble *double_p = collect_values[0].v_pointer;
 248 
 249   if (!double_p)
 250     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 251 
 252   *double_p = value-&gt;data[0].v_double;
 253 
 254   return NULL;
 255 }
 256 
 257 static void
 258 value_init_string (GValue *value)
 259 {
 260   value-&gt;data[0].v_pointer = NULL;
 261 }
 262 
 263 static void
 264 value_free_string (GValue *value)
 265 {
 266   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
 267     g_free (value-&gt;data[0].v_pointer);
 268 }
 269 
 270 static void
 271 value_copy_string (const GValue *src_value,
<span class="line-modified"> 272            GValue   *dest_value)</span>
 273 {
 274   dest_value-&gt;data[0].v_pointer = g_strdup (src_value-&gt;data[0].v_pointer);
 275 }
 276 
 277 static gchar*
<span class="line-modified"> 278 value_collect_string (GValue      *value,</span>
<span class="line-modified"> 279               guint        n_collect_values,</span>
<span class="line-modified"> 280               GTypeCValue *collect_values,</span>
<span class="line-modified"> 281               guint        collect_flags)</span>
 282 {
 283   if (!collect_values[0].v_pointer)
 284     value-&gt;data[0].v_pointer = NULL;
 285   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 286     {
 287       value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 288       value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 289     }
 290   else
 291     value-&gt;data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
 292 
 293   return NULL;
 294 }
 295 
 296 static gchar*
 297 value_lcopy_string (const GValue *value,
<span class="line-modified"> 298             guint         n_collect_values,</span>
<span class="line-modified"> 299             GTypeCValue  *collect_values,</span>
<span class="line-modified"> 300             guint         collect_flags)</span>
 301 {
 302   gchar **string_p = collect_values[0].v_pointer;
 303 
 304   if (!string_p)
 305     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 306 
 307   if (!value-&gt;data[0].v_pointer)
 308     *string_p = NULL;
 309   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 310     *string_p = value-&gt;data[0].v_pointer;
 311   else
 312     *string_p = g_strdup (value-&gt;data[0].v_pointer);
 313 
 314   return NULL;
 315 }
 316 
 317 static void
 318 value_init_pointer (GValue *value)
 319 {
 320   value-&gt;data[0].v_pointer = NULL;
 321 }
 322 
 323 static void
 324 value_copy_pointer (const GValue *src_value,
<span class="line-modified"> 325             GValue       *dest_value)</span>
 326 {
 327   dest_value-&gt;data[0].v_pointer = src_value-&gt;data[0].v_pointer;
 328 }
 329 
 330 static gpointer
 331 value_peek_pointer0 (const GValue *value)
 332 {
 333   return value-&gt;data[0].v_pointer;
 334 }
 335 
 336 static gchar*
 337 value_collect_pointer (GValue      *value,
<span class="line-modified"> 338                guint        n_collect_values,</span>
<span class="line-modified"> 339                GTypeCValue *collect_values,</span>
<span class="line-modified"> 340                guint        collect_flags)</span>
 341 {
 342   value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 343 
 344   return NULL;
 345 }
 346 
 347 static gchar*
 348 value_lcopy_pointer (const GValue *value,
<span class="line-modified"> 349              guint         n_collect_values,</span>
<span class="line-modified"> 350              GTypeCValue  *collect_values,</span>
<span class="line-modified"> 351              guint         collect_flags)</span>
 352 {
 353   gpointer *pointer_p = collect_values[0].v_pointer;
 354 
 355   if (!pointer_p)
 356     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 357 
 358   *pointer_p = value-&gt;data[0].v_pointer;
 359 
 360   return NULL;
 361 }
 362 
 363 static void
 364 value_free_variant (GValue *value)
 365 {
 366   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS) &amp;&amp;
 367       value-&gt;data[0].v_pointer)
 368     g_variant_unref (value-&gt;data[0].v_pointer);
 369 }
 370 
 371 static void
 372 value_copy_variant (const GValue *src_value,
<span class="line-modified"> 373            GValue   *dest_value)</span>
 374 {
 375   if (src_value-&gt;data[0].v_pointer)
 376     dest_value-&gt;data[0].v_pointer = g_variant_ref_sink (src_value-&gt;data[0].v_pointer);
 377   else
 378     dest_value-&gt;data[0].v_pointer = NULL;
 379 }
 380 
 381 static gchar*
<span class="line-modified"> 382 value_collect_variant (GValue     *value,</span>
<span class="line-modified"> 383               guint        n_collect_values,</span>
<span class="line-modified"> 384               GTypeCValue *collect_values,</span>
<span class="line-modified"> 385               guint        collect_flags)</span>
 386 {
 387   if (!collect_values[0].v_pointer)
 388     value-&gt;data[0].v_pointer = NULL;
 389   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 390     {
 391       value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 392       value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 393     }
 394   else
 395     value-&gt;data[0].v_pointer = g_variant_ref_sink (collect_values[0].v_pointer);
 396 
 397   return NULL;
 398 }
 399 
 400 static gchar*
 401 value_lcopy_variant (const GValue *value,
<span class="line-modified"> 402             guint         n_collect_values,</span>
<span class="line-modified"> 403             GTypeCValue  *collect_values,</span>
<span class="line-modified"> 404             guint         collect_flags)</span>
 405 {
 406   GVariant **variant_p = collect_values[0].v_pointer;
 407 
 408   if (!variant_p)
 409     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 410 
 411   if (!value-&gt;data[0].v_pointer)
 412     *variant_p = NULL;
 413   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 414     *variant_p = value-&gt;data[0].v_pointer;
 415   else
 416     *variant_p = g_variant_ref_sink (value-&gt;data[0].v_pointer);
 417 
 418   return NULL;
 419 }
 420 
 421 /* --- type initialization --- */
 422 void
 423 _g_value_types_init (void)
 424 {
 425   GTypeInfo info = {
<span class="line-modified"> 426     0,              /* class_size */</span>
<span class="line-modified"> 427     NULL,           /* base_init */</span>
<span class="line-modified"> 428     NULL,           /* base_destroy */</span>
<span class="line-modified"> 429     NULL,           /* class_init */</span>
<span class="line-modified"> 430     NULL,           /* class_destroy */</span>
<span class="line-modified"> 431     NULL,           /* class_data */</span>
<span class="line-modified"> 432     0,              /* instance_size */</span>
<span class="line-modified"> 433     0,              /* n_preallocs */</span>
<span class="line-modified"> 434     NULL,           /* instance_init */</span>
<span class="line-modified"> 435     NULL,           /* value_table */</span>
 436   };
 437   const GTypeFundamentalInfo finfo = { G_TYPE_FLAG_DERIVABLE, };
<span class="line-modified"> 438   GType type;</span>
 439 
 440   /* G_TYPE_CHAR / G_TYPE_UCHAR
 441    */
 442   {
 443     static const GTypeValueTable value_table = {
<span class="line-modified"> 444       value_init_long0,     /* value_init */</span>
<span class="line-modified"> 445       NULL,         /* value_free */</span>
<span class="line-modified"> 446       value_copy_long0,     /* value_copy */</span>
<span class="line-modified"> 447       NULL,         /* value_peek_pointer */</span>
<span class="line-modified"> 448       &quot;i&quot;,          /* collect_format */</span>
<span class="line-modified"> 449       value_collect_int,    /* collect_value */</span>
<span class="line-modified"> 450       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 451       value_lcopy_char,     /* lcopy_value */</span>
 452     };
 453     info.value_table = &amp;value_table;
 454     type = g_type_register_fundamental (G_TYPE_CHAR, g_intern_static_string (&quot;gchar&quot;), &amp;info, &amp;finfo, 0);
 455     g_assert (type == G_TYPE_CHAR);
 456     type = g_type_register_fundamental (G_TYPE_UCHAR, g_intern_static_string (&quot;guchar&quot;), &amp;info, &amp;finfo, 0);
 457     g_assert (type == G_TYPE_UCHAR);
 458   }
 459 
 460   /* G_TYPE_BOOLEAN
 461    */
 462   {
 463     static const GTypeValueTable value_table = {
<span class="line-modified"> 464       value_init_long0,      /* value_init */</span>
<span class="line-modified"> 465       NULL,          /* value_free */</span>
<span class="line-modified"> 466       value_copy_long0,      /* value_copy */</span>
 467       NULL,                      /* value_peek_pointer */
<span class="line-modified"> 468       &quot;i&quot;,           /* collect_format */</span>
<span class="line-modified"> 469       value_collect_int,     /* collect_value */</span>
<span class="line-modified"> 470       &quot;p&quot;,           /* lcopy_format */</span>
 471       value_lcopy_boolean,   /* lcopy_value */
 472     };
 473     info.value_table = &amp;value_table;
 474     type = g_type_register_fundamental (G_TYPE_BOOLEAN, g_intern_static_string (&quot;gboolean&quot;), &amp;info, &amp;finfo, 0);
 475     g_assert (type == G_TYPE_BOOLEAN);
 476   }
 477 
 478   /* G_TYPE_INT / G_TYPE_UINT
 479    */
 480   {
 481     static const GTypeValueTable value_table = {
<span class="line-modified"> 482       value_init_long0,     /* value_init */</span>
<span class="line-modified"> 483       NULL,         /* value_free */</span>
<span class="line-modified"> 484       value_copy_long0,     /* value_copy */</span>
 485       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 486       &quot;i&quot;,          /* collect_format */</span>
<span class="line-modified"> 487       value_collect_int,    /* collect_value */</span>
<span class="line-modified"> 488       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 489       value_lcopy_int,      /* lcopy_value */</span>
 490     };
 491     info.value_table = &amp;value_table;
 492     type = g_type_register_fundamental (G_TYPE_INT, g_intern_static_string (&quot;gint&quot;), &amp;info, &amp;finfo, 0);
 493     g_assert (type == G_TYPE_INT);
 494     type = g_type_register_fundamental (G_TYPE_UINT, g_intern_static_string (&quot;guint&quot;), &amp;info, &amp;finfo, 0);
 495     g_assert (type == G_TYPE_UINT);
 496   }
 497 
 498   /* G_TYPE_LONG / G_TYPE_ULONG
 499    */
 500   {
 501     static const GTypeValueTable value_table = {
<span class="line-modified"> 502       value_init_long0,     /* value_init */</span>
<span class="line-modified"> 503       NULL,         /* value_free */</span>
<span class="line-modified"> 504       value_copy_long0,     /* value_copy */</span>
 505       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 506       &quot;l&quot;,          /* collect_format */</span>
<span class="line-modified"> 507       value_collect_long,   /* collect_value */</span>
<span class="line-modified"> 508       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 509       value_lcopy_long,     /* lcopy_value */</span>
 510     };
 511     info.value_table = &amp;value_table;
 512     type = g_type_register_fundamental (G_TYPE_LONG, g_intern_static_string (&quot;glong&quot;), &amp;info, &amp;finfo, 0);
 513     g_assert (type == G_TYPE_LONG);
 514     type = g_type_register_fundamental (G_TYPE_ULONG, g_intern_static_string (&quot;gulong&quot;), &amp;info, &amp;finfo, 0);
 515     g_assert (type == G_TYPE_ULONG);
 516   }
 517 
 518   /* G_TYPE_INT64 / G_TYPE_UINT64
 519    */
 520   {
 521     static const GTypeValueTable value_table = {
<span class="line-modified"> 522       value_init_int64,     /* value_init */</span>
<span class="line-modified"> 523       NULL,         /* value_free */</span>
<span class="line-modified"> 524       value_copy_int64,     /* value_copy */</span>
 525       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 526       &quot;q&quot;,          /* collect_format */</span>
 527       value_collect_int64,  /* collect_value */
<span class="line-modified"> 528       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 529       value_lcopy_int64,    /* lcopy_value */</span>
 530     };
 531     info.value_table = &amp;value_table;
 532     type = g_type_register_fundamental (G_TYPE_INT64, g_intern_static_string (&quot;gint64&quot;), &amp;info, &amp;finfo, 0);
 533     g_assert (type == G_TYPE_INT64);
 534     type = g_type_register_fundamental (G_TYPE_UINT64, g_intern_static_string (&quot;guint64&quot;), &amp;info, &amp;finfo, 0);
 535     g_assert (type == G_TYPE_UINT64);
 536   }
 537 
 538   /* G_TYPE_FLOAT
 539    */
 540   {
 541     static const GTypeValueTable value_table = {
<span class="line-modified"> 542       value_init_float,      /* value_init */</span>
<span class="line-modified"> 543       NULL,          /* value_free */</span>
<span class="line-modified"> 544       value_copy_float,      /* value_copy */</span>
 545       NULL,                      /* value_peek_pointer */
<span class="line-modified"> 546       &quot;d&quot;,           /* collect_format */</span>
 547       value_collect_float,   /* collect_value */
<span class="line-modified"> 548       &quot;p&quot;,           /* lcopy_format */</span>
<span class="line-modified"> 549       value_lcopy_float,     /* lcopy_value */</span>
 550     };
 551     info.value_table = &amp;value_table;
 552     type = g_type_register_fundamental (G_TYPE_FLOAT, g_intern_static_string (&quot;gfloat&quot;), &amp;info, &amp;finfo, 0);
 553     g_assert (type == G_TYPE_FLOAT);
 554   }
 555 
 556   /* G_TYPE_DOUBLE
 557    */
 558   {
 559     static const GTypeValueTable value_table = {
<span class="line-modified"> 560       value_init_double,    /* value_init */</span>
<span class="line-modified"> 561       NULL,         /* value_free */</span>
<span class="line-modified"> 562       value_copy_double,    /* value_copy */</span>
 563       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 564       &quot;d&quot;,          /* collect_format */</span>
 565       value_collect_double, /* collect_value */
<span class="line-modified"> 566       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 567       value_lcopy_double,   /* lcopy_value */</span>
 568     };
 569     info.value_table = &amp;value_table;
 570     type = g_type_register_fundamental (G_TYPE_DOUBLE, g_intern_static_string (&quot;gdouble&quot;), &amp;info, &amp;finfo, 0);
 571     g_assert (type == G_TYPE_DOUBLE);
 572   }
 573 
 574   /* G_TYPE_STRING
 575    */
 576   {
 577     static const GTypeValueTable value_table = {
<span class="line-modified"> 578       value_init_string,    /* value_init */</span>
<span class="line-modified"> 579       value_free_string,    /* value_free */</span>
<span class="line-modified"> 580       value_copy_string,    /* value_copy */</span>
 581       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 582       &quot;p&quot;,          /* collect_format */</span>
 583       value_collect_string, /* collect_value */
<span class="line-modified"> 584       &quot;p&quot;,          /* lcopy_format */</span>
<span class="line-modified"> 585       value_lcopy_string,   /* lcopy_value */</span>
 586     };
 587     info.value_table = &amp;value_table;
 588     type = g_type_register_fundamental (G_TYPE_STRING, g_intern_static_string (&quot;gchararray&quot;), &amp;info, &amp;finfo, 0);
 589     g_assert (type == G_TYPE_STRING);
 590   }
 591 
 592   /* G_TYPE_POINTER
 593    */
 594   {
 595     static const GTypeValueTable value_table = {
<span class="line-modified"> 596       value_init_pointer,   /* value_init */</span>
<span class="line-modified"> 597       NULL,         /* value_free */</span>
<span class="line-modified"> 598       value_copy_pointer,   /* value_copy */</span>
 599       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 600       &quot;p&quot;,          /* collect_format */</span>
<span class="line-modified"> 601       value_collect_pointer,    /* collect_value */</span>
<span class="line-modified"> 602       &quot;p&quot;,          /* lcopy_format */</span>
 603       value_lcopy_pointer,  /* lcopy_value */
 604     };
 605     info.value_table = &amp;value_table;
 606     type = g_type_register_fundamental (G_TYPE_POINTER, g_intern_static_string (&quot;gpointer&quot;), &amp;info, &amp;finfo, 0);
 607     g_assert (type == G_TYPE_POINTER);
 608   }
 609 
 610   /* G_TYPE_VARIANT
 611    */
 612   {
 613     static const GTypeValueTable value_table = {
<span class="line-modified"> 614       value_init_pointer,   /* value_init */</span>
<span class="line-modified"> 615       value_free_variant,   /* value_free */</span>
<span class="line-modified"> 616       value_copy_variant,   /* value_copy */</span>
 617       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 618       &quot;p&quot;,          /* collect_format */</span>
<span class="line-modified"> 619       value_collect_variant,    /* collect_value */</span>
<span class="line-modified"> 620       &quot;p&quot;,          /* lcopy_format */</span>
 621       value_lcopy_variant,  /* lcopy_value */
 622     };
 623     info.value_table = &amp;value_table;
 624     type = g_type_register_fundamental (G_TYPE_VARIANT, g_intern_static_string (&quot;GVariant&quot;), &amp;info, &amp;finfo, 0);
 625     g_assert (type == G_TYPE_VARIANT);
 626   }
 627 }
 628 
 629 
 630 /* --- GValue functions --- */
 631 /**
 632  * g_value_set_char:
 633  * @value: a valid #GValue of type %G_TYPE_CHAR
 634  * @v_char: character value to be set
 635  *
 636  * Set the contents of a %G_TYPE_CHAR #GValue to @v_char.
 637  * Deprecated: 2.32: This function&#39;s input type is broken, see g_value_set_schar()
 638  */
 639 void
 640 g_value_set_char (GValue *value,
<span class="line-modified"> 641           gchar   v_char)</span>
 642 {
 643   g_return_if_fail (G_VALUE_HOLDS_CHAR (value));
 644 
 645   value-&gt;data[0].v_int = v_char;
 646 }
 647 
 648 /**
 649  * g_value_get_char:
 650  * @value: a valid #GValue of type %G_TYPE_CHAR
 651  *
 652  * Do not use this function; it is broken on platforms where the %char
 653  * type is unsigned, such as ARM and PowerPC.  See g_value_get_schar().
 654  *
 655  * Get the contents of a %G_TYPE_CHAR #GValue.
 656  *
 657  * Returns: character contents of @value
 658  * Deprecated: 2.32: This function&#39;s return type is broken, see g_value_get_schar()
 659  */
 660 gchar
 661 g_value_get_char (const GValue *value)
 662 {
 663   g_return_val_if_fail (G_VALUE_HOLDS_CHAR (value), 0);
 664 
 665   return value-&gt;data[0].v_int;
 666 }
 667 
 668 /**
 669  * g_value_set_schar:
 670  * @value: a valid #GValue of type %G_TYPE_CHAR
 671  * @v_char: signed 8 bit integer to be set
 672  *
 673  * Set the contents of a %G_TYPE_CHAR #GValue to @v_char.
 674  *
 675  * Since: 2.32
 676  */
 677 void
 678 g_value_set_schar (GValue *value,
<span class="line-modified"> 679            gint8   v_char)</span>
 680 {
 681   g_return_if_fail (G_VALUE_HOLDS_CHAR (value));
 682 
 683   value-&gt;data[0].v_int = v_char;
 684 }
 685 
 686 /**
 687  * g_value_get_schar:
 688  * @value: a valid #GValue of type %G_TYPE_CHAR
 689  *
 690  * Get the contents of a %G_TYPE_CHAR #GValue.
 691  *
 692  * Returns: signed 8 bit integer contents of @value
 693  * Since: 2.32
 694  */
 695 gint8
 696 g_value_get_schar (const GValue *value)
 697 {
 698   g_return_val_if_fail (G_VALUE_HOLDS_CHAR (value), 0);
 699 
 700   return value-&gt;data[0].v_int;
 701 }
 702 
 703 /**
 704  * g_value_set_uchar:
 705  * @value: a valid #GValue of type %G_TYPE_UCHAR
 706  * @v_uchar: unsigned character value to be set
 707  *
 708  * Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.
 709  */
 710 void
 711 g_value_set_uchar (GValue *value,
<span class="line-modified"> 712            guchar  v_uchar)</span>
 713 {
 714   g_return_if_fail (G_VALUE_HOLDS_UCHAR (value));
 715 
 716   value-&gt;data[0].v_uint = v_uchar;
 717 }
 718 
 719 /**
 720  * g_value_get_uchar:
 721  * @value: a valid #GValue of type %G_TYPE_UCHAR
 722  *
 723  * Get the contents of a %G_TYPE_UCHAR #GValue.
 724  *
 725  * Returns: unsigned character contents of @value
 726  */
 727 guchar
 728 g_value_get_uchar (const GValue *value)
 729 {
 730   g_return_val_if_fail (G_VALUE_HOLDS_UCHAR (value), 0);
 731 
 732   return value-&gt;data[0].v_uint;
 733 }
 734 
 735 /**
 736  * g_value_set_boolean:
 737  * @value: a valid #GValue of type %G_TYPE_BOOLEAN
 738  * @v_boolean: boolean value to be set
 739  *
 740  * Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.
 741  */
 742 void
 743 g_value_set_boolean (GValue  *value,
<span class="line-modified"> 744              gboolean v_boolean)</span>
 745 {
 746   g_return_if_fail (G_VALUE_HOLDS_BOOLEAN (value));
 747 
 748   value-&gt;data[0].v_int = v_boolean != FALSE;
 749 }
 750 
 751 /**
 752  * g_value_get_boolean:
 753  * @value: a valid #GValue of type %G_TYPE_BOOLEAN
 754  *
 755  * Get the contents of a %G_TYPE_BOOLEAN #GValue.
 756  *
 757  * Returns: boolean contents of @value
 758  */
 759 gboolean
 760 g_value_get_boolean (const GValue *value)
 761 {
 762   g_return_val_if_fail (G_VALUE_HOLDS_BOOLEAN (value), 0);
 763 
 764   return value-&gt;data[0].v_int;
 765 }
 766 
 767 /**
 768  * g_value_set_int:
 769  * @value: a valid #GValue of type %G_TYPE_INT
 770  * @v_int: integer value to be set
 771  *
 772  * Set the contents of a %G_TYPE_INT #GValue to @v_int.
 773  */
 774 void
 775 g_value_set_int (GValue *value,
<span class="line-modified"> 776          gint    v_int)</span>
 777 {
 778   g_return_if_fail (G_VALUE_HOLDS_INT (value));
 779 
 780   value-&gt;data[0].v_int = v_int;
 781 }
 782 
 783 /**
 784  * g_value_get_int:
 785  * @value: a valid #GValue of type %G_TYPE_INT
 786  *
 787  * Get the contents of a %G_TYPE_INT #GValue.
 788  *
 789  * Returns: integer contents of @value
 790  */
 791 gint
 792 g_value_get_int (const GValue *value)
 793 {
 794   g_return_val_if_fail (G_VALUE_HOLDS_INT (value), 0);
 795 
 796   return value-&gt;data[0].v_int;
 797 }
 798 
 799 /**
 800  * g_value_set_uint:
 801  * @value: a valid #GValue of type %G_TYPE_UINT
 802  * @v_uint: unsigned integer value to be set
 803  *
 804  * Set the contents of a %G_TYPE_UINT #GValue to @v_uint.
 805  */
 806 void
 807 g_value_set_uint (GValue *value,
<span class="line-modified"> 808           guint   v_uint)</span>
 809 {
 810   g_return_if_fail (G_VALUE_HOLDS_UINT (value));
 811 
 812   value-&gt;data[0].v_uint = v_uint;
 813 }
 814 
 815 /**
 816  * g_value_get_uint:
 817  * @value: a valid #GValue of type %G_TYPE_UINT
 818  *
 819  * Get the contents of a %G_TYPE_UINT #GValue.
 820  *
 821  * Returns: unsigned integer contents of @value
 822  */
 823 guint
 824 g_value_get_uint (const GValue *value)
 825 {
 826   g_return_val_if_fail (G_VALUE_HOLDS_UINT (value), 0);
 827 
 828   return value-&gt;data[0].v_uint;
 829 }
 830 
 831 /**
 832  * g_value_set_long:
 833  * @value: a valid #GValue of type %G_TYPE_LONG
 834  * @v_long: long integer value to be set
 835  *
 836  * Set the contents of a %G_TYPE_LONG #GValue to @v_long.
 837  */
 838 void
 839 g_value_set_long (GValue *value,
<span class="line-modified"> 840           glong   v_long)</span>
 841 {
 842   g_return_if_fail (G_VALUE_HOLDS_LONG (value));
 843 
 844   value-&gt;data[0].v_long = v_long;
 845 }
 846 
 847 /**
 848  * g_value_get_long:
 849  * @value: a valid #GValue of type %G_TYPE_LONG
 850  *
 851  * Get the contents of a %G_TYPE_LONG #GValue.
 852  *
 853  * Returns: long integer contents of @value
 854  */
 855 glong
 856 g_value_get_long (const GValue *value)
 857 {
 858   g_return_val_if_fail (G_VALUE_HOLDS_LONG (value), 0);
 859 
 860   return value-&gt;data[0].v_long;
 861 }
 862 
 863 /**
 864  * g_value_set_ulong:
 865  * @value: a valid #GValue of type %G_TYPE_ULONG
 866  * @v_ulong: unsigned long integer value to be set
 867  *
 868  * Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.
 869  */
 870 void
 871 g_value_set_ulong (GValue *value,
<span class="line-modified"> 872            gulong  v_ulong)</span>
 873 {
 874   g_return_if_fail (G_VALUE_HOLDS_ULONG (value));
 875 
 876   value-&gt;data[0].v_ulong = v_ulong;
 877 }
 878 
 879 /**
 880  * g_value_get_ulong:
 881  * @value: a valid #GValue of type %G_TYPE_ULONG
 882  *
 883  * Get the contents of a %G_TYPE_ULONG #GValue.
 884  *
 885  * Returns: unsigned long integer contents of @value
 886  */
 887 gulong
 888 g_value_get_ulong (const GValue *value)
 889 {
 890   g_return_val_if_fail (G_VALUE_HOLDS_ULONG (value), 0);
 891 
 892   return value-&gt;data[0].v_ulong;
 893 }
 894 
 895 /**
 896  * g_value_get_int64:
 897  * @value: a valid #GValue of type %G_TYPE_INT64
 898  *
 899  * Get the contents of a %G_TYPE_INT64 #GValue.
 900  *
 901  * Returns: 64bit integer contents of @value
 902  */
 903 void
 904 g_value_set_int64 (GValue *value,
<span class="line-modified"> 905            gint64  v_int64)</span>
 906 {
 907   g_return_if_fail (G_VALUE_HOLDS_INT64 (value));
 908 
 909   value-&gt;data[0].v_int64 = v_int64;
 910 }
 911 
 912 /**
 913  * g_value_set_int64:
 914  * @value: a valid #GValue of type %G_TYPE_INT64
 915  * @v_int64: 64bit integer value to be set
 916  *
 917  * Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.
 918  */
 919 gint64
 920 g_value_get_int64 (const GValue *value)
 921 {
 922   g_return_val_if_fail (G_VALUE_HOLDS_INT64 (value), 0);
 923 
 924   return value-&gt;data[0].v_int64;
 925 }
 926 
 927 /**
 928  * g_value_set_uint64:
 929  * @value: a valid #GValue of type %G_TYPE_UINT64
 930  * @v_uint64: unsigned 64bit integer value to be set
 931  *
 932  * Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.
 933  */
 934 void
 935 g_value_set_uint64 (GValue *value,
<span class="line-modified"> 936             guint64 v_uint64)</span>
 937 {
 938   g_return_if_fail (G_VALUE_HOLDS_UINT64 (value));
 939 
 940   value-&gt;data[0].v_uint64 = v_uint64;
 941 }
 942 
 943 /**
 944  * g_value_get_uint64:
 945  * @value: a valid #GValue of type %G_TYPE_UINT64
 946  *
 947  * Get the contents of a %G_TYPE_UINT64 #GValue.
 948  *
 949  * Returns: unsigned 64bit integer contents of @value
 950  */
 951 guint64
 952 g_value_get_uint64 (const GValue *value)
 953 {
 954   g_return_val_if_fail (G_VALUE_HOLDS_UINT64 (value), 0);
 955 
 956   return value-&gt;data[0].v_uint64;
 957 }
 958 
 959 /**
 960  * g_value_set_float:
 961  * @value: a valid #GValue of type %G_TYPE_FLOAT
 962  * @v_float: float value to be set
 963  *
 964  * Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.
 965  */
 966 void
 967 g_value_set_float (GValue *value,
<span class="line-modified"> 968            gfloat  v_float)</span>
 969 {
 970   g_return_if_fail (G_VALUE_HOLDS_FLOAT (value));
 971 
 972   value-&gt;data[0].v_float = v_float;
 973 }
 974 
 975 /**
 976  * g_value_get_float:
 977  * @value: a valid #GValue of type %G_TYPE_FLOAT
 978  *
 979  * Get the contents of a %G_TYPE_FLOAT #GValue.
 980  *
 981  * Returns: float contents of @value
 982  */
 983 gfloat
 984 g_value_get_float (const GValue *value)
 985 {
 986   g_return_val_if_fail (G_VALUE_HOLDS_FLOAT (value), 0);
 987 
 988   return value-&gt;data[0].v_float;
 989 }
 990 
 991 /**
 992  * g_value_set_double:
 993  * @value: a valid #GValue of type %G_TYPE_DOUBLE
 994  * @v_double: double value to be set
 995  *
 996  * Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.
 997  */
 998 void
 999 g_value_set_double (GValue *value,
<span class="line-modified">1000             gdouble v_double)</span>
1001 {
1002   g_return_if_fail (G_VALUE_HOLDS_DOUBLE (value));
1003 
1004   value-&gt;data[0].v_double = v_double;
1005 }
1006 
1007 /**
1008  * g_value_get_double:
1009  * @value: a valid #GValue of type %G_TYPE_DOUBLE
1010  *
1011  * Get the contents of a %G_TYPE_DOUBLE #GValue.
1012  *
1013  * Returns: double contents of @value
1014  */
1015 gdouble
1016 g_value_get_double (const GValue *value)
1017 {
1018   g_return_val_if_fail (G_VALUE_HOLDS_DOUBLE (value), 0);
1019 
1020   return value-&gt;data[0].v_double;
1021 }
1022 
1023 /**
1024  * g_value_set_string:
1025  * @value: a valid #GValue of type %G_TYPE_STRING
1026  * @v_string: (nullable): caller-owned string to be duplicated for the #GValue
1027  *
1028  * Set the contents of a %G_TYPE_STRING #GValue to @v_string.
1029  */
1030 void
1031 g_value_set_string (GValue  *value,
<span class="line-modified">1032                     const gchar *v_string)</span>
1033 {
1034   gchar *new_val;
1035 
1036   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1037 
1038   new_val = g_strdup (v_string);
1039 
1040   if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
1041     value-&gt;data[1].v_uint = 0;
1042   else
1043     g_free (value-&gt;data[0].v_pointer);
1044 
1045   value-&gt;data[0].v_pointer = new_val;
1046 }
1047 
1048 /**
1049  * g_value_set_static_string:
1050  * @value: a valid #GValue of type %G_TYPE_STRING
1051  * @v_string: (nullable): static string to be set
1052  *
1053  * Set the contents of a %G_TYPE_STRING #GValue to @v_string.
1054  * The string is assumed to be static, and is thus not duplicated
1055  * when setting the #GValue.
1056  */
1057 void
1058 g_value_set_static_string (GValue      *value,
<span class="line-modified">1059                const gchar *v_string)</span>
1060 {
1061   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1062 
1063   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
1064     g_free (value-&gt;data[0].v_pointer);
1065   value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
1066   value-&gt;data[0].v_pointer = (gchar*) v_string;
1067 }
1068 
1069 /**
1070  * g_value_set_string_take_ownership:
1071  * @value: a valid #GValue of type %G_TYPE_STRING
1072  * @v_string: (nullable): duplicated unowned string to be set
1073  *
1074  * This is an internal function introduced mainly for C marshallers.
1075  *
1076  * Deprecated: 2.4: Use g_value_take_string() instead.
1077  */
1078 void
1079 g_value_set_string_take_ownership (GValue *value,
<span class="line-modified">1080                    gchar  *v_string)</span>
1081 {
1082   g_value_take_string (value, v_string);
1083 }
1084 
1085 /**
1086  * g_value_take_string:
1087  * @value: a valid #GValue of type %G_TYPE_STRING
1088  * @v_string: (nullable): string to take ownership of
1089  *
1090  * Sets the contents of a %G_TYPE_STRING #GValue to @v_string.
1091  *
1092  * Since: 2.4
1093  */
1094 void
1095 g_value_take_string (GValue *value,
<span class="line-modified">1096              gchar  *v_string)</span>
1097 {
1098   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1099 
1100   if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
1101     value-&gt;data[1].v_uint = 0;
1102   else
1103     g_free (value-&gt;data[0].v_pointer);
1104   value-&gt;data[0].v_pointer = v_string;
1105 }
1106 
1107 /**
1108  * g_value_get_string:
1109  * @value: a valid #GValue of type %G_TYPE_STRING
1110  *
1111  * Get the contents of a %G_TYPE_STRING #GValue.
1112  *
1113  * Returns: string content of @value
1114  */
1115 const gchar*
1116 g_value_get_string (const GValue *value)
</pre>
<hr />
<pre>
1128  *
1129  * Returns: a newly allocated copy of the string content of @value
1130  */
1131 gchar*
1132 g_value_dup_string (const GValue *value)
1133 {
1134   g_return_val_if_fail (G_VALUE_HOLDS_STRING (value), NULL);
1135 
1136   return g_strdup (value-&gt;data[0].v_pointer);
1137 }
1138 
1139 /**
1140  * g_value_set_pointer:
1141  * @value: a valid #GValue of %G_TYPE_POINTER
1142  * @v_pointer: pointer value to be set
1143  *
1144  * Set the contents of a pointer #GValue to @v_pointer.
1145  */
1146 void
1147 g_value_set_pointer (GValue  *value,
<span class="line-modified">1148              gpointer v_pointer)</span>
1149 {
1150   g_return_if_fail (G_VALUE_HOLDS_POINTER (value));
1151 
1152   value-&gt;data[0].v_pointer = v_pointer;
1153 }
1154 
1155 /**
1156  * g_value_get_pointer:
1157  * @value: a valid #GValue of %G_TYPE_POINTER
1158  *
1159  * Get the contents of a pointer #GValue.
1160  *
1161  * Returns: (transfer none): pointer contents of @value
1162  */
1163 gpointer
1164 g_value_get_pointer (const GValue *value)
1165 {
1166   g_return_val_if_fail (G_VALUE_HOLDS_POINTER (value), NULL);
1167 
1168   return value-&gt;data[0].v_pointer;
1169 }
1170 
1171 G_DEFINE_POINTER_TYPE (GType, g_gtype)
1172 
1173 /**
1174  * g_value_set_gtype:
1175  * @value: a valid #GValue of type %G_TYPE_GTYPE
1176  * @v_gtype: #GType to be set
1177  *
1178  * Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.
1179  *
1180  * Since: 2.12
1181  */
1182 void
1183 g_value_set_gtype (GValue *value,
<span class="line-modified">1184            GType   v_gtype)</span>
1185 {
1186   g_return_if_fail (G_VALUE_HOLDS_GTYPE (value));
1187 
1188   value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (v_gtype);
1189 
1190 }
1191 
1192 /**
1193  * g_value_get_gtype:
1194  * @value: a valid #GValue of type %G_TYPE_GTYPE
1195  *
1196  * Get the contents of a %G_TYPE_GTYPE #GValue.
1197  *
1198  * Since: 2.12
1199  *
1200  * Returns: the #GType stored in @value
1201  */
1202 GType
1203 g_value_get_gtype (const GValue *value)
1204 {
</pre>
<hr />
<pre>
1326  * Return a newly allocated string, which describes the contents of a
1327  * #GValue.  The main purpose of this function is to describe #GValue
1328  * contents for debugging output, the way in which the contents are
1329  * described may change between different GLib versions.
1330  *
1331  * Returns: Newly allocated string.
1332  */
1333 gchar*
1334 g_strdup_value_contents (const GValue *value)
1335 {
1336   const gchar *src;
1337   gchar *contents;
1338 
1339   g_return_val_if_fail (G_IS_VALUE (value), NULL);
1340 
1341   if (G_VALUE_HOLDS_STRING (value))
1342     {
1343       src = g_value_get_string (value);
1344 
1345       if (!src)
<span class="line-modified">1346     contents = g_strdup (&quot;NULL&quot;);</span>
1347       else
<span class="line-modified">1348     {</span>
<span class="line-modified">1349       gchar *s = g_strescape (src, NULL);</span>
1350 
<span class="line-modified">1351       contents = g_strdup_printf (&quot;\&quot;%s\&quot;&quot;, s);</span>
<span class="line-modified">1352       g_free (s);</span>
<span class="line-modified">1353     }</span>
1354     }
1355   else if (g_value_type_transformable (G_VALUE_TYPE (value), G_TYPE_STRING))
1356     {
1357       GValue tmp_value = G_VALUE_INIT;
1358       gchar *s;
1359 
1360       g_value_init (&amp;tmp_value, G_TYPE_STRING);
1361       g_value_transform (value, &amp;tmp_value);
1362       s = g_strescape (g_value_get_string (&amp;tmp_value), NULL);
1363       g_value_unset (&amp;tmp_value);
1364       if (G_VALUE_HOLDS_ENUM (value) || G_VALUE_HOLDS_FLAGS (value))
<span class="line-modified">1365     contents = g_strdup_printf (&quot;((%s) %s)&quot;,</span>
<span class="line-modified">1366                     g_type_name (G_VALUE_TYPE (value)),</span>
<span class="line-modified">1367                     s);</span>
1368       else
<span class="line-modified">1369     contents = g_strdup (s ? s : &quot;NULL&quot;);</span>
1370       g_free (s);
1371     }
1372   else if (g_value_fits_pointer (value))
1373     {
1374       gpointer p = g_value_peek_pointer (value);
1375 
1376       if (!p)
<span class="line-modified">1377     contents = g_strdup (&quot;NULL&quot;);</span>
1378       else if (G_VALUE_HOLDS_OBJECT (value))
<span class="line-modified">1379     contents = g_strdup_printf (&quot;((%s*) %p)&quot;, G_OBJECT_TYPE_NAME (p), p);</span>
1380       else if (G_VALUE_HOLDS_PARAM (value))
<span class="line-modified">1381     contents = g_strdup_printf (&quot;((%s*) %p)&quot;, G_PARAM_SPEC_TYPE_NAME (p), p);</span>
1382       else if (G_VALUE_HOLDS (value, G_TYPE_STRV))
1383         {
1384           GStrv strv = g_value_get_boxed (value);
1385           GString *tmp = g_string_new (&quot;[&quot;);
1386 
1387           while (*strv != NULL)
1388             {
1389               gchar *escaped = g_strescape (*strv, NULL);
1390 
1391               g_string_append_printf (tmp, &quot;\&quot;%s\&quot;&quot;, escaped);
1392               g_free (escaped);
1393 
1394               if (*++strv != NULL)
1395                 g_string_append (tmp, &quot;, &quot;);
1396             }
1397 
1398           g_string_append (tmp, &quot;]&quot;);
1399           contents = g_string_free (tmp, FALSE);
1400         }
1401       else if (G_VALUE_HOLDS_BOXED (value))
<span class="line-modified">1402     contents = g_strdup_printf (&quot;((%s*) %p)&quot;, g_type_name (G_VALUE_TYPE (value)), p);</span>
1403       else if (G_VALUE_HOLDS_POINTER (value))
<span class="line-modified">1404     contents = g_strdup_printf (&quot;((gpointer) %p)&quot;, p);</span>
1405       else
<span class="line-modified">1406     contents = g_strdup (&quot;???&quot;);</span>
1407     }
1408   else
1409     contents = g_strdup (&quot;???&quot;);
1410 
1411   return contents;
1412 }
1413 
1414 /**
1415  * g_pointer_type_register_static:
1416  * @name: the name of the new pointer type.
1417  *
1418  * Creates a new %G_TYPE_POINTER derived type id for a new
1419  * pointer type with name @name.
1420  *
1421  * Returns: a new %G_TYPE_POINTER derived type id for @name.
1422  */
1423 GType
1424 g_pointer_type_register_static (const gchar *name)
1425 {
1426   const GTypeInfo type_info = {
<span class="line-modified">1427     0,          /* class_size */</span>
<span class="line-modified">1428     NULL,       /* base_init */</span>
<span class="line-modified">1429     NULL,       /* base_finalize */</span>
<span class="line-modified">1430     NULL,       /* class_init */</span>
<span class="line-modified">1431     NULL,       /* class_finalize */</span>
<span class="line-modified">1432     NULL,       /* class_data */</span>
<span class="line-modified">1433     0,          /* instance_size */</span>
<span class="line-modified">1434     0,          /* n_preallocs */</span>
<span class="line-modified">1435     NULL,       /* instance_init */</span>
<span class="line-modified">1436     NULL        /* value_table */</span>
1437   };
1438   GType type;
1439 
1440   g_return_val_if_fail (name != NULL, 0);
1441   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
1442 
1443   type = g_type_register_static (G_TYPE_POINTER, name, &amp;type_info, 0);
1444 
1445   return type;
1446 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
<span class="line-modified">   3  * Copyright (C) 2010 Christian Persch</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General
  16  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 /*
  20  * MT safe
  21  */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  26 #include &lt;stdlib.h&gt; /* qsort() */
  27 
  28 #include &quot;gvaluetypes.h&quot;
  29 #include &quot;gtype-private.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gobject.h&quot;
  32 #include &quot;gparam.h&quot;
  33 #include &quot;gboxed.h&quot;
  34 #include &quot;genums.h&quot;
  35 
  36 
  37 /* --- value functions --- */
  38 static void
  39 value_init_long0 (GValue *value)
  40 {
  41   value-&gt;data[0].v_long = 0;
  42 }
  43 
  44 static void
  45 value_copy_long0 (const GValue *src_value,
<span class="line-modified">  46       GValue       *dest_value)</span>
  47 {
  48   dest_value-&gt;data[0].v_long = src_value-&gt;data[0].v_long;
  49 }
  50 
  51 static gchar*
  52 value_lcopy_char (const GValue *value,
<span class="line-modified">  53       guint         n_collect_values,</span>
<span class="line-modified">  54       GTypeCValue  *collect_values,</span>
<span class="line-modified">  55       guint         collect_flags)</span>
  56 {
  57   gint8 *int8_p = collect_values[0].v_pointer;
  58 
  59   if (!int8_p)
  60     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
  61 
  62   *int8_p = value-&gt;data[0].v_int;
  63 
  64   return NULL;
  65 }
  66 
  67 static gchar*
  68 value_lcopy_boolean (const GValue *value,
<span class="line-modified">  69          guint         n_collect_values,</span>
<span class="line-modified">  70          GTypeCValue  *collect_values,</span>
<span class="line-modified">  71          guint         collect_flags)</span>
  72 {
  73   gboolean *bool_p = collect_values[0].v_pointer;
  74 
  75   if (!bool_p)
  76     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
  77 
  78   *bool_p = value-&gt;data[0].v_int;
  79 
  80   return NULL;
  81 }
  82 
  83 static gchar*
  84 value_collect_int (GValue      *value,
<span class="line-modified">  85        guint        n_collect_values,</span>
<span class="line-modified">  86        GTypeCValue *collect_values,</span>
<span class="line-modified">  87        guint        collect_flags)</span>
  88 {
  89   value-&gt;data[0].v_int = collect_values[0].v_int;
  90 
  91   return NULL;
  92 }
  93 
  94 static gchar*
  95 value_lcopy_int (const GValue *value,
<span class="line-modified">  96      guint         n_collect_values,</span>
<span class="line-modified">  97      GTypeCValue  *collect_values,</span>
<span class="line-modified">  98      guint         collect_flags)</span>
  99 {
 100   gint *int_p = collect_values[0].v_pointer;
 101 
 102   if (!int_p)
 103     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 104 
 105   *int_p = value-&gt;data[0].v_int;
 106 
 107   return NULL;
 108 }
 109 
 110 static gchar*
 111 value_collect_long (GValue      *value,
<span class="line-modified"> 112         guint        n_collect_values,</span>
<span class="line-modified"> 113         GTypeCValue *collect_values,</span>
<span class="line-modified"> 114         guint        collect_flags)</span>
 115 {
 116   value-&gt;data[0].v_long = collect_values[0].v_long;
 117 
 118   return NULL;
 119 }
 120 
 121 static gchar*
 122 value_lcopy_long (const GValue *value,
<span class="line-modified"> 123       guint         n_collect_values,</span>
<span class="line-modified"> 124       GTypeCValue  *collect_values,</span>
<span class="line-modified"> 125       guint         collect_flags)</span>
 126 {
 127   glong *long_p = collect_values[0].v_pointer;
 128 
 129   if (!long_p)
 130     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 131 
 132   *long_p = value-&gt;data[0].v_long;
 133 
 134   return NULL;
 135 }
 136 
 137 static void
 138 value_init_int64 (GValue *value)
 139 {
 140   value-&gt;data[0].v_int64 = 0;
 141 }
 142 
 143 static void
 144 value_copy_int64 (const GValue *src_value,
<span class="line-modified"> 145       GValue       *dest_value)</span>
 146 {
 147   dest_value-&gt;data[0].v_int64 = src_value-&gt;data[0].v_int64;
 148 }
 149 
 150 static gchar*
 151 value_collect_int64 (GValue      *value,
<span class="line-modified"> 152          guint        n_collect_values,</span>
<span class="line-modified"> 153          GTypeCValue *collect_values,</span>
<span class="line-modified"> 154          guint        collect_flags)</span>
 155 {
 156   value-&gt;data[0].v_int64 = collect_values[0].v_int64;
 157 
 158   return NULL;
 159 }
 160 
 161 static gchar*
 162 value_lcopy_int64 (const GValue *value,
<span class="line-modified"> 163        guint         n_collect_values,</span>
<span class="line-modified"> 164        GTypeCValue  *collect_values,</span>
<span class="line-modified"> 165        guint         collect_flags)</span>
 166 {
 167   gint64 *int64_p = collect_values[0].v_pointer;
 168 
 169   if (!int64_p)
 170     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 171 
 172   *int64_p = value-&gt;data[0].v_int64;
 173 
 174   return NULL;
 175 }
 176 
 177 static void
 178 value_init_float (GValue *value)
 179 {
 180   value-&gt;data[0].v_float = 0.0;
 181 }
 182 
 183 static void
 184 value_copy_float (const GValue *src_value,
<span class="line-modified"> 185       GValue       *dest_value)</span>
 186 {
 187   dest_value-&gt;data[0].v_float = src_value-&gt;data[0].v_float;
 188 }
 189 
 190 static gchar*
 191 value_collect_float (GValue      *value,
<span class="line-modified"> 192          guint        n_collect_values,</span>
<span class="line-modified"> 193          GTypeCValue *collect_values,</span>
<span class="line-modified"> 194          guint        collect_flags)</span>
 195 {
 196   value-&gt;data[0].v_float = collect_values[0].v_double;
 197 
 198   return NULL;
 199 }
 200 
 201 static gchar*
 202 value_lcopy_float (const GValue *value,
<span class="line-modified"> 203        guint         n_collect_values,</span>
<span class="line-modified"> 204        GTypeCValue  *collect_values,</span>
<span class="line-modified"> 205        guint         collect_flags)</span>
 206 {
 207   gfloat *float_p = collect_values[0].v_pointer;
 208 
 209   if (!float_p)
 210     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 211 
 212   *float_p = value-&gt;data[0].v_float;
 213 
 214   return NULL;
 215 }
 216 
 217 static void
 218 value_init_double (GValue *value)
 219 {
 220   value-&gt;data[0].v_double = 0.0;
 221 }
 222 
 223 static void
 224 value_copy_double (const GValue *src_value,
<span class="line-modified"> 225        GValue *dest_value)</span>
 226 {
 227   dest_value-&gt;data[0].v_double = src_value-&gt;data[0].v_double;
 228 }
 229 
 230 static gchar*
<span class="line-modified"> 231 value_collect_double (GValue    *value,</span>
<span class="line-modified"> 232           guint        n_collect_values,</span>
<span class="line-modified"> 233           GTypeCValue *collect_values,</span>
<span class="line-modified"> 234           guint        collect_flags)</span>
 235 {
 236   value-&gt;data[0].v_double = collect_values[0].v_double;
 237 
 238   return NULL;
 239 }
 240 
 241 static gchar*
 242 value_lcopy_double (const GValue *value,
<span class="line-modified"> 243         guint         n_collect_values,</span>
<span class="line-modified"> 244         GTypeCValue  *collect_values,</span>
<span class="line-modified"> 245         guint         collect_flags)</span>
 246 {
 247   gdouble *double_p = collect_values[0].v_pointer;
 248 
 249   if (!double_p)
 250     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 251 
 252   *double_p = value-&gt;data[0].v_double;
 253 
 254   return NULL;
 255 }
 256 
 257 static void
 258 value_init_string (GValue *value)
 259 {
 260   value-&gt;data[0].v_pointer = NULL;
 261 }
 262 
 263 static void
 264 value_free_string (GValue *value)
 265 {
 266   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
 267     g_free (value-&gt;data[0].v_pointer);
 268 }
 269 
 270 static void
 271 value_copy_string (const GValue *src_value,
<span class="line-modified"> 272        GValue *dest_value)</span>
 273 {
 274   dest_value-&gt;data[0].v_pointer = g_strdup (src_value-&gt;data[0].v_pointer);
 275 }
 276 
 277 static gchar*
<span class="line-modified"> 278 value_collect_string (GValue    *value,</span>
<span class="line-modified"> 279           guint        n_collect_values,</span>
<span class="line-modified"> 280           GTypeCValue *collect_values,</span>
<span class="line-modified"> 281           guint        collect_flags)</span>
 282 {
 283   if (!collect_values[0].v_pointer)
 284     value-&gt;data[0].v_pointer = NULL;
 285   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 286     {
 287       value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 288       value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 289     }
 290   else
 291     value-&gt;data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
 292 
 293   return NULL;
 294 }
 295 
 296 static gchar*
 297 value_lcopy_string (const GValue *value,
<span class="line-modified"> 298         guint         n_collect_values,</span>
<span class="line-modified"> 299         GTypeCValue  *collect_values,</span>
<span class="line-modified"> 300         guint         collect_flags)</span>
 301 {
 302   gchar **string_p = collect_values[0].v_pointer;
 303 
 304   if (!string_p)
 305     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 306 
 307   if (!value-&gt;data[0].v_pointer)
 308     *string_p = NULL;
 309   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 310     *string_p = value-&gt;data[0].v_pointer;
 311   else
 312     *string_p = g_strdup (value-&gt;data[0].v_pointer);
 313 
 314   return NULL;
 315 }
 316 
 317 static void
 318 value_init_pointer (GValue *value)
 319 {
 320   value-&gt;data[0].v_pointer = NULL;
 321 }
 322 
 323 static void
 324 value_copy_pointer (const GValue *src_value,
<span class="line-modified"> 325         GValue       *dest_value)</span>
 326 {
 327   dest_value-&gt;data[0].v_pointer = src_value-&gt;data[0].v_pointer;
 328 }
 329 
 330 static gpointer
 331 value_peek_pointer0 (const GValue *value)
 332 {
 333   return value-&gt;data[0].v_pointer;
 334 }
 335 
 336 static gchar*
 337 value_collect_pointer (GValue      *value,
<span class="line-modified"> 338            guint        n_collect_values,</span>
<span class="line-modified"> 339            GTypeCValue *collect_values,</span>
<span class="line-modified"> 340            guint        collect_flags)</span>
 341 {
 342   value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 343 
 344   return NULL;
 345 }
 346 
 347 static gchar*
 348 value_lcopy_pointer (const GValue *value,
<span class="line-modified"> 349          guint         n_collect_values,</span>
<span class="line-modified"> 350          GTypeCValue  *collect_values,</span>
<span class="line-modified"> 351          guint         collect_flags)</span>
 352 {
 353   gpointer *pointer_p = collect_values[0].v_pointer;
 354 
 355   if (!pointer_p)
 356     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 357 
 358   *pointer_p = value-&gt;data[0].v_pointer;
 359 
 360   return NULL;
 361 }
 362 
 363 static void
 364 value_free_variant (GValue *value)
 365 {
 366   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS) &amp;&amp;
 367       value-&gt;data[0].v_pointer)
 368     g_variant_unref (value-&gt;data[0].v_pointer);
 369 }
 370 
 371 static void
 372 value_copy_variant (const GValue *src_value,
<span class="line-modified"> 373        GValue *dest_value)</span>
 374 {
 375   if (src_value-&gt;data[0].v_pointer)
 376     dest_value-&gt;data[0].v_pointer = g_variant_ref_sink (src_value-&gt;data[0].v_pointer);
 377   else
 378     dest_value-&gt;data[0].v_pointer = NULL;
 379 }
 380 
 381 static gchar*
<span class="line-modified"> 382 value_collect_variant (GValue   *value,</span>
<span class="line-modified"> 383           guint        n_collect_values,</span>
<span class="line-modified"> 384           GTypeCValue *collect_values,</span>
<span class="line-modified"> 385           guint        collect_flags)</span>
 386 {
 387   if (!collect_values[0].v_pointer)
 388     value-&gt;data[0].v_pointer = NULL;
 389   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 390     {
 391       value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 392       value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 393     }
 394   else
 395     value-&gt;data[0].v_pointer = g_variant_ref_sink (collect_values[0].v_pointer);
 396 
 397   return NULL;
 398 }
 399 
 400 static gchar*
 401 value_lcopy_variant (const GValue *value,
<span class="line-modified"> 402         guint         n_collect_values,</span>
<span class="line-modified"> 403         GTypeCValue  *collect_values,</span>
<span class="line-modified"> 404         guint         collect_flags)</span>
 405 {
 406   GVariant **variant_p = collect_values[0].v_pointer;
 407 
 408   if (!variant_p)
 409     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 410 
 411   if (!value-&gt;data[0].v_pointer)
 412     *variant_p = NULL;
 413   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 414     *variant_p = value-&gt;data[0].v_pointer;
 415   else
 416     *variant_p = g_variant_ref_sink (value-&gt;data[0].v_pointer);
 417 
 418   return NULL;
 419 }
 420 
 421 /* --- type initialization --- */
 422 void
 423 _g_value_types_init (void)
 424 {
 425   GTypeInfo info = {
<span class="line-modified"> 426     0,        /* class_size */</span>
<span class="line-modified"> 427     NULL,     /* base_init */</span>
<span class="line-modified"> 428     NULL,     /* base_destroy */</span>
<span class="line-modified"> 429     NULL,     /* class_init */</span>
<span class="line-modified"> 430     NULL,     /* class_destroy */</span>
<span class="line-modified"> 431     NULL,     /* class_data */</span>
<span class="line-modified"> 432     0,        /* instance_size */</span>
<span class="line-modified"> 433     0,        /* n_preallocs */</span>
<span class="line-modified"> 434     NULL,     /* instance_init */</span>
<span class="line-modified"> 435     NULL,     /* value_table */</span>
 436   };
 437   const GTypeFundamentalInfo finfo = { G_TYPE_FLAG_DERIVABLE, };
<span class="line-modified"> 438   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
 439 
 440   /* G_TYPE_CHAR / G_TYPE_UCHAR
 441    */
 442   {
 443     static const GTypeValueTable value_table = {
<span class="line-modified"> 444       value_init_long0,   /* value_init */</span>
<span class="line-modified"> 445       NULL,     /* value_free */</span>
<span class="line-modified"> 446       value_copy_long0,   /* value_copy */</span>
<span class="line-modified"> 447       NULL,     /* value_peek_pointer */</span>
<span class="line-modified"> 448       &quot;i&quot;,      /* collect_format */</span>
<span class="line-modified"> 449       value_collect_int,  /* collect_value */</span>
<span class="line-modified"> 450       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 451       value_lcopy_char,   /* lcopy_value */</span>
 452     };
 453     info.value_table = &amp;value_table;
 454     type = g_type_register_fundamental (G_TYPE_CHAR, g_intern_static_string (&quot;gchar&quot;), &amp;info, &amp;finfo, 0);
 455     g_assert (type == G_TYPE_CHAR);
 456     type = g_type_register_fundamental (G_TYPE_UCHAR, g_intern_static_string (&quot;guchar&quot;), &amp;info, &amp;finfo, 0);
 457     g_assert (type == G_TYPE_UCHAR);
 458   }
 459 
 460   /* G_TYPE_BOOLEAN
 461    */
 462   {
 463     static const GTypeValueTable value_table = {
<span class="line-modified"> 464       value_init_long0,    /* value_init */</span>
<span class="line-modified"> 465       NULL,      /* value_free */</span>
<span class="line-modified"> 466       value_copy_long0,    /* value_copy */</span>
 467       NULL,                      /* value_peek_pointer */
<span class="line-modified"> 468       &quot;i&quot;,       /* collect_format */</span>
<span class="line-modified"> 469       value_collect_int,   /* collect_value */</span>
<span class="line-modified"> 470       &quot;p&quot;,       /* lcopy_format */</span>
 471       value_lcopy_boolean,   /* lcopy_value */
 472     };
 473     info.value_table = &amp;value_table;
 474     type = g_type_register_fundamental (G_TYPE_BOOLEAN, g_intern_static_string (&quot;gboolean&quot;), &amp;info, &amp;finfo, 0);
 475     g_assert (type == G_TYPE_BOOLEAN);
 476   }
 477 
 478   /* G_TYPE_INT / G_TYPE_UINT
 479    */
 480   {
 481     static const GTypeValueTable value_table = {
<span class="line-modified"> 482       value_init_long0,   /* value_init */</span>
<span class="line-modified"> 483       NULL,     /* value_free */</span>
<span class="line-modified"> 484       value_copy_long0,   /* value_copy */</span>
 485       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 486       &quot;i&quot;,      /* collect_format */</span>
<span class="line-modified"> 487       value_collect_int,  /* collect_value */</span>
<span class="line-modified"> 488       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 489       value_lcopy_int,    /* lcopy_value */</span>
 490     };
 491     info.value_table = &amp;value_table;
 492     type = g_type_register_fundamental (G_TYPE_INT, g_intern_static_string (&quot;gint&quot;), &amp;info, &amp;finfo, 0);
 493     g_assert (type == G_TYPE_INT);
 494     type = g_type_register_fundamental (G_TYPE_UINT, g_intern_static_string (&quot;guint&quot;), &amp;info, &amp;finfo, 0);
 495     g_assert (type == G_TYPE_UINT);
 496   }
 497 
 498   /* G_TYPE_LONG / G_TYPE_ULONG
 499    */
 500   {
 501     static const GTypeValueTable value_table = {
<span class="line-modified"> 502       value_init_long0,   /* value_init */</span>
<span class="line-modified"> 503       NULL,     /* value_free */</span>
<span class="line-modified"> 504       value_copy_long0,   /* value_copy */</span>
 505       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 506       &quot;l&quot;,      /* collect_format */</span>
<span class="line-modified"> 507       value_collect_long, /* collect_value */</span>
<span class="line-modified"> 508       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 509       value_lcopy_long,   /* lcopy_value */</span>
 510     };
 511     info.value_table = &amp;value_table;
 512     type = g_type_register_fundamental (G_TYPE_LONG, g_intern_static_string (&quot;glong&quot;), &amp;info, &amp;finfo, 0);
 513     g_assert (type == G_TYPE_LONG);
 514     type = g_type_register_fundamental (G_TYPE_ULONG, g_intern_static_string (&quot;gulong&quot;), &amp;info, &amp;finfo, 0);
 515     g_assert (type == G_TYPE_ULONG);
 516   }
 517 
 518   /* G_TYPE_INT64 / G_TYPE_UINT64
 519    */
 520   {
 521     static const GTypeValueTable value_table = {
<span class="line-modified"> 522       value_init_int64,   /* value_init */</span>
<span class="line-modified"> 523       NULL,     /* value_free */</span>
<span class="line-modified"> 524       value_copy_int64,   /* value_copy */</span>
 525       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 526       &quot;q&quot;,      /* collect_format */</span>
 527       value_collect_int64,  /* collect_value */
<span class="line-modified"> 528       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 529       value_lcopy_int64,  /* lcopy_value */</span>
 530     };
 531     info.value_table = &amp;value_table;
 532     type = g_type_register_fundamental (G_TYPE_INT64, g_intern_static_string (&quot;gint64&quot;), &amp;info, &amp;finfo, 0);
 533     g_assert (type == G_TYPE_INT64);
 534     type = g_type_register_fundamental (G_TYPE_UINT64, g_intern_static_string (&quot;guint64&quot;), &amp;info, &amp;finfo, 0);
 535     g_assert (type == G_TYPE_UINT64);
 536   }
 537 
 538   /* G_TYPE_FLOAT
 539    */
 540   {
 541     static const GTypeValueTable value_table = {
<span class="line-modified"> 542       value_init_float,    /* value_init */</span>
<span class="line-modified"> 543       NULL,      /* value_free */</span>
<span class="line-modified"> 544       value_copy_float,    /* value_copy */</span>
 545       NULL,                      /* value_peek_pointer */
<span class="line-modified"> 546       &quot;d&quot;,       /* collect_format */</span>
 547       value_collect_float,   /* collect_value */
<span class="line-modified"> 548       &quot;p&quot;,       /* lcopy_format */</span>
<span class="line-modified"> 549       value_lcopy_float,   /* lcopy_value */</span>
 550     };
 551     info.value_table = &amp;value_table;
 552     type = g_type_register_fundamental (G_TYPE_FLOAT, g_intern_static_string (&quot;gfloat&quot;), &amp;info, &amp;finfo, 0);
 553     g_assert (type == G_TYPE_FLOAT);
 554   }
 555 
 556   /* G_TYPE_DOUBLE
 557    */
 558   {
 559     static const GTypeValueTable value_table = {
<span class="line-modified"> 560       value_init_double,  /* value_init */</span>
<span class="line-modified"> 561       NULL,     /* value_free */</span>
<span class="line-modified"> 562       value_copy_double,  /* value_copy */</span>
 563       NULL,                     /* value_peek_pointer */
<span class="line-modified"> 564       &quot;d&quot;,      /* collect_format */</span>
 565       value_collect_double, /* collect_value */
<span class="line-modified"> 566       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 567       value_lcopy_double, /* lcopy_value */</span>
 568     };
 569     info.value_table = &amp;value_table;
 570     type = g_type_register_fundamental (G_TYPE_DOUBLE, g_intern_static_string (&quot;gdouble&quot;), &amp;info, &amp;finfo, 0);
 571     g_assert (type == G_TYPE_DOUBLE);
 572   }
 573 
 574   /* G_TYPE_STRING
 575    */
 576   {
 577     static const GTypeValueTable value_table = {
<span class="line-modified"> 578       value_init_string,  /* value_init */</span>
<span class="line-modified"> 579       value_free_string,  /* value_free */</span>
<span class="line-modified"> 580       value_copy_string,  /* value_copy */</span>
 581       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 582       &quot;p&quot;,      /* collect_format */</span>
 583       value_collect_string, /* collect_value */
<span class="line-modified"> 584       &quot;p&quot;,      /* lcopy_format */</span>
<span class="line-modified"> 585       value_lcopy_string, /* lcopy_value */</span>
 586     };
 587     info.value_table = &amp;value_table;
 588     type = g_type_register_fundamental (G_TYPE_STRING, g_intern_static_string (&quot;gchararray&quot;), &amp;info, &amp;finfo, 0);
 589     g_assert (type == G_TYPE_STRING);
 590   }
 591 
 592   /* G_TYPE_POINTER
 593    */
 594   {
 595     static const GTypeValueTable value_table = {
<span class="line-modified"> 596       value_init_pointer, /* value_init */</span>
<span class="line-modified"> 597       NULL,     /* value_free */</span>
<span class="line-modified"> 598       value_copy_pointer, /* value_copy */</span>
 599       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 600       &quot;p&quot;,      /* collect_format */</span>
<span class="line-modified"> 601       value_collect_pointer,  /* collect_value */</span>
<span class="line-modified"> 602       &quot;p&quot;,      /* lcopy_format */</span>
 603       value_lcopy_pointer,  /* lcopy_value */
 604     };
 605     info.value_table = &amp;value_table;
 606     type = g_type_register_fundamental (G_TYPE_POINTER, g_intern_static_string (&quot;gpointer&quot;), &amp;info, &amp;finfo, 0);
 607     g_assert (type == G_TYPE_POINTER);
 608   }
 609 
 610   /* G_TYPE_VARIANT
 611    */
 612   {
 613     static const GTypeValueTable value_table = {
<span class="line-modified"> 614       value_init_pointer, /* value_init */</span>
<span class="line-modified"> 615       value_free_variant, /* value_free */</span>
<span class="line-modified"> 616       value_copy_variant, /* value_copy */</span>
 617       value_peek_pointer0,  /* value_peek_pointer */
<span class="line-modified"> 618       &quot;p&quot;,      /* collect_format */</span>
<span class="line-modified"> 619       value_collect_variant,  /* collect_value */</span>
<span class="line-modified"> 620       &quot;p&quot;,      /* lcopy_format */</span>
 621       value_lcopy_variant,  /* lcopy_value */
 622     };
 623     info.value_table = &amp;value_table;
 624     type = g_type_register_fundamental (G_TYPE_VARIANT, g_intern_static_string (&quot;GVariant&quot;), &amp;info, &amp;finfo, 0);
 625     g_assert (type == G_TYPE_VARIANT);
 626   }
 627 }
 628 
 629 
 630 /* --- GValue functions --- */
 631 /**
 632  * g_value_set_char:
 633  * @value: a valid #GValue of type %G_TYPE_CHAR
 634  * @v_char: character value to be set
 635  *
 636  * Set the contents of a %G_TYPE_CHAR #GValue to @v_char.
 637  * Deprecated: 2.32: This function&#39;s input type is broken, see g_value_set_schar()
 638  */
 639 void
 640 g_value_set_char (GValue *value,
<span class="line-modified"> 641       gchar   v_char)</span>
 642 {
 643   g_return_if_fail (G_VALUE_HOLDS_CHAR (value));
 644 
 645   value-&gt;data[0].v_int = v_char;
 646 }
 647 
 648 /**
 649  * g_value_get_char:
 650  * @value: a valid #GValue of type %G_TYPE_CHAR
 651  *
 652  * Do not use this function; it is broken on platforms where the %char
 653  * type is unsigned, such as ARM and PowerPC.  See g_value_get_schar().
 654  *
 655  * Get the contents of a %G_TYPE_CHAR #GValue.
 656  *
 657  * Returns: character contents of @value
 658  * Deprecated: 2.32: This function&#39;s return type is broken, see g_value_get_schar()
 659  */
 660 gchar
 661 g_value_get_char (const GValue *value)
 662 {
 663   g_return_val_if_fail (G_VALUE_HOLDS_CHAR (value), 0);
 664 
 665   return value-&gt;data[0].v_int;
 666 }
 667 
 668 /**
 669  * g_value_set_schar:
 670  * @value: a valid #GValue of type %G_TYPE_CHAR
 671  * @v_char: signed 8 bit integer to be set
 672  *
 673  * Set the contents of a %G_TYPE_CHAR #GValue to @v_char.
 674  *
 675  * Since: 2.32
 676  */
 677 void
 678 g_value_set_schar (GValue *value,
<span class="line-modified"> 679        gint8   v_char)</span>
 680 {
 681   g_return_if_fail (G_VALUE_HOLDS_CHAR (value));
 682 
 683   value-&gt;data[0].v_int = v_char;
 684 }
 685 
 686 /**
 687  * g_value_get_schar:
 688  * @value: a valid #GValue of type %G_TYPE_CHAR
 689  *
 690  * Get the contents of a %G_TYPE_CHAR #GValue.
 691  *
 692  * Returns: signed 8 bit integer contents of @value
 693  * Since: 2.32
 694  */
 695 gint8
 696 g_value_get_schar (const GValue *value)
 697 {
 698   g_return_val_if_fail (G_VALUE_HOLDS_CHAR (value), 0);
 699 
 700   return value-&gt;data[0].v_int;
 701 }
 702 
 703 /**
 704  * g_value_set_uchar:
 705  * @value: a valid #GValue of type %G_TYPE_UCHAR
 706  * @v_uchar: unsigned character value to be set
 707  *
 708  * Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.
 709  */
 710 void
 711 g_value_set_uchar (GValue *value,
<span class="line-modified"> 712        guchar  v_uchar)</span>
 713 {
 714   g_return_if_fail (G_VALUE_HOLDS_UCHAR (value));
 715 
 716   value-&gt;data[0].v_uint = v_uchar;
 717 }
 718 
 719 /**
 720  * g_value_get_uchar:
 721  * @value: a valid #GValue of type %G_TYPE_UCHAR
 722  *
 723  * Get the contents of a %G_TYPE_UCHAR #GValue.
 724  *
 725  * Returns: unsigned character contents of @value
 726  */
 727 guchar
 728 g_value_get_uchar (const GValue *value)
 729 {
 730   g_return_val_if_fail (G_VALUE_HOLDS_UCHAR (value), 0);
 731 
 732   return value-&gt;data[0].v_uint;
 733 }
 734 
 735 /**
 736  * g_value_set_boolean:
 737  * @value: a valid #GValue of type %G_TYPE_BOOLEAN
 738  * @v_boolean: boolean value to be set
 739  *
 740  * Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.
 741  */
 742 void
 743 g_value_set_boolean (GValue  *value,
<span class="line-modified"> 744          gboolean v_boolean)</span>
 745 {
 746   g_return_if_fail (G_VALUE_HOLDS_BOOLEAN (value));
 747 
 748   value-&gt;data[0].v_int = v_boolean != FALSE;
 749 }
 750 
 751 /**
 752  * g_value_get_boolean:
 753  * @value: a valid #GValue of type %G_TYPE_BOOLEAN
 754  *
 755  * Get the contents of a %G_TYPE_BOOLEAN #GValue.
 756  *
 757  * Returns: boolean contents of @value
 758  */
 759 gboolean
 760 g_value_get_boolean (const GValue *value)
 761 {
 762   g_return_val_if_fail (G_VALUE_HOLDS_BOOLEAN (value), 0);
 763 
 764   return value-&gt;data[0].v_int;
 765 }
 766 
 767 /**
 768  * g_value_set_int:
 769  * @value: a valid #GValue of type %G_TYPE_INT
 770  * @v_int: integer value to be set
 771  *
 772  * Set the contents of a %G_TYPE_INT #GValue to @v_int.
 773  */
 774 void
 775 g_value_set_int (GValue *value,
<span class="line-modified"> 776      gint  v_int)</span>
 777 {
 778   g_return_if_fail (G_VALUE_HOLDS_INT (value));
 779 
 780   value-&gt;data[0].v_int = v_int;
 781 }
 782 
 783 /**
 784  * g_value_get_int:
 785  * @value: a valid #GValue of type %G_TYPE_INT
 786  *
 787  * Get the contents of a %G_TYPE_INT #GValue.
 788  *
 789  * Returns: integer contents of @value
 790  */
 791 gint
 792 g_value_get_int (const GValue *value)
 793 {
 794   g_return_val_if_fail (G_VALUE_HOLDS_INT (value), 0);
 795 
 796   return value-&gt;data[0].v_int;
 797 }
 798 
 799 /**
 800  * g_value_set_uint:
 801  * @value: a valid #GValue of type %G_TYPE_UINT
 802  * @v_uint: unsigned integer value to be set
 803  *
 804  * Set the contents of a %G_TYPE_UINT #GValue to @v_uint.
 805  */
 806 void
 807 g_value_set_uint (GValue *value,
<span class="line-modified"> 808       guint   v_uint)</span>
 809 {
 810   g_return_if_fail (G_VALUE_HOLDS_UINT (value));
 811 
 812   value-&gt;data[0].v_uint = v_uint;
 813 }
 814 
 815 /**
 816  * g_value_get_uint:
 817  * @value: a valid #GValue of type %G_TYPE_UINT
 818  *
 819  * Get the contents of a %G_TYPE_UINT #GValue.
 820  *
 821  * Returns: unsigned integer contents of @value
 822  */
 823 guint
 824 g_value_get_uint (const GValue *value)
 825 {
 826   g_return_val_if_fail (G_VALUE_HOLDS_UINT (value), 0);
 827 
 828   return value-&gt;data[0].v_uint;
 829 }
 830 
 831 /**
 832  * g_value_set_long:
 833  * @value: a valid #GValue of type %G_TYPE_LONG
 834  * @v_long: long integer value to be set
 835  *
 836  * Set the contents of a %G_TYPE_LONG #GValue to @v_long.
 837  */
 838 void
 839 g_value_set_long (GValue *value,
<span class="line-modified"> 840       glong   v_long)</span>
 841 {
 842   g_return_if_fail (G_VALUE_HOLDS_LONG (value));
 843 
 844   value-&gt;data[0].v_long = v_long;
 845 }
 846 
 847 /**
 848  * g_value_get_long:
 849  * @value: a valid #GValue of type %G_TYPE_LONG
 850  *
 851  * Get the contents of a %G_TYPE_LONG #GValue.
 852  *
 853  * Returns: long integer contents of @value
 854  */
 855 glong
 856 g_value_get_long (const GValue *value)
 857 {
 858   g_return_val_if_fail (G_VALUE_HOLDS_LONG (value), 0);
 859 
 860   return value-&gt;data[0].v_long;
 861 }
 862 
 863 /**
 864  * g_value_set_ulong:
 865  * @value: a valid #GValue of type %G_TYPE_ULONG
 866  * @v_ulong: unsigned long integer value to be set
 867  *
 868  * Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.
 869  */
 870 void
 871 g_value_set_ulong (GValue *value,
<span class="line-modified"> 872        gulong  v_ulong)</span>
 873 {
 874   g_return_if_fail (G_VALUE_HOLDS_ULONG (value));
 875 
 876   value-&gt;data[0].v_ulong = v_ulong;
 877 }
 878 
 879 /**
 880  * g_value_get_ulong:
 881  * @value: a valid #GValue of type %G_TYPE_ULONG
 882  *
 883  * Get the contents of a %G_TYPE_ULONG #GValue.
 884  *
 885  * Returns: unsigned long integer contents of @value
 886  */
 887 gulong
 888 g_value_get_ulong (const GValue *value)
 889 {
 890   g_return_val_if_fail (G_VALUE_HOLDS_ULONG (value), 0);
 891 
 892   return value-&gt;data[0].v_ulong;
 893 }
 894 
 895 /**
 896  * g_value_get_int64:
 897  * @value: a valid #GValue of type %G_TYPE_INT64
 898  *
 899  * Get the contents of a %G_TYPE_INT64 #GValue.
 900  *
 901  * Returns: 64bit integer contents of @value
 902  */
 903 void
 904 g_value_set_int64 (GValue *value,
<span class="line-modified"> 905        gint64  v_int64)</span>
 906 {
 907   g_return_if_fail (G_VALUE_HOLDS_INT64 (value));
 908 
 909   value-&gt;data[0].v_int64 = v_int64;
 910 }
 911 
 912 /**
 913  * g_value_set_int64:
 914  * @value: a valid #GValue of type %G_TYPE_INT64
 915  * @v_int64: 64bit integer value to be set
 916  *
 917  * Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.
 918  */
 919 gint64
 920 g_value_get_int64 (const GValue *value)
 921 {
 922   g_return_val_if_fail (G_VALUE_HOLDS_INT64 (value), 0);
 923 
 924   return value-&gt;data[0].v_int64;
 925 }
 926 
 927 /**
 928  * g_value_set_uint64:
 929  * @value: a valid #GValue of type %G_TYPE_UINT64
 930  * @v_uint64: unsigned 64bit integer value to be set
 931  *
 932  * Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.
 933  */
 934 void
 935 g_value_set_uint64 (GValue *value,
<span class="line-modified"> 936         guint64 v_uint64)</span>
 937 {
 938   g_return_if_fail (G_VALUE_HOLDS_UINT64 (value));
 939 
 940   value-&gt;data[0].v_uint64 = v_uint64;
 941 }
 942 
 943 /**
 944  * g_value_get_uint64:
 945  * @value: a valid #GValue of type %G_TYPE_UINT64
 946  *
 947  * Get the contents of a %G_TYPE_UINT64 #GValue.
 948  *
 949  * Returns: unsigned 64bit integer contents of @value
 950  */
 951 guint64
 952 g_value_get_uint64 (const GValue *value)
 953 {
 954   g_return_val_if_fail (G_VALUE_HOLDS_UINT64 (value), 0);
 955 
 956   return value-&gt;data[0].v_uint64;
 957 }
 958 
 959 /**
 960  * g_value_set_float:
 961  * @value: a valid #GValue of type %G_TYPE_FLOAT
 962  * @v_float: float value to be set
 963  *
 964  * Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.
 965  */
 966 void
 967 g_value_set_float (GValue *value,
<span class="line-modified"> 968        gfloat  v_float)</span>
 969 {
 970   g_return_if_fail (G_VALUE_HOLDS_FLOAT (value));
 971 
 972   value-&gt;data[0].v_float = v_float;
 973 }
 974 
 975 /**
 976  * g_value_get_float:
 977  * @value: a valid #GValue of type %G_TYPE_FLOAT
 978  *
 979  * Get the contents of a %G_TYPE_FLOAT #GValue.
 980  *
 981  * Returns: float contents of @value
 982  */
 983 gfloat
 984 g_value_get_float (const GValue *value)
 985 {
 986   g_return_val_if_fail (G_VALUE_HOLDS_FLOAT (value), 0);
 987 
 988   return value-&gt;data[0].v_float;
 989 }
 990 
 991 /**
 992  * g_value_set_double:
 993  * @value: a valid #GValue of type %G_TYPE_DOUBLE
 994  * @v_double: double value to be set
 995  *
 996  * Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.
 997  */
 998 void
 999 g_value_set_double (GValue *value,
<span class="line-modified">1000         gdouble v_double)</span>
1001 {
1002   g_return_if_fail (G_VALUE_HOLDS_DOUBLE (value));
1003 
1004   value-&gt;data[0].v_double = v_double;
1005 }
1006 
1007 /**
1008  * g_value_get_double:
1009  * @value: a valid #GValue of type %G_TYPE_DOUBLE
1010  *
1011  * Get the contents of a %G_TYPE_DOUBLE #GValue.
1012  *
1013  * Returns: double contents of @value
1014  */
1015 gdouble
1016 g_value_get_double (const GValue *value)
1017 {
1018   g_return_val_if_fail (G_VALUE_HOLDS_DOUBLE (value), 0);
1019 
1020   return value-&gt;data[0].v_double;
1021 }
1022 
1023 /**
1024  * g_value_set_string:
1025  * @value: a valid #GValue of type %G_TYPE_STRING
1026  * @v_string: (nullable): caller-owned string to be duplicated for the #GValue
1027  *
1028  * Set the contents of a %G_TYPE_STRING #GValue to @v_string.
1029  */
1030 void
1031 g_value_set_string (GValue  *value,
<span class="line-modified">1032         const gchar *v_string)</span>
1033 {
1034   gchar *new_val;
1035 
1036   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1037 
1038   new_val = g_strdup (v_string);
1039 
1040   if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
1041     value-&gt;data[1].v_uint = 0;
1042   else
1043     g_free (value-&gt;data[0].v_pointer);
1044 
1045   value-&gt;data[0].v_pointer = new_val;
1046 }
1047 
1048 /**
1049  * g_value_set_static_string:
1050  * @value: a valid #GValue of type %G_TYPE_STRING
1051  * @v_string: (nullable): static string to be set
1052  *
1053  * Set the contents of a %G_TYPE_STRING #GValue to @v_string.
1054  * The string is assumed to be static, and is thus not duplicated
1055  * when setting the #GValue.
1056  */
1057 void
1058 g_value_set_static_string (GValue      *value,
<span class="line-modified">1059          const gchar *v_string)</span>
1060 {
1061   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1062 
1063   if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
1064     g_free (value-&gt;data[0].v_pointer);
1065   value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
1066   value-&gt;data[0].v_pointer = (gchar*) v_string;
1067 }
1068 
1069 /**
1070  * g_value_set_string_take_ownership:
1071  * @value: a valid #GValue of type %G_TYPE_STRING
1072  * @v_string: (nullable): duplicated unowned string to be set
1073  *
1074  * This is an internal function introduced mainly for C marshallers.
1075  *
1076  * Deprecated: 2.4: Use g_value_take_string() instead.
1077  */
1078 void
1079 g_value_set_string_take_ownership (GValue *value,
<span class="line-modified">1080            gchar  *v_string)</span>
1081 {
1082   g_value_take_string (value, v_string);
1083 }
1084 
1085 /**
1086  * g_value_take_string:
1087  * @value: a valid #GValue of type %G_TYPE_STRING
1088  * @v_string: (nullable): string to take ownership of
1089  *
1090  * Sets the contents of a %G_TYPE_STRING #GValue to @v_string.
1091  *
1092  * Since: 2.4
1093  */
1094 void
1095 g_value_take_string (GValue *value,
<span class="line-modified">1096          gchar  *v_string)</span>
1097 {
1098   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
1099 
1100   if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
1101     value-&gt;data[1].v_uint = 0;
1102   else
1103     g_free (value-&gt;data[0].v_pointer);
1104   value-&gt;data[0].v_pointer = v_string;
1105 }
1106 
1107 /**
1108  * g_value_get_string:
1109  * @value: a valid #GValue of type %G_TYPE_STRING
1110  *
1111  * Get the contents of a %G_TYPE_STRING #GValue.
1112  *
1113  * Returns: string content of @value
1114  */
1115 const gchar*
1116 g_value_get_string (const GValue *value)
</pre>
<hr />
<pre>
1128  *
1129  * Returns: a newly allocated copy of the string content of @value
1130  */
1131 gchar*
1132 g_value_dup_string (const GValue *value)
1133 {
1134   g_return_val_if_fail (G_VALUE_HOLDS_STRING (value), NULL);
1135 
1136   return g_strdup (value-&gt;data[0].v_pointer);
1137 }
1138 
1139 /**
1140  * g_value_set_pointer:
1141  * @value: a valid #GValue of %G_TYPE_POINTER
1142  * @v_pointer: pointer value to be set
1143  *
1144  * Set the contents of a pointer #GValue to @v_pointer.
1145  */
1146 void
1147 g_value_set_pointer (GValue  *value,
<span class="line-modified">1148          gpointer v_pointer)</span>
1149 {
1150   g_return_if_fail (G_VALUE_HOLDS_POINTER (value));
1151 
1152   value-&gt;data[0].v_pointer = v_pointer;
1153 }
1154 
1155 /**
1156  * g_value_get_pointer:
1157  * @value: a valid #GValue of %G_TYPE_POINTER
1158  *
1159  * Get the contents of a pointer #GValue.
1160  *
1161  * Returns: (transfer none): pointer contents of @value
1162  */
1163 gpointer
1164 g_value_get_pointer (const GValue *value)
1165 {
1166   g_return_val_if_fail (G_VALUE_HOLDS_POINTER (value), NULL);
1167 
1168   return value-&gt;data[0].v_pointer;
1169 }
1170 
1171 G_DEFINE_POINTER_TYPE (GType, g_gtype)
1172 
1173 /**
1174  * g_value_set_gtype:
1175  * @value: a valid #GValue of type %G_TYPE_GTYPE
1176  * @v_gtype: #GType to be set
1177  *
1178  * Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.
1179  *
1180  * Since: 2.12
1181  */
1182 void
1183 g_value_set_gtype (GValue *value,
<span class="line-modified">1184        GType   v_gtype)</span>
1185 {
1186   g_return_if_fail (G_VALUE_HOLDS_GTYPE (value));
1187 
1188   value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (v_gtype);
1189 
1190 }
1191 
1192 /**
1193  * g_value_get_gtype:
1194  * @value: a valid #GValue of type %G_TYPE_GTYPE
1195  *
1196  * Get the contents of a %G_TYPE_GTYPE #GValue.
1197  *
1198  * Since: 2.12
1199  *
1200  * Returns: the #GType stored in @value
1201  */
1202 GType
1203 g_value_get_gtype (const GValue *value)
1204 {
</pre>
<hr />
<pre>
1326  * Return a newly allocated string, which describes the contents of a
1327  * #GValue.  The main purpose of this function is to describe #GValue
1328  * contents for debugging output, the way in which the contents are
1329  * described may change between different GLib versions.
1330  *
1331  * Returns: Newly allocated string.
1332  */
1333 gchar*
1334 g_strdup_value_contents (const GValue *value)
1335 {
1336   const gchar *src;
1337   gchar *contents;
1338 
1339   g_return_val_if_fail (G_IS_VALUE (value), NULL);
1340 
1341   if (G_VALUE_HOLDS_STRING (value))
1342     {
1343       src = g_value_get_string (value);
1344 
1345       if (!src)
<span class="line-modified">1346   contents = g_strdup (&quot;NULL&quot;);</span>
1347       else
<span class="line-modified">1348   {</span>
<span class="line-modified">1349     gchar *s = g_strescape (src, NULL);</span>
1350 
<span class="line-modified">1351     contents = g_strdup_printf (&quot;\&quot;%s\&quot;&quot;, s);</span>
<span class="line-modified">1352     g_free (s);</span>
<span class="line-modified">1353   }</span>
1354     }
1355   else if (g_value_type_transformable (G_VALUE_TYPE (value), G_TYPE_STRING))
1356     {
1357       GValue tmp_value = G_VALUE_INIT;
1358       gchar *s;
1359 
1360       g_value_init (&amp;tmp_value, G_TYPE_STRING);
1361       g_value_transform (value, &amp;tmp_value);
1362       s = g_strescape (g_value_get_string (&amp;tmp_value), NULL);
1363       g_value_unset (&amp;tmp_value);
1364       if (G_VALUE_HOLDS_ENUM (value) || G_VALUE_HOLDS_FLAGS (value))
<span class="line-modified">1365   contents = g_strdup_printf (&quot;((%s) %s)&quot;,</span>
<span class="line-modified">1366             g_type_name (G_VALUE_TYPE (value)),</span>
<span class="line-modified">1367             s);</span>
1368       else
<span class="line-modified">1369   contents = g_strdup (s ? s : &quot;NULL&quot;);</span>
1370       g_free (s);
1371     }
1372   else if (g_value_fits_pointer (value))
1373     {
1374       gpointer p = g_value_peek_pointer (value);
1375 
1376       if (!p)
<span class="line-modified">1377   contents = g_strdup (&quot;NULL&quot;);</span>
1378       else if (G_VALUE_HOLDS_OBJECT (value))
<span class="line-modified">1379   contents = g_strdup_printf (&quot;((%s*) %p)&quot;, G_OBJECT_TYPE_NAME (p), p);</span>
1380       else if (G_VALUE_HOLDS_PARAM (value))
<span class="line-modified">1381   contents = g_strdup_printf (&quot;((%s*) %p)&quot;, G_PARAM_SPEC_TYPE_NAME (p), p);</span>
1382       else if (G_VALUE_HOLDS (value, G_TYPE_STRV))
1383         {
1384           GStrv strv = g_value_get_boxed (value);
1385           GString *tmp = g_string_new (&quot;[&quot;);
1386 
1387           while (*strv != NULL)
1388             {
1389               gchar *escaped = g_strescape (*strv, NULL);
1390 
1391               g_string_append_printf (tmp, &quot;\&quot;%s\&quot;&quot;, escaped);
1392               g_free (escaped);
1393 
1394               if (*++strv != NULL)
1395                 g_string_append (tmp, &quot;, &quot;);
1396             }
1397 
1398           g_string_append (tmp, &quot;]&quot;);
1399           contents = g_string_free (tmp, FALSE);
1400         }
1401       else if (G_VALUE_HOLDS_BOXED (value))
<span class="line-modified">1402   contents = g_strdup_printf (&quot;((%s*) %p)&quot;, g_type_name (G_VALUE_TYPE (value)), p);</span>
1403       else if (G_VALUE_HOLDS_POINTER (value))
<span class="line-modified">1404   contents = g_strdup_printf (&quot;((gpointer) %p)&quot;, p);</span>
1405       else
<span class="line-modified">1406   contents = g_strdup (&quot;???&quot;);</span>
1407     }
1408   else
1409     contents = g_strdup (&quot;???&quot;);
1410 
1411   return contents;
1412 }
1413 
1414 /**
1415  * g_pointer_type_register_static:
1416  * @name: the name of the new pointer type.
1417  *
1418  * Creates a new %G_TYPE_POINTER derived type id for a new
1419  * pointer type with name @name.
1420  *
1421  * Returns: a new %G_TYPE_POINTER derived type id for @name.
1422  */
1423 GType
1424 g_pointer_type_register_static (const gchar *name)
1425 {
1426   const GTypeInfo type_info = {
<span class="line-modified">1427     0,      /* class_size */</span>
<span class="line-modified">1428     NULL,   /* base_init */</span>
<span class="line-modified">1429     NULL,   /* base_finalize */</span>
<span class="line-modified">1430     NULL,   /* class_init */</span>
<span class="line-modified">1431     NULL,   /* class_finalize */</span>
<span class="line-modified">1432     NULL,   /* class_data */</span>
<span class="line-modified">1433     0,      /* instance_size */</span>
<span class="line-modified">1434     0,      /* n_preallocs */</span>
<span class="line-modified">1435     NULL,   /* instance_init */</span>
<span class="line-modified">1436     NULL    /* value_table */</span>
1437   };
1438   GType type;
1439 
1440   g_return_val_if_fail (name != NULL, 0);
1441   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
1442 
1443   type = g_type_register_static (G_TYPE_POINTER, name, &amp;type_info, 0);
1444 
1445   return type;
1446 }
</pre>
</td>
</tr>
</table>
<center><a href="gvaluetransform.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluetypes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>