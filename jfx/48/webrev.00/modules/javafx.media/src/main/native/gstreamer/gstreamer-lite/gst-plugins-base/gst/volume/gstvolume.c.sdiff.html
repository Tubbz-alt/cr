<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/volume/gstvolume.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../typefind/gsttypefindfunctions.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../win32/common/config.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/volume/gstvolume.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
166 
167 
168 /* helper functions */
169 
170 static gboolean
171 volume_choose_func (GstVolume * self, const GstAudioInfo * info)
172 {
173   GstAudioFormat format;
174 
175   self-&gt;process = NULL;
176   self-&gt;process_controlled = NULL;
177 
178   format = GST_AUDIO_INFO_FORMAT (info);
179 
180   if (format == GST_AUDIO_FORMAT_UNKNOWN)
181     return FALSE;
182 
183   switch (format) {
184     case GST_AUDIO_FORMAT_S32:
185       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">186           if (self-&gt;current_vol_i32 &gt; VOLUME_UNITY_INT32) {</span>
<span class="line-modified">187             self-&gt;process = volume_process_int32_clamp;</span>
<span class="line-modified">188           } else {</span>
<span class="line-modified">189             self-&gt;process = volume_process_int32;</span>
<span class="line-modified">190           }</span>
<span class="line-modified">191           self-&gt;process_controlled = volume_process_controlled_int32_clamp;</span>
<span class="line-modified">192           break;</span>
193     case GST_AUDIO_FORMAT_S24:
194       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">195           if (self-&gt;current_vol_i24 &gt; VOLUME_UNITY_INT24) {</span>
<span class="line-modified">196             self-&gt;process = volume_process_int24_clamp;</span>
<span class="line-modified">197           } else {</span>
<span class="line-modified">198             self-&gt;process = volume_process_int24;</span>
<span class="line-modified">199           }</span>
<span class="line-modified">200           self-&gt;process_controlled = volume_process_controlled_int24_clamp;</span>
<span class="line-modified">201           break;</span>
202     case GST_AUDIO_FORMAT_S16:
203       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">204           if (self-&gt;current_vol_i16 &gt; VOLUME_UNITY_INT16) {</span>
<span class="line-modified">205             self-&gt;process = volume_process_int16_clamp;</span>
<span class="line-modified">206           } else {</span>
<span class="line-modified">207             self-&gt;process = volume_process_int16;</span>
<span class="line-modified">208           }</span>
<span class="line-modified">209           self-&gt;process_controlled = volume_process_controlled_int16_clamp;</span>
<span class="line-modified">210           break;</span>
211     case GST_AUDIO_FORMAT_S8:
212       /* only clamp if the gain is greater than 1.0 */
213       if (self-&gt;current_vol_i8 &gt; VOLUME_UNITY_INT8) {
<span class="line-modified">214             self-&gt;process = volume_process_int8_clamp;</span>
<span class="line-modified">215           } else {</span>
<span class="line-modified">216             self-&gt;process = volume_process_int8;</span>
<span class="line-modified">217           }</span>
<span class="line-modified">218           self-&gt;process_controlled = volume_process_controlled_int8_clamp;</span>
<span class="line-modified">219           break;</span>
220     case GST_AUDIO_FORMAT_F32:
<span class="line-modified">221           self-&gt;process = volume_process_float;</span>
<span class="line-modified">222           self-&gt;process_controlled = volume_process_controlled_float;</span>
<span class="line-modified">223           break;</span>
224     case GST_AUDIO_FORMAT_F64:
<span class="line-modified">225           self-&gt;process = volume_process_double;</span>
<span class="line-modified">226           self-&gt;process_controlled = volume_process_controlled_double;</span>
<span class="line-modified">227           break;</span>
228     default:
229       break;
230   }
231 
232   return (self-&gt;process != NULL);
233 }
234 
235 static gboolean
236 volume_update_volume (GstVolume * self, const GstAudioInfo * info,
237     gdouble volume, gboolean mute)
238 {
239   gboolean passthrough;
240   gboolean res;
241 
242   GST_DEBUG_OBJECT (self, &quot;configure mute %d, volume %f&quot;, mute, volume);
243 
244   if (mute) {
245     self-&gt;current_mute = TRUE;
246     self-&gt;current_volume = 0.0;
247 
</pre>
<hr />
<pre>
734 
735   /* don&#39;t process data with GAP */
736   if (GST_BUFFER_FLAG_IS_SET (outbuf, GST_BUFFER_FLAG_GAP))
737     return GST_FLOW_OK;
738 
739   gst_buffer_map (outbuf, &amp;map, GST_MAP_READWRITE);
740   ts = GST_BUFFER_TIMESTAMP (outbuf);
741   ts = gst_segment_to_stream_time (&amp;base-&gt;segment, GST_FORMAT_TIME, ts);
742 
743   if (GST_CLOCK_TIME_IS_VALID (ts)) {
744     GstControlBinding *mute_cb, *volume_cb;
745 
746     mute_cb = gst_object_get_control_binding (GST_OBJECT (self), &quot;mute&quot;);
747     volume_cb = gst_object_get_control_binding (GST_OBJECT (self), &quot;volume&quot;);
748 
749     if (mute_cb || (volume_cb &amp;&amp; !self-&gt;current_mute)) {
750       gint rate = GST_AUDIO_INFO_RATE (&amp;filter-&gt;info);
751       gint width = GST_AUDIO_FORMAT_INFO_WIDTH (filter-&gt;info.finfo) / 8;
752       gint channels = GST_AUDIO_INFO_CHANNELS (&amp;filter-&gt;info);
753       guint nsamples = map.size / (width * channels);
<span class="line-modified">754     GstClockTime interval = gst_util_uint64_scale_int (1, GST_SECOND, rate);</span>
755       gboolean have_mutes = FALSE;
756       gboolean have_volumes = FALSE;
757 
758       if (self-&gt;mutes_count &lt; nsamples &amp;&amp; mute_cb) {
<span class="line-modified">759       self-&gt;mutes = g_realloc (self-&gt;mutes, sizeof (gboolean) * nsamples);</span>
<span class="line-modified">760       self-&gt;mutes_count = nsamples;</span>
<span class="line-modified">761     }</span>
762 
<span class="line-modified">763     if (self-&gt;volumes_count &lt; nsamples) {</span>
<span class="line-modified">764       self-&gt;volumes = g_realloc (self-&gt;volumes, sizeof (gdouble) * nsamples);</span>
<span class="line-modified">765       self-&gt;volumes_count = nsamples;</span>
<span class="line-modified">766     }</span>
767 
768       if (volume_cb &amp;&amp; self-&gt;volumes) {
769         have_volumes =
770             gst_control_binding_get_value_array (volume_cb, ts, interval,
771             nsamples, (gpointer) self-&gt;volumes);
772         gst_object_replace ((GstObject **) &amp; volume_cb, NULL);
773       }
774       if (!have_volumes) {
775         volume_orc_memset_f64 (self-&gt;volumes, self-&gt;current_volume, nsamples);
776       }
777 
778       if (mute_cb &amp;&amp; self-&gt;mutes) {
779         have_mutes = gst_control_binding_get_value_array (mute_cb, ts, interval,
780             nsamples, (gpointer) self-&gt;mutes);
781         gst_object_replace ((GstObject **) &amp; mute_cb, NULL);
782       }
783       if (have_mutes) {
784         volume_orc_prepare_volumes (self-&gt;volumes, self-&gt;mutes, nsamples);
<span class="line-modified">785     } else {</span>
<span class="line-modified">786       g_free (self-&gt;mutes);</span>
<span class="line-modified">787       self-&gt;mutes = NULL;</span>
<span class="line-modified">788       self-&gt;mutes_count = 0;</span>
<span class="line-modified">789     }</span>
790 
791       self-&gt;process_controlled (self, map.data, self-&gt;volumes, channels,
792           map.size);
793 
794       goto done;
795     } else if (volume_cb) {
796       gst_object_unref (volume_cb);
797     }
<span class="line-modified">798     }</span>
799 
800   if (self-&gt;current_volume == 0.0 || self-&gt;current_mute) {
801     orc_memset (map.data, 0, map.size);
802     GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_GAP);
803   } else if (self-&gt;current_volume != 1.0) {
804     self-&gt;process (self, map.data, map.size);
805   }
806 
807 done:
808   gst_buffer_unmap (outbuf, &amp;map);
809 
810   return GST_FLOW_OK;
811 
812   /* ERRORS */
813 not_negotiated:
814   {
815     GST_ELEMENT_ERROR (self, CORE, NEGOTIATION,
816         (&quot;No format was negotiated&quot;), (NULL));
817     return GST_FLOW_NOT_NEGOTIATED;
818   }
</pre>
</td>
<td>
<hr />
<pre>
166 
167 
168 /* helper functions */
169 
170 static gboolean
171 volume_choose_func (GstVolume * self, const GstAudioInfo * info)
172 {
173   GstAudioFormat format;
174 
175   self-&gt;process = NULL;
176   self-&gt;process_controlled = NULL;
177 
178   format = GST_AUDIO_INFO_FORMAT (info);
179 
180   if (format == GST_AUDIO_FORMAT_UNKNOWN)
181     return FALSE;
182 
183   switch (format) {
184     case GST_AUDIO_FORMAT_S32:
185       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">186       if (self-&gt;current_vol_i32 &gt; VOLUME_UNITY_INT32) {</span>
<span class="line-modified">187         self-&gt;process = volume_process_int32_clamp;</span>
<span class="line-modified">188       } else {</span>
<span class="line-modified">189         self-&gt;process = volume_process_int32;</span>
<span class="line-modified">190       }</span>
<span class="line-modified">191       self-&gt;process_controlled = volume_process_controlled_int32_clamp;</span>
<span class="line-modified">192       break;</span>
193     case GST_AUDIO_FORMAT_S24:
194       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">195       if (self-&gt;current_vol_i24 &gt; VOLUME_UNITY_INT24) {</span>
<span class="line-modified">196         self-&gt;process = volume_process_int24_clamp;</span>
<span class="line-modified">197       } else {</span>
<span class="line-modified">198         self-&gt;process = volume_process_int24;</span>
<span class="line-modified">199       }</span>
<span class="line-modified">200       self-&gt;process_controlled = volume_process_controlled_int24_clamp;</span>
<span class="line-modified">201       break;</span>
202     case GST_AUDIO_FORMAT_S16:
203       /* only clamp if the gain is greater than 1.0 */
<span class="line-modified">204       if (self-&gt;current_vol_i16 &gt; VOLUME_UNITY_INT16) {</span>
<span class="line-modified">205         self-&gt;process = volume_process_int16_clamp;</span>
<span class="line-modified">206       } else {</span>
<span class="line-modified">207         self-&gt;process = volume_process_int16;</span>
<span class="line-modified">208       }</span>
<span class="line-modified">209       self-&gt;process_controlled = volume_process_controlled_int16_clamp;</span>
<span class="line-modified">210       break;</span>
211     case GST_AUDIO_FORMAT_S8:
212       /* only clamp if the gain is greater than 1.0 */
213       if (self-&gt;current_vol_i8 &gt; VOLUME_UNITY_INT8) {
<span class="line-modified">214         self-&gt;process = volume_process_int8_clamp;</span>
<span class="line-modified">215       } else {</span>
<span class="line-modified">216         self-&gt;process = volume_process_int8;</span>
<span class="line-modified">217       }</span>
<span class="line-modified">218       self-&gt;process_controlled = volume_process_controlled_int8_clamp;</span>
<span class="line-modified">219       break;</span>
220     case GST_AUDIO_FORMAT_F32:
<span class="line-modified">221       self-&gt;process = volume_process_float;</span>
<span class="line-modified">222       self-&gt;process_controlled = volume_process_controlled_float;</span>
<span class="line-modified">223       break;</span>
224     case GST_AUDIO_FORMAT_F64:
<span class="line-modified">225       self-&gt;process = volume_process_double;</span>
<span class="line-modified">226       self-&gt;process_controlled = volume_process_controlled_double;</span>
<span class="line-modified">227       break;</span>
228     default:
229       break;
230   }
231 
232   return (self-&gt;process != NULL);
233 }
234 
235 static gboolean
236 volume_update_volume (GstVolume * self, const GstAudioInfo * info,
237     gdouble volume, gboolean mute)
238 {
239   gboolean passthrough;
240   gboolean res;
241 
242   GST_DEBUG_OBJECT (self, &quot;configure mute %d, volume %f&quot;, mute, volume);
243 
244   if (mute) {
245     self-&gt;current_mute = TRUE;
246     self-&gt;current_volume = 0.0;
247 
</pre>
<hr />
<pre>
734 
735   /* don&#39;t process data with GAP */
736   if (GST_BUFFER_FLAG_IS_SET (outbuf, GST_BUFFER_FLAG_GAP))
737     return GST_FLOW_OK;
738 
739   gst_buffer_map (outbuf, &amp;map, GST_MAP_READWRITE);
740   ts = GST_BUFFER_TIMESTAMP (outbuf);
741   ts = gst_segment_to_stream_time (&amp;base-&gt;segment, GST_FORMAT_TIME, ts);
742 
743   if (GST_CLOCK_TIME_IS_VALID (ts)) {
744     GstControlBinding *mute_cb, *volume_cb;
745 
746     mute_cb = gst_object_get_control_binding (GST_OBJECT (self), &quot;mute&quot;);
747     volume_cb = gst_object_get_control_binding (GST_OBJECT (self), &quot;volume&quot;);
748 
749     if (mute_cb || (volume_cb &amp;&amp; !self-&gt;current_mute)) {
750       gint rate = GST_AUDIO_INFO_RATE (&amp;filter-&gt;info);
751       gint width = GST_AUDIO_FORMAT_INFO_WIDTH (filter-&gt;info.finfo) / 8;
752       gint channels = GST_AUDIO_INFO_CHANNELS (&amp;filter-&gt;info);
753       guint nsamples = map.size / (width * channels);
<span class="line-modified">754       GstClockTime interval = gst_util_uint64_scale_int (1, GST_SECOND, rate);</span>
755       gboolean have_mutes = FALSE;
756       gboolean have_volumes = FALSE;
757 
758       if (self-&gt;mutes_count &lt; nsamples &amp;&amp; mute_cb) {
<span class="line-modified">759         self-&gt;mutes = g_realloc (self-&gt;mutes, sizeof (gboolean) * nsamples);</span>
<span class="line-modified">760         self-&gt;mutes_count = nsamples;</span>
<span class="line-modified">761       }</span>
762 
<span class="line-modified">763       if (self-&gt;volumes_count &lt; nsamples) {</span>
<span class="line-modified">764         self-&gt;volumes = g_realloc (self-&gt;volumes, sizeof (gdouble) * nsamples);</span>
<span class="line-modified">765         self-&gt;volumes_count = nsamples;</span>
<span class="line-modified">766       }</span>
767 
768       if (volume_cb &amp;&amp; self-&gt;volumes) {
769         have_volumes =
770             gst_control_binding_get_value_array (volume_cb, ts, interval,
771             nsamples, (gpointer) self-&gt;volumes);
772         gst_object_replace ((GstObject **) &amp; volume_cb, NULL);
773       }
774       if (!have_volumes) {
775         volume_orc_memset_f64 (self-&gt;volumes, self-&gt;current_volume, nsamples);
776       }
777 
778       if (mute_cb &amp;&amp; self-&gt;mutes) {
779         have_mutes = gst_control_binding_get_value_array (mute_cb, ts, interval,
780             nsamples, (gpointer) self-&gt;mutes);
781         gst_object_replace ((GstObject **) &amp; mute_cb, NULL);
782       }
783       if (have_mutes) {
784         volume_orc_prepare_volumes (self-&gt;volumes, self-&gt;mutes, nsamples);
<span class="line-modified">785       } else {</span>
<span class="line-modified">786         g_free (self-&gt;mutes);</span>
<span class="line-modified">787         self-&gt;mutes = NULL;</span>
<span class="line-modified">788         self-&gt;mutes_count = 0;</span>
<span class="line-modified">789       }</span>
790 
791       self-&gt;process_controlled (self, map.data, self-&gt;volumes, channels,
792           map.size);
793 
794       goto done;
795     } else if (volume_cb) {
796       gst_object_unref (volume_cb);
797     }
<span class="line-modified">798   }</span>
799 
800   if (self-&gt;current_volume == 0.0 || self-&gt;current_mute) {
801     orc_memset (map.data, 0, map.size);
802     GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_GAP);
803   } else if (self-&gt;current_volume != 1.0) {
804     self-&gt;process (self, map.data, map.size);
805   }
806 
807 done:
808   gst_buffer_unmap (outbuf, &amp;map);
809 
810   return GST_FLOW_OK;
811 
812   /* ERRORS */
813 not_negotiated:
814   {
815     GST_ELEMENT_ERROR (self, CORE, NEGOTIATION,
816         (&quot;No format was negotiated&quot;), (NULL));
817     return GST_FLOW_NOT_NEGOTIATED;
818   }
</pre>
</td>
</tr>
</table>
<center><a href="../typefind/gsttypefindfunctions.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../win32/common/config.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>