<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gspawn-win32.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -450,12 +450,12 @@</span>
  
        if (ret &lt; 0)
          {
            int errsv = errno;
  
<span class="udiff-line-modified-removed">-       if (errno == EINTR)</span>
<span class="udiff-line-modified-removed">-         continue;</span>
<span class="udiff-line-modified-added">+     if (errno == EINTR)</span>
<span class="udiff-line-modified-added">+       continue;</span>
  
            failed = TRUE;
  
            g_set_error (error,
                         G_SPAWN_ERROR,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -631,11 +631,11 @@</span>
   * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
   * eventually calls) paste the argument vector elements together into
   * a command line, and the C runtime startup code does a corresponding
   * reconstruction of an argument vector from the command line, to be
   * passed to main(). Complications arise when you have argument vector
<span class="udiff-line-modified-removed">-  * elements that contain spaces of double quotes. The spawn*() functions</span>
<span class="udiff-line-modified-added">+  * elements that contain spaces or double quotes. The `spawn*()` functions</span>
   * don&#39;t do any quoting or escaping, but on the other hand the startup
   * code does do unquoting and unescaping in order to enable receiving
   * arguments with embedded spaces or double quotes. To work around this
   * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
   * argument vector elements that need it before calling the C runtime
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1042,42 +1042,42 @@</span>
   *
   * Since: 2.34
   */
  gboolean
  g_spawn_check_exit_status (gint      exit_status,
<span class="udiff-line-modified-removed">-                GError  **error)</span>
<span class="udiff-line-modified-added">+          GError  **error)</span>
  {
    gboolean ret = FALSE;
  
    if (WIFEXITED (exit_status))
      {
        if (WEXITSTATUS (exit_status) != 0)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="udiff-line-modified-removed">-                _(&quot;Child process exited with code %ld&quot;),</span>
<span class="udiff-line-modified-removed">-                (long) WEXITSTATUS (exit_status));</span>
<span class="udiff-line-modified-removed">-       goto out;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="udiff-line-modified-added">+            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="udiff-line-modified-added">+            (long) WEXITSTATUS (exit_status));</span>
<span class="udiff-line-modified-added">+     goto out;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else if (WIFSIGNALED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="udiff-line-modified-removed">-            _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="udiff-line-modified-removed">-            (long) WTERMSIG (exit_status));</span>
<span class="udiff-line-modified-added">+        _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="udiff-line-modified-added">+        (long) WTERMSIG (exit_status));</span>
        goto out;
      }
    else if (WIFSTOPPED (exit_status))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="udiff-line-modified-removed">-            _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="udiff-line-modified-removed">-            (long) WSTOPSIG (exit_status));</span>
<span class="udiff-line-modified-added">+        _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="udiff-line-modified-added">+        (long) WSTOPSIG (exit_status));</span>
        goto out;
      }
    else
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="udiff-line-modified-removed">-            _(&quot;Child process exited abnormally&quot;));</span>
<span class="udiff-line-modified-added">+        _(&quot;Child process exited abnormally&quot;));</span>
        goto out;
      }
  
    ret = TRUE;
   out:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,20 +1193,20 @@</span>
              {
                de = (struct linux_dirent64 *)(buf + pos);
  
                fd = filename_to_fd (de-&gt;d_name);
                if (fd &lt; 0 || fd == dir_fd)
<span class="udiff-line-modified-removed">-               continue;</span>
<span class="udiff-line-modified-added">+                   continue;</span>
  
<span class="udiff-line-modified-removed">-           if ((res = cb (data, fd)) != 0)</span>
<span class="udiff-line-modified-removed">-               break;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+               if ((res = cb (data, fd)) != 0)</span>
<span class="udiff-line-modified-added">+                   break;</span>
<span class="udiff-line-modified-added">+             }</span>
          }
  
        close (dir_fd);
        return res;
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+     }</span>
  
    /* If /proc is not mounted or not accessible we fall back to the old
     * rlimit trick */
  
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1408,11 +1408,11 @@</span>
            return FALSE;
          }
        else if (chunk == 0)
          break; /* EOF */
        else /* chunk &gt; 0 */
<span class="udiff-line-modified-removed">-     bytes += chunk;</span>
<span class="udiff-line-modified-added">+   bytes += chunk;</span>
      }
  
    *n_ints_read = (gint)(bytes / sizeof(gint));
  
    return TRUE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1597,29 +1597,29 @@</span>
  }
  #endif /* POSIX_SPAWN_AVAILABLE */
  
  static gboolean
  fork_exec_with_fds (gboolean              intermediate_child,
<span class="udiff-line-modified-removed">-                       const gchar          *working_directory,</span>
<span class="udiff-line-modified-removed">-                       gchar               **argv,</span>
<span class="udiff-line-modified-removed">-                       gchar               **envp,</span>
<span class="udiff-line-modified-removed">-                       gboolean              close_descriptors,</span>
<span class="udiff-line-modified-removed">-                       gboolean              search_path,</span>
<span class="udiff-line-modified-removed">-                       gboolean              search_path_from_envp,</span>
<span class="udiff-line-modified-removed">-                       gboolean              stdout_to_null,</span>
<span class="udiff-line-modified-removed">-                       gboolean              stderr_to_null,</span>
<span class="udiff-line-modified-removed">-                       gboolean              child_inherits_stdin,</span>
<span class="udiff-line-modified-removed">-                       gboolean              file_and_argv_zero,</span>
<span class="udiff-line-modified-removed">-                       gboolean              cloexec_pipes,</span>
<span class="udiff-line-modified-removed">-                       GSpawnChildSetupFunc  child_setup,</span>
<span class="udiff-line-modified-removed">-                       gpointer              user_data,</span>
<span class="udiff-line-modified-removed">-                       GPid                 *child_pid,</span>
<span class="udiff-line-modified-removed">-                       gint                 *child_close_fds,</span>
<span class="udiff-line-modified-removed">-                       gint                  stdin_fd,</span>
<span class="udiff-line-modified-removed">-                       gint                  stdout_fd,</span>
<span class="udiff-line-modified-removed">-                       gint                  stderr_fd,</span>
<span class="udiff-line-modified-removed">-                       GError              **error)</span>
<span class="udiff-line-modified-added">+                     const gchar          *working_directory,</span>
<span class="udiff-line-modified-added">+                     gchar               **argv,</span>
<span class="udiff-line-modified-added">+                     gchar               **envp,</span>
<span class="udiff-line-modified-added">+                     gboolean              close_descriptors,</span>
<span class="udiff-line-modified-added">+                     gboolean              search_path,</span>
<span class="udiff-line-modified-added">+                     gboolean              search_path_from_envp,</span>
<span class="udiff-line-modified-added">+                     gboolean              stdout_to_null,</span>
<span class="udiff-line-modified-added">+                     gboolean              stderr_to_null,</span>
<span class="udiff-line-modified-added">+                     gboolean              child_inherits_stdin,</span>
<span class="udiff-line-modified-added">+                     gboolean              file_and_argv_zero,</span>
<span class="udiff-line-modified-added">+                     gboolean              cloexec_pipes,</span>
<span class="udiff-line-modified-added">+                     GSpawnChildSetupFunc  child_setup,</span>
<span class="udiff-line-modified-added">+                     gpointer              user_data,</span>
<span class="udiff-line-modified-added">+                     GPid                 *child_pid,</span>
<span class="udiff-line-modified-added">+                     gint                 *child_close_fds,</span>
<span class="udiff-line-modified-added">+                     gint                  stdin_fd,</span>
<span class="udiff-line-modified-added">+                     gint                  stdout_fd,</span>
<span class="udiff-line-modified-added">+                     gint                  stderr_fd,</span>
<span class="udiff-line-modified-added">+                     GError              **error)</span>
  {
    GPid pid = -1;
    gint child_err_report_pipe[2] = { -1, -1 };
    gint child_pid_report_pipe[2] = { -1, -1 };
    guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1648,11 +1648,11 @@</span>
        if (status != ENOEXEC)
          {
            g_set_error (error,
                         G_SPAWN_ERROR,
                         G_SPAWN_ERROR_FAILED,
<span class="udiff-line-modified-removed">-                        _(&quot;Failed to spawn child process “%s” (%s)&quot;),</span>
<span class="udiff-line-modified-added">+                        _(&quot;Failed to spawn child process &#39;%s&#39; (%s)&quot;),</span>
                         argv[0],
                         g_strerror (status));
            return FALSE;
         }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1816,11 +1816,11 @@</span>
                  goto wait_again;
                else if (errno == ECHILD)
                  ; /* do nothing, child already reaped */
                else
                  g_warning (&quot;waitpid() should not fail in &quot;
<span class="udiff-line-modified-removed">-                &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
<span class="udiff-line-modified-added">+          &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
              }
          }
  
  
        if (!read_ints (child_err_report_pipe[0],
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,11 +1846,11 @@</span>
  
              case CHILD_EXEC_FAILED:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             _g_spawn_exec_err_to_g_error (buf[1]),
<span class="udiff-line-modified-removed">-                            _(&quot;Failed to execute child process \&quot;%s\&quot; (%s)&quot;),</span>
<span class="udiff-line-modified-added">+                            _(&quot;Failed to execute child process &#39;%s&#39; (%s)&quot;),</span>
                             argv[0],
                             g_strerror (buf[1]));
  
                break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1873,11 +1873,11 @@</span>
  
              default:
                g_set_error (error,
                             G_SPAWN_ERROR,
                             G_SPAWN_ERROR_FAILED,
<span class="udiff-line-modified-removed">-                            _(&quot;Unknown error executing child process \&quot;%s\&quot;&quot;),</span>
<span class="udiff-line-modified-added">+                            _(&quot;Unknown error executing child process &#39;%s&#39;&quot;),</span>
                             argv[0]);
                break;
              }
  
            goto cleanup_and_fail;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2061,12 +2061,12 @@</span>
  
      new_argv[0] = (char *) &quot;/bin/sh&quot;;
      new_argv[1] = (char *) file;
      while (argc &gt; 0)
        {
<span class="udiff-line-modified-removed">-     new_argv[argc + 1] = argv[argc];</span>
<span class="udiff-line-modified-removed">-     --argc;</span>
<span class="udiff-line-modified-added">+   new_argv[argc + 1] = argv[argc];</span>
<span class="udiff-line-modified-added">+   --argc;</span>
        }
  
      /* Execute the shell. */
      if (envp)
        execve (new_argv[0], new_argv, envp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2108,11 +2108,11 @@</span>
          execve (file, argv, envp);
        else
          execv (file, argv);
  
        if (errno == ENOEXEC)
<span class="udiff-line-modified-removed">-     script_execute (file, argv, envp);</span>
<span class="udiff-line-modified-added">+   script_execute (file, argv, envp);</span>
      }
    else
      {
        gboolean got_eacces = 0;
        const gchar *path, *p;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2125,23 +2125,23 @@</span>
          path = g_environ_getenv (envp, &quot;PATH&quot;);
        if (search_path &amp;&amp; path == NULL)
          path = g_getenv (&quot;PATH&quot;);
  
        if (path == NULL)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="udiff-line-modified-removed">-        * search path in libc is the current directory followed by</span>
<span class="udiff-line-modified-removed">-        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="udiff-line-modified-added">+      * search path in libc is the current directory followed by</span>
<span class="udiff-line-modified-added">+      * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
             */
  
            /* In GLib we put . last, for security, and don&#39;t use the
             * unportable confstr(); UNIX98 does not actually specify
             * what to search if PATH is unset. POSIX may, dunno.
             */
  
            path = &quot;/bin:/usr/bin:.&quot;;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
  
        len = strlen (file) + 1;
        pathlen = strlen (path);
        freeme = name = g_malloc (pathlen + len + 1);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2151,79 +2151,79 @@</span>
        /* And add the slash before the filename  */
        *name = &#39;/&#39;;
  
        p = path;
        do
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       char *startp;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     char *startp;</span>
  
<span class="udiff-line-modified-removed">-       path = p;</span>
<span class="udiff-line-modified-removed">-       p = my_strchrnul (path, &#39;:&#39;);</span>
<span class="udiff-line-modified-added">+     path = p;</span>
<span class="udiff-line-modified-added">+     p = my_strchrnul (path, &#39;:&#39;);</span>
  
<span class="udiff-line-modified-removed">-       if (p == path)</span>
<span class="udiff-line-modified-removed">-         /* Two adjacent colons, or a colon at the beginning or the end</span>
<span class="udiff-line-modified-added">+     if (p == path)</span>
<span class="udiff-line-modified-added">+       /* Two adjacent colons, or a colon at the beginning or the end</span>
               * of &#39;PATH&#39; means to search the current directory.
               */
<span class="udiff-line-modified-removed">-         startp = name + 1;</span>
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         startp = memcpy (name - (p - path), path, p - path);</span>
<span class="udiff-line-modified-added">+       startp = name + 1;</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       startp = memcpy (name - (p - path), path, p - path);</span>
  
<span class="udiff-line-modified-removed">-       /* Try to execute this name.  If it works, execv will not return.  */</span>
<span class="udiff-line-modified-added">+     /* Try to execute this name.  If it works, execv will not return.  */</span>
            if (envp)
              execve (startp, argv, envp);
            else
              execv (startp, argv);
  
<span class="udiff-line-modified-removed">-       if (errno == ENOEXEC)</span>
<span class="udiff-line-modified-removed">-         script_execute (startp, argv, envp);</span>
<span class="udiff-line-modified-added">+     if (errno == ENOEXEC)</span>
<span class="udiff-line-modified-added">+       script_execute (startp, argv, envp);</span>
  
<span class="udiff-line-modified-removed">-       switch (errno)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-         case EACCES:</span>
<span class="udiff-line-modified-removed">-           /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
<span class="udiff-line-modified-added">+     switch (errno)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+       case EACCES:</span>
<span class="udiff-line-modified-added">+         /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
                 * up finding no executable we can use, we want to diagnose
                 * that we did find one but were denied access.
                 */
<span class="udiff-line-modified-removed">-           got_eacces = TRUE;</span>
<span class="udiff-line-modified-added">+         got_eacces = TRUE;</span>
  
                /* FALL THRU */
  
<span class="udiff-line-modified-removed">-         case ENOENT:</span>
<span class="udiff-line-modified-added">+       case ENOENT:</span>
  #ifdef ESTALE
<span class="udiff-line-modified-removed">-         case ESTALE:</span>
<span class="udiff-line-modified-added">+       case ESTALE:</span>
  #endif
  #ifdef ENOTDIR
<span class="udiff-line-modified-removed">-         case ENOTDIR:</span>
<span class="udiff-line-modified-added">+       case ENOTDIR:</span>
  #endif
<span class="udiff-line-modified-removed">-           /* Those errors indicate the file is missing or not executable</span>
<span class="udiff-line-modified-added">+         /* Those errors indicate the file is missing or not executable</span>
                 * by us, in which case we want to just try the next path
                 * directory.
                 */
<span class="udiff-line-modified-removed">-           break;</span>
<span class="udiff-line-modified-added">+         break;</span>
  
<span class="udiff-line-modified-removed">-         case ENODEV:</span>
<span class="udiff-line-modified-removed">-         case ETIMEDOUT:</span>
<span class="udiff-line-modified-removed">-           /* Some strange filesystems like AFS return even</span>
<span class="udiff-line-modified-removed">-            * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="udiff-line-modified-removed">-            * else so ignore those, too.</span>
<span class="udiff-line-modified-removed">-            */</span>
<span class="udiff-line-modified-removed">-           break;</span>
<span class="udiff-line-modified-added">+       case ENODEV:</span>
<span class="udiff-line-modified-added">+       case ETIMEDOUT:</span>
<span class="udiff-line-modified-added">+         /* Some strange filesystems like AFS return even</span>
<span class="udiff-line-modified-added">+          * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="udiff-line-modified-added">+          * else so ignore those, too.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         break;</span>
  
<span class="udiff-line-modified-removed">-         default:</span>
<span class="udiff-line-modified-removed">-           /* Some other error means we found an executable file, but</span>
<span class="udiff-line-modified-added">+       default:</span>
<span class="udiff-line-modified-added">+         /* Some other error means we found an executable file, but</span>
                 * something went wrong executing it; return the error to our
                 * caller.
                 */
                g_free (freeme);
<span class="udiff-line-modified-removed">-           return -1;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         return -1;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
        while (*p++ != &#39;\0&#39;);
  
        /* We tried every element and none of them worked.  */
        if (got_eacces)
<span class="udiff-line-modified-removed">-     /* At least one failure was due to permissions, so report that</span>
<span class="udiff-line-modified-added">+   /* At least one failure was due to permissions, so report that</span>
           * error.
           */
          errno = EACCES;
  
        g_free (freeme);
</pre>
<center><a href="gspawn-win32.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>