diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.h b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.h
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.h
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.h
@@ -43,12 +43,10 @@
 
 /* qtdemux produces these for atoms it cannot parse */
 #define GST_QT_DEMUX_PRIVATE_TAG "private-qt-tag"
 #define GST_QT_DEMUX_CLASSIFICATION_TAG "classification"
 
-#define GST_QTDEMUX_MAX_STREAMS         32
-
 typedef struct _GstQTDemux GstQTDemux;
 typedef struct _GstQTDemuxClass GstQTDemuxClass;
 typedef struct _QtDemuxStream QtDemuxStream;
 
 enum QtDemuxState
@@ -71,12 +69,17 @@
   /* TRUE if pull-based */
   gboolean pullbased;
 
   gboolean posted_redirect;
 
-  QtDemuxStream *streams[GST_QTDEMUX_MAX_STREAMS];
-  gint     n_streams;
+  /* Protect pad exposing from flush event */
+  GMutex expose_lock;
+
+  /* list of QtDemuxStream */
+  GPtrArray *active_streams;
+  GPtrArray *old_streams;
+
   gint     n_video_streams;
   gint     n_audio_streams;
   gint     n_sub_streams;
 
   GstFlowCombiner *flowcombiner;
@@ -113,12 +116,15 @@
   GstTagList *tag_list;
 
   /* configured playback region */
   GstSegment segment;
 
-  /* The SEGMENT_EVENT from upstream *OR* generated from segment (above) */
-  GstEvent *pending_newsegment;
+  /* PUSH-BASED only: If the initial segment event, or a segment consequence of
+   * a seek or incoming TIME segment from upstream needs to be pushed. This
+   * variable is used instead of pushing the event directly because at that
+   * point we may not have yet emitted the srcpads. */
+  gboolean need_segment;
 
   guint32 segment_seqnum;
 
   /* flag to indicate that we're working with a smoothstreaming fragment
    * Mss doesn't have 'moov' or any information about the streams format,
@@ -149,11 +155,15 @@
   GPtrArray *protection_system_ids; /* Holds identifiers of all content protection systems for all tracks */
   GQueue protection_event_queue; /* holds copy of upstream protection events */
   guint64 cenc_aux_info_offset;
   guint8 *cenc_aux_info_sizes;
   guint32 cenc_aux_sample_count;
+  gchar *preferred_protection_system_id;
 
+  /* Whether the parent bin is streams-aware, meaning we can
+   * add/remove streams at any point in time */
+  gboolean streams_aware;
 
   /*
    * ALL VARIABLES BELOW ARE ONLY USED IN PUSH-BASED MODE
    */
   GstAdapter *adapter;
@@ -227,10 +237,21 @@
   guint64 fragment_start;
   /* UPSTREAM TIME : The offset in bytes of the [moof]
    * header start.
    * Note : This is not computed from the GST_BUFFER_OFFSET field */
   guint64 fragment_start_offset;
+
+  /* These two fields are used to perform an implicit seek when a fragmented
+   * file whose first tfdt is not zero. This way if the first fragment starts
+   * at 1 hour, the user does not have to wait 1 hour or perform a manual seek
+   * for the image to move and the sound to play.
+   *
+   * This implicit seek is only done if the first parsed fragment has a non-zero
+   * decode base time and a seek has not been received previously, hence these
+   * fields. */
+  gboolean received_seek;
+  gboolean first_moof_already_parsed;
 };
 
 struct _GstQTDemuxClass {
   GstElementClass parent_class;
 };
