diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c
@@ -29,10 +29,11 @@
 #include "gasyncqueue.h"
 #include "gasyncqueueprivate.h"
 #include "gmain.h"
 #include "gtestutils.h"
 #include "gtimer.h"
+#include "gutils.h"
 
 /**
  * SECTION:thread_pools
  * @title: Thread Pools
  * @short_description: pools of threads to execute work concurrently
@@ -88,11 +89,11 @@
 {
   GThreadPool pool;
   GAsyncQueue *queue;
   GCond cond;
   gint max_threads;
-  gint num_threads;
+  guint num_threads;
   gboolean running;
   gboolean immediate;
   gboolean waiting;
   GCompareDataFunc sort_func;
   gpointer sort_user_data;
@@ -151,11 +152,11 @@
 
   g_atomic_int_inc (&unused_threads);
 
   do
     {
-      if (g_atomic_int_get (&unused_threads) >= local_max_unused_threads)
+      if ((guint) g_atomic_int_get (&unused_threads) >= local_max_unused_threads)
         {
           /* If this is a superfluous thread, stop it. */
           pool = NULL;
         }
       else if (local_max_idle_time > 0)
@@ -163,11 +164,11 @@
           /* If a maximal idle time is given, wait for the given time. */
           DEBUG_MSG (("thread %p waiting in global pool for %f seconds.",
                       g_thread_self (), local_max_idle_time / 1000.0));
 
           pool = g_async_queue_timeout_pop (unused_thread_queue,
-                        local_max_idle_time * 1000);
+              local_max_idle_time * 1000);
         }
       else
         {
           /* If no maximal idle time is given, wait indefinitely. */
           DEBUG_MSG (("thread %p waiting in global pool.", g_thread_self ()));
@@ -231,11 +232,11 @@
 
   if (pool->running || (!pool->immediate &&
                         g_async_queue_length_unlocked (pool->queue) > 0))
     {
       /* This thread pool is still active. */
-      if (pool->num_threads > pool->max_threads && pool->max_threads != -1)
+      if (pool->max_threads != -1 && pool->num_threads > (guint) pool->max_threads)
         {
           /* This is a superfluous thread, so it goes to the global pool. */
           DEBUG_MSG (("superfluous thread %p in pool %p.",
                       g_thread_self (), pool));
         }
@@ -258,11 +259,11 @@
                       "(%d running, %d unprocessed).",
                       g_thread_self (), pool, pool->num_threads,
                       g_async_queue_length_unlocked (pool->queue)));
 
           task = g_async_queue_timeout_pop_unlocked (pool->queue,
-                             G_USEC_PER_SEC / 2);
+                 G_USEC_PER_SEC / 2);
         }
     }
   else
     {
       /* This thread pool is inactive, it will no longer process tasks. */
@@ -337,11 +338,11 @@
                        * finish and this is not the last thread of
                        * this pool and there are no tasks left in the
                        * queue, wakeup the remaining threads.
                        */
                       if (g_async_queue_length_unlocked (pool->queue) ==
-                          - pool->num_threads)
+                          (gint) -pool->num_threads)
                         g_thread_pool_wakeup_and_stop_all (pool);
                     }
                 }
               else if (pool->immediate ||
                        g_async_queue_length_unlocked (pool->queue) <= 0)
@@ -383,11 +384,11 @@
 g_thread_pool_start_thread (GRealThreadPool  *pool,
                             GError          **error)
 {
   gboolean success = FALSE;
 
-  if (pool->num_threads >= pool->max_threads && pool->max_threads != -1)
+  if (pool->max_threads != -1 && pool->num_threads >= (guint) pool->max_threads)
     /* Enough threads are already running */
     return TRUE;
 
   g_async_queue_lock (unused_thread_queue);
 
@@ -399,14 +400,19 @@
 
   g_async_queue_unlock (unused_thread_queue);
 
   if (!success)
     {
+      const gchar *prgname = g_get_prgname ();
+      gchar name[16] = "pool";
       GThread *thread;
 
+      if (prgname)
+        g_snprintf (name, sizeof (name), "pool-%s", prgname);
+
       /* No thread was found, we have to start a new one */
-      thread = g_thread_try_new ("pool", g_thread_pool_thread_proxy, pool, error);
+      thread = g_thread_try_new (name, g_thread_pool_thread_proxy, pool, error);
 
       if (thread == NULL)
         return FALSE;
 
       g_thread_unref (thread);
@@ -496,11 +502,11 @@
 
   if (retval->pool.exclusive)
     {
       g_async_queue_lock (retval->queue);
 
-      while (retval->num_threads < retval->max_threads)
+      while (retval->num_threads < (guint) retval->max_threads)
         {
           GError *local_error = NULL;
 
           if (!g_thread_pool_start_thread (retval, &local_error))
             {
@@ -769,16 +775,16 @@
   real->immediate = immediate;
   real->waiting = wait_;
 
   if (wait_)
     {
-      while (g_async_queue_length_unlocked (real->queue) != -real->num_threads &&
+      while (g_async_queue_length_unlocked (real->queue) != (gint) -real->num_threads &&
              !(immediate && real->num_threads == 0))
         g_cond_wait (&real->cond, _g_async_queue_get_mutex (real->queue));
     }
 
-  if (immediate || g_async_queue_length_unlocked (real->queue) == -real->num_threads)
+  if (immediate || g_async_queue_length_unlocked (real->queue) == (gint) -real->num_threads)
     {
       /* No thread is currently doing something (and nothing is left
        * to process in the queue)
        */
       if (real->num_threads == 0)
