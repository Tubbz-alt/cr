<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1998  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gutils.h&quot;
<a name="1" id="anc1"></a>
  32 
  33 #include &lt;stdarg.h&gt;
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;stdio.h&gt;
  36 #include &lt;locale.h&gt;
  37 #include &lt;string.h&gt;
<a name="2" id="anc2"></a><span class="line-modified">  38 #include &lt;ctype.h&gt;      /* For tolower() */</span>
  39 #include &lt;errno.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #ifdef G_OS_UNIX
  43 #include &lt;pwd.h&gt;
  44 #include &lt;unistd.h&gt;
  45 #endif
  46 #include &lt;sys/types.h&gt;
  47 #ifdef HAVE_SYS_PARAM_H
  48 #include &lt;sys/param.h&gt;
  49 #endif
  50 #ifdef HAVE_CRT_EXTERNS_H
  51 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  52 #endif
  53 #ifdef HAVE_SYS_AUXV_H
  54 #include &lt;sys/auxv.h&gt;
  55 #endif
  56 
  57 #include &quot;glib-init.h&quot;
  58 #include &quot;glib-private.h&quot;
  59 #include &quot;genviron.h&quot;
  60 #include &quot;gfileutils.h&quot;
  61 #include &quot;ggettext.h&quot;
  62 #include &quot;ghash.h&quot;
  63 #include &quot;gthread.h&quot;
  64 #include &quot;gtestutils.h&quot;
  65 #include &quot;gunicode.h&quot;
  66 #include &quot;gstrfuncs.h&quot;
  67 #include &quot;garray.h&quot;
  68 #include &quot;glibintl.h&quot;
  69 #include &quot;gstdio.h&quot;
  70 
  71 #ifdef G_PLATFORM_WIN32
  72 #include &quot;gconvert.h&quot;
  73 #include &quot;gwin32.h&quot;
  74 #endif
  75 
  76 
  77 /**
  78  * SECTION:misc_utils
  79  * @title: Miscellaneous Utility Functions
  80  * @short_description: a selection of portable utility functions
  81  *
  82  * These are portable utility functions.
  83  */
  84 
  85 #ifdef G_PLATFORM_WIN32
  86 #  include &lt;windows.h&gt;
  87 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
  88 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
  89 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
  90 #  endif
<a name="3" id="anc3"></a><span class="line-modified">  91 #  include &lt;lmcons.h&gt;       /* For UNLEN */</span>
  92 #endif /* G_PLATFORM_WIN32 */
  93 
  94 #ifdef G_OS_WIN32
  95 #  include &lt;direct.h&gt;
  96 #  include &lt;shlobj.h&gt;
<a name="4" id="anc4"></a><span class="line-removed">  97    /* older SDK (e.g. msvc 5.0) does not have these*/</span>
<span class="line-removed">  98 #  ifndef CSIDL_MYMUSIC</span>
<span class="line-removed">  99 #    define CSIDL_MYMUSIC 13</span>
<span class="line-removed"> 100 #  endif</span>
<span class="line-removed"> 101 #  ifndef CSIDL_MYVIDEO</span>
<span class="line-removed"> 102 #    define CSIDL_MYVIDEO 14</span>
<span class="line-removed"> 103 #  endif</span>
<span class="line-removed"> 104 #  ifndef CSIDL_INTERNET_CACHE</span>
<span class="line-removed"> 105 #    define CSIDL_INTERNET_CACHE 32</span>
<span class="line-removed"> 106 #  endif</span>
<span class="line-removed"> 107 #  ifndef CSIDL_COMMON_APPDATA</span>
<span class="line-removed"> 108 #    define CSIDL_COMMON_APPDATA 35</span>
<span class="line-removed"> 109 #  endif</span>
<span class="line-removed"> 110 #  ifndef CSIDL_MYPICTURES</span>
<span class="line-removed"> 111 #    define CSIDL_MYPICTURES 0x27</span>
<span class="line-removed"> 112 #  endif</span>
<span class="line-removed"> 113 #  ifndef CSIDL_COMMON_DOCUMENTS</span>
<span class="line-removed"> 114 #    define CSIDL_COMMON_DOCUMENTS 46</span>
<span class="line-removed"> 115 #  endif</span>
<span class="line-removed"> 116 #  ifndef CSIDL_PROFILE</span>
<span class="line-removed"> 117 #    define CSIDL_PROFILE 40</span>
<span class="line-removed"> 118 #  endif</span>
 119 #  include &lt;process.h&gt;
 120 #endif
 121 
<a name="5" id="anc5"></a><span class="line-removed"> 122 #ifdef HAVE_CARBON</span>
<span class="line-removed"> 123 #include &lt;CoreServices/CoreServices.h&gt;</span>
<span class="line-removed"> 124 #endif</span>
<span class="line-removed"> 125 </span>
 126 #ifdef HAVE_CODESET
 127 #include &lt;langinfo.h&gt;
 128 #endif
 129 
 130 #ifdef G_PLATFORM_WIN32
 131 
 132 gchar *
 133 _glib_get_dll_directory (void)
 134 {
 135   gchar *retval;
 136   gchar *p;
 137   wchar_t wc_fn[MAX_PATH];
 138 
 139 #ifdef DLL_EXPORT
 140   if (glib_dll == NULL)
 141     return NULL;
 142 #endif
 143 
 144   /* This code is different from that in
 145    * g_win32_get_package_installation_directory_of_module() in that
 146    * here we return the actual folder where the GLib DLL is. We don&#39;t
 147    * do the check for it being in a &quot;bin&quot; or &quot;lib&quot; subfolder and then
 148    * returning the parent of that.
 149    *
 150    * In a statically built GLib, glib_dll will be NULL and we will
 151    * thus look up the application&#39;s .exe file&#39;s location.
 152    */
 153   if (!GetModuleFileNameW (glib_dll, wc_fn, MAX_PATH))
 154     return NULL;
 155 
 156   retval = g_utf16_to_utf8 (wc_fn, -1, NULL, NULL, NULL);
 157 
 158   p = strrchr (retval, G_DIR_SEPARATOR);
 159   if (p == NULL)
 160     {
 161       /* Wtf? */
 162       return NULL;
 163     }
 164   *p = &#39;\0&#39;;
 165 
 166   return retval;
 167 }
 168 
 169 #endif
 170 
 171 /**
 172  * g_memmove:
 173  * @dest: the destination address to copy the bytes to.
 174  * @src: the source address to copy the bytes from.
 175  * @len: the number of bytes to copy.
 176  *
 177  * Copies a block of memory @len bytes long, from @src to @dest.
 178  * The source and destination areas may overlap.
 179  *
 180  * Deprecated:2.40: Just use memmove().
 181  */
 182 
 183 #ifndef GSTREAMER_LITE
 184 
 185 #ifdef G_OS_WIN32
 186 #undef g_atexit
 187 #endif
 188 
 189 /**
 190  * g_atexit:
 191  * @func: (scope async): the function to call on normal program termination.
 192  *
 193  * Specifies a function to be called at normal program termination.
 194  *
 195  * Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor
 196  * macro that maps to a call to the atexit() function in the C
 197  * library. This means that in case the code that calls g_atexit(),
 198  * i.e. atexit(), is in a DLL, the function will be called when the
 199  * DLL is detached from the program. This typically makes more sense
 200  * than that the function is called when the GLib DLL is detached,
 201  * which happened earlier when g_atexit() was a function in the GLib
 202  * DLL.
 203  *
 204  * The behaviour of atexit() in the context of dynamically loaded
 205  * modules is not formally specified and varies wildly.
 206  *
 207  * On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
 208  * loaded module which is unloaded before the program terminates might
 209  * well cause a crash at program exit.
 210  *
 211  * Some POSIX systems implement atexit() like Windows, and have each
 212  * dynamically loaded module maintain an own atexit chain that is
 213  * called when the module is unloaded.
 214  *
 215  * On other POSIX systems, before a dynamically loaded module is
 216  * unloaded, the registered atexit functions (if any) residing in that
 217  * module are called, regardless where the code that registered them
 218  * resided. This is presumably the most robust approach.
 219  *
 220  * As can be seen from the above, for portability it&#39;s best to avoid
 221  * calling g_atexit() (or atexit()) except in the main executable of a
 222  * program.
 223  *
 224  * Deprecated:2.32: It is best to avoid g_atexit().
 225  */
<a name="6" id="anc6"></a>
 226 void
 227 g_atexit (GVoidFunc func)
 228 {
 229   gint result;
 230   int errsv;
 231 
 232   result = atexit ((void (*)(void)) func);
 233   errsv = errno;
 234   if (result)
 235     {
 236       g_error (&quot;Could not register atexit() function: %s&quot;,
 237                g_strerror (errsv));
 238     }
 239 }
<a name="7" id="anc7"></a>
 240 
 241 #endif // GSTREAMER_LITE
 242 
 243 /* Based on execvp() from GNU Libc.
 244  * Some of this code is cut-and-pasted into gspawn.c
 245  */
 246 
 247 static gchar*
 248 my_strchrnul (const gchar *str,
<a name="8" id="anc8"></a><span class="line-modified"> 249           gchar        c)</span>
 250 {
 251   gchar *p = (gchar*)str;
 252   while (*p &amp;&amp; (*p != c))
 253     ++p;
 254 
 255   return p;
 256 }
 257 
 258 #ifdef G_OS_WIN32
 259 
 260 static gchar *inner_find_program_in_path (const gchar *program);
 261 
 262 gchar*
 263 g_find_program_in_path (const gchar *program)
 264 {
 265   const gchar *last_dot = strrchr (program, &#39;.&#39;);
 266 
 267   if (last_dot == NULL ||
 268       strchr (last_dot, &#39;\\&#39;) != NULL ||
 269       strchr (last_dot, &#39;/&#39;) != NULL)
 270     {
 271       const gint program_length = strlen (program);
 272       gchar *pathext = g_build_path (&quot;;&quot;,
<a name="9" id="anc9"></a><span class="line-modified"> 273                      &quot;.exe;.cmd;.bat;.com&quot;,</span>
<span class="line-modified"> 274                      g_getenv (&quot;PATHEXT&quot;),</span>
<span class="line-modified"> 275                      NULL);</span>
 276       gchar *p;
 277       gchar *decorated_program;
 278       gchar *retval;
 279 
 280       p = pathext;
 281       do
<a name="10" id="anc10"></a><span class="line-modified"> 282     {</span>
<span class="line-modified"> 283       gchar *q = my_strchrnul (p, &#39;;&#39;);</span>
 284 
<a name="11" id="anc11"></a><span class="line-modified"> 285       decorated_program = g_malloc (program_length + (q-p) + 1);</span>
<span class="line-modified"> 286       memcpy (decorated_program, program, program_length);</span>
<span class="line-modified"> 287       memcpy (decorated_program+program_length, p, q-p);</span>
<span class="line-modified"> 288       decorated_program [program_length + (q-p)] = &#39;\0&#39;;</span>
 289 
<a name="12" id="anc12"></a><span class="line-modified"> 290       retval = inner_find_program_in_path (decorated_program);</span>
<span class="line-modified"> 291       g_free (decorated_program);</span>
 292 
<a name="13" id="anc13"></a><span class="line-modified"> 293       if (retval != NULL)</span>
<span class="line-modified"> 294         {</span>
<span class="line-modified"> 295           g_free (pathext);</span>
<span class="line-modified"> 296           return retval;</span>
<span class="line-modified"> 297         }</span>
<span class="line-modified"> 298       p = q;</span>
<span class="line-modified"> 299     } while (*p++ != &#39;\0&#39;);</span>
 300       g_free (pathext);
 301       return NULL;
 302     }
 303   else
 304     return inner_find_program_in_path (program);
 305 }
 306 
 307 #endif
 308 
 309 /**
 310  * g_find_program_in_path:
 311  * @program: (type filename): a program name in the GLib file name encoding
 312  *
 313  * Locates the first executable named @program in the user&#39;s path, in the
 314  * same way that execvp() would locate it. Returns an allocated string
 315  * with the absolute path name, or %NULL if the program is not found in
 316  * the path. If @program is already an absolute path, returns a copy of
 317  * @program if @program exists and is executable, and %NULL otherwise.
 318  *
 319  * On Windows, if @program does not have a file type suffix, tries
 320  * with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
 321  * the `PATHEXT` environment variable.
 322  *
 323  * On Windows, it looks for the file in the same way as CreateProcess()
 324  * would. This means first in the directory where the executing
 325  * program was loaded from, then in the current directory, then in the
 326  * Windows 32-bit system directory, then in the Windows directory, and
 327  * finally in the directories in the `PATH` environment variable. If
 328  * the program is found, the return value contains the full name
 329  * including the type suffix.
 330  *
 331  * Returns: (type filename): a newly-allocated string with the absolute path,
 332  *     or %NULL
 333  **/
 334 #ifdef G_OS_WIN32
 335 static gchar *
 336 inner_find_program_in_path (const gchar *program)
 337 #else
 338 gchar*
 339 g_find_program_in_path (const gchar *program)
 340 #endif
 341 {
 342   const gchar *path, *p;
 343   gchar *name, *freeme;
 344 #ifdef G_OS_WIN32
 345   const gchar *path_copy;
 346   gchar *filename = NULL, *appdir = NULL;
 347   gchar *sysdir = NULL, *windir = NULL;
 348   int n;
 349   wchar_t wfilename[MAXPATHLEN], wsysdir[MAXPATHLEN],
 350     wwindir[MAXPATHLEN];
 351 #endif
 352   gsize len;
 353   gsize pathlen;
 354 
 355   g_return_val_if_fail (program != NULL, NULL);
 356 
 357   /* If it is an absolute path, or a relative path including subdirectories,
 358    * don&#39;t look in PATH.
 359    */
 360   if (g_path_is_absolute (program)
 361       || strchr (program, G_DIR_SEPARATOR) != NULL
 362 #ifdef G_OS_WIN32
 363       || strchr (program, &#39;/&#39;) != NULL
 364 #endif
 365       )
 366     {
 367       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<a name="14" id="anc14"></a><span class="line-modified"> 368       !g_file_test (program, G_FILE_TEST_IS_DIR))</span>
 369         return g_strdup (program);
 370       else
 371         return NULL;
 372     }
 373 
 374   path = g_getenv (&quot;PATH&quot;);
 375 #if defined(G_OS_UNIX)
 376   if (path == NULL)
 377     {
 378       /* There is no &#39;PATH&#39; in the environment.  The default
 379        * search path in GNU libc is the current directory followed by
 380        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.
 381        */
 382 
 383       /* In GLib we put . last, for security, and don&#39;t use the
 384        * unportable confstr(); UNIX98 does not actually specify
 385        * what to search if PATH is unset. POSIX may, dunno.
 386        */
 387 
 388       path = &quot;/bin:/usr/bin:.&quot;;
 389     }
 390 #else
 391   n = GetModuleFileNameW (NULL, wfilename, MAXPATHLEN);
 392   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 393     filename = g_utf16_to_utf8 (wfilename, -1, NULL, NULL, NULL);
 394 
 395   n = GetSystemDirectoryW (wsysdir, MAXPATHLEN);
 396   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 397     sysdir = g_utf16_to_utf8 (wsysdir, -1, NULL, NULL, NULL);
 398 
 399   n = GetWindowsDirectoryW (wwindir, MAXPATHLEN);
 400   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 401     windir = g_utf16_to_utf8 (wwindir, -1, NULL, NULL, NULL);
 402 
 403   if (filename)
 404     {
 405       appdir = g_path_get_dirname (filename);
 406       g_free (filename);
 407     }
 408 
 409   path = g_strdup (path);
 410 
 411   if (windir)
 412     {
 413       const gchar *tem = path;
 414       path = g_strconcat (windir, &quot;;&quot;, path, NULL);
 415       g_free ((gchar *) tem);
 416       g_free (windir);
 417     }
 418 
 419   if (sysdir)
 420     {
 421       const gchar *tem = path;
 422       path = g_strconcat (sysdir, &quot;;&quot;, path, NULL);
 423       g_free ((gchar *) tem);
 424       g_free (sysdir);
 425     }
 426 
 427   {
 428     const gchar *tem = path;
 429     path = g_strconcat (&quot;.;&quot;, path, NULL);
 430     g_free ((gchar *) tem);
 431   }
 432 
 433   if (appdir)
 434     {
 435       const gchar *tem = path;
 436       path = g_strconcat (appdir, &quot;;&quot;, path, NULL);
 437       g_free ((gchar *) tem);
 438       g_free (appdir);
 439     }
 440 
 441   path_copy = path;
 442 #endif
 443 
 444   len = strlen (program) + 1;
 445   pathlen = strlen (path);
 446   freeme = name = g_malloc (pathlen + len + 1);
 447 #ifdef GSTREAMER_LITE
 448   if (freeme == NULL)
 449       return NULL;
 450 #endif // GSTREAMER_LITE
 451 
 452   /* Copy the file name at the top, including &#39;\0&#39;  */
 453   memcpy (name + pathlen + 1, program, len);
 454   name = name + pathlen;
 455   /* And add the slash before the filename  */
 456   *name = G_DIR_SEPARATOR;
 457 
 458   p = path;
 459   do
 460     {
 461       char *startp;
 462 
 463       path = p;
 464       p = my_strchrnul (path, G_SEARCHPATH_SEPARATOR);
 465 
 466       if (p == path)
 467         /* Two adjacent colons, or a colon at the beginning or the end
 468          * of &#39;PATH&#39; means to search the current directory.
 469          */
 470         startp = name + 1;
 471       else
 472         startp = memcpy (name - (p - path), path, p - path);
 473 
 474       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified"> 475       !g_file_test (startp, G_FILE_TEST_IS_DIR))</span>
 476         {
 477           gchar *ret;
 478           ret = g_strdup (startp);
 479           g_free (freeme);
 480 #ifdef G_OS_WIN32
<a name="16" id="anc16"></a><span class="line-modified"> 481       g_free ((gchar *) path_copy);</span>
 482 #endif
 483           return ret;
 484         }
 485     }
 486   while (*p++ != &#39;\0&#39;);
 487 
 488   g_free (freeme);
 489 #ifdef G_OS_WIN32
 490   g_free ((gchar *) path_copy);
 491 #endif
 492 
 493   return NULL;
 494 }
 495 
 496 /* The functions below are defined this way for compatibility reasons.
 497  * See the note in gutils.h.
 498  */
 499 
 500 /**
 501  * g_bit_nth_lsf:
 502  * @mask: a #gulong containing flags
 503  * @nth_bit: the index of the bit to start the search from
 504  *
 505  * Find the position of the first bit set in @mask, searching
 506  * from (but not including) @nth_bit upwards. Bits are numbered
 507  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 508  * usually). To start searching from the 0th bit, set @nth_bit to -1.
 509  *
 510  * Returns: the index of the first bit set which is higher than @nth_bit, or -1
 511  *    if no higher bits are set
 512  */
 513 gint
 514 (g_bit_nth_lsf) (gulong mask,
 515                  gint   nth_bit)
 516 {
 517   return g_bit_nth_lsf_impl (mask, nth_bit);
 518 }
 519 
 520 /**
 521  * g_bit_nth_msf:
 522  * @mask: a #gulong containing flags
 523  * @nth_bit: the index of the bit to start the search from
 524  *
 525  * Find the position of the first bit set in @mask, searching
 526  * from (but not including) @nth_bit downwards. Bits are numbered
 527  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 528  * usually). To start searching from the last bit, set @nth_bit to
 529  * -1 or GLIB_SIZEOF_LONG * 8.
 530  *
 531  * Returns: the index of the first bit set which is lower than @nth_bit, or -1
 532  *    if no lower bits are set
 533  */
 534 gint
 535 (g_bit_nth_msf) (gulong mask,
 536                  gint   nth_bit)
 537 {
 538   return g_bit_nth_msf_impl (mask, nth_bit);
 539 }
 540 
 541 
 542 /**
 543  * g_bit_storage:
 544  * @number: a #guint
 545  *
 546  * Gets the number of bits used to hold @number,
 547  * e.g. if @number is 4, 3 bits are needed.
 548  *
 549  * Returns: the number of bits used to hold @number
 550  */
 551 guint
 552 (g_bit_storage) (gulong number)
 553 {
 554   return g_bit_storage_impl (number);
 555 }
 556 
 557 G_LOCK_DEFINE_STATIC (g_utils_global);
 558 
 559 typedef struct
 560 {
 561   gchar *user_name;
 562   gchar *real_name;
 563   gchar *home_dir;
 564 } UserDatabaseEntry;
 565 
<a name="17" id="anc17"></a>
 566 static  gchar   *g_user_data_dir = NULL;
 567 static  gchar  **g_system_data_dirs = NULL;
 568 static  gchar   *g_user_cache_dir = NULL;
 569 static  gchar   *g_user_config_dir = NULL;
<a name="18" id="anc18"></a>
 570 static  gchar  **g_system_config_dirs = NULL;
<a name="19" id="anc19"></a><span class="line-removed"> 571 </span>
 572 static  gchar  **g_user_special_dirs = NULL;
 573 
 574 /* fifteen minutes of fame for everybody */
 575 #define G_USER_DIRS_EXPIRE      15 * 60
 576 
 577 #ifdef G_OS_WIN32
 578 
 579 static gchar *
 580 get_special_folder (int csidl)
 581 {
 582   wchar_t path[MAX_PATH+1];
 583   HRESULT hr;
 584   LPITEMIDLIST pidl = NULL;
 585   BOOL b;
 586   gchar *retval = NULL;
 587 
 588   hr = SHGetSpecialFolderLocation (NULL, csidl, &amp;pidl);
 589   if (hr == S_OK)
 590     {
 591       b = SHGetPathFromIDListW (pidl, path);
 592       if (b)
<a name="20" id="anc20"></a><span class="line-modified"> 593     retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);</span>
 594       CoTaskMemFree (pidl);
 595     }
 596   return retval;
 597 }
 598 
 599 static char *
 600 get_windows_directory_root (void)
 601 {
 602   wchar_t wwindowsdir[MAX_PATH];
 603 
 604   if (GetWindowsDirectoryW (wwindowsdir, G_N_ELEMENTS (wwindowsdir)))
 605     {
 606       /* Usually X:\Windows, but in terminal server environments
 607        * might be an UNC path, AFAIK.
 608        */
 609       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
 610       char *p;
 611 
 612       if (windowsdir == NULL)
<a name="21" id="anc21"></a><span class="line-modified"> 613     return g_strdup (&quot;C:\\&quot;);</span>
 614 
 615       p = (char *) g_path_skip_root (windowsdir);
 616       if (G_IS_DIR_SEPARATOR (p[-1]) &amp;&amp; p[-2] != &#39;:&#39;)
<a name="22" id="anc22"></a><span class="line-modified"> 617     p--;</span>
 618       *p = &#39;\0&#39;;
 619       return windowsdir;
 620     }
 621   else
 622     return g_strdup (&quot;C:\\&quot;);
 623 }
 624 
 625 #endif
 626 
 627 /* HOLDS: g_utils_global_lock */
 628 static UserDatabaseEntry *
 629 g_get_user_database_entry (void)
 630 {
 631   static UserDatabaseEntry *entry;
 632 
 633   if (g_once_init_enter (&amp;entry))
 634     {
 635       static UserDatabaseEntry e;
 636 
 637 #ifdef G_OS_UNIX
 638       {
 639         struct passwd *pw = NULL;
 640         gpointer buffer = NULL;
 641         gint error;
 642         gchar *logname;
 643 
 644 #  if defined (HAVE_GETPWUID_R)
 645         struct passwd pwd;
 646 #    ifdef _SC_GETPW_R_SIZE_MAX
 647         /* This reurns the maximum length */
 648         glong bufsize = sysconf (_SC_GETPW_R_SIZE_MAX);
 649 
 650         if (bufsize &lt; 0)
 651           bufsize = 64;
 652 #    else /* _SC_GETPW_R_SIZE_MAX */
 653         glong bufsize = 64;
 654 #    endif /* _SC_GETPW_R_SIZE_MAX */
 655 
 656         logname = (gchar *) g_getenv (&quot;LOGNAME&quot;);
 657 
 658         do
 659           {
 660             g_free (buffer);
 661             /* we allocate 6 extra bytes to work around a bug in
 662              * Mac OS &lt; 10.3. See #156446
 663              */
 664             buffer = g_malloc (bufsize + 6);
 665             errno = 0;
 666 
 667             if (logname) {
 668               error = getpwnam_r (logname, &amp;pwd, buffer, bufsize, &amp;pw);
 669               if (!pw || (pw-&gt;pw_uid != getuid ())) {
 670                 /* LOGNAME is lying, fall back to looking up the uid */
 671                 error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 672               }
 673             } else {
 674               error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 675             }
 676             error = error &lt; 0 ? errno : error;
 677 
 678             if (!pw)
 679               {
 680                 /* we bail out prematurely if the user id can&#39;t be found
 681                  * (should be pretty rare case actually), or if the buffer
 682                  * should be sufficiently big and lookups are still not
 683                  * successful.
 684                  */
 685                 if (error == 0 || error == ENOENT)
 686                   {
 687                     g_warning (&quot;getpwuid_r(): failed due to unknown user id (%lu)&quot;,
 688                                (gulong) getuid ());
 689                     break;
 690                   }
 691                 if (bufsize &gt; 32 * 1024)
 692                   {
 693                     g_warning (&quot;getpwuid_r(): failed due to: %s.&quot;,
 694                                g_strerror (error));
 695                     break;
 696                   }
 697 
 698                 bufsize *= 2;
 699               }
 700           }
 701         while (!pw);
 702 #  endif /* HAVE_GETPWUID_R */
 703 
 704         if (!pw)
 705           {
 706             pw = getpwuid (getuid ());
 707           }
 708         if (pw)
 709           {
 710             e.user_name = g_strdup (pw-&gt;pw_name);
 711 
 712 #ifndef __BIONIC__
 713             if (pw-&gt;pw_gecos &amp;&amp; *pw-&gt;pw_gecos != &#39;\0&#39;)
 714               {
 715                 gchar **gecos_fields;
 716                 gchar **name_parts;
 717 
 718                 /* split the gecos field and substitute &#39;&amp;&#39; */
 719                 gecos_fields = g_strsplit (pw-&gt;pw_gecos, &quot;,&quot;, 0);
 720                 name_parts = g_strsplit (gecos_fields[0], &quot;&amp;&quot;, 0);
 721                 pw-&gt;pw_name[0] = g_ascii_toupper (pw-&gt;pw_name[0]);
 722                 e.real_name = g_strjoinv (pw-&gt;pw_name, name_parts);
 723                 g_strfreev (gecos_fields);
 724                 g_strfreev (name_parts);
 725               }
 726 #endif
 727 
 728             if (!e.home_dir)
 729               e.home_dir = g_strdup (pw-&gt;pw_dir);
 730           }
 731         g_free (buffer);
 732       }
 733 
 734 #endif /* G_OS_UNIX */
 735 
 736 #ifdef G_OS_WIN32
 737       {
 738         guint len = UNLEN+1;
 739         wchar_t buffer[UNLEN+1];
 740 
 741         if (GetUserNameW (buffer, (LPDWORD) &amp;len))
 742           {
 743             e.user_name = g_utf16_to_utf8 (buffer, -1, NULL, NULL, NULL);
 744             e.real_name = g_strdup (e.user_name);
 745           }
 746       }
 747 #endif /* G_OS_WIN32 */
 748 
 749       if (!e.user_name)
 750         e.user_name = g_strdup (&quot;somebody&quot;);
 751       if (!e.real_name)
 752         e.real_name = g_strdup (&quot;Unknown&quot;);
 753 
 754       g_once_init_leave (&amp;entry, &amp;e);
 755     }
 756 
 757   return entry;
 758 }
 759 
 760 /**
 761  * g_get_user_name:
 762  *
 763  * Gets the user name of the current user. The encoding of the returned
 764  * string is system-defined. On UNIX, it might be the preferred file name
 765  * encoding, or something else, and there is no guarantee that it is even
 766  * consistent on a machine. On Windows, it is always UTF-8.
 767  *
 768  * Returns: (type filename): the user name of the current user.
 769  */
 770 const gchar *
 771 g_get_user_name (void)
 772 {
 773   UserDatabaseEntry *entry;
 774 
 775   entry = g_get_user_database_entry ();
 776 
 777   return entry-&gt;user_name;
 778 }
 779 
 780 /**
 781  * g_get_real_name:
 782  *
 783  * Gets the real name of the user. This usually comes from the user&#39;s
 784  * entry in the `passwd` file. The encoding of the returned string is
 785  * system-defined. (On Windows, it is, however, always UTF-8.) If the
 786  * real user name cannot be determined, the string &quot;Unknown&quot; is
 787  * returned.
 788  *
 789  * Returns: (type filename): the user&#39;s real name.
 790  */
 791 const gchar *
 792 g_get_real_name (void)
 793 {
 794   UserDatabaseEntry *entry;
 795 
 796   entry = g_get_user_database_entry ();
 797 
 798   return entry-&gt;real_name;
 799 }
 800 
<a name="23" id="anc23"></a>








































































 801 /**
 802  * g_get_home_dir:
 803  *
 804  * Gets the current user&#39;s home directory.
 805  *
 806  * As with most UNIX tools, this function will return the value of the
 807  * `HOME` environment variable if it is set to an existing absolute path
 808  * name, falling back to the `passwd` file in the case that it is unset.
 809  *
 810  * If the path given in `HOME` is non-absolute, does not exist, or is
 811  * not a directory, the result is undefined.
 812  *
 813  * Before version 2.36 this function would ignore the `HOME` environment
 814  * variable, taking the value from the `passwd` database instead. This was
 815  * changed to increase the compatibility of GLib with other programs (and
 816  * the XDG basedir specification) and to increase testability of programs
 817  * based on GLib (by making it easier to run them from test frameworks).
 818  *
 819  * If your program has a strong requirement for either the new or the
 820  * old behaviour (and if you don&#39;t wish to increase your GLib
 821  * dependency to ensure that the new behaviour is in effect) then you
 822  * should either directly check the `HOME` environment variable yourself
 823  * or unset it before calling any functions in GLib.
 824  *
 825  * Returns: (type filename): the current user&#39;s home directory
 826  */
 827 const gchar *
 828 g_get_home_dir (void)
 829 {
<a name="24" id="anc24"></a><span class="line-modified"> 830   static gchar *home_dir;</span>
<span class="line-removed"> 831 </span>
<span class="line-removed"> 832   if (g_once_init_enter (&amp;home_dir))</span>
<span class="line-removed"> 833     {</span>
<span class="line-removed"> 834       gchar *tmp;</span>
 835 
<a name="25" id="anc25"></a><span class="line-modified"> 836       /* We first check HOME and use it if it is set */</span>
<span class="line-removed"> 837       tmp = g_strdup (g_getenv (&quot;HOME&quot;));</span>
<span class="line-removed"> 838 </span>
<span class="line-removed"> 839 #ifdef G_OS_WIN32</span>
<span class="line-removed"> 840       /* Only believe HOME if it is an absolute path and exists.</span>
<span class="line-removed"> 841        *</span>
<span class="line-removed"> 842        * We only do this check on Windows for a couple of reasons.</span>
<span class="line-removed"> 843        * Historically, we only did it there because we used to ignore $HOME</span>
<span class="line-removed"> 844        * on UNIX.  There are concerns about enabling it now on UNIX because</span>
<span class="line-removed"> 845        * of things like autofs.  In short, if the user has a bogus value in</span>
<span class="line-removed"> 846        * $HOME then they get what they pay for...</span>
<span class="line-removed"> 847        */</span>
<span class="line-removed"> 848       if (tmp)</span>
<span class="line-removed"> 849         {</span>
<span class="line-removed"> 850           if (!(g_path_is_absolute (tmp) &amp;&amp;</span>
<span class="line-removed"> 851                 g_file_test (tmp, G_FILE_TEST_IS_DIR)))</span>
<span class="line-removed"> 852             {</span>
<span class="line-removed"> 853               g_free (tmp);</span>
<span class="line-removed"> 854               tmp = NULL;</span>
<span class="line-removed"> 855             }</span>
<span class="line-removed"> 856         }</span>
<span class="line-removed"> 857 </span>
<span class="line-removed"> 858       /* In case HOME is Unix-style (it happens), convert it to</span>
<span class="line-removed"> 859        * Windows style.</span>
<span class="line-removed"> 860        */</span>
<span class="line-removed"> 861       if (tmp)</span>
<span class="line-removed"> 862         {</span>
<span class="line-removed"> 863           gchar *p;</span>
<span class="line-removed"> 864           while ((p = strchr (tmp, &#39;/&#39;)) != NULL)</span>
<span class="line-removed"> 865             *p = &#39;\\&#39;;</span>
<span class="line-removed"> 866         }</span>
<span class="line-removed"> 867 </span>
<span class="line-removed"> 868       if (!tmp)</span>
<span class="line-removed"> 869         {</span>
<span class="line-removed"> 870           /* USERPROFILE is probably the closest equivalent to $HOME? */</span>
<span class="line-removed"> 871           if (g_getenv (&quot;USERPROFILE&quot;) != NULL)</span>
<span class="line-removed"> 872             tmp = g_strdup (g_getenv (&quot;USERPROFILE&quot;));</span>
<span class="line-removed"> 873         }</span>
<span class="line-removed"> 874 </span>
<span class="line-removed"> 875       if (!tmp)</span>
<span class="line-removed"> 876         tmp = get_special_folder (CSIDL_PROFILE);</span>
<span class="line-removed"> 877 </span>
<span class="line-removed"> 878       if (!tmp)</span>
<span class="line-removed"> 879         tmp = get_windows_directory_root ();</span>
<span class="line-removed"> 880 #endif /* G_OS_WIN32 */</span>
<span class="line-removed"> 881 </span>
<span class="line-removed"> 882       if (!tmp)</span>
<span class="line-removed"> 883         {</span>
<span class="line-removed"> 884           /* If we didn&#39;t get it from any of those methods, we will have</span>
<span class="line-removed"> 885            * to read the user database entry.</span>
<span class="line-removed"> 886            */</span>
<span class="line-removed"> 887           UserDatabaseEntry *entry;</span>
<span class="line-removed"> 888 </span>
<span class="line-removed"> 889           entry = g_get_user_database_entry ();</span>
<span class="line-removed"> 890 </span>
<span class="line-removed"> 891           /* Strictly speaking, we should copy this, but we know that</span>
<span class="line-removed"> 892            * neither will ever be freed, so don&#39;t bother...</span>
<span class="line-removed"> 893            */</span>
<span class="line-removed"> 894           tmp = entry-&gt;home_dir;</span>
<span class="line-removed"> 895         }</span>
 896 
<a name="26" id="anc26"></a><span class="line-modified"> 897       /* If we have been denied access to /etc/passwd (for example, by an</span>
<span class="line-modified"> 898        * overly-zealous LSM), make up a junk value. The return value at this</span>
<span class="line-modified"> 899        * point is explicitly documented as �?undefined’. Memory management is as</span>
<span class="line-removed"> 900        * immediately above: strictly this should be copied, but we know not</span>
<span class="line-removed"> 901        * copying it is OK. */</span>
<span class="line-removed"> 902       if (tmp == NULL)</span>
<span class="line-removed"> 903         {</span>
<span class="line-removed"> 904           g_warning (&quot;Could not find home directory: $HOME is not set, and &quot;</span>
<span class="line-removed"> 905                      &quot;user database could not be read.&quot;);</span>
<span class="line-removed"> 906           tmp = &quot;/&quot;;</span>
<span class="line-removed"> 907         }</span>
 908 
<a name="27" id="anc27"></a><span class="line-modified"> 909       g_once_init_leave (&amp;home_dir, tmp);</span>
<span class="line-removed"> 910     }</span>
 911 
 912   return home_dir;
 913 }
 914 
 915 /**
 916  * g_get_tmp_dir:
 917  *
 918  * Gets the directory to use for temporary files.
 919  *
 920  * On UNIX, this is taken from the `TMPDIR` environment variable.
 921  * If the variable is not set, `P_tmpdir` is
 922  * used, as defined by the system C library. Failing that, a
 923  * hard-coded default of &quot;/tmp&quot; is returned.
 924  *
 925  * On Windows, the `TEMP` environment variable is used, with the
 926  * root directory of the Windows installation (eg: &quot;C:\&quot;) used
 927  * as a default.
 928  *
 929  * The encoding of the returned string is system-defined. On Windows,
 930  * it is always UTF-8. The return value is never %NULL or the empty
 931  * string.
 932  *
 933  * Returns: (type filename): the directory to use for temporary files.
 934  */
 935 const gchar *
 936 g_get_tmp_dir (void)
 937 {
 938   static gchar *tmp_dir;
 939 
 940   if (g_once_init_enter (&amp;tmp_dir))
 941     {
 942       gchar *tmp;
 943 
 944 #ifdef G_OS_WIN32
 945       tmp = g_strdup (g_getenv (&quot;TEMP&quot;));
 946 
 947       if (tmp == NULL || *tmp == &#39;\0&#39;)
 948         {
 949           g_free (tmp);
 950           tmp = get_windows_directory_root ();
 951         }
 952 #else /* G_OS_WIN32 */
 953       tmp = g_strdup (g_getenv (&quot;TMPDIR&quot;));
 954 
 955 #ifdef P_tmpdir
 956       if (tmp == NULL || *tmp == &#39;\0&#39;)
 957         {
 958           gsize k;
 959           g_free (tmp);
 960           tmp = g_strdup (P_tmpdir);
 961           k = strlen (tmp);
 962           if (k &gt; 1 &amp;&amp; G_IS_DIR_SEPARATOR (tmp[k - 1]))
 963             tmp[k - 1] = &#39;\0&#39;;
 964         }
 965 #endif /* P_tmpdir */
 966 
 967       if (tmp == NULL || *tmp == &#39;\0&#39;)
 968         {
 969           g_free (tmp);
 970           tmp = g_strdup (&quot;/tmp&quot;);
 971         }
 972 #endif /* !G_OS_WIN32 */
 973 
 974       g_once_init_leave (&amp;tmp_dir, tmp);
 975     }
 976 
 977   return tmp_dir;
 978 }
 979 
 980 /**
 981  * g_get_host_name:
 982  *
 983  * Return a name for the machine.
 984  *
 985  * The returned name is not necessarily a fully-qualified domain name,
 986  * or even present in DNS or some other name service at all. It need
 987  * not even be unique on your local network or site, but usually it
 988  * is. Callers should not rely on the return value having any specific
 989  * properties like uniqueness for security purposes. Even if the name
 990  * of the machine is changed while an application is running, the
 991  * return value from this function does not change. The returned
 992  * string is owned by GLib and should not be modified or freed. If no
 993  * name can be determined, a default fixed string &quot;localhost&quot; is
 994  * returned.
 995  *
 996  * The encoding of the returned string is UTF-8.
 997  *
 998  * Returns: the host name of the machine.
 999  *
1000  * Since: 2.8
1001  */
1002 const gchar *
1003 g_get_host_name (void)
1004 {
1005   static gchar *hostname;
1006 
1007   if (g_once_init_enter (&amp;hostname))
1008     {
1009       gboolean failed;
1010       gchar *utmp;
1011 
1012 #ifndef G_OS_WIN32
<a name="28" id="anc28"></a><span class="line-modified">1013       gchar *tmp = g_malloc (sizeof (gchar) * 100);</span>
<span class="line-modified">1014       failed = (gethostname (tmp, sizeof (gchar) * 100) == -1);</span>





























1015       if (failed)
1016         g_clear_pointer (&amp;tmp, g_free);
1017       utmp = tmp;
1018 #else
1019       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
1020       DWORD size = sizeof (tmp) / sizeof (tmp[0]);
1021       failed = (!GetComputerNameW (tmp, &amp;size));
1022       if (!failed)
1023         utmp = g_utf16_to_utf8 (tmp, size, NULL, NULL, NULL);
1024       if (utmp == NULL)
1025         failed = TRUE;
1026 #endif
1027 
1028       g_once_init_leave (&amp;hostname, failed ? g_strdup (&quot;localhost&quot;) : utmp);
1029     }
1030 
1031   return hostname;
1032 }
1033 
1034 G_LOCK_DEFINE_STATIC (g_prgname);
1035 static gchar *g_prgname = NULL;
1036 
1037 /**
1038  * g_get_prgname:
1039  *
1040  * Gets the name of the program. This name should not be localized,
1041  * in contrast to g_get_application_name().
1042  *
1043  * If you are using #GApplication the program name is set in
1044  * g_application_run(). In case of GDK or GTK+ it is set in
1045  * gdk_init(), which is called by gtk_init() and the
1046  * #GtkApplication::startup handler. The program name is found by
1047  * taking the last component of @argv[0].
1048  *
<a name="29" id="anc29"></a><span class="line-modified">1049  * Returns: the name of the program. The returned string belongs</span>

1050  *     to GLib and must not be modified or freed.
1051  */
1052 const gchar*
1053 g_get_prgname (void)
1054 {
1055   gchar* retval;
1056 
1057   G_LOCK (g_prgname);
<a name="30" id="anc30"></a><span class="line-removed">1058 #ifdef G_OS_WIN32</span>
<span class="line-removed">1059   if (g_prgname == NULL)</span>
<span class="line-removed">1060     {</span>
<span class="line-removed">1061       static gboolean beenhere = FALSE;</span>
<span class="line-removed">1062 </span>
<span class="line-removed">1063       if (!beenhere)</span>
<span class="line-removed">1064     {</span>
<span class="line-removed">1065       gchar *utf8_buf = NULL;</span>
<span class="line-removed">1066       wchar_t buf[MAX_PATH+1];</span>
<span class="line-removed">1067 </span>
<span class="line-removed">1068       beenhere = TRUE;</span>
<span class="line-removed">1069       if (GetModuleFileNameW (GetModuleHandle (NULL),</span>
<span class="line-removed">1070                   buf, G_N_ELEMENTS (buf)) &gt; 0)</span>
<span class="line-removed">1071         utf8_buf = g_utf16_to_utf8 (buf, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1072 </span>
<span class="line-removed">1073       if (utf8_buf)</span>
<span class="line-removed">1074         {</span>
<span class="line-removed">1075           g_prgname = g_path_get_basename (utf8_buf);</span>
<span class="line-removed">1076           g_free (utf8_buf);</span>
<span class="line-removed">1077         }</span>
<span class="line-removed">1078     }</span>
<span class="line-removed">1079     }</span>
<span class="line-removed">1080 #endif</span>
1081   retval = g_prgname;
1082   G_UNLOCK (g_prgname);
1083 
1084   return retval;
1085 }
1086 
1087 /**
1088  * g_set_prgname:
1089  * @prgname: the name of the program.
1090  *
1091  * Sets the name of the program. This name should not be localized,
1092  * in contrast to g_set_application_name().
1093  *
1094  * If you are using #GApplication the program name is set in
1095  * g_application_run(). In case of GDK or GTK+ it is set in
1096  * gdk_init(), which is called by gtk_init() and the
1097  * #GtkApplication::startup handler. The program name is found by
1098  * taking the last component of @argv[0].
1099  *
1100  * Note that for thread-safety reasons this function can only be called once.
1101  */
1102 void
1103 g_set_prgname (const gchar *prgname)
1104 {
1105   G_LOCK (g_prgname);
1106   g_free (g_prgname);
1107   g_prgname = g_strdup (prgname);
1108   G_UNLOCK (g_prgname);
1109 }
1110 
1111 G_LOCK_DEFINE_STATIC (g_application_name);
1112 static gchar *g_application_name = NULL;
1113 
1114 /**
1115  * g_get_application_name:
1116  *
1117  * Gets a human-readable name for the application, as set by
1118  * g_set_application_name(). This name should be localized if
1119  * possible, and is intended for display to the user.  Contrast with
1120  * g_get_prgname(), which gets a non-localized name. If
1121  * g_set_application_name() has not been called, returns the result of
1122  * g_get_prgname() (which may be %NULL if g_set_prgname() has also not
1123  * been called).
1124  *
1125  * Returns: human-readable application name. may return %NULL
1126  *
1127  * Since: 2.2
1128  **/
1129 const gchar *
1130 g_get_application_name (void)
1131 {
1132   gchar* retval;
1133 
1134   G_LOCK (g_application_name);
1135   retval = g_application_name;
1136   G_UNLOCK (g_application_name);
1137 
1138   if (retval == NULL)
1139     return g_get_prgname ();
1140 
1141   return retval;
1142 }
1143 
1144 /**
1145  * g_set_application_name:
1146  * @application_name: localized name of the application
1147  *
1148  * Sets a human-readable name for the application. This name should be
1149  * localized if possible, and is intended for display to the user.
1150  * Contrast with g_set_prgname(), which sets a non-localized name.
1151  * g_set_prgname() will be called automatically by gtk_init(),
1152  * but g_set_application_name() will not.
1153  *
1154  * Note that for thread safety reasons, this function can only
1155  * be called once.
1156  *
1157  * The application name will be used in contexts such as error messages,
1158  * or when displaying an application&#39;s name in the task list.
1159  *
1160  * Since: 2.2
1161  **/
1162 void
1163 g_set_application_name (const gchar *application_name)
1164 {
1165   gboolean already_set = FALSE;
1166 
1167   G_LOCK (g_application_name);
1168   if (g_application_name)
1169     already_set = TRUE;
1170   else
1171     g_application_name = g_strdup (application_name);
1172   G_UNLOCK (g_application_name);
1173 
1174   if (already_set)
1175     g_warning (&quot;g_set_application_name() called multiple times&quot;);
1176 }
1177 
<a name="31" id="anc31"></a>
































































































































1178 /**
1179  * g_get_user_data_dir:
1180  *
1181  * Returns a base directory in which to access application data such
1182  * as icons that is customized for a particular user.
1183  *
1184  * On UNIX platforms this is determined using the mechanisms described
1185  * in the
1186  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1187  * In this case the directory retrieved will be `XDG_DATA_HOME`.
1188  *
1189  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
1190  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
1191  * opposed to roaming) application data is used instead. See the
1192  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1193  * Note that in this case on Windows it will be the same
1194  * as what g_get_user_config_dir() returns.
1195  *
1196  * Returns: (type filename): a string owned by GLib that must not be modified
1197  *               or freed.
1198  * Since: 2.6
1199  **/
1200 const gchar *
1201 g_get_user_data_dir (void)
1202 {
<a name="32" id="anc32"></a><span class="line-modified">1203   gchar *data_dir = NULL;</span>
1204 
1205   G_LOCK (g_utils_global);
1206 
<a name="33" id="anc33"></a><span class="line-modified">1207   if (!g_user_data_dir)</span>
<span class="line-modified">1208     {</span>
<span class="line-modified">1209       const gchar *data_dir_env = g_getenv (&quot;XDG_DATA_HOME&quot;);</span>
<span class="line-removed">1210 </span>
<span class="line-removed">1211       if (data_dir_env &amp;&amp; data_dir_env[0])</span>
<span class="line-removed">1212         data_dir = g_strdup (data_dir_env);</span>
<span class="line-removed">1213 #ifdef G_OS_WIN32</span>
<span class="line-removed">1214       else</span>
<span class="line-removed">1215       data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
<span class="line-removed">1216 #endif</span>
<span class="line-removed">1217       if (!data_dir || !data_dir[0])</span>
<span class="line-removed">1218     {</span>
<span class="line-removed">1219           const gchar *home_dir = g_get_home_dir ();</span>
<span class="line-removed">1220 </span>
<span class="line-removed">1221           if (home_dir)</span>
<span class="line-removed">1222             data_dir = g_build_filename (home_dir, &quot;.local&quot;, &quot;share&quot;, NULL);</span>
<span class="line-removed">1223       else</span>
<span class="line-removed">1224             data_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.local&quot;, &quot;share&quot;, NULL);</span>
<span class="line-removed">1225     }</span>
<span class="line-removed">1226 </span>
<span class="line-removed">1227       g_user_data_dir = data_dir;</span>
<span class="line-removed">1228     }</span>
<span class="line-removed">1229   else</span>
<span class="line-removed">1230     data_dir = g_user_data_dir;</span>
1231 
1232   G_UNLOCK (g_utils_global);
1233 
<a name="34" id="anc34"></a><span class="line-modified">1234   return data_dir;</span>
1235 }
1236 
<a name="35" id="anc35"></a><span class="line-modified">1237 static void</span>
<span class="line-modified">1238 g_init_user_config_dir (void)</span>
1239 {
1240   gchar *config_dir = NULL;
<a name="36" id="anc36"></a>
1241 
<a name="37" id="anc37"></a><span class="line-modified">1242   if (!g_user_config_dir)</span>
<span class="line-removed">1243     {</span>
<span class="line-removed">1244       const gchar *config_dir_env = g_getenv (&quot;XDG_CONFIG_HOME&quot;);</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246       if (config_dir_env &amp;&amp; config_dir_env[0])</span>
1247     config_dir = g_strdup (config_dir_env);
1248 #ifdef G_OS_WIN32
<a name="38" id="anc38"></a><span class="line-modified">1249       else</span>
<span class="line-modified">1250       config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
1251 #endif
<a name="39" id="anc39"></a><span class="line-modified">1252       if (!config_dir || !config_dir[0])</span>
1253     {
<a name="40" id="anc40"></a><span class="line-modified">1254           const gchar *home_dir = g_get_home_dir ();</span>
<span class="line-modified">1255 </span>
<span class="line-modified">1256           if (home_dir)</span>
<span class="line-removed">1257             config_dir = g_build_filename (home_dir, &quot;.config&quot;, NULL);</span>
<span class="line-removed">1258       else</span>
<span class="line-removed">1259             config_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.config&quot;, NULL);</span>
1260     }
1261 
<a name="41" id="anc41"></a><span class="line-modified">1262       g_user_config_dir = config_dir;</span>
<span class="line-removed">1263     }</span>
1264 }
1265 
1266 /**
1267  * g_get_user_config_dir:
1268  *
1269  * Returns a base directory in which to store user-specific application
1270  * configuration information such as user preferences and settings.
1271  *
1272  * On UNIX platforms this is determined using the mechanisms described
1273  * in the
1274  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1275  * In this case the directory retrieved will be `XDG_CONFIG_HOME`.
1276  *
1277  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
1278  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
1279  * to roaming) application data is used instead. See the
1280  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1281  * Note that in this case on Windows it will be  the same
1282  * as what g_get_user_data_dir() returns.
1283  *
1284  * Returns: (type filename): a string owned by GLib that must not be modified
1285  *               or freed.
1286  * Since: 2.6
1287  **/
1288 const gchar *
1289 g_get_user_config_dir (void)
1290 {
<a name="42" id="anc42"></a>

1291   G_LOCK (g_utils_global);
1292 
<a name="43" id="anc43"></a><span class="line-modified">1293   g_init_user_config_dir ();</span>


1294 
1295   G_UNLOCK (g_utils_global);
1296 
<a name="44" id="anc44"></a><span class="line-modified">1297   return g_user_config_dir;</span>






















1298 }
1299 
1300 /**
1301  * g_get_user_cache_dir:
1302  *
1303  * Returns a base directory in which to store non-essential, cached
1304  * data specific to particular user.
1305  *
1306  * On UNIX platforms this is determined using the mechanisms described
1307  * in the
1308  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1309  * In this case the directory retrieved will be `XDG_CACHE_HOME`.
1310  *
1311  * On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
1312  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
1313  * repository for temporary Internet files is used instead. A typical path is
1314  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
1315  * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
1316  *
1317  * Returns: (type filename): a string owned by GLib that must not be modified
1318  *               or freed.
1319  * Since: 2.6
1320  **/
1321 const gchar *
1322 g_get_user_cache_dir (void)
1323 {
<a name="45" id="anc45"></a><span class="line-modified">1324   gchar *cache_dir = NULL;</span>
1325 
1326   G_LOCK (g_utils_global);
1327 
<a name="46" id="anc46"></a><span class="line-modified">1328   if (!g_user_cache_dir)</span>
<span class="line-modified">1329     {</span>
<span class="line-modified">1330       const gchar *cache_dir_env = g_getenv (&quot;XDG_CACHE_HOME&quot;);</span>
1331 
<a name="47" id="anc47"></a><span class="line-modified">1332       if (cache_dir_env &amp;&amp; cache_dir_env[0])</span>
<span class="line-removed">1333         cache_dir = g_strdup (cache_dir_env);</span>
<span class="line-removed">1334 #ifdef G_OS_WIN32</span>
<span class="line-removed">1335       else</span>
<span class="line-removed">1336         cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);</span>
<span class="line-removed">1337 #endif</span>
<span class="line-removed">1338       if (!cache_dir || !cache_dir[0])</span>
<span class="line-removed">1339     {</span>
<span class="line-removed">1340           const gchar *home_dir = g_get_home_dir ();</span>
1341 
<a name="48" id="anc48"></a><span class="line-modified">1342           if (home_dir)</span>
<span class="line-modified">1343             cache_dir = g_build_filename (home_dir, &quot;.cache&quot;, NULL);</span>
<span class="line-modified">1344       else</span>
<span class="line-modified">1345             cache_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.cache&quot;, NULL);</span>
<span class="line-modified">1346     }</span>
<span class="line-modified">1347       g_user_cache_dir = cache_dir;</span>
<span class="line-modified">1348     }</span>




1349   else
<a name="49" id="anc49"></a><span class="line-modified">1350     cache_dir = g_user_cache_dir;</span>

1351 
<a name="50" id="anc50"></a><span class="line-modified">1352   G_UNLOCK (g_utils_global);</span>











1353 
<a name="51" id="anc51"></a><span class="line-modified">1354   return cache_dir;</span>
1355 }
1356 
1357 /**
1358  * g_get_user_runtime_dir:
1359  *
1360  * Returns a directory that is unique to the current user on the local
1361  * system.
1362  *
1363  * This is determined using the mechanisms described
1364  * in the
1365  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1366  * This is the directory
1367  * specified in the `XDG_RUNTIME_DIR` environment variable.
1368  * In the case that this variable is not set, we return the value of
1369  * g_get_user_cache_dir(), after verifying that it exists.
1370  *
1371  * Returns: (type filename): a string owned by GLib that must not be
1372  *     modified or freed.
1373  *
1374  * Since: 2.28
1375  **/
1376 const gchar *
1377 g_get_user_runtime_dir (void)
1378 {
<a name="52" id="anc52"></a><span class="line-modified">1379   static const gchar *runtime_dir;</span>
<span class="line-removed">1380 </span>
<span class="line-removed">1381   if (g_once_init_enter (&amp;runtime_dir))</span>
<span class="line-removed">1382     {</span>
<span class="line-removed">1383       const gchar *dir;</span>
<span class="line-removed">1384 </span>
<span class="line-removed">1385       dir = g_strdup (getenv (&quot;XDG_RUNTIME_DIR&quot;));</span>
1386 
<a name="53" id="anc53"></a><span class="line-modified">1387       if (dir == NULL)</span>
<span class="line-removed">1388         {</span>
<span class="line-removed">1389           /* No need to strdup this one since it is valid forever. */</span>
<span class="line-removed">1390           dir = g_get_user_cache_dir ();</span>
<span class="line-removed">1391 </span>
<span class="line-removed">1392           /* The user should be able to rely on the directory existing</span>
<span class="line-removed">1393            * when the function returns.  Probably it already does, but</span>
<span class="line-removed">1394            * let&#39;s make sure.  Just do mkdir() directly since it will be</span>
<span class="line-removed">1395            * no more expensive than a stat() in the case that the</span>
<span class="line-removed">1396            * directory already exists and is a lot easier.</span>
<span class="line-removed">1397            *</span>
<span class="line-removed">1398            * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME</span>
<span class="line-removed">1399            * exists this will work.  If the user changed $XDG_CACHE_HOME</span>
<span class="line-removed">1400            * then they can make sure that it exists...</span>
<span class="line-removed">1401    */</span>
<span class="line-removed">1402           (void) g_mkdir (dir, 0700);</span>
<span class="line-removed">1403         }</span>
1404 
<a name="54" id="anc54"></a><span class="line-modified">1405       g_assert (dir != NULL);</span>


1406 
<a name="55" id="anc55"></a><span class="line-modified">1407       g_once_init_leave (&amp;runtime_dir, dir);</span>
<span class="line-removed">1408 }</span>
1409 
<a name="56" id="anc56"></a><span class="line-modified">1410   return runtime_dir;</span>
1411 }
1412 
<a name="57" id="anc57"></a><span class="line-modified">1413 #ifdef HAVE_CARBON</span>
1414 
<a name="58" id="anc58"></a><span class="line-modified">1415 static gchar *</span>
<span class="line-modified">1416 find_folder (OSType type)</span>
<span class="line-removed">1417 {</span>
<span class="line-removed">1418   gchar *filename = NULL;</span>
<span class="line-removed">1419   FSRef  found;</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421   if (FSFindFolder (kUserDomain, type, kDontCreateFolder, &amp;found) == noErr)</span>
<span class="line-removed">1422     {</span>
<span class="line-removed">1423       CFURLRef url = CFURLCreateFromFSRef (kCFAllocatorSystemDefault, &amp;found);</span>
<span class="line-removed">1424 </span>
<span class="line-removed">1425       if (url)</span>
<span class="line-removed">1426     {</span>
<span class="line-removed">1427       CFStringRef path = CFURLCopyFileSystemPath (url, kCFURLPOSIXPathStyle);</span>
<span class="line-removed">1428 </span>
<span class="line-removed">1429       if (path)</span>
<span class="line-removed">1430         {</span>
<span class="line-removed">1431           filename = g_strdup (CFStringGetCStringPtr (path, kCFStringEncodingUTF8));</span>
<span class="line-removed">1432 </span>
<span class="line-removed">1433           if (! filename)</span>
<span class="line-removed">1434         {</span>
<span class="line-removed">1435           filename = g_new0 (gchar, CFStringGetLength (path) * 3 + 1);</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437           CFStringGetCString (path, filename,</span>
<span class="line-removed">1438                       CFStringGetLength (path) * 3 + 1,</span>
<span class="line-removed">1439                       kCFStringEncodingUTF8);</span>
<span class="line-removed">1440         }</span>
<span class="line-removed">1441 </span>
<span class="line-removed">1442           CFRelease (path);</span>
<span class="line-removed">1443         }</span>
<span class="line-removed">1444 </span>
<span class="line-removed">1445       CFRelease (url);</span>
<span class="line-removed">1446     }</span>
<span class="line-removed">1447     }</span>
<span class="line-removed">1448 </span>
<span class="line-removed">1449   return filename;</span>
<span class="line-removed">1450 }</span>
1451 
1452 static void
1453 load_user_special_dirs (void)
1454 {
<a name="59" id="anc59"></a><span class="line-modified">1455   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = find_folder (kDesktopFolderType);</span>
<span class="line-removed">1456   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = find_folder (kDocumentsFolderType);</span>
<span class="line-removed">1457   g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = find_folder (kDesktopFolderType); /* XXX correct ? */</span>
<span class="line-removed">1458   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = find_folder (kMusicDocumentsFolderType);</span>
<span class="line-removed">1459   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = find_folder (kPictureDocumentsFolderType);</span>
<span class="line-removed">1460   g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = NULL;</span>
<span class="line-removed">1461   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = NULL;</span>
<span class="line-removed">1462   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = find_folder (kMovieDocumentsFolderType);</span>
1463 }
1464 
1465 #elif defined(G_OS_WIN32)
1466 
1467 static void
1468 load_user_special_dirs (void)
1469 {
1470   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
<a name="60" id="anc60"></a><span class="line-modified">1471                             DWORD dwFlags,</span>
<span class="line-modified">1472                             HANDLE hToken,</span>
<span class="line-modified">1473                             PWSTR *ppszPath);</span>
1474   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
1475 
1476   static const GUID FOLDERID_Downloads =
1477     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
1478   static const GUID FOLDERID_Public =
1479     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
1480 
1481   wchar_t *wcp;
1482 
1483   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle (&quot;shell32.dll&quot;),
<a name="61" id="anc61"></a><span class="line-modified">1484                                     &quot;SHGetKnownFolderPath&quot;);</span>
1485 
1486   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1487   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
1488 
1489   if (p_SHGetKnownFolderPath == NULL)
1490     {
1491       g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1492     }
1493   else
1494     {
1495       wcp = NULL;
1496       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Downloads, 0, NULL, &amp;wcp);
1497       if (wcp)
1498         {
1499           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1500           if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
1501               g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1502           CoTaskMemFree (wcp);
1503         }
1504       else
1505           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1506     }
1507 
1508   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = get_special_folder (CSIDL_MYMUSIC);
1509   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = get_special_folder (CSIDL_MYPICTURES);
1510 
1511   if (p_SHGetKnownFolderPath == NULL)
1512     {
1513       /* XXX */
1514       g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1515     }
1516   else
1517     {
1518       wcp = NULL;
1519       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Public, 0, NULL, &amp;wcp);
1520       if (wcp)
1521         {
1522           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1523           if (g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] == NULL)
1524               g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1525           CoTaskMemFree (wcp);
1526         }
1527       else
1528           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1529     }
1530 
1531   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = get_special_folder (CSIDL_TEMPLATES);
1532   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = get_special_folder (CSIDL_MYVIDEO);
1533 }
1534 
1535 #else /* default is unix */
1536 
1537 /* adapted from xdg-user-dir-lookup.c
1538  *
1539  * Copyright (C) 2007 Red Hat Inc.
1540  *
1541  * Permission is hereby granted, free of charge, to any person
1542  * obtaining a copy of this software and associated documentation files
1543  * (the &quot;Software&quot;), to deal in the Software without restriction,
1544  * including without limitation the rights to use, copy, modify, merge,
1545  * publish, distribute, sublicense, and/or sell copies of the Software,
1546  * and to permit persons to whom the Software is furnished to do so,
1547  * subject to the following conditions:
1548  *
1549  * The above copyright notice and this permission notice shall be
1550  * included in all copies or substantial portions of the Software.
1551  *
1552  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
1553  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
1554  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
1555  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
1556  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
1557  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
1558  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
1559  * SOFTWARE.
1560  */
1561 static void
1562 load_user_special_dirs (void)
1563 {
<a name="62" id="anc62"></a>
1564   gchar *config_file;
1565   gchar *data;
1566   gchar **lines;
1567   gint n_lines, i;
1568 
<a name="63" id="anc63"></a><span class="line-modified">1569   g_init_user_config_dir ();</span>
<span class="line-modified">1570   config_file = g_build_filename (g_user_config_dir,</span>
1571                                   &quot;user-dirs.dirs&quot;,
1572                                   NULL);
<a name="64" id="anc64"></a>
1573 
1574   if (!g_file_get_contents (config_file, &amp;data, NULL, NULL))
1575     {
1576       g_free (config_file);
1577       return;
1578     }
1579 
1580   lines = g_strsplit (data, &quot;\n&quot;, -1);
1581   n_lines = g_strv_length (lines);
1582   g_free (data);
1583 
1584   for (i = 0; i &lt; n_lines; i++)
1585     {
1586       gchar *buffer = lines[i];
1587       gchar *d, *p;
1588       gint len;
1589       gboolean is_relative = FALSE;
1590       GUserDirectory directory;
1591 
1592       /* Remove newline at end */
1593       len = strlen (buffer);
1594       if (len &gt; 0 &amp;&amp; buffer[len - 1] == &#39;\n&#39;)
<a name="65" id="anc65"></a><span class="line-modified">1595     buffer[len - 1] = 0;</span>
1596 
1597       p = buffer;
1598       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<a name="66" id="anc66"></a><span class="line-modified">1599     p++;</span>
1600 
1601       if (strncmp (p, &quot;XDG_DESKTOP_DIR&quot;, strlen (&quot;XDG_DESKTOP_DIR&quot;)) == 0)
1602         {
1603           directory = G_USER_DIRECTORY_DESKTOP;
1604           p += strlen (&quot;XDG_DESKTOP_DIR&quot;);
1605         }
1606       else if (strncmp (p, &quot;XDG_DOCUMENTS_DIR&quot;, strlen (&quot;XDG_DOCUMENTS_DIR&quot;)) == 0)
1607         {
1608           directory = G_USER_DIRECTORY_DOCUMENTS;
1609           p += strlen (&quot;XDG_DOCUMENTS_DIR&quot;);
1610         }
1611       else if (strncmp (p, &quot;XDG_DOWNLOAD_DIR&quot;, strlen (&quot;XDG_DOWNLOAD_DIR&quot;)) == 0)
1612         {
1613           directory = G_USER_DIRECTORY_DOWNLOAD;
1614           p += strlen (&quot;XDG_DOWNLOAD_DIR&quot;);
1615         }
1616       else if (strncmp (p, &quot;XDG_MUSIC_DIR&quot;, strlen (&quot;XDG_MUSIC_DIR&quot;)) == 0)
1617         {
1618           directory = G_USER_DIRECTORY_MUSIC;
1619           p += strlen (&quot;XDG_MUSIC_DIR&quot;);
1620         }
1621       else if (strncmp (p, &quot;XDG_PICTURES_DIR&quot;, strlen (&quot;XDG_PICTURES_DIR&quot;)) == 0)
1622         {
1623           directory = G_USER_DIRECTORY_PICTURES;
1624           p += strlen (&quot;XDG_PICTURES_DIR&quot;);
1625         }
1626       else if (strncmp (p, &quot;XDG_PUBLICSHARE_DIR&quot;, strlen (&quot;XDG_PUBLICSHARE_DIR&quot;)) == 0)
1627         {
1628           directory = G_USER_DIRECTORY_PUBLIC_SHARE;
1629           p += strlen (&quot;XDG_PUBLICSHARE_DIR&quot;);
1630         }
1631       else if (strncmp (p, &quot;XDG_TEMPLATES_DIR&quot;, strlen (&quot;XDG_TEMPLATES_DIR&quot;)) == 0)
1632         {
1633           directory = G_USER_DIRECTORY_TEMPLATES;
1634           p += strlen (&quot;XDG_TEMPLATES_DIR&quot;);
1635         }
1636       else if (strncmp (p, &quot;XDG_VIDEOS_DIR&quot;, strlen (&quot;XDG_VIDEOS_DIR&quot;)) == 0)
1637         {
1638           directory = G_USER_DIRECTORY_VIDEOS;
1639           p += strlen (&quot;XDG_VIDEOS_DIR&quot;);
1640         }
1641       else
<a name="67" id="anc67"></a><span class="line-modified">1642     continue;</span>
1643 
1644       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<a name="68" id="anc68"></a><span class="line-modified">1645     p++;</span>
1646 
1647       if (*p != &#39;=&#39;)
<a name="69" id="anc69"></a><span class="line-modified">1648     continue;</span>
1649       p++;
1650 
1651       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<a name="70" id="anc70"></a><span class="line-modified">1652     p++;</span>
1653 
1654       if (*p != &#39;&quot;&#39;)
<a name="71" id="anc71"></a><span class="line-modified">1655     continue;</span>
1656       p++;
1657 
1658       if (strncmp (p, &quot;$HOME&quot;, 5) == 0)
<a name="72" id="anc72"></a><span class="line-modified">1659     {</span>
<span class="line-modified">1660       p += 5;</span>
<span class="line-modified">1661       is_relative = TRUE;</span>
<span class="line-modified">1662     }</span>
1663       else if (*p != &#39;/&#39;)
<a name="73" id="anc73"></a><span class="line-modified">1664     continue;</span>
1665 
1666       d = strrchr (p, &#39;&quot;&#39;);
1667       if (!d)
1668         continue;
1669       *d = 0;
1670 
1671       d = p;
1672 
1673       /* remove trailing slashes */
1674       len = strlen (d);
1675       if (d[len - 1] == &#39;/&#39;)
1676         d[len - 1] = 0;
1677 
1678       if (is_relative)
1679         {
<a name="74" id="anc74"></a><span class="line-modified">1680           g_user_special_dirs[directory] = g_build_filename (g_get_home_dir (), d, NULL);</span>


1681         }
1682       else
<a name="75" id="anc75"></a><span class="line-modified">1683     g_user_special_dirs[directory] = g_strdup (d);</span>
1684     }
1685 
1686   g_strfreev (lines);
1687   g_free (config_file);
1688 }
1689 
1690 #endif /* platform-specific load_user_special_dirs implementations */
1691 
1692 
1693 /**
1694  * g_reload_user_special_dirs_cache:
1695  *
1696  * Resets the cache used for g_get_user_special_dir(), so
1697  * that the latest on-disk version is used. Call this only
1698  * if you just changed the data on disk yourself.
1699  *
<a name="76" id="anc76"></a><span class="line-modified">1700  * Due to threadsafety issues this may cause leaking of strings</span>
1701  * that were previously returned from g_get_user_special_dir()
1702  * that can&#39;t be freed. We ensure to only leak the data for
1703  * the directories that actually changed value though.
1704  *
1705  * Since: 2.22
1706  */
1707 void
1708 g_reload_user_special_dirs_cache (void)
1709 {
1710   int i;
1711 
1712   G_LOCK (g_utils_global);
1713 
1714   if (g_user_special_dirs != NULL)
1715     {
1716       /* save a copy of the pointer, to check if some memory can be preserved */
1717       char **old_g_user_special_dirs = g_user_special_dirs;
1718       char *old_val;
1719 
1720       /* recreate and reload our cache */
1721       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1722       load_user_special_dirs ();
1723 
1724       /* only leak changed directories */
1725       for (i = 0; i &lt; G_USER_N_DIRECTORIES; i++)
1726         {
1727           old_val = old_g_user_special_dirs[i];
1728           if (g_user_special_dirs[i] == NULL)
1729             {
1730               g_user_special_dirs[i] = old_val;
1731             }
1732           else if (g_strcmp0 (old_val, g_user_special_dirs[i]) == 0)
1733             {
1734               /* don&#39;t leak */
1735               g_free (g_user_special_dirs[i]);
1736               g_user_special_dirs[i] = old_val;
1737             }
1738           else
1739             g_free (old_val);
1740         }
1741 
1742       /* free the old array */
1743       g_free (old_g_user_special_dirs);
1744     }
1745 
1746   G_UNLOCK (g_utils_global);
1747 }
1748 
1749 /**
1750  * g_get_user_special_dir:
1751  * @directory: the logical id of special directory
1752  *
1753  * Returns the full path of a special directory using its logical id.
1754  *
1755  * On UNIX this is done using the XDG special user directories.
1756  * For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
1757  * falls back to `$HOME/Desktop` when XDG special user directories have
1758  * not been set up.
1759  *
1760  * Depending on the platform, the user might be able to change the path
1761  * of the special directory without requiring the session to restart; GLib
1762  * will not reflect any change once the special directories are loaded.
1763  *
1764  * Returns: (type filename): the path to the specified special directory, or
1765  *   %NULL if the logical id was not found. The returned string is owned by
1766  *   GLib and should not be modified or freed.
1767  *
1768  * Since: 2.14
1769  */
1770 const gchar *
1771 g_get_user_special_dir (GUserDirectory directory)
1772 {
<a name="77" id="anc77"></a>

1773   g_return_val_if_fail (directory &gt;= G_USER_DIRECTORY_DESKTOP &amp;&amp;
1774                         directory &lt; G_USER_N_DIRECTORIES, NULL);
1775 
1776   G_LOCK (g_utils_global);
1777 
1778   if (G_UNLIKELY (g_user_special_dirs == NULL))
1779     {
1780       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1781 
1782       load_user_special_dirs ();
1783 
1784       /* Special-case desktop for historical compatibility */
1785       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
<a name="78" id="anc78"></a><span class="line-modified">1786         g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (g_get_home_dir (), &quot;Desktop&quot;, NULL);</span>




1787     }
<a name="79" id="anc79"></a>
1788 
1789   G_UNLOCK (g_utils_global);
1790 
<a name="80" id="anc80"></a><span class="line-modified">1791   return g_user_special_dirs[directory];</span>
1792 }
1793 
1794 #ifdef G_OS_WIN32
1795 
1796 #undef g_get_system_data_dirs
1797 
1798 static HMODULE
1799 get_module_for_address (gconstpointer address)
1800 {
1801   /* Holds the g_utils_global lock */
1802 
1803   static gboolean beenhere = FALSE;
1804   typedef BOOL (WINAPI *t_GetModuleHandleExA) (DWORD, LPCTSTR, HMODULE *);
1805   static t_GetModuleHandleExA p_GetModuleHandleExA = NULL;
1806   HMODULE hmodule = NULL;
1807 
1808   if (!address)
1809     return NULL;
1810 
1811   if (!beenhere)
1812     {
1813       p_GetModuleHandleExA =
<a name="81" id="anc81"></a><span class="line-modified">1814     (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle (&quot;kernel32.dll&quot;),</span>
<span class="line-modified">1815                            &quot;GetModuleHandleExA&quot;);</span>
1816       beenhere = TRUE;
1817     }
1818 
1819   if (p_GetModuleHandleExA == NULL ||
1820       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
<a name="82" id="anc82"></a><span class="line-modified">1821                 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,</span>
<span class="line-modified">1822                 address, &amp;hmodule))</span>
1823     {
1824       MEMORY_BASIC_INFORMATION mbi;
1825       VirtualQuery (address, &amp;mbi, sizeof (mbi));
1826       hmodule = (HMODULE) mbi.AllocationBase;
1827     }
1828 
1829   return hmodule;
1830 }
1831 
1832 static gchar *
1833 get_module_share_dir (gconstpointer address)
1834 {
1835   HMODULE hmodule;
1836   gchar *filename;
1837   gchar *retval;
1838 
1839   hmodule = get_module_for_address (address);
1840   if (hmodule == NULL)
1841     return NULL;
1842 
1843   filename = g_win32_get_package_installation_directory_of_module (hmodule);
1844   retval = g_build_filename (filename, &quot;share&quot;, NULL);
1845   g_free (filename);
1846 
1847   return retval;
1848 }
1849 
1850 static const gchar * const *
1851 g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
1852 {
1853   GArray *data_dirs;
1854   HMODULE hmodule;
1855   static GHashTable *per_module_data_dirs = NULL;
1856   gchar **retval;
1857   gchar *p;
1858   gchar *exe_root;
1859 
1860   hmodule = NULL;
1861   if (address_of_function)
1862     {
1863       G_LOCK (g_utils_global);
1864       hmodule = get_module_for_address (address_of_function);
1865       if (hmodule != NULL)
<a name="83" id="anc83"></a><span class="line-modified">1866     {</span>
<span class="line-modified">1867       if (per_module_data_dirs == NULL)</span>
<span class="line-modified">1868         per_module_data_dirs = g_hash_table_new (NULL, NULL);</span>
<span class="line-modified">1869       else</span>
<span class="line-modified">1870         {</span>
<span class="line-modified">1871           retval = g_hash_table_lookup (per_module_data_dirs, hmodule);</span>
1872 
<a name="84" id="anc84"></a><span class="line-modified">1873           if (retval != NULL)</span>
<span class="line-modified">1874         {</span>
<span class="line-modified">1875           G_UNLOCK (g_utils_global);</span>
<span class="line-modified">1876           return (const gchar * const *) retval;</span>
<span class="line-removed">1877         }</span>
<span class="line-removed">1878         }</span>
1879     }
<a name="85" id="anc85"></a>

1880     }
1881 
1882   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
1883 
1884   /* Documents and Settings\All Users\Application Data */
1885   p = get_special_folder (CSIDL_COMMON_APPDATA);
1886   if (p)
1887     g_array_append_val (data_dirs, p);
1888 
1889   /* Documents and Settings\All Users\Documents */
1890   p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1891   if (p)
1892     g_array_append_val (data_dirs, p);
1893 
1894   /* Using the above subfolders of Documents and Settings perhaps
1895    * makes sense from a Windows perspective.
1896    *
1897    * But looking at the actual use cases of this function in GTK+
1898    * and GNOME software, what we really want is the &quot;share&quot;
1899    * subdirectory of the installation directory for the package
1900    * our caller is a part of.
1901    *
1902    * The address_of_function parameter, if non-NULL, points to a
1903    * function in the calling module. Use that to determine that
1904    * module&#39;s installation folder, and use its &quot;share&quot; subfolder.
1905    *
1906    * Additionally, also use the &quot;share&quot; subfolder of the installation
1907    * locations of GLib and the .exe file being run.
1908    *
1909    * To guard against none of the above being what is really wanted,
1910    * callers of this function should have Win32-specific code to look
1911    * up their installation folder themselves, and handle a subfolder
1912    * &quot;share&quot; of it in the same way as the folders returned from this
1913    * function.
1914    */
1915 
1916   p = get_module_share_dir (address_of_function);
1917   if (p)
1918     g_array_append_val (data_dirs, p);
1919 
1920   if (glib_dll != NULL)
1921     {
1922       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
1923       p = g_build_filename (glib_root, &quot;share&quot;, NULL);
1924       if (p)
<a name="86" id="anc86"></a><span class="line-modified">1925     g_array_append_val (data_dirs, p);</span>
1926       g_free (glib_root);
1927     }
1928 
1929   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
1930   p = g_build_filename (exe_root, &quot;share&quot;, NULL);
1931   if (p)
1932     g_array_append_val (data_dirs, p);
1933   g_free (exe_root);
1934 
1935   retval = (gchar **) g_array_free (data_dirs, FALSE);
1936 
1937   if (address_of_function)
1938     {
1939       if (hmodule != NULL)
<a name="87" id="anc87"></a><span class="line-modified">1940     g_hash_table_insert (per_module_data_dirs, hmodule, retval);</span>
1941       G_UNLOCK (g_utils_global);
1942     }
1943 
1944   return (const gchar * const *) retval;
1945 }
1946 
1947 const gchar * const *
1948 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
1949 {
1950   gboolean should_call_g_get_system_data_dirs;
1951 
1952   should_call_g_get_system_data_dirs = TRUE;
<a name="88" id="anc88"></a><span class="line-modified">1953   /* These checks are the same as the ones that g_get_system_data_dirs() does.</span>
1954    * Please keep them in sync.
1955    */
1956   G_LOCK (g_utils_global);
1957 
1958   if (!g_system_data_dirs)
1959     {
1960       const gchar *data_dirs = g_getenv (&quot;XDG_DATA_DIRS&quot;);
1961 
1962       if (!data_dirs || !data_dirs[0])
1963         should_call_g_get_system_data_dirs = FALSE;
1964     }
1965 
1966   G_UNLOCK (g_utils_global);
1967 
1968   /* There is a subtle difference between g_win32_get_system_data_dirs_for_module (NULL),
1969    * which is what GLib code can normally call,
1970    * and g_win32_get_system_data_dirs_for_module (&amp;_g_win32_get_system_data_dirs),
1971    * which is what the inline function used by non-GLib code calls.
1972    * The former gets prefix relative to currently-running executable,
1973    * the latter - relative to the module that calls _g_win32_get_system_data_dirs()
1974    * (disguised as g_get_system_data_dirs()), which could be an executable or
1975    * a DLL that is located somewhere else.
1976    * This is why that inline function in gutils.h exists, and why we can&#39;t just
1977    * call g_get_system_data_dirs() from there - because we need to get the address
1978    * local to the non-GLib caller-module.
1979    */
1980 
1981   /*
1982    * g_get_system_data_dirs() will fall back to calling
1983    * g_win32_get_system_data_dirs_for_module_real(NULL) if XDG_DATA_DIRS is NULL
1984    * or an empty string. The checks above ensure that we do not call it in such
1985    * cases and use the address_of_function that we&#39;ve been given by the inline function.
1986    * The reason we&#39;re calling g_get_system_data_dirs /at all/ is to give
1987    * XDG_DATA_DIRS precedence (if it is set).
1988    */
1989   if (should_call_g_get_system_data_dirs)
1990     return g_get_system_data_dirs ();
1991 
1992   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
1993 }
1994 
1995 #endif
1996 
<a name="89" id="anc89"></a>























1997 /**
1998  * g_get_system_data_dirs:
1999  *
2000  * Returns an ordered list of base directories in which to access
2001  * system-wide application data.
2002  *
2003  * On UNIX platforms this is determined using the mechanisms described
2004  * in the
2005  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
2006  * In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
2007  *
2008  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
2009  * If `XDG_DATA_DIRS` is undefined,
2010  * the first elements in the list are the Application Data
2011  * and Documents folders for All Users. (These can be determined only
2012  * on Windows 2000 or later and are not present in the list on other
2013  * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
2014  * CSIDL_COMMON_DOCUMENTS.
2015  *
2016  * Then follows the &quot;share&quot; subfolder in the installation folder for
2017  * the package containing the DLL that calls this function, if it can
2018  * be determined.
2019  *
2020  * Finally the list contains the &quot;share&quot; subfolder in the installation
2021  * folder for GLib, and in the installation folder for the package the
2022  * application&#39;s .exe file belongs to.
2023  *
2024  * The installation folders above are determined by looking up the
2025  * folder where the module (DLL or EXE) in question is located. If the
2026  * folder&#39;s name is &quot;bin&quot;, its parent is used, otherwise the folder
2027  * itself.
2028  *
2029  * Note that on Windows the returned list can vary depending on where
2030  * this function is called.
2031  *
2032  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2033  *     a %NULL-terminated array of strings owned by GLib that must not be
2034  *     modified or freed.
2035  *
2036  * Since: 2.6
2037  **/
2038 const gchar * const *
2039 g_get_system_data_dirs (void)
2040 {
<a name="90" id="anc90"></a><span class="line-modified">2041   gchar **data_dir_vector;</span>
2042 
<a name="91" id="anc91"></a><span class="line-removed">2043   /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()</span>
<span class="line-removed">2044    * does. Please keep them in sync.</span>
<span class="line-removed">2045    */</span>
2046   G_LOCK (g_utils_global);
2047 
<a name="92" id="anc92"></a><span class="line-modified">2048   if (!g_system_data_dirs)</span>
<span class="line-modified">2049     {</span>
<span class="line-modified">2050       gchar *data_dirs = (gchar *) g_getenv (&quot;XDG_DATA_DIRS&quot;);</span>
2051 
<a name="93" id="anc93"></a><span class="line-modified">2052 #ifndef G_OS_WIN32</span>
<span class="line-removed">2053       if (!data_dirs || !data_dirs[0])</span>
<span class="line-removed">2054           data_dirs = &quot;/usr/local/share/:/usr/share/&quot;;</span>
2055 
<a name="94" id="anc94"></a><span class="line-modified">2056       data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-modified">2057 #else</span>
<span class="line-removed">2058       if (!data_dirs || !data_dirs[0])</span>
<span class="line-removed">2059         data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));</span>
<span class="line-removed">2060       else</span>
<span class="line-removed">2061         data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2062 #endif</span>
2063 
<a name="95" id="anc95"></a><span class="line-modified">2064       g_system_data_dirs = data_dir_vector;</span>








2065     }
2066   else
<a name="96" id="anc96"></a><span class="line-modified">2067     data_dir_vector = g_system_data_dirs;</span>

2068 
<a name="97" id="anc97"></a><span class="line-modified">2069   G_UNLOCK (g_utils_global);</span>




2070 
<a name="98" id="anc98"></a><span class="line-modified">2071   return (const gchar * const *) data_dir_vector;</span>









2072 }
2073 
2074 /**
2075  * g_get_system_config_dirs:
2076  *
2077  * Returns an ordered list of base directories in which to access
2078  * system-wide configuration information.
2079  *
2080  * On UNIX platforms this is determined using the mechanisms described
2081  * in the
2082  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
2083  * In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
2084  *
2085  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
2086  * If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
2087  * data for all users is used instead. A typical path is
2088  * `C:\Documents and Settings\All Users\Application Data`.
2089  * This folder is used for application data
2090  * that is not user specific. For example, an application can store
2091  * a spell-check dictionary, a database of clip art, or a log file in the
2092  * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
2093  * to anyone using the computer.
2094  *
2095  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2096  *     a %NULL-terminated array of strings owned by GLib that must not be
2097  *     modified or freed.
2098  *
2099  * Since: 2.6
2100  **/
2101 const gchar * const *
2102 g_get_system_config_dirs (void)
2103 {
<a name="99" id="anc99"></a><span class="line-modified">2104   gchar **conf_dir_vector;</span>
2105 
2106   G_LOCK (g_utils_global);
2107 
<a name="100" id="anc100"></a><span class="line-modified">2108   if (!g_system_config_dirs)</span>
<span class="line-modified">2109     {</span>
<span class="line-modified">2110       const gchar *conf_dirs = g_getenv (&quot;XDG_CONFIG_DIRS&quot;);</span>
<span class="line-removed">2111 #ifdef G_OS_WIN32</span>
<span class="line-removed">2112       if (conf_dirs)</span>
<span class="line-removed">2113     {</span>
<span class="line-removed">2114       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2115     }</span>
<span class="line-removed">2116       else</span>
<span class="line-removed">2117     {</span>
<span class="line-removed">2118       gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);</span>
<span class="line-removed">2119 </span>
<span class="line-removed">2120       if (special_conf_dirs)</span>
<span class="line-removed">2121         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2122       else</span>
<span class="line-removed">2123       /* Return empty list */</span>
<span class="line-removed">2124       conf_dir_vector = g_strsplit (&quot;&quot;, G_SEARCHPATH_SEPARATOR_S, 0);</span>
2125 
<a name="101" id="anc101"></a><span class="line-removed">2126       g_free (special_conf_dirs);</span>
<span class="line-removed">2127     }</span>
<span class="line-removed">2128 #else</span>
<span class="line-removed">2129       if (!conf_dirs || !conf_dirs[0])</span>
<span class="line-removed">2130           conf_dirs = &quot;/etc/xdg&quot;;</span>
<span class="line-removed">2131 </span>
<span class="line-removed">2132       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2133 #endif</span>
<span class="line-removed">2134 </span>
<span class="line-removed">2135       g_system_config_dirs = conf_dir_vector;</span>
<span class="line-removed">2136     }</span>
<span class="line-removed">2137   else</span>
<span class="line-removed">2138     conf_dir_vector = g_system_config_dirs;</span>
2139   G_UNLOCK (g_utils_global);
2140 
<a name="102" id="anc102"></a><span class="line-modified">2141   return (const gchar * const *) conf_dir_vector;</span>
2142 }
2143 
2144 /**
2145  * g_nullify_pointer:
2146  * @nullify_location: (not nullable): the memory address of the pointer.
2147  *
2148  * Set the pointer at the specified location to %NULL.
2149  **/
2150 void
2151 g_nullify_pointer (gpointer *nullify_location)
2152 {
2153   g_return_if_fail (nullify_location != NULL);
2154 
2155   *nullify_location = NULL;
2156 }
2157 
2158 #define KILOBYTE_FACTOR (G_GOFFSET_CONSTANT (1000))
2159 #define MEGABYTE_FACTOR (KILOBYTE_FACTOR * KILOBYTE_FACTOR)
2160 #define GIGABYTE_FACTOR (MEGABYTE_FACTOR * KILOBYTE_FACTOR)
2161 #define TERABYTE_FACTOR (GIGABYTE_FACTOR * KILOBYTE_FACTOR)
2162 #define PETABYTE_FACTOR (TERABYTE_FACTOR * KILOBYTE_FACTOR)
2163 #define EXABYTE_FACTOR  (PETABYTE_FACTOR * KILOBYTE_FACTOR)
2164 
2165 #define KIBIBYTE_FACTOR (G_GOFFSET_CONSTANT (1024))
2166 #define MEBIBYTE_FACTOR (KIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2167 #define GIBIBYTE_FACTOR (MEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2168 #define TEBIBYTE_FACTOR (GIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2169 #define PEBIBYTE_FACTOR (TEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2170 #define EXBIBYTE_FACTOR (PEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2171 
2172 /**
2173  * g_format_size:
2174  * @size: a size in bytes
2175  *
2176  * Formats a size (for example the size of a file) into a human readable
2177  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
2178  * and are displayed rounded to the nearest tenth. E.g. the file size
<a name="103" id="anc103"></a><span class="line-modified">2179  * 3292528 bytes will be converted into the string &quot;3.2 MB&quot;.</span>


2180  *
2181  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
2182  *
2183  * This string should be freed with g_free() when not needed any longer.
2184  *
2185  * See g_format_size_full() for more options about how the size might be
2186  * formatted.
2187  *
2188  * Returns: a newly-allocated formatted string containing a human readable
2189  *     file size
2190  *
2191  * Since: 2.30
2192  */
2193 gchar *
2194 g_format_size (guint64 size)
2195 {
2196   return g_format_size_full (size, G_FORMAT_SIZE_DEFAULT);
2197 }
2198 
2199 /**
2200  * GFormatSizeFlags:
2201  * @G_FORMAT_SIZE_DEFAULT: behave the same as g_format_size()
2202  * @G_FORMAT_SIZE_LONG_FORMAT: include the exact number of bytes as part
2203  *     of the returned string.  For example, &quot;45.6 kB (45,612 bytes)&quot;.
2204  * @G_FORMAT_SIZE_IEC_UNITS: use IEC (base 1024) units with &quot;KiB&quot;-style
2205  *     suffixes. IEC units should only be used for reporting things with
2206  *     a strong &quot;power of 2&quot; basis, like RAM sizes or RAID stripe sizes.
2207  *     Network and storage sizes should be reported in the normal SI units.
2208  * @G_FORMAT_SIZE_BITS: set the size as a quantity in bits, rather than
2209  *     bytes, and return units in bits. For example, rather than .
2210  *
2211  * Flags to modify the format of the string returned by g_format_size_full().
2212  */
2213 
2214 #ifdef GSTREAMER_LITE
2215 #ifndef G_OS_WIN32
2216 #pragma GCC diagnostic push
2217 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2218 #endif // G_OS_WIN32
2219 #else // GSTREAMER_LITE
2220 #pragma GCC diagnostic push
2221 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2222 #endif // GSTREAMER_LITE
2223 
2224 /**
2225  * g_format_size_full:
2226  * @size: a size in bytes
2227  * @flags: #GFormatSizeFlags to modify the output
2228  *
2229  * Formats a size.
2230  *
2231  * This function is similar to g_format_size() but allows for flags
2232  * that modify the output. See #GFormatSizeFlags.
2233  *
2234  * Returns: a newly-allocated formatted string containing a human
2235  *     readable file size
2236  *
2237  * Since: 2.30
2238  */
2239 gchar *
2240 g_format_size_full (guint64          size,
2241                     GFormatSizeFlags flags)
2242 {
2243   struct Format
2244   {
2245     guint64 factor;
<a name="104" id="anc104"></a><span class="line-modified">2246     char string[9];</span>
2247   };
2248 
2249   typedef enum
2250   {
2251     FORMAT_BYTES,
2252     FORMAT_BYTES_IEC,
2253     FORMAT_BITS,
2254     FORMAT_BITS_IEC
2255   } FormatIndex;
2256 
2257   const struct Format formats[4][6] = {
2258     {
<a name="105" id="anc105"></a>
2259       { KILOBYTE_FACTOR, N_(&quot;%.1f kB&quot;) },
<a name="106" id="anc106"></a>
2260       { MEGABYTE_FACTOR, N_(&quot;%.1f MB&quot;) },
<a name="107" id="anc107"></a>
2261       { GIGABYTE_FACTOR, N_(&quot;%.1f GB&quot;) },
<a name="108" id="anc108"></a>
2262       { TERABYTE_FACTOR, N_(&quot;%.1f TB&quot;) },
<a name="109" id="anc109"></a>
2263       { PETABYTE_FACTOR, N_(&quot;%.1f PB&quot;) },
<a name="110" id="anc110"></a>
2264       { EXABYTE_FACTOR,  N_(&quot;%.1f EB&quot;) }
2265     },
<a name="111" id="anc111"></a><span class="line-modified">2266         {</span>

2267       { KIBIBYTE_FACTOR, N_(&quot;%.1f KiB&quot;) },
<a name="112" id="anc112"></a>
2268       { MEBIBYTE_FACTOR, N_(&quot;%.1f MiB&quot;) },
<a name="113" id="anc113"></a>
2269       { GIBIBYTE_FACTOR, N_(&quot;%.1f GiB&quot;) },
<a name="114" id="anc114"></a>
2270       { TEBIBYTE_FACTOR, N_(&quot;%.1f TiB&quot;) },
<a name="115" id="anc115"></a>
2271       { PEBIBYTE_FACTOR, N_(&quot;%.1f PiB&quot;) },
<a name="116" id="anc116"></a>
2272       { EXBIBYTE_FACTOR, N_(&quot;%.1f EiB&quot;) }
2273     },
2274     {
<a name="117" id="anc117"></a>
2275       { KILOBYTE_FACTOR, N_(&quot;%.1f kb&quot;) },
<a name="118" id="anc118"></a>
2276       { MEGABYTE_FACTOR, N_(&quot;%.1f Mb&quot;) },
<a name="119" id="anc119"></a>
2277       { GIGABYTE_FACTOR, N_(&quot;%.1f Gb&quot;) },
<a name="120" id="anc120"></a>
2278       { TERABYTE_FACTOR, N_(&quot;%.1f Tb&quot;) },
<a name="121" id="anc121"></a>
2279       { PETABYTE_FACTOR, N_(&quot;%.1f Pb&quot;) },
<a name="122" id="anc122"></a>
2280       { EXABYTE_FACTOR,  N_(&quot;%.1f Eb&quot;) }
2281     },
2282     {
<a name="123" id="anc123"></a>
2283       { KIBIBYTE_FACTOR, N_(&quot;%.1f Kib&quot;) },
<a name="124" id="anc124"></a>
2284       { MEBIBYTE_FACTOR, N_(&quot;%.1f Mib&quot;) },
<a name="125" id="anc125"></a>
2285       { GIBIBYTE_FACTOR, N_(&quot;%.1f Gib&quot;) },
<a name="126" id="anc126"></a>
2286       { TEBIBYTE_FACTOR, N_(&quot;%.1f Tib&quot;) },
<a name="127" id="anc127"></a>
2287       { PEBIBYTE_FACTOR, N_(&quot;%.1f Pib&quot;) },
<a name="128" id="anc128"></a>
2288       { EXBIBYTE_FACTOR, N_(&quot;%.1f Eib&quot;) }
<a name="129" id="anc129"></a><span class="line-modified">2289         }</span>
2290   };
2291 
2292   GString *string;
2293   FormatIndex index;
2294 
2295   string = g_string_new (NULL);
2296 
2297   switch (flags &amp; ~G_FORMAT_SIZE_LONG_FORMAT)
2298     {
2299     case G_FORMAT_SIZE_DEFAULT:
2300       index = FORMAT_BYTES;
2301       break;
2302     case (G_FORMAT_SIZE_DEFAULT | G_FORMAT_SIZE_IEC_UNITS):
2303       index = FORMAT_BYTES_IEC;
2304       break;
2305     case G_FORMAT_SIZE_BITS:
2306       index = FORMAT_BITS;
2307       break;
2308     case (G_FORMAT_SIZE_BITS | G_FORMAT_SIZE_IEC_UNITS):
2309       index = FORMAT_BITS_IEC;
2310       break;
2311     default:
2312       g_assert_not_reached ();
2313     }
2314 
2315 
2316   if (size &lt; formats[index][0].factor)
2317     {
2318       const char * format;
2319 
2320       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2321         {
2322           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;, (guint) size);
<a name="130" id="anc130"></a><span class="line-modified">2323     }</span>
<span class="line-modified">2324   else</span>
<span class="line-modified">2325     {</span>
2326           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u bit&quot;, &quot;%u bits&quot;, (guint) size);
2327         }
2328 
2329       g_string_printf (string, format, (guint) size);
2330 
2331       flags &amp;= ~G_FORMAT_SIZE_LONG_FORMAT;
2332     }
2333   else
2334     {
2335       const gsize n = G_N_ELEMENTS (formats[index]);
2336       gsize i;
2337 
2338       /*
2339        * Point the last format (the highest unit) by default
2340        * and then then scan all formats, starting with the 2nd one
2341        * because the 1st is already managed by with the plural form
2342        */
2343       const struct Format * f = &amp;formats[index][n - 1];
2344 
2345       for (i = 1; i &lt; n; i++)
2346         {
2347           if (size &lt; formats[index][i].factor)
2348             {
2349               f = &amp;formats[index][i - 1];
2350               break;
2351             }
2352         }
2353 
2354       g_string_printf (string, _(f-&gt;string), (gdouble) size / (gdouble) f-&gt;factor);
2355     }
2356 
2357   if (flags &amp; G_FORMAT_SIZE_LONG_FORMAT)
2358     {
2359       /* First problem: we need to use the number of bytes to decide on
2360        * the plural form that is used for display, but the number of
2361        * bytes potentially exceeds the size of a guint (which is what
2362        * ngettext() takes).
2363        *
2364        * From a pragmatic standpoint, it seems that all known languages
2365        * base plural forms on one or both of the following:
2366        *
2367        *   - the lowest digits of the number
2368        *
2369        *   - if the number if greater than some small value
2370        *
2371        * Here&#39;s how we fake it:  Draw an arbitrary line at one thousand.
2372        * If the number is below that, then fine.  If it is above it,
2373        * then we take the modulus of the number by one thousand (in
2374        * order to keep the lowest digits) and add one thousand to that
2375        * (in order to ensure that 1001 is not treated the same as 1).
2376        */
2377       guint plural_form = size &lt; 1000 ? size : size % 1000 + 1000;
2378 
2379       /* Second problem: we need to translate the string &quot;%u byte/bit&quot; and
2380        * &quot;%u bytes/bits&quot; for pluralisation, but the correct number format to
2381        * use for a gsize is different depending on which architecture
2382        * we&#39;re on.
2383        *
2384        * Solution: format the number separately and use &quot;%s bytes/bits&quot; on
2385        * all platforms.
2386        */
2387       const gchar *translated_format;
2388       gchar *formatted_number;
2389 
2390       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2391         {
<a name="131" id="anc131"></a><span class="line-modified">2392       /* Translators: the %s in &quot;%s bytes&quot; will always be replaced by a number. */</span>
2393           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s byte&quot;, &quot;%s bytes&quot;, plural_form);
2394         }
2395       else
2396         {
2397           /* Translators: the %s in &quot;%s bits&quot; will always be replaced by a number. */
2398           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s bit&quot;, &quot;%s bits&quot;, plural_form);
2399         }
<a name="132" id="anc132"></a><span class="line-removed">2400       /* XXX: Windows doesn&#39;t support the &quot;&#39;&quot; format modifier, so we</span>
<span class="line-removed">2401        * must not use it there.  Instead, just display the number</span>
<span class="line-removed">2402        * without separation.  Bug #655336 is open until a solution is</span>
<span class="line-removed">2403        * found.</span>
<span class="line-removed">2404        */</span>
<span class="line-removed">2405 #ifndef G_OS_WIN32</span>
2406       formatted_number = g_strdup_printf (&quot;%&#39;&quot;G_GUINT64_FORMAT, size);
<a name="133" id="anc133"></a><span class="line-removed">2407 #else</span>
<span class="line-removed">2408       formatted_number = g_strdup_printf (&quot;%&quot;G_GUINT64_FORMAT, size);</span>
<span class="line-removed">2409 #endif</span>
2410 
2411       g_string_append (string, &quot; (&quot;);
2412       g_string_append_printf (string, translated_format, formatted_number);
2413       g_free (formatted_number);
2414       g_string_append (string, &quot;)&quot;);
2415     }
2416 
2417   return g_string_free (string, FALSE);
2418 }
2419 
2420 #ifdef GSTREAMER_LITE
2421 #ifndef G_OS_WIN32
2422 #pragma GCC diagnostic pop
2423 #endif // G_OS_WIN32
2424 #else // GSTREAMER_LITE
2425 #pragma GCC diagnostic pop
2426 #endif // GSTREAMER_LITE
2427 
2428 /**
2429  * g_format_size_for_display:
2430  * @size: a size in bytes
2431  *
2432  * Formats a size (for example the size of a file) into a human
2433  * readable string. Sizes are rounded to the nearest size prefix
2434  * (KB, MB, GB) and are displayed rounded to the nearest tenth.
2435  * E.g. the file size 3292528 bytes will be converted into the
2436  * string &quot;3.1 MB&quot;.
2437  *
2438  * The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
2439  *
2440  * This string should be freed with g_free() when not needed any longer.
2441  *
2442  * Returns: a newly-allocated formatted string containing a human
2443  *     readable file size
2444  *
2445  * Since: 2.16
2446  *
2447  * Deprecated:2.30: This function is broken due to its use of SI
2448  *     suffixes to denote IEC units. Use g_format_size() instead.
2449  */
2450 gchar *
2451 g_format_size_for_display (goffset size)
2452 {
2453   if (size &lt; (goffset) KIBIBYTE_FACTOR)
2454     return g_strdup_printf (g_dngettext(GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;,(guint) size), (guint) size);
2455   else
2456     {
2457       gdouble displayed_size;
2458 
2459       if (size &lt; (goffset) MEBIBYTE_FACTOR)
2460         {
2461           displayed_size = (gdouble) size / (gdouble) KIBIBYTE_FACTOR;
2462           /* Translators: this is from the deprecated function g_format_size_for_display() which uses &#39;KB&#39; to
2463            * mean 1024 bytes.  I am aware that &#39;KB&#39; is not correct, but it has been preserved for reasons of
2464            * compatibility.  Users will not see this string unless a program is using this deprecated function.
2465            * Please translate as literally as possible.
2466            */
2467           return g_strdup_printf (_(&quot;%.1f KB&quot;), displayed_size);
2468         }
2469       else if (size &lt; (goffset) GIBIBYTE_FACTOR)
2470         {
2471           displayed_size = (gdouble) size / (gdouble) MEBIBYTE_FACTOR;
2472           return g_strdup_printf (_(&quot;%.1f MB&quot;), displayed_size);
2473         }
2474       else if (size &lt; (goffset) TEBIBYTE_FACTOR)
2475         {
2476           displayed_size = (gdouble) size / (gdouble) GIBIBYTE_FACTOR;
2477           return g_strdup_printf (_(&quot;%.1f GB&quot;), displayed_size);
2478         }
2479       else if (size &lt; (goffset) PEBIBYTE_FACTOR)
2480         {
2481           displayed_size = (gdouble) size / (gdouble) TEBIBYTE_FACTOR;
2482           return g_strdup_printf (_(&quot;%.1f TB&quot;), displayed_size);
2483         }
2484       else if (size &lt; (goffset) EXBIBYTE_FACTOR)
2485         {
2486           displayed_size = (gdouble) size / (gdouble) PEBIBYTE_FACTOR;
2487           return g_strdup_printf (_(&quot;%.1f PB&quot;), displayed_size);
2488         }
2489       else
2490         {
2491           displayed_size = (gdouble) size / (gdouble) EXBIBYTE_FACTOR;
2492           return g_strdup_printf (_(&quot;%.1f EB&quot;), displayed_size);
2493         }
2494     }
2495 }
2496 
2497 #if defined (G_OS_WIN32) &amp;&amp; !defined (_WIN64)
2498 
2499 /* Binary compatibility versions. Not for newly compiled code. */
2500 
2501 _GLIB_EXTERN const gchar *g_get_user_name_utf8        (void);
2502 _GLIB_EXTERN const gchar *g_get_real_name_utf8        (void);
2503 _GLIB_EXTERN const gchar *g_get_home_dir_utf8         (void);
2504 _GLIB_EXTERN const gchar *g_get_tmp_dir_utf8          (void);
2505 _GLIB_EXTERN gchar       *g_find_program_in_path_utf8 (const gchar *program);
2506 
2507 gchar *
2508 g_find_program_in_path_utf8 (const gchar *program)
2509 {
2510   return g_find_program_in_path (program);
2511 }
2512 
2513 const gchar *g_get_user_name_utf8 (void) { return g_get_user_name (); }
2514 const gchar *g_get_real_name_utf8 (void) { return g_get_real_name (); }
2515 const gchar *g_get_home_dir_utf8 (void) { return g_get_home_dir (); }
2516 const gchar *g_get_tmp_dir_utf8 (void) { return g_get_tmp_dir (); }
2517 
2518 #endif
2519 
2520 /* Private API:
2521  *
2522  * Returns %TRUE if the current process was executed as setuid
2523  */
2524 gboolean
2525 g_check_setuid (void)
2526 {
<a name="134" id="anc134"></a><span class="line-modified">2527 #if defined(HAVE_SYS_AUXV_H)</span>
2528   unsigned long value;
2529   int errsv;
2530 
2531   errno = 0;
2532   value = getauxval (AT_SECURE);
2533   errsv = errno;
2534   if (errsv)
2535     g_error (&quot;getauxval () failed: %s&quot;, g_strerror (errsv));
2536   return value;
2537 #elif defined(HAVE_ISSETUGID) &amp;&amp; !defined(__BIONIC__)
2538   /* BSD: http://www.freebsd.org/cgi/man.cgi?query=issetugid&amp;sektion=2 */
2539 
2540   /* Android had it in older versions but the new 64 bit ABI does not
2541    * have it anymore, and some versions of the 32 bit ABI neither.
2542    * https://code.google.com/p/android-developer-preview/issues/detail?id=168
2543    */
2544   return issetugid ();
2545 #elif defined(G_OS_UNIX)
2546   uid_t ruid, euid, suid; /* Real, effective and saved user ID&#39;s */
2547   gid_t rgid, egid, sgid; /* Real, effective and saved group ID&#39;s */
2548 
2549   static gsize check_setuid_initialised;
2550   static gboolean is_setuid;
2551 
2552   if (g_once_init_enter (&amp;check_setuid_initialised))
2553     {
2554 #ifdef HAVE_GETRESUID
2555       /* These aren&#39;t in the header files, so we prototype them here.
2556        */
2557       int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
2558       int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
2559 
2560       if (getresuid (&amp;ruid, &amp;euid, &amp;suid) != 0 ||
2561           getresgid (&amp;rgid, &amp;egid, &amp;sgid) != 0)
2562 #endif /* HAVE_GETRESUID */
2563         {
2564           suid = ruid = getuid ();
2565           sgid = rgid = getgid ();
2566           euid = geteuid ();
2567           egid = getegid ();
2568         }
2569 
2570       is_setuid = (ruid != euid || ruid != suid ||
2571                    rgid != egid || rgid != sgid);
2572 
2573       g_once_init_leave (&amp;check_setuid_initialised, 1);
2574     }
2575   return is_setuid;
2576 #else
2577   return FALSE;
2578 #endif
2579 }
2580 
2581 #ifdef G_OS_WIN32
2582 /**
2583  * g_abort:
2584  *
2585  * A wrapper for the POSIX abort() function.
2586  *
2587  * On Windows it is a function that makes extra effort (including a call
2588  * to abort()) to ensure that a debugger-catchable exception is thrown
2589  * before the program terminates.
2590  *
2591  * See your C library manual for more details about abort().
2592  *
2593  * Since: 2.50
2594  */
2595 void
2596 g_abort (void)
2597 {
2598   /* One call to break the debugger */
2599   DebugBreak ();
2600   /* One call in case CRT does get saner about abort() behaviour */
2601   abort ();
2602   /* And one call to bind them all and terminate the program for sure */
2603   ExitProcess (127);
2604 }
2605 #endif
<a name="135" id="anc135"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="135" type="hidden" />
</body>
</html>